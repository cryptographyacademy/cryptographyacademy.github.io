---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/247';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'LatticeFold+: Faster, Simpler, Shorter Lattice-Based Folding for Succinct Proof Systems';
const AUTHORS_HTML = 'Dan Boneh, Binyi Chen';

const CONTENT = `    <p class="text-gray-300">Dan Boneh and Binyi Chen</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Folding is a technique for building efficient succinct proof systems. Many existing folding protocols rely on the discrete-log based Pedersen commitment scheme, and are therefore not post-quantum secure and require a large (256-bit) field. Recently, Boneh and Chen constructed LatticeFold, a folding protocol using lattice-based commitments which is plausibly post-quantum secure and can operate with small (64-bit) fields. For knowledge soundness, LatticeFold requires the prover to provide a range proof on all the input witnesses using bit-decomposition, and this slows down the prover. In this work we present LatticeFold+, a very different lattice-based folding protocol that improves on LatticeFold in every respect: the prover is significantly faster, the verification circuit is simpler, and the folding proofs are shorter. To do so we develop two novel lattice techniques. First, we develop a new purely algebraic range proof which is much more efficient than the one in LatticeFold, and may be of independent interest. We further shrink the proof using double commitments (commitments of commitments). Second, we show how to fold statements about double commitments using a new sumcheck-based transformation.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Additional related work  7</p>

    <p class="text-gray-300">2  Preliminaries  8 2.1 Cyclotomic rings  8 2.2 Multilinear extensions and sumchecks over rings  11 2.3 Module-based Ajtai commitments  13 2.4 Reduction of Knowledge  13</p>

    <p class="text-gray-300">3  Generalized Committed Linear Relations  14</p>

    <p class="text-gray-300">4  A Toolbox of Reduction of Knowledge  15 4.1 Linear commitments and double commitments  16 4.2 Monomial set check  17 4.3 Range check  21 4.4 Commitment transformation  25</p>

    <p class="text-gray-300">5  Folding Generalized Committed Linear Relations  36 5.1 Folding  37 5.2 Decomposition  40 5.3 Efficiency estimate  41</p>

    <p class="text-gray-300">6  Conclusion and future work  43</p>

    <p class="text-gray-300">A  Reducing R1CS to the general linear relation  51 B  Supporting Small Moduli  52</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In recent years succinct non-interactive arguments of knowledge (SNARKs) have found many real-world applications: scaling and bridging blockchains <em>[x21, x27]</em>, authenticating media <em>[x20, x1, x13]</em>, machine learning <em>[x10, x16]</em>, verifiable delay functions <em>[x3]</em>, and many others. To avoid the high memory requirements of some SNARK proof systems, provers in practice break the task of constructing a proof into small steps and prove each step separately. This approach is called incrementally verifiable computation (IVC) <em>[x22]</em> or proof carrying data (PCD) <em>[x9]</em>. It also provides additional opportunities for parallelizing the prover <em>[Ngu+24]</em>.</p>

    <p class="text-gray-300">The original IVC/PCD schemes were built using SNARK recursion <em>[x21, x2]</em>, where the SNARK verifier is embedded in every computation step being proved. A more efficient approach, called accumulation or folding, was introduced in Halo <em>[x2]</em> and further developed in <em>[x5, Bün+21, x4]</em> and Nova <em>[x12]</em>. Many elegant ideas have since further optimized and extended the folding paradigm <em>[x14, x6, x7, x11, x12, x17]</em>.</p>

    <p class="text-gray-300">Folding is best explained using the language of reductions of knowledge <em>[x15]</em> (see Section 2.4 for details). Let <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> be two instance-witness relations. A reduction of knowledge from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> is a protocol <span class="math">\\Pi</span> between a prover and verifier. The verifier takes as input an instance <span class="math">\\varkappa_{1}</span> for <span class="math">\\mathcal{R}_{1}</span>, interacts with the prover, and outputs an instance <span class="math">\\varkappa_{2}</span> for <span class="math">\\mathcal{R}_{2}</span> at the end of the protocol. The key requirement is that if the prover can present a witness <span class="math">\\varkappa_{2}</span> for <span class="math">\\varkappa_{2}</span>, then it is possible to extract from the prover a witnesses <span class="math">\\varkappa_{1}</span> for <span class="math">\\varkappa_{1}</span>. Hence, knowledge of a valid witness for <span class="math">\\varkappa_{2}</span> proves knowledge of a valid witness for <span class="math">\\varkappa_{1}</span>.</p>

    <p class="text-gray-300">A folding scheme is a reduction of knowledge from some product relation <span class="math">\\mathcal{R}_{\\texttt{acc}}\\times\\mathcal{R}_{\\texttt{comp}}</span> to <span class="math">\\mathcal{R}_{\\texttt{acc}}</span>. That is, the folding scheme can fold a pair of instances <span class="math">(\\varkappa_{\\texttt{acc}},\\varkappa_{\\texttt{comp}})</span> into a single new instance <span class="math">\\varkappa^{\\prime}_{\\texttt{acc}}</span> of <span class="math">\\mathcal{R}_{\\texttt{acc}}</span>. By repeatedly folding in this way, the prover can accumulate many steps of a computation expressed by <span class="math">\\mathcal{R}_{\\texttt{comp}}</span> into a single instance of the accumulation relation <span class="math">\\mathcal{R}_{\\texttt{acc}}</span>. Eventually, the prover proves knowledge of a witness for the final <span class="math">\\mathcal{R}_{\\texttt{acc}}</span> instance, and this proves knowledge of a valid witness for every step of the computation. Alternatively, folding can take place along a <span class="math">d</span>-ary tree, with <span class="math">d</span>-to-<span class="math">1</span> foldings, as in <em>[Ngu+24, x18]</em>. The benefit of folding schemes is that now the statement being proved at every step only needs to ensure that folding was performed correctly at the previous step, which is far simpler than a full SNARK verifier. Folding is also much faster for the prover because folding two witnesses into one is primarily a random linear combination of the two witnesses.</p>

    <p class="text-gray-300">Folding schemes typically extend the input relation to include a short commitment to the witness. The commitment scheme is linearly homomorphic, so that the verifier can compute the folded instance as a a random linear combination of these input commitments. Often one uses Pedersen as the homomorphic commitment scheme. This poses three dif</p>

    <p class="text-gray-300">ficulties: first, the resulting schemes are unsound in a post-quantum setting; second, the Pedersen hash requires the prover to do a compute-intensive multiscalar multiplication over a large (256-bit) field; and third, the domain and range of the Pedersen hash are different groups, requiring arithmetic over two distinct fields to verify a folding proof. This can be expensive because arithmetic circuits natively support only one field.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Lattice-based folding.</h5>

    <p class="text-gray-300">Boneh and Chen <em>[x1]</em> recently proposed a lattice-based folding scheme, called LatticeFold, where the Pedersen commitment is replaced with an Ajtai commitment over modules. This resolves all three difficulties mentioned in the previous paragraph. However, using Ajtai commitments in folding introduces significant challenges. The difficulty is that Ajtai commitments are binding only when the input vector is low norm. This is incompatible with the random linear combination approach used in folding. Repeatedly taking a random linear combination of witnesses quickly increases the norm of the accumulated witness to the point where Ajtai commitments are no longer binding. This breaks soundness of the resulting folding scheme.</p>

    <p class="text-gray-300">To address this issue, folding in LatticeFold is done in two primary steps. First, a norm reduction step decomposes each of the two input witnesses into <span class="math">d</span> lower norm witnesses. Second, the resulting <span class="math">2d</span> instances are folded into a single low norm instance. This ensures that after repeated folding, the norm of the accumulated witness remains small. However, this by itself is insufficient. One must also exhibit an extractor that extracts from the prover low norm witnesses for the two input instances. LatticeFold ensures that the extracted witnesses are low norm by using a novel sumcheck-based range proof. Forcing the prover to output this range proof for the two input witnesses is sufficient to ensure that the extracted witnesses are valid and low norm. However, the range proof in LatticeFold uses bit decomposition and is therefore expensive to construct because it requires the prover to commit to many decomposed witnesses.</p>

    <p class="text-gray-300">Experiments by Nethermind <em>[x12]</em> show that this additional complexity in folding using Ajtai commitments results in a LatticeFold prover that runs in approximately the same time as the Pedersen-based HyperNova folding prover <em>[x10]</em>. While LatticeFold has the benefit of post-quantum security, one would further expect that Ajtai-based folding would be faster than Pedersen-based folding.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Our results.</h5>

    <p class="text-gray-300">In this work we design a new lattice-based folding scheme called LatticeFold+ that greatly improves the performance of LatticeFold using a number of new lattice-ring techniques.</p>

    <p class="text-gray-300">As in HyperNova, LatticeFold+ represents the computation relation <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> as either a rank-1 constraint system (R1CS), using quadratic constraints, or a customizable constraint system (CCS) <em>[x16]</em> using higher degree constraints. The first step in LatticeFold+ is</p>

    <p class="text-gray-300">a sumcheck-based linearization process that is a reduction of knowledge from an R1CS or CCS relation <span class="math">\\mathcal{R}_{\\mathsf{comp}}</span> to a general linear relation we call <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span>, as explained in Section 3. This step is similar to HyperNova’s linearization step, but adapted to operate over rings as was done in LatticeFold <em>[x1]</em>. This linearization step shows that it suffices to design a folding scheme that folds <span class="math">L&gt;2</span> instances of the linear relation <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> into two instances.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An instance of <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> is a triple <span class="math">(\\mathsf{cm},\\mathbf{r},\\mathbf{v})</span> where <span class="math">\\mathsf{cm}</span> is an Ajtai commitment to a witness vector <span class="math">\\mathbf{f}\\in R_{q}^{n}</span>, where the <span class="math">\\ell_{\\infty}</span> norm of <span class="math">\\mathbf{f}</span> satisfies $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B<span class="math"> (as defined in the next section). The elements </span>\\mathbf{r}<span class="math"> and </span>\\mathbf{v}<span class="math"> will be explained in Section 3. Here the witness </span>\\mathbf{f}<span class="math"> is an </span>n<span class="math">-vector of elements in the ring </span>R_{q}:=\\mathbb{Z}_{q}[X]/\\langle X^{d}+1\\rangle<span class="math"> for some prime </span>q<span class="math"> and degree </span>d>1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The core of LatticeFold+ takes as input <span class="math">L&gt;2</span> instances of <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> and folds them into two instances of <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span>. It does so in two steps. In the first step, it folds the given <span class="math">L</span> instances of <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> into one instance of <span class="math">\\mathcal{R}_{\\mathsf{lin},B^{2}}</span>, namely an instance with a norm bound <span class="math">B^{2}</span> on the witness. The new range proof in this step is purely algebraic — it does not require commitments to bit-decomposed vectors. The increase in norm from <span class="math">B</span> to <span class="math">B^{2}</span> has to be corrected, and LatticeFold+ does this in the second step. It uses witness decomposition to reduce a linear instance with norm bound <span class="math">B^{2}</span> to two linear instances with norm bound <span class="math">B</span> by splitting every scalar in the witness into its high and low order bits. This second step is approximately the same as decomposition in LatticeFold. The key new insights are in the first folding step, which we discuss next.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">A new range proof.</h4>

    <p class="text-gray-300">To ensure that an extractor is able to extract <span class="math">L</span> low norm witnesses from a folding prover, the prover must provide a range proof that all the input witnesses are low norm. We develop a new range proof, presented in Section 4.3, that avoids bit decomposition and is far more efficient than the range proof in LatticeFold. This range proof method may be of independent interest. The key idea is as follows. Say we want to prove that a committed vector <span class="math">\\mathbf{f}=(f_{1},\\ldots,f_{n})\\in\\mathbb{Z}_{q}^{n}</span> satisfies <span class="math">f_{i}\\in(-d/2,d/2)</span> for all <span class="math">i\\in[n]</span>. The prover will commit to a vector of ring elements <span class="math">\\mathbf{m}=(m_{1},\\ldots,m_{n})\\in R_{q}^{n}</span> where each <span class="math">m_{i}\\in R_{q}</span> is the monomial <span class="math">m_{i}:=X^{f_{i}}</span>. We denote this commitment by <span class="math">\\mathsf{com}\\left(\\mathbf{m}\\right)</span> and note that computing the Ajtai commitment to <span class="math">\\mathbf{m}</span> is fast because it is a vector of monomials (see Remark 4.3). Next we show in Lemma 2.2 that if <span class="math">m_{i}</span> is a monomial and <span class="math">m_{i}</span> and <span class="math">f_{i}</span> satisfy a simple algebraic relation then <span class="math">f_{i}\\in(-d/2,d/2)</span>. Hence, our range proof needs to (i) prove that <span class="math">\\mathsf{com}\\left(\\mathbf{m}\\right)</span> is a commitment to a vector of monomials, which we do in Section 4.2, and (ii) prove that <span class="math">\\mathbf{m}</span> and <span class="math">\\mathbf{f}</span> satisfy a certain algebraic relation, which we do in Section 4.3. Both steps are presented as reductions of knowledge that reduce these checks to checking a simple evaluation relation. The resulting range proof requires no commitments to bit-decomposed vectors, and is significantly faster than the LatticeFold range proof.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Double commitments.</h4>

    <p class="text-gray-300">When applying this range proof to a vector of ring elements <span class="math">\\mathbf{f}\\in R_{q}^{n}</span>, we could repeat the range proof above <span class="math">d</span> times: once for the vector of all constant</p>

    <p class="text-gray-300">terms in <span class="math">\\mathbf{f}</span>, once for the vector of all linear terms in <span class="math">\\mathbf{f}</span>, and so on. This would require the prover to commit to <span class="math">d</span> vectors <span class="math">\\mathbf{m}_{0},\\ldots,\\mathbf{m}_{d-1}\\in R_{q}^{n}</span> which would result in a large transcript of <span class="math">d</span> commitments <span class="math">\\mathbf{c}:=(\\mathsf{com}\\,(\\mathbf{m}_{0})\\,,\\ldots,\\mathsf{com}\\,(\\mathbf{m}_{d-1}))\\in R_{q}^{\\kappa\\times d}</span> that must be sent to the verifier. Instead, we introduce in Section 4.1 the concept of a <em>double commitment</em>, where the prover sends to the verifier a commitment to the vector of commitments <span class="math">\\mathbf{c}</span>. This vector <span class="math">\\mathbf{c}</span> is not low norm, so we must first decompose it to reduce its norm and then commit to the decomposition using an Ajtai commitment. We use <span class="math">\\mathsf{dcom}\\,(\\mathbf{M})</span> to denote this double commitment to the matrix <span class="math">\\mathbf{M}:=[\\mathbf{m}_{0},\\ldots,\\mathbf{m}_{d-1}]\\in R_{q}^{n\\times d}</span>. Note that <span class="math">\\mathsf{dcom}\\,(\\mathbf{M})\\in R_{q}^{\\kappa}</span> is short as required. These double commitments are crucial for making our folding proofs shorter and simpler to verify compared to LatticeFold. In Section 4.3 we present a range proof that uses double commitments to prove that a vector <span class="math">\\mathbf{f}\\in R_{q}^{n}</span> has low <span class="math">\\ell_{\\infty}</span> norm.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Commitment transformation.</h4>

    <p class="text-gray-300">Double commitments are not linearly homomorphic, and as a result statements that use double commitments are hard to fold using random linear combinations. In Section 4.4 we develop a technique that transforms such statements to ones involving only <em>linear</em> commitments to smaller witnesses. We use sumchecks to ensure consistency between the double commitment of a witness <span class="math">\\mathbf{M}</span> and a linear commitment to a transformed version of <span class="math">\\mathbf{M}</span>. Again, this technique may be of independent interest.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Supporting small field arithmetic.</h4>

    <p class="text-gray-300">Following Neo’s approach <em>[x23]</em>, LatticeFold+ naturally supports small prime moduli, which we reinterpret using the tensor-of-rings framework in Appendix B. The folding challenge set is of size <span class="math">q^{e}</span> if <span class="math">R_{q}\\cong\\mathbb{F}_{q^{e}}^{d/e}</span>, and the sumchecks are running over an extension field <span class="math">\\mathbb{F}_{q^{t}}</span>. We can achieve the desired security by setting <span class="math">e</span> and <span class="math">t</span> appropriately. For example, if <span class="math">q</span> is a 64-bit prime, to achieve 128-bit security, all the sumchecks will be over the extension field <span class="math">\\mathbb{F}_{q^{2}}</span>. If <span class="math">d\\gg 2</span>, a sumcheck over <span class="math">\\mathbb{F}_{q^{2}}</span> for a size-<span class="math">n</span> statement is more efficient than computing a module-based Ajtai commitment to a vector of size <span class="math">n</span> over <span class="math">R_{q}</span>. Hence, the prover cost for sumcheck is insignificant. We refer to the “Challenge sets” paragraph in Section 4 and Appendix B for a detailed discussion.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Evaluation.</h4>

    <p class="text-gray-300">LatticeFold+ improves over LatticeFold in every respect: the folding prover is faster, the folding verifier is simpler, and the folding proof is shorter. We give a detailed evaluation analysis in Section 5.3. Here we present a brief summary when folding <span class="math">L</span> witnesses each of dimension <span class="math">n</span> and norm less than <span class="math">B</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Prover complexity: In LatticeFold, the prover’s complexity is dominated by a degree-<span class="math">4</span> sumcheck over <span class="math">R_{q}</span> of size <span class="math">n</span> and the computation of <span class="math">L\\log_{2}(B)</span> commitments to bit-decomposed vectors. LatticeFold+ eliminates all these commitments and is consequently <span class="math">\\Omega(\\log(B))</span>-times faster. Concretely, going by Nethermind’s LatticeFold benchmark <em>[x24]</em>, we estimate that the LatticeFold+ prover is five times faster than the LatticeFold prover.</li>

      <li>Verifier circuit complexity: The verifier circuit size is dominated by hashing needed for</li>

    </ul>

    <p class="text-gray-300">the Fiat-Shamir transform. In LatticeFold, all the <span class="math">L\\log_{2}(B)</span> decomposed commitments must be hashed. LatticeFold+ eliminates all these commitments thereby shrinking the size of the verification circuit.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof size: The LatticeFold proof size is <span class="math">O_{\\lambda}(\\kappa d\\log B+d\\log n)</span> bits. In LatticeFold+ the proof size is only <span class="math">O_{\\lambda}(\\kappa d+\\log n)</span> bits. Since a folding circuit needs to compute a Fiat-Shamir hash of its input, this shorter proof leads to a simpler circuit when compared to LatticeFold. We also emphasize that, in folding-based IVC schemes, folding proofs serve as recursive witnesses and are not part of the final output proof.</li>

    </ul>

    <p class="text-gray-300">Finally, since the prover running time in LatticeFold is comparable to HyperNova <em>[x20]</em>, we expect the prover time in LatticeFold+ to be significantly faster than HyperNova. Hence, LatticeFold+ provides both a fast prover and plausible post-quantum security.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.1 Additional related work</h3>

    <p class="text-gray-300">Several post-quantum monolithic SNARKs (i.e., not using folding) are built from hash-based Merkle commitments: Stark <em>[x1]</em>, Ligero <em>[x1]</em>, Aurora <em>[x2]</em>, Brakedown <em>[x11]</em>, Basefold <em>[x26]</em>, Blaze <em>[x3]</em>, and Fractal <em>[x10]</em>. Their proof sizes scale sublinearly with the witness size. In practice they require a significant amount of memory when proving a large statement. Several elegant post-quantum lattice-based proof systems also offer sublinear proof size <em>[x3, x4, x5, x1, x2]</em> however the resulting proofs are larger than the hash-based schemes. One exception is LaBRADOR <em>[x5]</em> that produces relatively short proofs, but has a linear time verifier. We note that LaBRADOR also uses commitments to commitments to shrink the proof size. A polynomial commitment scheme derived from LaBRADOR, called Greyhound <em>[x21]</em>, has a square root time verifier. Other lattice-based proof systems, such as <em>[x12, x14]</em>, perform well for small statements, but their proof size is linear in the size of the witness. Cini et al. <em>[x10]</em> recently presented a lattice-based polynomial commitment scheme (PCS) from Bulletproof/FRI-like techniques <em>[x1, x2]</em>. Their approach achieves better control over witness norm/slack blowup than previous works. However, their scheme incurs norm blowup/slack at each step, limiting it to supporting only a logarithmic number of folding steps.</p>

    <p class="text-gray-300">Following LatticeFold <em>[x2]</em>, which uses module-based Ajtai commitments and the <span class="math">\\ell_{\\infty}</span>-norm, Fenzi et al. proposed Lova <em>[x13]</em> which operates similarly, but using integer-based Ajtai commitments and the <span class="math">\\ell_{2}</span>-norm. Lova <em>[x13]</em> relies on the integer-based SIS assumption, but has worse concrete efficiency. Very recently, Klooß et al. <em>[x15]</em> suggest another approach to <span class="math">\\ell_{2}</span>-norm range proofs that can apply to LatticeFold. Compared to LatticeFold+, their approach requires the use of subtractive sets which are only of polynomial size. To boost soundness, they rely on parallel repetition of folding challenges, which impacts efficiency.</p>

    <p class="text-gray-300">Concurrent to LatticeFold+, Neo <em>[x21]</em> addresses an orthogonal problem and suggests</p>

    <p class="text-gray-300">a new approach for embedding small field elements into the cyclotomic polynomial ring used in LatticeFold. This technique is naturally compatible with LatticeFold+.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300"><strong>Notation.</strong> <span class="math">\\lambda \\in \\mathbb{N}</span> is the security parameter. For <span class="math">l, r \\in \\mathbb{Z}</span>, <span class="math">l &amp;lt; r</span>, we denote by <span class="math">(l, r)</span> the set <span class="math">\\{l + 1, l + 2, \\ldots, r - 1\\}</span> and <span class="math">[l, r)</span> the set <span class="math">\\{l, l + 1, \\ldots, r - 1\\}</span>, and we define <span class="math">[n] := [0, n)</span>. For a set <span class="math">S</span>, we denote by <span class="math">P(S)</span> the power set of <span class="math">S</span> that consists of all the subsets of <span class="math">S</span>. If <span class="math">S</span> supports element subtraction, we denote by <span class="math">S - S</span> the set of differences between any two distinct elements in <span class="math">S</span>. A function <span class="math">f(\\lambda)</span> is <span class="math">\\mathsf{poly}(\\lambda)</span> if there exists a <span class="math">c \\in \\mathbb{N}</span> such that <span class="math">f(\\lambda) = O(\\lambda^c)</span>. If <span class="math">f(\\lambda) = o(\\lambda^{-c})</span> for all <span class="math">c \\in \\mathbb{N}</span>, we say <span class="math">f(\\lambda)</span> is in <span class="math">\\mathsf{negl}(\\lambda)</span> and is <strong>negligible</strong>. A probability that is <span class="math">1 - \\mathsf{negl}(\\lambda)</span> is <strong>overwhelming</strong>.</p>

    <p class="text-gray-300">By default, a vector is a column vector and a ring is always commutative. For a vector <span class="math">\\mathbf{f}</span> of length <span class="math">n</span>, we use <span class="math">\\mathbf{f}_i</span> or <span class="math">\\mathbf{f}[i]</span> (<span class="math">0 \\leq i &amp;lt; n</span>) to denote its <span class="math">i</span>th element. For two vectors <span class="math">\\mathbf{f}, \\mathbf{g}</span> of the same length we let <span class="math">\\langle \\mathbf{f}, \\mathbf{g} \\rangle</span> denote their inner product.</p>

    <p class="text-gray-300">Let <span class="math">\\bar{R}</span> be an arbitrary ring. Given column vectors <span class="math">\\mathbf{u}_1, \\ldots, \\mathbf{u}_k \\in \\bar{R}^n</span>, we use <span class="math">[\\mathbf{u}_1, \\ldots, \\mathbf{u}_k] \\in \\bar{R}^{n \\times k}</span> to denote horizontal concatenation and <span class="math">(\\mathbf{u}_1, \\ldots, \\mathbf{u}_k) \\in \\bar{R}^{nk}</span> to denote vertical concatenation. Concatenations of row vectors are similarly defined. For a matrix <span class="math">\\mathbf{M} \\in \\bar{R}^{n \\times m}</span>, <span class="math">\\{\\mathbf{M}_{i,<em>} \\in \\bar{R}^m\\}_{i \\in [n]}</span> and <span class="math">\\{\\mathbf{M}_{</em>,j} \\in \\bar{R}^n\\}_{j \\in [m]}</span> denote the rows and columns of <span class="math">\\mathbf{M}</span>, respectively. We denote by <span class="math">\\mathsf{flat}(\\mathbf{M}) := (\\mathbf{M}_{0,<em>}, \\ldots, \\mathbf{M}_{n-1,</em>}) \\in \\bar{R}^{nm}</span> the vertical concatenation of its rows. <span class="math">\\bar{R}[X_1, \\ldots, X_k]</span> denotes the set of <span class="math">k</span>-variate polynomials over <span class="math">\\bar{R}</span>, and we use <span class="math">\\bar{R}^{\\leq d}[X_1, \\ldots, X_k]</span> to denote the set of polynomials with the degree of each variable at most <span class="math">d</span>.</p>

    <p class="text-gray-300">An <strong>indexed relation</strong> is a set of triples <span class="math">(\\mathbb{I}, \\mathbb{z}, \\mathbb{w})</span> where the index <span class="math">\\mathbb{I}</span> is fixed at the setup phase, <span class="math">\\mathbb{z}</span> is the online instance and <span class="math">\\mathbb{w}</span> is the witness. In what follows, we omit the index <span class="math">\\mathbb{I}</span> when it is clear in the context.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.1 Cyclotomic rings</h2>

    <p class="text-gray-300">Let <span class="math">d \\in \\mathbb{N}</span> be a power of two. We denote by <span class="math">R := \\mathbb{Z}[X] / \\langle X^d + 1 \\rangle</span> the power-of-two cyclotomic ring of dimension <span class="math">d</span>. Let <span class="math">q &amp;gt; 2</span> be a prime and denote by <span class="math">R_q := R / qR = \\mathbb{Z}_q[X] / \\langle X^d + 1 \\rangle</span> where we represent <span class="math">\\mathbb{Z}_q := \\{-\\lfloor q/2 \\rfloor, \\ldots, \\lfloor q/2 \\rfloor\\}</span>. If <span class="math">q \\equiv 1 + 2e \\pmod{4e}</span> for some <span class="math">e \\mid d</span>, it is well-known that <span class="math">R_q \\cong \\mathbb{F}_{q^{d/e}}^e</span> via the Number Theoretic Transform (NTT). For <span class="math">f = \\sum_{i \\in [d]} f_i X^i \\in R_q</span>, we use <span class="math">\\mathsf{cf}(f) := (f_0, \\ldots, f_{d-1}) \\in \\mathbb{Z}_q^d</span> to denote the coefficient vector of <span class="math">f</span>, and <span class="math">\\mathsf{ct}(f) := f_0</span> is the constant term of <span class="math">f</span>. For a vector <span class="math">\\mathbf{f} \\in R_q^n</span>, we denote by <span class="math">\\mathsf{cf}(\\mathbf{f}) := (\\mathsf{cf}(\\mathbf{f}_0)^\\top, \\ldots, \\mathsf{cf}(\\mathbf{f}_{n-1})^\\top) \\in \\mathbb{Z}_q^{n \\times d}</span> the concatenation of the transposed coefficient vectors, and <span class="math">\\mathsf{ct}(\\mathbf{f}) = (\\mathsf{ct}(\\mathbf{f}_0), \\ldots, \\mathsf{ct}(\\mathbf{f}_{n-1})) \\in \\mathbb{Z}_q^n</span> is the first column of <span class="math">\\mathsf{cf}(\\mathbf{f})</span>.</p>

    <p class="text-gray-300"><strong>Monomial sets.</strong> Define the <span class="math">\\mathbb{Z}_q[X]</span>-monomial set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{M}&#x27; := \\{0, 1, X, X^2, X^3, \\ldots\\} \\subseteq \\mathbb{Z}_q[X]. \\tag{1}</span></div>

    <p class="text-gray-300">We will need the following lemma.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.1.</h6>

    <p class="text-gray-300">Let <span class="math">q&gt;2</span> be a prime. For every <span class="math">a\\in\\mathbb{Z}_{q}[X]</span> we have that <span class="math">a(X^{2})=a(X)^{2}</span> if and only if <span class="math">a\\in\\mathcal{M}^{\\prime}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">When <span class="math">a\\in\\mathcal{M}^{\\prime}</span> then indeed <span class="math">a(X^{2})=a(X)^{2}</span>. Conversely, we prove that <span class="math">a(X^{2})=a(X)^{2}</span> implies that <span class="math">a\\in\\mathcal{M}^{\\prime}</span>. Let <span class="math">a(X)=\\sum_{i=1}^{n}a_{i}X^{d_{i}}</span> for some <span class="math">d_{n}&gt;d_{n-1}&gt;\\ldots&gt;d_{1}\\geq 0</span>. If <span class="math">n=1</span> and <span class="math">a(X^{2})=a(X)^{2}</span> then <span class="math">a_{1}X^{2d_{1}}=a_{1}^{2}X^{2d_{1}}</span>, which implies that <span class="math">a_{1}^{2}=a_{1}</span>. Therefore <span class="math">a_{1}\\in\\{0,1\\}</span> and either way <span class="math">a\\in\\mathcal{M}^{\\prime}</span>, as required. Next, suppose towards a contradiction that <span class="math">a(X^{2})=a(X)^{2}</span>, but <span class="math">n&gt;1</span> and all <span class="math">a_{1},\\ldots,a_{n}\\in\\mathbb{Z}_{q}</span> are non-zero. The highest degree term in <span class="math">a(X)^{2}</span> has degree <span class="math">2d_{n}</span>. The second highest degree term in <span class="math">a(X)^{2}</span> has degree is <span class="math">d_{n}+d_{n-1}</span> and its coefficient is <span class="math">2a_{n}a_{n-1}</span>. Since <span class="math">2d_{n}&gt;d_{n}+d_{n-1}&gt;2d_{n-1}</span>, the polynomial <span class="math">a(X^{2})</span> has no term of degree <span class="math">d_{n}+d_{n-1}</span>. Therefore, because <span class="math">a(X^{2})=a(X)^{2}</span>, we can conclude that <span class="math">2a_{n}a_{n-1}=0</span>. But since <span class="math">q&gt;2</span> this implies that one of <span class="math">a_{n}</span> or <span class="math">a_{n-1}</span> must be zero, which contradicts the assumption that <span class="math">a_{1},\\ldots,a_{n}\\in\\mathbb{Z}_{q}</span> are non-zero. ∎</p>

    <p class="text-gray-300">Define another monomial set</p>

    <p class="text-gray-300"><span class="math">\\mathcal{M}\\coloneqq\\left\\{0,1,X,\\ldots,X^{d-1}\\right\\}\\subseteq\\mathcal{M}^{\\prime}\\,.</span> (2)</p>

    <p class="text-gray-300">In what follows, we abuse the notation a bit and sometimes also write <span class="math">\\mathcal{M}\\subseteq R_{q}</span> to denote the natural embedding of <span class="math">\\left\\{0,1,X,\\ldots,X^{d-1}\\right\\}\\subseteq\\mathbb{Z}_{q}[X]</span> to the ring <span class="math">R_{q}</span>, and a statement that “<span class="math">a</span> is in <span class="math">\\mathcal{M}</span>” is well-defined for <span class="math">a\\in R_{q}</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">Lemma 2.1 does not hold if <span class="math">\\mathbb{Z}_{q}[X]</span> is replaced by <span class="math">R_{q}</span>. For example, in <span class="math">\\mathbb{Z}_{q}[X]/\\langle X^{4}+1\\rangle</span> with <span class="math">q\\equiv 1\\pmod{4}</span>, define</p>

    <p class="text-gray-300"><span class="math">a(X)\\coloneqq X^{3}/2+(i/2)X^{2}+(i/2)X+(1/2)\\in R_{q}</span></p>

    <p class="text-gray-300">where <span class="math">i\\in\\mathbb{Z}_{q}</span> satisfies <span class="math">i^{2}=-1</span>. Then <span class="math">a(X)</span> satisfies <span class="math">a(X)^{2}=a(X^{2})</span>, but <span class="math">a</span> is not in <span class="math">\\mathcal{M}</span>.</p>

    <p class="text-gray-300">For <span class="math">a\\in(-d,d)\\subseteq\\mathbb{Z}_{q}</span>, we denote by <span class="math">\\mathsf{sgn}(a)\\in\\{-1,0,1\\}</span> the sign of <span class="math">a</span> and <span class="math">\\mathsf{sgn}(0)\\coloneqq 0</span>. Define <span class="math">\\mathsf{exp}(a)\\in R_{q}</span> as <span class="math">\\mathsf{exp}(a)\\coloneqq\\mathsf{sgn}(a)X^{a}</span>. Note that <span class="math">\\mathsf{exp}(a)</span> is in <span class="math">\\mathcal{M}</span>. E.g., if <span class="math">a&lt;0</span>, then <span class="math">\\mathsf{exp}(a)=-X^{a}=-(-X^{a+d})=X^{a+d}\\in\\mathcal{M}</span>. Similarly, we define set <span class="math">\\mathsf{EXP}(a)\\subseteq\\mathcal{M}</span> to be</p>

    <p class="text-gray-300">\\[ \\mathsf{EXP}(a)\\coloneqq\\begin{cases}\\{\\mathsf{exp}(a)\\}&\\text{if <span class="math">a\\neq 0</span>}\\\\ \\{0,1,X^{d/2}\\}&\\text{if <span class="math">a=0</span>}\\end{cases} \\] (3)</p>

    <p class="text-gray-300">For a matrix <span class="math">\\mathbf{M}\\in(-d,d)^{m\\times n}</span>, <span class="math">\\mathsf{exp}(\\mathbf{M})\\in\\mathcal{M}^{m\\times n}</span> denotes the matrix that replaces each entry <span class="math">\\mathbf{M}_{i,j}</span> with <span class="math">\\mathsf{exp}(\\mathbf{M}_{i,j})</span>, and <span class="math">\\mathsf{EXP}(\\mathbf{M}):[m]\\times[n]\\to P(\\mathcal{M})</span> denotes the product of sets that replaces each entry <span class="math">\\mathbf{M}_{i,j}</span> with <span class="math">\\mathsf{EXP}(\\mathbf{M}_{i,j})</span>.</p>

    <p class="text-gray-300">We will need the following lemma.</p>

    <p class="text-gray-300">Lemma 2.2.</p>

    <p class="text-gray-300">Let <span class="math">d^{\\prime}:=d/2</span> and <span class="math">\\psi:=\\sum_{i\\in[1,d^{\\prime})}i\\cdot(X^{-i}+X^{i})\\in R_{q}</span>. For every <span class="math">a\\in\\mathbb{Z}_{q}</span>, if <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span>, then for all <span class="math">b\\in\\mathsf{EXP}(a)\\subseteq\\mathcal{M}</span>, we have <span class="math">\\mathsf{ct}(b\\cdot\\psi)=a</span>. Conversely, if there exists <span class="math">b\\in\\mathcal{M}</span> such that <span class="math">\\mathsf{ct}(b\\cdot\\psi)=a</span>, then <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span> and <span class="math">b\\in\\mathsf{EXP}(a)</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span>, then either <span class="math">a=0</span> and <span class="math">\\mathsf{ct}(b\\cdot\\psi)=0</span> for all <span class="math">b\\in\\mathsf{EXP}(0)</span>, or <span class="math">a\\neq 0</span>, and the only element <span class="math">b:=\\mathsf{exp}(a)</span> in <span class="math">\\mathsf{EXP}(a)</span> satisfies that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ct}(b\\cdot\\psi)=\\mathsf{ct}\\left(\\mathsf{sgn}(a)X^{a}\\cdot\\sum_{i\\in[1,d^{\\prime})}i\\cdot(X^{-i}+X^{i})\\right)=a\\,.</span></p>

    <p class="text-gray-300">Conversely, suppose <span class="math">\\mathsf{ct}(b^{<em>}\\cdot\\psi)=a</span> for some <span class="math">b^{</em>}\\in\\mathcal{M}</span>, we show that <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span>. If <span class="math">b^{<em>}=0</span>, then <span class="math">a=0\\in(-d^{\\prime},d^{\\prime})</span>. Otherwise, <span class="math">b^{</em>}\\cdot\\psi</span> rotates and flips the signs of the coefficients of <span class="math">\\psi</span>, and the constant term <span class="math">\\mathsf{ct}(b^{<em>}\\cdot\\psi)</span> stays in <span class="math">(-d^{\\prime},d^{\\prime})</span>. Therefore, <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span> as required. Finally, given that <span class="math">b^{</em>}\\in\\mathcal{M}</span> and <span class="math">\\mathsf{ct}(b^{<em>}\\cdot\\psi)=a</span> for <span class="math">a\\in(-d^{\\prime},d^{\\prime})</span>, by inspection, <span class="math">b^{</em>}</span> is in <span class="math">\\mathsf{EXP}(a)</span> and the claim holds. ∎</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Remark 2.2 (Lookup arguments).</h6>

    <p class="text-gray-300">While we use Lemma 2.2 for a range proof, namely proving membership in the set <span class="math">(-d^{\\prime},d^{\\prime})\\subset\\mathbb{Z}_{q}</span>, the lemma can be generalized by replacing <span class="math">(-d^{\\prime},d^{\\prime})</span> with any table of values <span class="math">T\\subseteq\\mathbb{Z}_{q}</span> of size at most <span class="math">d</span>, where <span class="math">0\\in T</span>. Simply change the definition of <span class="math">\\psi</span> to encode the values in <span class="math">T</span>. Then our range proof gives a table lookup argument for <span class="math">T</span>. Specifically, given a table <span class="math">T=(T_{i})_{i\\in[d]}</span> where <span class="math">T_{0}=0</span>, one can set</p>

    <p class="text-gray-300"><span class="math">\\psi_{T}:=\\sum_{i\\in[1,d^{\\prime}]}(-T_{i})\\cdot X^{i}+\\sum_{i\\in[1,d^{\\prime})}T_{i+d^{\\prime}}X^{-i}\\,.</span></p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Norms.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given <span class="math">f=\\sum_{i\\in[d]}f_{i}X^{i}\\in R</span>, the <span class="math">\\ell_{\\infty}</span>-norm of <span class="math">f</span> is defined as $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}:=\\max_{i=0}^{d-1}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. For a matrix </span>\\mathbf{F}\\in R^{n\\times m}<span class="math"> with entries </span>\\{\\mathbf{F}_{i,j}\\}_{i\\in[n],j\\in[m]}<span class="math">, its </span>\\ell_{\\infty}<span class="math">-norm is defined as </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}:=\\max_{i\\in[n],j\\in[m]}\\{\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}_{i,j}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\}<span class="math">. We similarly define the </span>\\ell_{\\infty}<span class="math">-norms for </span>R_{q}<span class="math">-elements by lifting elements in </span>R_{q}<span class="math"> to </span>R$ via the natural embedding.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For an element <span class="math">a\\in R</span>, we define its operator norm as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}:=\\sup_{y\\in R}\\frac{\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\cdot y\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}{\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}\\,.$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite set <span class="math">\\mathcal{S}\\subseteq R</span>, the operator norm $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<span class="math"> is defined as </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}:=\\max_{a\\in\\mathcal{S}}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}<span class="math">. Similarly, we can define operator norms for sets over </span>R_{q}<span class="math"> by lifting the elements to </span>R<span class="math">. When we write </span>a\\cdot b<span class="math"> for </span>a\\in R_{q}<span class="math"> and </span>b\\in R<span class="math">, we meant the product over </span>R<span class="math"> between </span>b<span class="math"> and the embedding of </span>a<span class="math"> to </span>R$. We will use the following useful facts.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 2.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every <span class="math">a\\in\\mathcal{M}</span> and <span class="math">b\\in R</span>, we have $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\cdot b\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If <span class="math">a\\in\\mathcal{M}</span>, then either <span class="math">a=0</span> and the claim holds; or <span class="math">a\\cdot b</span> rotates the coefficients of <span class="math">b</span> and flips the sign of some coefficients of <span class="math">b</span>. Hence the <span class="math">\\ell_{\\infty}</span>-norm won’t change. ∎</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 2.4 (Corollary 1.2 of [LS18]). Let <span class="math">d, e \\in \\mathbb{N}</span> be power-of-twos and <span class="math">e \\mid d</span>, and let <span class="math">q \\equiv 1 + 2e \\pmod{4e}</span> be a prime. Every non-zero <span class="math">y \\in R_q</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\frac{q^{1/e}}{\\sqrt{e}}$ is invertible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Strong sampling sets. A strong sampling set <span class="math">S \\subseteq R_q</span> satisfies that the difference of any two distinct elements in <span class="math">S</span> is invertible. E.g., if <span class="math">q</span> is a prime, then <span class="math">\\mathbb{Z}_q \\subseteq R_q</span> is a strong sampling set as the difference of any two distinct elements in <span class="math">\\mathbb{Z}_q</span> is invertible in <span class="math">R_q</span>. By Lemma 2.4, the set of <span class="math">R_q</span>-elements with small coefficients is strongly samplable, because the differences of small coefficients are still small and thus invertible. Moreover, such a set has small operator norm:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 2.5 (Prop. 2 of [AL21]). For all <span class="math">u \\in R</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}} \\leq d \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gadget matrix decomposition. Let <span class="math">b &amp;gt; 1</span> and <span class="math">\\hat{b} = b^{k}</span> for some <span class="math">k \\in \\mathbb{N}</span>. Denote by <span class="math">\\mathbf{g}_{b,k} = (1, b, \\ldots, b^{k-1}) \\in \\mathbb{Z}^k</span>. Given a matrix <span class="math">\\mathbf{M} \\in R^{n \\times m}</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\hat{b}<span class="math">, we can deterministically decompose </span>^3<span class="math"> </span>\\mathbf{M}<span class="math"> into a matrix </span>\\mathbf{M}' \\in R^{n \\times mk}<span class="math"> such that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b<span class="math"> and </span>\\mathbf{M} = \\mathbf{M}'\\mathbf{G}_{b,k}<span class="math">, where </span>\\mathbf{G}_{b,k} \\in \\mathbb{Z}^{mk \\times m}<span class="math"> is the gadget matrix </span>\\mathbf{G}_{b,k} := I_m \\otimes \\mathbf{g}_{b,k}<span class="math">. We denote by </span>\\mathbf{G}_{b,k}^{-1}: R^{n \\times m} \\to R^{n \\times mk}<span class="math"> the deterministic function that maps </span>\\mathbf{M}<span class="math"> to </span>\\mathbf{G}_{b,k}^{-1}(\\mathbf{M}) = \\mathbf{M}'<span class="math">, that is, </span>\\mathbf{G}_{b,k}^{-1}(\\mathbf{M})\\mathbf{G}_{b,k} = \\mathbf{M}<span class="math">. We simply write </span>\\mathbf{G}<span class="math"> and </span>\\mathbf{G}^{-1}<span class="math"> when </span>m, b, k$ are all clear in the context.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-22" class="text-2xl font-bold">2.2 Multilinear extensions and sumchecks over rings</h2>

    <p class="text-gray-300">For a binary vector <span class="math">a \\in \\{0,1\\}^k</span>, denote by <span class="math">[a]_k := \\sum_{i \\in [k]} a_i 2^i \\in [2^k]</span>; for integer <span class="math">b \\in [2^k]</span>, denote by <span class="math">\\langle b \\rangle_k \\in \\{0,1\\}^k</span> the binary representation of <span class="math">b</span>. We write <span class="math">\\langle b \\rangle</span> in short when there is no ambiguity in context. We review the notion of multilinear extensions over rings.</p>

    <p class="text-gray-300">Definition 2.1 (Multilinear Extensions over Rings). Let <span class="math">\\bar{R}</span> be a ring with zero 0 and identity 1. The multilinear extension <span class="math">\\widetilde{f} \\in \\bar{R}^{\\leq 1}[X_1, \\ldots, X_k]</span> of a function <span class="math">f: \\{0,1\\}^k \\to \\bar{R}</span> is</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{f}(\\mathbf{x}) := \\sum_{\\mathbf{b} \\in \\{0,1\\}^k} f(\\mathbf{b}) \\cdot eq(\\mathbf{b}, \\mathbf{x})</span></div>

    <p class="text-gray-300">where <span class="math">eq(\\mathbf{b}, \\mathbf{x}) := \\prod_{i \\in [k]} \\left[ (1 - \\mathbf{b}_i)(1 - \\mathbf{x}_i) + \\mathbf{b}_i \\mathbf{x}_i \\right]</span>.</p>

    <p class="text-gray-300">For <span class="math">\\mathbf{r} \\in \\bar{R}^k</span> we define <span class="math">\\text{tensor}(\\mathbf{r}) := \\bigotimes_{i \\in [k]} (1 - \\mathbf{r}_i, \\mathbf{r}_i) \\in \\bar{R}^{2^k}</span> as the tensor product of <span class="math">\\mathbf{r}</span>. More generally, we can define tensor product over “<span class="math">\\bar{R}</span>-vector spaces”. Let <span class="math">\\mathsf{M}</span> be an <span class="math">\\bar{R}</span>-module. For <span class="math">\\mathbf{m} \\in \\mathsf{M}^k</span>, we define <span class="math">\\text{tensor}(\\mathbf{m}) := \\bigotimes_{i \\in [k]} (1 - \\mathbf{m}_i, \\mathbf{m}_i) \\in \\mathsf{M}^{2^k}</span>. E.g., if <span class="math">\\mathsf{M} = \\bar{R} \\times \\bar{R}</span> and <span class="math">\\mathbf{m} = (\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)}) \\in \\mathsf{M}^k</span> where <span class="math">\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)} \\in \\bar{R}^k</span>, then <span class="math">\\text{tensor}(\\mathbf{m}) = (\\text{tensor}(\\mathbf{r}^{(0)}), \\text{tensor}(\\mathbf{r}^{(1)}))</span> can be understood as a pair of tensor products of <span class="math">\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)} \\in \\bar{R}^k</span>, respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3For every entry <span class="math">x \\in (-\\hat{b}, \\hat{b})</span>, we first compute the base-<span class="math">b</span> decomposition <span class="math">(x_0, \\ldots, x_{k-1})</span> of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, if </span>x &lt; 0<span class="math">, we further flip the sign of </span>x_i<span class="math"> for all </span>i \\in [k]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">Remark 2.3. For a function <span class="math">f:\\{0,1\\}^k\\to \\bar{R}</span> we define its table as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {f} := \\left(f (\\langle 0 \\rangle_ {k}), f (\\langle 1 \\rangle_ {k}), \\dots , f (\\langle 2 ^ {k} - 1 \\rangle_ {k})\\right) \\in \\bar {R} ^ {2 ^ {k}}.</span></div>

    <p class="text-gray-300">Observe that the evaluation of <span class="math">\\widetilde{f}</span> at the point <span class="math">\\mathbf{r} \\in \\bar{R}^k</span> is exactly <span class="math">\\widetilde{f}(\\mathbf{r}) = \\langle \\mathbf{f}, \\text{tensor}(\\mathbf{r}) \\rangle</span>. More generally, for a point <span class="math">\\mathbf{m} \\in (\\bar{R}^\\ell)^k</span> where <span class="math">\\ell \\in \\mathbb{N}</span>, we define <span class="math">\\widetilde{f}(\\mathbf{m}) := \\langle \\mathbf{f}, \\text{tensor}(\\mathbf{m}) \\rangle \\in \\bar{R}^\\ell</span>. E.g., if <span class="math">\\ell = 2</span>, <span class="math">\\widetilde{f}(\\mathbf{m})</span> denotes the evaluations of <span class="math">f</span> at a pair of points <span class="math">\\mathbf{m} = (\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)})</span> where <span class="math">\\mathbf{r}^{(0)}, \\mathbf{r}^{(1)} \\in \\bar{R}^k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 2.6 (Generalized Schwartz-Zippel [BCPS18]). For a nonzero polynomial <span class="math">f \\in \\bar{R}^{\\leq d}[X_1, \\ldots, X_k]</span> and a strong sampling set <span class="math">\\mathcal{C}</span>, we have $\\operatorname*{Pr}_{\\mathbf{r} \\in \\mathbb{R} \\setminus \\mathcal{C}^k}[f(\\mathbf{r}) = 0] \\leq \\frac{dk}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As noted by [CCKP19], we can do sumcheck over rings.</p>

    <p class="text-gray-300">Lemma 2.7 (Generalized Sum-Check [CCKP19]). For a polynomial <span class="math">f \\in \\bar{R}^{\\leq \\ell}[X_1, \\ldots, X_k]</span> with individual degree at most <span class="math">\\ell</span>, a strong sampling set <span class="math">\\mathcal{C} \\subseteq \\bar{R}</span>, and a value <span class="math">s \\in \\bar{R}</span>, there is a public-coin interactive protocol that reduces the checking of</p>

    <div class="my-4 text-center"><span class="math-block">s \\stackrel {?} {=} \\sum_ {\\mathbf {b} \\in \\{0, 1 \\} ^ {k}} f (\\mathbf {b})</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to the checking of an evaluation claim <span class="math">\\widetilde{f}(\\mathbf{r}) \\stackrel{?}{=} v</span> for some <span class="math">\\mathbf{r} \\notin \\mathcal{C}^k</span> and <span class="math">v \\in \\bar{R}</span>. The protocol is perfectly complete, has prover time <span class="math">\\tilde{O}(2^k \\ell)</span>, verifier time and proof size <span class="math">O(k \\ell)</span>, and soundness error $\\frac{k \\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 2.4 (Boosting soundness). The soundness error $k\\ell /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can be decreased to </span>(k\\ell /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^r<span class="math"> with </span>r &gt; 1<span class="math"> parallel repetitions. E.g., for </span>r = 2<span class="math">, set </span>\\mathsf{M}_{\\mathcal{C}} \\coloneqq \\mathcal{C} \\times \\mathcal{C}<span class="math">, we can understand the 2-way parallel execution as a sumcheck with challenge set </span>\\mathsf{M}_{\\mathcal{C}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 2.5 (Batching multiple claims). As noted in [BCS21, Sect. 2.1] and in Hyperplonk [CBBZ23], when checking <span class="math">s &amp;gt; 1</span> sumcheck claims over the same domain, we can batch them into a single sumcheck over a larger domain, with no additional randomness needed outside the sumcheck itself. For example, we can view <span class="math">d</span> sumcheck claims over <span class="math">\\mathbb{Z}_q</span> as a single sumcheck claim over <span class="math">R_q = \\mathbb{Z}_q[X] / \\langle X^d + 1 \\rangle</span>. We can also view <span class="math">s &amp;gt; 1</span> sumcheck claims over <span class="math">R_q</span> as a single sumcheck claim over <span class="math">R_q[Y] / \\langle Y^s + 1 \\rangle</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 2.6 (Compressing multiple claims to one). Using randomness, we can compress multiple sumcheck claims into one. Given <span class="math">k</span> sumcheck claims (over a field <span class="math">\\mathbb{F}</span>) w.r.t. polynomials <span class="math">g_1, \\ldots, g_k</span> respectively, we can reduce the claims to a single sumcheck claim w.r.t. <span class="math">\\sum_{i=1}^{k} g_i \\cdot r^{i-1}</span>, where <span class="math">r \\notin \\mathbb{F}</span> is a random challenge. This introduces an additive soundness error of $k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. When </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is small, to boost soundness, we can lift the polynomials to a larger extension field </span>\\mathbb{F}'<span class="math"> of </span>\\mathbb{F}<span class="math"> and use a random challenge </span>r \\in \\mathbb{F}'$ instead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4 f needs to be a sum of product of multilinear polynomials to achieve prover time <span class="math">\\tilde{O}(2^k \\ell)</span>.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">13</p>

    <h2 id="sec-23" class="text-2xl font-bold">2.3 Module-based Ajtai commitments</h2>

    <p class="text-gray-300">We recall the Module Short Integer Solution (MSIS) assumption.</p>

    <p class="text-gray-300"><strong>Definition 2.2</strong> (Module SIS with <span class="math">\\ell_{\\infty}</span>-Norms [LS15; PR06; LM06; ACK21]). Let <span class="math">q = q(\\lambda)</span>, <span class="math">\\kappa = \\kappa(\\lambda)</span>, <span class="math">m = m(\\lambda)</span> and <span class="math">\\beta_{\\mathrm{SIS}} = \\beta_{\\mathrm{SIS}}(\\lambda)</span>. The module SIS assumption <span class="math">\\mathsf{MSIS}_{q,\\kappa,m,\\beta_{\\mathrm{SIS}}}^{\\infty}</span> holds if for all expected polynomial-time adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\mathbf{A} \\mathbf{x} = \\mathbf{0} \\bmod q) \\wedge 0 &lt; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\beta_{\\mathrm{SIS}} &amp; \\begin{array}{c} \\mathbf{A} \\stackrel{\\mathrm{u}}{=} R_{q}^{\\kappa \\times m} \\\\ \\mathbf{x} \\in R^{m} \\leftarrow \\mathcal{A}(\\mathbf{A}) \\end{array} \\end{array} \\right] = \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Looking ahead, to argue knowledge soundness of the folding schemes, we need the commitments to satisfy a relaxed binding property defined below.</p>

    <p class="text-gray-300"><strong>Definition 2.3</strong> (Relaxed Binding Commitment [ALS20; ACK21; Ajt96; PR06; LM06]). Fix <span class="math">q = q(\\lambda), \\kappa = \\kappa(\\lambda)</span>, <span class="math">m = m(\\lambda)</span>, bound <span class="math">b \\in \\mathbb{N}</span> and a set <span class="math">\\mathcal{S} \\subseteq R_q^*</span> with invertible elements. We say that a randomly sampled linear function <span class="math">\\mathbf{A} \\stackrel{\\mathrm{u}}{=} R_q^{\\kappa \\times m}</span> is <span class="math">(b, \\mathcal{S})</span>-relaxed binding if for all expected polynomial-time adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\begin{array}{c c} 0 &lt; \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}_{2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; b \\wedge s_{1}, s_{2} \\in \\mathcal{S} \\wedge &amp; \\mathbf{A} \\stackrel{\\mathrm{u}}{=} R_{q}^{\\kappa \\times m} \\\\ \\mathbf{A} \\mathbf{z}_{1} s_{1}^{-1} = \\mathbf{A} \\mathbf{z}_{2} s_{2}^{-1} \\wedge &amp; (\\mathbf{z}_{1}, \\mathbf{z}_{2} \\in R_{q}^{m}, s_{1}, s_{2}) \\leftarrow \\mathcal{A}(\\mathbf{A}) \\end{array} \\right] = \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is clear that if the <span class="math">(b, \\mathcal{S})</span>-relaxed binding property doesn't hold, then we can find <span class="math">\\mathbf{x} := s_2 \\mathbf{z}_1 - s_1 \\mathbf{z}_2 \\neq \\mathbf{0} \\in R^m</span> such that <span class="math">\\mathbf{A} \\mathbf{x} = 0 \\bmod q</span>. Here <span class="math">s_2 \\mathbf{z}_1 - s_1 \\mathbf{z}_2</span> is computed over <span class="math">R</span> by first lifting <span class="math">s_1, s_2, \\mathbf{z}_1, \\mathbf{z}_2</span> to <span class="math">R</span>. Moreover, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B := 2b \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}}<span class="math">, thus we can reduce the </span>(b, \\mathcal{S})<span class="math">-relaxed binding property to the MSIS assumption </span>\\mathsf{MSIS}_{q,\\kappa,m,B}^{\\infty}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-24" class="text-2xl font-bold">2.4 Reduction of Knowledge</h2>

    <p class="text-gray-300">We review the notion of reduction of knowledge (RoK) from [KP23]. Informally, it converts the checking of a statement in relation <span class="math">\\mathcal{R}_1</span> to that of a reduced statement in <span class="math">\\mathcal{R}_2</span>. Note that it also captures the notion of folding schemes.</p>

    <p class="text-gray-300"><strong>Definition 2.4</strong> (Reduction of Knowledge [KP23]). Let <span class="math">\\mathcal{R}_1</span>, <span class="math">\\mathcal{R}_2</span> be indexed relations. A reduction of knowledge <span class="math">\\Pi</span> from relation <span class="math">\\mathcal{R}_1</span> to <span class="math">\\mathcal{R}_2</span> consists of the following PPT algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}) \\to \\mathbb{I}</span>: on input security parameter <span class="math">\\lambda</span> output index <span class="math">\\mathbb{I}</span>.</li>

      <li><span class="math">\\mathsf{P}(\\mathbb{I}, \\mathbb{x}_1, \\mathbb{w}_1) \\to (\\mathbb{x}_2, \\mathbb{w}_2)</span>: take index <span class="math">\\mathbb{I}</span>, a statement <span class="math">(\\mathbb{x}_1, \\mathbb{w}_1) \\in \\mathcal{R}_1</span>, interacts with the verifier, and output a statement <span class="math">(\\mathbb{x}_2, \\mathbb{w}_2)</span> such that <span class="math">(\\mathbb{I}, \\mathbb{x}_2, \\mathbb{w}_2) \\in \\mathcal{R}_2</span>.</li>

      <li><span class="math">\\mathsf{V}(\\mathbb{I}, \\mathbb{x}_1) \\to \\mathbb{x}_2</span>: take index <span class="math">\\mathbb{I}</span>, an instance <span class="math">\\mathbb{x}_1</span> for <span class="math">\\mathcal{R}_1</span>, interacts with the prover, and output an instance <span class="math">\\mathbb{x}_2</span> for relation <span class="math">\\mathcal{R}_2</span>. <span class="math">\\mathsf{V}</span> outputs <span class="math">\\perp</span> if rejects early.</li>

    </ul>

    <p class="text-gray-300">For brevity, we denote by <span class="math">\\langle\\mathsf{P}(\\mathsf{w}_1),\\mathsf{V}\\rangle[\\mathbb{I},\\mathsf{z}_1]\\to (\\mathsf{z}_2,\\mathsf{w}_2)</span> the interaction between <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> with common input <span class="math">(\\mathbb{I},\\mathsf{z}_1)</span>, and assume without loss of generality that (i) the reduced instances output by the prover and verifier are the same, (ii) <span class="math">\\perp \\notin \\mathcal{L}(\\mathcal{R}_2)</span> by default.</p>

    <p class="text-gray-300">A reduction of knowledge with the above syntax satisfy the properties below.</p>

    <p class="text-gray-300"><strong>Definition 2.5 (Perfect Completeness).</strong> For every PPT adversary <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathbb {I}, \\mathsf {z} _ {1}, \\mathsf {w} _ {1}) \\notin \\mathcal {R} _ {1} \\lor &amp;amp; \\mathbb {I} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ (\\mathbb {I}, \\mathsf {z} _ {2}, \\mathsf {w} _ {2}) \\in \\mathcal {R} _ {2} &amp;amp; (\\mathsf {z} _ {1}, \\mathsf {w} _ {1}) \\leftarrow \\mathcal {A} (\\mathbb {I}) \\\\ &amp;amp; (\\mathsf {z} _ {2}, \\mathsf {w} _ {2}) \\leftarrow \\langle \\mathsf {P} (\\mathsf {w} _ {1}), \\mathsf {V} \\rangle [ \\mathbb {I}, \\mathsf {z} _ {1} ] \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300"><strong>Definition 2.6 (Knowledge Soundness).</strong> There exists a knowledge-error function <span class="math">\\kappa(\\cdot)</span> and an expected polynomial time extractor <span class="math">\\mathsf{Ext}</span> such that for all expected polynomial time adversaries <span class="math">(\\mathcal{A},\\mathsf{P}^{*})</span> that can output <span class="math">(\\mathbb{I},\\mathsf{z}_2,\\mathsf{w}_2)\\in \\mathcal{R}_2</span> with non-negligible probability after the interaction with <span class="math">\\mathsf{V}</span>, we have that given <span class="math">\\mathbb{I}\\gets \\mathcal{G}(1^{\\lambda})</span>, <span class="math">(\\mathsf{z}_1,\\mathsf{st})\\gets \\mathcal{A}(\\mathbb{I})</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ (\\mathbb {I}, \\langle \\mathsf {P} ^ {<em>} (\\mathsf {s t}), \\mathsf {V} \\rangle [ \\mathbb {I}, \\mathsf {z} _ {1} ]) \\in \\mathcal {R} _ {2} \\right] - \\Pr \\left[ (\\mathbb {I}, \\mathsf {z} _ {1}, \\mathsf {E x t} ^ {\\mathsf {P} ^ {</em>}} (\\mathbb {I}, \\mathsf {z} _ {1}, \\mathsf {s t})) \\in \\mathcal {R} _ {1} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\kappa (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Definition 2.7 (Public reducibility).</strong> There is a deterministic polynomial time algorithm <span class="math">f</span> such that for all PPT adversary <span class="math">\\mathcal{A}</span> and expected polynomial time adversary <span class="math">\\mathsf{P}^*</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} f (\\mathbb {I}, \\mathsf {z} _ {1}, \\mathsf {t r}) = \\mathsf {z} _ {2} &amp;amp; \\begin{array}{c} \\mathbb {I} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}) \\\\ (\\mathsf {z} _ {1}, \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathbb {I}) \\\\ (\\mathsf {t r}, \\mathsf {z} _ {2}, \\mathsf {w} _ {2}) \\leftarrow \\langle \\mathsf {P} ^ {*} (\\mathsf {s t}), \\mathsf {V} \\rangle [ \\mathbb {I}, \\mathsf {z} _ {1} ] \\end{array} \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Here <span class="math">\\mathsf{tr}</span> denotes the transcript of the interaction <span class="math">\\langle \\mathsf{P}^{*}(\\mathsf{st}),\\mathsf{V}\\rangle [\\mathbb{I},\\mathsf{z}_{1}]</span>.</p>

    <p class="text-gray-300">We recall the knowledge composition theorem from [KP23].</p>

    <p class="text-gray-300"><strong>Theorem 2.1 (Sequential Composition, Thm. 5 [KP23]).</strong> Let <span class="math">\\mathcal{R}_1</span>, <span class="math">\\mathcal{R}_2</span>, <span class="math">\\mathcal{R}_3</span> be indexed relations. Let <span class="math">\\Pi_1</span> (and <span class="math">\\Pi_2</span>) be reduction of knowledge from <span class="math">\\mathcal{R}_1</span> to <span class="math">\\mathcal{R}_2</span> (and from <span class="math">\\mathcal{R}_2</span> to <span class="math">\\mathcal{R}_3</span>), respectively. Then <span class="math">\\Pi_2 \\circ \\Pi_1</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_1</span> to <span class="math">\\mathcal{R}_3</span>.</p>

    <p class="text-gray-300">Our goal is to build a folding scheme for R1CS relations — relations expressed as a set of quadratic constraints — and more generally, for customizable constraint systems (CCS) [STW23] that are expressed as a set of constraints of higher degree. Lattice-Fold [BC24, Sec. 4] gives a reduction of knowledge from CCS over rings to a linear relation over rings. This reduction of knowledge is inspired by a technique used over fields in HyperNova [KS24b].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here we define a general linear relation over rings that is the target of this reduction of knowledge. The relation uses a commitment scheme <span class="math">\\mathsf{com}(\\cdot):R_q^n\\to R_q^\\kappa</span> for vectors <span class="math">\\mathbf{f}\\in R_q^n</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math">, for some norm bound </span>B<span class="math">. Usually, this is simply the Ajtai commitment scheme from Section 2.3. The commitment to </span>\\mathbf{f}<span class="math"> is denoted by </span>\\mathsf{cm} = \\mathsf{com}(\\mathbf{f})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">14</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">Let <span class="math">q&gt;2</span> be a prime, <span class="math">n,\\kappa,n_{\\mathsf{lin}}\\in\\mathbb{N}</span>, and let <span class="math">\\mathsf{com}\\left(\\cdot\\right):R_{q}^{n}\\to R_{q}^{\\kappa}</span> be a commitment scheme. A generalized committed linear relation parameterized by <span class="math">B\\in\\mathbb{N}</span>, denoted <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span>, is a set of triples <span class="math">(\\mathbb{I},\\mathbbz,\\mathbbw)</span> where</p>

    <p class="text-gray-300"><span class="math">\\mathbb{I}=\\big{(}\\mathsf{com}\\left(\\cdot\\right),\\ (\\mathbf{M}^{(i)}\\in R_{q}^{n\\times n})_{i\\in[n_{\\mathsf{lin}}]}\\big{)},\\quad\\mathbb{z}=(\\mathsf{cm}_{\\mathbf{f}},\\ \\mathbf{r}\\in\\mathsf{M}_{\\mathcal{C}}^{\\log n},\\ \\mathbf{v}\\in\\mathsf{M}_{q}^{n_{\\mathsf{lin}}}),\\quad\\mathbb{w}=\\mathbf{f}\\in R_{q}^{n}.</span></p>

    <p class="text-gray-300">Here <span class="math">\\mathsf{M}_{\\mathcal{C}}:=\\mathcal{C}\\times\\mathcal{C}</span> where <span class="math">\\mathcal{C}</span> is a strong sampling set, and <span class="math">\\mathsf{M}_{q}:=R_{q}\\times R_{q}</span>. A triple <span class="math">(\\mathbb{I},\\mathbb{z},\\mathbbw)</span> is in the relation <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B\\right)\\ \\wedge\\ \\left(\\mathsf{cm}_{\\mathbf{f}}=\\mathsf{com}\\left(\\mathbf{f}\\right)\\right)\\ \\wedge\\ \\left(\\forall i\\in[n_{\\mathsf{lin}}]:\\ \\left\\langle\\mathbf{M}^{(i)}\\cdot\\mathbf{f},\\mathsf{tensor}(\\mathbf{r})\\right\\rangle=\\mathbf{v}_{i}\\right).$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In words, an instance <span class="math">(\\mathsf{cm},\\mathbf{r},\\mathbf{v})</span> is in the language of the relation <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> if <span class="math">\\mathsf{cm}</span> is a commitment to a low-norm vector <span class="math">\\mathbf{f}\\in R_{q}^{n}</span>, and for all <span class="math">i\\in[n_{\\mathsf{lin}}]</span>, the multilinear extension of the vector <span class="math">\\mathbf{M}^{(i)}\\mathbf{f}\\in R_{q}^{n}</span> evaluates to the pair <span class="math">\\mathbf{v}_{i}\\in\\mathsf{M}_{q}</span> at the pair of points <span class="math">\\mathbf{r}\\in\\mathsf{M}_{\\mathcal{C}}^{\\log n}</span>.</p>

    <p class="text-gray-300">In Section A we present a reduction of knowledge from R1CS to <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> where <span class="math">n_{\\mathsf{lin}}=4</span>. This protocol shows that a folding scheme for <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> is sufficient for folding R1CS relations. At the heart of the protocol is a sumcheck to reduce the quadratic R1CS relation to four multilinear evaluation of degree 1, which is an instance of <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span>. When the R1CS relation is defined by matrices <span class="math">\\mathbf{A},\\mathbf{B},\\mathbf{C}\\in R_{q}^{n\\times m}</span>, the derived matrices <span class="math">\\mathbf{M}^{(1)},\\mathbf{M}^{(2)},\\mathbf{M}^{(3)},\\mathbf{M}^{(4)}\\in R_{q}^{n\\times n}</span> in <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> are</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}^{(1)}:=\\mathbf{I}_{n},\\quad\\mathbf{M}^{(2)}:=\\mathbf{A}\\cdot\\mathbf{G}_{B,\\hat{\\ell}}^{\\top},\\quad\\mathbf{M}^{(3)}:=\\mathbf{B}\\cdot\\mathbf{G}_{B,\\hat{\\ell}}^{\\top},\\quad\\mathbf{M}^{(4)}:=\\mathbf{C}\\cdot\\mathbf{G}_{B,\\hat{\\ell}}^{\\top}</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{\\ell}:=\\lceil\\log_{B}(q)\\rceil</span> and <span class="math">\\mathbf{G}_{B,\\hat{\\ell}}\\in\\mathbb{Z}_{q}^{m\\hat{\\ell}\\times m}=\\mathbb{Z}_{q}^{n\\times m}</span> is the gadget matrix from Section 2.1. A similar reduction of knowledge applies to CCS with higher degree constraints.</p>

    <h2 id="sec-27" class="text-2xl font-bold">4 A Toolbox of Reduction of Knowledge</h2>

    <p class="text-gray-300">In this section, we introduce several reduction of knowledge protocols, which serve as the building blocks of our folding scheme for general linear relations. In Section 4.1, we introduce double commitments, which commits matrices in <span class="math">R_{q}^{n\\times m}</span> to short vectors in <span class="math">R_{q}^{\\kappa}</span>. Section 4.2 introduces <span class="math">\\Pi_{\\mathsf{mon}}</span>, an RoK that checks if every entry of a committed matrix belongs to the monomial set from (2). In Section 4.3, we leverage <span class="math">\\Pi_{\\mathsf{mon}}</span> to construct a range-check protocol <span class="math">\\Pi_{\\mathsf{rgchk}}</span> for committed <span class="math">R_{q}</span>-vectors. In Section 4.4, using <span class="math">\\Pi_{\\mathsf{rgchk}}</span>, we present an RoK <span class="math">\\Pi_{\\mathsf{cm}}</span> which transforms a committed relation associated with a double commitment, into a simpler relation associated with regular Ajtai commitments.</p>

    <p class="text-gray-300">Recall that the power-of-two <span class="math">d\\in\\mathbb{N}</span> is the dimension of the ring <span class="math">R_{q}</span>, and <span class="math">d^{\\prime}:=d/2</span>. Define <span class="math">\\ell:=\\lceil\\log_{d^{\\prime}}(q)\\rceil</span>. We will work over two types of challenge sets.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Challenge sets.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A folding challenge set <span class="math">\\bar{\\mathcal{S}}\\subseteq R_{q}</span> is a strong sampling set with small operator norm. It is used to fold multiple witness vectors into a single low-norm vector. A sumcheck challenge set <span class="math">\\mathcal{C}</span> is used to sample challenges for sumcheck protocols. For simplicity, we assume that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">. In particular, when </span>q<span class="math"> is a 128-bit prime, we set </span>\\mathcal{C}:=\\mathbb{Z}_{q}<span class="math">. More generally, for a smaller modulus </span>q<span class="math">, we set </span>\\mathcal{C}<span class="math"> as a </span>\\mathbb{Z}_{q}<span class="math">-vector space that is large enough. E.g., if </span>q<span class="math"> is 64-bit, we can set </span>\\mathcal{C}:=\\mathbb{F}_{q^{2}}<span class="math">, which is a </span>\\mathbb{Z}_{q}<span class="math">-vector space of dimension 2. To prove a sumcheck claim over </span>R_{q}<span class="math"> (or </span>\\mathbb{Z}_{q}<span class="math">), we run a sumcheck protocol over the challenge space </span>\\mathcal{C}<span class="math">, which can be understood as two parallel sumcheck executions over the challenge space </span>\\mathbb{Z}_{q}<span class="math">. For notation convenience, in what follows, we assume </span>q<span class="math"> is large enough and </span>\\mathcal{C}=\\mathbb{Z}_{q}<span class="math">, but all protocols easily generalize to smaller moduli as specified in Appendix B. Finally, we define the </span>R_{q}<span class="math">-module </span>\\mathsf{M}_{q}:=R_{q}\\times R_{q}<span class="math"> and set </span>\\mathsf{M}_{\\mathcal{C}}:=\\mathcal{C}\\times\\mathcal{C}$. They are useful when we want to enforce even smaller sumcheck soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.1 Linear commitments and double commitments</h3>

    <h5 id="sec-30" class="text-base font-semibold mt-4">General linear commitments.</h5>

    <p class="text-gray-300">For <span class="math">\\mathbf{a}\\in R_{q}^{n}</span> and <span class="math">\\mathbf{M}\\in R_{q}^{n\\times m}</span>, we denote by <span class="math">\\mathsf{com}\\left(\\mathbf{a}\\right)\\in R_{q}^{\\kappa}</span> and <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)\\in R_{q}^{\\kappa\\times m}</span> the “general linear commitments” to <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{M}</span> respectively. In our paper, <span class="math">\\mathsf{com}\\left(\\mathbf{a}\\right)</span> is computed as <span class="math">\\mathbf{Aa}</span> given the SIS matrix <span class="math">\\mathbf{A}\\in R_{q}^{\\kappa\\times n}</span>. Similarly, we set <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right):=\\mathbf{A}\\times\\mathbf{M}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">b\\in\\mathbb{N}</span> and set <span class="math">\\mathcal{S}\\subseteq R_{q}^{<em>}</span>, we say that <span class="math">\\mathbf{a}\\in R_{q}^{n}</span> is a </em><span class="math">(b,\\mathcal{S})</span>-valid opening* of <span class="math">\\mathsf{cm}_{\\mathbf{a}}</span>, if <span class="math">\\mathsf{cm}_{\\mathbf{a}}=\\mathsf{com}\\left(\\mathbf{a}\\right)</span> and <span class="math">\\mathbf{a}=\\frac{\\mathbf{a}^{\\prime}}{s}</span> for some <span class="math">\\mathbf{a}^{\\prime}\\in R_{q}^{n}</span>, <span class="math">s\\in\\mathcal{S}</span> such that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a}^{\\prime}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<b<span class="math">. We simply say that </span>\\mathbf{a}<span class="math"> is a valid opening if </span>(b,\\mathcal{S})<span class="math"> is clear in context. Similarly, </span>\\mathbf{M}\\in R_{q}^{n\\times m}<span class="math"> is a valid opening of </span>C_{\\mathbf{M}}\\in R_{q}^{\\kappa\\times m}<span class="math"> if for all </span>i\\in[m]<span class="math">, the </span>i<span class="math">-th column of </span>\\mathbf{M}<span class="math"> is a valid opening of the </span>i<span class="math">-th column of </span>C_{\\mathbf{M}}<span class="math">. We define the commitment opening relation (for </span>R_{q}$-vectors)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{open}}:=\\left\\{\\left(\\mathsf{z}=\\mathsf{cm}_{\\mathbf{f}}\\in R_{q}^{\\kappa},\\mathsf{\\omega}=\\mathbf{f}\\in R_{q}^{n}\\right)\\,:\\,\\mathbf{f}\\text{ is valid opening of }\\mathsf{cm}_{\\mathbf{f}}\\right\\}.</span> (6)</p>

    <p class="text-gray-300">A general linear commitment is <span class="math">(b,\\mathcal{S})</span>-binding if it is infeasible to find two different <span class="math">(b,\\mathcal{S})</span>-valid openings <span class="math">\\mathbf{a},\\mathbf{a}^{\\prime}</span> to the same commitment <span class="math">\\mathsf{cm}</span>. In our work, binding is implied by the <span class="math">(b,\\mathcal{S}=\\bar{\\mathcal{S}}-\\bar{\\mathcal{S}})</span>-relaxed binding property (Definition 2.3). We simply say that the commitment is binding if <span class="math">(b,\\mathcal{S})</span> is clear in context.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Double commitments.</h5>

    <p class="text-gray-300">For a vector <span class="math">\\mathbf{m}\\in R_{q}^{n}</span>, the double commitment of <span class="math">\\mathbf{m}</span> is defined as <span class="math">\\mathsf{dcom}\\left(\\mathbf{m}\\right):=\\mathsf{com}\\left(\\mathbf{m}\\right)\\in R_{q}^{\\kappa}</span>. For a matrix <span class="math">\\mathbf{M}\\in R_{q}^{n\\times m}</span> where <span class="math">m&gt;1</span>, we compute the linear commitment <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)\\in R_{q}^{\\kappa\\times m}</span>, and decompose <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)</span> to a low norm vector <span class="math">\\tau\\in(-d^{\\prime},d^{\\prime})^{n}\\subseteq\\mathbb{Z}_{q}^{n}</span>, and finally set <span class="math">\\mathsf{com}\\left(\\tau\\right)\\in R_{q}^{\\kappa}</span> as the double commitment to <span class="math">\\mathbf{M}</span>, which is more compact. Specifically, assume that <span class="math">\\kappa md\\ell\\leq n</span>, we denote by</p>

    <p class="text-gray-300"><span class="math">\\mathsf{dcom}\\left(\\mathbf{M}\\right):=\\mathsf{com}\\left(\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}\\right))\\right)\\in R_{q}^{\\kappa}</span> (7)</p>

    <p class="text-gray-300">the double commitment to <span class="math">\\mathbf{M}</span>, which is much shorter than <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)</span>. Here the decomposition map <span class="math">\\mathsf{split}:R_{q}^{\\kappa\\times m}\\rightarrow(-d^{\\prime},d^{\\prime})^{n}</span> is an injective function computed as follows:</p>

    <p class="text-gray-300">Construction 4.1. On input <span class="math">\\mathsf{com}(\\mathbf{M})</span>, compute <span class="math">\\mathsf{split}(\\mathsf{com}(\\mathbf{M})) \\in (-d&#x27;, d&#x27;)^n</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. compute <span class="math">\\mathbf{M}&#x27; := \\mathbf{G}_{d&#x27;,\\ell}^{-1}(\\mathsf{com}(\\mathbf{M})) \\in R_q^{\\kappa \\times m\\ell}</span> — the gadget decomposition of <span class="math">\\mathsf{com}(\\mathbf{M}) \\in R_q^{\\kappa \\times m}</span>, and flatten it to <span class="math">\\mathbf{M}&#x27;&#x27; := \\mathsf{flat}(\\mathbf{M}&#x27;) \\in R_q^{\\kappa m\\ell}</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}'' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; d'$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pad <span class="math">\\tau_M&#x27;</span> with zeros to obtain <span class="math">\\tau_M \\in (-d&#x27;, d&#x27;)^n</span>, and output <span class="math">\\mathsf{split}(\\mathsf{com}(\\mathbf{M})) := \\tau_M</span>.</li>

    </ol>

    <p class="text-gray-300">split is injective given the injectivity of gadget decomposition and flattening. Moreover, by the property of gadget matrices, there is a function <span class="math">\\mathsf{pow} : (-d&#x27;, d&#x27;)^n \\to R_q^{\\kappa \\times m}</span> such that <span class="math">\\mathsf{pow}(\\mathsf{split}(\\mathbf{D})) = \\mathbf{D}</span> for all <span class="math">\\mathbf{D} \\in R_q^{\\kappa \\times m}</span>. (However, <span class="math">\\mathsf{pow}</span> is not injective.) Intuitively, <span class="math">\\mathsf{pow}</span> computes the power-sums of input sub-vectors and embeds the results to the coefficients of <span class="math">\\kappa \\times m</span> polynomial ring elements.</p>

    <p class="text-gray-300">We say that <span class="math">(\\tau \\in (-d&#x27;, d&#x27;)^n, \\mathbf{M} \\in R_q^{n \\times m})</span> is a valid opening of <span class="math">C \\in R_q^\\kappa</span> if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{M}</span> is a valid opening of <span class="math">\\mathsf{pow}(\\tau) = \\mathsf{com}(\\mathbf{M})</span>, and</li>

      <li><span class="math">\\tau</span> is a valid opening of <span class="math">C</span> when treating <span class="math">C</span> as a linear commitment.</li>

    </ol>

    <p class="text-gray-300">Remark 4.1. <span class="math">\\tau</span> is not necessarily <span class="math">\\mathsf{split}(\\mathsf{com}(\\mathbf{M}))</span> because <span class="math">\\mathsf{pow}</span> is not injective.</p>

    <p class="text-gray-300">Define the double commitment opening relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{dopen}, m} := \\left\\{ \\begin{array}{l l} (\\varkappa, \\varkappa) &amp;amp; : \\quad \\varkappa = C_{\\mathbf{M}} \\in R_q^\\kappa \\\\ (\\varkappa, \\varkappa) &amp;amp; : \\quad \\varkappa = (\\tau \\in (-d&#x27;, d&#x27;)^n, \\mathbf{M} \\in R_q^{n \\times m}) \\\\ &amp;amp; \\quad \\text{where } (\\tau, \\mathbf{M}) \\text{ is valid opening of } C_{\\mathbf{M}} \\end{array} \\right\\}. \\tag{8}</span></div>

    <p class="text-gray-300">Lemma 4.1. If <span class="math">\\mathsf{com}(\\cdot)</span> is binding, then <span class="math">\\mathsf{dcom}(\\cdot)</span> is also binding, that is, it's infeasible to find <span class="math">C, (\\tau, \\mathbf{M}), (\\tau&#x27;, \\mathbf{M}&#x27;)</span> where <span class="math">\\mathbf{M} \\neq \\mathbf{M}&#x27;</span> and <span class="math">(\\tau, \\mathbf{M})</span>, <span class="math">(\\tau&#x27;, \\mathbf{M}&#x27;)</span> are both valid openings of <span class="math">C</span>.</p>

    <p class="text-gray-300">Proof. We can find a collision for <span class="math">\\mathsf{com}(\\cdot)</span> given such openings: if <span class="math">\\mathsf{com}(\\mathbf{M}) = \\mathsf{com}(\\mathbf{M}&#x27;)</span>, then we find a collision <span class="math">\\mathbf{M} \\neq \\mathbf{M}&#x27;</span>; if <span class="math">\\tau \\neq \\tau&#x27;</span>, we find a collision <span class="math">(\\tau, \\tau&#x27;)</span> given that <span class="math">\\mathsf{com}(\\tau) = \\mathsf{com}(\\tau&#x27;) = C</span>. Otherwise, suppose <span class="math">\\tau = \\tau&#x27;</span> and <span class="math">\\mathsf{com}(\\mathbf{M}) \\neq \\mathsf{com}(\\mathbf{M}&#x27;)</span>. Since <span class="math">(\\tau, \\mathbf{M})</span>, <span class="math">(\\tau&#x27;, \\mathbf{M}&#x27;)</span> are both valid openings, we reach a contradiction that <span class="math">\\mathsf{com}(\\mathbf{M}) = \\mathsf{pow}(\\tau) = \\mathsf{pow}(\\tau&#x27;) = \\mathsf{com}(\\mathbf{M}&#x27;)</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4.2 Monomial set check</h2>

    <p class="text-gray-300">In this section, we present a protocol for checking that every element of a committed matrix <span class="math">\\mathbf{M}</span> is in the monomial set <span class="math">\\mathcal{M} \\subseteq R_q</span> from (2). This will be useful later in our range proofs. We present the protocol as a reduction of knowledge from an input relation <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{in}}</span> to an output relation <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{out}}</span>.</p>

    <p class="text-gray-300">The input relation <span class="math">\\mathcal{R}_{\\mathsf{m},\\mathsf{in}}</span> holds when the double commitment <span class="math">C_{\\mathbf{M}}</span> is a commitment to a witness matrix <span class="math">\\mathbf{M}</span> of monomials:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {m}, \\mathrm {i n}} := \\left\\{\\left(\\mathbb {x}, \\mathbb {w}\\right): \\begin{array}{l} \\mathbb {x} = C _ {\\mathbf {M}} \\in R _ {q} ^ {\\kappa}, \\mathbb {w} = \\mathbf {M} \\in R _ {q} ^ {n \\times m} \\text {s . t .} \\\\ \\left(\\left(\\mathbb {x}, \\mathbb {w}\\right): \\mathbf {M} _ {i, j} \\in \\mathcal {M} \\text {f o r a l l} (i, j) \\in [ n ] \\times [ m ] \\right. \\\\ \\left. \\left(C _ {\\mathbf {M}}, (\\operatorname {s p l i t} (\\operatorname {c o m} (\\mathbf {M})), \\mathbf {M})\\right) \\in \\mathcal {R} _ {\\text {d o p e n}, m} \\right\\}. \\end{array} \\right. \\tag {9}</span></div>

    <p class="text-gray-300">The output relation <span class="math">\\mathcal{R}_{\\mathsf{m,out}}</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {m}, \\text {o u t}} := \\left\\{\\left(\\mathbb {x}, \\mathbb {w}\\right): \\begin{array}{l} \\mathbb {x} = \\left(C _ {\\mathbf {M}} \\in R _ {q} ^ {\\kappa}, \\mathbf {r} \\in \\mathcal {C} ^ {\\log n}, \\mathbf {e} \\in R _ {q} ^ {m}\\right), \\mathbb {w} = \\mathbf {M} \\in R _ {q} ^ {n \\times m} \\text {s . t .} \\\\ \\mathbf {M} ^ {\\top} \\operatorname {t e n s o r} (\\mathbf {r}) = \\mathbf {e} \\wedge \\left(C _ {\\mathbf {M}}, (\\operatorname {s p l i t} (\\operatorname {c o m} (\\mathbf {M})), \\mathbf {M})\\right) \\in \\mathcal {R} _ {\\text {d o p e n}, m} \\end{array} \\right\\}. \\tag {10}</span></div>

    <p class="text-gray-300">The output relation holds for an instance <span class="math">\\mathbb{x} = (C_{\\mathbf{M}},\\mathbf{r},\\mathbf{e})</span> and a witness matrix <span class="math">\\mathbb{w} = \\mathbf{M}</span>, if <span class="math">\\mathbf{M}</span> is an opening of <span class="math">C_{\\mathbf{M}}</span> and satisfies <span class="math">\\mathbf{M}^{\\top}\\mathrm{tensor}(\\mathbf{r}) = \\mathbf{e}</span>.</p>

    <p class="text-gray-300">Before the construction, we introduce some notation and a useful corollary.</p>

    <p class="text-gray-300"><strong>Notation.</strong> For every <span class="math">i \\in [n]</span>, we write <span class="math">\\langle i \\rangle \\in \\{0,1\\}^{\\log n}</span> in short for <span class="math">\\langle i \\rangle_{\\log n}</span>. For a ring element <span class="math">a = \\sum_{i \\in [d]} a_i X^i \\in R_q</span>, and a value <span class="math">\\beta \\in \\mathbb{F}_{q^u}</span> (where <span class="math">u \\geq 1</span>), we denote by <span class="math">\\mathbf{ev}_a(\\beta) := \\sum_{i \\in [d]} a_i \\beta^i \\in \\mathbb{F}_{q^u}</span> the evaluation of <span class="math">a = a(X)</span> at point <span class="math">\\beta \\in \\mathbb{F}_{q^u}</span>.</p>

    <p class="text-gray-300"><strong>Corollary 4.1.</strong> Let <span class="math">q &amp;gt; 2</span> be a prime and <span class="math">\\mathbb{F}_{q^u}</span> an extension field of <span class="math">\\mathbb{Z}_q</span> with <span class="math">u \\geq 1</span>. For all <span class="math">a \\in \\mathcal{M} \\subseteq R_q</span> and <span class="math">\\beta \\in \\mathbb{F}_{q^u}</span>, we have <span class="math">\\mathbf{ev}_a(\\beta)^2 = \\mathbf{ev}_a(\\beta^2)</span> (where the arithmetic is over <span class="math">\\mathbb{F}_{q^u}</span>). And for every <span class="math">a \\in R_q</span> not in <span class="math">\\mathcal{M}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{\\beta \\in \\mathbb{F}_{q^u}}\\left[\\mathbf{ev}_a(\\beta)^2 = \\mathbf{ev}_a(\\beta^2)\\right] &lt; 2d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{q^u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Proof.</strong> The completeness is trivial. We focus on proving soundness. For <span class="math">a \\notin \\mathcal{M}</span>, consider the natural embedding <span class="math">a(X)</span> of <span class="math">a</span> in <span class="math">\\mathbb{Z}_q[X]</span> as a polynomial of degree less than <span class="math">d</span>. By Lemma 2.1, <span class="math">a(X)^2 \\neq a(X^2)</span> where <span class="math">a(X)^2</span> and <span class="math">a(X^2)</span> both have degree less than <span class="math">2d</span>. Moreover, since <span class="math">\\mathbb{Z}_q</span> is a subfield of <span class="math">\\mathbb{F}_{q^u}</span>, we can lift <span class="math">a(X)^2</span> and <span class="math">a(X^2)</span> from <span class="math">\\mathbb{Z}_q[X]</span> to <span class="math">\\mathbb{F}_{q^u}[X]</span>. Then by Lemma 2.6, the claim holds.</p>

    <p class="text-gray-300">Corollary 4.1 suggests a natural way to do monomial set check, by testing <span class="math">\\mathbf{ev}_{\\mathbf{M}_{i,j}}(\\beta)^2 = \\mathbf{ev}_{\\mathbf{M}_{i,j}}(\\beta^2)</span> for every entry <span class="math">(i,j)</span>. However, this is too expensive for the verifier, thus we use sumcheck to improve verifier complexity. We formally describe the construction below.</p>

    <p class="text-gray-300"><strong>Construction 4.2.</strong> On input <span class="math">\\mathbb{x} = C_{\\mathbf{M}} \\in R_q^\\kappa</span> and <span class="math">\\mathbb{w} = \\mathbf{M} \\in \\mathcal{M}^{n \\times m} \\subseteq R_q^{n \\times m}</span> where <span class="math">(\\mathbb{x}, \\mathbb{w}) \\in \\mathcal{R}_{\\mathfrak{m},\\mathfrak{in}}</span>, the protocol <span class="math">\\Pi_{\\mathfrak{mon}}</span> proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V} \\to \\mathsf{P}</span>: Send challenges <span class="math">\\mathbf{c} \\in \\mathcal{C}^{\\log n}</span> and <span class="math">\\beta \\in \\mathcal{C}</span>.</li>

    </ol>

    <p class="text-gray-300">18</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}</span> : Combine the following sumcheck claims to one according to Remark 2.6 and run a degree-3 sumcheck protocol for it. For all <span class="math">j \\in [m]</span>, denote by</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{m}^{(j)} := \\left(\\mathbf{e v}_{\\mathbf{M}_{0,j}}(\\beta), \\dots, \\mathbf{e v}_{\\mathbf{M}_{n-1,j}}(\\beta)\\right), \\qquad \\mathbf{m}^{\\prime(j)} := \\left(\\mathbf{e v}_{\\mathbf{M}_{0,j}}(\\beta^2), \\dots, \\mathbf{e v}_{\\mathbf{M}_{n-1,j}}(\\beta^2)\\right),</span></div>

    <p class="text-gray-300">the <span class="math">j</span>-th sumcheck claim is:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n]} \\operatorname{eq}(\\mathbf{c}, \\langle i \\rangle) \\cdot \\left(\\widetilde{\\mathbf{m}^{(j)}} (\\langle i \\rangle)^2 - \\widetilde{\\mathbf{m}^{\\prime(j)}} (\\langle i \\rangle)\\right) = 0. \\tag{11}</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathbf{r} \\xleftarrow{a} \\mathcal{C}^{\\log n}</span> be the sumcheck challenge, <span class="math">\\alpha \\xleftarrow{a} \\mathcal{C}</span> be the random combiner and <span class="math">v \\in \\mathcal{C}</span> be the claimed evaluation. The sumcheck reduces to the claim:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{eq}(\\mathbf{c}, \\mathbf{r}) \\cdot \\left[ \\sum_{j \\in [m]} \\alpha^j \\cdot \\left(\\widetilde{\\mathbf{m}^{(j)}} (\\mathbf{r})^2 - \\widetilde{\\mathbf{m}^{\\prime(j)}} (\\mathbf{r})\\right) \\right] \\stackrel{?}{=} v.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span> : Send <span class="math">\\left\\{\\mathbf{e}_j = \\widetilde{M_{*,j}}(\\mathbf{r}) \\in R_q\\right\\}_{j \\in [m]}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> : Check that:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{eq}(\\mathbf{c}, \\mathbf{r}) \\cdot \\left[ \\sum_{j \\in [m]} \\alpha^j \\cdot \\left(\\mathbf{e v}_{\\mathbf{e}_j}(\\beta)^2 - \\mathbf{e v}_{\\mathbf{e}_j}(\\beta^2)\\right) \\right] \\stackrel{?}{=} v. \\tag{12}</span></div>

    <p class="text-gray-300">Abort and return <span class="math">\\perp</span> if the checks fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the reduced statement <span class="math">(\\mathbb{z} = (C_{\\mathbf{M}}, \\mathbf{r}, \\mathbf{e}), \\omega = \\mathbf{M}) \\in \\mathcal{R}_{\\mathfrak{m},\\mathrm{out}}</span>.</li>

    </ol>

    <p class="text-gray-300">Remark 4.2 (Batching). <span class="math">\\Pi_{\\mathrm{mon}}</span> can be extended to check multiple committed matrices. That is, we convert all sumcheck statements into one via random linear combination and run a sumcheck protocol for the randomly-combined polynomial (c.f. Remark 2.6).</p>

    <p class="text-gray-300">Remark 4.3 (Efficiency). The protocol <span class="math">\\Pi_{\\mathrm{mon}}</span> is highly efficient for reasons below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The degree-3 sumcheck operates over <span class="math">\\mathcal{C}</span>. E.g., if <span class="math">q \\geq 2^{\\lambda}</span>, <span class="math">\\mathcal{C} = \\mathbb{Z}_q</span> has much more efficient arithmetic than <span class="math">R_q</span>. For a smaller modulus <span class="math">q</span>, we can still use parallel repetitions or extension fields of <span class="math">\\mathbb{Z}_q</span> to boost soundness without increasing much cost.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The multilinear evaluations <span class="math">\\{\\mathbf{e}_j\\}_{j \\in [m]}</span> can be computed in only <span class="math">O(n)</span> <span class="math">\\mathbb{Z}_q</span>-multiplications plus <span class="math">O(nm)</span> <span class="math">\\mathbb{Z}_q</span>-additions. We first compute the vector <span class="math">\\text{tensor}(\\mathbf{r})</span> using <span class="math">O(n)</span> <span class="math">\\mathbb{Z}_q</span>-multiplications. Then for each <span class="math">j \\in [m]</span>, <span class="math">\\widetilde{\\mathbf{M}_{<em>,j}}(\\mathbf{r}) = \\langle \\mathbf{M}_{</em>,j}, \\text{tensor}(\\mathbf{r}) \\rangle</span> is computed as follows: initialize <span class="math">v := \\sum_{i \\in [d]} v_i X^i \\in R_q</span> as zero. For every <span class="math">i \\in [n]</span>, do nothing if <span class="math">\\mathbf{M}_{i,j} = 0</span>; otherwise, denote by <span class="math">\\mathbf{M}_{i,j} = X^{m_{i,j}} \\in \\mathcal{M} \\subseteq R_q</span> where <span class="math">m_{i,j} \\in [d]</span>, and update <span class="math">v_{m_{i,j}} \\gets v_{m_{i,j}} + \\text{tensor}(\\mathbf{r})_i</span>. The resulting <span class="math">v</span> is exactly <span class="math">\\widetilde{\\mathbf{M}_{*,j}}(\\mathbf{r})</span> and it takes only <span class="math">O(n)</span> <span class="math">\\mathbb{Z}_q</span>-additions.</li>

    </ol>

    <p class="text-gray-300">19</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Looking ahead, in an end-to-end folding scheme, the prover also needs to compute the commitment <span class="math">C_{\\mathbf{M}}=\\mathsf{dcom}\\left(\\mathbf{M}\\right)</span>, whose main cost is computing <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)</span>. Recall that the entries of <span class="math">\\mathbf{M}</span> are in the monomial set <span class="math">\\mathcal{M} \\subseteq R_q</span>. Thus, for each column <span class="math">\\mathbf{M}_{<em>,j}</span> (<span class="math">j \\in [m]</span>), <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{</em>,j}\\right) = \\mathbf{AM}_{*,j}</span> is the sum of <span class="math">\\mathbf{A}</span>'s columns (after rotation and sign flipping). This requires only <span class="math">n\\kappa R_q</span>-additions, much more efficient than <span class="math">R_q</span>-multiplications. Overall, committing <span class="math">\\mathsf{com}\\left(\\mathbf{M}\\right)</span> takes <span class="math">\\approx n\\kappa m</span> <span class="math">R_q</span>-additions, or equivalently, <span class="math">n\\kappa dm</span> (parallelizable) <span class="math">\\mathbb{Z}_q</span>-additions. For <span class="math">m \\approx d = 64</span>, and <span class="math">q \\approx 2^{128}</span>, the concrete cost is comparable to computing an Ajtai commitment for an arbitrary <span class="math">\\mathbf{a} \\in R_q^n</span>, which takes <span class="math">n\\kappa R_q</span>-multiplications, or equivalently, <span class="math">\\Omega(n\\kappa d\\log d)</span> <span class="math">\\mathbb{Z}_q</span>-multiplications.</li>

    </ol>

    <p class="text-gray-300"><strong>Lemma 4.2.</strong> The protocol <span class="math">\\Pi_{\\mathrm{mon}}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{in}}</span> to <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{out}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Public reducibility is trivial. The claim follows from the lemmas below.</p>

    <p class="text-gray-300"><strong>Lemma 4.3.</strong> <span class="math">\\Pi_{\\mathrm{mon}}</span> is perfectly complete.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For every input statement in <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{in}}</span>, the verifier checks pass and the prover's output is in <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{out}}</span>: Since <span class="math">\\mathbf{M}</span>'s entries are in the monomial set <span class="math">\\mathcal{M}</span>, by Corollary 4.1, the sumcheck claim in (11) holds. Thus, the sumcheck verifier accepts, and the evaluation claim holds. Since the prover sends correct evaluations <span class="math">\\{\\mathbf{e}_j\\}</span>, the check in (12) holds and the output statement is in <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{out}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 4.4.</strong> If <span class="math">\\mathsf{dcom}(\\cdot)</span> is binding with binding error <span class="math">\\epsilon_{\\mathrm{bind}}</span>, then <span class="math">\\Pi_{\\mathrm{mon}}</span> is knowledge sound with knowledge error $\\epsilon_{\\mathrm{mon},m} := (2d + m + 4\\log n) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_{\\mathrm{bind}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> The extractor <span class="math">\\mathsf{Ext}</span> simulates the execution with the malicious prover <span class="math">(\\mathcal{A},\\mathsf{P}^{<em>})</span> and returns <span class="math">\\mathsf{P}^{</em>}</span>'s output if <span class="math">\\mathsf{P}^{*}</span> passes the verification. Otherwise, <span class="math">\\mathsf{Ext}</span> returns <span class="math">\\perp</span>. It is clear that <span class="math">\\mathsf{Ext}</span> has polynomial time complexity.</p>

    <p class="text-gray-300">Let <span class="math">\\omega = \\mathbf{M}</span> denote <span class="math">\\mathsf{Ext}</span>'s output. Let <span class="math">B_0</span> be the event that <span class="math">\\omega</span> is not valid for <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{in}}</span> but valid for <span class="math">\\mathcal{R}_{\\mathfrak{m},\\mathfrak{out}}</span>. That is, there exists an entry <span class="math">(i,j)</span> where <span class="math">\\mathbf{M}_{i,j} \\notin \\mathcal{M}</span>. Consider the following bad events:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Event <span class="math">B_{1}</span>: <span class="math">B_{0}</span> occurs and <span class="math">\\mathbf{ev}_{\\mathbf{M}_{i,j}}(\\beta)^2 = \\mathbf{ev}_{\\mathbf{M}_{i,j}}(\\beta^2)</span>. (Note that for a fixed <span class="math">\\mathbf{M}</span>, by Corollary 4.1, this happens with probability at most $2d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Event <span class="math">B_{3}</span>: <span class="math">B_{0}</span> occurs, the sumcheck claim (at Step 2) does not hold, but the evaluations <span class="math">\\mathbf{e}</span> of <span class="math">\\mathbf{M}</span> are correct. (Note that for a fixed <span class="math">\\mathbf{M}</span>, by sumcheck soundness, this happens with probability at most $3\\log n /</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{C}</td>

            <td class="px-3 py-2 border-b border-gray-700">$.)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose for contradiction that $\\operatorname<em>{Pr}[B_0] \\geq \\operatorname</em>{Pr}[B_1 \\vee B_2 \\vee B_3] &gt; 2d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 4\\log n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_{\\mathrm{bind}}<span class="math">. Then there is an adversary that breaks the binding property of </span>\\mathsf{com}(\\cdot)<span class="math"> with probability more than </span>\\epsilon_{\\mathrm{bind}}$, contradiction. Thus the claim holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">In this section, we show how to check that the <span class="math">\\mathbb{Z}_q</span>-coefficients of a committed <span class="math">R_q</span>-vector <span class="math">\\mathbf{f}</span> are within a fixed range <span class="math">(-B,B)</span>, where <span class="math">B = (d&#x27;)^k</span> for some <span class="math">k \\in \\mathbb{N}</span>. Recall that <span class="math">d&#x27; := d/2</span>.</p>

    <p class="text-gray-300"><strong>Warm-up.</strong> As a warm-up, we first set the range to <span class="math">(-d&#x27;, d&#x27;)</span> and range-check a vector <span class="math">\\tau \\in \\mathbb{Z}_q^n</span>. Our goal is to reduce the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{rg}}&#x27; := \\left\\{(\\mathbb{x}, \\mathbb{w}) : \\begin{array}{l} \\mathbb{x} = (\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}} \\in R_q^{\\kappa}), \\mathbb{w} = (\\tau, \\mathbf{m}_{\\tau} \\in R_q^n) \\text{ s.t.} \\\\ \\tau \\in (-d&#x27;, d&#x27;)^n \\wedge (\\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{m}_{\\tau}) \\in \\mathcal{R}_{\\mathrm{m},\\mathrm{in}} \\\\ (\\mathbf{m}_{\\tau} \\in \\mathsf{EXP}(\\tau)) \\wedge (\\mathsf{cm}_{\\tau}, \\tau) \\in \\mathcal{R}_{\\mathrm{open}} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}&#x27; := \\left\\{(\\mathbb{x}, \\mathbb{w}) : \\begin{array}{l} \\mathbb{x} = (\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}} \\in R_q^{\\kappa}, \\mathbf{r} \\in \\mathcal{C}^{\\log n}, (a, b \\in R_q)), \\\\ \\mathbb{w} = (\\tau, \\mathbf{m}_{\\tau} \\in R_q^n) \\text{ s.t.} \\\\ [\\tau, \\mathbf{m}_{\\tau}]^\\top \\mathsf{tensor}(\\mathbf{r}) = (a, b) \\\\ (\\mathsf{cm}_{\\tau}, \\tau) \\in \\mathcal{R}_{\\mathrm{open}} \\wedge (\\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{m}_{\\tau}) \\in \\mathcal{R}_{\\mathrm{open}} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">In words, <span class="math">\\mathcal{R}_{\\mathrm{rg}}&#x27;</span> checks that <span class="math">\\tau, \\mathbf{m}_{\\tau}</span> are openings to <span class="math">\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span>, and <span class="math">\\mathbf{m}_{\\tau}</span> is in <span class="math">\\mathsf{EXP}(\\tau) \\subseteq \\mathcal{M}^n</span> (where <span class="math">\\mathsf{EXP}(\\cdot)</span> is defined in (3)), and <span class="math">\\tau</span> is in the range <span class="math">(-d&#x27;, d&#x27;)^n</span>. <span class="math">\\mathcal{R}&#x27;</span> checks that for instance <span class="math">(\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{r}, a, b)</span>, the witnesses <span class="math">\\tau, \\mathbf{m}_{\\tau}</span> are openings to <span class="math">\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span> and the matrix-vector product <span class="math">[\\tau, \\mathbf{m}_{\\tau}]^\\top \\mathsf{tensor}(\\mathbf{r}) = (a, b)</span> holds. Here, <span class="math">\\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span> serves as a helper commitment for the range-check. One may understand it as a proof element in the reduction of knowledge. However, we put it directly into the instance to simplify the protocols and their analysis.</p>

    <p class="text-gray-300"><strong>Construction 4.3.</strong> On input <span class="math">\\mathbb{x} = (\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}} \\in R_q^{\\kappa})</span>, <span class="math">\\mathbb{w} = (\\tau \\in (-d&#x27;, d&#x27;)^n, \\mathbf{m}_{\\tau} \\in \\mathsf{EXP}(\\tau) \\subseteq \\mathcal{M}^n)</span> where <span class="math">( \\mathbb{x}, \\mathbb{w} ) \\in \\mathcal{R}_{\\mathrm{rg}}&#x27;</span>, the protocol proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run monomial set check <span class="math">\\Pi_{\\mathrm{mon}}</span> for <span class="math">\\mathbf{m}_{\\tau}</span>, which outputs a statement</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb{x} = (\\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{r} \\in \\mathcal{C}^{\\log n}, b \\in R_q), \\mathbb{w} = \\mathbf{m}_{\\tau}) \\in \\mathcal{R}_{\\mathrm{m},\\mathrm{out}}</span></div>

    <p class="text-gray-300">where <span class="math">b = \\langle \\mathbf{m}_{\\tau}, \\mathrm{tensor}(\\mathbf{r}) \\rangle \\in R_q</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span>: Send <span class="math">a := \\langle \\tau, \\mathrm{tensor}(\\mathbf{r}) \\rangle \\in \\mathcal{C}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span>: Let <span class="math">\\psi := \\sum_{i \\in [1,d&#x27;)} i \\cdot (X^{-i} + X^i) \\in R_q</span>. Check <span class="math">\\mathsf{ct}(\\psi \\cdot b) \\stackrel{?}{=} a</span>, abort and return <span class="math">\\perp</span> if the check fails.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the reduced statement <span class="math">(\\mathbb{x} = (\\mathsf{cm}_{\\tau}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{r}, (a, b)), \\mathbb{w} = (\\tau, \\mathbf{m}_{\\tau})) \\in \\mathcal{R}&#x27;</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 4.5.</strong> If <span class="math">\\mathsf{com}(\\cdot)</span> is binding with binding error <span class="math">\\epsilon_{\\mathrm{bind}}</span>, then the above protocol is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathrm{rg}}&#x27;</span> to <span class="math">\\mathcal{R}&#x27;</span> with knowledge error $\\epsilon_{\\mathrm{rg}}' := \\epsilon_{\\mathrm{mon},1} + \\epsilon_{\\mathrm{bind}} + \\log n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness is straightforward, we prove knowledge soundness below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The extractor simulates execution with the adversary <span class="math">(\\mathcal{A},\\mathsf{P}^{<em>})</span> and return <span class="math">\\mathsf{P}^{</em>}</span>'s output. Conditioned on the verifier accepts, let <span class="math">\\mathsf{w} = (\\tau ,\\mathbf{m}_{\\tau})</span> be the extractor's output. Suppose <span class="math">\\mathsf{w}</span> is not valid for <span class="math">\\mathcal{R}_{\\mathbf{rg}}^{\\prime}</span>, then either (i) <span class="math">\\mathbf{m}_{\\tau}</span> is an invalid opening or <span class="math">\\mathbf{m}_{\\tau} \\notin \\mathcal{M}^{n}</span>, which happens with probability at most <span class="math">\\epsilon_{\\mathrm{mon},1}</span>; or (ii) <span class="math">\\mathbf{m}_{\\tau}</span> is a valid opening within <span class="math">\\mathcal{M}^n</span>, but <span class="math">\\tau \\notin (-d&#x27;,d&#x27;)^n</span> or <span class="math">\\mathbf{m}_{\\tau} \\notin \\mathsf{EXP}(\\tau)</span>. By Lemma 2.2, we have <span class="math">\\mathsf{ct}(\\psi \\cdot \\mathbf{m}_{\\tau} - \\tau) \\neq \\mathbf{0}^n</span>. Note that verifier accepts and <span class="math">\\mathsf{w}</span> is valid for <span class="math">\\mathcal{R}&#x27;</span>, so <span class="math">\\mathsf{ct}(\\psi \\cdot b) = a</span> where <span class="math">a = \\langle \\tau ,\\mathsf{tensor}(\\mathbf{r})\\rangle</span>, <span class="math">\\mathsf{ct}(\\psi \\cdot b) = \\langle \\mathsf{ct}(\\psi \\cdot \\mathbf{m}_{\\tau}),\\mathsf{tensor}(\\mathbf{r})\\rangle</span>. By the binding property and Lemma 2.6 (over <span class="math">\\mathcal{C}</span>), this happens with probability at most $\\epsilon_{\\mathrm{bind}} + \\log n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In sum, with probability at most </span>\\epsilon_{\\mathbf{rg}}^{\\prime}<span class="math">, the adversary succeeds while the extractor&#x27;s output is invalid for </span>\\mathcal{R}_{\\mathbf{rg}}^{\\prime}$. Thus the claim holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we are ready to prove that a committed ring vector <span class="math">\\mathbf{f} \\in R_q^n</span> lies within a specific range. Naively, we can commit to the coefficient vectors <span class="math">\\operatorname{cf}(\\mathbf{f}) \\in \\mathbb{Z}_q^{n \\times d}</span> and run the above protocol in parallel <span class="math">d</span> times. However, this incurs high communication costs, as the input includes <span class="math">d</span> commitments of total size <span class="math">R_q^{\\kappa \\times d}</span>, which affects verifier circuit complexity for the Fiat-Shamir transform. To address this, we optimize communication via double commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. Given <span class="math">\\mathbf{f} \\in R_q^n</span> where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B = (d')^k$, denote by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {D} _ {\\mathbf {f}} = \\left[ \\mathbf {D} _ {\\mathbf {f}, 0}, \\dots , \\mathbf {D} _ {\\mathbf {f}, k - 1} \\right] = \\mathbf {G} _ {d ^ {\\prime}, k} ^ {- 1} (\\operatorname {c f} (\\mathbf {f})) \\in \\mathbb {Z} _ {q} ^ {n \\times d k} \\tag {13}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the decomposition matrix of <span class="math">\\operatorname{cf}(\\mathbf{f})</span> so that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{D}_{\\mathbf{f}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; d^{\\prime}<span class="math">. Here </span>\\mathbf{D}_{\\mathbf{f},i}\\in \\mathbb{Z}_q^{n\\times d}<span class="math"> for all </span>i\\in [k]<span class="math">. Let </span>\\mathbf{M}_{\\mathbf{f}}\\in \\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}})\\subseteq \\mathcal{M}^{n\\times dk}<span class="math">. Consider the double commitment </span>\\mathsf{dcom}(\\mathbf{M}_{\\mathbf{f}}) = \\mathsf{com}(\\tau_{\\mathbf{D}})<span class="math"> where </span>\\tau_{\\mathbf{D}}\\coloneqq \\mathsf{split}(\\mathsf{com}(\\mathbf{M}_{\\mathbf{f}}))\\in (-d',d')^n<span class="math"> is the decomposed version of </span>\\mathsf{com}(\\mathbf{M}_{\\mathbf{f}})<span class="math">. Let </span>\\mathbf{m}_{\\tau}\\in \\mathsf{EXP}(\\tau_{\\mathbf{D}})\\subseteq \\mathcal{M}^n$. We consider a range-check relation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {r g}, B} := \\left\\{\\left(\\mathbb {x}, \\mathbb {w}\\right): \\begin{array}{l} \\mathbb {x} = \\left(\\operatorname {c m} _ {\\mathbf {f}}, C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\operatorname {c m} _ {\\mathbf {m} _ {\\tau}} \\in R _ {q} ^ {\\kappa}\\right), \\\\ \\mathbb {w} = \\left[ \\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}, \\mathbf {f}, \\mathbf {M} _ {\\mathbf {f}} \\right] \\in \\mathbb {Z} _ {q} ^ {n} \\times R _ {q} ^ {n \\times (2 + d k)} \\quad \\text {s . t .} \\\\ \\operatorname {c f} (\\mathbf {f}) \\in (- B, B) ^ {n \\times d} \\wedge \\left(C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\mathbf {M} _ {\\mathbf {f}}\\right) \\in \\mathcal {R} _ {\\mathrm {m}, \\mathrm {i n}} \\\\ \\left(\\mathbf {M} _ {\\mathbf {f}} \\in \\operatorname {E X P} \\left(\\mathbf {D} _ {\\mathbf {f}}\\right)\\right) \\wedge \\left(\\left(C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\operatorname {c m} _ {\\mathbf {m} _ {\\tau}}\\right), \\left(\\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}\\right)\\right) \\in \\mathcal {R} _ {\\mathrm {r g}} ^ {\\prime} \\\\ \\left(C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\left(\\tau_ {\\mathbf {D}}, \\mathbf {M} _ {\\mathbf {f}}\\right)\\right) \\in \\mathcal {R} _ {\\text {d o p e n}, d k} \\end{array} \\right\\} \\tag {14}</span></div>

    <p class="text-gray-300">The reduction of knowledge is from <span class="math">\\mathcal{R}_{\\mathbf{rg},B}</span> to the output relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {d c o m}} := \\left\\{\\left(\\mathbb {x}, \\mathbb {w}\\right): \\begin{array}{l} \\mathbb {x} = \\left(\\operatorname {c m} _ {\\mathbf {f}}, C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\operatorname {c m} _ {\\mathbf {m} _ {\\tau}} \\in R _ {q} ^ {\\kappa}, \\mathbf {r} \\in \\mathcal {C} ^ {\\log n}, \\mathbf {e} \\in R _ {q} ^ {3 + d k}\\right), \\\\ \\mathbb {w} = \\left[ \\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}, \\mathbf {f}, \\mathbf {M} _ {\\mathbf {f}} \\right] \\in \\mathbb {Z} _ {q} ^ {n} \\times R _ {q} ^ {n \\times (2 + d k)} \\quad \\text {s . t .} \\\\ \\left[ \\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}, \\mathbf {f}, \\mathbf {M} _ {\\mathbf {f}} \\right] ^ {\\top} \\operatorname {t e n s o r} (\\mathbf {r}) = \\mathbf {e} \\\\ \\left(\\operatorname {c m} _ {\\mathbf {f}}, \\mathbf {f}\\right) \\in \\mathcal {R} _ {\\text {o p e n}} \\wedge \\left(\\operatorname {c m} _ {\\mathbf {m} _ {\\tau}}, \\mathbf {m} _ {\\tau}\\right) \\in \\mathcal {R} _ {\\text {o p e n}} \\\\ \\left(C _ {\\mathbf {M} _ {\\mathbf {f}}}, \\left(\\tau_ {\\mathbf {D}}, \\mathbf {M} _ {\\mathbf {f}}\\right)\\right) \\in \\mathcal {R} _ {\\text {d o p e n}, d k} \\end{array} \\right\\} \\tag {15}</span></div>

    <p class="text-gray-300">In words, given instance the commitment <span class="math">\\mathsf{cm}_{\\mathbf{f}}</span>, the helper commitments <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span>, the witness <span class="math">\\mathbf{f}</span>, and the helper witness vectors <span class="math">\\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}</span> and matrix <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>, the relation <span class="math">\\mathcal{R}_{\\mathbf{rg},B}</span> checks</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{f}</span> is an opening to <span class="math">\\mathsf{cm}_{\\mathbf{f}}</span>;</li>

      <li><span class="math">\\mathbf{m}_{\\tau}</span> and <span class="math">(\\tau_{\\mathbf{D}},\\mathbf{M}_{\\mathbf{f}})</span> are openings to <span class="math">\\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span> and <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> respectively;</li>

      <li><span class="math">\\mathbf{M}_{\\mathbf{f}}</span> is in <span class="math">\\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}})\\subseteq\\mathcal{M}^{n\\times dk}</span> and <span class="math">\\mathbf{m}_{\\tau}</span> is in <span class="math">\\mathsf{EXP}(\\tau_{\\mathbf{D}})\\subseteq\\mathcal{M}^{n}</span> (<span class="math">\\mathsf{EXP}(\\cdot)</span> is defined in (3));</li>

      <li><span class="math">\\tau_{\\mathbf{D}}</span> is a <span class="math">\\mathbb{Z}_{q}</span>-vector in <span class="math">(-d^{\\prime},d^{\\prime})^{n}</span>;</li>

      <li>the coefficients of <span class="math">\\mathbf{f}</span> lie within <span class="math">(-B,B)</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{rg},B}</span> is equivalent to a simpler relation that only checks <span class="math">(i)</span> and <span class="math">(v)</span> for instance <span class="math">\\mathsf{cm}_{\\mathbf{f}}</span> and witness <span class="math">\\mathbf{f}</span>, but we put all helper information into the statement to simplify the protocol and their analysis.</p>

    <p class="text-gray-300">Similarly, the output relation <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span> checks that, for instance <span class="math">(\\mathsf{cm}_{\\mathbf{f}},C_{\\mathbf{M}_{\\mathbf{f}}},\\mathsf{cm}_{\\mathbf{m}_{\\tau}},\\mathbf{r},\\mathbf{e})</span>, the witnesses <span class="math">\\mathbf{f},\\mathbf{m}_{\\tau}</span> are openings to <span class="math">\\mathsf{cm}_{\\mathbf{f}},\\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span> and <span class="math">(\\tau_{\\mathbf{D}},\\mathbf{M}_{\\mathbf{f}})</span> is an opening to <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span>, and the matrix-vector product <span class="math">[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{M}_{\\mathbf{f}}]^{\\top}\\mathsf{tensor}(\\mathbf{r})=\\mathbf{e}</span> holds.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">The protocol.</h4>

    <p class="text-gray-300">Intuitively, the protocol <span class="math">\\Pi_{\\mathsf{rgchk}}</span> does the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>check that <span class="math">\\mathbf{M}_{\\mathbf{f}}\\in\\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}})</span> and <span class="math">\\mathbf{m}_{\\tau}\\in\\mathsf{EXP}(\\tau_{\\mathbf{D}})</span> are well-formed via the monomial set tests;</li>

      <li>verify that each entry of <span class="math">\\mathsf{cf}(\\mathbf{f})</span>, <span class="math">\\tau_{\\mathbf{D}}</span> matches the constant term of the corresponding entry in <span class="math">\\sum_{i\\in[k]}d^{\\prime i}\\cdot(\\psi\\cdot\\mathbf{M}_{\\mathbf{f},i})</span> and <span class="math">\\psi\\cdot\\mathbf{m}_{\\tau}</span>; by Lemma 2.2, this implies that <span class="math">\\mathsf{cf}(\\mathbf{f})</span>, <span class="math">\\tau_{\\mathbf{D}}</span> are within the ranges.</li>

    </ol>

    <h6 id="sec-35" class="text-base font-medium mt-4">Construction 4.4.</h6>

    <p class="text-gray-300">On input <span class="math">\\mathsf{z}=(\\mathsf{cm}_{\\mathbf{f}},C_{\\mathbf{M}_{\\mathbf{f}}},\\mathsf{cm}_{\\mathbf{m}_{\\tau}})\\in R_{q}^{\\kappa\\times 3}</span>, <span class="math">\\mathsf{w}=[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{M}_{\\mathbf{f}}]\\in\\mathbb{Z}_{q}^{n}\\times R_{q}^{n\\times(2+dk)}</span> where <span class="math">(\\mathsf{z},\\mathsf{w})\\in\\mathcal{R}_{\\mathsf{rg},B}</span>, the protocol <span class="math">\\Pi_{\\mathsf{rgchk}}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run a batched protocol <span class="math">\\Pi_{\\mathsf{mon}}</span> (Construction 4.2) w.r.t. <span class="math">\\mathbf{M}_{\\mathbf{f}}=[\\mathbf{M}_{\\mathbf{f},0}\\in R_{q}^{n\\times d},\\ldots,\\mathbf{M}_{\\mathbf{f},k-1}]\\in\\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}})\\subseteq\\mathcal{M}^{n\\times dk}</span> and <span class="math">\\mathbf{m}_{\\tau}\\in\\mathsf{EXP}(\\tau_{\\mathbf{D}})\\subseteq\\mathcal{M}^{n}</span>. The output statements are</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{z}=(\\mathsf{cm}_{\\mathbf{m}_{\\tau}},\\mathbf{r},b\\in R_{q}),\\mathsf{w}=\\mathbf{m}_{\\tau})\\in\\mathcal{R}_{\\mathsf{m,out}}</span> <span class="math">(\\mathsf{z}=(C_{\\mathbf{M}_{\\mathbf{f}}},\\mathbf{r},\\mathbf{e}\\in R_{q}^{dk}),\\mathsf{w}=\\mathbf{M}_{\\mathbf{f}})\\in\\mathcal{R}_{\\mathsf{m,out}}</span></p>

    <p class="text-gray-300">where <span class="math">b=\\langle\\mathbf{m}_{\\tau},\\mathsf{tensor}(\\mathbf{r})\\rangle</span>. For every <span class="math">i\\in[k]</span>, denote by</p>

    <p class="text-gray-300"><span class="math">\\mathbf{u}_{i}:=(\\mathbf{M}_{\\mathbf{f},i})^{\\top}\\mathsf{tensor}(\\mathbf{r})=\\mathbf{e}[di,d(i+1))\\in R_{q}^{d}\\,.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}\\to\\mathsf{V}</span> : Send <span class="math">\\mathbf{v}:=\\mathsf{cf}(\\mathbf{f})^{\\top}\\mathsf{tensor}(\\mathbf{r})\\in\\mathcal{C}^{d}</span> and <span class="math">a:=\\langle\\tau_{\\mathbf{D}},\\mathsf{tensor}(\\mathbf{r})\\rangle\\in\\mathcal{C}</span></li>

      <li><span class="math">\\mathsf{V}</span> : Let <span class="math">\\psi:=\\sum_{i\\in[1,d^{\\prime})}i\\cdot(X^{-i}+X^{i})\\in R_{q}</span>. Check that <span class="math">\\mathsf{ct}(\\psi\\cdot b)\\stackrel{{\\scriptstyle?}}{{=}}a</span> and</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{ct}\\left(\\psi\\cdot(\\mathbf{u}_{0}+d^{\\prime}\\mathbf{u}_{1}+\\cdots+d^{\\prime k-1}\\mathbf{u}_{k-1})\\right)\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{v}</span> (16)</p>

    <p class="text-gray-300">Abort and return <span class="math">\\bot</span> if the checks fail.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote by <span class="math">\\hat{v}:=\\sum_{i\\in[d]}\\mathbf{v}_{i}X^{i}\\in R_{q}</span>. Return the reduced statement</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{z}_{o}=(\\mathsf{cm_{f}},C_{\\mathbf{M_{f}}},\\mathsf{cm_{m_{\\tau}}},\\mathbf{r},(a,b,\\hat{v},\\mathbf{u}_{0},\\ldots,\\mathbf{u}_{k-1})),\\mathsf{\\omega}_{o}=[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{M_{f}}])\\in\\mathcal{R}_{\\mathsf{dcom}}\\,.</span></p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 4.4.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathsf{rgchk}}</span> can be extended to support multiple input instances by batching the executions of <span class="math">\\Pi_{\\mathsf{mon}}</span> as described in Remark 4.2.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathsf{rgchk}}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{rg},B}</span> to <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Public reducibility is trivial. The claim follows from the lemmas below. ∎</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 4.6.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathsf{rgchk}}</span> is perfectly complete.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For every input statement in <span class="math">\\mathcal{R}_{\\mathsf{rg},B}</span>, we show that the verifier checks pass and the prover’s output is in <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span>.</p>

    <p class="text-gray-300">First, the prover’s output is in <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span>: <span class="math">\\{\\mathbf{u}_{i}\\}_{i\\in[k]}</span>, <span class="math">a</span>, <span class="math">b</span> sent by the honest prover are exactly the claimed values in <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span>. And the sent <span class="math">\\mathbf{v}</span> satisfies that <span class="math">\\mathbf{v}=\\mathsf{cf}(\\mathbf{f})^{\\top}\\mathsf{tensor}(\\mathbf{r})</span>. Thus, <span class="math">\\hat{v}:=\\sum_{i\\in[d]}\\mathbf{v}_{i}X^{i}=\\langle\\mathbf{f},\\mathsf{tensor}(\\mathbf{r})\\rangle</span> as required given that <span class="math">\\mathsf{tensor}(\\mathbf{r})</span> is in <span class="math">\\mathcal{C}^{n}=\\mathbb{Z}_{q}^{n}</span>.</p>

    <p class="text-gray-300">Next, we show that the verifier accepts: First, <span class="math">\\mathbf{m}_{\\tau}</span> is in <span class="math">\\mathsf{EXP}(\\tau_{\\mathbf{D}})\\subseteq\\mathcal{M}^{n}</span> and the matrix <span class="math">\\mathbf{M_{f}}</span> is in <span class="math">\\mathsf{EXP}(\\mathbf{D_{f}})\\subseteq\\mathcal{M}^{n\\times dk}</span>. By completeness of <span class="math">\\Pi_{\\mathsf{mon}}</span>, the monomial set checks pass. Also note that <span class="math">\\tau_{\\mathbf{D}}\\in(-d^{\\prime},d^{\\prime})^{n}</span>, by Lemma 2.2, we have <span class="math">\\mathsf{ct}(\\psi\\cdot\\mathbf{m}_{\\tau})=\\tau_{\\mathbf{D}}</span>. Since <span class="math">\\mathsf{tensor}(\\mathbf{r})\\in\\mathcal{C}^{n}=\\mathbb{Z}_{q}^{n}</span>, we have <span class="math">\\mathsf{ct}(\\psi\\cdot b)=a</span>. By definition of the decomposed matrix <span class="math">\\mathbf{D_{f}}</span>, with a similar argument, Eq. (16) holds and thus the verifier accepts. ∎</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Lemma 4.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathsf{com}\\left(\\cdot\\right)</span> is binding with binding error <span class="math">\\epsilon_{\\mathsf{bind}}</span>, then <span class="math">\\Pi_{\\mathsf{rgchk}}</span> is knowledge sound with knowledge error $\\epsilon_{\\mathsf{rg}}:=\\epsilon_{\\mathsf{mon},dk+1}+\\epsilon_{\\mathsf{bind}}+\\log n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}</span> simulates the execution with adversary <span class="math">(\\mathcal{A},\\mathsf{P}^{<em>})</span> and returns <span class="math">\\mathsf{P}^{</em>}</span>’s output witness if the verifier accepts. Otherwise <span class="math">\\mathsf{Ext}</span> returns <span class="math">\\bot</span>. It is clear that <span class="math">\\mathsf{Ext}</span> has polynomial time complexity.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{z}</span>, <span class="math">\\mathsf{z}_{o}</span> denote the instances for the input and output relations. Conditioned on the verifier accepts, let <span class="math">\\mathsf{\\omega}=(\\mathbf{f},\\mathbf{M_{f}},\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau})</span> be the extractor’s output. Suppose <span class="math">(\\mathsf{z},\\mathsf{\\omega})</span> is not in <span class="math">\\mathcal{R}_{\\mathsf{rg},B}</span> but <span class="math">(\\mathsf{z}_{o},\\mathsf{\\omega})</span> is in <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span>. Consider two cases.</p>

    <p class="text-gray-300">Case 1: <span class="math">\\mathbf{M_{f}}\\in R_{q}^{n\\times dk}</span> or <span class="math">\\mathbf{m}_{\\tau}\\in R_{q}^{n}</span> are invalid openings, or some of their entries are outside the monomial set. By knowledge soundness of <span class="math">\\Pi_{\\mathsf{mon}}</span>, this happens with probability at most <span class="math">\\epsilon_{\\mathsf{mon},dk+1}</span>.</p>

    <p class="text-gray-300">Case 2: <span class="math">\\mathbf{M_{f}}</span> is in <span class="math">\\mathcal{M}^{n\\times dk}</span> and <span class="math">\\mathbf{m}_{\\tau}</span> is in <span class="math">\\mathcal{M}^{n}</span> and they are valid openings, but</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cf}(\\mathbf{f})\\notin(-B,B)^{n\\times d}\\ \\vee\\ \\tau_{\\mathbf{D}}\\notin(-d^{\\prime},d^{\\prime})^{n}\\ \\vee\\ \\mathbf{M_{f}}\\notin\\mathsf{EXP}(\\mathbf{D_{f}})\\ \\vee\\ \\mathbf{m}_{\\tau}\\notin\\mathsf{EXP}(\\tau)\\,.</span></p>

    <p class="text-gray-300">For all <span class="math">i\\in[k]</span>, let <span class="math">\\mathbf{M_{f},}_{i}\\in\\mathcal{M}^{n\\times d}</span> be the <span class="math">(di+1)</span>-th to <span class="math">(di+d)</span>-th columns of <span class="math">\\mathbf{M_{f}}</span>. By Lemma 2.2, we have <span class="math">\\mathsf{ct}(\\psi\\cdot\\mathbf{m}_{\\tau}-\\tau_{\\mathbf{D}})\\neq\\mathbf{0}^{n}</span> or</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ct}\\left(\\psi\\cdot(\\mathbf{M_{f},}_{0}+d^{\\prime}\\mathbf{M_{f},}_{1}+\\cdot+d^{\\prime k-1}\\mathbf{M_{f},}_{k-1}))\\right)\\neq\\mathsf{cf}(\\mathbf{f})\\,.</span></p>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">(\\mathbb{Z}_o,\\mathbb{W})</span> is in <span class="math">\\mathcal{R}_{\\mathrm{dcom}}</span> and the verification passed, so <span class="math">\\mathsf{ct}(\\psi \\cdot b) = a</span> and (16) holds, where <span class="math">a = \\langle \\tau_{\\mathbf{D}},\\mathrm{tensor}(\\mathbf{r})\\rangle</span> and <span class="math">\\mathsf{ct}(\\psi \\cdot b) = \\langle \\mathsf{ct}(\\psi \\cdot \\mathbf{m}_{\\tau}),\\mathrm{tensor}(\\mathbf{r})\\rangle</span>. By the binding property of <span class="math">\\mathsf{com}(\\cdot)</span> and Lemma 2.6, this happens with probability at most $\\epsilon_{\\mathrm{bind}} + \\log n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In sum, the knowledge error is </span>\\epsilon_{\\mathrm{rg}} = \\epsilon_{\\mathrm{mon},dk + 1} + \\epsilon_{\\mathrm{bind}} + \\log n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-43" class="text-2xl font-bold">4.4 Commitment transformation</h2>

    <p class="text-gray-300">Double commitments are not linearly homomorphic, thus statements involving double commitments are hard to fold using random linear combinations. This section introduces a technique that simplifies such statements by reducing them to statements involving only linear commitments to smaller witnesses. The core idea is to use sumchecks to ensure consistency between the double commitment of a large witness matrix <span class="math">\\mathbf{M}_{\\mathbf{f}}</span> and a linear commitment to a folded version of <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Specifically, let <span class="math">B \\coloneqq (d&#x27;)^k</span> where <span class="math">k \\in \\mathbb{N}</span>. Fix <span class="math">b \\in \\mathbb{N}</span> and folding challenge set <span class="math">\\bar{S} \\subset R_q</span> such that <span class="math">\\mathsf{com}(\\cdot)</span> is <span class="math">(b, S \\coloneqq \\bar{S} - \\bar{S})</span>-binding and $b \\geq 2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{S}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op}}(d' + 1 + B + dk)<span class="math">. The protocol </span>\\Pi_{\\mathsf{cm}}<span class="math"> reduces relation </span>\\mathcal{R}_{\\mathsf{rg},B}$ from (14) to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {c o m}} := \\left\\{(z, w): \\begin{array}{l l} z = \\left(\\mathrm {c m} _ {\\mathbf {g}} \\in R _ {q} ^ {\\kappa}, \\mathbf {r} _ {o} \\in \\mathrm {M} _ {\\mathcal {C}} ^ {\\log n}, v _ {o} \\in \\mathrm {M} _ {q}\\right), &amp; w = \\mathbf {g} \\in R _ {q} ^ {n} \\text {s . t .} \\\\ \\langle \\mathbf {g}, \\operatorname {t e n s o r} (\\mathbf {r} _ {o}) \\rangle = v _ {o} \\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {g} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   b / 2 \\wedge (\\mathrm {c m} _ {\\mathbf {g}}, \\mathbf {g}) \\in \\mathcal {R} _ {\\mathrm {o p e n}} \\end{array} \\right\\} \\tag {17}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{M}_{\\mathcal{C}} := \\mathcal{C} \\times \\mathcal{C}</span> and <span class="math">\\mathsf{M}_q := R_q \\times R_q</span>. We can understand <span class="math">\\mathcal{R}_{\\mathrm{com}}</span> as a special case of the general linear relation <span class="math">\\mathcal{R}_{\\mathrm{lin},b/2}</span>, where the only linear check is the evaluation statement <span class="math">\\langle \\mathbf{g}, \\text{tensor}(\\mathbf{r}_o) \\rangle = v_o</span>.</p>

    <p class="text-gray-300"><strong>Why a double commitment and its transformation?</strong> One may attempt to avoid commitment transformation by flattening the matrix <span class="math">\\mathbf{M}_{\\mathbf{f}}</span> to a vector <span class="math">\\mathbf{f}_{\\mathbf{M}} \\in R_q^{n \\cdot dk}</span> and directly commit to <span class="math">\\mathbf{f}_{\\mathbf{M}}</span> via a linear commitment. However, this approach is infeasible for folding schemes, because after each folding step, one needs to range-check more and more integer elements in the witness. For example, in the first folding step, we need to range-check a witness vector of <span class="math">n</span> elements in <span class="math">R_q</span>. After the folding, the output witness now consists of <span class="math">ndk</span> <span class="math">R_q</span>-elements, which requires a range-proof again in a later folding step. This introduces a blowup of <span class="math">dk</span> in the witness size after each folding step.</p>

    <p class="text-gray-300"><strong>The protocol <span class="math">\\Pi_{\\mathrm{cm}}</span>.</strong> The protocol <span class="math">\\Pi_{\\mathrm{cm}}</span>, which we describe next, is the central protocol that we use in the next section to construct our folding scheme. It uses the range check protocol <span class="math">\\Pi_{\\mathrm{rgchk}}</span> from the previous section as a subroutine.</p>

    <p class="text-gray-300">At a high level, the protocol takes as input a double commitment <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> to the matrix <span class="math">\\mathbf{M}_{\\mathbf{f}}</span> (plus some auxiliary information), and the goal is to reduce the checking of the double commitment to that of a linear commitment <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span>, where the opening <span class="math">\\mathbf{g} \\approx \\mathbf{M}_{\\mathbf{f}} \\mathbf{s}&#x27;</span> is a random linear combination of <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>'s columns and some auxiliary vectors. (Here <span class="math">\\mathbf{s}&#x27;</span> is the folding challenge.) Towards this, the verifier sends <span class="math">\\mathbf{s}&#x27;</span> and the prover replies with <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span>. Further,</p>

    <p class="text-gray-300">the verifier needs to check that <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span> and <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> are consistent, that is, there exists a witness <span class="math">\\mathsf{com}(\\mathbf{M}_{\\mathbf{f}})</span>, which are the <span class="math">dk</span> linear commitments to the <span class="math">dk</span> columns of <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>, such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{cm}_{\\mathbf{g}}</span> is the correct random linear combination of <span class="math">\\mathsf{com}(\\mathbf{M}_{\\mathbf{f}})</span>'s columns (and some auxiliary vector commitments) with respect to <span class="math">\\mathbf{s}&#x27;</span>;</li>

      <li>the decomposed vector <span class="math">\\tau_{\\mathbf{D}} = \\mathsf{split}(\\mathsf{com}(\\mathbf{M}_{\\mathbf{f}}))</span> is a valid opening of <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span>, when viewing <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> as a linear commitment.</li>

    </ol>

    <p class="text-gray-300">The protocol <span class="math">\\Pi_{\\mathsf{cm}}</span> proves the above two relations efficiently via sumchecks.</p>

    <p class="text-gray-300">For simplicity, assume that <span class="math">n = \\kappa d^2 k\\ell</span> and <span class="math">\\kappa, k, \\ell, d</span> are powers of two (in Remark 4.8 we explain how to support smaller <span class="math">n</span>). Recall that <span class="math">\\mathsf{split}: R_q^{\\kappa \\times dk} \\to (-d&#x27;, d&#x27;)^n</span> is the injective map defined in Section 4.1 that decomposes a matrix in <span class="math">R_q^{\\kappa \\times dk}</span> to a low-norm vector in <span class="math">(-d, d&#x27;)^n</span>; and <span class="math">\\mathsf{pow}: (-d&#x27;, d&#x27;)^n \\to R_q^{\\kappa \\times dk}</span> is the map such that <span class="math">\\mathsf{pow}(\\mathsf{split}(\\mathbf{D})) = \\mathbf{D}</span> for all <span class="math">\\mathbf{D} \\in R_q^{\\kappa \\times dk}</span>.</p>

    <p class="text-gray-300"><strong>Construction 4.5.</strong> The protocol takes as input an instance-witness pair <span class="math">(\\mathbb{X},\\mathbb{W})\\in \\mathcal{R}_{\\mathrm{rg},B}</span> where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {x} = \\left(\\operatorname {c m} _ {\\mathbf {f}}, C _ {\\mathbf {M} _ {\\mathbf {f}}} = \\operatorname {c o m} \\left(\\tau_ {\\mathbf {D}}\\right), \\operatorname {c m} _ {\\mathbf {m} _ {\\tau}}\\right) \\in R _ {q} ^ {\\kappa \\times 3}, \\quad \\mathbb {w} = \\left[ \\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}, \\mathbf {f}, \\mathbf {M} _ {\\mathbf {f}} \\right] \\in \\mathbb {Z} _ {q} ^ {n} \\times \\left(R _ {q} ^ {n}\\right) ^ {2} \\times R _ {q} ^ {n \\times d k}</span></div>

    <p class="text-gray-300">and <span class="math">\\mathbf{m}_{\\tau}, \\mathbf{M}_{\\mathbf{f}}</span> satisfy <span class="math">\\mathbf{m}_{\\tau} \\in \\mathsf{EXP}(\\tau_{\\mathbf{D}}) \\subseteq \\mathcal{M}^{n}</span> and <span class="math">\\mathbf{M}_{\\mathbf{f}} \\in \\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}}) \\subseteq \\mathcal{M}^{n \\times dk}</span>. Here <span class="math">\\mathbf{D}_{\\mathbf{f}}</span> is a decomposition of <span class="math">\\mathbf{f}</span> as defined as in (13). The protocol <span class="math">\\Pi_{\\mathsf{cm}}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}: \\text{Run } \\Pi_{\\mathrm{rgchk}}</span> to reduce the input statement in <span class="math">\\mathcal{R}_{\\mathrm{rg},B}</span> to that in <span class="math">\\mathcal{R}_{\\mathrm{dcom}}</span> from (15). Let <span class="math">\\mathbf{r} \\in \\mathcal{C}^{\\log n}</span> and <span class="math">\\mathbf{e} \\in R_q^{3 + dk}</span> be the challenge and evaluations.</li>

      <li><span class="math">\\mathsf{V} \\to \\mathsf{P}</span>: Send folding challenges <span class="math">\\mathbf{s} \\xleftarrow{\\mathrm{e}} \\bar{S}^3</span> and <span class="math">\\mathbf{s}&#x27; \\xleftarrow{\\mathrm{e}} \\bar{S}^{dk}</span>.</li>

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span>: Send <span class="math">\\mathsf{com}(\\mathbf{h}) := \\mathsf{com}(\\mathbf{M}_{\\mathbf{f}})\\mathbf{s}&#x27; = \\mathsf{com}(\\mathbf{M}_{\\mathbf{f}}\\mathbf{s}&#x27;) \\in R_q^\\kappa</span>.</li>

      <li><span class="math">\\mathsf{V} \\to \\mathsf{P}</span>: Send challenges <span class="math">(\\mathbf{c}^{(0)}, \\mathbf{c}^{(1)}) \\xleftarrow{\\mathrm{e}} \\mathcal{C}^{\\log \\kappa} \\times \\mathcal{C}^{\\log \\kappa}</span>.</li>

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}</span>: Run two sumcheck protocols in parallel, where each of them checks the same sumcheck claims below in a batch via random linear combination (c.f. Remark 2.6) <span class="math">^8</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">u \\coloneqq \\langle \\mathbf{e}[3, 3 + dk), \\mathbf{s}&#x27; \\rangle \\in R_q</span>; the relation to be checked is</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\tau_ {\\mathbf {D}}, \\mathbf {m} _ {\\tau}, \\mathbf {f}, \\mathbf {h} \\right] ^ {\\top} \\cdot \\operatorname {t e n s o r} (\\mathbf {r}) \\stackrel {?} {=} (\\mathbf {e} [ 0, 2 ], u). \\tag {18}</span></div>

    <p class="text-gray-300">This left hand side represents four sums each over <span class="math">n</span> elements. Each sum can be compared to the corresponding value on the right hand side using a degree-2 sumcheck claim that uses the multilinear extensions of <span class="math">\\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}, \\mathbf{f}, \\mathbf{h}</span> and tensor(\\mathbf{r}) In total, (18) represents four sumcheck claims.</p>

    <p class="text-gray-300"><span class="math">^7</span>In practice, a standard implementation will set <span class="math">\\mathbf{m}_{\\tau} := \\exp(\\tau)</span> and <span class="math">\\mathbf{M}_{\\mathbf{f}} := \\exp(\\mathbf{D}_{\\mathbf{f}})</span>.</p>

    <p class="text-gray-300"><span class="math">^8</span>The two parallel sumcheck executions use independent verifier challenges.</p>

    <p class="text-gray-300">26</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">z \\in [2]</span>, define a vector <span class="math">\\mathbf{t}^{(z)} \\in R_q^n</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{t}^{(z)} = \\operatorname{tensor}\\left(\\mathbf{c}^{(z)}\\right) \\otimes \\mathbf{s}&#x27; \\otimes \\left(1, d&#x27;, \\dots, d&#x27;^{\\ell-1}\\right) \\otimes \\left(1, X, \\dots, X^{d-1}\\right). \\tag{19}</span></div>

    <p class="text-gray-300">Let <span class="math">\\widetilde{\\mathbf{t}^{(z)}}</span> denote <span class="math">\\mathbf{t}^{(z)}</span>'s multilinear extension which can be evaluated by the verifier in time <span class="math">O(\\log \\kappa + dk + \\ell)</span>. Check the two degree-2 sumcheck claims:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n]} \\widetilde{\\tau_{\\mathbf{D}}} (\\langle i \\rangle) \\cdot \\widetilde{\\mathbf{t}^{(z)}} (\\langle i \\rangle) \\stackrel{?}{=} \\langle \\operatorname{tensor}(\\mathbf{c}^{(z)}), \\operatorname{com}(\\mathbf{h}) \\rangle \\in R_q \\quad \\text{for } z = 0, 1. \\tag{20}</span></div>

    <p class="text-gray-300">If <span class="math">\\tau_{\\mathbf{D}} \\in (-d&#x27;, d&#x27;)^n</span>, this is equivalent to checking that (See Remark 4.5)</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\operatorname{tensor}(\\mathbf{c}^{(z)}), \\operatorname{pow}(\\tau_{\\mathbf{D}}) \\mathbf{s}&#x27; \\rangle \\stackrel{?}{=} \\langle \\operatorname{tensor}(\\mathbf{c}^{(z)}), \\operatorname{com}(\\mathbf{h}) \\rangle. \\tag{21}</span></div>

    <p class="text-gray-300">In total, (20) represents two sumcheck claims.</p>

    <p class="text-gray-300">The verifier can verify all six sumcheck claims from (18) and (20) as a batch using the sumcheck batching technique from Remark 2.5 and Remark 2.6. In Remark 4.6 we explain that these six sumchecks can be treated as <span class="math">6d</span> sumcheck claims over <span class="math">\\mathbb{Z}_q</span> that can all be compressed into a single sumcheck over <span class="math">\\mathbb{Z}_q</span> (or an extension field of <span class="math">\\mathbb{Z}_q</span>) via random linear combination (c.f. Remark 2.6).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> run two parallel sumcheck protocols for this single batch claim. The need for two parallel sumchecks is explained in Remark 4.9. Let <span class="math">\\mathbf{r}_o \\xleftarrow{\\circ} (\\mathcal{C} \\times \\mathcal{C})^{\\log n}</span> denote the corresponding sumcheck challenges. Then, since <span class="math">\\mathsf{V}</span> can evaluate <span class="math">eq(\\mathbf{r}, \\cdot)</span>, <span class="math">\\widetilde{\\mathbf{t}^{(0)}}</span>, <span class="math">\\widetilde{\\mathbf{t}^{(1)}}</span> at both <span class="math">\\mathcal{C}^{\\log n}</span> points in <span class="math">\\mathbf{r}_o</span> by itself, the two sumcheck executions reduce to the evaluation claims</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}, \\mathbf{f}, \\mathbf{h} \\right]^{\\top} \\cdot \\operatorname{tensor}(\\mathbf{r}_o) \\stackrel{?}{=} \\mathbf{e}_o \\tag{22}</span></div>

    <p class="text-gray-300">for some <span class="math">\\mathbf{e}_o \\in (R_q \\times R_q)^4</span>, where <span class="math">\\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}, \\mathbf{f}, \\mathbf{h} \\in R_q^n</span> are the committed witnesses. These are eight evaluation claims: a claim for each of <span class="math">\\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}, \\mathbf{f}, \\mathbf{h}</span> for each of the two points in <span class="math">\\mathbf{r}_o</span>. The next two steps aggregate these eight claims into two claims.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span>: Compute <span class="math">\\mathsf{cm}_{\\mathbf{g}} \\in R_q^{\\kappa}</span> and <span class="math">v_o \\in R_q^2</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{cm}_{\\mathbf{g}}, v_o) := \\mathbf{s}_0 \\cdot (C_{\\mathbf{M}_{\\mathbf{f}}}, \\mathbf{e}_{o,0}) + \\mathbf{s}_1 \\cdot (\\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathbf{e}_{o,1}) + \\mathbf{s}_2 \\cdot (\\mathsf{cm}_{\\mathbf{f}}, \\mathbf{e}_{o,2}) + (\\mathsf{com}(\\mathbf{h}), \\mathbf{e}_{o,3}) \\in R_q^{\\kappa+2}</span></div>

    <p class="text-gray-300">Here we treat <span class="math">\\mathbf{e}_o</span> as a matrix in <span class="math">R_q^{2 \\times 4}</span> so that <span class="math">\\mathbf{e}_{o,i} \\in R_q^2</span> is its <span class="math">i</span>'th column, for <span class="math">i \\in [4]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}</span>: Compute <span class="math">\\mathbf{g} \\coloneqq \\mathbf{s}_0 \\cdot \\tau_{\\mathbf{D}} + \\mathbf{s}_1 \\cdot \\mathbf{m}_{\\tau} + \\mathbf{s}_2 \\cdot \\mathbf{f} + \\mathbf{h} \\in R_q^n</span>.</li>

    </ol>

    <p class="text-gray-300">9 <span class="math">\\mathbf{t}^{(z)}</span> is a tensor product defined in (19), so <span class="math">\\widetilde{\\mathbf{t}^{(z)}}(\\mathbf{r}) = \\langle \\mathbf{t}^{(z)}, \\operatorname{tensor}(\\mathbf{r}) \\rangle</span> can be efficiently evaluated due to the mixed-product property of tensors.</p>

    <p class="text-gray-300">10 <span class="math">\\langle \\operatorname{tensor}(\\mathbf{c}^{(z)}), \\operatorname{com}(\\mathbf{h}) \\rangle</span> is directly computed by the verifier in time <span class="math">O(\\kappa)</span>.</p>

    <p class="text-gray-300">27</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the reduced statement <span class="math">(\\mathsf{z}=(\\mathsf{cm}_{\\mathbf{g}},\\mathbf{r}_{o},v_{o}),\\mathsf{\\omega}=\\mathbf{g})\\in\\mathcal{R}_{\\mathsf{com}}</span>.</li>

    </ol>

    <h6 id="sec-44" class="text-base font-medium mt-4">Remark 4.5.</h6>

    <p class="text-gray-300">To see why Eq. (20) and Eq. (21) are equivalent, it suffices to check <span class="math">\\langle\\tau_{\\mathbf{D}},\\mathbf{t}^{(z)}\\rangle=\\langle\\mathsf{tensor}(\\mathbf{c}^{(z)}),\\mathsf{pow}(\\tau_{\\mathbf{D}})\\mathbf{s}^{\\prime}\\rangle</span>. We can understand <span class="math">\\tau_{\\mathbf{D}}\\in(-d^{\\prime},d^{\\prime})^{\\kappa d^{2}k\\ell}</span> as a four-dimensional array <span class="math">T\\in(-d^{\\prime},d^{\\prime})^{\\kappa\\times dk\\times d\\times\\ell}</span> such that <span class="math">T_{i,j,o,p}=\\tau_{\\mathbf{D}}[i\\cdot(d^{2}k\\ell)+j\\cdot(d\\ell)+o\\cdot\\ell+p]</span>. Then we have</p>

    <p class="text-gray-300"><span class="math">\\langle\\tau_{\\mathbf{D}},\\mathbf{t}^{(z)}\\rangle</span> <span class="math">=\\langle\\tau_{\\mathbf{D}},\\mathsf{tensor}(\\mathbf{c}^{(z)})\\otimes\\mathbf{s}^{\\prime}\\otimes(1,d^{\\prime},\\ldots,d^{\\prime\\ell-1})\\otimes(1,X,\\ldots,X^{d-1})\\rangle</span> <span class="math">=\\sum_{i\\in[\\kappa],j\\in[dk],o\\in[d],p\\in[\\ell]}T_{i,j,o,p}\\cdot\\mathsf{tensor}(\\mathbf{c}^{(z)})_{i}\\cdot\\mathbf{s}^{\\prime}_{j}\\cdot d^{\\prime o}\\cdot X^{p}</span> <span class="math">=\\langle\\mathsf{tensor}(\\mathbf{c}^{(z)}),\\sum_{j\\in[dk]}\\left(\\sum_{o\\in[d],p\\in[\\ell]}T_{<em>,j,o,p}\\cdot d^{\\prime o}\\cdot X^{p}\\right)\\cdot\\mathbf{s}^{\\prime}_{j}\\rangle</span> <span class="math">=\\langle\\mathsf{tensor}(\\mathbf{c}^{(z)}),\\sum_{j\\in[dk]}\\mathsf{pow}(\\tau_{\\mathbf{D}})_{</em>,j}\\cdot\\mathbf{s}^{\\prime}_{j}\\rangle=\\langle\\mathsf{tensor}(\\mathbf{c}^{(z)}),\\mathsf{pow}(\\tau_{\\mathbf{D}})\\mathbf{s}^{\\prime}\\rangle\\,.</span></p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark 4.6 (Efficient Instantiations of Sumchecks).</h6>

    <p class="text-gray-300">Step 5 verifies six sumcheck claims over <span class="math">R_{q}</span> in a batch. Observe that each sumcheck claim over <span class="math">R_{q}</span> can be understood as <span class="math">d</span> sumcheck claims over <span class="math">\\mathbb{Z}_{q}</span>: In (18), the elements of <span class="math">\\mathsf{tensor}(\\mathbf{r})</span> are in <span class="math">\\mathbb{Z}_{q}</span>; similarly, in (20), the elements of <span class="math">\\tau_{\\mathbf{D}}</span> are in <span class="math">\\mathbb{Z}_{q}</span>. Thus there are only scalar multiplications rather than <span class="math">R_{q}</span>-multiplications in the degree-2 sumchecks. Hence the sumcheck claim over <span class="math">R_{q}</span> can be understood as <span class="math">d</span> coefficient-wise sumcheck claims over <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">In sum, the six sumcheck claims over <span class="math">R_{q}</span> can then be understood as <span class="math">6d</span> sumcheck claims over <span class="math">\\mathbb{Z}_{q}</span>. We can compress the <span class="math">6d</span> sumcheck claims over <span class="math">\\mathbb{Z}_{q}</span> to a single sumcheck claim over <span class="math">\\mathbb{Z}_{q}</span> (or its field extension) via random linear combination (c.f. Remark 2.6). Thus <span class="math">\\Pi_{\\mathsf{cm}}</span> only needs to run two parallel sumcheck protocols over <span class="math">\\mathbb{Z}_{q}</span> (or an extension field of <span class="math">\\mathbb{Z}_{q}</span>).</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 4.7 (Optimizing communication).</h6>

    <p class="text-gray-300">The communication is dominated by <span class="math">\\mathbf{e}^{\\prime}:=\\mathbf{e}[3,3+dk)\\in R_{q}^{dk}</span>, which consists of <span class="math">dk</span> “full” <span class="math">R_{q}</span>-elements. This affects the folding verifier circuit size as the Fiat-Shamir transform is the bottleneck. (E.g., a 2-to-1 hash over <span class="math">R_{q}</span> takes more than 100 R1CS constraints over <span class="math">R_{q}</span>.) Fortunately, we can use the same compression trick for <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{f}\\right)</span> to compress <span class="math">\\mathbf{e}^{\\prime}</span>.</p>

    <p class="text-gray-300">Let <span class="math">n^{\\prime}=nk/\\kappa</span> and assume that <span class="math">n^{\\prime}=n</span> for simplicity. (The technique easily generalizes for all <span class="math">n^{\\prime}\\leq n</span>.) Decompose <span class="math">\\mathbf{e}^{\\prime}</span> into <span class="math">\\tau_{\\mathbf{e}}\\in(-d^{\\prime},d^{\\prime})^{n^{\\prime}}</span> using an injective map similar to <span class="math">\\mathsf{split}(\\cdot)</span>. We reuse the notation <span class="math">\\mathsf{split}</span> and <span class="math">\\mathsf{pow}</span> and note that <span class="math">\\mathsf{pow}(\\tau_{\\mathbf{e}})=\\mathbf{e}^{\\prime}</span>. To check that <span class="math">\\mathbf{M}_{\\mathbf{f}}</span> is in <span class="math">\\mathcal{M}^{n\\times dk}</span> in the subprotocol <span class="math">\\Pi_{\\mathsf{mon}}</span> (Construction 4.2), the prover sends the commitment <span class="math">\\mathsf{com}\\left(\\tau_{\\mathbf{e}}\\right)</span> (rather than <span class="math">\\mathbf{e}^{\\prime}</span>) and the claimed values <span class="math">(\\mathbf{v}_{e},\\mathbf{v}_{e}^{\\prime}):=(\\mathbf{e}^{\\prime}[\\beta],\\mathbf{e}^{\\prime}[\\beta^{2}])\\in\\mathcal{C}^{dk}</span> (used in the check (12)). The rest of the protocol is the same as <span class="math">\\Pi_{\\mathsf{cm}}</span> except for the following changes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover proves that the committed <span class="math">\\tau_{\\mathbf{e}}</span> is in range <span class="math">(-d^{\\prime},d^{\\prime})^{n^{\\prime}}</span>. This can be achieved by sending <span class="math">\\mathsf{com}\\left(\\mathsf{exp}(\\tau_{\\mathbf{e}})\\right)</span> and running Construction 4.3, which is really efficient.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Step 5, the prover sends the claimed value of <span class="math">u</span> and batches a sumcheck claim that proves <span class="math">\\langle\\mathsf{pow}(\\tau_{\\mathbf{e}}),\\mathbf{s}^{\\prime}\\rangle=u</span>. (Recall that <span class="math">\\mathbf{e}^{\\prime}=\\mathsf{pow}(\\tau_{\\mathbf{e}})</span>.)</li>

      <li>In Step 5, the prover further proves that <span class="math">\\mathsf{pow}(\\tau_{\\mathbf{e}})[\\beta]=\\mathbf{v}_{e}</span> and <span class="math">\\mathsf{pow}(\\tau_{\\mathbf{e}})[\\beta^{2}]=\\mathbf{v}_{e}^{\\prime}</span> (via sumchecks). The idea is almost identical to that explained in Eq. (19), Eq. (20), except that the term <span class="math">(1,\\ldots,X^{d-1})</span> in Eq. (19) is replaced with <span class="math">(1,\\beta,\\ldots,\\beta^{d-1})</span> and <span class="math">(1,\\beta^{2},\\ldots,(\\beta^{2})^{d-1})</span> respectively.</li>

      <li>In Step 5, the prover proves the constant term check in Eq. (16) via sumchecks. Specifically, let <span class="math">\\mathbf{v}\\in\\mathcal{C}^{d}</span> be the claimed values in Eq. (16). The verifier sends <span class="math">\\mathbf{c}^{\\prime}\\stackrel{{\\scriptstyle n}}{{{\\leftarrow}}}\\mathcal{C}^{\\log d}</span> and the prover sends <span class="math">v^{\\prime}=\\langle\\mathbf{u}_{0}+\\cdots+d^{\\prime k-1}\\mathbf{u}_{k-1},\\mathsf{tensor}(\\mathbf{c}^{\\prime})\\rangle\\in R_{q}</span>. Denote by <span class="math">\\mathbf{z}:=(1,d^{\\prime},\\ldots,d^{\\prime k-1})\\otimes\\mathsf{tensor}(\\mathbf{c}^{\\prime})\\in\\mathcal{C}^{dk}</span>. It suffices to check that (i) <span class="math">\\mathsf{ct}(\\psi\\cdot v^{\\prime})=\\langle\\mathbf{v},\\mathsf{tensor}(\\mathbf{c}^{\\prime})\\rangle</span>, and (ii)</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle\\mathsf{pow}(\\tau_{\\mathbf{e}}),\\mathbf{z}\\rangle=v^{\\prime}\\,.</span> (23)</p>

    <p class="text-gray-300">The inner product (23) can be represented as a degree-2 sumcheck using the same trick in Eq. (19), Eq. (20).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At Step 2, <span class="math">\\mathsf{V}</span> samples two more challenges <span class="math">r_{1},r_{2}\\in\\bar{\\mathcal{S}}</span>, and at Step 6 and 7, <span class="math">\\mathsf{V}</span> and <span class="math">\\mathsf{P}</span> fold <span class="math">(\\mathsf{com}\\left(\\tau_{\\mathbf{e}}\\right),\\mathsf{com}\\left(\\mathsf{exp}(\\tau_{\\mathbf{e}})\\right)</span> and <span class="math">\\left(\\tau_{\\mathbf{e}},\\mathsf{exp}(\\tau_{\\mathbf{e}})\\right)</span> into <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span> and <span class="math">\\mathbf{g}</span> respectively, using scalars <span class="math">r_{1},r_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">This optimization removes <span class="math">\\mathbf{e}^{\\prime}</span> that has <span class="math">dk</span> <span class="math">R_{q}</span>-elements, at the cost of adding two commitments <span class="math">\\mathsf{com}\\left(\\tau_{\\mathbf{e}}\\right),\\mathsf{com}\\left(\\mathsf{exp}(\\tau_{\\mathbf{e}})\\right)\\in R_{q}^{n}</span>, one <span class="math">R_{q}</span>-element <span class="math">b</span> and <span class="math">\\mathcal{C}</span>-element <span class="math">a</span> in the execution of Construction 4.3, <span class="math">\\mathbf{v}_{e},\\mathbf{v}_{e}^{\\prime}</span> which has <span class="math">2dk</span> <span class="math">\\mathcal{C}</span>-elements, and <span class="math">v^{\\prime}\\in R_{q},\\mathbf{c}^{\\prime}\\in\\mathcal{C}^{\\log d}</span>. In practice, <span class="math">d\\gg\\kappa&gt;k</span>, so this gives us a <span class="math">\\approx dk/(2\\kappa)</span>-factor saving on communication.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 4.8 (Supporting <span class="math">n&lt;\\kappa d^{2}k\\ell</span>).</h6>

    <p class="text-gray-300">Construction 4.5 requires the witness length <span class="math">n</span> to be large enough, i.e., <span class="math">n\\geq\\kappa d^{2}k\\ell</span>. In this remark, we explain how to support smaller <span class="math">n</span>. To illustrate the idea, consider an example where <span class="math">d=(d^{<em>})^{2}</span> and <span class="math">n=\\kappa dk\\ell d^{</em>}\\ll\\kappa d^{2}k\\ell</span>. We need to make two changes to the protocol <span class="math">\\Pi_{\\mathsf{cm}}</span>.</p>

    <p class="text-gray-300">First, we need to slightly change how we compute <span class="math">\\tau_{\\mathbf{D}}=\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right))</span>. In Step 2 of Construction 4.1, instead of flattening the entire coefficient matrix <span class="math">\\mathsf{cf}(\\mathbf{M}_{\\mathbf{f}}^{\\prime\\prime})\\in\\mathbb{Z}_{q}^{\\kappa dk\\ell\\times d}</span> into a <span class="math">\\mathbb{Z}_{q}</span>-vector, we convert the matrix to an <span class="math">R_{q}</span>-vector: Split <span class="math">\\mathbf{C}:=\\mathsf{cf}(\\mathbf{M}_{\\mathbf{f}}^{\\prime\\prime})</span> into <span class="math">d^{*}</span> parts, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}=[\\mathbf{C}_{0},\\mathbf{C}_{1},\\ldots,\\mathbf{C}_{d^{*}-1}]</span></p>

    <p class="text-gray-300">where for every <span class="math">i\\in[d^{<em>}]</span>, <span class="math">\\mathbf{C}_{i}\\in\\mathbb{Z}_{q}^{\\kappa dk\\ell\\times d^{</em>}}</span> and we denote by <span class="math">\\tau_{i}:=\\mathsf{flat}(\\mathbf{C}_{i})\\in\\mathbb{Z}_{q}^{n=\\kappa dk\\ell d^{<em>}}</span>. Finally, we set <span class="math">\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)):=\\tau_{\\mathbf{D}}=\\sum_{i\\in[d^{</em>}]}\\tau_{i}X^{i}\\in R_{q}^{n}</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}=\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right)</span> is the double commitment in <span class="math">\\Pi_{\\mathsf{cm}}</span>. Now, the committed vector <span class="math">\\tau_{\\mathbf{D}}</span> is no longer in <span class="math">(-d^{\\prime},d^{\\prime})^{n}</span> but an <span class="math">R_{q}</span>-vector whose elements have degree <span class="math">d^{*}=\\sqrt{d}</span> and norm <span class="math">d^{\\prime}</span>, and we need to range-check the committed vector <span class="math">\\tau_{\\mathbf{D}}\\in R_{q}^{n}</span>. A naive approach</p>

    <p class="text-gray-300">is to send the linear commitment to a matrix <span class="math">\\mathbf{M}_{\\tau}\\in\\mathcal{M}^{n\\times d^{<em>}}</span> and run monomial set checks, which is still inefficient if <span class="math">d^{</em>}</span> is relatively large.</p>

    <p class="text-gray-300">Fortunately, the commitment <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right)\\in R_{q}^{\\kappa\\times d^{<em>}}</span> is </em>much shorter than<em> <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)\\in R_{q}^{\\kappa\\times dk}</span> and <span class="math">n</span> is now sufficiently long compared to <span class="math">\\kappa d^{</em>}\\ell d</span>. That is, <span class="math">d^{<em>}\\ll dk</span> and <span class="math">n=\\kappa dk\\ell d^{</em>}\\geq\\kappa d^{<em>}\\ell d</span>. This enables the prover to compute <span class="math">\\tau^{\\prime}:=\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right))\\in(-d^{\\prime},d)^{n}</span> (following 4.1 with no modification) and send the commitment <span class="math">\\mathsf{com}\\left(\\tau^{\\prime}\\right)</span>, and then range-check <span class="math">\\tau^{\\prime}</span> by running 4.3. Additionally, the protocol checks the consistency between <span class="math">\\mathsf{com}\\left(\\tau^{\\prime}\\right)</span>, <span class="math">\\mathsf{com}\\left(\\mathbf{h}^{\\prime}\\right):=\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right)\\mathbf{s}^{{}^{\\prime\\prime}}</span> (where <span class="math">\\mathbf{s}^{{}^{\\prime\\prime}}\\nleftarrow\\mathcal{\\bar{S}}^{d^{</em>}}</span>) and <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right)</span> via a sumcheck claim as in Eq. (20). The sumcheck claim can be batched in Step 5.</p>

    <p class="text-gray-300">As a trade-off, we replace the two commitments <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}=\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right),\\mathsf{cm}_{\\mathbf{m}_{\\tau}}=\\mathsf{com}\\left(\\mathsf{exp}(\\tau_{\\mathbf{D}})\\right)</span> with four commitments <span class="math">\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right),\\mathsf{com}\\left(\\tau^{\\prime}=\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right))\\right)</span>, <span class="math">\\mathsf{com}\\left(\\mathsf{exp}(\\tau^{\\prime})\\right)</span> and <span class="math">\\mathsf{com}\\left(\\mathbf{h}^{\\prime}\\right)</span> (that folds <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\tau}\\right)</span>).</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">Security analysis of 4.5.</h4>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span> is a random linear combination of the commitments <span class="math">[C_{\\mathbf{M}_{\\mathbf{f}}}=\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right),\\mathsf{cm}_{\\mathbf{m}_{\\tau}},\\mathsf{cm}_{\\mathbf{f}}]</span> and <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)</span>. However, the prover never sends <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)</span>, which is too large. Instead, the prover adaptively sends a folded commitment <span class="math">\\mathsf{com}\\left(\\mathbf{h}\\right)=\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)\\mathbf{s}^{\\prime}</span> after learning the challenge <span class="math">\\mathbf{s}^{\\prime}</span>. At a first glance, it is unclear how to enforce the prover to fix the witness <span class="math">\\mathbf{M}_{\\mathbf{f}}</span> before learning the challenge. A key observation is that <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> was sent initially, which is claimed to be the double commitment to <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>. By running a sumcheck to enforce the consistency between the instances <span class="math">\\mathsf{com}\\left(\\mathbf{h}\\right)</span>, <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> and the witness <span class="math">\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)</span>, we can recover the binding of <span class="math">\\mathbf{M}_{\\mathbf{f}}</span>. Next, we formally prove the security of the scheme.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem 4.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">k\\in\\mathbb{N}</span> and <span class="math">B:=(d^{\\prime})^{k}</span>. Fix <span class="math">b\\in\\mathbb{N}</span> and <span class="math">\\mathcal{\\bar{S}}\\subseteq R_{q}</span> such that <span class="math">\\mathsf{com}\\left(\\cdot\\right)</span> is <span class="math">(b,\\mathcal{S}=\\mathcal{\\bar{S}}-\\mathcal{\\bar{S}})</span>-binding (defined in Section 4.1) and $b\\geq 2\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{\\bar{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}(d^{\\prime}+1+B+dk)<span class="math">. Then </span>\\Pi_{\\mathsf{cm}}<span class="math"> is a reduction of knowledge from </span>\\mathcal{R}_{\\mathsf{rg},B}<span class="math"> to </span>\\mathcal{R}_{\\mathsf{com}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Public reducibility is trivial. The theorem follows from the lemmas below. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 4.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $b\\geq B^{\\prime}=2\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{\\bar{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}\\cdot(d^{\\prime}+1+B+dk)<span class="math">, then </span>\\Pi_{\\mathsf{cm}}$ is perfectly complete.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For every input instance <span class="math">\\mathsf{z}=\\left(\\mathsf{cm}_{\\mathbf{f}}=\\mathsf{com}\\left(\\mathbf{f}\\right),C_{\\mathbf{M}_{\\mathbf{f}}}=\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right),\\mathsf{cm}_{\\mathbf{m}_{\\tau}}=\\mathsf{com}\\left(\\mathbf{m}_{\\tau}\\right)\\right)</span> and witness <span class="math">\\mathsf{w}=\\left[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{M}_{\\mathbf{f}}\\right]</span> such that <span class="math">(\\mathsf{z},\\mathsf{w})\\in\\mathcal{R}_{\\mathsf{rg},B}</span>, we prove that the honest execution of <span class="math">\\Pi_{\\mathsf{cm}}</span> succeeds and the output statement is in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span>.</p>

    <p class="text-gray-300">We first show that the verifier accepts and the evaluation claim in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> (Eq. (17)) holds. By completeness of <span class="math">\\Pi_{\\mathsf{rgchk}}</span>, Step 1 executes correctly and the output statement is in <span class="math">\\mathcal{R}_{\\mathsf{dcom}}</span> from (15). This implies that the first 4 sumcheck claims at Step 5 hold. Moreover, since <span class="math">(C_{\\mathbf{M}_{\\mathbf{f}}},(\\tau_{\\mathbf{D}},\\mathbf{M}_{\\mathbf{f}}))\\in\\mathcal{R}_{\\mathsf{dopen},dk}</span> (defined in (8)), we have <span class="math">\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right)=C_{\\mathbf{M}_{\\mathbf{f}}}</span> and <span class="math">\\mathsf{pow}(\\tau_{\\mathbf{D}})=\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)</span>, thus</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pow}(\\tau_{\\mathbf{D}})\\mathbf{s}^{\\prime}=\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right)\\mathbf{s}^{\\prime}=\\mathsf{com}\\left(\\mathbf{h}\\right)</span></p>

    <p class="text-gray-300">and the last two sumcheck claims (at Step 5) hold. Therefore, the batched sumcheck executes correctly and the evaluation claims in (22) holds, which implies that the evaluation claim in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> also holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we show that the norm constraint in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> holds (Eq. (17)), which also implies that <span class="math">\\mathbf{g}</span> is a valid opening of <span class="math">\\mathsf{cm}_{\\mathbf{g}}</span>. Note that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau_{\\mathbf{D}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<d^{\\prime}<span class="math">, the entries of </span>\\mathbf{m}_{\\tau}<span class="math">, </span>\\mathbf{M}_{\\mathbf{f}}<span class="math"> are in the monomial set from (2), and </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<B$. By definition of operator norms from (4) and Lemma 2.3, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{g}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<d^{\\prime}\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}+\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}+B\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}+dk\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{op}}=B^{\\prime}/2\\leq b/2\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, the output statement is in <span class="math">\\mathcal{R}_{\\mathsf{com}}</span>, which completes the proof. ∎</p>

    <p class="text-gray-300">Before proving knowledge soundness, we review an adapted version of the coordinate-wise special soundnesss lemma from <em>[x10]</em>. Fix <span class="math">\\mu\\in\\mathbb{N}</span> and let <span class="math">\\bar{\\mathcal{S}}</span> be a finite set. For two vectors <span class="math">\\mathbf{a},\\mathbf{b}\\in\\bar{\\mathcal{S}}^{\\mu}</span>, we say that <span class="math">\\mathbf{a}\\equiv_{i}\\mathbf{b}</span> for <span class="math">i\\in[\\mu]</span> if <span class="math">\\mathbf{a}_{i}\\neq\\mathbf{b}_{i}</span> and <span class="math">\\mathbf{a}_{j}=\\mathbf{b}_{j}</span> for all <span class="math">j\\in[\\mu]\\setminus\\{i\\}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 4.9 (<em>[x10]</em>, Lemma 7.1).</h6>

    <p class="text-gray-300">Fix <span class="math">\\mu\\in\\mathbb{N}</span> and let <span class="math">\\bar{\\mathcal{S}}</span> be a finite set. Define <span class="math">U:=\\bar{\\mathcal{S}}^{\\mu}</span> and let <span class="math">\\Psi:U\\times T\\to\\{0,1\\}</span> be any predicate. Let <span class="math">\\mathcal{A}</span> be a probabilistic algorithm <span class="math">\\mathcal{A}:U\\to T</span> and let</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\Psi}(\\mathcal{A}):=\\Pr_{\\mathbf{u}\\xleftarrow{a}U}\\big{[}\\Psi(\\mathbf{u},\\mathcal{A}(\\mathbf{u}))=1\\big{]}.</span></p>

    <p class="text-gray-300">There is an oracle algorithm <span class="math">\\mathcal{E}</span> such that <span class="math">\\mathcal{E}^{\\mathcal{A}}(\\mathbf{u}_{0},y_{0})</span>, on input <span class="math">\\mathbf{u}_{0}\\xleftarrow{a}U</span>, <span class="math">y_{0}\\leftarrow\\mathcal{A}(\\mathbf{u}_{0})</span>, with probability at least</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\Psi}(\\mathcal{A})-\\mu/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (24)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">outputs <span class="math">\\mu+1</span> pairs <span class="math">(\\mathbf{u}_{0},y_{0})</span>, <span class="math">(\\mathbf{u}_{1},y_{1}\\leftarrow\\mathcal{A}(\\mathbf{u}_{1}))</span>, …, <span class="math">(\\mathbf{u}_{\\mu},y_{\\mu}\\leftarrow\\mathcal{A}(\\mathbf{u}_{\\mu}))</span> such that <span class="math">\\Psi(\\mathbf{u}_{i},y_{i})=1</span> for all <span class="math">i\\in[\\mu+1]</span> and <span class="math">\\mathbf{u}_{i+1}\\equiv_{i}\\mathbf{u}_{0}</span> for all <span class="math">i\\in[\\mu]</span>. <span class="math">\\mathcal{E}</span> calls <span class="math">\\mathcal{A}</span> for <span class="math">1+\\mu</span> times in expectation, and $1+\\mu(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ times in the worst case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we are ready to prove knowledge soundness.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 4.10.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">k\\in\\mathbb{N}</span> and <span class="math">B=(d^{\\prime})^{k}</span>. Let <span class="math">\\bar{\\mathcal{S}}</span>, <span class="math">\\mathcal{C}</span> be challenge sets where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}$. Define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\mathsf{sum}}:=(2\\log(n)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}\\,.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and <span class="math">\\mu=3+dk</span>. Fix any <span class="math">b\\in\\mathbb{N}</span> such that <span class="math">\\mathsf{com}\\left(\\cdot\\right)</span> is <span class="math">(b,\\mathcal{S}=\\bar{\\mathcal{S}}-\\bar{\\mathcal{S}})</span>-binding with binding error <span class="math">\\epsilon_{\\mathsf{bind}}</span>, the protocol <span class="math">\\Pi_{\\mathsf{cm}}</span> has knowledge error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon_{\\mathsf{cm},k}=\\frac{\\mu+dk}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+3\\epsilon_{\\mathsf{bind}}+\\epsilon_{\\mathsf{rg}}^{\\prime}+\\epsilon_{\\mathsf{rg}}+2\\epsilon_{\\mathsf{sum}}+\\frac{\\mu(\\log^{2}(\\kappa)+(2\\log n)^{2})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\mathsf{rg}}^{\\prime},\\epsilon_{\\mathsf{rg}}</span> are defined in Lemma 4.5 and Lemma 4.7.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Proof. Let <span class="math">\\mathcal{A}^<em> := (\\mathcal{A}, \\mathsf{P}^</em>)</span> be any malicious prover with winning probability <span class="math">\\epsilon_{\\mathcal{A}^<em>}</span>. Without loss of generality, we assume that <span class="math">\\mathcal{A}^</em></span> is deterministic. We derive an adversary <span class="math">\\mathcal{A}&#x27;</span> below that will be fed to the extractor in Lemma 4.9. Note that <span class="math">\\mathcal{A}&#x27;</span> only calls <span class="math">\\mathcal{A}^*</span> as an oracle. Recall that <span class="math">\\mathsf{M}_{\\mathcal{C}} := \\mathcal{C} \\times \\mathcal{C}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mu := 3 + dk</span> and <span class="math">U := \\bar{\\mathcal{S}}^{\\mu}</span>. The adversary <span class="math">\\mathcal{A}&#x27;</span>, with a hardcoded <span class="math">\\mathbf{r}_o \\in \\mathsf{M}_{\\mathcal{C}}^{\\log n}</span>, on input <span class="math">\\mathbf{u} = (\\mathbf{s} \\in \\bar{\\mathcal{S}}^3, \\mathbf{s}&#x27; \\in \\bar{\\mathcal{S}}^{dk})</span>, simulates execution with <span class="math">\\mathcal{A}^<em></span> by using <span class="math">\\mathbf{u}</span> as the folding challenge and <span class="math">\\mathbf{r}_o</span> as the challenge of the last sumcheck, and internally sampling other randomness of the verifier. If <span class="math">\\mathcal{A}^</em></span> fails or <span class="math">\\mathcal{A}^<em></span>'s output is not a valid witness for <span class="math">\\mathcal{R}_{\\mathrm{com}}</span>, <span class="math">\\mathcal{A}&#x27;</span> returns <span class="math">\\bot</span>; otherwise <span class="math">\\mathcal{A}&#x27;</span> outputs <span class="math">y := (\\mathrm{tr}, \\mathbb{w}_o)</span>, where <span class="math">\\mathbb{w}_o</span> is <span class="math">\\mathcal{A}^</em></span>'s output witness and <span class="math">\\mathrm{tr}</span> is the execution transcript, which includes the input and output instances, the verifier randomness, and the prover messages.</p>

    <p class="text-gray-300">Define the predicate <span class="math">\\Psi: U \\times \\{0,1\\}^* \\to \\{0,1\\}</span> such that <span class="math">\\Psi(\\mathbf{u}, y = (\\mathrm{tr}, \\mathbb{w}_o)) = 1</span> if and only if the following two conditions both hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The execution transcript <span class="math">\\mathrm{tr}</span> is accepted and uses <span class="math">\\mathbf{u}</span> as the folding challenges.</li>

      <li><span class="math">(\\mathbb{z}_o,\\mathbb{w}_o)\\in \\mathcal{R}_{\\mathrm{com}}</span> where <span class="math">\\mathbb{z}_o</span> is the output instance in the transcript.</li>

    </ol>

    <p class="text-gray-300">Next, we describe the extractor <span class="math">\\mathsf{Ext}</span> for <span class="math">\\Pi_{\\mathsf{cm}}</span>, which calls the extractor <span class="math">\\mathcal{E}</span> in Lemma 4.9 as a subroutine:</p>

    <p class="text-gray-300"><strong>Extractor Ext</strong>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\mathbf{r}_o \\xleftarrow{\\mathrm{e}} \\mathsf{M}_{\\mathcal{C}}^{\\log n}</span> to be used by <span class="math">\\mathcal{A}&#x27;</span>. Each call of <span class="math">\\mathcal{A}&#x27;</span> will reuse the same <span class="math">\\mathbf{r}_o</span> but freshly sample other randomness for simulating execution with <span class="math">\\mathcal{A}^*</span>.</li>

      <li>Sample <span class="math">\\mathbf{u}^{(0)} \\xleftarrow{\\mathrm{e}} U</span> and <span class="math">y_0 \\gets \\mathcal{A}&#x27;(\\mathbf{u}^{(0)})</span>.</li>

      <li>Call <span class="math">\\mathcal{E}^{\\mathcal{A}&#x27;}(\\mathbf{u}^{(0)}, y_0)</span>. If the execution fails, abort and return <span class="math">\\bot</span>; otherwise, parse the output</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {u} ^ {(0)}, y _ {0}), \\quad (\\mathbf {u} ^ {(1)}, y _ {1} \\leftarrow \\mathcal {A} (\\mathbf {u} _ {1})), \\quad \\ldots , \\quad (\\mathbf {u} ^ {(\\mu)}, y _ {\\mu} \\leftarrow \\mathcal {A} ^ {\\prime} (\\mathbf {u} ^ {(\\mu)}))</span></div>

    <p class="text-gray-300">where <span class="math">y_{i} = (\\mathrm{tr}_{i} = (\\mathbb{z}_{o}^{(i)},*)</span> , <span class="math">\\mathbb{w}_o^{(i)})</span> for all <span class="math">i\\in [\\mu +1]</span> and <span class="math">\\mathbf{u}^{(i + 1)}\\equiv_i\\mathbf{u}^{(0)}</span> for all <span class="math">i\\in [\\mu ]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">i\\in [\\mu ]</span>, compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {w} _ {i} := \\frac {\\mathbb {w} _ {o} ^ {(i + 1)} - \\mathbb {w} _ {o} ^ {(0)}}{\\mathbf {u} _ {i} ^ {(i + 1)} - \\mathbf {u} _ {i} ^ {(0)}} \\in R _ {q} ^ {n}. \\tag {25}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathbb{w} := [\\tilde{\\tau_{\\mathbf{D}}}, \\tilde{\\mathbf{m}_{\\tau}}, \\tilde{\\mathbf{f}}, \\tilde{\\mathbf{M}}_{\\mathbf{f}}] := [\\mathbb{w}_0, \\dots, \\mathbb{w}_{\\mu - 1}] \\in R_q^{n \\times \\mu}</span>.</li>

    </ol>

    <p class="text-gray-300">By Lemma 4.9, it is clear that <span class="math">\\mathsf{Ext}</span> runs in expected polynomial time. Next, we focus on analyzing the success probability of <span class="math">\\mathsf{Ext}</span>.</p>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">33</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Success probability. Define <span class="math">\\epsilon_{\\Psi}(\\mathcal{A}&#x27;) := \\operatorname{Pr}_{\\mathbf{u} \\in U, \\mathbf{r}_o \\in \\mathbb{R} - \\mathbf{M}_0^{\\log n}}[\\Psi(\\mathbf{u}, \\mathcal{A}&#x27;(\\mathbf{u})) = 1]</span>, which is equal to <span class="math">\\epsilon_{\\mathcal{A}^<em>}</span>. By Lemma 4.9, with non-negligible<span class="math">^{13}</span> probability $\\epsilon_{\\mathcal{A}^</em>} - \\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the extractor </span>\\mathsf{Ext}<span class="math"> does not abort. Conditioned on this, denote by </span>\\mathbf{z} = (\\mathsf{cm}_{\\mathbf{f}}, C_{\\mathbf{M}_{\\mathbf{f}}}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}})<span class="math"> the input instance in the execution, it suffices to upper-bound the probability that the extracted witness </span>\\mathsf{w} = [\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}, \\hat{\\mathbf{M}}_{\\mathbf{f}}]<span class="math"> is invalid, i.e., </span>(\\mathbf{z}, \\mathsf{w}) \\notin \\mathcal{R}_{\\mathbf{rg}, B}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We first review some properties of the extracted witness. Recall that <span class="math">\\mathsf{com}(\\cdot)</span> and multilinear evaluations are linear functions; <span class="math">\\mathsf{com}(\\cdot)</span> is <span class="math">(b, S = \\bar{S} - \\bar{S})</span>-binding and <span class="math">(\\mathsf{z}_o^{(i)}, \\mathsf{w}_o^{(i)}) \\in \\mathcal{R}_{\\mathsf{com}}</span> for all <span class="math">i \\in [\\mu + 1]</span>. Thus, if <span class="math">\\mathsf{Ext}</span> succeeds, <span class="math">\\mathsf{w} = [\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}, \\hat{\\mathbf{M}}_{\\mathbf{f}}]</span> has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}</span> are <span class="math">(b, S)</span>-valid openings of <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}} = \\mathsf{com}(\\hat{\\tau_{\\mathbf{D}}}), \\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathsf{cm}_{\\mathbf{f}}</span> (Eq. (6)).</li>

      <li><span class="math">\\hat{\\mathbf{M}}_{\\mathbf{f}}</span> is a valid opening of <span class="math">\\mathsf{com}\\left(\\hat{\\mathbf{M}}_{\\mathbf{f}}\\right)</span>. (However, <span class="math">(\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{M}}_{\\mathbf{f}})</span> may not be a valid opening of the double commitment <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span> if <span class="math">\\mathsf{com}\\left(\\hat{\\mathbf{M}}_{\\mathbf{f}}\\right) \\neq \\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}})</span>.)</li>

      <li>For every <span class="math">i \\in [\\mu + 1]</span>, parse <span class="math">\\mathbf{u}^{(i)} = (\\mathbf{s}^{(i)}, \\mathbf{s}&#x27;^{(i)} \\in \\bar{S}^{dk})</span> and denote by <span class="math">\\mathsf{com}\\left(\\mathbf{h}^{(i)}\\right)</span> (included in <span class="math">\\mathfrak{tr}_i</span>) the <span class="math">\\mathbf{h}</span>-commitment sent by the prover at Step 3. By linearity of <span class="math">\\mathsf{com}(\\cdot)</span> and the verifier computation at Step 6, we have that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{com} \\left(\\mathbf {h} ^ {(i)}\\right) = \\operatorname{com} \\left(\\hat {\\mathbf {M}} _ {\\mathbf {f}}\\right) \\mathbf {s} ^ {\\prime (i)}. \\tag {26}</span></div>

    <p class="text-gray-300">We note that <span class="math">\\hat{\\mathbf{M}}_{\\mathbf{f}}\\mathbf{s}^{\\prime (i)}</span>, however, may not be a <span class="math">(b,\\mathcal{S})</span>-valid opening of <span class="math">\\mathsf{com}\\left(\\mathbf{h}^{(i)}\\right)</span>, because we do not have sufficient norm guarantee for <span class="math">\\hat{\\mathbf{M}}_{\\mathbf{f}}\\mathbf{s}^{\\prime (i)}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}]^\\top \\mathrm{tensor}(\\mathbf{r}_o) = \\mathbf{e}_o^{(0)}[0,3)</span> where <span class="math">\\mathbf{e}_o^{(0)}</span> (in the first transcript <span class="math">\\mathfrak{tr}_0</span>) is the claimed evaluation in Eq. (22).</li>

      <li><span class="math">\\langle \\hat{\\mathbf{M}}_{\\mathbf{f}}\\mathbf{s}^{\\prime (0)}, \\mathrm{tensor}(\\mathbf{r}_o)\\rangle = \\mathbf{e}_o^{(0)}[3]</span>.</li>

    </ol>

    <p class="text-gray-300">Next, we analyze the probability of bad events below.</p>

    <p class="text-gray-300">Define <span class="math">\\mathsf{BAD}_1</span> as the event that <span class="math">\\mathsf{Ext}</span> does not abort, but <span class="math">\\hat{\\tau_{\\mathbf{D}}}</span> (in the extracted witness <span class="math">\\mathsf{w}</span>) is not in <span class="math">(-d&#x27;, d&#x27;)^n</span>.</p>

    <p class="text-gray-300">Claim 1. <span class="math">\\operatorname{Pr}[\\mathsf{BAD}_1] \\leq \\epsilon_1 := \\epsilon_{\\mathrm{bind}} + \\epsilon_{\\mathrm{rg}}&#x27; + \\epsilon_{\\mathrm{sum}}</span> where <span class="math">\\epsilon_{\\mathrm{rg}}&#x27;</span> is defined in Lemma 4.5.</p>

    <p class="text-gray-300">Proof. If <span class="math">\\mathsf{BAD}_1</span> occurs, by Property (1) and Property (4), we have <span class="math">(\\bar{\\mathbf{z}} = C_{\\mathbf{M}_{\\mathbf{f}}}, \\bar{\\mathbf{w}} = \\hat{\\tau_{\\mathbf{D}}}) \\in \\mathcal{R}_{\\mathrm{open}}</span> and <span class="math">\\langle \\hat{\\tau_{\\mathbf{D}}}, \\mathrm{tensor}(\\mathbf{r}_o) \\rangle = \\mathbf{e}_o^{(0)}[0]</span>.</p>

    <p class="text-gray-300">Conditioned on <span class="math">\\mathsf{Ext}</span> does not abort, consider a mental experiment where we re-run <span class="math">\\mathsf{Ext}^{\\mathcal{A}^<em>}</span> with fresh randomness. If the re-execution does not abort, let <span class="math">\\hat{\\tau_{\\mathbf{D}}}^</em></span> denote part of the extracted witness that is a claimed opening to <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span>; otherwise <span class="math">\\hat{\\tau_{\\mathbf{D}}}^* := \\bot</span>. Consider the</p>

    <p class="text-gray-300">first transcript generated by the re-execution. Let <span class="math">\\mathbf{r},\\mathbf{r}_{o}^{<em>},\\mathbf{e}[0],\\mathbf{e}_{o}[0]</span> be the random variables corresponding to the random challenges and evaluations at Step 1 and Eq. (22). Note that <span class="math">\\mathbf{r},\\mathbf{r}_{o}^{</em>}</span> are uniformly random, because the first transcript is for the first call to <span class="math">\\mathcal{A}^{<em>}</span>, and <span class="math">\\mathsf{Ext}^{\\mathcal{A}^{</em>}}</span> cannot do rejection sampling to bias the distribution.</p>

    <p class="text-gray-300">Let <span class="math">E^{*}</span> be the event that at least one event below occurs in the mental experiment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Event <span class="math">B_{1}</span>: <span class="math">(\\hat{\\tau_{\\mathbf{D}}}^{<em>}\\neq\\bot)\\wedge(\\hat{\\tau_{\\mathbf{D}}}^{</em>}\\neq\\hat{\\tau_{\\mathbf{D}}})</span>;</li>

      <li>Event <span class="math">B_{2}</span>: <span class="math">(\\hat{\\tau_{\\mathbf{D}}}^{*}=\\hat{\\tau_{\\mathbf{D}}})</span> and <span class="math">(\\hat{\\tau_{\\mathbf{D}}}\\notin(-d^{\\prime},d^{\\prime})^{n}\\wedge\\langle\\hat{\\tau_{\\mathbf{D}}},\\mathsf{tensor}(\\mathbf{r})\\rangle=\\mathbf{e}[0])</span>;</li>

      <li>Event <span class="math">B_{3}</span>: <span class="math">(\\hat{\\tau_{\\mathbf{D}}}^{<em>}=\\hat{\\tau_{\\mathbf{D}}})</span> and <span class="math">(\\langle\\hat{\\tau_{\\mathbf{D}}},\\mathsf{tensor}(\\mathbf{r})\\rangle\\neq\\mathbf{e}[0]\\wedge\\langle\\hat{\\tau_{\\mathbf{D}}},\\mathsf{tensor}(\\mathbf{r}_{o}^{</em>})\\rangle=\\mathbf{e}_{o}[0])</span>.</li>

    </ul>

    <p class="text-gray-300">By the binding property of <span class="math">\\mathsf{com}(\\cdot)</span>, Lemma 4.5, and Lemma 2.7, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[E^{*}\\right]\\leq\\Pr\\left[B_{1}\\right]+\\Pr\\left[B_{2}\\right]+\\Pr\\left[B_{3}\\right]\\leq\\epsilon_{\\mathsf{bind}}+\\epsilon_{\\mathsf{rg}}^{\\prime}+\\epsilon_{\\mathsf{sum}}.</span> (27)</p>

    <p class="text-gray-300">Note that if <span class="math">\\mathsf{BAD}_{1}</span> occurs in the mental experiment, then <span class="math">E^{<em>}</span> must also occur. Moreover, <span class="math">\\mathsf{BAD}_{1}</span> occurs with the same probability in the real execution and the mental experiment. Thus, <span class="math">\\Pr[\\mathsf{BAD}_{1}]\\leq\\Pr[E^{</em>}]</span> and the claim holds. ∎</p>

    <p class="text-gray-300">Define <span class="math">\\mathsf{BAD}_{2}</span> as the event that (i) <span class="math">\\mathsf{Ext}</span> does not abort and <span class="math">\\mathsf{BAD}_{1}</span> does not occur, but (ii) <span class="math">(\\hat{\\tau_{\\mathbf{D}}},\\hat{\\mathbf{M}}_{\\mathbf{f}})</span> (in the extracted witness <span class="math">\\mathbb{w}</span>) is not a valid opening of the double commitment <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span>, i.e., <span class="math">(C_{\\mathbf{M}_{\\mathbf{f}}},(\\hat{\\tau_{\\mathbf{D}}},\\hat{\\mathbf{M}}_{\\mathbf{f}}))\\notin\\mathcal{R}_{\\mathsf{dopen},dk}</span> (Eq. (8)).</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Claim 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then </span>\\Pr[\\mathsf{BAD}_{2}]\\leq\\epsilon_{2}\\coloneqq\\epsilon_{\\mathsf{bind}}+\\frac{\\mu(\\log^{2}(n)+(2\\log n)^{2})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{BAD}_{2}</span> occurs, then the following conditions all hold for the extracted witness <span class="math">\\mathbb{w}=[\\hat{\\tau_{\\mathbf{D}}},\\hat{\\mathbf{m}_{\\tau}},\\hat{\\mathbf{f}},\\hat{\\mathbf{M}}_{\\mathbf{f}}]</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(C_{\\mathbf{M}_{\\mathbf{f}}},\\hat{\\tau_{\\mathbf{D}}})\\in\\mathcal{R}_{\\mathsf{open}}</span> (Property (1)) and <span class="math">\\hat{\\mathbf{M}}_{\\mathbf{f}}</span> is a valid opening of <span class="math">\\mathsf{com}\\left(\\hat{\\mathbf{M}}_{\\mathbf{f}}\\right)</span> (Property (2));</li>

      <li>The sumcheck evaluation claims for <span class="math">\\hat{\\tau_{\\mathbf{D}}}</span> in the <span class="math">\\mu+1</span> transcripts are correct;</li>

      <li><span class="math">(C_{\\mathbf{M}_{\\mathbf{f}}},(\\hat{\\tau_{\\mathbf{D}}},\\hat{\\mathbf{M}}_{\\mathbf{f}}))\\notin\\mathcal{R}_{\\mathsf{dopen},dk}</span>, which implies that <span class="math">\\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}})\\neq\\mathsf{com}\\left(\\hat{\\mathbf{M}}_{\\mathbf{f}}\\right)</span>.</li>

    </ul>

    <p class="text-gray-300">Conditioned on <span class="math">\\mathsf{Ext}</span> does not abort, consider a mental experiment where we re-run <span class="math">\\mathsf{Ext}^{\\mathcal{A}^{<em>}}</span> with fresh randomness. If it does not abort, let <span class="math">\\mathbb{w}^{</em>}=(\\hat{\\tau_{\\mathbf{D}}}^{<em>},</em>,<em>,\\hat{\\mathbf{M}}_{\\mathbf{f}}^{</em>})</span> denote the extracted output, otherwise <span class="math">\\mathbb{w}^{<em>}\\coloneqq\\bot</span>. Let <span class="math">E^{</em>}</span> be the event that at least one event below occurs in the mental experiment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Event <span class="math">B_{1}</span>: <span class="math">(\\mathbb{w}^{<em>}\\neq\\bot)\\wedge(\\hat{\\tau_{\\mathbf{D}}}^{</em>}\\neq\\hat{\\tau_{\\mathbf{D}}})</span>;</li>

      <li>Event <span class="math">B_{2}</span>: <span class="math">(\\hat{\\tau_{\\mathbf{D}}}^{<em>}=\\hat{\\tau_{\\mathbf{D}}})</span> and <span class="math">\\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}})\\neq\\mathsf{com}\\left(\\hat{\\mathbf{M}}_{\\mathbf{f}}^{</em>}\\right)</span>.</li>

    </ul>

    <h6 id="sec-57" class="text-base font-medium mt-4">P</h6>

    <p class="text-gray-300">Note that if <span class="math">\\mathsf{BAD}_2</span> occurs in the mental experiment, then <span class="math">E^<em></span> also occurs. Moreover, <span class="math">\\mathsf{BAD}_2</span> occurs with the same probability in the real execution and the mental experiment. Thus, <span class="math">\\operatorname</em>{Pr}[\\mathsf{BAD}_2] \\leq \\operatorname<em>{Pr}[E^</em>] \\leq \\operatorname<em>{Pr}[B_1] + \\operatorname</em>{Pr}[B_2]</span>. Suppose for contradiction that <span class="math">\\operatorname<em>{Pr}[B_1] &amp;gt; \\epsilon_{\\mathsf{bind}}</span>, then we can find an adversary that breaks the binding property of <span class="math">\\mathsf{com}(\\cdot)</span> with probability <span class="math">\\operatorname</em>{Pr}[B_1] &amp;gt; \\epsilon_{\\mathsf{bind}}</span>, contradiction. Thus <span class="math">\\operatorname<em>{Pr}[B_1] \\leq \\epsilon_{\\mathsf{bind}}</span> and it suffices to analyze <span class="math">\\operatorname</em>{Pr}[B_2]</span>.</p>

    <p class="text-gray-300">For every <span class="math">i \\in [\\mu + 1]</span>, denote by <span class="math">\\mathbf{u}_i&#x27; = (<em>, \\mathbf{s}&#x27;^{(i)} \\in \\bar{\\mathcal{S}}^{dk})</span> the folding challenge in the <span class="math">i</span>-th transcript output by <span class="math">\\mathsf{Ext}</span> in the mental experiment. Observe that event <span class="math">B_2</span> implies that there exists <span class="math">i^</em> \\in [\\mu + 1]</span> where <span class="math">\\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}}) \\mathbf{s}&#x27;^{(i^<em>)} \\neq \\mathsf{com}(\\hat{\\mathbf{M}}_{\\mathbf{f}}^</em>) \\mathbf{s}&#x27;^{(i^<em>)}</span>; moreover, <span class="math">\\mathsf{com}(\\hat{\\mathbf{M}}_{\\mathbf{f}}^</em>) \\mathbf{s}&#x27;^{(i^<em>)} = \\mathsf{com}(\\mathbf{h}^{(i^</em>)})</span> by Property (3), where <span class="math">\\mathsf{com}(\\mathbf{h}^{(i^<em>)})</span> is in the transcript <span class="math">\\mathsf{tr}_{i^</em>}</span>. Thus, <span class="math">\\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}}) \\mathbf{s}&#x27;^{(i^<em>)} \\neq \\mathsf{com}(\\mathbf{h}^{(i^</em>)})</span>, but recall that the evaluation claim for <span class="math">\\hat{\\tau_{\\mathbf{D}}}</span> holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 4.9, <span class="math">\\mathsf{Ext}</span> calls the adversary for at most $\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times. For each fixed call, conditioned on that </span>\\mathsf{pow}(\\hat{\\tau_{\\mathbf{D}}}) \\mathbf{s}' \\neq \\mathsf{com}(\\mathbf{h})<span class="math"> (where </span>\\mathbf{s}'<span class="math"> is the folding challenge and </span>\\mathsf{com}(\\mathbf{h})<span class="math"> is the </span>\\mathbf{h}<span class="math">-commitment sent by the prover in this call), by Lemma 2.6 and Lemma 2.7, the sumcheck evaluation claim holds w.r.t. </span>\\widehat{\\tau_{\\mathbf{D}}}<span class="math"> with probability at most </span>(\\log \\kappa /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2 + \\epsilon_{\\mathsf{sum}}<span class="math">. By union bound over the </span>\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ calls, we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ B _ {2} ] \\leq \\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {\\mathcal {S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\left((\\log \\kappa /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) ^ {2} + \\epsilon_ {\\text {s u m}}\\right) \\leq \\frac {\\mu (\\log^ {2} (\\kappa) + (2 \\log n) ^ {2})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We note that this is where we rely on running two independent sumchecks to ensure a small soundness error despite the large union bound. We will come back to this in Remark 4.9.</p>

    <p class="text-gray-300">In sum, <span class="math">\\operatorname<em>{Pr}[\\mathsf{BAD}_2] \\leq \\operatorname</em>{Pr}[E^<em>] \\leq \\operatorname</em>{Pr}[B_1] + \\operatorname*{Pr}[B_2] \\leq \\epsilon_2</span> as claimed.</p>

    <p class="text-gray-300">Define <span class="math">\\mathsf{BAD}_3</span> as the event that (i) <span class="math">\\mathsf{Ext}</span> does not abort and <span class="math">(\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{M}}_{\\mathbf{f}})</span> in the extracted witness <span class="math">\\mathbf{w}</span> is a valid opening of <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}}</span>; but (ii) <span class="math">(\\mathbf{z}, \\mathbf{w}) \\notin \\mathcal{R}_{\\mathbf{rg}, B}</span>, where <span class="math">\\mathbf{z}</span> is the input instance.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 3. $\\operatorname*{Pr}[\\mathsf{BAD}_3] \\leq \\epsilon_3 \\coloneqq \\epsilon_{\\mathsf{bind}} + \\epsilon_{\\mathsf{rg}} + (dk) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_{\\mathsf{sum}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. If <span class="math">\\mathsf{BAD}_3</span> occurs, by Property (4), (5), we have that</p>

    <div class="my-4 text-center"><span class="math-block">[ \\hat {\\tau_ {\\mathbf {D}}}, \\hat {\\mathbf {m}} _ {\\tau}, \\hat {\\mathbf {f}}, \\hat {\\mathbf {M}} _ {\\mathbf {f}} \\mathbf {s} ^ {\\prime (0)} ] ^ {\\top} \\operatorname {t e n s o r} (\\mathbf {r} _ {o}) = \\mathbf {e} _ {o} ^ {(0)}.</span></div>

    <p class="text-gray-300">And by Property (1) and the premise of <span class="math">\\mathsf{BAD}_3</span>, <span class="math">\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}</span> are valid openings of <span class="math">C_{\\mathbf{M}_{\\mathbf{f}}} = \\mathsf{com}(\\hat{\\tau_{\\mathbf{D}}}), \\mathsf{cm}_{\\mathbf{m}_{\\tau}}, \\mathsf{cm}_{\\mathbf{f}}</span>; and <span class="math">(C_{\\mathbf{M}_{\\mathbf{f}}}, (\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{M}}_{\\mathbf{f}})) \\in \\mathcal{R}_{\\mathsf{dopen}, dk}</span>.</p>

    <p class="text-gray-300">Conditioned on <span class="math">\\mathsf{Ext}</span> does not abort, define <span class="math">\\mathsf{w}&#x27; = [\\hat{\\tau_{\\mathbf{D}}}, \\hat{\\mathbf{m}}_{\\tau}, \\hat{\\mathbf{f}}]</span> and consider a mental experiment where we re-run <span class="math">\\mathsf{Ext}^{A^<em>}</span> with fresh randomness. If it does not abort, let <span class="math">\\mathsf{w}^</em></span> denote the extracted output, otherwise <span class="math">\\mathsf{w}^<em> := \\bot</span>. Consider the first transcript generated by the re-execution. Let <span class="math">\\mathbf{r}, \\mathbf{r}_o^</em></span> and <span class="math">\\mathbf{e}, \\mathbf{e}_o, u</span> be the random variables corresponding to the verifier randomness and claimed evaluations at Step 1, Eq. (18) and Eq. (22). Let <span class="math">\\mathbf{s}^{*&#x27;} \\in \\bar{\\mathcal{S}}^{dk}</span> be the</p>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">folding challenge. Note that <span class="math">\\mathbf{r},\\mathbf{r}_o^<em>,\\mathbf{s}^{</em>&#x27;}</span> are uniformly random, because the first transcript corresponds to the first call to <span class="math">\\mathcal{A}^<em></span>, and thus <span class="math">\\mathsf{Ext}^{\\mathcal{A}^</em>}</span> cannot bias the distribution. Let <span class="math">E^*</span> be the event that at least one event below occurs in the mental experiment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">B_1</span>: <span class="math">(\\mathbb{w}^<em> \\neq \\bot \\land \\mathbb{w}^</em> \\neq \\mathbb{w})</span>;</li>

      <li><span class="math">B_2</span>: <span class="math">(\\mathbb{w}^* = \\mathbb{w})</span> and <span class="math">(\\mathbb{z}, \\mathbb{w}) \\notin \\mathcal{R}_{\\mathbf{rg}, B}</span> and <span class="math">\\mathbb{w}^\\top \\text{tensor}(\\mathbf{r}) = \\mathbf{e}</span>;</li>

      <li><span class="math">B_3</span>: <span class="math">(\\mathbb{w}^<em> = \\mathbb{w})</span> and <span class="math">\\mathbb{w}^\\top \\text{tensor}(\\mathbf{r}) \\neq \\mathbf{e}</span> and <span class="math">[\\mathbb{w}&#x27;, \\hat{\\mathbf{M}}_{\\mathbf{f}} \\mathbf{s}^{</em>&#x27;}]^\\top \\text{tensor}(\\mathbf{r}) = (\\mathbf{e}[0,2], u)</span>;</li>

      <li><span class="math">B_4</span>: <span class="math">(\\mathbb{w}^<em> = \\mathbb{w})</span> and <span class="math">[\\mathbb{w}&#x27;, \\hat{\\mathbf{M}}_{\\mathbf{f}} \\mathbf{s}^{</em>&#x27;}]^\\top \\text{tensor}(\\mathbf{r}) \\neq (\\mathbf{e}[0,2], u)</span> and <span class="math">[\\mathbb{w}&#x27;, \\hat{\\mathbf{M}}_{\\mathbf{f}} \\mathbf{s}^{<em>&#x27;}]^\\top \\text{tensor}(\\mathbf{r}_o^</em>) = \\mathbf{e}_o</span>.</li>

    </ul>

    <p class="text-gray-300">By the binding property of <span class="math">\\mathsf{com}(\\cdot)</span> and <span class="math">\\mathsf{dcom}(\\cdot)</span> (Lemma 4.1), knowledge soundness of <span class="math">\\Pi_{\\mathbf{rgchk}}</span> (Lemma 4.7), Lemma 2.6, and Lemma 2.7, we have that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr [ E ^ {*} ] \\leq \\Pr [ B _ {1} ] + \\Pr [ B _ {2} ] + \\Pr [ B _ {3} ] + \\Pr [ B _ {4} ] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {\\text {b i n d}} + \\epsilon_ {\\mathrm {r g}} + d k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {\\mathcal {S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_ {\\text {s u m}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Note that if <span class="math">\\mathsf{BAD}_3</span> occurs in the mental experiment, then <span class="math">E^<em></span> must also occur. Moreover, <span class="math">\\mathsf{BAD}_3</span> occurs with the same probability in the real execution and the mental experiment. Thus <span class="math">\\operatorname</em>{Pr}[\\mathsf{BAD}_3] \\leq \\operatorname<em>{Pr}[E^</em>]</span> and the claim holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conditioned on that <span class="math">\\mathsf{Ext}</span> does not abort and <span class="math">\\mathsf{BAD}_1</span>, <span class="math">\\mathsf{BAD}_2</span>, <span class="math">\\mathsf{BAD}_3</span> do not occur, the extracted witness <span class="math">\\mathbb{w}</span> is valid for the input <span class="math">\\mathbb{z}</span>, i.e., <span class="math">(\\mathbb{z},\\mathbb{w}) \\in \\mathcal{R}_{\\mathbf{rg},B}</span>. Thus, <span class="math">\\Pi_{\\mathsf{cm}}</span> is knowledge sound with knowledge error $\\epsilon_{\\mathsf{cm},k} := (3 + dk) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_1 + \\epsilon_2 + \\epsilon_3$. This completes the proof of Lemma 4.10.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 4.9. We need to run two parallel sumchecks at Step 5 because Claim 2 relies on a union bound over up to $\\mu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathcal{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ adversary calls and the bound is meaningless if we only run one sumcheck. It is unclear whether this is merely a proof artifact or if a concrete attack exists. We leave it as an interesting future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we present a folding scheme for generalized committed linear relations (Definition 3.1). Fix norm bound <span class="math">B = (d&#x27;)^k</span> where <span class="math">k \\in \\mathbb{N}</span>. Let <span class="math">L</span> be the number of input instances and <span class="math">\\bar{S}</span> the folding challenge set. Let <span class="math">\\mathsf{com}(\\cdot)</span> be a general linear commitment defined in Section 4.1. For simplicity, we assume that <span class="math">\\mathsf{com}(\\cdot)</span> is <span class="math">(2B^{2},\\bar{S} -\\bar{S})</span>-binding and</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {\\mathcal {S}} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {o p}} L \\left(d ^ {\\prime} + 1 + B + d k\\right) \\leq B ^ {2}. \\tag {28}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For an indexed relation <span class="math">\\mathcal{R}</span> and <span class="math">m\\in \\mathbb{N}</span>, we use <span class="math">\\mathcal{R}^{(m)}</span> to denote the set of tuples <span class="math">(\\mathbb{I},(\\mathbb{z}_i,\\mathbb{w}_i)_{i\\in [m]})</span> such that <span class="math">(\\mathbb{I},\\mathbb{z}_i,\\mathbb{w}_i)\\in \\mathcal{R}</span> for all <span class="math">i\\in [m]</span>. Define online relation <span class="math">\\mathcal{R}_{\\mathrm{comp}} :=</span></p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{lin},B}^{(L-2)}</span> and accumulated relation <span class="math">\\mathcal{R}_{\\mathsf{acc}} := \\mathcal{R}_{\\mathsf{lin},B}^{(2)}</span>. Our goal is to build a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{comp}} \\times \\mathcal{R}_{\\mathsf{acc}}</span> to <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>. Our construction consists of two phases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Section 5.1, we reduce <span class="math">\\mathcal{R}_{\\mathrm{comp}} \\times \\mathcal{R}_{\\mathrm{acc}} = \\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span> by leveraging and adapting the commitment-transformation protocol <span class="math">\\Pi_{\\mathrm{cm}}</span> from Section 4.4.</li>

      <li>To avoid norm blowup and enable unbounded folding, Section 5.2 reduces <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span> to <span class="math">\\mathcal{R}_{\\mathrm{acc}} = \\mathcal{R}_{\\mathrm{lin},B}^{(2)}</span> by adapting a decomposition technique from [BC24].</li>

    </ol>

    <p class="text-gray-300">Remark 5.1. One could also use the "decompose-then-fold" strategy from [BC24], which decompose <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},\\sqrt{B}}^{(2L)}</span> and then reduce back to <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> via folding. This strategy allows a larger parameter <span class="math">B</span> if needed, as the witness norm bound never exceeds <span class="math">B</span>. However, it leads to a less efficient prover for computing <span class="math">2L</span> decomposed commitments.</p>

    <p class="text-gray-300">We state our main result below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 5.1. Fix <span class="math">\\bar{S}, L, B = (d&#x27;)^k</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math">, (28) holds and assume that </span>\\operatorname{com}(\\cdot)<span class="math"> is </span>(2B^2, \\bar{S} - \\bar{S})<span class="math">-binding (Section 4.1). There exists a reduction of knowledge from </span>\\mathcal{R}_{\\mathrm{comp}} \\times \\mathcal{R}_{\\mathrm{acc}}<span class="math"> to </span>\\mathcal{R}_{\\mathrm{acc}}<span class="math">, where </span>\\mathcal{R}_{\\mathrm{comp}} := \\mathcal{R}_{\\mathrm{lin},B}^{(L-2)}<span class="math"> and </span>\\mathcal{R}_{\\mathrm{acc}} := \\mathcal{R}_{\\mathrm{lin},B}^{(2)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The claim follows from Theorem 5.2, Lemma 5.1 and the sequential composition theorem (Theorem 2.1). <span class="math">\\square</span></p>

    <h2 id="sec-59" class="text-2xl font-bold">5.1 Folding</h2>

    <p class="text-gray-300">In this section, we show how to reduce <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span>. Let us first recall the definition of <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> from Section 3. Given a triple <span class="math">(\\mathbb{I},\\mathbb{x},\\mathbb{w})</span> defined by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {I} = \\left(\\operatorname {c o m} (\\cdot), \\left(\\mathbf {M} ^ {(i)} \\in R _ {q} ^ {n \\times n}\\right) _ {i \\in [ n _ {\\text {l i n}} ]}\\right), \\quad \\mathbb {x} = \\left(\\operatorname {c m} _ {\\mathbf {f}} \\in R _ {q} ^ {\\kappa}, \\mathbf {r} \\in \\mathsf {M} _ {\\mathcal {C}} ^ {\\log n}, \\mathbf {v} \\in \\mathsf {M} _ {q} ^ {n _ {\\text {l i n}}}\\right), \\quad \\mathbb {w} = \\mathbf {f} \\in R _ {q} ^ {n},</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{M}_{\\mathcal{C}} := \\mathcal{C} \\times \\mathcal{C}</span> and <span class="math">\\mathsf{M}_q := R_q \\times R_q</span>, <span class="math">(\\mathbb{I}, \\mathbb{x}, \\mathbb{w})</span> is in the relation <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> if</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {f} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B\\right) \\wedge \\left(\\operatorname {c m} _ {\\mathbf {f}}, \\mathbf {f}\\right) \\in \\mathcal {R} _ {\\text {o p e n}} \\wedge \\left(\\langle \\mathbf {M} ^ {(i)} \\cdot \\mathbf {f}, \\operatorname {t e n s o r} (\\mathbf {r}) \\rangle = \\mathbf {v} _ {i} \\forall i \\in [ n _ {\\text {l i n}} ]\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the commitment opening relation <span class="math">\\mathcal{R}_{\\mathrm{open}}</span> is defined in (6). Notably, a statement in <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> consists of <span class="math">L</span> different statements in <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> with distinct challenge vectors <span class="math">\\mathbf{r}_i</span>. So we need a reduction that unifies the challenges <span class="math">\\mathbf{r}_i</span> into a single challenge <span class="math">\\mathbf{r}_o</span> in the output statement. Next, we first illustrate how to reduce from <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2 / L}</span>; then via batching, we extend the idea and show the reduction from <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span>.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Warm-up.</h4>

    <p class="text-gray-300">We first show how to reduce a single statement in <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> to <span class="math">\\mathcal{R}_{\\mathsf{lin},B^{2}/L}</span>. While this basic scheme is primarily for illustration, we later extend it to reduce <span class="math">L&gt;1</span> statements in <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> to a single statement in <span class="math">\\mathcal{R}_{\\mathsf{lin},B^{2}}</span>. Notably, the reduction from <span class="math">\\mathcal{R}_{\\mathsf{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathsf{lin},B^{2}}</span> unifies the challenges <span class="math">\\mathbf{r}_{i}</span> in the input statements to a single challenge <span class="math">\\mathbf{r}_{o}</span> in the output.</p>

    <p class="text-gray-300">Our scheme, <span class="math">\\Pi_{\\mathsf{lin},B}</span>, is a simple adaptation to <span class="math">\\Pi_{\\mathsf{cm}}</span> in 4.5. The key difference is that each linear check in <span class="math">\\mathcal{R}_{\\mathsf{lin},B}</span> is represented as a sumcheck claim, and a (batched) sumcheck protocol is used to reduce the claim to a fresh linear check in the output statement. More formally, for each <span class="math">\\ell\\in[n_{\\mathsf{lin}}]</span>, let <span class="math">\\langle\\mathbf{M}^{(\\ell)}\\mathbf{f},\\mathsf{tensor}(\\mathbf{r})\\rangle=\\mathbf{v}_{\\ell}</span> be the <span class="math">\\ell</span>-th input linear check, we can rewrite it as a sumcheck claim</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\mathbf{m}(\\langle i\\rangle)\\mathit{eq}(\\mathbf{r},\\langle i\\rangle)\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{v}_{\\ell}</span> (29)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{m}(\\langle i\\rangle)</span> is defined as <span class="math">\\mathbf{m}(\\langle i\\rangle):=\\sum_{j\\in[n]}\\mathbf{M}_{i,j}^{(\\ell)}\\mathbf{f}_{j}=\\mathbf{M}_{i,*}^{(\\ell)}\\mathbf{f}</span>.</p>

    <p class="text-gray-300">By running a sumcheck protocol, we can reduce the claim in (29) to an evaluation claim <span class="math">\\widetilde{\\mathbf{m}}(\\mathbf{r}_{o})=\\mathbf{v}_{o,\\ell}</span>. By 2.3, this is equivalent to</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathbf{m}}(\\mathbf{r}_{o})=\\sum_{i\\in[n]}(\\mathbf{M}_{i,*}^{(\\ell)}\\mathbf{f})\\cdot\\mathsf{tensor}(\\mathbf{r}_{o})_{i}=\\langle\\mathbf{M}^{(\\ell)}\\mathbf{f},\\mathsf{tensor}(\\mathbf{r}_{o})\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{v}_{o,\\ell}\\,.</span></p>

    <p class="text-gray-300">In sum, we reduce <span class="math">\\langle\\mathbf{M}^{(\\ell)}\\mathbf{f},\\mathsf{tensor}(\\mathbf{r})\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{v}_{\\ell}</span> to <span class="math">\\langle\\mathbf{M}^{(\\ell)}\\mathbf{f},\\mathsf{tensor}(\\mathbf{r}_{o})\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{v}_{o,\\ell}</span>.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">The adapted protocol.</h4>

    <p class="text-gray-300">We consider a protocol <span class="math">\\Pi_{\\mathsf{cm}}^{\\prime}</span> that adapts <span class="math">\\Pi_{\\mathsf{cm}}</span> (c.f. 4.5). In Step 5, we have <span class="math">n_{\\mathsf{lin}}</span> more equations akin to (18), where the <span class="math">\\ell</span>-th equation is of the form</p>

    <p class="text-gray-300"><span class="math">\\left[\\mathbf{M}^{(\\ell)}\\left[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{h}\\right]\\right]^{\\top}\\cdot\\mathsf{tensor}(\\mathbf{r})\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{e}^{(\\ell)}.</span></p>

    <p class="text-gray-300">Note that the prover provides the <span class="math">\\mathbf{e}^{(\\ell)}</span>-values prior to learning the folding challenges <span class="math">\\mathbf{s}</span>, <span class="math">\\mathbf{s}^{\\prime}</span>. Then we transform these equations using the technique above, which lead to equations similar to (22), i.e., of the form</p>

    <p class="text-gray-300"><span class="math">\\left[\\mathbf{M}^{(\\ell)}\\left[\\tau_{\\mathbf{D}},\\mathbf{m}_{\\tau},\\mathbf{f},\\mathbf{h}\\right]\\right]^{\\top}\\cdot\\mathsf{tensor}(\\mathbf{r}_{o})\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{e}_{o}^{(\\ell)}\\,.</span></p>

    <p class="text-gray-300">Steps 6-8 of <span class="math">\\Pi_{\\mathsf{cm}}^{\\prime}</span> are similar to those in <span class="math">\\Pi_{\\mathsf{cm}}</span>, except that we also fold the <span class="math">\\mathbf{e}_{o}^{(\\ell)}</span> values. The output relation of <span class="math">\\Pi_{\\mathsf{cm}}^{\\prime}</span> is exactly <span class="math">\\mathcal{R}_{\\mathsf{lin},B^{2}/L}</span> by definition of <span class="math">\\mathcal{R}_{\\mathsf{com}}</span> (17).</p>

    <p class="text-gray-300">We describe the protocol <span class="math">\\Pi_{\\mathsf{lin},B}</span> below:</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Construction 5.1.</h6>

    <p class="text-gray-300">On input the index <span class="math">\\mathbb{I}=((\\mathbf{M}^{(i)}\\in R_{q}^{n\\times n})_{i\\in[n_{\\mathsf{lin}}]},\\mathsf{com}\\left(\\cdot\\right))</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathbb{{z}}=(\\mathsf{cm}_{\\mathbf{f}}\\in R_{q}^{\\kappa},\\mathbf{r}\\in\\mathsf{M}_{\\mathcal{C}}^{\\log n},\\mathbf{v}\\in\\mathsf{M}_{q}^{n_{\\mathsf{lin}}})\\,,\\quad\\mathbb{{w}}=\\mathbf{f}\\in R_{q}^{n}</span></p>

    <p class="text-gray-300">where <span class="math">(\\mathbb{I},\\mathbb{{z}},\\mathbb{{w}})\\in\\mathcal{R}_{\\mathsf{lin},B}</span>, define the decomposed matrix <span class="math">\\mathbf{D}_{\\mathbf{f}}</span> for <span class="math">\\mathbf{f}</span> as in (13). Set <span class="math">\\mathbf{M}_{\\mathbf{f}}\\in\\mathsf{EXP}(\\mathbf{D}_{\\mathbf{f}})</span>, <span class="math">\\tau_{\\mathbf{D}}=\\mathsf{split}(\\mathsf{com}\\left(\\mathbf{M}_{\\mathbf{f}}\\right))\\in(-d^{\\prime},d^{\\prime})^{n}</span> where <span class="math">\\mathsf{split}</span> is defined in 4.1, and <span class="math">\\mathbf{m}_{\\tau}\\in\\mathsf{EXP}(\\tau_{\\mathbf{D}})</span>. The protocol <span class="math">\\Pi_{\\mathsf{lin},B}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\to \\mathsf{V}</span> : Send commitments</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C_{\\mathbf{M}_{\\mathbf{f}}} = \\mathsf{dcom}(\\mathbf{M}_{\\mathbf{f}}) = \\mathsf{com}(\\tau_{\\mathbf{D}}) \\in R_{q}^{\\kappa}, \\qquad \\mathsf{cm}_{\\mathbf{m}_{\\tau}} = \\mathsf{com}(\\mathbf{m}_{\\tau}) \\in R_{q}^{\\kappa}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}</span> : Run protocol <span class="math">\\Pi_{\\mathsf{cm}}^{\\prime}</span>, checking that <span class="math">\\langle \\mathbf{M}^{(i)}\\mathbf{f}, \\text{tensor}(\\mathbf{r}) \\rangle = \\mathbf{v}_i \\forall i \\in [n_{\\mathrm{lin}}]</span>, and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf{z}&#x27; = (\\mathsf{cm}_{\\mathbf{f}}, C_{\\mathbf{M}_{\\mathbf{f}}}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}), \\mathbf{w}&#x27; = (\\tau_{\\mathbf{D}}, \\mathbf{m}_{\\tau}, \\mathbf{f}, \\mathbf{M}_{\\mathbf{f}})\\right) \\in \\mathcal{R}_{\\mathsf{rg}, B}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{R}_{\\mathbf{rg},B}</span> is defined in (14).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the reduced statement <span class="math">\\left(\\mathbb{I},\\mathbf{z}_o = (\\mathsf{cm}_{\\mathbf{g}},\\mathbf{r}_o,\\mathbf{v}_o),\\mathbf{w}_o = \\mathbf{g}\\in R_q^n\\right)\\in \\mathcal{R}_{\\mathrm{lin},B^2 /L}</span></li>

    </ol>

    <p class="text-gray-300">By Eq. (28), Theorem 4.3, and the previous argument for reducing linear checks, <span class="math">\\Pi_{\\mathrm{lin},B}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathrm{lin},B}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2 /L}</span>. The knowledge error <span class="math">\\epsilon_{\\mathrm{lin},k}</span> is identical to <span class="math">\\epsilon_{\\mathrm{cm},k}</span> (in Theorem 4.3). <span class="math">^{16}</span></p>

    <p class="text-gray-300"><strong>Folding multiple inputs.</strong> Next, we extend <span class="math">\\Pi_{\\mathrm{lin},B}</span> to reduce multiple statements in the committed linear relation to a single statement. Our goal is to reduce from <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span>. The construction is a simple adaptation of Construction 5.1 via batching. We can understand it as running <span class="math">L</span> parallel instances of <span class="math">\\Pi_{\\mathrm{lin},B}</span>, but with two modifications: First, all of the concurrent sumchecks are compressed to one using random linear combination (c.f. Remark 2.6). Second, the output witness is a (randomly) folded sum of the <span class="math">L</span> input (and intermediate) witnesses. This is equivalent to summing up the output witnesses from the <span class="math">L</span> individual executions of <span class="math">\\Pi_{\\mathrm{lin},B}</span>.</p>

    <p class="text-gray-300"><strong>Construction 5.2.</strong> On input the index <span class="math">\\mathbb{I} = ((\\mathbf{M}^{(i)}\\in R_q^{n\\times n})_{i\\in [n_{\\mathrm{lin}}]},\\mathsf{com}(\\cdot))</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{z} = \\left\\{\\mathbf{z}_i = (\\mathsf{cm}_{\\mathbf{f}_i} \\in R_q^{\\kappa}, \\mathbf{r}_i \\in \\mathsf{M}_{\\mathsf{C}}^{\\log n}, \\mathbf{v}^{(i)} \\in \\mathsf{M}_q^{n_{\\mathrm{lin}}}) \\right\\}_{i \\in [L]}, \\quad \\mathbf{w} = \\left\\{\\mathbf{f}_i \\in R_q^n \\right\\}_{i \\in [L]}</span></div>

    <p class="text-gray-300">where <span class="math">(\\mathbb{I},\\mathbf{z},\\mathbf{w})\\in \\mathcal{R}_{\\mathrm{lin},B}^{(L)}</span>, the protocol <span class="math">\\Pi_{\\mathsf{mlin},L,B}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P} \\leftrightarrow \\mathsf{V}</span> : Check <span class="math">(\\mathbb{I}, \\mathbf{z}_i, \\mathbf{f}_i) \\in \\mathcal{R}_{\\mathrm{lin}, B} \\forall i \\in [L]</span> by running <span class="math">L</span> executions of <span class="math">\\Pi_{\\mathrm{lin}, B}</span> in parallel and compressing the sumcheck claims to a single one using random linear combination (c.f. Remark 2.6).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote by <span class="math">\\{(\\mathsf{cm}_{\\mathbf{g}_i},\\mathbf{r}_o,\\mathbf{v}_o^{(i)},\\mathbf{g}_i)\\in \\mathcal{R}_{\\mathrm{lin},B^2 /L}\\}_{i\\in [L]}</span> the reduced statements of the <span class="math">L</span> (batched) executions of <span class="math">\\Pi_{\\mathrm{lin},B}</span>. Return the reduced statement</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf{z} = \\left(\\sum_{i \\in [L]} \\mathsf{cm}_{\\mathbf{g}_i}, \\mathbf{r}_o, \\sum_{i \\in [L]} \\mathbf{v}_o^{(i)}\\right), \\mathbf{w} = \\sum_{i \\in [L]} \\mathbf{g}_i\\right) \\in \\mathcal{R}_{\\mathrm{lin}, B^2}.</span></div>

    <p class="text-gray-300"><span class="math">^{16}</span>The difference between <span class="math">\\Pi_{\\mathrm{lin},B}</span> and <span class="math">\\Pi_{\\mathrm{cm}}</span> is that we have more sumcheck claims to verify at Step 5, which can be compressed to one using the technique from Remark 2.6.</p>

    <p class="text-gray-300">Theorem 5.2. If <span class="math">\\mathsf{com}(\\cdot)</span> is <span class="math">(2B^{2},\\mathcal{S} = \\bar{\\mathcal{S}} -\\bar{\\mathcal{S}})</span>-binding and Eq. (28) holds, then <span class="math">\\Pi_{\\mathsf{m}\\mathsf{lin},L,B}</span> is a reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{lin},B}^{(L)}</span> to <span class="math">\\mathcal{R}_{\\mathsf{lin},B^2}</span> with knowledge error <span class="math">\\epsilon_{\\mathsf{m}\\mathsf{lin},B,L}\\leq L\\cdot \\epsilon_{\\mathsf{lin},k}</span>.</p>

    <p class="text-gray-300">Proof. Public reducibility and completeness follows from that of <span class="math">\\Pi_{\\mathrm{lin},B}</span>. The proof of knowledge soundness is almost identical to that of Theorem 4.3, except that the number of folding challenges is multiplied by <span class="math">L</span>.</p>

    <h2 id="sec-63" class="text-2xl font-bold">5.2 Decomposition</h2>

    <p class="text-gray-300">In this section, we show how to reduce <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(2)}</span>. The scheme is a simple adaptation to the decomposition protocol from [BC24].</p>

    <p class="text-gray-300">Construction 5.3. On input the index <span class="math">\\mathbb{I} = ((\\mathbf{M}^{(i)}\\in R_q^{n\\times n})_{i\\in [n_{\\mathrm{lin}}]},\\mathsf{com}(\\cdot))</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {z} = \\left(\\operatorname {c m} _ {\\mathbf {f}} \\in R _ {q} ^ {\\kappa}, \\mathbf {r} \\in \\mathrm {M} _ {\\mathcal {C}} ^ {\\log n}, \\mathbf {v} \\in \\mathrm {M} _ {q} ^ {n _ {\\mathrm {l i n}}}\\right), \\quad \\mathbb {w} = (\\mathbf {f} \\in R _ {q} ^ {n})</span></div>

    <p class="text-gray-300">such that <span class="math">(\\mathbb{I},\\mathbb{z},\\mathbb{w})\\in \\mathcal{R}_{\\mathrm{lin},B^2}</span> the protocol <span class="math">\\Pi_{\\mathrm{decomp},B}</span> proceeds as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathsf{P} \\to \\mathsf{V}</span> : Decompose <span class="math">\\mathbf{f}</span> to <span class="math">\\mathbf{F} = [\\mathbf{F}^{(0)}, \\mathbf{F}^{(1)}] \\in R_q^{n \\times 2}</span> according to Footnote 3, such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math"> and </span>\\mathbf{f} = \\mathbf{F} \\times [1, B]^\\top<span class="math"> . Denote the commitment </span>\\mathbf{C} = \\mathsf{com}(\\mathbf{F}) \\in R_q^{\\kappa \\times 2}<span class="math"> and values </span>\\mathbf{v}^{(0)}, \\mathbf{v}^{(1)} \\in \\mathsf{M}_q^{n_{\\mathrm{lin}}}<span class="math"> such that for all </span>i \\in [2]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb {I}, \\mathbb {z} _ {i} = (\\mathbf {C} _ {*, i}, \\mathbf {r}, \\mathbf {v} ^ {(i)}), \\mathbb {w} _ {i} = \\mathbf {F} ^ {(i)}) \\in \\mathcal {R} _ {\\mathrm {l i n}, B}.</span></div>

    <p class="text-gray-300">Send <span class="math">\\mathbf{C}</span> and <span class="math">(\\mathbf{v}^{(i)})_{i\\in [2]}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}</span> : Check <span class="math">\\mathbf{C} \\times [1, B]^\\top \\stackrel{?}{=} \\mathsf{cm}_{\\mathbf{f}}</span> and <span class="math">\\mathbf{v}^{(0)} + B \\mathbf{v}^{(1)} \\stackrel{?}{=} \\mathbf{v}</span>. Return <span class="math">\\perp</span> if fail.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return the reduced statement <span class="math">\\mathbb{z}_o = (\\mathbf{C}_{*,i},\\mathbf{r},\\mathbf{v}^{(i)})_{i\\in [2]}</span> and <span class="math">\\mathbb{w}_o = \\mathbf{F}</span>.</li>

    </ol>

    <p class="text-gray-300">Remark 5.2. In applications like IVC/PCDs, <span class="math">L</span> is typically kept small (e.g., <span class="math">&amp;lt; 10</span>) to minimize the folding verifier circuit size, thus the norm <span class="math">\\bar{b}</span> of the output witness in Construction 5.2 is much smaller than <span class="math">B^2</span>. In this case, to improve efficiency, we can delay the decomposition step until more folding steps are completed, or replace the norm bound <span class="math">B</span> in <span class="math">\\Pi_{\\mathrm{decomp},B}</span> with <span class="math">\\sqrt{\\bar{b}} &amp;lt; B</span>.</p>

    <p class="text-gray-300">Lemma 5.1. <span class="math">\\Pi_{\\mathrm{decomp},B}</span> is RoK from <span class="math">\\mathcal{R}_{\\mathrm{lin},B^2}</span> to <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{(2)}</span> with no knowledge error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The proof is a simple adaptation to that in Lemma 3.3 of [BC24]. Public reducibility and completeness are trivial. Next, we prove knowledge soundness. Given malicious prover's output <span class="math">\\mathbb{z}_o = (\\mathbf{C}_{*,i},\\mathbf{r},\\mathbf{v}^{(i)})_{i\\in [2]}</span> and <span class="math">\\mathbb{w}_o = \\mathbf{F}</span> the extractor simply outputs <span class="math">\\mathbf{f} := \\mathbf{F} \\times [1,B]^\\top</span>. If the verifier checks at Step 2 pass and <span class="math">(\\mathbb{z}_o,\\mathbb{w}_o) \\in \\mathcal{R}_{\\mathrm{lin},B}^{(2)}</span> then $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{f}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B^2<span class="math"> and other checks in </span>\\mathcal{R}_{\\mathrm{lin},B^2}<span class="math"> are satisfied w.r.t. </span>\\mathbb{z} = (\\mathsf{cm}_{\\mathbf{f}},\\mathbf{r},\\mathbf{v})<span class="math">. Thus, </span>(\\mathbb{I},\\mathbb{z},\\mathbf{f}) \\in \\mathcal{R}_{\\mathrm{lin},B^2}$ and the claim holds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">5.3 Efficiency estimate</p>

    <p class="text-gray-300">Next, we analyze the complexity of the reduction of knowledge from <span class="math">\\mathcal{R}_{\\mathsf{comp}}\\times\\mathcal{R}_{\\mathsf{acc}}</span> to <span class="math">\\mathcal{R}_{\\mathsf{acc}}</span>. The scheme we consider is the version that applies the technique from Remark 4.6 and Remark 4.7.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 5.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">\\mathcal{\\bar{S}},L,B=(d^{\\prime})^{k}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{\\bar{S}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\lambda}<span class="math"> and (28) holds. Assume that </span>\\mathsf{com}\\left(\\cdot\\right):R_{q}^{n}\\to R_{q}^{\\kappa}<span class="math"> is </span>(2B^{2},\\mathcal{\\bar{S}}-\\mathcal{\\bar{S}})<span class="math">-binding and </span>d\\gg\\max(\\kappa,\\log n)<span class="math">. Let </span>n_{\\mathsf{lin}}<span class="math"> be the number of linear checks in </span>\\mathcal{R}_{\\mathsf{lin},B}<span class="math">. The RoK from </span>\\mathcal{R}_{\\mathsf{comp}}\\times\\mathcal{R}_{\\mathsf{acc}}<span class="math"> to </span>\\mathcal{R}_{\\mathsf{acc}}$, combined with the optimization in Remark 4.6 and Remark 4.7, has the following complexity:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Prover time: Dominated by <span class="math">Ln\\kappa</span> <span class="math">R_{q}</span>-multiplications and <span class="math">O(Ln\\kappa dk)</span> <span class="math">R_{q}</span>-additions.</p>

    <p class="text-gray-300">Verifier time (excluding hashing): Dominated by <span class="math">O(Ldk)</span> <span class="math">R_{q}</span>-multiplications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Online instance size: $(L-2)\\cdot[(\\kappa+2n_{\\mathsf{lin}})\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\log n\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Accumulated instance size: $2\\cdot[(\\kappa+2n_{\\mathsf{lin}})\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\log n\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Folding proof size: Dominated by <span class="math">L(5\\kappa+6)+10</span> <span class="math">R_{q}</span>-elements, <span class="math">L(dk+5)</span> <span class="math">\\mathcal{\\bar{S}}</span>-elements, and <span class="math">L(2dk+d+1)</span> <span class="math">\\mathcal{C}</span>-elements.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 5.3 (Further optimizing proof sizes).</h6>

    <p class="text-gray-300">We can further shorten the proof size by replacing the <span class="math">5L</span> commitments with <span class="math">5</span> commitments. The idea is to have a <em>single</em> batch of helper commitments (e.g., <span class="math">\\mathsf{dcom}\\left(\\mathbf{M_{f}}\\right),\\mathsf{com}\\left(\\mathbf{m}_{\\tau}\\right),\\mathsf{com}\\left(\\mathbf{h}\\right)</span>, etc.) for all of the <span class="math">L</span> inputs, rather than having separate helper commitments for each input.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Remark 5.4.</h6>

    <p class="text-gray-300">An <span class="math">\\mathcal{\\bar{S}}</span>-element is much smaller than an <span class="math">R_{q}</span>-element. E.g., if we choose <span class="math">d=64</span> and each coordinate of <span class="math">\\mathcal{\\bar{S}}</span> to be in <span class="math">\\{-1,0,1,2\\}</span>, it takes less than <span class="math">2d</span> bits to represent an element in <span class="math">\\mathcal{\\bar{S}}</span>, compared to <span class="math">d\\log q</span> bits for an <span class="math">R_{q}</span>-element.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof of Theorem 5.3.</h6>

    <p class="text-gray-300">We first analyze prover complexity. Since the sumchecks are all instantiated over fields (See Remark 4.6), even with more parallel repetitions (or running over extension fields) for small <span class="math">q</span>, they remain much cheaper than computing commitments over <span class="math">R_{q}</span>. Also, it is much more efficient to compute the commitments to <span class="math">\\tau_{\\mathbf{D}}\\in(-d^{\\prime},d^{\\prime})^{n}</span> and <span class="math">\\mathbf{m}_{\\tau}=\\mathsf{exp}(\\tau_{\\mathbf{D}})</span> (at Step 1) than standard Ajtai commitments: <span class="math">\\mathsf{com}\\left(\\tau_{\\mathbf{D}}\\right)</span> only requires scalar multiplications rather than <span class="math">R_{q}</span>-multiplications; and because <span class="math">\\mathbf{m}_{\\tau}\\in\\mathcal{M}^{n}</span>, by Remark 4.3, <span class="math">\\mathsf{com}\\left(\\mathbf{m}_{\\tau}\\right)</span> takes only <span class="math">O(n\\kappa)</span> <span class="math">R_{q}</span>-additions.</p>

    <p class="text-gray-300">Therefore, for each online input <span class="math">i\\in[L-2]</span>, the dominant cost is for computing <span class="math">\\mathsf{com}\\left(\\mathbf{f}_{i}\\right)</span> (which takes <span class="math">n\\kappa</span> <span class="math">R_{q}</span>-multiplications), plus the task of computing <span class="math">\\mathsf{com}\\left(\\mathbf{M_{f}_{i}}\\right)</span> where <span class="math">\\mathbf{M_{f}_{i}}\\in\\mathcal{M}^{n\\times dk}</span>. By Remark 4.3, the latter takes <span class="math">O(n\\kappa dk)</span> <span class="math">R_{q}</span>-additions. Additionally, the prover needs to compute two decomposed commitments in <span class="math">\\Pi_{\\mathsf{decomp},}</span>. Thus the prover complexity is as claimed.</p>

    <p class="text-gray-300">Next, we analyze verifier complexity. With the optimization from Remark 4.7, there are two main expensive steps: (i) the sumcheck verifier at Step 5 of Construction 4.5, which takes <span class="math">O(dk)</span> <span class="math">R_{q}</span>-operations for each input <span class="math">i\\in[L]</span>; (ii) the folding operation at Step 6, which takes <span class="math">O(\\kappa)</span> <span class="math">R_{q}</span>-operation for each input <span class="math">i\\in[L]</span>. Since <span class="math">d\\gg\\kappa</span> in practice, the verifier complexity is as claimed.</p>

    <p class="text-gray-300">The instance sizes are correct by inspection. Next, we analyze the folding proof size. Since the sumchecks are instantiated over fields and only have  <span class="math">\\log n \\ll d</span>  rounds, their communication complexities are much smaller compared to commitments and  <span class="math">R_{q}</span> -elements.</p>

    <p class="text-gray-300">For each input  <span class="math">i \\in [L]</span> , besides the 2 commitments,  <span class="math">2R_{q}</span> -elements, and  <span class="math">2dk</span> <span class="math">\\mathcal{C}</span> -elements introduced from the optimization in Remark 4.7, the proof size is dominated by the 2 commitments  <span class="math">C_{\\mathbf{M}_{\\ell}}, \\mathsf{cm}_{\\mathbf{m}_{\\tau}}</span>  sent at Step 1 of Construction 5.1, the  <span class="math">dk + 5</span>  folding challenges  <span class="math">(\\mathbf{s}, \\mathbf{s}^{\\prime})</span>  in  <span class="math">\\bar{S}</span>  sent at Step 2, the  <span class="math">\\mathsf{com}(\\mathbf{h})</span> -commitment sent at Step 3, and the  <span class="math">4R_{q}</span> -elements  <span class="math">\\mathbf{e}[0..2], u</span>  in Construction 4.5. Additionally, the verifier sends a vector  <span class="math">(\\mathbf{v}, a) \\in \\mathcal{C}^{d + 1}</span>  at Step 2 of Construction 4.4. In total, they are  <span class="math">(5\\kappa + 6)R_{q}</span> -elements,  <span class="math">dk + 5</span> <span class="math">\\bar{S}</span> -elements, and  <span class="math">2dk + d + 1</span> <span class="math">\\mathcal{C}</span> -elements, all multiplied by  <span class="math">L</span> . Finally, we need to separately add the  <span class="math">\\mathbf{e}_o</span> -values (consisting of  <span class="math">8 + 2R_{q}</span> -elements) at Step 5 of Construction 4.5. Thus the claim holds.</p>

    <p class="text-gray-300">Comparison with LatticeFold. LatticeFold+ is a significant improvement over LatticeFold [BC24], both asymptotically and concretely.</p>

    <p class="text-gray-300">In LatticeFold, the prover's complexity is dominated by an  <span class="math">n</span> -sized degree-4 sumcheck over  <span class="math">R_{q}</span>  and the computation of  <span class="math">L\\log_2(B)</span>  decomposed commitments. This requires at least  <span class="math">O(Ln\\kappa \\log_2(B)R_q</span> -multiplication, which is  <span class="math">\\Omega (\\log_2(B))</span> -times worse than LatticeFold+.</p>

    <p class="text-gray-300">The verifier circuit size of LatticeFold+, dominated by the Fiat-Shamir transform, is also much better. In LatticeFold, it takes more than  <span class="math">L\\log_2(B)</span>  decomposed commitments and  <span class="math">\\Omega (\\log_2(n))</span> <span class="math">R_{q}</span> -elements (for sumcheck executions) into its transcript. This is at least  <span class="math">\\Omega (\\log_2(B))</span> -times worse than LatticeFold+.</p>

    <p class="text-gray-300">Concrete prover complexity. By Theorem 5.3, Remark 4.3, Remark 4.6, for typical parameters (e.g., 128-bit or 64-bit  <span class="math">q</span> ), we expect prover time to be comparable to the cost of only committing to input witnesses. Given the high efficiency of module-based Ajtai commitments (e.g., see Footnote 2), we anticipate promising performance and leave concrete implementation for future work.</p>

    <p class="text-gray-300">Concrete verifier circuit size for Fiat-Shamir. As noted in Remark 4.7, proof size is crucial to minimize recursive verifier circuit complexity in applications like IVC/PCD. We provide a candidate set of parameters to show how small the Fiat-Shamir verifier circuit can be. While not highly optimized, this choice serves as a baseline, and we expect further efficiency gains with better parameter tuning.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># of hashes for Fiat-Shamir</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">128-bit</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">{-1,0,1,2}d</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The parameters are chosen for 128-bit conjectured hardness against the best-known attacks on Module-SIS [APS15; Esg+19; ADPS16; BDGL16]. The prime  <span class="math">q</span>  is selected so that  <span class="math">R_{q}</span></p>

    <p class="text-gray-300">splits into 16 factors, and by Lemma 2.4, <span class="math">\\bar{\\mathcal{S}}</span> is indeed a strong sampling set. We set <span class="math">n=2^{21}</span> to allow proving a R1CS statements over <span class="math">\\mathbb{F}_{q^{4}}</span> of size <span class="math">16\\cdot 2^{21}=2^{25}</span>.</p>

    <p class="text-gray-300">The folding proof size is under 200KB without the optimization from Remark 5.3 and <span class="math">\\lesssim 100</span>KB with the optimization. This corresponds to <span class="math">\\lesssim 100</span> hashes (over <span class="math">R_{q}</span>) in the Fiat-Shamir transform circuit, which dominates the circuit cost of our recursive folding verifier. While LaBRADOR achieves even smaller proof sizes for the Fiat-Shamir transform, its linear-time verifier prevents its use in recursive SNARKs. We also emphasize that, in folding-based IVC schemes, folding proofs serve as recursive witnesses and are not part of the final output proof.</p>

    <h2 id="sec-68" class="text-2xl font-bold">6 Conclusion and future work</h2>

    <p class="text-gray-300">We presented LatticeFold+, a lattice-based folding technique that leverages a new purely algebraic ring-based range check along with a commitment transformation protocol that converts a statement about double commitments into a linear statement that can be folded. The result is a lattice-based folding system that is faster than LatticeFold, produces shorter proofs, and has a simpler verification circuit.</p>

    <p class="text-gray-300">This work raises two interesting directions for future work. First, throughout the paper we used the <span class="math">\\ell_{\\infty}</span> norm rather than <span class="math">\\ell_{2}</span> to simplify the analysis of our sub-protocols. However, the <span class="math">\\ell_{\\infty}</span> norm leads to slightly worse parameters in the definition of Module-SIS compared to <span class="math">\\ell_{2}</span>. It would be interesting to develop an <span class="math">\\ell_{2}</span> variant of all of our protocols. Second, we defined all of our protocols over <span class="math">\\mathbb{Z}_{q}</span> modules for a prime <span class="math">q</span>. In practice, there may be interest in implementing these protocols modulo a power of two. It would be interesting to generalize all these results to operate over a non-prime modulus.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Acknowledgments.</h4>

    <p class="text-gray-300">We sincerely thank the anonymous CRYPTO reviewers for their helpful comments. We also thank Wilson Nguyen for noting the equivalence between the tensor-of-rings framework and Neo’s approach for supporting small moduli. This work was funded by NSF, DARPA, the Simons Foundation, and UBRI. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</p>

    <h2 id="sec-70" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACK21] Thomas Attema, Ronald Cramer, and Lisa Kohl. “A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices”. In: <em>CRYPTO 2021, Part II</em>. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 549–579. doi: 10.1007/978-3-030-84245-1_19.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[ADPS16] Erdem Alkim, Léo Ducas, Thomas Pöppelmann, and Peter Schwabe. “Post-quantum Key Exchange - A New Hope”. In: <em>USENIX Security 2016</em>. Ed. by Thorsten Holz and Stefan Savage. USENIX Association, Aug. 2016, pp. 327–343.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: <em>ACM CCS 2017</em>. Ed. by Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu. ACM Press, 2017, pp. 2087–2104. doi: 10.1145/3133956.3134104.</li>

      <li>[Ajt96] Miklós Ajtai. “Generating Hard Instances of Lattice Problems (Extended Abstract)”. In: <em>28th ACM STOC</em>. ACM Press, May 1996, pp. 99–108. doi: 10.1145/237814.237838.</li>

      <li>[AL21] Martin R. Albrecht and Russell W. F. Lai. “Subtractive Sets over Cyclotomic Rings - Limits of Schnorr-Like Arguments over Lattices”. In: <em>CRYPTO 2021, Part II</em>. Ed. by Tal Malkin and Chris Peikert. Vol. 12826. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 519–548. doi: 10.1007/978-3-030-84245-1_18.</li>

      <li>[Alb+22] Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. “Lattice-Based SNARKs: Publicly Verifiable, Preprocessing, and Recursively Composable - (Extended Abstract)”. In: <em>CRYPTO 2022, Part II</em>. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Cham, Aug. 2022, pp. 102–132. doi: 10.1007/978-3-031-15979-4_4.</li>

      <li>[ALS20] Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. “Practical Product Proofs for Lattice Commitments”. In: <em>CRYPTO 2020, Part II</em>. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Cham, Aug. 2020, pp. 470–499. doi: 10.1007/978-3-030-56880-1_17.</li>

      <li>[APS15] Martin R Albrecht, Rachel Player, and Sam Scott. “On the concrete hardness of learning with errors”. In: <em>Journal of Mathematical Cryptology</em> 9.3 (2015), pp. 169–203.</li>

      <li>[AS24] Arasu Arun and Srinath Setty. <em>Nebula: Efficient read-write memory and switchboard circuits for folding schemes</em>. Cryptology ePrint Archive, Paper 2024/1605. 2024. url: https://eprint.iacr.org/2024/1605.</li>

      <li>[Bau+18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. “Sub-linear Lattice-Based Zero-Knowledge Arguments for Arithmetic Circuits”. In: <em>CRYPTO 2018, Part II</em>. Ed. by Hovav Shacham and Alexandra Boldyreva. Vol. 10992. LNCS. Springer, Cham, Aug. 2018, pp. 669–699. doi: 10.1007/978-3-319-96881-0_23.</li>

    </ul>

    <p class="text-gray-300">[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. “Verifiable Delay Functions”. In: CRYPTO 2018, Part I. Ed. by Hovav Shacham and Alexandra Boldyreva. Vol. 10991. LNCS. Springer, Cham, Aug. 2018, pp. 757–788. doi: 10.1007/978-3-319-96884-1_25.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed-Solomon Interactive Oracle Proofs of Proximity”. In: ICALP 2018. Ed. by Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella. Vol. 107. LIPIcs. Schloss Dagstuhl, July 2018, 14:1–14:17. doi: 10.4230/LIPIcs.ICALP.2018.14.</li>

      <li>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046. 2018. url: https://eprint.iacr.org/2018/046.</li>

      <li>[BC23] Benedikt Bünz and Binyi Chen. “Protostar: Generic Efficient Accumulation/Folding for Special-Sound Protocols”. In: ASIACRYPT 2023, Part II. Ed. by Jian Guo and Ron Steinfeld. Vol. 14439. LNCS. Springer, Singapore, Dec. 2023, pp. 77–110. doi: 10.1007/978-981-99-8724-5_3.</li>

      <li>[BC24] Dan Boneh and Binyi Chen. LatticeFold: A Lattice-based Folding Scheme and its Applications to Succinct Proof Systems. Cryptology ePrint Archive, Report 2024/257. 2024. url: https://eprint.iacr.org/2024/257.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: TCC 2020, Part II. Ed. by Rafael Pass and Krzysztof Pietrzak. Vol. 12551. LNCS. Springer, Cham, Nov. 2020, pp. 1–18. doi: 10.1007/978-3-030-64378-2_1.</li>

      <li>[BCPS18] Anurag Bishnoi, Pete L Clark, Aditya Potukuchi, and John R Schmitt. “On zeros of a polynomial in a finite grid”. In: Combinatorics, Probability and Computing 27.3 (2018), pp. 310–333.</li>

      <li>[BCS21] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Sumcheck Arguments and Their Applications”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 742–773. doi: 10.1007/978-3-030-84242-0_26.</li>

      <li>[BCS23] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. “Lattice-Based Succinct Arguments for NP with Polylogarithmic-Time Verification”. In: CRYPTO 2023, Part II. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14082. LNCS. Springer, Cham, Aug. 2023, pp. 227–251. doi: 10.1007/978-3-031-38545-2_8.</li>

    </ul>

    <p class="text-gray-300">[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: CRYPTO 2014, Part II. Ed. by Juan A. Garay and Rosario Gennaro. Vol. 8617. LNCS. Springer, Berlin, Heidelberg, Aug. 2014, pp. 276–294. doi: 10.1007/978-3-662-44381-1_16.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BDFG21] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. “Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 649–680. doi: 10.1007/978-3-030-84242-0_23.</li>

      <li>[BDGL16] Anja Becker, Léo Ducas, Nicolas Gama, and Thijs Laarhoven. “New directions in nearest neighbor searching with applications to lattice sieving”. In: 27th SODA. Ed. by Robert Krauthgamer. ACM-SIAM, Jan. 2016, pp. 10–24. doi: 10.1137/1.9781611974331.ch2.</li>

      <li>[Ben+19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: EUROCRYPT 2019, Part I. Ed. by Yuval Ishai and Vincent Rijmen. Vol. 11476. LNCS. Springer, Cham, May 2019, pp. 103–128. doi: 10.1007/978-3-030-17653-2_4.</li>

      <li>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019. url: https://eprint.iacr.org/2019/1021.</li>

      <li>[BLNS20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. “A Non-PCP Approach to Succinct Quantum-Safe Zero-Knowledge”. In: CRYPTO 2020, Part II. Ed. by Daniele Micciancio and Thomas Ristenpart. Vol. 12171. LNCS. Springer, Cham, Aug. 2020, pp. 441–469. doi: 10.1007/978-3-030-56880-1_16.</li>

      <li>[BMNW24] Benedikt Bünz, Pratyush Mishra, Wilson Nguyen, and William Wang. Arc: Accumulation for Reed–Solomon Codes. Cryptology ePrint Archive, Paper 2024/1731. 2024. url: https://eprint.iacr.org/2024/1731.</li>

      <li>[Bre+24] Martijn Brehm, Binyi Chen, Ben Fisch, Nicolas Resch, Ron D. Rothblum, and Hadas Zeilberger. Blaze: Fast SNARKs from Interleaved RAA Codes. Cryptology ePrint Archive, Paper 2024/1609. 2024. url: https://eprint.iacr.org/2024/1609.</li>

      <li>[BS23] Ward Beullens and Gregor Seiler. “LaBRADOR: Compact Proofs for R1CS from Module-SIS”. In: CRYPTO 2023, Part V. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14085. LNCS. Springer, Cham, Aug. 2023, pp. 518–548. doi: 10.1007/978-3-031-38554-4_17.</li>

    </ul>

    <p class="text-gray-300">[Bün+18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 315–334. doi: 10.1109/SP.2018.00020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Bün+21] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. “Proof-Carrying Data Without Succinct Arguments”. In: CRYPTO 2021, Part I. Ed. by Tal Malkin and Chris Peikert. Vol. 12825. LNCS. Virtual Event: Springer, Cham, Aug. 2021, pp. 681–710. doi: 10.1007/978-3-030-84242-0_24.</li>

      <li>[CBBZ23] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. “HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates”. In: EUROCRYPT 2023, Part II. Ed. by Carmit Hazay and Martijn Stam. Vol. 14005. LNCS. Springer, Cham, Apr. 2023, pp. 499–530. doi: 10.1007/978-3-031-30617-4_17.</li>

      <li>[CCKP19] Shuo Chen, Jung Hee Cheon, Dongwoo Kim, and Daejun Park. Verifiable Computing for Approximate Computation. Cryptology ePrint Archive, Report 2019/762. 2019. url: https://eprint.iacr.org/2019/762.</li>

      <li>[CMNW24] Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, and Hoeteck Wee. “Polynomial Commitments from Lattices: Post-quantum Security, Fast Verification and Transparent Setup”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 207–242. doi: 10.1007/978-3-031-68403-6_7.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. “Fractal: Post-quantum and Transparent Recursive Proofs from Holography”. In: EUROCRYPT 2020, Part I. Ed. by Anne Canteaut and Yuval Ishai. Vol. 12105. LNCS. Springer, Cham, May 2020, pp. 769–793. doi: 10.1007/978-3-030-45721-1_27.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. “Proof-Carrying Data and Hearsay Arguments from Signature Cards”. In: ICS 2010. Ed. by Andrew Chi-Chih Yao. Tsinghua University Press, Jan. 2010, pp. 310–331.</li>

      <li>[CWSK24] Bing-Jyue Chen, Suppakit Waiwitlikhit, Ion Stoica, and Daniel Kang. “ZKML: An Optimizing System for ML Inference in Zero-Knowledge Proofs”. In: Proceedings of the Nineteenth European Conference on Computer Systems, EuroSys 2024, Athens, Greece, April 22-25, 2024. ACM, 2024, pp. 560–574. doi: 10.1145/3627703.3650088. url: https://doi.org/10.1145/3627703.3650088.</li>

      <li>[DB22] Trisha Datta and Dan Boneh. Using ZK Proofs to Fight Disinformation. link. 2022.</li>

    </ul>

    <p class="text-gray-300">[DP24] Benjamin E. Diamond and Jim Posen. <em>Polylogarithmic Proofs for Multilinears over Binary Towers</em>. Cryptology ePrint Archive, Report 2024/504. 2024. url: https://eprint.iacr.org/2024/504.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[EG23] Liam Eagen and Ariel Gabizon. <em>ProtoGalaxy: Efficient ProtoStar-style folding of multiple instances</em>. Cryptology ePrint Archive, Report 2023/1106. 2023. url: https://eprint.iacr.org/2023/1106.</li>

      <li>[ENS20] Muhammed F. Esgin, Ngoc Khanh Nguyen, and Gregor Seiler. “Practical Exact Proofs from Lattices: New Techniques to Exploit Fully-Splitting Rings”. In: <em>ASIACRYPT 2020, Part II</em>. Ed. by Shiho Moriai and Huaxiong Wang. Vol. 12492. LNCS. Springer, Cham, Dec. 2020, pp. 259–288. doi: 10.1007/978-3-030-64834-3_9.</li>

      <li>[Esg+19] Muhammed F. Esgin, Ron Steinfeld, Amin Sakzad, Joseph K. Liu, and Dongxi Liu. “Short Lattice-Based One-out-of-Many Proofs and Applications to Ring Signatures”. In: <em>ACNS 19International Conference on Applied Cryptography and Network Security</em>. Ed. by Robert H. Deng, Valérie Gauthier-Umaña, Martín Ochoa, and Moti Yung. Vol. 11464. LNCS. Springer, Cham, June 2019, pp. 67–88. doi: 10.1007/978-3-030-21568-2_4.</li>

      <li>[FKNP24] Giacomo Fenzi, Christian Knabenhans, Ngoc Khanh Nguyen, and Duc Tu Pham. “Lova: Lattice-Based Folding Scheme from Unstructured Lattices”. In: <em>ASIACRYPT 2024, Part IV</em>. Ed. by Kai-Min Chung and Yu Sasaki. Vol. 15487. LNCS. Springer, Singapore, Dec. 2024, pp. 303–326. doi: 10.1007/978-981-96-0894-2_10.</li>

      <li>[FMN24] Giacomo Fenzi, Hossein Moghaddas, and Ngoc Khanh Nguyen. “Lattice-Based Polynomial Commitments: Towards Asymptotic and Concrete Efficiency”. In: <em>Journal of Cryptology</em> 37.3 (July 2024), p. 31. doi: 10.1007/s00145-024-09511-8.</li>

      <li>[Gol+23] Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. “Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS”. In: <em>CRYPTO 2023, Part II</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14082. LNCS. Springer, Cham, Aug. 2023, pp. 193–226. doi: 10.1007/978-3-031-38545-2_7.</li>

      <li>[KHSS22] Daniel Kang, Tatsunori Hashimoto, Ion Stoica, and Yi Sun. <em>ZK-IMG: Attested Images via Zero-Knowledge Proofs to Fight Disinformation</em>. 2022. eprint: 2211.04775.</li>

      <li>[KLNO24] Michael Klooß, Russell W. F. Lai, Ngoc Khanh Nguyen, and Michal Osadnik. “RoK, Paper, SISsors Toolkit for Lattice-Based Succinct Arguments - (Extended Abstract)”. In: <em>ASIACRYPT 2024, Part V</em>. Ed. by Kai-Min Chung and Yu Sasaki. Vol. 15488. LNCS. Springer, Singapore, Dec. 2024, pp. 203–235. doi: 10.1007/978-981-96-0935-2_7.</li>

    </ul>

    <p class="text-gray-300">[KP23] Abhiram Kothapalli and Bryan Parno. “Algebraic Reductions of Knowledge”. In: CRYPTO 2023, Part IV. Ed. by Helena Handschuh and Anna Lysyanskaya. Vol. 14084. LNCS. Springer, Cham, Aug. 2023, pp. 669–701. doi: 10.1007/978-3-031-38551-3_21.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KS24a] Abhiram Kothapalli and Srinath Setty. NeutronNova: Folding everything that reduces to zero-check. Cryptology ePrint Archive, Paper 2024/1606. 2024. URL: https://eprint.iacr.org/2024/1606.</li>

      <li>[KS24b] Abhiram Kothapalli and Srinath T. V. Setty. “HyperNova: Recursive Arguments for Customizable Constraint Systems”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 345–379. doi: 10.1007/978-3-031-68403-6_11.</li>

      <li>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: CRYPTO 2022, Part IV. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13510. LNCS. Springer, Cham, Aug. 2022, pp. 359–388. doi: 10.1007/978-3-031-15985-5_13.</li>

      <li>[LM06] Vadim Lyubashevsky and Daniele Micciancio. “Generalized Compact Knapsacks Are Collision Resistant”. In: ICALP 2006, Part II. Ed. by Michele Bugliesi, Bart Preneel, Vladimiro Sassone, and Ingo Wegener. Vol. 4052. LNCS. Springer, Berlin, Heidelberg, July 2006, pp. 144–155. doi: 10.1007/11787006_13.</li>

      <li>[LNP22] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. “Lattice-Based Zero-Knowledge Proofs and Applications: Shorter, Simpler, and More General”. In: CRYPTO 2022, Part II. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Vol. 13508. LNCS. Springer, Cham, Aug. 2022, pp. 71–101. doi: 10.1007/978-3-031-15979-4_3.</li>

      <li>[LS15] Adeline Langlois and Damien Stehlé. “Worst-case to average-case reductions for module lattices”. In: DCC 75.3 (2015), pp. 565–599. doi: 10.1007/s10623-014-9938-4.</li>

      <li>[LS18] Vadim Lyubashevsky and Gregor Seiler. “Short, Invertible Elements in Partially Splitting Cyclotomic Rings and Applications to Lattice-Based Zero-Knowledge Proofs”. In: EUROCRYPT 2018, Part I. Ed. by Jesper Buus Nielsen and Vincent Rijmen. Vol. 10820. LNCS. Springer, Cham, 2018, pp. 204–224. doi: 10.1007/978-3-319-78381-9_8.</li>

      <li>[Moh23] Nicolas Mohnblatt. Sangria: a folding scheme for PLONK. link. 2023.</li>

      <li>[NBS23] Wilson D. Nguyen, Dan Boneh, and Srinath T. V. Setty. “Revisiting the Nova Proof System on a Cycle of Curves”. In: 5th Conference on Advances in Financial Technologies, AFT 2023. Vol. 282. LIPIcs. 2023, 18:1–18:22.</li>

    </ul>

    <p class="text-gray-300">doi: 10.4230/LIPICS.AFT.2023.18. URL: https://doi.org/10.4230/LIPIcs.AFT.2023.18.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Net24] Nethermind. Latticefold and lattice-based operations performance report. 2024.</li>

      <li>[Ngu+24] Wilson D. Nguyen, Trisha Datta, Binyi Chen, Nirvan Tyagi, and Dan Boneh. “Mangrove: A Scalable Framework for Folding-Based SNARKs”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 308–344. doi: 10.1007/978-3-031-68403-6_10.</li>

      <li>[NS24] Ngoc Khanh Nguyen and Gregor Seiler. “Greyhound: Fast Polynomial Commitments from Lattices”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 243–275. doi: 10.1007/978-3-031-68403-6_8.</li>

      <li>[NS25] Wilson Nguyen and Srinath Setty. Neo: Lattice-based folding scheme for CCS over small fields and pay-per-bit commitments. Cryptology ePrint Archive, Report 2025/294. 2025. URL: https://eprint.iacr.org/2025/294.</li>

      <li>[NT16] Assa Naveh and Eran Tromer. “PhotoProof: Cryptographic Image Authentication for Any Set of Permissible Transformations”. In: 2016 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2016, pp. 255–271. doi: 10.1109/SP.2016.23.</li>

      <li>[PR06] Chris Peikert and Alon Rosen. “Efficient Collision-Resistant Hashing from Worst-Case Assumptions on Cyclic Lattices”. In: TCC 2006. Ed. by Shai Halevi and Tal Rabin. Vol. 3876. LNCS. Springer, Berlin, Heidelberg, Mar. 2006, pp. 145–166. doi: 10.1007/11681878_8.</li>

      <li>[RZ22] Carla Ràfols and Alexandros Zacharakis. Folding Schemes with Selective Verification. Cryptology ePrint Archive, Report 2022/1576. 2022. URL: https://eprint.iacr.org/2022/1576.</li>

      <li>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, Report 2023/552. 2023. URL: https://eprint.iacr.org/2023/552.</li>

      <li>[Val08] Paul Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: TCC 2008. Ed. by Ran Canetti. Vol. 4948. LNCS. Springer, Berlin, Heidelberg, Mar. 2008, pp. 1–18. doi: 10.1007/978-3-540-78524-8_1.</li>

      <li>[Whi18] Barry Whitehat. Roll up token. link. 2018.</li>

    </ul>

    <p class="text-gray-300">[Xie+22] Tiancheng Xie, Jiaheng Zhang, Zerui Cheng, Fan Zhang, Yupeng Zhang, Yongzheng Jia, Dan Boneh, and Dawn Song. "zkBridge: Trustless Cross-chain Bridges Made Practical". In: ACM CCS 2022. Ed. by Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi. ACM Press, Nov. 2022, pp. 3003-3017. DOI: 10.1145/3548606.3560652. [YCBC24] Chhavi Yadav, Amrita Roy Chowdhury, Dan Boneh, and Kamalika Chaudhuri. "FairProof: Confidential and Certifiable Fairness for Neural Networks". In: ICML 2024. OpenReview.net, 2024. URL: https://openreview.net/forum?id=EKye56rLuv. [ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. “BaseFold: Efficient Field-Agnostic Polynomial Commitment Schemes from Foldable Codes”. In: CRYPTO 2024, Part X. Ed. by Leonid Reyzin and Douglas Stebila. Vol. 14929. LNCS. Springer, Cham, Aug. 2024, pp. 138–169. DOI: 10.1007/978-3-031-68403-6_5.</p>

    <p class="text-gray-300">In this section we describe a reduction of knowledge from a committed R1CS relation to the general linear relation from Section 3. First, let us define the committed R1CS relation.</p>

    <p class="text-gray-300">Definition A.1 (Committed R1CS). A committed R1CS relation is an indexed relation parameterized by  <span class="math">B \\in \\mathbb{N}</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {c R 1 C S}, B} := \\left\\{ \\begin{array}{l l} &amp; \\mathbb {I} = (\\mathbf {A}, \\mathbf {B}, \\mathbf {C} \\in R _ {q} ^ {n \\times m}), \\\\ (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}): &amp; \\mathbb {x} = \\left(\\mathrm {c m} \\in R _ {q} ^ {\\kappa}, \\mathbf {x} \\in R _ {q} ^ {\\ell_ {\\mathrm {i n}}}\\right), \\quad \\mathbb {w} = \\mathbf {f} \\in R _ {q} ^ {n} \\quad \\text {w h e r e} \\\\ &amp; \\mathrm {c m} = \\operatorname {c o m} (\\mathbf {f}), \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {f} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B, \\quad \\text {a n d f o r} \\quad \\mathbf {z} = \\mathbf {G} _ {B, \\hat {\\ell}} ^ {\\top} \\cdot \\mathbf {f} \\in R _ {q} ^ {m}: \\\\ &amp; (\\mathbf {A z}) \\circ (\\mathbf {B z}) = (\\mathbf {C z}), \\quad \\mathbf {z} [ 0 \\dots \\ell_ {\\mathrm {i n}} ] = (1, \\mathbf {x}) \\end{array} \\right\\} \\tag {30}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\hat{\\ell} \\coloneqq \\lceil \\log_B(q) \\rceil</span>  and  <span class="math">\\mathbf{G}_{B,\\hat{\\ell}} \\in \\mathbb{Z}_q^{m\\hat{\\ell} \\times m} = \\mathbb{Z}_q^{n \\times m}</span>  is the gadget matrix from Section 2.1.</p>

    <p class="text-gray-300">In this definition we assumed that the dimension of the R1CS matrices is  <span class="math">n \\times m</span>  and that  <span class="math">n = m \\times \\hat{\\ell}</span> , where  <span class="math">\\hat{\\ell}</span>  is the expansion factor of the gadget matrix  <span class="math">\\mathbf{G}_{B,\\hat{\\ell}}</span> . One can just as easily describe a reduction of knowledge when the R1CS matrices are  <span class="math">n&#x27; \\times m</span> , for an unconstrained  <span class="math">n&#x27;</span> , however this complicates the tensor notation from Remark 2.3 since it requires tensors on varying number of variables. To keep things simple we assume  <span class="math">n = m \\times \\hat{\\ell}</span> .</p>

    <p class="text-gray-300">We first introduce a simplified linear relation,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {l i n}, B} ^ {\\prime} := \\left\\{ \\begin{array}{l l} &amp; \\mathbb {I} = \\left(\\operatorname {c o m} (\\cdot), \\left(\\mathbf {M} ^ {(i)} \\in R _ {q} ^ {n \\times n}\\right) _ {i \\in [ n _ {\\mathrm {l i n}} ]}\\right), \\\\ (\\mathbb {I}, \\mathbb {x}, \\mathbb {w}): &amp; \\mathbb {x} = \\left(\\operatorname {c m} _ {\\mathbf {f}}, \\mathbf {r} \\in \\mathcal {C} ^ {\\log n}, \\mathbf {v} \\in R _ {q} ^ {n _ {\\mathrm {l i n}}}\\right), \\quad \\mathbb {w} = \\mathbf {f} \\in R _ {q} ^ {n} \\quad \\text {s . t .} \\\\ &amp; \\left(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {f} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} &lt;   B\\right) \\wedge \\left(\\operatorname {c m} _ {\\mathbf {f}} = \\operatorname {c o m} (\\mathbf {f})\\right) \\wedge \\\\ &amp; \\left(\\forall i \\in [ n _ {\\mathrm {l i n}} ]: \\langle \\mathbf {M} ^ {(i)} \\cdot \\mathbf {f}, \\operatorname {t e n s o r} (\\mathbf {r}) \\rangle = \\mathbf {v} _ {i}\\right) \\end{array} \\right\\} \\tag {31}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">which is almost identical to  <span class="math">\\mathcal{R}_{\\mathrm{fin},B}</span>  except that we replace  <span class="math">\\mathsf{M}_q\\coloneqq R_q\\times R_q</span> <span class="math">\\mathsf{M}_{\\mathcal{C}}\\coloneqq \\mathcal{C}\\times \\mathcal{C}</span>  (from  <span class="math">\\mathcal{R}_{\\mathrm{fin},B}</span> ) with  <span class="math">R_{q}</span> ,  <span class="math">\\mathcal{C}</span>  respectively.</p>

    <p class="text-gray-300">The protocol to reduce  <span class="math">\\mathcal{R}_{\\mathrm{erics},B}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{fin},B}^{\\prime}</span>  is shown in Figure 1. Its completeness, knowledge soundness, and public reducibility are analyzed in [BC24, Sec. 4]. Let  <span class="math">\\mathbf{z}_o \\coloneqq (\\mathsf{cm},\\mathbf{r}_o,(v,v_{\\mathbf{A}},v_{\\mathbf{B}},v_{\\mathbf{C}}))</span>  denote the reduced instance in  <span class="math">\\mathcal{R}_{\\mathrm{fin},B}^{\\prime}</span> . To complete the reduction, we expand  <span class="math">\\mathbf{z}_o</span>  to an instance  <span class="math">\\mathbf{z}_o^\\prime</span>  in  <span class="math">\\mathcal{R}_{\\mathrm{fin},B}</span>  defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {z} _ {o} ^ {\\prime} := \\left(\\mathsf {c m}, \\mathbf {r} _ {o} ^ {\\prime} := (\\mathbf {r} _ {o}, \\mathbf {r} _ {o}) \\in \\mathsf {M} _ {\\mathcal {C}}, ((v, v), (v _ {\\mathbf {A}}, v _ {\\mathbf {A}}), (v _ {\\mathbf {B}}, v _ {\\mathbf {B}}), (v _ {\\mathbf {C}}, v _ {\\mathbf {C}})) \\in \\mathsf {M} _ {q} ^ {4}\\right).</span></div>

    <p class="text-gray-300">Remark A.1. In Figure 1, the evaluation  <span class="math">v = \\widetilde{\\mathbf{f}}(\\mathbf{r}_o)</span>  is never used. A reader may wonder why we need it in the reduced instance. This is because the accumulated instance in our folding scheme (Section 5.1) requires an evaluation check, which is the result of the sumcheck in Construction 5.2. So we add this evaluation value to align with the accumulated instance.</p>

    <p class="text-gray-300">In this section, we show how to support small prime moduli in LatticeFold+. Our approach is equivalent to the one used in [NS25], but we reinterpret it using the tensor-of-rings framework inspired by [DP24].</p>

    <p class="text-gray-300">Let  <span class="math">q</span>  be a prime modulus. Let  <span class="math">\\mathbb{K} = \\mathbb{F}_{q^t}</span>  be a sufficiently large extension field. Define the tensor ring  <span class="math">\\mathbb{E} \\coloneqq \\mathbb{K} \\otimes_{\\mathbb{F}_q} R_q</span> , which is a  <span class="math">\\mathbb{F}_q</span> -vector space of dimension  <span class="math">t \\times d</span> . We can view  <span class="math">\\mathbb{E}</span>  as a  <span class="math">\\mathbb{F}_q</span> -matrix of dimension  <span class="math">t \\times d</span> , where each row can be viewed as an  <span class="math">R_q</span> -element and each column can be viewed as a  <span class="math">\\mathbb{K}</span> -element. Importantly, there are two ways to interpret a "multiplication" between an  <span class="math">R_q</span> -element  <span class="math">a(X)</span>  and a  <span class="math">\\mathbb{K}</span> -element  <span class="math">b(Y)</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Column interpretation: View  <span class="math">a(X)</span>  as its coefficient vector  <span class="math">(a_1, \\ldots, a_d) \\in \\mathbb{Z}_q^d</span> , the multiplication  <span class="math">a(X) \\cdot b(Y) \\in \\mathbb{E}</span>  is interpreted as the matrix  $[a_1 \\cdot b(Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_2 \\cdot b(Y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_d \\cdot b(Y)]<span class="math"> , where we view  </span>a_i \\in \\mathbb{Z}_q<span class="math">  ( </span>1 \\leq i \\leq d<span class="math"> ) as a constant element in  </span>\\mathbb{K} = \\mathbb{F}_{q^t}<span class="math">  and “.” denotes  </span>\\mathbb{K}$ -multiplication.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Row interpretation: View  <span class="math">b(Y)</span>  as its coefficient vector  <span class="math">(b_1, \\ldots, b_t) \\in \\mathbb{Z}_q^t</span> , the multiplication  <span class="math">a(X) \\cdot b(Y) \\in \\mathbb{E}</span>  is interpreted as the matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\begin{array}{c} a (X) \\cdot b _ {1} \\\\ a (X) \\cdot b _ {2} \\\\ \\vdots \\\\ a (X) \\cdot b _ {t} \\end{array} \\right]</span></div>

    <p class="text-gray-300">where we view  <span class="math">b_{i} \\in \\mathbb{Z}_{q}</span>  ( <span class="math">1 \\leq i \\leq t</span> ) as a constant element in  <span class="math">R_{q}</span>  and “.” denotes  <span class="math">R_{q}</span> -multiplication.</p>

    <p class="text-gray-300">Given the tensor ring  <span class="math">\\mathbb{E}</span> , the inner product between an  <span class="math">R_{q}</span> -vector and a  <span class="math">\\mathbb{K}</span> -vector is now well-defined. Let us see how to run sumchecks over  <span class="math">\\mathbb{K}</span>  and do folding over  <span class="math">R_{q}</span>  in LatticeFold+.</p>

    <p class="text-gray-300">Parameters: A sumcheck challenge set  <span class="math">\\mathcal{C}</span>  (Section 4)</p>

    <p class="text-gray-300">Input:  <span class="math">\\mathbb{I} = (\\mathbf{A},\\mathbf{B},\\mathbf{C}\\in R_q^{n\\times m})</span>  and  <span class="math">\\mathbb{X}\\coloneqq (\\mathsf{cm},\\mathbf{x})\\in R_q^n\\times R_q^{\\ell_{\\mathrm{in}}}</span>  and  <span class="math">\\mathbb{W}\\coloneqq \\mathbf{f}\\in R_q^n</span></p>

    <p class="text-gray-300">Output:  <span class="math">\\mathbb{X}_o\\coloneqq \\left(\\mathsf{cm},\\mathbf{r}\\in \\mathcal{C}^{\\log n},(v,v_{\\mathbf{A}},v_{\\mathbf{B}},v_{\\mathbf{C}})\\in R_q^4\\right)</span>  and  <span class="math">\\mathbb{W}_o\\coloneqq \\mathbf{f}</span></p>

    <p class="text-gray-300">The protocol  <span class="math">\\langle \\mathsf{P}(\\mathsf{x};\\mathsf{w});\\mathsf{V}(\\mathsf{x})\\rangle</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}\\to \\mathsf{P}</span>  : V sends P a random vector  <span class="math">\\mathbf{r}\\gets \\mathcal{C}^{\\log n}</span></li>

      <li><span class="math">\\mathsf{P}\\leftrightarrow \\mathsf{V}</span>  : Define the polynomial  <span class="math">g\\in R_q^{\\leq 2}[X_1,\\ldots ,X_{\\log n}]</span>  as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g (\\mathbf {x}) := e q (\\mathbf {r}, \\mathbf {x}) \\cdot \\left[ g _ {\\mathbf {A}} (\\mathbf {x}) \\cdot g _ {\\mathbf {B}} (\\mathbf {x}) - g _ {\\mathbf {C}} (\\mathbf {x}) \\right]</span></div>

    <p class="text-gray-300">where for every  <span class="math">\\mathbf{M} \\in \\{\\mathbf{A}, \\mathbf{B}, \\mathbf{C}\\}</span>  set  <span class="math">\\mathbf{M}&#x27; := \\mathbf{M} \\cdot \\mathbf{G}_{B,\\hat{\\ell}}^{\\top} \\in R_q^{n \\times n}</span>  and define</p>

    <div class="my-4 text-center"><span class="math-block">g _ {\\mathbf {M}} (\\mathbf {x}) := \\sum_ {\\mathbf {b} \\in \\{0, 1 \\} ^ {\\log n}} (\\widetilde {\\mathbf {M} ^ {\\prime}}) (\\mathbf {x}, \\mathbf {b}) \\cdot \\widetilde {\\mathbf {f}} (\\mathbf {b}).</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{P}</span>  and  <span class="math">\\mathsf{V}</span>  run a sum-check protocol for the claim  <span class="math">\\sum_{\\mathbf{b} \\in \\{0,1\\}^{\\log n}} g(\\mathbf{b}) = 0</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{r}_o\\gets \\mathcal{C}^{\\log n}</span>  be the sum-check challenge vector. The protocol reduces to a random evaluation check  <span class="math">g(\\mathbf{r}_o)\\stackrel {?}{=}s</span>  for some  <span class="math">s\\in R_q</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}\\to \\mathsf{V}</span>  : P sends V values  <span class="math">(v,v_{\\mathbf{A}},v_{\\mathbf{B}},v_{\\mathbf{C}})\\in R_q^4</span>  . When P is honest these values are  <span class="math">v\\coloneqq \\widetilde{\\mathbf{f}} (\\mathbf{r}_o) = \\langle \\mathbf{f},\\mathrm{tensor}(\\mathbf{r}_o)\\rangle \\in R_q</span>  , and for every  <span class="math">\\mathbf{M}\\in \\{\\mathbf{A},\\mathbf{B},\\mathbf{C}\\}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">v _ {\\mathbf {M}} := \\sum_ {\\mathbf {b} \\in \\{0, 1 \\} ^ {\\log n}} \\widetilde {\\mathbf {M}} ^ {\\prime} (\\mathbf {r} _ {o}, \\mathbf {b}) \\cdot \\widetilde {\\mathbf {f}} (\\mathbf {b}) \\in R _ {q}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{M}&#x27; := \\mathbf{M} \\cdot \\mathbf{G}_{B,\\hat{\\ell}}^{\\top}</span> . Applying Remark 2.3 to the columns of  <span class="math">\\mathbf{M}&#x27;</span>  shows that</p>

    <div class="my-4 text-center"><span class="math-block">v _ {\\mathbf {M}} = \\left(\\left(\\mathbf {M} ^ {\\prime}\\right) ^ {\\top} \\cdot \\operatorname {t e n s o r} \\left(\\mathbf {r} _ {o}\\right)\\right) ^ {\\top} \\cdot \\mathbf {f} = \\left(\\mathbf {M} ^ {\\prime} \\cdot \\mathbf {f}\\right) ^ {\\top} \\cdot \\operatorname {t e n s o r} \\left(\\mathbf {r} _ {o}\\right) = \\langle \\mathbf {M} ^ {\\prime} \\cdot \\mathbf {f}, \\operatorname {t e n s o r} \\left(\\mathbf {r} _ {o}\\right) \\rangle .</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V computes  <span class="math">e \\coloneqq eq(\\mathbf{r},\\mathbf{r}_o)</span>  and checks that  <span class="math">e \\cdot (v_{\\mathbf{A}}v_{\\mathbf{B}} - v_{\\mathbf{C}}) \\stackrel{?}{=} s</span> .</li>

      <li>The derived  <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{\\prime}</span>  triple  <span class="math">(\\mathbb{I}_o,\\mathbb{X}_o,\\mathbb{W}_o)</span>  is defined by</li>

    </ol>

    <p class="text-gray-300">V outputs  <span class="math">\\mathbb{I}_o\\coloneqq (\\mathbf{I}_n,\\mathbf{A}&#x27;,\\mathbf{B}&#x27;,\\mathbf{C}&#x27;)</span>  and  <span class="math">\\mathbb{X}_o\\coloneqq \\big(\\mathsf{cm},\\mathbf{r}_o,(v,v_{\\mathbf{A}},v_{\\mathbf{B}},v_{\\mathbf{C}})\\big),</span></p>

    <p class="text-gray-300">P outputs  <span class="math">\\mathbb{W}_o\\coloneqq \\mathbf{f}</span></p>

    <p class="text-gray-300">Figure 1: The protocol to reduce  <span class="math">\\mathcal{R}_{\\mathrm{cRICS},B}</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{lin},B}^{\\prime}</span> .</p>

    <p class="text-gray-300">Sumchecks.</p>

    <p class="text-gray-300">In the variant of LatticeFold+, all the sumchecks are over <span class="math">\\mathbb{K}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eq. (11) is over <span class="math">\\mathbb{K}</span> where both eq(c, <span class="math">\\langle i\\rangle</span>) and <span class="math">\\widetilde{\\mathbf{m}^{(j)}}(\\langle i\\rangle)</span> are interpreted as <span class="math">\\mathbb{K}</span>-elements.</li>

      <li>Eq. (18) represents a sequence of inner product claims between <span class="math">R_{q}</span>-vectors and <span class="math">\\mathbb{K}</span>-vectors. By the column interpretation, they can be understood as a list of inner product claims between <span class="math">\\mathbb{Z}_{q}</span>-vectors and <span class="math">\\mathbb{K}</span>-vectors, which in turn can be interpreted as sumchecks over <span class="math">\\mathbb{K}</span>. By random linear combination, we can reduce them to a single sumcheck over <span class="math">\\mathbb{K}</span>.</li>

      <li>Similarly, the left hand side of Eq. (20) can be understood as <span class="math">d</span> sumcheck claims over <span class="math">\\mathbb{K}</span>, which can be reduced to a single sumcheck over <span class="math">\\mathbb{K}</span> by random linear combination. Note that <span class="math">\\mathbf{t}^{(z)}\\in\\mathbb{E}^{n}</span> (<span class="math">z\\in[2]</span>) is now interpreted as a <span class="math">\\mathbb{E}</span>-vector.</li>

    </ul>

    <h4 id="sec-73" class="text-lg font-semibold mt-6">Folding.</h4>

    <p class="text-gray-300">After running the sumcheck protocol, the above claims reduce to random evaluation statements, which can be interpreted as inner product claims between (committed) <span class="math">R_{q}</span>-vectors and a shared <span class="math">\\mathbb{K}</span>-vectors. By the row interpretation, each such claim can be viewed as <span class="math">t</span> inner product claims between a committed <span class="math">R_{q}</span>-vector and a <span class="math">\\mathbb{Z}_{q}</span>-vector, where the <span class="math">i</span>-th <span class="math">\\mathbb{Z}_{q}</span>-vector (<span class="math">i\\in[t]</span>) is identical across all committed <span class="math">R_{q}</span>-vectors. We can therefore fold the committed <span class="math">R_{q}</span>-vectors into a single vector using folding challenges over <span class="math">\\tilde{\\mathcal{S}}\\subseteq R_{q}</span>, reducing the claims to <span class="math">t</span> separate inner product claims between the folded <span class="math">R_{q}</span>-vector and a <span class="math">\\mathbb{Z}_{q}</span>-vector. Applying the column interpretation again, these <span class="math">t</span> claims can be viewed as a single inner product claim between a folded <span class="math">R_{q}</span>-vector and a <span class="math">\\mathbb{K}</span>-vector, which is an evaluation statement we need.</p>`;
---

<BaseLayout title="LatticeFold+: Faster, Simpler, Shorter Lattice-Based Folding... (2025/247)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/247
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
