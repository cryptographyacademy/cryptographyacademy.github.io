---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/614';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Quantum Attacks without Superposition Queries: the Offline Simon&#x27;s Algorithm';
const AUTHORS_HTML = 'Xavier Bonnetain, Akinori Hosoyamada, Mar&iacute;a Naya-Plasencia, Yu Sasaki, Andr&eacute; Schrottenloher';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In symmetric cryptanalysis, the model of superposition queries has lead to surprising results, with many constructions being broken in polynomial time thanks to Simon&#x27;s period-finding algorithm. But the practical implications of these attacks remain blurry. In contrast, the results obtained so far for a quantum adversary making classical queries only are less impressive.

In this paper, we introduce a new quantum algorithm which uses Simon&#x27;s subroutines in a novel way. We manage to leverage the algebraic structure of cryptosystems in the context of a quantum attacker limited to classical queries and offline quantum computations. We obtain improved quantum-time/classical-data tradeoffs with respect to the current literature, while using only as much hardware requirements (quantum and classical) as a standard exhaustive search using Grover&#x27;s algorithm. In particular, we are able to break the Even-Mansour construction in quantum time $O(2^{n/3})$, with $O(2^{n/3})$ classical queries and $O(n^2)$ qubits only. In addition, we propose an algorithm that
allows to improve some previous superposition attacks by reducing the
data complexity from exponential to polynomial, with the same time complexity.

Our approach can be seen in two complementary ways: reusing superposition queries during the iteration of a search using Grover&#x27;s algorithm, or alternatively, removing the memory requirement in some quantum attacks based on a collision search, thanks to their algebraic structure.

We provide a list of cryptographic applications, including the Even-Mansour construction, the FX construction, some Sponge authenticated modes of encryption, and many more.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Simon&#x27;s algorithm &middot; classical queries &middot; symmetric cryptography &middot; quantum cryptanalysis &middot; Even-Mansour construction &middot; FX construction</p>
    </section>

    <p class="text-gray-300">Ever since Shor [39] introduced his celebrated quantum polynomial-time algorithm for solving factorization and Discrete Logarithms, both problems believed to be classically intractable, post-quantum cryptography has become a subject of wide interest. Indeed, the security of classical cryptosystems relies on computational assumptions, which until recently, were made with respect to classical adversaries; if quantum adversaries are to be taken into account, the landscape of security is bound to change dramatically.</p>

    <p class="text-gray-300">While it is difficult to assert the precise power of quantum computers, which are yet to come, it is still possible to study quantum algorithms for cryptographic problems, and to estimate the computational cost of solving these problems for a quantum adversary. The ongoing project by NIST [35] for post-quantum asymmetric schemes aims to replace the current mostly used ones by new standards.</p>

    <p class="text-gray-300">In symmetric cryptography, the impact of quantum computing seems, at first sight, much more limited. This is because the security of most of symmetric-key schemes is not predicated on structured problems. Symmetric-key schemes are required to be computed extremely efficiently, and designers must avoid such computationally expensive operations. Grover's quantum search algorithm [22], another cornerstone of quantum computing, speeds up by a quadratic factor exhaustive search procedures. This has led to the common saying that &quot;doubling the key sizes&quot; should ensure a similar level of post-quantum security.</p>

    <p class="text-gray-300">However, the actual post-quantum security of symmetric-key schemes requires more delicate treatment. Recovering the secret key via exhaustive search is only one of all the possible approaches. The report of the National Academy of Sciences on the advent of quantum computing [34] also states that &quot;it is possible that there is some currently unknown clever quantum attack&quot; that would perform much better than Grover's algorithm. Indeed, cryptographers are making significant progress on quantum attackers with superposition queries, which break many symmetric-key schemes in polynomial time.</p>

    <p class="text-gray-300">Quantum Generic Attacks in Q1 and Q2 Models. Quantum attacks can be mainly classified into two types [20, 25, 23], Q1 model and Q2 model, assuming different abilities for the attacker. In the Q1 model, attackers have an access to a quantum computer to perform any offline computation, while they are only allowed to make online queries in a classical manner. In the Q2 model, besides the offline quantum computation, attackers are allowed to make superposition queries to a quantum cryptographic oracle. Here, we briefly review previous results in these models to introduce the context of our results.</p>

    <p class="text-gray-300">The Q2 model is particularly interesting as it yields some attacks with a very low cost. Kuwakado and Morii [29, 30] showed that the Even-Mansour cipher and the three-round Feistel networks, classically proven secure if their underlying building blocks are ideal, were broken in polynomial time. This exponential speedup, the first concerning symmetric cryptography, was obtained thanks to Simon's algorithm [40] for recovering a Boolean hidden shift. Later on, more results have been obtained in this setting, with more generic constructions broken [24, 31], and an exponential acceleration of slide attacks, which target ciphers with a self-similar structure. Versions of these attacks [5] for constructions with modular additions use Kuperberg's algorithm [27], allowing a better than quadratic speed-up. All these attacks, however, run in the model of superposition queries, which models a quantum adversary having some inherently quantum access to the primitives attacked. As such, they do not give any improvement when the adversary only has classical access.</p>

    <p class="text-gray-300">Stated differently, the attacks in the Q1 model are particularly relevant due to their impact on current data communication technology. However, the quantum algorithms that have been exploited for building attacks in the Q1 model are very limited and have not allowed more than a quadratic speed-up. The most used algortihm is the simple quantum exhaustive search with Grover's algorithm. A possible direction is the collision finding algorithm that is often said to achieve &quot;2n/<sup>3</sup> complexity&quot; versus 2n/<sup>2</sup> classically. However, even in this direction, there are several debatable points; basic quantum algorithms for finding collisions have massive quantum hardware requirements [9]. There is a quantum-hardwarefriendly variant [12], but then the time complexity becomes suboptimal.</p>

    <p class="text-gray-300">In summary, attacks using Simon's algorithm could achieve a very low complexity but could only be applied in the Q2 model, a very strong model. In contrast, attacks in the Q1 model are practically more relevant, but for now the obtained speed-ups were not surprising.</p>

    <p class="text-gray-300">Another model to consider when designing quantum attacks is whether the attacker has or not a big amount of quantum memory available. Small quantum computers seem like the most plausible scenario, and therefore attacks needing a polynomial amount of qubits are more practically relevant. Therefore, the most realistic scenario is Q1 with small quantum memory.</p>

    <p class="text-gray-300">Our Main Contribution. The breakthrough we present in this paper is the first application of Simon's algorithm [40] in the Q1 model, which requires significantly less than O 2 n/2 classical queries and offline quantum computations, only with poly(n) qubits, and no qRAM access (where n is the size of the secret). Namely, we remove the superposition queries in previous attacks. The new idea can be applied to a long list of ciphers and modes of operation. Let us illustrate the impact of our attacks by focusing on two applications:</p>

    <p class="text-gray-300">The first application is the key recovery on the Even-Mansour construction, which is one of the simplest attacks using Simon's algorithm. Besides the polynomial time attacks in the Q2 model, Kuwakado and Morii also developed an attack in the Q1 model with O 2 n/3 classical queries, quantum computations, qubits, and classical memory [30]. The extension of this Q1 attack by Hosoyamada and Sasaki [23] recovers the key with O 2 3n/7 classical queries, O 2 3n/7 quantum computations, polynomially many qubits and O 2 n/7 classical memory (to balance classical queries and quantum computations). Our attack in the Q1 model only uses polynomially many qubits, yet only requires O 2 n/3 classical queries, O n 32 n/3 quantum computations and poly(n) classical memory.</p>

    <p class="text-gray-300">The second application is the key recovery on the FX-construction FXk,kin,kout , which computes a ciphertext c from a plaintext p by c &larr; Ek(p &oplus; kin) &oplus; kout, where E is a block cipher, k is an m-bit key and kin, kout are two n-bit keys. Leander and May proposed an attack in the Q2 model with O n2 m/2 superposition queries, O n 32 m/2 quantum computations, poly(n) qubits and poly(n)</p>

    <p class="text-gray-300">classical memory [31]. <sup>1</sup> They combined Simon's algorithm and Grover's algorithm in a clever way, while it became inevitable to make queries in an adaptive manner. For the Q1 model, the meet-in-the-middle attack [23] can recover the key with  <span class="math">\\mathcal{O}\\left(2^{3(m+n)/7}\\right)</span>  complexities. Our results can improve the previous attacks in two directions. One is to reduce the amount of superposition queries in the Q2 model to the polynomial order and convert the adaptive attack to a non-adaptive one. The other is to completely remove the superposition queries. The comparison of previous quantum attacks and our attacks on Even-Mansour and the FX construction is shown in Table 1. Other interesting complexity trade-offs are possible, as shown in detail in sections 5 and 4.</p>

    <p class="text-gray-300"><strong>Table 1.</strong> Previous and New Quantum Attacks on Even-Mansour and FX, assuming that  <span class="math">m = \\mathcal{O}(n)</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Target</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Model</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Queries</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Q-memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">C-memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^3\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^2\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[30]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[30]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{EM}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{3n/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{3n/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^3 2^{n/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^2\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n2^{m/2}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^3 2^{m/2}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^2\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[31]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FX</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^3 2^{m/2}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^2\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{3(m+n)/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{3(m+n)/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{(m+n)/7}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[23]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(2^{(m+n)/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^3 2^{(m+n)/3}\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n^2\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathcal{O}\\left(n\\right)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 5</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Our New Observation. Here we describe our new algorithm used in the Q1 model with the Even-Mansour construction as an example. Recall that the encryption  <span class="math">E_{k_1,k_2}</span>  of the Even-Mansour construction is defined as  <span class="math">E_{k_1,k_2}(x) = P(x \\oplus k_1) \\oplus k_2</span> , where P is a public permutation and  <span class="math">k_1, k_2 \\in \\{0, 1\\}^n</span>  are the secret keys. Roughly speaking, our attack guesses (2n/3)-bit of  <span class="math">k_1</span>  (denoted by  <span class="math">k_1^{(2)}</span>  in Fig. 1) by using the Grover search, and checks if the guess is correct by applying Simon's algorithm to the remaining (n/3)-bit of  <span class="math">k_1</span>  (denoted by  <span class="math">k_1^{(1)}</span>  in Fig. 1). If we were in the Q2 model, we could recover  <span class="math">k_1</span>  by using the technique by Leander and May [31] in time  <span class="math">\\tilde{\\mathcal{O}}(2^{n/3})</span> . However, their technique is not applicable in the Q1 setting since quantum queries are required.</p>

    <p class="text-gray-300">Our core observation that realizes the above idea in the Q1 model is that, we can judge whether a function  <span class="math">f \\oplus g</span>  has a period (i.e., we can apply Simon's algorithm) without any quantum query to g, if we have the quantum state  <span class="math">|\\psi_g\\rangle</span>  :=</p>

    <p class="text-gray-300">Here we are assuming that m is in  <span class="math">\\mathcal{O}(n)</span> , which is the case for usual block ciphers.</p>

    <p class="text-gray-300"><span class="math">(\\sum_{x}|x\\rangle|g(x)\\rangle)^{\\otimes cn}</span>  (c is a small constant): If we have the quantum state  <span class="math">|\\psi_{g}\\rangle</span> , then we can make the quantum state  <span class="math">|\\psi_{f\\oplus g}\\rangle:=(\\sum_{x}|x\\rangle|(f\\oplus g)(x)\\rangle)^{\\otimes cn}</span>  by making  <span class="math">\\mathcal{O}(n)</span>  quantum queries to f. Once we obtain  <span class="math">|\\psi_{f\\oplus g}\\rangle</span> , by applying the Hadamard operation  <span class="math">H^{\\otimes n}</span>  to each  <span class="math">|x\\rangle</span>  register, we obtain the quantum state</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{x_1,u_1}(-1)^{u_1\\cdot x_1}|u_1\\rangle|(f\\oplus g)(x_1)\\rangle\\right)\\otimes\\cdots\\otimes\\left(\\sum_{x_{cn},u_{cn}}(-1)^{u_{cn}\\cdot x_{cn}}|u_{cn}\\rangle|(f\\oplus g)(x_{cn})\\rangle\\right)</span>$</p>

    <p class="text-gray-300">Then, roughly speaking,  <span class="math">\\dim(\\operatorname{Span}(u_1,\\ldots,u_{cn})) &lt; n</span>  always holds if  <span class="math">f \\oplus g</span>  has a secret period s, while  <span class="math">\\dim(\\operatorname{Span}(u_1,\\ldots,u_{cn})) = n</span>  holds with a high probability if  <span class="math">f \\oplus g</span>  does not have any period. Since the dimension of the vector space can be computed in time  <span class="math">\\mathcal{O}(n^3)</span> , we can judge if  <span class="math">f \\oplus g</span>  has a period in time  <span class="math">\\mathcal{O}(n^3)</span> . Note that we can reconstruct the quantum data  <span class="math">|\\psi_g\\rangle</span>  after judging whether  <span class="math">(f \\oplus g)</span>  has a period (with some errors) by appropriately performing uncomputations, which help us use these procedures as a subroutine without measurement in other quantum algorithms.</p>

    <p class="text-gray-300">For the Even-Mansour construction, we set  <span class="math">g:\\{0,1\\}^{n/3}\\to\\{0,1\\}^n</span>  by  <span class="math">g(x):=E_{k_1,k_2}(x\\|0^{2n/3})</span> . Then we can make the quantum state  <span class="math">|\\psi_g\\rangle</span>  by classically querying x to g for all  <span class="math">x\\in\\{0,1\\}^{n/3}</span> , which requires  <span class="math">2^{n/3}</span>  classical queries. After obtaining the state  <span class="math">|\\psi_g\\rangle</span> , we guess  <span class="math">k_1^{(2)}</span> . Suppose that here our guess is  <span class="math">k&#x27;\\in\\{0,1\\}^{2n/3}</span> . We define  <span class="math">f_{k&#x27;}:\\{0,1\\}^{n/3}\\to\\{0,1\\}^n</span>  by  <span class="math">f_{k&#x27;}(x):=P(x\\|k&#x27;)</span> . Then, roughly speaking, our guess is correct if and only if the function  <span class="math">f_{k&#x27;}\\oplus g</span>  has a period  <span class="math">k_1^{(1)}</span> . Thus we can judge whether the guess is correct without quantum queries to g, by using our technique described above. Since  <span class="math">k_1^{(2)}</span>  can be guessed in time  <span class="math">\\tilde{\\mathcal{O}}(2^{n/3})</span>  by using the Grover search, we can recover the keys by making  <span class="math">\\mathcal{O}(2^{n/3})</span>  classical queries and  <span class="math">\\tilde{\\mathcal{O}}(2^{n/3})</span>  offline quantum computations.</p>

    <p class="text-gray-300">    <img src="_page_4_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Idea of our Q1 attack on the Even-Mansour construction.</p>

    <p class="text-gray-300">We will show how we can similarly attack the FX construction in the Q1 model, by guessing additional key bits (see Fig. 2).</p>

    <p class="text-gray-300">Moreover, our attack idea in the Q1 model can also be used to reduce the number of quantum queries of attacks in the Q2 model. The Leander and May's attack on the FX construction in the Q2 model [31] guesses the m-bit key k of the FX construction  <span class="math">FX_{k,k_{in},k_{out}}</span>  and checks whether the guess is correct by</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. Idea of our Q1 attack on the FX construction.</p>

    <p class="text-gray-300">using Simon's algorithm, which requires  <span class="math">\\mathcal{O}(2^{m/2})</span>  online quantum queries and  <span class="math">\\tilde{\\mathcal{O}}(2^{m/2})</span>  offline quantum computations. Roughly speaking, the guess k' for the key k is correct if and only if  <span class="math">(f_{k&#x27;} \\oplus g)(x)</span>  has the secret period  <span class="math">k_{in}</span> , where  <span class="math">f_{k&#x27;}(x) = E_{k&#x27;}(x)</span>  and  <span class="math">g(x) = \\mathrm{FX}_{k,k_{in},k_{out}}(x)</span> . In the Q2 model, we can make the quantum state  <span class="math">|\\psi_g\\rangle = (\\sum_x |x\\rangle|g(x)\\rangle)^{\\otimes cn}</span>  by making  <span class="math">\\mathcal{O}(n)</span>  quantum queries to g. Thus, by our new attack idea described above, we can break the FX construction with  <span class="math">\\mathcal{O}(n)</span>  online quantum queries and  <span class="math">\\tilde{\\mathcal{O}}(2^{m/2})</span>  offline quantum computations, which exponentially improves the attack by Leander and May from the viewpoint of quantum query complexity.</p>

    <p class="text-gray-300">This exponential improvement on the quantum query complexity is due to the separation of offline queries and online computations: In the previous attack on the FX construction in the Q2 model by Leander and May, we have to do online queries and offline computations alternately in each iteration of the Grover search. Thus the number of online quantum queries becomes exponential in the previous attack. On the other hand, in our new attack, the online queries (i.e., the procedures to make the quantum state  <span class="math">|\\psi_g\\rangle</span> ) are completely separated from offline computations. This enables us to decrease the number of quantum queries exponentially, while we still need exponentially many offline computations.</p>

    <p class="text-gray-300"><strong>Paper organization.</strong> Section 2 gives preliminaries. Section 3 describes our main algorithms. Section 4 shows applications of our algorithms in the Q2 model. Section 5 shows applications of our algorithms in the Q1 model. Section 6 discusses further applications of our algorithm. Section 7 concludes the paper.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section, we introduce some quantum computing notions and review Simon's and Grover's algorithms. We refer to [36] for a broader presentation.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The Quantum Circuit Model</h3>

    <p class="text-gray-300">It has become standard in the cryptographic literature to write quantum algorithms in the circuit model, which is universal for quantum computing. We only consider the logical level of quantum circuits, with logical qubits, not their implementation level (which requires physical qubits, quantum error-correction, etc). Although it is difficult to estimate the cost of a physical implementation which does not yet exist, we can compare security levels as quantum operation counts in this model. For example, Grover search of the secret key for AES-128 is known to require approximately 2<sup>64</sup> quantum evaluations of the cipher, and 2 <sup>84</sup> quantum operations [21].</p>

    <p class="text-gray-300">Qubits and Operations. A quantum circuit represents a sequence of quantum operations, denoted as quantum gates, applied to a set of qubits. An individual qubit is a quantum object whose state is an element of a two-dimensional Hilbert space, with basis |0i, |1i (analogs of the classical logical 0 and 1). Hence, the state is described as a linear combination of |0i, |1i with complex coefficients (a superposition). We add to this a normalization condition: &alpha;|0i+&beta;|1i is such that |&alpha;| <sup>2</sup> +|&beta;| <sup>2</sup> = 1. When it is clear from context, we dismiss common normalization factors.</p>

    <p class="text-gray-300">When n qubits are given, the computational basis has 2<sup>n</sup> vectors, which are all n-bit strings. The qubits start in a state |0i, for example a fixed spin or polarization. The sequence of quantum gates that is applied modifies the superposition, thanks to constructive and destructive interferences. In the end, we measure the system, and obtain some n-bit vector in the computational basis, which we expect to hold a meaningful result.</p>

    <p class="text-gray-300">All computations are (linear) unitary operators of the Hilbert space, and as such, are reversible (this holds for the individual gates, but also for the whole circuit). In general, any classical computation can be made reversible (and so, implemented as a quantum circuit) provided that one uses sufficiently many ancilla qubits (which start in the state |0i and are brought back to |0i after the computation). Generally, on input |xi, we can perform some computation, copy the result to an output register using CNOT gates, and uncompute (perform backwards the same operations) to restore the initial state of the ancilla qubits. Uncomputing a unitary U corresponds to applying its adjoint operator U &lowast; .</p>

    <p class="text-gray-300">By the principle of deferred measurements, any measure that occurs inside the quantum circuit can be deferred to the end of the computation.</p>

    <p class="text-gray-300">Quantum Oracles. Many quantum algorithms require an oracle access. The difference they make with classical algorithms with this respect is that classical oracles (e.g. cryptographic oracles such as a cipher with unknown key) are queried &quot;classically&quot;, with a single value, while quantum oracles are unitary operators. We consider oracle calls of the type:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|c} |x\\rangle &amp; \\hline \\\\ |y\\rangle &amp; \\hline \\end{array} \\begin{array}{c|c} O_f &amp; |x\\rangle \\\\ &amp; |y\\oplus f(x)\\rangle \\end{array}</span>$</p>

    <p class="text-gray-300">which XOR their output value to an output register (ensuring reversibility). If we consider that |yi starts in the state |0i, then f(x) is simply written here. If the function f can be accessed through O<sup>f</sup> , we say it has superposition oracle access.</p>

    <p class="text-gray-300">Quantum RAM. Additionally to the use of &quot;plain&quot; quantum circuits with universal quantum computation, many algorithms require quantum random-access, or being able to access at runtime a superposition of memory cells. This is a strong requirement, since this requires an extensive quantum hardware (the qRAM) and a huge architecture that is harder to build than a quantum circuit with a limited number of qubits. Shor's algorithm, Simon's algorithm, Grover's algorithm do not require qRAM, if their oracle calls do not either, contrary to, e.g., the algorithm for quantum collision search of [9], whose optimal speedup can be realized only by using massive qRAM.</p>

    <p class="text-gray-300">Our algorithm has no such requirement, which puts it on the same level of practicality as Grover's algorithm for attacking symmetric primitives.</p>

    <p class="text-gray-300">Simon's algorithm [40] gives an exponential speedup on the following problem.</p>

    <p class="text-gray-300">Problem 1 (Simon's problem). Suppose given access to a function f : {0, 1} <sup>n</sup> &rarr; {0, 1} <sup>n</sup> that is either injective, or such that there exists s &isin; {0, 1} <sup>n</sup> with:</p>

    <p class="text-gray-300"><span class="math">$\\forall x, f(x) = f(y) \\iff y = x \\text{ or } y = x \\oplus s,</span>$</p>

    <p class="text-gray-300">then find &alpha;.</p>

    <p class="text-gray-300">In other words, the function f has a hidden Boolean period. It is also easy to extend this algorithm to a hidden Boolean shift, when we want to decide whether two functions f and g are such that g(x) = f(x &oplus; s) for all x. In practice, f can fall in any set X provided that it can be represented efficiently, but in our examples, we will consider functions producing bit strings.</p>

    <p class="text-gray-300">Solving this problem with classical oracle access to f requires &Omega; 2 n/2 queries, as we need to find a collision of f (or none, if there is no hidden period). Simon [40] gives an algorithm which only requires O (n) superposition queries. We fix c &ge; 1 a small constant to ensure a good success probability and repeat cn times Algorithm 1.</p>

    <p class="text-gray-300">We obtain either:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a list of cn random values of y;</li>
      <li>a list of cn random values of y in the hyperplane y &middot; s = 0.</li>
    </ul>

    <p class="text-gray-300">It becomes now easy to test whether s exists or not. If it doesn't, the system of equations obtained has full rank. If it does exist, we can find it by solving the system. Judging whether there exists such an s and actually finding it (if it exists) can be done in time O n 3 by Gaussian elimination.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Start in the all-zero state |0i|0i where the first register contains n qubits and the second represents elements of X.</li>
      <li>2: Apply Hadamard gates to obtain:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\{0,1\\}^n} |x\\rangle |0\\rangle</span>$</p>

    <p class="text-gray-300">3: Query O<sup>f</sup> to obtain:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\{0,1\\}^n} |x\\rangle |f(x)\\rangle = \\sum_{a \\in X} \\left( \\sum_{x \\in \\{0,1\\}^n | f(x) = a} |x\\rangle \\right) |a\\rangle</span>$</p>

    <p class="text-gray-300">4: Measure a (alternatively, we can defer this measurement), get a random value a &isin; X and:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\{0,1\\}^n \\mid f(x)=a} |x\\rangle</span>$</p>

    <p class="text-gray-300">5: Apply Hadamard gates:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{y \\in \\{0,1\\}^n} \\left( \\sum_{x \\in \\{0,1\\}^n | f(x) = a} (-1)^{x \\cdot y} \\right) | y \\rangle</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>6: Now measure the y register. There are two cases.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Either f hides no period s, in which case we get a random y.</li>
      <li>Either f hides a period s, in which case the amplitude of |yi is:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\{0,1\\}^n | f(x) = a} (-1)^{x \\cdot y} = (-1)^{x_0 \\cdot y} + (-1)^{(x_0 \\oplus s) \\cdot y}</span>$</p>

    <p class="text-gray-300">which is zero if y &middot; s = 1 and non-zero otherwise.</p>

    <p class="text-gray-300">&bull; In that case, measuring gives a random y such that y &middot; s = 0.</p>

    <p class="text-gray-300">Simon's Algorithm in Cryptography. This algorithm has been used in many attacks on modes of operation and constructions where recovering a secret requires to find a hidden shift between two functions having bit-string inputs. Generally, the functions to which Simon's algorithm is applied are not injective, and random collisions can occur. But a quick analysis (as done e.g. in [24]) shows that even in this case, a mild increase of the constant c will increase the success probability to a sufficient level. To be precise, the following proposition holds.</p>

    <p class="text-gray-300">Proposition 1 (Theorem 2 in [24]). Suppose that f : {0, 1} <sup>n</sup> &rarr; X has a period s 6= 0<sup>n</sup>, i.e., f(x &oplus; s) = f(x) for all x &isin; {0, 1} <sup>n</sup>, and satisfies</p>

    <p class="text-gray-300"><span class="math">$\\max_{t \\neq \\{s, 0^n\\}} \\Pr_x \\left[ f(x \\oplus t) = f(x) \\right] \\le \\frac{1}{2}.</span>$
(1)</p>

    <p class="text-gray-300">When we apply Simon's algorithm to f, it returns s with a probability at least 1 &minus; 2 <sup>n</sup> &middot; (3/4)cn.</p>

    <p class="text-gray-300">Grover's algorithm [22] allows a quadratic speedup on classical exhaustive search. Precisely, it solves the following problem:</p>

    <p class="text-gray-300">Problem 2 (Grover's problem). Consider a set X (the &quot;search space&quot;) whose elements are represented on  <span class="math">\\lceil \\log_2(|X|) \\rceil</span>  qubits, such that the uniform superposition  <span class="math">\\sum_{x \\in X} |x\\rangle</span>  is computable in  <span class="math">\\mathcal{O}(1)</span>  time. Given oracle access to a function  <span class="math">f: X \\to \\{0,1\\}</span>  (the &quot;test&quot;), find  <span class="math">x \\in X</span>  such that f(x) = 1.</p>

    <p class="text-gray-300">Classically, if there are  <span class="math">2^t</span>  preimages of 1, we expect one to be found in time (and oracle accesses to f)  <span class="math">\\mathcal{O}(|X|/2^t)</span> . Quantumly, Grover's algorithm finds one in time (and oracle accesses to  <span class="math">O_f</span> )  <span class="math">\\widetilde{\\mathcal{O}}\\left(\\sqrt{|X|/2^t}\\right)</span> . In particular, if there is one preimage of 1, the running time is  <span class="math">\\widetilde{\\mathcal{O}}\\left(\\sqrt{|X|}\\right)</span> . If the superposition oracle for f uses a ancilla qubits, then Grover's algorithm requires  <span class="math">a + \\lceil \\log_2(|X|) \\rceil</span>  qubits only.</p>

    <p class="text-gray-300">Grover's algorithm works first by producing the superposition  <span class="math">\\sum_{x\\in |X|}|x\\rangle</span> . It applies  <span class="math">\\widetilde{\\mathcal{O}}\\left(\\sqrt{|X|/2^t}\\right)</span>  times an operator which, by querying  <span class="math">O_f</span>  &quot;moves&quot; some amplitude towards the preimages of 1.</p>

    <p class="text-gray-300">In this section, we introduce a problem that can be seen as a general combination of Simon's and Grover's problems, and that will be solved by an according combination of algorithmic ideas. The problem has many cryptographic applications, and it will be at the core of our improved Q2 and Q1 time-memory-data tradeoffs.</p>

    <p class="text-gray-300">Problem 3 (Asymmetric Search of a Period). Let  <span class="math">F:\\{0,1\\}^m\\times\\{0,1\\}^n\\to\\{0,1\\}^\\ell</span>  and  <span class="math">g:\\{0,1\\}^n\\to\\{0,1\\}^\\ell</span>  be two functions. We consider F as a family of functions indexed by  <span class="math">\\{0,1\\}^m</span>  and write  <span class="math">F(i,\\cdot)=f_i(\\cdot)</span> . Assume that we are given quantum oracle access to F, and classical or quantum oracle access to g. (In the Q1 setting, g will be a classical oracle. In the Q2 setting, g will be a quantum oracle.)</p>

    <p class="text-gray-300">Assume that there exists exactly one  <span class="math">i \\in \\{0,1\\}^m</span>  such that  <span class="math">f_i \\oplus g</span>  has a hidden period, i.e.:  <span class="math">\\forall x \\in \\{0,1\\}^n, f_{i_0}(x) \\oplus g(x) = f_{i_0}(x \\oplus s) \\oplus g(x \\oplus s)</span>  for some s. Furthermore, assume that:</p>

    <p class="text-gray-300"><span class="math">$\\max_{\\substack{i \\in \\{0,1\\}^m \\setminus \\{i_0\\} \\\\ t \\in \\{0,1\\}^n \\setminus \\{0^n\\}}} \\Pr_{\\substack{x \\leftarrow \\{0,1\\}^n \\\\ \\{0^n\\}}} \\left[ (f_i \\oplus g)(x \\oplus t) = (f_i \\oplus g)(x) \\right] \\le \\frac{1}{2}</span>$
(2)</p>

    <p class="text-gray-300">Then find  <span class="math">i_0</span>  and s.</p>

    <p class="text-gray-300">In our cryptographic applications, g will be a keyed function such that adversaries have to make online queries to evaluate it, while F will be a function such that adversaries can evaluate it offline. For example, the problem of recovering</p>

    <p class="text-gray-300">keys of the FX construction FXk,kin,kout (x) = Ek(x&oplus;kin)&oplus;kout can be regarded as a simple cryptographic instantiation of Problem 3: Set g(x) := FXk,kin,kout (x) and F(i, x) := Ei(x). Then, roughly speaking, the function f<sup>i</sup> &oplus; g has a period kin if k = i, whereas it does not have any period if i 6= k and Condition (2) holds. Thus we can know whether i = k by checking whether f<sup>i</sup> &oplus;g has a period.</p>

    <p class="text-gray-300">Justification of Condition (2). We added Condition (2) in Problem 3 because the problem would be much harder to solve if we do not suppose any condition on f<sup>i</sup> . Such assumptions are standard in the litterature of quantum attacks using Simon's algorithm (see for example [24, Sections 2.2 and 4] or [4, Section 3]). This is reasonable for cryptographic applications, as a block cipher is expected to behave like a random permutation, which makes the functions we construct in our applications behave like random functions. This assumption is made in [24, 31], and such functions satisfy Condition (2) with an overwhelming probability. Moreover, as remarked in [24], a cryptographic construction that fails to satisfy Condition (2) would exhibit some poor differential properties which could be used for cryptanalysis.</p>

    <p class="text-gray-300">Here we explain existing algorithms to solve Problem 3 in both the Q1 model and the Q2 model, with the algorithms to recover keys of the FX construction as an example. Note that we consider the situation in which exponentially many qubits are not available.</p>

    <p class="text-gray-300">The model Q1. In the Q1 model, when we are allowed to make only classical queries to g := FXk,kin,kout , there exists a Q1 algorithm to attack the FX construction that uses a kind of meet-in-the-middle technique [23]. However, it does not make use of the exponential speed-up of Simon's algorithm, and its time complexity and query complexity is O 2 3(n+m)/7 (for m &le; 4n/3).</p>

    <p class="text-gray-300">The model Q2. Problem 3 can be solved with O n2 m/2 superposition queries to F(i, x) = Ei(x) and g(x) = FXk,kin,kout (x), and in time O n 32 m/2 , using the Grover-meet-Simon algorithm of [31]. Indeed, we make a Grover search on index i &isin; {0, 1} <sup>m</sup>. When testing whether a guess i for the key k is correct, we perform O (n) queries to F and O (n) queries to g, to check whether f<sup>i</sup> &oplus; g has a hidden period, hence whether the guess i is correct. Moreover, since superposition access to F and g is allowed, we can test i in superposition as well.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 An Algorithm for Asymmetric Search of a Shift</h3>

    <p class="text-gray-300">Here we describe our new algorithms to solve Problem 3. We begin with explaining two observations on the Grover-meets-Simon algorithm in the Q2 model described in Section 3.1, and how to improve it. Then we describe how to use the idea to make a good algorithm to solve Problem 3 in the Q1 model.</p>

    <p class="text-gray-300">Two observations. Our first observation is that, when doing the Grover search over i for Problem 3, each time a new i is tested, a new function f<sup>i</sup> is queried. But, in contrast, the function g is always the same. We would like to take this asymmetry into account, namely, to make less queries to g since it does not change. This in turn has many advantages: queries to g can become more costly than queries to f<sup>i</sup> .</p>

    <p class="text-gray-300">Our second observation is that, for each i &isin; I, once we have a superposition |&psi;gi = Ncn P <sup>x</sup>&isin;{0,1}<sup>n</sup> |xi|g(x)i and given a quantum oracle access to f<sup>i</sup> , we can obtain the information if f<sup>i</sup> &oplus; g has a period or not without making queries to g.</p>

    <p class="text-gray-300">From |&psi;gi, we can make the state |&psi;fi&oplus;gi = Ncn P <sup>x</sup>&isin;{0,1}<sup>n</sup> |xi|fi(x) &oplus; g(x)i by making queries to f<sup>i</sup> . By applying usual Simon's procedures on |&psi;fi&oplus;gi, we can judge if fi&oplus;g has a period. Moreover, by appropriately performing uncomputations, we can recover |&psi;gi (with some errors) and reuse it in other procedures.</p>

    <p class="text-gray-300">With these observations in mind, below we give an intuitive description of our algorithm Alg-PolyQ2 to solve Problem 3 in the Q2 model (we name our algorithm Alg-PolyQ2 because it will be applied to make Q2 attacks with polynomially many online queries in later sections). The main ideas of Alg-PolyQ2 are separating an online phase and offline computations, and iteratively reusing the quantum data |&psi;gi obtained by the online phase.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Online phase: Make cn quantum queries to g to prepare |&psi;gi.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Offline computations: Run the Grover search over i &isin; {0, 1} <sup>m</sup>. For each fixed i, run a testing procedure test such that: (a) test checks if i is a good element (i.e., f<sup>i</sup> &oplus; g has a period) by using |&psi;gi and making queries to f<sup>i</sup> , and (b) after checking if i is good, appropriately performs uncomputations to recover the quantum data |&psi;gi.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">A formal description of Alg-PolyQ2 is given in Algorithm 2. We fix a constant c &ge; 1, to be set later depending on the probability of error wanted.</p>

    <p class="text-gray-300">We show how to implement the testing procedure test in Algorithm 3 without any new query to g, using only exactly 2cn superposition queries to F. To write this procedure clearly, we consider a single function f in input, but remark that it works as well if f is a superposition of f<sup>i</sup> (as will be the case when test is called as the oracle of a Grover search).</p>

    <p class="text-gray-300">In practice, Algorithm 3 works up to some error (see Remark 1), which is amplified at each iteration of Algorithm 2. The complexity and success probability (including the errors) of Alg-PolyQ2 can be analyzed as below.</p>

    <p class="text-gray-300">Proposition 2. Suppose that m is in O (n). Let c be a sufficiently large constant. <sup>2</sup> Consider the setting of Problem 3: let i<sup>0</sup> &isin; {0, 1} <sup>m</sup> be the good element such that g &oplus; f<sup>i</sup><sup>0</sup> is periodic and assume that (2) holds. Then Alg-PolyQ2</p>

    <p class="text-gray-300"><sup>2</sup> See Proposition 5 for a concrete estimate.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Start in the all-zero state.</li>
      <li>2: Using cn queries to g, create the state:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$|\\psi_g\\rangle = \\bigotimes^{cn} \\left(\\sum_{x \\in \\{0,1\\}^n} |x\\rangle |g(x)\\rangle\\right)</span>$</p>

    <p class="text-gray-300">The circuit now contains  <span class="math">|\\psi_g\\rangle</span> , the &quot;g-database&quot;, and additional registers on which we can perform Grover search. Notice that  <span class="math">|\\psi_g\\rangle</span>  contains cn independent (and disentangled) registers.</p>

    <p class="text-gray-300">3: Create the uniform superposition over indices  <span class="math">i \\in \\{0,1\\}^m</span> :</p>

    <p class="text-gray-300"><span class="math">$|\\psi_g\\rangle\\otimes\\sum_{i\\in\\{0,1\\}^m}|i\\rangle</span>$</p>

    <p class="text-gray-300">4: Apply Grover iterations. The testing oracle is a unitary operator test that takes in input a register for  <span class="math">|i\\rangle</span>  and the &quot;g-database&quot;, and tests in superposition whether  <span class="math">f_i \\oplus g</span>  has a hidden period. If this is the case, it returns  <span class="math">|b \\oplus 1\\rangle</span>  on input  <span class="math">|b\\rangle</span> . Otherwise it returns  <span class="math">|b\\rangle</span> . (Algorithm 3 gives the details for test in the case that i is fixed.)</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|cccc} |\\psi_g\\rangle &amp; &amp; &amp; &amp; &amp; &amp; |\\psi_g\\rangle \\\\ |i\\rangle &amp; &amp; &amp; &amp; &amp; |i\\rangle \\\\ |b\\rangle &amp; &amp; &amp; &amp; &amp; |b\\text{ or } b\\oplus 1\\rangle \\end{array}</span>$</p>

    <p class="text-gray-300">The most important feature of test is that it does not change the g-database (up to some errors). The registers holding  <span class="math">|\\psi_g\\rangle</span>  are disentangled before and after the application of test.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>5: After  <span class="math">\\mathcal{O}\\left(2^{m/2}\\right)</span>  Grover iterations, measure the index i.</li>
      <li>6: If the hidden shift is also wanted, apply a single instance of Simon's algorithm (or re-use the database and perform a slightly extended computation of <strong>test</strong> to retrieve the result).</li>
    </ul>

    <p class="text-gray-300">finds  <span class="math">i_0</span>  with a probability in  <span class="math">\\Theta(1)</span>  by making  <span class="math">\\mathcal{O}(n)</span>  quantum queries to g and  <span class="math">\\mathcal{O}\\left(n2^{m/2}\\right)</span>  quantum queries to F. <sup>3</sup> The offline computation (the procedures excluding the ones to prepare the state  <span class="math">|\\psi_g\\rangle</span> ) of Alg-PolyQ2 is done in time  <span class="math">\\mathcal{O}\\left((n^3+nT_F)2^{m/2}\\right)</span> , where  <span class="math">T_F</span>  is the time required to evaluate F once.</p>

    <p class="text-gray-300">See Section A in the Appendix for a proof.</p>

    <p class="text-gray-300">Remark 1. Intuitively, the error produced in each iteration of Algorithm 3 is bounded by the maximum, on i, of:  <span class="math">p^{(i)} := \\Pr\\left[\\dim(\\operatorname{Span}(u_1, \\ldots, u_{cn})) &lt; n\\right]</span> , when  <span class="math">u_1, \\ldots, u_{cn}</span>  are produced with Simon's algorithm, i.e. the probability that Simon's algorithm returns the incorrect answer &quot; <span class="math">f_i \\oplus g</span>  is periodic&quot; even though</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^3&lt;/sup&gt;</span>  In later applications, F will be instantiated with unkeyed primitives, and quantum queries to F are emulated with offline computations of primitives such as block ciphers.</p>

    <p class="text-gray-300"><strong>Algorithm 3</strong> The procedure test that checks if a function  <span class="math">f \\oplus q</span>  has a period against the g-database, without any new query to q.</p>

    <p class="text-gray-300">1: We start with the g-database:</p>

    <p class="text-gray-300"><span class="math">$|\\psi_g\\rangle = \\bigotimes^{cn} \\left(\\sum_{x \\in \\{0,1\\}^n} |x\\rangle |g(x)\\rangle\\right)</span>$</p>

    <p class="text-gray-300">2: Using cn superposition queries to f, build the state:</p>

    <p class="text-gray-300"><span class="math">$|\\psi_{f\\oplus g}\\rangle = \\bigotimes^{cn} \\left(\\sum_{x\\in\\{0,1\\}^n} |x\\rangle|g(x)\\oplus f(x)\\rangle\\right)</span>$</p>

    <p class="text-gray-300">We will now perform, in a reversible way, the exact computations of Simon's algorithm to find if  <span class="math">g \\oplus f</span>  has a hidden period or not (in which case f and g have a hidden shift).</p>

    <p class="text-gray-300">3: Apply  <span class="math">(H^{\\otimes n} \\otimes I_m)^{cn} \\otimes I_1</span>  to  <span class="math">|\\psi_{f \\oplus g}\\rangle \\otimes |b\\rangle</span> , to obtain</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{u_1, x_1 \\in \\{0,1\\}^n} (-1)^{u_1 \\cdot x_1} |u_1\\rangle | (f \\oplus g)(x_1)\\rangle\\right) \\otimes \\cdots</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdots \\otimes \\left(\\sum_{u_{cn}, x_{cn} \\in \\{0,1\\}^n} (-1)^{u_{cn} \\cdot x_{cn}} |u_{cn}\\rangle | (f \\oplus g)(x_{cn})\\rangle\\right) \\otimes |b\\rangle. \\tag{3}</span>$</p>

    <p class="text-gray-300">4: Compute  <span class="math">d := \\dim(\\operatorname{Span}(u_1, \\dots, u_{cn}))</span> , set r := 0 if d = n and r := 1 if d &lt; n, and add r to b. Then uncompute d and r, and obtain</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\substack{u_1,\\dots,u_{cn}\\\\x_1,\\dots,x_{cn}}} (-1)^{u_1\\cdot x_1} |u_1\\rangle |(f\\oplus g)(x_1)\\rangle \\otimes \\cdots</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdots \\otimes (-1)^{u_{cn}\\cdot x_{cn}} |u_{cn}\\rangle |(f\\oplus g)(x_{cn})\\rangle \\otimes |b\\oplus r\\rangle. \\tag{4}</span>$</p>

    <p class="text-gray-300">Note that r in (4) depends on  <span class="math">u_1, \\ldots, u_{cn}</span>  and now the last register may be entangled with the registers of  <span class="math">u_1, \\ldots, u_{cn}</span> . 5: Uncompute  <span class="math">(H^{\\otimes n} \\otimes I_m)^{cn} \\otimes I_1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>6: Using cn new superposition queries to f, revert  <span class="math">|\\psi_{f\\oplus g}\\rangle</span>  to  <span class="math">|\\psi_g\\rangle</span> .</li>
    </ul>

    <p class="text-gray-300">There are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">f \\oplus q</span>  has a hidden period, then r = 1 always holds. Hence, in the output register, we always write 1.</li>
      <li>If  <span class="math">f \\oplus q</span>  does not have a hidden period, then with high probability, r = 0. Hence, in the output register, we write 0.</li>
    </ul>

    <p class="text-gray-300"><span class="math">f_i \\oplus g</span>  is not periodic. From condition (2), we can show that  <span class="math">p^{(i)} \\leq 2^{(n+1)/2}((1+1)^n)</span>  <span class="math">(\\frac{1}{2})/2)^{cn/2}</span>  holds (see Lemma 1 in the Appendix).</p>

    <p class="text-gray-300">Remark 2. Alg-PolyQ2 finds the index i such that  <span class="math">f_i \\oplus g</span>  has a period, but does not return the actual period of  <span class="math">f_i \\oplus g</span> . However, we can find the actual period of  <span class="math">f_i \\oplus g</span>  (after finding i with Alg-PolyQ2) by applying Simon's algorithm to  <span class="math">f_i \\oplus g</span> . Summary. With Alg-PolyQ2, we realize an &quot;asymmetric&quot; variant of Simon's algorithm, in which we store a &quot;compressed&quot; database for a single function g, which is not modified (up to some errors) while we test whether another function f has a hidden shift with g, or not. An immediate application of this algorithm will be to achieve an exponential improvement of the query complexity of some Q2 attacks on symmetric schemes. Indeed, in the context where Simon's algorithm and Grover's algorithm are combined, it may be possible to perform the queries to the secret-key cryptographic oracle only once, and so, to lower the query complexity to  <span class="math">\\mathcal{O}(n)</span> .</p>

    <p class="text-gray-300">In Alg-PolyQ2, (online) queries to g and (offline) queries to F are separated, and only cn superposition queries to g are made. Hence another tradeoff is at our reach, which was not possible when g was queried in each Grover iteration: removing superposition queries to g completely.</p>

    <p class="text-gray-300"><strong>Input:</strong> Classical query access to g</p>

    <p class="text-gray-300">Output: The g-database:</p>

    <p class="text-gray-300"><span class="math">$|\\psi_g\\rangle = \\bigotimes^{cn} \\left(\\sum_{x \\in \\{0,1\\}^n} |x\\rangle|g(x)\\rangle\\right)</span>$</p>

    <p class="text-gray-300">1: Start with the all-zero state</p>

    <p class="text-gray-300"><span class="math">$\\bigotimes^{cn}|0\\rangle|0\\rangle</span>$</p>

    <p class="text-gray-300">2: Apply Hadamard gates:</p>

    <p class="text-gray-300"><span class="math">$\\bigotimes^{cn} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle |0\\rangle</span>$</p>

    <p class="text-gray-300">3: For each  <span class="math">y \\in \\{0,1\\}^n</span> , query (classically) g(y), then apply a unitary which writes g(y) in the second register if the first contains the value y.</p>

    <p class="text-gray-300">This requires now to query the whole codebook for g to prepare the quantum state  <span class="math">|\\psi_g\\rangle</span> . Once  <span class="math">|\\psi_g\\rangle</span>  is built, the second offline phase runs in exactly the same way. Building  <span class="math">|\\psi_g\\rangle</span>  costs roughly  <span class="math">2^n</span>  time (and classical queries), while going through the search space for f takes  <span class="math">2^{m/2}</span>  iterations (and quantum queries to F). We call our new algorithm in the Q1 model Alg-ExpQ1 because it will be applied to make Q1 attacks with exponentially many online queries in later sections. The optimal point arrives when m=2n.</p>

    <p class="text-gray-300">Below we give an intuitive description of our algorithm Alg-ExpQ1 to solve Problem 3 in the Q1 model. As described above, the difference between Alg-ExpQ1 and Alg-PolyQ2 is the online phase to prepare  <span class="math">|\\psi_q\\rangle</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Online phase: Make  <span class="math">2^n</span>  classical queries to g and prepare the state  <span class="math">|\\psi_a\\rangle</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Offline computations: Run the Grover search over  <span class="math">i \\in \\{0, 1\\}^m</span> . For each fixed i, run a testing procedure test such that: (a) test checks if i is a good element (i.e.,  <span class="math">f_i \\oplus g</span>  has a period) by using  <span class="math">|\\psi_g\\rangle</span>  and making queries  <span class="math">f_i</span> , and (b) after checking if i is good, appropriately perform uncomputations to recover the quantum data  <span class="math">|\\psi_g\\rangle</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">A formal description of Alg-ExpQ1 is the same as that of Alg-PolyQ2 (Algorithm 2) except that we make  <span class="math">2^n</span>  classical queries to g to prepare the quantum state  <span class="math">|\\psi_g\\rangle</span> . See Algorithm 4 for formal description of the online phase. The complexity and success probability (including the errors) of Alg-ExpQ1 can be analyzed as below.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Suppose that m is in  <span class="math">\\mathcal{O}(n)</span> . Let c be a sufficiently large constant. <sup>4</sup> Consider the setting of Problem 3: let  <span class="math">i_0 \\in \\{0,1\\}^m</span>  be the good element such that  <span class="math">g \\oplus f_{i_0}</span>  is periodic and assume that (2) holds. Then  <span class="math">\\mathsf{Alg}\\mathsf{-ExpQ1}</span>  finds  <span class="math">i_0</span>  with a probability in  <span class="math">\\Theta(1)</span>  by making  <span class="math">\\mathcal{O}(2^n)</span>  classical queries to g and  <span class="math">\\mathcal{O}(n2^{m/2})</span>  quantum queries to F. <sup>5</sup> The offline computation (the procedures excluding the ones to prepare the state  <span class="math">|\\psi_g\\rangle</span> ) of  <span class="math">\\mathsf{Alg}\\mathsf{-ExpQ1}</span>  is done in time  <span class="math">\\mathcal{O}\\left((n^3+nT_F)2^{m/2}\\right)</span> , where  <span class="math">T_F</span>  is the time required to evaluate F once.</p>

    <p class="text-gray-300">A proof is given in Section A in the Appendix.</p>

    <p class="text-gray-300">Finding actual periods. The above algorithm Alg-ExpQ1 returns the index  <span class="math">i_0</span>  such that  <span class="math">f_{i_0} \\oplus g</span>  has a period, but does not return the actual period. Therefore, if we want to find the actual period of  <span class="math">f_{i_0} \\oplus g</span>  after finding  <span class="math">i_0</span> , we have to apply Simon's algorithm to  <span class="math">f_{i_0} \\oplus g</span>  again. Now we can make only classical queries to g, though, we can use the same idea with Alg-ExpQ1 to make an algorithm SimQ1 that finds the period of  <span class="math">f_{i_0} \\oplus g</span> . Again, let c be a positive integer constant.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Algorithm SimQ1.</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Make  <span class="math">2^n</span>  classical queries to g and prepare the quantum state  <span class="math">|\\psi_q\\rangle</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Make cn quantum queries to  <span class="math">f_{i_0}</span>  to obtain the quantum state  <span class="math">|\\psi_{f_{i_0} \\oplus g}\\rangle = \\bigotimes^{cn} (\\sum_x |x\\rangle |f_{i_0}(x) \\oplus g(x)\\rangle)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Apply  <span class="math">H^{\\otimes n}</span>  to each  <span class="math">|x\\rangle</span>  register to obtain the state</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\bigotimes^{cn} \\left( \\sum_{x,u} (-1)^{x \\cdot u} |u\\rangle |f_{i_0}(x) \\oplus g(x)\\rangle \\right) .</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Measure all  <span class="math">|u\\rangle</span>  registers to obtain cn vectors  <span class="math">u_1, \\ldots, u_{cn}</span> .</li>
    </ol>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup> See Proposition 5 for a concrete estimate.</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{5}&lt;/sup&gt;</span>  Again, in later applications, F will be instantiated with unkeyed primitives, and quantum queries to F are emulated with offline computations of primitives such as block ciphers.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the dimension d of the vector space V spanned by  <span class="math">u_1, \\ldots, u_{cn}</span> . If  <span class="math">d \\neq n-1</span> , return  <span class="math">\\perp</span> . If d=n-1, compute the vector  <span class="math">v \\neq 0^n \\in \\{0,1\\}^n</span>  that is orthogonal to V.</li>
    </ol>

    <p class="text-gray-300">Obviously the probability that the above algorithm SimQ1 returns the period of  <span class="math">f_{i_0} \\oplus g</span>  is the same as the probability that the original Simon's algorithm returns the period, under the condition that cn quantum queries can be made to the function  <span class="math">f_{i_0} \\oplus g</span> . Thus, from Proposition 1, the following proposition holds.</p>

    <p class="text-gray-300"><strong>Proposition 4.</strong> Suppose that  <span class="math">f_{i_0} \\oplus g</span>  has a period  <span class="math">s \\neq 0^n</span>  and satisfies</p>

    <p class="text-gray-300"><span class="math">$\\max_{t \\neq \\{s, 0^n\\}} \\Pr_x \\left[ (f_{i_0} \\oplus g)(x \\oplus t) = (f_{i_0} \\oplus g)(x) \\right] \\le \\frac{1}{2}.</span>$
(5)</p>

    <p class="text-gray-300">Then SimQ1 returns s with a probability at least  <span class="math">1-2^n \\cdot (3/4)^{cn}</span>  by making  <span class="math">\\mathcal{O}(2^n)</span>  classical queries to g and cn quantum queries to  <span class="math">f_{i_0}</span> . The offline computation of SimQ1 (the procedures excluding the ones to prepare the state  <span class="math">|\\psi_g\\rangle</span> ) runs in time  <span class="math">\\mathcal{O}(n^3+nT_f)</span> , where  <span class="math">T_f</span>  is the time required to evaluate  <span class="math">f_{i_0}</span>  once.</p>

    <p class="text-gray-300"><strong>Proposition 5 (Concrete cost estimates).</strong> In practice, for Propositions 2 and 3,  <span class="math">c \\simeq m/(n \\log_2(4/3))</span>  is sufficient.</p>

    <p class="text-gray-300"><em>Proof.</em> We need to have  <span class="math">4\\lfloor \\pi/\\left(4\\arcsin\\left(2^{-m/2}\\right)\\right)\\rfloor 2^{(n+1)/2}(3/4)^{cn/2}&lt;1/2</span> .</p>

    <p class="text-gray-300">In practice,  <span class="math">\\arcsin(x) \\simeq x</span>  and the rounding has a negligible impact. Hence, we need that  <span class="math">m/2 + (n+1)/2 + \\log_2(\\pi) + \\log_2(3/4)cn/2 &lt; -1</span> .</p>

    <p class="text-gray-300">This reduces to  <span class="math">c &gt; \\log_2(4/3)^{-1} (m+3+2\\log_2(\\pi))/n \\simeq m/(n\\log_2(4/3)n)</span> .</p>

    <p class="text-gray-300">Remark 3. If m=n, this means  <span class="math">c \\simeq 2.5</span> , and if m=2n,  <span class="math">c \\simeq 5</span> .</p>

    <p class="text-gray-300">This section shows that our new algorithm Alg-PolyQ2 can be used to construct Q2 attacks on various symmetric schemes. By using Alg-PolyQ2 we can exponentially reduce the number of quantum queries to the keyed oracle compared to previous Q2 attacks, with the same time cost.</p>

    <p class="text-gray-300">In each application, we consider that one evaluation of each primitive (e.g., a block cipher) can be done in time  <span class="math">\\mathcal{O}(1)</span> , for simplicity. For our practical estimates, we use the cost of the primitive as our unit, and consider that it is greater than the cost of solving the linear equation system. In addition, we assume that key lengths of n-bit block ciphers are in  <span class="math">\\mathcal{O}(n)</span> , which is the case for usual block ciphers.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 An Attack on the FX construction</h3>

    <p class="text-gray-300">Here we show a Q2 attack on the FX construction. As described in Section 3, the FX construction builds an <em>n</em>-bit block cipher  <span class="math">FX_{k,k_{in},k_{out}}</span>  with (2n+m)-bit</p>

    <p class="text-gray-300">keys  <span class="math">(k_{in}, k_{out} \\in \\{0, 1\\}^n \\text{ and } k \\in \\{0, 1\\}^m)</span>  from another <em>n</em>-bit block cipher  <span class="math">E_k</span>  with <em>m</em>-bit keys as</p>

    <p class="text-gray-300"><span class="math">$FX_{k,k_{in},k_{out}}(x) := E_k(x \\oplus k_{in}) \\oplus k_{out}.</span>$
(6)</p>

    <p class="text-gray-300">This construction is used to obtain a block cipher with long ((2n+m)-bit) keys from another block cipher with short (m-bit) keys. Roughly speaking, in the classical setting, the construction is proven to be secure up to  <span class="math">\\mathcal{O}\\left(2^{(n+m)/2}\\right)</span>  queries and computations if the underlying block cipher is secure [26].</p>

    <p class="text-gray-300">Concrete block ciphers such as DESX, proposed by Rivest in 1984 and analyzed in [26], PRINCE [7], and PRIDE [1] are designed based on the FX construction. To estimate security of these block ciphers against quantum computers, it is important to study quantum attacks on the FX construction.</p>

    <p class="text-gray-300">As briefly explained in Section 3, the previous Q2 attack by Leander and May [31] breaks the FX construction by making  <span class="math">\\mathcal{O}\\left(n2^{m/2}\\right)</span>  quantum queries, and its time complexity is  <span class="math">\\mathcal{O}\\left(n^32^{m/2}\\right)</span> .</p>

    <p class="text-gray-300"><strong>Application of our algorithm Alg-PolyQ2.</strong> Below we show that, by applying our algorithm Alg-PolyQ2, we can recover keys of the FX construction with only  <span class="math">\\mathcal{O}(n)</span>  quantum queries. Time complexity of our attack remains  <span class="math">\\mathcal{O}\\left(n^32^{m/2}\\right)</span> , which is the same as Leander and May's.</p>

    <p class="text-gray-300">Attack idea. As explained in Section 3, the problem of recovering the keys k and  <span class="math">k_{in}</span>  of the FX construction  <span class="math">F_{k,k_{in},k_{out}}</span>  can be reduced to Problem 3: Define  <span class="math">F: \\{0,1\\}^m \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  and  <span class="math">g: \\{0,1\\}^n \\to \\{0,1\\}^n</span>  by</p>

    <p class="text-gray-300"><span class="math">$F(i,x) = E_i(x) \\oplus E_i(x \\oplus 1)</span>$</p>

    <p class="text-gray-300"><span class="math">$g(x) = FX_{k,k_{in},k_{out}}(x) \\oplus FX_{k,k_{in},k_{out}}(x \\oplus 1).</span>$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$f_k(x) \\oplus g(x) = f_k(x \\oplus k_{in}) \\oplus g(x \\oplus k_{in})</span>$
(7)</p>

    <p class="text-gray-300">holds, i.e.,  <span class="math">f_k \\oplus g(x)</span>  has a period  <span class="math">k_{in}</span>  (note that  <span class="math">f_k(x) = F(k, x)</span> ). If E is a secure block cipher and  <span class="math">E_i</span>  is a random permutation for each i, intuitively,  <span class="math">f_i \\oplus g</span>  does not have any period for  <span class="math">i \\neq k</span> . Thus the problem of recovering k and  <span class="math">k_{in}</span>  is reduced to Problem 3 and we can apply our algorithm Alg-PolyQ2. Formally, the attack procedure is as follows.</p>

    <p class="text-gray-300">Attack description.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run Alg-PolyQ2 for the above F and g to recover k.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Apply Simon's algorithm to  <span class="math">f_k \\oplus g</span>  to recover  <span class="math">k_{in}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">k_{out} = E_k(0^n) \\oplus \\mathrm{FX}_{k,k_{in},k_{out}}(0^n)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Next we give a complexity analysis of the above attack.</p>

    <p class="text-gray-300">Analysis. We assume that  <span class="math">m = \\mathcal{O}(n)</span> , which is the case for usual block ciphers. If E is a secure block cipher and  <span class="math">E_i</span>  is a random permutation for each  <span class="math">i \\in \\{0,1\\}^m</span> , we can assume that  <span class="math">f_k \\oplus g = E_k \\oplus E_k(\\cdot \\oplus 1) \\oplus \\mathrm{FX}_{k,k_{in},k_{out}} \\oplus \\mathrm{FX}_{k,k_{in},k_{out}}(\\cdot \\oplus 1)</span>  is far from periodic for all  <span class="math">i \\neq k</span> , and that assumption (2) in Problem 3 holds.</p>

    <p class="text-gray-300">Hence, by Proposition 2, Alg-PolyQ2 recovers k with a high probability by making  <span class="math">\\mathcal{O}(n)</span>  quantum queries to g and  <span class="math">\\mathcal{O}\\left(n2^{m/2}\\right)</span>  quantum queries to F, which implies that k is recovered only with  <span class="math">\\mathcal{O}(n)</span>  quantum queries made to  <span class="math">\\mathrm{FX}_{k,k_{in},k_{out}}</span> , and in time  <span class="math">\\mathcal{O}\\left(n^32^{m/2}\\right)</span> . (Note that one evaluation of g (resp., F) can be done by  <span class="math">\\mathcal{O}(1)</span>  evaluations of  <span class="math">\\mathrm{FX}_{k,k_{in},k_{out}}</span>  (resp., E).)</p>

    <p class="text-gray-300">From Proposition 1, the second step can be done with  <span class="math">\\mathcal{O}(n)</span>  quantum queries in time  <span class="math">\\mathcal{O}(n^3)</span> . It is obvious that the third step can be done efficiently.</p>

    <p class="text-gray-300">In summary, our attack recovers the keys of the FX construction with a high probability by making  <span class="math">\\mathcal{O}(n)</span>  quantum queries to the (keyed) online oracle, and it runs in time  <span class="math">\\mathcal{O}(n^3 2^{m/2})</span> .</p>

    <p class="text-gray-300">Applications to DESX, PRINCE and PRIDE. DESX [26] has a 64-bit state, two 64-bit whitening key and one 56-bit inner key. From Propositions 2 and 5, we can estimate that our attack needs roughly 135 quantum queries and  <span class="math">2^{29}</span>  quantum computations of the cipher circuit.</p>

    <p class="text-gray-300">PRINCE [7], and PRIDE [1] are two ciphers using the FX construction with a 64-bit state, a 64-bit inner key and two 64-bit whitening keys. Hence, from Propositions 2 and 5, we can estimate that our attack needs roughly 155 quantum queries and  <span class="math">2^{33}</span>  quantum computations of the cipher circuit.</p>

    <p class="text-gray-300">This section shows that our new algorithm Alg-ExpQ1 can be used to construct Q1 attacks on various symmetric schemes, with a tradeoff between online classical queries, denoted below by D, and offline quantum computations, denoted below by T.</p>

    <p class="text-gray-300">All the algorithms that we consider run with a single processor, but they can use quantum or classical memories, whose amount is respectively denoted by Q (number of qubits) and M. Again, we consider that one evaluation of each primitive (e.g. a block cipher) can be done in time  <span class="math">\\mathcal{O}(1)</span> , for simplicity, and we assume that key lengths of n-bit block ciphers are in  <span class="math">\\mathcal{O}(n)</span> .</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Tradeoffs for the Even-Mansour Construction</h3>

    <p class="text-gray-300">The Even-Mansour construction [19] is a simple construction to make an <em>n</em>-bit block cipher  <span class="math">E_{k_1,k_2}</span>  from an <em>n</em>-bit public permutation P and two <em>n</em>-bit keys  <span class="math">k_1, k_2</span>  (see Fig. 3). The encryption  <span class="math">E_{k_1,k_2}</span>  is defined as  <span class="math">E_{k_1,k_2}(x) := P(x \\oplus k_1) \\oplus k_2</span> , and the decryption is defined accordingly.</p>

    <p class="text-gray-300">In the classical setting, roughly speaking, the Even-Mansour construction is proven secure up to  <span class="math">\\mathcal{O}\\left(2^{n/2}\\right)</span>  online queries and offline computations [19]. In fact there exists a classical attack with tradeoff  <span class="math">TD=2^n</span> , which balances at  <span class="math">T=D=2^{n/2}</span>  [15].</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3. The Even-Mansour construction.</p>

    <p class="text-gray-300">Previous Q1 attacks on the Even-Mansour construction. Kuwakado and Morii gave a Q1 attack that recovers keys of the Even-Mansour construction with  <span class="math">\\mathcal{O}(2^{n/3})</span>  classical queries and qubits, and  <span class="math">\\mathcal{O}(2^{n/3})</span>  offline quantum computations [30]. Their attack is based on a claw-finding algorithm by Brassard et al. [9], and gives the tradeoff  <span class="math">T^2D = 2^n</span> , with additional Q = D qubits. The balanced point  <span class="math">2^{n/3}</span>  is significantly smaller than the classical balanced point  <span class="math">2^{n/2}</span> . However, if we want to recover keys with this attack in time  <span class="math">T \\ll 2^{n/2}</span> , we need an exponential amount of qubits.</p>

    <p class="text-gray-300">Main previous attacks with polynomial qubits The best classical attacks allow a trade-off of  <span class="math">D \\cdot T = 2^n</span>  (see [18] for other trade-offs involving memory). With Grover we could recover the keys with a complexity of  <span class="math">2^{n/2}</span>  and 2 plaintextsciphertext pairs,  <span class="math">(P_1, C_1)</span>  and  <span class="math">(P_2, C_2)</span> , by performing an exhaustive search over the value of  <span class="math">k_1</span>  that would verify  <span class="math">P(P_1 \\oplus k_1) \\oplus P(P_2 \\oplus k_1) = C_1 \\oplus C_2</span> . In [23], Hosoyamada and Sasaki also gave a tradeoff  <span class="math">D \\cdot T^6 = 2^{3n}</span>  for  <span class="math">D \\leq 2^{3n/7}</span>  under the condition that only polynomially many qubits are available, by using the multi-target preimage search by Chailloux et al [12]. D and T are balanced at  <span class="math">D = T = 2^{3n/7}</span> , which is smaller than the classical balanced point  <span class="math">2^{n/2}</span> . The attack uses only polynomially many qubits, but requires  <span class="math">M = D^{1/3} = 2^{n/7}</span>  classical memory. At the balanced point, this still represents an exponentially large storage. Note that this is the only previous work that recover keys in time  <span class="math">T \\ll 2^{n/2}</span>  with polynomially many qubits.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Classical attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Grover</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">[23]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">[30]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">[Ours]</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tradeoff of <span class="math">D</span> and <span class="math">T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">T = 2^{n/2},</span> <span class="math">D = \\text{constant}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D \\cdot T^2 = 2^n</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Num. of qubits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{n/3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Classical memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\parallel</span> D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D^{1/3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{ c c c c c c c c c c c c c c c c c c c</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{3n/7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{n/3}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 2.</strong> Tradeoffs for Q1 attacks on the Even-Mansour construction. In this table we omit to write order notations, and ignore polynomial factors in the first and last rows.</p>

    <p class="text-gray-300">Application of Alg-ExpQ1. We explain how to use our algorithm Alg-ExpQ1 to attack the Even-Mansour construction. The tradeoff that we obtain is T 2 &middot; D = 2n, the same as the attack by Kuwakado and Morii above. It balances at T = D = 2n/<sup>3</sup> , but we use only poly(n) qubits and poly(n) classical memory. See Table 2 for comparison of attack complexities under the condition that poly(n) many qubits are available.</p>

    <p class="text-gray-300">Attack idea. The core observation of Kuwakado and Morii's polynomial-time attack in the Q2 model [30] is that the n-bit secret key k<sup>1</sup> is the period of the function Ek1,k<sup>2</sup> (x)&oplus;P(x), and thus Simon's algorithm can be applied if quantum queries to Ek1,k<sup>2</sup> are allowed. The key to this exponential speed up (compared to the classical attack) is to exploit the algebraic structure of Ek1,k<sup>2</sup> (the hidden period of the function) with Simon's algorithm.</p>

    <p class="text-gray-300">On the other hand, the previous Q1 (classical query) attacks described above use only generic multi-target preimage search algorithms that do not exploit any algebraic structures. Hence being able to exploit the algebraic structure in the Q1 model should give us some advantage.</p>

    <p class="text-gray-300">Our algorithm Alg-ExpQ1 realizes this idea. It first makes classical online queries to emulate the quantum queries required by Simon's algorithm (the gdatabase above) and then runs a combination of Simon's and Grover's algorithms offline (Grover search is used to find the additional m-bit secret information). A naive way to attack in the Q1 model would be to immediately combine Kuwakado and Morii's Q2 attack with Alg-ExpQ1. However, we would have to query the whole classical codebook to emulate quantum queries, which is too costly (and there is no Grover search step).</p>

    <p class="text-gray-300">Our new attack is as follows: We divide the n-bit key k<sup>1</sup> in k (1) 1 of u bits and k (2) 1 of n &minus; u bits and apply Simon's algorithm to recover k (1) 1 , while we guess k (2) 1 by the Grover search (see Fig. 4). Then, roughly speaking, Alg-ExpQ1 recovers the key by making D = 2<sup>u</sup> classical queries and T = 2(n&minus;u)/<sup>2</sup> offline Grover search iterations (note that the offline computation cost for Simon's algorithm is poly(n) and we ignore polynomial factors here for simplicity), which yields the tradeoff D &middot; T <sup>2</sup> = 2n, only with poly(n) qubits and poly(n) classical space.</p>

    <p class="text-gray-300">    <img src="_page_20_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4. Idea of our Q1 attack on the Even-Mansour construction.</p>

    <p class="text-gray-300">Attack description. Here we give the description of our Q1 attack. Let u be an integer such that  <span class="math">0 \\le u \\le n</span> . Define  <span class="math">F: \\{0,1\\}^{n-u} \\times \\{0,1\\}^u \\to \\{0,1\\}^n</span>  by</p>

    <p class="text-gray-300"><span class="math">$F(i,x) = P(x||i), \\tag{8}</span>$</p>

    <p class="text-gray-300">and define  <span class="math">g: \\{0,1\\}^u \\to \\{0,1\\}^n</span>  by  <span class="math">g(x) = E_{k_1,k_2}(x\\|0^{n-u})</span> . Note that  <span class="math">F(k_1^{(2)},x) \\oplus g(x)</span>  has the period  <span class="math">k_1^{(1)}</span>  since  <span class="math">F(k_1^{(2)},x) \\oplus g(x) = P(x\\|k_1^{(2)}) \\oplus P((x \\oplus k_1^{(1)})\\|k_1^{(2)}) \\oplus k_2</span> . Our attack is described as the following procedure:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run Alg-ExpQ1 for the above F and g to recover  <span class="math">k_1^{(2)}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Recover  <span class="math">k_1^{(1)}</span>  by applying SimQ1 to  <span class="math">f_{k_1^{(2)}}</span>  and g.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute  <span class="math">k_2 = E_{k_1,k_2}(0^n) \\oplus P(k_1)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Analysis. Below we assume that u is not too small, e.g.,  <span class="math">u \\geq n/\\log_2 n</span> . This assumption is not an essential restriction since, if u is too small, then the complexity of the first step becomes almost the same as the Grover search on  <span class="math">k_1</span> , which is not of interest.</p>

    <p class="text-gray-300">If P is a random permutation, we can assume that  <span class="math">f_i \\oplus g = P(\\cdot||i) \\oplus I</span>  <span class="math">E_{k_1,k_2}(\\cdot||0^{n-u})</span>  is far from periodic for all  <span class="math">i\\neq k_1^{(2)}</span> , and that assumption (2) in Problem 3 holds.</p>

    <p class="text-gray-300">Hence, by Proposition 3, Alg-ExpQ1 in Step 1 recovers  <span class="math">k_1^{(2)}</span>  with a high probability by making  <span class="math">\\mathcal{O}(2^u)</span>  classical queries to g and the offline computation of Alg-ExpQ1 runs in time  <span class="math">\\mathcal{O}\\left(n^32^{(n-u)/2}\\right)</span> . Here, notice that one evaluation of g(resp. F) can be done in  <span class="math">\\mathcal{O}(1)</span>  evaluations of  <span class="math">E_{k_1,k_2}</span>  (resp. P). In addition, from Proposition 4, SimQ1 in Step 2 recovers  <span class="math">k_1^{(1)}</span>  with a high probability by making  <span class="math">\\mathcal{O}\\left(2^{u}\\right)</span>  classical queries to g and the offline computation of Alg-ExpQ1 runs in time  <span class="math">\\mathcal{O}(n^3)</span> . Step 3 requires  <span class="math">\\mathcal{O}(1)</span>  queries to  <span class="math">E_{k_1,k_2}</span>  and  <span class="math">\\mathcal{O}(1)</span>  offline computa-</p>

    <p class="text-gray-300">In summary, our attack recovers keys of the Even-Mansour construction with a high probability by making  <span class="math">D = \\mathcal{O}(2^u)</span>  classical queries to  <span class="math">E_{k_1,k_2}</span>  and doing  <span class="math">T = \\mathcal{O}(n^3 2^{(n-u)/2})</span>  offline computations, which balances at  <span class="math">T = D = \\tilde{\\mathcal{O}}(2^{n/3})</span> . By construction of Alg-ExpQ1 and SimQ1, our attack uses poly(n) qubits and poly(n) classical memory.</p>

    <p class="text-gray-300"><strong>Applications to concrete instances.</strong> The Even-Mansour construction is a commonly used cryptographic construction. The masks used in Even-Mansour are often derived from a smaller key, which can make a direct key-recovery using Grover's algorithm more efficient. This is for example the case in the CAESAR candidate Minalpher [38]. In general, we need to have a secret key of at least two thirds of the state size for our attack to beat the exhaustive search.</p>

    <p class="text-gray-300">The Farfalle construction [2] degenerates to an Even-Mansour construction if the input message is only 1 block long. Instances of this construction use variable states and key sizes. The Kravatte instance [2] has a state size of 1600 bits, and a key size between 256 and 320 bits, which leads to an attack at a whopping</p>

    <p class="text-gray-300">cost of 2<sup>533</sup> data and time, while the direct key exhaustive seach would cost at most 2160. Xoofff [16] has a state size of 384 bits and a key size between 192 and 384 bits. Our attack needs 2<sup>128</sup> data, which is exactly the data limit of Xoofff. Hence, it is relevant if the key size is greater than 256.</p>

    <p class="text-gray-300">    <img src="_page_22_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5. One-block Farfalle.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Tradeoffs for the FX Construction</h3>

    <p class="text-gray-300">The FX construction [26] FXk,kin,kout , computes a ciphertext c from a plaintext p by c &larr; Ek(p &oplus; kin) &oplus; kout, where E is a block cipher, k is an m-bit key and kin, kout are two n-bit keys. In the classical setting, there exists a classical attack with tradeoff T D = 2n+m, which balances at T = D = 2(n+m)/<sup>2</sup> (see, for example, [17] for more details and memory trade-offs).</p>

    <p class="text-gray-300">Previous Q1 attacks on the FX construction. Applying Grover as we did before on Even-Mansour on the keys kin and k, we can recover the keys with only two pairs of plaintext-ciphertext and a time complexity of 2(n+m)/<sup>2</sup> , while only needing a polynomial number of qubits.</p>

    <p class="text-gray-300">In [23], Hosoyamada and Sasaki proposed a tradeoff D &middot; T <sup>6</sup> = 23(n+m) for D &le; min{2 <sup>n</sup>, 2 3(n+m)/7} with a polynomial amount of qubits, by using the multitarget preimage search by Chailloux et al [12]. The balance occurs at D = T = 2 3(n+m)/7 (if m &le; 4n/3), which is smaller than the classical balanced point 2 (n+m)/2 . The attack requires M = D1/<sup>3</sup> classical memory, thus the attack still requires exponentially large space at the balanced point. This was the only Q1 attack with time T 2 (n+m)/<sup>2</sup> and a polynomial amount of qubits.</p>

    <p class="text-gray-300">Application of Alg-ExpQ1. We explain how to apply our algorithm Alg-ExpQ1 to the FX construction. Our new tradoff is T 2 &middot; D = 2<sup>n</sup>+<sup>m</sup> for D &le; 2 <sup>n</sup>, which balances at T = D = 2(n+m)/<sup>3</sup> (for m &le; 2n), using only poly(n) qubits and poly(n) classical memory. See Table 3 for comparison of attack complexities under the condition that only poly(n) qubits are available.</p>

    <p class="text-gray-300">Attack idea. Recall that, in the Q1 attack on the Even-Mansour construction in Section 5.1, we divided the first key k<sup>1</sup> to two parts k (1) 1 and k (2) 1 and applied Simon's algorithm to k (1) <sup>1</sup> while we performed Grover search on k (2) 1 .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Classical attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Grover</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">[23]</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">[Ours]</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tradeoff of <span class="math">D</span> and <span class="math">T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ T = 2^{(n+m)/2} $ $ D = \\text{constant} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D \\cdot T^2 = 2^{n+m}</span> <span class="math">(D \\le 2^n)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Num. of qubits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\big  poly(n)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Class. memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mid D</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D^{1/3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">poly(n)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{ c c } 2^{(n+m)/2} \\ (m \\le n) \\end{array} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ 2^{3(n+m)/7} $ $ (m \\le 4n/3) $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{ c c } 2^{(n+m)/3} \\ (m \\le 2n) \\end{array} $</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 3.</strong> Tradeoffs for Q1 attacks on the FX construction. In this table we omit to write order notations, and ignore polynomial factors in the first and last rows.</p>

    <p class="text-gray-300">In a similar manner, for the FX construction  <span class="math">\\mathrm{FX}_{k,k_{in},k_{out}}</span>  we divide the n-bit key  <span class="math">k_{in}</span>  in  <span class="math">k_{in}^{(1)}</span>  of u bits and  <span class="math">k_{in}^{(2)}</span>  of (n-u) bits. We apply Simon's algorithm to recover  <span class="math">k_{in}^{(1)}</span>  while we perform Grover search on k in addition to  <span class="math">k_{in}^{(2)}</span>  (see Fig. 6).</p>

    <p class="text-gray-300">    <img src="_page_23_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6. Idea of our Q1 attack on the FX construction.</p>

    <p class="text-gray-300">Then, roughly speaking, by applying Alg-ExpQ1 we can recover the key by making  <span class="math">D=2^u</span>  classical queries and  <span class="math">T=2^{(n-u)/2}</span>  offline Grover iterations (note that the offline computation cost for the Simon's algorithm is  <span class="math">\\operatorname{poly}(n)</span>  and we ignore polynomial factors here for simplicity), which yields the tradeoff  <span class="math">D\\cdot T^2=2^{(n+m)}</span>  for  <span class="math">D\\leq 2^n</span> , with only  <span class="math">\\operatorname{poly}(n)</span>  qubits and  <span class="math">\\operatorname{poly}(n)</span>  classical memories.</p>

    <p class="text-gray-300">Attack description. Here we give the description of our Q1 attack. Let u be an integer such that  <span class="math">0 \\le u \\le n</span> . Define  <span class="math">F: \\{0,1\\}^{m+(n-u)} \\times \\{0,1\\}^u \\to \\{0,1\\}^n</span>  by</p>

    <p class="text-gray-300"><span class="math">$F(i||j,x) = E_i(x||j) (i \\in \\{0,1\\}^m, j \\in \\{0,1\\}^{n-u}),</span>$
(9)</p>

    <p class="text-gray-300">and define  <span class="math">g: \\{0,1\\}^u \\to \\{0,1\\}^n</span>  by  <span class="math">g(x) = FX_{k,k_{in},k_{out}}(x||0^{n-u}).</span></p>

    <p class="text-gray-300">Note that  <span class="math">F(k||k_{in}^{(2)},x)\\oplus g(x)</span>  has the period  <span class="math">k_{in}^{(1)}</span>  since  <span class="math">F(k||k_{in}^{(2)},x)\\oplus g(x)=E_k(x||k_{in}^{(2)})\\oplus E_k((x\\oplus k_{in}^{(1)})||k_{in}^{(2)})\\oplus k_{out}</span> . Our attack procedure runs as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run Alg-ExpQ1 for the above F and g to recover k and  <span class="math">k_{in}^{(2)}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Recover  <span class="math">k_{in}^{(1)}</span>  by applying SimQ1 to  <span class="math">f_{k||k_{in}^{(2)}}</span>  and g. 3. Compute  <span class="math">k_{out} = \\mathrm{FX}_{k,k_{in},k_{out}}(0^n) \\oplus E_k(k_{in})</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Analysis. We assume that  <span class="math">m = \\mathcal{O}(n)</span> , which is the case for usual block ciphers. In the same way as in the analysis for the attack on the Even-Mansour construction in Section 5.1, if E is a (pseudo) random permutation family and u is not too small  <span class="math">(e.g.\\ u \\ge n/\\log_2 n)</span> , we observe that the assumption (2), rephrased as:</p>

    <p class="text-gray-300"><span class="math">$\\max_{t \\in \\{0,1\\}^n \\setminus \\{0^n\\}} \\Pr_{x \\in \\{0,1\\}^n} \\left[ E_i(x||j) \\oplus E_i(x \\oplus t||j) \\oplus E_k\\left(x \\oplus k_{in}^{(1)}||k_{in}^{(2)}\\right) \\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\oplus E_k\\left(x \\oplus t \\oplus k_{in}^{(1)}||k_{in}^{(2)}\\right) = 0 \\right] \\le 1/2</span>$
(10)</p>

    <p class="text-gray-300">holds for all  <span class="math">(i,j) \\neq (k,k_1^{(2)})</span>  with overwhelming probability. This again implies that the claims of Propositions 3 and 4 hold for Alg-ExpQ1 in Step 1 and SimQ1 in Step 2, respectively.</p>

    <p class="text-gray-300">Thus our attack recovers keys of the FX construction with a high probability by making  <span class="math">D = \\mathcal{O}(2^u)</span>  classical queries to  <span class="math">\\mathrm{FX}_{k,k_{in},k_{out}}</span>  and doing  <span class="math">T = \\mathcal{O}\\left(n^3 2^{(m+n-u)/2}\\right)</span>  offline computations for  <span class="math">D \\leq 2^n</span> , which balances at  <span class="math">T = D = 2^n</span>  <span class="math">\\tilde{\\mathcal{O}}(2^{(n+m)/3})</span>  if  <span class="math">m \\leq 2n</span> . Our attack uses only  <span class="math">\\mathsf{poly}(n)</span>  qubits and  <span class="math">\\mathsf{poly}(n)</span>  classical memory by construction of Alg-ExpQ1 and SimQ1.</p>

    <p class="text-gray-300">Application to concrete instances. DESX [26] has a 64-bit state, two 64bit whitening key and one 56-bit inner key. From Propositions 2 and 5, we can estimate that our attack needs roughly 2<sup>42</sup> classical queries and 2<sup>40</sup> quantum computations of the cipher circuit.</p>

    <p class="text-gray-300">PRINCE [7], and PRIDE [1] are two ciphers using the FX construction with a 64-bit state, a 64-bit inner key and two 64-bit whitening keys. Hence, from Propositions 2 and 5, we can estimate that our attack needs roughly  <span class="math">2^{45}</span>  quantum queries and  <span class="math">2^{43}</span>  quantum computations of the cipher circuit.</p>

    <p class="text-gray-300">We can also see some encryption modes as an instance of the FX construction. This is for example the case of the XTS mode [32], popular for disk encryption. It is generally used with AES-256 and two whitening keys that depend on the block number and another 256-bit key. Hence, with the full codebook of one block, we can obtain the first key and the value of the whitening keys of the corresponding block. Once the first key is known, the second can easily be brute-forced from a few known plaintext-ciphertext couples in other blocks.</p>

    <p class="text-gray-300">Adiantum [14] is another mode for disk encryption that uses a variant of the FX construction with AES-256 and Chacha. There is however one slight difference: the FX masking keys are added with a modular addition instead of a xor. The FX construction is still vulnerable [5], but we will need to use</p>

    <p class="text-gray-300">Kuperberg's algorithm [28] instead of Simon's algorithm. As before, with the full codebook on one block, we can recover the AES and Chacha keys in a time slightly larger than  <span class="math">2^{256}</span> .</p>

    <p class="text-gray-300">Chaskey. The lightweight MAC Chaskey [33] is very close to an Even-Mansour construction (see Figure 7). Since the last message block ( <span class="math">m_2</span>  in Figure 7) is XORed to the key  <span class="math">K_1</span> , we can immediately apply our Q1 attack and recover  <span class="math">K_1</span>  and the value of the state before the xoring of the last message block. As  <span class="math">\\pi</span>  is a permutation easy to invert, this allows to retrieve K. The Chaskey round function applies on 128 bits. It contains 16 rounds with 4 modular additions on 32 bits, 4 XORs on 32 bits and some rotations. With a data limit of  <span class="math">2^{48}</span> , as advocated in the specification, our attack would require roughly  <span class="math">2^{(128-48)/2} \\times 2^{19} = 2^{59}</span>  quantum gates, where the dominant cost is solving the 80-dimensional linear system inside each iteration of Grover's algorithm.</p>

    <p class="text-gray-300">    <img src="_page_25_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7. Two-block Chaskey example.</p>

    <p class="text-gray-300"><strong>Sponges</strong> Our attack can be used on sponges if there is an input injected on a fixed state. In general, it has two drawbacks: the nonce has to be fixed, and the cost of the attack is at least  <span class="math">2^{c/2}</span>  with c the capacity of the sponge, which is often the classical security parameter. However, there are some cases where our attack is of interest.</p>

    <p class="text-gray-300">In particular, our attack needs a set of values that contains an affine space. If a nonce was injected the same way the messages are, then we only need to know the encryptions of identical messages, with a set of nonces that fills an affine space. Nonce-respecting adversaries are generally allowed to choose the nonce, but here, the mere assumption that the nonce is incremented for each message (which is the standard way nonces are processed in practice) is sufficient: A set of  <span class="math">2^k</span>  consecutive values contains an affine space of  <span class="math">(\\mathbb{Z}/(2))^{k-1}</span> .</p>

    <p class="text-gray-300">This is the case in the Beetle mode of lightweight authenticated encryption [13], whose initialization phase is described as  <span class="math">(K_1 \\oplus N) || K_2 \\mapsto f((K_1 \\oplus N) || K_2)</span> , where  <span class="math">K_1, N \\in \\{0,1\\}^r</span> ,  <span class="math">K_2 \\in \\{0,1\\}^c</span> , and f is a (r+c)-bit permutation.</p>

    <p class="text-gray-300">Here, the nonce is directly added to the key  <span class="math">K_1</span> , but as the key has the same length as the state, the attack would still work if the nonce was added after the</p>

    <p class="text-gray-300">first permutation. In Beetle[Light+], the rate is r = 64 bits and the capacity c = 80 bits. The rate is sufficiently large to embed 48 varying bits for the nonce; in that case, by making 2<sup>48</sup> classical queries and 2<sup>48</sup> Grover iterations, we can recover the secret K1||K2. In Beetle[Secure+], r = c = 128 bits. We can recover K1||K<sup>2</sup> with 2<sup>85</sup> messages and Grover iterations.</p>

    <p class="text-gray-300">    <img src="_page_26_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8. Beetle state initialization.</p>

    <p class="text-gray-300">In this section, we discuss on the application of our attack idea to relatedkey attacks, to some slide attacks, and to an extension of Problem 3. See also Section B in the Appendix for discussions on adaptive attacks and non-adaptive attacks.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Related Keys</h3>

    <p class="text-gray-300">Consider a block cipher E<sup>k</sup> with a key and block size of n bits. In the related-key setting, as introduced in [41], we are not only allowed to make chosen plaintext or ciphertext queries to a secret-key oracle hiding k, but also to query Ek&oplus;<code>(m) for any n-bit difference </code> and message m. Classically, this is a very powerful model, but it becomes especially meaningful when the block cipher is used inside a mode of operation (e.g. a hash function) in which key differences can be controlled by the attacker. It is shown in [41] that a secret key recovery in this model can be performed in 2n/<sup>2</sup> operations, as it amounts to find a collision between some query Ek&oplus;<code>(m) and some offline computation E</code> <sup>0</sup> (m) (we can use more than a single plaintext m to ensure an overwhelming success probability).</p>

    <p class="text-gray-300">R&uml;otteler and Steinwandt [37] noticed that, if a quantum adversary has superposition access to the oracle that maps <code> to Ek&oplus;</code>(m), it can mount a key-recovery in polynomial time using Simon's algorithm. Indeed, one can define a function:</p>

    <p class="text-gray-300"><span class="math">$f(x) = E_{k \\oplus x}(m) \\oplus E_x(m)</span>$</p>

    <p class="text-gray-300">which has k as hidden period, apply Simon's algorithm and recover k. This attack works for any block cipher, even ideal. In contrast, in the Q2 quantum attacker model, we know that some constructions are broken, but it does not seem to be the case for all of them.</p>

    <p class="text-gray-300">With our algorithm Alg-ExpQ1, we are able to translate this related-key superposition attack into an attack where the related-key oracle is queried only classically, but the attacker has quantum computing power. We write  <span class="math">k = k_1 || k_2</span>  where  <span class="math">k_1</span>  has n/3 bits and  <span class="math">k_2</span>  has 2n/3 bits. We query  <span class="math">E_{(k_1||k_2)\\oplus(\\ell_1||0)}(m)</span>  for a fixed m and all n/3-bit differences  <span class="math">\\ell_1</span> . Then we perform a Grover search on  <span class="math">k_2</span> . The classical security level in presence of a related-key oracle of this form, which is  <span class="math">2^{n/2}</span> , is reduced quantumly to  <span class="math">2^{n/3}</span> . This shows that the transition to a quantum setting has an impact on the related-key security even if the oracle remains classical.</p>

    <p class="text-gray-300">As a consequence, we could complete the security claims of the 16-round version of the block cipher Saturnin [10], a submission to the ongoing NIST lightweight cryptography competition<sup>6</sup>. The authors of Saturnin gave security claims against quantum attackers meeting the best generic attacks. No claims were given regarding the  <span class="math">Q_1</span>  model for related-key attacks. Our result gives the best generic quantum related-key attack on ideal block ciphers without superposition queries, and sets the level of security that should be expected from a block cipher in this setting: the key can be recovered in quantum time  <span class="math">\\widetilde{\\mathcal{O}}\\left(2^{n/3}\\right)</span>  for a block cipher of n bits (and using  <span class="math">2^{n/3}</span>  classical related-key queries). The corresponding security level for Saturnin<sub>16</sub>, which has blocks of 256 bits, lies at  <span class="math">2^{256/3} = 2^{85}</span> : we can say that in the  <span class="math">Q_1</span>  related-key setting, Saturnin<sub>16</sub> should have no attack with time complexity lower than  <span class="math">2^{85}</span> .</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Slide Attacks</h3>

    <p class="text-gray-300">Quantum slide attacks are a very efficient quantum counterpart of the classical slide attacks [3]. They have been introduced in [24], with a polynomial-time attack on 1-round self-similar ciphers. In many cases, our algorithm does not improve these attacks, because they are already too efficient and do not rely on a partial exhaustive search. Still, some of them use a partial exhaustive search. This is the case of the slide attack against 2 round self-similar ciphers of [31] and the slide attacks against whitened Feistels of [6].</p>

    <p class="text-gray-300">For example, we can see a 2 round self-similar cipher as an example of iterated FX cipher, as in Figure 9. Define functions  <span class="math">p_i</span> ,  <span class="math">F_i</span> , and g as</p>

    <p class="text-gray-300"><span class="math">$p_i((b,x)) = \\begin{cases} (0,E_i(x)) \\text{ if } b=0\\\\ (1,x) \\text{ if } b=1 \\end{cases}, \\quad F_i((b,x),y) = \\begin{cases} y \\oplus x \\text{ if } b=0\\\\ E_i(y) \\oplus x \\text{ if } b=1 \\end{cases},</span>$</p>

    <p class="text-gray-300">and  <span class="math">g((b,x))=\\mathrm{iFX}(x)</span> . We have the property that  <span class="math">\\mathrm{iFX}(E_{k_2}(x\\oplus k_1))\\oplus(x\\oplus k_1)=E_{k_2}(\\mathrm{iFX}(x))\\oplus x</span> . Hence, we have the hidden period  <span class="math">(1,k_1)</span>  in the function  <span class="math">f_{k_2}((b,x))=F_{k_2}((b,x),g(p_{k_2}(b,x)))</span> . To apply our attack, we need to compute  <span class="math">\\sum_{x,b}|x\\rangle|b\\rangle|f_i((b,x))\\rangle</span>  from the state  <span class="math">\\sum_x|x\\rangle|\\mathrm{iFX}(x)\\rangle</span> . We first need to add one qubit to obtain  <span class="math">\\sum_x|x\\rangle(|0\\rangle+|1\\rangle)|\\mathrm{iFX}(x)\\rangle</span> . Then, conditioned on the second register to be 0, we transform x into  <span class="math">E_i^{-1}(x)</span> . Next, conditioned on the second register to be 1, we transform  <span class="math">\\mathrm{iFX}(x)</span>  into  <span class="math">E_i(\\mathrm{iFX}(x))</span> . Finally, we add the first register to the third. Hence, we can apply our attack, and retrieve  <span class="math">k_1</span>  and  <span class="math">k_2</span>  using  <span class="math">\\mathcal{O}(|k_1|)</span>  queries and  <span class="math">\\mathcal{O}(|k_1|^32^{|k_2|/2})</span>  time, assuming  <span class="math">|k_1|=\\Omega(|k_2|)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> https://csrc.nist.gov/Projects/Lightweight-Cryptography</p>

    <p class="text-gray-300">    <img src="_page_28_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 9. Iterated-FX cipher.</p>

    <p class="text-gray-300">The above problem of recovering keys can be generalized as the following problem, which can be solved by the same strategy as above.</p>

    <p class="text-gray-300">Problem 4 (Constructing and Finding a Hidden Period). Let  <span class="math">g:\\{0,1\\}^n \\to \\{0,1\\}^\\ell</span>  be a function,  <span class="math">i \\in I</span> ,  <span class="math">p_i:\\{0,1\\}^n \\to \\{0,1\\}^n</span>  be a permutation and  <span class="math">F_i:\\{0,1\\}^n \\times \\{0,1\\}^\\ell \\to \\{0,1\\}^\\ell</span>  be a function such that  <span class="math">F_i(x,\\cdot)</span>  is a permutation. Assume that there exists  <span class="math">i_0 \\in I</span>  such that  <span class="math">f_{i_0}(x) = F_{i_0}(x, g(p_{i_0}(x)))</span>  has a period, i.e.:  <span class="math">\\forall x \\in \\{0,1\\}^n, f_{i_0}(x) = f_{i_0}(x \\oplus s)</span>  for some s. Assume that we are given quantum oracle access to  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and classical or quantum oracle access to  <span class="math">F_i</span> . (In the Q1 setting,  <span class="math">F_i</span>  will be a quantum oracle.) Then find  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  and  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  are  <span class="math">F_i</span>  ar</p>

    <p class="text-gray-300">This problem assumes that g is a keyed function, and that we can reversibly transform (x,g(x)) into a couple  <span class="math">(y,f_i(y))</span> , with  <span class="math">f_i</span>  a periodic function if  <span class="math">i=i_0</span> . We can see this transformation as a generalization of the CCZ equivalence [11], where the function mapping the graph of g and the graph of  <span class="math">f_i</span>  do not need to be an affine function. There may also be more than one solution (in which case we just want to find one), or there may be none, just as Grover's algorithm can handle cases with many expected solutions, or distinguish whether there is a solution or not. Note that Problem 3 is a special case of the above problem, in the case where  <span class="math">p_i</span>  is the identity, and  <span class="math">F_i</span>  is only the xoring of g and another function.</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Conclusion</h2>

    <p class="text-gray-300">In this paper, we have introduced a new quantum algorithm, in which we make use of Simon's algorithm in an offline way. The idea of making poly(n) superposition queries to the oracle (with, as input, a uniform superposition), storing them as some compressed database on  <span class="math">n^2</span>  qubits, and reusing them during the iterations of a Grover search, yielded surprising results. This idea, initially targeting the query complexity of some Q2 attacks on cryptographic schemes, enabled us to find new quantum-time/classical-data tradeoffs. Our result has three consequences, each of which answers a long-standing question in post-quantum cryptography.</p>

    <p class="text-gray-300">Simon's Algorithm can be Used in An Offline Setting. We provided the first example of use of Simon's algorithm (or more precisely, its core idea) in an offline setting, without quantum oracle queries.</p>

    <p class="text-gray-300">Improving More than the Time Complexity. Consider the example of our attack on the Even-Mansour construction in quantum time  <span class="math">\\widetilde{\\mathcal{O}}\\left(2^{n/3}\\right)</span>  and classical queries  <span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span> . With the same number of queries, the classical attack requires  <span class="math">\\mathcal{O}\\left(2^{2n/3}\\right)</span>  time and  <span class="math">\\mathcal{O}\\left(2^{n/3}\\right)</span>  classical memory to store the queries. In our attack, we do not need this storage. To the best of our knowledge, this is the first time that a quantum Q1 attack provides a quadratic speedup while the needs of hardware are also reduced.</p>

    <p class="text-gray-300">Q2 Attacks Make a Difference. Schemes which do not have an attack in the superposition model cannot be attacked by our algorithm. We showed that their algebraic structure, which makes the superposition attack possible, indeed made a practical difference when it came to Q1 attacks. We believe that this question needs further investigation.</p>

    <p class="text-gray-300"><strong>Acknowledgements.</strong> The authors thank L&eacute;o Perrin for proofreading this article and Elena Kirshanova for helpful remarks. This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement  <span class="math">n^o</span>  714294 - acronym QUASYModo).</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Albrecht, M.R., Driessen, B., Kavun, E.B., Leander, G., Paar, C., Yal&ccedil;in, T.: Block ciphers focus on the linear layer (feat. PRIDE). In: CRYPTO (2). Lecture Notes in Computer Science, vol. 8616, pp. 57&ndash;76. Springer (2014)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bertoni, G., Daemen, J., Hoffert, S., Peeters, M., Assche, G.V., Keer, R.V.: Farfalle: parallel permutation-based cryptography. IACR Trans. Symmetric Cryptol. 2017(4), 1&ndash;38 (2017), https://tosc.iacr.org/index.php/ToSC/article/view/801</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Biryukov, A., Wagner, D.A.: Slide attacks. In: FSE. Lecture Notes in Computer Science, vol. 1636, pp. 245&ndash;259. Springer (1999)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bonnetain, X.: Quantum key-recovery on full AEZ. In: Selected Areas in Cryptography SAC 2017. Lecture Notes in Computer Science, vol. 10719, pp. 394&ndash;406. Springer (2018)</li>
    </ul></li>
      <li><p class="text-gray-300">Bonnetain, X., Naya-Plasencia, M.: Hidden shift quantum cryptanalysis and implications. In: ASIACRYPT 2018. Lecture Notes in Computer Science, vol. 11272, pp. 560&ndash;592. Springer (2018)</p></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bonnetain, X., Naya-Plasencia, M., Schrottenloher, A.: On quantum slide attacks. In: Selected Areas in Cryptography SAC 2019. Lecture Notes in Computer Science, Springer (2020)</li>
    </ul></li>
      <li><p class="text-gray-300">Borghoff, J., Canteaut, A., G&uuml;neysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., Rombouts, P., Thomsen, S.S., Yal&ccedil;in, T.: PRINCE - A low-latency block cipher for pervasive computing applications - extended abstract. In: ASIACRYPT. Lecture Notes in Computer Science, vol. 7658, pp. 208&ndash;225. Springer (2012)</p></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Brassard, G., Hoyer, P., Mosca, M., Tapp, A.: Quantum amplitude amplification and estimation. Contemporary Mathematics 305, 53&ndash;74 (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Brassard, G., H&oslash;yer, P., Tapp, A.: Quantum cryptanalysis of hash and claw-free functions. In: Lucchesi, C.L., Moura, A.V. (eds.) LATIN '98: Theoretical Informatics, Third Latin American Symposium, Campinas, Brazil, April, 20-24, 1998, Proceedings. Lecture Notes in Computer Science, vol. 1380, pp. 163&ndash;169. Springer (1998), https://doi.org/10.1007/BFb0054319</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Canteaut, A., Duval, S., Leurent, G., Naya-Plasencia, M., Perrin, L., Pornin, T., Schrottenloher, A.: Saturnin: a suite of lightweight symmetric algorithms for post-quantum security (2019), https://project.inria.fr/saturnin/files/2019/05/SATURNIN-spec.pdf</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Carlet, C., Charpin, P., Zinoviev, V.: Codes, bent functions and permutations suitable for DES-like cryptosystems. Designs, Codes and Cryptography 15(2), 125&ndash; 156 (1998)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Chailloux, A., Naya-Plasencia, M., Schrottenloher, A.: An efficient quantum collision search algorithm and implications on symmetric cryptography. In: ASI-ACRYPT (2). Lecture Notes in Computer Science, vol. 10625, pp. 211&ndash;240. Springer (2017)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Chakraborti, A., Datta, N., Nandi, M., Yasuda, K.: Beetle family of lightweight and secure authenticated encryption ciphers. IACR Trans. Cryptogr. Hardw. Embed. Syst. 2018(2), 218&ndash;241 (2018), https://doi.org/10.13154/tches.v2018.i2.218-241</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Crowley, P., Biggers, E.: Adiantum: length-preserving encryption for entrylevel processors. IACR Trans. Symmetric Cryptol. 2018(4), 39&ndash;61 (2018), https://doi.org/10.13154/tosc.v2018.i4.39-61</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Daemen, J.: Limitations of the even-mansour construction. In: ASIACRYPT 1991. Lecture Notes in Computer Science, vol. 739, pp. 495&ndash;498. Springer (1991)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Daemen, J., Hoffert, S., Assche, G.V., Keer, R.V.: The design of xoodoo and xoofff. IACR Trans. Symmetric Cryptol. 2018(4), 1&ndash;38 (2018), https://doi.org/10.13154/tosc.v2018.i4.1-38</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Dinur, I.: Cryptanalytic time-memory-data tradeoffs for fx-constructions with applications to PRINCE and PRIDE. In: EUROCRYPT 2015. Lecture Notes in Computer Science, vol. 9056, pp. 231&ndash;253. Springer (2015)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Dinur, I., Dunkelman, O., Keller, N., Shamir, A.: Cryptanalysis of iterated evenmansour schemes with two keys. In: ASIACRYPT 2014. Lecture Notes in Computer Science, vol. 8873, pp. 439&ndash;457. Springer (2014)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Even, S., Mansour, Y.: A construction of a cipher from a single pseudorandom permutation. J. Cryptology 10(3), 151&ndash;162 (1997), http://dx.doi.org/10.1007/s001459900025</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Gagliardoni, T.: Quantum Security of Cryptographic Primitives. Ph.D. thesis, Darmstadt University of Technology, Germany (2017), http://tuprints.ulb.tudarmstadt.de/6019/</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Grassl, M., Langenberg, B., Roetteler, M., Steinwandt, R.: Applying grover's algorithm to AES: quantum resource estimates. In: PQCrypto. Lecture Notes in Computer Science, vol. 9606, pp. 29&ndash;43. Springer (2016)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Grover, L.K.: A Fast Quantum Mechanical Algorithm for Database Search. In: Miller, G.L. (ed.) Proceedings of the Twenty-Eighth Annual ACM Symposium on the Theory of Computing, Philadelphia, Pennsylvania, USA, May 22-24, 1996. pp. 212&ndash;219. ACM (1996), http://doi.acm.org/10.1145/237814.237866</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hosoyamada, A., Sasaki, Y.: Cryptanalysis against symmetric-key schemes with online classical queries and offline quantum computations. In: CT-RSA. Lecture Notes in Computer Science, vol. 10808, pp. 198&ndash;218. Springer (2018)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kaplan, M., Leurent, G., Leverrier, A., Naya-Plasencia, M.: Breaking symmetric cryptosystems using quantum period finding. In: CRYPTO (2). Lecture Notes in Computer Science, vol. 9815, pp. 207&ndash;237. Springer (2016)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kaplan, M., Leurent, G., Leverrier, A., Naya-Plasencia, M.: Quantum differential and linear cryptanalysis. IACR Trans. Symmetric Cryptol. 2016(1), 71&ndash;94 (2016), http://tosc.iacr.org/index.php/ToSC/article/view/536</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kilian, J., Rogaway, P.: How to protect DES against exhaustive key search. In: CRYPTO. Lecture Notes in Computer Science, vol. 1109, pp. 252&ndash;267. Springer (1996)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kuperberg, G.: A subexponential-time quantum algorithm for the dihedral hidden subgroup problem. SIAM J. Comput. 35(1), 170&ndash;188 (2005), https://doi.org/10.1137/S0097539703436345</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kuperberg, G.: Another subexponential-time quantum algorithm for the dihedral hidden subgroup problem. In: TQC 2013. LIPIcs, vol. 22, pp. 20&ndash;34. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik (2013)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kuwakado, H., Morii, M.: Quantum distinguisher between the 3-round feistel cipher and the random permutation. In: IEEE International Symposium on Information Theory, ISIT 2010, Proceedings. pp. 2682&ndash;2685. IEEE (2010)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Kuwakado, H., Morii, M.: Security on the quantum-type even-mansour cipher. In: Proceedings of the International Symposium on Information Theory and its Applications, ISITA 2012. pp. 312&ndash;316. IEEE (2012)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Leander, G., May, A.: Grover Meets Simon Quantumly Attacking the FXconstruction. In: ASIACRYPT 2017. Lecture Notes in Computer Science, vol. 10625, pp. 161&ndash;178. Springer (2017)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Martin, L.: XTS: A mode of AES for encrypting hard disks. IEEE Security &amp; Privacy 8(3), 68&ndash;69 (2010), https://doi.org/10.1109/MSP.2010.111</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Mouha, N., Mennink, B., Herrewege, A.V., Watanabe, D., Preneel, B., Verbauwhede, I.: Chaskey: An efficient MAC algorithm for 32-bit microcontrollers. In: Selected Areas in Cryptography. Lecture Notes in Computer Science, vol. 8781, pp. 306&ndash;323. Springer (2014)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>National Academies of Sciences, Engineering, and Medicine: Quantum Computing: Progress and Prospects. The National Academies Press, Washington, DC (2018), https://www.nap.edu/catalog/25196/quantum-computing-progress-and-prospects</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>National Institute of Standards and Technlology: Submission requirements and evaluation criteria for the post-quantum cryptography standardization process (2016), https://csrc.nist.gov/CSRC/media/ Projects/Post-Quantum-Cryptography/documents/call-for-proposals-final-dec-2016.pdf</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Nielsen, M.A., Chuang, I.: Quantum computation and quantum information. AAPT (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R&uml;otteler, M., Steinwandt, R.: A note on quantum related-key attacks. Inf. Process. Lett. 115(1), 40&ndash;44 (2015), https://doi.org/10.1016/j.ipl.2014.08.009</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Sasaki, Y., Todo, Y., Aoki, K., Naito, Y., Sugawara, T., Murakami, Y., Matsui, M., Hirose, S.: Minalpher v1.1. CAESAR competition. (2015), https://competitions.cr.yp.to/round2/minalpherv11.pdf</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Shor, P.W.: Algorithms for quantum computation: Discrete logarithms and factoring. In: 35th Annual Symposium on Foundations of Computer Science. pp. 124&ndash;134. IEEE Computer Society (1994)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Simon, D.R.: On the Power of Quantum Computation. In: 35th Annual Symposium on Foundations of Computer Science. pp. 116&ndash;123 (1994)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Winternitz, R.S., Hellman, M.E.: Chosen-key attacks on a block cipher. Cryptologia 11(1), 16&ndash;20 (1987), https://doi.org/10.1080/0161-118791861749</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Here we give error and complexity analyses for Alg-ExpQ1 and Alg-PolyQ2, and give proofs for Propositions 2 and 3.</p>

    <p class="text-gray-300">Recall that, in both of Alg-ExpQ1 and Alg-PolyQ2, we run a testing procedure test in each iteration of the Grover search. For each i &isin; {0, 1} <sup>m</sup> ({0, 1} <sup>m</sup> is the search space), we expect that test checks whether i is a good element by using auxiliary quantum data |&psi;gi, without changing |&psi;gi. However, in fact test outputs results only with some errors, and |&psi;gi is slightly modified at each test. Thus we have to do two kinds of analyses:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Analyses on the error of the procedure test.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Analyses on how much the error of test affects the success probability of the entire Grover search.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">In Section A.1, we give error analyses of the testing procedure test. In Section A.2, we analyze how the error of test affects the success probability of the Grover search, in a general setting. Actually we discuss about the quantum amplitude amplification (QAA) technique, which is a generalization of the entire Grover search. Finally, in Section A.3, we prove Propositions 2 and 3 by using the results in Sections A.1 and A.2.</p>

    <p class="text-gray-300">Recall that, for each function g : {0, 1} <sup>n</sup> &rarr; {0, 1} \` and a fixed positive integer c, the quantum state |&psi;gi is defined as</p>

    <p class="text-gray-300"><span class="math">$|\\psi_g\\rangle := \\bigotimes_{x \\in \\{0,1\\}^n} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle |g(x)\\rangle \\tag{11}</span>$</p>

    <p class="text-gray-300">Roughly speaking, we expect that the unitary operator test satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{test}|i\\rangle|\\psi_g\\rangle|b\\rangle = \\begin{cases} |i\\rangle|\\psi_g\\rangle|b\\rangle &amp; \\text{if } (f_i \\oplus g) \\text{ does not have a period,} \\\\ |i\\rangle|\\psi_g\\rangle|b \\oplus 1\\rangle &amp; \\text{if } (f_i \\oplus g) \\text{ has a period.} \\end{cases}</span>$
(12)</p>

    <p class="text-gray-300">holds with a small error. Recall that test is defined as a unitary operator that realizes the following procedures:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Query cn times to F to obtain</li>
    </ul>

    <p class="text-gray-300"><span class="math">$|i\\rangle \\otimes \\left(\\sum_{x_1 \\in \\{0,1\\}^n} |x_1\\rangle | (f_i \\oplus g)(x_1)\\rangle\\right) \\otimes \\cdots</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdots \\otimes \\left(\\sum_{x_{cn} \\in \\{0,1\\}^n} |x_{cn}\\rangle | (f_i \\oplus g)(x_{cn})\\rangle\\right) \\otimes |b\\rangle. \\tag{13}</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Apply I<sup>m</sup> &otimes; (H&otimes;<sup>n</sup> &otimes; I\`) cn &otimes; I<sup>1</sup> to obtain</li>
    </ul>

    <p class="text-gray-300"><span class="math">$|i\\rangle \\otimes \\left(\\sum_{u_{1},x_{1}\\in\\{0,1\\}^{n}} (-1)^{u_{1}\\cdot x_{1}} |u_{1}\\rangle |(f_{i}\\oplus g)(x_{1})\\rangle\\right) \\otimes \\cdots</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdots \\otimes \\left(\\sum_{u_{cn},x_{cn}\\in\\{0,1\\}^{n}} (-1)^{u_{cn}\\cdot x_{cn}} |u_{cn}\\rangle |(f_{i}\\oplus g)(x_{cn})\\rangle\\right) \\otimes |b\\rangle.</span>$</p>

    <p class="text-gray-300"><span class="math">$(14)</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Compute d := dim(Span(u1, . . . , ucn)), set r := 0 if d = n and r := 1 if d &lt; n, and add r to b. Then uncompute d and r, and obtain</li>
    </ul>

    <p class="text-gray-300"><span class="math">$|i\\rangle \\otimes \\sum_{\\substack{u_1,\\dots,u_{cn}\\\\x_1,\\dots,x_{cn}}} (-1)^{u_1\\cdot x_1} |u_1\\rangle |(f_i \\oplus g)(x_1)\\rangle \\otimes \\cdots</span>$
<span class="math">$\\cdots \\otimes (-1)^{u_{cn}\\cdot x_{cn}} |u_{cn}\\rangle |(f_i \\oplus g)(x_{cn})\\rangle \\otimes |b \\oplus r\\rangle. \\tag{15}</span>$</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Uncompute Steps 1 and 2.</li>
    </ul>

    <p class="text-gray-300">Note that if (f<sup>i</sup> &oplus; g) has a period, then r = 1 always holds and test|ii|&psi;gi|bi = |ii|&psi;gi|b &oplus; 1i follows. On the other hand, even if (f<sup>i</sup> &oplus; g) does not have any period, test|ii|&psi;gi|bi is not necessarily equal to |ii|&psi;gi|bi. However, we expect that test|ii|&psi;gi|bi = |ii|&psi;gi|bi + |&delta;i holds for some small error term |&delta;i.</p>

    <p class="text-gray-300">Moreover, in our attack setting we apply the operator test to a superposition:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle + \\sum_{f_i \\in F_1} \\beta_i |i\\rangle |\\psi_g\\rangle |b\\rangle, \\tag{16}</span>$</p>

    <p class="text-gray-300">where P|&alpha;<sup>i</sup> | <sup>2</sup> + P|&beta;<sup>i</sup> <sup>2</sup> = 1, and F0, F<sup>1</sup> are the subsets of F defined as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} F_0 &amp;:= \\left\\{ f_i \\in F | f_i \\oplus g \\text{ does not have any period} \\right\\}, \\\\ F_1 &amp;:= \\left\\{ f_i \\in F | f_i \\oplus g \\text{ has a period} \\right\\}. \\end{split}</span>$</p>

    <p class="text-gray-300">Roughly speaking, we expect that, when we apply test to the state (16), it changes to</p>

    <p class="text-gray-300"><span class="math">$\\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle + \\sum_{f_i \\in F_1} \\beta_i |i\\rangle |\\psi_g\\rangle |b \\oplus 1\\rangle</span>$
(17)</p>

    <p class="text-gray-300">up to a small error term.</p>

    <p class="text-gray-300">We can show the following lemma, which guarantees that the operator test works as we expect if c is sufficiently large.</p>

    <p class="text-gray-300">Lemma 1. It holds that</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{test}\\left(\\sum_{f_i \\in F_1} \\beta_i |i\\rangle |\\psi_g\\rangle |b\\rangle\\right) = \\sum_{f_i \\in F_1} \\beta_i |i\\rangle |\\psi_g\\rangle |b \\oplus 1\\rangle \\tag{18}</span>$</p>

    <p class="text-gray-300">for  <span class="math">b \\in \\{0,1\\}</span> . In addition, suppose that there exists a constant  <span class="math">0 \\le \\epsilon &lt; 1</span>  such that the following condition holds:</p>

    <p class="text-gray-300"><span class="math">$\\max_{\\substack{t \\in \\{0,1\\}^n \\setminus \\{0^n\\} \\\\ f_i \\in F_0}} \\Pr_{x \\leftarrow \\{0,1\\}^n} \\left[ (f_i \\oplus g)(x \\oplus t) = (f_i \\oplus g)(x) \\right] \\le \\epsilon \\tag{19}</span>$</p>

    <p class="text-gray-300">Then, for arbitrary  <span class="math">b \\in \\{0,1\\}</span> , there exists a vector  <span class="math">|\\delta_b\\rangle</span>  such that  <span class="math">|||\\delta_b\\rangle|| &lt; 2^{(n+1)/2}((1+\\epsilon)/2)^{cn/2}</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{test}\\left(\\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle\\right) = \\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle + |\\delta_b\\rangle \\tag{20}</span>$</p>

    <p class="text-gray-300">holds.</p>

    <p class="text-gray-300"><em>Proof.</em> (18) obviously follows from the definition of test and  <span class="math">F_1</span> . Below we show that (20) holds. Notice that (19) holds when the  <span class="math">f_i \\in F_0</span>  are almost random and summarizes that each of them is far from periodic.</p>

    <p class="text-gray-300">Let  <span class="math">U_1</span> ,  <span class="math">U_2</span> , and  <span class="math">U_3</span>  be the unitary operators that realize Steps 1, 2 and 3 of test, respectively. ( <span class="math">U_1^*</span>  and  <span class="math">U_2^*</span>  correspond to uncomputing  <span class="math">U_1</span>  and  <span class="math">U_2</span> , respectively, and test =  <span class="math">U_1^*U_2^*U_3U_2U_1</span>  holds.) Note that  <span class="math">U_1|i\\rangle|\\psi_g\\rangle|b\\rangle = |i\\rangle|\\psi_{f_i\\oplus g}\\rangle|b\\rangle</span>  holds for each i.</p>

    <p class="text-gray-300">holds for each i. Let  <span class="math">\\left|\\psi_2^{(i)}\\right\\rangle := U_2 U_1 |i\\rangle |\\psi_g\\rangle |b\\rangle = U_2 |i\\rangle |\\psi_{f_i \\oplus g}\\rangle |b\\rangle</span> . In addition, let us decompose  <span class="math">\\left|\\psi_2^{(i)}\\right\\rangle</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\left|\\psi_{2}^{(i)}\\right\\rangle = |i\\rangle \\otimes \\left|\\eta_{\\mathsf{good}}^{(i)}\\right\\rangle \\otimes |b\\rangle + |i\\rangle \\otimes \\left|\\eta_{\\mathsf{bad}}^{(i)}\\right\\rangle \\otimes |b\\rangle,\\tag{21}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\left|\\eta_{\\mathsf{good}}^{(i)}\\right\\rangle</span>  and  <span class="math">\\left|\\eta_{\\mathsf{bad}}^{(i)}\\right\\rangle</span>  are the vectors projected to the subspaces that correspond to the tuple  <span class="math">(u_1,\\ldots,u_{cn})</span>  such that  <span class="math">\\dim(\\mathrm{Span}(u_1,\\ldots,u_{cn}))=n</span>  and  <span class="math">\\dim(\\mathrm{Span}(u_1,\\ldots,u_{cn}))&lt; n</span> , respectively, in Step 2 of test. In particular,</p>

    <p class="text-gray-300"><span class="math">$\\left| \\eta_{\\mathsf{bad}}^{(i)} \\right\\rangle = \\sum_{\\substack{x_1, \\dots, x_{cn} \\\\ u_1, \\dots, u_{cn} \\\\ \\dim(\\operatorname{Span}(u_1, \\dots, u_{cn})) &lt; n}} (-1)^{u_1 \\cdot x_1} |u_1\\rangle |(f_i \\oplus g)(x_1)\\rangle \\otimes \\cdots</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdots \\otimes (-1)^{u_{cn} \\cdot x_{cn}} |u_{cn}\\rangle |(f_i \\oplus g)(x_{cn})\\rangle \\tag{22}</span>$</p>

    <p class="text-gray-300">holds. Then</p>

    <p class="text-gray-300"><span class="math">$U_3 U_2 U_1 |i\\rangle |\\psi_g\\rangle |b\\rangle = U_3 \\left|\\psi_2^{(i)}\\right\\rangle = |i\\rangle \\left|\\eta_{\\mathsf{good}}^{(i)}\\right\\rangle |b\\rangle + |i\\rangle \\left|\\eta_{\\mathsf{bad}}^{(i)}\\right\\rangle |b \\oplus 1\\rangle \\tag{23}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} \\operatorname{test}|i\\rangle|\\psi_{g}\\rangle|b\\rangle &amp;= U_{1}^{*}U_{2}^{*}U_{3}U_{2}U_{1}|i\\rangle|\\psi_{g}\\rangle|b\\rangle \\\\ &amp;= U_{1}^{*}U_{2}^{*}\\left(|i\\rangle\\otimes\\left|\\eta_{\\mathsf{good}}^{(i)}\\rangle\\otimes|b\\rangle+|i\\rangle\\otimes\\left|\\eta_{\\mathsf{bad}}^{(i)}\\rangle|b\\rangle\\right) \\\\ &amp;+ U_{1}^{*}U_{2}^{*}\\left(|i\\rangle\\left|\\eta_{\\mathsf{bad}}^{(i)}\\rangle|b\\oplus1\\rangle-|i\\rangle\\left|\\eta_{\\mathsf{bad}}^{(i)}\\rangle|b\\rangle\\right) \\\\ &amp;= |i\\rangle|\\psi_{g}\\rangle|b\\rangle+|\\delta_{b,i}\\rangle \\end{aligned} \\tag{24}</span>$</p>

    <p class="text-gray-300">follows, where  <span class="math">|\\delta_{b,i}\\rangle = U_1^* U_2^* \\left(|i\\rangle \\left|\\eta_{\\mathsf{bad}}^{(i)}\\right\\rangle |b\\oplus 1\\rangle - |i\\rangle \\left|\\eta_{\\mathsf{bad}}^{(i)}\\right\\rangle |b\\rangle \\right)</span> . Therefore we have</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{test}\\left(\\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle\\right) = \\sum_{f_i \\in F_0} \\alpha_i |i\\rangle |\\psi_g\\rangle |b\\rangle + |\\delta_b\\rangle, \\tag{25}</span>$</p>

    <p class="text-gray-300">where  <span class="math">|\\delta_b\\rangle = \\sum_{f_i \\in F_0} \\alpha_i |\\delta_{b,i}\\rangle</span> . Note that</p>

    <p class="text-gray-300"><span class="math">$\\||\\delta_b\\rangle\\| = \\sqrt{2} \\left\\| \\sum_{f_i \\in F_0} \\alpha_i |i\\rangle \\left| \\eta_{\\mathsf{bad}}^{(i)} \\right\\rangle |b\\rangle \\right\\|</span>$
(26)</p>

    <p class="text-gray-300">holds.</p>

    <p class="text-gray-300">By orthogonality of the  <span class="math">|i\\rangle</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$\\||\\delta_{b}\\rangle\\|^{2} = 2 \\sum_{f_{i} \\in F_{0}} |\\alpha_{i}|^{2} \\||\\eta_{\\mathsf{bad}}^{(i)}\\rangle\\|^{2} \\le 2 \\sum_{f_{i} \\in F_{0}} |\\alpha_{i}|^{2} \\max_{f_{i} \\in F_{0}} \\||\\eta_{\\mathsf{bad}}^{(i)}\\rangle\\|^{2} \\le 2 \\max_{f_{i} \\in F_{0}} \\||\\eta_{\\mathsf{bad}}^{(i)}\\rangle\\|^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$(27)</span>$</p>

    <p class="text-gray-300">which means that it suffices to focus on a single  <span class="math">f_i</span>  and bound  <span class="math">p_{\\mathsf{bad}}^{(i)} := \\left\\| \\left| \\eta_{\\mathsf{bad}}^{(i)} \\right| \\right\\|^2</span> . This is the probability of obtaining, for this function  <span class="math">f_i</span> , a tuple  <span class="math">(u_1, \\ldots, u_{cn})</span>  such that  <span class="math">\\dim(\\mathrm{Span}(u_1, \\ldots, u_{cn})) &lt; n</span>  upon measurement of the state  <span class="math">\\left| \\psi_2^{(i)} \\right\\rangle = |i\\rangle \\otimes \\left( \\left| \\eta_{\\mathsf{good}}^{(i)} \\right\\rangle + \\left| \\eta_{\\mathsf{bad}}^{(i)} \\right\\rangle \\right) \\otimes |b\\rangle</span> . We just have to make sure that it is low for all  <span class="math">f_i</span> .  <span class="math">\\dim(\\mathrm{Span}(u_1, \\ldots, u_{cn})) &lt; n</span>  holds if and only if there exists  <span class="math">t \\in \\{0, 1\\}^n \\setminus \\{0^n\\}</span>  such that  <span class="math">t \\perp u_j</span>  for all  <span class="math">1 \\leq j \\leq cn</span> . In addition, the registers  <span class="math">|u_1\\rangle, \\ldots, |u_{cn}\\rangle</span>  of  <span class="math">\\left| \\psi_2^{(i)} \\right\\rangle</span>  are unentangled from each other. Thus we have that</p>

    <p class="text-gray-300"><span class="math">$p_{\\mathsf{bad}}^{(i)} = \\Pr\\left[ (u_1, \\dots, u_{cn}) \\leftarrow \\left( \\mathsf{measure} \\middle| \\psi_2^{(i)} \\middle\\rangle \\right) : \\\\ \\exists t \\neq 0^n \\text{ s.t. } t \\perp u_j \\text{ for } 1 \\leq j \\leq cn \\right] \\\\ \\leq \\sum_{t \\in \\{0,1\\}^n \\setminus \\{0^n\\}} \\Pr\\left[ (u_1, \\dots, u_{cn}) \\leftarrow \\left( \\mathsf{measure} \\middle| \\psi_2^{(i)} \\middle\\rangle \\right) : \\\\ t \\perp u_j \\text{ for } 1 \\leq j \\leq cn \\right] \\\\ = \\sum_{t \\in \\{0,1\\}^n \\setminus \\{0^n\\}} \\left( \\Pr\\left[ u \\leftarrow \\left( \\mathsf{measure} \\middle| \\Psi^{(i)} \\middle\\rangle \\right) : t \\perp u \\right] \\right)^{cn} \\\\ \\leq 2^n \\left( \\max_{t \\in \\{0,1\\}^n \\setminus \\{0^n\\}} \\Pr\\left[ u \\leftarrow \\left( \\mathsf{measure} \\middle| \\Psi^{(i)} \\middle\\rangle \\right) : t \\perp u \\right] \\right)^{cn}</span>$
(28)</p>

    <p class="text-gray-300">holds, where  <span class="math">|\\Psi^{(i)}\\rangle = \\sum_{u,x} (-1)^{u\\cdot x} |u\\rangle |(f_i \\oplus g)(x)\\rangle</span> .</p>

    <p class="text-gray-300">Now we use the following claim as a fact, which is shown as a subordinate result in the proof of Theorem 1 in [24].</p>

    <p class="text-gray-300">Claim. Let  <span class="math">h:\\{0,1\\}^n \\to \\{0,1\\}^\\ell</span>  be a function and  <span class="math">|\\Phi\\rangle:=\\sum_{u,x}(-1)^{u\\cdot x}|u\\rangle|h(x)\\rangle</span> . Then, for each  <span class="math">t\\in\\{0,1\\}^n\\setminus\\{0^n\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[u \\leftarrow (\\text{measure } |\\Phi\\rangle) : t \\perp u\\right] = \\frac{1}{2} \\left(1 + \\Pr_{x \\leftarrow \\{0,1\\}^n} \\left[h(x \\oplus t) = h(x)\\right]\\right)</span>$
(29)</p>

    <p class="text-gray-300">holds.</p>

    <p class="text-gray-300">Applying this claim with  <span class="math">(f_i \\oplus g)</span>  and  <span class="math">|\\Psi^{(i)}\\rangle</span>  instead of h and  <span class="math">|\\Phi\\rangle</span> , from (28) it follows that  <span class="math">p_{\\mathsf{bad}}^{(i)}</span>  is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$2^{n} \\left( \\frac{1}{2} \\left( 1 + \\max_{t \\in \\{0,1\\}^{n} \\setminus \\{0^{n}\\}} \\Pr_{x \\leftarrow \\{0,1\\}^{n}} \\left[ (f_{i} \\oplus g)(x \\oplus t) = (f_{i} \\oplus g)(x) \\right] \\right) \\right)^{cn}.</span>$
(30)</p>

    <p class="text-gray-300">In addition, by the condition (19),</p>

    <p class="text-gray-300"><span class="math">$\\max_{\\substack{t \\in \\{0,1\\}^n \\setminus \\{0^n\\} \\\\ f_i \\in F_0}} \\Pr_{x \\leftarrow \\{0,1\\}^n} \\left[ (f_i \\oplus g)(x \\oplus t) = (f_i \\oplus g)(x) \\right] \\le \\epsilon</span>$
(31)</p>

    <p class="text-gray-300">holds for all  <span class="math">f_i \\in F_0</span> . Thus</p>

    <p class="text-gray-300"><span class="math">$p_{\\mathsf{bad}}^{(i)} \\le 2^n \\left(\\frac{1+\\epsilon}{2}\\right)^{cn}.\\tag{32}</span>$</p>

    <p class="text-gray-300">follows.</p>

    <p class="text-gray-300">From (27) and (32),</p>

    <p class="text-gray-300"><span class="math">$\\||\\delta_b\\rangle\\|^2 \\le 2^{n+1} \\left(\\frac{1+\\epsilon}{2}\\right)^{cn} \\tag{33}</span>$</p>

    <p class="text-gray-300">follows, which completes the proof.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Error Propagation Analyses for QAA</h3>

    <p class="text-gray-300">Here we analyze how the error of testing procedures affects success probability and complexity of the entire Grover search. For generality, we analyze the quantum amplitude amplification (QAA) technique by Brassard <em>et al.</em> [8] rather than the original Grover search. We first review the original QAA technique, and then give error analyses in our setting, explaining the difference between our setting and the original one.</p>

    <p class="text-gray-300">The Original Quantum Amplitude Amplification Let  <span class="math">\\mathcal{A}</span>  be a unitary operator that acts on n-qubit states and  <span class="math">\\chi: \\{0,1\\}^n \\to \\{0,1\\}</span>  be a function. Suppose that we obtain x such that  <span class="math">\\chi(x) = 1</span>  when we measure the state  <span class="math">\\mathcal{A}|0^n\\rangle</span>  with a probability a &gt; 0. We say that  <span class="math">x \\in \\{0,1\\}^n</span>  is good if  <span class="math">\\chi(x) = 1</span>  and x is bad otherwise. In addition, we say that a vector is good (resp. bad) if it is in the space spanned by  <span class="math">\\{|x\\rangle\\}_{x:\\text{good}}</span>  (resp.,  <span class="math">\\{|x\\rangle\\}_{x:\\text{bad}}</span> ). Our goal is to amplify</p>

    <p class="text-gray-300">the probability a and get &quot;good&quot;  <span class="math">x \\in \\{0,1\\}^n</span>  such that  <span class="math">\\chi(x) = 1</span>  with a high probability.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{S}_{\\chi}</span>  be the unitary operator defined as</p>

    <p class="text-gray-300"><span class="math">$S_{\\chi}|x\\rangle := \\begin{cases} -|x\\rangle &amp; \\text{if } \\chi(x) = 1, \\\\ |x\\rangle &amp; \\text{if } \\chi(x) = 0. \\end{cases}</span>$
(34)</p>

    <p class="text-gray-300">Below we call  <span class="math">S_{\\chi}</span>  checking procedure since it checks whether  <span class="math">\\chi(x) = 1</span>  and changes the phase accordingly. In addition, let  <span class="math">S_0</span>  denote  <span class="math">S_{\\chi_0}</span> , where  <span class="math">\\chi_0</span>  is the function such that  <span class="math">\\chi_0(x) = 1</span>  if and only if  <span class="math">x = 0^n</span> . Define a unitary operator  <span class="math">Q = Q(A, \\chi)</span>  by  <span class="math">Q := -AS_0A^{-1}S_{\\chi}</span> . Then the following proposition holds.</p>

    <p class="text-gray-300"><strong>Proposition 6 (Theorem 2 in [8].).</strong> Set  <span class="math">r := \\lfloor \\pi/4\\theta_a \\rfloor</span> , where  <span class="math">\\theta_a</span>  is the parameter such that  <span class="math">\\sin^2 \\theta_a = a</span>  and  <span class="math">0 &lt; \\theta_a \\le \\pi/2</span>  (note that  <span class="math">r \\approx \\sqrt{1/a}</span>  holds if a is sufficiently small). When we measure  <span class="math">Q^r \\mathcal{A}|0^n\\rangle</span> , we obtain  <span class="math">x \\in \\{0,1\\}^n</span>  such that  <span class="math">\\chi(x) = 1</span>  with a probability at least  <span class="math">\\max(1 - a, a)</span> .</p>

    <p class="text-gray-300">Here we give a rough overview of a proof of the above proposition. Let us put  <span class="math">|\\phi\\rangle := \\mathcal{A}|0^n\\rangle</span> , and decompose  <span class="math">|\\phi\\rangle</span>  as  <span class="math">|\\phi\\rangle = \\cos\\theta_a|\\phi_0\\rangle + \\sin\\theta_a|\\phi_1\\rangle</span> , where  <span class="math">|\\phi_0\\rangle</span>  and  <span class="math">|\\phi_1\\rangle</span>  are good and bad vectors, respectively. Note that  <span class="math">|\\phi_0\\rangle</span>  and  <span class="math">|\\phi_1\\rangle</span>  are uniquely determined from  <span class="math">|\\phi\\rangle</span> . Then we can show the following lemma, which claims that Q can be regarded as a rotation matrix on the space spanned by  <span class="math">|\\phi_0\\rangle</span>  and  <span class="math">|\\phi_1\\rangle</span> .</p>

    <p class="text-gray-300">Lemma 2 (Lemma 1 in [8]). It holds that</p>

    <p class="text-gray-300"><span class="math">$Q|\\phi_1\\rangle = \\cos 2\\theta_a |\\phi_1\\rangle - \\sin 2\\theta_a |\\phi_0\\rangle,</span>$</p>

    <p class="text-gray-300"><span class="math">$Q|\\phi_0\\rangle = \\sin 2\\theta_a |\\phi_1\\rangle + \\cos 2\\theta_a |\\phi_0\\rangle.</span>$</p>

    <p class="text-gray-300">From the above lemma, we have that</p>

    <p class="text-gray-300"><span class="math">$Q^r \\mathcal{A}|0^n\\rangle = \\sin((2r+1)\\theta_a)|\\phi_1\\rangle + \\cos((2r+1)\\theta_a)|\\phi_0\\rangle, \\tag{35}</span>$</p>

    <p class="text-gray-300">which implies that we obtain  <span class="math">x \\in \\{0,1\\}^n</span>  such that  <span class="math">\\chi(x) = 1</span>  since  <span class="math">(2r+1)\\theta_a \\approx \\pi/2</span> .</p>

    <p class="text-gray-300">Our Setting: Uncertain Checking Procedures Unlike the original technique, in our setting we consider the situation that the checking procedure can be done only with some errors. That is, we have access to a unitary operator  <span class="math">\\widehat{\\mathcal{S}&#x27;_{\\chi}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\widehat{\\mathcal{S}&#x27;_{\\chi}}|\\phi_1\\rangle|\\psi\\rangle|b\\rangle = |\\phi_1\\rangle|\\psi\\rangle|b\\oplus 1\\rangle + |\\delta_{1,b}\\rangle, \\tag{36}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\widehat{\\mathcal{S}&#x27;_{\\chi}}|\\phi_0\\rangle|\\psi\\rangle|b\\rangle = |\\phi_0\\rangle|\\psi\\rangle|b\\rangle + |\\delta_{0,b}\\rangle, \\tag{37}</span>$</p>

    <p class="text-gray-300">where  <span class="math">|\\psi\\rangle</span>  is an auxiliary data and  <span class="math">b \\in \\{0,1\\}</span> , and there exists an  <span class="math">\\epsilon \\geq 0</span>  such that  <span class="math">\\|\\delta_{a,b}\\| \\leq \\epsilon</span>  holds for  <span class="math">a,b \\in \\{0,1\\}</span> . (In our attack, the operator  <span class="math">\\widehat{\\mathcal{S}&#x27;_{\\chi}}</span>  is denoted by test.)</p>

    <p class="text-gray-300">Note that, given such  <span class="math">\\widehat{\\mathcal{S}&#x27;_\\chi}</span> , by using an ancilla qubit we can implement a unitary operator  <span class="math">\\mathcal{S}&#x27;_{\\chi}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$S_{\\chi}&#x27;|\\phi_1\\rangle|\\psi\\rangle = -|\\phi_1\\rangle|\\psi\\rangle + |\\delta_1\\rangle, \\tag{38}</span>$</p>

    <p class="text-gray-300"><span class="math">$S_{\\chi}&#x27;|\\phi_0\\rangle|\\psi\\rangle = |\\phi_0\\rangle|\\psi\\rangle + |\\delta_0\\rangle, \\tag{39}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\||\\delta_0\\rangle\\|</span> ,  <span class="math">\\||\\delta_1\\rangle\\| \\leq 2\\epsilon</span>  holds, since</p>

    <p class="text-gray-300"><span class="math">$\\widehat{\\mathcal{S}&#x27;_{\\chi}}|\\phi_a\\rangle|\\psi\\rangle|-\\rangle = (-1)^a|\\phi_a\\rangle|\\psi\\rangle|-\\rangle + \\frac{1}{\\sqrt{2}}(|\\delta_{a,0}\\rangle - |\\delta_{a,1}\\rangle)</span>$
(40)</p>

    <p class="text-gray-300">holds for  <span class="math">a \\in \\{0,1\\}</span> , here  <span class="math">|-\\rangle := \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)</span> . Let us define  <span class="math">Q&#x27; := -((\\mathcal{A}\\mathcal{S}_0\\mathcal{A}^{-1}) \\otimes I)\\mathcal{S}&#x27;_{\\chi}</span> . Then the following lemma holds.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> There exist vectors  <span class="math">|\\delta_0&#x27;\\rangle, |\\delta_1&#x27;\\rangle</span>  such that  <span class="math">||\\delta_0&#x27;\\rangle||, |||\\delta_1&#x27;\\rangle|| \\leq 2\\epsilon</span>  and</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;|\\phi_1\\rangle|\\psi\\rangle = (\\cos 2\\theta_a|\\phi_1\\rangle - \\sin 2\\theta_a|\\phi_0\\rangle)|\\psi\\rangle + |\\delta_1&#x27;\\rangle,</span>$</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;|\\phi_0\\rangle|\\psi\\rangle = (\\sin 2\\theta_a|\\phi_1\\rangle + \\cos 2\\theta_a|\\phi_0\\rangle)|\\psi\\rangle + |\\delta_0&#x27;\\rangle</span>$</p>

    <p class="text-gray-300">hold.</p>

    <p class="text-gray-300"><em>Proof.</em> We have that</p>

    <p class="text-gray-300"><span class="math">$\\|Q&#x27;|\\phi_1\\rangle|\\psi\\rangle - (Q\\otimes I)|\\phi_1\\rangle|\\psi\\rangle\\| = \\|\\mathcal{S}&#x27;_{\\gamma}|\\phi_1\\rangle|\\psi\\rangle - (\\mathcal{S}_{\\gamma}\\otimes I)|\\phi_1\\rangle|\\psi\\rangle\\| = \\|\\delta_1\\| \\le 2\\epsilon \\quad (41)</span>$</p>

    <p class="text-gray-300">holds. Therefore the first equality follows from Lemma 2. We can show the second equality in the same way.</p>

    <p class="text-gray-300">By using this lemma we can show the following proposition.</p>

    <p class="text-gray-300">Proposition 7 (QAA with uncertain checking procedures.). Let  <span class="math">\\epsilon</span>  be the error of  <span class="math">\\widehat{\\mathcal{S}&#x27;_{\\gamma}}</span>  described above. Then we have that</p>

    <p class="text-gray-300"><span class="math">$\\left| \\Pr \\left[ x \\leftarrow \\left( \\text{measure } Q&#x27;^{j} \\mathcal{A} | 0^{n} \\rangle | \\psi \\right) : \\chi(x) = 1 \\right] - \\Pr \\left[ x \\leftarrow \\left( \\text{measure } Q^{j} \\mathcal{A} | 0^{n} \\right) : \\chi(x) = 1 \\right] \\right| \\le 4j\\epsilon</span>$
(42)</p>

    <p class="text-gray-300">holds for all  <span class="math">x \\in \\{0,1\\}^n</span> . In particular, for  <span class="math">r := |\\pi/4\\theta_a|</span> , we obtain  <span class="math">x \\in \\{0,1\\}^n</span> such that  <span class="math">\\chi(x) = 1</span>  with a probability at least  <span class="math">\\max(1-a,a) - 4r\\epsilon</span>  when we measure  <span class="math">Q^{r} A |0^n\\rangle |\\psi\\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> From Lemma 3, it follows that there exists a vector  <span class="math">|\\delta^{(j)}\\rangle</span>  such that  <span class="math">\\||\\delta^{(j)}\\rangle\\| \\leq 4j\\epsilon</span>  and</p>

    <p class="text-gray-300"><span class="math">$Q^{\\prime j} \\mathcal{A} |0^{n}\\rangle |\\psi\\rangle = \\left(\\sin((2j+1)\\theta_{a})|\\phi_{1}\\rangle + \\cos((2j+1)\\theta_{a})|\\phi_{0}\\rangle\\right) \\otimes |\\psi\\rangle + \\left|\\delta^{(j)}\\right\\rangle</span>$
<span class="math">$= \\left(Q^{j} \\mathcal{A} |0^{n}\\rangle\\right) |\\psi\\rangle + \\left|\\delta^{(j)}\\right\\rangle</span>$
(43)</p>

    <p class="text-gray-300">holds. Let us put</p>

    <p class="text-gray-300"><span class="math">$p&#x27; := \\Pr\\left[x \\leftarrow \\left(\\text{measure } Q&#x27;^{j} \\mathcal{A} | 0^{n} \\rangle | \\xi \\rangle\\right) : \\chi(x) = 1\\right]</span>$
(44)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$p := \\Pr\\left[x \\leftarrow \\left(\\text{measure } Q^j \\mathcal{A} | 0^n \\right) : \\chi(x) = 1\\right]. \\tag{45}</span>$</p>

    <p class="text-gray-300">Then, since</p>

    <p class="text-gray-300"><span class="math">$p = \\Pr\\left[x \\leftarrow \\left(\\text{measure } (Q^j \\mathcal{A}|0^n\\rangle)|\\psi\\rangle\\right) : \\chi(x) = 1\\right]</span>$
(46)</p>

    <p class="text-gray-300">holds, we have that</p>

    <p class="text-gray-300"><span class="math">$|p - p&#x27;| \\le \\|(Q^{j} \\mathcal{A} |0^{n}\\rangle)|\\psi\\rangle - {Q&#x27;}^{j} \\mathcal{A} |0^{n}\\rangle|\\psi\\rangle\\|</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\|\\delta^{(j)}\\| \\le 4j\\epsilon, \\tag{47}</span>$</p>

    <p class="text-gray-300">which completes the proof.</p>

    <p class="text-gray-300">Here we complete the proofs for Propositions 2 and 3. Since the number of queries required to make the state  <span class="math">|\\psi_g\\rangle</span>  is obviously cn in the Q2 model and  <span class="math">2^n</span>  in the Q1 model, we give proofs for the statements on the offline computation (i.e., complexities and success probabilities for the procedures excluding the ones to prepare the state  <span class="math">|\\psi_g\\rangle</span> ). Hence it suffices to show the following lemma to prove Propositions 2 and 3.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong> Suppose that m is in  <span class="math">\\mathcal{O}(n)</span> . Let c be a sufficiently large constant,<sup>7</sup> and let  <span class="math">i_0 \\in \\{0,1\\}^m</span>  be the good element such that  <span class="math">g \\oplus f_i</span>  is periodic. Assume that</p>

    <p class="text-gray-300"><span class="math">$\\max_{\\substack{i \\leftarrow \\{0,1\\}^m \\setminus \\{i_0\\} \\\\ t \\in \\{0,1\\}^n \\setminus \\{0^n\\}}} \\Pr_{\\substack{x \\leftarrow \\{0,1\\}^n \\\\ \\{0^n\\}}} [(f_i \\oplus g)(x \\oplus t) = (f_i \\oplus g)(x)] \\le \\frac{1}{2}</span>$
(48)</p>

    <p class="text-gray-300">holds, and the quantum state  <span class="math">|\\psi_g\\rangle</span>  is given. Then, the offline phase of Alg-ExpQ1 and Alg-PolyQ2 finds a good  <span class="math">i \\in \\{0,1\\}^m</span>  with a probability in  <span class="math">\\Theta(1)</span>  by making  <span class="math">\\mathcal{O}\\left(n2^{m/2}\\right)</span>  quantum queries to F. In addition, the offline computation is done in time  <span class="math">O((n^3 + nT_F)2^{m/2})</span> , where is  <span class="math">T_F</span>  the time required to evaluate F once.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">|\\phi_1\\rangle := |i_0\\rangle |\\psi_{f_{i_0}\\oplus g}\\rangle</span>  and  <span class="math">|\\phi_0\\rangle := \\sum_{i\\in\\{0,1\\}^m\\setminus\\{i_0\\}} \\frac{1}{\\sqrt{2^m-1}} |i\\rangle |\\psi_{f_i\\oplus g}\\rangle</span> . Then, by the condition (48) and Lemma 1, we have that</p>

    <p class="text-gray-300"><span class="math">$test|\\phi_1\\rangle = |\\phi_1\\rangle, \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$test|\\phi_0\\rangle = |\\phi_0\\rangle + |\\delta\\rangle,</span>$
(49)</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> Strictly speaking, it is sufficient if c satisfies  <span class="math">4\\lfloor \\pi/4\\theta \\rfloor 2^{(n+1)/2} (3/4)^{cn/2} &lt; 1/2</span> , where  <span class="math">\\theta</span>  is a positive value such that  <span class="math">0 &lt; \\theta &lt; \\pi/2</span>  and  <span class="math">\\sin^2 \\theta = 1/2^m</span> .</p>

    <p class="text-gray-300">where  <span class="math">|\\delta\\rangle</span>  is a vector such that  <span class="math">||\\delta|| &lt; 2^{(n+1)/2}(3/4)^{cn/2}</span> .</p>

    <p class="text-gray-300">Now, the offline phases of Alg-ExpQ1 and Alg-PolyQ2 correspond to the (modified) quantum amplitude amplification of Proposition 7 with  <span class="math">\\mathcal{A}=H^{\\otimes m}, \\widehat{\\mathcal{S}_\\chi^i}=</span>  test,  <span class="math">\\epsilon=2^{(n+1)/2}(3/4)^{cn/2}</span> , and  <span class="math">a=1/2^m</span> . Therefore, by applying the Grover's iteration (i.e., Q')  <span class="math">\\mathcal{O}\\left(2^{m/2}\\right)</span>  times, we can obtain the good index  <span class="math">i_0</span>  with a probability at least  <span class="math">1-2^{-m/2}-O(2^{m/2}2^{(n+1)/2}(3/4)^{cn/2})</span> . Since we are assuming that c is a sufficiently large constant and  <span class="math">m=\\mathcal{O}\\left(n\\right)</span> ,  <span class="math">\\mathcal{O}\\left(2^{m/2}2^{(n+1)/2}(3/4)^{cn/2}\\right)</span>  o(1) holds. Thus we can obtain the good index  <span class="math">i_0</span>  with a probability in  <span class="math">\\Theta(1)</span> .</p>

    <p class="text-gray-300">Since each Grover's iteration (i.e., Q') makes  <span class="math">\\mathcal{O}(cn) = \\mathcal{O}(n)</span>  queries to F, the total number of quantum queries to F is  <span class="math">\\mathcal{O}(n2^{m/2})</span> . In addition, each Grover's iteration runs in time  <span class="math">\\mathcal{O}(n^3 + nT_F)</span>  since computing the dimension of the space spanned by cn can be done in time  <span class="math">\\mathcal{O}(n^3)</span> . Thus the offline phase runs in time  <span class="math">\\mathcal{O}(n^3 + nT_F)2^{m/2}</span> .</p>

    <p class="text-gray-300">Our attack on the FX construction in the Q2 model is non-adaptive since the online queries required to make the state  <span class="math">|\\psi_g\\rangle</span>  is just the uniform superposition of plaintexts. On the other hand, the previous Q2 attack on the construction by Leander and May is adaptive since quantum queries made to keyed online oracles are changed depending on the results for previous quantum queries. For Q1 attacks, both of existing quantum attacks and our attacks are non-adaptive.</p>

    </section>
`;
---

<BaseLayout title="Quantum Attacks without Superposition Queries: the Offline S... (2019/614)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/614
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The Quantum Circuit Model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Simon&#x27;s Algorithm</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Grover&#x27;s Algorithm</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Simon&#x27;s Algorithm with Asymmetric Queries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Existing Techniques to Solve the Problem</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">An Algorithm for Asymmetric Search of a Shift</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Asymmetric Search with Q1 Queries</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Q2 Attacks on Symmetric Schemes with Reduced Query Complexity</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">An Attack on the FX construction</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Q1 Attacks on Symmetric Schemes</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Tradeoffs for the Even-Mansour Construction</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Tradeoffs for the FX Construction</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Other Applications</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Discussion</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Related Keys</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Slide Attacks</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Proofs for Propositions 2 and 3</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Error Analyses for the testing procedure test</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Error Propagation Analyses for QAA</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Finishing the Proofs</a></li>
          </ol>
        </li>
        <li><a href="#app-b" class="hover:text-white">Adaptive Attacks and Non-Adaptive Attacks</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="quantum-attacks-without-superposition-queries-the-offline-2019" />
  </article>
</BaseLayout>
