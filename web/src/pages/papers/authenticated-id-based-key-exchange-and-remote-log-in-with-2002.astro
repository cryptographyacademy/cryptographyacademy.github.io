---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2002/164';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Authenticated ID-based Key Exchange and remote log-in with simple token and PIN number';
const AUTHORS_HTML = 'Mike Scott';

const CONTENT = `    <p class="text-gray-300">Michael Scott</p>

    <p class="text-gray-300">School of Computer Applications Dublin City University Ballymun, Dublin 9, Ireland. mike@computing.dcu.ie</p>

    <p class="text-gray-300">Abstract. Authenticated key exchange protocols tend to be either token based or password based. Token based schemes are often based on expensive (and irreplaceable) smart-card tokens, while password-only schemes require that a unique password is shared between every pair of correspondents. The magnetic strip swipe card and associated PIN number is a familiar and convenient format that motivates a combined "two-factor" approach. Finally we suggest an extension of the scheme for use in a client-server scenario.</p>

    <p class="text-gray-300">Keywords: Authenticated key exchange, pairing-based cryptosystems.</p>

    <p class="text-gray-300">Consider a small group of people who wish to communicate in private. It is inconvenient for them all to meet, so their point of commonality is access to a Trusted Authority (TA). These people expect to be able to trust one another – why else would they want to communicate in secret?</p>

    <p class="text-gray-300">The trusted authority issues to each member of the group an individual secret number associated with their identity. Each member then "splits" this number into a small user-selected PIN number, and a larger number which is stored in the hardware token. The individual secret can be reconstructed from these two components whenever it is required in the key-exchange protocol. The hardware token is in some convenient form-factor, but can easily be copied (which is convenient as it allows backup copies to be created).</p>

    <p class="text-gray-300">To communicate, each inserts their own token into a computer, types in their memorised PIN number and the identity of their correspondent. The individual secret is reconstructed, an ephemeral session key is calculated and the pair communicate in privacy.</p>

    <p class="text-gray-300">Note that each participants PIN is a secret unto themselves alone. This therefore differs from schemes like SPEKE [11], where a different low entropy secret must be shared between every pair of users, which could lead to a multiplicity of PINs to be remembered.</p>

    <p class="text-gray-300">Such a scheme as we propose is clearly open to the following active “insider” attack. Bob steals or copies Alice’s token, takes it home and carries out multiple off-line key exchange calculations trying every possible number for Alice’s PIN. Eventually he will find it.</p>

    <p class="text-gray-300">The scheme as proposed is also vulnerable to identity theft. If Trent should rob Bob’s token and rubber-hose his password, then Trent can become Bob at will, and can launch “insider” attacks. While we can assume that a token can be secretly copied, it can also be assumed that PIN theft cannot be carried out without the knowledge of the legitimate PIN-holder. However the scheme should be able to withstand an outsider stealing or copying any number of tokens and/or any number of passwords as long as none of the “stolen” passwords is associated with any of the stolen tokens. This seems to be the best that can be expected from such a scheme.</p>

    <p class="text-gray-300">We recognise that, in common with schemes like SPEKE, ours is vulnerable to an entity Trent who steals or copies a token, and is allowed to attempt multiple on-line guesses of the associated PIN while attempting to form a connection with legitimate users. It is assumed that suitable measures would be put in place to detect multiple failed connections from a purported individual, and to subsequently exclude him or her. We recognise however that in this context such guessing attacks could be “spread around” and tried against many legitimate individuals. For this reason the PIN number might be say 8 digits in length, rather than the more common 4-digits.</p>

    <p class="text-gray-300">Finally we would like our scheme to have the property of “forward secrecy”. If at some time time in the future all long-term secrets are revealed, including those of the trusted authority, previously recorded ciphertext should remain inviolable.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 The proposed scheme</h2>

    <p class="text-gray-300">The key exchange algorithm reconstructs the individual secret from the large number stored on the hardware token and the PIN. It is important that a correct individual secret cannot be detected from its format – it is just a number, and any number is possible. Essentially the relationship is linear and of the form <span class="math">D=N+PIN</span>, where <span class="math">D</span> is the individual secret, and <span class="math">N</span> is the number on the token.</p>

    <p class="text-gray-300">In our proposed scheme the trusted authority knows a master secret number <span class="math">s</span>. User identities are mapped using a suitable hash function to points on a particular elliptic curve. The user Alice has her identity hashed and mapped to a point <span class="math">A</span> of large prime order on the curve, and chooses a desired PIN number <span class="math">\\alpha</span>. After authenticating herself to the trusted authority she receives <span class="math">A</span> and <span class="math">sA</span>, calculates <span class="math">\\alpha A</span>, subtracts the two, stores <span class="math">A</span> and <span class="math">(s-\\alpha)A</span>, and memorises <span class="math">\\alpha</span>. As in a simple secret sharing scheme these two halves need to be reunited to reconstruct the correct value <span class="math">sA</span>. Clearly Alice cannot determine <span class="math">s</span> without solving a difficult discrete logarithm problem. We have the simple linear relationship <span class="math">sA=(s-\\alpha)A+\\alpha A</span>.</p>

    <p class="text-gray-300">Note that if an increment is added to <span class="math">\\alpha</span>, the effect can be offset by incrementing <span class="math">s</span> by the same amount. So for example if <span class="math">\\alpha</span> is incremented by <span class="math">\\delta</span>, the relationship <span class="math">(s+\\delta)A=(s-\\alpha)A+(\\alpha+\\delta)A</span> holds. This implies that if two or more correspondents increment their PINs by the same amount, they can still complete the key agreement process, although this time the key will be a function of <span class="math">(s+\\delta)</span>. This in turn implies that an opponent who has stolen multiple tokens cannot determine individual PINs – he cannot distinguish the effect of <span class="math">(\\alpha+\\delta)</span> from <span class="math">\\alpha</span>. So he can determine the difference between PINs, but not actual PINs, which is useless if he should attempt to communicate with a legitimate party.</p>

    <p class="text-gray-300">First let us consider the implementation of such a protocol using standard public key cryptographic constructions. One common approach is for a trusted centre to digitally “sign” our identity <em>[9]</em>, <em>[16]</em>. This secret signature (our <em>individual secret</em>) is subsequently used in the key exchange. Unless each correspondent’s signature is valid, a mutual session key cannot be negotiated. The trusted authorities public key is cleverly integrated into the key exchange to ensure that this is true.</p>

    <p class="text-gray-300">Now if every participant is to have their own PIN number, then it would appear that this PIN must also be generated by the signing process. A simple approach would be to remove part of the signature for use as a PIN. Unless the removed part were “put back in” the exchange could not take place successfully. However this will not satisfy our security requirement. An attacker who captures a token can exhaustively search through all possible PINs until the complete signature can be verified by the TA’s public key.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 The Tate pairing</h2>

    <p class="text-gray-300">The Weil and Tate pairings are operations on pairs of points on an elliptic curve. See <em>[14]</em> for some early applications, specifically in breaking elliptic curve based cryptosystems based on certain weak curves, by reducing the ECDLP problem to a DLP problem over an extension of the base field. More recently these pairings have been found to have applications for “good”. For example Joux’s clever tripartite Diffie-Hellman key exchange <em>[12]</em>, Boneh and Franklin’s ID-based encryption scheme <em>[4]</em>, and the BLS short signature scheme <em>[5]</em>.</p>

    <p class="text-gray-300">The Tate pairing <em>[8]</em> is written as <span class="math">e_{r}(P,Q)</span>, where <span class="math">P</span> and <span class="math">Q</span> are both points on a curve defined over <span class="math">\\mathbb{F}_{p^{k}}</span>, and <span class="math">P</span> is of order <span class="math">r</span>. Note however that there is no requirement for <span class="math">Q</span> to be of order <span class="math">r</span> <em>[17]</em>. The Tate pairing evaluates as an element of order <span class="math">r</span> in the field <span class="math">\\mathbb{F}_{p^{k}}</span>. In a normal EC setting it is quite unexciting; if <span class="math">P</span> and <span class="math">Q</span> are linearly dependent, that is if the curve group structure is cyclic, it evaluates as <span class="math">1</span>. The trick is to use points on <span class="math">P</span> and <span class="math">Q</span> which lie in different subgroups, so that <span class="math">P\\neq sQ</span> for any value of <span class="math">s</span>. This can only happen on a curve with a non-cyclic group structure. This behaviour is possible, and convenient, if <span class="math">r\\mid p^{k}-1</span> and <span class="math">k</span> is small. But note that the elliptic curve discrete logarithm problem on a curve with a small <span class="math">k</span> value is readily reduced to a discrete logarithm</p>

    <p class="text-gray-300">problem in the field <span class="math">\\mathbb{F}_{p^{k}}</span>, and so parameter sizes must be adjusted upwards to take account of this.</p>

    <p class="text-gray-300">These rather restrictive conditions are met by certain non-supersingular curves. In practise it is not difficult to find non-supersingular curves with moderate values of <span class="math">k</span>, for example the MNT curves described in <em>[15]</em>, or using the methods described in <em>[1]</em>, <em>[3]</em>, <em>[6]</em>, or <em>[19]</em>. If <span class="math">k&gt;1</span> (which we will assume here) a convenient way to make sure that <span class="math">P</span> and <span class="math">Q</span> are in seperate subgroups is to ensure that <span class="math">P</span>’s coordinates are in <span class="math">\\mathbb{F}_{p}</span> while <span class="math">Q</span>’s coordinates are in <span class="math">\\mathbb{F}_{p^{k}}</span>. In fact as pointed out in <em>[2]</em> when <span class="math">k</span> is even <span class="math">Q</span> can be conveniently placed on the “twisted” curve over <span class="math">\\mathbb{F}_{p^{k/2}}</span>. This also speeds up the calculation <em>[17]</em>.</p>

    <p class="text-gray-300">The Tate pairing has the following useful properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e_{r}(aP,bQ)=e_{r}(P,Q)^{ab}</span> for all <span class="math">a,b\\in\\mathbb{F}_{r}</span> (Bilinearity)</li>

      <li><span class="math">e_{r}(P,P)=1</span></li>

    </ol>

    <p class="text-gray-300">A modified pairing works well with supersingular curves, for which <span class="math">k</span> is always guaranteed to be small, and this is the case we will look at first.</p>

    <p class="text-gray-300">Consider the following supersingular elliptic curve over the field <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p\\equiv 3\\bmod 4</span> is a 512-bit prime:</p>

    <p class="text-gray-300"><span class="math">E(\\mathbb{F}_{p}):y^{2}=x^{3}+x</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The order of this supersingular curve is <span class="math">q+1</span>, and <span class="math">k=2</span> as $r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ p+1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ p^{2}-1<span class="math">. The discrete logarithm problem on this curve can be reduced to a discrete logarithm problem in the field </span>\\mathbb{F}_{p^{2}}$, but this is still considered intractable for a prime of the specified size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On this supersingular curve, using the terminology of Verheul <em>[20]</em>, we can define a distortion map <span class="math">\\phi:E(\\mathbb{F}_{p})\\to E(\\mathbb{F}_{p^{2}})</span> which maps a point <span class="math">(x,y)</span> to the point <span class="math">(-x,iy)</span> in a different subgroup, where <span class="math">i^{2}=-1</span>. Note that the condition <span class="math">p\\equiv 3\\bmod 4</span> implies that <span class="math">i</span> lies not in <span class="math">\\mathbb{F}_{p}</span>, but rather in the quadratic extension field, so the transformed point lies on the same curve defined over <span class="math">\\mathbb{F}_{p^{2}}</span>.</p>

    <p class="text-gray-300">Now consider the distorted Tate pairing:</p>

    <p class="text-gray-300"><span class="math">\\hat{e}_{r}(P,Q)=e_{r}(P,\\phi(Q))=\\mu</span></p>

    <p class="text-gray-300">where <span class="math">P</span> (of order <span class="math">r</span>) and <span class="math">Q</span> are points on the curve, <span class="math">\\mu\\in\\mathbb{F}_{p^{2}}</span> is of order <span class="math">r</span>, and <span class="math">e_{r}(P,Q)</span> is the Tate pairing <em>[8]</em>. Under these circumstances the distorted Tate pairing will produce a non-trivial result (<span class="math">\\hat{e}_{r}(P,Q)\\neq 1</span>). This pairing has the following proper</p>

    <p class="text-gray-300">The trusted authority generates a 512-bit prime  <span class="math">p \\equiv 3 \\mod 4</span>  such that  <span class="math">p + 1 = c.r</span> , where  <span class="math">r</span>  is a 160-bit prime, and chooses a suitable hash function  <span class="math">H: \\{0,1\\}^* \\to E(\\mathbb{F}_p)</span>  which hashes identity strings to a point on the supersingular curve. It publishes the public parameters  <span class="math">\\{p,r,H\\}</span> . The trusted authority then generates its own secret 160-bit number  <span class="math">s \\in \\mathbb{F}_r</span> .</p>

    <p class="text-gray-300">For individuals to register with the trusted authority they must prove their identity ID. In return they are supplied with  <span class="math">I</span>  and their individual secret  <span class="math">sI</span>  where  <span class="math">I = c.H(ID)</span> , a point of order  <span class="math">r</span>  on the curve. They store on their hardware token  <span class="math">I</span>  and  <span class="math">(s - \\rho)I</span> , where  <span class="math">\\rho</span>  is their personal choice of PIN number.</p>

    <p class="text-gray-300">The protocol is illustrated in Table 1. To a passive eavesdropper this appears very like an instance of the Diffie-Hellman key exchange in  <span class="math">\\mathbb{F}_{p^2}</span> . It would also appear that anyone not knowing, and not able to construct from available information,  <span class="math">\\hat{e}_r(A,B)^s</span>  or equivalently  <span class="math">sA</span>  or  <span class="math">sB</span> , is not in a position to launch a classical man-in-the-middle attack against it. Another way of looking at it is as a SPEKE-like key exchange, where the group generator is only known to the two legitimate participants. This is an established technique in the process of standardisation [10], and no active attacks are known against it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alice</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bob</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Generates random a < r</td>

            <td class="px-3 py-2 border-b border-gray-700">Generates random b < r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">IDa →</td>

            <td class="px-3 py-2 border-b border-gray-700">← IDb</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B = H(IDb)</td>

            <td class="px-3 py-2 border-b border-gray-700">A = H(IDa)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pa =帽子((s - α)A + αA, B)a</td>

            <td class="px-3 py-2 border-b border-gray-700">Pb =帽子((s - β)B + βB, A)b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pa →</td>

            <td class="px-3 py-2 border-b border-gray-700">← Pb</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">If Pb ≤ 1 or Pa^r ≠ 1 Abort</td>

            <td class="px-3 py-2 border-b border-gray-700">If Pa ≤ 1 or Pa^r ≠ 1 Abort</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key = Pb^a =帽子(A, B)^{sab}</td>

            <td class="px-3 py-2 border-b border-gray-700">Key = Pa^b =帽子(B, A)^{sab}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that the fact that Alice can easily obtain Bob's password if she has a copy of his token can be blamed on the relationship  <span class="math">\\hat{e}_r(sA,B) = \\hat{e}_r(A,sB)\\neq 1</span> , which is clearly required by the protocol. As pointed out before it is now a simple matter to search among  <span class="math">\\delta</span>  until  <span class="math">\\hat{e}_r(sA,B) = \\hat{e}_r((s - \\beta)B + \\delta B,A)</span> , in which case  <span class="math">\\delta = \\beta</span> . The underlying reason that this is possible is due to the fact that the Decisional Diffie-Hellman (DDH) problem is easy in this setting [4], and hence we can distinguish the action of a "right" password guess from a wrong one.</p>

    <p class="text-gray-300">The fact that  <span class="math">\\hat{e}_r(sA,B)\\neq 1</span>  depends directly on the property  <span class="math">\\hat{e}_r(P,P)\\neq 1</span> . Since  <span class="math">A</span>  and  <span class="math">B</span>  are members of the same subgroup, we know that  <span class="math">A = uP</span>  and  <span class="math">B = vP</span>  for some  <span class="math">u,v</span>  and  <span class="math">P</span> . Therefore  <span class="math">\\hat{e}_r(sA,B) = \\hat{e}_r(suP,vP) = \\hat{e}_r(P,P)^{suv}</span> .</p>

    <p class="text-gray-300">First we demonstrate that anyone who can determine the key from publicly transmitted information is in a position to solve an instance of the Bilinear Diffie-</p>

    <p class="text-gray-300">Hellman problem (BDH) <em>[4]</em>, which is believed to be hard. The BDH problem can be described succintly thus: Given <span class="math">\\{P,sP,aP,bP\\}</span>, determine <span class="math">\\hat{e}_{r}(P,P)^{sab}</span>.</p>

    <p class="text-gray-300">Assume an Oracle exists which when input the exchanged public data <span class="math">\\{A,B,P_{a}=\\hat{e}_{r}(sA,aB),P_{b}=\\hat{e}_{r}(bA,sB)\\}</span> outputs the key <span class="math">\\hat{e}_{r}(A,B)^{sab}</span>.</p>

    <p class="text-gray-300">Now we will demonstrate how this oracle can be used to solve an instance of the BDH problem. Generate a random <span class="math">u</span> and present to the Oracle <span class="math">\\{P,uP,\\hat{e}_{r}(sP,u(aP)),\\hat{e}_{r}(bP,u(sP))\\}</span> which is the same as <span class="math">\\{P,uP,\\hat{e}_{r}(sP,a(uP)),\\hat{e}_{r}(bP,s(uP))\\}</span>. The oracle will respond with <span class="math">\\hat{e}_{r}(P,uP)^{sab}=\\hat{e}_{r}(P,P)^{sabu}</span>. We recover <span class="math">\\hat{e}_{r}(P,P)^{sab}</span> by raising the output of the Oracle to the power of <span class="math">1/u</span>.</p>

    <p class="text-gray-300">Note that the inverse is not necessarily true: It cannot be concluded that a passive eavesdropper could use a BDH oracle to discover the key. This is because, although <span class="math">A</span> and <span class="math">B</span> are from the same subgroup, and therefore <span class="math">A=xB</span> for some value of <span class="math">x</span>, this <span class="math">x</span> value will not be known due to the action of the hash function.</p>

    <p class="text-gray-300">However a third group member who can solve BDH, can easily break the authentication of the scheme, as pointed out by Michael Cheng <em>[7]</em>. Imagine a third member <span class="math">X</span> of the group has <span class="math">X</span> and <span class="math">sX</span>. Now <span class="math">A=wX</span> for some <span class="math">w</span> and <span class="math">B=zX</span> for some <span class="math">z</span>, so if <span class="math">X</span> can solve BDH with input <span class="math">\\{X,sX,wX,zX\\}</span> then he can find <span class="math">\\hat{e}_{r}(X,X)^{swz}=\\hat{e}_{r}(wX,zX)^{s}=\\hat{e}_{r}(sA,B)</span>.</p>

    <p class="text-gray-300">The inverse is also true – an oracle that can determine <span class="math">\\hat{e}_{r}(sA,B)</span> from <span class="math">\\{X,sX,A,B\\}</span> can be used to solve an instance of BDH: Supply as input <span class="math">\\{P,sP,aP,bP\\}</span> amd the output will be <span class="math">\\hat{e}_{r}(P,P)^{sab}</span>.</p>

    <p class="text-gray-300">The sixth step of the protocol checks the order of the value received from the other party. This is to avoid a small subgroup confinement attack, whereby an active attacker substitutes a value of small order. Such a value when exponentiated remains in the same small subgroup, and can be found by a short exhaustive search through all the possible subgroup members. This is a well-known attack on Diffie-Hellman-like protocols, and the standard response is to check, as shown above, that the received value is indeed in the subgroup of order <span class="math">r</span>. However the extra work involved can be avoided by using the technique of Lim-Lee <em>[13]</em>. The idea is simple – ensure that there are no small subgroups, and if there are (for example there may be an unavoidable subgroup of order <span class="math">2</span>), then explicitly check for such cases. This places an extra constraint on parameter generation, however in practise this is not a problem. It is however necessary that the idea, originally described in the <span class="math">\\mathbb{F}_{p}</span> setting be adapted for the field <span class="math">\\mathbb{F}_{p^{2}}</span> which has <span class="math">p^{2}-1</span> elements. Briefly, ensure by design that the modulus <span class="math">p</span> is of the form such that <span class="math">p+1=2rq</span>, where <span class="math">q</span> is also prime. Then process a received value as follows: Raise it to the power of <span class="math">p-1</span> using the frobenius action – this requires a single modular division <em>[17]</em> – and then square it. The resulting value will either be <span class="math">1</span>, in which case the protocol should be aborted, or it will be a point of large order, whose order divides <span class="math">r.q</span>.</p>

    <p class="text-gray-300">Finally we maintain that this protocol has the property of forward secrecy. The ephemeral values <span class="math">a</span> and <span class="math">b</span> are discarded after use, and without them the agreed key cannot be determined in the future by anyone.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 A Client-Server Protocol</p>

    <p class="text-gray-300">In a client-server context multiple clients are assumed to wish to access an individual server. In this context the security requirements are rather different. Although the server may trust each client individually, it is not at all clear that clients may trust one-another. Therefore in this context it is important that the “insider” attacks cannot succeed, that is if Alice obtains Bob’s token, she cannot determine his password.</p>

    <p class="text-gray-300">The idea is to eliminate this attack by exploiting the fact that clients only need to communicate with servers, not with one-another. This is acheived by putting all the clients together in one sub-group, with the server in another. We want a setting where there is no bilinear pairing between points in the same subgroup that yields a non-trivial result. This implies a setting where the conventional Tate pairing satisfies <span class="math">e_{r}(P,P)=1</span> and where no distortion map exists. This will be the case for non-supersingular curves where <span class="math">k&gt;1</span>. See <em>[8]</em> section 2.4.</p>

    <p class="text-gray-300">The first step then is to find a non-supersingular curve with low, even <span class="math">k</span> value (say <span class="math">k=2</span>), and for which no distortion map exists. A suitable example <span class="math">k=2</span> curve is given in <em>[17]</em>, and it is our experience that it is not difficult to find such curves, using for example the “folklore” method described in <em>[3]</em>. Such curves do not support a distortion map – see theorem 4.1 of <em>[20]</em>.</p>

    <p class="text-gray-300">Assume for simplicity that the server takes on itself the role of Trusted Authority. It generates a <span class="math">k=2</span> non-supersingular curve over <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p</span> is 512-bits, such that the curve order is <span class="math">c.r</span> and is divisible by the 160-bit prime <span class="math">r</span>. It also generates its own secret <span class="math">s\\in\\mathbb{F}_{r}</span>. It is assumed that the server does not require a password. If the server’s identity is <span class="math">ID_{s}</span>, then this is mapped to a point <span class="math">S</span> on the same curve, but this time over the extension field <span class="math">\\mathbb{F}_{p^{2}}</span>, using a second hash function <span class="math">H_{2}:\\{0,1\\}^{*}\\rightarrow E(\\mathbb{F}_{p^{2}})</span>, such that <span class="math">S=H_{2}(ID_{s})</span>. So <span class="math">S</span> is a point on the curve <span class="math">E(\\mathbb{F}_{p^{2}})</span>. The server issues the curve parameters and the <span class="math">H_{2}</span> hash function.</p>

    <p class="text-gray-300">Alice registers with the server exactly as before and is issued with <span class="math">A</span> and an individual secret of the form <span class="math">sA</span>, where <span class="math">A=c.H(ID_{a})</span> is a point of order <span class="math">r</span> on the base elliptic curve <span class="math">E(\\mathbb{F}_{p})</span>. As before she partitions her individual secret up between the hardware token, and a short memorised PIN. Note that here we use the unmodified Tate pairing.</p>

    <p class="text-gray-300">To log-in, Alice executes the following protocol.</p>

    <p class="text-gray-300">Alice</p>

    <p class="text-gray-300">Generates random <span class="math">a&lt;r</span></p>

    <p class="text-gray-300"><span class="math">ID_{a}\\rightarrow</span></p>

    <p class="text-gray-300"><span class="math">S=H_{2}(ID_{s})</span></p>

    <p class="text-gray-300"><span class="math">P_{a}=e_{r}((s-\\alpha)A+\\alpha A,S)^{a}</span></p>

    <p class="text-gray-300"><span class="math">P_{a}\\rightarrow</span></p>

    <p class="text-gray-300">If <span class="math">P_{s}\\leq 1</span> or <span class="math">P_{s}^{\\ r}\\neq 1</span> Abort</p>

    <p class="text-gray-300"><span class="math">\\text{Key}=P_{s}^{\\ a}=e_{r}(A,S)^{sax}</span></p>

    <p class="text-gray-300">Server</p>

    <p class="text-gray-300">Generates random <span class="math">x&lt;r</span></p>

    <p class="text-gray-300"><span class="math">\\leftarrow ID_{s}</span></p>

    <p class="text-gray-300"><span class="math">A=c.H(ID_{a})</span></p>

    <p class="text-gray-300"><span class="math">P_{s}=e_{r}(A,sS)^{x}</span></p>

    <p class="text-gray-300"><span class="math">\\leftarrow P_{s}</span></p>

    <p class="text-gray-300">If <span class="math">P_{a}\\leq 1</span> or <span class="math">P_{a}^{\\ r}\\neq 1</span> Abort</p>

    <p class="text-gray-300"><span class="math">\\text{Key}=P_{a}^{\\ x}=e_{r}(A,S)^{sax}</span></p>

    <p class="text-gray-300">Re</p>

    <p class="text-gray-300">In this case the insider attack does not work, as for example between Alice and Bob <span class="math">e_{r}(A,B)=1</span>. Note that there is a co-DDH problem which is easy to solve in this setting, but the standard DDH problem remains hard.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">5.1 Security Analysis</h3>

    <p class="text-gray-300">Assume now that an oracle exists which when input the exchanged public data <span class="math">\\{A,S,P_{a}=e_{r}(sA,aS),P_{b}=e_{r}(bA,sS)\\}</span> outputs the agreed key. Then such an oracle can be used to solve an instance of the co-bilinear Diffie-Hellman (co-BDH) problem <em>[4]</em>, which is also believed to be hard. The co-BDH assumption is that given <span class="math">\\{P,sP,aP,Q,sQ,bQ\\}</span> it is hard to calculate <span class="math">e_{r}(P,Q)^{sab}</span>. Input <span class="math">\\{P,Q,e_{r}(sP,bQ),e_{r}(aP,sQ)\\}</span> to our oracle and it will respond with <span class="math">e_{r}(P,Q)^{sab}</span>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">6 Implementational issues</h2>

    <p class="text-gray-300">In both protocols we have made careful use of the observation from <em>[17]</em> that the second parameter to the Tate pairing does not have to be of order <span class="math">r</span>. This leads to considerable savings, as co-factor point multiplication (by <span class="math">c</span>) can be very expensive. In the key exchange protocol no co-factor multiplication is required. For the client-server protocol, the server is required to perform one co-factor multiplication. However the calculation on the client side remains relatively light-weight.</p>

    <p class="text-gray-300">Both protocols can also profit by compressing the pairing output <em>[18]</em>. For the case of <span class="math">k=2</span> as suggested here, the pairing value can be compressed to one-half of its normal length – a single <span class="math">\\mathbb{F}_{p}</span> value suffices instead of a full element of <span class="math">\\mathbb{F}_{p^{2}}</span>. See <em>[18]</em> for details. This has immediate and obvious bandwidth benefits. It also makes the pairing calculation a little faster <em>[17]</em>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">7 Conclusions</h2>

    <p class="text-gray-300">Most pairing-based protocols work equally well over both supersingular and non-supersingular curves, for example Boneh and Franklin IBE <em>[4]</em>. Here we demonstrate for the first time that the differences between the two types of pairing can be exploited to create protocols with quite different properties. This in turn can be directly related to the difficulty (or non-difficulty) of solving the DDH problem.</p>

    <p class="text-gray-300">The client-server protocol in particular may find useful application. The user password is remembered by the client and no vulnerable password file is stored on the server. The server’s master key <span class="math">s</span> is only needed for client registration purposes. For day-to-day use the server only needs access to <span class="math">sS</span>.</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] P. S. L. M. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In Security in Communication Networks – SCN’2002,</li>

    </ul>

    <p class="text-gray-300">volume 2576 of Lecture Notes in Computer Science, pages 263–273. Springer-Verlag, 2002.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] Paulo S. L. M. Barreto, B. Lynn, and M. Scott. On the selection of pairing-friendly groups. In Selected Areas in Cryptography – SAC’2003, volume 3006 of Lecture Notes in Computer Science, pages 17–25, Ottawa, Canada, 2003. Springer-Verlag.</li>

      <li>[3] I. Blake, G. Seroussi, and N. Smart. Advances in Elliptic Curve Cryptography, volume 2. Cambridge University Press, 2005.</li>

      <li>[4] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. SIAM Journal of Computing, 32(3):586–615, 2003.</li>

      <li>[5] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Advances in Cryptology – Asiacrypt’2001, volume 2248 of Lecture Notes in Computer Science, pages 514–532. Springer-Verlag, 2002.</li>

      <li>[6] F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Cryptology ePrint Archive, Report 2003/143, 2003. Available from http://eprint.iacr.org/2003/143.</li>

      <li>[7] Michael Cheng. Personal communication, 2004.</li>

      <li>[8] S. Galbraith. Supersingular curves in cryptography. In Advances in Cryptology – Asiacrypt’2001, volume 2248 of Lecture Notes in Computer Science, pages 495–513. Springer-Verlag, 2002.</li>

      <li>[9] Christoph G. Günther. An identity-based key-exchange protocol. In EUROCRYPT ’89, volume 434 of Lecture Notes in Computer Science, pages 29–37, 1990.</li>

      <li>[10] IEEE Computer Society, New York, USA. IEEE Standard Specifications for Password-Based Public-Key Cryptographic Techniques, 2003.</li>

      <li>[11] D. Jablon. Strong password-only authenticated key exchange. Computer Communication Review, ACM SIGCOMM, 26:5–26, 1996.</li>

      <li>[12] A. Joux. A one-round protocol for tripartite Diffie-Hellman. In Algorithm Number Theory Symposium – ANTS IV, volume 1838 of Lecture Notes in Computer Science, pages 385–394. Springer-Verlag, 2000.</li>

      <li>[13] C.H. Lim and P.J. Lee. A key recovery attack on discrete log-based schemes using a prime order subgroup. In Advances in Cryptology – Crypto ’97, volume 1294 of Lecture Notes in Computer Science, pages 249–263. Springer-Verlag, 1997.</li>

      <li>[14] A. Menezes. Elliptic Curve Public Key Cryptosystems. Kluwer Academic Publishers, 1993.</li>

      <li>[15] A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces for FR-reduction. IEICE Transactions on Fundamentals, E84-A(5):1234–1243, 2001.</li>

      <li>[16] E. Okamoto. Proposal for identity-based key distribution systems. Electronic Letters, 22:1283–1284, 1986.</li>

      <li>[17] M. Scott. Computing the Tate pairing. To be presented Cryptographers Track RSA conference February 2005.</li>

      <li>[18] M. Scott and P. Barreto. Compressed pairings. In Advances in Cryptology – Crypto 2004, volume 3152 of Lecture Notes in Computer Science, pages 140–156. Springer-Verlag, 2004.</li>

      <li>[19] M. Scott and P. Barreto. Generating more mnt elliptic curves. Cryptology ePrint Archive, Report 2004/058, 2004. http://eprint.iacr.org/2004/058.</li>

      <li>[20] E. Verheul. Evidence that xtr is more secure than super-singular elliptic curve cryptosystems. In EUROCRYPT 2002, volume 2045 of Lecture Notes in Computer Science, pages 195–210. Springer-Verlag, 2001.</li>

    </ul>`;
---

<BaseLayout title="Authenticated ID-based Key Exchange and remote log-in with s... (2002/164)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2002 &middot; eprint 2002/164
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
