---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1106';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'ProtoGalaxy:  Efficient ProtoStar-style folding of multiple instances';
const AUTHORS_HTML = 'Liam Eagen, Ariel Gabizon';

const CONTENT = `    <p class="text-gray-300">PROTOGALAXY: Efficient PROTOSTAR-style folding of multiple instances</p>

    <p class="text-gray-300">Liam Eagen<span class="math">^{1,2}</span> and Ariel Gabizon<span class="math">^{1}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span>Zeta Function Technologies <span class="math">^{2}</span>Blockstream Research</p>

    <p class="text-gray-300">January 29, 2024</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We continue the recent line of work on folding schemes. Building on ideas from PROTOSTAR [BC23] we construct a folding scheme where the recursive verifier's "marginal work", beyond linearly combining witness commitments, consists only of a logarithmic number of field operations and a constant number of hashes. Moreover, our folding scheme performs well when folding multiple instances at one step, in which case the marginal number of verifier field operations per instance becomes constant, assuming constant degree gates.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In the last two years, we have seen an explosion of interest in so-called folding<span class="math">^{1}</span> schemes [BCMS20, BCL<span class="math">^{+}</span>21, KST21, Moh, KS22, KS23, BC23]. Roughly speaking, a folding scheme "folds" several instances of a relation into one instance in a way that the correctness of this one instance implies the correctness of all original instances.</p>

    <p class="text-gray-300">The original motivation for folding schemes was improving the efficiency of incrementally verifiable computation[Val08] and proof carrying data [CT10].</p>

    <p class="text-gray-300">A related motivation is improving SNARK prover time when proving correctness of multiple instances of a relation: Given instances <span class="math">\\phi_1, \\ldots, \\phi_m</span>, rather than computing a SNARK proof <span class="math">\\Pi_i</span> for each one, we fold<span class="math">^{2}</span> them into a single instance <span class="math">\\phi^*</span> for which produce a single SNARK proof <span class="math">\\Pi</span>. If the computation required per instance <span class="math">\\phi_i</span> to show folding was done correctly is significantly smaller than that for producing the SNARK proof <span class="math">\\Pi_i</span>, the</p>

    <p class="text-gray-300">1 The term accumulation schemes [BCMS20, BCL<span class="math">^{+}</span>21] was introduced first for the same primitive. We alternate between the folding and accumulation terminologies.</p>

    <p class="text-gray-300">2To apply folding correctly in this usecase requires some additional work to make sure we have indeed folded the instances we are interested in; for example, computing a running hash of the instances during folding, and comparing it to a running hash independently computed by the final verifier.</p>

    <p class="text-gray-300">overall prover work will be smaller even after computing the proof for <span class="math">\\phi^{<em>}</span>. Alternatively, in the IVC context it is often recommended to simply use the witness for <span class="math">\\phi^{</em>}</span> as the final proof; then, at the expense of a longer proof, no SNARK is needed at all.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Single-instance vs Multi-instance folding</h3>

    <p class="text-gray-300">Protogalaxy focuses on <em><span class="math">k</span>-folding</em> - folding <span class="math">k</span> instances in one folding operation; which was also addressed in <em>[BCL^{+}21, x16]</em>. The benefit of <span class="math">k</span>-folding is giving a wider set of tradeoffs between folding and final decision costs, as well as reducing their combined cost.</p>

    <p class="text-gray-300">Generally, the goal of folding schemes has been to simplify the verifier as much as possible and move as much computation as possible out of the verifier and prover and into the decider. This is a sensible assumption when a folding scheme is used to instantiate a long running IVC protocol, but limits applicability in other cases where the decider must be run frequently. For example, consider a decentralized computation where multiple parties perform computations in a directed graph, as in PCD. If the parties do not trust one another, each will need to run the decider on their input accumulators they receive before folding new instances. Since each party will run both the prover and the decider, moving computation from the prover to the decider does not reduce the overall complexity of the protocol. This situation may be of particular interest for decentralized cryptocurrencies, where a large group of mutually distrusting actors are simultaneously manipulating a shared state.</p>

    <p class="text-gray-300">When folding multiple instances, we can take any combination of the following three approaches.</p>

    <p class="text-gray-300">First, the prover can simply fold the function <span class="math">F(X)</span> and the folding verifier sequentially <span class="math">k</span> times. This does not increase decider complexity, compared to folding once, but increases the prover complexity by <span class="math">k</span> times the cost of proving the verifier, dominated by (in Protostar) <span class="math">O(1)</span> elliptic curve scalar multiplications and hash functions per verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, the prover can fold the <span class="math">k</span> composition of <span class="math">F(X)</span>, <span class="math">G(X)=F(F(\\ldots F(X)\\ldots)</span> a single time. This keeps the recursion overhead small, but increases the decider complexity linearly in <span class="math">k</span> times the complexity of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, the prover can use a <span class="math">k</span>-folding scheme like Protogalaxy. This allows keeping the decider complexity corresponding to a <em>single application</em> of <span class="math">F</span>. Moreover, when a single party performs <em>both</em> the folding and deciding this can still result in smaller overall work. One reason for this is that when comparing to the second approach, <span class="math">k</span>-folding requires an in circuit <span class="math">k</span>-size MSM to combine instances, which due to Pippenger can be significantly faster than <span class="math">k</span> separate scalar multiplications required in the second approach.</p>

    <p class="text-gray-300">All three can be combined to find the optimal configuration for a particular <span class="math">F</span>, i.e. a prover can fold <span class="math">a</span> instances of the <span class="math">b</span> fold composition of <span class="math">F</span> sequentially <span class="math">c</span> times where <span class="math">k=abc</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">1.2 Previous work on folding schemes and our results</p>

    <p class="text-gray-300">All known folding schemes rely on additively homomorphic vector commitments, and the following template: We assume the folding verifier is given homomorphic commitments to the witnesses. The verifier takes a random combination of the witness commitments. The prover computes the corresponding combination of the witnesses themselves. Since all folding schemes share this work, we can define the <em>marginal work</em> of the prover and verifier as the additional work beyond this linear combination of witnesses and their commitments.</p>

    <p class="text-gray-300">It is hard pinning down precise prover marginal costs, especially for <em>[x1]</em>. At a high level, assuming the verifier equation is computed by a constant size arithemtic circuit, all schemes require in total <span class="math">O(n)</span> field and group operations per folding operation for a size <span class="math">n</span> witness. It is worth mentioning that this holds for HyperNova even when the verifier circuit contains at the base layer a <em>super-constant</em> linear component.</p>

    <p class="text-gray-300">Focusing on the verifier marginal work, we can easily see the difference between the two latest folding schemes - HyperNova <em>[x10]</em> and Protostar <em>[x1]</em>, and Protogalaxy. The differences in verifier work are more crucial as they must be performed <em>in-circuit</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>HyperNova performs a randomized sumcheck protocol to accumulate a new instance - except that the final (expensive) multilinear opening is delayed to the final decision. Thus, the verifier requires <span class="math">d\\log n</span> field operations - to evaluate the intermediate univariates sent during sumcheck, and <span class="math">\\log n</span> random-oracle like hashes - to obtain the challenges for the sumcheck.</li>

      <li>Protostar, rather than actually performing a sumcheck, simply reduces the instance to another that is a randomized sum of the instance, and then folds <em>this claim about the randomized sum</em>. Most of the folding work, in fact, is related to combining the random coefficients for the new instance’s sum with the current accumulator, and proving those coefficients are of an appropriate form - specifically, consecutive powers of a challenge <span class="math">\\beta</span>. This process requires <em>committing</em> to the vector of powers of <span class="math">\\beta</span>, which adds group operations to the folding verifier that needs to perform scalar multiplications on these commitments.</li>

      <li>Protogalaxy instead of combining randomized sums with different challenges, “converts” the accumulator to a claim using the new challenge. This avoids the need to commit to the power vector, and allows remaining with a succinct (<span class="math">\\log n</span> length) representation of the sum’s coefficients. An interesting point is that although this results in a polynomial of degree <span class="math">\\log n</span> expressed as a sum of length <span class="math">n</span>, we are able to recursively compute its coefficients in <span class="math">O(n)</span> rather than <span class="math">O(n\\log n)</span> operations (cf. Claim 4.4).</li>

    </ul>

    <p class="text-gray-300">The second difference between PROTOSTAR and PROTOGALAXY, responsible for more efficient folding of multiple instances, is a transition from monomial to Lagrange base: PROTOSTAR's folding creates a polynomial whose constant coefficient is the current accumulator's sum, and the coefficient of  <span class="math">X^d</span>  is the new instances's sum - where  <span class="math">d</span>  is the maximal degree of the verifier's checks. Attempting to do this for  <span class="math">k</span>  instances at once requires a degree growing exponentially in  <span class="math">k</span>  to make sure coefficients relating to different instances don't "mix".</p>

    <p class="text-gray-300">However, things are smoother in Lagrange base. We associate with each instance to be folded a different Lagrange coefficient. Essentially due to the property that a power of Lagrange polynomial  <span class="math">L_{i}(X)</span>  modulo the set's vanishing polynomial is  <span class="math">L_{i}(X)</span>  itself, there is no need for exponentially growing degrees in the Lagrange approach. Another simplification due to the Lagrange base, is avoiding the need to homogenize the verifier's constraint polynomials as done in PROTOSTAR. See Section 4 for the precise construction.</p>

    <p class="text-gray-300">Table 1: Comparing folding verifiers. CRH = collision resistant hash, RO="random oracle like" hash.  <span class="math">d =</span>  degree of verifier checks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Marginal verifier work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperNova</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log n) F, d log n CRH, log n RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROTOSTAR</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G, d + O(1) F, d + O(1) CRH, O(1) RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROTOGALAXY</td>

            <td class="px-3 py-2 border-b border-gray-700">d + log n F, d + log n CRH, O(1) RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PROTOGALAXY -k instances</td>

            <td class="px-3 py-2 border-b border-gray-700">kd + log n F, kd + log n CRH, O(1) RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 5 -k instances</td>

            <td class="px-3 py-2 border-b border-gray-700">log n + d log k F, kd + log n CRH, log k RO</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 5 -k accumulators</td>

            <td class="px-3 py-2 border-b border-gray-700">log k(log n + d) F, k(d + log n) CRH, log k RO</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We assume our field  <span class="math">\\mathbb{F}</span>  is of prime order. We assume all algorithms described receive as an implicit parameter the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Whenever we use the term efficient, we mean an algorithm running in time  <span class="math">\\mathsf{poly}(\\lambda)</span> . Furthermore, we assume an object generator  <span class="math">\\mathcal{O}</span>  that is run with input  <span class="math">\\lambda</span>  before all protocols, and returns all fields and groups used. Specifically, in our protocol  <span class="math">\\mathcal{O}(\\lambda) = (\\mathbb{F},\\mathbb{G})</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span>  is a prime field of super-polynomial size  <span class="math">r = \\lambda^{\\omega(1)}</span> .</li>

      <li><span class="math">\\mathbb{G}</span>  is a group of size  <span class="math">r</span> .</li>

    </ul>

    <p class="text-gray-300">We usually let the  <span class="math">\\lambda</span>  parameter be implicit, i.e. write  <span class="math">\\mathbb{F}</span>  instead of  <span class="math">\\mathbb{F}(\\lambda)</span> . We write  <span class="math">\\mathbb{G}</span>  additively.</p>

    <p class="text-gray-300">We often denote by <span class="math">[n]</span> the integers <span class="math">\\{1,\\ldots,n\\}</span>. We use the acronym e.w.p for “except with probability”; i.e. e.w.p <span class="math">\\gamma</span> means with probability <em>at least</em> <span class="math">1-\\gamma</span>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">3 Definitions based on Protostar</h2>

    <p class="text-gray-300">We review and adapt definitions from <em>[x1]</em>. We recommend reading the referenced sections for full understanding and context. All protocols described are between a prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span>. We use the convention that “the protocol has input <span class="math">(a;b)</span>” means that both <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> get <span class="math">a</span>, but only <span class="math">\\mathbf{P}</span> gets <span class="math">b</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">3.1 Special-sound protocols</h3>

    <p class="text-gray-300">Following <em>[x1, x2]</em> we define special-sound protocols. We recall first the definition from Section 2.1 of <em>[x1]</em>, of an <span class="math">a^{\\mu}</span>-out-of-<span class="math">N</span> special-sound interactive protocol: Roughly speaking, this means a <em>public-coin</em> protocol where verifier challenges are chosen from a domain of size <span class="math">N</span>, and a tree of accepting transcripts of arity <span class="math">a</span> is sufficient for extracting a witness. Based on that definition, we say that a <span class="math">(2\\mu+1)</span>-move interactive protocol (meaning <span class="math">\\mu+1</span> prover messages and <span class="math">\\mu</span> verifier messages) is <em>special-sound</em>, if it is <span class="math">a^{\\mu}</span>-out-of <span class="math">N</span> special-sound, for <span class="math">a=\\mathsf{poly}(\\lambda)</span> and <span class="math">N=\\lambda^{\\omega(1)}</span>. As explained in <em>[x1]</em>, the results of <em>[x1]</em> impy the non-interactive version of the protocol in the random oracle model is knowledge-sound with error <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.2 Defining accumulation/folding schemes</h3>

    <p class="text-gray-300">We define accumulation schemes in an equivalent way to <em>[x1]</em> but using different terminology, more focused on relations. In the definition below we are “accumulating” instances of a relation <span class="math">\\mathcal{R}</span> into an “accumulator” which is an instance of a relation <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span>. The reason we need the additional relation <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span> - rather than folding directly into <span class="math">\\mathcal{R}</span> - is that the accumulator requires more flexibility in its structure. For example, in Nova<em>[x10]</em>, <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span> corresponds to <em>relaxed</em> committed R1CS.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">Fix relations <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}_{\\mathrm{acc}}</span>. An <span class="math">(\\mathcal{R}\\mapsto\\mathcal{R}_{\\mathrm{acc}})</span>-accumulation/folding scheme is a public-coin interactive protocol <span class="math">\\mathscr{P}</span> between a prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol input is <span class="math">(\\phi,\\phi^{\\prime};\\omega,\\omega^{\\prime})</span>.</li>

      <li>When the protocol ends <span class="math">\\mathbf{V}</span> outputs <span class="math">\\phi^{<em>}</span>, and <span class="math">\\mathbf{P}</span> outputs <span class="math">\\omega^{</em>}</span>.</li>

      <li>Completeness: If <span class="math">(\\phi,\\omega)\\in\\mathcal{R}_{\\mathrm{acc}},(\\phi^{\\prime},\\omega^{\\prime})\\in\\mathcal{R}</span>, and <span class="math">\\mathbf{P},\\mathbf{V}</span> follow the protocol, we have with probability one that <span class="math">(\\phi^{<em>},\\omega^{</em>})\\in\\mathcal{R}_{\\mathrm{acc}}</span>.</li>

      <li>Knowledge soundness:</li>

    </ol>

    <p class="text-gray-300">The following protocol <span class="math">\\mathscr{P}^{<em>}</span> between <span class="math">\\mathbf{P}^{</em>}</span> and <span class="math">\\mathbf{V}^{*}</span> is knowledge-sound with error <span class="math">\\mathsf{negl}(\\lambda)</span> for the relation <span class="math">\\mathcal{R}_{\\mathrm{acc}}\\times\\mathcal{R}</span>:</p>

    <p class="text-gray-300">1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given inputs <span class="math">(\\phi,\\phi^{\\prime};\\omega,\\omega^{\\prime})</span>, <span class="math">\\mathbf{P}^{<em>}</span> and <span class="math">\\mathbf{V}^{</em>}</span> run the protocol <span class="math">\\mathcal{P}</span> as <span class="math">\\mathbf{P},\\mathbf{V}</span> with the same inputs.</li>

      <li>Let <span class="math">\\mathfrak{p}^{<em>}=(\\phi^{</em>},\\omega^{<em>})</span> be the final output of <span class="math">\\mathbf{P},\\mathbf{V}</span> in <span class="math">\\mathcal{P}</span>. <span class="math">\\mathbf{V}^{</em>}</span> outputs accept if and only if <span class="math">\\mathfrak{p}^{*}\\in\\mathcal{R}_{\\mathrm{acc}}</span>.</li>

    </ul>

    <p class="text-gray-300">In words, knowledge soundness means that if the accumulation protocol was followed correctly, and either the current accumulator <span class="math">\\phi</span>, or the current instance <span class="math">\\phi^{\\prime}</span> is invalid, then the new accumulator <span class="math">\\phi^{<em>}</span> will also be invalid, and thus will fail a final decision stage - in which a prover would need to show <span class="math">(\\phi^{</em>},\\omega^{<em>})\\in\\mathcal{R}_{\\mathrm{acc}}</span> for some <span class="math">\\omega^{</em>}</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.3 Relations based on interactive protocols</h3>

    <p class="text-gray-300">To define and motivate the relations we use in our accumulation scheme, we continue to review interactive protocol conventions from <em>[x1]</em>.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Interactive protocols from <em>[x1]</em>: <em>Given a relation <span class="math">\\mathcal{R}_{0}</span>, we look at interactive protocols for <span class="math">\\mathcal{R}_{0}</span> of the form described in Section 3.1 of </em>[x1]<em>:</em></h5>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol is parameterized by positive integers <span class="math">\\mathfrak{h},d,n</span> (<em>[x1]</em> uses <span class="math">\\ell</span> rather than <span class="math">n</span>).</li>

      <li>The protocol input is <span class="math">(\\phi_{0};\\omega_{0})</span> such that <span class="math">(\\phi_{0},\\omega_{0})\\in\\mathcal{R}_{0}</span>.</li>

      <li>We have <span class="math">\\mathfrak{h}</span> rounds where at round <span class="math">i</span> <span class="math">\\mathbf{P}</span> sends a vector <span class="math">m_{i}</span> over <span class="math">\\mathbb{F}</span>, and, if <span class="math">i&lt;\\mathfrak{h}</span>, <span class="math">\\mathbf{V}</span> responds with random challenge <span class="math">r_{i}\\in\\mathbb{F}</span>.</li>

      <li>Denote by <span class="math">\\omega</span> the transcript of the protocol - namely the concatentation of <span class="math">\\phi_{0}</span>, the vectors <span class="math">m_{i}</span>, and elements <span class="math">r_{i}</span>. Suppose <span class="math">\\omega</span> is of length <span class="math">M</span>. The protocol’s definition includes a degree <span class="math">d</span> mapping <span class="math">f:\\mathbb{F}^{M}\\to\\mathbb{F}^{n}</span>. At the end <span class="math">\\mathbf{V}</span> accepts if and only if <span class="math">f(\\omega)=0^{n}</span>.</li>

    </ul>

    <h5 id="sec-9" class="text-base font-semibold mt-4">“Committed” protocols</h5>

    <p class="text-gray-300">Let <span class="math">\\mathsf{cm}</span> be an additively homomorphic commitment function, mapping vectors over <span class="math">\\mathbb{F}</span> of length at most <span class="math">M</span>, into <span class="math">\\mathbb{G}</span>. Given <span class="math">\\mathsf{cm}</span> and an interactive protocol like the one described above, <em>[x1]</em> looks at a “committed” version of the protocol, where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span>’s messages <span class="math">\\mathsf{m}_{i}</span> are replaced by the commitments <span class="math">C_{i}=\\mathsf{cm}(m_{i})</span>.</li>

      <li>At the end of the protocol <span class="math">\\mathbf{P}</span> sends the vectors <span class="math">m_{i}</span>.</li>

      <li>Define <span class="math">\\omega</span> again as the concatenation of <span class="math">\\phi_{0}</span>, the vectors <span class="math">m_{i}</span>, and elements <span class="math">r_{i}</span>. <span class="math">\\mathbf{V}</span> accepts if and only if <span class="math">f(\\omega)=0^{n}</span> and for each <span class="math">i\\in[\\mathfrak{h}]</span>, <span class="math">\\mathsf{cm}(\\mathsf{m}_{i})=C_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Non-interactive proofs via Fiat-Shamir: <em>[x1]</em> now transforms such a committed protocol into a non-interactive proof in the random oracle model. Specifically, assume access to a random oracle <span class="math">\\mathscr{R}</span> mapping arbitrary strings into uniform elements of <span class="math">\\mathbb{F}</span>. We transform the above protocol to a non-interactive proof by having</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> set <span class="math">r_{0}=\\mathscr{R}(\\phi_{0})</span> and for each <span class="math">i\\in[\\mathfrak{h}-1]</span>, <span class="math">r_{i}=\\mathscr{R}(r_{i-1},C_{i})</span>.</li>

      <li>Having the verifier check the <span class="math">r_{i}</span> are correct by querying <span class="math">\\mathscr{R}</span> independently.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}</span> be a hash function mapping arbitrary strings into <span class="math">\\mathbb{F}</span>. We can replace <span class="math">\\mathscr{R}</span> with <span class="math">\\mathcal{H}</span> above to get a non-interactive proof in the standard model, with a heuristic knowledge soundness guarantee via Fiat-Shamir. We’ll assume access to <span class="math">\\mathcal{H}</span> of this form as an implicit parameter from now on.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Committed relations:</h4>

    <p class="text-gray-300">Given a vector <span class="math">\\omega</span> representing a transcript of the original non-committed protocol, we abuse notation and denote by <span class="math">\\phi=\\mathsf{cm}(\\omega)</span> a “committed” version of the transcript, where every vector <span class="math">m_{i}</span> is replaced by <span class="math">\\mathsf{cm}(m_{i})</span>, but <span class="math">\\phi_{0}</span> and the <span class="math">\\{r_{i}\\}</span> are left as is. That is, if <span class="math">\\omega=(\\phi_{0},m_{1},\\ldots,m_{\\mathfrak{h}},r_{1},\\ldots,r_{\\mathfrak{h}-1})</span></p>

    <p class="text-gray-300"><span class="math">\\phi=\\mathsf{cm}(\\omega)=(\\phi_{0},\\mathsf{cm}(m_{1}),\\ldots,\\mathsf{cm}(m_{\\mathfrak{h}}),r_{1},\\ldots,r_{\\mathfrak{h}-1}).</span></p>

    <p class="text-gray-300">In particular, <span class="math">\\phi</span> is a mixture of field and group elements. Given <span class="math">\\phi</span> of this form, we say it is <em><span class="math">\\mathcal{H}</span>-consistent</em> if the random challenges are computed as defined above. Namely, <span class="math">r_{i}=\\mathcal{H}(r_{i-1},C_{i})</span> for each <span class="math">i\\in[\\mathfrak{h}-1]</span> where we define <span class="math">r_{0}=\\mathcal{H}(\\phi_{0})</span>.</p>

    <p class="text-gray-300">Given this notation, we define the relation <span class="math">\\mathcal{R}_{f,\\mathsf{cm}}</span> “induced” by the committed protocol for <span class="math">\\mathcal{R}_{0}</span> when “Fiat-Shamired” with <span class="math">\\mathcal{H}</span>. <span class="math">\\mathcal{R}_{f,\\mathsf{cm}}</span> is defined as pairs of a committed transcript and the corresponding plain transcript. Formally, as all the pairs <span class="math">(\\phi,\\omega)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi</span> is <span class="math">\\mathcal{H}</span>-consistent.</li>

      <li><span class="math">\\phi=\\mathsf{cm}(\\omega)</span>.</li>

      <li><span class="math">f(\\omega)=0^{n}</span>.</li>

    </ol>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Knowledge soundness for committed relations</h4>

    <p class="text-gray-300">We now deal with a technicality that comes up in both Protostar and Protogalaxy’s knowledge soundness proof. The definition of a special-sound protocol requires that we are always able to extract a witness given a large enough tree of accepting transcripts. However, we’ll only be able to <em>either</em> extract a witness or produce of collision of <span class="math">\\mathsf{cm}</span>. We show this suffices.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 3.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">\\mathsf{cm}:\\mathbb{F}^{M}\\mapsto\\mathbb{G}</span> is a binding commitment. Given a relation <span class="math">\\mathcal{R}</span>, define the relation $\\mathcal{R}^{\\prime}=\\mathcal{R}\\cup\\{\\phi,(w,w^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{cm}(w)=\\mathsf{cm}(w^{\\prime}),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\lambda\\}<span class="math">; in words, a collision of </span>\\mathsf{cm}$ of appropriate length is a satisfying witness for any instance.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\mathscr{P}</span> is special-sound for <span class="math">\\mathcal{R}^{\\prime}</span> then it is knowledge-sound with error <span class="math">\\mathsf{negl}(\\lambda)</span> for <span class="math">\\mathcal{R}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Proof. We can use the result of [AFK22] to conclude <span class="math">\\mathcal{P}</span> is knowledge-sound for <span class="math">\\mathcal{R}&#x27;</span> with error <span class="math">\\mathrm{negl}(\\lambda)</span>. This means there is an extractor <span class="math">E</span>, that when <span class="math">\\mathcal{A}</span> convinces the verifier of the validity of instance <span class="math">\\phi</span>, produces a witness <span class="math">\\omega</span> such that <span class="math">(\\phi, \\omega) \\in \\mathcal{R}&#x27;</span> e.w.p <span class="math">\\mathrm{negl}(\\lambda)</span>. We define extractor <span class="math">E_1</span> for <span class="math">\\mathcal{R}</span>: <span class="math">E_1</span> runs <span class="math">E</span>, aborts if <span class="math">E</span>'s output <span class="math">\\omega</span> is a collision of <span class="math">\\mathsf{cm}</span>; and otherwise outputs <span class="math">\\omega</span>. By the binding property of <span class="math">\\mathsf{cm}</span>, the failure probability of <span class="math">E_1</span> is larger by at most <span class="math">\\mathrm{negl}(\\lambda)</span> than that of <span class="math">E</span>; and when it succeeds <span class="math">(\\phi, \\omega) \\in \\mathcal{R}</span>. Thus, <span class="math">\\mathcal{P}</span> is knowledge-sound with error <span class="math">\\mathrm{negl}(\\lambda)</span> for <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}^{\\mathrm{rand}}</span>: Let <span class="math">t \\coloneqq \\log n</span>. For <span class="math">i \\in [n]</span>, let <span class="math">S \\subset \\{0, \\dots, t - 1\\}</span> be the set such that <span class="math">i - 1 = \\sum_{j \\in [S]} 2^j</span>. We define the <span class="math">t</span>-variate polynomial <span class="math">\\mathsf{pow}_i</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{pow}_i(X_0, \\dots, X_{t-1}) = \\prod_{\\ell \\in S} X_\\ell</span></div>

    <p class="text-gray-300">Note that if <span class="math">\\beta = (\\beta, \\beta^2, \\beta^4, \\ldots, \\beta^{2^{t-1}})</span>, <span class="math">\\mathsf{pow}_i(\\beta) = \\beta^{i-1}</span>. For brevity, let <span class="math">\\mathcal{R} = \\mathcal{R}_{f,\\mathsf{cm}}</span>. We define the "randomized relaxed" version of <span class="math">\\mathcal{R}</span>, <span class="math">\\mathcal{R}^{\\mathrm{rand}}</span> - as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}^{\\mathrm{rand}}</span> consists of the pairs <span class="math">((\\phi, \\beta, e), \\omega)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi = \\mathsf{cm}(\\omega)</span></li>

      <li><span class="math">\\beta \\in \\mathbb{F}^t, e \\in \\mathbb{F}</span> and we have</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}) f_i(\\omega) = e.</span></div>

    <p class="text-gray-300">(Here, <span class="math">f_i</span> denotes the <span class="math">i</span>'th output coordinate of <span class="math">f</span>.)</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Main Protocol</h2>

    <p class="text-gray-300">We are ready to present our main scheme. Fix positive integers <span class="math">d, k &amp;lt; n</span> such that <span class="math">k + 1</span> is a power of two. Denote <span class="math">t \\coloneqq \\log n</span>. Assume <span class="math">\\mathbb{F}</span> contains a multiplicative subgroup <span class="math">\\mathbb{H}</span> of order <span class="math">k + 1</span> and <span class="math">L_0(X), L_1(X), \\ldots, L_k(X)</span> is its Lagrange base. Let <span class="math">Z(X) \\coloneqq \\prod_{a \\in \\mathbb{H}} (X - a)</span> be <span class="math">\\mathbb{H}</span>'s vanishing polynomial.</p>

    <p class="text-gray-300">PROTOGALAXY <span class="math">(\\Phi = (\\phi, \\beta, e), (\\phi_1, \\ldots, \\phi_k); \\omega, (\\omega_1, \\ldots, \\omega_k))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> checks for each <span class="math">i \\in [k]</span> that <span class="math">\\phi_i</span> is <span class="math">\\mathcal{H}</span>-consistent, and outputs <span class="math">\\mathrm{rej}</span> otherwise.</li>

      <li><span class="math">\\mathbf{V}</span> sends a challenge <span class="math">\\delta \\in \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> compute <span class="math">\\boldsymbol{\\delta} \\in \\mathbb{F}^t</span>, where <span class="math">\\boldsymbol{\\delta} := (\\delta, \\delta^2, \\ldots, \\delta^{2^{t-1}})</span></li>

      <li><span class="math">\\mathbf{P}</span> computes the polynomial</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F(X) := \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta} + X \\boldsymbol{\\delta}) f_i(\\omega).</span></div>

    <p class="text-gray-300">(Note that <span class="math">F(0) = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}) f_i(\\omega) = e</span>.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends the non-constant coefficients <span class="math">F_{1},\\ldots,F_{t}</span> of <span class="math">F(X)</span> to <span class="math">\\mathbf{V}</span>.</li>

      <li><span class="math">\\mathbf{V}</span> sends a random challenge <span class="math">\\alpha\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> compute <span class="math">F(\\alpha)=e+\\sum_{i\\in[t]}F_{i}\\alpha^{i}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> compute <span class="math">\\boldsymbol{\\beta}^{<em>}\\in\\mathbb{F}^{t}</span> where <span class="math">\\boldsymbol{\\beta}^{</em>}_{i}:=\\boldsymbol{\\beta}_{i}+\\alpha\\cdot\\boldsymbol{\\delta}_{i}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes the polynomial</li>

    </ol>

    <p class="text-gray-300"><span class="math">G(X):=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\boldsymbol{\\beta}^{*})f_{i}(L_{0}(X)\\omega+\\sum_{j\\in[k]}L_{j}(X)\\omega_{j}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> computes polynomial <span class="math">K(X)</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">G(X)=F(\\alpha)L_{0}(X)+Z(X)K(X).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends the coefficients of <span class="math">K(X)</span>.</li>

      <li><span class="math">\\mathbf{V}</span> sends a random challenge <span class="math">\\gamma\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">e^{*}:=F(\\alpha)L_{0}(\\gamma)+Z(\\gamma)K(\\gamma).</span></p>

    <p class="text-gray-300">At the end of the protocol</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> outputs the instance <span class="math">\\Phi^{<em>}=(\\phi^{</em>},\\boldsymbol{\\beta}^{<em>},e^{</em>})</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\phi^{*}:=L_{0}(\\gamma)\\phi+\\sum_{i\\in[k]}L_{i}(\\gamma)\\phi_{i}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> outputs the witness <span class="math">\\omega^{*}:=L_{0}(\\gamma)\\omega+\\sum_{i\\in[k]}L_{i}(\\gamma)\\omega_{i}</span>.</li>

    </ul>

    <h6 id="sec-15" class="text-base font-medium mt-4">Remark 4.1.</h6>

    <p class="text-gray-300">Since <span class="math">\\sum_{i=0}^{k}L_{i}(X)=1</span>, <span class="math">\\mathbf{V}</span> can compute <span class="math">\\phi^{*}</span> with <span class="math">k</span> rather than <span class="math">k+1</span> scalar multiplications as</p>

    <p class="text-gray-300"><span class="math">\\phi^{*}=\\phi+\\sum_{i\\in[k]}L_{i}(\\gamma)(\\phi_{i}-\\phi).</span></p>

    <p class="text-gray-300">We make crucial use of the following easily checkable lemma. Loosely speaking, it says any polynomial <span class="math">f(X)</span> “commutes modulo <span class="math">Z(X)</span>”, with multiplication by Lagrange polynomials.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 4.2.</h6>

    <p class="text-gray-300">Fix any polynomial <span class="math">f(X)\\in\\mathbb{F}[X]</span> and <span class="math">a_{0},\\ldots,a_{k}\\in\\mathbb{F}</span>. There exists <span class="math">Q(X)\\in\\mathbb{F}[X]</span> such that</p>

    <p class="text-gray-300"><span class="math">f\\left(\\sum_{i=0}^{k}a_{i}L_{i}(X)\\right)=\\sum_{i=0}^{k}f(a_{i})L_{i}(X)+Z(X)Q(X).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4.3. Let <span class="math">\\mathsf{cm}:\\mathbb{F}^M\\to \\mathbb{G}</span> be an additively homomorphic binding commitment scheme. Let <span class="math">\\mathcal{R} = \\mathcal{R}_{f,\\mathsf{cm}}</span>. Assume <span class="math">dnk = \\mathsf{poly}(\\lambda)</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda^{\\omega (1)}<span class="math">. Then PROTOGALAXY is an </span>(\\mathcal{R}^k\\mapsto \\mathcal{R}^{\\mathrm{rand}})$-accumulation/folding scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We prove completeness and soundness, and discuss efficiency in Claims 4.4 and 4.5.</p>

    <p class="text-gray-300">Completeness: Assume <span class="math">((\\phi_1, \\ldots, \\phi_k), (\\omega_1, \\ldots, \\omega_k)) \\in \\mathcal{R}^k</span> and <span class="math">((\\phi, \\beta, e), \\omega) \\in \\mathcal{R}^{\\text{rand}}</span>. We need to show that if the protocol is followed correctly, <span class="math">(\\Phi^<em>, \\omega^</em>) \\in \\mathcal{R}^{\\text{rand}}</span> with probability one. It is immediate from construction that <span class="math">\\mathsf{cm}(\\phi^<em>) = \\omega^</em></span>. So, to obtain <span class="math">(\\Phi^<em>, \\omega^</em>) \\in \\mathcal{R}^{\\text{rand}}</span> it is left to check that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) f_i(\\omega^*) = e^*.</span></div>

    <p class="text-gray-300">Note first that when <span class="math">((\\phi, \\beta, e), \\omega) \\in \\mathcal{R}^{\\text{rand}}</span></p>

    <div class="my-4 text-center"><span class="math-block">F(0) = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}) f_i(\\omega) = e.</span></div>

    <p class="text-gray-300">So in Step 7 <span class="math">\\mathbf{V}</span> is computing <span class="math">F(\\alpha)</span> correctly.</p>

    <p class="text-gray-300">Therefore, using Lemma 4.2</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} G(X) \\mod Z(X) &amp;amp;= \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) f_i\\left(L_0(X) \\omega + \\sum_{j \\in [k]} L_j(X) \\omega_j\\right) \\mod Z(X) \\\\ &amp;amp;= \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) \\left(L_0(X) f_i(\\omega) + \\sum_{j \\in [k]} L_j(X) f_i(\\omega_j)\\right) \\\\ &amp;amp;= \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) L_0(X) f_i(\\omega) = F(\\alpha) L_0(X). \\end{aligned}</span></div>

    <p class="text-gray-300">The second last equality uses <span class="math">f_i(\\omega_j) = 0</span>, for all <span class="math">j \\in [k], i \\in [n]</span>.</p>

    <p class="text-gray-300">Therefore, in step 11 <span class="math">\\mathbf{P}</span> is indeed able to send <span class="math">K(X)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">G(X) = F(\\alpha) L_0(X) + Z(X) K(X).</span></div>

    <p class="text-gray-300">And so, in step 13, we have <span class="math">e^<em> = G(\\gamma)</span>. Thus, using the definitions of <span class="math">G</span> and <span class="math">\\omega^</em></span>:</p>

    <div class="my-4 text-center"><span class="math-block">e^* = G(\\gamma) = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}_i^*) f_i(L_0(\\gamma) \\omega + \\sum_{j \\in [k]} L_j(\\gamma) \\omega_j) = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}_i^*) f_i(\\omega^*),</span></div>

    <p class="text-gray-300">as required.</p>

    <p class="text-gray-300">Knowledge soundness: Suppose we have a tree of arity <span class="math">N = \\max \\{n, dk\\}</span> of accepting transcripts in the sense that <span class="math">(\\Phi^<em>, \\omega^</em>) \\in \\mathcal{R}^{\\text{rand}}</span>; where the verifier input is <span class="math">(\\phi, (\\phi_1, \\ldots, \\phi_k))</span>. We show that we can either produce a collision of cm or a witness <span class="math">(\\omega, (\\omega_1, \\ldots, \\omega_k))</span> such</p>

    <p class="text-gray-300">that <span class="math">((\\phi,(\\phi_{1},\\ldots,\\phi_{k})),(\\omega,(\\omega_{1},\\ldots,\\omega_{k})))\\in\\mathcal{R}^{\\sf rand}\\times\\mathcal{R}^{k}</span>. According to Lemma 3.2 this suffices.</p>

    <p class="text-gray-300">We denote for <span class="math">1\\leq a,b,c\\leq N</span> by <span class="math">\\delta_{a},\\alpha_{a,b},\\gamma_{a,b,c}</span> the values for the challenges <span class="math">\\alpha,\\beta,\\gamma</span> used in the corresponding path in the transcript tree; and by <span class="math">(\\Phi_{a,b,c}^{<em>},\\omega_{a,b,c}^{</em>})</span> the final output in that path. For convenience, let us denote <span class="math">\\phi_{0}:=\\phi,\\omega_{0}:=\\omega</span>. In our first step described next we will either find a collision of <span class="math">\\sf cm</span> or find <span class="math">\\omega_{0},\\omega_{1},\\ldots,\\omega_{k}</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=0,\\ldots,k</span>, <span class="math">\\phi_{i}=\\sf cm(\\omega_{i})</span>.</li>

      <li>For all <span class="math">1\\leq a,b,c\\leq N</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\omega_{a,b,c}^{*}=\\sum_{i=0}^{k}L_{i}(\\gamma_{a,b,c})\\omega_{i}.</span></p>

    <p class="text-gray-300">For this purpose, choose any <span class="math">k+1</span> accepting transcripts using distinct values <span class="math">\\gamma_{0},\\ldots,\\gamma_{k}</span> for the challenge <span class="math">\\gamma</span> and let <span class="math">(\\Phi_{0}^{<em>},\\omega_{0}^{</em>}),\\ldots,(\\Phi_{k}^{<em>},\\omega_{k}^{</em>}))</span> be the outputs in those transcripts. We have for each <span class="math">j=0,\\ldots,k</span></p>

    <p class="text-gray-300"><span class="math">\\Phi_{j}^{*}=\\sum_{i=0}^{k}L_{i}(\\gamma_{j})\\phi_{i}.</span></p>

    <p class="text-gray-300">Since the <span class="math">(k+1)\\times(k+1)</span> matrix with <span class="math">L_{i}(\\gamma_{j})</span> in index <span class="math">(i,j)</span> is invertible, it means there exists for each <span class="math">j=0,\\ldots,k</span> coefficients <span class="math">\\{c_{j,\\ell}\\}</span> such that <span class="math">\\phi_{j}=\\sum_{\\ell=0}^{k}c_{j,\\ell}\\Phi_{\\ell}^{*}</span>. We define for <span class="math">j=0,\\ldots,k</span>,</p>

    <p class="text-gray-300"><span class="math">\\omega_{j}:=\\sum_{\\ell=0}^{k}c_{j,\\ell}\\omega_{\\ell}^{*}</span></p>

    <p class="text-gray-300">From linearity of <span class="math">\\sf cm</span> and <span class="math">\\sf cm(\\omega_{\\ell}^{<em>})=\\Phi_{\\ell}^{</em>}</span>, we have that <span class="math">\\phi_{j}=\\sf cm(\\omega_{j})</span> for each <span class="math">j\\in 0,\\ldots,k</span>. We apply this process more times such that each accepting transcript has been used at least once. If at any point, for some <span class="math">j</span> we obtain a <em>different</em> vector <span class="math">\\omega_{j}^{\\prime}\\neq\\omega_{j}</span> such that <span class="math">\\sf cm(\\omega_{j}^{\\prime})=\\phi_{j}</span> we output <span class="math">(\\omega_{j},\\omega_{j}^{\\prime})</span> as a collision.</p>

    <p class="text-gray-300">To proceed, we first define several polynomials. For <span class="math">i\\in[n]</span> define the polynomial</p>

    <p class="text-gray-300"><span class="math">P_{i}(Y_{1},Y_{2}):=\\sf pow_{i}(\\bm{\\beta}+Y_{1}\\cdot(Y_{2},Y_{2}^{2},\\ldots,Y_{2}^{2^{i-1}})).</span></p>

    <p class="text-gray-300">Note that <span class="math">\\left\\{P_{i}(Y_{1},Y_{2})\\right\\}_{i\\in[n]}</span> are linearly independent polynomials - since the degree of <span class="math">Y_{2}</span> in <span class="math">P_{i}</span> is precisely <span class="math">i-1</span>. For <span class="math">j\\in[k]</span>, define the polynomial <span class="math">Q_{j}(Y_{1},Y_{2}):=\\sum_{i\\in[n]}P_{i}(Y_{1},Y_{2})\\cdot f_{i}(\\omega_{j})</span>. We will show <span class="math">Q_{j}</span> is the zero polynomial for each <span class="math">j=1,\\ldots,k</span>. As the <span class="math">P_{i}</span> are linearly independent this implies <span class="math">f_{i}(\\omega_{j})=0</span> for all <span class="math">i\\in[n],j\\in[k]</span>; which in turn implies <span class="math">((\\phi_{1},\\ldots,\\phi_{k}),(\\omega_{1},\\ldots,\\omega_{k}))\\in\\mathcal{R}^{k}</span>.</p>

    <p class="text-gray-300">For given <span class="math">1\\leq a,b\\leq N</span> we know for <span class="math">1\\leq c\\leq N</span> that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\sf pow_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\omega_{a,b,c}^{*})=F_{\\alpha_{a,b}}L_{0}(\\gamma_{c})+Z_{\\alpha,\\beta}(\\gamma)K(\\gamma)</span></p>

    <p class="text-gray-300">Recall that <span class="math">\\omega_{a,b,c}^{*}=\\sum_{j=0}^{k}L_{j}(\\gamma_{c})\\omega_{j}</span>. We thus have as polynomials that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\sf pow_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\sum_{j=0}^{k}L_{j}(X)\\omega_{j})=F_{\\alpha_{a,b}}L_{0}(X)+Z(X)K(X)</span></p>

    <p class="text-gray-300">On the other hand, similarly to the completeness case, we have that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\sum_{j=0}^{k}L_{j}(X)\\omega_{j})\\mod Z(X)\\equiv\\sum_{j=0}^{k}L_{j}(X)\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{b}\\bm{\\delta}_{a})f_{i}(\\omega_{j})</span></p>

    <p class="text-gray-300">And so, comparing coefficients, we have that <span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\omega_{0})=F_{a,b}(\\alpha_{a,b})</span>, and for <span class="math">j\\in[k]</span> that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\omega_{j})=0</span></p>

    <p class="text-gray-300">Now, for <span class="math">j\\in[k]</span> note that</p>

    <p class="text-gray-300"><span class="math">Q_{j}(\\alpha_{a,b},\\delta_{a})=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\omega_{j})=0</span></p>

    <p class="text-gray-300">Since this holds for all <span class="math">1\\leq a,b\\leq N</span> we have that <span class="math">Q_{j}(Y_{1},Y_{2})</span> is identically zero as we intended to show.</p>

    <p class="text-gray-300">To show we have a valid witness for <span class="math">\\mathcal{R}^{\\mathsf{rand}}\\times\\mathcal{R}^{k}</span> it is left to show that <span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta})f_{i}(\\omega_{0})=e</span>. Fix some value <span class="math">1\\leq a\\leq N</span>, and the challenge <span class="math">\\delta=\\delta_{a}</span> sent in the transcripts in the <span class="math">a</span>’th branch of the tree. Denote by <span class="math">F</span> the polynomial <span class="math">F(X)=e+\\sum_{i\\in[t]}F_{i}X^{i}</span>, when we let <span class="math">\\{F_{i}\\}</span> be the values sent in step 5 in those transcripts. We know for <span class="math">N</span> different values <span class="math">\\alpha_{a,b}</span> that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+\\alpha_{a,b}\\bm{\\delta}_{a})f_{i}(\\omega_{0})=F(\\alpha_{a,b})</span></p>

    <p class="text-gray-300">So we have a polynomial identity</p>

    <p class="text-gray-300"><span class="math">H(X):=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta}+X\\bm{\\delta}_{a})f_{i}(\\omega_{0})=F(X),</span></p>

    <p class="text-gray-300">which means the constant coefficient of <span class="math">H(X)</span> is <span class="math">e</span> on one hand, but on the other hand <span class="math">\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta})f_{i}(\\omega_{0})</span>. In other words,</p>

    <p class="text-gray-300"><span class="math">e=\\sum_{i\\in[n]}\\mathsf{pow}_{i}(\\bm{\\beta})f_{i}(\\omega_{0}),</span></p>

    <p class="text-gray-300">as required. ∎</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Claim 4.4.</h6>

    <p class="text-gray-300">Given <span class="math">\\omega,\\bm{\\beta},\\bm{\\delta}</span>, the polynomial <span class="math">F(X)</span> in step 4 can be computed <span class="math">O(n)</span> <span class="math">\\mathbb{F}</span>-operations</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We can expand <span class="math">F(X)</span> as a sum over <span class="math">n</span> terms of degree <span class="math">t</span>. These terms are all products of <span class="math">t+1</span> linear factors, and computing each individually would take <span class="math">O(nt)=O(n\\log n)</span> time in general. However, we can exploit the structure of <span class="math">\\mathsf{pow}_{i}(\\bm{\\beta}+X\\bm{\\delta})</span> to compute the sum in <span class="math">O(n)</span> time.</p>

    <p class="text-gray-300">Consider the full binary tree of <span class="math">n</span> leaves, with each leaf <span class="math">i</span> from left to right labelled by <span class="math">f_{i}(\\omega)</span>. Define the <em>level</em> of a node to be its distance from the leaves. At each internal,</p>

    <p class="text-gray-300">non-leaf node of the tree at level <span class="math">\\ell &amp;gt; 0</span>, label the left edge from the node with 1 and the right edge with <span class="math">\\beta_{\\ell} + X\\delta_{\\ell}</span>. Given the path from the root to leaf <span class="math">i</span>, if we multiply the labels of each edge along the path and the label at the leaf, we have exactly the <span class="math">i</span>'th term from <span class="math">F(X)</span>, <span class="math">\\mathsf{pow}_i(\\beta + X\\delta)f_i(\\omega)</span>. Now, we can recursively construct the labels of each internal node. For each internal node at level <span class="math">k</span>, let <span class="math">\\mathfrak{n}_l</span> and <span class="math">\\mathfrak{n}_r</span> be the labels of the left and right children and let <span class="math">e_l</span> and <span class="math">e_r</span> be the labels of the edges connecting the left and right children. Define the label of each internal node to be <span class="math">\\mathfrak{n} := \\mathfrak{n}_l e_l + \\mathfrak{n}_r e_r</span>. Since <span class="math">\\deg(e_l) = 0</span> and <span class="math">\\deg(e_r) = 1</span>, it must be the case that <span class="math">\\deg(\\mathfrak{n}) = \\max(\\deg(\\mathfrak{n}_l), 1 + \\deg(\\mathfrak{n}_r)) \\leq k</span>. This yields <span class="math">F(X)</span> as the label for the root node.</p>

    <p class="text-gray-300">We want to show that we can compute all the labels in <span class="math">O(n)</span> time. Note that computing each <span class="math">\\mathfrak{n}</span> at level <span class="math">\\ell</span> takes <span class="math">O(\\ell)</span> field operations, since multiplying by <span class="math">e_r</span> takes <span class="math">O(\\ell)</span> operations. There are <span class="math">2^{t - \\ell}</span> nodes at level <span class="math">\\ell</span>, so the total number of field operations at level <span class="math">\\ell</span> is <span class="math">\\ell 2^{t - \\ell}</span>. Summing over <span class="math">\\ell</span> from 1 to <span class="math">t</span>, we find the total number of field operations is <span class="math">2n - t - 1 = O(n)</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i = 1}^{t} i 2^{t - i} = 2^{t - 1} \\sum_{i = 0}^{t - 1} (i + 1) 2^{-i} = 2^{t - 1} \\left. \\frac{d}{dx} \\frac{x^{t + 1} - 1}{x - 1} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x = 1/2} = 2n - t - 2 = O(n).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since we can compute all the labels in <span class="math">O(n)</span> time, we can compute the root label in <span class="math">O(n)</span> time. Note that this technique can be generalized to trees of arbitrary arity.</p>

    <p class="text-gray-300">In the following claim we denote by <span class="math">C</span> the maximum over <span class="math">i \\in [n]</span> of the number of multiplications needed to compute <span class="math">f_i(\\omega)</span> for a given input <span class="math">\\omega \\in \\mathbb{F}^M</span>.</p>

    <p class="text-gray-300"><strong>Claim 4.5.</strong> Given the values <span class="math">\\{\\mathsf{pow}_i(\\beta^*)\\}_{i\\in [n]}</span>, the polynomial <span class="math">G(X)</span> in step 9 can be computed in at most</p>

    <div class="my-4 text-center"><span class="math-block">dk \\log(dk)(M + 1) + (d - 1)kn(C + 1) = O(dk \\log(dk)M + dknC)</span></div>

    <p class="text-gray-300"><span class="math">\\mathbb{F}</span>-multiplications.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The degree of <span class="math">G(X)</span> is <span class="math">dk</span>, so given <span class="math">dk + 1</span> evaluations of <span class="math">G</span> we can compute its coefficients via IFFT with at most <span class="math">dk\\log(dk)</span> multiplications. The honest prover already knows <span class="math">k</span> evaluations of <span class="math">G</span> - as it vanishes on <span class="math">k</span> points of <span class="math">\\mathbb{H}</span>. So we only need <span class="math">(d - 1)k + 1</span> additional evaluations.</p>

    <p class="text-gray-300">Note that we can write <span class="math">G(X) = \\sum_{i \\in [n]} \\mathsf{pow}_i(\\beta^*) \\cdot P_i(X)</span> where we define for <span class="math">i \\in [n]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">P_i(X) := f_i\\left(L_0(X)(\\omega) + \\sum_{j \\in [k]} L_j(X)(\\omega_j)\\right).</span></div>

    <p class="text-gray-300">Let <span class="math">D</span> be the smallest power of two that is at least <span class="math">(d - 1)k + 1</span>, thus <span class="math">D \\leq 2(d - 1)k</span>. Let <span class="math">\\mathfrak{H}</span> be a subgroup of order <span class="math">D</span>. It suffices to evaluate each <span class="math">P_i</span> at all <span class="math">\\mathfrak{a} \\in \\mathfrak{H}</span>; and then</p>

    <p class="text-gray-300">5We count only the multiplications as these typically dominate the costs of the additions/subtractions. For an <span class="math">f</span> containing much more additions than multiplications one should count the total number of operations instead.</p>

    <p class="text-gray-300">perform <span class="math">n((d-1)k+1)</span> multiplications with the values <span class="math">\\{\\mathsf{pow}_i(\\boldsymbol{\\beta}^*)\\}_{i\\in[n]}</span> to obtain the evaluations of <span class="math">G</span>.</p>

    <p class="text-gray-300">Recall that the <span class="math">\\{\\omega_j\\}</span> are vectors of length <span class="math">M</span>. For each <span class="math">\\ell \\in [M]</span>, we first evaluate the following polynomial <span class="math">S_\\ell</span> on <span class="math">\\mathfrak{H}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">S_\\ell(X) := L_0(X)(\\omega)_\\ell + \\sum_{j \\in [k]} L_j(X)(\\omega_j)_\\ell.</span></div>

    <p class="text-gray-300">Using FFT, this requires at most <span class="math">(d-1)k\\log((d-1)k)M</span> multiplications. Given these evaluations, we can evaluate each <span class="math">P_i</span> on <span class="math">\\mathfrak{a} \\in \\mathfrak{H}</span> via an evaluation of <span class="math">f_i</span>. These evaluations of <span class="math">\\{f_i\\}</span> will take in total <span class="math">(d-1)knC</span> multiplications. Summing the different terms that came up gives the result in the claim.</p>

    <p class="text-gray-300"><strong>Remark 4.6.</strong> The <span class="math">nC</span> factor in Claim 4.5 can be replaced by a factor <span class="math">N</span> equal to the number of multiplications required to compute <span class="math">f</span> on input <span class="math">\\omega \\in \\mathbb{F}^M</span>. <span class="math">N</span> can be significantly smaller than <span class="math">nC</span> in cases where the <span class="math">\\{f_i\\}</span> vary significantly in their complexity.</p>

    <p class="text-gray-300">In this section we assume familiarity with the sumcheck protocol; for an introduction, see Section 4.1 of Thaler[Tha]. In the protocol of the previous section the folding prover's costs scale quasilinearly with the number of instances <span class="math">k - O(k\\log k)</span>; and the verifier's cost scales linearly with <span class="math">k</span>. Here, we improve those dependencies to linear and logarithmic respectively, at the cost of a more complex protocol with potentially worse constants. Roughly, we replace the vanishing check mod <span class="math">Z(X)</span> with a sumcheck over a domain of size <span class="math">k</span>. For simplicity, we assume this sumcheck works over the boolean hypercube, but it naturally generalizes to larger bases. Given a collection of <span class="math">k = 2^s - 1</span> instances, folding begins in the same way as before by refreshing the randomness <span class="math">\\beta</span> with <span class="math">\\delta</span>. More precisely, <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> will run the protocol of the previous section up to step 8. Now, using the notation there, denote <span class="math">\\boldsymbol{\\delta}^n \\coloneqq (\\delta^n, \\delta^{n \\cdot 2}, \\dots, \\delta^{n \\cdot 2^{s-1}}) \\in \\mathbb{F}^s</span>, and <span class="math">\\omega_0 \\coloneqq \\omega</span>; and <span class="math">e_0 \\coloneqq F(\\alpha)</span> as computed by <span class="math">\\mathbf{V}</span> in step 7. Note that when <span class="math">\\mathbf{P}</span> is honest, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) f_i(\\omega_0) = e_0.</span></div>

    <p class="text-gray-300">Below we denote by <span class="math">\\mathsf{eq}</span> the <span class="math">2s</span>-variate multilinear polynomial with <span class="math">\\mathsf{eq}(a,b) = 1</span> for <span class="math">a = b \\in \\{0,1\\}^s</span> and <span class="math">\\mathsf{eq}(a,b) = 0</span> for <span class="math">a \\neq b \\in \\{0,1\\}^s</span>; and overload notation and denote by <span class="math">j \\in \\{0,\\dots,k\\}</span> the <span class="math">s</span>-length binary decomposition of <span class="math">j</span>. <span class="math">\\mathbf{P}</span> will show the following expression holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=0}^{k} \\mathsf{eq}(j, \\boldsymbol{\\delta}^n) \\sum_{i \\in [n]} \\mathsf{pow}_i(\\boldsymbol{\\beta}^*) f_i\\left(\\sum_{\\ell=0}^{k} \\mathsf{eq}(j, \\ell) \\omega_\\ell\\right) = \\mathsf{eq}(0, \\boldsymbol{\\delta}^n) \\cdot e_0.</span></div>

    <p class="text-gray-300">We can think of the lhs of the above identity, as summing the following <span class="math">s</span>-variate polynomial <span class="math">G(\\mathfrak{J})</span> over <span class="math">j \\in \\{0, \\dots, k\\}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">G(\\mathfrak{J}) := \\operatorname{eq}(\\mathfrak{J}, \\boldsymbol{\\delta}^n) \\sum_{i \\in [n]} \\operatorname{pow}_i(\\boldsymbol{\\beta}^*) f_i \\left( \\sum_{\\ell=0}^{k} \\operatorname{eq}(\\mathfrak{J}, \\ell) \\omega_\\ell \\right).</span></div>

    <p class="text-gray-300">We now run a sumcheck protocol for <span class="math">G</span> over <span class="math">\\{0,1\\}^s \\sim \\{0,\\dots,k\\}</span> to check it sums to <span class="math">\\operatorname{eq}(0,\\boldsymbol{\\delta}^n) \\cdot e_0</span>. For <span class="math">a \\in [s]</span>, in the <span class="math">a</span>'th round <span class="math">\\mathbf{P}</span> sends a univariate polynomial <span class="math">P_a</span> of degree <span class="math">d</span>, and replaces the <span class="math">a</span>'th variable with a verifier challenge <span class="math">\\gamma_a</span>. Following these rounds, the correctness of the sumcheck is reduced to checking <span class="math">G(\\boldsymbol{\\gamma}) = P_s(\\gamma_s)</span>; which is in turn equivalent to showing <span class="math">^6</span> <span class="math">((\\phi^<em>, \\boldsymbol{\\beta}^</em>, e^<em>), \\omega^</em>) \\in \\mathcal{R}^{\\text{rand}}</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\phi^* := \\sum_{\\ell=0}^{k} \\operatorname{eq}(\\gamma, \\ell) \\phi_\\ell</span>, where <span class="math">\\forall \\ell \\in \\{0, \\dots, k\\}</span>, <span class="math">\\phi_\\ell := \\operatorname{cm}(\\omega_\\ell)</span></li>

      <li><span class="math">\\omega^* := \\sum_{\\ell=0}^{k} \\operatorname{eq}(\\gamma, \\ell) \\omega_\\ell</span>,</li>

      <li><span class="math">e^* := P_s(\\gamma_s) / \\operatorname{eq}(\\boldsymbol{\\gamma}, \\boldsymbol{\\delta}^n)</span>.</li>

    </ul>

    <p class="text-gray-300">And so in this variant of the PROTOGALAXY, <span class="math">\\mathbf{V}</span> outputs <span class="math">(\\phi^<em>, \\boldsymbol{\\beta}^</em>, e^<em>)</span> and <span class="math">\\mathbf{P}</span> outputs <span class="math">\\omega^</em></span>. In total <span class="math">\\mathbf{V}</span> needs to evaluate <span class="math">s = \\lceil \\log k \\rceil</span> hashes and perform <span class="math">O(\\log n + d \\log k)</span> field operations - the <span class="math">\\log n</span> operations coming from running the original protocol up to step 8. The prover only sends <span class="math">ds</span> scalars to communicate the <span class="math">P_a(X)</span> polynomials as compared to <span class="math">dk</span> for the univariate PROTOGALAXY protocol. In total the prover requires only <span class="math">O(kdM + nkdC)</span> field operations. The main thing to show is that the univariates sent during sumcheck can be computed efficiently.</p>

    <p class="text-gray-300"><strong>Claim 5.1.</strong> The polynomials <span class="math">P_a(X)</span> can all be computed in a total of <span class="math">O(kdM + nkdC)</span> field operations.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We show for <span class="math">i \\in [s]</span>, that computing <span class="math">P_a(X)</span> takes <span class="math">O(2^{-a}(kdM + nkdC))</span> field operations. If this is the case, then it follows that the total computation is <span class="math">O(kdM + nkdC)</span>.</p>

    <p class="text-gray-300">We illustrate the claim on <span class="math">P_1</span>. Below we denote by <span class="math">\\boldsymbol{\\delta}^m</span> the last <span class="math">s - 1</span> coordinates of <span class="math">\\boldsymbol{\\delta}^n</span>. We have</p>

    <div class="my-4 text-center"><span class="math-block">P_1(X) = (1 + \\delta^n X) \\sum_{j \\in [k/2]} \\operatorname{eq}(j, \\boldsymbol{\\delta}^m) \\sum_{i \\in [n]} \\operatorname{pow}_i(\\boldsymbol{\\beta}^*) f_i \\left( \\sum_{\\ell \\in [k/2]} \\operatorname{eq}(j, \\ell) (X \\cdot \\omega_{2\\ell} + (1 - X) \\omega_{2\\ell+1}) \\right)</span></div>

    <p class="text-gray-300">First, for each <span class="math">j \\in [k/2]</span>, we precompute for the length <span class="math">M</span> vector of polynomials <span class="math">v_i(X) := X \\cdot \\omega_{2i} + (1 - X) \\omega_{2i+1}</span>, <span class="math">d</span> evaluations for each <span class="math">v_{i,\\ell}(X)</span>. This takes <span class="math">O(kdM)</span> field operations.</p>

    <p class="text-gray-300">6A formal knowledge soundness proof for this protocol would proceed similarly to that of Theorem 4.3 extracting the <span class="math">\\{\\omega_\\ell\\}</span> from the <span class="math">\\{\\phi_\\ell\\}</span> and address the case of finding a collision of <span class="math">\\mathsf{cm}</span>. Since the details are almost identical, we omit them.</p>

    <p class="text-gray-300">To compute <span class="math">P_{1}(X)</span>, we must compute it at <span class="math">d</span> values. For each evaluation, we need to evaluate the outer sum at <span class="math">k/2</span> values <span class="math">j \\in [k/2]</span>. For each such evaluation, we need to evaluate a sum of length <span class="math">n</span> whose <span class="math">i</span>'th term is</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{pow}_{i}(\\boldsymbol{\\beta}^{*}) f_{i}(v_{i}(X)).</span></div>

    <p class="text-gray-300">As we have already computed <span class="math">d + 1</span> values of <span class="math">v_{i}</span>'s argument, we can evaluate <span class="math">f_{i}(v_{i}(X))</span> at <span class="math">d</span> inputs in <span class="math">O(dC)</span> operations. So in total we get <span class="math">O(nkdC)</span>. Since the other <span class="math">P_{a}</span>'s have the same form as <span class="math">P_{1}</span> on domains of size going down by two, the claim follows.</p>

    <h2 id="sec-20" class="text-2xl font-bold">Folding Many Accumulators</h2>

    <p class="text-gray-300">This technique transposes into accumulator folding as well. Denote now <span class="math">k = 2^s</span>, and let <span class="math">K := \\{0, \\dots, k - 1\\}</span>. We fold <span class="math">k</span> accumulators by replacing <span class="math">\\boldsymbol{\\beta}</span> with a linear combination of the <span class="math">\\boldsymbol{\\beta}_j</span> values from each instance. Assume we have <span class="math">k</span> instances <span class="math">\\left\\{(\\phi_j, \\boldsymbol{\\beta}_j, e_j)\\right\\}_{j \\in K}</span> with corresponding witnesses <span class="math">\\{\\omega_j\\}_{j \\in K}</span>. <span class="math">\\mathbf{V}</span> chooses a random <span class="math">\\delta \\in \\mathbb{F}</span>, and we set <span class="math">\\boldsymbol{\\delta} := (\\delta, \\delta^2, \\dots, \\delta^{2^{s-1}}) \\in \\mathbb{F}^s</span>. We look at the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">G(\\mathfrak{J}) := \\operatorname{eq}(\\mathfrak{J}, \\boldsymbol{\\delta}) \\sum_{i \\in [n]} \\operatorname{pow}_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(\\mathfrak{J}, \\ell) \\boldsymbol{\\beta}_{\\ell} \\right) f_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(\\mathfrak{J}, \\ell) \\omega_{\\ell} \\right).</span></div>

    <p class="text-gray-300">When <span class="math">\\mathbf{P}</span> is honest, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{j \\in K} G(j) &amp;amp;= \\sum_{j \\in K} \\operatorname{eq}(j, \\boldsymbol{\\delta}) \\sum_{i \\in [n]} \\operatorname{pow}_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(j, \\ell) \\boldsymbol{\\beta}_{\\ell} \\right) f_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(j, \\ell) \\omega_{\\ell} \\right) \\\\ &amp;amp;= \\sum_{j \\in K} \\operatorname{eq}(j, \\boldsymbol{\\delta}) \\sum_{i \\in [n]} \\operatorname{pow}_{i} \\left( \\boldsymbol{\\beta}_{j} \\right) f_{i}(\\omega_{j}) = \\sum_{j \\in K} \\operatorname{eq}(j, \\boldsymbol{\\delta}) e_{j}. \\end{aligned}</span></div>

    <p class="text-gray-300">We again run a sumcheck protocol for <span class="math">G</span> over <span class="math">j \\in [k]</span>, up to and not including the final step of evaluating <span class="math">G(\\boldsymbol{\\gamma})</span>. Denote again by <span class="math">P_{a}(X)</span>, for <span class="math">a \\in [s]</span>, the univariate polynomials sent in the rounds of the sumcheck. Note that now each <span class="math">P_{a}</span> has degree at most <span class="math">d + t</span>. Following <span class="math">s</span> rounds, the sumcheck verifier needs to check</p>

    <div class="my-4 text-center"><span class="math-block">G(\\boldsymbol{\\gamma}) = \\operatorname{eq}(\\gamma, \\boldsymbol{\\delta}) \\sum_{i \\in [n]} \\operatorname{pow}_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(\\boldsymbol{\\gamma}, \\ell) \\boldsymbol{\\beta}_{\\ell} \\right) f_{i} \\left( \\sum_{\\ell \\in K} \\operatorname{eq}(\\boldsymbol{\\gamma}, \\ell) \\omega_{\\ell} \\right).</span></div>

    <p class="text-gray-300">This corresponds to showing <span class="math">((\\phi^{<em>},\\boldsymbol{\\beta}^{</em>},e^{<em>}),\\omega^{</em>})\\in\\mathcal{R}^{\\sf rand}</span> where</p>

    <p class="text-gray-300"><span class="math">\\phi^{<em>}</span> <span class="math">:=\\sum_{\\ell\\in K}\\mathsf{eq}(\\gamma,\\ell)\\phi_{\\ell},</span> <span class="math">\\boldsymbol{\\beta}^{</em>}</span> <span class="math">=\\sum_{\\ell\\in K}\\mathsf{eq}(\\boldsymbol{\\gamma},\\ell)\\boldsymbol{\\beta}_{\\ell},</span> <span class="math">e^{<em>}</span> <span class="math">=\\mathsf{eq}(\\boldsymbol{\\gamma},\\boldsymbol{\\delta})^{-1}\\cdot P_{s}(\\gamma_{s}),</span> <span class="math">\\omega^{</em>}</span> <span class="math">=\\sum_{\\ell\\in K}\\mathsf{eq}(\\boldsymbol{\\gamma},\\ell)\\omega_{\\ell}.</span></p>

    <p class="text-gray-300">Thus, we have reduced the <span class="math">k</span> instances of <span class="math">\\mathcal{R}^{\\sf rand}</span> to the instance <span class="math">\\Phi^{<em>}=(\\phi^{</em>},\\boldsymbol{\\beta}^{<em>},e^{</em>})</span>, where <span class="math">\\phi^{<em>}:=\\mathsf{cm}(\\omega^{</em>})</span>. The folding verifier can compute <span class="math">\\phi^{<em>}=\\sum_{\\ell\\in K}\\mathsf{eq}(\\boldsymbol{\\gamma},\\ell)\\phi_{\\ell}</span> using <span class="math">k</span> scalar multiplications; as well as <span class="math">\\boldsymbol{\\beta}^{</em>}</span> and <span class="math">e^{*}</span> using <span class="math">O((k+d)t)</span> field operations.</p>

    <p class="text-gray-300">The main thing to address is the efficiency of computing <span class="math">\\left\\{P_{a}(X)\\right\\}_{a\\in[s]}</span>. Using a combination of the techniques used in Claims 4.4 and 5.1, one can show</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Claim 5.2.</h6>

    <p class="text-gray-300">The polynomials <span class="math">P_{a}(X)</span> can all be computed in a total of <span class="math">O(kdM+nkdC)</span> field operations.</p>

    <p class="text-gray-300">It follows from Claim 5.2 that <span class="math">\\mathbf{P}</span> requires in total <span class="math">O(kdM+nkdC)</span> <span class="math">\\mathbb{F}</span>-operations.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Acknowledgements</h3>

    <p class="text-gray-300">We thank Benedikt Bünz and Binyi Chen for discussions on Protostar. We thank the Ethereum Foundation and 0xPARC for supporting this work. We thank Cody Gunton, Sergei Iakovenko, Thor Kampefner, Mara Mihali, Ivan Mikushin, Pratyush Mishra, Srinath Setty, Zac Williamson and David Wong for corrections and comments.</p>

    <h2 id="sec-23" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFK22] T. Attema, S. Fehr, and M. Klooß. Fiat-shamir transformation of multi-round interactive proofs. In Eike Kiltz and Vinod Vaikuntanathan, editors, Theory of Cryptography - 20th International Conference, TCC 2022, Chicago, IL, USA, November 7-10, 2022, Proceedings, Part I, volume 13747 of Lecture Notes in Computer Science, pages 113–142. Springer, 2022.</li>

      <li>[BC23] B. Bünz and B. Chen. Protostar: Generic efficient accumulation/folding for special sound protocols. IACR Cryptol. ePrint Arch., page 620, 2023.</li>

      <li>[BCL^{+}21] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. Proof-carrying data without succinct arguments. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021,</li>

    </ul>

    <p class="text-gray-300">Proceedings, Part I, volume 12825 of Lecture Notes in Computer Science, pages 681–710. Springer, 2021.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. Recursive proof composition from accumulation schemes. In Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 1–18. Springer, 2020.</li>

      <li>[CT10] A. Chiesa and E. Tromer. Proof-carrying data and hearsay arguments from signature cards. In Innovations in Computer Science - ICS 2010, Tsinghua University, Beijing, China, January 5-7, 2010. Proceedings, pages 310–331. Tsinghua University Press, 2010.</li>

      <li>[KS22] A. Kothapalli and S. T. V. Setty. Supernova: Proving universal machine executions without universal circuits. IACR Cryptol. ePrint Arch., page 1758, 2022.</li>

      <li>[KS23] A. Kothapalli and S. Setty. Hypernova: Recursive arguments for customizable constraint systems. IACR Cryptol. ePrint Arch., page 573, 2023.</li>

      <li>[KST21] A. Kothapalli, S. T. V. Setty, and I. Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. IACR Cryptol. ePrint Arch., page 370, 2021.</li>

      <li>[Moh] N. Mohnblatt. Sangria: a folding scheme for plonk.</li>

      <li>[Tha] Justin Thaler. Proofs, arguments, and zero-knowledge.</li>

      <li>[Val08] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Theory of Cryptography, Fifth Theory of Cryptography Conference, TCC 2008, New York, USA, March 19-21, 2008, volume 4948 of Lecture Notes in Computer Science, pages 1–18. Springer, 2008.</li>

    </ul>`;
---

<BaseLayout title="ProtoGalaxy:  Efficient ProtoStar-style folding of multiple ... (2023/1106)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1106
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
