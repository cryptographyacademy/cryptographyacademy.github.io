---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/2099';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'MicroNova: Folding-based arguments with efficient (on-chain) verification';
const AUTHORS_HTML = 'Jiaxing Zhao, Srinath Setty, Weidong Cui, Greg Zaverucha';

const CONTENT = `    <p class="text-gray-300">Jiaxing Zhao^{†⋆}, Srinath Setty^{⋆}, Weidong Cui^{⋆}, and Greg Zaverucha^{⋆} ^{†}University of Science and Technology of China ^{⋆}Microsoft Research</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We describe the design and implementation of MicroNova, a folding-based recursive argument for producing proofs of incremental computations of the form <span class="math">y=F^{(\\ell)}(x)</span>, where <span class="math">F</span> is a possibly non-deterministic computation (encoded using a constraint system such as R1CS), <span class="math">x</span> is the initial input, <span class="math">y</span> is the output, and <span class="math">\\ell&amp;gt;0</span>. The proof of an <span class="math">\\ell</span>-step computation is produced step-by-step such that the proof size nor the time to verify it depends on <span class="math">\\ell</span>. The proof at the final iteration is then compressed, to achieve further succinctness in terms of proof size and verification time. Compared to prior folding-based arguments, a distinguishing aspect of MicroNova is the concrete efficiency of the verifier—even in a resource-constrained environment such as Ethereum’s blockchain. In particular, the compressed proof consists of <span class="math">O(\\log N)</span> group elements and it can be verified with <span class="math">O(\\log N)</span> group scalar multiplications and two pairing operations, where <span class="math">N</span> is the number of constraints for a single invocation of <span class="math">F</span>. MicroNova requires a universal trusted setup and can employ any existing setup material created for the popular KZG univariate polynomial commitment scheme. Finally, we implement and experimentally evaluate MicroNova. We find that MicroNova’s proofs can be efficiently verified on the Ethereum blockchain with <span class="math">\\approx</span>2.2M gas. Furthermore, MicroNova’s prover incurs minimal overheads atop its baseline Nova’s prover.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A folding scheme <em>[52]</em> is a cryptographic protocol involving a <em>prover</em> and a <em>verifier</em>, where they interactively reduce the task of checking two NP instances into the task of checking a single NP instance. A folding scheme can be used on its own to reduce the prover’s work when proving multiple instances. Beyond this, Kothapalli et al. <em>[50, 52]</em> show that folding schemes that satisfy certain mild requirements immediately provide an efficient realization of incrementally verifiable computation (IVC) <em>[66]</em>, a powerful cryptographic primitive that enables one to prove the correct execution of a “long running” computation in an incremental manner.</p>

    <p class="text-gray-300">Suppose we have an incremental computation of the form <span class="math">z_{i}=F(\\omega_{i},z_{i-1})</span>, where <span class="math">i\\geq 1</span>, <span class="math">F</span> is a function (typically represented using a circuit), <span class="math">\\omega_{i}</span> is the non-deterministic input of the prover for step <span class="math">i</span>, <span class="math">z_{0}</span> is the initial input, and <span class="math">z_{i}</span> is the output after <span class="math">i</span> steps. With an IVC scheme, the prover takes as input a proof <span class="math">\\pi_{i}</span> that proving that <span class="math">z_{i}</span> is the correct output after executing <span class="math">i</span> steps of the incremental computation, and then outputs a proof <span class="math">\\pi_{i+1}</span> that proves the correct execution of the first <span class="math">i+1</span> steps to produce an output <span class="math">z_{i+1}</span>. Crucially, the prover’s work (or the memory requirements to update a proof) nor the proof size grows with the number of steps executed thus far, and the verifier can verify any proof produced by the prover to verify the execution of the computation thus far. Thus, IVC unlocks proving the correct execution of large computations without the prover running out of memory.</p>

    <p class="text-gray-300">IVC has a wide variety of applications in decentralized settings including rollups <em>[53, 70]</em>, verifiable delay functions <em>[17, 69]</em>, proofs of (virtual) machine executions (e.g., RISC-V). In all of these applications, the statement that the prover wishes to prove can be expressed in an incremental manner. For example, in a rollup, <span class="math">F</span> checks the correct execution of a batch of blockchain transactions. In a VDF, <span class="math">F</span> encodes checks that a delay function such as MinRoot <em>[45]</em> was executed correctly. In proofs of machine executions, <span class="math">F</span> checks a certain number of iterations of the fetch-decode-execute loop of a particular machine.</p>

    <p class="text-gray-300">Early works <em>[15, 66]</em> constructed IVC via succinct non-interactive arguments of knowledge (SNARKs) <em>[13, 39, 46, 55]</em>: the prover at step <span class="math">i</span> proves the correct execution of the step computation <span class="math">F</span> and that it has verified a SNARK <span class="math">\\pi_{i-1}</span> proving the correct execution of the first <span class="math">i-1</span> steps (the latter requires representing the SNARK verifier as a circuit alongside <span class="math">F</span>). Folding schemes bypass the need for SNARKs (and even NARKs) by employing a particular type of reduction of knowledge <em>[47]</em>. Indeed, a folding scheme is simpler and more prover-efficient than a SNARK. Nova <em>[52]</em> provides a folding scheme for R1CS, a popular NP-complete problem that generalizes arithmetic circuit satisfiability. In this folding scheme, the prover’s work at each step is dominated by two multi-scalar multiplications (MSMs) of sizes equal to the number of constraints and number of witness variables in R1CS expressing the step computation (this is an order of magnitude lower work compared to a SNARK prover <em>[30, 38, 59]</em>). Furthermore, the size of the folding scheme verifier proven at each step by the prover is constant sized (<span class="math">\\approx</span>10,000 gates). Nova’s IVC scheme is fully implemented and is public <em>[6]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unlike SNARK-based IVC, folding-scheme-based IVC produces IVC proofs whose size and time to verify scale linearly with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For example, in Nova, an IVC proof is </span>\\approx 3\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> field elements (where each field element is </span>\\approx<span class="math">32 bytes). Even when </span>F<span class="math"> is of modest size such as a when </span>F<span class="math"> is represented with a million R1CS constraints, the proof size is </span>\\approx$96 MB, and the verifier spends multiple seconds to verify a proof. To address this, Nova describes an approach to use SNARKs</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">to compress IVC proofs: the prover uses a SNARK (e.g., Spartan <em>[59]</em>) to prove the knowledge of a valid IVC proof. The resulting proofs are no longer incrementally updateable with a folding scheme, but this is acceptable in many target applications. In the rollup example, a verifier running on a blockchain merely requires a succinct proof of correct execution of a batch of transactions.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Problem: Verifier times</h3>

    <p class="text-gray-300">A topic that has received significantly less attention—even with a flurry of recent works on folding schemes <em>[7, 12, 18, 24, 27, 28, 32, 34, 35, 48, 49, 50, 51]</em>—is the verifier’s costs in folding-based arguments. A folding scheme requires an additively homomorphic commitment scheme with succinct commitments for vectors. For this, Nova uses Pedersen’s commitment instantiated over a cycle of elliptic curves. Concretely, Nova’s implementation <em>[6]</em> uses the Pasta curves <em>[8]</em>, which are simple and fast. Then, to compress IVC proofs <em>[52, §5–6]</em>, Nova treats these (vector) commitments as commitments to multilinear polynomials in evaluation form over the Boolean hypercube. Nova then uses Spartan <em>[59]</em> with an IPA-based polynomial commitment scheme <em>[20, 23]</em> to prove the knowledge of a valid IVC proof.</p>

    <p class="text-gray-300">Under the above scheme, for an <span class="math">N</span>-sized step circuit, the compressed proofs are <span class="math">O(\\log N)</span> group elements (e.g., a few KBs in practice), which is acceptable. However the time to verify a compressed proof is <span class="math">O(N)</span>-sized MSM, where <span class="math">N</span> is at least <span class="math">10,000</span> (given that Nova’s folding scheme’s verifier must be represented as a circuit at each step of the computation). For values of <span class="math">N</span> that one may want to use, this requires the verifier runtime to be up to several seconds of CPU time. Also, it is well known that this verifier cannot feasibly be run on Ethereum’s blockchain: the verifier incurs several billions gas, which is orders of magnitude higher gas than what is allowed by the block limit.</p>

    <p class="text-gray-300">A solution to address this problem is to compose Nova with an existing SNARK (e.g., Plonk <em>[38]</em>) i.e., use Plonk to prove the knowledge of a valid Nova proof. Unfortunately, the resulting prover is impractical (§9). Our work can be viewed as an optimization of Nova’s proof compression layer.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Our solution: MicroNova</h3>

    <p class="text-gray-300">MicroNova is a new IVC scheme with an efficient verifier for compressed IVC proofs. In particular, MicroNova contributes new techniques to improve verifier times in folding-based proof systems and to make the verifier suitable for on-chain verification (e.g., on Ethereum). MicroNova builds on Nova <em>[52]</em> given Nova is fully implemented and heavily optimized <em>[6]</em>. However, our techniques apply easily to other folding-scheme-based arguments (e.g., HyperNova <em>[50]</em>, Protostat <em>[24]</em>, Protogalaxy <em>[34]</em>, NeutronNova <em>[51]</em>) to reduce verifier times and to achieve efficient on-chain verification. Many of MicroNova’s techniques are of independent interest. For instance, we provide a variant of KZG that directly works with multilinear polynomials in the evaluation basis. We also provide a verifier-efficient version of Spartan <em>[59]</em>, which we call MicroSpartan.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.2.1 Implementation and experimental evaluation.</h4>

    <p class="text-gray-300">We implement MicroNova as a modular library in about 11,000 lines of Rust. We also implement MicroNova’s verifier in about 3,300 lines of Solidity. The prover is generic over a cycle of elliptic curves and a hash function that instantiates the random oracle for Fiat-Shamir transform <em>[37]</em>. For efficient on-chain verification, we employ the BN254/Grumpkin elliptic curve cycle (where BN254 is pairing-friendly and Grumpkin is not pairing-friendly), Poseidon (for in-circuit hash function), and Keccak (for on-chain hash function). The library accepts <span class="math">F</span> described as a circuit with bellpepper <em>[1]</em>.</p>

    <p class="text-gray-300">We experimentally evaluate MicroNova on an Azure VM of size Standard F64s_v2 (64 vCPUs, 2.70 GHz Intel processor, and 128 GiB memory), and compare it with Nova <em>[6, 52]</em> on the same testbed. For MicroNova’s on-chain verifier, we evaluate it with Foundry <em>[4]</em>. In our experiments, we vary the number of constraints <span class="math">N</span> in <span class="math">F</span>. We find the following.</p>

    <p class="text-gray-300">IVC. The per-step prover cost in MicroNova’s IVC scheme is about the same as the per-step prover cost in Nova—except when <span class="math">N</span> is small. This is because MicroNova, which aims to keep the verifier circuit on non-pairing-friendly curve small, incurs a higher recursion overhead (<span class="math">\\approx</span>74,000 constraints on BN254 and <span class="math">\\approx</span>1,300 on Grumpkin) when compared to Nova (<span class="math">\\approx</span>10,000 constraints on BN254 and <span class="math">\\approx</span>10,000 on Grumpkin). However, this overhead is dwarfed when <span class="math">N</span> exceeds the size of the recursive verifier circuit.</p>

    <p class="text-gray-300">IVC proof compression and on-chain verification. MicroNova’s compressed proofs are small, and quick to produce and verify. These costs are independent of the number of steps of IVC. In other words, the prover’s and the verifier’s costs can be amortized indefinitely with any number of steps prior to posting proofs on a blockchain.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover’s cost to compress an IVC proof scales close to linearly with <span class="math">N</span> and is concretely small (tens of seconds). The prover’s cost is dominated by a constant cost until <span class="math">N\\approx 2^{21}</span>: for on-chain verification, MicroNova, in addition to proving a folded <span class="math">F</span>, proves a constant-sized R1CS (<span class="math">\\approx</span>1.7M constraints) to prove the evaluation of a polynomial committed over the non-pairing-friendly curve (i.e., Grumpkin).</li>

      <li>The compressed proofs are small <span class="math">\\approx</span> 11 KB until <span class="math">N\\approx 2^{21}</span>, and then has a logarithmic scaling with <span class="math">N</span> (the proof length increases by 0.2 KB each time <span class="math">N</span> doubles).</li>

      <li>The verifier takes <span class="math">\\approx</span>14 ms to verify a compressed proof.</li>

      <li>MicroNova’s Solidity verifier takes <span class="math">\\approx</span>2.2M gas on Ethereum blockchain until <span class="math">N\\approx 2^{21}</span>, and then its gas cost has a</li>

    </ul>

    <p class="text-gray-300">logarithmic scaling with <span class="math">N</span> (the cost increases by 32K gas each time <span class="math">N</span> doubles).</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 A technical overview of MicroNova</h2>

    <p class="text-gray-300">This section provides an overview of MicroNova, building on prior work <em>[52, 56]</em>. Section 4 provides a self-contained description of MicroNova.</p>

    <p class="text-gray-300">(1) A new IVC scheme over half-pairing cycles. We begin with a simple modification to Nova: we instantiate Nova over a “half pairing” cycle of elliptic curves. Specifically, instead of the Pasta curves, MicroNova uses the BN254/Grumpkin cycle (we enhanced Nova’s implementation so that it is generic over the curve cycle and can use other “half pairing” curve cycles such as Pluto/Eris). One reason for this change is so that the verifier can make use of BN254 precompiles available in Ethereum. The other reason to use a paring-friendly curve is that we replace Pedersen’s commitment scheme with the KZG polynomial commitment scheme <em>[44]</em>. In particular, Nova’s IVC scheme only requires a succinct, additively homomorphic commitment scheme, so MicroNova uses KZG to commit to vectors defined over the scalar field of the pairing-friendly elliptic curve in the cycle, i.e., MicroNova treats entries in a vector of size <span class="math">n</span> as coefficients of a univariate polynomial of degree <span class="math">n</span>. On the non-pairing-friendly curve, MicroNova uses Pedersen commitments.</p>

    <p class="text-gray-300">Since MicroNova treats the entries in a vector as coefficients of a univariate polynomial, it does not require any FFTs to change basis (e.g., from an evaluation from to coefficient form). In other words, the prover’s commitment costs in MicroNova is same as that of Nova’s—albeit on a different curve cycle. Because of this design, MicroNova exhibits another desirable feature of not requiring a new setup: MicroNova can use any existing trusted setup material that was created for other proof systems such as Plonk. Since KZG’s trusted setup is updatable, one can start with existing material and update it to add additional security.</p>

    <p class="text-gray-300">(i) Minimize circuit on non-pairing-friendly curve. A more substantial change is that we replace the folding strategy in Nova (which is formally described in <em>[56]</em>) with a strategy based on CycleFold <em>[49]</em>. This ensures that the size of the circuit defined on the secondary (i.e., non-pairing-friendly) curve goes down from 10,000 gates to about 1,300 gates. The verifier circuit on the primary (i.e., pairing-friendly) curve increases from 10,000 gates to about 37,000 gates. However, this trade-off is crucial for on-chain verification (which we unpack below). The higher overhead on the primary curve can be easily offset by using a step function <span class="math">F</span> that is large enough to make the recursion overhead small.</p>

    <p class="text-gray-300">(ii) Avoid circuit-friendly hashes in the on-chain verifier. Another substantial change is related to a hash check in the Nova verifier. In Nova, an IVC proof contains R1CS instances and their witnesses, and the verifier must ensure that the public IO of one of the instances contains a hash of the other instances. This hash check is also performed by the recursive verifier circuit, so the hash function is chosen to be circuit-friendly (e.g., Poseidon). In our context, the verifier runs on a blockchain, and on Ethereum, there are no precompiles for Poseidon hash function, so it must be implemented by using basic opcodes (which is expensive). Furthermore, Poseidon requires storing a large-sized parameters (which is also expensive). Replacing Poseidon with an on-chain-efficient hash function (e.g., Keccak) is not an option as this results in non-trivial recursion overheads. We introduce new techniques to get the best of both worlds: our mechanism allows the recursive verifier circuit to use a circuit-friendly hash function (e.g., Poseidon) while allowing the on-chain verifier to use an on-chain-efficient hash function (e.g., Keccak). In a nutshell, we leverage interaction (which is turned non-interactive with Fiat-Shamir transformation) where the verifier circuit “fingerprints” the message (it hashes with Poseidon) using a random challenge. The on-chain verifier then only has to derive a challenge by hashing the purported pre-image (e.g., with Keccak) and then reexecute the fingerprinting operation. Both are inexpensive for the on-chain verifier.</p>

    <p class="text-gray-300">(2) A new proof compression layer. MicroNova follows the blueprint in Nova to compress IVC proofs: prove the knowledge of valid IVC proofs with Spartan <em>[59]</em>. We make substantial modifications to Spartan to enable efficient on-chain verification. In MicroNova, an IVC proof contains two committed relaxed R1CS instances, one on a pairing-friendly curve and another on the non-pairing-friendly curve. We devise specialized variants of Spartan for each of these.</p>

    <p class="text-gray-300">For the instance on the pairing-friendly curve, we design MicroSpartan that only requires a single invocation of the sum-check protocol <em>[54]</em> and a single polynomial evaluation argument producing a proof of length <span class="math">O(\\log N)</span> group elements. For the polynomial evaluation argument, building on a prior idea <em>[21]</em>, we devise a reduction of knowledge <em>[47]</em> from a multilinear polynomial evaluation instance (where the multilinear polynomial is given in evaluation form) to a set of univariate polynomial evaluation instances, which we prove with a batched version of KZG <em>[44]</em>. We refer to this multilinear polynomial evaluation argument as HyperKZG.</p>

    <p class="text-gray-300">(i) MicroSpartan: A SNARK with minimal proof sizes. Spartan <em>[59]</em> is a SNARK for R1CS. To prove the knowledge of a satisfying witness <span class="math">\\widetilde{w}</span> to an R1CS instance with R1CS matrices <span class="math">(A,B,C)</span>, Spartan invokes the sum-check protocol multiple times in sequence. In particular, it invokes the sum-check protocol twice in sequence to reduce R1CS satisfiability to checking evaluations of multilinear polynomials <span class="math">\\widetilde{w}</span>, <span class="math">\\widetilde{A}</span>, <span class="math">\\widetilde{B}</span>, and <span class="math">\\widetilde{C}</span> at a random point. To prove the evaluation of <span class="math">\\widetilde{w}</span>, one can invoke the evaluation argument of a polynomial commitment scheme. To prove evaluations of sparse multilinear polynomials encoding R1CS matrices, Spartan invokes Spark, a special-purpose SNARK that internally involves multiple sequential invocations of the sum-check protocol <em>[60]</em> and a polynomial evaluation argument. BabySpartan <em>[61]</em> improves</p>

    <p class="text-gray-300">upon Spartan in terms of commitment costs but retains Spartan’s proof length and verification costs. A key take-away is that the verifier has to evaluate multiple sum-check proofs and multiple polynomial evaluation arguments.</p>

    <p class="text-gray-300">We redesign Spartan with a focus on minimizing verifier’s costs—at the cost of the prover providing additional commitments. We refer to this variant as MicroSpartan. In particular, we provide a new reduction from circuit satisfiability to a zero-check and two lookup checks. MicroSpartan reduces all these checks simultaneously to a collection of multilinear polynomial evaluation instances, with a single invocation of the sum-check protocol. We introduce additional claims in this single sum-check protocol so that all committed multilinear polynomials are evaluated at the same random point. To prove these multilinear polynomial evaluation instances, the prover and the verifier fold them into a single instance with a simple random linear combination (without requiring any additional invocations of the sum-check protocol or other auxiliary protocols). To prove that single multilinear polynomial evaluation instance, MicroSpartan invokes HyperKZG. Since MicroSpartan is invoked only once after many steps of IVC, the additional commitment work by the prover is tolerable.</p>

    <p class="text-gray-300">(ii) HyperKZG: Prove multilinear polynomial evaluation instances with a reduction to univariate KZG. MicroSpartan treats a vector <span class="math">w</span> of size <span class="math">n</span> containing the coefficients of a degree-<span class="math">n</span> univariate polynomial as evaluations of a multilinear polynomial in <span class="math">\\log n</span> variables over the Boolean hypercube. Accordingly, the univariate KZG commitment to <span class="math">w</span> serves as a commitment to a multilinear polynomial <span class="math">\\widetilde{w}</span>, where <span class="math">\\widetilde{w}</span> denotes the multilinear extension of the vector <span class="math">w</span>. This matches exactly the requirement of MicroSpartan. Now, all that is necessary is a way to prove evaluations of multilinear polynomials committed in this manner.</p>

    <p class="text-gray-300">Gemini <em>[21, §2.4.2]</em> describes a protocol to reduce a multilinear polynomial evaluation instance in coefficient form to a logarithmic number of univariate polynomial evaluations. However, in our context, the multilinear polynomials are in evaluation form rather than coefficient form. Directly applying Gemini’s technique in our context requires polynomial interpolations during folding, which increases the prover’s work. We make a small—but crucial—modification to Gemini’s reduction protocol. This modification allows us to directly prove evaluations of multilinear polynomials in evaluation form, allowing us to use Spartan and its variant MicroSpartan to compress IVC proofs. We additionally specialize this protocol to use the univariate KZG scheme, allowing us to employ standard techniques to batch multiple univariate evaluations into one <em>[14, 21, 36]</em>.</p>

    <p class="text-gray-300">(iii) DelegatedSpartan: Proving the instance on the non-pairing-friendly curve. In MicroNova’s IVC proof, for the committed relaxed R1CS instance defined over the non-pairing-friendly curve (e.g., Grumpkin), the commitment scheme used is Pedersen (one cannot use KZG on non-pairing-friendly curves). In this setting, the only option is to use an IPA-based evaluation argument <em>[20, 23]</em>. Unfortunately, the on-chain verifier will have to compute a multi-scalar multiplication (MSM) of size proportional to the number of constraints in the circuit defined over the secondary non-pairing-friendly curve. MicroNova’s circuit on the secondary curve is minimal, but this still requires at least 1,000 group scalar multiplications from the on-chain verifier. There are no precompiles for operations over a curve such as Grumpkin, so this is infeasible (even with a precompile, the cost will be prohibitive). The on-chain verifier must also evaluate the multilinear extension (MLE) of R1CS matrices on its own or ask the prover to prove it via Spark. The latter increases the size of the MSM that the verifier must compute to be proportional to the number of non-zero entries in the R1CS matrices (in our setting this is about 5,600). It is infeasible to have the verifier perform these tasks.</p>

    <p class="text-gray-300">To address these, we design a variant of Spartan, which we refer to as DelegatedSpartan. DelegatedSpartan runs Spartan’s core protocol <em>[59, §4.1]</em>, with two modifications: (1) the verifier efficiently evaluates the MLE of R1CS matrices on its own by leveraging the highly repetitive nature of the circuit; and (2) the verifier delegates the polynomial evaluation to the prover by using MicroSpartan.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We observe that the circuit, which computes a group scalar multiplication on the non-pairing-friendly curve is highly structured: it consists of 128 iterations of the textbook double-and-add loop (using the incomplete affine addition law), followed by a complete addition to add the resulting point to the accumulator. We leverage this structure to make the verifier’s work to evaluate the MLE of R1CS matrices inexpensive: the verifier performs finite field operations proportional to the number of non-zero entries resulting from a single iteration of the double and add operation and a single complete addition law. In a nutshell, the idea is to express the MLE of the entire matrix in terms of the MLE of repeated sub-matrix, so the verifier only has to evaluate the MLE of the repeated sub-matrix and then performs work logarithmic in the number of copies to compute the desired MLE of the entire matrix. This computation is inexpensive for the verifier—even when the verifier is implemented as a smart contract on Ethereum.</li>

      <li>We use MicroSpartan to prove the evaluation of a polynomial committed with Pedersen’s commitment over the non-pairing-friendly curve. This is done by writing the polynomial evaluation algorithm as a circuit over the pairing-friendly curve in the cycle. To minimize the size of this circuit, MicroNova uses matrix commitments <em>[68]</em> to commit to the witness of the circuit on the second curve: view the witness as a matrix of size <span class="math">n_{1}\\times n_{2}</span> and commit to rows of the matrix with Pedersen’s commitment scheme. During MicroNova’s IVC, folding a matrix commitment requires <span class="math">n_{1}</span> group scalar multiplications instead of one in Pedersen’s commitment, but this limits the size of MSM—to be proven via MicroSpartan—when compressing IVC proofs to be of size <span class="math">O(n_{1}+n_{2})</span> rather than <span class="math">O(n_{1}\\cdot n_{2})</span>. Concretely, we set <span class="math">n_{1}=8,n_{2}=256</span>, which ensures that the polynomial evaluation circuit proven via MicroSpartan is only 1.7M constraints. With matrix</li>

    </ul>

    <p class="text-gray-300">commitments, MicroNova’s recursion overhead goes up from about 37,000 gates to about 74,000 gates.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300">In this section, we recall reductions of knowledge. In Appendix A, we formally present multilinear polynomials and relevant properties, commitment schemes, arguments of knowledge, and IVC. This section borrows text from prior work <em>[51]</em>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We let <span class="math">\\lambda</span> to denote the security parameter. We let <span class="math">\\mathsf{negl}(\\lambda)</span> to denote a negligible function in <span class="math">\\lambda</span>. We write <span class="math">\\Pr[X]\\approx\\epsilon</span> to mean that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X]-\\epsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)<span class="math">. Throughout the paper, the depicted asymptotics depend on </span>\\lambda<span class="math">, but we elide this for brevity. We let PPT denote probabilistic polynomial time and let EPT denote expected probabilistic polynomial time. We let </span>[n]<span class="math"> denote the set </span>\\{1,\\ldots,n\\}<span class="math">. We let </span>\\{u_{i}\\}_{i\\in[n]}<span class="math"> denote the set </span>\\{u_{1},\\ldots,u_{n}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let <span class="math">\\mathbb{F}</span> to denote a finite field (e.g., the prime field <span class="math">\\mathbb{F}_{p}</span> for a large prime <span class="math">p</span>) and let <span class="math">\\mathbb{F}^{n}</span> denote vectors of length <span class="math">n</span> over elements in <span class="math">\\mathbb{F}</span>. We write <span class="math">\\mathbb{F}^{d}[X_{1},\\ldots,X_{n}]</span> to denote multivariate polynomials over field <span class="math">\\mathbb{F}</span> in the variables <span class="math">(X_{1},\\ldots,X_{n})</span> with degree bound <span class="math">d</span> for each variable. We omit the superscript if there is no degree bound. We denote vectors as <span class="math">\\bm{v}=(v_{1},\\ldots,v_{n})</span>. Given a vector of polynomials <span class="math">\\bm{g}</span>, we let <span class="math">\\bm{g}(x)=(g_{1}(x),\\ldots,g_{n}(x))</span>. We let <span class="math">\\mathsf{eq}(x,y)\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell},Y_{1},\\ldots,Y_{\\ell}]</span> denote the polynomial that outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\ell}</span>. For vector <span class="math">v\\in\\mathbb{F}^{n}</span> we let <span class="math">\\widetilde{v}\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\log n}]</span> denote the multilinear polynomial extension of <span class="math">v</span> (i.e., <span class="math">\\widetilde{v}(i)=\\sum_{j}\\mathsf{eq}(i,j)\\cdot v_{j}</span>).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2 Committed Relaxed R1CS</h3>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 3.1 (Committed relaxed R1CS).</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span> and a commitment scheme <span class="math">\\mathsf{Com}</span> over <span class="math">\\mathbb{F}</span>. Let the public parameters consist of size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span>, and commitment parameters <span class="math">\\mathsf{pp}_{W}</span> and <span class="math">\\mathsf{pp}_{E}</span> for vectors of size <span class="math">m</span> and <span class="math">m-\\ell-1</span> respectively. The committed relaxed R1CS structure consists of sparse matrices <span class="math">A,B,C\\in\\mathbb{F}^{m\\times m}</span> with at most <span class="math">n=\\Omega(m)</span> non-zero entries in each matrix. A committed relaxed R1CS instance is a tuple <span class="math">(\\overline{E},u,\\overline{W},\\mathsf{x})</span>, where <span class="math">\\overline{E}</span> and <span class="math">\\overline{W}</span> are commitments, <span class="math">u\\in\\mathbb{F}</span>, and <span class="math">\\mathsf{x}\\in\\mathbb{F}^{\\ell}</span> are public inputs and outputs. An instance <span class="math">(\\overline{E},u,\\overline{W},\\mathsf{x})</span> is satisfied by a witness <span class="math">(E,r_{E},W,r_{W})\\in(\\mathbb{F}^{m},\\mathbb{F},\\mathbb{F}^{m-\\ell-1},\\mathbb{F})</span> if <span class="math">\\overline{E}=\\mathsf{Com}(\\mathsf{pp}_{E},E,r_{E})</span>, <span class="math">\\overline{W}=\\mathsf{Com}(\\mathsf{pp}_{W},W,r_{W})</span>, and <span class="math">(A\\cdot Z)\\circ(B\\cdot Z)=u\\cdot(C\\cdot Z)+E</span>, where <span class="math">Z=(W,\\mathsf{x},u)</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.3 Reductions of Knowledge</h3>

    <p class="text-gray-300">We now recall reductions of knowledge (RoK) <em>[47]</em>, which are a generalization of arguments of knowledge, in which a verifier interactively reduces checking a prover’s knowledge of a witness in a relation <span class="math">\\mathcal{R}_{1}</span> to checking the prover’s knowledge of a witness in another (simpler) relation <span class="math">\\mathcal{R}_{2}</span>. In particular, both parties take as input a claimed instance <span class="math">u_{1}</span> to be checked, and the prover additionally takes as input a corresponding witness <span class="math">w_{1}</span> such that <span class="math">(u_{1},w_{1})\\in\\mathcal{R}_{1}</span>. After interaction, the prover and verifier together output a new statement <span class="math">u_{2}</span> to be checked in place of the original statement, and the prover additionally outputs a corresponding witness <span class="math">w_{2}</span> such that <span class="math">(u_{2},w_{2})\\in\\mathcal{R}_{2}</span>. Appendix A.2 provides a formal definition.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.2 (Folding scheme).</h6>

    <p class="text-gray-300">A folding scheme for <span class="math">\\mathcal{R}_{1}^{m}</span> and <span class="math">\\mathcal{R}_{2}^{n}</span> is a RoK of type <span class="math">\\mathcal{R}_{1}^{m}\\times\\mathcal{R}_{2}^{n}\\to\\mathcal{R}_{1}</span> where the encoder outputs its input structure. We call a reduction of type <span class="math">\\mathcal{R}^{n}\\to\\mathcal{R}</span> simply as a folding scheme for <span class="math">\\mathcal{R}</span>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.4 The sum-check protocol</h3>

    <p class="text-gray-300">Recall that the standard sum-check relation checks that the sum of evaluations of an <span class="math">\\ell</span>-variate polynomial <span class="math">Q</span> (under a commitment) on the Boolean hypercube results in some value <span class="math">T</span>. Formally, the sum-check relation is defined as follows.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3.3 (Unstructured sum-check relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively homomorphic commitment scheme. Consider a size bound <span class="math">\\ell\\in\\mathbb{N}</span>. The unstructured sum-check relation <span class="math">\\mathsf{USC}</span> over public parameter, instance, witness pairs is defined as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{USC}=\\left\\{\\begin{array}[]{l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(\\mathsf{pp},(\\overline{Q},T),Q\\right)&\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}Q\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}],\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline{Q}=\\mathsf{Com}(\\mathsf{pp},Q),\\\\ T=\\sum_{x\\in\\{0,1\\}^{\\ell}}Q(x)\\end{array}\\right.\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Central to our development is the sum-check protocol <em>[54]</em>, which, when recast as a reduction of knowledge <em>[22]</em>, reduces from the sum-check relation to the polynomial evaluation relation, which we define below.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3.4 (Polynomial evaluation relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively homomorphic commitment scheme. Consider a size bound <span class="math">\\ell\\in\\mathbb{N}</span> and let <span class="math">\\mathsf{pp}</span> denote public parameters of the commitment scheme. We define the polynomial evaluation relation, <span class="math">\\mathsf{PE}</span>, as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{PE}=\\left\\{\\begin{array}[]{l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(\\mathsf{pp},(\\overline{Q},x,y),Q\\right)&\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}Q\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}],\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline{Q}=\\mathsf{Com}(\\mathsf{pp},Q),\\\\ y=Q(x)\\end{array}\\right.\\end{array}\\right\\}. \\]</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 3.1 (The sum-check protocol).</h6>

    <p class="text-gray-300">There exists a succinct, public-coin, tree-extractable reduction of knowledge (Lemma A.4) from <span class="math">\\mathsf{USC}</span> to <span class="math">\\mathsf{PE}</span> compatible with all encoder, generator, and commitment algorithms where the output commitment is the same as the input commitment. For polynomials in <span class="math">\\mathbb{F}^{d}[X_{1},\\ldots,X_{\\ell}]</span> the communication complexity is <span class="math">O(d\\cdot\\ell)</span> elements in <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 3.5 (Multilinear polynomial evaluation relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively homomorphic commitment scheme. Consider a size bound <span class="math">\\ell\\in\\mathbb{N}</span> and let</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},2^{\\ell})</span>. We define the multilinear polynomial evaluation relation, <span class="math">\\mathsf{MPE}</span>, as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{MPE}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(\\overline{Q},x,y),Q\\right)\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}Q\\in\\mathbb{F}^{1}[X_{1},\\ldots,X_{\\ell}],\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline{Q}=\\mathsf{Com}(\\mathsf{pp},Q),\\\\ y=Q(x)\\end{array}\\right.\\right\\}. \\]</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3.6 (Univariate polynomial evaluation relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively homomorphic commitment scheme. Consider a size bound <span class="math">n\\in\\mathbb{N}</span> and let <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>. We define the univariate polynomial evaluation relation, <span class="math">\\mathsf{UPE}</span>, as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{UPE}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(\\overline{Q},x,y),Q\\right)\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}Q\\in\\mathbb{F}^{n}[X],\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline{Q}=\\mathsf{Com}(\\mathsf{pp},Q),\\\\ y=Q(x)\\end{array}\\right.\\right\\}. \\]</p>

    <h2 id="sec-20" class="text-2xl font-bold">4 MicroNova’s IVC with proof compression</h2>

    <p class="text-gray-300">This section describes MicroNova’s IVC scheme. In a nutshell, MicroNova’s IVC scheme starts with Nova’s IVC scheme and makes crucial modifications to enable efficient verification of compressed IVC proofs. This section focuses on MicroNova’s IVC scheme; we also describe how to compress MicroNova’s IVC proofs assuming a black box SNARK. The next section describes a modified Spartan <em>[59]</em> that provides efficient on-chain verification. Our presentation here borrows from and extends the description in Nova <em>[52]</em>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.1 MicroNova’s folding scheme</h3>

    <p class="text-gray-300">MicroNova’s folding scheme combines Nova’s folding scheme <em>[52]</em> with CycleFold technique <em>[49]</em>, to get a folding scheme over a 2-cycle of elliptic curves <span class="math">(E_{1},E_{2})</span> such that the circuit defined over <span class="math">E_{2}</span> is constant-sized and small.</p>

    <p class="text-gray-300">This allows us to use “half pairing” cycles (i.e., <span class="math">E_{1}</span> is pairing friendly but <span class="math">E_{2}</span> is not), which are significantly more efficient than cycles of pairing-friendly curves and as efficient as non-pairing-friendly cycle of curves (e.g., Pasta curves). The motivation to keep the instance on <span class="math">E_{2}</span> small is that when compressing IVC proofs (which we discuss in the next section), the prover has to prove the knowledge of a valid witness for the instance defined over <span class="math">E_{2}</span>. Since <span class="math">E_{2}</span> is not pairing-friendly, one must use a depth-1 recursion using a SNARK defined over <span class="math">E_{1}</span> and keeping the instance on <span class="math">E_{2}</span> small significantly reduces the prover’s work in this. The use of CycleFold <em>[49]</em> in MicroNova reduces the instance defined over <span class="math">E_{2}</span> by more than <span class="math">10\\times</span> compared to Nova, but this is not sufficient. We discuss additional techniques in the next section to reduce the depth-1 recursion costs further.</p>

    <p class="text-gray-300">Details. Recall that Nova <em>[52]</em> provides a folding scheme for committed relaxed R1CS, where the verifier performs two group scalar multiplications and two group additions. If the committed relaxed R1CS instances are defined over the scalar field of <span class="math">E_{1}</span>, then these elliptic curve operations in the folding scheme’s verifier represented as a circuit involve operations over the base field of <span class="math">E_{1}</span>, so they cannot be efficiently represented in the scalar field of <span class="math">E_{1}</span>.</p>

    <p class="text-gray-300">Notation. Let <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})</span> be the trivially satisfying instance-witness pair in committed relaxed R1CS, where <span class="math">E,W,</span> and <span class="math">\\mathsf{x}</span> are appropriately-sized zero vectors, <span class="math">r_{E}=0</span>, <span class="math">r_{W}=0</span>, and <span class="math">\\overline{E}</span> and <span class="math">\\overline{W}</span> are commitments of <span class="math">E</span> and <span class="math">W</span> respectively.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{EC}</span> denote a subset of committed relaxed R1CS (Definition 3.1) in which the constraints are defined over the scalar field of <span class="math">E_{2}</span> and the commitment scheme commits to vectors over the scalar field of <span class="math">E_{2}</span>, and the structure is fixed to compute the following deterministic computation: <span class="math">R\\leftarrow P+r\\cdot Q</span>, where <span class="math">P,Q,R</span> are arbitrary (elliptic curve) group elements on <span class="math">E_{1}</span>, and <span class="math">r</span> is a scalar in the corresponding scalar field of <span class="math">E_{1}</span>. For instances in <span class="math">\\mathsf{EC}</span>, <span class="math">\\mathsf{x}=(r,P,Q,R)</span>, <span class="math">u=1</span>, and <span class="math">\\overline{E}=\\mathsf{u}_{\\perp}.\\overline{E}</span>.</p>

    <p class="text-gray-300">Since the elliptic curve points on <span class="math">E_{1}</span> are a pair of field elements in the base field of <span class="math">E_{1}</span> (which equals the scalar field of <span class="math">E_{2}</span>), the elliptic curve group scalar multiplication and point addition can be represented “natively” on <span class="math">E_{2}</span> (i.e., without any wrong-field arithmetic or field emulation). Concretely, when the scalar is 128-bits, the structure in <span class="math">\\mathsf{EC}</span> requires only <span class="math">\\approx</span>1,300 constraints in R1CS. We denote this committed relaxed R1CS structure as <span class="math">\\mathsf{s}_{\\mathsf{EC}}</span>.</p>

    <p class="text-gray-300">We interpret Nova’s folding scheme as a RoK from two committed relaxed R1CS instance-witness pairs (defined over the scalar field of <span class="math">E_{1}</span>) to a single committed relaxed R1CS instance-witness pair (defined over the scalar field of <span class="math">E_{1}</span>) and two committed relaxed R1CS instance-witness pairs in <span class="math">\\mathsf{EC}</span> (defined over the scalar field of <span class="math">E_{2}</span>) i.e., Nova’s folding scheme can be interpreted as an RoK of the form</p>

    <p class="text-gray-300"><span class="math">\\Pi_{1}:\\mathsf{CRR1CS}\\times\\mathsf{CRR1CS}\\rightarrow\\mathsf{CRR1CS}\\times\\mathsf{EC}^{2}.</span></p>

    <p class="text-gray-300">In other words, the verifier in the <span class="math">\\Pi_{1}</span> RoK obtains untrusted advice regarding the elliptic curve operations that it would have otherwise performed. This untrusted advice is provided in the form of a pair of committed relaxed R1CS instances that are satisfying if and only if the advice is correct.</p>

    <p class="text-gray-300">We then invoke Nova’s folding scheme twice to fold the advice instances into a running instance. This can be viewed as a RoK: <span class="math">\\Pi_{2}:\\mathsf{EC}\\times\\mathsf{EC}^{2}\\rightarrow\\mathsf{EC}</span>. By sequentially composing the two RoKs, <span class="math">\\Pi_{2}\\circ(1_{\\mathsf{EC}}\\times\\Pi_{1})</span>, we get a multi-folding scheme, a generalization of folding schemes <em>[50]</em>:</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{CRR1CS},\\mathsf{EC})\\times\\mathsf{CRR1CS}\\rightarrow(\\mathsf{CRR1CS},\\mathsf{EC}).</span></p>

    <p class="text-gray-300">Crucially, the verifier of this folding scheme is efficiently represented in <span class="math">E_{1}</span>’s scalar field. Also, the instance defined over <span class="math">E_{2}</span> is constant-sized (e.g., <span class="math">\\approx 1,300</span> R1CS constraints).</p>

    <p class="text-gray-300">Non-interactivity. To design MicroNova’s IVC scheme, we require our folding scheme to be non-interactive in the standard model. As in prior work <em>[50, 52]</em>, we apply the Fiat-Shamir transformation <em>[37]</em> to achieve non-interactivity. Next, we heuristically instantiate the random oracle using a cryptographic hash function. Naturally, we can only heuristically argue the security of the resulting non-interactive folding scheme. Note that most recursive arguments require such an assumption <em>[24, 25, 26, 31, 48, 50, 52]</em>.</p>

    <p class="text-gray-300">###</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 MicroNova’s IVC scheme</h3>

    <p class="text-gray-300">We construct an IVC scheme from MicroNova’s folding scheme using an approach similar to Nova’s. We make a crucial modification to enable efficient verification of compressed IVC proofs.</p>

    <p class="text-gray-300">In Nova, the verifier has to perform a hash check to ensure that a value of public input in one of the R1CS instances in the proof is a hash of another instance and other material (a verification key, initial input and final output of IVC, etc.). For efficiency, MicroNova and its base Nova instantiate this hash function with Poseidon <em>[40]</em>. However, Poseidon is inefficient to verify on Ethereum and requires a large set of parameters to be stored on-chain. A naive solution is to use a general proof system: the prover proves that the required hash check holds by producing a SNARK. Unfortunately, this requires producing and verifying a SNARK. To address this, we design a light-weight RoK and we embed certain checks inside the recursive verifier circuit. This RoK enables the verifier circuit to use a circuit-friendly hash function (e.g., Poseidon) while allowing the on-chain verifier to use an on-chain-efficient hash function (e.g., Keccak). Furthermore, our approach does not require producing any additional SNARK, improving efficiency.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.2.1 An auxiliary RoK.</h4>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 4.2 (Hash relation).</h6>

    <p class="text-gray-300">Let <span class="math">n\\in\\mathbb{N}</span> denote a size bound. Let <span class="math">h</span> denote a hash function that can hash a vector of <span class="math">n</span> elements over a finite field <span class="math">\\mathbb{F}</span>. We define the hash relation over public parameter, instance, witness tuples as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{HASH}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(d,v),\\bot\\right)\\end{array}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda}),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">v\\in\\mathbb{F}^{n},\\\\ h(\\mathsf{pp},v)=d,\\end{array}\\right.\\right\\}. \\]</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 4.3 (Hash circuit relation).</h6>

    <p class="text-gray-300">Consider a subset of committed relaxed R1CS, where the public IO contains three values <span class="math">(c,d,f)\\in\\mathbb{F}^{3}</span>, a part of the non-deterministic witness is a vector <span class="math">v\\in\\mathbb{F}^{n}</span>, the structure, which we denote with <span class="math">\\mathsf{s}_{\\mathsf{HAC}}</span>, computes <span class="math">d\\leftarrow h(\\mathsf{pp},v)</span> and <span class="math">f\\leftarrow\\sum_{i=0}^{n-1}v_{i}\\cdot c^{i}</span>, <span class="math">u=1</span>, and <span class="math">\\overline{E}=\\mathsf{u}_{\\bot}.\\overline{E}</span>. Denote this subset with <span class="math">\\mathsf{HAC}</span>.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Construction 1 (RoK from <span class="math">\\mathsf{HASH}</span> to <span class="math">\\mathsf{HAC}</span>).</h6>

    <p class="text-gray-300">We construct a RoK as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{\\lambda})\\rightarrow\\mathsf{pp}</span>: produce parameters for <span class="math">h</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s}=\\bot)\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>: output <span class="math">(\\mathsf{pp},\\mathsf{pp})</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> are given as <span class="math">\\mathsf{HASH}</span> instance: <span class="math">(d,v)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\rightarrow\\mathcal{P}</span>: <span class="math">c\\in_{R}\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}</span>: The prover computes an instance-witness pair <span class="math">(\\mathsf{u},\\mathsf{w})\\in\\mathsf{HAC}</span> and sends <span class="math">\\overline{W}\\leftarrow\\mathsf{u}.\\overline{W}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">f=\\sum_{i=0}^{n-1}v_{i}\\cdot c^{i}</span>.</li>

      <li><span class="math">\\mathcal{P},\\mathcal{V}</span>: Produce the following instance-witness pair in <span class="math">\\mathsf{HAC}</span> (the verifier only outputs the instance):</li>

    </ol>

    <p class="text-gray-300"><span class="math">((\\mathsf{u}_{\\bot}.\\overline{E},1,\\overline{W},(c,d,f)),\\mathsf{w})\\in\\mathsf{HAC}</span></p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 4.1.</h6>

    <p class="text-gray-300">Construction 1 is an RoK of type <span class="math">\\mathsf{HASH}\\rightarrow\\mathsf{HAC}</span> with a single round, a constant communication complexity, and the prover’s work is linear in <span class="math">n</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The claimed efficiency is easy to check. Perfect completeness is easy to check. Given a valid instance <span class="math">(d,v)</span> in <span class="math">\\mathsf{HASH}</span>, <span class="math">d=h(v)</span>. For any <span class="math">c\\in\\mathbb{F}</span> sent by the verifier, the prover can compute a satisfying instance-witness pair in <span class="math">\\mathsf{HAC}</span>. Specifically, the prover computes a committed relaxed R1CS instance-witness pair <span class="math">(\\mathsf{u},\\mathsf{w})</span> that computes <span class="math">d\\leftarrow h(v)</span> and <span class="math">f\\leftarrow\\sum_{i=0}^{n-1}v_{i}\\cdot c^{i}</span> and places <span class="math">(c,d,f)</span> in the public IO. In the honest prover case, the relaxed instance is “strict” i.e., <span class="math">\\mathsf{u}.u=1</span> and <span class="math">\\mathsf{u}.\\overline{E}=\\mathsf{u}_{\\bot}.\\overline{E}</span>. This instance passes the verifier’s check in step 3. Furthermore, the instance output by the verifier matches that of the prover. So, the output instance-witness pair is in <span class="math">\\mathsf{HAC}</span> and is satisfying.</p>

    <p class="text-gray-300">We prove knowledge soundness as follows. Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the input instance and a malicious prover <span class="math">\\mathcal{P}^{\\star}</span> that succeds with probability <span class="math">\\epsilon</span>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda})</span>. Suppose on input a random tape <span class="math">\\mathsf{r}</span>, the adversary <span class="math">\\mathcal{A}</span> picks an <span class="math">\\mathsf{HASH}</span> instance <span class="math">(d,v)</span> and some auxiliary state <span class="math">\\mathsf{st}</span>. We construct an extractor <span class="math">\\mathcal{E}</span> that succeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in obtaining satisfying witness for the original instance.</p>

    <p class="text-gray-300">On input <span class="math">\\mathsf{r}</span>, <span class="math">\\mathcal{E}</span> first obtains the following tuple from the adversary:</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{s}=\\bot,(d,v),\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{r})</span></p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> then computes <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}=\\bot)</span>. Next, <span class="math">\\mathcal{E}</span> runs</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{u}=(\\mathsf{u}_{\\bot}.\\overline{E},1,\\overline{W},(c,d,f)),\\mathsf{w})\\leftarrow\\langle\\mathcal{P}^{\\star},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),(d,v),\\mathsf{st}).</span></p>

    <p class="text-gray-300">The extractor outputs <span class="math">\\bot</span> as the witness for the input instance. Since the extractor runs <span class="math">\\mathcal{P}^{\\star}</span> only once, it runs in expected polynomial time.</p>

    <p class="text-gray-300">We must now argue that <span class="math">\\bot</span> is a satisfying witness for the <span class="math">\\mathsf{HASH}</span> instance <span class="math">(d,v)</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. We are given that <span class="math">\\mathsf{w}</span> is a satisfying witness for the <span class="math">\\mathsf{HAC}</span> instance <span class="math">\\mathsf{u}=(\\mathsf{u}_{\\bot}.\\overline{E},1,\\overline{W},(c,d,f))</span> with structure <span class="math">\\mathsf{s}_{\\mathsf{HAC}}</span>. From this satisfying witness, parse out a value <span class="math">v^{\\prime}\\in\\mathbb{F}^{n}</span> such that <span class="math">d=h(\\mathsf{pp},v^{\\prime})</span> and <span class="math">f=\\sum_{i=0}^{n-1}v_{i}^{\\prime}\\cdot c^{i}</span>. From the verifier’s checks, we have that <span class="math">f=\\sum_{i=0}^{n-1}v_{i}\\cdot c^{i}</span>. Since <span class="math">c</span> is a random challenge and because <span class="math">h</span> is a collision-resistant hash function, by the Schwartz-Zippel lemma over <span class="math">c</span>, we have that <span class="math">v=v^{\\prime}</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Since <span class="math">h(\\mathsf{pp},v^{\\prime})=d</span> and <span class="math">v=v^{\\prime}</span>, we have that <span class="math">d=h(\\mathsf{pp},v)</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Therefore, <span class="math">(\\mathsf{pp},(d,v),\\bot)\\in\\mathsf{HASH}</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <p class="text-gray-300">Non-interactivity. We make the above RoK non-interactive using Fiat-Shamir transform and instantiate the random oracle in the plain model using a concrete hash function. As in prior work <em>[47]</em>, we assume that the resulting non-interactive RoK is knowledge sound. Let <span class="math">\\mathcal{H}</span> denote this hash function.</p>

    <p class="text-gray-300">In our concrete instantiation, we use an on-chain efficient hash function for <span class="math">\\mathcal{H}</span>, specifically Keccak.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">4.2.2 Constructing IVC from MicroNova’s folding scheme</h4>

    <p class="text-gray-300">Recall that an IVC scheme allows a prover to show that <span class="math">z_{n}=F^{(n)}(z_{0})</span> for some count <span class="math">n</span>, initial input <span class="math">z_{0}</span>, and output <span class="math">z_{n}</span>. We now show how to construct an IVC scheme for a non-deterministic, polynomial-time computable function <span class="math">F</span> using our non-interactive folding scheme for committed relaxed R1CS (§4.1). In MicroNova’s folding scheme, the “running” instance is a pair of committed relaxed R1CS instances, one encoding the correct execution of <span class="math">F^{\\prime}</span> and another encoding the correct execution of a group scalar multiplication operation followed by a group point addition. So, in the construction below, for a trivially satisfying running instance, we use <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{u}_{\\perp})</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Construction 2 (IVC).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{NIFS}=(\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span> be the non-interactive folding scheme for committed relaxed R1CS (§4.1). Consider a polynomial-time function <span class="math">F</span> that takes non-deterministic input, and a cryptographic hash function <span class="math">\\mathsf{hash}</span>. We define our augmented function <span class="math">F^{\\prime}</span> as follows (all arguments to <span class="math">F^{\\prime}</span> are taken as non-deterministic advice):</p>

    <p class="text-gray-300"><span class="math">F^{\\prime}(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi,r_{i},r_{i+1},c)\\rightarrow\\mathsf{x}</span>:</p>

    <p class="text-gray-300">If <span class="math">i=0</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">m\\leftarrow(\\mathsf{vk},i+1,z_{0},F(z_{0},\\omega_{0}),(\\mathsf{u}_{\\perp},\\mathsf{u}_{\\perp}),r_{i+1})</span>,</li>

      <li>compute <span class="math">d\\leftarrow\\mathsf{hash}(m)</span>, and <span class="math">f\\leftarrow\\sum_{i=0}^{n-1}m_{i}\\cdot c^{i}</span>,</li>

      <li>output <span class="math">(c,d,f)</span>.</li>

    </ol>

    <p class="text-gray-300">Otherwise,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse <span class="math">\\mathsf{u}_{i}.\\mathsf{x}</span> as <span class="math">(c,d,f)</span>, where <span class="math">\\mathsf{u}_{i}.\\mathsf{x}</span> is the public IO of <span class="math">\\mathsf{u}_{i}</span>,</li>

      <li>check that <span class="math">d=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i})</span></li>

      <li>check that <span class="math">(\\mathsf{u}_{i}.\\overline{E},\\mathsf{u}_{i}.u)=(\\mathsf{u}_{\\perp}.\\overline{E},1)</span>,</li>

      <li>compute <span class="math">\\mathsf{U}_{i+1}\\leftarrow\\mathsf{NIFS}.\\mathsf{V}(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},\\pi)</span>, and</li>

      <li><span class="math">m\\leftarrow(\\mathsf{vk},i+1,z_{0},F(z_{i},\\omega_{i}),\\mathsf{U}_{i+1},r_{i+1})</span>,</li>

      <li>compute <span class="math">d\\leftarrow\\mathsf{hash}(m)</span>, and <span class="math">f\\leftarrow\\sum_{i=0}^{n-1}m_{i}\\cdot c^{i}</span>,</li>

      <li>output <span class="math">(c,d,f)</span>.</li>

    </ol>

    <p class="text-gray-300">Because <span class="math">F^{\\prime}</span> can be computed in polynomial time, it can be represented as a committed relaxed R1CS structure. We assume that there is a deterministic procedure, which we denote with AUGMENT, that takes as input a function <span class="math">F</span> and public parameters <span class="math">\\mathsf{pp}</span> sampled by <span class="math">\\mathcal{G}</span> of the IVC scheme, and outputs the committed relaxed R1CS structure corresponding to <span class="math">F^{\\prime}</span>, which we denote with <span class="math">\\mathsf{s}_{F^{\\prime}}</span>. Note that this assumes a canonical representation of the message <span class="math">m</span> as a vector of <span class="math">n</span> field elements (<span class="math">n</span> is a constant). Let <span class="math">(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1})\\leftarrow\\mathsf{trace}(F^{\\prime},(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi,r_{i},r_{i+1},c))</span> denote the satisfying committed relaxed R1CS instance-witness pair <span class="math">(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1})</span> for the execution of <span class="math">F^{\\prime}</span>, as a committed Relaxed R1CS with structure <span class="math">\\mathsf{s}_{F^{\\prime}}</span>, on non-deterministic advice <span class="math">(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi,r_{i},r_{i+1},c)</span>. Note that <span class="math">\\mathsf{trace}</span> is a randomized algorithm that internally samples randomness to create hiding commitments inside <span class="math">\\mathsf{u}_{i+1}</span>. Additionally, note that <span class="math">\\mathsf{trace}</span> sets <span class="math">\\mathsf{u}_{i+1}.\\overline{E}=\\mathsf{u}_{\\perp}.\\overline{E}</span> and that <span class="math">\\mathsf{u}_{i+1}.u=1</span>.</p>

    <p class="text-gray-300">We define the IVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda})\\rightarrow\\mathsf{pp}</span>: Output <span class="math">\\mathsf{NIFS}.\\mathsf{G}(1^{\\lambda})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>compute <span class="math">\\mathsf{s}_{F^{\\prime}}\\leftarrow\\mathsf{AUGMENT}(\\mathsf{pp},F)</span>;</li>

      <li>compute <span class="math">(\\mathsf{pk}_{\\mathsf{fs}},\\mathsf{vk}_{\\mathsf{fs}})\\leftarrow\\mathsf{NIFS}.\\mathsf{K}(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}})</span>;</li>

      <li>output <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow((\\mathsf{pp},F,\\mathsf{pk}_{\\mathsf{fs}}),(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}},\\mathsf{vk}_{\\mathsf{fs}}))</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i})\\rightarrow\\Pi_{i+1}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">i=0</span>, <span class="math">(\\mathsf{U}_{i+1},\\mathsf{W}_{i+1},\\pi)\\leftarrow((\\mathsf{u}_{\\perp},\\mathsf{u}_{\\perp}),(\\mathsf{w}_{\\perp},\\mathsf{w}_{\\perp}),\\perp)</span>;</li>

      <li>otherwise, parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i})</span> and compute <span class="math">(\\mathsf{U}_{i+1},\\mathsf{W}_{i+1},\\pi)\\leftarrow\\mathsf{NIFS}.\\mathsf{P}(\\mathsf{pk},(\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}))</span>;</li>

      <li>sample <span class="math">r_{i+1}\\in\\mathbb{F}</span> randomly;</li>

      <li>compute <span class="math">c\\leftarrow\\mathcal{H}(\\mathsf{vk},i+1,z_{0},F(z_{i},\\omega_{i}),\\mathsf{U}_{i+1},r_{i+1})</span>;</li>

      <li>compute <span class="math">(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1})\\leftarrow\\mathsf{trace}(F^{\\prime},(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi,r_{i},r_{i+1},c))</span>, and</li>

      <li>output <span class="math">\\Pi_{i+1}\\leftarrow((\\mathsf{U}_{i+1},\\mathsf{W}_{i+1}),(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1}),r_{i+1})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi_{i})\\rightarrow\\{0,1\\}</span>:</p>

    <p class="text-gray-300">If <span class="math">i=0</span>, check that <span class="math">z_{i}=z_{0}</span>; otherwise,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i})</span>,</li>

      <li>parse <span class="math">\\mathsf{u}_{i}.\\mathsf{x}</span> as <span class="math">(c,d,f)</span>, where <span class="math">\\mathsf{u}_{i}.\\mathsf{x}</span> is the public IO of <span class="math">\\mathsf{u}_{i}</span>,</li>

      <li>check that <span class="math">d=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i})</span>,</li>

      <li>check that <span class="math">(\\mathsf{u}_{i}.\\overline{E},\\mathsf{u}_{i}.u)=(\\mathsf{u}_{\\perp}.\\overline{E},1)</span>, and</li>

      <li>check that <span class="math">\\mathsf{W}_{i}</span> and <span class="math">\\mathsf{w}_{i}</span> are satisfying witnesses to <span class="math">\\mathsf{U}_{i}</span> and <span class="math">\\mathsf{u}_{i}</span> respectively using <span class="math">\\mathsf{vk}.\\mathsf{pp}</span> and <span class="math">\\mathsf{vk}.\\mathsf{s}_{F^{\\prime}}</span>.</li>

    </ol>

    <h6 id="sec-32" class="text-base font-medium mt-4">Lemma 4.2.</h6>

    <p class="text-gray-300">Construction 2 is an IVC scheme that satisfies completeness and knowledge soundness.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof Intuition (Completeness).</h6>

    <p class="text-gray-300">Given a satisfying IVC proof <span class="math">\\Pi_{i}=((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),r_{i})</span> suppose that <span class="math">\\mathcal{P}</span> outputs <span class="math">\\Pi_{i+1}=((\\mathsf{U}_{i+1},\\mathsf{W}_{i+1}),(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1}),r_{i+1})</span>. Because <span class="math">\\Pi_{i}</span> is a valid IVC proof, <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> and <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> are satisfying instance-witness pairs. Because <span class="math">(\\mathsf{U}_{i+1},\\mathsf{W}_{i+1})</span> is obtained by folding <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> and <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span>, it must be satisfying by the folding scheme’s completeness. By construction, <span class="math">(\\mathsf{u}_{i+1},\\mathsf{w}_{i+1})</span> is satisfying instance-witness pair that satisfies the IVC verifier’s auxiliary checks including the ones that involve <span class="math">r_{i+1}</span>. Thus, <span class="math">\\Pi_{i+1}</span> is satisfying. ∎</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof Intuition (knowledge soundness).</h6>

    <p class="text-gray-300">For function <span class="math">F</span>, constant <span class="math">n</span>, <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},F)</span>, consider an adversary <span class="math">\\mathcal{P}^{<em>}</span> that outputs <span class="math">(z_{0},z,\\Pi)</span> such that <span class="math">\\mathcal{V}(\\mathsf{vk},(n,z_{0},z),\\Pi)=1</span> with probability <span class="math">\\epsilon</span>. We construct an extractor <span class="math">\\mathcal{E}</span> that with input <span class="math">(\\mathsf{pp},z_{0},z)</span>, outputs <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> such that by computing <span class="math">z_{i}\\leftarrow F(z_{i-1},\\omega_{i-1})</span> for all <span class="math">i\\in\\{1,\\ldots,n\\}</span> we have that <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. We show inductively that <span class="math">\\mathcal{E}</span> can construct an extractor <span class="math">\\mathcal{E}_{i}</span> that outputs <span class="math">(z_{i},\\ldots,z_{n-1})</span>, <span class="math">(\\omega_{i},\\ldots,\\omega_{n-1})</span>, and <span class="math">\\Pi_{i}</span> such that for all <span class="math">j\\in\\{i+1,\\ldots,n\\}</span>, <span class="math">z_{j}=F(z_{j-1},\\omega_{j-1})</span>, <span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span>, and <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Then, because in the base case when <span class="math">i=0</span>, <span class="math">\\mathcal{V}</span> checks that <span class="math">z_{0}=z_{i}</span>, it is sufficient for <span class="math">\\mathcal{E}</span> to run <span class="math">\\mathcal{E}_{0}</span> to retrieve values <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span>. Initially, <span class="math">\\mathcal{E}_{n}</span> simply runs the assumed <span class="math">\\mathcal{P}^{</em>}</span> to get a satisfying <span class="math">\\Pi_{n}</span>. Given extractor <span class="math">\\mathcal{E}_{i}</span> that</p>

    <p class="text-gray-300">satisfies the inductive hypothesis, we can construct extractor <span class="math">\\mathcal{E}_{i-1}</span>. Note that this proof is identical to the knowledge soundness proof of Nova’s IVC scheme. ∎</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">4.3 Compressing MicroNova’s IVC Proofs</h3>

    <p class="text-gray-300">MicroNova’s IVC proofs are linear in the size of <span class="math">F</span>, so they are not efficient to verify on a blockchain. We now discuss how to compress MicroNova’s IVC proofs so they are exponentially smaller and faster to verify. In theory, one can address this problem with any SNARK for <span class="math">\\mathsf{NP}</span>. Specifically, the prover can produce a SNARK proving that it knows <span class="math">\\Pi_{i}</span> such that IVC verifier <span class="math">\\mathcal{V}</span> accepts for statement <span class="math">(i,z_{0},z_{i})</span>. Unfortunately, employing an off-the-shelf SNARK makes the overall solution impractical as the SNARK prover must prove, among other things, the knowledge of vectors whose commitments equal a particular value; this requires encoding a linear number of group scalar multiplications in R1CS. To address this, we design SNARKs tailored for our purpose and we describe it in Section 5. Below, we describe how to use a SNARK to prove the knowledge of a valid IVC proof. Formally, we design a SNARK for the following relation.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 4.4 (IVC proof validity relation).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IVC}=(\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span> denote the IVC scheme described in Construction 2. We define the relation <span class="math">\\mathcal{R}_{\\mathsf{VIVC}}</span> over public parameter, structure, instance, and witness tuples as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{VIVC}}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},F,(n,z_{0},z_{n}),\\Pi_{n}\\right)\\end{array}\\right.\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}\\mathsf{vk}\\leftarrow\\mathsf{IVC},\\mathsf{K}(\\mathsf{pp},F),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{IVC},\\mathsf{V}(\\mathsf{vk},(n,z_{0},z_{n}),\\Pi)=1\\end{array}\\right. \\] ∎</p>

    <p class="text-gray-300">In a nutshell, we leverage the fact that <span class="math">\\Pi</span> contains three committed relaxed R1CS instance-witness pairs. So, <span class="math">\\mathcal{P}</span> first folds the instance-witness pairs <span class="math">(\\mathsf{u},\\mathsf{w})</span> and <span class="math">(\\mathsf{U},\\mathsf{W})</span> in <span class="math">\\Pi</span> to produce a folded instance-witness pair <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span>, using <span class="math">\\mathsf{NIFS},\\mathsf{P}</span>. Next, <span class="math">\\mathcal{P}</span> runs <span class="math">\\mathsf{SNARK},\\mathsf{P}</span> to produce a proof <span class="math">\\pi</span> that it knows a valid witness for <span class="math">\\mathsf{U}^{\\prime}</span>. The compressed proof consists of <span class="math">(\\mathsf{U},\\mathsf{u},\\pi)</span>. When <span class="math">\\mathcal{V}</span> verifies <span class="math">\\mathcal{P}</span>’s proof, it will have to perform a hash check correspondance between <span class="math">\\mathsf{u}</span> and <span class="math">\\mathsf{U}</span>, where the hash function used is the same as the one used in <span class="math">F^{\\prime}</span> (i.e., Poseidon in our case). To avoid this, we employ an auxiliary RoK (Construction 1) allowing the verifier to instead use an on-chain-efficient hash function (e.g., Keccak).</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Construction 3 (A SNARK of a Valid IVC Proof).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{IVC}=(\\mathsf{G},\\mathsf{K},\\mathsf{P},\\mathsf{V})</span> denote the IVC scheme in Construction 2, let <span class="math">\\mathsf{NIFS}</span> denote the non-interactive folding scheme (§4.1), and let <span class="math">\\mathsf{hash}</span> and <span class="math">\\mathcal{H}</span> denote two cryptographic hash functions, <span class="math">\\mathsf{hash}</span> is circuit-friendly (e.g., Poseidon) and <span class="math">\\mathcal{H}</span> is on-chain-friendly (e.g., Keccak). Let <span class="math">\\mathsf{SNARK}</span> denote a SNARK for committed relaxed R1CS that has the same public parameter generator algorithm as the IVC scheme. We construct a SNARK <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for the relation <span class="math">\\mathcal{R}_{\\mathsf{VIVC}}</span> (Definition 4.4) as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda})\\rightarrow\\mathsf{pp}</span>: Output <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{SNARK},\\mathsf{G}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{IVC}},\\mathsf{vk}_{\\mathsf{IVC}})\\leftarrow\\mathsf{IVC},\\mathsf{K}(\\mathsf{pp},F)</span>.</li>

      <li>Compute <span class="math">\\mathsf{s}_{F^{\\prime}}\\leftarrow\\mathsf{AUGMENT}(\\mathsf{pp},F)</span>.</li>

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{F^{\\prime}}},\\mathsf{vk}_{\\mathsf{F^{\\prime}}})\\leftarrow\\mathsf{SNARK},\\mathsf{K}(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{EC}},\\mathsf{vk}_{\\mathsf{EC}})\\leftarrow\\mathsf{SNARK},\\mathsf{K}(\\mathsf{pp},\\mathsf{s}_{\\mathsf{EC}})</span>.</li>

      <li>Output <span class="math">((\\mathsf{pk}_{\\mathsf{IVC}},\\mathsf{pk}_{\\mathsf{F^{\\prime}}},\\mathsf{pk}_{\\mathsf{EC}}),(\\mathsf{vk}_{\\mathsf{IVC}},\\mathsf{vk}_{\\mathsf{F^{\\prime}}},\\mathsf{vk}_{\\mathsf{EC}}))</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(n,z_{0},z_{n}),\\Pi_{n}))\\rightarrow\\pi</span>:</p>

    <p class="text-gray-300">If <span class="math">n=0</span>, output <span class="math">\\bot</span>; otherwise,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse <span class="math">\\Pi_{n}</span> as <span class="math">((\\mathsf{U}_{n},\\mathsf{W}_{n}),(\\mathsf{u}_{n},\\mathsf{w}_{n}),r_{n})</span></li>

      <li><span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime},\\pi_{n})\\leftarrow\\mathsf{NIFS},\\mathsf{P}(\\mathsf{pk}_{\\mathsf{IVC}},((\\mathsf{U}_{n},\\mathsf{W}_{n}),(\\mathsf{u}_{n},\\mathsf{w}_{n})))</span></li>

      <li>parse <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span> as <span class="math">((\\mathsf{U}_{\\mathsf{F^{\\prime}}},\\mathsf{U}_{\\mathsf{EC}}),(\\mathsf{W}_{\\mathsf{F^{\\prime}}},\\mathsf{W}_{\\mathsf{EC}}))</span></li>

      <li>compute <span class="math">\\pi_{\\mathsf{F^{\\prime}}}\\leftarrow\\mathsf{SNARK},\\mathsf{P}(\\mathsf{pk}_{\\mathsf{F^{\\prime}}},\\mathsf{U}_{\\mathsf{F^{\\prime}}},\\mathsf{W}_{\\mathsf{F^{\\prime}}})</span></li>

      <li>compute <span class="math">\\pi_{\\mathsf{EC}}\\leftarrow\\mathsf{SNARK},\\mathsf{P}(\\mathsf{pk}_{\\mathsf{EC}},\\mathsf{U}_{\\mathsf{EC}},\\mathsf{W}_{\\mathsf{EC}})</span></li>

      <li>output <span class="math">(\\mathsf{U}_{n},\\mathsf{u}_{n},r_{n},\\pi_{n},\\pi_{\\mathsf{F^{\\prime}}},\\pi_{\\mathsf{EC}})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(n,z_{0},z_{n}),\\pi)\\rightarrow\\{0,1\\}</span>:</p>

    <p class="text-gray-300">If <span class="math">n=0</span>, check that <span class="math">z_{0}=z_{i}</span>; otherwise,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse <span class="math">\\pi</span> as <span class="math">(\\mathsf{U}_{n},\\mathsf{u}_{n},r_{n},\\pi_{n},\\pi_{\\mathsf{F^{\\prime}}},\\pi_{\\mathsf{EC}})</span>,</li>

      <li>parse public IO <span class="math">\\mathsf{u}_{n},\\mathsf{x}</span> as <span class="math">(c,d,f)</span>,</li>

      <li><span class="math">m\\leftarrow(\\mathsf{vk}_{\\mathsf{IVC}},i,z_{0},z_{n},\\mathsf{U}_{n},r_{n})</span>,</li>

      <li>check that <span class="math">c=\\mathcal{H}(m)</span> and <span class="math">f=\\sum_{i=0}^{n-1}m_{i}\\cdot c^{i}</span>,</li>

      <li>check that <span class="math">(\\mathsf{u}.\\overline{E},\\mathsf{u}.u)=(\\mathsf{u}_{\\bot}.\\overline{E},1)</span>,</li>

      <li>compute <span class="math">\\mathsf{U}^{\\prime}\\leftarrow\\mathsf{NIFS},\\mathsf{V}(\\mathsf{vk}_{\\mathsf{IVC}},\\mathsf{U}_{n},\\mathsf{u}_{n},\\pi_{n})</span>,</li>

      <li>parse <span class="math">\\mathsf{U}^{\\prime}</span> as <span class="math">(\\mathsf{U}_{\\mathsf{F^{\\prime}}},\\mathsf{U}_{\\mathsf{EC}})</span></li>

      <li>check that <span class="math">\\mathsf{SNARK},\\mathsf{V}(\\mathsf{vk}_{\\mathsf{F^{\\prime}}},\\mathsf{U}_{\\mathsf{F^{\\prime}}},\\pi_{\\mathsf{F^{\\prime}}})=1</span>, and</li>

      <li>check that <span class="math">\\mathsf{SNARK},\\mathsf{V}(\\mathsf{vk}_{\\mathsf{EC}},\\mathsf{U}_{\\mathsf{EC}},\\pi_{\\mathsf{EC}})=1</span>.</li>

    </ol>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 4.1 (A SNARK of a Valid IVC Proof).</h6>

    <p class="text-gray-300">Construction 3 is a SNARK of a valid IVC proof produced by Construction 2.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof Intuition.</h6>

    <p class="text-gray-300">Completeness and knowledge soundness hold due to the completeness and knowledge soundness of the underlying SNARK, the auxiliary RoK (Construction 1), and the non-interactive folding scheme. In more detail, by the knowledge soundness of the non-interactive auxiliary RoK (§4.2.1), <span class="math">\\mathcal{V}</span>’s check in step (3) and (4) is equivalent to checking that <span class="math">d=\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{IVC}},i,z_{0},z_{n},\\mathsf{U}_{n},r_{n})</span>. Assuming that the non-interactive folding scheme satisfies succinctness (e.g., with Pedersen commitments), succinctness holds due to the fact that <span class="math">\\mathsf{u}</span>, <span class="math">\\mathsf{U}</span>, and <span class="math">\\pi</span> are succinct, and due to the succinctness of the underling SNARK. ∎</p>

    <h2 id="sec-40" class="text-2xl font-bold">5 MicroNova’s SNARKs for R1CS</h2>

    <p class="text-gray-300">MicroNova’s IVC proof compression layer (§4.3) requires two SNARKs: (1) a SNARK to prove a committed relaxed R1CS instance encoding the correct execution of <span class="math">F^{\\prime}</span>, and (2) a SNARK to prove an instance in <span class="math">\\mathsf{EC}</span>, which itself a subset of committed relaxed R1CS. In MicroNova, the first instance is defined over a pairing-friendly elliptic curve <span class="math">E_{1}</span> (e.g., BN254), and the second instance is defined over a non-pairing-friendly elliptic curve <span class="math">E_{2}</span> (e.g., Grumpkin), and <span class="math">E_{1}/E_{2}</span> is a 2-cycle of elliptic curves (i.e., the base field of <span class="math">E_{1}</span> equals the scalar field of <span class="math">E_{2}</span> and vice versa). We now</p>

    <p class="text-gray-300">describe two different adaptations of Spartan <em>[59]</em>. We refer to these as MicroSpartan and DelegatedSpartan respectively.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.1 MicroSpartan (for a pairing-friendly curve)</h3>

    <p class="text-gray-300">This section describes MicroSpartan, a SNARK that builds on Spartan <em>[59]</em> but minimizes its verifier time and proof sizes. Recall that Spartan runs several sequential invocations of the sum-check protocol and reduces the satisfiability of committed relaxed R1CS to proving evaluations of two multilinear polynomials encoding the witness <span class="math">W</span> and error terms <span class="math">E</span> and of three sparse multilinear polynomials encoding the R1CS structure <span class="math">(A,B,C)</span>.</p>

    <p class="text-gray-300">In contrast, MicroSpartan reduces the satisfiability of committed relaxed R1CS to a collection of sum-check instances and two lookup checks. The lookup instances can be proven with a straightforward use of lookup arguments. A state-of-the-art sum-check-based option is Lasso <em>[63]</em>, but it uses multiple invocations of the sum-check protocol. Instead, we employ a bit more expensive logUp protocol <em>[24, 42]</em>, which requires the prover to send additional polynomial commitments. With those additional commitments, the lookup check reduces to a handful of sum-check instances. The prover then invokes the sum-check protocol <em>[54]</em> to prove all sum-check instances including the ones arising from lookup checks. At the end of the sum-check protocol, all committed polynomials are queried at the same point <span class="math">r</span>, where <span class="math">r</span> is chosen over the course of the sum-check protocol. Since all polynomials are evaluated at the same random point, by leveraging homomorphic properties of the polynomial commitments, the verifier requests an evaluation of a single polynomial at a single point. In other words, the prover and the verifier fold evaluation claims about all polynomial commitments into a single evaluation claim, so the prover has to produce a single polynomial evaluation argument about the folded polynomial. Overall, MicroNova makes a single invocation of the sum-check protocol followed by a single invocation of the polynomial evaluation argument. For the polynomial evaluation argument, MicroNova uses HyperKZG (§6), which reduces the single multilinear evaluation into a collection of univariate polynomial evaluation instances, which are proven with a batched version of KZG.</p>

    <p class="text-gray-300">We recall the sum-check relation SC <em>[51, Definition 6]</em>, and introduce additional relations. For <span class="math">N\\in\\mathbb{N}</span>, let <span class="math">\\mathsf{eq}_{\\tau}</span>, where <span class="math">\\tau\\in\\mathbb{F}^{\\log N}</span>, denote the multilinear polynomial <span class="math">g</span> such that for all <span class="math">i\\in\\{0,1\\}^{\\log N}</span>, <span class="math">g(i)=\\mathsf{eq}(\\tau,i)</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 5.1 (Structured lookup relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size parameters <span class="math">n,m\\in\\mathbb{N}</span>. We define the lookup relation <span class="math">\\mathsf{SLKP}</span> over public parameter, instance, witness tuples as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{SLKP}=\\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(\\overline{a},\\overline{v}),(\\tau,a,v)\\right)\\end{array}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}v,a\\in\\mathbb{F}^{m},\\mathsf{eq}_{\\tau}\\in\\mathbb{F}^{n},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\forall i\\in[m].\\ v_{i}=\\tau_{a_{i}},\\\\ \\mathsf{Com}(\\mathsf{pp},a)=\\overline{a},\\\\ \\mathsf{Com}(\\mathsf{pp},v)=\\overline{v},\\end{array}\\right.\\right\\}. \\]</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 5.2 (Piece-wise lookup relation).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Consider size parameters <span class="math">n,m,\\ell\\in\\mathbb{N}</span>. We define the lookup relation <span class="math">\\mathsf{PLKP}</span> over public parameter, instance, witness tuples as follows. <span class="math">\\mathsf{PLKP}=</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left\\{\\begin{array}[]{l}\\left(\\mathsf{pp},(\\overline{w},\\overline{a},\\overline{v}),(\\mathsf{x},u,a,v)\\right)\\end{array}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}z=(w,u,\\mathsf{x}),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">v,a\\in\\mathbb{F}^{m},\\mathsf{x}\\in\\mathbb{F}^{\\ell},\\\\ u\\in\\mathbb{F},z\\in\\mathbb{F}^{n},\\\\ \\forall i\\in[m].\\ v_{i}=z_{a_{i}},\\\\ \\mathsf{Com}(\\mathsf{pp},w)=\\overline{w},\\\\ \\mathsf{Com}(\\mathsf{pp},a)=\\overline{a},\\\\ \\mathsf{Com}(\\mathsf{pp},v)=\\overline{v},\\end{array}\\right.\\right\\}. \\]</p>

    <p class="text-gray-300">Construction 4 (MicroSpartan: A RoK CRR1CS <span class="math">\\rightarrow</span> LKP). Let <span class="math">\\Pi=(\\mathsf{Gen},\\mathsf{Com})</span> denote an additively-homomorphic commitment scheme for vectors over finite field <span class="math">\\mathbb{F}</span>. Let <span class="math">m</span> denote the number of constraints and <span class="math">n</span> denote the number of witness variables for members of CRR1CS. Let <span class="math">N_{A},N_{B},N_{C}</span> denote the number of non-zero entries in R1CS matrices. Let <span class="math">N=N_{A}+N_{B}+N_{C}</span>. WLOG, <span class="math">N</span> is a power of 2. Suppose that matrices are represented in the COO format as a vector of tuples. Let <span class="math">M</span> denote the concatenation of sparse representations of <span class="math">A,B,C</span>. We construct a RoK as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{\\lambda})\\rightarrow\\mathsf{pp}</span>: output <span class="math">\\Pi.\\mathsf{Gen}(1^{\\lambda},N)</span></li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s})\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>: compute <span class="math">\\mathsf{row},\\mathsf{col},\\mathsf{val}_{A},\\mathsf{val}_{B}</span>, <span class="math">\\mathsf{val}_{C}\\in\\mathbb{F}^{N}</span> as follows.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">(i,(r,c,v))\\in M</span>, <span class="math">\\mathsf{row}[i]=r</span>, <span class="math">\\mathsf{col}[i]=c</span>.</li>

      <li>for <span class="math">(i,(r,c,v))\\in A</span>, <span class="math">\\mathsf{val}_{A}[i]=v</span>.</li>

      <li>for <span class="math">(i,(r,c,v))\\in B</span>, <span class="math">\\mathsf{val}_{B}[i+n_{A}]=v</span>.</li>

      <li>for <span class="math">(i,(r,c,v))\\in C</span>, <span class="math">\\mathsf{val}_{C}[i+n_{A}+n_{B}]=v</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{pk}\\leftarrow(\\mathsf{row},\\mathsf{col},\\mathsf{val}_{A},\\mathsf{val}_{B},\\mathsf{val}_{C})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}\\leftarrow(\\mathsf{Com}(\\mathsf{pp},\\mathsf{row}),\\mathsf{Com}(\\mathsf{pp},\\mathsf{col}),\\mathsf{Com}(\\mathsf{pp},\\mathsf{val}_{A}),</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp},\\mathsf{val}_{B}),\\mathsf{Com}(\\mathsf{pp},\\mathsf{val}_{C}))</span></p>

    <p class="text-gray-300">Output <span class="math">(\\mathsf{pk},\\mathsf{vk})</span></p>

    <p class="text-gray-300">The prover and the verifier are given an instance in CRR1CS: <span class="math">(\\overline{E},\\overline{W},u,\\mathsf{x})</span>. The prover is additionally provided with a witness: <span class="math">(E,W)</span>. Let <span class="math">z=(w,u,\\mathsf{x})</span>. WLOG, we assume that all vectors are padded with zeros to be of size <span class="math">N</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}</span>: The prover sends commitments <span class="math">(\\overline{a},\\overline{b},\\overline{c})</span>, where <span class="math">a=Az,b=Bz,c=Cz</span>,<span class="math">\\overline{a}=\\mathsf{Com}(\\mathsf{pp},a),\\overline{b}=\\mathsf{Com}(\\mathsf{pp},b),\\overline{c}=\\mathsf{Com}(\\mathsf{pp},c)</span>.</li>

      <li><span class="math">\\mathcal{V}\\rightarrow\\mathcal{P}</span>: Sample and send <span class="math">\\tau\\in_{R}\\mathbb{F}^{\\log N}</span>.</li>

      <li><span class="math">\\mathcal{P}\\rightarrow\\mathcal{V}</span>: The prover sends <span class="math">(v_{a},v_{b},v_{c},\\overline{L_{\\mathsf{r}}},\\overline{L_{\\mathsf{c}}})</span>, where <span class="math">v_{a}=\\widetilde{a}(\\tau),v_{b}=\\widetilde{b}(\\tau),v_{c}=\\widetilde{c}(\\tau)</span>, and for all <span class="math">i\\in[N]</span>, <span class="math">L_{\\mathsf{r}}[i]=\\mathsf{eq}_{\\tau}[\\mathsf{row}[i]]</span> and <span class="math">L_{\\mathsf{c}}[i]=z[\\mathsf{col}[i]]</span>.</li>

      <li><span class="math">\\mathcal{V}\\rightarrow\\mathcal{P}</span>: Sample and send a random value <span class="math">c\\in\\mathbb{F}</span></li>

      <li>The prover and the verifier output the following instance-witness pairs (the verifier only outputs instances):</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(F_{1},G_{1}),(\\overline{a},\\overline{b},\\overline{c},\\overline{E},u,\\tau),(a,b,c,E))\\in\\mathsf{SC},</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">G_{1}((a,b,c,E),(u,\\tau))=(a,b,c,E,\\mathsf{eq}_{\\tau})</span></p>

    <p class="text-gray-300"><span class="math">F_{1}(a(x),b(x),c(x),E(x),\\mathsf{eq}_{\\tau})=\\mathsf{eq}_{\\tau}(x)\\cdot</span></p>

    <p class="text-gray-300"><span class="math">(a(x)\\cdot b(x)-u\\cdot c(x)-E(x))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(F_{2},G_{2}),(v_{a},\\overline{a},\\tau),(a))\\in\\mathsf{SC}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">G_{2}(a,\\tau)=(a,\\mathsf{eq}_{\\tau})</span></p>

    <p class="text-gray-300"><span class="math">F_{2}(a(x),\\mathsf{eq}_{\\tau}(x))=\\mathsf{eq}_{\\tau}(x)\\cdot a(x)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(F_{3},G_{3}),(v_{b},\\overline{b},\\tau),(b))\\in\\mathsf{SC}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">G_{3}(b,\\tau)=(b,\\mathsf{eq}_{\\tau})</span></p>

    <p class="text-gray-300"><span class="math">F_{3}(b(x),\\mathsf{eq}_{\\tau}(x))=\\mathsf{eq}_{\\tau}(x)\\cdot b(x)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(F_{4},G_{4}),(v_{c},\\overline{c},\\tau),(c))\\in\\mathsf{SC}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">G_{4}(c,\\tau)=(c,\\mathsf{eq}_{\\tau})</span></p>

    <p class="text-gray-300"><span class="math">F_{4}(c(x),\\mathsf{eq}_{\\tau}(x))=\\mathsf{eq}_{\\tau}(x)\\cdot c(x)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(F_{5},G_{5}),\\mathsf{u},\\mathsf{w})\\in\\mathsf{SC}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">T=v_{a}+c\\cdot v_{b}+c^{2}\\cdot v_{c}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}=(T,(\\overline{L_{\\mathsf{r}}},\\overline{L_{\\mathsf{c}}},\\overline{w},\\overline{\\mathsf{val}_{A}},\\overline{\\mathsf{val}_{B}},\\overline{\\mathsf{val}_{C}}),(\\mathsf{x},u,c))</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{w}=(L_{\\mathsf{r}},L_{\\mathsf{c}},w,\\mathsf{val}_{A},\\mathsf{val}_{B},\\mathsf{val}_{C})</span></p>

    <p class="text-gray-300"><span class="math">G_{5}(\\mathsf{w},(\\mathsf{x},u,c))=(L_{\\mathsf{r}},L_{\\mathsf{c}},z=(w,u,\\mathsf{x}),\\mathsf{val})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{val}=\\mathsf{val}_{A}+c\\cdot\\mathsf{val}_{B}+c^{2}\\cdot\\mathsf{val}_{C}</span></p>

    <p class="text-gray-300"><span class="math">F_{5}(L_{\\mathsf{r}}(x),L_{\\mathsf{c}}(x),z(x),\\mathsf{val}(x))=L_{\\mathsf{r}}(x)\\cdot\\mathsf{val}(x)\\cdot L_{\\mathsf{c}}(x)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pp},(\\overline{\\mathsf{row}},\\overline{L_{\\mathsf{r}}}),(\\tau,\\mathsf{row},\\mathsf{L_{\\mathsf{r}}}))\\in\\mathsf{SLKP}</span></li>

      <li><span class="math">(\\mathsf{pp},(\\overline{w},\\overline{\\mathsf{col}},\\overline{L_{\\mathsf{c}}}),(\\mathsf{x},u,\\mathsf{col},\\mathsf{L_{\\mathsf{c}}}))\\in\\mathsf{PLKP}</span></li>

    </ul>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof Intuition.</h6>

    <p class="text-gray-300">The construction above essentially streamlines the checks done in Spartan <em>[59]</em>. The first sum-check instance checks if the constraints are satisfying assuming that polynomials <span class="math">a,b,c</span> are correct. The last sum-check instance recomputes <span class="math">(\\widetilde{Az}(\\tau),\\widetilde{Bz}(\\tau),\\widetilde{Cz}(\\tau))</span> assuming the validity of <span class="math">L_{\\mathsf{r}}</span> and <span class="math">L_{\\mathsf{c}}</span>. By the construction of <span class="math">\\mathsf{val}</span> polynomials, this sum-check instance recomputes the claimed values via preprocessed R1CS matrices and <span class="math">w</span>. The two lookup checks validate the correctness of <span class="math">(L_{\\mathsf{r}},L_{\\mathsf{c}})</span> using preprocessed address vectors. We still need to validate the correctness of the provided <span class="math">(v_{a},v_{b},v_{c})</span> values. One option is to invoke the polynomial evaluation argument, but this ends up querying polynomials at two different locations: some polynomials at <span class="math">\\tau</span> and others at <span class="math">r</span>, where <span class="math">r</span> is chosen over the course of the sum-check protocol. Instead, we express the multilinear polynomial evaluation as a degree-2 sum-check instance. At the end of the single sum-check, all polynomials including <span class="math">(a,b,c)</span> are queried at <span class="math">r</span>. ∎</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.2 DelegatedSpartan: SNARKs over a non-pairing-friendly curve</h3>

    <p class="text-gray-300">Spartan <em>[59, §5.1]</em> can be phrased as a RoK from <span class="math">\\mathsf{CRR1CS}</span> to <span class="math">\\mathsf{MPE}^{2}</span>. There are two instances in the output relation because there are two commitments in the input instance.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Lemma 5.1 (Spartan’s NARK <em>[59]</em>).</h6>

    <p class="text-gray-300">For instances in <span class="math">\\mathsf{CRR1CS}</span>, let <span class="math">m</span> denote the number of constraints and <span class="math">n</span> denote the number of variables. There exists a RoK from <span class="math">\\mathsf{CRR1CS}</span> to <span class="math">\\mathsf{MPE}^{2}</span> with the following efficiency characteristics. The prover’s work is <span class="math">O(m+n)</span> field operations; the verifier’s work is <span class="math">O(\\log m+\\log n)</span> field operations, plus the cost to evaluate the multilinear extension (MLE) of R1CS matrices at a random point; and the communication complexity is <span class="math">O(\\log m+\\log n)</span> finite field elements.</p>

    <p class="text-gray-300">To prove two <span class="math">\\mathsf{MPE}</span> instances <span class="math">(\\mathsf{u}_{1},\\mathsf{u}_{2})</span>, we do the following. We cannot use HyperKZG because <span class="math">E_{2}</span> is not pairing-friendly.</p>

    <p class="text-gray-300">(1) Reduce polynomial evaluations to circuit satisfiability. We design an R1CS circuit, <span class="math">\\mathsf{polyeval}</span>, over the scalar field of <span class="math">E_{1}</span> that checks the purported instance-witness pairs and places the corresponding instances in the public IO. All inputs are taken non-deterministically and the circuit hardcodes the public parameters <span class="math">\\mathsf{pp}</span>. Note that all steps except for steps (3) and (4) are represented without any field emulation.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{polyeval}(Q_{1},Q_{2},x_{1},x_{2})\\rightarrow(q_{1},q_{2},x,y_{1},y_{2})</span></p>

    <p class="text-gray-300">(1) compute <span class="math">q_{1}\\leftarrow\\mathsf{Com}(\\mathsf{pp},Q_{1})</span></p>

    <p class="text-gray-300">(2) compute <span class="math">q_{2}\\leftarrow\\mathsf{Com}(\\mathsf{pp},Q_{2})</span></p>

    <p class="text-gray-300">(3) compute <span class="math">y_{1}\\leftarrow Q_{1}(x_{1})</span></p>

    <p class="text-gray-300">(4) compute <span class="math">y_{2}\\leftarrow Q_{2}(x_{2})</span></p>

    <p class="text-gray-300">(5) output <span class="math">(q_{1},q_{2},x_{1},x_{2},y_{1},y_{2})</span></p>

    <p class="text-gray-300">Using <span class="math">\\mathsf{u}_{1}</span> and <span class="math">\\mathsf{u}_{2}</span>, the verifier constructs a committed relaxed R1CS instance <span class="math">\\mathsf{u}_{\\mathsf{polyeval}}</span>. Then, it is easy to see that the satisfiability of <span class="math">\\mathsf{u}_{1}</span>, <span class="math">\\mathsf{u}_{2}</span> is tantamount to the knowledge of satisfying witnesses to <span class="math">\\mathsf{u}_{\\mathsf{polyeval}}</span>.</p>

    <p class="text-gray-300">(2) Prove the circuit with MicroSpartan. Since the R1CS circuit is defined over the scalar field of <span class="math">E_{1}</span>, we invoke MicroSpartan with HyperKZG to produce a succinct proof with an efficient on-chain verifier.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">5.3 Implemented optimizations</h3>

    <p class="text-gray-300">Efficiently evaluating the MLE of R1CS matrices in <span class="math">\\mathsf{EC}</span>. Recall that DelegatedSpartan is run to prove the satisfiability of a small circuit containing about 1,300 constraints. This circuit computes a scalar multiplication and a point addition. Since DelegatedSpartan relies on Lemma 5.1, the verifier has to evaluate the MLE of R1CS matrices. The time-optimal algorithm takes time linear in the number of non-zero entries in R1CS matrices <em>[59, 64, 67]</em>. In our context, R1CS matrices have <span class="math">\\approx</span>6,000 non-zero entries. While a linear number of field operations is relatively inexpensive on-chain, this requires storing R1CS matrices on-chain, which is prohibitive (we attempted to do a clever encoding of R1CS matrix entries and the costs were still prohibitive).</p>

    <p class="text-gray-300">We observe that this circuit can be made structured given that it implements many iterations of a double-add loop to compute a scalar multiplication followed by some constraints to do point addition. We introduce dummy constraints so that the R1CS matrices contain repeated copies of the same sub-matrix, one for each loop iteration, followed by some entries in the end. Now, to evaluate the MLE of these structured matrices, the verifier evaluates the MLE of the three sub-matrices (there are at most 30 non-zero entries) and the MLEs of the non-uniform portion of the matrices (which also only has a few tens of non-zero entries). Using these values, the verifier computes the MLE of the three structured matrices with only <span class="math">O(\\log k)</span> finite field operations (<span class="math">k=128</span> in our case). Overall, the on-chain verifier stores a succinct representation of these matrices and evaluates MLEs efficiently on the fly. Although this idea is folklore and described in different forms in prior work <em>[62]</em>, implementing it required substantial circuit engineering.</p>

    <p class="text-gray-300">Prove <span class="math">\\mathsf{u}_{\\mathsf{polyeval}}</span> with <span class="math">\\mathsf{U}_{F^{\\prime}}</span> in a batch. MicroSpartan naturally provides a batched variant that proves multiple R1CS instances at once (i.e., by batching all the sum-check protocol invocations). For ease of reference, we refer to this as BatchedMicroSpartan. To prove <span class="math">\\mathsf{U}_{F^{\\prime}}</span>, MicroNova invokes MicroSpartan already, so we use BatchedMicroSpartan to prove <span class="math">\\mathsf{u}_{\\mathsf{polyeval}}</span> and <span class="math">\\mathsf{U}_{\\mathsf{F^{\\prime}}}</span> in a single batch, saving proof sizes and verifier costs by <span class="math">\\approx</span>2<span class="math">\\times</span>.</p>

    <p class="text-gray-300">Reduce the size of <span class="math">\\mathsf{polyeval}</span> circuit. A natural commitment scheme over a non-pairing-friendly curve <span class="math">E_{2}</span> is Pedersen’s commitment scheme. In our context, the instances in <span class="math">\\mathsf{MPE}</span> commit to vectors of size <span class="math">n=2,048</span>. This means that the <span class="math">\\mathsf{polyeval}</span> circuit performs that many group scalar multiplications and finite field operations. To reduce this work, we employ a matrix commitment scheme <em>[68]</em>: a commitment to a vector of size <span class="math">n</span> is <span class="math">n_{1}</span> group elements each committing to a vector of size <span class="math">n_{2}</span>, where <span class="math">n=n_{1}\\cdot n_{2}</span>. This reduces the size of the circuit from <span class="math">O(n_{1}\\cdot n_{2})</span> to <span class="math">O(n_{1}+n_{2})</span>. However, the trade-off is that the recursive verifier circuit has to perform <span class="math">O(n_{1})</span> group scalar multiplications, rather than <span class="math">O(1)</span>, to fold instances in <span class="math">E_{2}</span>. To balance the two costs, we pick <span class="math">n_{1}=8</span> and <span class="math">n_{2}=256</span>. We provide additional details in Appendix B.</p>

    <h2 id="sec-48" class="text-2xl font-bold">6 HyperKZG: Proving multilinear evaluations</h2>

    <p class="text-gray-300">This section describes HyperKZG, a RoK from a multilinear polynomial evaluation instance to a collection of univariate polynomial evaluation instances. We then prove those univariate polynomial evaluation instances with univariate KZG. Together, the verifier’s work is dominated by two pairing operations and a logarithmic number of group scalar multiplications. Our starting point here is the reduction from Gemini <em>[21]</em> that reduces the task of checking a multilinear polynomial in <em>coefficient</em> form over <span class="math">\\log n</span> variables to the task of checking evaluations of <span class="math">\\log n</span> univariate polynomials over <span class="math">n</span> coefficients. We make a small—but crucial—modification to this reduction that allows committing to multilinear polynomials in evaluation form. This in turn makes it possible to use the commitment scheme with MicroSpartan without requiring a change of basis (which entails superlinear and expensive operations such as FFTs).</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">6.1 Reducing multilinear to univariate evaluations</h3>

    <h6 id="sec-50" class="text-base font-medium mt-4">Construction 5 (An RoK from <span class="math">\\mathsf{MPE}</span> to <span class="math">\\mathsf{UPE}</span>).</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span>, a commitment scheme <span class="math">\\mathsf{com}</span> for vectors over <span class="math">\\mathbb{F}</span>, and a size parameter <span class="math">n</span>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>. Let <span class="math">\\ell=\\log n</span>. We construct a reduction of knowledge from <span class="math">\\mathsf{MPE}</span> to <span class="math">\\mathsf{UPE}^{3\\log n-1}</span>. That is, the prover and verifier reduce the task of checking the evaluation of a multilinear polynomial over <span class="math">\\log n</span> variables to the task of checking <span class="math">3\\log n-1</span> evaluations of univariate polynomials with <span class="math">n</span> coefficients.</p>

    <p class="text-gray-300">For a vector <span class="math">P\\in\\mathbb{F}^{n}</span>, let <span class="math">P_{\\mathsf{evens}}\\in\\mathbb{F}^{n/2}</span> and <span class="math">P_{\\mathsf{odds}}\\in\\mathbb{F}^{n/2}</span> denote vectors with elements from <span class="math">P</span> at the even indices and odd indices respectively.</p>

    <p class="text-gray-300">Consider an arbitrary instance in <span class="math">\\mathsf{MPE}</span> <span class="math">(\\overline{P},x,y)</span>, and suppose the prover claims that it knows polynomial <span class="math">P</span> such that <span class="math">(\\mathsf{pp},(\\overline{P},x,y),P)\\in\\mathsf{MPE}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">P^{(0)}=P</span>. The prover computes <span class="math">\\forall i\\in\\{1,\\ldots,\\ell-1\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">P^{(i)}=(1-x_{i})\\cdot P_{\\mathsf{evens}}^{(i-1)}+x_{i}\\cdot P_{\\mathsf{odds}}^{(i-1)}</span></p>

    <p class="text-gray-300">The prover sends commitments <span class="math">(\\overline{P}^{(1)},\\ldots,\\overline{P}^{(\\ell-1)})</span>. The verifier sends a random challenge <span class="math">r\\in\\mathbb{F}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover sends claimed evaluations, treating each vector as coefficients of a univariate polynomial of appropriate degree. For all <span class="math">i\\in\\{1,\\ldots,\\ell\\}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">y^{(i)}=P^{(i)}(r^{2})</span></p>

    <p class="text-gray-300"><span class="math">y_{\\mathsf{pos}}^{(i-1)}=P^{(i-1)}(r)</span></p>

    <p class="text-gray-300"><span class="math">y_{\\mathsf{neg}}^{(i-1)}=P^{(i-1)}(-r)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that for all <span class="math">i\\in\\{1,\\ldots,\\ell\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">y^{(i)}=(1-x_{i})\\cdot\\frac{y_{\\mathsf{pos}}^{(i-1)}+y_{\\mathsf{neg}}^{(i-1)}}{2}+x_{i}\\cdot\\frac{y_{\\mathsf{pos}}^{(i-1)}-y_{\\mathsf{neg}}^{(i-1)}}{2\\cdot r}</span></p>

    <p class="text-gray-300">The verifier checks that <span class="math">y^{(\\ell)}=y</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\overline{P}^{(0)}=\\overline{P}</span>. The prover and the verifier output a collection of instance-witness pairs in <span class="math">\\mathsf{UPE}</span> (the verifier only outputs instances): for <span class="math">i\\in\\{1,\\ldots,\\ell-1\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},(\\overline{P}^{(i)},r^{2},y^{(i)}),P^{(i)})\\in\\mathsf{UPE},</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Observe that <span class="math">P^{(i)}</span> corresponds to partially evaluating <span class="math">P</span> as a multilinear polynomial at <span class="math">(x_{1},\\ldots,x_{i})</span>. Each step <span class="math">i</span> corresponds to a step of the evaluation algorithm from <em>[67, Section 5.1]</em> (also described in <em>[65, Lemma 3.8]</em>), for polynomials in evaluation form.</li>

    </ol>

    <p class="text-gray-300">and for <span class="math">i\\in\\{0,\\ldots,\\ell-1\\}</span></p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},(\\overline{P}^{(i)},r,y_{\\mathsf{pos}}^{(i)}),P^{(i)})\\in\\mathsf{UPE}</span> <span class="math">(\\mathsf{pp},(\\overline{P}^{(i)},-r,y_{\\mathsf{neg}}^{(i)}),P^{(i)})\\in\\mathsf{UPE}</span></p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 6.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a size bound <span class="math">n</span>, Construction 5 is a reduction of knowledge from <span class="math">\\mathsf{MPE}</span> to <span class="math">\\mathsf{UPE}^{3\\log n-1}</span> with the following efficiency characteristics. The prover’s cost is dominated by $\\sum_{i=0}^{\\ell-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}(2^{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{p}}<span class="math"> where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}(2^{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{p}}<span class="math"> denotes the cost of committing to a vector of size </span>2^{i}<span class="math">, and the cost of computing </span>P^{(i)}<span class="math"> for all </span>i\\in\\{1,\\ldots,\\ell-1\\}<span class="math"> The communication cost is dominated by </span>(\\sum_{i=0}^{\\ell-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}(2^{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{c}})+3\\log n\\cdot\\mathsf{F}<span class="math"> where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{com}(2^{i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{c}}<span class="math"> denotes the size of a commitment for a vector of size </span>2^{i}<span class="math"> and </span>\\mathsf{F}<span class="math"> denotes the size of a field element, The verifier’s cost is dominated by </span>O(\\log n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof (sketch).</h6>

    <p class="text-gray-300">The claimed efficiency is easy to check. Perfect completeness is also easy to check. This follows immediately from the correctness of the multilinear polynomial evaluation algorithm in the Lagrange basis (i.e., multilinear polynomials represented in their evaluation form over a Boolean hypercube) on which the protocol is based (see <em>[65, Lemma 3.8]</em>), and the correctness of the verifier’s checks in the RoK, which holds for any random challenge <span class="math">r\\in\\mathbb{F}</span> when the prover is honest.</p>

    <p class="text-gray-300">We prove knowledge soundness as follows. Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the input instance and a malicious prover <span class="math">\\mathcal{P}^{\\star}</span> that succeds with probability <span class="math">\\epsilon</span>. Let <span class="math">n\\in\\mathbb{N}</span> denote a size parameter. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda},n)</span>. Suppose on input a random tape <span class="math">\\mathsf{r}</span>, the adversary <span class="math">\\mathcal{A}</span> picks an <span class="math">\\mathsf{MPE}</span> instance <span class="math">(\\overline{P},x,y)</span> and some auxiliary state <span class="math">\\mathsf{st}</span>. We construct an extractor <span class="math">\\mathcal{E}</span> that succeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in obtaining satisfying witness for the original instance.</p>

    <p class="text-gray-300">On input <span class="math">\\mathsf{r}</span>, <span class="math">\\mathcal{E}</span> first obtains the following tuple from the adversary:</p>

    <p class="text-gray-300"><span class="math">((\\overline{P},x,y),\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{r})</span></p>

    <p class="text-gray-300">The extractor <span class="math">\\mathcal{E}</span> runs <span class="math">\\langle\\mathcal{P}^{\\star},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),(d,v),\\mathsf{st})</span> to obtain the following instance-witness pairs, where <span class="math">i\\in\\{1,\\ldots,\\log n</span>.</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},(\\overline{P}^{(i)},r^{2},y^{(i)}),P^{(i)})\\in\\mathsf{UPE}</span> <span class="math">(\\mathsf{pp},(\\overline{P}^{(i-1)},r,y_{\\mathsf{pos}}^{(i-1)}),P^{(i-1)})\\in\\mathsf{UPE}</span> <span class="math">(\\mathsf{pp},(\\overline{P}^{(i-1)},-r,y_{\\mathsf{neg}}^{(i-1)}),P^{(i-1)})\\in\\mathsf{UPE}</span></p>

    <p class="text-gray-300">The extractor outputs <span class="math">P^{(0)}</span> as the witness for the input instance. Since the extractor runs <span class="math">\\mathcal{P}^{\\star}</span> only once, it runs in expected polynomial time. We must now argue that <span class="math">P^{(0)}</span> is a satisfying witness for the <span class="math">\\mathsf{MPE}</span> instance <span class="math">(\\overline{P},x,y)</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. This follows from an anlysis similar to our base protocol’s analysis <em>[21, Lemma 5.4]</em>. ∎</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">6.2 Proving <span class="math">\\mathsf{UPE}</span> instances with batched KZG</h3>

    <p class="text-gray-300">To prove instances in <span class="math">\\mathsf{UPE}</span>, we invoke batched KZG <em>[19, 44]</em>. For uniformity, we batch <span class="math">3\\log n</span> evaluations rather than <span class="math">3\\log n-1</span> evaluations as depicted i.e., we evaluate each of the <span class="math">\\log n</span> univariate polynomials at <span class="math">r,-r,</span> and <span class="math">r^{2}</span>. Our approach to batching leverages the particular characteristics of our setting. Suppose <span class="math">p_{1},\\ldots,p_{k}</span> are polynomials in <span class="math">\\mathbb{F}[X]</span> and <span class="math">(u_{1},\\ldots,u_{t})</span> are values in <span class="math">\\mathbb{F}</span> and <span class="math">v_{i,j}</span> are the corresponding evaluations such that <span class="math">p_{i}(u_{j})=v_{i,j}</span>. In our context, <span class="math">t=3</span> (since each polynomial is evaluated at three points) and <span class="math">k=\\log n</span>.</p>

    <p class="text-gray-300">Let <span class="math">C_{1},\\ldots,C_{k}</span> be commitments to <span class="math">p_{i}</span>. Call this a <span class="math">(k,t)</span>-polynomial relation. A prover can convince a verifier that the relation holds, more efficiently than the <span class="math">O(kt)</span> direct solution, by using two types of batching (in order):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold the <span class="math">k</span> polynomials into a single polynomial, by taking a random linear combination, thus creating a <span class="math">(1,t)</span>-polynomial relation instance.</li>

      <li>Batch the <span class="math">t</span> evaluations for a single polynomial directly.</li>

    </ol>

    <p class="text-gray-300">Step 1. The verifier sends a random value <span class="math">q\\in\\mathbb{F}</span> to the prover, who computes the following polynomial</p>

    <p class="text-gray-300"><span class="math">B(X)=p_{1}(X)+q\\cdot p_{2}(X)+q^{2}\\cdot p_{3}(X)+\\ldots+q^{k-1}\\cdot p_{k}(X)</span></p>

    <p class="text-gray-300">The verifier computes <span class="math">C_{B}=\\sum_{i=1}^{k}q^{i-1}C_{i}</span> locally (since the commitments are linearly homomorphic). Similarly, for the evaluation of <span class="math">B</span> at any of the points <span class="math">u_{i}</span>, we have</p>

    <p class="text-gray-300"><span class="math">B(u_{i})</span> <span class="math">=q^{0}\\cdot p_{1}(u_{i})+q^{1}\\cdot p_{2}(u_{i})+\\ldots+q^{k-1}\\cdot p_{k}(u_{i})</span> <span class="math">=v_{1,i}+q\\cdot v_{2,i}+\\ldots+q^{k-1}\\cdot v_{k,i}</span></p>

    <p class="text-gray-300">which <span class="math">\\mathcal{V}</span> can also compute locally. Now <span class="math">(\\mathcal{P},\\mathcal{V})</span> have a <span class="math">(1,t)</span> instance, where <span class="math">B(X)</span> is the committed polynomial and <span class="math">(u_{i})_{i=1}^{t}</span> are the <span class="math">t</span> points. The cost to the verifier in of Step 1 is <span class="math">t-1</span> group scalar multiplications.</p>

    <p class="text-gray-300">Step 2. In this step we batch the verifier’s work to check the <span class="math">t</span> openings of <span class="math">B(X)</span> using the details of verifying KZG polynomial commitments <em>[44]</em>. Compute the <span class="math">t</span> witnesses <span class="math">W_{i}=\\mathsf{KZG.Open}(\\mathsf{ck},C_{B},u_{i},B(u_{i}))</span>. Checking these individually entails checking:</p>

    <p class="text-gray-300"><span class="math">e(C_{B}-B(u_{i})G+u_{i}W_{i},H)=e(W_{i},\\tau H)</span> (1)</p>

    <p class="text-gray-300">for all <span class="math">i\\in[t]</span>. A well-known batching technique <em>[14]</em> applied to pairing-based signatures <em>[36, Technique 3]</em> is as follows. Suppose the verification of <span class="math">t</span> items is of the form</p>

    <p class="text-gray-300"><span class="math">e(L_{1},H)=e(R_{1},H^{\\prime})\\ \\wedge\\ \\ldots\\ \\wedge\\ e(L_{t},H)=e(R_{t},H^{\\prime})\\ .</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}</span> instead samples a random <span class="math">(d_{2},\\ldots,d_{t})</span> and checks</p>

    <p class="text-gray-300"><span class="math">e(L_{1},H)e(L_{2},H)^{d_{2}}\\cdots e(L_{t},H)^{d_{t}}=</span> <span class="math">e(R_{1},H^{\\prime})e(R_{2},H^{\\prime})^{d_{2}}\\cdots e(R_{t},H^{\\prime})^{d_{t}}</span> <span class="math">e(L_{1},H)e(d_{2}L_{2},H)\\cdots e(d_{t}L_{t},H)=</span> <span class="math">e(R_{1},H^{\\prime})e(d_{2}R_{2},H^{\\prime})\\cdots e(d_{t}R_{t},H^{\\prime})</span> <span class="math">e(L_{1}+d_{2}L_{2}+\\ldots+d_{t}L_{t},H)=</span> <span class="math">e(R_{1}+d_{2}R_{2}+\\ldots+d_{t}R_{t},H^{\\prime})\\ .</span></p>

    <p class="text-gray-300"><span class="math">L_{i}</span> and <span class="math">R_{i}</span> as in Equation (1), the verifier’s cost in Step 2 is <span class="math">4\\cdot(t-1)</span> scalar multiplications in <span class="math">\\mathbb{G}_{1}</span> and two pairings. In HyperKZG, we have <span class="math">k=\\ell</span> polynomials and <span class="math">t=3</span> points so Step 1 costs <span class="math">\\ell-1</span> scalar multiplications and Step 2 costs 8 scalar multiplications and two pairings, for a total of <span class="math">\\ell+7</span> scalar multiplications and two pairings. In Equation (1) we re-arranged the KZG verification equation (following <em>[43]</em>) so that all scalar multiplications are in <span class="math">\\mathbb{G}_{1}</span>, and a single pairing is required for verification, allowing us to make use of Ethereum’s pre-compiled contracts.</p>

    <p class="text-gray-300">Additional optimizations. For Step 2, we could employ the approach of Boneh et al. <em>[19]</em> that batches multiple polynomials at multiple (possibly different) points. However, in our context, the number of evaluations is only three, so there is limited gain to the prover and the verifier (the prover would compute two MSMs of size <span class="math">n</span> instead of three in our current version) and the verifier’s work will be about the same. The verifier is a bit more complex with their approach. Given the limited benefits, we do not implement this optimization.</p>

    <h2 id="sec-54" class="text-2xl font-bold">7 Implementation</h2>

    <p class="text-gray-300">We implement MicroNova on top of Nova <em>[6]</em> as a library in about 11,000 lines of Rust. For a curve cycle, we use BN254/Grumpkin <em>[5]</em>; it also supports Pallas/Vesta <em>[8]</em> and Secp/Secq curve cycles <em>[5]</em>. For a circuit-friendly hash function, we use Poseidon <em>[40]</em>. For a on-chain-efficient hash function, we use Keccak256. The APIs of MicroNova accept a step function <span class="math">F</span> as a circuit expressed with bellpepper <em>[1]</em>. The library also implements BatchedMicroSpartan and DelegatedSpartan to compress an IVC proof produced by MicroNova, as well as implementations of (non-batched) MicroSpartan and the baseline Spartan to compress an IVC proof of Nova. For polynomial commitment schemes, the library implements HyperKZG for pairing-friendly curves (e.g., BN254), and Pedersen commitments that can serve all curves (e.g., Grumpkin).</p>

    <p class="text-gray-300">We also implement MicroSpartan as a <em>stand-alone</em> proof system alongside MicroNova and Nova, targeting scenarios that does not require IVC. To build such stand-alone prover and verifier, we design a straightforward augmented circuit that, given step <span class="math">F</span> and <span class="math">z_{i-1}</span>, compute <span class="math">z_{i}\\leftarrow F(z_{i-1})</span>, and outputs <span class="math">\\mathsf{x}\\leftarrow(z_{i},z_{i-1})</span> into R1CS public IO.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">On-chain verifier.</h4>

    <p class="text-gray-300">We implement MicroNova’s on-chain verifier as a library in about 3,300 lines of Solidity. The library also provides an on-chain verifier for the stand-alone MicroSpartan and HyperKZG. Both MicroNova and the stand-alone MicroSpartan are over BN254. We use Ethereum’s EC precompiles to support EC operations (i.e., ecAdd, ecMul and ecPairing) <em>[2]</em>. Fiat-Shamir transcript is built on Keccak256.</p>

    <p class="text-gray-300">To send proofs on-chain, we use serde <em>[9]</em>. We wrote a deserializer in Solidity to reconstruct appropriate data structures. We customize the serialization so the elliptic curve points are in affine form, prime field elements are in big-endian format, and other values are encoded in fixed size byte arrays. This avoids expensive on-chain conversions. The on-chain verifier also accepts a serialized verifier key as an argument. In more detail, the on-chain verifier receives a byte sequence containing a verifier key, a proof, and the public IO (e.g., <span class="math">z_{0},z_{n}</span>, number of steps). After receiving the sequence, the on-chain verifier inexpensively deserializes it into data structures, and then verifies the proof. The verifier reverts if any step in the verification fails.</p>

    <h2 id="sec-56" class="text-2xl font-bold">8 Experimental evaluation</h2>

    <p class="text-gray-300">In this section, we experimentally evaluate MicroNova. To evaluate the cost of achieving a succinct on-chain verifier, we compare MicroNova with Nova. In addition to evaluating the full system, we also provide microbenchmarks for the underlying components of MicroNova: HyperKZG and stand-alone MicroSpartan with HyperKZG as its polynomial commitment scheme. These microbenchmarks will provide enough context to understand the performance of MicroNova, and are in Section 8.4.</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">8.1 Metrics and testbed</h3>

    <p class="text-gray-300">Our principal evaluation metrics are: (1) the prover’s cost to produce a proof; (2) the verifier’s cost to verify a proof on a CPU; (3) the verifier’s cost to verify a proof on-chain; (4) the size of a proof on a CPU; and (5) the size of a proof on-chain. For (1) and (2), we use the wall clock time, and for (3), we measure gas costs on the Ethereum virtual machine (EVM). For (4) and (5), we report length in bytes, but by serializing proof data structures differently. For example, proofs verified on a CPU have elliptic curve points in compressed form (decompression of points is relatively inexpensive on a CPU, but expensive on-chain).</p>

    <p class="text-gray-300">For our measurements, we use an Azure Fsv2-series VM of size Standard F64s_v2 (64 vCPUs, 2.70 GHz Intel(R) Xeon(R) Platinum 8168, and 128 GiB memory).</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">8.2 Methodology and parameters</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We report performance with varying step circuit sizes $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We use a synthetic circuit, from prior work <em>[52, 59]</em>, that contains </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n_{c}<span class="math"> R1CS constraints and </span>n_{v}<span class="math"> R1CS variables, and maintains </span>n_{c}/n_{v}\\approx 1<span class="math">. The circuit computes </span>y=x^{2^{n_{c}}}<span class="math"> naively with repeated multiplications on a prime field with </span>n_{c}<span class="math"> constraints. We use a public IO of length 1, i.e., </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$. We set the number of IVC steps proven to 10.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use cargo bench to measure metrics (1) and (2). For metric (4), we serialize the proof structure with serde <em>[9]</em> and then measure the number of bytes after compressing the serialized proof string with ZlibEncoder <em>[3]</em>. For metric (5), we serialize proofs as described in Section 7</p>

    <p class="text-gray-300">To compile MicroNova’s Solidity verifier, we use Foundry <em>[4]</em> with Solidity command-line compiler solc version 0.8.25 on EVM version cancun. We configure solc optimizer</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">0.91</td>

            <td class="px-3 py-2 border-b border-gray-700">1.77</td>

            <td class="px-3 py-2 border-b border-gray-700">3.52</td>

            <td class="px-3 py-2 border-b border-gray-700">6.62</td>

            <td class="px-3 py-2 border-b border-gray-700">12.5</td>

            <td class="px-3 py-2 border-b border-gray-700">23.0</td>

            <td class="px-3 py-2 border-b border-gray-700">46.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MicroNova</td>

            <td class="px-3 py-2 border-b border-gray-700">2.45</td>

            <td class="px-3 py-2 border-b border-gray-700">3.21</td>

            <td class="px-3 py-2 border-b border-gray-700">4.77</td>

            <td class="px-3 py-2 border-b border-gray-700">7.75</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9</td>

            <td class="px-3 py-2 border-b border-gray-700">24.6</td>

            <td class="px-3 py-2 border-b border-gray-700">48.7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Prover's total cost on a CPU (in seconds) to produce an IVC proof of 10 steps of varying step-circuit sizes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.30</td>

            <td class="px-3 py-2 border-b border-gray-700">2.39</td>

            <td class="px-3 py-2 border-b border-gray-700">4.44</td>

            <td class="px-3 py-2 border-b border-gray-700">8.49</td>

            <td class="px-3 py-2 border-b border-gray-700">16.7</td>

            <td class="px-3 py-2 border-b border-gray-700">33.2</td>

            <td class="px-3 py-2 border-b border-gray-700">66.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.45</td>

            <td class="px-3 py-2 border-b border-gray-700">0.68</td>

            <td class="px-3 py-2 border-b border-gray-700">1.08</td>

            <td class="px-3 py-2 border-b border-gray-700">1.93</td>

            <td class="px-3 py-2 border-b border-gray-700">3.51</td>

            <td class="px-3 py-2 border-b border-gray-700">6.73</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova3</td>

            <td class="px-3 py-2 border-b border-gray-700">5.31</td>

            <td class="px-3 py-2 border-b border-gray-700">10.4</td>

            <td class="px-3 py-2 border-b border-gray-700">20.3</td>

            <td class="px-3 py-2 border-b border-gray-700">39.9</td>

            <td class="px-3 py-2 border-b border-gray-700">78.5</td>

            <td class="px-3 py-2 border-b border-gray-700">155</td>

            <td class="px-3 py-2 border-b border-gray-700">310</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.02</td>

            <td class="px-3 py-2 border-b border-gray-700">3.87</td>

            <td class="px-3 py-2 border-b border-gray-700">7.18</td>

            <td class="px-3 py-2 border-b border-gray-700">13.5</td>

            <td class="px-3 py-2 border-b border-gray-700">26.1</td>

            <td class="px-3 py-2 border-b border-gray-700">50.1</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MicroNova</td>

            <td class="px-3 py-2 border-b border-gray-700">28.5</td>

            <td class="px-3 py-2 border-b border-gray-700">29.9</td>

            <td class="px-3 py-2 border-b border-gray-700">30.5</td>

            <td class="px-3 py-2 border-b border-gray-700">33.7</td>

            <td class="px-3 py-2 border-b border-gray-700">40.8</td>

            <td class="px-3 py-2 border-b border-gray-700">66.7</td>

            <td class="px-3 py-2 border-b border-gray-700">119</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with flags --via-ir and --optimizer-runs=50000. To measure gas costs, we use gasleft().</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first measure the size of MicroNova's verifier circuit, as it determines recursion overheads: the number of additional constraints that the prover must prove at each incremental step besides proving an invocation of  <span class="math">F</span> . We find that MicroNova's verifier circuit is  <span class="math">\\approx 74,000</span>  R1CS constraints on the pairing-friendly curve, and  <span class="math">\\approx 1,300</span>  on the non-pairing-friendly curve. Precisely, the circuit is of 74,352 constraints on BN254 and 2,037 on Grumpkin, while the latter includes dummy constraints (§5.3), which does not cost the prover or the verifier, to make the circuit uniform. As a comparison, Nova's verifier circuit is  <span class="math">\\approx 10,000</span>  R1CS constraints on each curve in the cycle (9,949 and 10,502 constraints on BN254 and Grumpkin curve respectively). That is, MicroNova's recursion overhead is about  <span class="math">3 \\times</span>  higher than Nova's, but this overhead is negligible when  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is sufficiently large, which is the case in our target applications (e.g., a Rollup).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When varying the step circuit size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , we pick the number of constraints  </span>n_c<span class="math">  so that when augmented with MicroNova&#x27;s verifier circuit, the total number of constraints in  </span>F'<span class="math">  equals to a power of 2. For ease of depiction, we use these powers of 2 to denote  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  e.g., when  </span>F'<span class="math">  has  </span>2^{20}<span class="math">  constraints,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n_c = 2^{20} - 74, 352 = 974, 224<span class="math"> , and we will use  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{20}<span class="math">  in figures to represent  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 974, 224<span class="math"> . Note that MicroNova and Nova prove the same  </span>F<span class="math">  in our experiments (sizes of augmented circuits  </span>F'$  of MicroNova and Nova are different due to their different recursion overheads).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We instantiate Nova over BN254/Grumpkin. For proof compression, Nova library implements non-preprocessing Spartan [59], which does not provide succinct verification, let alone on-chain verification (the verifier's work is linear in the circuit size). We refer to this version of Spartan as SpartanNARK. To provide a full context, we experiment with different configurations. For its IVC proof component on Grumpkin curve, Nova compresses it with SpartanNARK</p>

    <p class="text-gray-300">Figure 2: Prover's cost on a CPU (in seconds) to compress an IVC proof of varying step-circuit sizes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova1</td>

            <td class="px-3 py-2 border-b border-gray-700">78.0</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

            <td class="px-3 py-2 border-b border-gray-700">397</td>

            <td class="px-3 py-2 border-b border-gray-700">768</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova2</td>

            <td class="px-3 py-2 border-b border-gray-700">25.4</td>

            <td class="px-3 py-2 border-b border-gray-700">26.8</td>

            <td class="px-3 py-2 border-b border-gray-700">30.6</td>

            <td class="px-3 py-2 border-b border-gray-700">43.6</td>

            <td class="px-3 py-2 border-b border-gray-700">77.0</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova3</td>

            <td class="px-3 py-2 border-b border-gray-700">188</td>

            <td class="px-3 py-2 border-b border-gray-700">383</td>

            <td class="px-3 py-2 border-b border-gray-700">690</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">5.0s</td>

            <td class="px-3 py-2 border-b border-gray-700">10s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova4</td>

            <td class="px-3 py-2 border-b border-gray-700">20.9</td>

            <td class="px-3 py-2 border-b border-gray-700">21.2</td>

            <td class="px-3 py-2 border-b border-gray-700">20.7</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">21.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MicroNova</td>

            <td class="px-3 py-2 border-b border-gray-700">13.6</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

            <td class="px-3 py-2 border-b border-gray-700">13.8</td>

            <td class="px-3 py-2 border-b border-gray-700">13.6</td>

            <td class="px-3 py-2 border-b border-gray-700">13.7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: Verifier's cost on a CPU (in milliseconds) to verify a compressed IVC proof of varying step-circuit sizes. Entries with "s" are in seconds.</p>

    <p class="text-gray-300">and with an IPA-based polynomial commitment scheme. For its proof of IVC on BN254 curve, Nova can compress it with either SpartanNARK or MicroSpartan, and with either IPA-PC or HyperKZG as the polynomial commitment scheme. We use the following notation to refer to different variants of Nova for brevity:  <span class="math">\\mathrm{Nova}^1</span>  Nova with SpartanNARK and IPA-PC;  <span class="math">\\mathrm{Nova}^2</span>  Nova with SpartanNARK and HyperKZG;  <span class="math">\\mathrm{Nova}^3</span>  Nova with MicroSpartan and IPA-PC; and  <span class="math">\\mathrm{Nova}^4</span>  Nova with MicroSpartan and HyperKZG.</p>

    <p class="text-gray-300">Prover. Figure 1 depicts the prover's total cost to produce a proof of a ten-step IVC (four variants of Nova are exactly the same for the IVC prover). Figure 2 depicts the prover's cost to compress an IVC proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MicroNova's prover's cost to produce and to compress an IVC proof scale roughly linearly with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . When  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is small, MicroNova incurs higher overheads than Nova, but the overhead drops as  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  increases. This is because (1) Nova&#x27;s verifier&#x27;s circuit on both curves combined is smaller than MicroNova&#x27;s, and (2) when MicroNova compresses an IVC proof the BatchedMicroSpartan proves a constant-sized R1CS polyeval of 1.7M constraints that proves 2 MPE instances on Grumpkin curve ( </span>\\S 5.3<span class="math"> ). For MicroNova&#x27;s prover to compress an IVC proof, such constant cost is dominating until  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}<span class="math"> , then the R1CS of IVC is no longer smaller than the R1CS of polyeval. At  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}<span class="math"> , MicroNova&#x27;s IVC prover overhead over Nova is only  </span>3.2\\%$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that Nova using SpartanNARK has a better prover time than with MicroSpartan because the former incurs linear verification costs whereas the latter does not. These results also confirm that HyperKZG is significantly more efficient than IPA-based polynomial commitment scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier and proof sizes. Figure 3 depicts the verifier's cost to verify a compressed IVC proof on a CPU. The cost under the first three Nova instantiation scale close to linearly with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . MicroNova&#x27;s verifier cost is the lowest:  </span>&lt; 14$  ms (Nova with MicroSpartan and HyperKZG benefits from techniques in this work and performs better than other Nova variants).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4 depicts the on-chain verifier's costs for MicroNova (we do not depict Nova's costs as it is impractical to verify Nova's proof on-chain). We can see that both the gas cost and proof length remains (almost) unchanged up to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}<span class="math">  (this is due to fixed-sized polyeval circuit proven by MicroNova). Then, they have a logarithmic growth with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> : when  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  increases from  </span>2^{21}<span class="math">  to  </span>2^{22}<span class="math"> , or from  </span>2^{22}$  to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">13.1</td>

            <td class="px-3 py-2 border-b border-gray-700">13.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">gas cost</td>

            <td class="px-3 py-2 border-b border-gray-700">2.23</td>

            <td class="px-3 py-2 border-b border-gray-700">2.22</td>

            <td class="px-3 py-2 border-b border-gray-700">2.22</td>

            <td class="px-3 py-2 border-b border-gray-700">2.22</td>

            <td class="px-3 py-2 border-b border-gray-700">2.22</td>

            <td class="px-3 py-2 border-b border-gray-700">2.25</td>

            <td class="px-3 py-2 border-b border-gray-700">2.28</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4: MicroNova's on-chain proof size (in KB) and the verifier's on-chain cost (in M gas) to verify a compressed IVC proof of varying step-circuit sizes. The length of the verifier's key on-chain is 1,368 bytes regardless of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova1</td>

            <td class="px-3 py-2 border-b border-gray-700">10.3</td>

            <td class="px-3 py-2 border-b border-gray-700">10.6</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">11.1</td>

            <td class="px-3 py-2 border-b border-gray-700">11.4</td>

            <td class="px-3 py-2 border-b border-gray-700">11.7</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova2</td>

            <td class="px-3 py-2 border-b border-gray-700">11.4</td>

            <td class="px-3 py-2 border-b border-gray-700">11.8</td>

            <td class="px-3 py-2 border-b border-gray-700">12.1</td>

            <td class="px-3 py-2 border-b border-gray-700">12.5</td>

            <td class="px-3 py-2 border-b border-gray-700">12.8</td>

            <td class="px-3 py-2 border-b border-gray-700">13.2</td>

            <td class="px-3 py-2 border-b border-gray-700">13.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova3</td>

            <td class="px-3 py-2 border-b border-gray-700">9.04</td>

            <td class="px-3 py-2 border-b border-gray-700">9.20</td>

            <td class="px-3 py-2 border-b border-gray-700">9.37</td>

            <td class="px-3 py-2 border-b border-gray-700">9.53</td>

            <td class="px-3 py-2 border-b border-gray-700">9.70</td>

            <td class="px-3 py-2 border-b border-gray-700">9.86</td>

            <td class="px-3 py-2 border-b border-gray-700">10.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova4</td>

            <td class="px-3 py-2 border-b border-gray-700">10.3</td>

            <td class="px-3 py-2 border-b border-gray-700">10.5</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">11.0</td>

            <td class="px-3 py-2 border-b border-gray-700">11.2</td>

            <td class="px-3 py-2 border-b border-gray-700">11.4</td>

            <td class="px-3 py-2 border-b border-gray-700">11.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MicroNova</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">11.0</td>

            <td class="px-3 py-2 border-b border-gray-700">11.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">2^{23}</span> , the gas cost of the on-chain verifier only increases by  <span class="math">32\\mathrm{K} (&amp;lt; 2\\%)</span> , and the proof length only grows by 264 bytes  <span class="math">(\\approx 2\\%)</span>  each time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 5 depicts the size of compressed IVC proofs of MicroNova and Nova on a CPU. MicroNova's proof is about  <span class="math">10.8\\mathrm{KB}</span> , until  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}<span class="math"> , and then has a logarithmic growth with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , but still remains small. The different Nova variants have similar proof sizes despite using IPA-based polynomial commitment scheme because proof sizes are similar under both IPA-PC and HyperKZG.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Decomposing MicroNova's on-chain costs. Figure 6 depicts the on-chain gas costs of four components of MicroNova's verifier: (1) deserialization; (2) DelegatedSpartan's verifier; (3) BatchedMicroSpartan's verifier; and (4) HyperKZG verifier, which is included in (3).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, the deserialization's cost scales linearly with the proof length (in our implementation, the deserialization also handles verifier's key and other parameters, which are constant-sized). DelegatedSpartan verifier has a constant cost. BatchedMicroSpartan and HyperKZG's verifiers' costs exhibit the same trend as MicroNova's verifier—costs nearly unchanged until  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}<span class="math">  and then have a logarithmic scaling. Second, BatchedMicroSpartan contributes  </span>\\approx 65\\%<span class="math">  of the cost of MicroNova&#x27;s verifier; it also contributes a vast majority of MicroNova&#x27;s gas cost increase when the circuit grows. Within BatchedMicroSpartan,  </span>\\approx 31\\%<span class="math">  is incurred by HyperKZG verifier. The DelegatedSpartan verifier contributes  </span>&lt; 25\\%<span class="math">  of MicroNova&#x27;s cost, while the deserialization only contributes  </span>6\\%$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When varying the size of the step circuit  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , we use the same set of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n_c<span class="math">  we have picked when evaluating MicroNova (§8.3). We have the stand-alone MicroSpartan prove and verify 10 continuous steps of  </span>F$  one after another.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: MicroNova's and Nova's proof sizes on a CPU (in KB).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218-221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MicroNova</td>

            <td class="px-3 py-2 border-b border-gray-700">2.23</td>

            <td class="px-3 py-2 border-b border-gray-700">2.22</td>

            <td class="px-3 py-2 border-b border-gray-700">2.25</td>

            <td class="px-3 py-2 border-b border-gray-700">2.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Deserialization</td>

            <td class="px-3 py-2 border-b border-gray-700">0.126</td>

            <td class="px-3 py-2 border-b border-gray-700">0.126</td>

            <td class="px-3 py-2 border-b border-gray-700">0.128</td>

            <td class="px-3 py-2 border-b border-gray-700">0.130</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DelegatedSpartan</td>

            <td class="px-3 py-2 border-b border-gray-700">0.552</td>

            <td class="px-3 py-2 border-b border-gray-700">0.552</td>

            <td class="px-3 py-2 border-b border-gray-700">0.552</td>

            <td class="px-3 py-2 border-b border-gray-700">0.552</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BatchedMicroSpartan</td>

            <td class="px-3 py-2 border-b border-gray-700">1.44</td>

            <td class="px-3 py-2 border-b border-gray-700">1.43</td>

            <td class="px-3 py-2 border-b border-gray-700">1.46</td>

            <td class="px-3 py-2 border-b border-gray-700">1.49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperKZG</td>

            <td class="px-3 py-2 border-b border-gray-700">0.447</td>

            <td class="px-3 py-2 border-b border-gray-700">0.447</td>

            <td class="px-3 py-2 border-b border-gray-700">0.459</td>

            <td class="px-3 py-2 border-b border-gray-700">0.471</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 6: Cost of four components of MicroNova's on-chain verifier (in M gas). HyperKZG is included in BatchedMicroSpartan while the deserialization or DelegatedSpartan is not. Four columns of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{18}<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{19}<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{20}<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{21}$  are merged into one as data is (nearly) the same.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">218</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">222</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">1.18</td>

            <td class="px-3 py-2 border-b border-gray-700">3.94</td>

            <td class="px-3 py-2 border-b border-gray-700">7.36</td>

            <td class="px-3 py-2 border-b border-gray-700">13.9</td>

            <td class="px-3 py-2 border-b border-gray-700">26.6</td>

            <td class="px-3 py-2 border-b border-gray-700">51.9</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\( \\text{Verify}^1 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.09</td>

            <td class="px-3 py-2 border-b border-gray-700">5.12</td>

            <td class="px-3 py-2 border-b border-gray-700">5.15</td>

            <td class="px-3 py-2 border-b border-gray-700">5.20</td>

            <td class="px-3 py-2 border-b border-gray-700">5.23</td>

            <td class="px-3 py-2 border-b border-gray-700">5.26</td>

            <td class="px-3 py-2 border-b border-gray-700">5.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\( \\text{proof}^1 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.18</td>

            <td class="px-3 py-2 border-b border-gray-700">5.63</td>

            <td class="px-3 py-2 border-b border-gray-700">5.86</td>

            <td class="px-3 py-2 border-b border-gray-700">6.08</td>

            <td class="px-3 py-2 border-b border-gray-700">6.31</td>

            <td class="px-3 py-2 border-b border-gray-700">6.53</td>

            <td class="px-3 py-2 border-b border-gray-700">6.76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\( \\text{Verify}^2 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.81</td>

            <td class="px-3 py-2 border-b border-gray-700">0.86</td>

            <td class="px-3 py-2 border-b border-gray-700">0.88</td>

            <td class="px-3 py-2 border-b border-gray-700">0.90</td>

            <td class="px-3 py-2 border-b border-gray-700">0.93</td>

            <td class="px-3 py-2 border-b border-gray-700">0.95</td>

            <td class="px-3 py-2 border-b border-gray-700">0.98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\( \\text{proof}^2 \\)</td>

            <td class="px-3 py-2 border-b border-gray-700">6.25</td>

            <td class="px-3 py-2 border-b border-gray-700">6.78</td>

            <td class="px-3 py-2 border-b border-gray-700">7.04</td>

            <td class="px-3 py-2 border-b border-gray-700">7.30</td>

            <td class="px-3 py-2 border-b border-gray-700">7.57</td>

            <td class="px-3 py-2 border-b border-gray-700">7.83</td>

            <td class="px-3 py-2 border-b border-gray-700">8.10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Performance results of stand-alone MicroSpartan per-step average, from the first row to the last: (1) prover's cost (in seconds); (2) verifier's cost on CPU (in milliseconds); (3) proof length on CPU (in KB); (4) verifier's cost on chain (in M gas); and (5) proof length on chain (in KB). The length of the verifier's key on-chain is always 824 bytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">217</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">219</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">221</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">223</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">225</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">commit</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05</td>

            <td class="px-3 py-2 border-b border-gray-700">0.15</td>

            <td class="px-3 py-2 border-b border-gray-700">0.53</td>

            <td class="px-3 py-2 border-b border-gray-700">1.8</td>

            <td class="px-3 py-2 border-b border-gray-700">7.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prove</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08</td>

            <td class="px-3 py-2 border-b border-gray-700">0.24</td>

            <td class="px-3 py-2 border-b border-gray-700">0.75</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">9.7</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verify on CPU</td>

            <td class="px-3 py-2 border-b border-gray-700">2.7</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3.0</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof on CPU</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0</td>

            <td class="px-3 py-2 border-b border-gray-700">2.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.8</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verify on-chain</td>

            <td class="px-3 py-2 border-b border-gray-700">0.35</td>

            <td class="px-3 py-2 border-b border-gray-700">0.37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.39</td>

            <td class="px-3 py-2 border-b border-gray-700">0.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.44</td>

            <td class="px-3 py-2 border-b border-gray-700">0.46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof on-chain</td>

            <td class="px-3 py-2 border-b border-gray-700">2.6</td>

            <td class="px-3 py-2 border-b border-gray-700">2.9</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9</td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8: HyperKZG's performance for polynomials of various length: (1) commit cost on CPU (in seconds); (2) prover's cost (in seconds); (3) verifier's cost on CPU (in milliseconds); (4) proof length on CPU (in KB); (5) verifier's cost on-chain (in M gas); and (6) proof length on chain (in KB). Length of the verifier's key on-chain is always 320 bytes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 7 shows the stand-alone MicroSpartan's average performance results of 10 steps. Throughout the 10 steps of the same  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , MicroSpartan&#x27;s performance fluctuates negligibly ( </span>&lt; 2\\%<span class="math">  of the average). The cost of the standalone MicroSpartan prover scales close to linearly with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . On- and off-chain verifier cost, the proof length on a CPU, and the proof length on-chain have a logarithmic scaling with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">HyperKZG. We vary the size of polynomials from  <span class="math">2^{15}</span>  to  <span class="math">2^{25}</span> , which is the range of the size of committed polynomials when evaluating MicroNova, stand-alone MicroSpartan, and Nova with HyperKZG in §8.3. As shown in Figure 8, HyperKZG's cost to commit and to prove an evaluation both grow close to linearly with the size of the polynomial, and the HyperKZG's verifier's cost grows logarithmically.</p>

    <h2 id="sec-62" class="text-2xl font-bold">9 Discussion of naive solutions</h2>

    <p class="text-gray-300">This section discusses naive solutions to the problem that MicroNova addresses: a folding-based IVC scheme with an efficient verifier. In theory, we can compose an existing folding-based IVC scheme (e.g., Nova) with an off-the-shelf SNARK <em>[38, 41]</em>: we represent Nova’s verifier as a circuit and then prove the knowledge of a valid witness to that circuit. This achieves an efficient verifier, but it makes the prover multiple orders of magnitude slower than MicroNova’s prover.</p>

    <p class="text-gray-300">Recall that Nova’s IVC proof contains an instance-witness pair on pairing curve (e.g., BN254) and an instance-witness pair on a non-pairing curve (e.g., Grumpkin). With Groth16 or Plonk (instantiated with BN254), we will be using them to prove a circuit that checks if <em>both</em> instances are satisfying. For a step circuit used in Nova with a <span class="math">10^{6}</span> gates, the Nova verifier as a circuit, will be at least a billion to a trillion gates due to the need to emulate BN254 scalar multiplication operations (at least one per gate in the step circuit) inside a circuit defined over BN254. Note that half-pairing cycles do not directly help as Groth16 and Plonk need pairing-friendly curves. Known techniques can bring this to a few hundred million gates. However, the prover times are impractical.</p>

    <p class="text-gray-300">MicroNova contains a set of techniques to make the above naive solution practical. Indeed, MicroNova’s techniques make the circuit proven with a SNARK significantly smaller (<span class="math">\\approx</span>1.7 million gates). Additionally, we use more efficient techniques (e.g., sum-checks) than Plonk’s (e.g., quotient-checks) to make the prover concretely efficient. Indeed, the prover times for compression are only tens of seconds (Figure 2).</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">9.1 Concurrent work</h3>

    <p class="text-gray-300">Sonobe <em>[10]</em> is a library that implements Nova <em>[52]</em> and other folding schemes. Sonobe’s focus is on modularity, so it is not fully optimized for performance. Like MicroNova, Sonobe also focuses on producing Nova proofs that are efficiently verifiable on-chain. Sonobe crucially relies on our prior work CycleFold <em>[49]</em>, which was discovered while designing MicroNova.</p>

    <p class="text-gray-300">However, there are several differences between our approach and their approach. First, Sonobe employs Groth16 <em>[41]</em> to compress IVC proofs given Groth16 provides an efficient on-chain verifier. So, Sonobe’s requires a separate trusted setup for each application proven via Sonobe. In contrast, MicroNova requires only a universal trusted setup. In fact, MicroNova does not require any new trusted setup: it can use any existing trusted setup material created for other popular proof systems such as Plonk <em>[38]</em>. Second, Sonobe is more gas efficient: verifying a proof requires about 800,000 gas on Ethereum virtual machine. Whereas, MicroNova’s proofs require 2.2 M gas since its proofs are longer and more complex to verify than the proof generated by Sonobe. However, one can apply further compression to MicroNova’s proofs using Groth16 to further compress MicroNova’s proofs—while retaining the trusted setup property of MicroNova. Third, to produce a compressed proof, Sonobe’s approach requires proving a circuit of size <span class="math">\\approx</span>10 M constraints via Groth16. In contrast, MicroNova’s approach only requires proving a circuit of size <span class="math">\\approx</span>1 M constraints via MicroSpartan. We leave it to the future work to provide a more detailed comparison.</p>

    <h2 id="sec-64" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Craig Costello and Michael Naehrig for helpful discussions on various aspects of elliptic curves. We thank Abhiram Kothapalli for conversations about some of the RoKs introduced in this paper. We thank Sebastian Angel for his contributions during the early stages of this project. Finally, we thank Wilson Nguyen, Carlos Pérez, Jay White, and the anonymous IEEE S&P reviewers for comments on a prior version of this paper.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] bellpepper. https://crates.io/crates/bellpepper</li>

      <li>[2] EVM precompiled contracts. https://www.evm.codes/precompiled</li>

      <li>[3] flate2. https://crates.io/crates/flate2</li>

      <li>[4] Foundry. https://getfoundry.sh/</li>

      <li>[5] halo2curves. https://crates.io/crates/halo2curves</li>

      <li>[6] Nova: Recursive SNARKs without trusted setup. https://github.com/Microsoft/Nova</li>

      <li>[7] Ova: A slightly better Nova. https://hackmd.io/V4838nnlRKal9ZiTHiGYzw</li>

      <li>[8] Pasta curves. https://crates.io/crates/pasta_curves</li>

      <li>[9] Serde. https://crates.io/crates/serde</li>

      <li>[10] sonobe. https://github.com/privacy-scaling-explorations/sonobe/</li>

      <li>[11] Awesome Folding. https://github.com/lurk-lab/awesome-folding (2023)</li>

      <li>[12] Arun, A., Setty, S.: Nebula: Efficient read-write memory and switchboard circuits for folding schemes. Cryptology ePrint Archive (2024)</li>

      <li>[13] Babai, L., Fortnow, L., Levin, L.A., Szegedy, M.: Checking computations in polylogarithmic time. In: STOC (1991)</li>

      <li>[14] Bellare, M., Garay, J.A., Rabin, T.: Fast batch verification for modular exponentiation and digital signatures. In: EUROCRYPT. pp. 236–250 (1998)</li>

      <li>[15] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO (2014)</li>

      <li>[16] Boneh, D.: ZKP MOOC Lecture 10: Recursive SNARKs. https://www.youtube.com/watch?v=0LW-qeVe6QI (2023)</li>

      <li>[17] Boneh, D., Bünz, B., Fisch, B.: A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712 (2018)</li>

      <li>[18] Boneh, D., Chen, B.: LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257 (2024)</li>

      <li>[19] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive (2020)</li>

      <li>[20] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: EUROCRYPT (2016)</li>

      <li>[21] Bootle, J., Chiesa, A., Hu, Y., Orrú, M.: Gemini: Elastic SNARKs for diverse environments. In: EUROCRYPT. pp. 427–457 (2022)</li>

      <li>[22] Bootle, J., Chiesa, A., Sotiraki, K.: Sumcheck arguments and their applications. In: CRYPTO. pp. 742–773 (2021)</li>

      <li>[23] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: S&amp;P (2018)</li>

      <li>[24] Bünz, B., Chen, B.: Protostar: Generic efficient accumulation/folding for special sound protocols. In: ASIACRYPT (2023)</li>

      <li>[25] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: CRYPTO (2021)</li>

      <li>[26] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Proof-carrying data from accumulation schemes. In: TCC (2020)</li>

      <li>[27] Bünz, B., Chen, J.: Proofs for deep thought: Accumulation for large memories and deterministic computations. Cryptology ePrint Archive, Paper 2024/325 (2024)</li>

      <li>[28] Bünz, B., Mishra, P., Nguyen, W., Wang, W.: Accumulation without homomorphism. Cryptology ePrint Archive, Paper 2024/474 (2024)</li>

      <li>[29] Chen, B., Bünz, B., Boneh, D., Zhang, Z.: Hyperplonk: Plonk with linear-time prover and high-degree custom gates. In: EUROCRYPT (2023)</li>

      <li>[30] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In: EUROCRYPT (2020)</li>

      <li>[31] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: EUROCRYPT (2020)</li>

      <li>[32] Dimitriou, N., Garreta, A., Manzur, I., Vlasov, I.: Mova: Nova folding without committing to error terms. Cryptology ePrint Archive, Paper 2024/1220 (2024)</li>

      <li>[33] Drake, J.: ZK Whiteboard Sessions - Module Fourteen: Nova Crash Course with Justin Drake. https://www.youtube.com/watch?v=SwonTtOQzAk (2022)</li>

      <li>[34] Eagen, L., Gabizon, A.: Protogalaxy: Efficient ProtoStar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106 (2023)</li>

      <li>[35] Eagen, L., Gabizon, A., Sefranek, M., Towa, P., Williamson, Z.J.: Stackproofs: Private proofs of stack and contract execution using protogalaxy. Cryptology ePrint Archive, Paper 2024/1281 (2024)</li>

      <li>[36] Ferrara, A.L., Green, M., Hohenberger, S., Pedersen, M.Ø.: Practical short signature batch verification. In: Fischlin, M. (ed.) Topics in Cryptology – CT-RSA 2009. pp. 309–324. Springer Berlin Heidelberg, Berlin, Heidelberg (2009)</li>

      <li>[37] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: CRYPTO. pp. 186–194 (1986)</li>

      <li>[38] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. ePrint Report 2019/953 (2019)</li>

      <li>[39] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT (2013)</li>

      <li>[40] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. Cryptology ePrint Archive, Paper 2019/458 (2019)</li>

      <li>[41] Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT (2016)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42] Haböck, U.: Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Paper 2022/1530 (2022)</li>

      <li>[43] Jie, K.W.: A minimum-viable KZG polynomial commitment scheme implementation. https://ethresear.ch/t/a-minimum-viable-kzg-polynomial-commitment-scheme-implementation-7675 (July 2020)</li>

      <li>[44] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASI-ACRYPT. pp. 177–194 (2010)</li>

      <li>[45] Khovratovich, D., Maller, M., Tiwari, P.R.: MinRoot: candidate sequential function for Ethereum VDF. Cryptology ePrint Archive, Paper 2022/1626 (2022)</li>

      <li>[46] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: STOC (1992)</li>

      <li>[47] Kothapalli, A., Parno, B.: Algebraic reductions of knowledge. In: CRYPTO (2023)</li>

      <li>[48] Kothapalli, A., Setty, S.: SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive (2022)</li>

      <li>[49] Kothapalli, A., Setty, S.: Cyclefold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Paper 2023/1192 (2023), https://eprint.iacr.org/2023/1192, https://eprint.iacr.org/2023/1192</li>

      <li>[50] Kothapalli, A., Setty, S.: HyperNova: Recursive arguments for customizable constraint systems. In: CRYPTO (2024)</li>

      <li>[51] Kothapalli, A., Setty, S.: NeutronNova: Folding everything that reduces to zero-check. Cryptology ePrint Archive, Paper 2024/1606 (2024), https://eprint.iacr.org/2024/1606</li>

      <li>[52] Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive Zero-Knowledge Arguments from Folding Schemes. In: CRYPTO (2022)</li>

      <li>[53] Lee, J., Nikitin, K., Setty, S.: Replicated state machines without replicated execution. In: S&P (2020)</li>

      <li>[54] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. In: FOCS (Oct 1990)</li>

      <li>[55] Micali, S.: CS proofs. In: FOCS (1994)</li>

      <li>[56] Nguyen, W., Boneh, D., Setty, S.: Revisiting the Nova proof system on a cycle of curves. Cryptology ePrint Archive, Paper 2023/969 (2023)</li>

      <li>[57] Papamanthou, C., Shi, E., Tamassia, R.: Signatures of correct computation. In: TCC (2013)</li>

      <li>[58] Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. J. ACM 27(4) (1980)</li>

      <li>[59] Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: CRYPTO (2020)</li>

      <li>[60] Setty, S., Lee, J.: Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Report 2020/1275 (2020)</li>

      <li>[61] Setty, S., Thaler, J.: BabySpartan: Lasso-based SNARK for non-uniform computation. Cryptology ePrint Archive, Paper 2023/1799 (2023), https://eprint.iacr.org/2023/1799</li>

      <li>[62] Setty, S., Thaler, J., Wahby, R.: Customizable constraint systems for succinct arguments. Cryptology ePrint Archive (2023)</li>

      <li>[63] Setty, S., Thaler, J., Wahby, R.: Unlocking the lookup singularity with lasso. In: EUROCRYPT (2024)</li>

      <li>[64] Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: CRYPTO (2013)</li>

      <li>[65] Thaler, J.: Proofs, arguments, and zero-knowledge. http://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.html (2020)</li>

      <li>[66] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: TCC. pp. 552–576 (2008)</li>

      <li>[67] Vu, V., Setty, S., Blumberg, A.J., Walfish, M.: A hybrid architecture for verifiable computation. In: S&P (2013)</li>

      <li>[68] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: S&P (2018)</li>

      <li>[69] Wesolowski, B.: Efficient verifiable delay functions. In: EUROCRYPT. pp. 379–407 (2019)</li>

      <li>[70] WhiteHat, B., Gluchowski, A., HarryR, Fu, Y., Castonguay, P.: Roll_up / roll_back snark side chain ~17000 tps. https://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675 (Oct 2018)</li>

    </ul>

    <p class="text-gray-300">Appendix A Additional background</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">A.1 Polynomials and multilinear extensions</h3>

    <p class="text-gray-300">We adapt this section from prior work <em>[59]</em>. We recall several definitions and results regarding multivariate polynomials.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition A.1 (Multilinear polynomial).</h6>

    <p class="text-gray-300">A multivariate polynomial is called a multilinear polynomial if the degree of the polynomial in each variable is at most one.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition A.2 (Multilinear polynomial extension).</h6>

    <p class="text-gray-300">Given a vector <span class="math">v\\in\\mathds{F}^{n}</span> a multilinear polynomial extension of <span class="math">v</span> is an <span class="math">(\\log n)</span>-variate multilinear polynomial, denoted <span class="math">\\widetilde{v}</span>, such that <span class="math">\\widetilde{v}(x)=v_{x}</span> for all <span class="math">x\\in\\{0,1\\}^{\\log n}</span>. Specifically, <span class="math">\\widetilde{v}</span> can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{v}(x)=\\sum_{y\\in\\{0,1\\}^{\\ell}}v_{y}\\cdot\\mathsf{eq}(x,y)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{eq}(x,y)=\\prod_{i=1}^{\\ell}(x_{i}\\cdot y_{i}+(1-x_{i})\\cdot(1-y_{i}))</span>, outputs <span class="math">1</span> if <span class="math">x=y</span> and <span class="math">0</span> otherwise for <span class="math">x,y\\in\\{0,1\\}^{\\log n}</span>.</p>

    <p class="text-gray-300">For any <span class="math">r\\in\\mathds{F}^{\\ell}</span>, <span class="math">\\widetilde{v}(r)</span> can be computed in <span class="math">O(2^{\\ell})</span> operations in <span class="math">\\mathds{F}</span> <em>[64, 67]</em>.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Lemma A.1 (Schwartz-Zippel <em>[58]</em>).</h6>

    <p class="text-gray-300">let <span class="math">g:\\mathds{F}^{\\ell}\\to\\mathds{F}</span> be an <span class="math">\\ell</span>-variate polynomial of total degree at most <span class="math">d</span>. Then, on any finite set <span class="math">S\\subseteq\\mathds{F}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\leftarrow S^{\\ell}}[g(x)=0]\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">A.2 Commitment Schemes</h3>

    <h6 id="sec-71" class="text-base font-medium mt-4">Definition A.3 (Commitment Scheme).</h6>

    <p class="text-gray-300">A commitment scheme is defined by polynomial-time algorithm <span class="math">\\mathsf{Gen}:\\mathbb{N}^{2}\\to P</span> that produces public parameters given the security parameter and size parameter, a deterministic polynomial-time algorithm <span class="math">\\mathsf{Com}:P\\times M\\times R\\to C</span> that produces a commitment in <span class="math">C</span> given a public parameters, message, and randomness tuple such that binding holds. That is, for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(\\lambda,n)</span>, and given <span class="math">((m_{1},r_{1}),(m_{2},r_{2}))\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[(m_{1},r_{1})\\neq(m_{2},r_{2})\\land\\mathsf{Com}(\\mathsf{pp},m_{1},r_{1})=\\mathsf{Com}(\\mathsf{pp},m_{2},r_{2})]\\approx 0.</span></p>

    <p class="text-gray-300">The commitment scheme is deterministic if <span class="math">\\mathsf{Com}</span> does not use its randomness.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Definition A.4 (Homomorphic).</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span> is homomorphic if the message space <span class="math">M</span>, randomness space <span class="math">R</span>, and commitment space <span class="math">C</span> are groups and for all <span class="math">n\\in\\mathbb{N}</span>, and <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(\\lambda,n)</span>, we have that for any <span class="math">m_{1},m_{2}\\in M</span> and <span class="math">r_{1},r_{2}\\in R</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Com}(\\mathsf{pp},m_{1},r_{1})+\\mathsf{Com}(\\mathsf{pp},m_{2},r_{2})=\\mathsf{Com}(\\mathsf{pp},m_{1}+m_{2},r_{1}+r_{2}).</span></p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition A.5 (Succinct Commitments).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A commitment scheme <span class="math">(\\mathsf{Gen},\\mathsf{Com})</span>, over message space <span class="math">M</span> and commitment space <span class="math">R</span>, provides succinct commitments if for all <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Gen}(1^{\\lambda})</span>, and any <span class="math">m\\in M</span> and <span class="math">r\\in R</span>, we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Com}(\\mathsf{pp},m,r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O_{\\lambda}(\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We modify the original definition to account for the preprocessed setting, in which a deterministic encoder algorithm preprocesses a portion of the statement called the structure (typically encoding a circuit or set of constraints) once and outputs a prover and verifier key which can be used to verify any number of witnesses (e.g., variable assignments) against this structure. We enable the encoder to additionally output a new structure to check the output instance-witness pair against (this can be preprocessed by a subsequent encoder).</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Definition A.6 (Reduction of Knowledge <em>[47]</em>).</h6>

    <p class="text-gray-300">Consider relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> over public parameters, structure, instance, and witness tuples. A reduction of knowledge from <span class="math">\\mathcal{R}_{1}</span> to <span class="math">\\mathcal{R}_{2}</span> is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic algorithm <span class="math">\\mathcal{K}</span>, called the generator, the prover, the verifier and the encoder respectively:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(\\lambda,n)\\to\\mathsf{pp}</span>: Takes as input security parameter <span class="math">\\lambda</span> and size parameters <span class="math">n</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})\\to(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span> and structure <span class="math">\\mathsf{s}_{1}</span>. Outputs prover key <span class="math">\\mathsf{pk}</span>, verifier key <span class="math">\\mathsf{vk}</span>, and updated structure <span class="math">\\mathsf{s}_{2}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},u_{1},w_{1})\\to(u_{2},w_{2})</span>: Takes as input <span class="math">\\mathsf{pk}</span>, and an instance-witness pair <span class="math">(u_{1},w_{1})</span>. Reduces the task of checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span> to checking <span class="math">(\\mathsf{pp},\\mathsf{s},u_{2},w_{2})\\in\\mathcal{R}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},u_{1})\\to u_{2}</span>: Takes as input <span class="math">\\mathsf{vk}</span>, and an instance <span class="math">u_{1}</span> in <span class="math">\\mathcal{R}_{1}</span>. Reduces the task of checking instance <span class="math">u_{1}</span> to the task of checking a new instance <span class="math">u_{2}</span> in <span class="math">\\mathcal{R}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> denote the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. We treat <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> as a function that takes as input <span class="math">((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1})</span> and runs the interaction on the prover’s input <span class="math">(\\mathsf{pk},u_{1},w_{1})</span> and the verifier’s input <span class="math">(\\mathsf{vk},u_{1})</span>. At the end of the interaction, <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> outputs the verifier’s instance <span class="math">u_{2}</span> and the prover’s witness <span class="math">w_{2}</span>. A reduction of knowledge <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies the following conditions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For any PPT adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n)</span>, <span class="math">(\\mathsf{s}_{1},u_{1},w_{1})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1}</span> and <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})</span> we have that the prover’s output instance is equal to the verifier’s output instance <span class="math">u_{2}</span>, and that</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathsf{s}_{2},\\langle\\mathcal{P},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},w_{1}))\\in\\mathcal{R}_{2}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness: For any expected polynomial-time adversaries <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{P}^{*}</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n)</span>, <span class="math">(\\mathsf{s}_{1},u_{1},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})</span>, we have that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[(\\mathsf{pp},\\mathsf{s}_{1},u_{1},\\mathcal{E}(\\mathsf{pp},\\mathsf{s},u_{1},\\mathsf{st}))\\in\\mathcal{R}_{1}]\\approx\\Pr[(\\mathsf{pp},\\mathsf{s}_{2},\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},\\mathsf{st}))\\in\\mathcal{R}_{2}].</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public reducibility: There exists a deterministic polynomial-time function <span class="math">\\varphi</span> such that for any PPT adversary <span class="math">\\mathcal{A}</span> and expected polynomial-time adversary <span class="math">\\mathcal{P}^{*}</span>, given</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}</span> <span class="math">\\leftarrow\\mathcal{G}(\\lambda,n),</span> <span class="math">(\\mathsf{s}_{1},u_{1},\\mathsf{st})</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathsf{pp}),</span> <span class="math">(\\mathsf{pk},\\mathsf{vk},\\mathsf{s}_{2})</span> <span class="math">\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1}),</span></p>

    <p class="text-gray-300">and <span class="math">(u_{2},w_{2})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),u_{1},\\mathsf{st})</span> with the interaction transcript <span class="math">\\mathsf{tr}</span>, we have that <span class="math">\\varphi(\\mathsf{pp},\\mathsf{s}_{1},u_{1},\\mathsf{tr})=u_{2}</span>.</p>

    <p class="text-gray-300">We can define various additional properties for RoKs such as succinctness (the communication is sublinear in the witness size), non-interactivity (the interaction is a single message from the prover), public-coin (the verifier only sends random challenges), and tree-extractability (there exists an extractor that can produce a satisfying witness given a tree of accepting transcripts). We define these properties in Appendix A.3.</p>

    <p class="text-gray-300">Typically, we are interested in reducing several relations at once. We can interpret several relations as a single relation using the following product operator.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Definition A.7 (Relation product).</h6>

    <p class="text-gray-300">For relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> over public parameter, structure, instance, and witness pairs we define the relation product as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{1}\\times\\mathcal{R}_{2}=\\left\\{\\ \\ (\\mathsf{pp},\\mathsf{s},(u_{1},u_{2}),(w_{1},w_{2}))\\ \\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\ \\ (\\mathsf{pp},\\mathsf{s},u_{1},w_{1})\\in\\mathcal{R}_{1},(\\mathsf{pp},\\mathsf{s},u_{2},w_{2})\\in\\mathcal{R}_{2}\\ \\ \\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let <span class="math">\\mathcal{R}^{n}</span> denote <span class="math">\\mathcal{R}\\times\\ldots\\times\\mathcal{R}</span> for <span class="math">n</span> times.</p>

    <p class="text-gray-300">A motivating property of RoKs is that they are composable, allowing us to build complex reductions by stitching together simpler ones. In particular, given reductions <span class="math">\\Pi_{1}:\\mathcal{R}_{1}\\to\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}:\\mathcal{R}_{2}\\to\\mathcal{R}_{3}</span> we have that <span class="math">\\Pi_{2}\\circ\\Pi_{1}</span> (that is, running <span class="math">\\Pi_{1}</span> first and then running <span class="math">\\Pi_{2}</span> on the outputs) is a reduction of knowledge from <span class="math">R_{1}</span> to <span class="math">\\mathcal{R}_{3}</span>. Similarly, given reductions <span class="math">\\Pi_{1}:\\mathcal{R}_{1}\\to\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}:\\mathcal{R}_{3}\\to\\mathcal{R}_{4}</span> we have that <span class="math">\\Pi_{1}\\times\\Pi_{2}</span> (that is, independently running <span class="math">\\Pi_{1}</span> and <span class="math">\\Pi_{2}</span> on pairs of inputs) is a reduction of knowledge from <span class="math">\\mathcal{R}_{1}\\times\\mathcal{R}_{3}</span> to <span class="math">\\mathcal{R}_{2}\\times\\mathcal{R}_{4}</span>.</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">A.3. Reductions of Knowledge</h3>

    <p class="text-gray-300">First, we define additional properties of reductions of knowledge.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Definition A.8 (Succinctness).</h6>

    <p class="text-gray-300">A reduction of knowledge is succinct if the communication complexity and the verifier time complexity is at most poly-logarithmic in the size of the structure and witness.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Definition A.9 (Non-interactivity).</h6>

    <p class="text-gray-300">A reduction of knowledge is non-interactive if the interaction consists of a single message from the prover to the verifier. In this case, we denote this single message as the output of the prover, and as an input to the verifier.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Definition A.10 (Public-coin).</h6>

    <p class="text-gray-300">A reduction of knowledge is public-coin if the verifier only sends uniformly random challenges during the interaction.</p>

    <p class="text-gray-300">Next, we define the semantics of the sequential and parallel composition operators.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma A.2 (Sequential composition <em>[47]</em>).</h6>

    <p class="text-gray-300">For reductions <span class="math">\\Pi_{1}=(\\mathcal{G},\\mathcal{K}_{1},\\mathcal{P}_{1},\\mathcal{V}_{1}):\\mathcal{R}_{1}\\rightarrow\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}=(\\mathcal{G},\\mathcal{K}_{2},\\mathcal{P}_{2},\\mathcal{V}_{2}):\\mathcal{R}_{2}\\rightarrow\\mathcal{R}_{3}</span>, we have that <span class="math">\\Pi_{2}\\circ\\Pi_{1}=(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V}):\\mathcal{R}_{1}\\rightarrow\\mathcal{R}_{3}</span> where <span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1})</span> computes <span class="math">(\\mathsf{pk}_{1},\\mathsf{vk}_{1},\\mathsf{s}_{2})\\leftarrow\\mathcal{K}_{1}(\\mathsf{pp},\\mathsf{s}_{1})</span>, <span class="math">(\\mathsf{pk}_{2},\\mathsf{vk}_{2},\\mathsf{s}_{3})\\leftarrow\\mathcal{K}_{2}(\\mathsf{pp},\\mathsf{s}_{2})</span> and outputs <span class="math">((\\mathsf{pk}_{1},\\mathsf{pk}_{2}),(\\mathsf{vk}_{1},\\mathsf{vk}_{2}),\\mathsf{s}_{3})</span> and where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}((\\mathsf{pk}_{1},\\mathsf{pk}_{2}),u_{1},w_{1})</span> <span class="math">=\\mathcal{P}_{2}(\\mathsf{pk}_{2},\\mathcal{P}_{1}(\\mathsf{pk}_{1},u_{1},w_{1}))</span> <span class="math">\\mathcal{V}((\\mathsf{vk}_{1},\\mathsf{vk}_{2}),u_{1})</span> <span class="math">=\\mathcal{V}_{2}(\\mathsf{vk}_{2},\\mathcal{V}_{1}(\\mathsf{vk}_{1},u_{1},w_{1}))</span></p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma A.3 (Parallel composition <em>[47]</em>).</h6>

    <p class="text-gray-300">Consider relations <span class="math">\\mathcal{R}_{1}</span>, <span class="math">\\mathcal{R}_{2}</span>, <span class="math">\\mathcal{R}_{3}</span>, and <span class="math">\\mathcal{R}_{4}</span>. For reductions of knowledge <span class="math">\\Pi_{1}=(\\mathcal{G},\\mathcal{K},\\mathcal{P}_{1},\\mathcal{V}_{1}):\\mathcal{R}_{1}\\rightarrow\\mathcal{R}_{2}</span> and <span class="math">\\Pi_{2}=(\\mathcal{G},\\mathcal{K},\\mathcal{P}_{2},\\mathcal{V}_{2}):\\mathcal{R}_{3}\\rightarrow\\mathcal{R}_{4}</span> we have that <span class="math">\\Pi_{1}\\times\\Pi_{2}=(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V}):\\mathcal{R}_{1}\\times\\mathcal{R}_{3}\\rightarrow\\mathcal{R}_{2}\\times\\mathcal{R}_{4}</span> where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(u_{1},u_{3}),(w_{1},w_{3}))</span> <span class="math">=(\\mathcal{P}_{1}(\\mathsf{pk},u_{1},w_{1}),\\mathcal{P}_{2}(\\mathsf{pk},u_{3},w_{3}))</span> <span class="math">\\mathcal{V}(\\mathsf{vk},(u_{1},u_{3}))</span> <span class="math">=(\\mathcal{V}_{1}(\\mathsf{vk},u_{1}),\\mathcal{V}_{2}(\\mathsf{vk},u_{3}))</span></p>

    <p class="text-gray-300">Next, we can define arguments of knowledge as a special type of reduction of knowledge.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Definition A.11 (Argument of Knowledge).</h6>

    <p class="text-gray-300">Consider the boolean relation <span class="math">\\mathsf{TRUE}=\\{(\\mathsf{true},\\bot)\\}</span>. A proof of knowledge for relation <span class="math">\\mathcal{R}</span> is a reduction of knowledge of type <span class="math">\\mathcal{R}\\rightarrow\\mathsf{TRUE}</span>.</p>

    <p class="text-gray-300">When proving the security of protocols, reasoning about knowledge soundness directly is typically cumbersome. To alleviate this issue, Bootle et al. <em>[20]</em> show that to prove knowledge soundness for the vast majority of public-coin interactions, it is sufficient to show that there exists an extractor that can produce a satisfying witness when provided a tree of accepting transcripts with refreshed verifier randomness at each layer. This property is known as tree-extractability and we formally state the corresponding result for reductions of knowledge (proven by Kothapalli and Parno <em>[47]</em>).</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Definition A.12 (Tree of transcripts).</h6>

    <p class="text-gray-300">Consider an <span class="math">m</span>-round public-coin interactive protocol <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> that satisfies the interface described in Definition A.6. For a public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1})</span>, a <span class="math">(n_{1},\\ldots,n_{m})</span>-tree of accepting transcripts is a tree of depth <span class="math">m</span> where each vertex at layer <span class="math">i</span> has <span class="math">n_{i}</span> outgoing edges such that (1) each vertex in layer <span class="math">i\\in[m]</span> is labeled with a prover message for round <span class="math">i</span>; (2) each outgoing edge from layer <span class="math">i\\in[m]</span> is labeled with a different choice of verifier randomness for round <span class="math">i</span>; (3) each leaf is labeled with an accepting statement-witness pair output by the prover and verifier corresponding to the interaction along the path.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Lemma A.4 (Tree extraction <em>[47]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider an <span class="math">m</span>-round public-coin interactive protocol <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> that satisfies the interface described in Definition A.6 and satisfies completeness. Then <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> is a reduction of knowledge if there exists a PPT extractor <span class="math">\\chi</span> that outputs a satisfying witness <span class="math">w_{1}</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>, given an <span class="math">(n_{1},\\ldots,n_{m})</span>-tree of accepting transcripts for public parameter, structure, instance tuple <span class="math">(\\mathsf{pp},\\mathsf{s},u_{1})</span> where the verifier’s randomness is sampled from space <span class="math">Q</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{\\lambda})<span class="math">, and </span>\\prod_{i}n_{i}=\\mathsf{poly}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-85" class="text-xl font-semibold mt-8">A.4. Incrementally Verifiable Computation</h3>

    <p class="text-gray-300">Recall that incrementally verifiable computation (IVC), enables a prover to to produce a proof <span class="math">\\pi_{i+1}</span> for <span class="math">i+1</span> steps of a computation given a proof <span class="math">\\pi_{i}</span> for <span class="math">i</span> steps of the computation in a way that ensures that the proof size remains independent of the total steps of computation. As IVC is a major application of folding schemes <em>[50, 25, 52]</em>, for completeness, we recall the formal definition below.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition A.13 (Incrementally verifiable computation (IVC)).</h6>

    <p class="text-gray-300">An incrementally verifiable computation (IVC) scheme is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic <span class="math">\\mathcal{K}</span> denoting the generator, the prover, the verifier, and the encoder respectively, with the following interface</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},N)\\rightarrow\\mathsf{pp}</span>: on input security parameter <span class="math">\\lambda</span> and size bounds <span class="math">N</span>, samples public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>: on input public parameters <span class="math">\\mathsf{pp}</span>, and polynomial-time function <span class="math">F</span>, deterministically produces a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i})\\rightarrow\\Pi_{i+1}</span>: on input a prover key <span class="math">\\mathsf{pk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_{0}</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_{i}</span>, a non-deterministic advice <span class="math">\\omega_{i}</span>, and an IVC proof <span class="math">\\Pi_{i}</span> attesting to <span class="math">z_{i}</span>, produces a new proof <span class="math">\\Pi_{i+1}</span> attesting to <span class="math">z_{i+1}=F(z_{i},\\omega_{i})</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi_{i})\\rightarrow\\{0,1\\}</span>: on input a verifier key <span class="math">\\mathsf{vk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_{0}</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_{i}</span>, and an IVC proof <span class="math">\\Pi_{i}</span> attesting to <span class="math">z_{i}</span>, outputs <span class="math">1</span> if <span class="math">\\Pi_{i}</span> is accepting, and <span class="math">0</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">An IVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies the following requirements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: For any PPT adversary <span class="math">\\mathcal{A}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} \\mathcal {V} (\\mathsf {v k}, (i + 1, z _ {0}, z _ {i + 1}), \\Pi_ {i + 1}) = 1 \\\\ \\text {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ F, (i, z _ {0}, z _ {i}, \\Pi_ {i}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F), \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}), \\\\ \\mathcal {V} (\\mathsf {v k}, i, z _ {0}, z _ {i}, \\Pi_ {i}) = 1, \\\\ \\Pi_ {i + 1} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\Pi_ {i}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">where <span class="math">F</span> is a polynomial-time computable function represented as an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: Consider constant <span class="math">n \\in \\mathbb{N}</span>. For all expected polynomial-time adversaries <span class="math">\\mathcal{P}^*</span> there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\Pr_ {\\mathbf {r}} \\left[ \\begin{array}{l l} z _ {n} = z \\text { where} &amp;amp; \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}) &amp;amp; (F, (z _ {0}, z _ {i}), \\Pi) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}, \\mathsf {r}), \\\\ \\forall i \\in \\{0, \\ldots , n - 1 \\} &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F), \\\\ &amp;amp; \\mathcal {V} (\\mathsf {v k}, (n, z _ {0}, z), \\Pi) = 1, \\\\ &amp;amp; (\\omega_ {0}, \\ldots , \\omega_ {n - 1}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {r}) \\end{array} \\right] \\approx 1</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{r}</span> denotes an arbitrarily long random tape. Moreover, <span class="math">F</span> is a polynomial-time computable function represented as an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: The size of an IVC proof <span class="math">\\Pi</span> is independent of the number of iterations <span class="math">n</span>.</li>

    </ol>

    <h2 id="sec-87" class="text-2xl font-bold">Appendix B. Details on polyeval with matrix commitment</h2>

    <p class="text-gray-300">Suppose that we have witness vectors <span class="math">(Q_{1}, Q_{2})</span> for instances in <span class="math">\\mathsf{MPE}^2</span> i.e., each has <span class="math">n</span> field elements of <span class="math">E_{2}</span>. Suppose that their commitments are <span class="math">q_{1}</span> and <span class="math">q_{2}</span> respectively, each containing <span class="math">n_{1}</span> curve points on <span class="math">E_{2}</span>.</p>

    <p class="text-gray-300">To evaluate both <span class="math">Q_{1}</span> and <span class="math">Q_{2}</span> at the same point <span class="math">x</span> (i.e., <span class="math">x = x_{1} = x_{2}</span>), the verifier produces a challenge <span class="math">c</span> (e.g., using a transcript in the non-interactive version), and combine two matrices into one by <span class="math">Q \\gets Q_{1} + c \\cdot Q_{2}</span>. We split <span class="math">x</span> with <span class="math">\\ell = \\log n</span> scalars of <span class="math">E_{2}</span> into <span class="math">(r_{1}, r_{2}) \\gets x</span>, where <span class="math">r_{1}</span> gets the first <span class="math">\\log n_{1}</span> scalars and <span class="math">r_{2}</span> gets the rest <span class="math">\\log n_{2}</span> scalars (both <span class="math">n_{1}</span> and <span class="math">n_{2}</span> are powers of 2 in our context). Then, we fold <span class="math">n_{1}</span> rows of <span class="math">Q</span> into one row—a vector <span class="math">Q&#x27;</span> of <span class="math">n_{2}</span> scalars—by taking a weighted sum, where the weight of <span class="math">i</span>-th row of <span class="math">Q</span> equals to <span class="math">\\operatorname{eq}(r_{1}, i)</span>. This effectively evaluates the polynomial using the tensor structure of multilinear polynomial evaluations [68].</p>

    <p class="text-gray-300">We now describe a more refined polyeval that checks the purported instance-witness pairs of <span class="math">\\mathsf{MPE}^2</span>, and output the instance. All arguments are taken as non-deterministic advice, and hash is a hash function (e.g., Poseidon).</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {p o l y e v a l} \\left(\\mathrm {p p}, q _ {1}, q _ {2}, c, x, Q ^ {\\prime}\\right)\\rightarrow (d, c, x, y)</span></div>

    <p class="text-gray-300">(1) parse pp as <span class="math">(n_{1}, n_{2}, \\mathsf{ck})</span>, where ck is the Pedersen's commitment key. (2) compute <span class="math">o_1 \\gets \\operatorname{Com}(\\operatorname{ck}, Q&#x27;)</span>. (3) parse <span class="math">x</span> as <span class="math">(r_1, r_2)</span>, which is described above. (4) compute <span class="math">T \\gets (\\operatorname{eq}(r_1, 0), \\dots, \\operatorname{eq}(r_1, n_1 - 1))</span>, (5) compute <span class="math">q \\gets q_{1} + c \\cdot q_{2}</span>, (6) compute <span class="math">o_2 \\gets \\operatorname{Com}(q, T)</span> // an MSM. (7) check that <span class="math">o_1 = o_2</span>. (8) compute <span class="math">y \\gets \\widehat{Q&#x27;}(r_2)</span>, which is the evaluation. (9) compute <span class="math">d \\gets \\mathrm{hash}((q_1, q_2))</span>. (10) output <span class="math">(d, c, x, y)</span>.</p>

    <p class="text-gray-300">As before, polyeval can be efficiently represented by an R1CS circuit over the base field of <span class="math">E_{2}</span> (i.e., the scalar field of <span class="math">E_{1}</span>). The circuit hardcodes the public parameters pp and places the instances checked in the public IO.</p>

    <p class="text-gray-300">Appendix C Meta-Review</p>

    <p class="text-gray-300">The following meta-review was prepared by the program committee for the 2025 IEEE Symposium on Security and Privacy (S&P) as part of the review process as detailed in the call for papers.</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">C.1 Summary</h3>

    <p class="text-gray-300">MicroNova improves on prior designs and implementations of incrementally verifiable computation. The final proof output after any number of iterations of a function <span class="math">F</span> is of size <span class="math">O(\\log n)</span> group elements and can be verified with <span class="math">O(\\log n)</span> group scalar multiplications and two pairing operations where <span class="math">n</span> is the constraint complexity of <span class="math">F</span>.</p>

    <p class="text-gray-300">There is a well-known approach to compressing IVC proofs using SNARKs (proof composition). MicroNova is an optimized instantiation of this general idea for Nova. Previously, Nova used Spartan with IPA-based polynomial commitment scheme to compress the final IVC proof. The time to verify is <span class="math">O(n)</span>. This paper both modifies Nova and builds a verifier-efficient version of Spartan using as its polynomial commitment scheme a new KZG variant for multilinear polynomials. It then uses this in place of Spartan to compress Nova IVC proofs. It demonstrates that verification can reasonably be executed via a smart contract on Ethereum.</p>

    <h3 id="sec-89" class="text-xl font-semibold mt-8">C.2 Scientific Contributions</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>provides a valuable step forward in an established field</li>

    </ul>

    <h3 id="sec-90" class="text-xl font-semibold mt-8">C.3 Reasons for Acceptance</h3>

    <p class="text-gray-300">The paper is well written, has a thorough experimental section, achieves practical results, and presents a number of techniques that may be of independent interest.</p>`;
---

<BaseLayout title="MicroNova: Folding-based arguments with efficient (on-chain)... (2024/2099)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/2099
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
