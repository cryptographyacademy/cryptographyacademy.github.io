---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1038';
---

<BaseLayout title="Reinforced Concrete: A Fast Hash Function for Verifiable Computation (2021/1038)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Reinforced Concrete: A Fast Hash Function for Verifiable
        Computation
      </h1>
      <p class="text-gray-400 mb-2">
        Lorenzo Grassi, Dmitry Khovratovich,
        Reinhard L&uuml;ftenegger, Christian Rechberger,
        Markus Schofnegger, Roman Walch
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; CCS 2022 &middot; eprint 2021/1038
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">RC in a Nutshell</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Security Requirements and
            Claims</a>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Specification and Rationale</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">The Bricks Function</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">The Concrete Function</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">The Bars Function</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">Sponge Framework
                Parameters</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Security Analysis</a>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Lookup Tables and System of
            Constraints for Bar</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-6.1"
                class="hover:text-white">Soundness and
                Completeness</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">Concrete Instances</a>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">Performance</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-8.1"
                class="hover:text-white">Proof System
                Performance</a>
            </li>
            <li>
              <a href="#sec-8.2"
                class="hover:text-white">Plain Implementation
                Performance</a>
            </li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#app-a"
            class="hover:text-white">A. Bijectivity of RC
            Components</a>
        </li>
        <li>
          <a href="#app-b"
            class="hover:text-white">B. Security Analysis</a>
        </li>
      </ul>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We propose a new hash function Reinforced Concrete, which is
        the first generic purpose hash that is fast both for a
        zero-knowledge prover and in native x86 computations. It is
        suitable for a various range of zero-knowledge proofs and
        protocols, from set membership to generic purpose verifiable
        computation. Being up to 15x faster than its predecessor
        Poseidon hash, Reinforced Concrete inherits security from
        traditional time-tested schemes such as AES, whereas taking the
        zero-knowledge performance from a novel and efficient
        decomposition of a prime field into compact buckets.
      </p>
      <p class="text-gray-300">
        The new hash function is suitable for a wide range of
        applications like privacy-preserving cryptocurrencies,
        verifiable encryption, protocols with state membership proofs,
        or verifiable computation. It may serve as a drop-in
        replacement for various prime-field hashes such as variants of
        MiMC, Poseidon, Pedersen hash, and others.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Hash functions, verifiable
        computation, zksnarks, finite fields
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        The recent years have been marked as a thrive of distributed
        verifiable computation, where the outcome of some algorithm
        <span class="math">\mathcal&#123;A&#125;</span> is accompanied
        with a succinct proof of correctness, widely known as a SNARK.
        Performance of those protocols, however, remains a major
        bottleneck for applications. The reasons are manyfold, but one
        crucial point is that SNARKs are constructed for statements
        formulated over prime fields whereas regular computer programs
        are written for and executed over bitstrings. The necessary
        translation of code into finite field arithmetic carries a
        significant overhead.
      </p>
      <p class="text-gray-300">
        In this paper we remove one of such bottlenecks by offering a
        hash function that is fast both for SNARKs and native
        computation. There already exist functions that excel in either
        of those areas, but not in both. The motivation for such a
        swiss-army tool is the following. To scale, parallelize, and
        aggregate proofs we employ what is called a recursive proof
        protocol, where a party can prove their share of computation
        together with a verification of proof coming from the
        predecessor. This also enables wrapping multiple proofs into a
        single succinct check.
      </p>

      <p class="text-gray-300">
        <strong>Summary of use cases.</strong> The new hash function
        addresses, among others, the following use cases:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4 mb-4">
        <li>
          <strong>Fast and efficient set membership proofs</strong>
          based on Merkle tree accumulators. Immensely popular in
          cryptocurrency protocols, this case requires a hash function
          for the tree. Its ZK circuit should minimize the proof
          creation time.
        </li>
        <li>
          <strong>Verifiable computation</strong> based on recursive
          proofs. Here the entire computation is a chain of functions
          <span class="math">F_1, F_2, \dots, F_k</span> applied
          consecutively to some state. Here we minimize both native
          computation time and the prover time.
        </li>
      </ul>

      <p class="text-gray-300">
        <strong>Summary of requirements.</strong> (1) Minimal prover
        time &mdash; for many ZK proof systems it is a (super)linear
        function of the gate count, where each gate is usually a basic
        field arithmetic operation. (2) Native performance &mdash; a
        hash function should run as fast as possible on typical
        hardware. (3) Security &mdash; it is desirable to base
        security on a more traditional rather than algebraic security
        analysis.
      </p>
      <p class="text-gray-300">
        <strong>Our design: Reinforced Concrete.</strong> We present a
        new sponge hash function Reinforced Concrete (RC) over
        <span class="math">\mathbb&#123;F&#125;_p</span> exploiting
        all the advantages of lookup-equipped proof systems and
        suitable for both membership proofs and verifiable computation
        use cases. The permutation that instantiates RC is composed of
        two types of components: (1) outer ones for preventing
        statistical attacks; (2) an inner one for preventing algebraic
        attacks. The inner part strengthens the whole construction like
        steel bars strengthen concrete, hence the name.
      </p>
      <p class="text-gray-300">
        For the inner component, instead of using simple power maps as
        in Poseidon and Rescue, we use a single building block with a
        complex algebraic structure, which we call Bars. A Bars layer
        can be seen as a non-linear layer composed of independent
        high-degree and dense S-boxes. The Bars function combines a
        layer of S-boxes (such as in AES) with a field element
        decomposition in just a handful of small operations.
      </p>
      <p class="text-gray-300">
        Even if it prevents algebraic attacks, it can be broken by more
        traditional statistical attacks such as rebound attacks. The
        external rounds are instantiated with other layers which are
        known to protect against statistical attacks, including affine
        layers called Concrete that provides full diffusion and a
        low-degree non-linear layer called Bricks.
      </p>
      <p class="text-gray-300">
        <strong>Comparison to other designs.</strong> When compared to
        hash functions tailored to the same use cases, RC is on par in
        the gate metric and much faster in native performance. Over
        generic prime fields (such as the scalar fields of BLS12-381
        or BN254) RC is faster by a factor of 5 compared to Poseidon
        and by a factor of 140 compared to Rescue. Using specially
        crafted fields increases these factors to 16 and 357
        respectively. RC is only 5x slower than Blake2, the fastest
        traditional hash algorithm benchmarked, but requires 7 times
        fewer gates when encoded into a circuit.
      </p>
      <p class="text-gray-300">
        <strong>Supported proof systems.</strong> A number of ZK proof
        system protocols support lookup tables, including Arya,
        Plookup, Halo2, and Cairo. As lookup gates also speed up
        traditional hash functions like SHA-2, the authors expect such
        protocols to become widespread.
      </p>
      <p class="text-gray-300">
        <strong>Restrictions and future work.</strong> A proof system
        should support lookup gates, as otherwise the RC circuit would
        be quite large (around 5000 constraints). Also the Bars
        component is specific for each field, implying some work when
        carrying it to a new curve. Devising a more generic Bars is
        the subject of future work.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. RC IN A NUTSHELL                                          -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. RC in a Nutshell</h2>
      <p class="text-gray-300">
        The RC hash function operates in the sponge framework. The
        sponge converts a fixed length bijective function (called RC
        permutation) to a variable-length hash function, which is
        collision- and preimage-resistant as long as the underlying
        permutation does not exhibit any &ldquo;non-random&rdquo;
        properties up to the bound defined by the security level
        <span class="math">2^\lambda</span> (in our case
        <span class="math">\lambda</span> is universally set to 128).
      </p>
      <p class="text-gray-300">
        The RC permutation can be considered as a modified 7-round SP
        network, where input, output and intermediate state elements
        are from
        <span class="math">\mathbb&#123;F&#125;_p^3</span> for a
        prime number
        <span class="math">p</span>. More formally,
      </p>
      <div class="math-block">
        \mathsf&#123;RC&#125; := \mathsf&#123;Concrete&#125;^&#123;(8)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(7)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(6)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(5)&#125; \circ \mathsf&#123;Bars&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(4)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(3)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(2)&#125; \circ \mathsf&#123;Bricks&#125; \circ \mathsf&#123;Concrete&#125;^&#123;(1)&#125;
      </div>
      <p class="text-gray-300">
        In the following, we refer to Concrete &#x2218; Bricks as
        &ldquo;round&rdquo;.
      </p>
      <p class="text-gray-300">
        We define RC for different
        <span class="math">p</span>, with two (-BN and -BLS) being
        scalar fields of the curves BN254 and BLS12-381, and another
        one (-ST) crafted for a specially chosen field in order to
        deliver the highest performance.
      </p>
      <p class="text-gray-300">
        <strong>Design.</strong> The RC design is a modification of a
        traditional word-oriented SP-network (SPN) for constructing
        cryptographic permutations. It differs from a traditional SPN
        in two aspects: (1) the middle layer of the SP network is
        replaced by a special component called Bars, which does not
        admit a low-degree polynomial description but can be
        implemented as a circuit with reasonable costs in ZK; (2)
        instead of applying independent non-linear transformations on
        single words, RC uses low-degree non-linear layers called
        Bricks that additionally mix different words. The third
        component, Concrete, is an analog of the traditional affine
        layer over
        <span class="math">\mathbb&#123;F&#125;</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. SECURITY REQUIREMENTS AND CLAIMS                          -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Security Requirements and Claims
      </h2>
      <p class="text-gray-300">
        The high-level security claims, which determine the parameter
        selection for RC, are the following:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4 mb-4">
        <li>
          For the sponge hash function with RC, collision and preimage
          resistance up to
          <span class="math">2^&#123;128&#125;</span> field operations
          for 256-bit fields. Ability to instantiate a random oracle
          in protocols up to
          <span class="math">2^&#123;128&#125;</span> calls.
        </li>
        <li>
          For authenticated encryption using RC, confidentiality and
          integrity up to
          <span class="math">2^&#123;128&#125;</span> encrypted
          messages for 256-bit fields.
        </li>
        <li>
          When using RC in other future schemes, a 1-element CICO
          security up to
          <span class="math">2^&#123;128&#125;</span> field
          operations. More concretely, it should be infeasible to find
          such
          <span class="math">x_1, x_2, y_1, y_2</span> such that
        </li>
      </ul>
      <div class="math-block">
        \mathsf&#123;RC&#125;(0, x_1, x_2) = (0, y_1, y_2)
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. SPECIFICATION AND RATIONALE                               -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Specification and Rationale
      </h2>
      <p class="text-gray-300">
        The story behind the design of RC, which has determined its
        inner components, is as follows: (1) We wanted to design a
        hash function which has a high degree as a polynomial and would
        not allow a treatment with algebraic methods such as
        Gr&ouml;bner basis. (2) We sought to have table lookup
        functionality applied to finite field elements rather than
        bitstrings. For this we had to design an efficient way to
        decompose a field element into smaller chunks, apply some
        nonlinear transformation, and then wrap it back (composition).
        This was to become Bars. (3) In order to protect against
        non-algebraic attacks, we had to wrap Bars with additional
        confusion and diffusion layers.
      </p>

      <!-- 4.1 Bricks -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 The Bricks Function
      </h3>
      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition (Bricks)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The function
            <span class="math">\mathsf&#123;Bricks&#125; :
            \mathbb&#123;F&#125;_p^3 \to
            \mathbb&#123;F&#125;_p^3</span> is a non-linear
            permutation of degree
            <span class="math">d = 5</span> (with the requirement
            <span class="math">\gcd(p-1, d) = 1</span>). It is
            defined as
          </p>
          <div class="math-block">
            \mathsf&#123;Bricks&#125;(x_1, x_2, x_3) = \bigl(x_1^d,\; x_2(x_1^2 + \alpha_1 x_1 + \beta_1),\; x_3(x_2^2 + \alpha_2 x_2 + \beta_2)\bigr),
          </div>
          <p class="text-gray-300">
            where
            <span class="math">\alpha_1, \alpha_2, \beta_1, \beta_2
            \in \mathbb&#123;F&#125;_p</span> such that
            <span class="math">\alpha_i^2 - 4\beta_i</span> is not a
            quadratic residue modulo
            <span class="math">p</span>.
          </p>
        </div>
      </div>
      <p class="text-gray-300">
        The invertibility of Bricks relies on the fact that
        <span class="math">z^2 + \alpha z + \beta \neq 0</span> for
        each <span class="math">z \in
        \mathbb&#123;F&#125;_p</span>. See Appendix A.1 for a proof.
      </p>

      <!-- 4.2 Concrete -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 The Concrete Function
      </h3>
      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition (Concrete)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The function
            <span class="math">\mathsf&#123;Concrete&#125;^&#123;(j)&#125; :
            \mathbb&#123;F&#125;_p^3 \to
            \mathbb&#123;F&#125;_p^3</span> denotes the
            multiplication of the state by a
            <span class="math">3 \times 3</span> MDS matrix
            <span class="math">M =
            \mathsf&#123;circ&#125;(2,1,1)</span> with subsequent
            addition of the
            <span class="math">j</span>-th round constant vector
            <span class="math">c^&#123;(j)&#125; \in
            \mathbb&#123;F&#125;_p^3</span>:
          </p>
          <div class="math-block">
            \mathsf&#123;Concrete&#125;^&#123;(j)&#125;(x) := \begin&#123;pmatrix&#125; 2 &amp; 1 &amp; 1 \\ 1 &amp; 2 &amp; 1 \\ 1 &amp; 1 &amp; 2 \end&#123;pmatrix&#125; \times \begin&#123;pmatrix&#125; x_1 \\ x_2 \\ x_3 \end&#123;pmatrix&#125; + c^&#123;(j)&#125;.
          </div>
        </div>
      </div>
      <p class="text-gray-300">
        Note that <span class="math">M</span> is invertible and MDS
        for each <span class="math">p \ge 3</span>. The elements
        <span class="math">c_1^&#123;(j)&#125;, c_2^&#123;(j)&#125;,
        c_3^&#123;(j)&#125;</span> are certain pseudo-random
        constants, generated using e.g. Shake-128 with rejection
        sampling.
      </p>

      <!-- 4.3 Bars -->
      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 The Bars Function
      </h3>
      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition (Bars)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The function
            <span class="math">\mathsf&#123;Bars&#125; :
            \mathbb&#123;F&#125;_p^3 \to
            \mathbb&#123;F&#125;_p^3</span> is defined as
          </p>
          <div class="math-block">
            \mathsf&#123;Bars&#125;(x_1, x_2, x_3) = (\mathsf&#123;Bar&#125;(x_1),\; \mathsf&#123;Bar&#125;(x_2),\; \mathsf&#123;Bar&#125;(x_3)).
          </div>
          <p class="text-gray-300">
            The function
            <span class="math">\mathsf&#123;Bar&#125; :
            \mathbb&#123;F&#125;_p \to
            \mathbb&#123;F&#125;_p</span> is a permutation of
            <span class="math">\mathbb&#123;F&#125;_p</span> coming
            from <span class="math">n</span> smaller permutations
            acting independently on
            <span class="math">n</span> smaller domains
            <span class="math">\mathbb&#123;Z&#125;_&#123;s_1&#125;,
            \ldots,
            \mathbb&#123;Z&#125;_&#123;s_n&#125;</span>. Overall,
          </p>
          <div class="math-block">
            \mathsf&#123;Bar&#125; = \mathsf&#123;Comp&#125; \circ \mathsf&#123;SBox&#125; \circ \mathsf&#123;Decomp&#125;.
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>4.3.1 Decomposition and Composition.</strong> We choose
        the standard representation
        <span class="math">\mathbb&#123;F&#125;_p =
        \&#123;0, 1, \dots, p-1\&#125;</span>, thus identifying an
        element <span class="math">x \in
        \mathbb&#123;F&#125;_p</span> with an integer
        <span class="math">0 \le x \le p-1</span>. The decomposition
        maps
        <span class="math">\mathbb&#123;F&#125;_p \to
        \mathbb&#123;Z&#125;_&#123;s_1&#125; \times \cdots \times
        \mathbb&#123;Z&#125;_&#123;s_n&#125;</span> as
      </p>
      <div class="math-block">
        x = x_1 \cdot s_2 s_3 \cdots s_n + x_2 \cdot s_3 s_4 \cdots s_n + \cdots + x_&#123;n-1&#125; \cdot s_n + x_n = \sum_&#123;i=1&#125;^&#123;n&#125; x_i \prod_&#123;j &gt; i&#125; s_j
      </div>
      <p class="text-gray-300">
        with <span class="math">0 \le x_i &lt; s_i</span> and where
        the <span class="math">s_i</span> are chosen such that
        <span class="math">\prod_&#123;i=1&#125;^&#123;n&#125; s_i
        &gt; p</span>. The digits
        <span class="math">x_i \in
        \mathbb&#123;Z&#125;_&#123;s_i&#125;</span> are determined
        similarly to ordinary base-<span class="math">b</span>
        expansion:
      </p>
      <div class="math-block">
        x_n := x \bmod s_n, \quad x_i := \frac&#123;x - \sum_&#123;j &gt; i&#125; x_j \prod_&#123;k &gt; j&#125; s_k&#125;&#123;\prod_&#123;j &gt; i&#125; s_j&#125; \bmod s_i.
      </div>
      <p class="text-gray-300">
        For convenience we define
        <span class="math">b_i := \prod_&#123;j &gt; i&#125; s_j =
        s_&#123;i+1&#125; s_&#123;i+2&#125; \dots s_n</span>, with
        <span class="math">b_n := 1</span>. The composition
        <span class="math">\mathsf&#123;Comp&#125; :
        \mathbb&#123;Z&#125;_&#123;s_1&#125; \times \cdots \times
        \mathbb&#123;Z&#125;_&#123;s_n&#125; \to
        \mathbb&#123;F&#125;_p</span> is
      </p>
      <div class="math-block">
        \mathsf&#123;Comp&#125;(y_1, \dots, y_n) := \sum_&#123;i=1&#125;^&#123;n&#125; y_i b_i \bmod p.
      </div>

      <p class="text-gray-300">
        <strong>4.3.2 SBox.</strong> Let
        <span class="math">(v_1, v_2, \ldots, v_n) =
        \mathsf&#123;Decomp&#125;(p-1)</span> and let
        <span class="math">p' \le \min_&#123;1 \le i \le n&#125;
        v_i</span>. Then
        <span class="math">x_i</span> is converted as follows:
      </p>
      <div class="math-block">
        y_i := S(x_i) = \begin&#123;cases&#125; f(x_i) &amp; \text&#123;if &#125; x_i &lt; p', \\ x_i &amp; \text&#123;if &#125; x_i \ge p', \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        where <span class="math">f</span> denotes a permutation of
        <span class="math">\mathbb&#123;Z&#125;_&#123;p'&#125;</span>.
        The <span class="math">f</span> function is derived from the
        MiMC cipher (which implicitly requires
        <span class="math">p'</span> being prime).
      </p>

      <!-- 4.4 Sponge -->
      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 Sponge Framework Parameters
      </h3>
      <p class="text-gray-300">
        The bijective transformation RC is used in the sponge framework
        similarly to Poseidon and Rescue. The parameters are:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4 mb-4">
        <li>
          Rate is two
          <span class="math">\mathbb&#123;F&#125;_p</span> elements,
          capacity is one
          <span class="math">\mathbb&#123;F&#125;_p</span> element.
        </li>
        <li>
          Claimed preimage and collision security level of 128 bits.
        </li>
        <li>
          The padding rule is simply to add the 0 element to any input
          of odd length. The very first capacity value is initialized
          by the length-depending constant.
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- 5. SECURITY ANALYSIS                                         -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Security Analysis</h2>
      <p class="text-gray-300">
        This section summarizes the authors&rsquo; own analysis of RC
        security. They customarily reduce the security of the RC hash
        to its resistance against known cryptanalytic attacks,
        focusing on two classes:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4 mb-4">
        <li>
          <strong>Statistical attacks</strong> (including differential,
          linear, rebound, truncated, impossible, MiTM, boomerang)
          cannot be mounted on RC even with the middle component
          replaced with a single Bricks layer up to
          <span class="math">2^&#123;128&#125;</span> field
          operations.
        </li>
        <li>
          The <strong>middle component</strong>
          Bricks-Concrete-Bars-Concrete-Bricks resists invariant
          subspace and algebraic (e.g., Gr&ouml;bner basis) attacks up
          to <span class="math">2^&#123;128&#125;</span> field
          operations.
        </li>
      </ul>
      <p class="text-gray-300">
        The short summary: differential and linear attacks do not work
        as long as the Bricks layer is involved; rebound attacks cannot
        be mounted for 5 or more rounds (at least 2 rounds of security
        margin); no invariant subspace attacks have been found;
        Gr&ouml;bner basis cryptanalysis fails at greatly weakened
        versions (10-bit fields) already. Detailed analysis is
        presented in Appendix B.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. LOOKUP TABLES AND CONSTRAINTS                             -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Lookup Tables and System of Constraints for Bar
      </h2>
      <p class="text-gray-300">
        This section creates tables and a set of constraints such that
        for <span class="math">x, y \in
        \mathbb&#123;F&#125;_p</span> it holds
        <span class="math">y = \mathsf&#123;Bar&#125;(x)</span> if
        and only if this set of constraints is satisfied. Two
        challenges are faced:
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        ml-4 mb-4">
        <li>
          The S-box <span class="math">S_i</span> acts on a domain of
          size <span class="math">s_i</span>, making each S-box
          potentially unique.
        </li>
        <li>
          Since
          <span class="math">\prod_i s_i &gt; p</span>, there exist
          distinct elements in
          <span class="math">\mathbb&#123;Z&#125;_&#123;s_1&#125;
          \times \ldots \times
          \mathbb&#123;Z&#125;_&#123;s_n&#125;</span> that produce
          the same
          <span class="math">x \in
          \mathbb&#123;F&#125;_p</span>. The constraint system must
          prevent this collision.
        </li>
      </ul>
      <p class="text-gray-300">
        These challenges are addressed with two additional sets of
        variables
        <span class="math">(z_1, \ldots, z_n)</span> and
        <span class="math">(c_1, \ldots, c_n)</span>. The variable
        <span class="math">z_i</span> encodes if
        <span class="math">x_i &lt; p'</span>
        (<span class="math">S_i</span> is non-linear) or
        <span class="math">x_i \ge p'</span>
        (<span class="math">S_i</span> is identity):
      </p>
      <div class="math-block">
        z_i := \begin&#123;cases&#125; 0, &amp; \text&#123;if &#125; x_i &lt; p'; \\ 1, &amp; \text&#123;if &#125; x_i \ge p'. \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        The variables <span class="math">(c_1, \ldots, c_n)</span>
        indicate if a tuple overflows
        <span class="math">p</span>. Only sequences output by a
        finite-state automaton
        <span class="math">\mathcal&#123;A&#125;</span> are allowed;
        they characterize all tuples
        <span class="math">(x_1, \ldots, x_n) \in
        \mathbb&#123;N&#125;^n</span> with
        <span class="math">\sum_&#123;i=1&#125;^&#123;n&#125; x_i b_i
        &lt; p</span>.
      </p>

      <p class="text-gray-300">
        Three 4-ary tables are created:
        <span class="math">T_2</span> contains all binary sequences of
        length 4;
        <span class="math">T_3</span> contains all outputs of length 4
        of the automaton
        <span class="math">\mathcal&#123;A&#125;</span>;
        <span class="math">T_1</span> encodes the output of the
        S-boxes <span class="math">S_1, \ldots, S_n</span>.
      </p>

      <p class="text-gray-300">
        The claim is that
        <span class="math">y = \mathsf&#123;Bar&#125;(x)</span> holds
        if and only if for
        <span class="math">x, y \in
        \mathbb&#123;F&#125;_p</span> and
        <span class="math">(x_1, \dots, x_n), (y_1, \dots, y_n) \in
        \mathbb&#123;N&#125;^n</span> the following constraints are
        satisfied:
      </p>
      <div class="math-block">
        \forall\, n \ge i \ge 1 :\; (x_i,\, i \cdot z_i,\, y_i,\, c_i) \in T_1,
      </div>
      <div class="math-block">
        \forall\, \lceil (n-1)/3 \rceil - 1 \ge i \ge 1 :\; (c_&#123;3i-2&#125;,\, c_&#123;3i-1&#125;,\, c_&#123;3i&#125;,\, c_&#123;3i+1&#125;) \in T_3,
      </div>
      <div class="math-block">
        (c_&#123;n-3&#125;,\, c_&#123;n-2&#125;,\, c_&#123;n-1&#125;,\, c_n) \in T_3,
      </div>
      <div class="math-block">
        \forall\, \lceil n/4 \rceil - 1 \ge i \ge 1 :\; (z_&#123;4i-3&#125;,\, z_&#123;4i-2&#125;,\, z_&#123;4i-1&#125;,\, z_&#123;4i&#125;) \in T_2,
      </div>
      <div class="math-block">
        (z_&#123;n-3&#125;,\, z_&#123;n-2&#125;,\, z_&#123;n-1&#125;,\, z_n) \in T_2,
      </div>
      <div class="math-block">
        x = \sum_&#123;i=1&#125;^&#123;n&#125; x_i b_i \bmod p, \qquad y = \sum_&#123;i=1&#125;^&#123;n&#125; y_i b_i \bmod p.
      </div>
      <p class="text-gray-300">
        The total number of lookup constraints is
        <span class="math">n + \lceil (n-1)/3 \rceil + \lceil n/4
        \rceil \approx 1.59n</span>.
      </p>

      <!-- 6.1 Soundness and Completeness -->
      <h3 id="sec-6.1" class="text-xl font-semibold mt-8 mb-3">
        6.1 Soundness and Completeness
      </h3>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 1 (Completeness)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The set of constraints (7)&ndash;(13) is complete, i.e.,
            for any
            <span class="math">x, y \in
            \mathbb&#123;F&#125;_p</span> with
            <span class="math">y =
            \mathsf&#123;Bar&#125;(x)</span> it is possible to
            construct
            <span class="math">\&#123;x_i, y_i, c_i, z_i : 1 \le i
            \le n\&#125;</span> that satisfy them.
          </p>
        </div>
      </div>
      <p class="text-gray-300">
        <em>Proof sketch.</em> The proof proceeds in four steps:
        (1) construct
        <span class="math">x_i, y_i</span> from Decomp and SBox and
        verify constraints (12) and (13);
        (2) define
        <span class="math">z_i</span> satisfying Table
        <span class="math">T_2</span> constraints;
        (3) define
        <span class="math">c_i</span> satisfying Table
        <span class="math">T_3</span> constraints, showing
        that the finite-state automaton
        <span class="math">\mathcal&#123;A&#125;</span> captures all
        valid sequences by ruling out forbidden subsequences
        <span class="math">(2, \ldots)</span>,
        <span class="math">(\ldots, 0, 2, \ldots)</span>,
        <span class="math">(\ldots, 1, 0, \ldots)</span>, and
        <span class="math">(\ldots, 2, 0, \ldots)</span>;
        (4) verify that
        <span class="math">(x_i, i \cdot z_i, y_i, c_i)</span>
        satisfies Table
        <span class="math">T_1</span> constraints by case analysis on
        each possible range of
        <span class="math">x_i</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2 (Soundness)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The set of constraints (7)&ndash;(13) is sound, i.e., for
            any
            <span class="math">x, y \in
            \mathbb&#123;F&#125;_p</span> and any
            <span class="math">\&#123;x_i, y_i, z_i, c_i \in
            \mathbb&#123;N&#125; : 1 \le i \le n\&#125;</span> that
            satisfy them all it holds
            <span class="math">y =
            \mathsf&#123;Bar&#125;(x)</span>.
          </p>
        </div>
      </div>
      <p class="text-gray-300">
        <em>Proof sketch.</em> For
        <span class="math">\mathcal&#123;R&#125;_&#123;&lt;
        p&#125; := \&#123;(z_1, \dots, z_n) \in \mathcal&#123;R&#125;
        : \sum_&#123;i=1&#125;^&#123;n&#125; z_i b_i &lt;
        p\&#125;</span>, the proof shows: (1)
        <span class="math">(x_1, \ldots, x_n) =
        \mathsf&#123;Decomp&#125;(x)</span> by showing the case
        <span class="math">\hat&#123;x&#125; \ge p</span> leads to a
        contradiction via Table
        <span class="math">T_3</span> constraints; (2) for each
        <span class="math">i</span>,
        <span class="math">y_i = S(x_i)</span> follows from Table
        <span class="math">T_1</span> and the binary encoding of
        <span class="math">z_i</span>; (3) combining
        <span class="math">\mathsf&#123;Bar&#125; =
        \mathsf&#123;Comp&#125; \circ \mathsf&#123;SBox&#125; \circ
        \mathsf&#123;Decomp&#125;</span> with constraint (13) yields
        <span class="math">y =
        \mathsf&#123;Bar&#125;(x)</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. CONCRETE INSTANCES                                        -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7. Concrete Instances</h2>
      <p class="text-gray-300">
        The values of
        <span class="math">\alpha_1, \alpha_2, \beta_1,
        \beta_2</span> are:
        for <span class="math">p = p_&#123;\text&#123;BLS381&#125;&#125;</span>:
        <span class="math">(1, 3, 2, 4)</span>;
        for <span class="math">p = p_&#123;\text&#123;BN254&#125;&#125;</span>:
        <span class="math">(1, 3, 2, 4)</span>;
        for <span class="math">p = p_&#123;\text&#123;ST&#125;&#125;</span>:
        <span class="math">(1, 2, 3, 4)</span>.
      </p>
      <p class="text-gray-300">
        For the Bar function, a decomposition into
        <span class="math">n = 27</span> small S-boxes is chosen for
        <span class="math">p</span> being the order of BLS12-381 or
        BN254 curves.
      </p>
      <p class="text-gray-300">
        <strong>BLS12-381.</strong>
        <span class="math">p_&#123;\text&#123;BLS381&#125;&#125; =
        \mathtt&#123;0x73eda753\ldots00000001&#125;</span>. The
        largest prime
        <span class="math">p'</span> smaller than or equal to
        <span class="math">v = \min_&#123;1 \le i \le 27&#125;
        v_i</span> is
        <span class="math">p' = 659</span>.
      </p>
      <p class="text-gray-300">
        <strong>BN254.</strong>
        <span class="math">p_&#123;\text&#123;BN254&#125;&#125; =
        \mathtt&#123;0x30644e72\ldots f0000001&#125;</span>. The
        largest prime
        <span class="math">p'</span> smaller than or equal to
        <span class="math">v</span> is
        <span class="math">p' = 641</span>.
      </p>
      <p class="text-gray-300">
        <strong>Special prime.</strong> A 250-bit prime
        <span class="math">p_&#123;\text&#123;ST&#125;&#125;</span>
        has been crafted for proof systems that are not elliptic curve
        based, admitting the representation:
      </p>
      <div class="math-block">
        p_&#123;\text&#123;ST&#125;&#125; = 2^&#123;250&#125; - 3 \cdot 2^&#123;241&#125; + 1 = \sum_&#123;i=0&#125;^&#123;24&#125; (2^&#123;10&#125; - 6) \cdot 2^&#123;10i&#125; + 1,
      </div>
      <p class="text-gray-300">
        i.e.,
        <span class="math">s_2 = s_3 = \dots = s_&#123;24&#125; =
        1024</span>,
        <span class="math">s_&#123;25&#125; = 1023</span>,
        <span class="math">v_1 = v_2 = \dots = v_&#123;25&#125; =
        1018</span>. This makes the decomposition and modular
        reduction extremely fast.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 8. PERFORMANCE                                               -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8. Performance</h2>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8 mb-3">
        8.1 Proof System Performance
      </h3>
      <p class="text-gray-300">
        <strong>8.1.1 Circuit metrics.</strong> Two metrics are used.
        The first counts regular gates (arithmetic + lookup), as
        defined in the Plonk and Plookup papers. The second, the
        <em>area-degree product</em>, applies to custom gates and
        estimates prover cost as (number of gates) &times; (max degree
        of a gate constraint) &times; (gate arity).
      </p>
      <p class="text-gray-300">
        <strong>8.1.2 Measuring hash functions.</strong>
        <strong>RC</strong> (BLS/BN primes): Bricks: 8 gates per
        round; Concrete: 6 gates per round; Bars: 282 gates per round
        (decomposition 26, composition 26, table 42 per element).
        Total:
        <span class="math">8 \cdot 6 + 6 \cdot 8 + 282 = 378</span>
        regular gates. Area-degree product:
        <span class="math">378 \cdot 15 = 5670</span>.
      </p>
      <p class="text-gray-300">
        <strong>Poseidon-128</strong> with 2 inputs needs 633 gates.
        <strong>Rescue</strong> with 2 inputs requires 480 regular
        gates (Rescue-Prime: 420). <strong>Sinsemilla</strong> for
        <span class="math">k = 10</span>,
        <span class="math">t = 51</span> yields about 510 regular
        gates, with an optimized area-degree product of 1530.
      </p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8 mb-3">
        8.2 Plain Implementation Performance
      </h3>
      <p class="text-gray-300">
        RC was implemented in pure Rust using the ff_ce library for
        field operations. All benchmarks were obtained on a Linux
        Desktop PC with an Intel i7-4790 CPU (3.6 GHz) and 16 GB RAM.
        Key results: RC is faster than Poseidon by a factor of 5 for
        <span class="math">p_&#123;\text&#123;BN254&#125;&#125;</span>
        and
        <span class="math">p_&#123;\text&#123;BLS381&#125;&#125;</span>,
        and by a factor of 16 for
        <span class="math">p_&#123;\text&#123;ST&#125;&#125;</span>.
        Compared to fast binary hash functions, RC is only about 5x
        slower than Blake2, while requiring 7 times fewer Plookup
        gates.
      </p>
      <p class="text-gray-300">
        For computing a Merkle tree with
        <span class="math">2^&#123;20&#125;</span> elements: RC
        requires 3.91s (BN) / 3.97s (BLS) / 1.36s (ST), compared to
        Poseidon at 22.6s (BN) and SHA-256 at 0.624s.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A. BIJECTIVITY OF RC COMPONENTS                     -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A. Bijectivity of RC Components
      </h2>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        A.1 Bijectivity of Bricks
      </h3>
      <p class="text-gray-300">
        Given
        <span class="math">\alpha_1, \alpha_2, \beta_1, \beta_2 \in
        \mathbb&#123;F&#125;_p</span> such that
        <span class="math">\alpha_i^2 - 4 \cdot \beta_i</span> is a
        non-quadratic residue mod
        <span class="math">p</span>, the Bricks function is
        invertible. Given
        <span class="math">\mathsf&#123;Bricks&#125;(x_1, x_2, x_3)
        = (y_1, y_2, y_3)</span>,
      </p>
      <div class="math-block">
        x_1 = y_1^&#123;1/d&#125;, \quad x_2 = \frac&#123;y_2&#125;&#123;x_1^2 + \alpha_1 x_1 + \beta_1&#125;, \quad x_3 = \frac&#123;y_3&#125;&#123;x_2^2 + \alpha_2 x_2 + \beta_2&#125;,
      </div>
      <p class="text-gray-300">
        since (1)
        <span class="math">x \mapsto x^d</span> is invertible due to
        <span class="math">\gcd(d, p-1) = 1</span>; (2)
        <span class="math">z^2 + \alpha_i z + \beta_i \neq 0</span>
        for each
        <span class="math">z \in
        \mathbb&#123;F&#125;_p</span> because
        <span class="math">\alpha_i^2 - 4\beta_i</span> is not a
        square.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        A.2 Bijectivity of Bar
      </h3>
      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">Lemma 3</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The function
            <span class="math">\mathsf&#123;Bar&#125;</span> permutes
            <span class="math">\mathbb&#123;F&#125;_p</span>.
          </p>
        </div>
      </div>
      <p class="text-gray-300">
        <em>Proof sketch.</em> For
        <span class="math">\mathcal&#123;R&#125;_&#123;&lt;
        p&#125; := \&#123;(z_1, \dots, z_n) \in \mathcal&#123;R&#125;
        : \sum_&#123;i=1&#125;^&#123;n&#125; z_i b_i &lt;
        p\&#125;</span>, the proof shows:
        (1) Decomp is injective and
        <span class="math">\mathsf&#123;Decomp&#125;(\mathbb&#123;F&#125;_p) \subseteq \mathcal&#123;R&#125;_&#123;&lt; p&#125;</span>;
        (2) <span class="math">\mathsf&#123;SBox&#125;(\mathcal&#123;R&#125;_&#123;&lt; p&#125;) \subseteq \mathcal&#123;R&#125;_&#123;&lt; p&#125;</span>,
        so SBox permutes
        <span class="math">\mathcal&#123;R&#125;_&#123;&lt;
        p&#125;</span>;
        (3) Comp is injective on
        <span class="math">\mathcal&#123;R&#125;_&#123;&lt;
        p&#125;</span>.
        It follows that
        <span class="math">\mathsf&#123;Bar&#125; =
        \mathsf&#123;Comp&#125; \circ \mathsf&#123;SBox&#125; \circ
        \mathsf&#123;Decomp&#125;</span> is injective and hence
        surjective.
      </p>
      <p class="text-gray-300">
        The key step in (2) uses the property that for every
        <span class="math">1 \le k \le n</span>:
      </p>
      <div class="math-block">
        \sum_&#123;i=k+1&#125;^&#123;n&#125; (s_i - 1) b_i = b_k - 1.
      </div>
      <p class="text-gray-300">
        Informally, the sum of the maximal values of the first
        <span class="math">l = n - k</span> least significant
        positions equals the value of the next greater significant
        position minus 1.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        A.3 The SBox Function
      </h3>
      <p class="text-gray-300">
        The non-identity part
        <span class="math">f :
        \mathbb&#123;F&#125;_&#123;p'&#125; \to
        \mathbb&#123;F&#125;_&#123;p'&#125;</span> of each S-box must
        be a permutation of
        <span class="math">\mathbb&#123;F&#125;_&#123;p'&#125;</span>
        with high degree and a dense polynomial description. The
        technique: (1) choose the smallest prime
        <span class="math">d = 2^n - 1</span> with
        <span class="math">\gcd(d, p' - 1) = 1</span>;
        (2) compute the
        <span class="math">r</span>-fold composition
      </p>
      <div class="math-block">
        f(X) := (f_r \circ f_&#123;r-1&#125; \circ \cdots \circ f_1)(X), \quad f_i(X) := (X + c_i)^d \text&#123; for random &#125; c_i \in \mathbb&#123;F&#125;_&#123;p'&#125;,
      </div>
      <p class="text-gray-300">
        with
        <span class="math">r = 2 \lceil \log_d(p') \rceil</span>,
        aiming for degree
        <span class="math">p' - 2</span> and
        <span class="math">p' - 1</span> non-zero coefficients.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B. SECURITY ANALYSIS                                -->
    <!-- ============================================================ -->

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B. Security Analysis
      </h2>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.1 Statistical Attacks
      </h3>
      <p class="text-gray-300">
        The security analysis considers a variant RC&prime; in which
        the middle component Bricks-Concrete-Bars-Concrete-Bricks is
        replaced with a single Bricks. If RC&prime; is secure against
        statistical attacks, then so is the full RC.
      </p>

      <p class="text-gray-300">
        <strong>B.1.1 Differential Cryptanalysis.</strong>
        The differential probability is defined as
      </p>
      <div class="math-block">
        \mathrm&#123;Prob&#125;(\delta_I \to \delta_O) = \frac&#123;|\&#123;x \in \mathbb&#123;F&#125;_p^t \mid F(x + \delta_I) - F(x) = \delta_O\&#125;|&#125;&#123;p^t&#125;.
      </div>
      <p class="text-gray-300">
        For the power map:
        <span class="math">\mathrm&#123;DP&#125;_&#123;\max&#125;(x
        \mapsto x^d) = (d-1)/p</span>. The best differential
        characteristic over two rounds has probability at most
        <span class="math">4(d-1)^2 / p^4 \ll p^&#123;-3&#125;</span>,
        due to at least four active words each contributing a factor
        proportional to
        <span class="math">p^&#123;-1&#125;</span>. Two consecutive
        rounds suffice for security against differential attacks.
      </p>

      <p class="text-gray-300">
        <strong>B.1.2 Truncated and Impossible Differentials.</strong>
        Truncated differentials with probability 1 exist over a single
        round but cannot be extended further. An impossible
        differential exists over two rounds. Three rounds suffice for
        security.
      </p>

      <p class="text-gray-300">
        <strong>B.1.3 Meet-in-the-Middle and Boomerang.</strong>
        These rely on chaining two good differential/linear trails. The
        six-round RC&prime; is secure.
      </p>

      <p class="text-gray-300">
        <strong>B.1.4 Rebound Attacks.</strong> The inbound phase can
        cover two rounds; the outbound phase can extend one round in
        each direction. RC&prime; with six rounds is secure since no
        attack on five or more rounds was found (at least 2 rounds of
        security margin).
      </p>

      <p class="text-gray-300">
        <strong>B.1.5 Linear and Zero-Correlation.</strong> Linear
        attacks pose no threat with the same number of rounds as for
        differential cryptanalysis. Finding zero-correlation linear
        hulls is infeasible for the four Bricks layers.
      </p>

      <p class="text-gray-300">
        <strong>B.1.6 Square/Integral &amp; Mixture Differential.</strong>
        Only one round can be covered with an integral attack. Both
        Bricks and Concrete mix the state components, preventing
        extension.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.2 Invariant Subspace Attack and Fixed Points
      </h3>
      <p class="text-gray-300">
        <strong>B.2.1 Invariant Subspaces.</strong> For the Bars
        layer, subspaces where only a single word is active, and
        subspaces of the form
        <span class="math">\langle (1,1,0) \rangle</span>,
        <span class="math">\langle (1,0,1) \rangle</span>,
        <span class="math">\langle (0,1,1) \rangle</span>, or
        <span class="math">\langle (1,1,1) \rangle</span> are
        invariant. However, there is no invariant subspace for Bricks,
        ensuring security against this attack.
      </p>
      <p class="text-gray-300">
        <strong>B.2.2 Fixed Points.</strong> The only fixed points for
        Bricks are
        <span class="math">(0,0,0)</span>,
        <span class="math">(\pm 1, 0, 0)</span>, and
        <span class="math">(\pm \sqrt&#123;-1&#125;, 0, 0)</span>.
        For Bar, the number of fixed points is
        <span class="math">\bigl(\prod_&#123;i=1&#125;^&#123;n&#125;
        (s_i - p')\bigr)^3</span>. For
        <span class="math">p_&#123;\text&#123;BLS381&#125;&#125;
        \approx 2^&#123;256&#125;</span>, the probability for a random
        point to be a fixed point is approximately
        <span class="math">2^&#123;-364.4&#125;</span>.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.3 Gr&ouml;bner Basis Cryptanalysis
      </h3>
      <p class="text-gray-300">
        Under the assumption of a semi-regular input system, the
        degree of regularity
        <span class="math">d_&#123;\text&#123;reg&#125;&#125;</span>
        provides an upper bound for the highest degree element in a
        Gr&ouml;bner basis. The complexity bound is:
      </p>
      <div class="math-block">
        C_&#123;GB&#125;(l, d_&#123;\text&#123;reg&#125;&#125;) \in O\left(\binom&#123;l + d_&#123;\text&#123;reg&#125;&#125;&#125;&#123;l&#125;^\omega\right),
      </div>
      <p class="text-gray-300">
        where <span class="math">\omega</span> is the linear algebra
        constant. For the algebraic model of Bar, the expected degree
        of regularity is
        <span class="math">d_&#123;\text&#123;reg&#125;&#125;^&#123;\text&#123;Bar&#125;&#125;
        = 1 - n + 2 \sum_&#123;i=1&#125;^&#123;n&#125; (s_i - 1)
        \approx 2n \sqrt[n]&#123;p&#125;</span>.
      </p>
      <p class="text-gray-300">
        Practical experiments on small-scale instances of
        Concrete &#x2218; Bars &#x2218; Concrete in the CICO-setting
        show the ratio
        <span class="math">d_&#123;\text&#123;reg&#125;&#125; /
        d_&#123;\text&#123;mag&#125;&#125; \approx 3</span> and
        practical runtimes approximately the square root of the
        complexity estimates. For the full-scale instance with
        <span class="math">n = 27</span>:
      </p>
      <div class="math-block">
        (C_&#123;GB&#125;(l = 170, d_&#123;\text&#123;reg&#125;&#125;/3))^&#123;1/2&#125; &gt; 2^&#123;1360&#125;,
      </div>
      <p class="text-gray-300">
        far exceeding the security level of
        <span class="math">2^&#123;128&#125;</span>.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.4 Other Algebraic Attacks
      </h3>
      <p class="text-gray-300">
        <strong>B.4.1 Interpolation Analysis.</strong> The total degree
        of one word of the permutation RC over
        <span class="math">\mathbb&#123;F&#125;_p</span> is
        <span class="math">d_B \cdot d_S^6</span>. It suffices that
        <span class="math">d_B &gt; 2^&#123;127&#125;</span>. Since
        Bars is defined non-linearly on at least
        <span class="math">p'^&#123;27&#125; \ge 2^&#123;251&#125;</span>
        points, the degree far exceeds this requirement. For
        small-scale instances the degree was always maximal
        (<span class="math">p - 2</span>).
      </p>
      <p class="text-gray-300">
        <strong>B.4.2 Higher-Order Differential and Zero-Sum.</strong>
        Security against interpolation implies security against
        higher-order differential attacks. The authors do not claim
        security against zero-sum partitions, as there is a gap in the
        literature between the number of rounds coverable by a
        zero-sum partition and the rounds breakable in a sponge hash
        function.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.5 Side-channel Attacks
      </h3>
      <p class="text-gray-300">
        For the RC design, its native execution can be run without
        table lookups as the table is computed as a polynomial. If
        prime field operations were implemented in constant-time, the
        function would be leakage-free.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        B.6 Every Building Block is Necessary
      </h3>
      <p class="text-gray-300">
        <strong>B.6.1 Necessity of Bars.</strong> Without Bars, a
        much higher number of rounds is needed. Using Gr&ouml;bner
        basis approaches in the CICO setting, the authors show that
        <span class="math">r \ge 54</span> rounds are needed for the
        full-round equation approach, and
        <span class="math">r \ge 33</span> for the intermediate
        variables approach (both for
        <span class="math">p \approx 2^&#123;256&#125;</span>).
      </p>
      <p class="text-gray-300">
        <strong>B.6.2 Necessity of Concrete.</strong> Without
        Concrete, the subspaces
        <span class="math">\langle (0,1,0), (0,0,1) \rangle</span>
        and
        <span class="math">\langle (0,0,1) \rangle</span> would be
        invariant through the whole permutation.
      </p>
      <p class="text-gray-300">
        <strong>B.6.3 Necessity of Bricks.</strong> Without Bricks, an
        attacker could work with a system of equations over the smaller
        fields of the Bars layer. Also, both outbound phases of a
        rebound attack would be linear.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        Special thanks to Ferdinand Sauer for valuable discussion on
        Gr&ouml;bner basis computations and for assistance in
        conducting the practical experiments. Thanks to Alex Vlasov
        (Matter Labs) for modular math optimizations and comments.
      </p>
      <p class="text-gray-300">
        Lorenzo Grassi is supported by the European Research Council
        (ERC) under grant ERC-2017-ADG Nr. 788980 ESCADA. Roman Walch
        is supported by the &ldquo;DDAI&rdquo; COMET Module within
        the COMET Programme, funded by the Austrian Federal Ministry
        for Transport, Innovation and Technology (bmvit), the Austrian
        Federal Ministry for Digital and Economic Affairs (bmdw), the
        Austrian Research Promotion Agency (FFG), the province of
        Styria (SFG) and partners from industry and academia.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside space-y-2 text-gray-400
        text-sm">
        <li>
          [1] Hash functions for zero-knowledge applications zoo.
          IAIK, Graz University of Technology (2021).
        </li>
        <li>
          [2] Tornado cash privacy solution version 1.4 (2021).
        </li>
        <li>
          [3] ZCash protocol specification (2022).
        </li>
        <li>
          [4] Albrecht, M.R. et al. &ldquo;Algebraic Cryptanalysis of
          STARK-Friendly Designs: Application to MARVELlous and
          MiMC&rdquo;. In: <em>ASIACRYPT 2019</em>. LNCS, vol. 11923,
          pp. 371&ndash;397.
        </li>
        <li>
          [5] Albrecht, M.R. et al. &ldquo;Feistel Structures for
          MPC, and More&rdquo;. In: <em>ESORICS 2019</em>. LNCS,
          vol. 11736, pp. 151&ndash;171.
        </li>
        <li>
          [6] Albrecht, M.R. et al. &ldquo;MiMC: Efficient Encryption
          and Cryptographic Hashing with Minimal Multiplicative
          Complexity&rdquo;. In: <em>ASIACRYPT 2016</em>. LNCS,
          vol. 10031, pp. 191&ndash;219.
        </li>
        <li>
          [7] Aly, A. et al. &ldquo;Design of symmetric-key
          primitives for advanced cryptographic protocols&rdquo;.
          <em>IACR Trans. Symmetric Cryptol.</em> 2020(3), 1&ndash;45.
        </li>
        <li>
          [8] Ashur, T., Dhooghe, S. &ldquo;MARVELlous: a
          STARK-Friendly Family of Cryptographic Primitives&rdquo;.
          ePrint 2018/1098.
        </li>
        <li>
          [9] Baign&egrave;res, T., Stern, J., Vaudenay, S.
          &ldquo;Linear Cryptanalysis of Non Binary Ciphers&rdquo;.
          In: <em>SAC 2007</em>. LNCS, vol. 4876, pp. 184&ndash;211.
        </li>
        <li>
          [10] Bardet, M. et al. &ldquo;Asymptotic behaviour of the
          index of regularity of quadratic semi-regular polynomial
          systems&rdquo;. In: <em>MEGA 2005</em>.
        </li>
        <li>
          [11] Bariant, A. et al. &ldquo;Practical algebraic attacks
          against some arithmetization-oriented hash
          functions&rdquo; (2022).
        </li>
        <li>
          [12] Ben-Sasson, E. et al. &ldquo;Fast Reed-Solomon
          interactive oracle proofs of proximity&rdquo;. In:
          <em>ICALP 2018</em>. LIPIcs, vol. 107.
        </li>
        <li>
          [13] Ben-Sasson, E. et al. &ldquo;Aurora: Transparent
          succinct arguments for R1CS&rdquo;. In:
          <em>EUROCRYPT 2019</em>. LNCS, vol. 11476,
          pp. 103&ndash;128.
        </li>
        <li>
          [14] Bertoni, G. et al. &ldquo;On the Indifferentiability of
          the Sponge Construction&rdquo;. In: <em>EUROCRYPT 2008</em>.
          LNCS, vol. 4965, pp. 181&ndash;197.
        </li>
        <li>
          [15] Bertoni, G. et al. &ldquo;On alignment in
          Keccak&rdquo;.
        </li>
        <li>
          [16] Beyne, T. et al. &ldquo;Out of Oddity &ndash; New
          Cryptanalytic Techniques Against Symmetric Primitives
          Optimized for Integrity Proof Systems&rdquo;. In:
          <em>CRYPTO 2020</em>. LNCS, vol. 12172,
          pp. 299&ndash;328.
        </li>
        <li>
          [17] Biham, E., Biryukov, A., Shamir, A.
          &ldquo;Cryptanalysis of Skipjack Reduced to 31 Rounds Using
          Impossible Differentials&rdquo;. In:
          <em>EUROCRYPT 1999</em>. LNCS, vol. 1592.
        </li>
        <li>
          [18] Biham, E., Shamir, A. &ldquo;Differential
          Cryptanalysis of DES-like Cryptosystems&rdquo;. In:
          <em>CRYPTO 1990</em>. LNCS, vol. 537, pp. 2&ndash;21.
        </li>
        <li>
          [19] Biham, E., Shamir, A. <em>Differential Cryptanalysis
          of the Data Encryption Standard</em>. Springer (1993).
        </li>
        <li>
          [20] Bogdanov, A., Wang, M. &ldquo;Zero Correlation Linear
          Cryptanalysis with Reduced Data Complexity&rdquo;. In:
          <em>FSE 2012</em>. LNCS, vol. 7549, pp. 29&ndash;48.
        </li>
        <li>
          [21] Boneh, D. et al. &ldquo;Halo infinite: Proof-carrying
          data from additive polynomial commitments&rdquo;. In:
          <em>CRYPTO 2021</em>. LNCS, vol. 12825,
          pp. 649&ndash;680.
        </li>
        <li>
          [22] Bootle, J. et al. &ldquo;Arya: Nearly linear-time
          zero-knowledge proofs for correct program execution&rdquo;.
          In: <em>ASIACRYPT 2018</em>. LNCS, vol. 11272,
          pp. 595&ndash;626.
        </li>
        <li>
          [23] Boura, C. et al. &ldquo;Higher-Order Differential
          Properties of Keccak and Luffa&rdquo;. In:
          <em>FSE 2011</em>. LNCS, vol. 6733, pp. 252&ndash;269.
        </li>
        <li>
          [24] Bowe, S., Hopwood, D. &ldquo;Zcash Orchard: Sinsemilla
          Gadget&rdquo; (2021).
        </li>
        <li>
          [25] B&uuml;nz, B. et al. &ldquo;Proof-carrying data
          without succinct arguments&rdquo;. In:
          <em>CRYPTO 2021</em>. LNCS, vol. 12825,
          pp. 681&ndash;710.
        </li>
        <li>
          [26] B&uuml;nz, B. et al. &ldquo;Recursive proof
          composition from accumulation schemes&rdquo;. In:
          <em>TCC 2020</em>. LNCS, vol. 12551, pp. 1&ndash;18.
        </li>
        <li>
          [27] Chiesa, A., Ojha, D., Spooner, N. &ldquo;Fractal:
          Post-quantum and transparent recursive proofs from
          holography&rdquo;. In: <em>EUROCRYPT 2020</em>. LNCS,
          vol. 12105, pp. 769&ndash;793.
        </li>
        <li>
          [28] Cid, C., Leurent, G. &ldquo;An Analysis of the XSL
          Algorithm&rdquo;. In: <em>ASIACRYPT 2005</em>. LNCS,
          vol. 3788, pp. 333&ndash;352.
        </li>
        <li>
          [29] Courtois, N.T., Pieprzyk, J. &ldquo;Cryptanalysis of
          Block Ciphers with Overdefined Systems of
          Equations&rdquo;. In: <em>ASIACRYPT 2002</em>. LNCS,
          vol. 2501, pp. 267&ndash;287.
        </li>
        <li>
          [30] Cox, D.A. et al. <em>Ideals, varieties, and algorithms
          &ndash; an introduction to computational algebraic geometry
          and commutative algebra</em>. 2nd ed. Springer (1997).
        </li>
        <li>
          [31] Daemen, J., Knudsen, L.R., Rijmen, V. &ldquo;The
          Block Cipher Square&rdquo;. In: <em>FSE 1997</em>. LNCS,
          vol. 1267, pp. 149&ndash;165.
        </li>
        <li>
          [32] Daemen, J., Rijmen, V. <em>The Design of Rijndael:
          AES</em>. Springer (2002).
        </li>
        <li>
          [33] Eichlseder, M. et al. &ldquo;An algebraic attack on
          ciphers with low-degree round functions: Application to full
          MiMC&rdquo;. In: <em>ASIACRYPT 2020</em>. LNCS,
          vol. 12491, pp. 477&ndash;506.
        </li>
        <li>
          [34] Gabizon, A., Williamson, Z.J. &ldquo;plookup: A
          simplified polynomial protocol for lookup tables&rdquo;.
          ePrint 2020/315.
        </li>
        <li>
          [35] Gabizon, A., Williamson, Z.J., Ciobotaru, O.
          &ldquo;Plonk: Permutations over Lagrange-bases for
          oecumenical noninteractive arguments of knowledge&rdquo;.
          ePrint 2019/953.
        </li>
        <li>
          [36] Genovese, G. &ldquo;Improving the algorithms of
          Berlekamp and Niederreiter for factoring polynomials over
          finite fields&rdquo;. <em>J. Symb. Comput.</em> 42(1-2),
          159&ndash;177 (2007).
        </li>
        <li>
          [37] Goldberg, L. et al. &ldquo;Cairo &ndash; a
          Turing-complete STARK-friendly CPU architecture&rdquo;.
          ePrint (2021).
        </li>
        <li>
          [38] Grassi, L. &ldquo;Mixture Differential Cryptanalysis:
          a New Approach to Distinguishers and Attacks on
          round-reduced AES&rdquo;. <em>IACR Trans. Symmetric
          Cryptol.</em> 2018(2), 133&ndash;160.
        </li>
        <li>
          [39] Grassi, L. et al. &ldquo;A New Feistel Approach Meets
          Fluid-SPN: Griffin for Zero-Knowledge Applications&rdquo;.
          ePrint 2022/403.
        </li>
        <li>
          [40] Grassi, L. et al. &ldquo;The Legendre symbol and the
          modulo-2 operator in symmetric schemes over
          <span class="math">\mathbb&#123;F&#125;_p^n</span>&rdquo;.
          ePrint (2021).
        </li>
        <li>
          [41] Grassi, L. et al. &ldquo;Poseidon: A new hash function
          for zero-knowledge proof systems&rdquo;. <em>USENIX Security
          2021</em>.
        </li>
        <li>
          [42] Grassi, L. et al. &ldquo;On a generalization of
          substitution-permutation networks: The HADES design
          strategy&rdquo;. In: <em>EUROCRYPT 2020</em>. LNCS,
          vol. 12106, pp. 674&ndash;704.
        </li>
        <li>
          [43] Grassi, L. et al. &ldquo;Invertible Quadratic
          Non-Linear Layers for MPC-/FHE-/ZK-Friendly Schemes over
          <span class="math">\mathbb&#123;F&#125;_p^n</span>&rdquo;.
          ePrint 2021/1695.
        </li>
        <li>
          [44] Grassi, L. et al. &ldquo;Subspace Trail Cryptanalysis
          and its Applications to AES&rdquo;. <em>IACR Trans.
          Symmetric Cryptol.</em> 2016(2), 192&ndash;225.
        </li>
        <li>
          [45] Grassi, L. et al. &ldquo;A New Structural-Differential
          Property of 5-Round AES&rdquo;. In:
          <em>EUROCRYPT 2017</em>. LNCS, vol. 10211,
          pp. 289&ndash;317.
        </li>
        <li>
          [46] Grassi, L. et al. &ldquo;Proving Resistance Against
          Infinitely Long Subspace Trails: How to Choose the Linear
          Layer&rdquo;. <em>IACR Trans. Symmetric Cryptol.</em>
          2021(2).
        </li>
        <li>
          [47] Groth, J. &ldquo;On the size of pairing-based
          non-interactive arguments&rdquo;. In:
          <em>EUROCRYPT 2016</em>. LNCS, vol. 9666,
          pp. 305&ndash;326.
        </li>
        <li>
          [48] Guido, B. et al. &ldquo;Cryptographic sponge
          functions&rdquo; (2011).
        </li>
        <li>
          [49] Hopwood, D. &ldquo;Zcon0 conference notes&rdquo;
          (2019).
        </li>
        <li>
          [50] Jakobsen, T., Knudsen, L.R. &ldquo;The Interpolation
          Attack on Block Ciphers&rdquo;. In: <em>FSE 1997</em>.
          LNCS, vol. 1267, pp. 28&ndash;40.
        </li>
        <li>
          [51] Keller, N., Rosemarin, A. &ldquo;Mind the Middle Layer:
          The HADES Design Strategy Revisited&rdquo;. In:
          <em>EUROCRYPT 2021</em>. LNCS, vol. 12697, pp. 35&ndash;63.
        </li>
        <li>
          [52] Knudsen, L.R. &ldquo;Truncated and Higher Order
          Differentials&rdquo;. In: <em>FSE 1994</em>. LNCS,
          vol. 1008, pp. 196&ndash;211.
        </li>
        <li>
          [53] Knudsen, L.R. &ldquo;DEAL &ndash; A 128-bit Block
          Cipher&rdquo; (1998).
        </li>
        <li>
          [54] Lai, X. &ldquo;Higher order derivatives and
          differential cryptanalysis&rdquo;. In: <em>Communications
          and Cryptography</em>. pp. 227&ndash;233. Springer US
          (1994).
        </li>
        <li>
          [55] Lamberger, M. et al. &ldquo;Rebound Distinguishers:
          Results on the Full Whirlpool Compression Function&rdquo;.
          In: <em>ASIACRYPT 2009</em>. LNCS, vol. 5912,
          pp. 126&ndash;143.
        </li>
        <li>
          [56] Leander, G. et al. &ldquo;A Cryptanalysis of
          PRINTcipher: The Invariant Subspace Attack&rdquo;. In:
          <em>CRYPTO 2011</em>. LNCS, vol. 6841, pp. 206&ndash;221.
        </li>
        <li>
          [57] Leander, G. et al. &ldquo;A Generic Approach to
          Invariant Subspace Attacks&rdquo;. In:
          <em>EUROCRYPT 2015</em>. LNCS, vol. 9056,
          pp. 254&ndash;283.
        </li>
        <li>
          [58] Maller, M. et al. &ldquo;Sonic: Zero-knowledge SNARKs
          from linear-size universal and updatable structured reference
          strings&rdquo;. In: <em>CCS 2019</em>. pp. 2111&ndash;2128.
        </li>
        <li>
          [59] Matsui, M. &ldquo;Linear Cryptanalysis Method for DES
          Cipher&rdquo;. In: <em>EUROCRYPT 1993</em>. LNCS,
          vol. 765, pp. 386&ndash;397.
        </li>
        <li>
          [60] Mendel, F. et al. &ldquo;The Rebound Attack:
          Cryptanalysis of Reduced Whirlpool and
          Gr&oslash;stl&rdquo;. In: <em>FSE 2009</em>. LNCS,
          vol. 5665, pp. 260&ndash;276.
        </li>
        <li>
          [61] Ozdemir, A. et al. &ldquo;Scaling verifiable
          computation using efficient set accumulators&rdquo;. In:
          <em>USENIX Security 2020</em>. pp. 2075&ndash;2092.
        </li>
        <li>
          [62] Parno, B. et al. &ldquo;Pinocchio: Nearly practical
          verifiable computation&rdquo;. In: <em>IEEE S&amp;P
          2013</em>. pp. 238&ndash;252.
        </li>
        <li>
          [63] Pearson, L. et al. &ldquo;Plonkup: Reconciling Plonk
          with Plookup&rdquo;. ePrint (2022).
        </li>
        <li>
          [64] Sauer, J.F., Szepieniec, A. &ldquo;SoK: Gr&ouml;bner
          basis algorithms for arithmetization oriented
          ciphers&rdquo;. ePrint (2021).
        </li>
        <li>
          [65] Szepieniec, A. &ldquo;On the use of the Legendre symbol
          in symmetric cipher design&rdquo;. ePrint (2021).
        </li>
        <li>
          [66] Tram&egrave;r, F. et al. &ldquo;Remote side-channel
          attacks on anonymous transactions&rdquo;. In:
          <em>USENIX Security 2020</em>. pp. 2739&ndash;2756.
        </li>
        <li>
          [67] Wagner, D.A. &ldquo;The Boomerang Attack&rdquo;. In:
          <em>FSE 1999</em>. LNCS, vol. 1636, pp. 156&ndash;170.
        </li>
        <li>
          [68] Williamson, Z. &ldquo;zkSummit: Plookup&rdquo; (2020).
        </li>
        <li>
          [69] Wood, G. et al. &ldquo;Ethereum: A secure decentralised
          generalised transaction ledger&rdquo; (2014).
        </li>
      </ol>
    </section>

  </article>
</BaseLayout>
