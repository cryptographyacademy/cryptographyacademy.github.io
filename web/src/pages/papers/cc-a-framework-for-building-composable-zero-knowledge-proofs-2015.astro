---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1093';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'C$\\emptyset$C$\\emptyset$: A Framework for Building Composable Zero-Knowledge Proofs';
const AUTHORS_HTML = 'Ahmed Kosba, Zhichao Zhao, Andrew Miller, Yi Qian, Hubert Chan, Charalampos Papamanthou, Rafael Pass, abhi shelat, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">C∅C∅: A Framework for Building Composable Zero-Knowledge Proofs</p>

    <p class="text-gray-300">Ahmed Kosba† Zhichao Zhao<em> Andrew Miller† Yi Qian‡ T-H. Hubert Chan</em> Charalampos Papamanthou† Rafael Pass‡ abhi shelat• Elaine Shi‡</p>

    <p class="text-gray-300">†: UMD  *: HKU  ‡: Cornell  ●: UVA</p>

    <p class="text-gray-300">Non-interactive zero-knowledge proofs are a powerful cryptographic primitive used in privacy-preserving protocols. We design and build C∅C∅, the first system enabling developers to build efficient, composable, non-interactive zero-knowledge proofs for generic, user-defined statements. C∅C∅ extends state-of-the-art SNARK constructions by applying known strengthening transformations to yield UC-composable zero-knowledge proofs suitable for modular use in larger cryptographic protocols.</p>

    <p class="text-gray-300">To attain fast practical performance, C∅C∅ includes a library of several "SNARK-friendly" cryptographic primitives.</p>

    <p class="text-gray-300">These primitives are used in the strengthening transformations in order to reduce the overhead of achieving composable security. Our open-source library of optimized arithmetic circuits for these functions are up to  <span class="math">40 \\times</span>  more efficient than standard implementations and are thus of independent interest for use in other NIZK projects.</p>

    <p class="text-gray-300">Finally, we evaluate C∅C∅ on applications such as anonymous credentials, private smart contracts, and nonoutsourced proof-of-work puzzles and demonstrate  <span class="math">5 \\times</span>  to  <span class="math">8 \\times</span>  speedup in these application settings compared to naive implementations.</p>

    <p class="text-gray-300">Non-Interactive Zero-Knowledge proofs (NIZKs) are a powerful building block in the design of expressive cryptographic protocols such as anonymous credentials, anonymous survey systems [43], privacy-preserving digital currencies [11,47], and multi-party computation [39] in general. Typically, NIZKs are used to defend against malicious parties and enforce honest behavior. Specifically, any deviation from the protocol will result in failure of NIZK verification, and thus translate to an aborting (i.e., Denial-of-Service) attack.</p>

    <p class="text-gray-300">Excitingly, recent advent of Succinct Non-Interactive ARguments of Knowledge (SNARKs) [19, 37] have greatly accelerated the idea to proof-of-concept cycle for systems that employ NIZKs. Although SNARKs have non-privacy-focused applications such as verifiable computation [13, 31, 32, 48, 55, 61, 63, 64, 66, 67], here we focus on using SNARKs as a concrete instantiation of NIZKs. In particular, most known SNARK implementations [13, 32, 55, 63] provide a zero-knowledge option, often referred to as zk-SNARKs.</p>

    <p class="text-gray-300">Despite their well-known drawback of relying on assumptions that are non-falsifiable, SNARKs are attractive to practitioners not only due to their (relative) practical efficiency, but more importantly for their general-purpose nature. In contrast, until recently, most systems <em>[22, 23, 43]</em> adopted customized NIZK protocols for application-specific statements of interest. Although this customized approach can result in protocols highly optimized for the specific task at hand, the enormous cryptography expertise and time required to develop new protocols for each application severely limit the adoption of modern cryptography building blocks such as NIZKs.</p>

    <p class="text-gray-300">The general-purpose feature of SNARKs is quite compelling, and promises to simplify the usage of NIZKs in secure systems. With latest open-source SNARK implementations <em>[2, 13, 32, 55, 63]</em>, even system builders who are not cryptography experts can easily express a statement to be proven in a familiar programming language, and automated toolchains will generate a corresponding SNARK implementation. Further, this approach in turn enables rapid protocol prototyping, and avoids the need for full-scale protocol redesign when the functionality requirements change (as is often needed for customized protocols), since it is easy to modify a zk-SNARK to prove a different statement.</p>

    <p class="text-gray-300">SNARKs have made an impact since their invention: they have been adopted to instantiate NIZKs in various systems <em>[11, 33, 47, 53]</em>, including ones built for production usage (e.g., Zero-Cash <em>[11]</em>); further, new cryptocurrency systems such as Ethereum <em>[65]</em> have pronounced interest in supporting SNARKs as an opcode <em>[3]</em>.</p>

    <p class="text-gray-300">Composability is the recommended best practice in pragmatic cryptography engineering. Composability of cryptographic building blocks is often imperative in protocol design. When cryptographic building blocks are composable, they do not interfere with other building blocks in the same protocol or with other possibly concurrent protocol instances. For this reason, a universally composable (UC-secure) <em>[24, 25, 27]</em> NIZK is frequently recommended or necessary in designing larger cryptographic systems <em>[43, 47]</em>.</p>

    <p class="text-gray-300">While some may be tempted to dismiss UC as being a theoretical notion, we stress that UC is of vital importance and the recommended best practice in pragmatic cryptography engineering. We give a 10-min crash course on UC for the practitioner in Appendix B, and clearly state why one should care about UC, and why UC provides “worry-free” adoption of cryptographic building blocks as if were “ideal boxes”, and help avoid numerous perils and subtle attacks that might arise from lack of composability.</p>

    <p class="text-gray-300">Pitfalls of using zk-SNARKs in protocol design. Unfortunately, known instantiations of zk-SNARKs <em>[13, 32, 55, 63]</em> are not known to satisfy composability and therefore often cannot be adopted straight out of the box in the design of larger protocols. From a more technical standpoint, UC-secure protocols would often require simulation sound extractable zero-knowledge proofs. In other words, suppose that a simulator answers an adversary’s queries on polynomially many, possibly false statements—nevertheless, whenever the adversary submits a proof for a new statement, the simulator must be able to extract a valid witness except with negligible failure probability. Known zk-SNARKs do not offer such strong soundness properties. Despite the fact that SNARKs allow “knowledge extraction”, SNARKs’ knowledge extractor is too weak for many UC-secure protocols, since SNARKs’ extractor is non-blackbox, must know the concrete algorithm of the adversarial prover. By contrast, in UC-secure protocols, the ideal-world simulator must extract witnesses without knowing the environment’s algorithm.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.1 Our Results and Contributions</p>

    <p class="text-gray-300">In this paper, we design and build C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> (pronounced “coco”, short for Composable 0-knowledge, Compact 0-knowledge). C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> is the first system that provides practical, UC-secure, non-interactive zero-knowledge proofs for general, user-defined statements. C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> makes UC-secure NIZKs an accessible building block for system builders who are not necessarily cryptography experts.</p>

    <p class="text-gray-300">C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> provides UC-secure NIZKs that are circuit succinct, but not witness succinct. In other words, the size of the proofs and verification time are (quasi-)linear in the witness size, but independent of the size of the circuit that encodes the language. Note that in comparison, standard, non-UC-secure SNARKs achieve a stronger notion of succinctness, i.e., they are both circuit- and witness succinct. We note that currently there is also no known UC-secure zero-knowledge proof construction that is circuit- and witness succinct, even under non-standard assumptions—whether or how we can achieve this is left as future work. Below we describe our technical contributions in more detail.</p>

    <p class="text-gray-300">SNARK-lifting transformations optimized for concrete efficiency. At the core, C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> builds on top of existing SNARKs and hence inherit their generality. To achieve simulation sound extractability, we adopt efficient SNARK-lifting transformations that allow us to transform zk-SNARKs to zero-knowledge proofs with simulation sound extractability, such that they could be adopted in UC-secure protocols. Our transformations are inspired by the work by De Santis et al. transforms an ordinary NIZK to a simulation sound NIZK <em>[60]</em>. Although De Santis’s work only achieves a weaker notion called simulation soundness (without the online extraction property), it is not theoretically difficult to modify their constructions to additionally allow online extraction of the witness. In particular, under the common reference string model, one could encrypt the witness with a public-key encryption scheme, such that the simulator with knowledge of the secret key can extract the witness.</p>

    <p class="text-gray-300">Our main contribution is not to show the theoretical feasibility of a SNARK lifting transformation, but to carefully select and optimize these constructions for concrete efficiency, and offer composable NIZKs as a building block to non-expert programmers. To optimize for concrete efficiency, we made various explorations: 1) we explored and compared different variants of SNARK-lifting transformations (see Sections 3, 4 and 5); 2) we consider “SNARK-friendly cryptography”, where we carefully select known cryptographic primitives (e.g., encryption, key exchange, pseudo-random functions, signatures) and express them as efficient algebraic circuits which is the representation recognized by SNARKs. Earlier and concurrent works have considered the optimization of such primitives for specific purposes, such as <em>[33, 34, 11, 14]</em>. In this paper, we study more possible optimizations/alternatives with a focus on composable SNARKs. For example, we study the trade-offs of existing constructions such as RSA and field extension for key exchange, and propose to use a customized elliptic curve-based construction that is more efficient. Additionally, we select and optimize different block ciphers for symmetric encryption, and compare their performance. Overall, our implementation for encryption for example achieves more than 8x-9x compared to optimized RSA-based constructions.</p>

    <p class="text-gray-300">Beyond the SNARKs, succinct algebraic circuit representation of cryptographic primitives can also be of independent interest in other cryptographic applications such as multi-party computation <em>[10]</em> where computation is expressed as an algebraic circuit. Besides our work, earlier work has also considered optimizing cryptographic primitives for SNARK-friendliness in other application contexts <em>[33, 53, 11]</em>.</p>

    <p class="text-gray-300">Programming model. C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> is a Java-based library that allows developers to encode statements to be proven as a circuit, where each gate expresses an algebraic constraint. C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> provides a development interface similar to that of libsnark <em>[15]</em>, where the developer can encode a circuit modularly by defining and composing “gadgets”.</p>

    <p class="text-gray-300">In comparison with directly using earlier SNARK programming frameworks <em>[13, 15, 32, 55, 63, 64]</em>, C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> provides the following advantages: with previous frameworks, the developer not only needs to implement the user-defined statement to be proven as an algebraic circuit, but would also be faced with the daunting task of implementing the entire SNARK-lifting transformation, including primitives such as encryption and signatures, as algebraic circuits.</p>

    <p class="text-gray-300">With C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span>, the developer only needs to implement the high-level application (i.e., user-defined statement), and the C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> framework handles the remaining automatically and results in highly optimized implementations. To how easy/hard it is to program with C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span>, we provide a code sample in Figure 2 of the Appendix.</p>

    <p class="text-gray-300">Open source and evaluation. Figure 1 presents the high-level architecture of C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> and highlights our contributions. A code example can be found in Appendix A. We report the performance of C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> through both micro-benchmarks as well as three end-to-end applications. First, we show that for individual primitives such as encryption, we achieve 10x to 40x speedup in comparison with a straightforward, unoptimized baseline. Next, we evaluated C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> with three end-to-end applications, and demonstrate 5<span class="math">\\times</span> to 8<span class="math">\\times</span> performance improvement over an unoptimized baseline. To make our work reusable by the community, we are in the process of open sourcing our code and implementations.</p>

    <p class="text-gray-300">Adoption. C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> has been adopted in subsequent works <em>[46, 47]</em> to build privacy-preserving protocols. These works adopted an earlier, naive version of C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> that implemented unoptimized constructions described in Section 3 of this paper, and without SNARK-friendly cryptography optimizations. Since then, we have adopted more efficient constructions and SNARK-friendly optimizations, allowing us to demonstrate 5<span class="math">\\times</span> performance improvements in end-to-end applications such as Hawk <em>[47]</em> (see Section 7 for detailed evaluations).</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">Non-interactive zero-knowledge proofs were first proposed by Blum, Feldman, and Micali <em>[20]</em>, and later extended to multi-theorem by Blum et al. <em>[21]</em>.</p>

    <p class="text-gray-300">Sahai <em>[59]</em> was the first to construct a one-time, simulation-sound NIZK scheme. De Santis et al. <em>[60]</em> subsequently provide unbounded simulation-sound NIZKs, allowing the adversary to access many simulated proofs of possibly false statements. Neither technique is practical. Simulation soundness is a slightly weaker condition than simulation sound extractability—the latter requires that even after seeing a polynomial number of simulated proofs of possibly false statements, whenever a polynomial-time adversary produces a valid proof, an extractor can extract a valid witness except with negligible failures. It has been observed <em>[41, 42]</em> that simulation sound extractable NIZKs are UC-secure NIZKs by Canetti’s definition <em>[24]</em> in the presence of a static adversary. Groth et al. <em>[42]</em> construct perfect NIZK arguments for circuit satisfiability using bilinear groups. They also extend their scheme to construct UC-secure NIZKs. Groth <em>[41]</em> also gave more practical, simulation-sound extractable NIZK constructions for an NP language for bilinear groups.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">All of the above simulation-sound extractable NIZKs are not <em>succinct</em>—namely the size of the proof is proportional to the size of the witness verification circuit $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ that encodes the language. In</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: C∅C∅'s architecture. The components that represent our contributions are highlighted in blue.</p>

    <p class="text-gray-300">fact, Gentry and Wichs [38] has shown succinct non-interactive arguments to be impossible from any falsifiable assumption. Existing SNARKs adopt non-falsifiable assumptions to attain succinctness as well as practical efficiency [13, 31, 32, 37, 55, 63].</p>

    <p class="text-gray-300">In general, non-malleability is closely related to and often necessary in composable protocols. Zerocash [11] features a technique bearing resemblance ours to ensure a limited form of non-malleability, called "transaction non-malleability". However, Zerocash is not known to satisfy composable security.</p>

    <p class="text-gray-300">Garman et al. [36] construct a simulation sound SNARK in the CRS model by using well-known techniques to augment the statement with a trapdoor for the simulator. Their goal was to define an ideal model for decentralized anonymous payments, and design a scheme that satisfies the model in the stand-alone setting with static corruptions; their goal was not to achieve composability, and therefore a weaker notion suffices, and they can also achieve witness succinctness. They do not provide implementations details for the costs of their choices.</p>

    <p class="text-gray-300">Finally, Appendix B provides an overview of UC, and explains why UC is the best practice for cryptography engineering.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. In the remainder of the paper,  <span class="math">f(\\lambda) \\approx g(\\lambda)</span>  means that there exists a negligible function  <span class="math">\\nu(\\lambda)</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda) - g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\nu(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">2.1 Non-Interactive Zero-Knowledge Proofs</p>

    <p class="text-gray-300">A non-interactive zero-knowledge proof system (NIZK) for an NP language <span class="math">\\mathcal{L}</span> consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{crs}\\leftarrow\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span>, also written as <span class="math">\\mathsf{crs}\\leftarrow\\mathsf{KeyGen}_{\\text{nizk}}(1^{\\lambda},\\mathcal{L})</span>: Takes in a security parameter <span class="math">\\lambda</span>, a description of the language <span class="math">\\mathcal{L}</span>, and generates a common reference string <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w)</span>: Takes in <span class="math">\\mathsf{crs}</span>, a statement <span class="math">\\mathsf{stmt}</span>, a witness <span class="math">w</span> such that <span class="math">(\\mathsf{stmt},w)\\in\\mathcal{L}</span>, and produces a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">b\\leftarrow\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)</span>: Takes in a <span class="math">\\mathsf{crs}</span>, a statement <span class="math">\\mathsf{stmt}</span>, and a proof <span class="math">\\pi</span>, and outputs <span class="math">0</span> or <span class="math">1</span>, denoting accept or reject.</li>

      <li><span class="math">(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{ek})\\leftarrow\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Generates a simulated common reference string <span class="math">\\widehat{\\mathsf{crs}}</span>, trapdoor <span class="math">\\tau</span>, and extract key <span class="math">\\mathsf{ek}</span></li>

      <li><span class="math">\\pi\\leftarrow\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span>: Uses trapdoor <span class="math">\\tau</span> to produce a proof <span class="math">\\pi</span> without needing a witness</li>

    </ul>

    <p class="text-gray-300">Perfect completeness. A NIZK system is said to be perfectly complete, if an honest prover with a valid witness can always convince an honest verifier. More formally, for any <span class="math">(\\mathsf{stmt},w)\\in R</span>, we have that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathsf{crs}\\leftarrow\\mathcal{K}(1^{\\lambda},\\mathcal{L}),\\ \\pi\\leftarrow\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w):\\\\ \\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)=1\\end{array}\\right]=1 \\]</p>

    <p class="text-gray-300">Computational zero-knowlege. Informally, an NIZK system is computationally zero-knowledge if the proof does not reveal any information about the witness to any polynomial-time adversary. More formally, a NIZK system is said to computationally zero-knowledge, if there exists a polynomial-time simulator <span class="math">S=(\\widehat{\\mathcal{K}},\\widehat{\\mathcal{P}})</span>, such that for all non-uniform polynomial-time adversary <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{crs}\\leftarrow\\mathcal{K}(1^{\\lambda},\\mathcal{L}):\\mathcal{A}^{\\mathcal{P}(\\mathsf{crs},\\cdot,\\cdot)}(\\mathsf{crs})=1\\right]</span> <span class="math">\\approx</span> <span class="math">\\Pr\\left[(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{ek})\\leftarrow\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L}):\\mathcal{A}^{\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\tau,\\cdot,\\cdot)}(\\widehat{\\mathsf{crs}})=1\\right]</span></p>

    <p class="text-gray-300">In the above, <span class="math">\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt},w)</span> verifies that <span class="math">(\\mathsf{stmt},w)\\in\\mathcal{L}</span>, and if so, outputs <span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span> which simulates a proof without knowing a witness. Otherwise, if <span class="math">(\\mathsf{stmt},w)\\notin\\mathcal{L}</span>, the experiment aborts. This notion is <em>adaptive</em> zero knowledge in the sense that the simulator must specify the reference string before seeing the theorem statements.</p>

    <p class="text-gray-300">Computational soundness. A NIZK scheme for the language <span class="math">\\mathcal{L}</span> is said to be computationally sound, if for all polynomial-time adversaries <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathsf{crs}\\leftarrow\\mathcal{K}(1^{\\lambda},\\mathcal{L}),(\\mathsf{stmt},\\pi)\\leftarrow\\mathcal{A}(\\mathsf{crs}):\\\\ (\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)=1)\\wedge(\\mathsf{stmt}\\notin\\mathcal{L})\\end{array}\\right]\\approx 0 \\]</p>

    <p class="text-gray-300">Simulation extractability. Simulation extractability is a strong notion which requires that even after seeing many simulated proofs (even for false theorems), whenever the adversary makes a new proof, a simulator is able to extract a witness. Simulation extractability implies simulation soundness and non-malleability (i.e., it is not feasible for an adversary to take a verifying proof and “maul” it into a verifying proof for another statement) since if the simulator can extract a valid witness from an adversary’s proof, the statement must belong to the language. More formally,</p>

    <p class="text-gray-300">a NIZK system is said to be simulation extractable if it satisfies computational zero-knowledge and additionally, there exists a polynomial-time algorithm <span class="math">\\mathcal{E}</span>, such that for any polynomial-time adversary <span class="math">\\mathcal{A}</span>, it holds that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{ek})\\leftarrow\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L});\\\\ (\\mathsf{stmt},\\pi)\\leftarrow\\mathcal{A}^{\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\cdot)}(\\widehat{\\mathsf{crs}},\\mathsf{ek});\\\\ w\\leftarrow\\mathcal{E}(\\widehat{\\mathsf{crs}},\\mathsf{ek},\\mathsf{stmt},\\pi):\\mathsf{stmt}\\notin Q\\text{ and}\\\\ (\\mathsf{stmt},w)\\notin\\mathcal{L}\\text{ and }V(\\widehat{\\mathsf{crs}},\\mathsf{stmt},\\pi)=1\\end{array}\\right]\\approx 0 \\]</p>

    <p class="text-gray-300">where in the above, <span class="math">Q</span> is the list of oracle queries made by <span class="math">\\mathcal{A}</span> to <span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\cdot)</span>. Here the <span class="math">\\widehat{\\mathcal{K}}</span> is identical to the zero-knowledge simulation setup algorithm.</p>

    <p class="text-gray-300">A few remarks about the definition follow. First, note that the extractor algorithm <span class="math">\\mathcal{E}</span> works for all adversaries, and does not therefore depend or have access to the adversary’s code. Rather, the extractor’s advantage arises entirely from its special access to a trapdoor <span class="math">\\mathsf{ek}</span> for the <span class="math">\\widehat{\\mathsf{crs}}</span>. Next, note that the adversary may be able to fake a (different) proof for a statement that has been queried, however, it is not able to forge a proof for any other invalid statement. There is a natural strengthening of the above notion where the adversary cannot even fake a different proof for a statement queried (in fact, it is this stronger notion that is given as the default in <em>[41]</em>). We define and give constructions for this later in Section 5. In Hawk <em>[47]</em>, however, it is shown that the weaker notion defined above suffices for a typical UC application; therefore we focus on this notion first.</p>

    <p class="text-gray-300">Relation between UC secure NIZKs and simulation sound extractability. It is well understood that the notion of simulation-sound extractability and UC-secure NIZKs are roughly speaking interchangeable <em>[41, 26]</em>. Therefore, for the remainder of the paper, we will use the notion simulation-sound extractability, and later in Appendix C, we elaborate on the relationship between simulation sound extractability and UC security for NIZKs.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 SNARKs</h3>

    <p class="text-gray-300">A SNARK is a NIZK that is succint, perfectly complete, computationally zero-knowledge, and has a knowledge extractor (a stronger property than soundness):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinctness. A SNARK is said to be succinct if an honestly generated proof has <span class="math">\\mathsf{poly}(\\lambda)</span> bits and that the verification algorithm <span class="math">\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)</span> runs in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{stmt}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathsf{poly}(\\lambda))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Adaptive knowledge extraction. Knowledge extraction requires that if a proof generated by an adversary is accepted by the verifier, then the adversary “knows” a witness for the given instance; i.e., there exists an algorithm <span class="math">\\mathcal{E}</span> which recovers a witness. Furthermore, the extraction property holds adaptively even if the prover picks the statement after seeing the reference string. Formally, a SNARK for language <span class="math">\\mathcal{L}</span> satisfies the knowledge extraction property <em>iff:</em></p>

    <p class="text-gray-300">For all polynomial-sized adversary <span class="math">\\mathcal{A}</span>, there exists a polynomial-size extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span>, such that for all advice strings <span class="math">z\\in\\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\mathsf{crs}\\leftarrow\\mathcal{K}(1^{\\lambda},\\mathcal{L})\\\\ (\\mathsf{stmt},\\pi)\\leftarrow\\mathcal{A}(\\mathsf{crs},z)\\ :\\ \\ \\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)=1\\\\ a\\leftarrow\\mathcal{E}_{\\mathcal{A}}(\\mathsf{crs},z)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\end{array}\\right]\\approx 0 \\]</p>

    <p class="text-gray-300">Note that the knowledge extraction property implies computationally soundness (defined for NIZK).</p>

    <p class="text-gray-300">3 Basic Lifting Transformation</p>

    <p class="text-gray-300">We begin by presenting the theoretical constructions that C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> implements. In this section, we will start from a simpler basic construction that is relatively inefficient and provides a slightly weaker notion of composability (and nonetheless strong enough for many applications); we then describe improvements and strengthenings in Sections 4 and 5 respectively.</p>

    <p class="text-gray-300">We show a construction that transforms any NIZK to one that satisfies simulation sound extractability.</p>

    <p class="text-gray-300">Typically, a NIZK only guarantees soundness, which simply means that if the verifier accepts a proof, then the statement must be in the language. However, in many cases, what we actually desire is to guarantee that the prover actually “knows” a valid witness. For example, given a collision-resistant hash function, it is necessarily true that a collision <em>exists</em>, though to actually <em>compute</em> such a collision is intractable. The definition of simulation extractability captures the desired knowledge property–given a valid proof (and the extraction key produced during setup), the extractor algorithm can efficiently compute a witness.</p>

    <p class="text-gray-300">Intuition. Our first construction makes use of an asymmetric signature scheme and encryption scheme, the public keys for which are embedded in the setup parameters, and the private keys for which are embedded in the trapdoor and extraction key, respectively. The idea is to force every prover to encrypt a witness and a signature, at least one of which must be legitimate. While an honest prover will simply provide a valid witness, the simulated prover will use the signing key to provide a signature. The extractor can simply use the decryption key to recover a valid witness (or at least a signature) from the proof. This guarantees that an adversary who breaks the system can be leveraged to either break the soundness of the underlying NIZK or the unforgeability of the signature scheme.</p>

    <p class="text-gray-300">Construction. In the following, assume <span class="math">\\Sigma</span> is an unforgeable signature scheme, and <span class="math">(\\mathsf{KeyGen}_{\\mathsf{Enc}},\\mathsf{Enc},\\mathsf{Dec})</span> is a perfectly correct public key encryption scheme.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span>: Run <span class="math">(\\mathsf{pk},\\mathsf{sk})\\leftarrow\\Sigma.\\mathsf{Gen}(1^{\\lambda})</span>. Run <span class="math">(\\mathsf{pk}_{e},\\mathsf{sk}_{e})\\leftarrow\\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda})</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}^{\\prime}</span> be the following language: <span class="math">((\\mathsf{stmt},c),(r,w,\\sigma))\\in\\mathcal{L}^{\\prime}</span> <em>iff</em></p>

    <p class="text-gray-300"><span class="math">(c=\\mathsf{Enc}(\\mathsf{pk}_{e},(w,\\sigma),r))\\ \\wedge</span> <span class="math">((\\mathsf{stmt},w)\\in\\mathcal{L}\\lor(\\Sigma.\\mathcal{V}(\\mathsf{pk},\\mathsf{stmt},\\sigma)=1))</span></p>

    <p class="text-gray-300">Run <span class="math">\\mathsf{nizk.crs}\\leftarrow\\mathsf{nizk.}\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>.</p>

    <p class="text-gray-300">Publish <span class="math">\\mathsf{crs}:=(\\mathsf{nizk.crs},\\mathsf{pk},\\mathsf{pk}_{e})</span> as the common reference string.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w)</span>: Parse <span class="math">\\mathsf{crs}:=(\\mathsf{nizk.crs},\\mathsf{pk})</span>. Choose random <span class="math">r</span>, and compute <span class="math">c:=\\mathsf{Enc}(\\mathsf{pk}_{e},(w,\\bot),r)</span>.</li>

    </ul>

    <p class="text-gray-300">Call <span class="math">\\pi:=\\mathsf{nizk.}\\mathcal{P}(\\mathsf{nizk.crs},(\\mathsf{stmt},c),(r,w,\\bot))</span>, and output <span class="math">\\pi^{\\prime}:=(c,\\pi)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi^{\\prime})</span>: Parse <span class="math">\\pi^{\\prime}:=(c,\\pi)</span>, and output <span class="math">\\mathsf{nizk.}\\mathcal{V}(\\mathsf{nizk.crs},(\\mathsf{stmt},c),\\pi)</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Run the honest <span class="math">\\mathcal{K}</span> algorithm, but retain the signing key <span class="math">\\mathsf{sk}</span> as the simulation trapdoor <span class="math">\\tau:=\\mathsf{sk}</span>. The extraction key <span class="math">\\mathsf{ek}:=\\mathsf{sk}_{e}</span>, the simulated <span class="math">\\widehat{\\mathsf{crs}}:=\\mathsf{crs}=(\\mathsf{nizk.crs},\\mathsf{pk},\\mathsf{pk}_{e})</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span>: the simulator calls</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi:=\\mathsf{nizk.}\\mathcal{P}(\\mathsf{nizk.crs},(\\mathsf{stmt},c),(\\bot,\\bot,\\sigma))</span></p>

    <p class="text-gray-300">where <span class="math">\\sigma:=\\Sigma.\\mathsf{Sign}(\\mathsf{sk},\\mathsf{stmt})</span> and <span class="math">c</span> is an encryption of <span class="math">(\\bot,\\sigma)</span>. Output <span class="math">(c,\\pi)</span></p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Assume that the underlying NIZK scheme satisfies perfect completeness, computational soundness, and computational zero-knowlege, that the signature scheme satisfies existential unforgeability under chosen message attack, and that the encryption scheme is semantically secure and perfectly correct, then the above construction is a zero-knowledge proof system satisfying perfect completeness, computational zero-knowledge, and simulation extractability.</p>

    <p class="text-gray-300">The proof for the above theorem appears in the appendix.</p>

    <p class="text-gray-300">This basic SNARK-lifting construction can be further optimized for concrete performance. We defer the details of these optimizations to Appendix D, and instead focus on describing a more efficient construction that avoids evaluating signatures inside a SNARK circuit, but instead relies on pseudorandom functions and commitments.</p>

    <h2 id="sec-7" class="text-2xl font-bold">4 Improved SNARK Lifting</h2>

    <p class="text-gray-300">The previous section demonstrates the possibility of upgrading any NIZK to an SSE-NIZK. However, the construction relies on the use of signature scheme within an arithmetic circuit, which limits its performance. In this section, we first show a more efficient construction that avoids the use of signature schemes.</p>

    <p class="text-gray-300">Our construction makes use of a pseudo-random function and a perfectly-binding commitment scheme, which together replace the original signature scheme.</p>

    <p class="text-gray-300">Intuition. Recall the intuition for a pseudorandom function <span class="math">f</span>: without the knowledge of the key <span class="math">a</span>, <span class="math">f_{a}(\\cdot)</span> behaves like a true random function. However, given <span class="math">a</span>, one can compute <span class="math">f_{a}(\\cdot)</span> easily. In order to use this in lieu of a signature, we include a commitment to <span class="math">a</span> in the public parameters, and keep <span class="math">a</span> (and the commitment opening) as the trapdoor.</p>

    <p class="text-gray-300">We then design a transformed language such that a prover with a correct witness can pass; otherwise, the (simulated) prover must give <span class="math">f_{a}(\\mathsf{stmt})</span> and an opening of the commitment to the same <span class="math">a</span>.</p>

    <p class="text-gray-300">Construction. Let <span class="math">\\{f_{s}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}\\}_{s\\in\\{0,1\\}^{\\lambda}}</span> be a pseudo-random function family, let <span class="math">\\mathsf{comm}</span> be a perfectly binding commitment scheme, and let <span class="math">(\\mathsf{KeyGen}_{\\mathsf{Enc}},\\mathsf{Enc},\\mathsf{Dec})</span> be a semantically secure encryption scheme.</p>

    <p class="text-gray-300">To simplify our description, we assume <span class="math">\\mathsf{Enc}</span> and <span class="math">\\mathsf{comm}</span> both take exactly <span class="math">\\lambda</span> random bits as randomness and that the witness for <span class="math">\\mathcal{L}</span> is exactly <span class="math">\\lambda</span> bits; it is straightforward to adapt the proof when they are of different lengths.</p>

    <p class="text-gray-300">Note that in the language <span class="math">\\mathcal{L}^{\\prime}</span>, <span class="math">c</span> must be a correct encryption of some <span class="math">w</span> and <span class="math">\\mu</span>, which allows the extractor to decrypt. For a statement-witness pair to be valid, either a witness in <span class="math">\\mathcal{R}_{\\mathcal{L}}</span> is provided or an opening to <span class="math">\\rho</span> together with the value of <span class="math">f_{a}(\\mathsf{stmt})</span> is provided, where <span class="math">a</span> is the opened value of <span class="math">\\rho</span> (from <span class="math">\\mathsf{crs}</span>).</p>

    <p class="text-gray-300">For language <span class="math">\\mathcal{L}</span> with <span class="math">\\mathsf{NP}</span> relation <span class="math">\\mathcal{R}_{\\mathcal{L}}</span>, let <span class="math">\\mathcal{L}^{\\prime}</span> be the language defined as <span class="math">\\big{(}(\\mathsf{stmt},c,\\mathsf{pk}_{e},\\rho),(\\mu,r,r^{\\prime},w,a)\\big{)}\\in\\mathcal{R}_{\\mathcal{L}^{\\prime}}</span> iff:</p>

    <p class="text-gray-300"><span class="math">c</span> <span class="math">=</span> <span class="math">\\mathsf{Enc}(\\mathsf{pk}_{e},(w,\\mu);r)\\wedge</span> <span class="math">\\Big{(}(\\mathsf{stmt},w)\\in\\mathcal{R}_{\\mathcal{L}}\\vee\\big{(}\\rho</span> <span class="math">=</span> <span class="math">\\mathsf{comm}(a;r^{\\prime})\\wedge\\mu</span> <span class="math">=</span> <span class="math">f_{a}(\\mathsf{stmt})\\big{)}\\Big{)}</span></p>

    <p class="text-gray-300">Our SSE-NIZK construction is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{nizk.crs}\\leftarrow\\mathsf{nizk.}\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>;</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk}_{e},\\mathsf{sk}_{e})\\leftarrow\\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda})</span>; <span class="math">s_{0},r_{0}\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};\\rho:=\\mathsf{comm}(s_{0};r_{0})</span>; return <span class="math">\\mathsf{crs}:=(\\mathsf{nizk.crs},\\mathsf{pk}_{e},\\rho)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w)</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Parse }\\mathsf{crs}:=(\\mathsf{nizk.crs},\\mathsf{pk}_{e},\\rho)</span>; <span class="math">\\text{Output }\\bot\\text{ if }(\\mathsf{stmt},w)\\notin\\mathcal{R}_{\\mathcal{L}}</span>; <span class="math">z_{0},z_{1},z_{2},r_{1}\\stackrel{\\S}{\\leftarrow}\\{0,1\\}^{\\lambda}</span>; <span class="math">c\\leftarrow\\mathsf{Enc}(\\mathsf{pk}_{e},(w,z_{0});r_{1})</span>; <span class="math">\\mathsf{nizk.}\\pi\\leftarrow\\mathsf{nizk.}\\mathcal{P}(\\mathsf{nizk.crs},(\\mathsf{stmt},c,\\mathsf{pk}_{e},\\rho)</span>, <span class="math">(z_{0},r_{1},z_{1},w,z_{2}))</span>; return <span class="math">\\pi:=(c,\\mathsf{nizk.}\\pi)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Parse }\\mathsf{crs}:=(\\mathsf{nizk.crs},\\mathsf{pk}_{e},\\rho)\\text{ and }\\pi:=(c,\\mathsf{nizk.}\\pi)</span>; <span class="math">\\text{Call }\\mathsf{nizk.}\\mathcal{V}(\\mathsf{nizk.crs},(\\mathsf{stmt},c,\\mathsf{pk}_{e},\\rho),\\mathsf{nizk.}\\pi)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Run <span class="math">\\mathcal{K}</span> to get <span class="math">\\widehat{\\mathsf{crs}}:=\\mathsf{crs}</span>, but keep trapdoor <span class="math">\\tau:=(s_{0},r_{0})</span>, extraction key <span class="math">\\mathsf{ek}:=\\mathsf{sk}_{e}</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Parse }\\widehat{\\mathsf{crs}}:=(\\mathsf{nizk.crs},\\mathsf{pk}_{e},\\rho)\\text{ and }\\tau:=(s_{0},r_{0})</span>; <span class="math">z_{3},r_{1}\\stackrel{\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};\\mu=f_{s_{0}}(\\mathsf{stmt})</span>; <span class="math">c=\\mathsf{Enc}(\\mathsf{pk}_{e},(z_{3},\\mu);r_{1})</span>; <span class="math">\\mathsf{nizk.}\\pi\\leftarrow\\mathsf{nizk.}\\mathcal{P}(\\mathsf{nizk.crs},(\\mathsf{stmt},c,\\mathsf{pk}_{e},\\rho)</span>, <span class="math">(\\mu,r_{1},r_{0},z_{3},s_{0}))</span>; return <span class="math">\\pi:=(c,\\mathsf{nizk.}\\pi)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We also define the extractor here:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\widehat{\\mathsf{crs}},\\mathsf{ek},\\mathsf{stmt},\\pi)</span>: <span class="math">\\text{Parse }\\pi:=(c,\\mathsf{nizk.}\\pi)</span>; <span class="math">(w,\\mu)\\leftarrow\\mathsf{Dec}(\\mathsf{ek},c);\\text{return }w</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Assume that the underlying NIZK scheme satisfies perfect completeness, computational soundness, computational zero-knowledge, and that the encryption scheme is semantically secure and perfectly correct, and that the pseudo-random function family is secure, and that the commitment scheme is perfectly binding and computational hiding, then the above construction is a zero-knowledge proof system satisfying perfect completeness, computational zero-knowledge, and simulation sound extractability.</p>

    <p class="text-gray-300">We defer the proof to Appendix E.2.</p>

    <p class="text-gray-300">Optimization using hash functions. We demonstrate a way to improve the performance by the use of hash functions. Intuitively, we can apply a collision resistant hash function to the statement before applying the PRF.</p>

    <p class="text-gray-300">We need a collision resistant hash function <span class="math">h:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{\\lambda}</span>. Formally, for any polynomial time adversary <span class="math">\\mathcal{A}</span> we have,</p>

    <p class="text-gray-300"><span class="math">\\Pr[x_{0},x_{1}\\leftarrow\\mathcal{A}(1^{\\lambda}):x_{0}\\neq x_{1}\\wedge h(x_{0})=h(x_{1})]=\\mathsf{negl}(1^{k})</span></p>

    <p class="text-gray-300">Next we show how to change our construction. We modify our language <span class="math">\\mathcal{L}^{\\prime}</span> as follows,</p>

    <p class="text-gray-300">For language  <span class="math">\\mathcal{L}</span>  with NP relation  <span class="math">\\mathcal{R}_{\\mathcal{L}}</span> , let  <span class="math">\\mathcal{L}&#x27;</span>  be the language defined as  <span class="math">\\left((\\mathsf{stmt}, c, \\mathsf{pk}_e, \\rho), (\\mu, r, r&#x27;, w, a)\\right) \\in \\mathcal{R}_{\\mathcal{L}&#x27;}</span>  iff:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, (w, \\mu); r\\right) \\wedge \\\\ \\left(\\left(\\operatorname {s t m t}, w\\right) \\in \\mathcal {R} _ {\\mathcal {L}} \\vee (\\rho = \\operatorname {c o m m} (a; r ^ {\\prime}) \\wedge \\mu = f _ {a} (h (\\operatorname {s t m t})))\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that instead  <span class="math">\\mu = f_{a}(\\mathsf{stmt})</span> , we have  <span class="math">\\mu = f_{a}(h(\\mathsf{stmt}))</span> . That is to say, we apply a hash function before applying the PRF. We then modify the algorithms accordingly. The algorithms  <span class="math">\\mathcal{K}</span> ,  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\widehat{\\mathcal{K}}</span>  and  <span class="math">\\mathcal{E}</span>  are the same as before. The only part that needs changing is  <span class="math">\\widehat{\\mathcal{P}}</span> ,</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\mathcal{P}} (\\widehat{\\mathrm{crs}},\\tau ,\\mathrm{stmt})</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\text {P a r s e} \\widehat {\\mathrm {c r s}} := (\\mathrm {n i z k . c r s}, \\mathrm {p k} _ {e}, \\rho) \\text {a n d} \\tau := (s _ {0}, r _ {0}); \\\\ z _ {3}, r _ {1} \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\} ^ {\\lambda}; \\mu = f _ {s _ {0}} (h (\\mathsf {s t m t})); \\\\ c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, \\left(z _ {3}, \\mu\\right); r _ {1}\\right); \\\\ \\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\mathcal {P} (\\operatorname {n i z k}. \\operatorname {c r s}, (\\operatorname {s t m t}, c, \\operatorname {p k} _ {e}, \\rho), \\\\ (\\mu , r _ {1}, r _ {0}, z _ {3}, s _ {0})); \\\\ \\text {r e t u r n} \\pi := (c, \\operatorname {n i z k}. \\pi). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The change is we apply  <span class="math">h</span>  to  <span class="math">\\mathsf{stmt}</span>  as defined in  <span class="math">\\mathcal{L}&#x27;</span> .</p>

    <p class="text-gray-300">Next we argue the proofs can still go through. For the simulation sound extractability part, the experiments can be defined similarly. The changes are that in step 2,  <span class="math">\\mu = f_{s_0}(\\mathsf{stmt}_x)</span>  or  <span class="math">\\mu = F(\\mathsf{stmt}_x)</span>  and that in step 5, return condition (3) is changed to  <span class="math">f_{s_0}(\\mathsf{stmt}) = \\mu</span>  or  <span class="math">F(\\mathsf{stmt}) = \\mu</span> . It can be seen that except Claim 5, all claims can go through. Luckily we can still prove Claim 5 similarly. Observe that since  <span class="math">\\mathsf{stmt}</span>  has not appeared before, we can argue that  <span class="math">h(\\mathsf{stmt})</span>  has not been queried on  <span class="math">F</span>  except for negligible probability, hence  <span class="math">F(h(\\mathsf{stmt})) = \\mu</span>  happens with only negligible probability.</p>

    <p class="text-gray-300">For the zero-knowledge part, we also modify the experiments accordingly. Then it can be seen that the proofs can go through naturally.</p>

    <p class="text-gray-300">In this section, we define a strengthened version of simulation sound extractability and provide a construction.</p>

    <p class="text-gray-300">The original definition of simulation sound extractability says that if the adversary does not know a witness for a statement, he can only prove that statement if he has previously submitted this statement as an oracle query (i.e., to the simulated prover). In our strengthened definition, which we call "strongly simulation sound extractable", we further constrain the adversary to only produce statement-proof pairs that have been previously queried. In other words, under the weaker definition, it is possible for an adversary to generate novel proofs for previously-queried statements; this is precluded by the stronger definition.</p>

    <p class="text-gray-300">Strongly simulation sound extractable. We say a NIZK for a language  <span class="math">\\mathcal{L}</span>  is strongly simulation extractable iff there exists an extractor  <span class="math">\\mathcal{E}</span>  such that for all polynomial-size adversary  <span class="math">\\mathcal{A}</span> , the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l l} (\\widehat {\\mathsf {c r s}}, \\tau , \\mathsf {e k}) \\leftarrow \\widehat {\\mathcal {K}} (1 ^ {\\lambda}) &amp;amp; (\\mathsf {s t m t}, \\pi) \\notin Q \\text {a n d} \\\\ (\\mathsf {s t m t}, \\pi) \\leftarrow \\mathcal {A} ^ {\\widehat {\\mathcal {P}} (\\widehat {\\mathsf {c r s}}, \\tau , \\cdot)} (\\widehat {\\mathsf {c r s}}, \\mathsf {e k}): &amp;amp; (\\mathsf {s t m t}, w) \\notin \\mathcal {R} _ {\\mathcal {L}} \\text {a n d} \\\\ w \\leftarrow \\mathcal {E} (\\widehat {\\mathsf {c r s}}, \\mathsf {e k}, \\mathsf {s t m t}, \\pi) &amp;amp; \\mathcal {V} (\\widehat {\\mathsf {c r s}}, \\mathsf {s t m t}, \\pi) = 1 \\end{array} \\right] \\\\ = \\operatorname {n e g l} (\\lambda) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">Q</span> is the set of statement-proof pairs generated by the oracle calls to <span class="math">\\widehat{\\mathcal{P}}</span>.</p>

    <p class="text-gray-300">Intuition. Like before, a prover must always provide an encryption of a (possibly bogus) witness. Our construction makes use of a one-time signature scheme. A pair of one-time signing/verification keys are generated for each proof. Compared with Section 4, the difference is that instead of <span class="math">f_{a}(\\mathsf{stmt})</span>, a simulated prover is required to provide <span class="math">\\mu = f_{a}(\\mathsf{pk})</span>. Then we require the prover to sign the statement together with the proof, the cipher-text, and <span class="math">\\mu</span>. Briefly, due to the security of signature scheme, the adversary must use a different <span class="math">\\mathsf{pk}</span> from the ones returned from oracle queries. Thus, in order for a statement to pass the verifier without a proper witness, the prover must generate <span class="math">f_{a}(\\mathsf{pk})</span> without the knowledge of <span class="math">a</span> (thus breaking the pseudo-random function).</p>

    <p class="text-gray-300">Construction. Given a language <span class="math">\\mathcal{L}</span> with NP relation <span class="math">\\mathcal{R}_{\\mathcal{L}}</span>, let <span class="math">\\mathcal{L}&#x27;</span> be the language that</p>

    <p class="text-gray-300"><span class="math">\\big{(}(\\mathsf{stmt},c,\\mu,\\mathsf{pk}_{s},\\mathsf{pk}_{e},\\rho),(r,r^{\\prime},w,a)\\big{)}\\in \\mathcal{R}_{\\mathcal{L}&#x27;}</span> iff:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c = \\operatorname{Enc}(\\mathsf{pk}_{e}, w; r) \\wedge \\\\ \\left((\\mathsf{stmt}, w) \\in \\mathcal{R}_{\\mathcal{L}} \\vee \\big(\\mu = f_{a}(\\mathsf{pk}_{s}) \\wedge \\rho = \\mathsf{comm}(a; r^{\\prime})\\big)\\right) \\end{array}</span></div>

    <p class="text-gray-300">Next we show the construction from NIZK to strong SE-NIZK.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span>:</li>

      <li>nizk.crs <span class="math">\\leftarrow</span> nizk. <span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>;</li>

      <li><span class="math">(\\mathsf{pk}_e,\\mathsf{sk}_e)\\gets \\mathsf{KeyGen}_{\\mathrm{Enc}}(1^{\\lambda});s_0,r_0\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span></li>

      <li><span class="math">\\rho := \\mathsf{comm}(s_0;r_0)</span>. return crs := (nizk.crs, pk_e, ρ).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w)</span>:</li>

      <li>Parse crs := (nizk.crs, pk_e, ρ);</li>

      <li>Abort if <span class="math">(\\mathsf{stmt},w)\\notin \\mathcal{R}_{\\mathcal{L}}</span>;</li>

      <li><span class="math">(\\mathsf{pk}_s,\\mathsf{sk}_s)\\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^{\\lambda});z_0,z_1,z_2,r_1\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span></li>

      <li><span class="math">c = \\mathsf{Enc}(\\mathsf{pk}_e,w;r_1);</span></li>

      <li>nizk. <span class="math">\\pi \\gets</span> nizk. <span class="math">\\mathcal{P}(\\mathsf{nizk.crs},(\\mathsf{stmt},c,z_0,\\mathsf{pk}_s,\\mathsf{pk}_e,\\rho),</span></li>

      <li><span class="math">(r_1,z_1,w,z_2));</span></li>

      <li><span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s,(\\mathsf{stmt},c,z_0,\\mathsf{nizk.}\\pi));</span></li>

      <li>return <span class="math">\\pi := (c,z_0,\\mathsf{nizk.}\\pi ,\\mathsf{pk}_s,\\sigma)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathsf{crs},\\mathsf{stmt},\\pi)</span>:</li>

      <li>Parse crs := (nizk.crs, pk_e, ρ) and <span class="math">\\pi := (c, \\mu, \\mathsf{nizk.}\\pi, \\mathsf{pk}_s, \\sigma)</span>;</li>

      <li>Abort if <span class="math">\\mathsf{Verify}(\\mathsf{pk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk.}\\pi), \\sigma) = 0</span>;</li>

      <li>Call nizk. <span class="math">\\mathcal{V}(\\mathsf{nizk.crs}, (\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho), \\mathsf{nizk.}\\pi)</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda}, \\mathcal{L})</span>: Run <span class="math">\\mathcal{K}</span> to get <span class="math">\\widehat{\\mathsf{crs}} := \\mathsf{crs}</span>, but keep trapdoor <span class="math">\\tau := (s_0, r_0)</span>, extraction key <span class="math">\\mathsf{ek} := \\mathsf{sk}_e</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}}, \\tau, \\mathsf{stmt})</span>:</li>

      <li>Parse <span class="math">\\widehat{\\mathsf{crs}} := (\\mathsf{nizk.crs}, \\mathsf{pk}_e, \\rho)</span> and <span class="math">\\tau := (s_0, r_0)</span>;</li>

      <li><span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^{\\lambda})</span>; <span class="math">\\mu = f_{s_0}(\\mathsf{pk}_s)</span>;</li>

      <li><span class="math">z_3, r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^{\\lambda}</span>; <span class="math">c = \\mathsf{Enc}(\\mathsf{pk}_e, z_3; r_1)</span>;</li>

      <li>nizk. <span class="math">\\pi \\gets</span> nizk. <span class="math">\\mathcal{P}(\\mathsf{nizk.crs}, (\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho),</span></li>

      <li><span class="math">(r_1, r_0, z_3, s_0))</span>;</li>

      <li><span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk.}\\pi))</span>;</li>

      <li>return <span class="math">\\pi := (c, \\mu, \\mathsf{nizk.}\\pi, \\mathsf{pk}_s, \\sigma)</span>.</li>

    </ul>

    <p class="text-gray-300">12</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We also define the extractor here:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\widehat{\\mathsf{crs}},\\mathsf{ek},\\mathsf{stmt},\\pi)</span>: Parse <span class="math">\\pi:=(c,\\mu,\\mathsf{nizk}.\\pi,\\mathsf{pk}_{s},\\sigma);</span> <span class="math">w\\leftarrow\\mathsf{Dec}(\\mathsf{ek},c);\\mathsf{return}\\ w.</span></p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Assume that the underlying NIZK scheme satisfies perfect completeness, computational soundness, computational zero-knowledge, that the encryption scheme is semantically secure and perfectly correct, that the pseudo-random function family is secure, that the commitment scheme is perfectly binding and computational hiding, and that the one-time signature scheme is strongly unforgeable. Then the above construction is a zero-knowledge proof system satisfying perfect completeness, computational zero-knowledge, and strongly simulation sound extractability.</p>

    <p class="text-gray-300">The proof uses a similar idea of that in Section 4, which we defer to Appendix E.3.</p>

    <h2 id="sec-11" class="text-2xl font-bold">6 SNARK-Friendly Cryptography</h2>

    <p class="text-gray-300">We now discuss how to efficiently implement the theoretical constructions described in Sections 3, 4, and 5. In particular, our theoretical constructions require implementing several cryptographic primitives such as encryption, commitment, and pseudorandom functions as statements (i.e., circuits) to be proven. This raises interesting challenges in terms of practical performance because traditionally, these cryptographic primitives are optimized for raw execution on modern processor architectures, not as SNARK statements.</p>

    <p class="text-gray-300">In the remainder of the section, we will describe several important optimizations, and report the performance improvement attained through micro-benchmarking numbers.</p>

    <p class="text-gray-300">What is efficient and not efficient for SNARKs. Known SNARK constructions model computation as algebraic circuits modulo a large prime <span class="math">p</span>. Standard implementations and parameter choices for cryptographic primitives are targeted at modern hardware platforms with different constraints than SNARKs. For example, some algebraic operations, like addition and constant-scalar multiplication of field elements <span class="math">\\mathbb{F}_{p}</span>, which are expensive in hardware, are essentially free in a SNARK; however, while XORing two 32-bit numbers takes a single cycle on an ordinary CPU, this is far more costly in an arithmetic circuit.</p>

    <p class="text-gray-300">The following observations guide our choices. These points were noted by other earlier works <em>[6, 11, 14, 33, 34, 55, 62]</em> as well.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Addition and multiplications by constants in the field <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p</span> is the SNARK field order, are almost for free, and in particular are much cheaper than multiplication. Reducing the number of multiplication gates is the main optimization criteria.</li>

      <li>Bit-level operations are expensive because splitting a field element into <span class="math">n</span> bits requires <span class="math">n+1</span> multiplication gates.</li>

      <li>However, once we have a binary representation of a value, operations like Rotation and Shift are free.</li>

      <li>Random-access lookup tables, such as those used in many S-Box symmetric cryptography implementations, are likely a bottleneck. Typically, there are two main approaches to implement lookup tables in a circuit. The first approach is a linear scan to select one element, which results in <span class="math">O(n)</span> cost. The other approach involves using a permutation network to sort a sequence of memory accesses by address and providing a proof of consistency; the complexity of this depends on the number of the accesses to the array. *[12, 13, 62]</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification can be simpler than forward computation. The SNARK circuits do not always have to compute the result, but can instead represent a verification algorithm. For example, a multiplicative inverse circuit does not have to encode the computation of the inverse, but can instead consist of a single multiplication constraint on the value provided by the prover.</li>

    </ul>

    <p class="text-gray-300">Designing SNARK-friendly cryptographic primitives. We explore the following strategies for designing SNARK-friendly cryptographic primitives.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol- and algebraic-level choices. First, for the same cryptographic building block (e.g., encryption, signature), we explore building it from different algebraic building blocks such as RSA and Diffie-Hellman. Certain algebraic structures and operations are by nature more efficient when encoded as SNARK circuits. We also explore various choices such as using public-key encryption vs hybrid encryption.</li>

      <li>Circuit-level optimizations. Once a scheme is fixed, we perform numerous optimizations at the circuit level to reduce the concrete circuit size.</li>

    </ol>

    <p class="text-gray-300">We now describe our protocol choices and optimizations for the cryptographic tasks needed in our SNARK-lifting constructions from Sections 3, 4 and 5.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">6.1 Encryption</h3>

    <p class="text-gray-300">As the costs of all our SNARK-lifting constructions are dominated by the public-key encryption of the witness, we focus most of our efforts on this task.</p>

    <p class="text-gray-300">Public-Key encryption. Hawk <em>[47]</em> and Gyges <em>[46]</em> use an earlier version of C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> that has naïve implementation of RSA with OAEP, which is poorly suited to arithmetic circuits.</p>

    <p class="text-gray-300">We start by implementing an optimized circuit for RSA-OAEP encryption with SHA-256 as the hash and mask generation function <em>[44]</em>. The essential challenge with RSA is that the arithmetic operations are over integers mod <span class="math">n</span>, where <span class="math">n</span> is larger (e.g., 1024 bits) than the SNARK field order <span class="math">p</span> (typically a 254-bit prime). We represent integers mod <span class="math">n</span> as <span class="math">\\lceil\\frac{\\log_{2}n}{m}\\rceil</span> <span class="math">m</span>-bit elements. To multiply a pair of such integers <span class="math">z:=x<em>y</span> mod <span class="math">n</span>, we construct a circuit that verifies <span class="math">x</em>y=q*n+z</span>, where <span class="math">q</span> and <span class="math">z</span> are <span class="math">\\lceil\\frac{\\log_{2}n}{m}\\rceil</span> <span class="math">m</span>-bit elements provided as witnesses by the prover. Our current implementation for big integers uses <span class="math">m=64</span> for easy interfacing. It is possible to use larger <span class="math">m</span>, but this results in less than 1% savings in our implementation, as this is not the bottleneck of the circuit. To improve over a naive implementation, we use an efficient approach for long integer equality checks when the chunks are not aligned to reduce the number of comparisons. Furthermore, we use a manually-optimized circuit for SHA-256 to implement the OAEP encoding within the circuit.</p>

    <p class="text-gray-300">Hybrid encryption. We consider the use of hybrid encryption, where we use a public-key scheme to exchange/encrypt a symmetric key, and then use the symmetric key to encrypt the plaintext. To explore this alternative, we explored various options for key exchange and symmetric-key encryption as we describe below.</p>

    <p class="text-gray-300">Key exchange. Although it is possible to use the optimized RSA circuit above to encrypt and exchange a symmetric key, we explored the following schemes for a SNARK-friendly key exchange in order to find a more efficient alternative than RSA.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Diffie-Hellman key exchange via a SNARK-friendly field extension. Instead of relying on RSA as the main PKE scheme, we investigate another scheme based on the Discrete-Logarithm problem</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in Extension Fields, and use it for symmetric key exchange. Since <span class="math">p</span> is only 254-bit prime, the DL problem in <span class="math">\\mathbb{F}_{p}</span> will not be hard, therefore an extension <span class="math">\\mathbb{F}_{p^{\\mu}}</span> will be used instead. This idea is mainly inspired by the construction in PinocchioCoin <em>[33]</em>. The key exchange circuit has two generators in that case <span class="math">g,h\\in\\mathbb{F}_{p^{\\mu}}</span>, where <span class="math">\\langle g\\rangle=\\langle h\\rangle</span> is a large multiplicative subgroup of order $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p^{\\mu}-1<span class="math">. We follow Lentra’s guidelines for selecting </span>q<span class="math"> to be a factor of the </span>\\mu<span class="math">-th cyclotomic polynomial </span>\\Phi_{\\mu}(x)<span class="math"> when evaluated at </span>x=p$ <em>[49]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The hardness of discrete-log in extension fields has been studied for quite some time; recently quasi-polynomial time algorithms <em>[40, 57]</em> have been designed for the special case of fixed-sized, i.e., small, characteristic fields. The key ideas behind these recent algorithms, however, do not extend to larger characteristic fields. To estimate the security level in our case, we observe that the finite field in our context is related to pairing-based curves due to the underlying implementation of SNARKs using BN curves <em>[7]</em>. In fact, the prime <span class="math">p</span> has a special form in our case (<span class="math">p</span> can be computed based on a polynomial <span class="math">36x^{4}+36x^{3}+18x^{2}+6x+1</span>). This property can be utilized to solve the Discrete-Logarithm problem faster using the the Special Number Field Sieve algorithm proposed by Joux et al <em>[45]</em>. This is the best attack (see <em>[56]</em>) we are aware of; using <span class="math">\\mu=4</span> in our scenario yields about 86-bit security.</p>

    <p class="text-gray-300">The extension field construction requires us to search for large primes that divide <span class="math">\\Phi_{\\mu}(p)</span>. In our implementation using libsnark <em>[15]</em>, in order to get about 80-bit level of security, we set <span class="math">\\mu</span> to be 4 as mentioned above, and choose <span class="math">q</span> to be the 398-bit prime factor of the <span class="math">\\Phi_{4}(p)</span>, where <span class="math">p</span> is the SNARK field order of libsnark. For higher security when <span class="math">\\mu=6</span>, we found a 313-bit prime order subgroup for the extension field. However, to get higher security levels (i.e., <span class="math">\\mu&gt;6</span>), this may require expensive factorization.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Diffie-Hellman key exchange via a SNARK-friendly Elliptic Curve.</em> The field extension approach above has two drawbacks: 1) The size of public keys and keying material is large. For 80-bit security, the size of the exchanged key is nearly 128 bytes. A hash-based key derivation function (KDF) will have a high cost for SNARKs, especially if we raise the security level of the field extension to above 100. 2) It requires expensive factorization to find suitable parameters to achieve higher bit security. Therefore, we investigated whether we can construct a SNARK-friendly elliptic curve mainly for key exchange. Note that in earlier works that proposed elliptic curves for SNARKs <em>[14, 32]</em>, one goal was to implement the pairing operation efficiently within the circuits. On the other hand, our goal here to implement the operation required in key exchange, i.e. <span class="math">g^{x}</span>, in a more efficient way.</li>

    </ul>

    <p class="text-gray-300">Following the guidelines described in constructing Curve25519 <em>[16]</em>, we propose a SNARK-friendly Montgomery elliptic curve over the SNARK field <span class="math">\\mathbb{F}_{p}</span>, that is specified by the equation: <span class="math">y^{2}=x^{3}+Ax^{2}+x</span>, where <span class="math">A=126932</span>.</p>

    <p class="text-gray-300">Choosing <span class="math">A=126932</span> implies that the order of the curve is <span class="math">8\\times</span> 251-bit prime, and the order of its twist is <span class="math">4\\times</span> 252-bit prime. Note that the size of the prime order subgroup is above <span class="math">2^{250}</span>, achieving about 125-bit security. The secret key in our construction has the same properties as in Curve25519, i.e. chosen to be a multiple of 8, in order to avoid small subgroup attacks. Note that we don’t follow the other efficiency guidelines described for Curve25519, due to the different setting and cost model. Finally, the safety of the parameters of the new curve was verified according to the script available online on the Safe Curves website <em>[18]</em>.</p>

    <p class="text-gray-300">The implementation of point addition and multiplication using the above curve is very efficient. Assuming affine coordinates, both point doubling and addition can both be encoded using the same</p>

    <p class="text-gray-300">number of constraints in our case. In fact, each step only requires 4 multiplication gates. This is because verifying multiplicative inverses in SNARKs is very cheap, costing one multiplication gate per operation. Furthermore, to implement the operation <span class="math">g^{x}</span> efficiently, one possible optimization is to pre-compute all powers for a base <span class="math">g</span>, and hardcode them in the circuit, i.e. <span class="math">\\{g^{2},g^{3},..,g^{251}\\}</span>, then use them to compute <span class="math">g^{x}</span>. In our implementation, the operation <span class="math">g^{x}</span> costs 6 multiplications per each bit in <span class="math">x</span> (compared to 60 multiplications in Geppetto’s curve <em>[32]</em>).</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Symmetric-key encryption.</h4>

    <p class="text-gray-300">After exchanging a secret key using a public key scheme, symmetric encryption is performed in CBC mode using a block cipher. Note that in the case of using the extension field-based scheme or the elliptic curve scheme, we use a hash-based key derivation function to derive a secret key and a secret initialization vector for the symmetric encryption. This process is not required in the RSA case, as the sender can encrypt the random key and initialization vector directly.</p>

    <p class="text-gray-300">Choosing a standard block cipher like AES can be a poor choice for SNARKs due to its complexity. For example, using an available naïve implementation of AES using snarklib <em>[28]</em>, one AES-128 block requires more than 1 million gates, which would result in very expensive circuits especially when the plaintext is long. A conservative lower bound for naive AES implementation using <em>[55]</em> or <em>[62]</em> will be about 65k gates. This high cost is mainly because naïve implementations use inefficient look up tables for S-boxes, as well as similarly unoptimized procedures. In our optimized implementation, we substantially reduce the overhead for memory accesses by using a customized efficient manual implementation for the S-Box, and remove other look up tables when more efficient alternatives can be used. Our more efficient implementation costs about 23k gates per block, and about 4.6k gates in the initial key expansion phase (we are also investigating more optimizations in an ongoing work).</p>

    <p class="text-gray-300">To achieve more practical performance, we looked for lightweight ciphers according to the criteria we described in the beginning of the section, and found two promising ciphers, Speck and Chaskey block ciphers. Speck was proposed in 2013 <em>[8]</em> by NSA, and in 2015, no attacks have been found so far <em>[9]</em>. The Chaskey block cipher is an Even-Mansour block cipher that was used in the Chaskey MAC algorithm <em>[54]</em>. In terms of security, this block cipher relies on a weaker security model, in which the time complexity of an attack is about <span class="math">2^{k}/D</span> if the attacker obtains <span class="math">D</span> chosen plaintext-ciphertext pairs, and the key size is <span class="math">k</span> bits. For increased security, we use a more secure version of the Chaskey block cipher called Chaskey-LTS, which applies 16 rounds instead of 8 to achieve long-term security. Both Speck and Chaskey-LTS ciphers have more SNARK-friendly implementations compared to AES, but the disadvantage of using these ciphers is that they are new compared to AES. We plan to investigate more lightweight ciphers in the future as well.</p>

    <p class="text-gray-300">Micro-benchmarks. Table 1 provides the micro-benchmarks for the public key and symmetric key schemes discussed above, compared to their naïve implementations when possible. It should be noted that for PKE schemes, we assumed that the public key is hardcoded in the circuit, which is suitable for our purposes in the transformations. If the public keys are not hardcoded, the cost for the field extension circuit will increase with about 20k gates, and the cost for the elliptic curve scheme will be about 5K gates, but it will result into minor difference in the RSA case. As noted in the table, the cost of SNARK-friendly elliptic curve is more than 10x better than the RSA-2048 case. Also, the cost of Field Extension is about 4x better than the RSA-1024 case, but it costs more gates compared to the elliptic curve setting due to the cost of hash-based key derivation using SHA-256 (Exploring SNARK-friendly key derivation functions can be a direction for future work).</p>

    <p class="text-gray-300">Table 1: Number of constraints of PKE and symmetric-key encryption. Numbers between (. represent naive implementation cost, when significant. The field extension uses  <span class="math">(\\mu = 4)</span> . The block cipher schemes all use a 128-bit key. The block cipher cost does not include any one-time key expansion cost.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PKE Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key Exchange + Derivation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Block Cipher</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost / Block</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP (1024)</td>

            <td class="px-3 py-2 border-b border-gray-700">205k (330k) + 0</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">23k (1m, 65k)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Field Extension</td>

            <td class="px-3 py-2 border-b border-gray-700">3.5k + 52k</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP (2048)</td>

            <td class="px-3 py-2 border-b border-gray-700">435k (654k) + 0</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey</td>

            <td class="px-3 py-2 border-b border-gray-700">5k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Elliptic Curve</td>

            <td class="px-3 py-2 border-b border-gray-700">3k + 26k</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: # gates for encrypting 200 bytes for all schemes. RSA uses 2048-bit keys. ECDH refers to key exchange using the SNARK-friendly elliptic curve.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost Per Bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ratio</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP only</td>

            <td class="px-3 py-2 border-b border-gray-700">868k</td>

            <td class="px-3 py-2 border-b border-gray-700">542.47</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + AES</td>

            <td class="px-3 py-2 border-b border-gray-700">728k</td>

            <td class="px-3 py-2 border-b border-gray-700">455.06</td>

            <td class="px-3 py-2 border-b border-gray-700">7.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">522k</td>

            <td class="px-3 py-2 border-b border-gray-700">326.17</td>

            <td class="px-3 py-2 border-b border-gray-700">5.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">496k</td>

            <td class="px-3 py-2 border-b border-gray-700">310.11</td>

            <td class="px-3 py-2 border-b border-gray-700">5.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH + AES</td>

            <td class="px-3 py-2 border-b border-gray-700">323k</td>

            <td class="px-3 py-2 border-b border-gray-700">202.10</td>

            <td class="px-3 py-2 border-b border-gray-700">3.53</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH + Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">117k</td>

            <td class="px-3 py-2 border-b border-gray-700">73.21</td>

            <td class="px-3 py-2 border-b border-gray-700">1.28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ECDH + Chaskey LTS [Baseline]</td>

            <td class="px-3 py-2 border-b border-gray-700">91k</td>

            <td class="px-3 py-2 border-b border-gray-700">57.17</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the block ciphers, the table shows about 4x better cost for Speck and Chaskey compared to an optimized version of AES. We also compared with our optimized version of AES (23k multiplication gates) to an auto-generated SNARK circuit using snarklib [28] ( <span class="math">&amp;gt;1</span>  million multiplication gates). In this case, our optimized version of AES implementation is at least 40x better than the auto-generated version, and it is also at least 2-3x better than a lower bound estimate for AES implementation using current compilers.</p>

    <p class="text-gray-300">Starting from this point, we will only present results for the high security setting using RSA-2048 and the SNARK-friendly elliptic curve. The results of lower-level security involving Field Extension can be found in Appendix G. Table 2 provides the cost of encrypting 200 bytes using the above schemes (after optimizations). It can be noted that using the snark-friendly elliptic curve with the two lightweight ciphers provides better performance than the other techniques achieving about 3-9x speedup.</p>

    <p class="text-gray-300">PRFs and commitments. In our implementation, we instantiate PRFs and Commitments using an efficient SHA-256 circuit. An efficient SHA-256 circuit costs about 26k gates for one block (512-bit input), while its naive implementation using SNARK compilers costs more than 40k gates. The optimizations are mainly achieved by representing Boolean operations efficiently, and careful circuit design. A previous similar implementation and a detailed discussion of SHA-256 optimizations can be found in [11]. Our implementation has additional 1000 gates savings via further low-level optimizations across rounds.</p>

    <p class="text-gray-300">Collision resistant hashes. Lattice-based cryptography, including Ajtai's collision resistant hash, are promising for use in SNARKs [14]. However, existing estimates of concrete security for such schemes only extend to lattices over small finite fields, but do not a priori apply to lattices con</p>

    <p class="text-gray-300">Table 3: Application - Privacy-preserving smart contracts: Benchmarks for pour and freeze circuits in Hawk [47].</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">171.72</td>

            <td class="px-3 py-2 border-b border-gray-700">190.28</td>

            <td class="px-3 py-2 border-b border-gray-700">230.14</td>

            <td class="px-3 py-2 border-b border-gray-700">212.97</td>

            <td class="px-3 py-2 border-b border-gray-700">213.77</td>

            <td class="px-3 py-2 border-b border-gray-700">233.48</td>

            <td class="px-3 py-2 border-b border-gray-700">301.72</td>

            <td class="px-3 py-2 border-b border-gray-700">451.42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">55.26</td>

            <td class="px-3 py-2 border-b border-gray-700">65.67</td>

            <td class="px-3 py-2 border-b border-gray-700">86.74</td>

            <td class="px-3 py-2 border-b border-gray-700">83.81</td>

            <td class="px-3 py-2 border-b border-gray-700">81.94</td>

            <td class="px-3 py-2 border-b border-gray-700">85.29</td>

            <td class="px-3 py-2 border-b border-gray-700">109.36</td>

            <td class="px-3 py-2 border-b border-gray-700">167.49</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">295.55</td>

            <td class="px-3 py-2 border-b border-gray-700">314.25</td>

            <td class="px-3 py-2 border-b border-gray-700">421.44</td>

            <td class="px-3 py-2 border-b border-gray-700">383.62</td>

            <td class="px-3 py-2 border-b border-gray-700">388.84</td>

            <td class="px-3 py-2 border-b border-gray-700">427.91</td>

            <td class="px-3 py-2 border-b border-gray-700">559.22</td>

            <td class="px-3 py-2 border-b border-gray-700">838.33</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">9.65</td>

            <td class="px-3 py-2 border-b border-gray-700">9.65</td>

            <td class="px-3 py-2 border-b border-gray-700">9.65</td>

            <td class="px-3 py-2 border-b border-gray-700">9.58</td>

            <td class="px-3 py-2 border-b border-gray-700">9.58</td>

            <td class="px-3 py-2 border-b border-gray-700">9.58</td>

            <td class="px-3 py-2 border-b border-gray-700">12.39</td>

            <td class="px-3 py-2 border-b border-gray-700">12.39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">124.53</td>

            <td class="px-3 py-2 border-b border-gray-700">130.87</td>

            <td class="px-3 py-2 border-b border-gray-700">185.56</td>

            <td class="px-3 py-2 border-b border-gray-700">166.38</td>

            <td class="px-3 py-2 border-b border-gray-700">170.56</td>

            <td class="px-3 py-2 border-b border-gray-700">188.68</td>

            <td class="px-3 py-2 border-b border-gray-700">389.47</td>

            <td class="px-3 py-2 border-b border-gray-700">389.47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">41.59</td>

            <td class="px-3 py-2 border-b border-gray-700">44.68</td>

            <td class="px-3 py-2 border-b border-gray-700">68.7</td>

            <td class="px-3 py-2 border-b border-gray-700">57.13</td>

            <td class="px-3 py-2 border-b border-gray-700">54.68</td>

            <td class="px-3 py-2 border-b border-gray-700">67.01</td>

            <td class="px-3 py-2 border-b border-gray-700">132.34</td>

            <td class="px-3 py-2 border-b border-gray-700">132.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">213.36</td>

            <td class="px-3 py-2 border-b border-gray-700">224.09</td>

            <td class="px-3 py-2 border-b border-gray-700">331.28</td>

            <td class="px-3 py-2 border-b border-gray-700">285.49</td>

            <td class="px-3 py-2 border-b border-gray-700">290.71</td>

            <td class="px-3 py-2 border-b border-gray-700">337.75</td>

            <td class="px-3 py-2 border-b border-gray-700">732.24</td>

            <td class="px-3 py-2 border-b border-gray-700">732.24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">6.22</td>

            <td class="px-3 py-2 border-b border-gray-700">6.22</td>

            <td class="px-3 py-2 border-b border-gray-700">6.22</td>

            <td class="px-3 py-2 border-b border-gray-700">6.15</td>

            <td class="px-3 py-2 border-b border-gray-700">6.15</td>

            <td class="px-3 py-2 border-b border-gray-700">6.15</td>

            <td class="px-3 py-2 border-b border-gray-700">8.95</td>

            <td class="px-3 py-2 border-b border-gray-700">8.95</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">100.39</td>

            <td class="px-3 py-2 border-b border-gray-700">104.03</td>

            <td class="px-3 py-2 border-b border-gray-700">133.15</td>

            <td class="px-3 py-2 border-b border-gray-700">150.98</td>

            <td class="px-3 py-2 border-b border-gray-700">158.21</td>

            <td class="px-3 py-2 border-b border-gray-700">183.97</td>

            <td class="px-3 py-2 border-b border-gray-700">192.48</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">32.83</td>

            <td class="px-3 py-2 border-b border-gray-700">32.95</td>

            <td class="px-3 py-2 border-b border-gray-700">44.38</td>

            <td class="px-3 py-2 border-b border-gray-700">47.93</td>

            <td class="px-3 py-2 border-b border-gray-700">52.04</td>

            <td class="px-3 py-2 border-b border-gray-700">66.7</td>

            <td class="px-3 py-2 border-b border-gray-700">65.41</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">169.31</td>

            <td class="px-3 py-2 border-b border-gray-700">175.22</td>

            <td class="px-3 py-2 border-b border-gray-700">228.78</td>

            <td class="px-3 py-2 border-b border-gray-700">257.65</td>

            <td class="px-3 py-2 border-b border-gray-700">264.86</td>

            <td class="px-3 py-2 border-b border-gray-700">315.89</td>

            <td class="px-3 py-2 border-b border-gray-700">345.26</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">7.97</td>

            <td class="px-3 py-2 border-b border-gray-700">7.97</td>

            <td class="px-3 py-2 border-b border-gray-700">7.97</td>

            <td class="px-3 py-2 border-b border-gray-700">9.86</td>

            <td class="px-3 py-2 border-b border-gray-700">9.86</td>

            <td class="px-3 py-2 border-b border-gray-700">9.86</td>

            <td class="px-3 py-2 border-b border-gray-700">10.42</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">70.68</td>

            <td class="px-3 py-2 border-b border-gray-700">73.99</td>

            <td class="px-3 py-2 border-b border-gray-700">103.18</td>

            <td class="px-3 py-2 border-b border-gray-700">122.9</td>

            <td class="px-3 py-2 border-b border-gray-700">125.37</td>

            <td class="px-3 py-2 border-b border-gray-700">150.99</td>

            <td class="px-3 py-2 border-b border-gray-700">170.38</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">21.7</td>

            <td class="px-3 py-2 border-b border-gray-700">23.78</td>

            <td class="px-3 py-2 border-b border-gray-700">34.85</td>

            <td class="px-3 py-2 border-b border-gray-700">41.96</td>

            <td class="px-3 py-2 border-b border-gray-700">41.07</td>

            <td class="px-3 py-2 border-b border-gray-700">51.55</td>

            <td class="px-3 py-2 border-b border-gray-700">54.86</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">115.64</td>

            <td class="px-3 py-2 border-b border-gray-700">122.05</td>

            <td class="px-3 py-2 border-b border-gray-700">175.11</td>

            <td class="px-3 py-2 border-b border-gray-700">209.96</td>

            <td class="px-3 py-2 border-b border-gray-700">215.17</td>

            <td class="px-3 py-2 border-b border-gray-700">258.23</td>

            <td class="px-3 py-2 border-b border-gray-700">291.59</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.54</td>

            <td class="px-3 py-2 border-b border-gray-700">4.54</td>

            <td class="px-3 py-2 border-b border-gray-700">4.54</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.99</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">94.06</td>

            <td class="px-3 py-2 border-b border-gray-700">97.92</td>

            <td class="px-3 py-2 border-b border-gray-700">124.1</td>

            <td class="px-3 py-2 border-b border-gray-700">146.52</td>

            <td class="px-3 py-2 border-b border-gray-700">149.68</td>

            <td class="px-3 py-2 border-b border-gray-700">174.43</td>

            <td class="px-3 py-2 border-b border-gray-700">137.16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">29.98</td>

            <td class="px-3 py-2 border-b border-gray-700">32.71</td>

            <td class="px-3 py-2 border-b border-gray-700">43.96</td>

            <td class="px-3 py-2 border-b border-gray-700">46.87</td>

            <td class="px-3 py-2 border-b border-gray-700">47.38</td>

            <td class="px-3 py-2 border-b border-gray-700">57.22</td>

            <td class="px-3 py-2 border-b border-gray-700">42.09</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">155.25</td>

            <td class="px-3 py-2 border-b border-gray-700">164.45</td>

            <td class="px-3 py-2 border-b border-gray-700">211.49</td>

            <td class="px-3 py-2 border-b border-gray-700">247.86</td>

            <td class="px-3 py-2 border-b border-gray-700">253.82</td>

            <td class="px-3 py-2 border-b border-gray-700">299.87</td>

            <td class="px-3 py-2 border-b border-gray-700">236.11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">8.25</td>

            <td class="px-3 py-2 border-b border-gray-700">8.25</td>

            <td class="px-3 py-2 border-b border-gray-700">8.25</td>

            <td class="px-3 py-2 border-b border-gray-700">10.42</td>

            <td class="px-3 py-2 border-b border-gray-700">10.42</td>

            <td class="px-3 py-2 border-b border-gray-700">10.42</td>

            <td class="px-3 py-2 border-b border-gray-700">8.74</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">62.48</td>

            <td class="px-3 py-2 border-b border-gray-700">65.61</td>

            <td class="px-3 py-2 border-b border-gray-700">93.17</td>

            <td class="px-3 py-2 border-b border-gray-700">117.35</td>

            <td class="px-3 py-2 border-b border-gray-700">120.22</td>

            <td class="px-3 py-2 border-b border-gray-700">144.89</td>

            <td class="px-3 py-2 border-b border-gray-700">111.02</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">20.74</td>

            <td class="px-3 py-2 border-b border-gray-700">20.95</td>

            <td class="px-3 py-2 border-b border-gray-700">34.52</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">41.03</td>

            <td class="px-3 py-2 border-b border-gray-700">48.94</td>

            <td class="px-3 py-2 border-b border-gray-700">40.52</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">103.87</td>

            <td class="px-3 py-2 border-b border-gray-700">109.09</td>

            <td class="px-3 py-2 border-b border-gray-700">156.13</td>

            <td class="px-3 py-2 border-b border-gray-700">200.22</td>

            <td class="px-3 py-2 border-b border-gray-700">205.43</td>

            <td class="px-3 py-2 border-b border-gray-700">245.01</td>

            <td class="px-3 py-2 border-b border-gray-700">188.71</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.82</td>

            <td class="px-3 py-2 border-b border-gray-700">4.82</td>

            <td class="px-3 py-2 border-b border-gray-700">4.82</td>

            <td class="px-3 py-2 border-b border-gray-700">6.99</td>

            <td class="px-3 py-2 border-b border-gray-700">6.99</td>

            <td class="px-3 py-2 border-b border-gray-700">6.99</td>

            <td class="px-3 py-2 border-b border-gray-700">5.31</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">structed over a SNARK's (much larger) native field. In Appendix F, we establish that these estimates do indeed apply and show how to parameterize lattice-based schemes.</p>

    <p class="text-gray-300">Signatures. For digital signatures, one possible approach is to use an optimized RSA-PSS signature verification circuit using the PKCS-1 standard v2.1 [44]. As stated earlier, SNARK circuits do not necessarily have to compute, and since the signature verification in RSA is cheaper (due to the small public exponent), we adopt a signature verification circuit instead, and apply the same optimizations we applied for the RSA Encryption circuit. We currently use SHA-256 to hash the message to be signed. We use this signature circuit to implement the transformation in Section 3.</p>

    <p class="text-gray-300">Table 4: Application - anonymous credential</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">219.91</td>

            <td class="px-3 py-2 border-b border-gray-700">235.66</td>

            <td class="px-3 py-2 border-b border-gray-700">399.83</td>

            <td class="px-3 py-2 border-b border-gray-700">258.2</td>

            <td class="px-3 py-2 border-b border-gray-700">277.2</td>

            <td class="px-3 py-2 border-b border-gray-700">403.58</td>

            <td class="px-3 py-2 border-b border-gray-700">527.09</td>

            <td class="px-3 py-2 border-b border-gray-700">777.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">82.35</td>

            <td class="px-3 py-2 border-b border-gray-700">83.13</td>

            <td class="px-3 py-2 border-b border-gray-700">175.61</td>

            <td class="px-3 py-2 border-b border-gray-700">93.74</td>

            <td class="px-3 py-2 border-b border-gray-700">98.64</td>

            <td class="px-3 py-2 border-b border-gray-700">172.92</td>

            <td class="px-3 py-2 border-b border-gray-700">192.88</td>

            <td class="px-3 py-2 border-b border-gray-700">269.14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">403.82</td>

            <td class="px-3 py-2 border-b border-gray-700">432.46</td>

            <td class="px-3 py-2 border-b border-gray-700">757.07</td>

            <td class="px-3 py-2 border-b border-gray-700">469.98</td>

            <td class="px-3 py-2 border-b border-gray-700">499.09</td>

            <td class="px-3 py-2 border-b border-gray-700">763.54</td>

            <td class="px-3 py-2 border-b border-gray-700">990.16</td>

            <td class="px-3 py-2 border-b border-gray-700">1508.48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">16.45</td>

            <td class="px-3 py-2 border-b border-gray-700">16.45</td>

            <td class="px-3 py-2 border-b border-gray-700">16.45</td>

            <td class="px-3 py-2 border-b border-gray-700">16.38</td>

            <td class="px-3 py-2 border-b border-gray-700">16.38</td>

            <td class="px-3 py-2 border-b border-gray-700">16.38</td>

            <td class="px-3 py-2 border-b border-gray-700">20.86</td>

            <td class="px-3 py-2 border-b border-gray-700">20.86</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">159.36</td>

            <td class="px-3 py-2 border-b border-gray-700">178.28</td>

            <td class="px-3 py-2 border-b border-gray-700">298.85</td>

            <td class="px-3 py-2 border-b border-gray-700">206.44</td>

            <td class="px-3 py-2 border-b border-gray-700">218.8</td>

            <td class="px-3 py-2 border-b border-gray-700">342.64</td>

            <td class="px-3 py-2 border-b border-gray-700">423.63</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">54.54</td>

            <td class="px-3 py-2 border-b border-gray-700">64.35</td>

            <td class="px-3 py-2 border-b border-gray-700">117.47</td>

            <td class="px-3 py-2 border-b border-gray-700">81.64</td>

            <td class="px-3 py-2 border-b border-gray-700">82.06</td>

            <td class="px-3 py-2 border-b border-gray-700">137.41</td>

            <td class="px-3 py-2 border-b border-gray-700">166.47</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">273.76</td>

            <td class="px-3 py-2 border-b border-gray-700">305.55</td>

            <td class="px-3 py-2 border-b border-gray-700">552.62</td>

            <td class="px-3 py-2 border-b border-gray-700">376.05</td>

            <td class="px-3 py-2 border-b border-gray-700">399.17</td>

            <td class="px-3 py-2 border-b border-gray-700">639.72</td>

            <td class="px-3 py-2 border-b border-gray-700">804.45</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">14.77</td>

            <td class="px-3 py-2 border-b border-gray-700">14.77</td>

            <td class="px-3 py-2 border-b border-gray-700">14.77</td>

            <td class="px-3 py-2 border-b border-gray-700">16.66</td>

            <td class="px-3 py-2 border-b border-gray-700">16.66</td>

            <td class="px-3 py-2 border-b border-gray-700">16.66</td>

            <td class="px-3 py-2 border-b border-gray-700">18.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">154.27</td>

            <td class="px-3 py-2 border-b border-gray-700">172.81</td>

            <td class="px-3 py-2 border-b border-gray-700">285.92</td>

            <td class="px-3 py-2 border-b border-gray-700">202.77</td>

            <td class="px-3 py-2 border-b border-gray-700">215.08</td>

            <td class="px-3 py-2 border-b border-gray-700">339.11</td>

            <td class="px-3 py-2 border-b border-gray-700">419.53</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">54.27</td>

            <td class="px-3 py-2 border-b border-gray-700">64.17</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">81.19</td>

            <td class="px-3 py-2 border-b border-gray-700">82.4</td>

            <td class="px-3 py-2 border-b border-gray-700">137.2</td>

            <td class="px-3 py-2 border-b border-gray-700">166.99</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">264.34</td>

            <td class="px-3 py-2 border-b border-gray-700">295.44</td>

            <td class="px-3 py-2 border-b border-gray-700">528.02</td>

            <td class="px-3 py-2 border-b border-gray-700">368.66</td>

            <td class="px-3 py-2 border-b border-gray-700">391.79</td>

            <td class="px-3 py-2 border-b border-gray-700">632.34</td>

            <td class="px-3 py-2 border-b border-gray-700">796.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">15.05</td>

            <td class="px-3 py-2 border-b border-gray-700">15.05</td>

            <td class="px-3 py-2 border-b border-gray-700">15.05</td>

            <td class="px-3 py-2 border-b border-gray-700">17.22</td>

            <td class="px-3 py-2 border-b border-gray-700">17.22</td>

            <td class="px-3 py-2 border-b border-gray-700">17.22</td>

            <td class="px-3 py-2 border-b border-gray-700">19.46</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another optimization that can be done is to use the same approach we used for optimized DH key exchange, by relying on a SNARK-friendly elliptic curve-based scheme for signatures. Such scheme can actually be derived based on the curve used earlier in key exchange, like the relation between the curve used in Ed25519 [17] and Curve25519 [16]. Since our final transformation does not rely mainly on signatures within the circuits, we leave investigating this direction to future work.</p>

    <p class="text-gray-300">To show the enhancement introduced by our techniques, we evaluate the performance of our transformations and the SNARK-friendly cryptography in the context of three different real applications that use zk-SNARKs. The evaluation will include the three transformations presented in Section 3, the transformation in Section 4, and the stronger version in Section 5. The evaluation will also compare all the encryption schemes presented earlier in Table 8. The baseline will be a naive implementation that adopts the first transformation while using unoptimized standard RSA for both encryption and signature. As before, we assume a minimum of 112-bit security in our implementation. Results for 80-bit security are provided in Appendix G.</p>

    <p class="text-gray-300">We ran our experiments on an Amazon EC2 r2.x8 large instance. Our experiments used a single core (2.5 GHz), and 19 GB memory in the worst case. The experiments relied on libsnark as a backend, for which we developed an interface that translates our circuits into libsnark's gadget library constructs. The benchmarks include the initial one-time key generation time, the proof construction time by the prover, and the verification time by the verifier.</p>

    <p class="text-gray-300">Table 5: Application - nonoutsourced puzzles for thwarting mining pools (Type II) [53].</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">109.23</td>

            <td class="px-3 py-2 border-b border-gray-700">119.73</td>

            <td class="px-3 py-2 border-b border-gray-700">173.99</td>

            <td class="px-3 py-2 border-b border-gray-700">152.07</td>

            <td class="px-3 py-2 border-b border-gray-700">155.84</td>

            <td class="px-3 py-2 border-b border-gray-700">179.08</td>

            <td class="px-3 py-2 border-b border-gray-700">244.36</td>

            <td class="px-3 py-2 border-b border-gray-700">383.46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">35.48</td>

            <td class="px-3 py-2 border-b border-gray-700">43.78</td>

            <td class="px-3 py-2 border-b border-gray-700">61.09</td>

            <td class="px-3 py-2 border-b border-gray-700">50.17</td>

            <td class="px-3 py-2 border-b border-gray-700">52.06</td>

            <td class="px-3 py-2 border-b border-gray-700">61.57</td>

            <td class="px-3 py-2 border-b border-gray-700">86.41</td>

            <td class="px-3 py-2 border-b border-gray-700">134.31</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">182.27</td>

            <td class="px-3 py-2 border-b border-gray-700">200.62</td>

            <td class="px-3 py-2 border-b border-gray-700">296.58</td>

            <td class="px-3 py-2 border-b border-gray-700">256.39</td>

            <td class="px-3 py-2 border-b border-gray-700">263.26</td>

            <td class="px-3 py-2 border-b border-gray-700">303.05</td>

            <td class="px-3 py-2 border-b border-gray-700">446.85</td>

            <td class="px-3 py-2 border-b border-gray-700">710.03</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.43</td>

            <td class="px-3 py-2 border-b border-gray-700">6.36</td>

            <td class="px-3 py-2 border-b border-gray-700">6.36</td>

            <td class="px-3 py-2 border-b border-gray-700">6.36</td>

            <td class="px-3 py-2 border-b border-gray-700">9.3</td>

            <td class="px-3 py-2 border-b border-gray-700">9.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">59.39</td>

            <td class="px-3 py-2 border-b border-gray-700">62.58</td>

            <td class="px-3 py-2 border-b border-gray-700">89.41</td>

            <td class="px-3 py-2 border-b border-gray-700">113.38</td>

            <td class="px-3 py-2 border-b border-gray-700">116.1</td>

            <td class="px-3 py-2 border-b border-gray-700">135.37</td>

            <td class="px-3 py-2 border-b border-gray-700">163.2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">23.2</td>

            <td class="px-3 py-2 border-b border-gray-700">23.31</td>

            <td class="px-3 py-2 border-b border-gray-700">32.44</td>

            <td class="px-3 py-2 border-b border-gray-700">43.28</td>

            <td class="px-3 py-2 border-b border-gray-700">43.38</td>

            <td class="px-3 py-2 border-b border-gray-700">46.51</td>

            <td class="px-3 py-2 border-b border-gray-700">57.89</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">95.53</td>

            <td class="px-3 py-2 border-b border-gray-700">101.09</td>

            <td class="px-3 py-2 border-b border-gray-700">147.41</td>

            <td class="px-3 py-2 border-b border-gray-700">189.85</td>

            <td class="px-3 py-2 border-b border-gray-700">194.72</td>

            <td class="px-3 py-2 border-b border-gray-700">230.53</td>

            <td class="px-3 py-2 border-b border-gray-700">272.43</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.75</td>

            <td class="px-3 py-2 border-b border-gray-700">4.75</td>

            <td class="px-3 py-2 border-b border-gray-700">4.75</td>

            <td class="px-3 py-2 border-b border-gray-700">6.64</td>

            <td class="px-3 py-2 border-b border-gray-700">6.64</td>

            <td class="px-3 py-2 border-b border-gray-700">6.64</td>

            <td class="px-3 py-2 border-b border-gray-700">7.34</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ ECDH</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">47.34</td>

            <td class="px-3 py-2 border-b border-gray-700">52.18</td>

            <td class="px-3 py-2 border-b border-gray-700">73.48</td>

            <td class="px-3 py-2 border-b border-gray-700">101.3</td>

            <td class="px-3 py-2 border-b border-gray-700">103.95</td>

            <td class="px-3 py-2 border-b border-gray-700">133.17</td>

            <td class="px-3 py-2 border-b border-gray-700">95.53</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">16.56</td>

            <td class="px-3 py-2 border-b border-gray-700">19.26</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">34.69</td>

            <td class="px-3 py-2 border-b border-gray-700">34.72</td>

            <td class="px-3 py-2 border-b border-gray-700">48.45</td>

            <td class="px-3 py-2 border-b border-gray-700">34.71</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">73.81</td>

            <td class="px-3 py-2 border-b border-gray-700">80.67</td>

            <td class="px-3 py-2 border-b border-gray-700">120.47</td>

            <td class="px-3 py-2 border-b border-gray-700">168.16</td>

            <td class="px-3 py-2 border-b border-gray-700">173.03</td>

            <td class="px-3 py-2 border-b border-gray-700">216.82</td>

            <td class="px-3 py-2 border-b border-gray-700">157.61</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

            <td class="px-3 py-2 border-b border-gray-700">5.66</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Privacy-preserving smart contracts. Hawk [47] is a recently proposed cryptocurrency system that enables users to run privacy-preserving decentralized applications on top of the blockchain, such as private auctions, crowdfunding, etc. In order to achieve privacy, Hawk relies mainly on zk-SNARKs to main its guarantees. The original Hawk paper [47] used the transformation in Section 3, using only unoptimized RSA for encryption and signature. We investigate how the proposed transformation can provide better performance.</p>

    <p class="text-gray-300">We applied our transformations to two Hawk circuits: pour and freeze, which mainly enable users to spend or commit to secret coin values that they own. Table 3 presents the results at the 112-bit security level. It can be noted that the transformation presented in Section 5 achieves better performance compared to other transformations. Furthermore, for both pour and freeze circuits, usage of SNARK-friendly cryptographic schemes using ECDH and the lightweight ciphers achieved more than  <span class="math">5 \\times</span>  speedup compared to the naive implementation used for the first transformation. As stated in the Hawk paper, Hawk has now switched their implementation to using the C0C0 framework.</p>

    <p class="text-gray-300">Anonymous credentials. In this application, a user has a secret credential with multiple attributes. The credential is signed by a trusted public authority, and the main purpose of the circuit is to prove a property regarding one attribute of the credential in zero knowledge, i.e. without leakage any of the credential details. In our experiments, we assume the credential has a total size of 1 KB, and that the credential is signed using RSA-PSS with a 2048-bit key and using SHA-256 as the hash function. The main statement being proved is a simple inequality over a numeric attribute, e.g. check if the age attribute in a secret credential is greater than a certain age.</p>

    <p class="text-gray-300">Table 4 provides the benchmarks for this application at the 112-bit security level, showing more than  <span class="math">5 \\times</span>  speedup compared to the naive implementation used for the first transformation. The main reason for why the speedup in this application is higher than the previous one is due to the size of the secret witness here, which makes the encryption modules dominant in the circuit.</p>

    <p class="text-gray-300">Nonoutsourceable puzzles. Motivated by the prevalence of Bitcoin mining coalitions, which is harmful to the decentralization goal of cryptocurrency, Miller et al. proposed a technique for deterring coalitions using what is called: Nonoutsourceable Puzzles [53]. These puzzles aims to discourage pool operators from outsourcing mining work to other workers, as they can enable a worker to steal the reward without being implicated. The implementation of these nonoutsourceable puzzles relied on zk-SNARKs as well, and hence we investigate how our techniques will perform in the context of this application.</p>

    <p class="text-gray-300">Table 5 provides the benchmarks at the 112-bit security level, showing that using SNARK-friendly schemes along with the third transformation (the transformation in Section 5) can achieve  <span class="math">8 \\times</span>  speedup compared to the naive implementation used for the first transformation.</p>

    <p class="text-gray-300">Discussion: transformation cost. Although we have noted the perils of non-composability in protocol design, we nonetheless evaluate the cost of our SNARK lifting transformations in Table 6. This table reflects the most efficient transformation (Section 5). Note that the proof size in the table includes any additional outputs that are not part of the original statement. As the table shows, the additional proof size correlates with the size of the secret witness. This is why the anonymous credential application has the largest proof size. In terms of the proof computation time, the transformation we employed resulted in nearly  <span class="math">2 \\times</span>  higher proof time in the worst case, which is still practical within the context of the applications we considered.</p>

    <p class="text-gray-300">Table 6: Cost comparison with non-UC secure scheme. Proof size includes any additional outputs that are not part of the original statement, e.g. encrypted witness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Application (Witness Size)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Metric</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-UC secure</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transformation in Section 5</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hawk [Pour] (0.18KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">73.76</td>

            <td class="px-3 py-2 border-b border-gray-700">92.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prove(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">21.09</td>

            <td class="px-3 py-2 border-b border-gray-700">28.12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">123.3</td>

            <td class="px-3 py-2 border-b border-gray-700">155.25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.59</td>

            <td class="px-3 py-2 border-b border-gray-700">8.25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hawk [Freeze] (0.18KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">43.42</td>

            <td class="px-3 py-2 border-b border-gray-700">62.61</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prove(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">12.51</td>

            <td class="px-3 py-2 border-b border-gray-700">20.84</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">68.96</td>

            <td class="px-3 py-2 border-b border-gray-700">103.87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16</td>

            <td class="px-3 py-2 border-b border-gray-700">4.82</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Anonymous Credential (1KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">109.458</td>

            <td class="px-3 py-2 border-b border-gray-700">154.48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prove(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">40.44</td>

            <td class="px-3 py-2 border-b border-gray-700">54.56</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008</td>

            <td class="px-3 py-2 border-b border-gray-700">0.011</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">1.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">177.42</td>

            <td class="px-3 py-2 border-b border-gray-700">264.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">15.05</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nonoutsourceable Puzzle (0.16KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">28.92</td>

            <td class="px-3 py-2 border-b border-gray-700">47.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Prove(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">9.49</td>

            <td class="px-3 py-2 border-b border-gray-700">16.54</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.28</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key (MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">41.87</td>

            <td class="px-3 py-2 border-b border-gray-700">73.81</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key (KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">2.51</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8 Conclusion</p>

    <p class="text-gray-300">We design and implement a framework called C∅C∅, making <em>composable</em> zero-knowledge proofs a practically efficient and accessible building block for non-specialist programmers for the first time. In comparison with earlier works, C∅C∅ makes it much easier for programmers to code up composable NIZKs for general statements — in particular, the programmer now only needs to code up the high-level application and need not express the SNARK lifting transformation itself as algebraic circuits. We formally prove the security of our constructions, and demonstrate the practical performance of C∅C∅ in several applications that require zero-knowledge proofs. We show that through careful optimizations and design of SNARK-friendly cryptographic primitives, C∅C∅ provides <span class="math">\\mathbf{5}\\times</span> to <span class="math">\\mathbf{8}\\times</span> performance improvement in comparison with naive implementations.</p>

    <h2 id="sec-16" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We gratefully acknowledge Jonathan Katz for helpful technical discussions about the zero-knowledge proof constructions. We also thank Dario Fiore for pointing out an error in the previous version in one of the optimizations in the baseline schemes we compare with . This work is funded in part by NSF grants CNS-1314857, CNS-1453634, CNS-1518765, CNS-1514261, a Packard Fellowship, a Sloan Fellowship, two Google Faculty Research Awards, a VMWare Research Award, as well as grants from the DARPA Safeware and DARPA Brandeis programs. This work was done in part while a subset of the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant CNS-1523467.</p>

    <h2 id="sec-17" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Intel SGX for dummies (intel SGX design objectives). https://software.intel.com/en-us/blogs/2013/09/26/protecting-application-secrets-with-intel-sgx.</li>

      <li>[2] jsnark: A java library for building snarks. oblivm.com/jsnark.</li>

      <li>[3] Personal communication with vitalik buterin.</li>

      <li>[4] Trusted computing group. http://www.trustedcomputinggroup.org/.</li>

      <li>[5] M. R. Albrecht, R. Player, and S. Scott. On the concrete hardness of learning with errors. 2015.</li>

      <li>[6] M. Backes, M. Barbosa, D. Fiore, and R. M. Reischuk. Adsnark: nearly practical and privacy-preserving proofs on authenticated data. In Security and Privacy (SP), 2015 IEEE Symposium on. IEEE, 2015.</li>

      <li>[7] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Cryptology ePrint Archive, Report 2005/133, 2005.</li>

      <li>[8] R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and L. Wingers. The simon and speck families of lightweight block ciphers. Cryptology ePrint Archive, Report 2013/404, 2013.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[9] R. Beaulieu, D. Shors, J. Smith, S. Treatman-Clark, B. Weeks, and L. Wingers. Simon and speck: Block ciphers for the internet of things. Cryptology ePrint Archive, Report 2015/585, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In STOC, 1988.</li>

      <li>[11] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from bitcoin. In S & P, 2014.</li>

      <li>[12] E. Ben-Sasson, A. Chiesa, D. Genkin, and E. Tromer. Fast reductions from rams to delegatable succinct constraint satisfaction problems: extended abstract. In ITCS, 2013.</li>

      <li>[13] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza. Snarks for C: verifying program executions succinctly and in zero knowledge. In CRYPTO, 2013.</li>

      <li>[14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In Advances in Cryptology–CRYPTO 2014, pages 276–294. Springer, 2014.</li>

      <li>[15] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In USENIX Security, 2014.</li>

      <li>[16] D. J. Bernstein. Curve25519: new diffie-hellman speed records. In Public Key Cryptography-PKC 2006, pages 207–228. Springer, 2006.</li>

      <li>[17] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B.-Y. Yang. High-speed high-security signatures. Journal of Cryptographic Engineering, 2(2):77–89, 2012.</li>

      <li>[18] D. J. Bernstein and T. Lange. Safecurves: choosing safe curves for elliptic-curve cryptography. http://safecurves.cr.yp.to. Accessed: 2016-05-20.</li>

      <li>[19] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In ITCS, pages 326–349, 2012.</li>

      <li>[20] M. Blum, P. Feldman, and S. Micali. Non-interactive zero-knowledge and its applications. In STOC, 1988.</li>

      <li>[21] M. Blum, A. D. Santis, S. Micali, and G. Persiano. Non-interactive zero knowledge. SIAM Jornal of Computation, 1991.</li>

      <li>[22] J. Camenisch, S. Hohenberger, and A. Lysyanskaya. Compact e-cash. In EUROCRYPT, 2005.</li>

      <li>[23] J. Camenisch and A. Lysyanskaya. An efficient system for non-transferable anonymous credentials with optional anonymity revocation. In EUROCRYPT, 2001.</li>

      <li>[24] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</li>

      <li>[25] R. Canetti, Y. Dodis, R. Pass, and S. Walfish. Universally composable security with global setup. In TCC. 2007.</li>

      <li>[26] R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable two-party and multi-party secure computation. In STOC, 2002.</li>

      <li>[27] R. Canetti and T. Rabin. Universal composition with joint state. In CRYPTO, 2003.</li>

      <li>[28] J. Carlsson. snarklib: a c++ template library for zero knowledge proofs. https://github.com/jancarlsson/snarklib.</li>

      <li>[29] Y. Chen and P. Q. Nguyen. Bkz 2.0: Better lattice security estimates. In ASIACRYPT, 2011.</li>

      <li>[30] Y. Chen and P. Q. Nguyen. Bkz 2.0: Better lattice security estimates (full version), 2012.</li>

      <li>[31] A. Chiesa, E. Tromer, and M. Virza. Cluster computing in zero knowledge. In EUROCRYPT. 2015.</li>

    </ul>

    <p class="text-gray-300">[32] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter, M. Naehrig, B. Parno, and S. Zahur. Geppetto: Versatile verifiable computation. In S&P, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[33] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno. Pinocchio Coin: building Zerocoin from a succinct pairing-based proof system. In PETShop, 2013.</li>

      <li>[34] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, and B. Parno. Turning shabby x.509 certificates into elegant anonymous credentials with the magic of verifiable computation. In S& P, 2016.</li>

      <li>[35] D. Fiore and A. Nitulescu. On the (in) security of snarks in the presence of oracles. In Theory of Cryptography Conference, pages 108–138. Springer, 2016.</li>

      <li>[36] C. Garman, M. Green, and I. Miers. Accountable privacy for decentralized anonymous payments. In Financial Crypto’16, 2016.</li>

      <li>[37] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Eurocrypt, 2013.</li>

      <li>[38] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC, 2011.</li>

      <li>[39] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game. In ACM symposium on Theory of computing (STOC), 1987.</li>

      <li>[40] R. Granger, T. Kleinjung, and J. Zumbragel. On the discrete logarithm problem in finite fields of fixed characteristic. IACR ePrint Archive 2015/685, 2015.</li>

      <li>[41] J. Groth. Simulation-sound nizk proofs for a practical language and constant size group signatures. In ASIACRYPT, 2006.</li>

      <li>[42] J. Groth, R. Ostrovsky, and A. Sahai. Perfect non-interactive zero knowledge for NP. In EUROCRYPT, 2006.</li>

      <li>[43] S. Hohenberger, S. Myers, R. Pass, and a. shelat. Anonize: A large-scale anonymous survey system. In S & P, 2014.</li>

      <li>[44] J. Jonsson and B. Kaliski. Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1, 2003. RFC 3447.</li>

      <li>[45] A. Joux and C. Pierrot. The special number field sieve in <span class="math">F_{p^{n}}</span>, application to pairing-friendly constructions. Cryptology ePrint Archive, Report 2013/582, 2013.</li>

      <li>[46] A. Juels, A. Kosba, and E. Shi. The ring of gyges: Using smart contracts for crime. Manuscript, 2015.</li>

      <li>[47] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou. Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In IEEE Symposium on Security and Privacy, 2016.</li>

      <li>[48] A. E. Kosba, D. Papadopoulos, C. Papamanthou, M. F. Sayed, E. Shi, and N. Triandopoulos. Trueset: Nearly practical verifiable set computations. In Usenix Security Symposium, 2014.</li>

      <li>[49] A. K. Lenstra. Using cyclotomic polynomials to construct efficient discrete logarithm cryptosystems over finite fields. In Information Security and Privacy, pages 126–138. Springer, 1997.</li>

      <li>[50] R. Lindner and C. Peikert. Better key sizes (and attacks) for lwe-based encryption. In CT-RSA, Berlin, 2011.</li>

      <li>[51] C. C. Martin R. Albrecht, J.-C. Faug<span class="math">\\grave{e}</span>re, R. Fitzpatrick, and L. Per-ret. On the complexity of the bkw algorithm on lwe. In Designs, Codes and Cryptography, volume 74, pages 325–354, 2015.</li>

      <li>[52] D. Micciancio and O. Regev. Lattice-based cryptography. In Bernstein et al, pages 147–191, 2009.</li>

      <li>[53] A. Miller, E. Shi, A. Kosba, and J. Katz. Nonoutsourceable Scratch-Off Puzzles to Discourage Bitcoin Mining Coalitions (preprint), 2014.</li>

    </ul>

    <p class="text-gray-300">[54] N. Mouha, B. Mennink, A. Van Herrewege, D. Watanabe, B. Preneel, and I. Verbauwhede. Chaskey: An efficient mac algorithm for 32-bit microcontrollers. In Selected Areas in Cryptography. 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[55] B. Parno, J. Howell, C. Gentry, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In S & P, 2013.</li>

      <li>[56] L. G. Pierrick Gaudry and M. Videau. Collecting relations for the number field sieve in <span class="math">gf(p^{6})</span>. IACR ePrint Archive 2016/124, 2016.</li>

      <li>[57] A. J. Razvan Barbulescu, Pierrick Gaudry and E. Thome. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In EUROCRYPT’14, 2014.</li>

      <li>[58] M. R<span class="math">\\ddot{u}</span>ckert and M. Schneider. Estimating the security of lattice-based cryptosystems. 2010.</li>

      <li>[59] A. Sahai. Non-malleable non-interactive zero knowledge and adaptive chosen-ciphertext security. In FOCS ’99, 1999.</li>

      <li>[60] A. D. Santis, G. D. Crescenzo, R. Ostrovsky, G. Persiano, and A. Sahai. Robust non-interactive zero knowledge. In CRYPTO, 2001.</li>

      <li>[61] S. Setty, V. Vu, N. Panpalia, B. Braun, A. Blumberg, and M. Walfish. Taking proof-based verified computation a few steps closer to actual practicality. In USENIX security, 2012.</li>

      <li>[62] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient ram and control flow in verifiable outsourced computation. In NDSS, 2015.</li>

      <li>[63] R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In NDSS, 2015.</li>

      <li>[64] M. Walfish and A. J. Blumberg. Verifying computations without reexecuting them. Communications of the ACM, 58(2):74–84, 2015.</li>

      <li>[65] G. Wood. Ethereum: A secure decentralized transaction ledger. http://gavwood.com/paper.pdf.</li>

      <li>[66] Y. Zhang, J. Katz, and C. Papamanthou. Integridb: Verifiable SQL for outsourced databases. In ACM CCS, 2015.</li>

      <li>[67] Y. Zhang, C. Papamanthou, and J. Katz. ALITHEIA: towards practical verifiable graph processing. In ACM CCS, 2014.</li>

    </ul>

    <h2 id="sec-18" class="text-2xl font-bold">Appendix</h2>

    <h2 id="sec-19" class="text-2xl font-bold">Appendix A Sample Code</h2>

    <p class="text-gray-300">Figure 2 illustrates a code example written using C<span class="math">\\emptyset</span>C<span class="math">\\emptyset</span> for a circuit that computes a certain property over a secret document or credential that is signed by some authority.</p>

    <h2 id="sec-20" class="text-2xl font-bold">Appendix B UC 10-Minute Crash Course and Why the Practitioner Should Care</h2>

    <p class="text-gray-300">Although universal composability (UC) <em>[24]</em> and later variants <em>[25, 27]</em> are often considered as a theoretical framework for composability, we stress that they are of vital importance in practical engineering of cryptographic protocols. To aid the reader, we explain what UC provides in non-technical terms below.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: A code example for an anonymous credential circuit using C@C@.</p>

    <p class="text-gray-300">UC allows abstraction of cryptography. Cryptographic building blocks and protocols are complex. When programmers in the real world program cryptography, they should not have to think about cryptography at the abstraction of modular exponentiations or RSA hardness. Rather, they should be able to think about cryptography as a blackbox while abstracting away the implementation details.</p>

    <p class="text-gray-300">UC provides a technically correct way for doing this. The programmer can now think about cryptographic building blocks simply as making remote procedural calls to a trusted third party.</p>

    <p class="text-gray-300">UC guarantees that every (in)security property that holds in this virtual world where the trusted third party exists would hold in the real world as well — when the cryptographic building blocks are instantiated with building blocks that UC-realize the this trusted third party. Moreover, this holds no matter how many instances of the cryptographic building block or other cryptographic protocols are running, possibly concurrently.</p>

    <p class="text-gray-300">Spirit of UC is in action and perils of non-composability. The spirit of UC is applied in the real world all the time. Programmers never think of cryptographic systems as their full expanded implementation details but rather as ideal boxes. For example, trusted hardware such as TPMs <em>[4]</em> and Intel SGX <em>[1]</em> run complex cryptographic protocols, but the programmer should not have to be aware of the concrete implementation details. In fact, abstraction is often quoted as one ofthe most powerful tools in all of computer science.</p>

    <p class="text-gray-300">Clearly, it is common practice for programmers to abstract away cryptographic implementation details, i.e., the spirit of UC is implicitly in action every day.</p>

    <p class="text-gray-300">Unfortunately, making up abstractions without formal backing leads to numerous perils and pitfalls. A textbook, introductory example of failure of composability is the following:</p>

    <p class="text-gray-300">Imagine that Alice and Bob play rock-paper-scissors over the Internet. Alice calls a cryptographic commitment scheme to commit “rock”, Bob commits “scissors”. Alice and Bob then both open their commitments to decide the winner. Traditionally, we think of commitments as a building block that provides two important properties, “hiding” and “binding”. Unfortunately, it turns out that simply hiding and biding are not sufficient for this application. In particular, if the commitment scheme is malleable, Bob will be able maul Alice’s commitment into a commitment of a winning choice (and later maul Alice’s opening accordingly too)!</p>

    <p class="text-gray-300">The fundamental reason of this failure example is the following: While tempting, it is technically incorrect to think of a “hiding” and “binding” commitment as a simple trusted third party that remembers what is committed upon a “commit” invocation, and later reveal what is committed upon an “open” invocation. In other words, simply hiding and binding are not sufficient to realize a UC-secure commitment scheme.</p>

    <p class="text-gray-300">Why should you care? UC provides a formal technical tool to allow programmers to correctly abstract cryptography as simple ideal boxes in practice. UC-secure building blocks are thus the recommended best practice especially for programmers who are not cryptographers, to allow “worry-free” adoption of cryptographic building blocks as if they were ideal boxes, while avoiding many subtle pitfalls and attacks that arise from non-composability.</p>

    <h2 id="sec-21" class="text-2xl font-bold">Appendix C From SSE-NIZK to UC-Secure NIZKs</h2>

    <p class="text-gray-300">As mentioned earlier in Section 2.1, the notion of simulation sound extractability (SSE) is roughly speaking equivalent to UC-secure NIZKs. We now elaborate on the relation between SSE-NIZKs and UC-Secure NIZKs.</p>

    <p class="text-gray-300">Recall that in Sections 2 and 5, we defined a weak and a strong notion of SSE respectively. Groth <em>[41]</em> showed that the stronger notion of SSE can be used to instantiate a NIZK ideal functionality <span class="math">\\mathcal{F}_{\\text{\\tiny NIZK}}</span>. In a similar fashion, it is not hard to show that the a weak SSE secure NIZK can be used to realize a weaker version of the ideal functionality called <span class="math">\\mathcal{F}_{\\text{\\tiny WEAK-NIZK}}</span> (see Figure 3)</p>

    <p class="text-gray-300">The main difference between the weaker and the stronger version is that the weaker version may permit an adversary to maul an existing proof to a new proof, but for the <em>same statement</em>.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: A weak NIZK UC ideal functionality</p>

    <p class="text-gray-300">Both versions prevent the adversary from mauling a proof to a related statement. Depending on the application, sometimes the weak SSE notion suffices in protocol design, e.g., in Hawk [47].</p>

    <p class="text-gray-300">In this section, we show an improvement of Section 3. The idea is simple:</p>

    <p class="text-gray-300">Note in the construction of Section 3, for a witness to be valid for  <span class="math">\\mathcal{R}_{\\mathcal{L}&#x27;}</span> , either  <span class="math">w</span>  or  <span class="math">\\sigma</span>  is valid, but not both. Hence, instead of encrypting both (concatenation), we only need to encrypt the one we actually use.</p>

    <p class="text-gray-300">For language  <span class="math">\\mathcal{L}</span>  with NP relation  <span class="math">\\mathcal{R}_{\\mathcal{L}}</span> , let  <span class="math">\\mathcal{L}&#x27;</span>  be  <span class="math">((\\mathrm{stmt}, c, \\mathrm{pk}_s, \\mathrm{pk}_e), (r, w)) \\in \\mathcal{R}_{\\mathcal{L}&#x27;}</span>  iff:</p>

    <div class="my-4 text-center"><span class="math-block">c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, w; r\\right) \\wedge</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\operatorname {s t m t}, w\\right) \\in \\mathcal {R} _ {\\mathcal {L}} \\vee \\operatorname {V e r i f y} \\left(\\mathrm {p k} _ {s}, \\operatorname {s t m t}, w\\right) = 1\\right)</span></div>

    <p class="text-gray-300">The construction is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span></li>

    </ul>

    <p class="text-gray-300">snark.crs  <span class="math">\\leftarrow</span>  snark.  <span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span></p>

    <p class="text-gray-300"><span class="math">(pk_{e},sk_{e})\\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda})</span></p>

    <p class="text-gray-300"><span class="math">(pk_{s},sk_{s})\\gets \\mathsf{KeyGen}_{\\mathsf{Sig}}(1^{\\lambda})</span></p>

    <p class="text-gray-300">return  <span class="math">\\mathsf{crs} \\coloneqq (\\mathsf{snark.crs}, \\mathsf{pk}_s, \\mathsf{pk}_e)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathrm{crs},\\mathrm{stmt},w)</span></li>

    </ul>

    <p class="text-gray-300">Parse crs := (snark.crs, pk_s, pk_e);</p>

    <p class="text-gray-300">Abort if  <span class="math">(\\mathsf{stmt},w)\\notin \\mathcal{R}_{\\mathcal{L}};z_0,r_1\\stackrel {\\mathrm{s}}{\\leftarrow}\\{0,1\\}^{\\lambda};c = \\mathsf{Enc}(\\mathsf{pk}_e,w;r_1);</span></p>

    <p class="text-gray-300">snark.  <span class="math">\\pi \\gets</span>  snark.  <span class="math">\\mathcal{P}(\\mathrm{snark.crs},(\\mathrm{stmt},c,\\mathrm{pk}_s,\\mathrm{pk}_e),(r_1,w))</span></p>

    <p class="text-gray-300">return  <span class="math">\\pi \\coloneqq (c,\\mathsf{snark}.\\pi)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}(\\mathrm{crs},\\mathrm{stmt},\\pi)</span></li>

    </ul>

    <p class="text-gray-300">Parse crs := (snark.crs, pk_s, pk_e) and  <span class="math">\\pi := (c, \\text{snark.}\\pi)</span> ;</p>

    <p class="text-gray-300">Call snark.  <span class="math">\\mathcal{V}(\\mathrm{snark.crs},(\\mathrm{stmt},c,\\mathrm{pk}_s,\\mathrm{pk}_e),\\mathrm{snark.}\\pi)</span></p>

    <p class="text-gray-300"><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Run <span class="math">\\mathcal{K}</span> to get <span class="math">\\widehat{\\mathsf{crs}}:=\\mathsf{crs}</span>, but keep trapdoor <span class="math">\\tau:=\\mathsf{sk}_{s}</span>, extraction key <span class="math">\\mathsf{ek}:=\\mathsf{sk}_{e}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Parse }\\widehat{\\mathsf{crs}}:=({\\sf snark.crs},{\\sf pk}_{s},{\\sf pk}_{e})</span> and <span class="math">\\tau:=\\mathsf{sk}_{s}</span>;</p>

    <p class="text-gray-300"><span class="math">z_{1},r_{1}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}^{\\lambda}</span>; <span class="math">c=\\mathsf{Enc}({\\sf pk}_{e},\\sigma;r_{1})</span>;</p>

    <p class="text-gray-300"><span class="math">\\sigma\\leftarrow\\mathsf{Sign}(\\mathsf{sk}_{s},\\mathsf{stmt})</span></p>

    <p class="text-gray-300"><span class="math">{\\sf snark}.\\pi\\leftarrow{\\sf snark}.\\mathcal{P}({\\sf snark.crs},({\\sf stmt},c,{\\sf pk}_{s},{\\sf pk}_{e}),</span></p>

    <p class="text-gray-300"><span class="math">(r_{1},\\sigma))</span>;</p>

    <p class="text-gray-300">return <span class="math">\\pi:=(c,{\\sf snark}.\\pi)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We also define the extractor here:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\widehat{\\mathsf{crs}},\\mathsf{ek},\\mathsf{stmt},\\pi)</span>: <span class="math">\\text{Parse }\\pi:=(c,{\\sf snark}.\\pi)</span>;</p>

    <p class="text-gray-300"><span class="math">w\\leftarrow\\mathsf{Dec}(\\mathsf{ek},c)</span>; return <span class="math">w</span>.</p>

    <p class="text-gray-300">Note that in a SNARK circuit realizing this construction, the size of <span class="math">w</span> has to be the maximum of the signature size and the size of the witness that <span class="math">\\mathcal{L}</span> accepts. In other words, the shorter component will be padded inside the circuit.</p>

    <p class="text-gray-300">We next prove the construction is a SSE-NIZK.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Assume that the underlying NIZK scheme satisfies perfect completeness, computational soundness, and computational zero-knowlege, that the signature scheme satisfies existential unforgeability under chosen message attack, and that the encryption scheme is semantically secure and perfectly correct, then the above construction is a zero-knowledge proof system satisfying perfect completeness, computational zero-knowledge, and simulation sound extractability.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness is obvious. Next we show zero-knowledge and simulation sound extractability.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">The construction is zero-knowledge.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The lemma can be proved similarly as previous one. ∎</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">The construction is simulation sound extractable.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows the same idea as the previous proof, We only sketch the hybrid games:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{0}</span>: Actual game.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{1}</span>: Change the return condition to, <span class="math">w\\leftarrow\\mathsf{Dec}(\\mathsf{ek},c)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{stmt}\\notin Q</span>; (2) <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}},\\mathsf{stmt},\\pi)=1</span>;</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{pk}_{s},\\mathsf{stmt},w)=1</span></li>

    </ol>

    <p class="text-gray-300">We argue that <span class="math">\\Pr[\\mathsf{Expt}_{0}]\\leq\\Pr[\\mathsf{Expt}_{1}]+\\mathsf{negl}(\\lambda)</span>: By the soundness of the underlying NIZK, we know that <span class="math">(\\mathsf{stmt},c,\\mathsf{pk}_{s},\\mathsf{pk}_{e})\\in\\mathcal{L}^{\\prime}</span> except for negligible probability. Hence we only focus on such cases. By the perfectly correctness of the underlying encryption scheme, all valid witnesses must use the unique <span class="math">w</span> decrypted.</p>

    <p class="text-gray-300">If <span class="math">(\\mathsf{stmt},w)\\notin\\mathcal{R}_{\\mathcal{L}}</span> then we must have <span class="math">\\mathsf{Verify}(\\mathsf{pk}_{s},\\mathsf{stmt},w)=1</span>, which gives <span class="math">\\Pr[\\mathsf{Expt}_{0}]\\leq\\Pr[\\mathsf{Expt}_{1}]+\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Next we argue that <span class="math">\\Pr[\\mathsf{Expt}_{1}^{\\mathcal{A}}]\\leq\\mathsf{negl}(\\lambda)</span>: Consider otherwise, then we use <span class="math">\\mathsf{Expt}_{1}^{\\mathcal{A}}</span> as an adversary for the security game of the signature scheme: Get <span class="math">\\mathsf{pk}_{s}</span> from the game; Run <span class="math">\\mathsf{Expt}_{1}^{\\mathcal{A}}</span> with the same <span class="math">\\mathsf{pk}_{s}</span>; Replace signature with oracle calls (hence <span class="math">\\mathsf{sk}_{s}</span> is no longer); Output the <span class="math">w</span> decrypted.</p>

    <p class="text-gray-300">E Omitted Proofs</p>

    <p class="text-gray-300">Notation. We adopt several conventions for the convenience of readers following along with our experiment proofs. Sometimes we need placeholders that correspond to different variables in the experiments. To avoid confusing the names, we reserve <span class="math">z_{0},z_{1},\\ldots</span> for this purpose. For example, <span class="math">z_{3}</span> replaces witness “<span class="math">w</span>” in <span class="math">\\mathsf{Expt}_{0}</span>, although <span class="math">z_{3}</span> need not be a valid witness. To highlight the difference between successive experiments, we color the new line red, and may reproduce the previous line it replaces, striken through.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">E.1 Proof of Theorem 1</h3>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof of Theorem 1.</h6>

    <p class="text-gray-300">The proof of perfect completeness is obvious. We now show that this transformation gives a zero knowledge and simulation sound extractable NIZK.</p>

    <p class="text-gray-300">Proof of zero-knowledge. We now show that no polynomial-time adversary <span class="math">\\mathcal{A}</span> can win the zero knowledge game except with negligible probability.</p>

    <p class="text-gray-300">We construct the following hybrid games:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{\\mathsf{A}}</span>. <span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span> and <span class="math">\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt},w)</span> are run as defined. Recall that <span class="math">\\widehat{\\mathcal{P}}_{1}</span> checks the witness <span class="math">w</span> and then calls <span class="math">(c,\\pi)\\leftarrow\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{\\mathsf{B}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Use the underlying simulator setup algorithm nizk.<span class="math">\\widehat{\\mathcal{K}}</span>. Return the simulated <span class="math">\\widehat{\\mathsf{crs}}:=({\\sf nizk.}\\widehat{\\mathsf{crs}},{\\sf pk},{\\sf pk}_{c})</span>, and trapdoor <span class="math">\\tau:=({\\sf nizk.}\\tau,{\\sf sk})</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt},w)</span>: Abort if <span class="math">(\\mathsf{stmt},w)\\notin\\mathcal{L}</span>. Output <span class="math">(c,\\pi)</span>, where <span class="math">c</span> is an encryption of <span class="math">(\\bot,\\sigma)</span> and <span class="math">\\pi\\leftarrow{\\sf nizk.}\\widehat{\\mathcal{P}}({\\sf nizk.}\\widehat{\\mathsf{crs}},{\\sf nizk.}\\tau,(\\mathsf{stmt},c))</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{\\mathsf{C},t}</span>, where <span class="math">t</span> is a polynomial function of <span class="math">\\lambda</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Same as before.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt},w)</span>: Check if <span class="math">(\\mathsf{stmt},w)\\in\\mathcal{L}</span>, and abort otherwise. For the first <span class="math">t-1</span> queries, let <span class="math">c</span> be an encryption of <span class="math">(w,\\bot)</span>, and output <span class="math">(c,\\pi)</span> where <span class="math">\\pi\\leftarrow{\\sf nizk.}\\widehat{\\mathcal{P}}({\\sf nizk.}\\widehat{\\mathsf{crs}},{\\sf nizk.}\\tau,(\\mathsf{stmt},c))</span>. However, for the <span class="math">t^{th}</span> and all subsequent queries, behave the same as in <span class="math">\\mathsf{Expt}_{\\mathsf{B}}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{\\mathsf{D}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Same as before.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}_{1}(\\widehat{\\mathsf{crs}},\\bot,\\mathsf{stmt},w)</span>: Check if <span class="math">(\\mathsf{stmt},w)\\in\\mathcal{L}</span>, and abort otherwise. Let <span class="math">c</span> be an encryption of <span class="math">(w,\\bot)</span>, and output <span class="math">(c,\\pi)</span> where <span class="math">\\pi\\leftarrow{\\sf nizk.}\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,(\\mathsf{stmt},c))</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_{\\mathsf{E}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>: Actually just run <span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L})</span>, and output <span class="math">(\\mathsf{crs},\\bot,\\bot)</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{P}}_{1}(\\mathsf{crs},\\bot,\\mathsf{stmt},w)</span>: Actually just run <span class="math">\\mathcal{P}(\\mathsf{crs},\\mathsf{stmt},w)</span>.</li>

    </ul>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">First, <span class="math">\\mathsf{Expt}_{\\mathsf{A}}</span> and <span class="math">\\mathsf{Expt}_{\\mathsf{B}}</span> are indistinguishable by reduction to zero knowledge property of the underlying NIZK. Next, notice that <span class="math">\\mathsf{Expt}_{\\mathsf{B}}</span> and <span class="math">\\mathsf{Expt}_{\\mathsf{C},1}</span> are identical. We can also prove for every polynomial function <span class="math">t\\geq 1</span> that <span class="math">\\mathsf{Expt}_{\\mathsf{C},t}</span> and <span class="math">\\mathsf{Expt}_{\\mathsf{C},t+1}</span> are indistinguishable by a reduction to the semantic security of the underlying encryption scheme. Suppose <span class="math">\\mathcal{A}</span> distinguishes between <span class="math">\\mathsf{Expt}_{\\mathsf{C},t}</span> and <span class="math">\\mathsf{Expt}_{\\mathsf{C},t+1}</span>. Then we can construct an adversary <span class="math">\\mathcal{A}^{\\prime}</span> for the semantic security game as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate <span class="math">(\\widehat{\\mathsf{crs}},\\tau,ek)\\leftarrow\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span></li>

      <li>Call <span class="math">b\\leftarrow A^{\\widehat{\\mathcal{P}}^{\\dagger}(\\widehat{\\mathsf{crs}},\\tau,\\cdot,\\cdot)}</span>, where <span class="math">\\widehat{\\mathcal{P}}^{\\dagger}(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{stmt},w)</span> checks if <span class="math">(stmt,w)\\in\\mathcal{L}</span>, and then does as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the first <span class="math">t-1</span> queries, behave as in <span class="math">\\mathsf{Expt}_{\\mathsf{C},t}</span>.</li>

      <li>For the <span class="math">(t+1)^{th}</span> and all subsequent queries, behave as in <span class="math">\\mathsf{Expt}_{\\mathsf{C},t+1}</span>.</li>

      <li>On the <span class="math">t^{th}</span> query, let <span class="math">\\sigma:=\\Sigma.\\mathsf{Sign}(\\mathsf{sk},\\mathsf{stmt})</span>, and choose <span class="math">m_{1}:=(w,\\bot)</span> and <span class="math">m_{2}:=(\\bot,\\sigma)</span> as the adversary’s plaintexts in the sematic security game. Let <span class="math">c^{\\dagger}</span> be the resulting challenge ciphertext obtained from the semantic security game. Output <span class="math">(c^{\\dagger},\\pi^{\\dagger})</span>, where <span class="math">\\pi^{\\dagger}\\leftarrow\\mathsf{nizk.}\\widehat{\\mathcal{P}}(\\widehat{\\mathsf{crs}},\\tau,(\\mathsf{stmt},c^{\\dagger}))</span>.</li>

      <li>Output <span class="math">b</span></li>

    </ul>

    <p class="text-gray-300">This reduction succeeds because conditioned on the challenger choosing <span class="math">m_{1}</span> or <span class="math">m_{2}</span>, the resulting distribution is identical to <span class="math">\\mathsf{Expt}_{\\mathsf{C},t}</span> or <span class="math">\\mathsf{Expt}_{\\mathsf{C},t+1}</span> respectively. Next, suppose <span class="math">\\mathcal{A}</span> is able to distinguish between <span class="math">\\mathsf{Expt}_{\\mathsf{B}}</span> and <span class="math">\\mathsf{Expt}_{\\mathsf{D}}</span>. Let <span class="math">t^{<em>}&gt;1</span> be a polynomial function that bounds the number of oracle calls made by <span class="math">\\mathcal{A}</span>. Notice that <span class="math">\\mathsf{Expt}_{\\mathsf{C},t^{</em>}}</span> is identical to <span class="math">\\mathsf{Expt}_{\\mathsf{D}}</span> when run with <span class="math">\\mathcal{A}</span>. By induction using the argument above, <span class="math">\\mathsf{Expt}_{\\mathsf{C},1}</span> is indistinguishable from <span class="math">\\mathsf{Expt}_{\\mathsf{C},t^{*}}</span>. Finally, <span class="math">\\mathsf{Expt}_{\\mathsf{D}}</span> is indistinguishable from <span class="math">\\mathsf{Expt}_{\\mathsf{E}}</span> because the underlying proof system is zero knowledge.</p>

    <p class="text-gray-300">Proof of simulation sound extractability. We construct the following extractor:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}(\\widehat{\\mathsf{crs}},\\mathsf{ek},\\mathsf{stmt},\\pi^{\\prime})</span>: parse <span class="math">\\pi^{\\prime}:=(c,\\pi)</span>, and let <span class="math">(w,\\sigma):=\\mathsf{Dec}(\\mathsf{sk}_{e},c)</span>. Output <span class="math">w</span>.</li>

    </ul>

    <p class="text-gray-300">We now show that no polynomial-time adversary <span class="math">\\mathcal{A}</span> can win the simulation sound extractable game except with negligible probability.</p>

    <p class="text-gray-300">Given that the encryption scheme is perfectly correct, we can assume that the <span class="math">(w,\\sigma)</span> decrypted by <span class="math">\\mathcal{E}</span> is the unique plaintext that produces <span class="math">c</span> as a ciphertext.</p>

    <p class="text-gray-300">Suppose <span class="math">\\sigma</span> is a valid signature, but <span class="math">\\mathsf{stmt}</span> is not one of the statements signed via an oracle query to <span class="math">\\widehat{\\mathcal{P}}</span>. Since the underlying signature scheme is unforgeable, this event occurs with negligible probability.</p>

    <p class="text-gray-300">Otherwise, suppose <span class="math">w</span> is not a valid witness under language <span class="math">\\mathcal{L}</span> (and hence <span class="math">(\\mathsf{stmt},c)</span> is not a statement in <span class="math">\\mathcal{L}^{\\prime}</span>). This reduces to breaking the computational soundness of the underlying NIZK. Note that the adversary <span class="math">\\mathcal{A}^{\\prime}</span> for the computational soundness game must take in a real <span class="math">\\mathsf{crs}</span> and must generate a valid proof for a false statement. We can therefore construct <span class="math">\\mathcal{A}^{\\prime}(\\mathsf{crs})</span> from <span class="math">\\mathcal{A}</span> as follows: First, <span class="math">\\mathcal{A}^{\\prime}</span> runs <span class="math">(\\widehat{\\mathsf{crs}},\\tau,\\mathsf{ek})\\leftarrow\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L})</span>, but then discards <span class="math">\\widehat{\\mathsf{crs}}</span>. The <span class="math">\\mathsf{crs}</span> provided as input will be used instead. Notice that <span class="math">\\mathsf{crs}</span> and <span class="math">\\widehat{\\mathsf{crs}}</span> here are identically distributed, since both the soundness game and <span class="math">\\widehat{\\mathcal{K}}</span> both run the ordinary setup <span class="math">\\mathsf{nizk.}\\mathcal{K}</span> directly. Next, <span class="math">\\mathcal{A}^{\\prime}</span> runs <span class="math">(\\mathsf{stmt},(c,\\pi))\\leftarrow\\mathcal{A}^{\\widehat{\\mathcal{P}}(\\mathsf{crs},\\tau,\\cdot)}</span> as in the simulation sound extractable game, and returns <span class="math">((\\mathsf{stmt},c),\\pi)</span> to the computational soundness game, winning both games with similar probability. Notice that the oracle <span class="math">\\widehat{\\mathcal{P}}(\\mathsf{crs},\\tau,\\cdot)</span> does not have access to any trapdoor for the underlying NIZK and cannot generate false proofs. <span class="math">\\square</span></p>

    <p class="text-gray-300">E.2 Proof of Theorem 2</p>

    <p class="text-gray-300">Proof. Completeness is obvious.</p>

    <p class="text-gray-300">Proof of simulation sound extractability.</p>

    <p class="text-gray-300">Lemma 3. The construction is simulation sound extractable.</p>

    <p class="text-gray-300">Proof. We define the simulation soundness extractability experiment as follows:</p>

    <p class="text-gray-300">Expt0 (Actual game):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\text {n i z k . c r s} \\leftarrow \\text {n i z k .} \\mathcal {K} \\left(1 ^ {\\lambda}, \\mathcal {L} ^ {\\prime}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p k} _ {e}, \\mathsf {s k} _ {e}\\right) \\leftarrow \\mathsf {K e y G e n} _ {\\mathsf {E n c}} \\left(1 ^ {\\lambda}\\right); s _ {0}, r _ {0} \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\} ^ {\\lambda};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\operatorname {c o m m} \\left(s _ {0}; r _ {0}\\right); \\widehat {\\operatorname {c r s}} := (\\operatorname {n i z k . c r s}, \\mathrm {p k} _ {e}, \\rho).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function  <span class="math">O(\\mathsf{stmt}_x)</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z _ {3}, r _ {1} \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\} ^ {\\lambda}; \\mu = f _ {s _ {0}} (\\mathsf {s t m t} _ {x});</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, \\left(z _ {3}, \\mu\\right); r _ {1}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\mathcal {P} (\\operatorname {n i z k}. \\operatorname {c r s}, (\\operatorname {s t m t} _ {x}, c, \\mathrm {p k} _ {e}, \\rho),</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mu , r _ {1}, r _ {0}, z _ {3}, s _ {0}));</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {r e t u r n} \\pi := (c, \\operatorname {n i z k}. \\pi).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt},\\pi)\\gets \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathsf{crs}},\\mathsf{ek})</span></li>

      <li>Parse  <span class="math">\\pi \\coloneqq (c,\\mathsf{nizk}.\\pi)</span>  .  <span class="math">(w,\\mu)\\gets \\mathsf{Dec}(\\mathsf{ek},c)</span></li>

      <li>Let  <span class="math">Q</span>  be the set of  <span class="math">\\mathsf{stmt}_x</span>  queried by  <span class="math">\\mathcal{A}</span> .</li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1)  <span class="math">\\mathsf{stmt} \\notin Q</span> ; and (2)  <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}}, \\mathsf{stmt}, \\pi) = 1</span> ; and (3)  <span class="math">(\\mathsf{stmt}, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span> .</p>

    <p class="text-gray-300">Note that this is exactly the definition. We next show that  <span class="math">\\operatorname*{Pr}[\\mathsf{Expt}_0] = \\mathsf{negl}(\\lambda)</span>  by a series of hybrid games, which proves simulation sound extractability.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Expt}_1</span>  (Relax return condition):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\operatorname {c r s} \\leftarrow \\operatorname {n i z k}. \\mathcal {K} \\left(1 ^ {\\lambda}, \\mathcal {L} ^ {\\prime}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p k} _ {e}, \\mathsf {s k} _ {e}\\right) \\leftarrow \\mathsf {K e y G e n} _ {\\mathsf {E n c}} \\left(1 ^ {\\lambda}\\right); s _ {0}, r _ {0} \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\} ^ {\\lambda};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\operatorname {c o m m} \\left(s _ {0}; r _ {0}\\right); \\widehat {\\operatorname {c r s}} := (\\operatorname {n i z k}. \\operatorname {c r s}, \\mathrm {p k} _ {e}, \\rho).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function  <span class="math">O(\\mathsf{stmt}_x)</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z _ {3}, r _ {1} \\stackrel {\\S} {\\leftarrow} \\{0, 1 \\} ^ {\\lambda}; \\mu = f _ {s _ {0}} (\\mathsf {s t m t} _ {x});</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, \\left(z _ {3}, \\mu\\right); r _ {1}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\mathcal {P} (\\operatorname {n i z k}. \\operatorname {c r s}, (\\operatorname {s t m t} _ {x}, c, \\mathrm {p k} _ {e}, \\rho),</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mu , r _ {1}, r _ {0}, z _ {3}, s _ {0}));</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {r e t u r n} \\pi := (c, \\operatorname {n i z k}. \\pi).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt},\\pi)\\gets \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathsf{crs}},\\mathsf{ek})</span></li>

      <li>Parse  <span class="math">\\pi \\coloneqq (c,\\mathsf{nizk}.\\pi)</span>  .  <span class="math">(w,\\mu)\\gets \\mathsf{Dec}(\\mathsf{ek},c)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">Q</span> be the set of <span class="math">\\mathsf{stmt}_x</span> queried by <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1) <span class="math">\\mathsf{stmt} \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}}, \\mathsf{stmt}, \\pi) = 1</span>; and (3) <span class="math">f_{s_0}(\\mathsf{stmt}) = \\mu</span>.</p>

    <p class="text-gray-300"><strong>Claim 1.</strong> If the underlying encryption scheme is perfectly correct, and that the commitment scheme is perfectly binding, and that the underlying NIZK is computationally sound, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_0] \\leq \\operatorname{Pr}[\\mathsf{Expt}_1] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> From the (computational) soundness of the underlying NIZK, we know that <span class="math">(\\mathsf{stmt}, c, \\mathsf{pk}_e, \\rho) \\in \\mathcal{L}&#x27;</span> holds except for negligible probability.</p>

    <p class="text-gray-300">Since the underlying encryption scheme is perfectly correct, the decrypted <span class="math">(w, \\mu)</span> is the only possible value that encrypts to <span class="math">c</span>, hence it is unique for all valid witnesses. Given <span class="math">(\\mathsf{stmt}, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>, we consider all such valid witnesses for <span class="math">\\mathcal{R}_{\\mathcal{L}&#x27;}</span>, there must exist <span class="math">s_0&#x27;, r_0&#x27;</span> such that: (1) <span class="math">\\rho = \\mathsf{comm}(s_0&#x27;; r_0&#x27;)</span>; (2) <span class="math">\\mu = f_{s_0&#x27;}(\\mathsf{stmt})</span>. From the perfectly binding property of the underlying commitment scheme, all witnesses must use the unique value <span class="math">s_0&#x27; = s_0</span> (recall <span class="math">s_0</span> is from setup).</p>

    <p class="text-gray-300">Hence, assuming soundness holds, we have <span class="math">f_{s_0} = \\mu</span>.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>Expt₂ (Use simulation setup):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau)\\gets \\mathsf{nizk.}\\widehat{\\mathcal{K}}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>; <span class="math">(\\mathsf{pk}_e,\\mathsf{sk}_e)\\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda});s_0,r_0\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span> <span class="math">\\rho := \\mathsf{comm}(s_0;r_0);\\widehat{\\mathsf{crs}} := (\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{pk}_e,\\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">z_{3},r_{1}\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};\\mu = f_{s_{0}}(\\mathsf{stmt}_{x});</span> <span class="math">c = \\mathsf{Enc}(\\mathsf{pk}_{e},(z_{3},\\mu);r_{1});</span> <span class="math">\\mathsf{nizk.}\\pi \\gets \\mathsf{nizk.}\\widehat{\\mathcal{P}}_{1}(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau,(\\mathsf{stmt}_{x},c,\\mathsf{pk}_{e},\\rho),</span> <span class="math">(\\mu ,r_1,r_0,z_3,s_0));</span> Equivalent: <span class="math">\\mathsf{nizk.}\\pi \\gets \\mathsf{nizk.}\\widehat{\\mathcal{P}}(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau,(\\mathsf{stmt}_{x},c,\\mathsf{pk}_{e},\\rho));</span> return <span class="math">\\pi := (c,\\mathsf{nizk.}\\pi).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt},\\pi)\\gets \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathsf{crs}},\\mathsf{ek});</span></li>

      <li>Parse <span class="math">\\pi := (c, \\mathsf{nizk.} \\pi)</span>; <span class="math">(w, \\mu) \\gets \\mathsf{Dec}(\\mathsf{ek}, c)</span>;</li>

      <li>Let <span class="math">Q</span> be the set of <span class="math">\\mathsf{stmt}_x</span> queried by <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1) <span class="math">\\mathsf{stmt} \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}}, \\mathsf{stmt}, \\pi) = 1</span>; and (3) <span class="math">f_{s_0}(\\mathsf{stmt}) = \\mu</span>.</p>

    <p class="text-gray-300"><strong>Claim 2.</strong> Assuming the underlying NIZK is computationally zero-knowledge, we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_1] \\leq \\operatorname{Pr}[\\mathsf{Expt}_2] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given any polynomial adversary <span class="math">\\mathcal{A}</span>, we construct the following adversary <span class="math">\\mathcal{B}</span> for the zero-knowledge game of the underlying NIZK.</p>

    <p class="text-gray-300">Run <span class="math">\\mathsf{Expt}_2</span>, with <span class="math">\\mathsf{nizk.}\\widehat{\\mathsf{crs}}</span> obtained from the zero-knowledge game. Replace all calls to <span class="math">\\mathsf{nizk.}\\widehat{\\mathcal{P}}_1</span> with oracle calls to the game. Note that we do not have <span class="math">\\mathsf{nizk.}\\tau</span>, which is not used anymore.</p>

    <p class="text-gray-300">Observe that <span class="math">\\mathsf{Expt}_1, \\mathsf{Expt}_2</span> corresponds to running the game with honest and simulated setup/prover, respectively. I.e., <span class="math">\\operatorname{Pr}[\\mathcal{B}] = \\operatorname{Pr}[\\mathsf{Expt}_1]</span> with honest setup and <span class="math">\\operatorname{Pr}[\\mathcal{B}] = \\operatorname{Pr}[\\mathsf{Expt}_2]</span> with</p>

    <p class="text-gray-300">simulation setup. As the underlying NIZK is computationally zero-knowledge, and that <span class="math">\\mathsf{Expt}_2^A</span> runs in polynomial time, the claim holds.</p>

    <h2 id="sec-31" class="text-2xl font-bold">Expt₃ (Separate <span class="math">s_0</span>):</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\text{nizk.}\\widehat{\\text{crs}}, \\text{nizk.} \\tau) \\leftarrow \\text{nizk.} \\widehat{\\mathcal{K}}(1^{\\lambda}, \\mathcal{L}&#x27;); $$ $$ (\\mathsf{pk}_e, \\mathsf{sk}_e) \\leftarrow \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda}); \\; s_0, s_0&#x27;, r_0 \\stackrel{\\text{§}}{←} \\{0, 1\\}^{\\lambda}; $$ $$ \\rho := \\mathsf{comm}(s_0&#x27;; r_0); \\; \\widehat{\\text{crs}} := (\\text{nizk.} \\widehat{\\text{crs}}, \\mathsf{pk}_e, \\rho).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x)</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z_3, r_1 \\stackrel{\\text{§}}{←} \\{0, 1\\}^{\\lambda}; \\; \\mu = f_{s_0}(\\mathsf{stmt}_x); $$ $$ c = \\mathsf{Enc}(\\mathsf{pk}_e, (z_3, \\mu); r_1); $$ $$ \\text{nizk.} \\pi \\leftarrow \\text{nizk.} \\widehat{\\mathcal{P}}(\\text{nizk.} \\widehat{\\text{crs}}, \\text{nizk.} \\tau, (\\mathsf{stmt}_x, c, \\mathsf{pk}_e, \\rho)); $$ $$ \\text{return } \\pi := (c, \\text{nizk.} \\pi).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt}, \\pi) \\leftarrow \\mathcal{A}^{O(\\cdot)}(\\widehat{\\text{crs}}, \\mathsf{ek});</span></li>

      <li>Parse <span class="math">\\pi := (c, \\mathsf{nizk.} \\pi); \\; (w, \\mu) \\leftarrow \\mathsf{Dec}(\\mathsf{ek}, c);</span></li>

      <li>Let <span class="math">Q</span> be the set of <span class="math">\\mathsf{stmt}_x</span> queried by <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1) <span class="math">\\mathsf{stmt} \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\text{crs}}, \\mathsf{stmt}, \\pi) = 1</span>; and (3) <span class="math">f_{s_0}(\\mathsf{stmt}) = \\mu</span>.</p>

    <p class="text-gray-300"><strong>Claim 3.</strong> If the underlying commitment scheme is computationally hiding, we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_2] \\leq \\operatorname{Pr}[\\mathsf{Expt}_3] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By the hiding property of the commitment scheme, we know that for all polynomial adversary <span class="math">\\mathcal{B}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr[x_0, x_1 \\stackrel{\\text{§}}{←} \\{0, 1\\}^{\\lambda}; b \\stackrel{\\text{§}}{←} \\{0, 1\\}: \\mathcal{B}(x_0, x_1, \\mathsf{comm}(x_b)) = b] \\\\ \\leq \\frac{1}{2} + \\mathsf{negl}(\\lambda) \\end{array}</span></div>

    <p class="text-gray-300">Consider the following adversary <span class="math">\\mathcal{B}</span>: Run <span class="math">\\mathsf{Expt}_2^A</span>, except with <span class="math">s_0 = x_1, s_0&#x27; = x_0</span> and <span class="math">\\rho = \\mathsf{comm}(x_b)</span>. Return the output of <span class="math">\\mathsf{Expt}_2</span>.</p>

    <p class="text-gray-300">Observe that getting a commitment of <span class="math">s_0</span> actually corresponds to <span class="math">\\mathsf{Expt}_2^A</span>, while <span class="math">s_0&#x27;</span> corresponds to <span class="math">\\mathsf{Expt}_3^A</span>. Hence by the hiding property, we have</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[B = b] = \\frac{1}{2} \\Pr[\\mathcal{B} = 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = 0] + \\frac{1}{2} \\Pr[\\mathcal{B} = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = 1] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\frac{1}{2} (1 - \\Pr[\\mathsf{Expt}_3]) + \\frac{1}{2} \\Pr[\\mathsf{Expt}_2] \\\\ \\leq \\frac{1}{2} + \\mathsf{negl}(\\lambda) \\end{array} $$</p>

    <p class="text-gray-300">which gives <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_2] - \\operatorname{Pr}[\\mathsf{Expt}_3] \\leq \\mathsf{negl}(\\lambda)</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Expt₄ (Replace PRF):</h2>

    <p class="text-gray-300">Let <span class="math">F</span> be a true random function.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300">(nizk.crs, nizk.τ) ← nizk.K(1^λ, L');</p>

    <p class="text-gray-300">(pk_e, sk_e) ← KeyGenEnc(1^λ); s_0, s'_0, r_0 ← {0, 1}^λ;</p>

    <p class="text-gray-300">ρ := comm(s'_0; r_0); crs := (nizk.crs, pk_e, ρ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function O(stmt_x):</li>

    </ol>

    <p class="text-gray-300">z_3, r_1 ← {0, 1}^λ; μ ← F(stmt_x);</p>

    <p class="text-gray-300">c = Enc(pk_e, (z_3, μ); r_1);</p>

    <p class="text-gray-300">nizk.π ← nizk.P(nizk.crs, nizk.τ, (stmt_x, c, pk_e, ρ));</p>

    <p class="text-gray-300">return π := (c, nizk.π).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(stmt, π) ← A^{O(·)}(crs, ek);</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse π := (c, nizk.π); (w, μ) ← Dec(ek, c);</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let Q be the set of stmt_x queried by A.</li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1) stmt∉Q; and (2) V(crs, stmt, π) = 1; and (3) F(stmt) = μ.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Claim 4.</h6>

    <p class="text-gray-300">If the underlying pseudo-random function family {f_s}_s∈{0,1}^λ is secure, then we have Pr[Expt_3] ≤ Pr[Expt_4] + negl(λ).</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By the security of the underlying pseudo-random function family, no polynomial-time algorithm can distinguish a PRF from a true random function F.</p>

    <p class="text-gray-300">We construct the following adversary B for the security game of PRF: Run Expt_4^A, replace each call to F(·) with an oracle call to the game. Return the output of Expt_4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that we have Pr[B = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run with PRF] = Pr[Expt_3] and also Pr[B = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Run with Random] = Pr[Expt_4], which completes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-35" class="text-base font-medium mt-4">Claim 5.</h6>

    <p class="text-gray-300">We have Pr[Expt_4] ≤ 2^{-λ}.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have stmt∉Q. As F is true random function, we can view F(stmt) as newly generated random bits independent from μ. The result follows. ∎</p>

    <p class="text-gray-300">The above claims complete the proof for simulation sound extractability. ∎</p>

    <p class="text-gray-300">Proof of computational zero-knowledge. We prove the following lemma first:</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">If (KeyGen_Enc, Enc, Dec) is a semantically secure encryption scheme, then for all polynomial adversary A, we have the following:</p>

    <p class="text-gray-300">Pr [ (pk, sk) ← KeyGen_Enc(1^λ) : A^{O^0(pk,·,·)}(pk) = 1 ]</p>

    <p class="text-gray-300">≈ Pr [ (pk, sk) ← KeyGen_Enc(1^λ) : A^{O^1(pk,·,·)}(pk) = 1 ]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where O^b(pk, m_0, m_1) : Abort if</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≠</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. Return Enc(pk, m_b; U_λ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">t^*</span>  be the polynomial bound on the maximum number of queries. We define oracles  $O_t(m_0, m_1) : \\text{Abort if }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Return  </span>\\mathsf{Enc}(\\mathsf{pk}, m_1; U_\\lambda)<span class="math">  for the first  </span>t<span class="math">  queries and  </span>\\mathsf{Enc}(\\mathsf{pk}, m_0; U_\\lambda)$  otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that  <span class="math">O_0 = O^0</span>  and  <span class="math">O_{t^*} = O^1</span> . We next prove  <span class="math">O_t</span>  and  <span class="math">O_{t+1}</span>  are indistinguishable by the security game of the encryption.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We construct the following adversary  <span class="math">\\mathcal{B}</span>  for the security game of the encryption: Get  <span class="math">\\mathsf{pk}</span>  from the game; Run  <span class="math">\\mathcal{A}^{O_t(\\cdot,\\cdot)}</span>  with the  <span class="math">(t+1)</span> -th query answered by oracle call to the game. Return the output of  <span class="math">\\mathcal{A}</span> . Observe that  $\\operatorname*{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  answered by  </span>O^0] = \\operatorname<em>{Pr}[\\mathcal{A}^{O_t}]<span class="math">  and  </span>\\operatorname</em>{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  answered by  </span>O^1] = \\operatorname*{Pr}[\\mathcal{A}^{O_{t+1}}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the cipher-text indistinguishability of the encryption scheme, we have  <span class="math">\\operatorname<em>{Pr}[\\mathcal{A}^{O_t}]\\approx \\operatorname</em>{Pr}[\\mathcal{A}^{O_{t + 1}}]</span></p>

    <p class="text-gray-300">Proof. We prove zero-knowledge by showing any adversary  <span class="math">\\mathcal{A}</span>  can not distinguish a series of hybrid games.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: (just  <span class="math">\\widehat{\\mathcal{K}}</span> )</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k. c r s} \\leftarrow \\operatorname {n i z k. K} \\left(1 ^ {\\lambda}, \\mathcal {L} ^ {\\prime}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p k} _ {e}, \\mathsf {s k} _ {e}\\right) \\leftarrow \\mathsf {K e y G e n} _ {\\mathsf {E n c}} \\left(1 ^ {\\lambda}\\right); s _ {0}, r _ {0} \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\} ^ {\\lambda};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\operatorname {c o m m} \\left(s _ {0}; r _ {0}\\right); \\widehat {\\operatorname {c r s}} := (\\operatorname {n i z k . c r s}, \\mathrm {p k} _ {e}, \\rho).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function  <span class="math">O(\\mathsf{stmt}_x, w)</span> : (just  <span class="math">\\widehat{\\mathcal{P}}_1</span> )</li>

    </ol>

    <p class="text-gray-300">Abort if  <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span> ;  <span class="math">z_3, r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda</span> ;</p>

    <div class="my-4 text-center"><span class="math-block">\\mu = f _ {s _ {0}} \\left(\\operatorname {s t m t} _ {x}\\right); c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, \\left(z _ {3}, \\mu\\right); r _ {1}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\mathcal {P} (\\operatorname {n i z k}. \\operatorname {c r s}, (\\operatorname {s t m t} _ {x}, c, \\mathrm {p k} _ {e}, \\rho),</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mu , r _ {1}, r _ {0}, z _ {3}, s _ {0}));</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {r e t u r n} \\pi := (c, \\operatorname {n i z k}. \\pi).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b\\gets \\mathcal{A}^{O(\\cdot ,\\cdot)}(\\widehat{\\mathrm{crs}})</span>  ; Output  <span class="math">b</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\operatorname {n i z k}. \\widehat {\\operatorname {c r s}}, \\operatorname {n i z k}. \\tau\\right) \\leftarrow \\operatorname {n i z k}. \\widehat {\\mathcal {K}} \\left(1 ^ {\\lambda}, \\mathcal {L} ^ {\\prime}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathrm {p k} _ {e}, \\mathrm {s k} _ {e}\\right) \\leftarrow \\operatorname {K e y G e n} _ {\\text {E n c}} \\left(1 ^ {\\lambda}\\right); s _ {0}, r _ {0} \\stackrel {{\\S}} {{\\leftarrow}} \\{0, 1 \\} ^ {\\lambda};</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho := \\operatorname {c o m m} \\left(s _ {0}; r _ {0}\\right); \\widehat {\\operatorname {c r s}} := (\\operatorname {n i z k}. \\widehat {\\operatorname {c r s}}, \\mathrm {p k} _ {e}, \\rho).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function  <span class="math">O(\\mathsf{stmt}_x, w)</span> :</li>

    </ol>

    <p class="text-gray-300">Abort if  <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span> ;  <span class="math">z_3, r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda</span> ;</p>

    <div class="my-4 text-center"><span class="math-block">\\mu = f _ {s _ {0}} \\left(\\operatorname {s t m t} _ {x}\\right); c = \\operatorname {E n c} \\left(\\mathrm {p k} _ {e}, \\left(z _ {3}, \\mu\\right); r _ {1}\\right);</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\widehat {\\mathcal {P}} _ {1} (\\operatorname {n i z k}. \\widehat {\\operatorname {c r s}}, \\operatorname {n i z k}. \\tau , (\\operatorname {s t m t} _ {x}, c, \\mathrm {p k} _ {e}, \\rho),</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mu , r _ {1}, r _ {0}, z _ {3}, s _ {0}));</span></div>

    <p class="text-gray-300">Equivalent:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {n i z k}. \\pi \\leftarrow \\operatorname {n i z k}. \\widehat {\\mathcal {P}} (\\operatorname {n i z k}. \\widehat {\\operatorname {c r s}}, \\operatorname {n i z k}. \\tau , (\\operatorname {s t m t} _ {x}, c, \\mathrm {p k} _ {e}, \\rho));</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {r e t u r n} \\pi := (c, \\operatorname {n i z k}. \\pi).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 6.</strong> If the underlying NIZK is zero-knowledge, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_0] \\leq \\operatorname{Pr}[\\mathsf{Expt}_1] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider the following adversary <span class="math">\\mathcal{B}</span> for the zero-knowledge game: Get <span class="math">\\mathsf{crs}</span> from the game; Run <span class="math">\\mathsf{Expt}_1</span> with <span class="math">\\mathsf{crs}</span>; Replace all calls to <span class="math">\\widehat{\\mathcal{P}}_1</span> with oracle calls. Output the same as <span class="math">\\mathsf{Expt}_1</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the zero-knowledge property, we have $\\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{honest}] \\approx \\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{simulated}]<span class="math">. Observe that </span>\\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{honest}] = \\operatorname{Pr}[\\mathsf{Expt}_0]<span class="math"> while </span>\\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{simulated}] = \\operatorname{Pr}[\\mathsf{Expt}_1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>Expt₂ (encrypt true witness):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau)\\gets \\mathsf{nizk.}\\widehat{\\mathcal{K}} (1^{\\lambda},\\mathcal{L}^{\\prime})</span>; <span class="math">(\\mathsf{pk}_e,\\mathsf{sk}_e)\\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda});s_0,r_0\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span> <span class="math">\\rho := \\mathsf{comm}(s_0;r_0);\\widehat{\\mathsf{crs}} := (\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{pk}_e,\\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x,w)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Abort}</span> if <span class="math">(\\mathsf{stmt}_x,w)\\notin \\mathcal{R}_{\\mathcal{L}};z_3,z_0,r_1\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span> <span class="math">\\mu = f_{z_0}(\\mathsf{stmt}_x);c = \\mathsf{Enc}(\\mathsf{pk}_e,(w,z_0);r_1);</span> <span class="math">\\mathsf{nizk.}\\pi \\gets \\mathsf{nizk.}\\widehat{\\mathcal{P}} (\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau ,(\\mathsf{stmt}_x,c,\\mathsf{pk}_e,\\rho));</span> <span class="math">\\mathsf{return}\\pi := (c,\\mathsf{nizk.}\\pi).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 7.</strong> If the underlying encryption scheme is secure, we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_1] \\approx \\operatorname{Pr}[\\mathsf{Expt}_2]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We construct the following adversary <span class="math">\\mathcal{B}</span> for the game in Lemma 4: Get <span class="math">\\mathsf{pk}</span> from the game; Run <span class="math">\\mathsf{Expt}_2</span> with <span class="math">\\mathsf{pk}</span>; Replace <span class="math">\\mathsf{Enc}</span> with oracle calls to the game (providing both <span class="math">(z_3, \\mu), (w, z_0)</span> as two messages). Output as <span class="math">\\mathsf{Expt}_2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 4, we have $\\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{encrypting } w] \\approx \\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{encrypting } z_3]<span class="math">. And observe they correspond to </span>\\mathsf{Expt}_2<span class="math"> and </span>\\mathsf{Expt}_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>Expt₃ (Use nizk. <span class="math">\\widehat{\\mathcal{P}}_1</span>):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau)\\gets \\mathsf{nizk.}\\widehat{\\mathcal{K}} (1^{\\lambda},\\mathcal{L}^{\\prime})</span>; <span class="math">(\\mathsf{pk}_e,\\mathsf{sk}_e)\\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^{\\lambda});</span> <span class="math">s_0,r_0\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};\\rho := \\mathsf{comm}(s_0;r_0);</span> <span class="math">\\widehat{\\mathsf{crs}} := (\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{pk}_e,\\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x,w)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Abort}</span> if <span class="math">(\\mathsf{stmt}_x,w)\\notin \\mathcal{R}_{\\mathcal{L}};z_0,z_1,z_2,r_1\\stackrel {\\S}{\\leftarrow}\\{0,1\\}^{\\lambda};</span> <span class="math">c = \\mathsf{Enc}(\\mathsf{pk}_e,(w,z_0);r_1);</span> <span class="math">\\mathsf{nizk.}\\pi \\gets \\mathsf{nizk.}\\widehat{\\mathcal{P}}_1(\\mathsf{nizk.}\\widehat{\\mathsf{crs}},\\mathsf{nizk.}\\tau ,(\\mathsf{stmt}_x,c,\\mathsf{pk}_e,\\rho),</span> <span class="math">(z_0,r_1,z_1,w,z_2));</span> <span class="math">\\mathsf{return}\\pi := (c,\\mathsf{nizk.}\\pi).</span></p>

    <p class="text-gray-300">37</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 8.</strong> We have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_3] = \\operatorname{Pr}[\\mathsf{Expt}_2]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The two probabilities are equal, by the definition of <span class="math">\\mathsf{nizk}.\\widehat{\\mathcal{K}}_1</span> and that <span class="math">(z_0,r_1,z_1,w,z_2)</span> is valid.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>Expt₄ (Back to <span class="math">\\mathcal{P}</span>):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <pre><code class="language-text">nizk.crs ← nizk.K(1λ, L&#x27;);
(pkₑ, skₑ) ← KeyGenEnc(1λ); s₀, r₀ ⇔ {0, 1}λ;
ρ := comm(s₀; r₀); crs := (nizk.crs, pkₑ, ρ).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <pre><code class="language-text">Abort if (stmtₓ, w) ∉ R_L; z₀, z₁, z₂, r₁ ⇔ {0, 1}λ;
c = Enc(pkₑ, (w, z₀); r₁);
nizk.π ← nizk.P(nizk.crs, (stmtₓ, c, pkₑ, ρ), (z₀, r₁, z₁, w, z₂));
return π := (c, nizk.π).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 9.</strong> If the underlying NIZK is zero-knowledge, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_4] \\approx \\operatorname{Pr}[\\mathsf{Expt}_3]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We construct the following adversary <span class="math">\\mathcal{B}</span> for the zero-knowledge game: Get crs from the game; Run <span class="math">\\mathsf{Expt}_4^{\\mathcal{A}}</span> with crs; Replace nizk.P with oracle calls. Return the output of <span class="math">\\mathsf{Expt}_4^{\\mathcal{A}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the zero-knowledge property, we have $\\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{honest}] \\approx \\operatorname{Pr}[\\mathcal{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{simulated}]<span class="math">. And observe the two probabilities correspond two </span>\\operatorname{Pr}[\\mathsf{Expt}_4]<span class="math"> and </span>\\operatorname{Pr}[\\mathsf{Expt}_3]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the last experiment is just the honest prover, which completes the proof of the zero-knowledge property.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300">The proof of simulation sound extractable and the proof of zero-knowledge completes the theorem.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>E.3 Proof of Theorem 3</strong></p>

    <p class="text-gray-300"><strong>Proof of Theorem 3.</strong> Completeness is obvious, we next prove it is also strongly simulation sound extractable and zero-knowledge.</p>

    <p class="text-gray-300"><strong>Strong simulation sound extractability.</strong></p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> The construction is strongly simulation sound extractable.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The game for strong simulation sound extractability is defined as follows:</p>

    <p class="text-gray-300"><strong>Expt₀ (Actual game):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300">nizk.crs <span class="math">\\leftarrow</span> nizk.<span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>; <span class="math">(pk_e, sk_e) \\leftarrow KeyGen_{Enc}(1^{\\lambda});\\ s_0, r_0 \\stackrel{\\text{\\text{S}}}{{\\leftarrow}} \\{0,1\\}^{\\lambda};</span> <span class="math">\\rho := \\mathrm{comm}(s_0;r_0).\\ \\widehat{\\mathrm{crs}} := (\\mathrm{nizk.crs}, pk_e, \\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathrm{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(pk_s, sk_s) \\leftarrow KeyGen_{Sig}(1^{\\lambda});\\ \\mu = f_{s_0}(pk_s);</span> <span class="math">z_3, r_1 \\stackrel{\\text{S}}{{\\leftarrow}} \\{0,1\\}^{\\lambda};\\ c = \\mathrm{Enc}(pk_e, z_3; r_1);</span> nizk.<span class="math">\\pi \\leftarrow</span> nizk.<span class="math">\\mathcal{P}(\\mathrm{nizk.crs}, (\\mathrm{stmt}_x, c, \\mu, pk_s, pk_e, \\rho),</span> <span class="math">(r_1, r_0, z_3, s_0));</span> <span class="math">\\sigma \\leftarrow \\mathrm{Sign}(sk_s, (\\mathrm{stmt}, c, \\mu, nizk.\\pi));</span> return <span class="math">\\pi := (c, \\mu, nizk.\\pi, pk_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{stmt}, \\pi) \\leftarrow \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathrm{crs}}, \\mathrm{ek});</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\pi := (c, \\mu, nizk.\\pi, pk_s, \\sigma);\\ w \\leftarrow \\mathrm{Dec}(ek, c);</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">Q</span> be the set of statement-proof pairs generated by <span class="math">O(\\cdot)</span></li>

    </ol>

    <p class="text-gray-300">Output 1 iff: (1) <span class="math">(\\mathrm{stmt}, \\pi) \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathrm{crs}}, \\mathrm{stmt}, \\pi) = 1</span>; and (3) <span class="math">(\\mathrm{stmt}, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>.</p>

    <p class="text-gray-300"><strong>Expt<span class="math">_1</span> (Relax return condition):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300">nizk.crs <span class="math">\\leftarrow</span> nizk.<span class="math">\\mathcal{K}(1^{\\lambda},\\mathcal{L}^{\\prime})</span>; <span class="math">(pk_e, sk_e) \\leftarrow KeyGen_{Enc}(1^{\\lambda});\\ s_0, r_0 \\stackrel{\\text{S}}{{\\leftarrow}} \\{0,1\\}^{\\lambda};</span> <span class="math">\\rho := \\mathrm{comm}(s_0;r_0);\\ \\widehat{\\mathrm{crs}} := (\\mathrm{nizk.crs}, pk_e, \\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathrm{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(pk_s, sk_s) \\leftarrow KeyGen_{Sig}(1^{\\lambda});\\ \\mu = f_{s_0}(pk_s);</span> <span class="math">z_3, r_1 \\stackrel{\\text{S}}{{\\leftarrow}} \\{0,1\\}^{\\lambda};\\ c = \\mathrm{Enc}(pk_e, z_3; r_1);</span> nizk.<span class="math">\\pi \\leftarrow</span> nizk.<span class="math">\\mathcal{P}(\\mathrm{nizk.crs}, (\\mathrm{stmt}_x, c, \\mu, pk_s, pk_e, \\rho),</span> <span class="math">(r_1, r_0, z_3, s_0));</span> <span class="math">\\sigma \\leftarrow \\mathrm{Sign}(sk_s, (\\mathrm{stmt}, c, \\mu, nizk.\\pi));</span> return <span class="math">\\pi := (c, \\mu, nizk.\\pi, pk_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathrm{stmt}, \\pi) \\leftarrow \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathrm{crs}}, \\mathrm{ek});</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\pi := (c, \\mu, nizk.\\pi, pk_s, \\sigma);\\ w \\leftarrow \\mathrm{Dec}(ek, c);</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">Q</span> be the set of statement-proof pairs and <span class="math">T</span> be the set of verification keys generated by <span class="math">O(\\cdot)</span>. The experiment outputs 1 iff:</li>

    </ol>

    <p class="text-gray-300">(1) <span class="math">(\\mathrm{stmt}, \\pi) \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathrm{crs}}, \\mathrm{stmt}, \\pi) = 1</span>; and (3) <span class="math">pk_s \\notin T</span>; and (4) <span class="math">\\mu = f_{s_0}(pk_s)</span>.</p>

    <p class="text-gray-300"><strong>Claim 10.</strong> If the underlying one-time signature scheme is strongly unforgeable, and that the underlying NIZK is sound, then we have <span class="math">\\operatorname{Pr}[\\mathrm{Expt}_0] \\leq \\operatorname{Pr}[\\mathrm{Expt}_1] + \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">39</p>

    <p class="text-gray-300">Proof. Note that if <span class="math">(\\mathsf{stmt},\\pi)\\notin Q</span> and “<span class="math">\\mathsf{pk}_s</span> has been generated by <span class="math">O(\\cdot)</span>”, then the <span class="math">(\\mathsf{stmt},c,\\mu,\\mathsf{nizk}.\\pi)</span> (from <span class="math">\\mathsf{stmt}</span> and <span class="math">\\pi</span>) is a valid message/signature pair. Hence by the unforgeability of the signature scheme, we know that <span class="math">(\\mathsf{stmt},\\pi)\\notin Q</span> and “<span class="math">\\mathsf{pk}_s</span> has been generated by <span class="math">O(\\cdot)</span>” happens with negligible probability, which allows us to focus on <span class="math">\\mathsf{pk}_s\\notin T</span>.</p>

    <p class="text-gray-300">The decrypted <span class="math">w</span> is unique for all valid witnesses. Further, if some witness is valid for <span class="math">\\mathcal{L}&#x27;</span> and that <span class="math">(\\mathsf{stmt}, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>, we know it must be the case that there exists some <span class="math">s_0&#x27;</span>, such that <span class="math">\\rho</span> is a valid commitment of <span class="math">s_0&#x27;</span> and that <span class="math">\\mu = f_{s_0&#x27;}(\\mathsf{pk}_s)</span>, which implies <span class="math">\\mu = f_{s_0}(\\mathsf{pk}_s)</span>, by the perfectly binding property.</p>

    <p class="text-gray-300">Expt2 (Use simulation setup):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300">(nizk.crs, nizk.τ) ← nizk.K(1^λ, L'); (pk_e, sk_e) ← KeyGenEnc(1^λ); s_0, r_0 ← {0, 1}^λ; ρ := comm(s_0; r_0); crs := (nizk.crs, pk_e, ρ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300">(pk_s, sk_s) ← KeyGenSig(1^λ); μ = f_{s_0}(\\mathsf{pk}_s); z_3, r_1 ← {0, 1}^λ; c = Enc(pk_e, z_3; r_1); nizk.π ← nizk.P1(nizk.crs, nizk.τ, (stmt_x, c, μ, pk_s, pk_e, ρ), (r_1, r_0, z_3, s_0)); Equivalent: nizk.π ← nizk.P(nizk.crs, (stmt_x, c, μ, pk_s, pk_e, ρ)); σ ← Sign(sk_s, (stmt, c, μ, nizk.π)); return π := (c, μ, nizk.π, pk_s, σ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(stmt, π) ← A^{O(·)}(crs, ek);</li>

      <li>Parse π := (c, μ, nizk.π, pk_s, σ); w ← Dec(ek, c);</li>

      <li>Let Q be the set of statement-proof pairs and T be the set of verification keys generated by O(·). The experiment outputs 1 iff:</li>

    </ol>

    <p class="text-gray-300">(1) (stmt, π) ∉ Q; and (2) V(crs, stmt, π) = 1; and (3) pk_s ∉ T; and (4) μ = f_{s_0}(\\mathsf{pk}_s).</p>

    <p class="text-gray-300">Claim 11. If the underlying NIZK is zero-knowledge, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_1] \\leq \\operatorname{Pr}[\\mathsf{Expt}_2] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Proof. By the zero-knowledge property, no polynomial-time algorithm can distinguish an honest setup from an simulation setup. Also note that our experiment runs in polynomial time. This completes the proof.</p>

    <p class="text-gray-300">Expt3 (Separate <span class="math">s_0</span>):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300">(nizk.crs, nizk.τ) ← nizk.K(1^λ, L'); (pk_e, sk_e) ← KeyGenEnc(1^λ); s_0, s_0', r_0 ← {0, 1}^λ; ρ := comm(s_0'; r_0); crs := (nizk.crs, pk_e, ρ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda)</span>; <span class="math">\\mu = f_{s_0}(\\mathsf{pk}_s); z_3, r_1 \\stackrel{\\</span>}{\\leftarrow} \\{0, 1\\}^\\lambda<span class="math">; </span>c = \\mathsf{Enc}(\\mathsf{pk}_e, z_3; r_1)<span class="math">; </span>\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk}.\\widehat{\\mathcal{P}}(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, (\\mathsf{stmt}_x, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho))<span class="math">; </span>\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi))<span class="math">; </span>\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma)$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt}, \\pi) \\gets \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathsf{crs}}, \\mathsf{ek})</span>;</li>

      <li>Parse <span class="math">\\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma)</span>; <span class="math">w \\gets \\mathsf{Dec}(\\mathsf{ek}, c)</span>;</li>

      <li>Let <span class="math">Q</span> be the set of statement-proof pairs and <span class="math">T</span> be the set of verification keys generated by <span class="math">O(\\cdot)</span>. The experiment outputs 1 iff:</li>

    </ol>

    <p class="text-gray-300">(1) <span class="math">(\\mathsf{stmt}, \\pi) \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}}, \\mathsf{stmt}, \\pi) = 1</span>; and (3) <span class="math">\\mathsf{pk}_s \\notin T</span>; and (4) <span class="math">\\mu = f_{s_0}(\\mathsf{pk}_s)</span>.</p>

    <p class="text-gray-300"><strong>Claim 12.</strong> If the underlying commitment scheme is computationally hiding, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_2] \\leq \\operatorname{Pr}[\\mathsf{Expt}_3] + \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By the hiding property, no polynomial algorithm can distinguish the commitment of two elements.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300"><strong>Expt₄ (Replace PRF):</strong></p>

    <p class="text-gray-300">Let <span class="math">F</span> be a true random function.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{nizk}.\\tau) \\gets \\mathsf{nizk}.\\mathcal{K}(1^\\lambda, \\mathcal{L}&#x27;)</span>; <span class="math">(\\mathsf{pk}_e, \\mathsf{sk}_e) \\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^\\lambda); s_0, s_0&#x27;, r_0 \\stackrel{\\</span>}{\\leftarrow} \\{0, 1\\}^\\lambda<span class="math">; </span>\\rho := \\mathsf{comm}(s_0'; r_0)<span class="math">; </span>\\widehat{\\mathsf{crs}} := (\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{pk}_e, \\rho)$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x)</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda)</span>; <span class="math">\\mu = F(\\mathsf{pk}_s); z_3, r_1 \\stackrel{\\</span>}{\\leftarrow} \\{0, 1\\}^\\lambda<span class="math">; </span>c = \\mathsf{Enc}(\\mathsf{pk}_e, z_3; r_1)<span class="math">; </span>\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk}.\\widehat{\\mathcal{P}}(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, (\\mathsf{stmt}_x, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho))<span class="math">; </span>\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi))<span class="math">; </span>\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma)$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{stmt}, \\pi) \\gets \\mathcal{A}^{O(\\cdot)}(\\widehat{\\mathsf{crs}}, \\mathsf{ek})</span>;</li>

      <li>Parse <span class="math">\\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma)</span>; <span class="math">w \\gets \\mathsf{Dec}(\\mathsf{ek}, c)</span>;</li>

      <li>Let <span class="math">Q</span> be the set of statement-proof pairs and <span class="math">T</span> be the set of verification keys generated by <span class="math">O(\\cdot)</span>. The experiment outputs 1 iff:</li>

    </ol>

    <p class="text-gray-300">(1) <span class="math">(\\mathsf{stmt}, \\pi) \\notin Q</span>; and (2) <span class="math">\\mathcal{V}(\\widehat{\\mathsf{crs}}, \\mathsf{stmt}, \\pi) = 1</span>; and (3) <span class="math">\\mathsf{pk}_s \\notin T</span>; and (4) <span class="math">\\mu = F(\\mathsf{pk}_s)</span>.</p>

    <p class="text-gray-300"><strong>Claim 13.</strong> If the underlying PRF is secure, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_3] \\leq \\operatorname{Pr}[\\mathsf{Expt}_4]</span>.</p>

    <p class="text-gray-300">Proof. Since the PRF is secure, no polynomial-time algorithm can distinguish <span class="math">F</span> from <span class="math">f_{s_0}</span>.</p>

    <p class="text-gray-300">We convert <span class="math">\\mathsf{Expt}_4</span> to an adversary for the security game of PRF, similar to the proof of Claim 4. It corresponds to <span class="math">\\mathsf{Expt}_4</span> and <span class="math">\\mathsf{Expt}_3</span> when running with random function and PRF, respectively. This completes the proof.</p>

    <p class="text-gray-300"><strong>Claim 14.</strong> We have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_4] \\leq 2^{-\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Since <span class="math">\\mathsf{pk}_s \\notin T</span>, we know that <span class="math">F(\\mathsf{pk}_s)</span> has not been queried before. Hence we may view <span class="math">F(\\mathsf{pk}_s)</span> as newly generated random bits independent from <span class="math">\\mu</span>. This completes the proof.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> The construction is computationally zero-knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We prove this by showing a series of indistinguishable hybrids, where the first one is the simulation setup and the last one is the honest setup.</p>

    <p class="text-gray-300"><strong>Expt₀ (actual game):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <pre><code class="language-text">nizk.crs ← nizk.K(1λ, L&#x27;);
(pk_e, sk_e) ← KeyGenEnc(1λ); s₀, r₀ ⇔ {0, 1}λ;
ρ := comm(s₀; r₀); crs := (nizk.crs, pk_e, ρ).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <pre><code class="language-text">Abort if $(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}$;
(pk_s, sk_s) ← KeyGenSig(1λ); μ = f_{s₀}(pk_s);
z₃, r₁ ⇔ {0, 1}λ; c = Enc(pk_e, z₃; r₁);
nizk.π ← nizk.P(nizk.crs, (stmt, c, μ, pk_s, pk_e, ρ),
(r₁, r₀, z₃, s₀));
σ ← Sign(sk_s, (stmt, c, μ, nizk.π));
return π := (c, μ, nizk.π, pk_s, σ).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathsf{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Expt₁ (use simulation setup):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <pre><code class="language-text">(nizk.crs, nizk.τ) ← nizk.K(1λ, L&#x27;);
(pk_e, sk_e) ← KeyGenEnc(1λ); s₀, r₀ ⇔ {0, 1}λ;
ρ := comm(s₀; r₀); crs := (nizk.crs, pk_e, ρ).</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <pre><code class="language-text">Abort if $(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}$;
(pk_s, sk_s) ← KeyGenSig(1λ); μ = f_{s₀}(pk_s);
z₃, r₁ ⇔ {0, 1}λ; c = Enc(pk_e, z₃; r₁);</code></pre>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\leftarrow \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathsf{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span> <span class="math">\\mathbf{0}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <p class="text-gray-300">Abort if <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>; <span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda); \\mu = f_{s_0}(\\mathsf{pk}_s);</span> <span class="math">r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda; c = \\mathsf{Enc}(\\mathsf{pk}_e, w; r_1);</span> <span class="math">\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk}.\\widehat{\\mathcal{P}}(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}), \\mathsf{nizk}.\\tau, (\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho));</span> <span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi));</span> <span class="math">\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 17.</strong> If the underlying commitment scheme is computationally hiding, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_3] \\approx \\operatorname{Pr}[\\mathsf{Expt}_2]</span>.</p>

    <p class="text-gray-300"><strong>Expt₄ (Replace PRF):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{nizk}.\\tau) \\gets \\mathsf{nizk}.\\widehat{\\mathcal{K}}(1^\\lambda, \\mathcal{L}&#x27;);</span> <span class="math">(\\mathsf{pk}_e, \\mathsf{sk}_e) \\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^\\lambda); s_0, s_0&#x27;, r_0 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">\\rho := \\mathsf{comm}(s_0&#x27;; r_0); \\widehat{\\mathsf{crs}} := (\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{pk}_e, \\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <p class="text-gray-300">Abort if <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>; <span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda); \\mu \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda; c = \\mathsf{Enc}(\\mathsf{pk}_e, w; r_1);</span> <span class="math">\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk}.\\widehat{\\mathcal{P}}(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{nizk}.\\tau, (\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho));</span> <span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi));</span> <span class="math">\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 18.</strong> If the underlying PRF is secure and that the underlying one-time signature scheme is unforgeable, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_4] \\approx \\operatorname{Pr}[\\mathsf{Expt}_3]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First note that the generated <span class="math">\\mathsf{pk}_s</span>'s are distinct except for negligible probability, as otherwise it would break the one-time signature scheme.</p>

    <p class="text-gray-300">Also, we can replace <span class="math">f_{s_0}</span> in <span class="math">\\mathsf{Expt}_3</span> with a true random function <span class="math">F</span>, which is identical to <span class="math">\\mathsf{Expt}_4</span> when the <span class="math">\\mathsf{pk}_s</span>'s are all distinct.</p>

    <p class="text-gray-300"><strong>Expt₅ (Use nizk. <span class="math">\\widehat{\\mathcal{P}}_1</span>):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{nizk}.\\tau) \\gets \\mathsf{nizk}.\\widehat{\\mathcal{K}}(1^\\lambda, \\mathcal{L}&#x27;);</span> <span class="math">(\\mathsf{pk}_e, \\mathsf{sk}_e) \\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^\\lambda); s_0&#x27;, r_0 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">\\rho := \\mathsf{comm}(s_0&#x27;; r_0); \\widehat{\\mathsf{crs}} := (\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{pk}_e, \\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <p class="text-gray-300">Abort if <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>; <span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda); \\mu \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">z_1, z_2, r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda; c = \\mathsf{Enc}(\\mathsf{pk}_e, w; r_1);</span> <span class="math">\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk}.\\widehat{\\mathcal{P}}_1(\\mathsf{nizk}.\\widehat{\\mathsf{crs}}, \\mathsf{nizk}.\\tau,</span> <span class="math">(\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho), (r_1, z_1, w, z_2));</span> <span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi));</span> <span class="math">\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 19.</strong> We have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_5] = \\operatorname{Pr}[\\mathsf{Expt}_4]</span>.</p>

    <p class="text-gray-300"><strong>Expt₆ (Use <span class="math">\\mathcal{P}</span>):</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{nizk.crs} \\gets \\mathsf{nizk.K}(1^\\lambda, \\mathcal{L}&#x27;)</span>; <span class="math">(\\mathsf{pk}_e, \\mathsf{sk}_e) \\gets \\mathsf{KeyGen}_{\\mathsf{Enc}}(1^\\lambda); s_0&#x27;, r_0 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">\\rho := \\mathsf{comm}(s_0&#x27;; r_0); \\widehat{\\mathsf{crs}} := (\\mathsf{nizk.crs}, \\mathsf{pk}_e, \\rho).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define function <span class="math">O(\\mathsf{stmt}_x, w)</span>:</li>

    </ol>

    <p class="text-gray-300">Abort if <span class="math">(\\mathsf{stmt}_x, w) \\notin \\mathcal{R}_{\\mathcal{L}}</span>; <span class="math">(\\mathsf{pk}_s, \\mathsf{sk}_s) \\gets \\mathsf{KeyGen}_{\\mathrm{Sig}}(1^\\lambda); \\mu \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda;</span> <span class="math">z_1, z_2, r_1 \\stackrel{\\S}{\\leftarrow} \\{0, 1\\}^\\lambda; c = \\mathsf{Enc}(\\mathsf{pk}_e, w; r_1);</span> <span class="math">\\mathsf{nizk}.\\pi \\gets \\mathsf{nizk.P}(\\mathsf{nizk.crs}, (\\mathsf{stmt}, c, \\mu, \\mathsf{pk}_s, \\mathsf{pk}_e, \\rho),</span> <span class="math">(r_1, z_1, w, z_2));</span> <span class="math">\\sigma \\gets \\mathsf{Sign}(\\mathsf{sk}_s, (\\mathsf{stmt}, c, \\mu, \\mathsf{nizk}.\\pi));</span> <span class="math">\\mathsf{return} \\pi := (c, \\mu, \\mathsf{nizk}.\\pi, \\mathsf{pk}_s, \\sigma).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\mathcal{A}^{O(\\cdot, \\cdot)}(\\widehat{\\mathrm{crs}})</span>; Output <span class="math">b</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Claim 20.</strong> If the underlying NIZK is zero-knowledge, then we have <span class="math">\\operatorname{Pr}[\\mathsf{Expt}_6] \\approx \\operatorname{Pr}[\\mathsf{Expt}_5]</span>.</p>

    <p class="text-gray-300">Note that the last experiment is exactly the definition. This completes the proof for the zero-knowledge part.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">The Ajtai hash is a lattice-based collision-resistant hash function that shows great promise for use in SNARK-friendly cryptographic applications (e.g., Merkle trees, just for one example). [14, 47].</p>

    <p class="text-gray-300">Ben-Sasson et al. have suggested a parameterization that they conjecture to be secure based on heuristic extrapolation of earlier estimates [14]. However, this extrapolation is delicate, and a lack of confidence in this heuristic has apparently stalled its use (e.g., it was not used in Zerocash [11], a</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">practical real-world application for which this construction would provide a significant performance enhancement).</p>

    <p class="text-gray-300">The collision-resistance of the Ajtai hash relies on the hardness of the SIS problem. Hence, it is natural to estimate the hardness of Ajtai hash by evaluating its corresponding SIS problem. So far, the best concrete security analysis of SIS is based on empirical observation of the running time of the best known attack algorithms (LLL,BKZ,BKZ2.0) over a range of parameterizations <em>[5, 30, 51]</em>. However, to reap the performance benefits of using this within a SNARK, we must choose a parameterization that lies outside the range covered in this experiment (i.e., the arity of the lattice must be a large prime <span class="math">q\\sim 2^{254}</span>, the native field of the SNARK, whereas prior experiments cover only small prime <span class="math">n^{2}\\leq p\\leq n^{8}</span>). Therefore it is not apparent a priori if the concrete security estimates can safely be extrapolated here.</p>

    <p class="text-gray-300">In this note, we review the concrete security analysis for SIS, and reproduce (in part) the empirical experiments from <em>[58]</em>, extended to the parameter ranges appropriate for SNARK-friendly crypto. We provide a step-by-step algorithm for concrete security analysis of arbitrary SIS instance, and use the algorithm to estimate the security of Ajtai hash functions.</p>

    <p class="text-gray-300">Based on our experiments and calculations, we conclude that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is indeed reasonable to extrapolate from prior concrete hardness estimates of SIS based primitives, such as Ajtai hash, even in the SNARK-friendly parameter ranges.</li>

      <li>To achieve 80 bits of security based on reduction to SIS (against the best-known attacks today), we should increase the dimension of the Ajtai hash to <span class="math">n=3</span> (rather than <span class="math">n=1</span> as suggested in <em>[14]</em>).</li>

    </ol>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">F.1 Preliminaries</h3>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Notations.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote with log the logarithm to base 2. Vectors and matrices are written in boldface, e.g., <span class="math">\\mathbf{v}</span> and <span class="math">\\mathbf{M}</span>. We use $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{p}<span class="math"> to denote the </span>l_{p}<span class="math"> norm of vector </span>\\mathbf{v}<span class="math">. In particular, we denote with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the </span>l_{2}<span class="math"> norm of vector </span>\\mathbf{v}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 1 (Lattice).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A (full-dimensional) lattice in <span class="math">\\mathbb{R}^{m}</span> is a discrete subgroup $L=\\{\\mathbf{B}\\mathbf{x}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathbf{x}\\in\\mathbb{Z}^{m}\\}<span class="math">, where typically </span>\\mathbf{B}=[\\mathbf{b_{1}},\\ldots,\\mathbf{b_{m}}]\\in\\mathbb{Z}^{m\\times m}<span class="math"> is a matrix of linearly independent vectors. The matrix </span>\\mathbf{B}<span class="math"> is a basis of the lattice </span>L<span class="math"> and we write </span>L=L(\\mathbf{B})<span class="math">. The rank of a lattice </span>L<span class="math"> is the rank of the basis matrix </span>\\mathbf{B}<span class="math">. If the rank equals </span>m<span class="math">, we say that </span>L$ is full-rank..</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The Shortest Vector Problem (SVP) is probably the most fundamental hard problem in lattice literature <em>[52]</em>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 2 (Shortest Vector Problem (SVP)).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a basis <span class="math">\\mathbf{B}</span> of <span class="math">L</span> and an approximation factor <span class="math">\\gamma\\geq 1</span>, the task of SVP is to find a set <span class="math">\\mathbf{v}\\in L</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma L_{0}<span class="math">, where </span>L_{0}<span class="math"> denotes the shortest vector in lattice </span>L$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are only concerned with a type of lattices called “q-array” lattice. Note that every q-ary lattice is full-rank.s</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 3 (q-ary).</h6>

    <p class="text-gray-300">A lattice <span class="math">L</span> is called a q-ary if <span class="math">q\\mathbb{Z}\\subseteq L</span>.</p>

    <p class="text-gray-300">For <span class="math">q\\in\\mathbb{N}</span> and <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span>, we define two most important q-arys.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Lambda_{q}(\\mathbf{A})=\\{\\mathbf{w}\\in\\mathbb{Z}^{n}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\exists\\mathbf{e}\\in\\mathbb{Z}^{m}\\mathbf{A}^{\\top}\\mathbf{e}=\\mathbf{w}\\,(mod\\ q)\\}$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Lambda_{q}^{\\perp}(\\mathbf{A})=\\{\\mathbf{v}\\in\\mathbb{Z}^{m}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathbf{A}\\mathbf{v}=\\mathbf{0}\\,(mod\\ q)\\}$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be a prime and <span class="math">m=O(n\\log(n))</span>. With high probability, the rows of <span class="math">\\mathbf{A}</span> are linearly independent over <span class="math">\\mathbb{Z}_{q}</span> and <span class="math">det(\\Lambda_{q}^{\\perp}(\\mathbf{A}))=q^{n}</span>.</p>

    <p class="text-gray-300">The Short Integer Solution (SIS) problem is defined over the q-arry <span class="math">\\Lambda_{q}^{\\perp}(\\mathbf{A})</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 4 (Short Integer Solution (SIS)).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given <span class="math">n,m,q\\in\\mathbb{N}</span>, a randomly picked <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span>, and a norm bound <span class="math">1\\leq\\beta&lt;q</span>, the SIS problem, denoted as <span class="math">SIS(n,m,q,\\beta)</span>, is to find <span class="math">\\mathbf{v}\\in\\Lambda_{q}^{\\perp}(\\mathbf{A})</span> with $0<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 5 (Ajtai Hash).</h6>

    <p class="text-gray-300">Given <span class="math">n,m,q\\in\\mathbb{N}</span>, a randomly picked <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times m}</span>, the Ajtai Hash <span class="math">h_{Ajtai(n,m,q)}:\\{0,1\\}^{m}\\to\\mathbb{Z}_{q}^{n}</span> is defined as</p>

    <p class="text-gray-300"><span class="math">h(\\mathbf{x})=\\mathbf{A}\\mathbf{x}\\ (mod\\ q)</span> (3)</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">F.2 High Level Idea</h3>

    <p class="text-gray-300">Our goal is to study the concrete hardness of the Ajtai hash function. Specifically, given an instance <span class="math">h_{Ajtai(n,m,q)}</span>, what level of bit-security does it satisfy?</p>

    <p class="text-gray-300">The collision-resistance of the Ajtai hash reduces to SIS: In particular, if the adversary can find a collision for <span class="math">h_{Ajtai(n,m,q)}</span>, then it would also break <span class="math">SIS(n,m,q,\\sqrt{m})</span>. Hence, it is natural to estimate the hardness of the Ajtai hash by evaluating its corresponding SIS problem. We focus on the security analysis of the SIS problem next.</p>

    <p class="text-gray-300">The best known algorithm for solving SIS relies on Lattice Reduction Algorithms such as LLL and BKZ. Given the original input lattice basis <span class="math">\\mathbf{B}</span>, the goal of lattice basis reduction is to find a basis <span class="math">\\mathbf{\\bar{B}}</span> with short, nearly orthogonal vectors. If the basis after reduction <span class="math">\\mathbf{\\bar{B}}</span> is of “good quality”, the shortest row vector in the reduced basis can be a relatively good estimation of the shortest vector in the lattice. We adopt the convention that the first non-zero vector, denoted as <span class="math">\\mathbf{\\bar{b_{0}}}</span>, is the shortest vector in the reduced basis <span class="math">\\mathbf{\\bar{B}}</span>. Intuitively, given <span class="math">SIS(n,m,q,\\beta)</span>, the lattice reduction based attack keeps reducing the basis of the q-array <span class="math">\\Lambda_{q}^{\\perp}(\\mathbf{A})</span> until its <span class="math">\\mathbf{\\bar{b_{0}}}</span> is <span class="math">\\leq\\beta</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In practice, finding the shortest vector for hard lattice instances requires at least exponential running time. The hardness of SIS is estimated by the time cost for the lattice reduction algorithm to find a basis with a certain level of “quality”. The quality of a basis <span class="math">B</span> of <span class="math">m</span>-dimensional lattice <span class="math">L</span> is characterized by the root Hermite factor <span class="math">\\delta_{0}</span>, which is defined such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b_{0}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\delta_{0}^{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">det(L)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{1/m}<span class="math">. Notice that the q-array </span>\\Lambda_{q}^{\\perp}(\\mathbf{A})<span class="math"> of </span>SIS(n,m,q,\\beta)<span class="math"> has determinant </span>det(\\Lambda_{q}^{\\perp}(\\mathbf{A}))=q^{n}<span class="math">. The concrete hardness of </span>SIS(n,m,q,\\beta)<span class="math"> is estimated by the time cost the for lattice reduction algorithm to find a basis with </span>\\delta_{0}=(\\beta/q^{n/m})^{1/m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">F.3 Lattice Reduction Algorithm: BKZ, BKZ2.0</h3>

    <p class="text-gray-300">Several works in literature have studied the running time of BKZ <em>[5, 30, 58, 50]</em>. Specifically, they provide estimated running time for BKZ/BKZ2.0 to find a basis with certain <span class="math">\\delta_{0}</span> root Hermite factor. The running time below is measured by clock cycles.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ruckert and Schneider <em>[58]</em> provides a table of <span class="math">\\delta_{0}</span> and BKZ running time based the estimation by extrapolation on “dollar-days” cost.</li>

      <li>Lindner and Peikert <em>[50]</em> gives the estimate on BKZ as: <span class="math">T_{LP11}=2^{1.8/\\log\\delta_{0}-78.9}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">δ0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m=2n log q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ=log TACF15</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">λ=log TCN12</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0139</td>

            <td class="px-3 py-2 border-b border-gray-700">508</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">26.8</td>

            <td class="px-3 py-2 border-b border-gray-700">27.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0085</td>

            <td class="px-3 py-2 border-b border-gray-700">1016</td>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

            <td class="px-3 py-2 border-b border-gray-700">63.8</td>

            <td class="px-3 py-2 border-b border-gray-700">60.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0064</td>

            <td class="px-3 py-2 border-b border-gray-700">1524</td>

            <td class="px-3 py-2 border-b border-gray-700">289</td>

            <td class="px-3 py-2 border-b border-gray-700">111.1</td>

            <td class="px-3 py-2 border-b border-gray-700">107.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0052</td>

            <td class="px-3 py-2 border-b border-gray-700">2032</td>

            <td class="px-3 py-2 border-b border-gray-700">379</td>

            <td class="px-3 py-2 border-b border-gray-700">167.2</td>

            <td class="px-3 py-2 border-b border-gray-700">162.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7: Security level of the Ajtai Hash for  <span class="math">n = 2,3,4</span> . Prime modulo is set to  <span class="math">q = 2^{254}</span> . We set  <span class="math">m</span>  equal to  <span class="math">2n\\log q</span>  (i.e., as appropriate for a Merkle tree application).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Albrecht et al. [51] extrapolate a model similar to [50] on BKZ2.0 as:  <span class="math">T_{ACF15} = 2^{0.009 / \\log^2\\delta_0 + 4.1}</span></li>

      <li>Chen and Nguyen [30] provide a simulation-based estimate for BKZ2.0. We denote the estimated running time as  <span class="math">T_{CN12}(m^{<em>},\\delta_{0})</span>  (The simulation also takes the lattice dimension  <span class="math">m^{</em>}</span>  as input).</li>

    </ol>

    <p class="text-gray-300">Notice that the experiments in the above works are run with relatively small prime modulo  <span class="math">p</span> . In order to show that the empirical results also apply under the setting where the prime modulo is very large  <span class="math">q &amp;gt;&amp;gt; p</span> . We repeat the experiments in [58] on BKZ with  <span class="math">q = 2^{254}</span> . Specifically, we run the BKZ reduction algorithm on q-array of randomly generated SIS instance with various  <span class="math">(n, m, \\beta)</span>  settings. Our running time matches theirs except for a constant speed up (due to a faster CPU) whenever the root Hermite factors under the two settings are equivalent.</p>

    <p class="text-gray-300">BKZ2.0 [29] is an upgraded version of BKZ. These improvements include early termination, extreme pruning, limiting the enumeration radius to the Gaussian Heuristic, and local block preprocessing [29]. We assume with confidence that the empirical results for BKZ2.0 apply in the setting with large prime  <span class="math">q</span> . We use the BKZ2.0 estimations  <span class="math">T_{ACF15}</span>  and  <span class="math">T_{CN12}</span>  in the security analysis next.</p>

    <p class="text-gray-300">Set  <span class="math">q = 2^{254}</span> . We evaluate the concrete security level of the Ajtai hash  <span class="math">h_{Ajtai(n,m,q)}</span>  for  <span class="math">n = 1,2,3,4</span>  by calling Security-SIS on input  <span class="math">n,q,\\sqrt{m}</span> . Note that we require input length  <span class="math">m &amp;gt; n\\log q</span>  in order to obtain a hash function that compresses its input. Also,  <span class="math">m \\geq 2n\\log q</span>  is required for Merkle Tree applications. See Table 7.</p>

    <p class="text-gray-300">The root Hermite factor  <span class="math">\\delta_0</span>  measures the quality of a lattice basis. Specifically, assume q-array lattice  <span class="math">\\Lambda_q^\\perp (\\mathbf{A})</span>  of  <span class="math">SIS(n,m,q,\\beta)</span>  has root Hermite factor  <span class="math">\\delta_0</span> , its shortest basis vector  <span class="math">\\mathbf{b_0}</span>  satisfies</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {b} _ {\\mathbf {0}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\delta_ {0} ^ {m} q ^ {n / m}. \\tag {4}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The goal of the lattice reduction algorithm is to find the shortest possible  <span class="math">\\mathbf{b_0}</span> . The right hand side is minimized when</p>

    <div class="my-4 text-center"><span class="math-block">m = m ^ {*} = \\sqrt {\\frac {n \\log q}{\\log \\delta_ {0}}}. \\tag {5}</span></div>

    <p class="text-gray-300">This optimal value  <span class="math">m^<em></span>  is the optimal sample size for lattice reduction algorithm, and is sometimes called the "optimal sub-dimension" [52]. Following many other works [5, 30, 50, 51, 58], we assume  <span class="math">m^</em></span>  is always chosen for BKZ/BKZ2.0.</p>

    <p class="text-gray-300">F.4.2 Calculate the bit-security of SIS</p>

    <p class="text-gray-300">Recall that the security level of <span class="math">SIS(n,m,q,\\beta)</span> can be estimated by the time cost for lattice reduction algorithm to find a basis with <span class="math">\\delta_{0}=(\\beta/q^{n/m})^{1/m}</span>. The problem here is that <span class="math">m</span> is chosen as the optimal value <span class="math">m^{<em>}=\\sqrt{\\frac{n\\log q}{\\log\\delta_{0}}}</span>, which is an expression of <span class="math">\\delta_{0}</span>. Following the arguments in </em>[58]<em>, we give a simple expression of the optimal <span class="math">m^{</em>}</span> that is only dependent on <span class="math">(n,q,\\beta)</span> for SIS problem.</p>

    <p class="text-gray-300"><span class="math">m^{*}=\\lceil\\frac{2n\\log q}{\\log\\beta}\\rceil.</span> (6)</p>

    <p class="text-gray-300">Fixing <span class="math">\\delta_{0}</span> value, the minimum of <span class="math">\\delta_{0}^{m}q^{n/m}</span> achieves when <span class="math">m=m^{<em>}=\\sqrt{\\frac{n\\log q}{\\log\\delta_{0}}}</span>. Equivalently, fixing <span class="math">m=m^{</em>}</span>, some lattice reduction algorithm can find a basis with <span class="math">\\delta_{0}=2^{n\\log q/m^{<em>2}}</span>. Therefore, there is some lattice reduction algorithm can find vector of length <span class="math">\\delta_{0}^{m^{</em>}}q^{n/m^{<em>}}=2^{n\\log q/m^{</em>}}q^{n/m^{<em>}}=q^{2n/m^{</em>}}</span> in <span class="math">m^{<em>}</span>-dimensional lattice. It requires <span class="math">q^{2n/m^{</em>}}\\leq\\beta</span> to break <span class="math">SIS(n,m,q,\\beta)</span>, which gives <span class="math">m^{*}=\\lceil\\frac{2n\\log q}{\\log\\beta}\\rceil</span>.</p>

    <p class="text-gray-300">Combining the above arguments gives us the following algorithm for calculating the bit-security of the SIS problem.</p>

    <p class="text-gray-300">Input : <span class="math">(n,q,\\beta)</span> Output: <span class="math">\\lambda</span> begin Compute <span class="math">m^{<em>}=\\lceil\\frac{2n\\log q}{\\log\\beta}\\rceil</span>; Compute <span class="math">\\delta_{0}=(\\beta/q^{n/m^{</em>}})^{1/m^{<em>}}</span>; Compute <span class="math">T_{BKZ}</span> using the BKZ2.0 estimation either by <span class="math">T_{ACF15}(\\delta_{0})</span> or <span class="math">T_{CN12}(m^{</em>},\\delta_{0})</span>; Return <span class="math">\\lambda=\\log T_{BKZ}</span>. end Algorithm 1 Calculate the bit-security of <span class="math">SIS(n,m,q,\\beta)</span></p>

    <p class="text-gray-300">Algorithm 1</p>

    <p class="text-gray-300">G Additional Results</p>

    <p class="text-gray-300">In this section, additional results showing the micro-benchmarks and application results using RSA-OAEP with 1024-bit key, and field extension with <span class="math">\\mu=4</span>. Table 8 provides the number of gates needed to encrypt 200 bytes, while Tables 9 , 10 and 11 provide the results of applying these primitives in the three applications considered in the paper.</p>

    <p class="text-gray-300">Table 8: # gates for encrypting 200 bytes at 80-bits of security. RSA uses 1024-bit key, and Field extension assume  <span class="math">\\mu = 4</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Total Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cost Per Bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ratio</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP only</td>

            <td class="px-3 py-2 border-b border-gray-700">820k</td>

            <td class="px-3 py-2 border-b border-gray-700">512.5</td>

            <td class="px-3 py-2 border-b border-gray-700">6.77</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + AES</td>

            <td class="px-3 py-2 border-b border-gray-700">500k</td>

            <td class="px-3 py-2 border-b border-gray-700">312.5</td>

            <td class="px-3 py-2 border-b border-gray-700">4.13</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">294k</td>

            <td class="px-3 py-2 border-b border-gray-700">183.75</td>

            <td class="px-3 py-2 border-b border-gray-700">2.43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSA-OAEP + Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">268k</td>

            <td class="px-3 py-2 border-b border-gray-700">167.5</td>

            <td class="px-3 py-2 border-b border-gray-700">2.21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Field Extension + AES</td>

            <td class="px-3 py-2 border-b border-gray-700">353k</td>

            <td class="px-3 py-2 border-b border-gray-700">220.62</td>

            <td class="px-3 py-2 border-b border-gray-700">2.92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Field Extension + Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">147k</td>

            <td class="px-3 py-2 border-b border-gray-700">91.88</td>

            <td class="px-3 py-2 border-b border-gray-700">1.21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Field Extension + Chaskey LTS [Baseline]</td>

            <td class="px-3 py-2 border-b border-gray-700">121k</td>

            <td class="px-3 py-2 border-b border-gray-700">75.62</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 9: Application - Privacy-preserving smart contracts: Benchmarks for pour and freeze circuits in Hawk [47].</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">166.29</td>

            <td class="px-3 py-2 border-b border-gray-700">170.5</td>

            <td class="px-3 py-2 border-b border-gray-700">203.27</td>

            <td class="px-3 py-2 border-b border-gray-700">178.74</td>

            <td class="px-3 py-2 border-b border-gray-700">186.76</td>

            <td class="px-3 py-2 border-b border-gray-700">199.7</td>

            <td class="px-3 py-2 border-b border-gray-700">288.02</td>

            <td class="px-3 py-2 border-b border-gray-700">396.68</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">54.88</td>

            <td class="px-3 py-2 border-b border-gray-700">55.04</td>

            <td class="px-3 py-2 border-b border-gray-700">69.07</td>

            <td class="px-3 py-2 border-b border-gray-700">55.15</td>

            <td class="px-3 py-2 border-b border-gray-700">64.4</td>

            <td class="px-3 py-2 border-b border-gray-700">67.61</td>

            <td class="px-3 py-2 border-b border-gray-700">99.3</td>

            <td class="px-3 py-2 border-b border-gray-700">132.14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">284.41</td>

            <td class="px-3 py-2 border-b border-gray-700">292.38</td>

            <td class="px-3 py-2 border-b border-gray-700">365.51</td>

            <td class="px-3 py-2 border-b border-gray-700">307.76</td>

            <td class="px-3 py-2 border-b border-gray-700">320.94</td>

            <td class="px-3 py-2 border-b border-gray-700">360.02</td>

            <td class="px-3 py-2 border-b border-gray-700">531.81</td>

            <td class="px-3 py-2 border-b border-gray-700">727.87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">8.46</td>

            <td class="px-3 py-2 border-b border-gray-700">12.39</td>

            <td class="px-3 py-2 border-b border-gray-700">12.39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">126.99</td>

            <td class="px-3 py-2 border-b border-gray-700">123.38</td>

            <td class="px-3 py-2 border-b border-gray-700">162.56</td>

            <td class="px-3 py-2 border-b border-gray-700">131.16</td>

            <td class="px-3 py-2 border-b border-gray-700">134.39</td>

            <td class="px-3 py-2 border-b border-gray-700">159.72</td>

            <td class="px-3 py-2 border-b border-gray-700">340.92</td>

            <td class="px-3 py-2 border-b border-gray-700">340.92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">43.12</td>

            <td class="px-3 py-2 border-b border-gray-700">41.5</td>

            <td class="px-3 py-2 border-b border-gray-700">52.94</td>

            <td class="px-3 py-2 border-b border-gray-700">41.06</td>

            <td class="px-3 py-2 border-b border-gray-700">41.37</td>

            <td class="px-3 py-2 border-b border-gray-700">51.77</td>

            <td class="px-3 py-2 border-b border-gray-700">110.41</td>

            <td class="px-3 py-2 border-b border-gray-700">110.41</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">202.22</td>

            <td class="px-3 py-2 border-b border-gray-700">210.19</td>

            <td class="px-3 py-2 border-b border-gray-700">279.34</td>

            <td class="px-3 py-2 border-b border-gray-700">225.57</td>

            <td class="px-3 py-2 border-b border-gray-700">230.78</td>

            <td class="px-3 py-2 border-b border-gray-700">273.84</td>

            <td class="px-3 py-2 border-b border-gray-700">637.71</td>

            <td class="px-3 py-2 border-b border-gray-700">637.71</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">5.03</td>

            <td class="px-3 py-2 border-b border-gray-700">8.95</td>

            <td class="px-3 py-2 border-b border-gray-700">8.95</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">106.89</td>

            <td class="px-3 py-2 border-b border-gray-700">138.63</td>

            <td class="px-3 py-2 border-b border-gray-700">123.66</td>

            <td class="px-3 py-2 border-b border-gray-700">126.52</td>

            <td class="px-3 py-2 border-b border-gray-700">151.09</td>

            <td class="px-3 py-2 border-b border-gray-700">188.49</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">32.92</td>

            <td class="px-3 py-2 border-b border-gray-700">35.59</td>

            <td class="px-3 py-2 border-b border-gray-700">46.95</td>

            <td class="px-3 py-2 border-b border-gray-700">41.32</td>

            <td class="px-3 py-2 border-b border-gray-700">41.43</td>

            <td class="px-3 py-2 border-b border-gray-700">49.88</td>

            <td class="px-3 py-2 border-b border-gray-700">64.83</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">173.83</td>

            <td class="px-3 py-2 border-b border-gray-700">179.73</td>

            <td class="px-3 py-2 border-b border-gray-700">233.3</td>

            <td class="px-3 py-2 border-b border-gray-700">211.24</td>

            <td class="px-3 py-2 border-b border-gray-700">216.46</td>

            <td class="px-3 py-2 border-b border-gray-700">257.52</td>

            <td class="px-3 py-2 border-b border-gray-700">337.66</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">7.9</td>

            <td class="px-3 py-2 border-b border-gray-700">7.9</td>

            <td class="px-3 py-2 border-b border-gray-700">7.9</td>

            <td class="px-3 py-2 border-b border-gray-700">8.74</td>

            <td class="px-3 py-2 border-b border-gray-700">8.74</td>

            <td class="px-3 py-2 border-b border-gray-700">8.74</td>

            <td class="px-3 py-2 border-b border-gray-700">10.42</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">76.87</td>

            <td class="px-3 py-2 border-b border-gray-700">77.05</td>

            <td class="px-3 py-2 border-b border-gray-700">110.62</td>

            <td class="px-3 py-2 border-b border-gray-700">97.12</td>

            <td class="px-3 py-2 border-b border-gray-700">96.59</td>

            <td class="px-3 py-2 border-b border-gray-700">122.39</td>

            <td class="px-3 py-2 border-b border-gray-700">165.62</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">24.28</td>

            <td class="px-3 py-2 border-b border-gray-700">24.84</td>

            <td class="px-3 py-2 border-b border-gray-700">43.39</td>

            <td class="px-3 py-2 border-b border-gray-700">31.99</td>

            <td class="px-3 py-2 border-b border-gray-700">32.06</td>

            <td class="px-3 py-2 border-b border-gray-700">42.96</td>

            <td class="px-3 py-2 border-b border-gray-700">55.14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">120.66</td>

            <td class="px-3 py-2 border-b border-gray-700">128.06</td>

            <td class="px-3 py-2 border-b border-gray-700">187.6</td>

            <td class="px-3 py-2 border-b border-gray-700">157.57</td>

            <td class="px-3 py-2 border-b border-gray-700">162.79</td>

            <td class="px-3 py-2 border-b border-gray-700">209.83</td>

            <td class="px-3 py-2 border-b border-gray-700">283.99</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.47</td>

            <td class="px-3 py-2 border-b border-gray-700">4.47</td>

            <td class="px-3 py-2 border-b border-gray-700">4.47</td>

            <td class="px-3 py-2 border-b border-gray-700">5.31</td>

            <td class="px-3 py-2 border-b border-gray-700">5.31</td>

            <td class="px-3 py-2 border-b border-gray-700">5.31</td>

            <td class="px-3 py-2 border-b border-gray-700">6.99</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">97.52</td>

            <td class="px-3 py-2 border-b border-gray-700">100.52</td>

            <td class="px-3 py-2 border-b border-gray-700">126.24</td>

            <td class="px-3 py-2 border-b border-gray-700">122.7</td>

            <td class="px-3 py-2 border-b border-gray-700">122.24</td>

            <td class="px-3 py-2 border-b border-gray-700">143.09</td>

            <td class="px-3 py-2 border-b border-gray-700">161.56</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">32.6</td>

            <td class="px-3 py-2 border-b border-gray-700">32.77</td>

            <td class="px-3 py-2 border-b border-gray-700">44.06</td>

            <td class="px-3 py-2 border-b border-gray-700">41.71</td>

            <td class="px-3 py-2 border-b border-gray-700">41.6</td>

            <td class="px-3 py-2 border-b border-gray-700">44.47</td>

            <td class="px-3 py-2 border-b border-gray-700">49.91</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">163.7</td>

            <td class="px-3 py-2 border-b border-gray-700">168.92</td>

            <td class="px-3 py-2 border-b border-gray-700">215.96</td>

            <td class="px-3 py-2 border-b border-gray-700">203.15</td>

            <td class="px-3 py-2 border-b border-gray-700">208.36</td>

            <td class="px-3 py-2 border-b border-gray-700">247.44</td>

            <td class="px-3 py-2 border-b border-gray-700">276.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Pour]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">8.11</td>

            <td class="px-3 py-2 border-b border-gray-700">8.11</td>

            <td class="px-3 py-2 border-b border-gray-700">8.11</td>

            <td class="px-3 py-2 border-b border-gray-700">9.23</td>

            <td class="px-3 py-2 border-b border-gray-700">9.23</td>

            <td class="px-3 py-2 border-b border-gray-700">9.23</td>

            <td class="px-3 py-2 border-b border-gray-700">9.79</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">65.03</td>

            <td class="px-3 py-2 border-b border-gray-700">68.56</td>

            <td class="px-3 py-2 border-b border-gray-700">95.66</td>

            <td class="px-3 py-2 border-b border-gray-700">85.74</td>

            <td class="px-3 py-2 border-b border-gray-700">89.63</td>

            <td class="px-3 py-2 border-b border-gray-700">118.97</td>

            <td class="px-3 py-2 border-b border-gray-700">131.17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">20.87</td>

            <td class="px-3 py-2 border-b border-gray-700">21.36</td>

            <td class="px-3 py-2 border-b border-gray-700">35.08</td>

            <td class="px-3 py-2 border-b border-gray-700">27.01</td>

            <td class="px-3 py-2 border-b border-gray-700">27.03</td>

            <td class="px-3 py-2 border-b border-gray-700">42.96</td>

            <td class="px-3 py-2 border-b border-gray-700">41.81</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">108.34</td>

            <td class="px-3 py-2 border-b border-gray-700">113.56</td>

            <td class="px-3 py-2 border-b border-gray-700">160.6</td>

            <td class="px-3 py-2 border-b border-gray-700">143.8</td>

            <td class="px-3 py-2 border-b border-gray-700">149.01</td>

            <td class="px-3 py-2 border-b border-gray-700">200.04</td>

            <td class="px-3 py-2 border-b border-gray-700">225.52</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Freeze]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">5.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5.8</td>

            <td class="px-3 py-2 border-b border-gray-700">5.8</td>

            <td class="px-3 py-2 border-b border-gray-700">6.36</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 10: Application - anonymous credential</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">214.65</td>

            <td class="px-3 py-2 border-b border-gray-700">235.25</td>

            <td class="px-3 py-2 border-b border-gray-700">364.38</td>

            <td class="px-3 py-2 border-b border-gray-700">226.33</td>

            <td class="px-3 py-2 border-b border-gray-700">238.73</td>

            <td class="px-3 py-2 border-b border-gray-700">364.73</td>

            <td class="px-3 py-2 border-b border-gray-700">922.65</td>

            <td class="px-3 py-2 border-b border-gray-700">922.65</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">81.73</td>

            <td class="px-3 py-2 border-b border-gray-700">83.67</td>

            <td class="px-3 py-2 border-b border-gray-700">138.8</td>

            <td class="px-3 py-2 border-b border-gray-700">82.11</td>

            <td class="px-3 py-2 border-b border-gray-700">82.46</td>

            <td class="px-3 py-2 border-b border-gray-700">140.76</td>

            <td class="px-3 py-2 border-b border-gray-700">339.17</td>

            <td class="px-3 py-2 border-b border-gray-700">339.17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">392.68</td>

            <td class="px-3 py-2 border-b border-gray-700">418.57</td>

            <td class="px-3 py-2 border-b border-gray-700">685.2</td>

            <td class="px-3 py-2 border-b border-gray-700">416.03</td>

            <td class="px-3 py-2 border-b border-gray-700">439.16</td>

            <td class="px-3 py-2 border-b border-gray-700">679.71</td>

            <td class="px-3 py-2 border-b border-gray-700">1823.48</td>

            <td class="px-3 py-2 border-b border-gray-700">1823.48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">15.26</td>

            <td class="px-3 py-2 border-b border-gray-700">26.47</td>

            <td class="px-3 py-2 border-b border-gray-700">26.47</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">161.23</td>

            <td class="px-3 py-2 border-b border-gray-700">180.87</td>

            <td class="px-3 py-2 border-b border-gray-700">300.89</td>

            <td class="px-3 py-2 border-b border-gray-700">182.26</td>

            <td class="px-3 py-2 border-b border-gray-700">194.71</td>

            <td class="px-3 py-2 border-b border-gray-700">311.3</td>

            <td class="px-3 py-2 border-b border-gray-700">551.61</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">54.63</td>

            <td class="px-3 py-2 border-b border-gray-700">64.21</td>

            <td class="px-3 py-2 border-b border-gray-700">117.91</td>

            <td class="px-3 py-2 border-b border-gray-700">63.68</td>

            <td class="px-3 py-2 border-b border-gray-700">65.16</td>

            <td class="px-3 py-2 border-b border-gray-700">117.6</td>

            <td class="px-3 py-2 border-b border-gray-700">202.12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">276.79</td>

            <td class="px-3 py-2 border-b border-gray-700">308.57</td>

            <td class="px-3 py-2 border-b border-gray-700">555.64</td>

            <td class="px-3 py-2 border-b border-gray-700">314.2</td>

            <td class="px-3 py-2 border-b border-gray-700">337.33</td>

            <td class="px-3 py-2 border-b border-gray-700">577.87</td>

            <td class="px-3 py-2 border-b border-gray-700">1040.03</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">15.54</td>

            <td class="px-3 py-2 border-b border-gray-700">15.54</td>

            <td class="px-3 py-2 border-b border-gray-700">15.54</td>

            <td class="px-3 py-2 border-b border-gray-700">25.63</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">156.38</td>

            <td class="px-3 py-2 border-b border-gray-700">176.36</td>

            <td class="px-3 py-2 border-b border-gray-700">288.67</td>

            <td class="px-3 py-2 border-b border-gray-700">179.01</td>

            <td class="px-3 py-2 border-b border-gray-700">187.79</td>

            <td class="px-3 py-2 border-b border-gray-700">307.69</td>

            <td class="px-3 py-2 border-b border-gray-700">524.38</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">53.88</td>

            <td class="px-3 py-2 border-b border-gray-700">64.2</td>

            <td class="px-3 py-2 border-b border-gray-700">107.12</td>

            <td class="px-3 py-2 border-b border-gray-700">63.76</td>

            <td class="px-3 py-2 border-b border-gray-700">64.65</td>

            <td class="px-3 py-2 border-b border-gray-700">121.06</td>

            <td class="px-3 py-2 border-b border-gray-700">191.97</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">268.82</td>

            <td class="px-3 py-2 border-b border-gray-700">299.91</td>

            <td class="px-3 py-2 border-b border-gray-700">532.49</td>

            <td class="px-3 py-2 border-b border-gray-700">308.26</td>

            <td class="px-3 py-2 border-b border-gray-700">331.39</td>

            <td class="px-3 py-2 border-b border-gray-700">571.93</td>

            <td class="px-3 py-2 border-b border-gray-700">985.36</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">14.91</td>

            <td class="px-3 py-2 border-b border-gray-700">14.91</td>

            <td class="px-3 py-2 border-b border-gray-700">14.91</td>

            <td class="px-3 py-2 border-b border-gray-700">16.03</td>

            <td class="px-3 py-2 border-b border-gray-700">16.03</td>

            <td class="px-3 py-2 border-b border-gray-700">16.03</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 11: Application - nonoutsourceable puzzles for thwarting mining pools (Type II) [53].</p>

    <p class="text-gray-300">|   | Transformation in Section 3  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700">Chaskey LTS</td>

            <td class="px-3 py-2 border-b border-gray-700">Speck</td>

            <td class="px-3 py-2 border-b border-gray-700">AES</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">106.92</td>

            <td class="px-3 py-2 border-b border-gray-700">108.4</td>

            <td class="px-3 py-2 border-b border-gray-700">150.16</td>

            <td class="px-3 py-2 border-b border-gray-700">120.53</td>

            <td class="px-3 py-2 border-b border-gray-700">123.27</td>

            <td class="px-3 py-2 border-b border-gray-700">142.72</td>

            <td class="px-3 py-2 border-b border-gray-700">215.37</td>

            <td class="px-3 py-2 border-b border-gray-700">292.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">35.92</td>

            <td class="px-3 py-2 border-b border-gray-700">35.12</td>

            <td class="px-3 py-2 border-b border-gray-700">48.91</td>

            <td class="px-3 py-2 border-b border-gray-700">43.24</td>

            <td class="px-3 py-2 border-b border-gray-700">43.6</td>

            <td class="px-3 py-2 border-b border-gray-700">49.81</td>

            <td class="px-3 py-2 border-b border-gray-700">84.37</td>

            <td class="px-3 py-2 border-b border-gray-700">96.98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">171.13</td>

            <td class="px-3 py-2 border-b border-gray-700">178.75</td>

            <td class="px-3 py-2 border-b border-gray-700">248.63</td>

            <td class="px-3 py-2 border-b border-gray-700">202.45</td>

            <td class="px-3 py-2 border-b border-gray-700">207.32</td>

            <td class="px-3 py-2 border-b border-gray-700">243.13</td>

            <td class="px-3 py-2 border-b border-gray-700">386.84</td>

            <td class="px-3 py-2 border-b border-gray-700">531.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">5.24</td>

            <td class="px-3 py-2 border-b border-gray-700">8.18</td>

            <td class="px-3 py-2 border-b border-gray-700">8.18</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 4  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">62.04</td>

            <td class="px-3 py-2 border-b border-gray-700">65.39</td>

            <td class="px-3 py-2 border-b border-gray-700">94.8</td>

            <td class="px-3 py-2 border-b border-gray-700">80.42</td>

            <td class="px-3 py-2 border-b border-gray-700">84.4</td>

            <td class="px-3 py-2 border-b border-gray-700">106.82</td>

            <td class="px-3 py-2 border-b border-gray-700">154.42</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">23.32</td>

            <td class="px-3 py-2 border-b border-gray-700">23.48</td>

            <td class="px-3 py-2 border-b border-gray-700">37.12</td>

            <td class="px-3 py-2 border-b border-gray-700">27.08</td>

            <td class="px-3 py-2 border-b border-gray-700">29.38</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">52.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">100.05</td>

            <td class="px-3 py-2 border-b border-gray-700">105.61</td>

            <td class="px-3 py-2 border-b border-gray-700">155.92</td>

            <td class="px-3 py-2 border-b border-gray-700">131.49</td>

            <td class="px-3 py-2 border-b border-gray-700">138.35</td>

            <td class="px-3 py-2 border-b border-gray-700">178.15</td>

            <td class="px-3 py-2 border-b border-gray-700">260.91</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">4.68</td>

            <td class="px-3 py-2 border-b border-gray-700">5.52</td>

            <td class="px-3 py-2 border-b border-gray-700">5.52</td>

            <td class="px-3 py-2 border-b border-gray-700">5.52</td>

            <td class="px-3 py-2 border-b border-gray-700">7.34</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Transformation in Section 5  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ Field Ext.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyb. Enc. w/ RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSA</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">51.29</td>

            <td class="px-3 py-2 border-b border-gray-700">54.09</td>

            <td class="px-3 py-2 border-b border-gray-700">77.66</td>

            <td class="px-3 py-2 border-b border-gray-700">70.72</td>

            <td class="px-3 py-2 border-b border-gray-700">73.62</td>

            <td class="px-3 py-2 border-b border-gray-700">99.5</td>

            <td class="px-3 py-2 border-b border-gray-700">120.51</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">18.87</td>

            <td class="px-3 py-2 border-b border-gray-700">19.11</td>

            <td class="px-3 py-2 border-b border-gray-700">28.52</td>

            <td class="px-3 py-2 border-b border-gray-700">23.16</td>

            <td class="px-3 py-2 border-b border-gray-700">23.36</td>

            <td class="px-3 py-2 border-b border-gray-700">36.66</td>

            <td class="px-3 py-2 border-b border-gray-700">43.56</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verify(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Eval. Key(MB)</td>

            <td class="px-3 py-2 border-b border-gray-700">80.27</td>

            <td class="px-3 py-2 border-b border-gray-700">85.14</td>

            <td class="px-3 py-2 border-b border-gray-700">125.44</td>

            <td class="px-3 py-2 border-b border-gray-700">115.73</td>

            <td class="px-3 py-2 border-b border-gray-700">120.6</td>

            <td class="px-3 py-2 border-b border-gray-700">164.38</td>

            <td class="px-3 py-2 border-b border-gray-700">202.41</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ver. Key(KB)</td>

            <td class="px-3 py-2 border-b border-gray-700">4.89</td>

            <td class="px-3 py-2 border-b border-gray-700">4.89</td>

            <td class="px-3 py-2 border-b border-gray-700">4.89</td>

            <td class="px-3 py-2 border-b border-gray-700">6.01</td>

            <td class="px-3 py-2 border-b border-gray-700">6.01</td>

            <td class="px-3 py-2 border-b border-gray-700">6.01</td>

            <td class="px-3 py-2 border-b border-gray-700">6.71</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="C$\emptyset$C$\emptyset$: A Framework for Building Composabl... (2015/1093)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1093
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
