---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1763';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'cq: Cached quotients for fast lookups';
const AUTHORS_HTML = 'Liam Eagen, Dario Fiore, Ariel Gabizon';

const CONTENT = `    <p class="text-gray-300">cq:* Cached quotients for fast lookups</p>

    <p class="text-gray-300">Liam Eagen Alpen Labs</p>

    <p class="text-gray-300">Dario Fiore IMDEA software institute</p>

    <p class="text-gray-300">Ariel Gabizon Aztec Labs</p>

    <p class="text-gray-300">July 5, 2024</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">We present a protocol for checking the values of a committed polynomial <span class="math">f(X) \\in \\mathbb{F}_{&amp;lt;n}[X]</span> over a multiplicative subgroup <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> of size <span class="math">n</span> are contained in a table <span class="math">t \\in \\mathbb{F}^N</span>. After an <span class="math">O(N \\log N)</span> preprocessing step, the prover algorithm runs in time <span class="math">O(n \\log n)</span>. Thus, we continue to improve upon the recent breakthrough sequence of results [ZBK+22, PK22, GK22, ZGK+22] starting from Caulk [ZBK+22], which achieve sublinear complexity in the table size <span class="math">N</span>. The two most recent works in this sequence [GK22, ZGK+22] achieved prover complexity <span class="math">O(n \\cdot \\log^2 n)</span>.</p>

    <p class="text-gray-300">Moreover, cq has the following attractive features.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As in [ZBK+22, PK22, ZGK+22] our construction relies on homomorphic table commitments, which makes them amenable to vector lookups.</li>

      <li>As opposed to [ZBK+22, PK22, GK22, ZGK+22] the cq verifier doesn't involve pairings with prover defined <span class="math">\\mathbb{G}_2</span> points, which makes recursive aggregation of proofs more convenient.</li>

    </ol>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The lookup problem is fundamental to the efficiency of modern zk-SNARKs. Somewhat informally, it asks for a protocol to prove the values of a committed polynomial <span class="math">f(X) \\in \\mathbb{F}_{&amp;lt;n}[X]</span> are contained in a table <span class="math">T</span> of size <span class="math">N</span> of predefined legal values. When the table <span class="math">T</span> corresponds to an operation without an efficient low-degree arithmetization in <span class="math">\\mathbb{F}</span>, such a protocol produces significant savings in proof construction time for programs containing the operation. Building on previous work of [BCG+18], plookup [GW20] was the first to explicitly describe a solution to this problem in the polynomial-IOP context. plookup described a protocol with prover complexity quasilinear in both <span class="math">n</span> and <span class="math">N</span>. This left the intriguing question of whether the dependence on <span class="math">N</span> could be made sublinear after performing a preprocessing step for the table <span class="math">T</span>. Caulk [ZBK+22] answered this question in the affirmative by leveraging bi-linear pairings, achieving a run time of <span class="math">O(n^2 +</span></p>

    <p class="text-gray-300">*Pronounced “seek you”.</p>

    <p class="text-gray-300"><span class="math">n\\log N</span> ).  <span class="math">\\mathsf{Caulk}_{+}</span>  [PK22] improved this to  <span class="math">O(n^{2})</span>  getting rid of the dependence on table size completely. <span class="math">^{1}</span></p>

    <p class="text-gray-300">Naturally, the quadratic dependence on  <span class="math">n</span>  of these works made them impractical for a circuit with many lookup gates. This was resolved in two more recent protocols - baloo [ZGK+22] and Floohup [GK22] achieving a runtime of  <span class="math">O(n\\log^2 n)</span> . While Floohup has better concrete constants, baloo preserved an attractive feature of Caulk - using a homomorphic commitment to the table. This means that given commitments  <span class="math">\\mathsf{cm}_1, \\mathsf{cm}_2</span>  to tables  <span class="math">T_1, T_2</span>  with elements  <span class="math">\\{a_i\\}, \\{b_i\\}</span>  respectively; we can check membership in the set of elements  <span class="math">\\{a_i + \\alpha b_i\\}</span>  by running the protocol with  <span class="math">\\mathsf{cm} := \\mathsf{cm}_1 + \\alpha \\cdot \\mathsf{cm}_2</span>  as the table commitment. This is crucial for vector lookups that have become popular in zk-SNARKs, as described in Section 4 of [GW20].</p>

    <p class="text-gray-300">One drawback of all four recent constructions - Caulk, Caulk+, baloo, Floohup; is that they require the verifier perform a pairing where both  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  pairing arguments are not fixed in the protocol, but prover defined. This makes it harder to recursively aggregate multiple proofs via random combination, in the style described e.g. in Section 8 of [BCMS20].</p>

    <p class="text-gray-300">In this paper, we present a protocol called cq - short for "cached quotients" which is a central technical component in the construction (and arguably in all four preceding works). cq</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Improves asymptotic prover performance in field operations from  <span class="math">O(n \\log^2 n)</span>  to  <span class="math">O(n \\log n)</span> , and has smaller constants in group operations and proof size compared to baloo.</li>

      <li>Uses homomorphic table commitments similarly to Caulk, Caulk+ and baloo, enabling convenient vector lookups.</li>

      <li>Achieves for the first time in this line of work convenient aggregatability by having all verifier pairings use fixed protocol-defined  <span class="math">\\mathbb{G}_2</span>  arguments.</li>

    </ol>

    <p class="text-gray-300">Table 1: Scheme comparison.  <span class="math">n =</span>  witness size,  <span class="math">N =</span>  Table size, "Aggregatable"  <span class="math">=</span>  All prover defined pairing arguments are in  <span class="math">{\\mathbb{G}}_{1}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Preprocessing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Homomorphic?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregatable?</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk [ZBK+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">14 G1, 1 G2, 4 F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2 + n · log(N)) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4P</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk+ [PK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">7 G1, 1 G2, 2 F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n2) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Floohup [GK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log2 N) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">6 G1, 1 G2, 4 F</td>

            <td class="px-3 py-2 border-b border-gray-700">6n G1, n G2, O(n log2 n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">baloo [ZGK+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">12 G1, 1 G2, 4 F</td>

            <td class="px-3 py-2 border-b border-gray-700">13n G1, n G2, O(n log2 n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cq (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F, G1</td>

            <td class="px-3 py-2 border-b border-gray-700">8 G1, 3 F</td>

            <td class="px-3 py-2 border-b border-gray-700">8n G1, O(n log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1.2 Technical Overview</p>

    <p class="text-gray-300">We explain our protocol in the context of the line of work starting from <em>[ZBK+22]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">The innovation of Caulk</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To restate the problem, we have an input polynomial <span class="math">f(X)</span>, a table <span class="math">\\mathfrak{t}</span> of size <span class="math">N</span> encoded as the values of a polynomial <span class="math">T(X)\\in\\mathbb{F}_{&lt;N}[X]</span> on a subgroup <span class="math">\\mathbb{V}</span> of size <span class="math">N</span>. We want to show <span class="math">f</span>’s values on a subgroup <span class="math">\\mathbb{H}</span> of size <span class="math">n</span> are contained in <span class="math">\\mathfrak{t}</span>; concisely that $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}\\subset\\mathfrak{t}<span class="math">. We think of the parameters as </span>n<<N<span class="math">. We want our prover </span>\\mathbf{P}<span class="math"> to perform a number of operations <em>sublinear</em> in </span>N<span class="math">, or ideally, a number of operations depending only on </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One natural approach - is to send the verifier <span class="math">\\mathbf{V}</span> a polynomial <span class="math">T_{f}</span> encoding the <span class="math">n</span> <em>values from <span class="math">\\mathfrak{t}</span> actually used in <span class="math">f</span></em>, and then run a lookup protocol using <span class="math">T_{f}</span>. The challenging problem is then to prove <span class="math">T_{f}</span> <em>actually encodes values from <span class="math">T</span></em>. Speaking imprecisely, the “witness” to <span class="math">T_{f}</span>’s correctness is a quotient <span class="math">Q</span> of degree <span class="math">N-n</span>. It would defeat our purpose to actually compute <span class="math">Q</span> - as that would require <span class="math">O(N)</span> operations.</p>

    <p class="text-gray-300">The central innovation of <span class="math">\\mathsf{Caulk}</span> <em>[ZBK+22]</em> is the following observation: If we precompute commitments to certain quotient polynomials, we can compute in a number of operations depending only on <span class="math">n</span>, the <em>commitment</em> to <span class="math">Q</span>. Moreover, having only a commitment to <span class="math">Q</span> suffices to check, via pairings, that <span class="math">T_{f}</span> is valid.</p>

    <p class="text-gray-300">This approach was a big step forward, enabling for the first time lookups sublinear in table size. However, it has the following disadvantage: “Extracting” the subtable of values used in <span class="math">f</span>, is analogous to looking at restrictions of the original table polynomial to arbitrary sets - far from the nice subgroups we are used to in zk-SNARK world. Very roughly speaking, this is why all previous four works end up needing to work with interpolation and evaluation of polynomials on arbitrary sets. The corresponding algorithms for working on such sets have asymptotics of <span class="math">O(n\\cdot\\log^{2}n)</span> rather than the <span class="math">O(n\\log n)</span> we get for subgroups (of order <span class="math">2^{k}</span> for example).</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Our approach</h4>

    <p class="text-gray-300">The key difference between <em>[ZBK+22, x11, x14, ZGK+22]</em> and <span class="math">\\mathfrak{eq}</span> is that we use the idea of succinct computation of quotient commitments, not to extract a subtable, <em>but to directly run an existing lookup protocol on the original large table more efficiently</em>. Specifically, we use as our starting point the “logarithmic derivative based lookup” of <em>[x10, x15]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>[x11]</em> utilizes the following lemma (cf. Lemma 2.4 or Lemma 5 in <em>[x11]</em>): $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}\\subset\\mathfrak{t}<span class="math"> if and only if for some </span>m\\in\\mathbb{F}^{N}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[N]}\\frac{m_{i}}{X+\\mathfrak{t}_{i}}=\\sum_{i\\in[n]}\\frac{1}{X+f_{i}},</span></p>

    <p class="text-gray-300">as rational functions. <em>[x11]</em> checks this identity on a random <span class="math">\\beta</span>, by sending commitments to polynomials <span class="math">A</span> and <span class="math">B</span> whose values correspond to the summands evaluated at <span class="math">\\beta</span> of the LHS and RHS respectively. Given commitments to <span class="math">A,B</span>, we can check the above equality holds via various sumcheck techniques, e.g. as described in <em>[BCR+19]</em> (cf. Lemma 2.1). The RHS is not a problem because it is a sum of size <span class="math">n</span>. Computing <span class="math">A</span>’s</p>

    <p class="text-gray-300">commitment is actually not a problem either, because the number of its non-zero values on <span class="math">\\mathbb{V}</span> is at most <span class="math">n</span>. So when precomputing the commitments to the Lagrange base of <span class="math">\\mathbb{V}</span>, we can compute <span class="math">A</span>’s commitment in <span class="math">n</span> group operations.</p>

    <p class="text-gray-300">The main challenge is to convince the verifier <span class="math">\\mathbf{V}</span> that <span class="math">A</span> is correctly formed. This is equivalent to the existence of a quotient polynomial <span class="math">Q_{A}(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">A(X)(T(X)+\\beta)-m(X)=Q_{A}(X)\\cdot Z_{\\mathbb{V}}(X).</span></p>

    <p class="text-gray-300">It can be seen that this is the same <span class="math">Q_{A}(X)</span> as when writing</p>

    <p class="text-gray-300"><span class="math">A(X)T(X)=Q_{A}(X)Z_{\\mathbb{V}}(X)+R(X),</span></p>

    <p class="text-gray-300">for <span class="math">R(X)\\in\\mathbb{F}_{&lt;N}[X]</span>.</p>

    <p class="text-gray-300">Here is where our central innovation, and the term “cached quotients” come from. We observe that while computing <span class="math">Q_{A}</span> would take too long, we can compute the commitment <span class="math">[Q_{A}(x)]_{1}</span> to <span class="math">Q_{A}</span> in <span class="math">O(n)</span> operations as follows. We precompute for each <span class="math">L_{i}(X)</span> in the Lagrange basis of <span class="math">\\mathbb{V}</span> its quotient commitment when multiplying with <span class="math">T(X)</span>, i.e. the commitment to <span class="math">Q_{i}(X)</span> such that for some remainder <span class="math">R_{i}(X)\\in\\mathbb{F}_{&lt;N}[X]</span>.</p>

    <p class="text-gray-300"><span class="math">L_{i}(X)T(X)=Q_{i}(X)\\cdot Z_{\\mathbb{V}}(X)+R_{i}(X).</span></p>

    <p class="text-gray-300">Given the commitments <span class="math">[Q_{i}(x)]_{1}</span>, <span class="math">[Q_{A}(x)]_{1}</span> can be computed in <span class="math">O(n)</span> <span class="math">\\mathbb{G}_{1}</span>-operations via linear combination. Moreover, all the elements <span class="math">[Q_{i}(x)]_{1}</span> can be computed in an <span class="math">O(N\\log N)</span> preprocessing phase leveraging the work of Feist and Khovratovich[FK]. See Section 3 for details on this.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Terminology and Conventions</h3>

    <p class="text-gray-300">We assume our field <span class="math">\\mathbb{F}</span> is of prime order. We denote by <span class="math">\\mathbb{F}_{&lt;d}[X]</span> the set of univariate polynomials over <span class="math">\\mathbb{F}</span> of degree smaller than d. We assume all algorithms described receive as an implicit parameter the security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Whenever we use the term <em>efficient</em>, we mean an algorithm running in time <span class="math">\\mathsf{poly}(\\lambda)</span>. Furthermore, we assume an <em>object generator</em> <span class="math">\\mathcal{O}</span> that is run with input <span class="math">\\lambda</span> before all protocols, and returns all fields and groups used. Specifically, in our protocol <span class="math">\\mathcal{O}(\\lambda)=(\\mathbb{F},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t},e,g_{1},g_{2},g_{t})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a prime field of super-polynomial size <span class="math">r=\\lambda^{\\omega(1)}</span> .</li>

      <li><span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t}</span> are all groups of size <span class="math">r</span>, and <span class="math">e</span> is an efficiently computable non-degenerate pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>.</li>

      <li><span class="math">g_{1},g_{2}</span> are uniformly chosen generators such that <span class="math">e(g_{1},g_{2})=g_{t}</span>.</li>

    </ul>

    <p class="text-gray-300">We usually let the <span class="math">\\lambda</span> parameter be implicit, i.e. write <span class="math">\\mathbb{F}</span> instead of <span class="math">\\mathbb{F}(\\lambda)</span>. We write <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> additively. We use the notations <span class="math">[x]_{1}:=x\\cdot g_{1}</span> and <span class="math">[x]_{2}:=x\\cdot g_{2}</span>.</p>

    <p class="text-gray-300">We often denote by <span class="math">[n]</span> the integers <span class="math">\\{1,\\ldots,n\\}</span>. We use the acronym e.w.p. for “except with probability”; i.e. e.w.p. <span class="math">\\gamma</span> means with probability <em>at least</em> <span class="math">1-\\gamma</span></p>

    <p class="text-gray-300">universal SRS-based public-coin protocols</p>

    <p class="text-gray-300">We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the “proof length” of an interactive protocol.</p>

    <p class="text-gray-300">We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic <span class="math">\\mathsf{poly}(\\lambda)</span>-time from an “SRS of monomials” of the form <span class="math">\\left\\{\\left[x^{i}\\right]_{1}\\right\\}_{a\\leq i\\leq b},\\left\\{\\left[x^{i}\\right]_{2}\\right\\}_{c\\leq i\\leq d}</span>, for uniform <span class="math">x\\in\\mathbb{F}</span>, and some integers <span class="math">a,b,c,d</span> with absolute value bounded by <span class="math">\\mathsf{poly}(\\lambda)</span>. It then follows from Bowe et al. <em>[x1]</em> that the required SRS can be derived in a universal and updatable setup requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a <span class="math">\\mathsf{negl}(\\lambda)</span> advantage in its probability of producing a proof of any statement.</p>

    <p class="text-gray-300">For notational simplicity, we sometimes use the SRS <span class="math">\\mathsf{srs}</span> as an implicit parameter in protocols, and do not explicitly write it.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">The Aurora lemma</h5>

    <p class="text-gray-300">Our sumcheck relies on the following lemma originally used in the Aurora construction (<em>[BCR^{+}19]</em>, Remark 5.6).</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 2.1.</h6>

    <p class="text-gray-300">Let <span class="math">H\\subset\\mathbb{F}</span> be a multiplicative subgroup of size <span class="math">t</span>. For <span class="math">f\\in\\mathbb{F}_{&lt;t}[X]</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\sum_{a\\in H}f(a)=t\\cdot f(0).</span></p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 The algebraic group model</h3>

    <p class="text-gray-300">We introduce some terminology from <em>[x12]</em> to capture analysis in the Algebraic Group Model of Fuchsbauer, Kiltz and Loss<em>[x16]</em>.</p>

    <p class="text-gray-300">In our protocols, by an <em>algebraic adversary</em> <span class="math">\\mathcal{A}</span> in an SRS-based protocol we mean a <span class="math">\\mathsf{poly}(\\lambda)</span>-time algorithm which satisfies the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in\\{1,2\\}</span>, whenever <span class="math">\\mathcal{A}</span> outputs an element <span class="math">A\\in\\mathbb{G}_{i}</span>, it also outputs a vector <span class="math">v</span> over <span class="math">\\mathbb{F}</span> such that <span class="math">A=&lt;v,\\mathsf{srs}_{i}&gt;</span>.</li>

    </ul>

    <p class="text-gray-300">First we say our <span class="math">\\mathsf{srs}</span> <em>has degree <span class="math">Q</span></em> if all elements of <span class="math">\\mathsf{srs}_{i}</span> are of the form <span class="math">\\left[f(x)\\right]_{i}</span> for <span class="math">f\\in\\mathbb{F}_{&lt;Q+1}[X]</span> and uniform <span class="math">x\\in\\mathbb{F}</span>. In the following discussion let us assume we are executing a protocol with a degree <span class="math">Q</span> SRS, and denote by <span class="math">f_{i,j}</span> the corresponding polynomial for the <span class="math">j</span>’th element of <span class="math">\\mathsf{srs}_{i}</span>.</p>

    <p class="text-gray-300">Denote by <span class="math">a,b</span> the vectors of <span class="math">\\mathbb{F}</span>-elements whose encodings in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> an algebraic adversary <span class="math">\\mathcal{A}</span> outputs during a protocol execution; e.g., the <span class="math">j</span>’th <span class="math">\\mathbb{G}_{1}</span> element output by <span class="math">\\mathcal{A}</span> is <span class="math">\\left[a_{j}\\right]_{1}</span>.</p>

    <p class="text-gray-300">By a “real pairing check” we mean a check of the form</p>

    <p class="text-gray-300"><span class="math">(a\\cdot T_{1})\\cdot(T_{2}\\cdot b)=0</span></p>

    <p class="text-gray-300">for some matrices <span class="math">T_{1},T_{2}</span> over <span class="math">\\mathbb{F}</span>. Note that such a check can indeed be done efficiently given the encoded elements and the pairing function <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>.</p>

    <p class="text-gray-300">Given such a “real pairing check”, and the adversary <span class="math">\\mathcal{A}</span> and protocol execution during which the elements were output, define the corresponding “ideal check” as follows. Since <span class="math">\\mathcal{A}</span> is algebraic when he outputs <span class="math">\\left[a_{j}\\right]_{i}</span> he also outputs a vector <span class="math">v</span> such that, from linearity, <span class="math">a_{j}=\\sum v_{\\ell}f_{i,\\ell}(x)=R_{i,j}(x)</span> for <span class="math">R_{i,j}(X):=\\sum v_{\\ell}f_{i,\\ell}(X)</span>. Denote, for <span class="math">i\\in\\{1,2\\}</span> the vector of polynomials <span class="math">R_{i}=(R_{i,j})_{j}</span>. The corresponding ideal check, checks as a polynomial identity whether</p>

    <p class="text-gray-300"><span class="math">(R_{1}\\cdot T_{1})\\cdot(T_{2}\\cdot R_{2})\\equiv 0</span></p>

    <p class="text-gray-300">The following lemma is inspired by <em>[x10]</em>’s analysis of <em>[x13]</em>, and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks. Before stating the lemma we define the <span class="math">Q</span>-DLOG assumption similarly to <em>[x10]</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.2.</h6>

    <p class="text-gray-300">Fix integer <span class="math">Q</span>. The <span class="math">Q</span>-DLOG assumption for <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span> states that given</p>

    <p class="text-gray-300"><span class="math">\\left[1\\right]_{1},\\left[x\\right]_{1},\\ldots,\\left[x^{Q}\\right]_{1},\\left[1\\right]_{2},\\left[x\\right]_{2},\\ldots,\\left[x^{Q}\\right]_{2}</span></p>

    <p class="text-gray-300">for uniformly chosen <span class="math">x\\in\\mathbb{F}</span>, the probability of an efficient <span class="math">\\mathcal{A}</span> outputting <span class="math">x</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 2.3.</h6>

    <p class="text-gray-300">Assume the <span class="math">Q</span>-DLOG for <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span>. Given an algebraic adversary <span class="math">\\mathcal{A}</span> participating in a protocol with a degree <span class="math">Q</span> SRS, the probability of any real pairing check passing is larger by at most an additive <span class="math">\\mathsf{negl}(\\lambda)</span> factor than the probability the corresponding ideal check holds.</p>

    <p class="text-gray-300">See <em>[x11]</em> for the proof.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">The log-derivative method</h5>

    <p class="text-gray-300">We crucially use the following lemma from <em>[x14]</em>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.4.</h6>

    <p class="text-gray-300">Assume the characteristic of <span class="math">\\mathbb{F}</span> is larger than <span class="math">\\max(n,N)</span>. Given <span class="math">f\\in\\mathbb{F}^{n}</span>, and <span class="math">t\\in\\mathbb{F}^{N}</span>, we have <span class="math">f\\subset t</span> as sets if and only if for some <span class="math">m\\in\\mathbb{F}^{N}</span> the following identity of rational functions holds</p>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[n]}\\frac{1}{X+f_{i}}=\\sum_{i\\in[N]}\\frac{m_{i}}{X+t_{i}}.</span></p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Cached quotients</h2>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Notation:</h5>

    <p class="text-gray-300">In this section and the next we use the following conventions. <span class="math">\\mathbb{V}\\subset\\mathbb{F}</span> denotes a mutliplicative subgroup of order <span class="math">N</span> which is a power of two. We denote by <span class="math">\\mathbf{g}</span> a generator of <span class="math">\\mathbb{V}</span>. Hence, <span class="math">\\mathbb{V}=\\left\\{\\mathbf{g},\\mathbf{g}^{2},\\ldots,\\mathbf{g}^{N}=1\\right\\}</span>. Given <span class="math">P\\in\\mathbb{F}[X]</span> and integer <span class="math">i\\in[N]</span>, we denote <span class="math">P_{i}:=P(\\mathbf{g}^{i})</span>. For <span class="math">i\\in[N]</span>, we denote by <span class="math">L_{i}\\in\\mathbb{F}_{&lt;N}[X]</span> the <span class="math">i</span>’th Lagrange polynomial of <span class="math">\\mathbb{V}</span>. Thus, <span class="math">(L_{i})_{i}=1</span> and <span class="math">(L_{i})_{j}=0</span> for <span class="math">i\\neq j\\in[N]</span>.</p>

    <p class="text-gray-300">For a polynomial <span class="math">A(X)\\in\\mathbb{F}_{&lt;N}[X]</span>, we say it is <em><span class="math">n</span>-sparse</em> if <span class="math">A_{i}\\neq 0</span> for at most <span class="math">n</span> values <span class="math">i\\in[N]</span>. The <em>sparse representation</em> of such <span class="math">A</span> consists of the (at most) <span class="math">n</span> pairs</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(i,A_{i})</span> such that <span class="math">A_{i}\\neq 0</span>. We denote $\\operatorname{supp}(A):=\\{i\\in[N]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{i}\\neq 0\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main result of this section is a method to compute a commitment to a quotient polynomial - derived from a product with a preprocessed polynomial; in a number of operations depending only on the sparsity of the other polynomial in the product.</p>

    <p class="text-gray-300">The result crucially relies on the following lemma based on a result of Feist and Khovratovich[FK].</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Lemma 3.1.</h6>

    <p class="text-gray-300">Fix <span class="math">T\\in\\mathbb{F}_{&lt;N}[X]</span>, and a subgroup <span class="math">\\mathbb{V}\\subset\\mathbb{F}</span> of size <span class="math">N</span>. There is an algorithm that given the <span class="math">\\mathbb{G}_{1}</span> elements <span class="math">\\left\\{\\left[x^{i}\\right]_{1}\\right\\}_{i\\in\\{0,\\ldots,N-1\\}}</span> computes for <span class="math">i\\in[N]</span>, the elements <span class="math">q_{i}:=[Q_{i}(x)]_{1}</span> where <span class="math">Q_{i}(X)\\in\\mathbb{F}[X]</span> is such that</p>

    <p class="text-gray-300"><span class="math">L_{i}(X)\\cdot T(X)=T_{i}\\cdot L_{i}(X)+Z_{\\mathbb{V}}(X)\\cdot Q_{i}(X)</span></p>

    <p class="text-gray-300">in <span class="math">O(N\\cdot\\log N)</span> <span class="math">\\mathbb{G}_{1}</span> operations.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall the definition of the Lagrange polynomial</p>

    <p class="text-gray-300"><span class="math">L_{i}(X)=\\frac{Z_{\\mathbb{V}}(X)}{Z^{\\prime}_{\\mathbb{V}}(\\mathbf{g}^{i})(X-\\mathbf{g}^{i})}.</span></p>

    <p class="text-gray-300">Substituting this definition, we can write the quotient <span class="math">Q_{i}(X)</span> as</p>

    <p class="text-gray-300"><span class="math">Q_{i}(X)=\\frac{T(X)-T_{i}}{Z^{\\prime}_{\\mathbb{V}}(\\mathbf{g}^{i})(X-\\mathbf{g}^{i})}=Z^{\\prime}_{\\mathbb{V}}(\\mathbf{g}^{i})^{-1}K_{i}(X),</span></p>

    <p class="text-gray-300">for <span class="math">K_{i}(X):=\\frac{T(X)-T_{i}}{X-\\mathbf{g}^{i}}</span>. Note that the values <span class="math">\\left\\{\\left[K_{i}(x)\\right]_{1}\\right\\}_{i\\in[N]}</span> are exactly the KZG opening proofs of <span class="math">T(X)</span> at the elements of <span class="math">\\mathbb{V}</span>. Thus, the algorithm of Feist and Khovratovich [FK, Tom] can be used to compute commitments to all the proofs <span class="math">\\left[K_{i}(x)\\right]_{1}</span> in <span class="math">O(N\\log N)</span> <span class="math">\\mathbb{G}_{1}</span>-operations. This works by writing the vector of <span class="math">\\left[K_{i}(x)\\right]_{1}</span> as a the product of a matrix with the vector of <span class="math">\\left[x^{i}\\right]_{1}</span>. This matrix is a DFT matrix times a Toeplitz matrix, both of which have algorithms for evaluating matrix vector products in <span class="math">O(N\\log N)</span> operations. Thus, all the KZG proofs can be computed in <span class="math">O(N\\log N)</span> field operations and operations in <span class="math">\\mathbb{G}_{1}</span>.</p>

    <p class="text-gray-300">Finally, the algorithm just needs to scale each <span class="math">\\left[K_{i}(x)\\right]_{1}</span> by <span class="math">Z^{\\prime}_{\\mathbb{V}}(\\mathbf{g}^{i})^{-1}</span> to compute <span class="math">\\left[Q_{i}(x)\\right]_{1}</span>. Conveniently, these values admit a very simple description when <span class="math">Z_{\\mathbb{V}}(X)=X^{N}-1</span> is a group of roots of unity.</p>

    <p class="text-gray-300"><span class="math">Z^{\\prime}_{\\mathbb{V}}(X)^{-1}=(NX^{N-1})^{-1}\\equiv X/N\\bmod Z_{\\mathbb{V}}(X)</span></p>

    <p class="text-gray-300">In total, the prover computes the coefficients of <span class="math">T(X)</span> in <span class="math">O(N\\log N)</span> field operations, computes the KZG proofs for <span class="math">T(\\mathbf{g}^{i})=t_{i}</span> in <span class="math">O(N\\log N)</span> group operations, and then scales these proofs by <span class="math">\\mathbf{g}^{i}/N</span> in <span class="math">O(N)</span> group operations. In total, this takes <span class="math">O(N\\log N)</span> field and group operations in <span class="math">\\mathbb{G}_{1}</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 3.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix integer parameters <span class="math">0\\leq n\\leq N</span> such that <span class="math">n,N</span> are powers of two dividing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">. Fix </span>T\\in\\mathbb{F}_{<N}[X]<span class="math">, and a subgroup </span>\\mathbb{V}\\subset\\mathbb{F}<span class="math"> of size </span>N<span class="math">. Let </span>\\mathsf{srs}=\\left\\{\\left[x^{i}\\right]_{1}\\right\\}_{i\\in[0,\\ldots,N-1]}<span class="math"> for some </span>x\\in\\mathbb{F}<span class="math">. There is an algorithm </span>\\mathscr{A}<span class="math"> that after a preprocessing step of </span>O(N\\log N)<span class="math"> </span>\\mathbb{F}<span class="math">- and </span>\\mathbb{G}_{1}<span class="math">-operations starting with </span>\\mathsf{srs}$ does the following.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given input <span class="math">A(X)\\in\\mathbb{F}_{&lt;N}[X]</span> that is <span class="math">n</span>-sparse and given in sparse representation, <span class="math">\\mathscr{A}</span> computes in <span class="math">O(n)</span> <span class="math">\\mathbb{F}</span>-operations and <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span>-operations each of the elements <span class="math">\\mathsf{cm}_{1}=\\left[Q(x)\\right]_{1},\\mathsf{cm}_{2}=\\left[R(x)\\right]_{1}</span> for <span class="math">Q(X),R(X)\\in\\mathbb{F}_{&lt;N}[X]</span> such that</p>

    <p class="text-gray-300"><span class="math">A(X)\\cdot T(X)=Q(X)\\cdot Z_{\\mathbb{V}}(X)+R(X).</span></p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The preprocessing step consists of computing the quotient commitments <span class="math">\\left[Q_{i}(X)\\right]_{1}</span> in <span class="math">O(N\\log N)</span> operations, as described in Lemma 3.1. As stated in the lemma, for each <span class="math">i\\in[N]</span> we have</p>

    <p class="text-gray-300"><span class="math">L_{i}(X)\\cdot T(X)=T_{i}\\cdot L_{i}(X)+Z_{\\mathbb{V}}(X)\\cdot Q_{i}(X).</span></p>

    <p class="text-gray-300">By assumption, the polynomial <span class="math">A(X)</span> can be written as a linear combination of at most <span class="math">n</span> summands in the Lagrange basis of <span class="math">\\mathbb{V}</span>.</p>

    <p class="text-gray-300"><span class="math">A(X)=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot L_{i}(X)</span></p>

    <p class="text-gray-300">Substituting this into the product with <span class="math">T(X)</span>, and substituting each of the products <span class="math">L_{i}(X)T(X)</span> with the appropriate cached quotient <span class="math">Q_{i}(X)</span> we find</p>

    <p class="text-gray-300"><span class="math">A(X)T(X)</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot L_{i}(X)T(X)=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot T_{i}L_{i}(X)+A_{i}\\cdot Z_{\\mathbb{V}}(X)Q_{i}(X)</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot T_{i}L_{i}(X)+Z_{\\mathbb{V}}(X)\\cdot\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot Q_{i}(X).</span></p>

    <p class="text-gray-300">Observing that the terms of the first sum are all of degree smaller than <span class="math">N</span>, we get that</p>

    <p class="text-gray-300"><span class="math">Q(X)</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot Q_{i}(X)</span> <span class="math">R(X)</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}T_{i}\\cdot L_{i}(X)</span></p>

    <p class="text-gray-300">Hence, commitments to both the quotient <span class="math">Q(X)</span> and remainder <span class="math">R(X)</span> can be computed in at most <span class="math">n</span> group operations as</p>

    <p class="text-gray-300"><span class="math">\\left[Q(x)\\right]_{1}</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot\\left[Q_{i}(x)\\right]_{1}</span> <span class="math">\\left[R(x)\\right]_{1}</span> <span class="math">=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}T_{i}\\cdot\\left[L_{i}(x)\\right]_{1}</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">Before describing our protocol, we give a definition of a lookup protocol secure against algebraic adversaries.</p>

    <p class="text-gray-300"><strong>Definition 4.1.</strong> A lookup protocol is a pair <span class="math">\\mathcal{P} = (\\text{gen}, \\text{IsInTable})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{gen}(N, \\mathfrak{t})</span> is a randomized algorithm receiving as input parameters integer <span class="math">N</span> and <span class="math">\\mathfrak{t} \\in \\mathbb{F}^N</span>. Given these inputs <span class="math">\\operatorname{gen}</span> outputs a string <span class="math">\\mathbf{srs}</span> of <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span> elements.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{IsInTable}(\\mathsf{cm},\\mathfrak{t},\\mathsf{srs},\\mathbb{H};f)</span> is an interactive public coin protocol between <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> where <span class="math">\\mathbf{P}</span> has private input <span class="math">f\\in \\mathbb{F}_{&amp;lt;n}[X]</span>, and both parties have access to <span class="math">\\mathfrak{t},\\mathsf{cm}</span> and <span class="math">\\mathsf{srs} = \\mathsf{gen}(N,\\mathfrak{t})</span>; such that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <strong>Completeness:</strong> If <span class="math">\\mathsf{cm} = [f(x)]_1</span> and $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}} \\subset \\mathfrak{t}<span class="math"> then </span>\\mathbf{V}<span class="math"> outputs </span>\\mathsf{acc}$ with probability one.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Knowledge soundness in the algebraic group model:</strong> The probability of any efficient algebraic <span class="math">\\mathcal{A}</span> to win the following game is <span class="math">\\operatorname{negl}(\\lambda)</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> chooses integer parameters <span class="math">N, n</span> and a table <span class="math">\\mathfrak{t} \\in \\mathbb{F}^N</span>.</li>

      <li>We compute <span class="math">\\mathsf{srs} = \\mathsf{gen}(\\mathfrak{t}, N)</span>.</li>

      <li><span class="math">\\mathcal{A}</span> sends a message <span class="math">\\mathsf{cm}</span> and <span class="math">f\\in \\mathbb{F}_{&amp;lt;d}[X]</span> such that <span class="math">\\mathsf{cm} = [f(x)]_1</span> where <span class="math">d</span> is such that all <span class="math">\\mathbb{G}_1</span> elements in <span class="math">\\mathsf{srs}</span> are linear combinations of <span class="math">\\left\\{\\left[x^i\\right]_1\\right\\}_{i\\in \\{0,\\dots,d - 1\\}}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> and <span class="math">\\mathbf{V}</span> engage in the protocol <span class="math">\\mathsf{IsInTable}(\\mathfrak{t},\\mathsf{cm},\\mathsf{srs},\\mathbb{H})</span>, where <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> is a subgroup of order <span class="math">n</span>, with <span class="math">\\mathcal{A}</span> taking the role of <span class="math">\\mathbf{P}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> wins if</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> outputs <span class="math">\\mathsf{acc}</span>, and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">* $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}} \\not\\subset \\mathfrak{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say a lookup protocol is homomorphic if for any fixed parameter <span class="math">N</span> and fixed randomness, <span class="math">\\operatorname{gen}(\\mathfrak{t}, N)</span> can be written as <span class="math">(\\operatorname{gen}_1, \\operatorname{gen}_2(\\mathfrak{t}))</span> such that <span class="math">\\operatorname{gen}_1</span> is fixed, and <span class="math">\\operatorname{gen}_2</span> is an <span class="math">\\mathbb{F}</span>-linear function of <span class="math">\\mathfrak{t}</span>.</p>

    <h2 id="sec-22" class="text-2xl font-bold">4.1 The cq protocol</h2>

    <p class="text-gray-300"><span class="math">\\operatorname{gen}(N, \\mathfrak{t})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose random <span class="math">x \\in \\mathbb{F}</span> compute and output <span class="math">\\left\\{\\left[x^i\\right]_1\\right\\}_{i \\in \\{0, \\dots, N-1\\}}, \\left\\{\\left[x^i\\right]_2\\right\\}_{i \\in \\{0, \\dots, N\\}}</span>.</li>

      <li>Compute and output <span class="math">[Z_{\\mathbb{V}}(x)]_2</span>.</li>

      <li>Compute <span class="math">T(X) = \\sum_{i\\in [N]}\\mathfrak{t}_iL_i(X)</span>. Compute and output <span class="math">[T(x)]_2</span>.</li>

      <li>For <span class="math">i \\in [N]</span>, compute and output:</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">q_{i} = [Q_{i}(x)]_{1}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">L _ {i} (X) \\cdot T (X) = \\mathbf {t} _ {i} \\cdot L _ {i} (X) + Z _ {\\mathbb {V}} (X) \\cdot Q _ {i} (X).</span></div>

    <p class="text-gray-300">(b) <span class="math">[L_i(x)]_1</span> (c) <span class="math">\\left[\\frac{L_i(x) - L_i(0)}{x}\\right]_1</span></p>

    <p class="text-gray-300">Before describing IsInTable, we explain an optimization we use in Step 6 of Round 2. Since we know in advance we are going to open <span class="math">B</span> at zero, it is more efficient to commit to the <em>the opening proof polynomial</em> <span class="math">B_0(X) \\coloneqq \\frac{B(X) - B(0)}{X}</span> of <span class="math">B</span> at 0 instead of committing to <span class="math">B</span>. To evaluate <span class="math">B</span>, <span class="math">\\mathbf{V}</span> can use the relation <span class="math">B(X) = B_0(X) \\cdot X + b_0</span>.</p>

    <p class="text-gray-300">We note that it's possible to make a similar optimization for <span class="math">A</span> to further reduce proof size and prover time. However, this entails an additional verifier pairing for the check in Step 11 of Round 2.</p>

    <p class="text-gray-300">IsInTable(cm, t, srs, <span class="math">\\mathbb{H}</span>; <span class="math">f</span>):</p>

    <p class="text-gray-300"><strong>Round 1: Committing to the multiplicities vector</strong></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathbf{P}</span> computes the polynomial <span class="math">m(X)\\in \\mathbb{F}_{&amp;lt; N}[X]</span> defined by setting <span class="math">m_{i}</span>, for each <span class="math">i\\in [N]</span>, to the number of times <span class="math">\\mathfrak{t}_i</span> appears in $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends <span class="math">\\mathfrak{m} := [m(x)]_1</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Round 2: Interpolating the rational identity at a random <span class="math">\\beta</span>; checking correctness of <span class="math">A</span>'s values + degree check for <span class="math">B</span> using pairings</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> chooses and sends random <span class="math">\\beta \\in \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes <span class="math">A \\in \\mathbb{F}_{&amp;lt; N}[X]</span> such that for <span class="math">i \\in [N]</span>, <span class="math">A_i = m_i / (\\mathfrak{t}_i + \\beta)</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathsf{a} := [A(x)]_1</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathfrak{q}_{\\mathbf{a}} := [Q_A(x)]_1</span> where <span class="math">Q_{A} \\in \\mathbb{F}_{&amp;lt; N}[X]</span> is such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A (X) (T (X) + \\beta) - m (X) = Q _ {A} (X) \\cdot Z _ {\\mathbb {V}} (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> computes <span class="math">B(X)\\in \\mathbb{F}_{&amp;lt;n}[X]</span> such that for <span class="math">i\\in [n]</span>, <span class="math">B_{i} = 1 / (f_{i} + \\beta)</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes <span class="math">B_0(X) \\in \\mathbb{F}_{&amp;lt;n-1}[X]</span> defined as <span class="math">B_0(X) := \\frac{B(X) - B(0)}{X}</span>.</li>

    </ol>

    <p class="text-gray-300">2We assume here that t's values are distinct. If there are duplicate values in t, one must rather set <span class="math">m_i = 0</span> for the indices i of the duplicates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathsf{b}_0 := [B_0(x)]_1</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes <span class="math">Q_B(X)</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">B(X)(f(X) + \\beta) - 1 = Q_B(X) \\cdot Z_{\\mathbb{H}}(X).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathfrak{q}_{\\mathbf{b}} := [Q_B(x)]_1</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathsf{p} = [P(x)]_1</span> where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">P(X) := B_0(X) \\cdot X^{N-1-(n-2)}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> checks that <span class="math">A</span> encodes the correct values:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{a}, [T(x)]_2) = e(\\mathsf{q}_{\\mathsf{a}}, [Z_{\\mathbb{V}}(x)]_2) \\cdot e(\\mathsf{m} - \\beta \\cdot \\mathsf{a}, [1]_2).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> checks that <span class="math">B_0</span> has the appropriate degree:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\mathsf{b}_0, \\left[ x^{N-1-(n-2)} \\right]_2\\right) = e(\\mathsf{p}, [1]_2).</span></div>

    <p class="text-gray-300"><strong>Round 3: Checking correctness of <span class="math">B</span> at random <span class="math">\\gamma \\in \\mathbb{F}</span></strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> sends random <span class="math">\\gamma \\in \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> sends <span class="math">b_{0,\\gamma} := B_0(\\gamma), f_\\gamma := f(\\gamma)</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes and sends the value <span class="math">a_0 := A(0)</span>.</li>

      <li><span class="math">\\mathbf{V}</span> sets <span class="math">b_0 := (N \\cdot a_0)/n</span>.</li>

      <li>As part of checking the correctness of <span class="math">B</span>, <span class="math">\\mathbf{V}</span> computes <span class="math">Z_{\\mathbb{H}}(\\gamma) = \\gamma^n - 1</span>, <span class="math">b_\\gamma := b_{0,\\gamma} \\cdot \\gamma + b_0</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q_{b,\\gamma} := \\frac{b_\\gamma \\cdot (f_\\gamma + \\beta) - 1}{Z_{\\mathbb{H}}(\\gamma)}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To perform a batched KZG check for the correctness of the values <span class="math">b_{0,\\gamma}, f_\\gamma, Q_{b,\\gamma}</span></li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\mathbf{V}</span> sends random <span class="math">\\eta \\in \\mathbb{F}</span>. <span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> separately compute</p>

    <div class="my-4 text-center"><span class="math-block">v := b_{0,\\gamma} + \\eta \\cdot f_\\gamma + \\eta^2 \\cdot Q_{b,\\gamma}.</span></div>

    <p class="text-gray-300">(b) <span class="math">\\mathbf{P}</span> computes <span class="math">\\pi_\\gamma := [h(x)]_1</span> for</p>

    <div class="my-4 text-center"><span class="math-block">h(X) := \\frac{B_0(X) + \\eta \\cdot f(X) + \\eta^2 \\cdot Q_B(X) - v}{X - \\gamma}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{c}:=\\mathsf{b}_{0}+\\eta\\cdot\\mathsf{cm}+\\eta^{2}\\cdot\\mathsf{q}_{\\mathsf{b}}</span></p>

    <p class="text-gray-300">and checks that</p>

    <p class="text-gray-300"><span class="math">e(\\mathsf{c}-[v]_{1}+\\gamma\\cdot\\pi_{\\gamma},[1]_{2})=e(\\pi_{\\gamma},[x]_{2}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To perform a KZG check for the correctness of <span class="math">a_{0}</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> computes and sends <span class="math">\\mathsf{a}_{0}:=[A_{0}(x)]_{1}</span> for</li>

    </ul>

    <p class="text-gray-300"><span class="math">A_{0}(X):=\\frac{A(X)-a_{0}}{X}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}</span> checks that</li>

    </ul>

    <p class="text-gray-300"><span class="math">e(\\mathsf{a}-[a_{0}]_{1},[1]_{2})=e(\\mathsf{a}_{0},[x]_{2}).</span></p>

    <p class="text-gray-300">Note that although the above description contains nine pairings, we can reduce to five pairings via the standard technique of combining several pairings equations into one pairing product via randomness, and then grouping pairings that share the same <span class="math">\\mathbb{G}_{2}</span> argument. (The different <span class="math">\\mathbb{G}_{2}</span> arguments are <span class="math">[1]_{2},[x]_{2},\\left[x^{N-1-(n-2)}\\right]_{2},[Z_{\\mathbb{V}}(x)]_{2},[T(x)]_{2}</span>.) It is easy to check that <span class="math">\\mathfrak{cq}</span> is homomorphic according to Definition 4.1.</p>

    <p class="text-gray-300">The main things to address are the efficiency of the gen algorithm used for preprocessing, the efficiency of <span class="math">\\mathbf{P}</span> in <span class="math">\\mathsf{IsInTable}</span>, and the knowledge soundness of <span class="math">\\mathsf{IsInTable}</span>.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Runtime of gen:</h5>

    <p class="text-gray-300">We claim that gen requires <span class="math">O(N\\log N)</span> <span class="math">\\mathbb{G}_{1}</span>- and <span class="math">\\mathbb{F}</span>-operations and <span class="math">O(N)</span> <span class="math">\\mathbb{G}_{2}</span>-operations. The claim regarding the <span class="math">\\mathbb{G}_{2}</span> operations is obvious. The elements <span class="math">\\{q_{i}\\}</span> can be computed in <span class="math">O(N\\log N)</span> operations according to Lemma 3.1. The elements <span class="math">\\{[L_{i}(x)]_{1}\\}</span> can be computed in <span class="math">O(N\\log N)</span> via FFT as explained in Section 3.3 of <em>[x1]</em>. Given the element <span class="math">[L_{i}(x)]_{1}</span>, the element <span class="math">\\left[\\frac{L_{i}(x)-L_{i}(0)}{x}\\right]_{1}</span> can be computed as</p>

    <p class="text-gray-300"><span class="math">\\left[\\frac{L_{i}(x)-L_{i}(0)}{x}\\right]_{1}=\\mathbf{g}^{-i}\\cdot\\left[L_{i}(x)\\right]_{1}-(1/N)\\cdot\\left[x^{N-1}\\right]_{1}.</span></p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Runtime of <span class="math">\\mathbf{P}</span>:</h5>

    <p class="text-gray-300">Note first that the computation of <span class="math">\\mathsf{m},\\mathsf{a}</span> can be done in <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span>-operations as <span class="math">m(X)</span> and <span class="math">A(X)</span> are <span class="math">n</span>-sparse. The main thing to address is the computation of <span class="math">\\mathsf{q}_{\\mathsf{a}}</span>; that can be done in <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span>-operations given <span class="math">\\mathsf{srs}</span> according to Theorem 3.2. The only step requiring <span class="math">O(n\\log n)</span> <span class="math">\\mathbb{F}</span>-operations is the computation of the quotient <span class="math">Q_{B}(X)</span> which involves FFT on <span class="math">\\mathbb{H}</span>. We also note that the commitment <span class="math">\\mathsf{a}_{0}=\\left[\\frac{A(x)-A(0)}{x}\\right]_{1}</span> can be computed in <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span>-operations as the linear combination</p>

    <p class="text-gray-300"><span class="math">\\left[\\frac{A(x)-A(0)}{x}\\right]_{1}=\\sum_{i\\in\\mathrm{supp}(A)}A_{i}\\cdot\\left[\\frac{L_{i}(x)-L_{i}(0)}{x}\\right]_{1}.</span></p>

    <p class="text-gray-300">Knowledge soundness proof: Let <span class="math">\\mathcal{A}</span> be an efficient algebraic adversary participating in the Knowledge Soundness game from Definition 4.1. We show its probability of winning the game is <span class="math">\\mathsf{negl}(\\lambda)</span>. Let <span class="math">f \\in \\mathbb{F}_{&amp;lt;N}[X]</span> be the polynomial sent by <span class="math">\\mathcal{A}</span> in the third step of the game such that <span class="math">\\mathsf{cm} = [f(x)]_1</span>. As <span class="math">\\mathcal{A}</span> is algebraic, when sending the commitments <span class="math">\\mathsf{m}, \\mathsf{a}, \\mathsf{b}_0, \\mathsf{p}, \\mathsf{q}_\\mathsf{a}, \\mathsf{q}_\\mathsf{b}, \\pi_\\gamma, \\mathsf{a}_0</span> during protocol execution it also sends polynomials <span class="math">m(X), A(X), B_0(X)</span>, <span class="math">P(X), Q_A(X), Q_B(X), h(X), A_0(X) \\in \\mathbb{F}_{&amp;lt;N}[X]</span> such that the former are their corresponding commitments. Let <span class="math">E</span> be the event that <span class="math">\\mathbf{V}</span> outputs <span class="math">\\mathsf{acc}</span>. Note that the event that <span class="math">\\mathcal{A}</span> wins the knowledge soundness game is contained in <span class="math">E</span>. <span class="math">E</span> implies all pairing checks have passed. Let <span class="math">A \\subset E</span> be the event that one of the corresponding ideal pairing checks as defined in Section 2.2 didn't pass. According to Lemma 2.3, <span class="math">\\operatorname{Pr}(A) = \\mathsf{negl}(\\lambda)</span>. Given that <span class="math">A</span> didn't occur, we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From Round 2, Step 11</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">A (X) (T (X) + \\beta) - M (X) = Q _ {A} (X) \\cdot Z _ {\\mathbb {V}} (X)</span></div>

    <p class="text-gray-300">Which means that for all <span class="math">i\\in [N]</span></p>

    <div class="my-4 text-center"><span class="math-block">A _ {i} = \\frac {M _ {i}}{T _ {i} + \\beta}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>From Round 2, Step 12</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">X ^ {N - 1 - (n - 2)} B _ {0} (X) = P (X),</span></div>

    <p class="text-gray-300">which implies that <span class="math">\\deg(B_0) \\leq n - 2</span>. Note also that we know <span class="math">\\deg(A) &amp;lt; N</span> simply from <span class="math">\\left[x^{N-1}\\right]_1</span> being the highest <span class="math">\\mathbb{G}_1</span> power in <span class="math">\\mathsf{srs}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Moving to Round 3, from the checks of steps 6c and 7b, e.w.p. $n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\eta \\in \\mathbb{F}<span class="math"> (see e.g. Section 3 of [GWC19] for an explanation of batched KZG [KZG10]), we have </span>b_{0,\\gamma} = B_0(\\gamma), Q_{b,\\gamma} = Q_B(\\gamma), f_\\gamma = f(\\gamma), a_0 = A(0)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">B(X) \\coloneqq B_0(X) \\cdot X + b_0</span> for <span class="math">b_0</span> set as in step 4. Note that we have <span class="math">\\deg(B) &amp;lt; n</span>. Let <span class="math">\\omega</span> by a generator of <span class="math">\\mathbb{H}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- By how <span class="math">b_{\\gamma}, Q_{b,\\gamma}</span> are set in step 5, the above implies that e.w.p. $(N + n) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\gamma$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">B (X) \\cdot (f (X) + \\beta) = 1 + Q _ {B} (X) Z _ {\\mathbb {H}} (X),</span></div>

    <p class="text-gray-300">which implies for all <span class="math">i\\in [n]</span> that <span class="math">B(\\omega^i) = \\frac{1}{f(\\omega^i) + \\beta}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We now have using Lemma 2.1 that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">N \\cdot a _ {0} = \\sum_ {i \\in [ N ]} A _ {i} = \\sum_ {i \\in [ N ]} \\frac {m _ {i}}{T _ {i} + \\beta},</span></div>

    <p class="text-gray-300">3An important point is that when using an SRS built with higher degrees in <span class="math">\\mathbb{G}_1</span>, <span class="math">A</span> must also be degree checked via an additional pairing. In such a case, we must also change the power of <span class="math">X</span> in Step 12 of Round 2 from <span class="math">N - 1 - (n - 2)</span> to <span class="math">d - (n - 2)</span> where <span class="math">d</span> is the maximal SRS degree in <span class="math">\\mathbb{G}_1</span>.</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300"><span class="math">n\\cdot b_{0}=\\sum_{i\\in[n]}B(\\omega^{i})=\\sum_{i\\in[n]}\\frac{1}{f(\\omega^{i})+\\beta}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that <span class="math">b_{0}</span> was set such that <span class="math">N\\cdot a_{0}=n\\cdot b_{0}</span>. Multiplying denominators, we see that e.w.p. $(n+N)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\beta\\in\\mathbb{F}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[N]}\\frac{m_{i}}{T_{i}+X}=\\sum_{i\\in[n]}\\frac{1}{f(\\omega^{i})+X},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which implies $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{H}}\\subset\\mathfrak{t}$ by Lemma 2.4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In summary, we have shown the event that <span class="math">\\mathbf{V}</span> outputs <span class="math">\\mathsf{acc}</span> while $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{H}}\\not\\subset\\mathfrak{t}<span class="math"> is contained in a constant number of events with probability </span>\\mathsf{negl}(\\lambda)<span class="math">; and so </span>\\mathfrak{cq}$ satisfies the knowledge soundness property.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-25" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">We thank Kobi Gurkan, Aurel Nicolas and Marek Sefranek for corrections.</p>

    <h2 id="sec-26" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCG^{+}18] J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen, and M. Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In Thomas Peyrin and Steven D. Galbraith, editors, Advances in Cryptology - ASI-ACRYPT 2018 - 24th International Conference on the Theory and Application of Cryptology and Information Security, Brisbane, QLD, Australia, December 2-6, 2018, Proceedings, Part I, volume 11272 of Lecture Notes in Computer Science, pages 595–626. Springer, 2018.</li>

      <li>[BCMS20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. Recursive proof composition from accumulation schemes. In Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 1–18. Springer, 2020.</li>

      <li>[BCR^{+}19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. Aurora: Transparent succinct arguments for R1CS. In Advances in Cryptology - EUROCRYPT 2019 - 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Darmstadt, Germany, May 19-23, 2019, Proceedings, Part I, pages 103–128, 2019.</li>

      <li>[BGG17] S. Bowe, A. Gabizon, and M. D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-snark. Cryptology ePrint Archive, Paper 2017/602, 2017. https://eprint.iacr.org/2017/602.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BGM17] S. Bowe, A. Gabizon, and I. Miers. Scalable multi-party computation for zksnark parameters in the random beacon model. Cryptology ePrint Archive, Paper 2017/1050, 2017. https://eprint.iacr.org/2017/1050.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Eag22] Liam Eagen. Bulletproofs++. Cryptology ePrint Archive, Paper 2022/510, 2022. https://eprint.iacr.org/2022/510.</li>

      <li>[FK] D. Feist and D. Khovratovich. Fast amortized kate proofs.</li>

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part II, pages 33–62, 2018.</li>

      <li>[GK22] A. Gabizon and D. Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of table size. Cryptology ePrint Archive, Paper 2022/1447, 2022. https://eprint.iacr.org/2022/1447.</li>

      <li>[Gro16] J. Groth. On the size of pairing-based non-interactive arguments. In Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, pages 305–326, 2016.</li>

      <li>[GW20] A. Gabizon and Z. J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Paper 2020/315, 2020. https://eprint.iacr.org/2020/315.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Paper 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[Hab22] U. Haböck. Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Paper 2022/1530, 2022. https://eprint.iacr.org/2022/1530.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. pages 177–194, 2010.</li>

      <li>[PK22] J. Posen and A. A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Paper 2022/957, 2022. https://eprint.iacr.org/2022/957.</li>

      <li>[Tom] A. Tomescu. Feist-khovratovich technique for computing kzg proofs fast.</li>

      <li>[ZBK^{+}22] A. Zapico, V. Buterin, D. Khovratovich, M. Maller, A. Nitulescu, and M. Simkin. Caulk: Lookup arguments in sublinear time. Cryptology ePrint Archive, Paper 2022/621, 2022. https://eprint.iacr.org/2022/621.</li>

    </ul>

    <p class="text-gray-300">[ZGK^{+}22] A. Zapico, A. Gabizon, D. Khovratovich, M. Maller, and C. Ràfols. Baloo: Nearly optimal lookup arguments. Cryptology ePrint Archive, Paper 2022/1565, 2022. https://eprint.iacr.org/2022/1565.</p>`;
---

<BaseLayout title="cq: Cached quotients for fast lookups (2022/1763)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1763
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
