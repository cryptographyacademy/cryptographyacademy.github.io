---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/239';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-19';
const TITLE_HTML = 'Meet-in-the-Middle Attacks and Structural Analysis of Round-Reduced PRINCE';
const AUTHORS_HTML = 'Patrick Derbez&lt;sup&gt;1&lt;/sup&gt; and Léo Perrin2? patrick.derbez@irisa.fr leo.perrin@uni.lu';

const CONTENT = `    <p class="text-gray-300">Patrick Derbez&lt;sup&gt;1&lt;/sup&gt; and Léo Perrin2? patrick.derbez@irisa.fr leo.perrin@uni.lu</p>

    <p class="text-gray-300">1 IRISA, University of Rennes 1 &lt;sup&gt;2&lt;/sup&gt; SnT, University of Luxembourg</p>

    <p class="text-gray-300">Abstract. NXP Semiconductors and its academic partners challenged the cryptographic community with nding practical attacks on the block cipher they designed, PRINCE. Instead of trying to attack as many rounds as possible using attacks which are usually impractical despite being faster than brute-force, the challenge invites cryptographers to nd practical attacks and encourages them to actually implement them. In this paper, we present new attacks on round-reduced PRINCE including the ones which won the challenge in the 4, 6 and 8-round categories the highest for which winners were identied. Our rst attacks rely on a meet-in-the-middle approach and break up to 10 rounds of the cipher. We also describe heuristic methods we used to nd practical SAT-based and dierential attacks.</p>

    <p class="text-gray-300">Finally, we also present an analysis of the cycle structure of the internal rounds of PRINCE leading both to a low complexity distinguisher for 4-round PRINCE-core and an alternative representation of the cipher valid in particular contexts and which highlights, in these cases, a poor diusion.</p>

    <p class="text-gray-300">Keywords: PRINCE, practical attacks, meet-in-the-middle, SAT-solver, statistical analysis</p>

    <p class="text-gray-300">When tasked with assessing the security of a block cipher, cryptanalysts have now a broad range of tools at their disposal: dierential attack <a href="#page-24-0">[1]</a>, linear attack <a href="#page-24-1">[2]</a>, meet-in-the-middle attack <a href="#page-24-2">[3]</a>, etc. The main purpose of a security analysis is usually to identify aws in the design of a primitive and then to illustrate their gravity through the description of an attack covering as many rounds as possible. However, applicability of said attacks in a realistic situation is usually not the rst objective of the cryptanalyst. A simple reason for this is that as</p>

    <p class="text-gray-300">&lt;sup&gt;?&lt;/sup&gt; Patrick Derbez and Léo Perrin were supported by the CORE ACRYPT project from the Fond National de Recherche (Luxembourg).</p>

    <p class="text-gray-300">c IACR 2015. This article is the full version of the article published by Springer-Verlag available at 10.1007/978-3-662-48116-5_10.</p>

    <p class="text-gray-300">our understanding of the design of block ciphers improved, the ease of identifying practical attacks decreased. Furthermore and in accordance with the famous maxim attacks only get better, an impractical attack submitted at a given time may later be improved.</p>

    <p class="text-gray-300">While impractical attacks provide the academic community with valuable insights into the security provided by dierent block ciphers, their components, their design strategies, etc., crypanalysis in the industry is more focused on practical attacks. In order to promote this view, the Technical University of Denmark (DTU), NXP Semiconductors and the Ruhr University of Bochum challenged the cryptographic community <a href="#page-24-3">[4]</a> with nding low data complexity attacks on the block cipher PRINCE <a href="#page-24-4">[5]</a>. More precisely, they accept attacks requiring only at most 2 &lt;sup&gt;20&lt;/sup&gt; chosen plaintexts or 2 &lt;sup&gt;30&lt;/sup&gt; known plaintexts. Furthermore, extra rewards (from 1000 to 10000e) are given for attacks on at least 8 rounds which require at most 2 &lt;sup&gt;45&lt;/sup&gt; bytes of memory (about 32 Terabytes) and at most 2 &lt;sup&gt;64&lt;/sup&gt; encryptions of the round-reduced variant attacked.</p>

    <p class="text-gray-300">Studying PRINCE in this setting may provide valuable data on multiple accounts. First of all, PRINCE is a lightweight block cipher, meaning that it is intended to be run on processors with little computing power to devote to security related algorithm or on hardware where every logical gate counts. Research on this topic is intense nowadays as the need for such primitives becomes increasingly pressing, see <a href="#page-24-5">[6]</a> for an extensive review of the algorithms that have been proposed. Second, PRINCE implements a simplied version of the so-called FX construction: encryption under key (k0||k1) consists in xor-ing k&lt;sup&gt;0&lt;/sup&gt; to the plaintext, applying a block cipher called PRINCE-core keyed with k&lt;sup&gt;1&lt;/sup&gt; and then output the result xor-ed with L(k0) where L is a simple linear bijection. This strategy allows for a greater key size without the cost of a sophisticated key schedule. However, it is impossible to make a security claim as strong as for a more classical construction. Finally, PRINCE-core has a unique property called α-reection. If we denote by Ec,k&lt;sup&gt;1&lt;/sup&gt; the encryption under PRINCE-core with subkey k1, then the corresponding decryption operation is Ec,k1⊕&lt;sup&gt;α&lt;/sup&gt; for a constant α. In other words, decryption is merely encryption under a related-key. The consequences of this property have already been studied and, in particular, some values of α dierent from the one used have been showed to lead to weaker algorithms <a href="#page-24-6">[7]</a>.</p>

    <p class="text-gray-300">PRINCE has already been the subject of several cryptanalyses, notably <a href="#page-24-7">[8]</a> where the security of the algorithm against multiple attacks was assessed, <a href="#page-24-6">[7]</a> which investigated the inuence of the value of α, <a href="#page-24-8">[9]</a> which described Meetin-the-Middle attacks on the block cipher and, nally, <a href="#page-24-9">[10]</a> proposed the best attack to date in terms of number of rounds attacked. A list of the cryptanalyses of round-reduced PRINCE is provided in Table <a href="#page-2-0">1.</a> Attacks working only on PRINCE-core or for modied versions of PRINCE (dierent α or S-Box) are not shown.</p>

    <p class="text-gray-300">As stated before, most of the attacks usually considered often have impractical complexities. For instance, dierential attacks and linear attacks require large amounts of chosen (respectively known) plaintexts, both of which may be impossible to gather to begin with if the algorithm is implemented on a small-device</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Description</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Reference</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Type</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Data (CP)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[8]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Di. / Logic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27&lt;br&gt;&lt;&lt; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43.4&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.7&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Appendix D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">101.1&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66.25&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.7&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50.7&lt;br&gt;2&lt;br&gt;(online)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65.7&lt;br&gt;2&lt;br&gt;(online)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68 (online)&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Section 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Dierential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.1&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14.9&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[9]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57.3&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46.89&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51.21&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52.21&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multiple di.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57.94&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60.62&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.52&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Time complexity is measured in encryption units</p>

    <p class="text-gray-300">Memory complexity is measured in 64-bit blocks</p>

    <p class="text-gray-300">Table 1: The best attacks on round-reduced PRINCE in the single-key model.</p>

    <p class="text-gray-300">with little computer and, hence, a small throughput. Therefore, we focused our eorts on Meet-in-the-Middle (MitM) attacks, algebraic/logic attack where the fact that a ciphertext is the encryption of a plaintext is encoded as an equation which is fed to a solver and, surprisingly, dierential attack for which we found a heuristic method decreasing signicantly the data complexity.</p>

    <p class="text-gray-300">Our contribution. We describe dierent low data complexity attacks on roundreduced PRINCE which were submitted to the PRINCE challenge and turned out <a href="#page-24-10">[11]</a> to be the best ones on PRINCE reduced to 4, 6 and 8 rounds. In Section <a href="#page-4-0">3,</a> we describe our attacks obtained using the meet-in-the-middle technique and we also show a new attack on 10 rounds with practical memory and a time complexity around 2 encryptions. Then, we describe in Section <a href="#page-11-0">4</a> a low data dierential attack against 6-round PRINCE, which is the fastest known. In fact, the power of the lter used to discard wrong pairs in a dierential attack can be raised to the power 4 when attacking 6-round PRINCE by considering groups of pairs. In Section <a href="#page-14-0">5</a> we show how the equation given to a SAT-solver can be modified so as to make an attack on 4 rounds practical, and how to simplify our 6-round differential attack by using a SAT-solver to take care of the tedious details of the key recovery. We finally present in Section 6 some observations about the cycle structure of the internal rounds of PRINCE and how it implies the existence of alternative representations of the cipher highlighting a poor diffusion in some subsets of the input space. While we do not use these to attack PRINCE directly, we show that the size of these subsets remains reasonable and actually find such sets for 4-round PRINCE-core.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">2 Specification of PRINCE</h3>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Description of PRINCE</h3>

    <p class="text-gray-300">PRINCE is a 64-bit block cipher with a 128-bit key. It is based on a variant of the the FX-construction which was proposed by Kilian and Rogaway as a generalization of the DESX scheme. The master key k is split into two 64-bit parts  <span class="math">k=k_0 \\parallel k_1</span>  and  <span class="math">k_0</span>  is used to generate a third subkey  <span class="math">k_0&#x27;=(k_0\\gg 1)\\oplus(k_0\\gg 63)</span> . Both  <span class="math">k_0</span>  and  <span class="math">k_0&#x27;</span>  are used as pre- and post- whitening keys respectively. The full version of the cipher has 12 rounds and is depicted on Figure 1.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;    <img src="_page_3_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: the PRINCE cipher.</p>

    <p class="text-gray-300">The encryption is quite similar to the AES and consists of a nibble-based substitution layer S and a linear layer M. The operation M can be divided into a ShiftRows operations and a matrix multiplication M' operating independently on each column but not nibble-oriented. Furthermore the matrix M' is an involution and, combined to the fact that the round constants satisfy the relation  <span class="math">RC_i \\oplus RC_i&#x27; = \\alpha</span>  where  <span class="math">\\alpha = \\text{C0AC29B7C97C50DD}</span> , the decryption process  <span class="math">D_{k_0,k_1,k_0&#x27;}</span>  is equal to the encryption process  <span class="math">E_{k_0&#x27;,k_1\\oplus\\alpha,k_0}</span> . For further details about PRINCE we refer the reader to [5].</p>

    <p class="text-gray-300"><strong>Notations.</strong> In the sequel we denote both the plaintext and the ciphertext by p and c respectively. For the first R rounds of 2R-round PRINCE, we denote the</p>

    <p class="text-gray-300">internal state just before (resp. after) the r-th SubNibble layer by  <span class="math">x_r</span>  (resp.  <span class="math">y_r</span> ) while for the last R rounds those internal states are denoted by  <span class="math">y&#x27;_r</span>  and  <span class="math">x&#x27;_r</span>  respectively as shown on Figure 1. Given a collection of messages  <span class="math">\\{p^0, \\ldots, p^m, \\ldots\\}</span> , the notation  <span class="math">x_r^m[i]</span>  holds for the nibble i of the state  <span class="math">x_r</span>  of the message  <span class="math">p^m</span> . As PRINCE is not fully nibble-oriented we use the notation  <span class="math">x_r[i]_b</span>  to refer to the bit i of the state  <span class="math">x_r</span>  and the following relation holds for all  <span class="math">i \\in \\{0, \\ldots, 15\\}</span> :</p>

    <p class="text-gray-300"><span class="math">$x_r[i] = x_r[4i+3]_b \\parallel x_r[4i+2]_b \\parallel x_r[4i+1]_b \\parallel x_r[4i]_b.</span>$</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">bi</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ts</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">nib</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">bles</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">3</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\nabla</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ア</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 2: Ordering of bits/nibbles in PRINCE.</p>

    <p class="text-gray-300">Finally, we use the following notations for some functions.</p>

    <p class="text-gray-300">R The composition of S and M so that R(x) = M(S(x)) = SR(M'(S(x))).  <span class="math">E_{k_{0||k_1}}^r</span>  PRINCE reduced to r rounds.  <span class="math">E_{c,k_1}</span>  full PRINCE-core.</p>

    <p class="text-gray-300"><span class="math">E_{k_1}^{c,r}</span>  PRINCE-core reduced to r rounds.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;3 Meet-in-the-Middle Attacks</h3>

    <p class="text-gray-300">In this section we present both the 6-round attack and the 8-round attack which won the PRINCE Challenge in the chosen-plaintext category together with a new attack on 10 rounds. The aim of the challenge was to find the best attacks using at most  <span class="math">2^{20}</span>  chosen plaintexts and thus we decided to follow the strategy used by Demirci and Selçuk on AES in [3], later improved by Dunkelman et al. in [12], Derbez et al. in [13,14] and by Li et al. in [9]. While our 10-round attack does not fit the restriction on the data complexity it shows that this kind of attacks is one of the most powerful on SP-Network.</p>

    <p class="text-gray-300">First we give the definition of an ordered  <span class="math">\\delta</span> -set which is a particular structure of messages used in our attacks.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Let a  <span class="math">\\delta</span> -set be a set of 16 PRINCE-states that are all different in one state nibble (the active nibble) and all equal in the other state nibble (the inactive nibbles). An ordered  <span class="math">\\delta</span> -set is a  <span class="math">\\delta</span> -set  <span class="math">\\{x^0, \\ldots, x^{15}\\}</span>  such that the difference in the active nibble between  <span class="math">x^0</span>  and  <span class="math">x^i</span>  is equal to i, for  <span class="math">0 \\le i \\le 15</span> .</p>

    <p class="text-gray-300">In the sequel we consider  <span class="math">\\delta</span> -sets such that nibble 7 is the active one. For such a particular set we made the following observations which are the core of our new attacks.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;<strong>Observation 1</strong> Consider the encryption of a collection  <span class="math">\\{p^0, p^1, \\ldots, p^{15}\\}</span>  of 16 messages through 6-round PRINCE. If the set  <span class="math">\\{y_2^0, y_2^1, \\ldots, y_2^{15}\\}</span>  is an ordered  <span class="math">\\delta</span> -set then the ordered sequence</p>

    <p class="text-gray-300"><span class="math">$\\left[y_2&#x27;^{1}[7] \\oplus y_2&#x27;^{0}[7], y_2&#x27;^{2}[7] \\oplus y_2&#x27;^{0}[7], \\dots, y_2&#x27;^{15}[7] \\oplus y_2&#x27;^{0}[7]\\right]</span>$</p>

    <p class="text-gray-300">is fully determined by the following 8 nibble parameters:</p>

    <p class="text-gray-300"><span class="math">$-x_3^0[0,7,10,13]</span>$
<span class="math">-x_3&#x27;^0[0,7,10,13]</span></p>

    <p class="text-gray-300">Consequently, there are at most  <span class="math">2^{8\\times4}=2^{32}</span>  possible sequences when we consider all the possible choices of keys and ordered  <span class="math">\\delta</span> -sets (out of the  <span class="math">2^{4\\times15}=2^{60}</span>  of the theoretically possible 15-nibble sequences).</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is straightforward. The goal is to propagate the differences from the state  <span class="math">y_2</span>  (which are known) to the state nibble  <span class="math">y&#x27;_2[7]</span> . At each intermediate round, each S-box is either a parameter, not required or constant (so output differences are equal to zero).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-1&quot;&gt;&lt;/span&gt;<strong>Observation 2</strong> Consider the encryption of a collection  <span class="math">\\{p^0, p^1, \\ldots, p^{15}\\}</span>  of 16 messages through 8-round PRINCE. If the set  <span class="math">\\{x_2^0, x_2^1, \\ldots, x_2^{15}\\}</span>  is an ordered  <span class="math">\\delta</span> -set then the ordered sequence</p>

    <p class="text-gray-300"><span class="math">$\\left[x_2&#x27;^{1}[7] \\oplus x_2&#x27;^{0}[7], \\dots, x_2&#x27;^{15}[7] \\oplus x_2&#x27;^{0}[7], y_2&#x27;^{1}[6] \\oplus y_2&#x27;^{0}[6], \\dots, y_2&#x27;^{15}[6] \\oplus y_2&#x27;^{0}[6]\\right]</span>$</p>

    <p class="text-gray-300">is fully determined by the following 42 nibble parameters:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} - &amp; x_2^0[7] &amp; - &amp; x_4&#x27;^0[0..15] \\\\ - &amp; x_3^0[0,7,10,13] &amp; - &amp; x_3&#x27;^0[0,7,10,13] \\\\ - &amp; x_4^0[0..15] &amp; - &amp; x_2&#x27;^0[7] \\end{array}</span>$</p>

    <p class="text-gray-300">Furthermore, those 42 state nibbles can be directly computed from the full state  <span class="math">x_4</span>  and 4 nibbles of  <span class="math">M^{-1}(k_1)</span> . Consequently, there are at most  <span class="math">2^{4\\times(16+4)}=2^{80}</span>  possible sequences when we consider all the possible choices of keys and ordered  <span class="math">\\delta</span> -sets (out of the  <span class="math">2^{4\\times30}=2^{120}</span>  of the theoretically possible 30-nibble sequences).</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is similar to the one of Observation 1 except the parameters are related. Indeed, from the full state  <span class="math">x_4</span>  one can directly compute  <span class="math">x_4&#x27;</span>  as no keys are involved. Then we note that the 4 nibbles  <span class="math">M^{-1}(k_1)[4..7]</span>  are enough to compute  <span class="math">x_3^0[0,7,10,13]</span>  from  <span class="math">x_4</span>  and  <span class="math">x_3&#x27;&#x27;[0,7,10,13]</span>  from  <span class="math">x_4&#x27;</span> . Finally, the knowledge of  <span class="math">M^{-1}(k_1)[7]</span>  allows to compute  <span class="math">x_2^0[7]</span>  and  <span class="math">x_2&#x27;&#x27;[7]</span>  from  <span class="math">x_3^0[0,7,10,13]</span>  and  <span class="math">x_3&#x27;&#x27;[0,7,10,13]</span>  respectively.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">3.1 6-round Attack</h4>

    <p class="text-gray-300">The 6-round attack is depicted on Figure 3 and its scenario is straightforward. First the  <span class="math">2^{32}</span>  possible sequences given in Observation 1 are computed and stored in a hash table during a preprocessing phase. Then during the online phase, we begin by asking for the encryption of a structure of  <span class="math">2^{16}</span>  chosen plaintexts such that nibbles from 4 to 7 take all the possible values while the other ones are constant, and pick one of them denoted  <span class="math">p^0</span> . Now the goal of the adversary is to identify an ordered  <span class="math">\\delta</span> -set containing  <span class="math">y_2^0</span> . To do so, he has to guess the fives nibbles  <span class="math">x_1^0[4..7]</span>  and  <span class="math">x_2^0[7]</span>  and propagate the differences from the state  <span class="math">y_2</span>  to the plaintext. Then he gets the corresponding ciphertexts, guess the fives nibbles  <span class="math">x_1&#x27;&#x27;[4..7]</span>  and  <span class="math">x_2&#x27;&#x27;[7]</span>  and propagates the differences from the ciphertexts to  <span class="math">y_2&#x27;[7]</span> . Finally he discards all the guesses which do not lead to a match in the previously built hash table. The probability for a wrong guess to pass the test is  <span class="math">2^{32} \\times 2^{-60} = 2^{-28}</span>  so we expect  <span class="math">2^5</span>  candidates to remain at the end of the attack. The wrong ones can be discarded by replaying the attack with an other choice for  <span class="math">p^0</span>  without increasing the overall complexity of the attack.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;    <img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: 6r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">The data complexity of this attack is  <span class="math">2^{16}</span>  chosen plaintexts and the memory requirement is around  <span class="math">2^{32} \\times 4 \\times 15 \\times 2^{-3} \\approx 2^{34.9}</span>  bytes. During the online phase 10 state nibbles are guessed however they can assume only  <span class="math">2^{33}</span>  values once the plaintext/ciphertext pair is given. Indeed, the knowledge of the 33 bits</p>

    <p class="text-gray-300"><span class="math">$\\{(k_0 \\oplus k_1)[16..27]_b, (k&#x27;_0 \\oplus k_1)[16..27]_b, k_1[28..31]_b, k_0[28..32]_b\\},\\</span>$</p>

    <p class="text-gray-300">is enough to compute all of them from p and c. Thus the time complexity of the online phase is approximately  <span class="math">16 \\times 2^{33} \\times 40/(6 \\times 64) \\approx 2^{33.7}</span>  encryptions.</p>

    <p class="text-gray-300"><strong>Key recovery.</strong> At the end of the attack 128 - 33 = 95 key bits are still missing. To find them the best way is to apply several meet-in-the-middle attacks</p>

    <p class="text-gray-300">successively. For instance, one could begin by running the attack depicted on Figure 12 in Appendix A which has an overall complexity below  <span class="math">2^{28}</span>  as most key bits required in the online phase are already known.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;3.2 8-round Attack</h3>

    <p class="text-gray-300">The 8-round attack is similar to the one on 6 rounds and is depicted on Figure 4. It relies on Observation 2 so the memory complexity is around  <span class="math">2^{80} \\times 15 \\times 8 \\times 2^{-3} \\approx 2^{83.9}</span>  bytes. In the online phase, the data complexity remains unchanged to  <span class="math">2^{16}</span>  chosen plaintexts but the number of state variable to guess is increased. The identification step requires to guess the four nibbles  <span class="math">x_1^0[4..7]</span>  and then the nine nibbles  <span class="math">x_1&#x27;^0[0..7]</span>  and  <span class="math">x_2&#x27;^0[6]</span>  are guessed to build the sequence from the ciphertexts. Those 13 nibbles can assume only  <span class="math">2^{49}</span>  values once the plaintext/ciphertext pair  <span class="math">(p^0, c^0)</span>  given as they all can be derived from</p>

    <p class="text-gray-300"><span class="math">$\\{(k_0 \\oplus k_1)[16..24, 28..31]_b, (k_0&#x27; \\oplus k_1)[0..23, 27..31]_b, k_0[25..27]_b, k_1[24..27]_b\\}.</span>$</p>

    <p class="text-gray-300">Thus the time complexity of the online phase is approximately  <span class="math">16 \\times 2^{49} \\times 52/(8 \\times 64) \\approx 2^{49.7}</span>  encryptions and we expect  <span class="math">2^{49} \\times 2^{80} \\times 2^{-120} = 2^9</span>  candidates to remain at the end of the attack.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;    <img src="_page_7_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4: 8r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300"><strong>Key recovery.</strong> As for the previous attack, the most efficient way to recover the missing key bits is to perform other attacks. For instance one could run the attack depicted on Figure 13 (Appendix B) which has the same complexity than the one above since there are approximately 2&lt;sup&gt;9&lt;/sup&gt; candidates for the 4 active nibbles</p>

    <p class="text-gray-300">of  <span class="math">x_1</span> . Then the search space would be small enough to perform an exhaustive search without increasing the overall complexity.</p>

    <p class="text-gray-300"><strong>Trade-off.</strong> It is possible to trade some memory against time without increasing the data complexity by noticing that for a considered structure of  <span class="math">2^{16}</span>  plaintexts the 4 active nibbles of  <span class="math">x_3</span>  take all the possible values. Thus we can fix them to 0 during the offline phase and save a factor  <span class="math">2^{16}</span>  in memory. In the other hand, we now need to run the attack for all the possible choices for  <span class="math">p^0</span>  increasing the time complexity by the same factor of  <span class="math">2^{16}</span> .</p>

    <p class="text-gray-300">A more sophisticated attack against 8-round PRINCE, requiring much less memory, is described in Appendix E.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">3.3 10-round Attack</h4>

    <p class="text-gray-300">We now investigate PRINCE reduced to 10 rounds. While we were unable to find an attack requiring less than  <span class="math">2^{20}</span>  chosen plaintexts for the PRINCE Challenge, we found one competitive with the current best known attack. To describe it we first extend the definition of a  <span class="math">\\delta</span> -set as it was done in [13], then we show a meetin-the-middle attack as the two ones above and finally we apply the differential enumeration technique ([12]).</p>

    <p class="text-gray-300"><span class="math">\\delta</span> -set. In [13] Derbez <em>et al.</em> shown that the notion of  <span class="math">\\delta</span> -set can be extended to set of states such that some <em>linear combinations</em> of state bits are constant. In the sequel we denote by  <span class="math">\\delta</span> -set a set of 16 messages such that  <span class="math">y_2[0..4, 6, 8..12, 14]</span>  and  <span class="math">M&#x27;(y_2)[0..4, 6, 8..12, 14]</span>  are constant, exploiting the fact that the matrix operating on the columns are not MDS.</p>

    <p class="text-gray-300">10-round attack. The basis of our attack on 10 rounds is depicted on Figure 5. The meet-in-the-middle is performed on the four bit-equations described above. The state bytes required as the parameters of the hash table can be computed from the whole state  <span class="math">x_5</span>  and 8 nibbles of the equivalent subkey  <span class="math">M^{-1}(k_1)</span>  and thus approximately  <span class="math">2^{96}</span>  60-bit sequences are stored. In the online phase the 24 state nibbles needed can be computed from the following 66 key bits:</p>

    <pre><code class="language-text">\\{k_0[0,20..24,28..32,52..56,60..63]_b, k_1[20..23,28..31,52..55,60..63]_b,\\\\ (k_0\\oplus k_1)[16..19,24..27,48..51,56..59]_b,\\\\ (k_0&#x27;\\oplus k_1)[16..19,24..26,48..51,56..58]_b\\}.
</code></pre>

    <p class="text-gray-300">Note that this attack does not actually work because the number of sequences stored is higher than the number of possible 60-bit sequences and thus no key candidates are filtered. The aim of the next section is to show how to reduce the memory requirement.</p>

    <p class="text-gray-300"><strong>Differential Enumeration Technique.</strong> Li et al. applied this technique against PRINCE in [9] and successfully mounted new attacks on 8 and 9 rounds. The idea of this technique originally introduced by Dunkelman <em>et al.</em> in [12] is to store in the hash table only the sequences built from a  <span class="math">\\delta</span> -set containing a message  <span class="math">p^0</span>  that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;    <img src="_page_9_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5: 10r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">belongs to a pair  <span class="math">(p^0,p^1)</span>  following a well-chosen differential characteristic. In our case the truncated differential characteristic is depicted on Figure 5 assuming a zero difference in hatched nibbles. Thus we expect to store only  <span class="math">2^{96+4-60}=2^{40}</span>  sequences in the offline phase. However generating them is not as trivial as for the basic attack. We propose the following procedure which has a time complexity around  <span class="math">2^{72}</span>  operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consider a pair  <span class="math">(p^0, p^1)</span>  following the differential characteristic.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">S^{-1} \\circ M&#x27; \\circ S</span>  can be seen as 4 invertible super Sboxes  <span class="math">\\S_0, \\ldots, S_3</span>  operating on 16-bit words. Build 4 hash tables such that one can retrieve (x, y) from  <span class="math">(x \\oplus y, S_i(x) \\oplus S_i(y))</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guess the difference in the active nibbles of both  <span class="math">y_4</span>  and y'4 and retrieve the actual value of  <span class="math">x_5</span>  and  <span class="math">x&#x27;_5</span>  for both messages of the pair.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guess the difference in the two active nibbles of the first column of  <span class="math">y_3</span>  and get back the actual values of  <span class="math">y_4[2, 5, 8, 15]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Combined with the knowledge of  <span class="math">x_5</span>  this leads to the knowledge of the four key nibbles  <span class="math">M^{-1}(k_1)[2,5,8,15]</span> . Use them to partially encrypt  <span class="math">x_5&#x27;</span>  and check if the difference in the first column of  <span class="math">y_3&#x27;</span>  is correct.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Use  <span class="math">M^{-1}(k_1)[15]</span>  to partially decrypt  <span class="math">y_4</span>  and get the difference in  <span class="math">x_2[15]</span>  and check its correctness. Do the same for the difference in  <span class="math">x&#x27;_2[15]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guess the difference in the two active nibbles of the third column of  <span class="math">y_3</span>  and get back  <span class="math">M^{-1}(k_1)[0,7,11,13]</span> .</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compute the value of the missing parameters and check whether the pair follows the characteristic or not. If it does then build the 60-bit sequence from  <span class="math">p^0</span>  and store it in the hash table.</li>
    </ol>

    <p class="text-gray-300">The complexity of this procedure is dominated by the complexity of steps 4-5 which is  <span class="math">2^{72}</span>  simple operations that we estimate to be equivalent to  <span class="math">2^{69}</span>  encryptions. Now that the table is built the online phase is quite similar to the one of the offline phase:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ask for a structure of  <span class="math">2^{32}</span>  chosen plaintexts and store the ciphertexts in a hash table to identify the pairs that may follows the differential characteristic.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each pair  <span class="math">(p^0, p^1)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Guess the difference in the first column of  <span class="math">y_1</span>  and of  <span class="math">y_2</span> , deduce the corresponding value of  <span class="math">(k_0 \\oplus k_1)[12..15]</span>  and  <span class="math">k_1[15]</span> . Store them in a hash table  <span class="math">T_0</span>  indexed by  <span class="math">k_1[15], k_0[61..63]_b</span> .</li>
      <li>(b) Similarly compute  <span class="math">(k&#x27;_0 \\oplus k_1)[12..15]</span>  and  <span class="math">k_1[15]</span>  from the ciphertexts and use  <span class="math">T_0</span>  and the linear relations between  <span class="math">k_0</span>  and k'0 to get back the  <span class="math">2^{2\\times 4+2}</span> .  <span class="math">2^{-7} = 2^3</span>  corresponding values of the key nibbles above. Store those  <span class="math">2^{13}</span>  key candidates in a hash table  <span class="math">T_1</span>  indexed by  <span class="math">(k_0 \\oplus k_1)[12..15]</span> ,  <span class="math">(k&#x27;_0 \\oplus k_1)[12..15]</span>  and  <span class="math">k_0[55]_b \\oplus k_0[60]_b (= (k_0 \\oplus k_1)[55]_b \\oplus \\ldots \\oplus (k_0 \\oplus k_1)[60]_b \\oplus (k&#x27;_0 \\oplus k_1)[55]_b \\oplus \\ldots \\oplus (k&#x27;_0 \\oplus k_1)[59]_b \\oplus k_1[60]_b)</span> .</li>
      <li>(c) Repeat the two steps above but now by guessing the third column of  <span class="math">y_2</span>  and use  <span class="math">T_1</span>  to obtain the  <span class="math">2^{2\\times 13-8-8-1}=2^9</span>  and store them in a hash table  <span class="math">T_2</span>  indexed by the difference in  <span class="math">y_2</span> . (While the match is on 33 bits,  <span class="math">(k_0 \\oplus k_1)[12..15]</span>  and  <span class="math">(k&#x27;_0 \\oplus k_1)[12..15]</span>  only depend on four 4-bit parameters.)</li>
      <li>(d) Repeat the three steps above but now by guessing the third column of  <span class="math">y_1</span>  and use  <span class="math">T_3</span>  to finally retrieve all the  <span class="math">2^{9+9-8} = 2^{10}</span>  key candidates.</li>
      <li>(e) For each key candidate identify a  <span class="math">\\delta</span> -set from  <span class="math">p^0</span> , build the 60-bit sequence and check whether it belongs to the table constructed in the offline phase. If it does then try the key candidate.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Repeat the procedure until the right key is found.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">As each structure contains  <span class="math">2^{63}</span>  pairs and each of these pairs follows the differential with probability  <span class="math">2^{-28-60}=2^{-88}</span> , we need  <span class="math">2^{25}</span>  structures on average. Then, for each structure we have to study only  <span class="math">2^{63-32}=2^{31}</span>  pairs and for each of them we have to perform  <span class="math">4\\times 2^{13}+2^{10}\\times 2^4</span>  simple operations estimated to approximately  <span class="math">2^{12}</span>  encryptions. Thus this procedure has a the time complexity of  <span class="math">2^{25+31+12}=2^{68}</span>  encryptions and requires  <span class="math">2^{25+32}=2^{57}</span>  chosen plaintexts. At the end of the attack  <span class="math">2^{66}\\times 2^{40}\\times 2^{-60}=2^{46}</span>  key candidates remain. As 62 key bits are also missing performing an exhaustive search is not a valid option. Instead, the best way to recover the key is to apply several meet-in-the-middle attacks. For instance, we can assume that when a match happens we get back the corresponding values of the red nibbles in Figure 5 and then deduce step by step each key bits of  <span class="math">M^{-1}(k_1)</span>  by completing the first and the third columns of  <span class="math">y_3&#x27;</span>  without increasing the overall complexity of the attack.</p>

    <p class="text-gray-300">In this section we describe a new dierential attack against 6-round PRINCE. There has already been some dierential cryptanalyses of PRINCE, see for example <a href="#page-24-9">[10]</a>, which is the best attack to date, and also <a href="#page-24-14">[15]</a>. Our attack uses a new method to increase the power of the lter by considering groups of pairs. This allows a rather low data complexity considering that 6-rounds are attacked and that dierential attacks usually demand large amounts of chosen plaintexts.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">4.1 Amplied Dierential Trails</h3>

    <p class="text-gray-300">Our attack rely on some dierences propagating identically in dierent pairs. To better describe this, we introduce the following denitions.</p>

    <p class="text-gray-300">Encryption We call encryption a couple plaintext/ciphertext encrypted under a xed key.</p>

    <p class="text-gray-300">Pair A pair is a set of two encryptions where the plaintexts are separated by a known dierence.</p>

    <p class="text-gray-300">Family A family is a group of pairs with a particular structure. They are generated from a single pair (p[0], ..., p[b − 1]),(p 0 [0], ..., p&lt;sup&gt;0&lt;/sup&gt; [b − 1]) , where p[i] and p 0 [i] are nibbles. Suppose that the input dierence covers the rst three nibbles so that p[3] = p 0 [3] = c[3], ..., p[b − 1] = p 0 [b − 1] = c[b − 1] for some constants c[i]. Then the family corresponding to this pair is made by exchanging some nibbles between the two encryptions in the pair so as to obtain the following pairs:</p>

    <pre><code class="language-text">    (p[0], p[1], p[2], c[3], ..., c[b − 1])
  (p
     0
      [0], p0
             [1], p0
                     [2], c[3], ..., c[b − 1])

                                                       (p
                                                         0
                                                          [0], p[1], p[2], c[3], ..., c[b − 1])
                                                      (p[0], p
                                                               0
                                                                [1], p0
                                                                        [2], c[3], ..., c[b − 1])

   (p[0], p
            0
             [1], p[2], c[3], ..., c[b − 1])
  (p
     0
      [0], p[1], p
                   0
                    [2], c[3], ..., c[b − 1])

                                                      (p[0], p[1], p
                                                                      0
                                                                       [2], c[3], ..., c[b − 1])
                                                     (p
                                                        0
                                                         [0], p0
                                                                [1], p[2], c[3], ..., c[b − 1]).
</code></pre>

    <p class="text-gray-300">Overall, if there are n nibble with non-zero dierences in the input then a family is made of 2 &lt;sup&gt;n&lt;/sup&gt;−&lt;sup&gt;1&lt;/sup&gt; pairs and 2 &lt;sup&gt;n&lt;/sup&gt; encryptions.</p>

    <p class="text-gray-300">In the case of PRINCE, we consider dierential trails where the input differences are only over one column and such that all the pairs in a family follow the same trail for the rst three rounds. For example, the trails we describe in Section <a href="#page-12-0">4.2</a> are either followed by all the elements in a family or none of them. A similar heuristic is used in <a href="#page-24-15">[16]</a> to perform a multiset attack on the SASAS structure.</p>

    <p class="text-gray-300">This behaviour comes from the fact that the transition in the trails we study depend only on the transitions occurring during the rst round, which are the same in all pairs of a family, and on the actual value of some nibbles to which the dierence have not had the time to propagate, which are the same in all encryptions of the structure.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;4.2 Our Trails</h4>

    <p class="text-gray-300">We consider trails which are completely specified during the first 3 rounds and then propagate with probability 1 for 2.5 rounds before having spread to the full internal state. Figure 6 shows a first trail covering 5.5 rounds in this way which we denote  <span class="math">\\mathcal{T}_1</span> . Each array corresponds to the differences between the internal states of two encryptions under 6-round PRINCE and each cell gives the value of the difference: light gray corresponds to a fully specified non-zero value at the nibble level (e.g. a difference of 1), dark gray to an unkown non-zero difference and white to a zero difference. A very similar trail with a probability 2 times smaller,  <span class="math">\\mathcal{T}_2</span> , is given in Figure 14 (see Appendix C). To compute their probabilities, we use the difference distribution matrix of the S-Box. If we let the input difference be (1,1,1,0,...,0), then  <span class="math">\\mathcal{T}_1</span>  has a probability of  <span class="math">2^{-2\\cdot 3} \\cdot 2^{-2} \\cdot 2^{-2-2-3} = 2^{-15}</span>  and  <span class="math">\\mathcal{T}_2</span>  has a probability of  <span class="math">2^{-2\\cdot 3} \\cdot 2^{-2} \\cdot 2^{-2-3-3} = 2^{-16}</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;    <img src="_page_12_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6: The 5.5 rounds trail  <span class="math">\\mathcal{T}_1</span> .</p>

    <p class="text-gray-300">Querying enough families at random to find one right family for any of these would require  <span class="math">(2^{-15} + 2^{-16})^{-1} = 2^{14.41}</span>  families with an input difference over 3 nibbles, i.e.  <span class="math">2^{14.41} \\cdot 2^3 = 2^{17.41}</span>  encryptions. However, we can use structures to decrease this complexity.</p>

    <p class="text-gray-300">We note that the input differences which might lead to an output difference of 1 are those listed in Table 2. As we can see, the second bit from the right</p>

    <p class="text-gray-300">in little-endian notation is only involved in 0x2 and 0xb which, taken together, only have a probability of 1/4 of leading to a dierence of 1. Hence, we use the following structures where b is a bit taking all possible values and c is constant accross the structure:</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">bbcb bbcb bbcb cccc cccc ... cccc.</h3>

    <p class="text-gray-300">We found experimentally that such structures contain several<a href="#page-13-1">3</a> right families with probability 2 &lt;sup&gt;−&lt;/sup&gt;5.&lt;sup&gt;9&lt;/sup&gt; on average when we take into account all possible input dierences, i.e. (δ, δ&lt;sup&gt;0&lt;/sup&gt; , δ&lt;sup&gt;00&lt;/sup&gt; , 0, ..., 0) where δ, δ 0 , δ &lt;sup&gt;00&lt;/sup&gt; ∈ {1, 4, c, d}. Hence, obtaining at least 2 right families only requires about 2 9+5.&lt;sup&gt;9&lt;/sup&gt; = 214.&lt;sup&gt;9&lt;/sup&gt; queries to the encryption oracle on average.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;Table 2: Input dierences which might be mapped to a dierence of 1 by the S-Box of PRINCE.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hexadecimal Binary Probability</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0x1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0001</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0x2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0010</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0x4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0xb</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1011</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0xc</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1100</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0xd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1101</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4.3 Filtering Right Pairs</h3>

    <p class="text-gray-300">Full diusion has been achieved by the 6-th round. Thus, we guess 12 bits to be able to partially invert the last round on one column. More precisely, we rst guess the dierence in one column before the last MixColumns for one pair. Each guess leads to a candidate for the corresponding column of k 0 &lt;sup&gt;0&lt;/sup&gt; ⊕ k&lt;sup&gt;1&lt;/sup&gt; that we try against the three other pairs of the family. A guess leads to the correct nibble having a zero dierence in every pair of the family with probability 2 &lt;sup&gt;−&lt;/sup&gt;3·&lt;sup&gt;4&lt;/sup&gt; = 2&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;12&lt;/sup&gt; . We repeat this independently over each column and obtain either 64 bits of key material or none at all. Since there are either several right families or none at all in the structures we consider, we only return the key guesses which come from several families as well as the corresponding families.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;3&lt;/sup&gt; Actually, a structure of size 2 &lt;sup&gt;12&lt;/sup&gt; where the rst three nibbles take all values contains 64 right families with probability about 2 −5.9 . If we reduce these to form the structures of 2 &lt;sup&gt;9&lt;/sup&gt; plaintext/ciphertext encryptions we described, only some of these 64 families are still present, hence the presence of either 0 or several right families in a structure.</p>

    <p class="text-gray-300">Note this is a powerful filter: while we expect each family from the structure to yield about one 64 bits candidates, the probability to have a collision is very small&lt;sup&gt;4&lt;/sup&gt;.</p>

    <p class="text-gray-300">The same procedure is then used one round earlier to recover 48 bits of  <span class="math">k_1</span> , corresponding to its three first columns. They allow us to partially decrypt the family and check whether differences after the third MixColumns are correct for the three first columns. The probability for a wrong family to pass this test is  <span class="math">2^{-6\\cdot 4\\cdot 4} = 2^{-96}</span> , so we expect to be left with right families only. Finally, the missing 16 bits of  <span class="math">k_1</span>  are recovered by performing an exhaustive search.</p>

    <p class="text-gray-300">Complexity: Querying  <span class="math">2^{5.9}</span>  structures of  <span class="math">2^9</span>  chosen plaintexts to obtain at least 2 right families, the time complexity of the key recovery procedure is around  <span class="math">2^{5.9+9} \\cdot 2^{12} \\cdot 7</span>  partial encryptions, which is equivalent to  <span class="math">2^{29.7} \\cdot \\frac{4}{6\\cdot16} \\approx 2^{25.1}</span>  encryptions. The memory complexity is dominated by the storage of the  <span class="math">2^{14.9}</span>  required to run this attack.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">5.1 Attacking 4-Round PRINCE with a SAT-Solver</h3>

    <p class="text-gray-300"><strong>Encoding PRINCE as a CNF Formula</strong> The idea is to generate a CNF formula where a set p of boolean variables correspond to the 64 bits of the plaintext, c to the 64 bits of the ciphertext and k to the 128 bits of the key, and such that there exists a unique assignment of the variables satisfying the CNF corresponding to the case  <span class="math">E_k(p) = c</span> .</p>

    <p class="text-gray-300">Hence, if we generate such a formula, set the variables in p and k to a chosen value and use a SAT-solver to find an assignment satisfying the CNF formula, the variables in c will correspond to the ciphertext. Solving such a formula is easy, an observation which we can relate to the fact that the evaluation of a block cipher has to be &quot;easy&quot; from the point of view of complexity theory.</p>

    <p class="text-gray-300">Another way to use such a formula is to fix the variables in p and in c according to a known plaintext/ciphertext pair, solve the CNF and recover the key from the variables corresponding to it. Unless the number of rounds is very small (at most 3 in the case of PRINCE), solving such a system is impractical. Again, we can relate this observation to the fact that recovering the key given one or several plaintext/ciphertext pair has to be &quot;hard&quot;. Our approach consists in using some knowledge about the internal state of the cipher to simplify the task of the SAT-solver and make such a resolution possible for a higher number of rounds.</p>

    <p class="text-gray-300">In order to encode a PRINCE encryption as a CNF formula, we introduce several sets of 64 Boolean variables corresponding to each step of each round: one for the internal state at the beginning of the round  <span class="math">(x_r)</span> , one for the internal</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;4&lt;/sup&gt; Each structure yields  <span class="math">2^{9-3}=2^6</span>  families for each of the  <span class="math">4^3</span>  interesting input differences so that we consider the families by groups of  <span class="math">2^{12}</span> . This implies that a collision has a probability of about  <span class="math">\\binom{2^{12}}{2} \\cdot 2^{-64} \\approx 2^{-41}</span> .</p>

    <p class="text-gray-300">state after going throught the S-Box (yr), etc. We also use boolean variables corresponding to the key bits.</p>

    <p class="text-gray-300">Our task is then to create a CNF formula connecting these variables in such a way as to ensure that, for instance if k[0, ..., 63] is xed, it has only one solution where yr[0, ..., 63] is indeed the image of x[0, ..., 63]&lt;sup&gt;r&lt;/sup&gt; by S, etc.</p>

    <p class="text-gray-300">In order to encode the linear layer, we use the alternative representation of M&lt;sup&gt;0&lt;/sup&gt; from <a href="#page-24-9">[10]</a> where it was shown that M&lt;sup&gt;0&lt;/sup&gt; operates on columns of 4-bits independently by rst rotating them by a column-dependent number of bit and then xor-ing the hamming weight of the column in each bit. We thus add variables corresponding to the hamming weights of the columns and encode the corresponding xor's as CNF formulas. The SR operation is only a permutation of the bits so we simply set the corresponding bits to be equal.</p>

    <p class="text-gray-300">The encoding of the S-Box is less simple to obtain. In order to nd the best one, we chose to look for it directly instead of using the ANF as an intermediate step. Indeed, since the S-Box is 4x4, it is small enough for us to brute-force all clauses<a href="#page-15-0">5</a> involving input and output bits and check if they hold for every input.</p>

    <p class="text-gray-300">Doing this lead us to nd 29 clauses with 3 variables. However, they are not sucient to completely specify the S-Box so we used a greedy algorithm to nd the best clauses with 4 variables to add to this encoding. In the end, we have 29 clauses with 3 variables and 9 clauses with 4 variables which are such that the only solutions of the CNF made of all these clauses are all the assignments corresponding to pairs x, S(x) for all x ∈ [0, 15].</p>

    <p class="text-gray-300">These clauses with 3 variables can be interpreted as simple implications. For example, if o[3, ..., 0]&lt;sup&gt;b&lt;/sup&gt; = S(i[3, ..., 0]b) then the following two clauses hold with probability 1 :</p>

    <p class="text-gray-300"><span class="math">$(i[1]_b \\vee o[2]_b \\vee o[3]_b) \\wedge (i[1]_b \\vee o[1]_b \\vee o[2]_b).</span>$</p>

    <p class="text-gray-300">They are logically equivalent to the following implication:</p>

    <p class="text-gray-300"><span class="math">$\\overline{i[1]_b} \\implies \\left( (o[2]_b \\vee o[3]_b) \\wedge (o[1]_b \\vee o[2]_b) \\right).</span>$</p>

    <p class="text-gray-300">Dierential Over Denition The approach consisting in using the knowledge from a dierential trail to ease the task of a SAT-solver used to attack a cryptographic primitive has been explored in <a href="#page-25-0">[17]</a> in order to attack MD4 and MD5. The authors of this paper rst use heuristic methods to nd a high probability dierential trail leading to a collision and then use a SAT-solver to nd a pair of messages which satises this trail. In the same paper, we can nd the following observation:</p>

    <p class="text-gray-300">An interesting result of our experiments with SAT solvers is the importance of having a dierential path encoded in the formula.</p>

    <p class="text-gray-300">As we shall see, this also holds for block ciphers. Attacking 4 rounds PRINCEcore takes more than 10 hours if we simply encode as a CNF that some plaintext</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;5&lt;/sup&gt; A clause is the logical OR of several variables, e.g. a ∨ b, a, a ∨ b ∨ c where x is the negation of x.</p>

    <p class="text-gray-300">are encrypted into known ciphertexts but we can both drastically reduce this time while breaking PRINCE with its whitening keys using dierential overdenition.</p>

    <p class="text-gray-300">Denition 2. We call Dierential Over Denition (or DOD) the following algorithm which simplies a CNF formula knowing that the variables correspond to bits of the internal state of an encryption following a certain trail.</p>

    <p class="text-gray-300">For all pairs of variables in the CNF, proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If they are assumed to be equal, replace all occurrences of the rst one by the second one.</li>
      <li>If they are assumed to be dierent, replace all occurrences of the rst one by the negation of the second one.</li>
    </ul>

    <p class="text-gray-300">While the idea behind this algorithm is simple, it is necessary for cryptographers to implement it eciently by hand. Indeed, the only input of a SAT-solver is a CNF formula, i.e. merely a list of clauses from which deriving what variables are equal to each other without knowledge of the structure of the problem is far from trivial. For instance, it would be necessary for the SAT-solver to understand that the set of clauses used to model one S-Box call all correspond to a unique function so that identical inputs lead to identical outputs; all this without having any distinction between the input and output bits. That is why dierential over-denition, an easy algorithm for the cryptographer to implement, is a valuable pre-processing step when using a SAT-solver for cryptography leading to gains in time complexity of several orders of magnitude.</p>

    <p class="text-gray-300">This algorithm can be implemented eciently using a hashtable containing the correspondences between the variables. Once this algorithm has been run, the CNF is over dened: the solution would have been such that the equalities hold anyway but there are less variables and less clauses in the CNF. However, if the pair actually does not follow the trail, the CNF has become unsatisable. This is a dierence between our work and the one described in <a href="#page-25-0">[17]</a>: we do not always know before hand if the CNF has a solution. We can think of this as a trade-o between solving one CNF known to be true and solving many overdened CNF's which may or may not be true: the second approach loses time by requiring several calls to a SAT-solver but these calls take less time thanks to the over-denition.</p>

    <p class="text-gray-300">Such an over denition can be used in dierent ways.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Propagating only the zero dierences holding with probability 1 inside a group of 8 encryptions with many zero dierences is enough to reduce the time complexity of an attack on 4 rounds from more than 10 hours to a few seconds (see below). Furthermore, such a formula is always true.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instead of implementing an algorithm recovering the key from a pair following a particular trail by peeling of layer after layer of encryption in our attack on 6 rounds described in the remainder of this section, we simply re-used the code of our attack on 4 rounds and over-dened the CNF modeling the encryptions of right pairs according to the high probability trail we used.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We implemented the attack described in Algorithm 1 to attack 4-round PRINCE (with its whitening keys) using the SAT-solver Minisat [18] and obtained an average total time of 5.13s and average time spent solving the CNF of 3.06s. The designers of PRINCE did not consider SAT-based attacks but they did investigate algebraic attacks. They manage to attack 4-round PRINCE-core in less than 2s while our attack requires about 5s to attack 4-round PRINCE, a cipher which uses twice as much key material.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;<strong>Algorithm 1</strong> Using Differential over-Definition to enable an attack on 4-round PRINCE.</p>

    <p class="text-gray-300">Query 2&lt;sup&gt;10&lt;/sup&gt; plaintext/ciphertexts where the first 10 bits take all possible values. Select a subset of 8 plaintext/ciphertext maximizing the number of 0-differences in the output.</p>

    <p class="text-gray-300">Encode the 8 encryptions as a CNF A.</p>

    <p class="text-gray-300">Overdefine A by propagating zero-differences with probability 1.</p>

    <p class="text-gray-300">Use a SAT-solver to retrieve the key bits from A</p>

    <p class="text-gray-300"><strong>return</strong>  <span class="math">k_0||k_1</span></p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">5.2 Differential Attacks on 6-Round PRINCE</h4>

    <p class="text-gray-300">Another use possible use for a SAT-solver is the handling of the tedious details of an actual attack implementation, e.g. the finding of an efficient guessing strategy. We illustrate this by performing the recovery of the second chunk of the master key in our 6-round differential attack using a SAT-solver. Pseudo-code describing this attack on 6-round PRINCE is provided in Algorithm 2.</p>

    <p class="text-gray-300">We ran this attack 10 times and found that about  <span class="math">2^{5.75}</span>  structures were needed on average. The filtering step is the most time consuming: finding a right pair requires about 6 minutes while the SAT-solver requires about 0.5s to recover the full key or (rarely) to discard the pair. For this reason, we approximate the complexity of this attack by the complexity of its filtering step. Memory complexity is dominated by the SAT-solver but is (well) below 1 Go, i.e. (well) below  <span class="math">2^{27}</span>  64-bits blocks.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;6 Structural Analysis of PRINCE</h3>

    <p class="text-gray-300">The  <span class="math">\\alpha</span> -reflection introduced along with PRINCE [5] is the name given to the following property of a block cipher  <span class="math">E_k</span> :  <span class="math">E_k^{-1} = E_{k \\oplus \\alpha}</span> . In other words there is a constant  <span class="math">\\alpha</span>  such that decryption for a key k is the same operation as encryption under key  <span class="math">k \\oplus \\alpha</span> . PRINCE-core implements this property by having a three-parts structure as decribed here:</p>

    <p class="text-gray-300"><span class="math">$E_{c,k_1} = F_{k_1 \\oplus \\alpha}^{-1} \\circ I \\circ F_{k_1},</span>$</p>

    <p class="text-gray-300">where  <span class="math">F_k</span>  corresponds to 5 rounds of a classical Substitution-Permutation Network construction and where I is an involution.</p>

    <p class="text-gray-300">Since we are going to study the structure of the cycles of different functions in a fashion similar to the way Biryukov analysed the inner-rounds of some involutional ciphers in [19], we define the cycle type of a permutation.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> The cycle type of a permutation  <span class="math">\\pi</span>  is an (ordered) multiset containing the cycle lengths of the permutation. The cycle type of  <span class="math">\\pi</span>  is denoted by  <span class="math">\\mathcal{L}(\\pi)</span> .</p>

    <p class="text-gray-300">In what follows, we do not represent the round constants for the sake of simplicity. However, not only do our result hold in their presence but we could actually generalize them to any key schedule preserving the fact that the subkeys of symmetric rounds have a XOR equal to  <span class="math">\\alpha</span> .</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">6.1 Small Cycles in Round-Reduced PRINCE</h3>

    <p class="text-gray-300">The central involution is  <span class="math">I = S^{-1} \\circ M&#x27; \\circ S</span> . Therefore, it is isomorphic to M', a linear involution operating on each column of the internal state independently. It is easy to check experimentally the result given in [7] stating that M' has exactly  <span class="math">2^{32}</span>  fixed points, meaning that I also has  <span class="math">2^{32}</span>  fixed points. Therefore, I has  <span class="math">2^{32}</span>  cycles of length 1 and  <span class="math">2^{63} - 2^{31}</span>  cycles of length 2.</p>

    <p class="text-gray-300">The cycle type of  <span class="math">I^{\\alpha}: x \\mapsto I(x) \\oplus \\alpha</span>  is more sophisticated but still contains a fair amount of small cycles. After noting that both I and  <span class="math">x \\mapsto x \\oplus \\alpha</span>  operate on each column of the internal space independently, we denote  <span class="math">I_i^{\\alpha}</span>  the restriction of  <span class="math">x \\mapsto I(x) \\oplus \\alpha</span>  to column i and  <span class="math">I_i</span>  that of I. Since each of the  <span class="math">I_i^{\\alpha}</span> 's operates only on a space of size  <span class="math">2^{16}</span> , it is easy to generate their complete cycle structures independently by searching the whole space. Each  <span class="math">I_i^{\\alpha}</span>  has a cycle type made of many &quot;small&quot; cycles, the largest having a length of 2844. This is explained by the fact that both I and  <span class="math">x \\mapsto x \\oplus \\alpha</span>  are involutions and each column of I has exactly  <span class="math">2^8</span>  fixed points. Thus, most of the cycles have a particular structure described in [20] which we recall in Figure 7. We remark that to each cycle of  <span class="math">I_i^{\\alpha}</span>  correspond two fixed points of  <span class="math">I_i</span> .</p>

    <p class="text-gray-300">After generating the cycle type for each  <span class="math">I_i^{\\alpha}</span> , we combine them to obtain the cycle type of  <span class="math">x\\mapsto I(x)\\oplus \\alpha</span>  using Algorithm 3. The cycle type of this function is too complex to be printed completely but some information extracted from it is given in Table 3. If we pick x uniformly at random, the expected length of the cycle it is on is  <span class="math">2^{30.7}</span> .</p>

    <p class="text-gray-300">Recall that  <span class="math">E_{k_1}^{c,4}</span>  is the permutation of  <span class="math">\\{0,1\\}^{64}</span>  corresponding to an encryption under key  <span class="math">k_1</span>  by PRINCE-core reduced to 4 rounds. Then  <span class="math">x\\mapsto E_{k_1}^{c,4}(x)\\oplus\\alpha</span>  has the same cycle type as  <span class="math">I^\\alpha</span>  due to the cancellation of the last round of one encryption with the first round of the next. Indeed, to each cycle of this function corresponds one of  <span class="math">I^\\alpha</span> , as illustrated in Figure 8 where a cycle  <span class="math">(x_0,x_1,x_2,x_3)</span>  of length 4 of  <span class="math">x\\mapsto E_{k_1}^{c,4}</span>  is represented along with the corresponding cycle of  <span class="math">I^\\alpha</span>  (dashed line).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt; While there are some cycles which do not have this structure, they are a small minority: for  <span class="math">f_0</span> , 256 elements out of 65536 are on such cycles, 64 for  <span class="math">f_1</span> , 8 for  <span class="math">f_2</span>  and 194 for  <span class="math">f_3</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;    <img src="_page_19_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7: The structure of a cycle of  <span class="math">I_i^{\\alpha}</span>  for  <span class="math">i \\in [0,3]</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cycle Length <span class="math">\\ell</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\#\\{\\text{cycles of length}\\ell\\}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">P[\\ell(x) = \\ell, x \\text{ drawn uniformly}]</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-57}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{10.25}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-53.75}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{15.46}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-48.54}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10080</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{33.06}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-17.63}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">110880</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{31.96}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-15.27}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leq 2^{10}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-22.4}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leq 2^{15}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-12.4}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\leq 2^{24}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-4.1}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Information about the cycle type of  <span class="math">I^{\\alpha}</span> , where  <span class="math">\\ell(x)</span>  is the length of the cycle on which x is.</p>

    <p class="text-gray-300">A first consequence of these observations is the existence of a distinguisher for 4-round PRINCE-core requiring about  <span class="math">2^{27.4}</span>  adaptatively chosen plaintexts. As stated in Table 2, an element picked at random is on a cycle of length at most  <span class="math">2^{15}</span>  with probability  <span class="math">2^{-12.4}</span> . Therefore, we repeat multiple times the experiment consisting in picking an element x uniformly at random and then check if it is on a cycle of length at most  <span class="math">2^{15}</span>  by iterating  <span class="math">x\\mapsto E_{k_1}^{c,4}(x)\\oplus\\alpha</span>  at most  <span class="math">2^{15}</span>  times. The experiment is a success if x is on a cycle of length at most  <span class="math">2^{15}</span> . If the permutation is  <span class="math">E_{k_1}^{c,4}</span>  for some  <span class="math">k_1</span> , then its probability of success is  <span class="math">2^{12.4}</span>  but if the permutation is a random permutation&lt;sup&gt;7&lt;/sup&gt;, then the probability of success becomes  <span class="math">2^{-49}</span> . We confirmed experimentally the success probability of this experiment for  <span class="math">E_{k_1}^{c,4}</span> .</p>

    <p class="text-gray-300">A second consequence is the existence of &quot;small&quot; sets of plaintext/ciphertext encryptions where the set of the ciphertexts is the image of the set of the encryptions by a function significantly simpler than a PRINCE encryption. This topic is studied in the next section.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;7&lt;/sup&gt; Recall that the probability for x to be on a cycle of length  <span class="math">\\ell</span>  for a permutation of [0, N-1] is equal to 1/N. Hence, the probability that the length is smaller than  <span class="math">2^{15}</span>  for a permutation of  <span class="math">[0, 2^{64} - 1]</span>  is  <span class="math">\\sum_{\\ell=1}^{2^{15}} 2^{-64} = 2^{-49}</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;    <img src="_page_20_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8: Correspondance between a cycle of x 7→ E c,4 k&lt;sup&gt;1&lt;/sup&gt; (x) ⊕ α and a cycle of I α.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">6.2 Simplications of PRINCE's Representation</h3>

    <p class="text-gray-300">The particular cycle types of the round-reduced versions of PRINCE studied above lead to simpler alternative representations of the encryption algorithm.</p>

    <p class="text-gray-300">Consequences of the Cycle Type of I Suppose that an encryption is such that the input of I is one of the 2 &lt;sup&gt;32&lt;/sup&gt; xed-points of this function. Then the key addition before and after this function cancel each other so that only the addition of α remains. Then, since M is linear, the operations M&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; ◦ (⊕α) ◦ M become simply the addition of M&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; (α). Thus, the 4 center rounds minus the rst and last key addition become a simple S-Box layer which we denote S &lt;sup&gt;0&lt;/sup&gt; and which is dened by</p>

    <p class="text-gray-300"><span class="math">$S&#x27;(x) = S^{-1}(S(x) \\oplus M^{-1}(\\alpha)).</span>$</p>

    <p class="text-gray-300">This simplifying process is summarized in Figure <a href="#page-21-0">9.</a> Note that if M&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; (α) has any nibble equal to 0 then the function S 0 is the identity for this nibble. However, for the value of α chosen by the designers of PRINCE, there is no such nibble.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;    <img src="_page_21_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 9: Simplication of the 4 center-rounds if the input of I is a xed point.</p>

    <p class="text-gray-300">The simplication goes further. Indeed, since S &lt;sup&gt;0&lt;/sup&gt; operates only at the nibble level, it commutes with the operations SR and SR&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; (up to a reordering of the S-Boxes in S 0 ). Therefore, if we add one round before and one round after S 0 , we can replace SR&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; ◦ S &lt;sup&gt;0&lt;/sup&gt; ◦ SR by S &lt;sup&gt;00&lt;/sup&gt; where S &lt;sup&gt;00&lt;/sup&gt; is another S-Box layer. Hence, 6-round of PRINCE operate on each column of the internal state independently: each output bit depends only on 16 bits of the input, 28 bits<a href="#page-21-1">8</a> of k&lt;sup&gt;1&lt;/sup&gt; and at most 18 bits of k0. This simplication is summarized in Figure <a href="#page-21-2">10.</a></p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-2&quot;&gt;&lt;/span&gt;    <img src="_page_21_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 10: Simplication of the 6 center-rounds if the input of I is a xed point.</p>

    <p class="text-gray-300">Similar simplications occur if instead of having a xed point we have a particular collision between two encryptions. This setting corresponds to the socalled mirror slide attack described by Dunkelman et al. in <a href="#page-25-4">[21]</a>. Consider two</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;8&lt;/sup&gt; In each column, 16 bits from the corresponding column of k&lt;sup&gt;1&lt;/sup&gt; are used as well as 16 bits from the corresponding column of SR&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; (k1). Since the top nibble of these two sets is the same, we are left with 32 − 4 = 28 bits.</p>

    <p class="text-gray-300">encryptions  <span class="math">(p^0,c^0)</span>  and  <span class="math">(p^1,c^1)</span>  by PRINCE-core as follows</p>

    <p class="text-gray-300"><span class="math">$c^{0} = E_{c,k_{1}}(p^{0}) = (F_{k_{1} \\oplus \\alpha}^{-1} \\circ I \\circ F_{k_{1}})(p^{0})</span>$</p>

    <p class="text-gray-300"><span class="math">$c^{1} = E_{c,k_{1}}(p^{1}) = (F_{k_{1} \\oplus \\alpha}^{-1} \\circ I \\circ F_{k_{1}})(p^{1})</span>$</p>

    <p class="text-gray-300">which are such that  <span class="math">F_{k_1}(p^0) = I(F_{k_1}(p^1))</span> . In this case, we have that</p>

    <p class="text-gray-300"><span class="math">$c^{0} = (F_{k_{1} \\oplus \\alpha}^{-1} \\circ F_{k_{1}})(p^{1})</span>$</p>

    <p class="text-gray-300"><span class="math">$c^{1} = (F_{k_{1} \\oplus \\alpha}^{-1} \\circ F_{k_{1}})(p^{0}),</span>$</p>

    <p class="text-gray-300">where 6 rounds of  <span class="math">F_{k_1 \\oplus \\alpha}^{-1} \\circ F_{k_1}</span>  can be simplified exactly as described and therefore only operate on each column separately.</p>

    <p class="text-gray-300">In conclusion, if an encryption is such that the input of I is a fixed-point of this function or if two encryptions form a mirror slide pair, then 4 rounds of PRINCE consist simply in 16 parallel operations on each nibble and 6 rounds of PRINCE in 4 parallel operations on each column.</p>

    <p class="text-gray-300">Consequences of the Cycle type of  <span class="math">I^{\\alpha}</span>  Consider a sequence of plaintexts  <span class="math">(p^0,\\ldots,p^{\\ell-1})</span>  and their corresponding ciphertexts  <span class="math">(c^0,\\ldots,c^{\\ell-1})</span>  such that the input  <span class="math">x_5^i \\oplus k_1</span>  of the sixth round for the plaintext  <span class="math">p^i</span>  is the image of  <span class="math">x_5^{i-1} \\oplus k_1</span>  by  <span class="math">I^{\\alpha}</span> . We call such a sequence a <em>cycle set</em> and we give a representation of such a sequence on Figure 11: if two values are equal then they are connected by a line; red lines correspond to the cycle of  <span class="math">I^{\\alpha}</span>  this set is built out of and blue lines correspond to the propagation of these equalities through identical operations, namely  <span class="math">x \\mapsto k_1 \\oplus R^{-1}(x \\oplus k_1)</span> .</p>

    <p class="text-gray-300">There is a unique function mapping  <span class="math">p^i</span>  to  <span class="math">c^{i-1}</span>  in every cycle set which corresponds to the encryption algorithm where the 4 center-rounds have been removed and replaced by a simple addition of  <span class="math">\\alpha</span> . This means that this function undergoes the simplifications described above except that these cover 2 more rounds. In particular, for 6-round PRINCE-core, the function mapping  <span class="math">p^i</span>  to  <span class="math">c^{i-1}</span>  only operates at the nibble level and, for 8-round PRINCE-core, it operates at the column level. At least 10 rounds are necessary to obtain full diffusion out of the 12 PRINCE has.</p>

    <p class="text-gray-300">The cycle sets we consider cover the 4 center-rounds of PRINCE but it is possible to generalize this construction to an arbitrary amount of rounds. However, the cycle set sizes are abnormaly small in this case because of the cycle type of  <span class="math">I^{\\alpha}</span> . Indeed, a random plaintext/ciphertext pair is in a cycle set of size  <span class="math">2^{30.7}</span>  and in a cycle set of size smaller than  <span class="math">2^{15}</span>  with probability  <span class="math">2^{-12.4}</span> . In other cases, including a priori if we have a cycle covering at least 6 rounds, the expected size of a cycle set is the expected size of the cycle of a random permutation a random element is on, namely  <span class="math">2^{63}</span> .</p>

    <p class="text-gray-300">Should the cycle sets of PRINCE become identifiable, the security of up to 8 rounds may be compromised as the alternative versions of the cipher we described in this Section are much weaker than the original cipher. Furthermore, since small cycles are not unlikely to be found, the data complexity of such an attack may remain feasible.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;    <img src="_page_23_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 11: A cycle set of 6-round PRINCE-core.</p>

    <p class="text-gray-300">We looked for practical attacks which would hinder the security provided by round-reduced versions of PRINCE in a realistic framework provided by the designers of this cipher. We found that approaches based on a Meet-in-the-Middle, SAT-based or, surprisingly, dierential framework can all lead to practical attacks on up to half of the rounds. We checked our results by actually implementing one of our attacks. As a matter of fact, our attacks were the best submitted to the PRINCE-challenge for 4, 6 and 8 rounds. Furthermore, during our investigations on PRINCE we discovered a new attack on 10 rounds which despite its data complexity of 2 &lt;sup&gt;57&lt;/sup&gt; chosen plaintexts has a reasonable complexity and a very (very!) motivated adversary could run it.</p>

    <p class="text-gray-300">We also identied some simplications of the encryption occurring because of the small cycles of the inner-rounds of this block cipher, thus shedding new light on the consequences of the α-reection as it is implemented in PRINCE.</p>

    <p class="text-gray-300">The authors thank Alex Biryukov for useful discussions about the dierential attack on PRINCE. We also thank NXP Semiconductors for organizing the PRINCE challenge and sending us our rewards! The work of the authors was supported by the CORE ACRYPT project (ID C12-15-4009992) funded by the Fonds National de la Recherche (Luxembourg).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;1. Biham, E., Shamir, A.: Dierential cryptanalysis of DES-like cryptosystems. Journal of CRYPTOLOGY 4(1) (1991) 372</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;2. Matsui, M.: Linear cryptoanalysis method for DES cipher. In: Advances in Cryptology - EUROCRYPT 93, Workshop on the Theory and Application of of Cryptographic Techniques, Lofthus, Norway, May 23-27, 1993, Proceedings. (1993) 386 397</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;3. Demirci, H., Selçuk, A.A.: A meet-in-the-middle attack on 8-round AES. In: Fast Software Encryption, Springer (2008) 116126</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-3&quot;&gt;&lt;/span&gt;4. Semiconductors, N.: The PRINCE challenge. <a href="https://www.emsec.rub.de/research/research_startseite/prince-challenge/">https://www.emsec.rub.de/</a> <a href="https://www.emsec.rub.de/research/research_startseite/prince-challenge/">research/research\\_startseite/prince-challenge/</a> (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-4&quot;&gt;&lt;/span&gt;5. Borgho, J., Canteaut, A., Güneysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., et al.: PRINCE a low-latency block cipher for pervasive computing applications. In: Advances in CryptologyASIACRYPT 2012. Springer (2012) 208225</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-5&quot;&gt;&lt;/span&gt;6. Biryukov, A., Perrin, L.: State of the art in lightweight cryptography. <a href="http://cryptolux.org/index.php/Lightweight_Cryptography">http:</a> <a href="http://cryptolux.org/index.php/Lightweight_Cryptography">//cryptolux.org/index.php/Lightweight\\_Cryptography</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-6&quot;&gt;&lt;/span&gt;7. Soleimany, H., Blondeau, C., Yu, X., Wu, W., Nyberg, K., Zhang, H., Zhang, L., Wang, Y.: Reection cryptanalysis of PRINCE-like ciphers. Journal of Cryptology (2013) 127</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-7&quot;&gt;&lt;/span&gt;8. Jean, J., Nikoli¢, I., Peyrin, T., Wang, L., Wu, S.: Security analysis of prince. In: Fast Software Encryption: 20th International Workshop, FSE 2013, Singapore, March 11-13, 2013. Revised Selected Papers. Volume 8424., Springer (2014) 92</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-8&quot;&gt;&lt;/span&gt;9. Li, L., Jia, K., Wang, X.: Improved meet-in-the-middle attacks on aes-192 and prince. Cryptology ePrint Archive, Report 2013/573 (2013) <a href="http://eprint.iacr.org/">http://eprint.iacr.</a> <a href="http://eprint.iacr.org/">org/.</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-9&quot;&gt;&lt;/span&gt;10. Canteaut, A., Fuhr, T., Gilbert, H., Naya-Plasencia, M., Reinhard, J.R.: Multiple dierential cryptanalysis of round-reduced PRINCE (full version). Cryptology ePrint Archive, Report 2014/089 (2014) <a href="http://eprint.iacr.org/">http://eprint.iacr.org/.</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-10&quot;&gt;&lt;/span&gt;11. Rechberger, C.: Update on the 10000 euro PRINCE cipher-breaking challenge: Results of round-1. <a href="http://crypto.2014.rump.cr.yp.to/d037206eda8f9278cef1ea26cd62e51f.pdf">http://crypto.2014.rump.cr.yp.to/</a> <a href="http://crypto.2014.rump.cr.yp.to/d037206eda8f9278cef1ea26cd62e51f.pdf">d037206eda8f9278cef1ea26cd62e51f.pdf</a> (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-11&quot;&gt;&lt;/span&gt;12. Dunkelman, O., Keller, N., Shamir, A.: Improved single-key attacks on 8-round AES-192 and AES-256. In: Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings. (2010) 158176</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-12&quot;&gt;&lt;/span&gt;13. Derbez, P., Fouque, P.: Exhausting Demirci-Selçuk meet-in-the-middle attacks against reduced-round AES. In: Fast Software Encryption - 20th International Workshop, FSE 2013, Singapore, March 11-13, 2013. Revised Selected Papers. (2013) 541560</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-13&quot;&gt;&lt;/span&gt;14. Derbez, P., Fouque, P.A., Jean, J.: Improved Key Recovery Attacks on Reduced-Round AES in the Single-Key Setting. In Johansson, T., Nguyen, P.Q., eds.: EU-ROCRYPT. Volume 7881 of Lecture Notes in Computer Science., Springer (2013) 371387</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-14&quot;&gt;&lt;/span&gt;15. Abed, F., List, E., Lucks, S.: On the security of the core of prince against biclique and dierential cryptanalysis. Cryptology ePrint Archive, Report 2012/712 (2012) <a href="http://eprint.iacr.org/">http://eprint.iacr.org/.</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-15&quot;&gt;&lt;/span&gt;16. Biryukov, A., Shamir, A.: Structural cryptanalysis of SASAS. In Ptzmann, B., ed.: Advances in Cryptology EUROCRYPT 2001. Volume 2045 of Lecture Notes in Computer Science. Springer Berlin Heidelberg (2001) 395405</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;17. Mironov, I., Zhang, L.: Applications of sat solvers to cryptanalysis of hash functions. In Biere, A., Gomes, C., eds.: Theory and Applications of Satisability Testing - SAT 2006. Volume 4121 of Lecture Notes in Computer Science. Springer Berlin Heidelberg (2006) 102115</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;18. Eén, N., Sörensson, N.: An extensible SAT-solver. In: Theory and applications of satisability testing, Springer (2004) 502518</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;19. Biryukov, A.: Analysis of involutional ciphers: Khazad and Anubis. In: Fast Software Encryption, Springer (2003) 4553</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;20. Moore, J.H., Simmons, G.J.: Cycle structure of the DES with weak and semi-weak keys. In: Advances in CryptologyCRYPTO'86, Springer (1987) 932</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-4&quot;&gt;&lt;/span&gt;21. Dunkelman, O., Keller, N., Shamir, A.: Minimalism in cryptography: the evenmansour scheme revisited. In: Advances in CryptologyEUROCRYPT 2012. Springer (2012) 336354</p></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;Algorithm 2 Using trails T1, T&lt;sup&gt;2&lt;/sup&gt; and a SAT-solver to recover the complete key k0||k&lt;sup&gt;1&lt;/sup&gt; of 6-round PRINCE.</p>

    <pre><code class="language-text">while the key has not been retrieved do
   Query a structure S =

                            (p
                              0
                               , c0
                                  ), ...,(p
                                         2
                                          12−1
                                              , c2
                                                 12−1

   H ← empty hashtable of lists of families indexed by 64-bits integers
   for all families F in S do
      for one pair in F do
          for all columns of the internal state do
             for all the 2
                          12 possible dierences do
                 Deduce the corresponding 16-bit key material k16
                 for all remaining pairs in F do
                    Invert key addition for the column using k16
                    Invert S
                             −1
                                for the column
                    Invert M0
                               for the column
                 end for
                 if correct nibble has zero dierence in all pairs then store k16
             end for
          end for
      end for
      Combine all guesses from each column into 64-bits guesses
      for all 64-bits guesses k64 append F to H[k64]
   end for
   for all k64 among the keys of H do
      if H[k64] contains strictly more than 1 element then
          for all families F in H[k64] do
             Generate a CNF A encoding all encryptions in F with same key such
that k1 + L(k0) = k64.
             for all trails T in {T1, T2} do
                 B ← DoD(A, T)
                 if B is satisable then retrieve k0||k1 from the solution of B and
return it
             end for
          end for
      end if
   end for
end while
</code></pre>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;Algorithm 3 Generating the cycle type of I &lt;sup&gt;α&lt;/sup&gt; from those of its columns.</h4>

    <pre><code class="language-text">for i ∈ [0, 3] do
   Li ← List of the cycle length of I
                                       α
                                       i
end for
L ← Hashtable indexed by integers
for (\`0, \`1, \`2, \`3) ∈ L0 × L1 × L2 × L3 do
   \` ← lcm
             \`0, \`1, \`2, \`3

   L[\`] ← L[\`] + \`
                   −1
                      ·
                       Q3
                          i=0 \`i
end for
return L
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;    <img src="_page_27_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 12: 6r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;B The Second 8-round Attack</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;    <img src="_page_27_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 13: 8r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-28-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;C The Second 5.5 Rounds Trail</h3>

    <p class="text-gray-300">    <img src="_page_28_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 14: The second 5.5 rounds trail  <span class="math">\\mathcal{T}_2</span> .</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;D Simple Meet-in-the-Middle Attacks</h3>

    <p class="text-gray-300">In this section we describe two attacks on round-reduced Prince. Both are simple meet-in-the-middle attacks requiring only few known plaintext/ciphertext pairs to work.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">D.1 4-round Attack</h3>

    <p class="text-gray-300"><strong>Simple Attack.</strong> We begin by presenting a simple attack on 4-round Prince with a complexity around  <span class="math">2^{40}</span>  which is depicted on Figure 15. It is based on the two following equations involving few bits of the middle states y and y':</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} y[38]_b \\oplus y[46]_b = y&#x27;[38]_b \\oplus y&#x27;[46]_b \\\\ y[39]_b \\oplus y[43]_b \\oplus y[47]_b = y&#x27;[47]_b \\end{cases}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">K_p</span>  (resp.  <span class="math">K_c</span> ) be the key bits required to compute  <span class="math">y[38]_b \\oplus y[46]_b</span>  and  <span class="math">y[39]_b \\oplus y[43]_b \\oplus y[47]_b</span>  from p (resp.  <span class="math">y&#x27;[38]_b \\oplus y&#x27;[46]_b</span>  and  <span class="math">y&#x27;[47]_b</span>  from p). Then the attacks scenario is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ask for n known plaintext/ciphertext pairs.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let T be an empty hash table.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all possible values of  <span class="math">K_p</span>  do</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) for j from 1 to n compute  <span class="math">y^j[38]_b \\oplus y^j[46]_b</span>  and  <span class="math">y^j[39]_b \\oplus y^j[43]_b \\oplus y^j[47]_b</span>  from the j-th plaintext</li>
      <li>(b) make the sequence  <span class="math">s = [y^1[38]_b \\oplus y^1[46]_b, y^1[39]_b \\oplus y^1[43]_b \\oplus y^1[47]_b, \\dots]</span></li>
      <li>(c) add the value of  <span class="math">K_p</span>  to  <span class="math">T[s]_b</span></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all possible values of  <span class="math">K_c</span>  do</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) for j from 1 to n compute  <span class="math">y&#x27;^j[38]_b \\oplus y&#x27;^j[46]_b</span>  and  <span class="math">y^j[47]_b</span>  from the j-th ciphertext</li>
      <li>(b) make the sequence  <span class="math">s = [y&#x27;^1[38]_b \\oplus y&#x27;^1[46]_b, y&#x27;^1[47]_b, \\ldots]</span></li>
      <li>(c) check whether T[s] is empty or not. If T[s] is empty then the guess of  <span class="math">K_c</span>  is wrong. Otherwise, T[s] contains the possible value(s) for  <span class="math">K_p</span>  and, if n is large enough, this will happen only for the right guess.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;    <img src="_page_29_Figure_10.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 15: 4r attack. Hatched bits play no role.</p>

    <p class="text-gray-300">In our case, both  <span class="math">K_p</span>  and  <span class="math">K_c</span>  can assume only  <span class="math">2^{40}</span>  values and thus 40 plaintext/ciphertext pairs are enough to get only one candidate for  <span class="math">K_p \\cup K_c</span>  with high probability. Thus the complexity of this attack is 40 known plaintexts and around  <span class="math">2^{40}</span>  for both time and memory.</p>

    <p class="text-gray-300"><strong>Saving data and memory.</strong> First we stress that  <span class="math">K_P</span>  (resp.  <span class="math">K_C</span> ) can be safely replaced by any basis of the vector space spawned by itself so let consider it as a vector space over  <span class="math">\\mathbb{F}_2</span> . Now we are interested by the vector space  <span class="math">K_P \\cap K_C</span> . Here a basis of this vector space is:</p>

    <p class="text-gray-300"><span class="math">$\\{k_1[36..39]_b, k_1[44..47]_b, k_0[37..39]_b, k_0[45..47]_b, k_0[40]_b \\oplus \\ldots \\oplus k_0[44]_b \\oplus k_1[40]_b \\oplus \\ldots \\oplus k_1[43]_b\\}.</span>$</p>

    <p class="text-gray-300">Thus only 33 plaintext/ciphertext pairs are needed to discard the wrong guesses and the attack scenario becomes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ask for n known plaintext/ciphertext pairs.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For all possible values of  <span class="math">K_p \\cap K_c</span>  do</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Let T be an empty hash table.</li>
    </ul></li>
      <li><p class="text-gray-300">(b) Partially encrypt/decrypt the plaintext/ciphertext pairs.</p></li>
      <li><p class="text-gray-300">(c) For all possible values of  <span class="math">K_p</span>  do</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. for j from 1 to n compute  <span class="math">y^j[38]_b \\oplus y^j[46]_b</span>  and  <span class="math">y^j[39]_b \\oplus y^j[43]_b \\oplus y^j[47]_b</span>  from the j-th plaintext</li>
      <li>ii. make the sequence  <span class="math">s = \\left[y^1[38]_b \\oplus y^1[46]_b, y^1[39]_b \\oplus y^1[43]_b \\oplus y^1[47]_b, \\ldots\\right]</span></li>
      <li>iii. add the value of  <span class="math">K_p</span>  to T[s]</li>
    </ul></li>
      <li><p class="text-gray-300">(d) For all possible values of  <span class="math">K_c</span>  do</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. for j from 1 to n compute  <span class="math">y&#x27;^j[38]_b \\oplus y&#x27;^j[46]_b</span>  and  <span class="math">y^j[47]_b</span>  from the j-th ciphertext</li>
      <li>ii. make the sequence  <span class="math">s = [y&#x27;^{1}[38]_{b} \\oplus y&#x27;^{1}[46]_{b}, y&#x27;^{1}[47]_{b}, \\ldots]</span></li>
      <li>iii. check whether T[s] is empty or not. If T[s] is empty then the guess of  <span class="math">K_c</span>  is wrong. Otherwise, T[s] contains the possible value(s) for  <span class="math">K_p</span>  and, if n is large enough, this will happen only for the right guess.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">All in all the memory requirement is approximately  <span class="math">25 \\times 2^{25} \\times 2^{-3} \\approx 2^{26.7}</span>  bytes and the time complexity around  <span class="math">33 \\times 2 \\times 2^{40} \\times 40/(4 \\times 64) \\approx 2^{43.4}</span>  encryptions.</p>

    <p class="text-gray-300"><strong>Key recovery.</strong> At the end of the attack we know (or have very few candidates for)  <span class="math">K_p \\cup K_c</span> . But we still need 128-65=63 key bits to fully recover  <span class="math">k_0</span>  and  <span class="math">k_1</span> . Performing an exhaustive search at this point would increase the overall complexity of the attack and thus is not a good idea. Instead, it is better to perform another meet-in-the-middle attacks successively. For instance, the attack depicted in Figure 16 allows to recover 20 more key bits with a time complexity around  <span class="math">2^{20}</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;    <img src="_page_30_Figure_11.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 16: 4r attack. black bits are known. Hatched bits play no role.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">D.2 6-round Attack</h4>

    <p class="text-gray-300">The 4-round attack can be extended to a 6-round attack as depicted on Figure 17. Now the dimension of both  <span class="math">K_p</span>  and  <span class="math">K_c</span>  is 96 and the dimension of the intersection is 64. Thus it leads to an attacks requiring  <span class="math">(2 \\times 96 - 64)/2 = 64</span>  known plaintext/ciphertext pairs, with a memory complexity around  <span class="math">(96-64) \\times 2^{96-64} \\times 2^{-3} = 2^{34}</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-1&quot;&gt;&lt;/span&gt;    <img src="_page_31_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 17: 6r attack. Hatched bits play no role.</p>

    <p class="text-gray-300">bytes and a time complexity of approximately  <span class="math">2\\times64\\times2^{96}\\times104/(6\\times64)\\approx2^{101.1}</span>  encryptions.</p>

    <p class="text-gray-300">Finally, an exhaustive search can be perform to retrieve  <span class="math">k_0</span>  and  <span class="math">k_1</span>  without increasing the overall complexity.</p>

    <p class="text-gray-300">In this section we concisely describe a second attack against 8-round PRINCE, still based on Demirci and Selçuk technique, requiring much less memory than the attack described Section 3.2.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">Step 1</h3>

    <p class="text-gray-300">The first step of the attack is depicted on Figure 18. This is a classical Demirci and Selçuk attack against 8-round PRINCE. The nibble requiblack in the online phase are in gray and can take  <span class="math">2^{8\\times4}=2^{32}</span>  values. In another hand, nibbles requiblack in the offline phase are in black and can assume  <span class="math">2^{80}</span>  values thanks to the (lack of) key schedule.</p>

    <p class="text-gray-300">Here  <span class="math">\\delta</span> -sets contain  <span class="math">2^4=16</span>  messages and the check is performed on sequences of (16-1)=15 differences in one nibble, <em>i.e.</em> on 60-bit sequences. As more than  <span class="math">2^{60}</span>  sequences are computed during the offline phase, the attack does not filter values of gray nibbles.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">Step 2</h3>

    <p class="text-gray-300">The idea is to switch the online and the offline phases (and actually they are now both performed online). Given a plaintext/ciphertext pair (P, C) we compute the  <span class="math">2^{32}</span>  possible 60-bit sequences and store them in a hash table. Then for each value</p>

    <p class="text-gray-300">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;    <img src="_page_32_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 18: Step 1. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">of the black nibbles, we compute the corresponding 60-bit sequence and check whether it belongs to the hash table. Only  <span class="math">2^{80-60+32}=2^{52}</span>  values should pass this test.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Step 3</h4>

    <p class="text-gray-300">We notice that, given a structure of  <span class="math">2^{16}</span>  plaintexts such that the first column is active while the other ones are constant, each column of state  <span class="math">y_3</span>  takes all the possible values too. Hence we can fix the value to 0 of 4 black nibbles of  <span class="math">y_4</span>  (shiftrows of a column), decreasing the time complexity by a factor  <span class="math">2^{16}</span> . As a result, the hash table now has to contain  <span class="math">2^{48}</span>  sequences,  <span class="math">2^{32}</span>  for each of the  <span class="math">2^{16}</span>  plaintext/ciphertext pairs.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">Step 4</h3>

    <p class="text-gray-300">To decrease further the number of possible values for the black nibbles, we apply the same attack but we change the nibble on which the check is performed as shown on Figure 19. So we have to store an other table containing  <span class="math">2^{48}</span>  60-bit sequences and guess the value of the black nibble of  <span class="math">y_2&#x27;</span> . Only  <span class="math">2^{52+4-60+48}=2^{44}</span>  values should pass this test.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">Step 5</h3>

    <p class="text-gray-300">As in step 4, we perform the two others attacks corresponding to the two other positions for the black nibble on  <span class="math">y&#x27;_2</span> . Only  <span class="math">2^{28}</span>  values should pass this test.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;    <img src="_page_33_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 19: Step 4. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Step 6</h4>

    <p class="text-gray-300">We switch again online and offline phases, coming back to a classical Demirci and SelÃğuk attack. We run successively the four previous attacks to retrieve a unique plaintext/ciphertext pair together with a unique value for the first column of  <span class="math">y_1</span>  and the whole state  <span class="math">y_1&#x27;</span> . Indeed, we did not check whether the plaintext/ciphertext pair and the first column of  <span class="math">y_1</span>  are the same for the four attacks, while they have to. Thus only the right ones should remain at the end of the attack.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">Step 7</h3>

    <p class="text-gray-300">The missing 48 bits of the key can be exhausted.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">Complexity</h3>

    <p class="text-gray-300">The data complexity is  <span class="math">2^{16}</span>  chosen plaintexts. The memory complexity is around  <span class="math">4\\times 2^{48}</span>  60-bit sequences which is equal to  <span class="math">2^{52.9}</span>  bytes. The time complexity is dominated by steps 2/3, which is equivalent to  <span class="math">2^{64}\\times 2^4\\times (42-4)/(8\\times 16)\\simeq 2^{66.25}</span>  encryptions.</p>

`;
---

<BaseLayout title="Meet-in-the-Middle Attacks and Structural Analysis of Round-... (2015/239)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/239
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="meet-in-the-middle-attacks-and-structural-analysis-of-round-2015" />
  </article>
</BaseLayout>
