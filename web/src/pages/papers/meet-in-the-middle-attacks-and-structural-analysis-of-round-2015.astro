---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/239';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Meet-in-the-Middle Attacks and Structural Analysis of Round-Reduced PRINCE';
const AUTHORS_HTML = 'Patrick Derbez, Léo Perrin';

const CONTENT = `    <p class="text-gray-300">Meet-in-the-Middle Attacks and Structural Analysis of Round-Reduced PRINCE</p>

    <p class="text-gray-300">Patrick Derbez¹ and Léo Perrin²*</p>

    <p class="text-gray-300">patrick.derbez@irisa.fr</p>

    <p class="text-gray-300">leo.perrin@uni.lu</p>

    <p class="text-gray-300">¹ IRISA, University of Rennes 1 ² SnT, University of Luxembourg</p>

    <p class="text-gray-300">Abstract. NXP Semiconductors and its academic partners challenged the cryptographic community with finding practical attacks on the block cipher they designed, PRINCE. Instead of trying to attack as many rounds as possible using attacks which are usually impractical despite being faster than brute-force, the challenge invites cryptographers to find practical attacks and encourages them to actually implement them. In this paper, we present new attacks on round-reduced PRINCE including the ones which won the challenge in the 4, 6 and 8-round categories — the highest for which winners were identified. Our first attacks rely on a meet-in-the-middle approach and break up to 10 rounds of the cipher. We also describe heuristic methods we used to find practical SAT-based and differential attacks.</p>

    <p class="text-gray-300">Finally, we also present an analysis of the cycle structure of the internal rounds of PRINCE leading both to a low complexity distinguisher for 4-round PRINCE-core and an alternative representation of the cipher valid in particular contexts and which highlights, in these cases, a poor diffusion.</p>

    <p class="text-gray-300">Keywords: PRINCE, practical attacks, meet-in-the-middle, SAT-solver, statistical analysis</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">When tasked with assessing the security of a block cipher, cryptanalysts have now a broad range of tools at their disposal: differential attack [1], linear attack [2], meet-in-the-middle attack [3], etc. The main purpose of a security analysis is usually to identify flaws in the design of a primitive and then to illustrate their gravity through the description of an attack covering as many rounds as possible. However, applicability of said attacks in a realistic situation is usually not the first objective of the cryptanalyst. A simple reason for this is that as</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Patrick Derbez and Léo Perrin were supported by the CORE ACRYPT project from the Fond National de Recherche (Luxembourg).</li>

    </ul>

    <p class="text-gray-300">© IACR 2015. This article is the full version of the article published by Springer-Verlag available at 10.1007/978-3-662-48116-5_10.</p>

    <p class="text-gray-300">our understanding of the design of block ciphers improved, the ease of identifying practical attacks decreased. Furthermore and in accordance with the famous maxim “attacks only get better”, an impractical attack submitted at a given time may later be improved.</p>

    <p class="text-gray-300">While impractical attacks provide the academic community with valuable insights into the security provided by different block ciphers, their components, their design strategies, etc., crypanalysis in the industry is more focused on practical attacks. In order to promote this view, the Technical University of Denmark (DTU), NXP Semiconductors and the Ruhr University of Bochum challenged the cryptographic community <em>[4]</em> with finding low data complexity attacks on the block cipher PRINCE <em>[5]</em>. More precisely, they accept attacks requiring only at most <span class="math">2^{20}</span> chosen plaintexts or <span class="math">2^{30}</span> known plaintexts. Furthermore, extra rewards (from 1000 to 10000€) are given for attacks on at least 8 rounds which require at most <span class="math">2^{45}</span> bytes of memory (about 32 Terabytes) and at most <span class="math">2^{64}</span> encryptions of the round-reduced variant attacked.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Studying PRINCE in this setting may provide valuable data on multiple accounts. First of all, PRINCE is a lightweight block cipher, meaning that it is intended to be run on processors with little computing power to devote to security related algorithm or on hardware where every logical gate counts. Research on this topic is intense nowadays as the need for such primitives becomes increasingly pressing, see <em>[6]</em> for an extensive review of the algorithms that have been proposed. Second, PRINCE implements a simplified version of the so-called FX construction: encryption under key ($k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}<span class="math">) consists in xor-ing </span>k_{0}<span class="math"> to the plaintext, applying a block cipher called PRINCE-core keyed with </span>k_{1}<span class="math"> and then output the result xor-ed with </span>L(k_{0})<span class="math"> where </span>L<span class="math"> is a simple linear bijection. This strategy allows for a greater key size without the cost of a sophisticated key schedule. However, it is impossible to make a security claim as strong as for a more classical construction. Finally, PRINCE-core has a unique property called </span>\\alpha<span class="math">-reflection. If we denote by </span>E_{c,k_{1}}<span class="math"> the encryption under PRINCE-core with subkey </span>k_{1}<span class="math">, then the corresponding decryption operation is </span>E_{c,k_{1}\\oplus\\alpha}<span class="math"> for a constant </span>\\alpha<span class="math">. In other words, decryption is merely encryption under a related-key. The consequences of this property have already been studied and, in particular, some values of </span>\\alpha$ different from the one used have been showed to lead to weaker algorithms <em>[7]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">PRINCE has already been the subject of several cryptanalyses, notably <em>[8]</em> where the security of the algorithm against multiple attacks was assessed, <em>[7]</em> which investigated the influence of the value of <span class="math">\\alpha</span>, <em>[9]</em> which described Meet-in-the-Middle attacks on the block cipher and, finally, <em>[10]</em> proposed the best attack to date in terms of number of rounds attacked. A list of the cryptanalyses of round-reduced PRINCE is provided in Table 1. Attacks working only on PRINCE-core or for modified versions of PRINCE (different <span class="math">\\alpha</span> or S-Box) are not shown.</p>

    <p class="text-gray-300">As stated before, most of the attacks usually considered often have impractical complexities. For instance, differential attacks and linear attacks require large amounts of chosen (respectively known) plaintexts, both of which may be impossible to gather to begin with if the algorithm is implemented on a small-device</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Description</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Reference</td>

            <td class="px-3 py-2 border-b border-gray-700">Type</td>

            <td class="px-3 py-2 border-b border-gray-700">Rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">Data (CP)</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">Memory</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[8]</td>

            <td class="px-3 py-2 border-b border-gray-700">Integral</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 5</td>

            <td class="px-3 py-2 border-b border-gray-700">Diff. / Logic</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">5s</td>

            <td class="px-3 py-2 border-b border-gray-700"><< 227</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Appendix D</td>

            <td class="px-3 py-2 border-b border-gray-700">MitM</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">33 KP</td>

            <td class="px-3 py-2 border-b border-gray-700">243.4</td>

            <td class="px-3 py-2 border-b border-gray-700">226.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">64 KP</td>

            <td class="px-3 py-2 border-b border-gray-700">2101.1</td>

            <td class="px-3 py-2 border-b border-gray-700">234</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">266.25</td>

            <td class="px-3 py-2 border-b border-gray-700">249.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">233.7</td>

            <td class="px-3 py-2 border-b border-gray-700">231.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">250.7 (online)</td>

            <td class="px-3 py-2 border-b border-gray-700">284.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">265.7 (online)</td>

            <td class="px-3 py-2 border-b border-gray-700">268.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">268 (online)</td>

            <td class="px-3 py-2 border-b border-gray-700">241</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Section 4</td>

            <td class="px-3 py-2 border-b border-gray-700">Differential</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">214.9</td>

            <td class="px-3 py-2 border-b border-gray-700">225.1</td>

            <td class="px-3 py-2 border-b border-gray-700">214.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[9]</td>

            <td class="px-3 py-2 border-b border-gray-700">MitM</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">253</td>

            <td class="px-3 py-2 border-b border-gray-700">260</td>

            <td class="px-3 py-2 border-b border-gray-700">230</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">257.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[10]</td>

            <td class="px-3 py-2 border-b border-gray-700">Multiple diff.</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">246.89</td>

            <td class="px-3 py-2 border-b border-gray-700">251.21</td>

            <td class="px-3 py-2 border-b border-gray-700">252.21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">257.94</td>

            <td class="px-3 py-2 border-b border-gray-700">260.62</td>

            <td class="px-3 py-2 border-b border-gray-700">261.52</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Time complexity is measured in encryption units Memory complexity is measured in 64-bit blocks</p>

    <p class="text-gray-300">Table 1: The best attacks on round-reduced PRINCE in the single-key model.</p>

    <p class="text-gray-300">with little computer and, hence, a small throughput. Therefore, we focused our efforts on Meet-in-the-Middle (MitM) attacks, algebraic/logic attack where the fact that a ciphertext is the encryption of a plaintext is encoded as an equation which is fed to a solver and, surprisingly, differential attack for which we found a heuristic method decreasing significantly the data complexity.</p>

    <p class="text-gray-300">Our contribution. We describe different low data complexity attacks on round-reduced PRINCE which were submitted to the PRINCE challenge and turned out [11] to be the best ones on PRINCE reduced to 4, 6 and 8 rounds. In Section 3, we describe our attacks obtained using the meet-in-the-middle technique and we also show a new attack on 10 rounds with practical memory and a time complexity around  <span class="math">2^{68}</span>  encryptions. Then, we describe in Section 4 a low data differential attack against 6-round PRINCE, which is the fastest known. In fact, the power of the filter used to discard wrong pairs in a differential attack can be raised to the power 4 when attacking 6-round PRINCE by considering groups of pairs. In Section 5 we show how the equation given to a SAT-solver can be</p>

    <p class="text-gray-300">modified so as to make an attack on 4 rounds practical, and how to simplify our 6-round differential attack by using a SAT-solver to take care of the tedious details of the key recovery. We finally present in Section 6 some observations about the cycle structure of the internal rounds of PRINCE and how it implies the existence of alternative representations of the cipher highlighting a poor diffusion in some subsets of the input space. While we do not use these to attack PRINCE directly, we show that the size of these subsets remains reasonable and actually find such sets for 4-round PRINCE-core.</p>

    <p class="text-gray-300">PRINCE is a 64-bit block cipher with a 128-bit key. It is based on a variant of the the FX-construction which was proposed by Kilian and Rogaway as a generalization of the DESX scheme. The master key  <span class="math">k</span>  is split into two 64-bit parts  <span class="math">k = k_{0} \\parallel k_{1}</span>  and  <span class="math">k_{0}</span>  is used to generate a third subkey  <span class="math">k_{0}&#x27; = (k_{0} \\gg 1) \\oplus (k_{0} \\gg 63)</span> . Both  <span class="math">k_{0}</span>  and  <span class="math">k_{0}&#x27;</span>  are used as pre- and post- whitening keys respectively. The full version of the cipher has 12 rounds and is depicted on Figure 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1: the PRINCE cipher.</p>

    <p class="text-gray-300">The encryption is quite similar to the AES and consists of a nibble-based substitution layer  <span class="math">S</span>  and a linear layer  <span class="math">M</span> . The operation  <span class="math">M</span>  can be divided into a ShiftRows operations and a matrix multiplication  <span class="math">M&#x27;</span>  operating independently on each column but not nibble-oriented. Furthermore the matrix  <span class="math">M&#x27;</span>  is an involution and, combined to the fact that the round constants satisfy the relation  <span class="math">RC_{i} \\oplus RC_{i}&#x27; = \\alpha</span>  where  <span class="math">\\alpha = \\mathsf{C0AC29B7C97C50DD}</span> , the decryption process  <span class="math">D_{k_0,k_1,k_0&#x27;}</span>  is equal to the encryption process  <span class="math">E_{k_0&#x27;,k_1 \\oplus \\alpha ,k_0}</span> . For further details about PRINCE we refer the reader to [5].</p>

    <p class="text-gray-300">Notations. In the sequel we denote both the plaintext and the ciphertext by  <span class="math">p</span>  and  <span class="math">c</span>  respectively. For the first  <span class="math">R</span>  rounds of  <span class="math">2R</span> -round PRINCE, we denote the</p>

    <p class="text-gray-300">internal state just before (resp. after) the  <span class="math">r</span> -th SubNibble layer by  <span class="math">x_{r}</span>  (resp.  <span class="math">y_{r}</span> ) while for the last  <span class="math">R</span>  rounds those internal states are denoted by  <span class="math">y_{r}^{\\prime}</span>  and  <span class="math">x_{r}^{\\prime}</span>  respectively as shown on Figure 1. Given a collection of messages  <span class="math">\\{p^{0},\\ldots ,p^{m},\\ldots \\}</span> , the notation  <span class="math">x_{r}^{m}[i]</span>  holds for the nibble  <span class="math">i</span>  of the state  <span class="math">x_{r}</span>  of the message  <span class="math">p^m</span> . As PRINCE is not fully nibble-oriented we use the notation  <span class="math">x_{r}[i]_{b}</span>  to refer to the bit  <span class="math">i</span>  of the state  <span class="math">x_{r}</span>  and the following relation holds for all  <span class="math">i\\in \\{0,\\dots ,15\\}</span> :</p>

    <p class="text-gray-300"><span class="math">x_{r}[i] = x_{r}[4i + 3]_{b}\\parallel x_{r}[4i + 2]_{b}\\parallel x_{r}[4i + 1]_{b}\\parallel x_{r}[4i]_{b}.</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig.2: Ordering of bits/nibbles in PRINCE.</p>

    <p class="text-gray-300">Finally, we use the following notations for some functions.</p>

    <p class="text-gray-300"><span class="math">R</span>  The composition of  <span class="math">S</span>  and  <span class="math">M</span>  so that  <span class="math">R(x) = M\\big(S(x)\\big) = SR\\big(M&#x27;(S(x))\\big)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$E_{k_{0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_1}}^r<span class="math">  PRINCE reduced to  </span>r$  rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">E_{c,k_1}</span>  full PRINCE-core.</p>

    <p class="text-gray-300"><span class="math">E_{k_1}^{c,r}</span>  PRINCE-core reduced to  <span class="math">r</span>  rounds.</p>

    <p class="text-gray-300">In this section we present both the 6-round attack and the 8-round attack which won the PRINCE Challenge in the chosen-plaintext category together with a new attack on 10 rounds. The aim of the challenge was to find the best attacks using at most  <span class="math">2^{20}</span>  chosen plaintexts and thus we decided to follow the strategy used by Demirci and Selçuk on AES in [3], later improved by Dunkelman et al. in [12], Derbez et al. in [13,14] and by Li et al. in [9]. While our 10-round attack does not fit the restriction on the data complexity it shows that this kind of attacks is one of the most powerful on SP-Network.</p>

    <p class="text-gray-300">First we give the definition of an ordered  <span class="math">\\delta</span> -set which is a particular structure of messages used in our attacks.</p>

    <p class="text-gray-300">Definition 1. Let a  <span class="math">\\delta</span> -set be a set of 16 PRINCE-states that are all different in one state nibble (the active nibble) and all equal in the other state nibble (the inactive nibbles). An ordered  <span class="math">\\delta</span> -set is a  <span class="math">\\delta</span> -set  <span class="math">\\{x^0, \\ldots, x^{15}\\}</span>  such that the difference in the active nibble between  <span class="math">x^0</span>  and  <span class="math">x^i</span>  is equal to  <span class="math">i</span> , for  <span class="math">0 \\leq i \\leq 15</span> .</p>

    <p class="text-gray-300">In the sequel we consider <span class="math">\\delta</span>-sets such that nibble 7 is the active one. For such a particular set we made the following observations which are the core of our new attacks.</p>

    <p class="text-gray-300"><strong>Observation 1</strong> Consider the encryption of a collection <span class="math">\\{p^0, p^1, \\ldots, p^{15}\\}</span> of 16 messages through 6-round PRINCE. If the set <span class="math">\\{y_2^0, y_2^1, \\ldots, y_2^{15}\\}</span> is an ordered <span class="math">\\delta</span>-set then the ordered sequence</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ y _ {2} ^ {\\prime 1} [ 7 ] \\oplus y _ {2} ^ {\\prime 0} [ 7 ], y _ {2} ^ {\\prime 2} [ 7 ] \\oplus y _ {2} ^ {\\prime 0} [ 7 ], \\dots , y _ {2} ^ {\\prime 1 5} [ 7 ] \\oplus y _ {2} ^ {\\prime 0} [ 7 ] \\right]</span></div>

    <p class="text-gray-300">is fully determined by the following 8 nibble parameters:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - x _ {3} ^ {0} [ 0, 7, 1 0, 1 3 ] \\quad - x _ {3} ^ {\\prime 0} [ 0, 7, 1 0, 1 3 ] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Consequently, there are at most <span class="math">2^{8 \\times 4} = 2^{32}</span> possible sequences when we consider all the possible choices of keys and ordered <span class="math">\\delta</span>-sets (out of the <span class="math">2^{4 \\times 15} = 2^{60}</span> of the theoretically possible 15-nibble sequences).</p>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is straightforward. The goal is to propagate the differences from the state <span class="math">y_{2}</span> (which are known) to the state nibble <span class="math">y_{2}^{\\prime}[7]</span>. At each intermediate round, each S-box is either a parameter, not required or constant (so output differences are equal to zero).</p>

    <p class="text-gray-300"><strong>Observation 2</strong> Consider the encryption of a collection <span class="math">\\{p^0, p^1, \\ldots, p^{15}\\}</span> of 16 messages through 8-round PRINCE. If the set <span class="math">\\{x_2^0, x_2^1, \\ldots, x_2^{15}\\}</span> is an ordered <span class="math">\\delta</span>-set then the ordered sequence</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ x _ {2} ^ {\\prime 1} [ 7 ] \\oplus x _ {2} ^ {\\prime 0} [ 7 ], \\dots , x _ {2} ^ {\\prime 1 5} [ 7 ] \\oplus x _ {2} ^ {\\prime 0} [ 7 ], y _ {2} ^ {\\prime 1} [ 6 ] \\oplus y _ {2} ^ {\\prime 0} [ 6 ], \\dots , y _ {2} ^ {\\prime 1 5} [ 6 ] \\oplus y _ {2} ^ {\\prime 0} [ 6 ] \\right]</span></div>

    <p class="text-gray-300">is fully determined by the following 42 nibble parameters:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - x _ {2} ^ {0} [ 7 ] \\quad - x _ {4} ^ {\\prime 0} [ 0.. 1 5 ] \\\\ - x _ {3} ^ {0} [ 0, 7, 1 0, 1 3 ] \\quad - x _ {3} ^ {\\prime 0} [ 0, 7, 1 0, 1 3 ] \\\\ - x _ {4} ^ {0} [ 0.. 1 5 ] \\quad - x _ {2} ^ {\\prime 0} [ 7 ] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Furthermore, those 42 state nibbles can be directly computed from the full state <span class="math">x_4</span> and 4 nibbles of <span class="math">M^{-1}(k_1)</span>. Consequently, there are at most <span class="math">2^{4 \\times (16 + 4)} = 2^{80}</span> possible sequences when we consider all the possible choices of keys and ordered <span class="math">\\delta</span>-sets (out of the <span class="math">2^{4 \\times 30} = 2^{120}</span> of the theoretically possible 30-nibble sequences).</p>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is similar to the one of Observation 1 except the parameters are related. Indeed, from the full state <span class="math">x_4</span> one can directly compute <span class="math">x_4&#x27;</span> as no keys are involved. Then we note that the 4 nibbles <span class="math">M^{-1}(k_1)[4..7]</span> are enough to compute <span class="math">x_3^0 [0,7,10,13]</span> from <span class="math">x_4</span> and <span class="math">x_3&#x27;^0 [0,7,10,13]</span> from <span class="math">x_4&#x27;</span>. Finally, the knowledge of <span class="math">M^{-1}(k_1)[7]</span> allows to compute <span class="math">x_2^0 [7]</span> and <span class="math">x_2&#x27;^0 [7]</span> from <span class="math">x_3^0 [0,7,10,13]</span> and <span class="math">x_3&#x27;^0 [0,7,10,13]</span> respectively.</p>

    <p class="text-gray-300">The 6-round attack is depicted on Figure 3 and its scenario is straightforward. First the  <span class="math">2^{32}</span>  possible sequences given in Observation 1 are computed and stored in a hash table during a preprocessing phase. Then during the online phase, we begin by asking for the encryption of a structure of  <span class="math">2^{16}</span>  chosen plaintexts such that nibbles from 4 to 7 take all the possible values while the other ones are constant, and pick one of them denoted  <span class="math">p^0</span> . Now the goal of the adversary is to identify an ordered  <span class="math">\\delta</span> -set containing  <span class="math">y_2^0</span> . To do so, he has to guess the five nibbles  <span class="math">x_1^0[4..7]</span>  and  <span class="math">x_2^0[7]</span>  and propagate the differences from the state  <span class="math">y_2</span>  to the plaintext. Then he gets the corresponding ciphertexts, guess the five nibbles  <span class="math">x_1&#x27;^0[4..7]</span>  and  <span class="math">x_2&#x27;^0[7]</span>  and propagates the differences from the ciphertexts to  <span class="math">y_2&#x27;[7]</span> . Finally he discards all the guesses which do not lead to a match in the previously built hash table. The probability for a wrong guess to pass the test is  <span class="math">2^{32} \\times 2^{-60} = 2^{-28}</span>  so we expect  <span class="math">2^5</span>  candidates to remain at the end of the attack. The wrong ones can be discarded by replaying the attack with an other choice for  <span class="math">p^0</span>  without increasing the overall complexity of the attack.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: 6r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">The data complexity of this attack is  <span class="math">2^{16}</span>  chosen plaintexts and the memory requirement is around  <span class="math">2^{32} \\times 4 \\times 15 \\times 2^{-3} \\approx 2^{34.9}</span>  bytes. During the online phase 10 state nibbles are guessed however they can assume only  <span class="math">2^{33}</span>  values once the plaintext/ciphertext pair is given. Indeed, the knowledge of the 33 bits</p>

    <p class="text-gray-300"><span class="math">\\{(k_0\\oplus k_1)[16..27]_b,(k_0&#x27;\\oplus k_1)[16..27]_b,k_1[28..31]_b,k_0[28..32]_b\\},</span></p>

    <p class="text-gray-300">is enough to compute all of them from  <span class="math">p</span>  and  <span class="math">c</span> . Thus the time complexity of the online phase is approximately  <span class="math">16 \\times 2^{33} \\times 40 / (6 \\times 64) \\approx 2^{33.7}</span>  encryptions.</p>

    <p class="text-gray-300">Key recovery. At the end of the attack  <span class="math">128 - 33 = 95</span>  key bits are still missing. To find them the best way is to apply several meet-in-the-middle attacks</p>

    <p class="text-gray-300">successively. For instance, one could begin by running the attack depicted on Figure 12 in Appendix A which has an overall complexity below  <span class="math">2^{28}</span>  as most key bits required in the online phase are already known.</p>

    <p class="text-gray-300">The 8-round attack is similar to the one on 6 rounds and is depicted on Figure 4. It relies on Observation 2 so the memory complexity is around  <span class="math">2^{80} \\times 15 \\times 8 \\times 2^{-3} \\approx 2^{83.9}</span>  bytes. In the online phase, the data complexity remains unchanged to  <span class="math">2^{16}</span>  chosen plaintexts but the number of state variable to guess is increased. The identification step requires to guess the four nibbles  <span class="math">x_{1}^{0}[4..7]</span>  and then the nine nibbles  <span class="math">x_{1}^{\\prime 0}[0..7]</span>  and  <span class="math">x_{2}^{\\prime 0}[6]</span>  are guessed to build the sequence from the ciphertexts. Those 13 nibbles can assume only  <span class="math">2^{49}</span>  values once the plaintext/ciphertext pair  <span class="math">(p^{0}, c^{0})</span>  given as they all can be derived from</p>

    <p class="text-gray-300"><span class="math">\\{(k_0\\oplus k_1)[16..24,28..31]_b,(k_0&#x27;\\oplus k_1)[0..23,27..31]_b,k_0[25..27]_b,k_1[24..27]_b\\} .</span></p>

    <p class="text-gray-300">Thus the time complexity of the online phase is approximately  <span class="math">16 \\times 2^{49} \\times 52 / (8 \\times 64) \\approx 2^{49.7}</span>  encryptions and we expect  <span class="math">2^{49} \\times 2^{80} \\times 2^{-120} = 2^9</span>  candidates to remain at the end of the attack.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4: 8r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">Key recovery. As for the previous attack, the most efficient way to recover the missing key bits is to perform other attacks. For instance one could run the attack depicted on Figure 13 (Appendix B) which has the same complexity than the one above since there are approximately  <span class="math">2^{9}</span>  candidates for the 4 active nibbles</p>

    <p class="text-gray-300">of <span class="math">x_{1}</span>. Then the search space would be small enough to perform an exhaustive search without increasing the overall complexity.</p>

    <p class="text-gray-300">Trade-off. It is possible to trade some memory against time without increasing the data complexity by noticing that for a considered structure of <span class="math">2^{16}</span> plaintexts the 4 active nibbles of <span class="math">x_{3}</span> take all the possible values. Thus we can fix them to 0 during the offline phase and save a factor <span class="math">2^{16}</span> in memory. In the other hand, we now need to run the attack for all the possible choices for <span class="math">p^{0}</span> increasing the time complexity by the same factor of <span class="math">2^{16}</span>.</p>

    <p class="text-gray-300">A more sophisticated attack against 8-round PRINCE, requiring much less memory, is described in Appendix E.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.3 10-round Attack</h3>

    <p class="text-gray-300">We now investigate PRINCE reduced to 10 rounds. While we were unable to find an attack requiring less than <span class="math">2^{20}</span> chosen plaintexts for the PRINCE Challenge, we found one competitive with the current best known attack. To describe it we first extend the definition of a <span class="math">\\delta</span>-set as it was done in <em>[13]</em>, then we show a meet-in-the-middle attack as the two ones above and finally we apply the differential enumeration technique (<em>[12]</em>).</p>

    <p class="text-gray-300"><span class="math">\\delta</span>-set. In <em>[13]</em> Derbez et al. shown that the notion of <span class="math">\\delta</span>-set can be extended to set of states such that some linear combinations of state bits are constant. In the sequel we denote by <span class="math">\\delta</span>-set a set of 16 messages such that <span class="math">y_{2}[0..4,6,8..12,14]</span> and <span class="math">M^{\\prime}(y_{2})[0..4,6,8..12,14]</span> are constant, exploiting the fact that the matrix operating on the columns are not MDS.</p>

    <p class="text-gray-300">10-round attack. The basis of our attack on 10 rounds is depicted on Figure 5. The meet-in-the-middle is performed on the four bit-equations described above. The state bytes required as the parameters of the hash table can be computed from the whole state <span class="math">x_{5}</span> and 8 nibbles of the equivalent subkey <span class="math">M^{-1}(k_{1})</span> and thus approximately <span class="math">2^{96}</span> 60-bit sequences are stored. In the online phase the 24 state nibbles needed can be computed from the following 66 key bits:</p>

    <p class="text-gray-300">\\[ \\{k_{0}[0,20..24,28..32,52..56,60..63]_{b},k_{1}[20..23,28..31,52..55,60..63]_{b},\\\\ (k_{0}\\oplus k_{1})[16..19,24..27,48..51,56..59]_{b},\\\\ (k_{0}^{\\prime}\\oplus k_{1})[16..19,24..26,48..51,56..58]_{b}\\}. \\]</p>

    <p class="text-gray-300">Note that this attack does not actually work because the number of sequences stored is higher than the number of possible 60-bit sequences and thus no key candidates are filtered. The aim of the next section is to show how to reduce the memory requirement.</p>

    <p class="text-gray-300">Differential Enumeration Technique. Li et al. applied this technique against PRINCE in <em>[9]</em> and successfully mounted new attacks on 8 and 9 rounds. The idea of this technique originally introduced by Dunkelman et al. in <em>[12]</em> is to store in the hash table only the sequences built from a <span class="math">\\delta</span>-set containing a message <span class="math">p^{0}</span> that</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig.5: 10r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">belongs to a pair  <span class="math">(p^0, p^1)</span>  following a well-chosen differential characteristic. In our case the truncated differential characteristic is depicted on Figure 5 assuming a zero difference in hatched nibbles. Thus we expect to store only  <span class="math">2^{96 + 4 - 60} = 2^{40}</span>  sequences in the offline phase. However generating them is not as trivial as for the basic attack. We propose the following procedure which has a time complexity around  <span class="math">2^{72}</span>  operations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider a pair  <span class="math">(p^0, p^1)</span>  following the differential characteristic.</li>

      <li><span class="math">S^{-1} \\circ M&#x27; \\circ S</span>  can be seen as 4 invertible super Sboxes  <span class="math">\\S_0, \\ldots, S_3</span>  operating on 16-bit words. Build 4 hash tables such that one can retrieve  <span class="math">(x, y)</span>  from  <span class="math">(x \\oplus y, S_i(x) \\oplus S_i(y))</span> .</li>

      <li>Guess the difference in the active nibbles of both  <span class="math">y_4</span>  and  <span class="math">y&#x27;4</span>  and retrieve the actual value of  <span class="math">x_5</span>  and  <span class="math">x_5&#x27;</span>  for both messages of the pair.</li>

      <li>Guess the difference in the two active nibbles of the first column of  <span class="math">y_{3}</span>  and get back the actual values of  <span class="math">y_{4}[2,5,8,15]</span> .</li>

      <li>Combined with the knowledge of  <span class="math">x_{5}</span>  this leads to the knowledge of the four key nibbles  <span class="math">M^{-1}(k_1)[2, 5, 8, 15]</span> . Use them to partially encrypt  <span class="math">x_{5}&#x27;</span>  and check if the difference in the first column of  <span class="math">y_{3}&#x27;</span>  is correct.</li>

      <li>Use  <span class="math">M^{-1}(k_1)[15]</span>  to partially decrypt  <span class="math">y_4</span>  and get the difference in  <span class="math">x_2[15]</span>  and check its correctness. Do the same for the difference in  <span class="math">x_2&#x27;[15]</span> .</li>

      <li>Guess the difference in the two active nibbles of the third column of  <span class="math">y_{3}</span>  and get back  <span class="math">M^{-1}(k_1)[0, 7, 11, 13]</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the value of the missing parameters and check whether the pair follows the characteristic or not. If it does then build the 60-bit sequence from <span class="math">p^0</span> and store it in the hash table.</li>

    </ol>

    <p class="text-gray-300">The complexity of this procedure is dominated by the complexity of steps 4-5 which is <span class="math">2^{72}</span> simple operations that we estimate to be equivalent to <span class="math">2^{69}</span> encryptions. Now that the table is built the online phase is quite similar to the one of the offline phase:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ask for a structure of <span class="math">2^{32}</span> chosen plaintexts and store the ciphertexts in a hash table to identify the pairs that may follow the differential characteristic.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each pair <span class="math">(p^0, p^1)</span>:</li>

    </ol>

    <p class="text-gray-300">(a) Guess the difference in the first column of <span class="math">y_{1}</span> and of <span class="math">y_{2}</span>, deduce the corresponding value of <span class="math">(k_{0} \\oplus k_{1})[12..15]</span> and <span class="math">k_{1}[15]</span>. Store them in a hash table <span class="math">T_{0}</span> indexed by <span class="math">k_{1}[15], k_{0}[61..63]_{b}</span>.</p>

    <p class="text-gray-300">(b) Similarly compute <span class="math">(k_0&#x27; \\oplus k_1)[12..15]</span> and <span class="math">k_{1}[15]</span> from the ciphertexts and use <span class="math">T_{0}</span> and the linear relations between <span class="math">k_{0}</span> and <span class="math">k&#x27;0</span> to get back the <span class="math">2^{2 \\times 4 + 2}</span>. <span class="math">2^{-7} = 2^{3}</span> corresponding values of the key nibbles above. Store those <span class="math">2^{13}</span> key candidates in a hash table <span class="math">T_{1}</span> indexed by <span class="math">(k_{0} \\oplus k_{1})[12..15]</span>, <span class="math">(k_0&#x27; \\oplus k_1)[12..15]</span> and <span class="math">k_{0}[55]_b \\oplus k_{0}[60]_b</span> (<span class="math">= (k_{0} \\oplus k_{1})[55]_b \\oplus \\ldots \\oplus (k_{0} \\oplus k_{1})[60]_b \\oplus (k_0&#x27; \\oplus k_1)[55]_b \\oplus \\ldots \\oplus (k_0&#x27; \\oplus k_1)[59]_b \\oplus k_{1}[60]_b</span>).</p>

    <p class="text-gray-300">(c) Repeat the two steps above but now by guessing the third column of <span class="math">y_{2}</span> and use <span class="math">T_{1}</span> to obtain the <span class="math">2^{2 \\times 13 - 8 - 8 - 1} = 2^{9}</span> and store them in a hash table <span class="math">T_{2}</span> indexed by the difference in <span class="math">y_{2}</span>. (While the match is on 33 bits, <span class="math">(k_{0} \\oplus k_{1})[12..15]</span> and <span class="math">(k_{0}&#x27; \\oplus k_{1})[12..15]</span> only depend on four 4-bit parameters.)</p>

    <p class="text-gray-300">(d) Repeat the three steps above but now by guessing the third column of <span class="math">y_{1}</span> and use <span class="math">T_{3}</span> to finally retrieve all the <span class="math">2^{9 + 9 - 8} = 2^{10}</span> key candidates.</p>

    <p class="text-gray-300">(e) For each key candidate identify a <span class="math">\\delta</span>-set from <span class="math">p^0</span>, build the 60-bit sequence and check whether it belongs to the table constructed in the offline phase. If it does then try the key candidate.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Repeat the procedure until the right key is found.</li>

    </ol>

    <p class="text-gray-300">As each structure contains <span class="math">2^{63}</span> pairs and each of these pairs follows the differential with probability <span class="math">2^{-28 - 60} = 2^{-88}</span>, we need <span class="math">2^{25}</span> structures on average. Then, for each structure we have to study only <span class="math">2^{63 - 32} = 2^{31}</span> pairs and for each of them we have to perform <span class="math">4 \\times 2^{13} + 2^{10} \\times 2^{4}</span> simple operations estimated to approximately <span class="math">2^{12}</span> encryptions. Thus this procedure has a time complexity of <span class="math">2^{25 + 31 + 12} = 2^{68}</span> encryptions and requires <span class="math">2^{25 + 32} = 2^{57}</span> chosen plaintexts. At the end of the attack <span class="math">2^{66} \\times 2^{40} \\times 2^{-60} = 2^{46}</span> key candidates remain. As 62 key bits are also missing performing an exhaustive search is not a valid option. Instead, the best way to recover the key is to apply several meet-in-the-middle attacks. For instance, we can assume that when a match happens we get back the corresponding values of the red nibbles in Figure 5 and then deduce step by step each key bits of <span class="math">M^{-1}(k_1)</span> by completing the first and the third columns of <span class="math">y_3&#x27;</span> without increasing the overall complexity of the attack.</p>

    <p class="text-gray-300">In this section we describe a new differential attack against 6-round PRINCE. There has already been some differential cryptanalyses of PRINCE, see for example [10], which is the best attack to date, and also [15]. Our attack uses a new method to increase the power of the filter by considering groups of pairs. This allows a rather low data complexity considering that 6-rounds are attacked and that differential attacks usually demand large amounts of chosen plaintexts.</p>

    <h2 id="sec-8" class="text-2xl font-bold">4.1 Amplified Differential Trails</h2>

    <p class="text-gray-300">Our attack relies on some differences propagating identically in different pairs. To better describe this, we introduce the following definitions.</p>

    <p class="text-gray-300"><strong>Encryption</strong> We call <em>encryption</em> a couple plaintext/ciphertext encrypted under a fixed key.</p>

    <p class="text-gray-300"><strong>Pair</strong> A <em>pair</em> is a set of two encryptions where the plaintexts are separated by a known difference.</p>

    <p class="text-gray-300"><strong>Family</strong> A <em>family</em> is a group of pairs with a particular structure. They are generated from a single pair <span class="math">\\{(p[0],\\dots,p[b-1]), (p&#x27;[0],\\dots,p&#x27;[b-1])\\}</span>, where <span class="math">p[i]</span> and <span class="math">p&#x27;[i]</span> are nibbles. Suppose that the input difference covers the first three nibbles so that <span class="math">p[3] = p&#x27;[3] = c[3], \\dots, p[b-1] = p&#x27;[b-1] = c[b-1]</span> for some constants <span class="math">c[i]</span>. Then the family corresponding to this pair is made by exchanging some nibbles between the two encryptions in the pair so as to obtain the following pairs:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (p[0], p[1], p[2], c[3], \\dots, c[b-1]) \\\\ (p&#x27;[0], p&#x27;[1], p&#x27;[2], c[3], \\dots, c[b-1]) \\end{array} \\right. \\quad \\left\\{ \\begin{array}{l} (p&#x27;[0], p[1], p[2], c[3], \\dots, c[b-1]) \\\\ (p[0], p&#x27;[1], p&#x27;[2], c[3], \\dots, c[b-1]) \\end{array} \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (p[0], p&#x27;[1], p[2], c[3], \\dots, c[b-1]) \\\\ (p&#x27;[0], p[1], p&#x27;[2], c[3], \\dots, c[b-1]) \\end{array} \\right. \\quad \\left\\{ \\begin{array}{l} (p[0], p[1], p&#x27;[2], c[3], \\dots, c[b-1]) \\\\ (p&#x27;[0], p&#x27;[1], p[2], c[3], \\dots, c[b-1]) \\end{array} \\right.</span></div>

    <p class="text-gray-300">Overall, if there are <span class="math">n</span> nibble with non-zero differences in the input then a family is made of <span class="math">2^{n-1}</span> pairs and <span class="math">2^n</span> encryptions.</p>

    <p class="text-gray-300">In the case of PRINCE, we consider differential trails where the input differences are only over one column and such that all the pairs in a family follow the same trail for the first three rounds. For example, the trails we describe in Section 4.2 are either followed by all the elements in a family or none of them. A similar heuristic is used in [16] to perform a multiset attack on the SASAS structure.</p>

    <p class="text-gray-300">This behaviour comes from the fact that the transition in the trails we study depend only on the transitions occurring during the first round, which are the same in all pairs of a family, and on the actual value of some nibbles to which the difference have not had the time to propagate, which are the same in all encryptions of the structure.</p>

    <p class="text-gray-300">We consider trails which are completely specified during the first 3 rounds and then propagate with probability 1 for 2.5 rounds before having spread to the full internal state. Figure 6 shows a first trail covering 5.5 rounds in this way which we denote  <span class="math">\\mathcal{T}_1</span> . Each array corresponds to the differences between the internal states of two encryptions under 6-round PRINCE and each cell gives the value of the difference: light gray corresponds to a fully specified non-zero value at the nibble level (e.g. a difference of 1), dark gray to an unknown non-zero difference and white to a zero difference. A very similar trail with a probability 2 times smaller,  <span class="math">\\mathcal{T}_2</span> , is given in Figure 14 (see Appendix C). To compute their probabilities, we use the difference distribution matrix of the S-Box. If we let the input difference be  <span class="math">(1,1,1,0,\\dots,0)</span> , then  <span class="math">\\mathcal{T}_1</span>  has a probability of  <span class="math">2^{-2\\cdot 3}\\cdot 2^{-2}\\cdot 2^{-2 - 2 - 3} = 2^{-15}</span>  and  <span class="math">\\mathcal{T}_2</span>  has a probability of  <span class="math">2^{-2\\cdot 3}\\cdot 2^{-2}\\cdot 2^{-2 - 3 - 3} = 2^{-16}</span> .</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6: The 5.5 rounds trail  <span class="math">\\mathcal{T}_1</span> .</p>

    <p class="text-gray-300">Querying enough families at random to find one right family for any of these would require  <span class="math">(2^{-15} + 2^{-16})^{-1} = 2^{14.41}</span>  families with an input difference over 3 nibbles, i.e.  <span class="math">2^{14.41} \\cdot 2^3 = 2^{17.41}</span>  encryptions. However, we can use structures to decrease this complexity.</p>

    <p class="text-gray-300">We note that the input differences which might lead to an output difference of 1 are those listed in Table 2. As we can see, the second bit from the right</p>

    <p class="text-gray-300">in little-endian notation is only involved in  <span class="math">0 \\times 2</span>  and  <span class="math">0 \\times b</span>  which, taken together, only have a probability of  <span class="math">1/4</span>  of leading to a difference of 1. Hence, we use the following structures where  <span class="math">b</span>  is a bit taking all possible values and  <span class="math">c</span>  is constant across the structure:</p>

    <p class="text-gray-300">bbcb bbcbb bbcb ccccc ccccc ... cccc.</p>

    <p class="text-gray-300">We found experimentally that such structures contain several <span class="math">^3</span>  right families with probability  <span class="math">2^{-5.9}</span>  on average when we take into account all possible input differences, i.e.  <span class="math">(\\delta, \\delta&#x27;, \\delta&#x27;&#x27;, 0, \\dots, 0)</span>  where  <span class="math">\\delta, \\delta&#x27;, \\delta&#x27;&#x27; \\in \\{1, 4, c, d\\}</span> . Hence, obtaining at least 2 right families only requires about  <span class="math">2^{9+5.9} = 2^{14.9}</span>  queries to the encryption oracle on average.</p>

    <p class="text-gray-300">Table 2: Input differences which might be mapped to a difference of 1 by the S-Box of PRINCE.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hexadecimal</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Binary</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Probability</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0x1</td>

            <td class="px-3 py-2 border-b border-gray-700">0001</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0x2</td>

            <td class="px-3 py-2 border-b border-gray-700">0010</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0x4</td>

            <td class="px-3 py-2 border-b border-gray-700">0100</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0xb</td>

            <td class="px-3 py-2 border-b border-gray-700">1011</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0xc</td>

            <td class="px-3 py-2 border-b border-gray-700">1100</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0xd</td>

            <td class="px-3 py-2 border-b border-gray-700">1101</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Full diffusion has been achieved by the 6-th round. Thus, we guess 12 bits to be able to partially invert the last round on one column. More precisely, we first guess the difference in one column before the last MixColumns for one pair. Each guess leads to a candidate for the corresponding column of  <span class="math">k_0&#x27; \\oplus k_1</span>  that we try against the three other pairs of the family. A guess leads to the correct nibble having a zero difference in every pair of the family with probability  <span class="math">2^{-3 \\cdot 4} = 2^{-12}</span> . We repeat this independently over each column and obtain either 64 bits of key material or none at all. Since there are either several right families or none at all in the structures we consider, we only return the key guesses which come from several families as well as the corresponding families.</p>

    <p class="text-gray-300">Note this is a powerful filter: while we expect each family from the structure to yield about one 64 bits candidates, the probability to have a collision is very small⁴.</p>

    <p class="text-gray-300">The same procedure is then used one round earlier to recover 48 bits of <span class="math">k_{1}</span>, corresponding to its three first columns. They allow us to partially decrypt the family and check whether differences after the third MixColumns are correct for the three first columns. The probability for a wrong family to pass this test is <span class="math">2^{-6 \\cdot 4 \\cdot 4} = 2^{-96}</span>, so we expect to be left with right families only. Finally, the missing 16 bits of <span class="math">k_{1}</span> are recovered by performing an exhaustive search.</p>

    <p class="text-gray-300"><strong>Complexity</strong>: Querying <span class="math">2^{5.9}</span> structures of <span class="math">2^{9}</span> chosen plaintexts to obtain at least 2 right families, the time complexity of the key recovery procedure is around <span class="math">2^{5.9 + 9} \\cdot 2^{12} \\cdot 7</span> partial encryptions, which is equivalent to <span class="math">2^{29.7} \\cdot \\frac{4}{6 \\cdot 16} \\approx 2^{25.1}</span> encryptions. The memory complexity is dominated by the storage of the <span class="math">2^{14.9}</span> required to run this attack.</p>

    <h2 id="sec-12" class="text-2xl font-bold">5.1 Attacking 4-Round PRINCE with a SAT-Solver</h2>

    <p class="text-gray-300"><strong>Encoding PRINCE as a CNF Formula</strong> The idea is to generate a CNF formula where a set <span class="math">p</span> of boolean variables correspond to the 64 bits of the plaintext, <span class="math">c</span> to the 64 bits of the ciphertext and <span class="math">k</span> to the 128 bits of the key, and such that there exists a unique assignment of the variables satisfying the CNF corresponding to the case <span class="math">E_{k}(p) = c</span>.</p>

    <p class="text-gray-300">Hence, if we generate such a formula, set the variables in <span class="math">p</span> and <span class="math">k</span> to a chosen value and use a SAT-solver to find an assignment satisfying the CNF formula, the variables in <span class="math">c</span> will correspond to the ciphertext. Solving such a formula is easy, an observation which we can relate to the fact that the evaluation of a block cipher has to be "easy" from the point of view of complexity theory.</p>

    <p class="text-gray-300">Another way to use such a formula is to fix the variables in <span class="math">p</span> and in <span class="math">c</span> according to a known plaintext/ciphertext pair, solve the CNF and recover the key from the variables corresponding to it. Unless the number of rounds is very small (at most 3 in the case of PRINCE), solving such a system is impractical. Again, we can relate this observation to the fact that recovering the key given one or several plaintext/ciphertext pair has to be "hard". Our approach consists in using some knowledge about the internal state of the cipher to simplify the task of the SAT-solver and make such a resolution possible for a higher number of rounds.</p>

    <p class="text-gray-300">In order to encode a PRINCE encryption as a CNF formula, we introduce several sets of 64 Boolean variables corresponding to each step of each round: one for the internal state at the beginning of the round <span class="math">(x_r)</span>, one for the internal</p>

    <p class="text-gray-300">⁴ Each structure yields <span class="math">2^{9-3} = 2^6</span> families for each of the <span class="math">4^3</span> interesting input differences so that we consider the families by groups of <span class="math">2^{12}</span>. This implies that a collision has a probability of about <span class="math">\\binom{2^{12}}{2} \\cdot 2^{-64} \\approx 2^{-41}</span>.</p>

    <p class="text-gray-300">state after going through the S-Box <span class="math">(y_r)</span>, etc. We also use boolean variables corresponding to the key bits.</p>

    <p class="text-gray-300">Our task is then to create a CNF formula connecting these variables in such a way as to ensure that, for instance if <span class="math">k[0,\\dots,63]</span> is fixed, it has only one solution where <span class="math">y_r[0,\\dots,63]</span> is indeed the image of <span class="math">x[0,\\dots,63]_r</span> by <span class="math">S</span>, etc.</p>

    <p class="text-gray-300">In order to encode the linear layer, we use the alternative representation of <span class="math">M&#x27;</span> from [10] where it was shown that <span class="math">M&#x27;</span> operates on columns of 4-bits independently by first rotating them by a column-dependent number of bit and then xor-ing the hamming weight of the column in each bit. We thus add variables corresponding to the hamming weights of the columns and encode the corresponding xor's as CNF formulas. The <span class="math">SR</span> operation is only a permutation of the bits so we simply set the corresponding bits to be equal.</p>

    <p class="text-gray-300">The encoding of the S-Box is less simple to obtain. In order to find the best one, we chose to look for it directly instead of using the ANF as an intermediate step. Indeed, since the S-Box is 4x4, it is small enough for us to brute-force all clauses involving input and output bits and check if they hold for every input.</p>

    <p class="text-gray-300">Doing this lead us to find 29 clauses with 3 variables. However, they are not sufficient to completely specify the S-Box so we used a greedy algorithm to find the best clauses with 4 variables to add to this encoding. In the end, we have 29 clauses with 3 variables and 9 clauses with 4 variables which are such that the only solutions of the CNF made of all these clauses are all the assignments corresponding to pairs <span class="math">(x, S(x))</span> for all <span class="math">x \\in [0,15]</span>.</p>

    <p class="text-gray-300">These clauses with 3 variables can be interpreted as simple implications. For example, if <span class="math">o[3,\\dots,0]_b = S(i[3,\\dots,0]_b)</span> then the following two clauses hold with probability 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(i [ 1 ] _ {b} \\vee o [ 2 ] _ {b} \\vee o [ 3 ] _ {b}\\right) \\wedge \\left(i [ 1 ] _ {b} \\vee o [ 1 ] _ {b} \\vee o [ 2 ] _ {b}\\right).</span></div>

    <p class="text-gray-300">They are logically equivalent to the following implication:</p>

    <div class="my-4 text-center"><span class="math-block">\\overline{i[1]_b} \\Rightarrow \\left((o[2]_b \\vee o[3]_b) \\wedge (o[1]_b \\vee o[2]_b)\\right).</span></div>

    <p class="text-gray-300"><strong>Differential Over Definition</strong> The approach consisting in using the knowledge from a differential trail to ease the task of a SAT-solver used to attack a cryptographic primitive has been explored in [17] in order to attack MD4 and MD5. The authors of this paper first use heuristic methods to find a high probability differential trail leading to a collision and then use a SAT-solver to find a pair of messages which satisfies this trail. In the same paper, we can find the following observation:</p>

    <p class="text-gray-300">An interesting result of our experiments with SAT solvers is the importance of having a differential path encoded in the formula.</p>

    <p class="text-gray-300">As we shall see, this also holds for block ciphers. Attacking 4 rounds PRINCE-core takes more than 10 hours if we simply encode as a CNF that some plaintext</p>

    <p class="text-gray-300">5 A clause is the logical OR of several variables, e.g. a \\lor b , a , \\overline{a} \\lor b \\lor \\overline{c} where \\overline{x} is the negation of x .</p>

    <p class="text-gray-300">are encrypted into known ciphertexts but we can both drastically reduce this time while breaking PRINCE with its whitening keys using <em>differential over-definition</em>.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> <em>We call Differential Over Definition (or DOD) the following algorithm which simplifies a CNF formula knowing that the variables correspond to bits of the internal state of an encryption following a certain trail.</em></p>

    <p class="text-gray-300"><em>For all pairs of variables in the CNF, proceed as follows:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>If they are assumed to be equal, replace all occurrences of the first one by the second one.</em></li>

      <li><em>If they are assumed to be different, replace all occurrences of the first one by the negation of the second one.</em></li>

    </ul>

    <p class="text-gray-300">While the idea behind this algorithm is simple, it is necessary for cryptographers to implement it efficiently “by hand”. Indeed, the only input of a SAT-solver is a CNF formula, i.e. merely a list of clauses from which deriving what variables are equal to each other without knowledge of the structure of the problem is far from trivial. For instance, it would be necessary for the SAT-solver to “understand” that the set of clauses used to model one S-Box call all correspond to a unique function so that identical inputs lead to identical outputs; all this without having any distinction between the input and output bits. That is why differential over-definition, an easy algorithm for the cryptographer to implement, is a valuable pre-processing step when using a SAT-solver for cryptography leading to gains in time complexity of several orders of magnitude.</p>

    <p class="text-gray-300">This algorithm can be implemented efficiently using a hashtable containing the correspondences between the variables. Once this algorithm has been run, the CNF is over defined: the solution would have been such that the equalities hold anyway but there are less variables and less clauses in the CNF. However, if the pair actually does not follow the trail, the CNF has become unsatisfiable. This is a difference between our work and the one described in [17]: we do not always know before hand if the CNF has a solution. We can think of this as a trade-off between “solving one CNF known to be true” and “solving many over-defined CNF’s which may or may not be true”: the second approach loses time by requiring several calls to a SAT-solver but these calls take less time thanks to the over-definition.</p>

    <p class="text-gray-300">Such an over definition can be used in different ways.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Propagating only the zero differences holding with probability 1 inside a group of 8 encryptions with many zero differences is enough to reduce the time complexity of an attack on 4 rounds from more than 10 hours to a few seconds (see below). Furthermore, such a formula is always true.</li>

      <li>Instead of implementing an algorithm recovering the key from a pair following a particular trail by peeling of layer after layer of encryption in our attack on 6 rounds described in the remainder of this section, we simply re-used the code of our attack on 4 rounds and over-defined the CNF modeling the encryptions of right pairs according to the high probability trail we used.</li>

    </ol>

    <p class="text-gray-300">We implemented the attack described in Algorithm 1 to attack 4-round PRINCE (with its whitening keys) using the SAT-solver Minisat [18] and obtained an average total time of 5.13s and average time spent solving the CNF of 3.06s. The designers of PRINCE did not consider SAT-based attacks but they did investigate algebraic attacks. They manage to attack 4-round PRINCE-core in less than 2s while our attack requires about 5s to attack 4-round PRINCE, a cipher which uses twice as much key material.</p>

    <p class="text-gray-300">Algorithm 1 Using Differential over-Definition to enable an attack on 4-round PRINCE. Query <span class="math">2^{10}</span> plaintext/ciphertexts where the first 10 bits take all possible values. Select a subset of 8 plaintext/ciphertext maximizing the number of 0-differences in the output. Encode the 8 encryptions as a CNF <span class="math">A</span>. Overdefine <span class="math">A</span> by propagating zero-differences with probability 1. Use a SAT-solver to retrieve the key bits from <span class="math">A</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">return $k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-13" class="text-2xl font-bold">5.2 Differential Attacks on 6-Round PRINCE</h2>

    <p class="text-gray-300">Another use possible use for a SAT-solver is the handling of the tedious details of an actual attack implementation, e.g. the finding of an efficient guessing strategy. We illustrate this by performing the recovery of the second chunk of the master key in our 6-round differential attack using a SAT-solver. Pseudo-code describing this attack on 6-round PRINCE is provided in Algorithm 2.</p>

    <p class="text-gray-300">We ran this attack 10 times and found that about <span class="math">2^{5.75}</span> structures were needed on average. The filtering step is the most time consuming: finding a right pair requires about 6 minutes while the SAT-solver requires about 0.5s to recover the full key or (rarely) to discard the pair. For this reason, we approximate the complexity of this attack by the complexity of its filtering step. Memory complexity is dominated by the SAT-solver but is (well) below 1 Go, i.e. (well) below <span class="math">2^{27}</span> 64-bits blocks.</p>

    <h2 id="sec-14" class="text-2xl font-bold">6 Structural Analysis of PRINCE</h2>

    <p class="text-gray-300">The <span class="math">\\alpha</span>-reflection introduced along with PRINCE [5] is the name given to the following property of a block cipher <span class="math">E_{k}</span>: <span class="math">E_{k}^{-1} = E_{k \\oplus \\alpha}</span>. In other words there is a constant <span class="math">\\alpha</span> such that decryption for a key <span class="math">k</span> is the same operation as encryption under key <span class="math">k \\oplus \\alpha</span>. PRINCE-core implements this property by having a three-parts structure as described here:</p>

    <div class="my-4 text-center"><span class="math-block">E_{c, k_{1}} = F_{k_{1} \\oplus \\alpha}^{-1} \\circ I \\circ F_{k_{1}},</span></div>

    <p class="text-gray-300">where <span class="math">F_{k}</span> corresponds to 5 rounds of a classical Substitution-Permutation Network construction and where <span class="math">I</span> is an involution.</p>

    <p class="text-gray-300">Since we are going to study the structure of the cycles of different functions in a fashion similar to the way Biryukov analysed the inner-rounds of some involutional ciphers in [19], we define the <em>cycle type</em> of a permutation.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> The cycle type of a permutation <span class="math">\\pi</span> is an (ordered) multiset containing the cycle lengths of the permutation. The cycle type of <span class="math">\\pi</span> is denoted by <span class="math">\\mathcal{L}(\\pi)</span>.</p>

    <p class="text-gray-300">In what follows, we do not represent the round constants for the sake of simplicity. However, not only do our result hold in their presence but we could actually generalize them to any key schedule preserving the fact that the subkeys of symmetric rounds have a XOR equal to <span class="math">\\alpha</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">6.1 Small Cycles in Round-Reduced PRINCE</h2>

    <p class="text-gray-300">The central involution is <span class="math">I = S^{-1} \\circ M&#x27; \\circ S</span>. Therefore, it is isomorphic to <span class="math">M&#x27;</span>, a linear involution operating on each column of the internal state independently. It is easy to check experimentally the result given in [7] stating that <span class="math">M&#x27;</span> has exactly <span class="math">2^{32}</span> fixed points, meaning that <span class="math">I</span> also has <span class="math">2^{32}</span> fixed points. Therefore, <span class="math">I</span> has <span class="math">2^{32}</span> cycles of length 1 and <span class="math">2^{63} - 2^{31}</span> cycles of length 2.</p>

    <p class="text-gray-300">The cycle type of <span class="math">I^{\\alpha}: x \\mapsto I(x) \\oplus \\alpha</span> is more sophisticated but still contains a fair amount of small cycles. After noting that both <span class="math">I</span> and <span class="math">x \\mapsto x \\oplus \\alpha</span> operate on each column of the internal space independently, we denote <span class="math">I_i^\\alpha</span> the restriction of <span class="math">x \\mapsto I(x) \\oplus \\alpha</span> to column <span class="math">i</span> and <span class="math">I_i</span> that of <span class="math">I</span>. Since each of the <span class="math">I_i^\\alpha</span>'s operates only on a space of size <span class="math">2^{16}</span>, it is easy to generate their complete cycle structures independently by searching the whole space. Each <span class="math">I_i^\\alpha</span> has a cycle type made of many "small" cycles, the largest having a length of 2844. This is explained by the fact that both <span class="math">I</span> and <span class="math">x \\mapsto x \\oplus \\alpha</span> are involutions and each column of <span class="math">I</span> has exactly <span class="math">2^8</span> fixed points. Thus, most of the cycles have a particular structure described in [20] which we recall in Figure 7. We remark that to each cycle of <span class="math">I_i^\\alpha</span> correspond two fixed points of <span class="math">I_i</span>.</p>

    <p class="text-gray-300">After generating the cycle type for each <span class="math">I_i^\\alpha</span>, we combine them to obtain the cycle type of <span class="math">x \\mapsto I(x) \\oplus \\alpha</span> using Algorithm 3. The cycle type of this function is too complex to be printed completely but some information extracted from it is given in Table 3. If we pick <span class="math">x</span> uniformly at random, the expected length of the cycle it is on is <span class="math">2^{30.7}</span>.</p>

    <p class="text-gray-300">Recall that <span class="math">E_{k_1}^{c,4}</span> is the permutation of <span class="math">\\{0,1\\}^{64}</span> corresponding to an encryption under key <span class="math">k_{1}</span> by PRINCE-core reduced to 4 rounds. Then <span class="math">x \\mapsto E_{k_1}^{c,4}(x) \\oplus \\alpha</span> has the same cycle type as <span class="math">I^{\\alpha}</span> due to the cancellation of the last round of one encryption with the first round of the next. Indeed, to each cycle of this function corresponds one of <span class="math">I^{\\alpha}</span>, as illustrated in Figure 8 where a cycle <span class="math">(x_0, x_1, x_2, x_3)</span> of length 4 of <span class="math">x \\mapsto E_{k_1}^{c,4}</span> is represented along with the corresponding cycle of <span class="math">I^{\\alpha}</span> (dashed line).</p>

    <p class="text-gray-300">6 While there are some cycles which do not have this structure, they are a small minority: for <span class="math">f_0</span>, 256 elements out of 65536 are on such cycles, 64 for <span class="math">f_1</span>, 8 for <span class="math">f_2</span> and 194 for <span class="math">f_3</span>.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7: The structure of a cycle of  <span class="math">I_{i}^{\\alpha}</span>  for  <span class="math">i \\in [0,3]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Cycle Length ℓ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#{cycles of length ℓ}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P[ℓ(x) = ℓ, x drawn uniformly]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2-57</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">210.25</td>

            <td class="px-3 py-2 border-b border-gray-700">2-53.75</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">215.46</td>

            <td class="px-3 py-2 border-b border-gray-700">2-48.54</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10080</td>

            <td class="px-3 py-2 border-b border-gray-700">233.06</td>

            <td class="px-3 py-2 border-b border-gray-700">2-17.63</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">110880</td>

            <td class="px-3 py-2 border-b border-gray-700">231.96</td>

            <td class="px-3 py-2 border-b border-gray-700">2-15.27</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≤ 210</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2-22.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≤ 215</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2-12.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">≤ 224</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2-4.1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Information about the cycle type of  <span class="math">I^{\\alpha}</span> , where  <span class="math">\\ell(x)</span>  is the length of the cycle on which  <span class="math">x</span>  is.</p>

    <p class="text-gray-300">A first consequence of these observations is the existence of a distinguisher for 4-round PRINCE-core requiring about  <span class="math">2^{27.4}</span>  adaptatively chosen plaintexts. As stated in Table 2, an element picked at random is on a cycle of length at most  <span class="math">2^{15}</span>  with probability  <span class="math">2^{-12.4}</span> . Therefore, we repeat multiple times the experiment consisting in picking an element  <span class="math">x</span>  uniformly at random and then check if it is on a cycle of length at most  <span class="math">2^{15}</span>  by iterating  <span class="math">x \\mapsto E_{k_1}^{c,4}(x) \\oplus \\alpha</span>  at most  <span class="math">2^{15}</span>  times. The experiment is a success if  <span class="math">x</span>  is on a cycle of length at most  <span class="math">2^{15}</span> . If the permutation is  <span class="math">E_{k_1}^{c,4}</span>  for some  <span class="math">k_1</span> , then its probability of success is  <span class="math">2^{12.4}</span>  but if the permutation is a random permutation <span class="math">^7</span> , then the probability of success becomes  <span class="math">2^{-49}</span> . We confirmed experimentally the success probability of this experiment for  <span class="math">E_{k_1}^{c,4}</span> .</p>

    <p class="text-gray-300">A second consequence is the existence of "small" sets of plaintext/ciphertext encryptions where the set of the ciphertexts is the image of the set of the encryptions by a function significantly simpler than a PRINCE encryption. This topic is studied in the next section.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 8: Correspondance between a cycle of  <span class="math">x \\mapsto E_{k_1}^{c,4}(x) \\oplus \\alpha</span>  and a cycle of  <span class="math">I^{\\alpha}</span> .</p>

    <p class="text-gray-300">The particular cycle types of the round-reduced versions of PRINCE studied above lead to simpler alternative representations of the encryption algorithm.</p>

    <p class="text-gray-300">Consequences of the Cycle Type of  <span class="math">I</span>  Suppose that an encryption is such that the input of  <span class="math">I</span>  is one of the  <span class="math">2^{32}</span>  fixed-points of this function. Then the key addition before and after this function cancel each other so that only the addition of  <span class="math">\\alpha</span>  remains. Then, since  <span class="math">M</span>  is linear, the operations  <span class="math">M^{-1} \\circ (\\oplus \\alpha) \\circ M</span>  become simply the addition of  <span class="math">M^{-1}(\\alpha)</span> . Thus, the 4 center rounds — minus the first and last key addition — become a simple S-Box layer which we denote  <span class="math">S&#x27;</span>  and which is defined by</p>

    <div class="my-4 text-center"><span class="math-block">S ^ {\\prime} (x) = S ^ {- 1} \\bigl (S (x) \\oplus M ^ {- 1} (\\alpha) \\bigr).</span></div>

    <p class="text-gray-300">This simplifying process is summarized in Figure 9. Note that if  <span class="math">M^{-1}(\\alpha)</span>  has any nibble equal to 0 then the function  <span class="math">S&#x27;</span>  is the identity for this nibble. However, for the value of  <span class="math">\\alpha</span>  chosen by the designers of PRINCE, there is no such nibble.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 9: Simplification of the 4 center-rounds if the input of  <span class="math">I</span>  is a fixed point.</p>

    <p class="text-gray-300">The simplification goes further. Indeed, since  <span class="math">S&#x27;</span>  operates only at the nibble level, it commutes with the operations  <span class="math">SR</span>  and  <span class="math">SR^{-1}</span>  (up to a reordering of the S-Boxes in  <span class="math">S&#x27;</span> ). Therefore, if we add one round before and one round after  <span class="math">S&#x27;</span> , we can replace  <span class="math">SR^{-1} \\circ S&#x27; \\circ SR</span>  by  <span class="math">S&#x27;&#x27;</span>  where  <span class="math">S&#x27;&#x27;</span>  is another S-Box layer. Hence, 6-round of PRINCE operate on each column of the internal state independently: each output bit depends only on 16 bits of the input, 28 bits <span class="math">^8</span>  of  <span class="math">k_1</span>  and at most 18 bits of  <span class="math">k_0</span> . This simplification is summarized in Figure 10.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 10: Simplification of the 6 center-rounds if the input of  <span class="math">I</span>  is a fixed point.</p>

    <p class="text-gray-300">Similar simplifications occur if instead of having a fixed point we have a particular collision between two encryptions. This setting corresponds to the so-called mirror slide attack described by Dunkelman et al. in [21]. Consider two</p>

    <p class="text-gray-300">encryptions <span class="math">(p^0,c^0)</span> and <span class="math">(p^1,c^1)</span> by PRINCE-core as follows</p>

    <div class="my-4 text-center"><span class="math-block">c ^ {0} = E _ {c, k _ {1}} \\left(p ^ {0}\\right) = \\left(F _ {k _ {1} \\oplus \\alpha} ^ {- 1} \\circ I \\circ F _ {k _ {1}}\\right) \\left(p ^ {0}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">c ^ {1} = E _ {c, k _ {1}} \\left(p ^ {1}\\right) = \\left(F _ {k _ {1} \\oplus \\alpha} ^ {- 1} \\circ I \\circ F _ {k _ {1}}\\right) \\left(p ^ {1}\\right)</span></div>

    <p class="text-gray-300">which are such that <span class="math">F_{k_1}(p^0) = I\\big(F_{k_1}(p^1)\\big)</span>. In this case, we have that</p>

    <div class="my-4 text-center"><span class="math-block">c ^ {0} = \\left(F _ {k _ {1} \\oplus \\alpha} ^ {- 1} \\circ F _ {k _ {1}}\\right) \\left(p ^ {1}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">c ^ {1} = \\left(F _ {k _ {1} \\oplus \\alpha} ^ {- 1} \\circ F _ {k _ {1}}\\right) (p ^ {0}),</span></div>

    <p class="text-gray-300">where 6 rounds of <span class="math">F_{k_1\\oplus \\alpha}^{-1}\\circ F_{k_1}</span> can be simplified exactly as described and therefore only operate on each column separately.</p>

    <p class="text-gray-300">In conclusion, if an encryption is such that the input of <span class="math">I</span> is a fixed-point of this function or if two encryptions form a mirror slide pair, then 4 rounds of PRINCE consist simply in 16 parallel operations on each nibble and 6 rounds of PRINCE in 4 parallel operations on each column.</p>

    <p class="text-gray-300">Consequences of the Cycle type of <span class="math">I^{\\alpha}</span> Consider a sequence of plaintexts <span class="math">(p^0, \\ldots, p^{t-1})</span> and their corresponding ciphertexts <span class="math">(c^0, \\ldots, c^{t-1})</span> such that the input <span class="math">x_5^i \\oplus k_1</span> of the sixth round for the plaintext <span class="math">p^i</span> is the image of <span class="math">x_5^{i-1} \\oplus k_1</span> by <span class="math">I^{\\alpha}</span>. We call such a sequence a cycle set and we give a representation of such a sequence on Figure 11: if two values are equal then they are connected by a line; red lines correspond to the cycle of <span class="math">I^{\\alpha}</span> this set is built out of and blue lines correspond to the propagation of these equalities through identical operations, namely <span class="math">x \\mapsto k_1 \\oplus R^{-1}(x \\oplus k_1)</span>.</p>

    <p class="text-gray-300">There is a unique function mapping <span class="math">p^i</span> to <span class="math">c^{i-1}</span> in every cycle set which corresponds to the encryption algorithm where the 4 center-rounds have been removed and replaced by a simple addition of <span class="math">\\alpha</span>. This means that this function undergoes the simplifications described above except that these cover 2 more rounds. In particular, for 6-round PRINCE-core, the function mapping <span class="math">p^i</span> to <span class="math">c^{i-1}</span> only operates at the nibble level and, for 8-round PRINCE-core, it operates at the column level. At least 10 rounds are necessary to obtain full diffusion out of the 12 PRINCE has.</p>

    <p class="text-gray-300">The cycle sets we consider cover the 4 center-rounds of PRINCE but it is possible to generalize this construction to an arbitrary amount of rounds. However, the cycle set sizes are abnormally small in this case because of the cycle type of <span class="math">I^{\\alpha}</span>. Indeed, a random plaintext/ciphertext pair is in a cycle set of size <span class="math">2^{30.7}</span> and in a cycle set of size smaller than <span class="math">2^{15}</span> with probability <span class="math">2^{-12.4}</span>. In other cases, including a priori if we have a cycle covering at least 6 rounds, the expected size of a cycle set is the expected size of the cycle of a random permutation a random element is on, namely <span class="math">2^{63}</span>.</p>

    <p class="text-gray-300">Should the cycle sets of PRINCE become identifiable, the security of up to 8 rounds may be compromised as the alternative versions of the cipher we described in this Section are much weaker than the original cipher. Furthermore, since small cycles are not unlikely to be found, the data complexity of such an attack may remain feasible.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 11: A cycle set of 6-round PRINCE-core.</p>

    <p class="text-gray-300">We looked for practical attacks which would hinder the security provided by round-reduced versions of PRINCE in a realistic framework provided by the designers of this cipher. We found that approaches based on a Meet-in-the-Middle, SAT-based or, surprisingly, differential framework can all lead to practical attacks on up to half of the rounds. We checked our results by actually implementing one of our attacks. As a matter of fact, our attacks were the best submitted to the PRINCE-challenge for 4, 6 and 8 rounds. Furthermore, during our investigations on PRINCE we discovered a new attack on 10 rounds which despite its data complexity of  <span class="math">2^{57}</span>  chosen plaintexts has a reasonable complexity and a very (very!) motivated adversary could run it.</p>

    <p class="text-gray-300">We also identified some simplifications of the encryption occurring because of the small cycles of the inner-rounds of this block cipher, thus shedding new light on the consequences of the  <span class="math">\\alpha</span> -reflection as it is implemented in PRINCE.</p>

    <p class="text-gray-300">The authors thank Alex Biryukov for useful discussions about the differential attack on PRINCE. We also thank NXP Semiconductors for organizing the PRINCE challenge and sending us our rewards! The work of the authors was supported by the CORE ACRYPT project (ID C12-15-4009992) funded by the Fonds National de la Recherche (Luxembourg).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Biham, E., Shamir, A.: Differential cryptanalysis of DES-like cryptosystems. Journal of CRYPTOLOGY 4(1) (1991) 3–72</li>

      <li>Matsui, M.: Linear cryptoanalysis method for DES cipher. In: Advances in Cryptology - EUROCRYPT 93, Workshop on the Theory and Application of Cryptographic Techniques, Lofthus, Norway, May 23–27, 1993, Proceedings. (1993) 386–397</li>

      <li>Demirci, H., Selçuk, A.A.: A meet-in-the-middle attack on 8-round AES. In: Fast Software Encryption, Springer (2008) 116–126</li>

      <li>Semiconductors, N.: The PRINCE challenge. https://www.emsec.rub.de/research/research_startseite/prince-challenge/ (2014)</li>

      <li>Borghoff, J., Canteaut, A., Güneysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., et al.: PRINCE – a low-latency block cipher for pervasive computing applications. In: Advances in Cryptology–ASIACRYPT 2012. Springer (2012) 208–225</li>

      <li>Biryukov, A., Perrin, L.: State of the art in lightweight cryptography. http://cryptolux.org/index.php/Lightweight_Cryptography</li>

      <li>Soleimany, H., Blondeau, C., Yu, X., Wu, W., Nyberg, K., Zhang, H., Zhang, L., Wang, Y.: Reflection cryptanalysis of PRINCE-like ciphers. Journal of Cryptology (2013) 1–27</li>

      <li>Jean, J., Nikolić, I., Peyrin, T., Wang, L., Wu, S.: Security analysis of prince. In: Fast Software Encryption: 20th International Workshop, FSE 2013, Singapore, March 11–13, 2013. Revised Selected Papers. Volume 8424., Springer (2014) 92</li>

      <li>Li, L., Jia, K., Wang, X.: Improved meet-in-the-middle attacks on aes-192 and prince. Cryptology ePrint Archive, Report 2013/573 (2013) http://eprint.iacr.org/.</li>

      <li>Canteaut, A., Fuhr, T., Gilbert, H., Naya-Plasencia, M., Reinhard, J.R.: Multiple differential cryptanalysis of round-reduced PRINCE (full version). Cryptology ePrint Archive, Report 2014/089 (2014) http://eprint.iacr.org/.</li>

      <li>Rechberger, C.: Update on the 10000 euro PRINCE cipher-breaking challenge: Results of round-1. http://crypto.2014.rump.cr.yp.to/d037206eda8f9278cef1ea26cd62e51f.pdf (2014)</li>

      <li>Dunkelman, O., Keller, N., Shamir, A.: Improved single-key attacks on 8-round AES-192 and AES-256. In: Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5–9, 2010. Proceedings. (2010) 158–176</li>

      <li>Derbez, P., Fouque, P.: Exhausting Demirci-Selçuk meet-in-the-middle attacks against reduced-round AES. In: Fast Software Encryption - 20th International Workshop, FSE 2013, Singapore, March 11–13, 2013. Revised Selected Papers. (2013) 541–560</li>

      <li>Derbez, P., Fouque, P.A., Jean, J.: Improved Key Recovery Attacks on Reduced-Round AES in the Single-Key Setting. In Johansson, T., Nguyen, P.Q., eds.: EUROCRYPT. Volume 7881 of Lecture Notes in Computer Science., Springer (2013) 371–387</li>

      <li>Abed, F., List, E., Lucks, S.: On the security of the core of prince against biclique and differential cryptanalysis. Cryptology ePrint Archive, Report 2012/712 (2012) http://eprint.iacr.org/.</li>

      <li>Biryukov, A., Shamir, A.: Structural cryptanalysis of SASAS. In Pfitzmann, B., ed.: Advances in Cryptology – EUROCRYPT 2001. Volume 2045 of Lecture Notes in Computer Science. Springer Berlin Heidelberg (2001) 395–405</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mironov, I., Zhang, L.: Applications of sat solvers to cryptanalysis of hash functions. In Biere, A., Gomes, C., eds.: Theory and Applications of Satisfiability Testing - SAT 2006. Volume 4121 of Lecture Notes in Computer Science. Springer Berlin Heidelberg (2006) 102-115</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eén, N., Sörensson, N.: An extensible SAT-solver. In: Theory and applications of satisfiability testing, Springer (2004) 502-518</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Biryukov, A.: Analysis of involutional ciphers: Khazad and Anubis. In: Fast Software Encryption, Springer (2003) 45-53</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Moore, J.H., Simmons, G.J.: Cycle structure of the DES with weak and semi-weak keys. In: Advances in Cryptology-CRYPTO'86, Springer (1987) 9-32</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Dunkelman, O., Keller, N., Shamir, A.: Minimalism in cryptography: the even-mansour scheme revisited. In: Advances in Cryptology-EUROCRYPT 2012. Springer (2012) 336-354</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2 Using trails T1,T2 and a SAT-solver to recover the complete key k0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k1 of 6-round PRINCE.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">while the key has not been retrieved do Query a structure S = ((p0,c0),..., (p212-1, c212-1) H ← empty hashtable of lists of families indexed by 64-bits integers for all families F in S do for one pair in F do for all columns of the internal state do for all the 212 possible differences do Deduce the corresponding 16-bit key material k16 for all remaining pairs in F do Invert key addition for the column using k16 Invert S-1 for the column Invert M' for the column end for if correct nibble has zero difference in all pairs then store k16 end for end for end for Combine all guesses from each column into 64-bits guesses for all 64-bits guesses k64 append F to H[k64] end for for all k64 among the keys of H do if H[k64] contains strictly more than 1 element then for all families F in H[k64] do Generate a CNF A encoding all encryptions in F with same key such that k1 + L(k0) = k64. for all trails T in {T1,T2} do B ← DoD(A,T) if B is satisfiable then retrieve k0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">k1 from the solution of B and return it end for end for end if end for end while</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 3 Generating the cycle type of  <span class="math">I^{\\alpha}</span>  from those of its columns. for  <span class="math">i\\in [0,3]</span>  do  <span class="math">\\mathcal{L}_i\\gets</span>  List of the cycle length of  <span class="math">I_i^\\alpha</span> end for <span class="math">\\mathcal{L}\\gets</span>  Hashtable indexed by integers for  <span class="math">(\\ell_0,\\ell_1,\\ell_2,\\ell_3)\\in \\mathcal{L}_0\\times \\mathcal{L}_1\\times \\mathcal{L}_2\\times \\mathcal{L}_3</span>  do  <span class="math">\\ell \\leftarrow \\operatorname {lcm}\\bigl (\\ell_0,\\ell_1,\\ell_2,\\ell_3\\bigr)</span> <span class="math">\\mathcal{L}[\\ell ]\\gets \\mathcal{L}[\\ell ] + \\ell^{-1}\\cdot \\prod_{i = 0}^{3}\\ell_{i}</span> end for return  <span class="math">\\mathcal{L}</span></p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 12: 6r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Fig. 13: 8r attack. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Fig. 14: The second 5.5 rounds trail  <span class="math">\\mathcal{T}_2</span> .</p>

    <p class="text-gray-300">In this section we describe two attacks on round-reduced Prince. Both are simple meet-in-the-middle attacks requiring only few known plaintext/ciphertext pairs to work.</p>

    <p class="text-gray-300">Simple Attack. We begin by presenting a simple attack on 4-round Prince with a complexity around  <span class="math">2^{40}</span>  which is depicted on Figure 15. It is based on the two following equations involving few bits of the middle states  <span class="math">y</span>  and  <span class="math">y&#x27;</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{c} y [ 3 8 ] _ {b} \\oplus y [ 4 6 ] _ {b} = y ^ {\\prime} [ 3 8 ] _ {b} \\oplus y ^ {\\prime} [ 4 6 ] _ {b} \\\\ y [ 3 9 ] _ {b} \\oplus y [ 4 3 ] _ {b} \\oplus y [ 4 7 ] _ {b} = y ^ {\\prime} [ 4 7 ] _ {b} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Let  <span class="math">K_{p}</span>  (resp.  <span class="math">K_{c}</span> ) be the key bits required to compute  <span class="math">y[38]_b \\oplus y[46]_b</span>  and  <span class="math">y[39]_b \\oplus y[43]_b \\oplus y[47]_b</span>  from  <span class="math">p</span>  (resp.  <span class="math">y&#x27;[38]_b \\oplus y&#x27;[46]_b</span>  and  <span class="math">y&#x27;[47]_b</span>  from  <span class="math">c</span> ). Then the attacks scenario is:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ask for  <span class="math">n</span>  known plaintext/ciphertext pairs.</li>

      <li>Let  <span class="math">T</span>  be an empty hash table.</li>

      <li>For all possible values of  <span class="math">K_{p}</span>  do</li>

    </ol>

    <p class="text-gray-300">(a) for  <span class="math">j</span>  from 1 to  <span class="math">n</span>  compute  <span class="math">y^{j}[38]_{b} \\oplus y^{j}[46]_{b}</span>  and  <span class="math">y^{j}[39]_{b} \\oplus y^{j}[43]_{b} \\oplus y^{j}[47]_{b}</span>  from the  <span class="math">j</span> -th plaintext (b) make the sequence  <span class="math">s = \\left[y^{1}[38]_{b} \\oplus y^{1}[46]_{b}, y^{1}[39]_{b} \\oplus y^{1}[43]_{b} \\oplus y^{1}[47]_{b}, \\ldots\\right]</span> (c) add the value of  <span class="math">K_{p}</span>  to  <span class="math">T[s]_b</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all possible values of  <span class="math">K_{c}</span>  do</li>

    </ol>

    <p class="text-gray-300">(a) for  <span class="math">j</span>  from 1 to  <span class="math">n</span>  compute  <span class="math">y&#x27;^{j}[38]_{b} \\oplus y&#x27;^{j}[46]_{b}</span>  and  <span class="math">y^{j}[47]_{b}</span>  from the  <span class="math">j</span> -th ciphertext (b) make the sequence  <span class="math">s = \\left[y^{\\prime 1}[38]_b\\oplus y^{\\prime 1}[46]_b,y^{\\prime 1}[47]_b,\\ldots \\right]</span> (c) check whether  <span class="math">T[s]</span>  is empty or not. If  <span class="math">T[s]</span>  is empty then the guess of  <span class="math">K_{c}</span>  is wrong. Otherwise,  <span class="math">T[s]</span>  contains the possible value(s) for  <span class="math">K_{p}</span>  and, if  <span class="math">n</span>  is large enough, this will happen only for the right guess.</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Fig. 15: 4r attack. Hatched bits play no role.</p>

    <p class="text-gray-300">In our case, both  <span class="math">K_{p}</span>  and  <span class="math">K_{c}</span>  can assume only  <span class="math">2^{40}</span>  values and thus 40 plaintext/ciphertext pairs are enough to get only one candidate for  <span class="math">K_{p} \\cup K_{c}</span>  with high probability. Thus the complexity of this attack is 40 known plaintexts and around  <span class="math">2^{40}</span>  for both time and memory.</p>

    <p class="text-gray-300">Saving data and memory. First we stress that  <span class="math">K_{P}</span>  (resp.  <span class="math">K_{C}</span> ) can be safely replaced by any basis of the vector space spawned by itself so let consider it as a vector space over  <span class="math">\\mathbb{F}_2</span> . Now we are interested by the vector space  <span class="math">K_{P} \\cap K_{C}</span> . Here a basis of this vector space is:</p>

    <p class="text-gray-300"><span class="math">\\{k_{1}[36..39]_{b}, k_{1}[44..47]_{b}, k_{0}[37..39]_{b}, k_{0}[45..47]_{b}, k_{0}[40]_{b} \\oplus \\ldots \\oplus k_{0}[44]_{b} \\oplus k_{1}[40]_{b} \\oplus \\ldots \\oplus k_{1}[43]_{b}\\}</span> .</p>

    <p class="text-gray-300">Thus only 33 plaintext/ciphertext pairs are needed to discard the wrong guesses and the attack scenario becomes:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ask for  <span class="math">n</span>  known plaintext/ciphertext pairs.</li>

      <li>For all possible values of  <span class="math">K_{p} \\cap K_{c}</span>  do</li>

    </ol>

    <p class="text-gray-300">(a) Let  <span class="math">T</span>  be an empty hash table.</p>

    <p class="text-gray-300">(b) Partially encrypt/decrypt the plaintext/ciphertext pairs. (c) For all possible values of  <span class="math">K_{p}</span>  do</p>

    <p class="text-gray-300">i. for  <span class="math">j</span>  from 1 to  <span class="math">n</span>  compute  <span class="math">y^{j}[38]_{b} \\oplus y^{j}[46]_{b}</span>  and  <span class="math">y^{j}[39]_{b} \\oplus y^{j}[43]_{b} \\oplus y^{j}[47]_{b}</span>  from the  <span class="math">j</span> -th plaintext ii. make the sequence  <span class="math">s = \\left[y^{1}[38]_{b} \\oplus y^{1}[46]_{b}, y^{1}[39]_{b} \\oplus y^{1}[43]_{b} \\oplus y^{1}[47]_{b}, \\ldots\\right]</span> iii. add the value of  <span class="math">K_{p}</span>  to  <span class="math">T[s]</span></p>

    <p class="text-gray-300">(d) For all possible values of  <span class="math">K_{c}</span>  do</p>

    <p class="text-gray-300">i. for  <span class="math">j</span>  from 1 to  <span class="math">n</span>  compute  <span class="math">y^{\\prime j}[38]_b\\oplus y^{\\prime j}[46]_b</span>  and  <span class="math">y^{j}[47]_{b}</span>  from the  <span class="math">j</span>  -th ciphertext ii. make the sequence  <span class="math">s = \\left[y^{\\prime 1}[38]_b\\oplus y^{\\prime 1}[46]_b,y^{\\prime 1}[47]_b,\\ldots \\right]</span> iii. check whether  <span class="math">T[s]</span>  is empty or not. If  <span class="math">T[s]</span>  is empty then the guess of  <span class="math">K_{c}</span>  is wrong. Otherwise,  <span class="math">T[s]</span>  contains the possible value(s) for  <span class="math">K_{p}</span>  and, if  <span class="math">n</span>  is large enough, this will happen only for the right guess.</p>

    <p class="text-gray-300">All in all the memory requirement is approximately  <span class="math">25 \\times 2^{25} \\times 2^{-3} \\approx 2^{26.7}</span>  bytes and the time complexity around  <span class="math">33 \\times 2 \\times 2^{40} \\times 40 / (4 \\times 64) \\approx 2^{43.4}</span>  encryptions.</p>

    <p class="text-gray-300">Key recovery. At the end of the attack we know (or have very few candidates for)  <span class="math">K_{p} \\cup K_{c}</span> . But we still need  <span class="math">128 - 65 = 63</span>  key bits to fully recover  <span class="math">k_{0}</span>  and  <span class="math">k_{1}</span> . Performing an exhaustive search at this point would increase the overall complexity of the attack and thus is not a good idea. Instead, it is better to perform another meet-in-the-middle attacks successively. For instance, the attack depicted in Figure 16 allows to recover 20 more key bits with a time complexity around  <span class="math">2^{20}</span> .</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> Fig. 16: 4r attack. black bits are known. Hatched bits play no role.</p>

    <p class="text-gray-300">The 4-round attack can be extended to a 6-round attack as depicted on Figure 17. Now the dimension of both  <span class="math">K_{p}</span>  and  <span class="math">K_{c}</span>  is 96 and the dimension of the intersection is 64. Thus it leads to an attacks requiring  <span class="math">(2 \\times 96 - 64) / 2 = 64</span>  known plaintext/ciphertext pairs, with a memory complexity around  <span class="math">(96 - 64) \\times 2^{96 - 64} \\times 2^{-3} = 2^{34}</span></p>

    <p class="text-gray-300">!<a href="img-16.jpeg">img-16.jpeg</a> Fig. 17: 6r attack. Hatched bits play no role.</p>

    <p class="text-gray-300">bytes and a time complexity of approximately  <span class="math">2 \\times 64 \\times 2^{96} \\times 104 / (6 \\times 64) \\approx 2^{101.1}</span>  encryptions.</p>

    <p class="text-gray-300">Finally, an exhaustive search can be performed to retrieve  <span class="math">k_{0}</span>  and  <span class="math">k_{1}</span>  without increasing the overall complexity.</p>

    <p class="text-gray-300">In this section we concisely describe a second attack against 8-round PRINCE, still based on Demirci and Selçuk technique, requiring much less memory than the attack described Section 3.2.</p>

    <p class="text-gray-300">The first step of the attack is depicted on Figure 18. This is a classical Demirci and Selçuk attack against 8-round PRINCE. The nibble requiback in the online phase are in gray and can take  <span class="math">2^{8 \\times 4} = 2^{32}</span>  values. In another hand, nibbles requiback in the offline phase are in black and can assume  <span class="math">2^{80}</span>  values thanks to the (lack of) key schedule.</p>

    <p class="text-gray-300">Here  <span class="math">\\delta</span> -sets contain  <span class="math">2^{4} = 16</span>  messages and the check is performed on sequences of  <span class="math">(16 - 1) = 15</span>  differences in one nibble, i.e. on 60-bit sequences. As more than  <span class="math">2^{60}</span>  sequences are computed during the offline phase, the attack does not filter values of gray nibbles.</p>

    <p class="text-gray-300">The idea is to switch the online and the offline phases (and actually they are now both performed online). Given a plaintext/ciphertext pair  <span class="math">(P, C)</span>  we compute the  <span class="math">2^{32}</span>  possible 60-bit sequences and store them in a hash table. Then for each value</p>

    <p class="text-gray-300">!<a href="img-17.jpeg">img-17.jpeg</a> Fig. 18: Step 1. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">of the black nibbles, we compute the corresponding 60-bit sequence and check whether it belongs to the hash table. Only  <span class="math">2^{80 - 60 + 32} = 2^{52}</span>  values should pass this test.</p>

    <p class="text-gray-300">We notice that, given a structure of  <span class="math">2^{16}</span>  plaintexts such that the first column is active while the other ones are constant, each column of state  <span class="math">y_{3}</span>  takes all the possible values too. Hence we can fix the value to 0 of 4 black nibbles of  <span class="math">y_{4}</span>  (shiftrows of a column), decreasing the time complexity by a factor  <span class="math">2^{16}</span> . As a result, the hash table now has to contain  <span class="math">2^{48}</span>  sequences,  <span class="math">2^{32}</span>  for each of the  <span class="math">2^{16}</span>  plaintext/ciphertext pairs.</p>

    <p class="text-gray-300">To decrease further the number of possible values for the black nibbles, we apply the same attack but we change the nibble on which the check is performed as shown on Figure 19. So we have to store an other table containing  <span class="math">2^{48}</span>  60-bit sequences and guess the value of the black nibble of  <span class="math">y_2&#x27;</span> . Only  <span class="math">2^{52 + 4 - 60 + 48} = 2^{44}</span>  values should pass this test.</p>

    <p class="text-gray-300">As in step 4, we perform the two others attacks corresponding to the two other positions for the black nibble on  <span class="math">y_2&#x27;</span> . Only  <span class="math">2^{28}</span>  values should pass this test.</p>

    <p class="text-gray-300">!<a href="img-18.jpeg">img-18.jpeg</a> Fig. 19: Step 4. No difference in white nibbles. Nibbles required in online (resp. offline) phase are in gray (resp. black). Differences in dotted nibbles are known during the offline phase. Hatched nibbles play no role.</p>

    <p class="text-gray-300">We switch again online and offline phases, coming back to a classical Demirci and SelAğuk attack. We run successively the four previous attacks to retrieve a unique plaintext/ciphertext pair together with a unique value for the first column of  <span class="math">y_{1}</span>  and the whole state  <span class="math">y_{1}^{\\prime}</span> . Indeed, we did not check whether the plaintext/ciphertext pair and the first column of  <span class="math">y_{1}</span>  are the same for the four attacks, while they have to. Thus only the right ones should remain at the end of the attack.</p>

    <p class="text-gray-300">The missing 48 bits of the key can be exhausted.</p>

    <p class="text-gray-300">The data complexity is  <span class="math">2^{16}</span>  chosen plaintexts. The memory complexity is around  <span class="math">4 \\times 2^{48}</span>  60-bit sequences which is equal to  <span class="math">2^{52.9}</span>  bytes. The time complexity is dominated by steps  <span class="math">2/3</span> , which is equivalent to  <span class="math">2^{64} \\times 2^4 \\times (42 - 4) / (8 \\times 16) \\simeq 2^{66.25}</span>  encryptions.</p>`;
---

<BaseLayout title="Meet-in-the-Middle Attacks and Structural Analysis of Round-... (2015/239)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/239
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
