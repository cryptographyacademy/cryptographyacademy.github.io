---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2007/395';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Second Preimage Attacks on Dithered Hash Functions';
const AUTHORS_HTML = 'Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir, Sebastien Zimmer';

const CONTENT = `    <p class="text-gray-300">Charles Bouillaguet<span class="math">^{1}</span>, Pierre-Alain Fouque<span class="math">^{1}</span>, Adi Shamir<span class="math">^{1,2}</span>, and Sebastien Zimmer<span class="math">^{1}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> École normale supérieure Département d’Informatique 45, rue d’Ulm 75230 Paris cedex 05, France Charles.Bouillaguet@ens.fr, Pierre-Alain.Fouque@ens.fr, Sebastien.Zimmer@ens.fr</p>

    <p class="text-gray-300">2 Weizmann Institute of Science Adi.Shamir@weizmann.ac.il</p>

    <p class="text-gray-300">Abstract. The goal of this paper is to analyze the security of dithered variants of the Merkle-Damgård mode of operation that use a third input to indicate the position of a block in the message to be hashed. These modes of operation for hash functions have been proposed to avoid some structural weaknesses of the Merkle-Damgard paradigm, e.g. that second preimages can be constructed in much less than <span class="math">2^{n}</span> work, as pointed out by Kelsey and Schneier. Among the modes of operation that use such a third input are Rivest’s dithered hashing and Biham and Dunkelman’s HAIFA proposal.</p>

    <p class="text-gray-300">We propose several new second preimage attacks on the Merkle-Damgård mode of operation, which can also attack Rivest’s dithered hash with almost the same complexity. When applied to Shoup’s UOWHF, these attacks can be shown to be optimal since their complexity matches Shoup’s security bound.</p>

    <p class="text-gray-300">Keywords: Cryptanalysis, Hash Function, Dithering</p>

    <p class="text-gray-300">Hash functions have recently been the subject of numerous attacks which have highlighted many weaknesses (either on some specific hash functions or on the general Merkle-Damgård mode of operation). Wang et al. [29–32], Biham et al. [3], Klima [19] and Joux et al. [14] all show that differential attacks can be used to efficiently find collisions in specific hash functions based on the MD4 design such as MD5, RIPEMD, SHA-0 and SHA-1. This type of results is important for at least two reasons. First, collision resistance is a classical property that hash function should have. In addition, if collisions were easy to construct, perhaps it would become easier to mount stronger types of attacks which rely on the possibility to find collisions, such as Joux’s [13] multicollision attack on combiners. Following this result, Kelsey and Schneier [16] extended a previous result of Dean [8], and showed that Joux’s idea can be used to mount an efficient second preimage attack. All these attacks led the NIST to organize workshops and to solicit new hash function candidates.</p>

    <p class="text-gray-300">After Kelsey and Schneier published their attack, several researchers proposed to tweak the Merkle-Damgård paradigm, using a third input (called “dithering”) to avoid attacks based on fixed points that can be iterated an arbitrary number of times. In this paper, we study the second preimage resistance of such dithered modes of operation, which is crucial for the security of signature schemes based on the “hash-and-sign” paradigm.</p>

    <p class="text-gray-300">1.1 Related Work</p>

    <p class="text-gray-300">Independently of the Ph.D thesis of Dean <em>[8]</em>, Kelsey and Schneier <em>[16]</em> presented at EUROCRYPT 2005 a second preimage attack that works against all hash functions based on the Merkle-Damgård construction. The complexity of their attack is <span class="math">k\\cdot 2^{n/2+1}+2^{n-k+1}</span> evaluations of the compression function. It relies on <em>expandable messages</em>, <em>i.e.</em> a family of messages of different lengths that hash to the same value. These messages are used to bypass the Merkle-Damgård strengthening. This in turn allows them to reapply the long message attack <em>[20]</em> which was supposedly foiled by the strengthening.</p>

    <p class="text-gray-300">Biham and Dunkelman proposed Haifa <em>[23]</em>, which adds in each block the number of message bits which were hashed so far. The simplest way to implement Haifa is to shorten each data block by 64 bits, and to concatenate the 64 bit counter instead. Rivest <em>[25]</em> introduced a clever way to decrease the number of bits used for this extra input to either 2 or 16, thus increasing the bandwidth available for actual data, by using a specific sequence of values to “dither” the actual inputs. The properties of this sequence were claimed by Rivest to be sufficient to avoid the Kelsey-Schneier attack.</p>

    <p class="text-gray-300">Another variant of the long message attack is the “Nostradamus attack” of Kelsey and Kohno <em>[15]</em> which makes it possible to commit to a hash value <span class="math">h</span> and then to find a message that hashes to <span class="math">h</span> with any desired prefix. For their attack, they have introduced the “diamond” structure which is reminiscent of a binary tree. It is a <span class="math">2^{\\ell}</span>-multicollision where all the <span class="math">2^{\\ell}</span> colliding messages have a different initial value. Its construction cost is heavy, <span class="math">2^{n/2+\\ell/2+2}</span> (where <span class="math">n</span> is the size of the hash function output), but then it allows to connect any message to the collision tree with only <span class="math">2^{n-\\ell+1}</span> calls to the hash function.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Our Results</h3>

    <p class="text-gray-300">In this paper, we propose several new generic second preimage attacks on various dithered versions of the Merkle-Damgård paradigm in which the compression function can be modeled by a random oracle. Our technique mainly relies on the diamond structure from the herding attack of <em>[15]</em>. If the diamond is a <span class="math">2^{\\ell}</span>-multicollision, we obtain a second preimage of a message of size <span class="math">2^{k}</span> in time <span class="math">2^{n/2+\\ell/2+2}+2^{n-\\ell+1}+2^{n-k+1}</span>. This expression is optimal for <span class="math">\\ell\\approx n/3</span> where the complexity becomes <span class="math">2^{2n/3+2}+2^{n-k+1}</span>. This is slightly more expensive than the <span class="math">k\\cdot 2^{n/2+1}+2^{n-k+1}</span> complexity of the Kelsey-Schneier attack (for SHA-1, the Kelsey-Schneier attack complexity is about <span class="math">2^{106}</span> work whereas ours is approximately <span class="math">2^{109}</span>). The main advantage of our attack is that it can be extended to Rivest’s dithered proposal since the dithering sequence used in the third input has an undesirable property that can be exploited to make the attack efficient: the number of <span class="math">\\ell</span>-letter subwords in it is exceptionally small, and thus one of these subwords must occur very frequently. Compared to the original attack, we lose a factor equal to the inverse of the frequency of the most probable word. The function mapping <span class="math">\\ell</span> to the number of <span class="math">\\ell</span>-letter words in the sequence is called the <em>factor complexity</em> of the sequence (see for example <em>[1]</em>). For the particular sequence chosen by Rivest, this complexity is only linear in the size <span class="math">\\ell</span> of the words. For example, for Rivest’s 16-bit sequence, the attack requires <span class="math">2^{n/2+\\ell/2+2}+(8\\ell+32768)\\cdot 2^{n-\\ell+1}+2^{n-k+1}</span> work, which for SHA-1 is approximately <span class="math">2^{121}</span>.</p>

    <p class="text-gray-300">This is slightly worse than the attacks against the basic Merkle-Damgård construction but it is still much smaller than the <span class="math">2^{160}</span> security which was expected for the dithered construction.</p>

    <p class="text-gray-300">An extension of the basic attack can also be applied to a Universal One Way Hash Function designed by Shoup <em>[27]</em>, which has some similarities with dithered hashing. Our technique yields the first published attack against this particular hash function. This additionally proves that Shoup’s security bound is tight since there is asymptotically only a factor of <span class="math">\\mathcal{O}\\left(\\log k\\right)</span> between his bound and our attack’s complexity.</p>

    <p class="text-gray-300">The attacks presented above demonstrate that the properties of the dithering sequence influencing the security of dithered hash functions may not be well understood, and may include additional properties beyond its factor complexity and its repetition-freeness.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Organization of the Paper.</h3>

    <p class="text-gray-300">We describe our attack against the Merkle-Damgård construction in section 2. We introduce some terminology and describe the dithered Merkle-Damgård construction in section 3, and then we extend our attack to tackle dithered Merkle-Damgård in section 4. We apply it to Rivest’s concrete proposal, as well as to some of the variations that he suggested. In section 5, we apply the extended attack against Shoup’s UOWHF construction.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 A New Generic Second Preimage Attack</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 The Merkle-Damgård construction</h3>

    <p class="text-gray-300">We first describe briefly the classical Merkle-Damgård construction. An iterated hash function <span class="math">H^{F}:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{n}</span> is built by iterating a basic compression function <span class="math">F:\\{0,1\\}^{m}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span>. The hash process works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pad and split a message <span class="math">M</span> into <span class="math">r</span> blocks <span class="math">x_{1},\\ldots,x_{r}</span> of <span class="math">m</span> bits each.</li>

      <li>Set <span class="math">h_{0}</span> to the initialization value <span class="math">IV</span>.</li>

      <li>For each message block <span class="math">i</span> compute <span class="math">h_{i}=F\\left(h_{i-1},x_{i}\\right)</span>.</li>

      <li>Output <span class="math">H^{F}(M)=h_{r}</span>.</li>

    </ul>

    <p class="text-gray-300">The padding is usually done by appending a single ’1’ bit followed by as many ’0’ bits as needed to complete an <span class="math">m</span>-bit block. Merkle <em>[21]</em> and Damgård <em>[7]</em> independently proved in 1989 that making the binary encoding of the message length part of the padding improves the security of the construction: with this so-called <em>strengthening</em>, the scheme is proven to be Collision-Resistance Preserving, in the sense that a collision in the hash function <span class="math">H^{F}</span> would imply a collision in the compression function <span class="math">F</span>. As a side effect, the strengthening defines an upper bound on the size of the messages that can be processed (because the encoding of the length has a fixed size). In most deployed hash functions, this limit is <span class="math">2^{64}</span> bits, or equivalently <span class="math">2^{55}</span> 512-bit blocks. In the sequel, we denote the maximal number of admissible blocks by <span class="math">2^{k}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.2 Description of the Attack</p>

    <p class="text-gray-300">We describe a new technique to build expandable messages. It relies heavily on the diamond structure introduced by Kelsey and Kohno <em>[15]</em> to find second preimages. An expandable message <span class="math">\\mathcal{M}</span> is a family of messages with different number of blocks but with the same hash up to strengthening. We call any one of these messages an <em>instance</em> of <span class="math">\\mathcal{M}</span>. The <em>range</em> of <span class="math">\\mathcal{M}</span> is the set of lengths of its instances.</p>

    <p class="text-gray-300">A diamond of size <span class="math">\\ell</span> is a multicollision that has the shape of a complete converging binary tree of height <span class="math">\\ell</span>. It therefore has <span class="math">2^{\\ell}</span> leaves. Its nodes are labelled by chaining values over <span class="math">n</span> bits, and its edges are labelled by message blocks over <span class="math">m</span> bits, which map between the chaining values at the two ends of the edge by the compression function. Thus, from any one of the <span class="math">2^{\\ell}</span> leaves, there is a path labelled by <span class="math">\\ell</span> message blocks that leads to the same target value <span class="math">h_{T}</span> labelling the root of the tree.</p>

    <p class="text-gray-300">Let <span class="math">M</span> be a message of size <span class="math">2^{k}</span>. The main idea of the attack is that after a big collision tree of height <span class="math">\\ell</span> is built during an (expensive) preprocessing stage, it costs less than <span class="math">2^{n}</span> work to “connect” the target chaining value <span class="math">h_{T}</span> of the tree to one of the <span class="math">2^{k}</span> chaining values <span class="math">h_{i}</span> obtained when hashing <span class="math">M</span>. It also costs much less than <span class="math">2^{n}</span> work to connect an arbitrary prefix to one of the <span class="math">2^{\\ell}</span> leaves, if we do not care which one it is. The attack works in four steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Preprocessing step: compute a collision tree of height <span class="math">\\ell</span> with an arbitrary target value <span class="math">h_{T}</span>. Note that this has to be done only once, and can be reused when computing second preimages of multiple messages.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Connect the target <span class="math">h_{T}</span> to some block in the message <span class="math">M</span>. This can be done by generating random message blocks <span class="math">B</span>, until <span class="math">F(h_{T},B)=h_{i_{0}}</span> for some <span class="math">i_{0}</span>, $\\ell+1\\leq i_{0}<\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>B_{0}$ be a message block satisfying this condition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate an arbitrary prefix <span class="math">P</span> of size <span class="math">i_{0}-\\ell-1</span> whose hash is one of the chaining values labelling a leaf. Let <span class="math">h=H^{F}(P)</span> be this value, and let <span class="math">T</span> be the chain of <span class="math">\\ell</span> blocks traversing the tree from <span class="math">h</span> to <span class="math">h_{T}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Form a message $M^{\\prime}=P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{i_{0}+1}\\ldots M_{2^{r}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1: Summary of the attack on classic Merkle-Damgård.</p>

    <p class="text-gray-300">The message <span class="math">M^{\\prime}</span> has the same hash as <span class="math">M</span>, before strengthening, and has the same length, so we have obtained a full collision in the strengthened Merkle-Damgård construction.</p>

    <p class="text-gray-300">A collision tree of height <span class="math">\\ell</span> can be constructed with time and space complexity <span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}</span> (see <em>[15]</em> for details). The second step of the attack can be carried out with <span class="math">2^{n-k+1}</span> work, and the third one with <span class="math">2^{n-\\ell+1}</span> work. The total time complexity of the attack is then :</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+2^{n-k+1}+2^{n-\\ell+1}.</span></p>

    <p class="text-gray-300">If <span class="math">n</span> is much bigger than <span class="math">k</span> (which is the case in all the members of the SHA family), then the first term of this sum becomes negligible compared to the other two; we will use</p>

    <p class="text-gray-300">this approximation in the sequel. The complexity is minimal when <span class="math">\\ell=\\frac{n}{3}</span>, and with this setting, the total cost of our attack is about <span class="math">3\\cdot 2^{2n/3+2}+2^{n-k+1}</span>.</p>

    <p class="text-gray-300">It must be noted that if we choose <span class="math">\\ell\\geq k</span>, then the connection in the third step of the attack can be realized for free. This step amount to finding a prefix of a given length, the hash of which is one of the values labelling the leaves of the collision tree. When there are more leaves than possible lengths for the prefix (that is, <span class="math">2^{k}</span>), then the hash value labelling the <span class="math">i</span>-th leaf can be obtained by hashing a chosen message of length <span class="math">i</span> blocks. This makes the attack slightly less expensive when <span class="math">n</span> is very big.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Comparison With Kelsey and Schneier</h3>

    <p class="text-gray-300">The difference between the two techniques lies in the way expandable messages are built. Kelsey and Schneier build an expandable message in time <span class="math">k\\cdot 2^{n/2+1}</span>. Here, we build an expandable message in time <span class="math">2^{n/2+\\ell/2+2}+2^{n-\\ell+1}</span>. On the original Merkle-Damgård construction their attack is more efficient than ours (on SHA-1, they can find a second preimage of a message of size <span class="math">2^{55}</span> with <span class="math">2^{106}</span> work, whereas we need <span class="math">2^{109}</span> calls to the compression function to obtain the same result). However, our technique to build expandable messages is more flexible, and in particular it can be adapted to work even when an additional dithering input is given, unlike the original Kelsey-Schneier technique. In addition, our technique gives the adversary more control on the second preimage, since she can typically choose about half of the message in an arbitrary way.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Dithered Hashing</h2>

    <p class="text-gray-300">The general idea of dithered hashing is to perturb the hashing process by using an additional input to the compression function, formed by the consecutive elements of a fixed <em>dithering</em> sequence. This gives the attacker less control over the input of the compression function, and makes the hash of a message block dependent on its position in the whole message. In particular, its goal is to prevent attacks based on expandable messages.</p>

    <p class="text-gray-300">Since the dithering sequence <span class="math">\\mathbf{z}</span> has to be at least as long as the maximal number of blocks in any message that can be processed by the hash function, it is reasonable to consider infinite sequences as candidates for <span class="math">\\mathbf{z}</span>. Let <span class="math">\\mathcal{A}</span> be a finite alphabet, and let the dithering sequence <span class="math">\\mathbf{z}</span> be an eventually infinite word over <span class="math">\\mathcal{A}</span>. Let <span class="math">\\mathbf{z}[i]</span> denote the <span class="math">i</span>-th element of <span class="math">\\mathbf{z}</span>. The dithered Merkle-Damgård construction is obtained by setting <span class="math">h_{i}=F\\left(x_{i},h_{i-1},\\mathbf{z}\\left[i\\right]\\right)</span> in the definition of the Merkle-Damgård scheme.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Words and Sequences</h3>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Notations and Terminology.</h4>

    <p class="text-gray-300">Let <span class="math">\\omega</span> be a word over the finite alphabet <span class="math">\\mathcal{A}</span>. The dot operator denotes concatenation. If <span class="math">\\omega</span> can be written as <span class="math">\\omega\\ =\\ x.y.z</span> (where <span class="math">x</span>,<span class="math">y</span> or <span class="math">z</span> can be empty), we say that <span class="math">x</span> is a <em>prefix</em> of <span class="math">\\omega</span> and that <span class="math">y</span> is a <em>factor</em> (or subword) of <span class="math">\\omega</span>. A finite word <span class="math">\\omega</span> is a <em>square</em> if it can be written as <span class="math">\\omega=x.x</span>, where <span class="math">x</span> is not empty. A finite</p>

    <p class="text-gray-300">word <span class="math">\\omega</span> is an <em>abelian square</em> if it can be written as <span class="math">\\omega=x.x^{\\prime}</span> where <span class="math">x^{\\prime}</span> is a permutation of <span class="math">x</span> (<em>i.e.</em> a reordering of the letters of <span class="math">x</span>). A word is said to be <em>square-free</em> (resp. <em>abelian square-free</em>) if none of its factors is a square (resp. an abelian square). Note that abelian square-free words are in particular square-free.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">An Infinite Abelian Square-Free Sequence.</h4>

    <p class="text-gray-300">In 1992, Keränen <em>[17]</em> exhibited an infinite abelian square-free word <span class="math">\\mathbf{k}</span> over a four-letter alphabet (there are no infinite abelian square-free words over a ternary alphabet). In this paper, we call this infinite abelian square-free word the <em>Keränen sequence</em>. Details about its construction can be found in <em>[17, 18, 25]</em>.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Sequence Complexity.</h4>

    <p class="text-gray-300">The number of factors of a given size of an infinite word gives an intuitive notion of its <em>complexity</em>: a sequence is more complex (or richer) if it possesses a large number of different factors. We denote by <span class="math">Fact_{\\mathbf{z}}(\\ell)</span> the number of factors of size <span class="math">\\ell</span> of the sequence <span class="math">\\mathbf{z}</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 Rivest’s Proposals.</h3>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Keränen-DMD.</h4>

    <p class="text-gray-300">Rivest suggested to directly use the Keränen sequence as a source of dithering inputs. The dithering inputs are taken from the alphabet <span class="math">\\mathcal{A}=\\{a,b,c,d\\}</span>, and can be encoded by two bits. The number of data bits in the input of the compression function is thus reduced by only two bits, which improves the hashing efficiency. It is possible to generate the Keränen sequence online, one symbol at a time, in logarithmic space and constant amortized time.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Rivest’s Concrete Proposal.</h4>

    <p class="text-gray-300">Rivest’s concrete proposal is referred to as DMD-CP (Dithered Merkle-Damgård– Concrete Proposal). To speed up the generation of the dithering sequence, Rivest proposed a slightly modified scheme, in which the dithering symbols are 16-bit wide. If the message <span class="math">M</span> is <span class="math">r</span> blocks long, then for <span class="math">1\\leq i&lt;r</span> the <span class="math">i</span>-th dithering symbol has the form:</p>

    <p class="text-gray-300"><span class="math">\\big{(}0,\\mathbf{k}\\big{[}\\big{\\lfloor}i/2^{13}\\big{\\rfloor}\\big{]},i\\mod 2^{13}\\big{)}\\in\\{0,1\\}\\times\\mathcal{A}\\times\\{0,1\\}^{13}</span></p>

    <p class="text-gray-300">The idea is to increment the counter for each dithering symbol, and to shift to the next letter in the Keränen sequence, only when the counter overflows. This “diluted” dithering sequence can essentially be generated <span class="math">2^{13}</span> times faster than the Keränen sequence. The last dithering symbol has a different form :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mod m)\\in\\{0,1\\}\\times\\{0,1\\}^{15}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-16" class="text-2xl font-bold">4 Second Preimage Attacks on Dithered Merkle-Damgård</h2>

    <p class="text-gray-300">In this section, we present the first known second preimage attack on Rivest’s dithered Merkle-Damgård construction. In section 4.1, we adapt the attack of section 2 to Keränen-</p>

    <p class="text-gray-300">DMD, obtaining second preimages in time <span class="math">(k+39)\\cdot 2^{n-k}</span>. We then apply the extended attack to MMD-CP, obtaining second preimages with about <span class="math">2^{n-k+16}</span> evaluations of the compression function. We show some examples of sequences which make the corresponding dithered constructions immune to our attack. This notably covers the case of Haifa <em>[23]</em>. Lastly, we present in section 4.2 a variation of the attack, which includes an expensive preprocessing, but which is able to cope with sequences of high complexity over a small alphabet with a very small online cost.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.1 Adapting the Attack to Dithered Merkle-Damgård</h3>

    <p class="text-gray-300">Let us now assume that the hashing algorithm uses a dithering sequence <span class="math">\\mathbf{z}</span>. When building the collision tree, we must choose which dithering symbols to use. A simple solution is to use the same dithering symbol for all the edges at the same depth in the tree. A tuple of <span class="math">\\ell</span> letters is then required to build the collision tree. We will also need an additional letter to connect the tree to the message <span class="math">M</span>. This way, in order to build a collision tree of height <span class="math">\\ell</span>, we have to fix a word <span class="math">\\omega</span> of size <span class="math">\\ell+1</span>, use <span class="math">\\omega[i]</span> as the dithering symbol of depth <span class="math">i</span>, and use the last letter of <span class="math">\\omega</span> to realize the connection.</p>

    <p class="text-gray-300">The dithering sequence makes the hash of a block dependent on its position in the whole message. Therefore, the collision tree can be connected to its target only at certain positions, namely, at the positions where <span class="math">\\omega</span> and <span class="math">\\mathbf{z}</span> match. The range of such an expandable message <span class="math">\\mathcal{M}</span> is then given by:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\text{Range}\\,\\mathcal{M}=\\Big{\\{}i\\in\\mathbb{N}\\,\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\left(\\ell+1\\leq i\\right)\\wedge\\left(\\mathbf{z}[i-\\ell]\\ldots\\mathbf{z}[i]=\\omega\\right)\\Big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that finding a connecting block <span class="math">B_{0}</span> in the second step defines the length of the instance of <span class="math">\\mathcal{M}</span> that is required. If <span class="math">i_{0}</span> is in the range of <span class="math">\\mathcal{M}</span>, it will be possible to build this instance. Otherwise, another block <span class="math">B_{0}</span> has to be found.</p>

    <p class="text-gray-300">To make sure that <span class="math">\\text{Range}\\,\\mathcal{M}</span> is not empty, <span class="math">\\omega</span> has to be a factor of <span class="math">\\mathbf{z}</span>. Ideally, <span class="math">\\omega</span> should be the factor of length <span class="math">\\ell+1</span> which occurs most frequently in <span class="math">\\mathbf{z}</span>, as the cost of the attack ultimately depends on the number of connecting blocks tried before finding a useful one (with <span class="math">i_{0}\\in\\text{Range}\\,\\mathcal{M}</span>). What is the probability that a factor <span class="math">\\omega</span> appears at a random position in <span class="math">\\mathbf{z}</span>? Although this is highly sequence-dependent, it is possible to give a generic lower bound : in the worst case, all factors of size <span class="math">\\ell+1</span> appear in <span class="math">\\mathbf{z}</span> with the same frequency. In this setting, the probability that a randomly chosen factor of size <span class="math">\\ell+1</span> in <span class="math">\\mathbf{z}</span> is the word <span class="math">\\omega</span> is <span class="math">1/Fact_{\\mathbf{z}}(\\ell+1)</span>.</p>

    <p class="text-gray-300">The main property of <span class="math">\\mathbf{z}</span> influencing the cost of our attack is its complexity (which is related to its min-entropy), whereas its repetition-freeness influences the cost of Kelsey and Schneier type attacks.</p>

    <p class="text-gray-300">The cost of finding this second preimage for a given sequence <span class="math">\\mathbf{z}</span> is then:</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+Fact_{\\mathbf{z}}(\\ell+1)\\cdot 2^{n-k+1}+2^{n-\\ell+1}.</span></p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Cryptanalysis of Keränen-DMD.</h4>

    <p class="text-gray-300">The cost of the extended attack against Keränen-DMD depends on the complexity of the sequence <span class="math">\\mathbf{k}</span>. Since it has a very regular structure,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Choose the most frequent factor <span class="math">\\omega</span> of <span class="math">\\mathbf{z}</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Build a collision tree of size <span class="math">\\ell</span> using <span class="math">\\omega</span> as the dithering symbols in all the leaf-to-root paths. Let <span class="math">h_{T}</span> be the target value of the tree.</li>

      <li>Find a connecting block <span class="math">B_{0}</span> mapping <span class="math">h_{T}</span> to anyone of the <span class="math">h_{i}</span> (say <span class="math">h_{i_{0}}</span>), by using <span class="math">\\omega[\\ell]</span> as the dithering letter. Repeat until <span class="math">i_{o}\\in\\text{Range}\\,\\mathcal{M}</span>.</li>

      <li>Carry the remaining steps of the attack as described previously.</li>

    </ol>

    <p class="text-gray-300">Fig. 2: Summary of the attack when a dithering sequence <span class="math">\\mathbf{z}</span> is used.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{k}</span> has an unusually low complexity (there are other abelian square-free sequences with exponential complexity, see appendix A). In appendix B we prove the following lemma:</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">For <span class="math">\\ell\\leq 85</span>, we have:</p>

    <p class="text-gray-300"><span class="math">Fact_{\\mathbf{k}}(\\ell)\\leq 8\\cdot\\ell+332.</span></p>

    <p class="text-gray-300">By computing the exact number of factors of <span class="math">\\mathbf{k}</span>, it is possible to observe that this bound is tight (for example there are exactly 732 factors of size 50). With <span class="math">\\ell=50</span>, and assuming that all factors occur equally often in <span class="math">\\mathbf{k}</span>, the probability that a connecting block falls in the range of <span class="math">\\mathcal{M}</span> is <span class="math">2^{-9.5}</span>. However, we observe that in the first <span class="math">2^{30}</span> symbols of <span class="math">\\mathbf{k}</span> there are factors of size 50 occurring 2941800 times while some others only occur 910237 times. By choosing one of the former, and assuming that the frequency of this factor is the same throughout <span class="math">\\mathbf{k}</span>, the probability can be increased to <span class="math">2^{-8.5}</span>, but we are not going to take this slight improvement into account when computing the cost of the attack.</p>

    <p class="text-gray-300">Despite being strongly repetition-free, the sequence <span class="math">\\mathbf{k}</span> offers an extremely weak security level against our attack. We illustrate this by evaluating the cost of our attack on Keranen-DMD:</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+(8\\cdot\\ell+340)\\cdot 2^{n-k+1}+2^{n-\\ell+1}.</span></p>

    <p class="text-gray-300">If <span class="math">n</span> is greater than about <span class="math">3k</span>, then by setting <span class="math">\\ell=k-3</span>, the total cost of the attack is about:</p>

    <p class="text-gray-300"><span class="math">(k+39)\\cdot 2^{n-k+4}</span></p>

    <p class="text-gray-300">which is much smaller than <span class="math">2^{n}</span> in spite of the dithering.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Cryptanalysis of DMD-CP.</h4>

    <p class="text-gray-300">We now apply the attack to Rivest’s concrete proposal. We first need to evaluate the complexity of its dithering sequence. Recall from section 3.2 that it is based on the Keränen sequence, but that we move on to the next symbol of the sequence only when a 13 bit counter overflows. The original motivation was to reduce the cost of the dithering, but it has the unintentional effect of increasing the resulting sequence complexity. However, in appendix B we prove that this effect is quite small:</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{c}</span> denote the sequence obtained by diluting <span class="math">\\mathbf{k}</span> with a 13-bit counter . Then for every <span class="math">0\\leq\\ell&lt;2^{13}</span>, we have :</p>

    <p class="text-gray-300"><span class="math">Fact_{\\mathbf{c}}(\\ell)=8\\cdot\\ell+32760.</span></p>

    <p class="text-gray-300">The dilution does not generate a sequence of higher asymptotic complexity: it is still linear in <span class="math">\\ell</span>, even though the constant term is bigger due to the counter. The cost of the attack is therefore :</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+(8\\cdot\\ell+32768)\\cdot 2^{n-k+1}+2^{n-\\ell+1}.</span></p>

    <p class="text-gray-300">Again, if <span class="math">n</span> is greater than about <span class="math">3k</span>, the best value of <span class="math">\\ell</span> is given by <span class="math">\\ell=k-3</span>, and the complexity of the attack is then approximately:</p>

    <p class="text-gray-300"><span class="math">(k+4096)\\cdot 2^{n-k+4}\\simeq 2^{n-k+16}.</span></p>

    <p class="text-gray-300">For settings corresponding to SHA-1, a second preimage can be computed in time <span class="math">2^{121}</span>.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Countermeasures.</h4>

    <p class="text-gray-300">Even though the dilution does not increase the asymptotic complexity of a sequence, the presence of a counter increases the complexity of the attack. If we simply used a counter over <span class="math">i</span> bits as the dithering sequence, the number of factors of size <span class="math">\\ell</span> would be <span class="math">Fact(\\ell)=2^{i}</span> (as long as <span class="math">i\\leq\\ell</span>). The complexity of the attack would then become :</p>

    <p class="text-gray-300"><span class="math">2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+2^{n-k+i+1}+2^{n-\\ell+1}.</span></p>

    <p class="text-gray-300">In practice, the dominating term is <span class="math">2^{n-k+i+1}</span>. By taking <span class="math">i=k</span>, we would obtain a scheme which is resistant to our attack. This is essentially the choice made by the designers of Haifa <em>[23]</em>, but such a dithering sequence consumes <span class="math">k</span> bits of bandwidth. Note that as long as the counter does not overflow, no variation of the attack of Kelsey and Schneier can be applied to the dithered construction.</p>

    <p class="text-gray-300">A possible way to improve the resistance of Rivest’s dithered hashing to this attack is to use a dithering sequence of high complexity over a small alphabet (to preserve bandwidth). In appendix A we show that there is an abelian square-free sequence over 6 letters with complexity greater than <span class="math">2^{\\ell/2}</span>. Then, with <span class="math">\\ell=2k/3</span>, the total cost of the online attack is <span class="math">2^{n-2k/3}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Another possible way to repair Rivest’s dithered hashing is to use a pseudo random sequence over a small alphabet. Even though it may not be repetition-free, its complexity is almost maximal. Suppose the alphabet has size $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{i}<span class="math">. Then the expected number of </span>\\ell<span class="math">-letter factors in a pseudo random word of size </span>2^{k}<span class="math"> is: </span>2^{i\\cdot\\ell}\\cdot\\left(1-\\exp-2^{k-i\\cdot\\ell}\\right)<span class="math"> (refer to <em>[11, 12]</em> for a proof of this claim). The total optimal cost of the online attack is </span>2^{n-k/(i+1)+3}<span class="math"> and is obtained with </span>\\ell=k/(i+1)<span class="math">. With 8-bit dithering symbols and if </span>k=55<span class="math">, as in the SHA family, the complexity of the attack is </span>2^{n-4}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.2 A Generic Attack on any Dithering Scheme With a Small Alphabet</h3>

    <p class="text-gray-300">The attacks described so far exploited the low complexity of Rivest’s specific dithering sequences. In this section we show that the weakness is more general, and that after some preprocessing second preimages can be found in <span class="math">\\max\\big{(}\\mathcal{O}\\left(2^{k}\\right),\\mathcal{O}\\left(2^{(n-k)/2}\\right)\\big{)}</span> time for any dithering sequence (even of maximal complexity) if the dithering alphabet is small.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Outline of the Attack. The new attack can be viewed as a type of time-memory tradeoff. For any given compression function, we precompute a fixed data structure called a kite generator which can then be used to compute additional preimages for any dithering sequence and any given message of length  <span class="math">\\mathcal{O}\\left(2^k\\right)</span>  in time  <span class="math">\\max \\bigl (\\mathcal{O}\\left(2^k\\right),\\mathcal{O}\\left(2^{(n - k) / 2}\\right)\\bigr)</span>  and negligible additional space. Note that for the SHA-1 parameters of  <span class="math">n = 160</span>  and  <span class="math">k = 55</span> , the time complexity of the new attack is  <span class="math">2^{55}</span> , which is just the time needed to hash the original message! The size of the kite generator is  $\\mathcal{O}\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot 2^{n - k}\\right)<span class="math">  (where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 4<span class="math">  for Rivest&#x27;s original proposal, and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{15}<span class="math">  for Rivest&#x27;s concrete proposal). The kite generator is a labelled directed graph whose  </span>2^{n - k}<span class="math">  vertices are labelled by some easily recognized subset of the chaining values that includes the IV (e.g., the tiny fraction of hash values which are extremely close to IV). Each directed edge (which can be traversed in both directions) is labelled by one letter  </span>\\alpha<span class="math">  from the dithering alphabet and one message block  </span>m<span class="math"> , and it leads from vertex  </span>h_1<span class="math">  to vertex  </span>h_2<span class="math">  if  </span>F(h_{1},m,a) = h_{2}$ . Each vertex in the generator should have exactly two outgoing edges labelled by each dithering letter, and thus the expected number of ingoing edges labelled by each letter is also 2. The generator is highly connected in the sense that there is an exponentially large diverging binary tree with any desired dithering sequence starting at any vertex, and an exponentially large converging tree with any desired dithering sequence (whose degrees are not always 2) ending at most vertices. It can be viewed as a generalization of the collision tree of Kelsey and Kohno [15], which is a single tree with a single root in only the converging direction and with no dithering labels.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Once computed (during an unbounded precomputation stage), we can use the generator to find a second preimage for any given message  <span class="math">M</span>  with  <span class="math">2^k</span>  blocks and any dithering sequence. We first hash the long input  <span class="math">M</span>  to find (with high probability) some intermediate hash value  <span class="math">h_i</span>  which appears in the generator. We then use the generator to replace the first  <span class="math">i</span>  blocks in the message by a different set of  <span class="math">i</span>  blocks. We start from the generator vertex labelled by  <span class="math">IV</span> , and follow some path in the generator of length  <span class="math">i - (n - k)</span>  which has the desired dithering sequence (there are exponentially many paths we can choose from). It leads to some hash value  <span class="math">h_t</span>  in the generator. We then evaluate the full diverging tree of depth  <span class="math">(n - k)/2</span>  and the desired dithering sequence starting at  <span class="math">h_t</span> , and the full converging tree of depth  <span class="math">(n - k)/2</span>  and the desired dithering sequence ending at  <span class="math">h_i</span> . Since</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 3: A Kite</p>

    <p class="text-gray-300">the number of leaves in each tree is <span class="math">\\mathcal{O}\\left(2^{(n-k)/2}\\right)</span> and they are labelled by only <span class="math">2^{n-k}</span> possible values, we expect by the birthday paradox to find a common chaining value among the two sets of leaves. We can now combine the long random chain of length <span class="math">i-(n-k)</span> with the two short tree chains of length <span class="math">(n-k)/2</span> to find a <em>kite</em>-shaped structure of the same length <span class="math">i</span> and with the same dithering sequence as the original message between the two chaining values <span class="math">IV</span> and <span class="math">h_{i}</span>.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Finding Collisions inside a Kite.</h4>

    <p class="text-gray-300">The simplest way to find the common leaf is to store all the leaf values of the diverging and converging trees in an additional data structure, sort it, and look for repetitions. This requires time and space <span class="math">\\mathcal{O}\\left(2^{(n-k)/2}\\right)</span>. However, it is possible to find the common leaf value by a more sophisticated algorithm which requires the same time but negligible additional space. It is based on Pollard’s <span class="math">\\rho</span> method, with appropriate modifications. Let <span class="math">f_{1}(x)</span> be the mapping from the root of the diverging tree to the leaf in which the path is determined by the desired dithering sequence where the first <span class="math">n-k-1</span> bits in <span class="math">x</span> define which of the two outgoing edges with each dithering symbol to follow. Let <span class="math">f_{2}(x)</span> be a similar mapping from the root of the converging tree to the leaf specified by <span class="math">x</span>. Finally, let <span class="math">f_{0}(x)</span> be the random function from <span class="math">n-k</span> bit values to <span class="math">n-k</span> bit values in which the last bit of <span class="math">x</span> determines whether we apply <span class="math">f_{1}</span> or <span class="math">f_{2}</span> to <span class="math">x</span>. By iterating <span class="math">f_{0}</span> on a random initial value <span class="math">x_{0}</span>, we expect to enter a loop after <span class="math">\\mathcal{O}\\left(2^{(n-k)/2}\\right)</span> steps. The entry point into this loop represents two different values <span class="math">x_{1}</span> and <span class="math">x_{2}</span> which converge under <span class="math">f_{0}</span> to the same value <span class="math">x_{0}</span>. With constant probability <span class="math">x_{1}</span> and <span class="math">x_{2}</span> have different final bits, and in this case <span class="math">x_{0}</span> is a common leaf in the diverging and converging tree paths represented by <span class="math">f_{1}(x_{1})</span> and <span class="math">f_{2}(x_{2})</span> .</p>

    <p class="text-gray-300">When the size of the dithering alphabet <span class="math">\\mathcal{A}</span> exceeds <span class="math">2^{k}</span> (as in the Haifa proposal) the size of the kite generator becomes larger than <span class="math">2^{n}</span>, and thus our attack becomes more expensive than the trivial attack that precomputes and stores one message that hashes to each one of the <span class="math">2^{n}</span> possible values.</p>

    <p class="text-gray-300">The attack can be applied with essentially the same complexity even when the <span class="math">IV</span> is not known during the precomputation stage (e.g., when it is time dependent). When we hash the original long message, we have to find two intermediate hash values <span class="math">h_{i}</span> and <span class="math">h_{j}</span> (instead of <span class="math">IV</span> and <span class="math">h_{i}</span>), and connect them by a properly dithered kite-shaped structure of the same length.</p>

    <p class="text-gray-300">Note that if we reduce the size of either the message or the kite generator, we are unlikely to find any common chaining values between the given message and the generator. Finding a way to connect the generator back into the message will require <span class="math">2^{n-k+1}</span> additional steps, and thus the time complexity of finding second preimages in arbitrarily dithered SHA-1 will jump from <span class="math">2^{55}</span> to at least <span class="math">2^{106}</span>. It is an interesting open problem whether we can precompute a smaller generator, and trade it off smoothly with a larger computing time without such quantum jumps.</p>

    <p class="text-gray-300">5 An Attack on Shoup’s UOWHF</p>

    <p class="text-gray-300">In this section, we show that our attack is generic enough to be applied against hash functions enjoying a different security property, namely Universal One-Way Hash Function (UOWHF). A UOWHF is a keyed hash function <span class="math">H</span> for which any computationally bounded adversary <span class="math">A</span> wins the following game with negligible probability. First <span class="math">A</span> chooses a message <span class="math">M</span>, then a key <span class="math">K</span> is chosen at random and given to <span class="math">A</span>. The adversary wins if she violates the Target Collision Resistance (TCR) of <span class="math">H</span>, that is if she generates a message <span class="math">M^{\\prime}</span> different from <span class="math">M</span> that collides with <span class="math">M</span> for the key <span class="math">K</span> (i.e. such that <span class="math">H_{K}(M)=H_{K}(M^{\\prime})</span> with <span class="math">M\\neq M^{\\prime}</span>).</p>

    <p class="text-gray-300">At EUROCRYPT 2000, Shoup <em>[27]</em> had proposed a simple construction for a UOWHF that hashes messages of arbitrary size, given a UOWHF that hashes messages of fixed size. It is a Merkle-Damgård-like mode of operation, but before every iteration, one of several possible masks is XORed to the chaining value. The number of masks is logarithmic in the length of the hashed message, and the order in which they are used is carefully chosen to maximize the security of the scheme. This is reminiscent of dithered hashing, except that here the dithering process does not hit the bandwidth available to actual data.</p>

    <p class="text-gray-300">We first describe briefly Shoup’s construction, and then show how our attack can be applied against it. This way we prove that for this particular construction, Shoup’s security bound is tight.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.1 Description</h3>

    <p class="text-gray-300">The construction has some similarities with Rivest’s dithered hashing. It starts from a universal one way compression function <span class="math">F</span> that is keyed by a key <span class="math">K</span>, <span class="math">F_{K}\\colon\\{0,1\\}^{m}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span>. This compression function is then iterated, as described below, to obtain a variable input length UOWHF <span class="math">H_{K}^{F}</span>.</p>

    <p class="text-gray-300">A certain number of “masks” are needed, each one of which is a random <span class="math">n</span>-bit string. Assuming that the maximal size of hashed messages is <span class="math">2^{k}</span> then <span class="math">k+1</span> masks <span class="math">M_{0},\\ldots,M_{k}</span> are required. The key of the whole iterated function consists of <span class="math">K</span> and of these masks. After each application of the compression function, a mask is XORed to the result. The order in which the masks are applied is defined by a specified sequence over the alphabet <span class="math">\\mathcal{A}=\\{0,\\ldots,k\\}</span>. The scheduling sequence is <span class="math">\\mathbf{z}[i]=\\nu_{2}(i)</span>, for <span class="math">1\\leq i\\leq 2^{k}</span>, where <span class="math">\\nu_{2}(i)</span> denotes the largest integer <span class="math">\\nu</span> such that <span class="math">2^{\\nu}</span> divides <span class="math">i</span>. Let <span class="math">M</span> be a message that can be split into <span class="math">r</span> blocks <span class="math">x_{1},\\ldots,x_{r}</span> and let <span class="math">h_{0}</span> be an arbitrary <span class="math">n</span>-bit string. We define <span class="math">h_{i}=F_{K}\\left(h_{i-1}\\oplus M_{\\nu_{2}(i)},x_{i}\\right)</span>, and <span class="math">H_{K}^{F}(M)=h_{r}</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.2 An Attack Matching the Security Bound</h3>

    <p class="text-gray-300">In <em>[27]</em>, Shoup proves the following security result:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 1 (Main result of <em>[27]</em>)</h6>

    <p class="text-gray-300">If an adversary is able to break the target collision resistance of <span class="math">H^{F}</span> with probability <span class="math">\\epsilon</span> in time <span class="math">T</span>, then one can construct an adversary that breaks the target collision resistance of <span class="math">F</span> in time <span class="math">T</span>, with probability <span class="math">\\epsilon/2^{k}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">In this section we show that this bound is almost tight. First, we give an alternate definition of the dithering sequence <span class="math">\\mathbf{z}</span>. We define:</p>

    <p class="text-gray-300">\\[ u_{i}=\\begin{cases}0&\\text{if }i=1,\\\\ u_{i-1}.(i-1).u_{i-1}&\\text{otherwise.}\\end{cases} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As an example, we have <span class="math">u_{4}=010201030102010</span>. It is clear that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{i}-1<span class="math">, and it is easy to show that for all </span>i<span class="math">, </span>u_{i}<span class="math"> is a prefix of </span>\\mathbf{z}<span class="math">. The dithering sequence is thus simply </span>u_{k}<span class="math"> (a prefix of </span>\\mathbf{z}<span class="math"> of size </span>2^{k}-1$ is arguably enough).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The most frequently-occurring factor of size <span class="math">\\ell&lt;2^{k}</span> in <span class="math">\\mathbf{z}</span> is the prefix of size <span class="math">\\ell</span> of <span class="math">\\mathbf{z}</span>. It is a prefix of <span class="math">u_{j}</span> with <span class="math">j=\\lceil\\log_{2}\\left(\\ell+1\\right)\\rceil</span>, and <span class="math">u_{j}</span> itself occurs <span class="math">2^{k-j}</span> times in <span class="math">\\mathbf{z}=u_{k}</span>. The probability for a random factor of <span class="math">\\mathbf{z}</span> of size <span class="math">\\ell</span> to be exactly this candidate is equal to the number of occurrences of this candidate divided by the number of <span class="math">\\ell</span>-bit strings in <span class="math">\\mathbf{z}</span>. Thus this probability is <span class="math">\\frac{2^{k-j}}{2^{k}-\\ell}</span>. This can in turn be lower-bounded by: <span class="math">2^{-j}\\geq\\frac{1}{2(\\ell+1)}</span>. Our attack can be applied against the TCR property of <span class="math">H^{F}</span> as described above: just choose at random a (long) message <span class="math">x</span>. Once the key is chosen at random, build a collision tree using a prefix of <span class="math">\\mathbf{z}</span> of size <span class="math">\\ell</span>, and continue as described in section 4. The cost of the attack is then:</p>

    <p class="text-gray-300"><span class="math">T=2^{\\frac{n}{2}+\\frac{\\ell}{2}+2}+2(\\ell+1)\\cdot 2^{n-k+1}+2^{n-\\ell+1}.</span></p>

    <p class="text-gray-300">This attack breaks the target collision resistance with probability <span class="math">\\mathcal{O}\\left(1\\right)</span>. Therefore, with Shoup’s result, one can construct an adversary <span class="math">A</span> against <span class="math">F</span> with running time <span class="math">\\mathcal{O}\\left(T\\right)</span> and probability of success <span class="math">\\mathcal{O}\\left(1/2^{k}\\right)</span>. Therefore, the adversary <span class="math">\\mathcal{A}^{\\prime}</span> which runs <span class="math">\\mathcal{A}</span> <span class="math">2^{k}</span> times has a probability <span class="math">\\mathcal{O}\\left(1\\right)</span> of breaking the TCR property. When <span class="math">n\\geq 3k</span>, <span class="math">T\\simeq\\left(2k+3\\right)\\cdot 2^{n-k+1}</span> (with <span class="math">\\ell=k-1</span>), and thus the running time of the adversary is <span class="math">\\mathcal{O}\\left(2^{k}\\cdot T\\right)=\\mathcal{O}\\left(k\\cdot 2^{n}\\right)</span>. If <span class="math">F</span> is a random oracle, the best attack against <span class="math">F</span>’s TCR property runs in time <span class="math">\\mathcal{O}\\left(2^{n}\\right)</span>, which means that there is only a factor <span class="math">k</span> between Shoup’s security proof and our attack.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.3 Further Improvement of the Attack</h3>

    <p class="text-gray-300">Our attack can be improved to obtain a gap <span class="math">\\mathcal{O}\\left(\\log k\\right)</span> between Shoup’s security proof and our attack. To this end, we use the following trick. Instead of focusing on the most frequent word of size <span class="math">\\ell</span>, we focus on the most frequent word of size <span class="math">\\mathcal{O}\\left(\\log_{2}(\\ell)\\right)</span> for which it is easier to connect a collision tree to the original message, because it occurs more frequently.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More precisely, let <span class="math">\\omega_{0}</span> be the <span class="math">(s+1)</span>-letter prefix of <span class="math">\\mathbf{z}</span>, where <span class="math">s=\\lceil\\log_{2}(12\\ell\\cdot k)\\rceil</span>. First we produce a collision tree for every <span class="math">\\ell</span>-symbol word <span class="math">\\omega</span> such that $\\omega\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega_{0}<span class="math"> is a factor of </span>\\mathbf{z}<span class="math">. Thus, for every such word </span>\\omega<span class="math"> are associated a collision tree and the target </span>h_{\\omega}<span class="math"> of the collision tree. Since we are free to choose the hash value labelling the leaves of a tree, we now use the set of all these targets as the leaves for a new smaller collision tree using the </span>s<span class="math"> first letters of </span>\\omega_{0}<span class="math"> as a dithering. This way we herd all the previously constructed collision tree in a bigger aggregated tree. Let </span>h_{T}<span class="math"> denote the target of the resulting collision tree. We continue the attack nearly as usual. We find a block </span>B_{0}<span class="math"> such that </span>F_{K}\\left(h_{T}\\oplus M_{\\omega_{0}[s+1]},B_{0}\\right)=h_{i_{0}}<span class="math"> for some </span>i_{0}<span class="math">, with </span>\\mathbf{z}[i_{0}-s-1]\\ldots\\mathbf{z}[i_{0}]=\\omega_{0}$ and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">i_0 \\geq \\ell + s + 1</span> . This fixes a word  <span class="math">\\omega_1 = \\mathbf{z}[i_0 - s - \\ell - 3] \\ldots \\mathbf{z}[i_0 - s - 2]</span>  and the particular subtree generated with  <span class="math">\\omega_1</span>  as dithering symbols. Finally we generate an arbitrary prefix  <span class="math">P</span>  of size  <span class="math">i_0 - s - \\ell - 4</span>  whose hash is one of the leaf of the  <span class="math">\\omega_1</span>  subtree. Let  <span class="math">T</span>  be the chain of  <span class="math">\\ell + s</span>  blocks traversing successively the  <span class="math">\\omega_1</span>  subtree and then the small  <span class="math">\\omega_0</span>  collision tree, from  <span class="math">h</span>  to  <span class="math">h_T</span> . The second preimage is therefore  $P \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_0 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i_0 + 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2^k}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">c_{\\ell}</span>  denote the number of  <span class="math">\\ell</span> -letter words  <span class="math">w</span>  such  $\\omega \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\omega_0<span class="math">  is a factor of  </span>\\mathbf{z}<span class="math"> . Note that the previous attack is correct if and only if the number of leaves of the  </span>\\omega_0<span class="math">  collision tree is greater than  </span>c_{\\ell}<span class="math">  the number of collision graph we have to herd. It can be shown that for the particular value chosen for  </span>s<span class="math"> ,  </span>2^s \\geq c_{\\ell}$ , thus the attack is correct and the cost of this attack is roughly:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">c _ {\\ell} \\cdot 2 ^ {\\frac {n}{2} + \\frac {\\ell}{2} + 2} + 2 ^ {\\frac {n}{2} + \\frac {\\log_ {2} (\\ell)}{2} + 2} + 2 (1 + \\log_ {2} \\ell) \\cdot 2 ^ {n - k + 1} + 2 ^ {n - \\ell + 1}.</span></div>

    <p class="text-gray-300">Compared to the previous attack, we now have to build  <span class="math">c_{\\ell}</span>  collision trees of size  <span class="math">\\ell</span>  instead of one, but it also becomes easier to connect our structure to the original message. Note that the term  <span class="math">2^{n/2 + \\log_2(\\ell)/2 + 2}</span>  is always negligible before  <span class="math">c_{\\ell} \\cdot 2^{n/2 + \\ell/2 + 2}</span> .</p>

    <p class="text-gray-300">If  <span class="math">n \\gg 3k</span> , when  <span class="math">\\ell = k</span> , the term  <span class="math">c_{\\ell} \\cdot 2^{n/2 + \\ell/2 + 2} = \\mathcal{O}\\left(2^{n/2 + k/2 + 2 \\log_2 k}\\right)</span>  is smaller than  <span class="math">2^{n - k + 1}</span>  and the cost of the attack is  <span class="math">\\mathcal{O}\\left(\\log k \\cdot 2^{n - k}\\right)</span> . Therefore, with the same proof as in the previous subsection, we can show that there is a factor  <span class="math">\\mathcal{O}(\\log k)</span>  between Shoup's security proof and our attack. Note that, depending on the parameters, this improved version of the attack may be worse than the basic version.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Basic</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Improved</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-1</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">2112</td>

            <td class="px-3 py-2 border-b border-gray-700">2115</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">2208</td>

            <td class="px-3 py-2 border-b border-gray-700">2206</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An intriguing connection between Shoup's and Rivest's ideas shows up as soon as we notice that the scheduling sequence  <span class="math">\\mathbf{z}</span>  chosen by Shoup is abelian square-free. In fact, one year after Shoup's construction was published, Mironov [22] proved that an even stronger notion of repetition-freeness was necessary:  <span class="math">\\mathbf{z}</span>  is, and has to be, even-free. A word is even-free if all of its non-empty factors contain at least one letter an odd number of times. Note that all even-free words are abelian square-free. We believe that the role these non-trivial sequences play in iterated constructions in cryptography (such as hashing) has yet to be completely understood.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Allouche, J.P.: Sur la complexité des suites infinies. Bull. Belg. Math. Soc. 1 (1994) 133-143</li>

      <li>Andreeva, E., Neven, G., Preneel, B., Shrimpton, T.: Seven-Property-Preserving Iterated Hashing: ROX. Cryptology ePrint Archive, Report 2007/176, to appear in ASIACRPT'07 (2007)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Biham, E., Chen, R., Joux, A., Carribault, P., Lemuet, C., Jalby, W.: Collisions of SHA-0 and Reduced SHA-1. [6] 36–57</li>

      <li>Brassard, G., ed.: CRYPTO ’89, Santa Barbara, California, USA, August0-24, 1989, Proceedings. In Brassard, G., ed.: CRYPTO. Volume 435 of Lecture Notes in Computer Science., Springer (1990)</li>

      <li>Cobham, A.: Uniform tag seqences. Mathematical Systems Theory 6(3) (1972) 164–192</li>

      <li>Cramer, R., ed.: Advances in Cryptology - EUROCRYPT 2005, 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Aarhus, Denmark, May 22-26, 2005, Proceedings. In Cramer, R., ed.: EUROCRYPT’05. Volume 3494 of Lecture Notes in Computer Science., Springer (2005)</li>

      <li>Damgård, I.: A Design Principle for Hash Functions. [4] 416–427</li>

      <li>Dean, R.D.: Formal Aspects of Mobile Code Security. PhD thesis, Princeton University (January 1999)</li>

      <li>Ehrenfeucht, A., Lee, K.P., Rozenberg, G.: Subword Complexities of Various Classes of Deterministic Developmental Languages without Interactions. Theor. Comput. Sci. 1(1) (1975) 59–75</li>

      <li>Feller, W.: 12. In: An Introduction to Probability Theory and Its Applications. Volume 1. John Wiley &amp; Sons (1971)</li>

      <li>Gheorghiciuc, I.: The Subword Complexity of Finite and Infinite Binary Words. PhD thesis, University of Pennsylvania (September 2004)</li>

      <li>Janson, S., Lonardi, S., Szpankowski, W.: On average sequence complexity. Theor. Comput. Sci. 326(1-3) (2004) 213–227</li>

      <li>Joux, A.: Multicollisions in Iterated Hash Functions. Application to Cascaded Constructions. In Franklin, M.K., ed.: CRYPTO’04. Volume 3152 of Lecture Notes in Computer Science., Springer (2004) 306–316</li>

      <li>Joux, A., Peyrin, T.: Hash Functions and the (Amplified) Boomerang Attack. In Menezes, A., ed.: CRYPTO. Volume 4622 of Lecture Notes in Computer Science., Springer (2007) 244–263</li>

      <li>Kelsey, J., Kohno, T.: Herding Hash Functions and the Nostradamus Attack. In Vaudenay, S., ed.: EUROCRYPT’06. Volume 4004 of Lecture Notes in Computer Science., Springer (2006) 183–200</li>

      <li>Kelsey, J., Schneier, B.: Second Preimages on n-Bit Hash Functions for Much Less than <span class="math">2^{\\rm R}</span> Work. [6] 474–490</li>

      <li>Keränen, V.: Abelian Squares are Avoidable on 4 Letters. In Kuich, W., ed.: ICALP. Volume 623 of Lecture Notes in Computer Science., Springer (1992) 41–52</li>

      <li>Keränen, V.: On abelian square-free DT0L-languages over 4 letters. In Harju, T., ed.: WORDS’03. Volume 27., TUCS General Publication (2003) 95–109</li>

      <li>Klima, V.: Tunnels in Hash Functions: MD5 Collisions Within a Minute. Cryptology ePrint Archive, Report 2006/105 (2006) http://eprint.iacr.org/.</li>

      <li>Menezes, A., van Oorschot, P., Vanstone, S.: Handbook of Applied Cryptography</li>

      <li>Merkle, R.C.: One Way Hash Functions and DES. [4] 428–446</li>

      <li>Mironov, I.: Hash Functions: From Merkle-Damgård to Shoup. In Pfitzmann, B., ed.: EUROCRYPT. Volume 2045 of Lecture Notes in Computer Science., Springer (2001) 166–181</li>

      <li>Orr Dunkelman, E.B.: A Framework for Iterative Hash Functions — HAIFA. Presented at the second NIST hash workshop (August 24–25 2006)</li>

      <li>Pansiot, J.J.: Complexité des facteurs des mots infinis engendrés par morphismes itérés. In Paredaens, J., ed.: 11th ICALP, Antwerpen. Volume 172 of LNCS., Springer (july 1984) 380–389</li>

      <li>Rivest, R.L.: Abelian Square-Free Dithering for Iterated Hash Functions. Presented at ECrypt Hash Function Workshop, June 21, 2005, Cracow, and at the Cryptographic Hash workshop, November 1, 2005, Gaithersburg, Maryland (August 2005)</li>

      <li>Rogaway, P., Shrimpton, T.: Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision Resistance. In Roy, B.K., Meier, W., eds.: FSE. Volume 3017 of Lecture Notes in Computer Science., Springer (2004) 371–388</li>

      <li>Shoup, V.: A Composition Theorem for Universal One-Way Hash Functions. In: EUROCRYPT’00. (2000) 445–452</li>

      <li>Shoup, V., ed.: Advances in Cryptology - CRYPTO 2005: 25th Annual International Cryptology Conference, Santa Barbara, California, USA, August 14-18, 2005, Proceedings. In Shoup, V., ed.: CRYPTO. Volume 3621 of Lecture Notes in Computer Science., Springer (2005)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wang, X., Lai, X., Feng, D., Chen, H., Yu, X.: Cryptanalysis of the Hash Functions MD4 and RIPEMD. [6] 1–18</li>

      <li>Wang, X., Yin, Y.L., Yu, H.: Finding Collisions in the Full SHA-1. [28] 17–36</li>

      <li>Wang, X., Yu, H.: How to Break MD5 and Other Hash Functions. [6] 19–35</li>

      <li>Wang, X., Yu, H., Yin, Y.L.: Efficient Collision Search Attacks on SHA-0. [28] 1–16</li>

    </ol>

    <h2 id="sec-31" class="text-2xl font-bold">Appendix A There are Abelian Square-Free Sequences of Exponential Complexity</h2>

    <p class="text-gray-300">Another way to repair DMD-CP would be to find an infinite abelian square-free sequence of exponential complexity. This is indeed possible, although we do not know how to do it without slightly enlarging the alphabet.</p>

    <p class="text-gray-300">We start with the abelian square-free Keränen sequence <span class="math">\\mathbf{k}</span> over <span class="math">\\{a,b,c,d\\}</span>, and with another sequence <span class="math">\\mathbf{u}</span> over <span class="math">\\{0,1\\}</span> that has an exponential complexity. Such a sequence can be built for example by concatenating the binary encoding of all the consecutive integers. Then we can create a sequence <span class="math">\\tilde{\\mathbf{z}}</span> over the union alphabet <span class="math">\\mathcal{A}=\\{a,b,c,d,0,1\\}</span> by interleaving <span class="math">\\mathbf{k}</span> and <span class="math">\\mathbf{u}:\\tilde{\\mathbf{z}}=\\mathbf{k}[1].\\mathbf{u}[1].\\mathbf{k}[2].\\mathbf{u}[2]\\dotsc</span>. The resulting shuffled sequence inherits both properties: it is still abelian square-free, and has a complexity of order <span class="math">\\Omega\\left(2^{\\ell/2}\\right)</span>.</p>

    <p class="text-gray-300">Even with this exponentially complex dithering sequence, our attack is still more efficient than brute-force in finding second preimages. Although it may be possible to find square-free sequences with even higher complexity, it is probably very difficult to achieve optimal protection, and the generation of the dithering sequences is likely to become more and more complex.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Appendix B Proofs of Sequence-Complexity Related Results</h2>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">Sequences Generated by Morphisms.</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a function <span class="math">\\tau:\\mathcal{A}^{<em>}\\rightarrow\\mathcal{A}^{</em>}</span> is a <em>morphism</em> if for all words <span class="math">x</span> and <span class="math">y</span>, <span class="math">\\tau(x.y)=\\tau(x).\\tau(y)</span>. A morphism is then entirely determined by the images of the individuals letters. A morphism is said to be <em><span class="math">r</span>-uniform</em> (with <span class="math">r\\in\\mathbb{N}</span>) if for all word <span class="math">x</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tau(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=r\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If, for a given letter </span>\\alpha\\in\\mathcal{A}<span class="math">, we have </span>\\tau(\\alpha)=\\alpha.x<span class="math"> for some word </span>x<span class="math">, then </span>\\tau<span class="math"> is <em>non-erasing</em> for </span>\\alpha<span class="math">. Given a morphism </span>\\tau<span class="math"> and an initialization letter </span>\\alpha<span class="math">, let </span>u_{n}<span class="math"> denote the </span>n<span class="math">-th iterate of </span>\\tau<span class="math"> over </span>\\alpha<span class="math">: </span>u_{n}=\\tau^{n}(\\alpha)<span class="math">. If </span>\\tau<span class="math"> is </span>r<span class="math">-uniform (with </span>r\\geq 2<span class="math">) and non-erasing for </span>\\alpha<span class="math">, then </span>u_{n}<span class="math"> is a strict prefix of </span>u_{n+1}<span class="math">, for all </span>n\\in\\mathbb{N}<span class="math">. Let </span>\\tau^{\\infty}(\\alpha)<span class="math"> denote the limit of this sequence : it is the only fixed point of </span>\\tau<span class="math"> that begins with the letter </span>\\alpha<span class="math">. Such infinite sequences are called <em>uniform tag sequences</em> <em>[5]</em> or <em></span>r$-automatic</em> sequences <em>[1]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Because they have a very regular structure, there is a spectacular result <em>[5]</em> regarding the complexity of infinite sequences generated by uniform morphisms:</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 2 (Cobham, 1972).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{z}</span> be an infinite sequence generated by an <span class="math">r</span>-uniform morphism, and assume that the alphabet size $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is constant. Then </span>\\mathbf{z}$ has <em>linear</em> complexity:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Fact_{\\mathbf{z}}(\\ell)\\leq r\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\cdot\\ell.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is worth mentioning that similar results exist in the case of sequences generated by non-uniform morphisms <em>[24, 9]</em>, although the upper bound can be quadratic.</p>

    <p class="text-gray-300">Proofs. Since the Keränen sequence is <span class="math">85</span>-uniform <em>[17, 18, 25]</em>, the result of theorem 2 gives: <span class="math">Fact_{\\mathbf{k}}(\\ell)\\leq 1360\\cdot\\ell</span>. This upper-bound is relatively rough, and for particular values of <span class="math">\\ell</span>, it is possible to obtain a much better approximation (which is tight):</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Lemma 1 (of section 4.1).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{z}</span> be an infinite sequence over the alphabet <span class="math">\\mathcal{A}</span> generated by a <span class="math">r</span>-uniform morphism <span class="math">\\tau</span>. For all <span class="math">\\ell</span>, <span class="math">1\\leq\\ell\\leq r</span>, we have :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Fact_{\\mathbf{z}}(\\ell)\\leq\\ell\\cdot\\Big{(}Fact_{\\mathbf{z}}(2)-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Big{)}+\\Big{[}(r+1)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-Fact_{\\mathbf{z}}(2)\\Big{]}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If <span class="math">\\ell\\leq r</span>, then any factor of <span class="math">\\mathbf{z}</span> of size <span class="math">\\ell</span> falls in one of these two classes (possibly both, but this does not matter, as we are looking for an upper bound) :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Either it is a factor of <span class="math">\\tau(\\alpha)</span> for some letter <span class="math">\\alpha\\in\\mathcal{A}</span>. There are no more than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(r-\\ell+1)$ such factors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Or it is a factor of <span class="math">\\tau(\\alpha).\\tau(\\beta)</span>, for two letters <span class="math">\\alpha,\\beta\\in\\mathcal{A}</span> (and is not a factor of either <span class="math">\\tau(\\alpha)</span> or <span class="math">\\tau(\\beta)</span>). For any given pair <span class="math">(\\alpha,\\beta)</span>, there can only be <span class="math">\\ell-1</span> such factors. Moreover, <span class="math">\\alpha\\beta</span> must be a factor of size <span class="math">2</span> of <span class="math">\\mathbf{z}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\text{So }Fact_{\\mathbf{z}}(\\ell)\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(r-\\ell+1)+Fact_{\\mathbf{z}}(2)\\cdot(\\ell-1).\\qed$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The result of this lemma can be specialized for the Keränen sequence, to obtain the result announced in section 4.1. In this case, we have <span class="math">r=85</span>, $\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathcal{A}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=4<span class="math"> and </span>Fact_{\\mathbf{k}}(2)=12$ (all non-repeating pairs of letters).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-37" class="text-base font-medium mt-4">Lemma 2 (of section 4.1).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{z}</span> be an arbitrary sequence over <span class="math">\\mathcal{A}</span>, and let <span class="math">\\mathbf{d}</span> denote the sequence obtained by diluting <span class="math">\\mathbf{z}</span> with a counter over <span class="math">i</span> bits. Then for every <span class="math">\\ell</span> not equal to 1 modulo <span class="math">2^{i}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">Fact_{\\mathbf{d}}(\\ell)</span> <span class="math">=\\big{(}2^{i}-(\\ell\\mod 2^{i})+1\\big{)}\\cdot Fact_{z}\\big{(}\\big{\\lceil}\\ell\\cdot 2^{-i}\\big{\\rceil}\\big{)}</span> <span class="math">\\quad+\\big{(}\\big{(}\\ell\\mod 2^{i}\\big{)}-1\\big{)}\\cdot Fact_{\\mathbf{z}}\\big{(}\\big{\\lceil}(\\ell-1)\\cdot 2^{-i}\\big{\\rceil}+1\\big{)}</span></p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The counter over <span class="math">i</span> bits splits the diluted sequence <span class="math">\\mathbf{c}</span> into chunks of size <span class="math">2^{i}</span> (a new chunk begins when the counter reaches <span class="math">0</span>). In a chunk, the letter from <span class="math">\\mathbf{z}</span> does not change, and only the counter varies. To obtain the number of factors of size <span class="math">\\ell</span>, let us slide a window of size <span class="math">\\ell</span> over <span class="math">\\mathbf{d}</span>. This window overlaps at least <span class="math">\\big{\\lceil}\\ell\\cdot 2^{-i}\\big{\\rceil}</span> chunks (when the beginning of the window is aligned at the beginning of a chunk), and at most <span class="math">\\big{\\lceil}(l-1)\\cdot 2^{-i}\\big{\\rceil}+1</span> chunks (when the window begins just before a chunk boundary). These two numbers are equal if and only if <span class="math">\\ell\\equiv 1\\mod 2^{i}</span>. When this case is avoided, then these two numbers are consecutive integers.</p>

    <p class="text-gray-300">This means that by sliding this window of size <span class="math">\\ell</span> over <span class="math">\\mathbf{d}</span> we will only observe factors of <span class="math">\\mathbf{z}</span> of size <span class="math">\\big{\\lceil}\\ell\\cdot 2^{-i}\\big{\\rceil}</span> and <span class="math">\\big{\\lceil}\\ell\\cdot 2^{-i}\\big{\\rceil}+1</span>. Given a factor of size <span class="math">\\big{\\lceil}\\ell\\cdot 2^{-i}\\big{\\rceil}</span> of <span class="math">\\mathbf{z}</span>, there are <span class="math">\\big{(}2^{i}-(\\ell\\mod 2^{i})+1\\big{)}</span> positions of a window of size <span class="math">\\ell</span> that allow us to observe this factor</p>

    <p class="text-gray-300">with different values of the counter (it essentially amounts to moving the window without crossing a chunk boundary).</p>

    <p class="text-gray-300">Similarly, there are <span class="math">\\left(\\left(\\ell\\mod 2^{i}\\right)-1\\right)</span> positions of the window that contain a given factor of <span class="math">\\mathbf{z}</span> of size <span class="math">\\left\\lceil\\ell\\cdot 2^{-i}\\right\\rceil+1</span>. <span class="math">\\Box</span></p>

    <p class="text-gray-300">By taking <span class="math">2\\leq\\ell\\leq 2^{i}</span>, we have that <span class="math">\\left\\lceil\\ell\\cdot 2^{-i}\\right\\rceil=1</span>. Therefore, only the number of factors of size <span class="math">1</span> and <span class="math">2</span> of <span class="math">\\mathbf{z}</span> come into play. The formula can be further simplified into:</p>

    <p class="text-gray-300"><span class="math">Fact_{\\mathbf{d}}(\\ell)=\\ell\\cdot\\Big{(}Fact_{\\mathbf{z}}(2)-Fact_{\\mathbf{z}}(1)\\Big{)}+(2^{i}+1)\\cdot Fact_{\\mathbf{z}}(1)-Fact_{2}(\\mathbf{z}).</span></p>

    <p class="text-gray-300">For the Keränen sequence with <span class="math">i=13</span>, this gives: <span class="math">Fact_{\\mathbf{d}}(\\ell)=8\\cdot\\ell+32760</span>.</p>

    <h2 id="sec-39" class="text-2xl font-bold">Appendix C Second Preimage Resistance of Iterated Hash Functions</h2>

    <p class="text-gray-300">Until now we have presented generic second-preimage attacks against particular dithered Merkle-Damgård constructions. In this section, we show that there exists a dithered Merkle-Damgård construction with optimal security against second preimage attacks. For this purpose, we study the HAsh Iterative FrAmework (Haifa) introduced in <em>[23]</em>. It is a Merkle-Damgård construction where a counter is added to the input of the compression function. It can be considered as a dithered Merkle-Damgård construction over an alphabet of <span class="math">2^{k}</span> letters where the role of the dithering is played by the counter. The authors of <em>[23]</em> explain why their proposition resists to all known attacks and claim an upper bound of <span class="math">2^{n}</span> on the complexity of the best possible generic second-preimage attack. In this section we give a proof of their claim, showing that this construction meets the optimal security level against second preimage attacks.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">C.1 Description of Haifa</h3>

    <p class="text-gray-300">We first briefly describe Haifa. The HAsh Iterative FrAmework <span class="math">H^{F}:\\{0,1\\}^{*}\\to\\{0,1\\}^{n}</span> is built by iterating a compression function <span class="math">F\\colon\\{0,1\\}^{m}\\times\\{0,1\\}^{n}\\times\\{0,1\\}^{64}\\to\\{0,1\\}^{n}</span>. The hash process works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pad and split a message <span class="math">M</span> into <span class="math">r</span> blocks <span class="math">x_{1},\\ldots,x_{r}</span> of <span class="math">m</span> bits each.</li>

      <li>Set <span class="math">h_{0}</span> to the initialization value <span class="math">IV</span> .</li>

      <li>For each message block <span class="math">i</span> compute <span class="math">h_{i}=F\\left(h_{i-1},x_{i},i\\right)</span> .</li>

      <li>Output <span class="math">H^{F}(M)=h_{r}</span>.</li>

    </ul>

    <p class="text-gray-300">The padding is done by appending a single ’1’ bit followed by as many ’0’ bit as needed to complete a <span class="math">m</span>-bit block.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">C.2 Security Result</h3>

    <p class="text-gray-300">We model the compression function by a random oracle for two reasons. First we want to take into account only generic attacks, the adversary should not be able to exploit a</p>

    <p class="text-gray-300">particular weakness or property of the compression function. Second, for 1-block messages, the iterated hash function is reduced to the compression function, therefore if the compression function is not a good hash function, the iterated hash function cannot be a good compression function either.</p>

    <p class="text-gray-300">The kind of security results that we obtain by reasoning about a mode of operation in the random oracle model is inherently different from these obtained by the reductionist approach of <em>[26]</em>. Andreeva, Neven, Preneel and Shrimpton <em>[2]</em> proved that Haifa does not preserve the second preimage resistance of the compression function (using a special compression function that admits the IV as a fixpoint). Here, we prove that Haifa is second-preimage resistant when instancied with a “reasonable” compression function. These two results are not contradictory though. Note that the same security result can be stated (losing only a small constant factor) in the Ideal Cipher Model, by considering that the hash function implements the Davies-Meyer mode of operation with independent random permutations.</p>

    <p class="text-gray-300">Let us consider an unbounded adversary <span class="math">\\mathcal{A}</span> that, given a message <span class="math">M</span>, tries to find a message <span class="math">M^{\\prime}</span> such that <span class="math">H^{F}(M)=H^{F}(M^{\\prime})</span>. Let <span class="math">Q</span> denote the number of queries <span class="math">\\mathcal{A}</span> sends to the <span class="math">F</span> oracle. We enforce <span class="math">\\mathcal{A}</span> to always return a message <span class="math">M^{\\prime}</span>, even if it is not a second preimage, and to evaluate <span class="math">H^{F}(M)</span> and <span class="math">H^{F}(M^{\\prime})</span>, by issuing the corresponding queries to the random oracle.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Theorem 3 (Security of Haifa).</h6>

    <p class="text-gray-300">Let <span class="math">H^{F}</span> be an iterated hash function following the scheme of Haifa and <span class="math">\\mathcal{A}</span> a second preimage adversary against <span class="math">H^{F}</span> which makes at most <span class="math">Q</span> queries to <span class="math">F</span>. Then:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[H^{F}(M)=H^{F}(M^{\\prime})\\colon\\mathcal{A}\\text{ returns }M^{\\prime}\\right]\\leq\\frac{2Q}{2^{n}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This essentially comes from the fact that when the adversary submits a query to <span class="math">F</span>, she has to specify the value <span class="math">i_{0}</span> of the counter. Indeed, the adversary wins if and only if she can find a message <span class="math">\\tilde{M}</span> such that <span class="math">H^{F}(\\tilde{M})=h_{i}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=i<span class="math"> or </span>H^{F}(\\tilde{M})=h_{r}<span class="math"> (using previously introduced notations). This implies that for every query where the value of the counter is </span>i_{0}<span class="math">, she can win only if the oracle outputs </span>h_{i_{0}}<span class="math"> or </span>h_{r}$. The detailled proof follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When the classical Merkle-Damgård construction achieved a proven bound $Q\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2^{n-1}$ (which can be established with a very similar proof as the one used for the previous theorem), Haifa reaches the same security level as a random oracle, which is the best security that we can hope.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof (of theorem 3).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We simulate the execution of the adversary <span class="math">\\mathcal{A}</span>, and bookmark the queries sent by <span class="math">A</span> to the random oracles: it is a set <span class="math">S</span> of tuples <span class="math">(x,m,i,y)</span>, with <span class="math">y=F_{i}(x,m)</span>. We suppose that <span class="math">\\mathcal{A}</span> evaluates <span class="math">H(M)</span>, so <span class="math">\\mathcal{A}</span> sends the corresponding queries to the oracles at some point. Let us note these queries $(h_{i},m_{i},i,h_{i+1})_{1\\leq i\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. In particular, </span>H(M)=h_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> succeeds in finding a second preimage, then <span class="math">\\mathcal{A}</span> has produced a collision in particular. It is well known that in the presence of the so-called Merkle-Damgård <em>strengthening</em>, this implies a collision on the compression function <em>[7, 21]</em>. However, this collision is <em>constrained</em> : the resulting target hash value is one of the <span class="math">h_{i}</span>. Finding such a collision is harder than finding an arbitrary collision.</p>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{A}</span> wins. We distinguish two cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{\\prime}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then the values of the counter entering the compression function in its last invocation are different. Therefore, </span>\\mathcal{A}<span class="math"> has found a second preimage on </span>F<span class="math">. Each query has a probability </span>2^{-n}<span class="math"> to yield this preimage. Since there are </span>Q<span class="math"> queries, the probability that </span>\\mathcal{A}<span class="math"> wins this way is upper-bounded by </span>Q/2^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The key of the reasoning is that <span class="math">\\mathbf{E}</span> is realized whenever <span class="math">\\mathcal{A}</span> wins. Thanks to the result of Merkle-Damgård, we know that there is a collision on the compression function where one of the colliding hash value is one of the <span class="math">h_{i}</span>. However, this is not sufficient to say that <span class="math">\\mathbf{E}</span> is realized, because we would need to know that the values of the counter are actually the same. We now prove that it is indeed the case.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Lemma 3 (Collision-Resistance extended to Haifa)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H^{F}</span> be a hash function implementing the mode of operation of Haifa. Let <span class="math">F</span> be the compression function. Then, if <span class="math">H^{F}(M)=H^{F}(M^{\\prime})</span> with <span class="math">M\\neq M^{\\prime}</span> and $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{\\prime}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then there is a collision on </span>F<span class="math">, with the same value of the counter (this means that </span>\\mathbf{E}$ is realized).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">let us note <span class="math">M=x_{1},\\ldots,x_{r}</span>, <span class="math">M^{\\prime}=x_{1}^{\\prime},\\ldots,x_{r}^{\\prime}</span>, <span class="math">h_{0}=h_{0}^{\\prime}=IV</span>, <span class="math">h_{i}=F(h_{i-1},i,x_{i})</span> and <span class="math">h_{i}^{\\prime}=F(h_{i-1}^{\\prime},i,x_{i}^{\\prime})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">h_{r}=h_{r}^{\\prime}</span>, either there is a collision for <span class="math">F</span> (with counter value <span class="math">r</span>), or <span class="math">(x_{r},h_{r-1})=(x_{r}^{\\prime},h_{r-1}^{\\prime})</span>. In the latter case, either there is a collision for <span class="math">F</span> (with counter value <span class="math">r-1</span>) or <span class="math">(x_{r-1},h_{r-2})=(x_{r-1}^{\\prime},h_{r-2}^{\\prime})</span>. This argument repeats. Since $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M^{\\prime}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then either there is a collision for </span>F<span class="math"> at some point (with the same counter value), or </span>x_{i}=x_{i}^{\\prime}<span class="math">, for all </span>i<span class="math">, </span>1\\leq i\\leq r<span class="math">. In the latter case, </span>M=M^{\\prime}$, which is impossible. This completes the proof of the lemma. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that <span class="math">\\mathbf{E}</span> being realized does not imply that <span class="math">\\mathcal{A}</span> has won, because of a corner case : if <span class="math">\\mathcal{A}</span> finds a preimage of <span class="math">H(M)</span> for <span class="math">F</span> but with a message block that does not include the padding, then <span class="math">\\mathcal{A}</span> cannot automatically produce a second preimage. Now, let us show the following inequality:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{P}\\big{[}\\mathbf{E}\\big{]}\\leq\\frac{Q}{2^{n}}</span></p>

    <p class="text-gray-300">Everytime <span class="math">\\mathcal{A}</span> submits a query to the oracle, the probability that <span class="math">\\mathbf{E}</span> is triggered by this particular query is upper-bounded by <span class="math">2^{-n}</span>. When submitting a query (and note</p>

    <p class="text-gray-300">that <span class="math">i_0</span> is part of the query), a random value is chosen by the random oracle, and <span class="math">\\mathbf{E}</span> is realized only if this value is <span class="math">h_{i_0 + 1}</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{A}</span> sends <span class="math">Q</span> queries to the oracle during its execution, we obtain the announced bound.</p>

    <p class="text-gray-300">21</p>`;
---

<BaseLayout title="Second Preimage Attacks on Dithered Hash Functions (2007/395)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2007 &middot; eprint 2007/395
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
