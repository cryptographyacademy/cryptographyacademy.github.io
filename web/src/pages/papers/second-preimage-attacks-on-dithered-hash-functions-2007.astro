---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2007/395';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Second Preimage Attacks on Dithered Hash Functions';
const AUTHORS_HTML = 'Charles Bouillaguet&lt;sup&gt;1&lt;/sup&gt; , Pierre-Alain Fouque&lt;sup&gt;1&lt;/sup&gt; , Adi Shamir1,&lt;sup&gt;2&lt;/sup&gt; , and Sebastien Zimmer&lt;sup&gt;1&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Charles Bouillaguet&lt;sup&gt;1&lt;/sup&gt; , Pierre-Alain Fouque&lt;sup&gt;1&lt;/sup&gt; , Adi Shamir1,&lt;sup&gt;2&lt;/sup&gt; , and Sebastien Zimmer&lt;sup&gt;1&lt;/sup&gt;</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; École normale supérieure Département d'Informatique 45, rue d'Ulm 75230 Paris cedex 05, France Charles.Bouillaguet@ens.fr, Pierre-Alain.Fouque@ens.fr, Sebastien.Zimmer@ens.fr &lt;sup&gt;2&lt;/sup&gt; Weizmann Institute of Science Adi.Shamir@weizmann.ac.il</p>

    </blockquote>

    <p class="text-gray-300">Abstract. The goal of this paper is to analyze the security of dithered variants of the Merkle-Damgård mode of operation that use a third input to indicate the position of a block in the message to be hashed. These modes of operation for hash functions have been proposed to avoid some structural weaknesses of the Merkle-Damgard paradigm, e.g. that second preimages can be constructed in much less than 2 &lt;sup&gt;n&lt;/sup&gt; work, as pointed out by Kelsey and Schneier. Among the modes of operation that use such a third input are Rivest's dithered hashing and Biham and Dunkelman's Haifa proposal.</p>

    <p class="text-gray-300">We propose several new second preimage attacks on the Merkle-Damgård mode of operation, which can also attack Rivest's dithered hash with almost the same complexity. When applied to Shoup's UOWHF, these attacks can be shown to be optimal since their complexity matches Shoup's security bound.</p>

    <p class="text-gray-300">Keywords: Cryptanalysis, Hash Function, Dithering</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Hash functions have recently been the subject of numerous attacks which have highlighted many weaknesses (either on some specific hash functions or on the general Merkle-Damgård mode of operation). Wang et al. [29–32], Biham et al. [3], Klima [19] and Joux et al. [14] all show that differential attacks can be used to efficiently find collisions in specific hash functions based on the MD4 design such as MD5, RIPEMD, SHA-0 and SHA-1. This type of results is important for at least two reasons. First, collision resistance is a classical property that hash function should have. In addition, if collisions were easy to construct, perhaps it would become easier to mount stronger types of attacks which rely on the possibility to find collisions, such as Joux's [13] multicollision attack on combiners. Following this result, Kelsey and Schneier [16] extended a previous result of Dean [8], and showed that Joux's idea can be used to mount an efficient second preimage attack. All these attacks led the NIST to organize workshops and to solicit new hash function candidates.</p>

    <p class="text-gray-300">After Kelsey and Schneier published their attack, several researchers proposed to tweak the Merkle-Damgård paradigm, using a third input (called &quot;dithering&quot;) to avoid attacks based on fixed points that can be iterated an arbitrary number of times. In this paper, we study the second preimage resistance of such dithered modes of operation, which is crucial for the security of signature schemes based on the &quot;hash-and-sign&quot; paradigm.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <p class="text-gray-300">Independently of the Ph.D thesis of Dean [8], Kelsey and Schneier [16] presented at EUROCRYPT 2005 a second preimage attack that works against all hash functions based on the Merkle-Damgård construction. The complexity of their attack is  <span class="math">k \\cdot 2^{n/2+1} + 2^{n-k+1}</span>  evaluations of the compression function. It relies on expandable messages, i.e. a family of messages of different lengths that hash to the same value. These messages are used to bypass the Merkle-Damgård strengthening. This in turn allows them to reapply the long message attack [20] which was supposedly foiled by the strengthening.</p>

    <p class="text-gray-300">Biham and Dunkelman proposed HAIFA [23], which adds in each block the number of message bits which were hashed so far. The simplest way to implement HAIFA is to shorten each data block by 64 bits, and to concatenate the 64 bit counter instead. Rivest [25] introduced a clever way to decrease the number of bits used for this extra input to either 2 or 16, thus increasing the bandwidth available for actual data, by using a specific sequence of values to &quot;dither&quot; the actual inputs. The properties of this sequence were claimed by Rivest to be sufficient to avoid the Kelsey-Schneier attack.</p>

    <p class="text-gray-300">Another variant of the long message attack is the &quot;Nostradamus attack&quot; of Kelsey and Kohno [15] which makes it possible to commit to a hash value h and then to find a message that hashes to h with any desired prefix. For their attack, they have introduced the &quot;diamond&quot; structure which is reminiscent of a binary tree. It is a  <span class="math">2^{\\ell}</span> -multicollision where all the  <span class="math">2^{\\ell}</span>  colliding messages have a different initial value. Its construction cost is heavy,  <span class="math">2^{n/2+\\ell/2+2}</span>  (where n is the size of the hash function output), but then it allows to connect any message to the collision tree with only  <span class="math">2^{n-\\ell+1}</span>  calls to the hash function.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Our Results</h3>

    <p class="text-gray-300">In this paper, we propose several new generic second preimage attacks on various dithered versions of the Merkle-Damgård paradigm in which the compression function can be modeled by a random oracle. Our technique mainly relies on the diamond structure from the herding attack of [15]. If the diamond is a  <span class="math">2^{\\ell}</span> -multicollision, we obtain a second preimage of a message of size  <span class="math">2^k</span>  in time  <span class="math">2^{n/2+\\ell/2+2}+2^{n-\\ell+1}+2^{n-k+1}</span> . This expression is optimal for  <span class="math">\\ell \\approx n/3</span>  where the complexity becomes  <span class="math">2^{2n/3+2} + 2^{n-k+1}</span> . This is slightly more expensive than the  <span class="math">k \\cdot 2^{n/2+1} + 2^{n-k+1}</span>  complexity of the Kelsey-Schneier attack (for SHA-1, the Kelsey-Schneier attack complexity is about 2&lt;sup&gt;106&lt;/sup&gt; work whereas ours is approximately  <span class="math">2^{109}</span> ). The main advantage of our attack is that it can be extended to Rivest's dithered proposal since the dithering sequence used in the third input has an undesirable property that can be exploited to make the attack efficient: the number of  <span class="math">\\ell</span> -letter subwords in it is exceptionally small, and thus one of these subwords must occur very frequently. Compared to the original attack, we lose a factor equal to the inverse of the frequency of the most probable word. The function mapping  <span class="math">\\ell</span>  to the number of  <span class="math">\\ell</span> -letter words in the sequence is called the factor complexity of the sequence (see for example [1]). For the particular sequence chosen by Rivest, this complexity is only linear in the size  <span class="math">\\ell</span>  of the words. For example, for Rivest's 16-bit sequence, the attack requires  <span class="math">2^{n/2+\\ell/2+2} + (8\\ell + 32768) \\cdot 2^{n-\\ell+1} + 2^{n-k+1}</span>  work, which for SHA-1 is approximately  <span class="math">2^{121}</span> . This is slightly worse than the attacks against the basic Merkle-Damgård construction but it is still much smaller than the  <span class="math">2^{160}</span>  security which was expected for the dithered construction.</p>

    <p class="text-gray-300">An extension of the basic attack can also be applied to a Universal One Way Hash Function designed by Shoup [27], which has some similarities with dithered hashing. Our technique yields the first published attack against this particular hash function. This additionally proves that Shoup's security bound is tight since there is asymptotically only a factor of  <span class="math">\\mathcal{O}(\\log k)</span>  between his bound and our attack's complexity.</p>

    <p class="text-gray-300">The attacks presented above demonstrate that the properties of the dithering sequence influencing the security of dithered hash functions may not be well understood, and may include additional properties beyond its factor complexity and its repetition-freeness.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.3 Organization of the Paper.</h4>

    <p class="text-gray-300">We describe our attack against the Merkle-Damgård construction in section 2. We introduce some terminology and describe the dithered Merkle-Damgård construction in section 3, and then we extend our attack to tackle dithered Merkle-Damgård in section 4. We apply it to Rivest's concrete proposal, as well as to some of the variations that he suggested. In section 5, we apply the extended attack against Shoup's UOWHF construction.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 A New Generic Second Preimage Attack</h2>

    <h2 id="sec-6" class="text-2xl font-bold">2.1 The Merkle-Damgård construction</h2>

    <p class="text-gray-300">We first describe briefly the classical Merkle-Damgård construction. An iterated hash function  <span class="math">H^F: \\{0,1\\}^* \\to \\{0,1\\}^n</span>  is built by iterating a basic compression function  <span class="math">F: \\{0,1\\}^m \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span> . The hash process works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad and split a message M into r blocks  <span class="math">x_1, \\ldots, x_r</span>  of m bits each.</li>
      <li>Set  <span class="math">h_0</span>  to the initialization value IV.</li>
      <li>For each message block <em>i</em> compute  <span class="math">h_i = F(h_{i-1}, x_i)</span> .</li>
      <li>Output  <span class="math">H^F(M) = h_r</span> .</li>
    </ul>

    <p class="text-gray-300">The padding is usually done by appending a single '1' bit followed by as many '0' bits as needed to complete an m-bit block. Merkle [21] and Damgård [7] independently proved in 1989 that making the binary encoding of the message length part of the padding improves the security of the construction: with this so-called <em>strengthening</em>, the scheme is proven to be Collision-Resistance Preserving, in the sense that a collision in the hash function  <span class="math">H^F</span>  would imply a collision in the compression function F. As a side effect, the strengthening defines an upper bound on the size of the messages that can be processed (because the encoding of the length has a fixed size). In most deployed hash functions, this limit is  <span class="math">2^{64}</span>  bits, or equivalently  <span class="math">2^{55}</span>  512-bit blocks. In the sequel, we denote the maximal number of admissible blocks by  <span class="math">2^k</span> .</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.2 Description of the Attack</h2>

    <p class="text-gray-300">We describe a new technique to build expandable messages. It relies heavily on the diamond structure introduced by Kelsey and Kohno [15] to find second preimages. An expandable message  <span class="math">\\mathcal{M}</span>  is a family of messages with different number of blocks but with the same hash up to strengthening. We call any one of these messages an <em>instance</em> of  <span class="math">\\mathcal{M}</span> . The range of  <span class="math">\\mathcal{M}</span>  is the set of lengths of its instances.</p>

    <p class="text-gray-300">A diamond of size  <span class="math">\\ell</span>  is a multicollision that has the shape of a complete converging binary tree of height  <span class="math">\\ell</span> . It therefore has  <span class="math">2^{\\ell}</span>  leaves. Its nodes are labelled by chaining values over n bits, and its edges are labelled by message blocks over m bits, which map between the chaining values at the two ends of the edge by the compression function. Thus, from any one of the  <span class="math">2^{\\ell}</span>  leaves, there is a path labelled by  <span class="math">\\ell</span>  message blocks that leads to the same target value  <span class="math">h_T</span>  labelling the root of the tree.</p>

    <p class="text-gray-300">Let M be a message of size  <span class="math">2^k</span> . The main idea of the attack is that after a big collision tree of height  <span class="math">\\ell</span>  is built during an (expensive) preprocessing stage, it costs less than  <span class="math">2^n</span>  work to &quot;connect&quot; the target chaining value  <span class="math">h_T</span>  of the tree to one of the  <span class="math">2^k</span>  chaining values  <span class="math">h_i</span>  obtained when hashing M. It also costs much less than  <span class="math">2^n</span>  work to connect an arbitrary prefix to one of the  <span class="math">2^{\\ell}</span>  leaves, if we do not care which one it is. The attack works in four steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Preprocessing step: compute a collision tree of height  <span class="math">\\ell</span>  with an arbitrary target value  <span class="math">h_T</span> . Note that this has to be done only once, and can be reused when computing second preimages of multiple messages.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Connect the target  <span class="math">h_T</span>  to some block in the message M. This can be done by generating random message blocks B, until  <span class="math">F(h_T, B) = h_{i_0}</span>  for some  <span class="math">i_0</span> ,  <span class="math">\\ell + 1 \\le i_0 &lt; |M|</span> . Let  <span class="math">B_0</span>  be a message block satisfying this condition.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate an arbitrary prefix P of size  <span class="math">i_0 \\ell 1</span>  whose hash is one of the chaining values labelling a leaf. Let  <span class="math">h = H^F(P)</span>  be this value, and let T be the chain of  <span class="math">\\ell</span>  blocks traversing the tree from h to  <span class="math">h_T</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Form a message  <span class="math">M&#x27; = P||T||B_0||M_{i_0+1}...M_{2^r}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Fig. 1: Summary of the attack on classic Merkle-Damgård.</p>

    <p class="text-gray-300">The message M' has the same hash as M, before strengthening, and has the same length, so we have obtained a full collision in the strengthened Merkle-Damgård construction.</p>

    <p class="text-gray-300">A collision tree of height  <span class="math">\\ell</span>  can be constructed with time and space complexity  <span class="math">2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2}</span>  (see [15] for details). The second step of the attack can be carried out with  <span class="math">2^{n-k+1}</span>  work, and the third one with  <span class="math">2^{n-\\ell+1}</span>  work. The total time complexity of the attack is then:</p>

    <p class="text-gray-300"><span class="math">$2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + 2^{n-k+1} + 2^{n-\\ell+1}</span>$</p>

    <p class="text-gray-300">If n is much bigger than k (which is the case in all the members of the SHA family), then the first term of this sum becomes negligible compared to the other two; we will use</p>

    <p class="text-gray-300">this approximation in the sequel. The complexity is minimal when  <span class="math">\\ell = \\frac{n}{3}</span> , and with this setting, the total cost of our attack is about  <span class="math">3 \\cdot 2^{2n/3+2} + 2^{n-k+1}</span> .</p>

    <p class="text-gray-300">It must be noted that if we choose  <span class="math">\\ell \\geq k</span> , then the connection in the third step of the attack can be realized for free. This step amount to finding a prefix of a given length, the hash of which is one of the values labelling the leaves of the collision tree. When there are more leaves than possible lengths for the prefix (that is,  <span class="math">2^k</span> ), then the hash value labelling the <em>i</em>-th leaf can be obtained by hashing a chosen message of length <em>i</em> blocks. This makes the attack slightly less expensive when <em>n</em> is very big.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.3 Comparison With Kelsey and Schneier</h3>

    <p class="text-gray-300">The difference between the two techniques lies in the way expandable messages are built. Kelsey and Schneier build an expandable message in time  <span class="math">k \\cdot 2^{n/2+1}</span> . Here, we build an expandable message in time  <span class="math">2^{n/2+\\ell/2+2} + 2^{n-\\ell+1}</span> . On the original Merkle-Damgård construction their attack is more efficient than ours (on SHA-1, they can find a second preimage of a message of size  <span class="math">2^{55}</span>  with  <span class="math">2^{106}</span>  work, whereas we need  <span class="math">2^{109}</span>  calls to the compression function to obtain the same result). However, our technique to build expandable messages is more flexible, and in particular it can be adapted to work even when an additional dithering input is given, unlike the original Kelsey-Schneier technique. In addition, our technique gives the adversary more control on the second preimage, since she can typically choose about half of the message in an arbitrary way.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Dithered Hashing</h2>

    <p class="text-gray-300">The general idea of dithered hashing is to perturb the hashing process by using an additional input to the compression function, formed by the consecutive elements of a fixed <em>dithering</em> sequence. This gives the attacker less control over the input of the compression function, and makes the hash of a message block dependent on its position in the whole message. In particular, its goal is to prevent attacks based on expandable messages.</p>

    <p class="text-gray-300">Since the dithering sequence  <span class="math">\\mathbf{z}</span>  has to be at least as long as the maximal number of blocks in any message that can be processed by the hash function, it is reasonable to consider infinite sequences as candidates for  <span class="math">\\mathbf{z}</span> . Let  <span class="math">\\mathcal{A}</span>  be a finite alphabet, and let the dithering sequence  <span class="math">\\mathbf{z}</span>  be an eventually infinite word over  <span class="math">\\mathcal{A}</span> . Let  <span class="math">\\mathbf{z}[i]</span>  denote the i-th element of  <span class="math">\\mathbf{z}</span> . The dithered Merkle-Damgård construction is obtained by setting  <span class="math">h_i = F(x_i, h_{i-1}, \\mathbf{z}[i])</span>  in the definition of the Merkle-Damgård scheme.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.1 Words and Sequences</h4>

    <p class="text-gray-300">Notations and Terminology. Let  <span class="math">\\omega</span>  be a word over the finite alphabet  <span class="math">\\mathcal{A}</span> . The dot operator denotes concatenation. If  <span class="math">\\omega</span>  can be written as  <span class="math">\\omega = x.y.z</span>  (where x,y or z can be empty), we say that x is a <em>prefix</em> of  <span class="math">\\omega</span>  and that y is a <em>factor</em> (or subword) of  <span class="math">\\omega</span> . A finite word  <span class="math">\\omega</span>  is a <em>square</em> if it can be written as  <span class="math">\\omega = x.x</span> , where x is not empty. A finite</p>

    <p class="text-gray-300">word ω is an abelian square if it can be written as ω = x.x′ where x ′ is a permutation of x (i.e. a reordering of the letters of x). A word is said to be square-free (resp. abelian square-free) if none of its factors is a square (resp. an abelian square). Note that abelian square-free words are in particular square-free.</p>

    <p class="text-gray-300">An Infinite Abelian Square-Free Sequence. In 1992, Keränen [17] exhibited an infinite abelian square-free word k over a four-letter alphabet (there are no infinite abelian square-free words over a ternary alphabet). In this paper, we call this infinite abelian square-free word the Keränen sequence. Details about its construction can be found in [17, 18, 25].</p>

    <p class="text-gray-300">Sequence Complexity. The number of factors of a given size of an infinite word gives an intuitive notion of its complexity: a sequence is more complex (or richer) if it possesses a large number of different factors. We denote by F actz(ℓ) the number of factors of size ℓ of the sequence z.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2 Rivest's Proposals.</h2>

    <p class="text-gray-300">Keränen-DMD. Rivest suggested to directly use the Keränen sequence as a source of dithering inputs. The dithering inputs are taken from the alphabet A = {a, b, c, d}, and can be encoded by two bits. The number of data bits in the input of the compression function is thus reduced by only two bits, which improves the hashing efficiency. It is possible to generate the Keränen sequence online, one symbol at a time, in logarithmic space and constant amortized time.</p>

    <p class="text-gray-300">Rivest's Concrete Proposal. Rivest's concrete proposal is referred to as DMD-CP (Dithered Merkle-Damgård– Concrete Proposal). To speed up the generation of the dithering sequence, Rivest proposed a slightly modified scheme, in which the dithering symbols are 16-bit wide. If the message M is r blocks long, then for 1 ≤ i &lt; r the i-th dithering symbol has the form:</p>

    <p class="text-gray-300"><span class="math">$(0, \\mathbf{k}[|i/2^{13}|], i \\mod 2^{13}) \\in \\{0, 1\\} \\times \\mathcal{A} \\times \\{0, 1\\}^{13}</span>$</p>

    <p class="text-gray-300">The idea is to increment the counter for each dithering symbol, and to shift to the next letter in the Keränen sequence, only when the counter overflows. This &quot;diluted&quot; dithering sequence can essentially be generated 2 &lt;sup&gt;13&lt;/sup&gt; times faster than the Keränen sequence. The last dithering symbol has a different form :</p>

    <p class="text-gray-300"><span class="math">$(1, |M| \\mod m) \\in \\{0, 1\\} \\times \\{0, 1\\}^{15}</span>$</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Second Preimage Attacks on Dithered Merkle-Damgård</h2>

    <p class="text-gray-300">In this section, we present the first known second preimage attack on Rivest's dithered Merkle-Damgård construction. In section 4.1, we adapt the attack of section 2 to KeränenDMD, obtaining second preimages in time  <span class="math">(k+39) \\cdot 2^{n-k}</span> . We then apply the extended attack to MMD-CP, obtaining second preimages with about  <span class="math">2^{n-k+16}</span>  evaluations of the compression function. We show some examples of sequences which make the corresponding dithered constructions immune to our attack. This notably covers the case of HAIFA [23]. Lastly, we present in section 4.2 a variation of the attack, which includes an expensive preprocessing, but which is able to cope with sequences of high complexity over a small alphabet with a very small online cost.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.1 Adapting the Attack to Dithered Merkle-Damgård</h2>

    <p class="text-gray-300">Let us now assume that the hashing algorithm uses a dithering sequence  <span class="math">\\mathbf{z}</span> . When building the collision tree, we must choose which dithering symbols to use. A simple solution is to use the same dithering symbol for all the edges at the same depth in the tree. A tuple of  <span class="math">\\ell</span>  letters is then required to build the collision tree. We will also need an additional letter to connect the tree to the message M. This way, in order to build a collision tree of height  <span class="math">\\ell</span> , we have to fix a word  <span class="math">\\omega</span>  of size  <span class="math">\\ell+1</span> , use  <span class="math">\\omega[i]</span>  as the dithering symbol of depth i, and use the last letter of  <span class="math">\\omega</span>  to realize the connection.</p>

    <p class="text-gray-300">The dithering sequence makes the hash of a block dependent on its position in the whole message. Therefore, the collision tree can be connected to its target only at certain positions, namely, at the positions where  <span class="math">\\omega</span>  and  <span class="math">\\mathbf{z}</span>  match. The range of such an expandable message  <span class="math">\\mathcal{M}</span>  is then given by:</p>

    <p class="text-gray-300">Range
<span class="math">$\\mathcal{M} = \\left\\{ i \\in \\mathbb{N} \\, \\middle| \\, \\left( \\ell + 1 \\le i \\right) \\land \\left( \\mathbf{z}[i - \\ell] \\dots \\mathbf{z}[i] = \\omega \\right) \\right\\}.</span>$</p>

    <p class="text-gray-300">Note that finding a connecting block  <span class="math">B_0</span>  in the second step defines the length of the instance of  <span class="math">\\mathcal{M}</span>  that is required. If  <span class="math">i_0</span>  is in the range of  <span class="math">\\mathcal{M}</span> , it will be possible to build this instance. Otherwise, another block  <span class="math">B_0</span>  has to be found.</p>

    <p class="text-gray-300">To make sure that Range  <span class="math">\\mathcal{M}</span>  is not empty,  <span class="math">\\omega</span>  has to be a factor of  <span class="math">\\mathbf{z}</span> . Ideally,  <span class="math">\\omega</span>  should be the factor of length  <span class="math">\\ell+1</span>  which occurs most frequently in  <span class="math">\\mathbf{z}</span> , as the cost of the attack ultimately depends on the number of connecting blocks tried before finding a useful one (with  <span class="math">i_0 \\in \\text{Range } \\mathcal{M}</span> ). What is the probability that a factor  <span class="math">\\omega</span>  appears at a random position in  <span class="math">\\mathbf{z}</span> ? Although this is highly sequence-dependent, it is possible to give a generic lower bound: in the worst case, all factors of size  <span class="math">\\ell+1</span>  appear in  <span class="math">\\mathbf{z}</span>  with the same frequency. In this setting, the probability that a randomly chosen factor of size  <span class="math">\\ell+1</span>  in  <span class="math">\\mathbf{z}</span>  is the word  <span class="math">\\omega</span>  is  <span class="math">1/Fact_{\\mathbf{z}}(\\ell+1)</span> .</p>

    <p class="text-gray-300">The main property of z influencing the cost of our attack is its complexity (which is related to its min-entropy), whereas its repetition-freeness influences the cost of Kelsey and Schneier type attacks.</p>

    <p class="text-gray-300">The cost of finding this second preimage for a given sequence z is then:</p>

    <p class="text-gray-300"><span class="math">$2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + Fact_{\\mathbf{z}}(\\ell+1) \\cdot 2^{n-k+1} + 2^{n-\\ell+1}.</span>$</p>

    <p class="text-gray-300">Cryptanalysis of Keränen-DMD. The cost of the extended attack against Keränen-DMD depends on the complexity of the sequence <strong>k</strong>. Since it has a very regular structure,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Choose the most frequent factor  <span class="math">\\omega</span>  of <strong>z</strong>, with  <span class="math">|\\omega| = \\ell + 1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Build a collision tree of size  <span class="math">\\ell</span>  using  <span class="math">\\omega</span>  as the dithering symbols in all the leaf-to-root paths. Let  <span class="math">h_T</span>  be the target value of the tree.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Find a connecting block  <span class="math">B_0</span>  mapping  <span class="math">h_T</span>  to anyone of the  <span class="math">h_i</span>  (say  <span class="math">h_{i_0}</span> ), by using  <span class="math">\\omega[\\ell]</span>  as the dithering letter. Repeat until  <span class="math">i_o \\in \\text{Range } \\mathcal{M}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Carry the remaining steps of the attack as described previously.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Fig. 2: Summary of the attack when a dithering sequence z is used.</p>

    <p class="text-gray-300"><strong>k</strong> has an unusually low complexity (there are other abelian square-free sequences with exponential complexity, see appendix A). In appendix B we prove the following lemma:</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> For  <span class="math">\\ell &lt; 85</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{k}}(\\ell) \\leq 8 \\cdot \\ell + 332.</span>$</p>

    <p class="text-gray-300">By computing the exact number of factors of  <span class="math">\\mathbf{k}</span> , it is possible to observe that this bound is tight (for example there are exactly 732 factors of size 50). With  <span class="math">\\ell=50</span> , and assuming that all factors occur equally often in  <span class="math">\\mathbf{k}</span> , the probability that a connecting block falls in the range of  <span class="math">\\mathcal{M}</span>  is  <span class="math">2^{-9.5}</span> . However, we observe that in the first  <span class="math">2^{30}</span>  symbols of  <span class="math">\\mathbf{k}</span>  there are factors of size 50 occurring 2941800 times while some others only occur 910237 times. By choosing one of the former, and assuming that the frequency of this factor is the same throughout  <span class="math">\\mathbf{k}</span> , the probability can be increased to  <span class="math">2^{-8.5}</span> , but we are not going to take this slight improvement into account when computing the cost of the attack.</p>

    <p class="text-gray-300">Despite being strongly repetition-free, the sequence  <span class="math">{\\bf k}</span>  offers an extremely weak security level against our attack. We illustrate this by evaluating the cost of our attack on Keranen-DMD:</p>

    <p class="text-gray-300"><span class="math">$2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + (8 \\cdot \\ell + 340) \\cdot 2^{n-k+1} + 2^{n-\\ell+1}</span>$</p>

    <p class="text-gray-300">If n is greater than about 3k, then by setting  <span class="math">\\ell = k - 3</span> , the total cost of the attack is about:</p>

    <p class="text-gray-300"><span class="math">$(k+39)\\cdot 2^{n-k+4}</span>$</p>

    <p class="text-gray-300">which is much smaller than  <span class="math">2^n</span>  in spite of the dithering.</p>

    <p class="text-gray-300">Cryptanalysis of DMD-CP. We now apply the attack to Rivest's concrete proposal. We first need to evaluate the complexity of its dithering sequence. Recall from section 3.2 that it is based on the Keränen sequence, but that we move on to the next symbol of the sequence only when a 13 bit counter overflows. The original motivation was to reduce the cost of the dithering, but it has the unintentional effect of increasing the resulting sequence complexity. However, in appendix B we prove that this effect is quite small:</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let <strong>c</strong> denote the sequence obtained by diluting <strong>k</strong> with a 13-bit counter. Then for every  <span class="math">0 \\le \\ell &lt; 2^{13}</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{c}}(\\ell) = 8 \\cdot \\ell + 32760.</span>$</p>

    <p class="text-gray-300">The dilution does not generate a sequence of higher asymptotic complexity: it is still linear in  <span class="math">\\ell</span> , even though the constant term is bigger due to the counter. The cost of the attack is therefore:</p>

    <p class="text-gray-300"><span class="math">$2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + (8 \\cdot \\ell + 32768) \\cdot 2^{n-k+1} + 2^{n-\\ell+1}</span>$
.</p>

    <p class="text-gray-300">Again, if n is greater than about 3k, the best value of  <span class="math">\\ell</span>  is given by  <span class="math">\\ell = k - 3</span> , and the complexity of the attack is then approximately:</p>

    <p class="text-gray-300"><span class="math">$(k+4096) \\cdot 2^{n-k+4} \\simeq 2^{n-k+16}</span>$
.</p>

    <p class="text-gray-300">For settings corresponding to SHA-1, a second preimage can be computed in time  <span class="math">2^{121}</span> .</p>

    <p class="text-gray-300"><strong>Countermeasures.</strong> Even though the dilution does not increase the asymptotic complexity of a sequence, the presence of a counter increases the complexity of the attack. If we simply used a counter over i bits as the dithering sequence, the number of factors of size  <span class="math">\\ell</span>  would be  <span class="math">Fact(\\ell) = 2^i</span>  (as long as  <span class="math">i \\leq \\ell</span> ). The complexity of the attack would then become:</p>

    <p class="text-gray-300"><span class="math">$2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + 2^{n-k+i+1} + 2^{n-\\ell+1}</span>$
.</p>

    <p class="text-gray-300">In practice, the dominating term is  <span class="math">2^{n-k+i+1}</span> . By taking i = k, we would obtain a scheme which is resistant to our attack. This is essentially the choice made by the designers of HAIFA [23], but such a dithering sequence consumes k bits of bandwidth. Note that as long as the counter does not overflow, no variation of the attack of Kelsey and Schneier can be applied to the dithered construction.</p>

    <p class="text-gray-300">A possible way to improve the resistance of Rivest's dithered hashing to this attack is to use a dithering sequence of high complexity over a small alphabet (to preserve bandwidth). In appendix A we show that there is an abelian square-free sequence over 6 letters with complexity greater than  <span class="math">2^{\\ell/2}</span> . Then, with  <span class="math">\\ell = 2k/3</span> , the total cost of the online attack is  <span class="math">2^{n-2k/3}</span> .</p>

    <p class="text-gray-300">Another possible way to repair Rivest's dithered hashing is to use a pseudo random sequence over a small alphabet. Even though it may not be repetition-free, its complexity is almost maximal. Suppose the alphabet has size  <span class="math">|\\mathcal{A}| = 2^i</span> . Then the expected number of  <span class="math">\\ell</span> -letter factors in a pseudo random word of size  <span class="math">2^k</span>  is:  <span class="math">2^{i\\cdot\\ell}\\cdot (1-\\exp{-2^{k-i\\cdot\\ell}})</span>  (refer to [11, 12] for a proof of this claim). The total optimal cost of the online attack is  <span class="math">2^{n-k/(i+1)+3}</span>  and is obtained with  <span class="math">\\ell = k/(i+1)</span> . With 8-bit dithering symbols and if k=55, as in the SHA family, the complexity of the attack is  <span class="math">2^{n-4}</span> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.2 A Generic Attack on any Dithering Scheme With a Small Alphabet</h4>

    <p class="text-gray-300">The attacks described so far exploited the low complexity of Rivest's specific dithering sequences. In this section we show that the weakness is more general, and that after some preprocessing second preimages can be found in  <span class="math">\\max(\\mathcal{O}(2^k), \\mathcal{O}(2^{(n-k)/2}))</span>  time for any dithering sequence (even of maximal complexity) if the dithering alphabet is small.</p>

    <p class="text-gray-300">Outline of the Attack. The new attack can be viewed as a type of time-memory tradeoff. For any given compression function, we precompute a fixed data structure called a kite generator&lt;sup&gt;3&lt;/sup&gt; which can then be used to compute additional preimages for any dithering sequence and any given message of length  <span class="math">\\mathcal{O}(2^k)</span>  in time  <span class="math">\\max(\\mathcal{O}(2^k), \\mathcal{O}(2^{(n-k)/2}))</span> and negligible additional space. Note that for the SHA-1 parameters of n=160 and k=55, the time complexity of the new attack is  <span class="math">2^{55}</span> , which is just the time needed to hash the original message! The size of the kite generator is  <span class="math">\\mathcal{O}(|\\mathcal{A}| \\cdot 2^{n-k})</span>  (where  <span class="math">|\\mathcal{A}| = 4</span> for Rivest's original proposal, and  <span class="math">|\\mathcal{A}| = 2^{15}</span>  for Rivest's concrete proposal). The kite generator is a labelled directed graph whose  <span class="math">2^{n-k}</span>  vertices are labelled by some easily recognized subset of the chaining values that includes the IV (e.g., the tiny fraction of hash values which are extremely close to IV). Each directed edge (which can be traversed in both directions) is labelled by one letter  <span class="math">\\alpha</span>  from the dithering alphabet and one message block m, and it leads from vertex  <span class="math">h_1</span>  to vertex  <span class="math">h_2</span>  if  <span class="math">F(h_1, m, a) = h_2</span> . Each vertex in the generator should have exactly two outgoing edges labelled by each dithering letter, and thus the expected number of ingoing edges labelled by each letter is also 2. The generator is highly connected in the sense that there is an exponentially large diverging binary tree with any desired dithering sequence starting at any vertex, and an exponentially large converging tree &lt;sup&gt;4&lt;/sup&gt; with any desired dithering sequence (whose degrees are not always 2) ending at most vertices. It can be viewed as a generalization of the collision tree of Kelsey and Kohno [15], which is a single tree with a single root in only the converging direction and with no dithering labels.</p>

    <p class="text-gray-300">Once computed (during an unbounded precomputation stage), we can use the generator to find a second preimage for any given message M with  <span class="math">2^k</span>  blocks and any dithering sequence. We first hash the long input M to find (with high probability) some intermediate hash value  <span class="math">h_i</span>  which appears in the generator. We then use the generator to replace the first i blocks in the message by a different set of i blocks. We start from the generator vertex labelled by IV, and follow some path in the generator of length i - (n - k) which has the desired dithering sequence (there are exponentially many paths we can choose from). It leads to some hash value  <span class="math">h_t</span>  in the generator. We then evaluate the full diverging tree of depth (n - k)/2 and the desired dithering sequence ending at  <span class="math">h_i</span> . Since</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;3&lt;/sup&gt; We call it a kite generator since we use it generate <em>kites</em> of the form of</p>

    <p class="text-gray-300">    <img src="_page_9_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: A Kite</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;4&lt;/sup&gt; See [10] for a formal justification of this claim.</p>

    <p class="text-gray-300">the number of leaves in each tree is  <span class="math">\\mathcal{O}\\left(2^{(n-k)/2}\\right)</span>  and they are labelled by only  <span class="math">2^{n-k}</span>  possible values, we expect by the birthday paradox to find a common chaining value among the two sets of leaves. We can now combine the long random chain of length i - (n - k) with the two short tree chains of length (n - k)/2 to find a <em>kite</em>-shaped structure of the same length i and with the same dithering sequence as the original message between the two chaining values IV and  <span class="math">h_i</span> .</p>

    <p class="text-gray-300">Finding Collisions inside a Kite. The simplest way to find the common leaf is to store all the leaf values of the diverging and converging trees in an additional data structure, sort it, and look for repetitions. This requires time and space  <span class="math">\\mathcal{O}(2^{(n-k)/2})</span> . However, it is possible to find the common leaf value by a more sophisticated algorithm which requires the same time but negligible additional space. It is based on Pollard's  <span class="math">\\rho</span>  method, with appropriate modifications. Let  <span class="math">f_1(x)</span>  be the mapping from the root of the diverging tree to the leaf in which the path is determined by the desired dithering sequence where the first n-k-1 bits in x define which of the two outgoing edges with each dithering symbol to follow. Let  <span class="math">f_2(x)</span>  be a similar mapping from the root of the converging tree to the leaf specified by x. Finally, let  <span class="math">f_0(x)</span>  be the random function from n-k bit values to n-k bit values in which the last bit of x determines whether we apply  <span class="math">f_1</span>  or  <span class="math">f_2</span>  to x. By iterating  <span class="math">f_0</span>  on a random initial value  <span class="math">x_0</span> , we expect to enter a loop after  <span class="math">\\mathcal{O}\\left(2^{(n-k)/2}\\right)</span>  steps. The entry point into this loop represents two different values  <span class="math">x_1</span>  and  <span class="math">x_2</span>  which converge under  <span class="math">f_0</span>  to the same value  <span class="math">x_0</span> . With constant probability  <span class="math">x_1</span>  and  <span class="math">x_2</span>  have different final bits, and in this case  <span class="math">x_0</span>  is a common leaf in the diverging and converging tree paths represented by  <span class="math">f_1(x_1)</span>  and  <span class="math">f_2(x_2)^{-5}</span> .</p>

    <p class="text-gray-300">When the size of the dithering alphabet  <span class="math">\\mathcal{A}</span>  exceeds  <span class="math">2^k</span>  (as in the HAIFA proposal) the size of the kite generator becomes larger than  <span class="math">2^n</span> , and thus our attack becomes more expensive than the trivial attack that precomputes and stores one message that hashes to each one of the  <span class="math">2^n</span>  possible values.</p>

    <p class="text-gray-300">The attack can be applied with essentially the same complexity even when the IV is not known during the precomputation stage (e.g., when it is time dependent). When we hash the original long message, we have to find two intermediate hash values  <span class="math">h_i</span>  and  <span class="math">h_j</span>  (instead of IV and  <span class="math">h_i</span> ), and connect them by a properly dithered kite-shaped structure of the same length.</p>

    <p class="text-gray-300">Note that if we reduce the size of either the message or the kite generator, we are unlikely to find any common chaining values between the given message and the generator. Finding a way to connect the generator back into the message will require  <span class="math">2^{n-k+1}</span>  additional steps, and thus the time complexity of finding second preimages in arbitrarily dithered SHA-1 will jump from  <span class="math">2^{55}</span>  to at least  <span class="math">2^{106}</span> . It is an interesting open problem whether we can precompute a smaller generator, and trade it off smoothly with a larger computing time without such quantum jumps.</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;5&lt;/sup&gt; Note that the length of the path in each one of the trees was extended from (n-k)/2 to n-k-1 in order to make sufficiently many leaves reachable from both roots, and thus we have to shorten the tail to i-2(n-k-1) to get the same total path length.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 An Attack on Shoup's UOWHF</h2>

    <p class="text-gray-300">In this section, we show that our attack is generic enough to be applied against hash functions enjoying a different security property, namely Universal One-Way Hash Function (UOWHF). A UOWHF is a keyed hash function H for which any computationally bounded adversary A wins the following game with negligible probability. First A chooses a message M, then a key K is chosen at random and given to A. The adversary wins if she violates the Target Collision Resistance (TCR) of H, that is if she generates a message M' different from M that collides with M for the key K (i.e. such that  <span class="math">H_K(M) = H_K(M&#x27;)</span>  with  <span class="math">M \\neq M&#x27;</span> ).</p>

    <p class="text-gray-300">At EUROCRYPT 2000, Shoup [27] had proposed a simple construction for a UOWHF that hashes messages of arbitrary size, given a UOWHF that hashes messages of fixed size. It is a Merkle-Damgård-like mode of operation, but before every iteration, one of several possible masks is XORed to the chaining value. The number of masks is logarithmic in the length of the hashed message, and the order in which they are used is carefully chosen to maximize the security of the scheme. This is reminiscent of dithered hashing, except that here the dithering process does not hit the bandwidth available to actual data.</p>

    <p class="text-gray-300">We first describe briefly Shoup's construction, and then show how our attack can be applied against it. This way we prove that for this particular construction, Shoup's security bound is tight.</p>

    <h2 id="sec-16" class="text-2xl font-bold">5.1 Description</h2>

    <p class="text-gray-300">The construction has some similarities with Rivest's dithered hashing. It starts from a universal one way compression function F that is keyed by a key K,  <span class="math">F_K</span> :  <span class="math">\\{0,1\\}^m \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span> . This compression function is then iterated, as described below, to obtain a variable input length UOWHF  <span class="math">H_K^F</span> .</p>

    <p class="text-gray-300">A certain number of &quot;masks&quot; are needed, each one of which is a random n-bit string. Assuming that the maximal size of hashed messages is  <span class="math">2^k</span>  then k+1 masks  <span class="math">M_0, \\ldots, M_k</span>  are required. The key of the whole iterated function consists of K and of these masks. After each application of the compression function, a mask is XORed to the result. The order in which the masks are applied is defined by a specified sequence over the alphabet  <span class="math">\\mathcal{A} = \\{0, \\ldots, k\\}</span> . The scheduling sequence is  <span class="math">\\mathbf{z}[i] = \\nu_2(i)</span> , for  <span class="math">1 \\leq i \\leq 2^k</span> , where  <span class="math">\\nu_2(i)</span>  denotes the largest integer  <span class="math">\\nu</span>  such that  <span class="math">2^{\\nu}</span>  divides i. Let M be a message that can be split into r blocks  <span class="math">x_1, \\ldots, x_r</span>  and let  <span class="math">h_0</span>  be an arbitrary n-bit string. We define  <span class="math">h_i = F_K\\left(h_{i-1} \\oplus M_{\\nu_2(i)}, x_i\\right)</span> , and  <span class="math">H_K^F(M) = h_r</span> .</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">5.2 An Attack Matching the Security Bound</h4>

    <p class="text-gray-300">In [27], Shoup proves the following security result:</p>

    <p class="text-gray-300"><strong>Theorem 1 (Main result of [27]).</strong> If an adversary is able to break the target collision resistance of  <span class="math">H^F</span>  with probability  <span class="math">\\epsilon</span>  in time T, then one can construct an adversary that breaks the target collision resistance of F in time T, with probability  <span class="math">\\epsilon/2^k</span> .</p>

    <p class="text-gray-300">In this section we show that this bound is almost tight. First, we give an alternate definition of the dithering sequence z. We define:</p>

    <p class="text-gray-300"><span class="math">$u_i = \\begin{cases} 0 &amp; \\text{if } i = 1, \\\\ u_{i-1}.(i-1).u_{i-1} &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">As an example, we have  <span class="math">u_4 = 010201030102010</span> . It is clear that  <span class="math">|u_i| = 2^i - 1</span> , and it is easy to show that for all i,  <span class="math">u_i</span>  is a prefix of  <span class="math">\\mathbf{z}</span> . The dithering sequence is thus simply  <span class="math">u_k</span>  (a prefix of  <span class="math">\\mathbf{z}</span>  of size  <span class="math">2^k - 1</span>  is arguably enough).</p>

    <p class="text-gray-300">The most frequently-occurring factor of size  <span class="math">\\ell &lt; 2^k</span>  in  <span class="math">\\mathbf{z}</span>  is the prefix of size  <span class="math">\\ell</span>  of  <span class="math">\\mathbf{z}</span> . It is a prefix of  <span class="math">u_j</span>  with  <span class="math">j = \\lceil \\log_2{(\\ell+1)} \\rceil</span> , and  <span class="math">u_j</span>  itself occurs  <span class="math">2^{k-j}</span>  times in  <span class="math">\\mathbf{z} = u_k</span> . The probability for a random factor of  <span class="math">\\mathbf{z}</span>  of size  <span class="math">\\ell</span>  to be exactly this candidate is equal to the number of occurrences of this candidate divided by the number of  <span class="math">\\ell</span> -bit strings in  <span class="math">\\mathbf{z}</span> . Thus this probability is  <span class="math">\\frac{2^{k-j}}{2^k-\\ell}</span> . This can in turn be lower-bounded by:  <span class="math">2^{-j} \\geq \\frac{1}{2(\\ell+1)}</span> . Our attack can be applied against the TCR property of  <span class="math">H^F</span>  as described above: just choose at random a (long) message x. Once the key is chosen at random, build a collision tree using a prefix of  <span class="math">\\mathbf{z}</span>  of size  <span class="math">\\ell</span> , and continue as described in section 4. The cost of the attack is then:</p>

    <p class="text-gray-300"><span class="math">$T = 2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + 2(\\ell + 1) \\cdot 2^{n-k+1} + 2^{n-\\ell+1}.</span>$</p>

    <p class="text-gray-300">This attack breaks the target collision resistance with probability  <span class="math">\\mathcal{O}(1)</span> . Therefore, with Shoup's result, one can construct an adversary A against F with running time  <span class="math">\\mathcal{O}(T)</span>  and probability of success  <span class="math">\\mathcal{O}(1/2^k)</span> . Therefore, the adversary  <span class="math">\\mathcal{A}&#x27;</span>  which runs  <span class="math">\\mathcal{A}(2^k)</span>  times has a probability  <span class="math">\\mathcal{O}(1)</span>  of breaking the TCR property. When  <span class="math">n \\geq 3k</span> ,  <span class="math">T \\simeq (2k+3) \\cdot 2^{n-k+1}</span>  (with  <span class="math">\\ell = k-1</span> ), and thus the running time of the adversary is  <span class="math">\\mathcal{O}(2^k \\cdot T) = \\mathcal{O}(k \\cdot 2^n)</span> . If F is a random oracle, the best attack against F's TCR property runs in time  <span class="math">\\mathcal{O}(2^n)</span> , which means that there is only a factor k between Shoup's security proof and our attack.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.3 Further Improvement of the Attack</h3>

    <p class="text-gray-300">Our attack can be improved to obtain a gap  <span class="math">\\mathcal{O}(\\log k)</span>  between Shoup's security proof and our attack. To this end, we use the following trick. Instead of focusing on the most frequent word of size  <span class="math">\\ell</span> , we focus on the most frequent word of size  <span class="math">\\mathcal{O}(\\log_2(\\ell))</span>  for which it is easier to connect a collision tree to the original message, because it occurs more frequently.</p>

    <p class="text-gray-300">More precisely, let  <span class="math">\\omega_0</span>  be the (s+1)-letter prefix of  <span class="math">\\mathbf{z}</span> , where  <span class="math">s = \\lceil \\log_2(12\\ell \\cdot k) \\rceil</span> . First we produce a collision tree for every  <span class="math">\\ell</span> -symbol word  <span class="math">\\omega</span>  such that  <span class="math">\\omega \\| \\omega_0</span>  is a factor of  <span class="math">\\mathbf{z}</span> . Thus, for every such word  <span class="math">\\omega</span>  are associated a collision tree and the target  <span class="math">h_{\\omega}</span>  of the collision tree. Since we are free to choose the hash value labelling the leaves of a tree, we now use the set of all these targets as the leaves for a new smaller collision tree using the s first letters of  <span class="math">\\omega_0</span>  as a dithering. This way we herd all the previously constructed collision tree in a bigger aggregated tree. Let  <span class="math">h_T</span>  denote the target of the resulting collision tree. We continue the attack nearly as usual. We find a block  <span class="math">B_0</span>  such that  <span class="math">F_K\\left(h_T \\oplus M_{\\omega_0[s+1]}, B_0\\right) = h_{i_0}</span>  for some  <span class="math">i_0</span> , with  <span class="math">\\mathbf{z}[i_0 - s - 1] \\dots \\mathbf{z}[i_0] = \\omega_0</span>  and</p>

    <p class="text-gray-300"><span class="math">i_0 \\geq \\ell + s + 1</span> . This fixes a word  <span class="math">\\omega_1 = \\mathbf{z}[i_0 - s - \\ell - 3] \\dots \\mathbf{z}[i_0 - s - 2]</span>  and the particular subtree generated with  <span class="math">\\omega_1</span>  as dithering symbols. Finally we generate an arbitrary prefix P of size  <span class="math">i_0 - s - \\ell - 4</span>  whose hash is one of the leaf of the  <span class="math">\\omega_1</span>  subtree. Let T be the chain of  <span class="math">\\ell + s</span>  blocks traversing successively the  <span class="math">\\omega_1</span>  subtree and then the small  <span class="math">\\omega_0</span>  collision tree, from h to  <span class="math">h_T</span> . The second preimage is therefore  <span class="math">P||T||B_0||x_{i_0+1}||\\dots||x_{2^k}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">c_{\\ell}</span>  denote the number of  <span class="math">\\ell</span> -letter words w such  <span class="math">\\omega \\| \\omega_0</span>  is a factor of  <span class="math">\\mathbf{z}</span> . Note that the previous attack is correct if and only if the number of leaves of the  <span class="math">\\omega_0</span>  collision tree is greater than  <span class="math">c_{\\ell}</span>  the number of collision graph we have to herd. It can be shown that for the particular value chosen for s,  <span class="math">2^s \\geq c_{\\ell}</span> , thus the attack is correct and the cost of this attack is roughly:</p>

    <p class="text-gray-300"><span class="math">$c_{\\ell} \\cdot 2^{\\frac{n}{2} + \\frac{\\ell}{2} + 2} + 2^{\\frac{n}{2} + \\frac{\\log_2(\\ell)}{2} + 2} + 2(1 + \\log_2 \\ell) \\cdot 2^{n-k+1} + 2^{n-\\ell+1}.</span>$</p>

    <p class="text-gray-300">Compared to the previous attack, we now have to build  <span class="math">c_{\\ell}</span>  collision trees of size  <span class="math">\\ell</span>  instead of one, but it also becomes easier to connect our structure to the original message. Note that the term  <span class="math">2^{n/2 + \\log_2(\\ell)/2 + 2}</span>  is always negligible before  <span class="math">c_{\\ell} \\cdot 2^{n/2 + \\ell/2 + 2}</span> .</p>

    <p class="text-gray-300">If  <span class="math">n \\gg 3k</span> , when  <span class="math">\\ell = k</span> , the term  <span class="math">c_{\\ell} \\cdot 2^{n/2 + \\ell/2 + 2} = \\mathcal{O}\\left(2^{n/2 + k/2 + 2\\log_2 k}\\right)</span>  is smaller than  <span class="math">2^{n-k+1}</span>  and the cost of the attack is  <span class="math">\\mathcal{O}\\left(\\log k \\cdot 2^{n-k}\\right)</span> . Therefore, with the same proof as in the previous subsection, we can show that there is a factor  <span class="math">\\mathcal{O}\\left(\\log k\\right)</span>  between Shoup's security proof and our attack. Note that, depending on the parameters, this improved version of the attack may be worse than the basic version.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Parameters</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">n</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Basic</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Improved</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{112}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{115}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{208}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{206}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">5.4 Comparing the Shoup and Rivest Dithering Techniques</h4>

    <p class="text-gray-300">An intriguing connection between Shoup's and Rivest's ideas shows up as soon as we notice that the scheduling sequence  <span class="math">\\mathbf{z}</span>  chosen by Shoup is abelian square-free. In fact, one year after Shoup's construction was published, Mironov [22] proved that an even stronger notion of repetition-freeness was necessary:  <span class="math">\\mathbf{z}</span>  is, and has to be, even-free. A word is even-free if all of its non-empty factors contain at least one letter an odd number of times. Note that all even-free words are abelian square-free. We believe that the role these non-trivial sequences play in iterated constructions in cryptography (such as hashing) has yet to be completely understood.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Allouche, J.P.: Sur la complexité des suites infinies. Bull. Belg. Math. Soc. 1 (1994) 133-143</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Andreeva, E., Neven, G., Preneel, B., Shrimpton, T.: Seven-Property-Preserving Iterated Hashing: ROX. Cryptology ePrint Archive, Report 2007/176, to appear in ASIACRYPT'07 (2007)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Biham, E., Chen, R., Joux, A., Carribault, P., Lemuet, C., Jalby, W.: Collisions of SHA-0 and Reduced SHA-1. [6] 36–57</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Brassard, G., ed.: CRYPTO '89, Santa Barbara, California, USA, August0-24, 1989, Proceedings. In Brassard, G., ed.: CRYPTO. Volume 435 of Lecture Notes in Computer Science., Springer (1990)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Cobham, A.: Uniform tag seqences. Mathematical Systems Theory 6(3) (1972) 164–192</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Cramer, R., ed.: Advances in Cryptology EUROCRYPT 2005, 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Aarhus, Denmark, May 22-26, 2005, Proceedings. In Cramer, R., ed.: EUROCRYPT'05. Volume 3494 of Lecture Notes in Computer Science., Springer (2005)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Damgård, I.: A Design Principle for Hash Functions. [4] 416–427</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Dean, R.D.: Formal Aspects of Mobile Code Security. PhD thesis, Princeton University (January 1999)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Ehrenfeucht, A., Lee, K.P., Rozenberg, G.: Subword Complexities of Various Classes of Deterministic Developmental Languages without Interactions. Theor. Comput. Sci. 1(1) (1975) 59–75</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Feller, W.: 12. In: An Introduction to Probability Theory and Its Applications. Volume 1. John Wiley &amp; Sons (1971)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Gheorghiciuc, I.: The Subword Complexity of Finite and Infinite Binary Words. PhD thesis, University of Pennsylvania (September 2004)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Janson, S., Lonardi, S., Szpankowski, W.: On average sequence complexity. Theor. Comput. Sci. 326(1-3) (2004) 213–227</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Joux, A.: Multicollisions in Iterated Hash Functions. Application to Cascaded Constructions. In Franklin, M.K., ed.: CRYPTO'04. Volume 3152 of Lecture Notes in Computer Science., Springer (2004) 306–316</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Joux, A., Peyrin, T.: Hash Functions and the (Amplified) Boomerang Attack. In Menezes, A., ed.: CRYPTO. Volume 4622 of Lecture Notes in Computer Science., Springer (2007) 244–263</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Kelsey, J., Kohno, T.: Herding Hash Functions and the Nostradamus Attack. In Vaudenay, S., ed.: EUROCRYPT'06. Volume 4004 of Lecture Notes in Computer Science., Springer (2006) 183–200</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Kelsey, J., Schneier, B.: Second Preimages on n-Bit Hash Functions for Much Less than 2n Work. [6] 474–490</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Keränen, V.: Abelian Squares are Avoidable on 4 Letters. In Kuich, W., ed.: ICALP. Volume 623 of Lecture Notes in Computer Science., Springer (1992) 41–52</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Keränen, V.: On abelian square-free DT0L-languages over 4 letters. In Harju, T., ed.: WORDS'03. Volume 27., TUCS General Publication (2003) 95–109</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Klima, V.: Tunnels in Hash Functions: MD5 Collisions Within a Minute. Cryptology ePrint Archive, Report 2006/105 (2006) http://eprint.iacr.org/.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Menezes, A., van Oorschot, P., Vanstone, S.: Handbook of Applied Cryptography</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Merkle, R.C.: One Way Hash Functions and DES. [4] 428–446</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Mironov, I.: Hash Functions: From Merkle-Damgård to Shoup. In Pfitzmann, B., ed.: EUROCRYPT. Volume 2045 of Lecture Notes in Computer Science., Springer (2001) 166–181</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Orr Dunkelman, E.B.: A Framework for Iterative Hash Functions HAIFA. Presented at the second NIST hash workshop (August 24–25 2006)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pansiot, J.J.: Complexité des facteurs des mots infinis engendrés par morphismes itérés. In Paredaens, J., ed.: 11th ICALP, Antwerpen. Volume 172 of LNCS., Springer (july 1984) 380–389</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Rivest, R.L.: Abelian Square-Free Dithering for Iterated Hash Functions. Presented at ECrypt Hash Function Workshop, June 21, 2005, Cracow, and at the Cryptographic Hash workshop, November 1, 2005, Gaithersburg, Maryland (August 2005)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Rogaway, P., Shrimpton, T.: Cryptographic Hash-Function Basics: Definitions, Implications, and Separations for Preimage Resistance, Second-Preimage Resistance, and Collision Resistance. In Roy, B.K., Meier, W., eds.: FSE. Volume 3017 of Lecture Notes in Computer Science., Springer (2004) 371–388</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Shoup, V.: A Composition Theorem for Universal One-Way Hash Functions. In: EUROCRYPT'00. (2000) 445–452</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Shoup, V., ed.: Advances in Cryptology CRYPTO 2005: 25th Annual International Cryptology Conference, Santa Barbara, California, USA, August 14-18, 2005, Proceedings. In Shoup, V., ed.: CRYPTO. Volume 3621 of Lecture Notes in Computer Science., Springer (2005)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wang, X., Lai, X., Feng, D., Chen, H., Yu, X.: Cryptanalysis of the Hash Functions MD4 and RIPEMD. [6] 1–18</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wang, X., Yin, Y.L., Yu, H.: Finding Collisions in the Full SHA-1. [28] 17–36</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wang, X., Yu, H.: How to Break MD5 and Other Hash Functions. [6] 19–35</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Wang, X., Yu, H., Yin, Y.L.: Efficient Collision Search Attacks on SHA-0. [28] 1–16</li>
    </ol></li>
    </ul>

    <h2 id="sec-21" class="text-2xl font-bold">A There are Abelian Square-Free Sequences of Exponential Complexity</h2>

    <p class="text-gray-300">Another way to repair DMD-CP would be to find an infinite abelian square-free sequence of exponential complexity. This is indeed possible, although we do not know how to do it without slightly enlarging the alphabet.</p>

    <p class="text-gray-300">We start with the abelian square-free Keränen sequence k over {a, b, c, d}, and with another sequence u over {0, 1} that has an exponential complexity. Such a sequence can be built for example by concatenating the binary encoding of all the consecutive integers. Then we can create a sequence ˜z over the union alphabet A = {a, b, c, d, 0, 1} by interleaving k and u : z˜ = k[1].u[1].k[2].u[2]. . . . . The resulting shuffled sequence inherits both properties: it is still abelian square-free, and has a complexity of order Ω 2 ℓ/2 .</p>

    <p class="text-gray-300">Even with this exponentially complex dithering sequence, our attack is still more efficient than brute-force in finding second preimages. Although it may be possible to find square-free sequences with even higher complexity, it is probably very difficult to achieve optimal protection, and the generation of the dithering sequences is likely to become more and more complex.</p>

    <h2 id="sec-22" class="text-2xl font-bold">B Proofs of Sequence-Complexity Related Results</h2>

    <p class="text-gray-300">Sequences Generated by Morphisms. We say that a function τ : A&lt;sup&gt;∗&lt;/sup&gt; → A&lt;sup&gt;∗&lt;/sup&gt; is a morphism if for all words x and y, τ (x.y) = τ (x).τ (y). A morphism is then entirely determined by the images of the individuals letters. A morphism is said to be r-uniform (with r ∈ N) if for all word x, |τ (x)| = r · |x|. If, for a given letter α ∈ A, we have τ (α) = α.x for some word x, then τ is non-erasing for α. Given a morphism τ and an initialization letter α, let u&lt;sup&gt;n&lt;/sup&gt; denote the n-th iterate of τ over α: u&lt;sup&gt;n&lt;/sup&gt; = τ n (α). If τ is r-uniform (with r ≥ 2) and non-erasing for α, then u&lt;sup&gt;n&lt;/sup&gt; is a strict prefix of un+1, for all n ∈ N. Let τ∞(α) denote the limit of this sequence : it is the only fixed point of τ that begins with the letter α. Such infinite sequences are called uniform tag sequences [5] or r-automatic sequences [1].</p>

    <p class="text-gray-300">Because they have a very regular structure, there is a spectacular result [5] regarding the complexity of infinite sequences generated by uniform morphisms:</p>

    <p class="text-gray-300">Theorem 2 (Cobham, 1972). Let z be an infinite sequence generated by an r-uniform morphism, and assume that the alphabet size A is constant. Then z has linear complexity:</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{z}}(\\ell) \\leq r \\cdot |\\mathcal{A}|^2 \\cdot \\ell.</span>$</p>

    <p class="text-gray-300">It is worth mentioning that similar results exist in the case of sequences generated by non-uniform morphisms [24, 9], although the upper bound can be quadratic.</p>

    <p class="text-gray-300">Proofs. Since the Keränen sequence is 85-uniform [17, 18, 25], the result of theorem 2 gives: F actk(ℓ) ≤ 1360· ℓ. This upper-bound is relatively rough, and for particular values of ℓ, it is possible to obtain a much better approximation (which is tight):</p>

    <p class="text-gray-300">Lemma 1 (of section 4.1). Let z be an infinite sequence over the alphabet A generated by a r-uniform morphism τ . For all ℓ, 1 ≤ ℓ ≤ r, we have :</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{z}}(\\ell) \\leq \\ell \\cdot \\Big(Fact_{\\mathbf{z}}(2) - |\\mathcal{A}|\\Big) + \\Big[(r+1) \\cdot |\\mathcal{A}| - Fact_{\\mathbf{z}}(2)\\Big].</span>$</p>

    <p class="text-gray-300">Proof. If ℓ ≤ r, then any factor of z of size ℓ falls in one of these two classes (possibly both, but this does not matter, as we are looking for an upper bound) :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Either it is a factor of τ (α) for some letter α ∈ A. There are no more than |A|·(r−ℓ+1) such factors.</li>
      <li>Or it is a factor of τ (α).τ (β), for two letters α, β ∈ A (and is not a factor of either τ (α) or τ (β)). For any given pair (α, β), there can only be ℓ−1 such factors. Moreover, αβ must be a factor of size 2 of z.</li>
    </ul>

    <p class="text-gray-300">So
<span class="math">$Fact_{\\mathbf{z}}(\\ell) \\leq |A| \\cdot (r - \\ell + 1) + Fact_{\\mathbf{z}}(2) \\cdot (\\ell - 1)</span>$
.</p>

    <p class="text-gray-300">The result of this lemma can be specialized for the Keränen sequence, to obtain the result announced in section 4.1. In this case, we have r = 85, A  = 4 and F actk(2) = 12 (all non-repeating pairs of letters).</p>

    <p class="text-gray-300">Lemma 2 (of section 4.1). Let z be an arbitrary sequence over A, and let d denote the sequence obtained by diluting z with a counter over i bits. Then for every ℓ not equal to 1 modulo 2 i , we have:</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{d}}(\\ell) = (2^{i} - (\\ell \\mod 2^{i}) + 1) \\cdot Fact_{z}(\\lceil \\ell \\cdot 2^{-i} \\rceil) + ((\\ell \\mod 2^{i}) - 1) \\cdot Fact_{\\mathbf{z}}(\\lceil (\\ell - 1) \\cdot 2^{-i} \\rceil + 1)</span>$</p>

    <p class="text-gray-300">Proof. The counter over i bits splits the diluted sequence c into chunks of size 2 i (a new chunk begins when the counter reaches 0). In a chunk, the letter from z does not change, and only the counter varies. To obtain the number of factors of size ℓ, let us slide a window of size ℓ over d. This window overlaps at least ℓ · 2 −i chunks (when the beginning of the window is aligned at the beginning of a chunk), and at most (l − 1) · 2 −i +1 chunks (when the window begins just before a chunk boundary). These two numbers are equal if and only if ℓ ≡ 1 mod 2&lt;sup&gt;i&lt;/sup&gt; . When this case is avoided, then these two numbers are consecutive integers.</p>

    <p class="text-gray-300">This means that by sliding this window of size ℓ over d we will only observe factors of z of size ℓ · 2 −i and ℓ · 2 −i + 1. Given a factor of size ℓ · 2 −i of z, there are 2 &lt;sup&gt;i&lt;/sup&gt; − (ℓ mod 2&lt;sup&gt;i&lt;/sup&gt; ) + 1 positions of a window of size ℓ that allow us to observe this factor with different values of the counter (it essentially amounts to moving the window without crossing a chunk boundary).</p>

    <p class="text-gray-300">Similarly, there are  <span class="math">(\\ell \\mod 2^i) - 1</span>  positions of the window that contain a given factor of  <span class="math">\\mathbf{z}</span>  of size  <span class="math">\\lceil \\ell \\cdot 2^{-i} \\rceil + 1</span> .</p>

    <p class="text-gray-300">By taking  <span class="math">2 \\le \\ell \\le 2^i</span> , we have that  <span class="math">\\lceil \\ell \\cdot 2^{-i} \\rceil = 1</span> . Therefore, only the number of factors of size 1 and 2 of <strong>z</strong> come into play. The formula can be further simplified into:</p>

    <p class="text-gray-300"><span class="math">$Fact_{\\mathbf{d}}(\\ell) = \\ell \\cdot \\left( Fact_{\\mathbf{z}}(2) - Fact_{\\mathbf{z}}(1) \\right) + (2^{i} + 1) \\cdot Fact_{\\mathbf{z}}(1) - Fact_{2}(\\mathbf{z}).</span>$</p>

    <p class="text-gray-300">For the Keränen sequence with i = 13, this gives:  <span class="math">Fact_{\\mathbf{d}}(\\ell) = 8 \\cdot \\ell + 32760</span> .</p>

    <h2 id="sec-23" class="text-2xl font-bold">C Second Preimage Resistance of Iterated Hash Functions</h2>

    <p class="text-gray-300">Until now we have presented generic second-preimage attacks against particular dithered Merkle-Damgård constructions. In this section, we show that there exists a dithered Merkle-Damgård construction with optimal security against second preimage attacks. For this purpose, we study the HAsh Iterative FrAmework (HAIFA) introduced in [23]. It is a Merkle-Damgård construction where a counter is added to the input of the compression function. It can be considered as a dithered Merkle-Damgård construction over an alphabet of  <span class="math">2^k</span>  letters where the role of the dithering is played by the counter. The authors of [23] explain why their proposition resists to all known attacks and claim an upper bound of  <span class="math">2^n</span>  on the complexity of the best possible generic second-preimage attack. In this section we give a proof of their claim, showing that this construction meets the optimal security level against second preimage attacks.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">C.1 Description of Haifa</h4>

    <p class="text-gray-300">We first briefly describe HAIFA. The HAsh Iterative FrAmework  <span class="math">H^F: \\{0,1\\}^* \\to \\{0,1\\}^n</span>  is built by iterating a compression function  <span class="math">F: \\{0,1\\}^m \\times \\{0,1\\}^n \\times \\{0,1\\}^{64} \\to \\{0,1\\}^n</span> . The hash process works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Pad and split a message M into r blocks  <span class="math">x_1, \\ldots, x_r</span>  of m bits each.</li>
      <li>Set  <span class="math">h_0</span>  to the initialization value IV.</li>
      <li>For each message block i compute  <span class="math">h_i = F(h_{i-1}, x_i, i)</span> .</li>
      <li>Output  <span class="math">H^F(M) = h_r</span> .</li>
    </ul>

    <p class="text-gray-300">The padding is done by appending a single '1' bit followed by as many '0' bit as needed to complete a m-bit block.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">C.2 Security Result</h4>

    <p class="text-gray-300">We model the compression function by a random oracle for two reasons. First we want to take into account only generic attacks, the adversary should not be able to exploit a particular weakness or property of the compression function. Second, for 1-block messages, the iterated hash function is reduced to the compression function, therefore if the compression function is not a good hash function, the iterated hash function cannot be a good compression function either.</p>

    <p class="text-gray-300">The kind of security results that we obtain by reasoning about a mode of operation in the random oracle model is inherently different from these obtained by the reductionist approach of [26]. Andreeva, Neven, Preneel and Shrimpton [2] proved that HAIFA does not preserve the second preimage resistance of the compression function (using a special compression function that admits the IV as a fixpoint). Here, we prove that HAIFA is second-preimage resistant when instancied with a &quot;reasonable&quot; compression function. These two results are not contradictory though. Note that the same security result can be stated (losing only a small constant factor) in the Ideal Cipher Model, by considering that the hash function implements the Davies-Meyer mode of operation with independent random permutations.</p>

    <p class="text-gray-300">Let us consider an unbounded adversary  <span class="math">\\mathcal{A}</span>  that, given a message M, tries to find a message M' such that  <span class="math">H^F(M) = H^F(M&#x27;)</span> . Let Q denote the number of queries  <span class="math">\\mathcal{A}</span>  sends to the F oracle. We enforce  <span class="math">\\mathcal{A}</span>  to always return a message M', even if it is not a second preimage, and to evaluate  <span class="math">H^F(M)</span>  and  <span class="math">H^F(M&#x27;)</span> , by issuing the corresponding queries to the random oracle.</p>

    <p class="text-gray-300"><strong>Theorem 3 (Security of</strong> HAIFA). Let  <span class="math">H^F</span>  be an iterated hash function following the scheme of HAIFA and A a second preimage adversary against  <span class="math">H^F</span>  which makes at most Q queries to F. Then:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[H^F(M) = H^F(M&#x27;) \\colon \\mathcal{A} \\text{ returns } M&#x27;\\right] \\leq \\frac{2Q}{2^n}.</span>$</p>

    <p class="text-gray-300">This essentially comes from the fact that when the adversary submits a query to F, she has to specify the value  <span class="math">i_0</span>  of the counter. Indeed, the adversary wins if and only if she can find a message  <span class="math">\\tilde{M}</span>  such that  <span class="math">H^F(\\tilde{M}) = h_i</span>  and  <span class="math">|\\tilde{M}| = i</span>  or  <span class="math">H^F(\\tilde{M}) = h_r</span>  (using previously introduced notations). This implies that for every query where the value of the counter is  <span class="math">i_0</span> , she can win only if the oracle outputs  <span class="math">h_{i_0}</span>  or  <span class="math">h_r</span> . The detailled proof follows.</p>

    <p class="text-gray-300">When the classical Merkle-Damgård construction achieved a proven bound&lt;sup&gt;6&lt;/sup&gt;  <span class="math">Q \\cdot |M|/2^{n-1}</span>  (which can be established with a very similar proof as the one used for the previous theorem), HAIFA reaches the same security level as a random oracle, which is the best security that we can hope.</p>

    <p class="text-gray-300">Proof (of theorem 3).</p>

    <p class="text-gray-300">We simulate the execution of the adversary  <span class="math">\\mathcal{A}</span> , and bookmark the queries sent by A to the random oracles: it is a set S of tuples (x, m, i, y), with  <span class="math">y = F_i(x, m)</span> . We suppose that  <span class="math">\\mathcal{A}</span>  evaluates H(M), so  <span class="math">\\mathcal{A}</span>  sends the corresponding queries to the oracles at some point. Let us note these queries  <span class="math">(h_i, m_i, i, h_{i+1})_{1 \\leq i \\leq |M|}</span> . In particular,  <span class="math">H(M) = h_{|M|+1}</span> .</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt; Remark that it implies that the attack of Kelsey and Schneier [16] is optimal against classical Merkle-Damgård.</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{A}</span>  succeeds in finding a second preimage, then  <span class="math">\\mathcal{A}</span>  has produced a collision in particular. It is well known that in the presence of the so-called Merkle-Damgård <em>strengthening</em>, this implies a collision on the compression function [7, 21]. However, this collision is <em>constrained</em>: the resulting target hash value is one of the  <span class="math">h_i</span> . Finding such a collision is harder than finding an arbitrary collision.</p>

    <p class="text-gray-300">Suppose A wins. We distinguish two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">|M| \\neq |M&#x27;|</span> , then the values of the counter entering the compression function in its last invocation are different. Therefore,  <span class="math">\\mathcal{A}</span>  has found a second preimage on F. Each query has a probability  <span class="math">2^{-n}</span>  to yield this preimage. Since there are Q queries, the probability that  <span class="math">\\mathcal{A}</span>  wins this way is upper-bounded by  <span class="math">Q/2^n</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Otherwise, |M| = |M'|. Let us formalize our notion of constrained collision. We consider the following event, that we call <strong>E</strong>. We say that <strong>E</strong> is realized if and only if there is in S a query  <span class="math">(x, m, i_0, y)</span>  such that  <span class="math">y = h_{i_0+1}</span> , for a given value of  <span class="math">i_0</span>  (recall that  <span class="math">h_{i_0}</span>  is the  <span class="math">i_0</span> -th chaining value obtained in the process of hashing M), and such that  <span class="math">(x, m) \\neq (h_{i_0}, m_{i_0})</span> . Intuitively, <strong>E</strong> is realized as soon as A submits a query the answer of which gives a second preimage of one of the  <span class="math">h_i</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The key of the reasoning is that  <span class="math">\\mathbf{E}</span>  is realized whenever  <span class="math">\\mathcal{A}</span>  wins. Thanks to the result of Merkle-Damgård, we know that there is a collision on the compression function where one of the colliding hash value is one of the  <span class="math">h_i</span> . However, this is not sufficient to say that  <span class="math">\\mathbf{E}</span>  is realized, because we would need to know that the values of the counter are actually the same. We now prove that it is indeed the case.</p>

    <p class="text-gray-300"><strong>Lemma 3</strong> (Collision-Resistance extended to Haifa). Let  <span class="math">H^F</span>  be a hash function implementing the mode of operation of Haifa. Let F be the compression function. Then, if  <span class="math">H^F(M) = H^F(M&#x27;)</span>  with  <span class="math">M \\neq M&#x27;</span>  and |M| = |M'|, then there is a collision on F, with the same value of the counter (this means that  <span class="math">\\mathbf{E}</span>  is realized).</p>

    <p class="text-gray-300"><em>Proof.</em> let us note  <span class="math">M = x_1, \\ldots, x_r, M&#x27; = x&#x27;_1, \\ldots, x&#x27;_r, h_0 = h&#x27;_0 = IV, h_i = F(h_{i-1}, i, x_i)</span>  and  <span class="math">h&#x27;_i = F(h&#x27;_{i-1}, i, x&#x27;_i)</span> .</p>

    <p class="text-gray-300">Since  <span class="math">h_r = h&#x27;_r</span> , either there is a collision for F (with counter value r), or  <span class="math">(x_r, h_{r-1}) = (x&#x27;_r, h&#x27;_{r-1})</span> . In the latter case, either there is a collision for F (with counter value r-1) or  <span class="math">(x_{r-1}, h_{r-2}) = (x&#x27;_{r-1}, h&#x27;_{r-2})</span> . This argument repeats. Since |M| = |M'|, then either there is a collision for F at some point (with the same counter value), or  <span class="math">x_i = x&#x27;_i</span> , for all  <span class="math">i, 1 \\le i \\le r</span> . In the latter case, M = M', which is impossible. This completes the proof of the lemma.</p>

    <p class="text-gray-300">Note that <strong>E</strong> being realized does not imply that  <span class="math">\\mathcal{A}</span>  has won, because of a corner case: if  <span class="math">\\mathcal{A}</span>  finds a preimage of H(M) for F but with a message block that does not include the padding, then  <span class="math">\\mathcal{A}</span>  cannot automatically produce a second preimage. Now, let us show the following inequality:</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{P}\\big[\\mathbf{E}\\big] \\le \\frac{Q}{2^n}</span>$</p>

    <p class="text-gray-300">Everytime  <span class="math">\\mathcal{A}</span>  submits a query to the oracle, the probability that  <span class="math">\\mathbf{E}</span>  is triggered by this particular query is upper-bounded by  <span class="math">2^{-n}</span> . When submitting a query (and note</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">that&lt;br&gt;i0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">is part of the query), a random value is chosen by the random oracle, and</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">E</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">is realized only if this value is</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hi0+1.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Since A sends Q queries to the oracle during its execution, we obtain the announced bound. ⊓⊔</p>

`;
---

<BaseLayout title="Second Preimage Attacks on Dithered Hash Functions (2007/395)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2007 &middot; eprint 2007/395
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="second-preimage-attacks-on-dithered-hash-functions-2007" />
  </article>
</BaseLayout>
