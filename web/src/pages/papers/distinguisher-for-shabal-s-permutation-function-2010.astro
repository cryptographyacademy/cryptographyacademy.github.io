---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2010/398';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Distinguisher for Shabal&#x27;s Permutation Function';
const AUTHORS_HTML = 'Peter Novotney';

const CONTENT = `    <p class="text-gray-300">Peter Novotney peternov@microsoft.com</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In this note we consider the Shabal permutation function <span class="math">\\mathcal{P}</span> as a block cipher with input <span class="math">A_{p}</span>,<span class="math">B_{p}</span> and key <span class="math">C</span>,<span class="math">M</span> and describe a distinguisher with a data complexity of <span class="math">2^{23}</span> random inputs with a given difference. If the attacker can control one chosen bit of <span class="math">B_{p}</span>, only <span class="math">2^{21}</span> inputs with a given difference are required on average. This distinguisher does not appear to lead directly to an attack on the full Shabal construction.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The Shabal hash function <em>[4]</em> is a second round candidate in NIST’s SHA-3 hash function competition. Shabal uses a iterated hash mode built around a keyed permutation function <span class="math">\\mathcal{P}</span>, which takes as input <span class="math">A_{p}</span>,<span class="math">B_{p}</span> and takes as a key <span class="math">C</span>,<span class="math">M</span>. In this note we will demonstrate that given an unknown key <span class="math">C</span>,<span class="math">M</span>, we can distinguish the permutation function <span class="math">\\mathcal{P}</span> with known input differences with respect to XOR on <span class="math">A_{p}</span> and <span class="math">B_{p}</span>. Others have noted various distinguishers in the Shabal permutation function as well: In <em>[2]</em> the non-ideal behavior of Shabal’s permutation function using a cube tester is described. Fixed points and key collisions of the permutation are described in <em>[6]</em>. A related key distinguisher is given in <em>[3]</em>, and <em>[1]</em> presents a distinguisher based on rotational differences. In <em>[5]</em> the authors of Shabal respond to some of these papers. The distinguisher in this note seems to add its own unique features to those referenced above.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 The Shabal Permutation Function</h2>

    <p class="text-gray-300">We use a slightly different description of the Shabal permutation function than given in <em>[4]</em>. The description below retains intermediate values, allowing them to be uniquely referenced in the differential description in section 3. Our description assumes the default tunable parameters <span class="math">(p,r)=(3,12)</span> as defined in <em>[4]</em>.</p>

    <p class="text-gray-300">The Shabal permutation function takes 4 inputs <span class="math">A_{p}</span>, <span class="math">B_{p}</span>, <span class="math">C</span>, and <span class="math">M</span>, and gives as output <span class="math">A_{c}</span> and <span class="math">B_{c}</span>. We will consider <span class="math">A_{p}</span> and <span class="math">B_{p}</span> as the plaintext and <span class="math">M</span> and <span class="math">C</span> as the key. <span class="math">A_{p}</span> contains 12 words and <span class="math">B_{p}</span>, <span class="math">C</span> and <span class="math">M</span> each contain 16 words, where words are 32 bits. All additions and multiplications are mod <span class="math">2^{32}</span>. <span class="math">\\mathcal{P}</span> is given as:</p>

    <p class="text-gray-300">First we initialize the intermediate arrays with the input values:</p>

    <p class="text-gray-300"><span class="math">i\\rightarrow 0\\dots 11</span> <span class="math">A[i]:=A_{p}[i]</span> <span class="math">i\\rightarrow 0\\dots 15</span> <span class="math">B[i]:=B_{p}[i]\\lll 17</span></p>

    <p class="text-gray-300">Main computation of the permutation:</p>

    <p class="text-gray-300"><span class="math">i\\rightarrow 0\\dots 47</span> <span class="math">a_{i}:=5(A[11+i]\\lll 15)\\oplus A[i]</span> <span class="math">k_{i}:=3(a_{i}\\oplus C[8-i\\bmod 16])\\oplus M[i\\bmod 16]</span> <span class="math">b_{i}:=B[13+i]\\oplus(B[9+i]\\wedge\\overline{B[6+i]})</span> <span class="math">f_{i}:=k_{i}\\oplus b_{i}</span> <span class="math">A[12+i]:=f_{i}</span> <span class="math">B[16+i]:=\\overline{f_{i}}\\oplus(B[i]\\lll 1)</span></p>

    <p class="text-gray-300">Perform the output whitening on <span class="math">A</span> and copy result to output buffers:</p>

    <p class="text-gray-300"><span class="math">i\\rightarrow 0\\dots 11</span> <span class="math">A_{c}[i]:=A[i+48]+C[i+3]+C[i+15]+C[i+27]</span> <span class="math">i\\rightarrow 0\\dots 15</span> <span class="math">B_{c}[i]:=B[i+48]</span></p>

    <h2 id="sec-5" class="text-2xl font-bold">3 The Differential</h2>

    <p class="text-gray-300">The differential we analyze has a one bit difference in both <span class="math">A_{p}</span> and <span class="math">B_{p}</span> with respect to XOR and is given below:</p>

    <p class="text-gray-300"><span class="math">\\Delta A_{p}[10]</span> <span class="math">=</span> <span class="math">0{\\tt x80000000h}</span> <span class="math">\\Delta B_{p}[7]</span> <span class="math">=</span> <span class="math">0{\\tt x00002000h}</span></p>

    <p class="text-gray-300">These differences are chosen such that they cancel each other out multiple times with high probability and remain unaffected as possible by the multiplication mod<span class="math">2^{32}</span>, making it to round 26 of the permutation with a 1-bit difference with probability 1/8.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3.1 Following the Differential to Round 26</h3>

    <p class="text-gray-300">After the initial 17 bit rotations of the <span class="math">B</span> values our differential is of the form</p>

    <p class="text-gray-300"><span class="math">\\Delta A[10]</span> <span class="math">=</span> <span class="math">0{\\tt x80000000h}</span> <span class="math">\\Delta B[7]</span> <span class="math">=</span> <span class="math">0{\\tt x40000000h}</span></p>

    <p class="text-gray-300">From here we enter the main section of the permutation function. There are 48 total rounds counting from 0, so <span class="math">i=0...47</span>. The following rounds are those that involve the words with differences in <span class="math">A</span> or <span class="math">B</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round 1:  <span class="math">b_{1} = B[14] \\oplus (B[10] \\wedge \\overline{B[7]})</span> , so  <span class="math">\\Delta b_{1} = 0</span>  when  <span class="math">B[10] \\wedge \\Delta B[7] = 0</span>  which occurs with probability  <span class="math">1/2</span> . Note that we can set one bit in  <span class="math">B_{p}[10]</span>  appropriately so this condition is always met.</li>

      <li>Round 7:  <span class="math">B[23] \\coloneqq \\overline{f_7} \\oplus (B[7] \\ll 1)</span>  so  <span class="math">\\Delta B[23] = 0 \\times 800000000 \\mathrm{h}</span></li>

      <li>Round 10: we have  <span class="math">a_{10} \\coloneqq 5(A[9] \\ll 15) \\oplus A[10]</span> , so  <span class="math">\\Delta a_{10} = 0 \\times 800000000 \\mathrm{h}</span> . In the  <span class="math">k_{10}</span>  step we multiple by three, but since the difference is in the highest order bit we have  <span class="math">\\Delta k_{10} = 0 \\times 800000000 \\mathrm{h}</span> .  <span class="math">b_{10} \\coloneqq B[23] \\oplus (B[19] \\wedge \\overline{B[16]})</span>  so  <span class="math">\\Delta b_{10} = 0 \\times 800000000 \\mathrm{h}</span>  and therefore the difference cancels at  <span class="math">f_{10} \\coloneqq k_{10} \\oplus b_{10}</span> .</li>

      <li>Round 14:  <span class="math">b_{14} \\coloneqq B[27] \\oplus (B[23] \\wedge \\overline{B[20]})</span>  where  <span class="math">\\Delta B[23] = 0 \\times 800000000 \\mathrm{h}</span> , so if  <span class="math">\\Delta B[23] \\wedge \\overline{B[20]} = 0</span>  the difference cancels and we are left with  <span class="math">\\Delta b_{14} = 0</span> . This occurs with probability  <span class="math">1/2</span> .</li>

      <li>Round 17:  <span class="math">b_{17} \\coloneqq B[30] \\oplus (B[26] \\wedge \\overline{B[23]})</span>  and again  <span class="math">\\Delta B[23] = 0 \\times 800000000 \\mathrm{h}</span>  so if  <span class="math">B[26] \\wedge \\Delta B[20] = 0</span>  the difference cancels out and we have  <span class="math">\\Delta b_{17} = 0</span> . This occurs with probability  <span class="math">1/2</span> .</li>

      <li>Round 23:  <span class="math">B[39] \\coloneqq \\overline{f_{23}} \\oplus (B[23] \\ll 1) = 0 \\times 00000001 \\mathrm{h}</span> .</li>

      <li>Round 26:  <span class="math">b_{26} \\coloneqq B[39] \\oplus (B[35] \\wedge \\overline{B[32]})</span>  and we end up with  <span class="math">\\Delta A[38] = 0 \\times 00000001 \\mathrm{h}</span>  and  <span class="math">\\Delta B[42] = 0 \\times 00000001 \\mathrm{h}</span> .</li>

    </ul>

    <p class="text-gray-300">From round 0 to round 26 the overall probability of hitting this one bit difference in  <span class="math">A[38]</span>  and  <span class="math">B[42]</span>  is  <span class="math">1/8</span>  (1/4 if we are free to modify one bit of  <span class="math">B_p[10]</span> ).</p>

    <p class="text-gray-300">After round 26 the 1-bit differential begins to diffuse. However, due to there being only 6 rounds until the creation of the first output word  <span class="math">B_{c}[0] \\coloneqq B[48]</span> , the diffusion does not appear to be sufficient to remove biases in  <span class="math">\\Delta B[48]</span> . Table 1 shows an example differential in  <span class="math">\\Delta B[i + 16]</span>  progressing from round  <span class="math">i = 26</span>  to  <span class="math">i = 32</span> . The bolded value shows the position of the original 1 bit differential considering the 15 bit rotation operation that occurs every round. In experimental data described below, this is the bit with the largest bias at the end of each round.</p>

    <p class="text-gray-300">|  Example Differential  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=26</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000000000000000000001</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=27</td>

            <td class="px-3 py-2 border-b border-gray-700">0000000000000111100000000000000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=28</td>

            <td class="px-3 py-2 border-b border-gray-700">1100000000000000000000000111001</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=29</td>

            <td class="px-3 py-2 border-b border-gray-700">0000001011110000011000000000001</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=30</td>

            <td class="px-3 py-2 border-b border-gray-700">00110000001110110000111100001000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=31</td>

            <td class="px-3 py-2 border-b border-gray-700">10000011110001110110100101111010</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">i=32</td>

            <td class="px-3 py-2 border-b border-gray-700">01011100000010110100010110000000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Example differential in  <span class="math">\\Delta B[i + 16]</span>  for rounds  <span class="math">i = 26\\ldots 32</span></p>

    <p class="text-gray-300">We measure the biases in  <span class="math">B_{c}[0]</span>  experimentally by the following procedure:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">k = 1 \\ldots 2^{32}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) Generate Random  <span class="math">A_{p},B_{p},M</span>  , and  <span class="math">C</span> (b) Set  <span class="math">A_p&#x27; \\coloneqq A_p \\oplus 0 \\times 800000000</span>  h</p>

    <p class="text-gray-300">Set  <span class="math">B_p&#x27; \\coloneqq B_p \\oplus 0 \\times 000020000</span>  h</p>

    <p class="text-gray-300">(c)  <span class="math">A_{c},B_{c}\\coloneqq \\mathrm{Shabal - }\\mathcal{P}(A_{p},B_{p},M,C)</span> (d)  <span class="math">A_{c}^{\\prime},B_{c}^{\\prime}\\coloneqq \\mathrm{Shabal - }\\mathcal{P}(A_{p}^{\\prime},B_{p}^{\\prime},M,C)</span> (e) Count value of each bit in  <span class="math">\\Delta B_{c}[0] := B_{c}[0] \\oplus B_{c}^{\\prime}[0]</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate bias of each bit in the  <span class="math">2^{32}</span>  samples of  <span class="math">\\Delta B_{c}[0]</span></li>

    </ol>

    <p class="text-gray-300">With  <span class="math">2^{32}</span>  samples we can see that some bits are significantly biased. The results for some of the bits with the greatest bias are listed in Table 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bit</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bias with Random Input</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bias after fixing Bp[10]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-13.9</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-12.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-13.8</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-12.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-14.7</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-13.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-14.0</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-13.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-12.9</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-11.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-11.2</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 2-10.1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Selection of Measured Bit Biases in  <span class="math">\\Delta {B}_{c}\\left\\lbrack  0\\right\\rbrack</span></p>

    <p class="text-gray-300">Given  <span class="math">2^{23}</span>  inputs with the given difference, we expect to be able to statistically distinguish the bias of bit 26. If we can fix the  <span class="math">B_{p}[10]</span>  value on the inputs we can distinguish with  <span class="math">2^{21}</span>  inputs.</p>

    <p class="text-gray-300">Thank you to Anne Canteaut and the Shabal Team for taking the time to confirm the existence of this distinguisher on the inner permutation of Shabal. And thank you to Niels Ferguson, for the initial conversations that lead to this paper.</p>

    <p class="text-gray-300">This distinguisher shows that one can skip large amounts of the mixing in  <span class="math">\\mathcal{P}</span>  with a high probability given specific differences in the input. However, it does not seem possible to apply these biases to the full Shabal hash function since the IV is fixed, and multiple final iterations follow the last message block. While the difference given in this note was chosen to minimize the effects of the multiplication (mod  <span class="math">2^{32}</span> ) in the first 26 rounds, it seems possible that one could find other differences in  <span class="math">A_{p}, B_{p}</span>  giving greater biases than seen here.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Gilles Van Assche. A rotational distinguisher on shabal’s keyed permutation and its impact on the security proofs. Available online, 2010.</li>

      <li>[2] Jean-Philippe Aumasson. On the pseudorandomness of shabal’s keyed permutation. Available online, 2009.</li>

      <li>[3] Jean-Philippe Aumasson, Atefeh Mashatan, and Willi Meier. More on shabal’s permutation. OFFICIAL COMMENT, 2009.</li>

      <li>[4] Emmanuel Bresson, Anne Canteaut, Benot Chevallier-Mames, Christophe Clavier, Thomas Fuhr, Aline Gouget, Thomas Icart, Jean-Franois Misarsky, Mara Naya-Plasencia, Pascal Paillier, Thomas Pornin, Jean-Ren Reinhard, Cline Thuillet, and Marion Videau. Shabal, a submission to nists cryptographic hash algorithm competition. Submission to NIST, 2008.</li>

      <li>[5] Emmanuel Bresson, Anne Canteaut, Benot Chevallier-Mames, Christophe Clavier, Thomas Fuhr, Aline Gouget, Thomas Icart, Jean-Franois Misarsky, Mara Naya-Plasencia, Pascal Paillier, Thomas Pornin, Jean-Ren Reinhard, Cline Thuillet, and Marion Videau. Indifferentiability with distinguishers: Why shabal does not require ideal ciphers. Cryptology ePrint Archive, Report 2009/199, 2009.</li>

      <li>[6] Lars R. Knudsen, Krystian Matusiewicz, and Sren S. Thomsen. Observations on the shabal keyed permutation. OFFICIAL COMMENT, 2009.</li>

    </ul>`;
---

<BaseLayout title="Distinguisher for Shabal&#x27;s Permutation Function (2010/398)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2010 &middot; eprint 2010/398
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
