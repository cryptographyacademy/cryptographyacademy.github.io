---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/1167';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'fflonk: a Fast-Fourier inspired verifier efficient version of PlonK';
const AUTHORS_HTML = 'Ariel Gabizon, Zachary J.  Williamson';

const CONTENT = `    <p class="text-gray-300">Ariel Gabizon Zachary J. Williamson Aztec Network</p>

    <p class="text-gray-300">November 1, 2021</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">We present a variant of the Kate, Zaverucha and Goldberg polynomial commitment scheme [\\[KZG10\\]](#page-17-0) where d polynomials can be opened at a point that is a d'th power, such that the amount of verifier group operations does not depend on d. Our method works by reducing opening multiple polynomials at a single point x, to opening a single polynomial at many points via an "FFT-like identity".</p>

    <p class="text-gray-300">As an application we present a version of the PlonK zk-SNARK[\\[GWC19\\]](#page-17-1) with significantly improved verifier performance, at the cost of roughly tripling the prover time. Specifically, in addition to the two pairings, the verifier only performs five scalar multiplications, rather than 16 or 18 as in the versions presented in [\\[GWC19\\]](#page-17-1).</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Polynomial commitment schemes (PCS)[\\[KZG10\\]](#page-17-0) have become a central ingredient in recent constructions of succinct arguments(SNARKs) <a href="#page-17-2">\\[MBKM19,</a> <a href="#page-16-0">Gab19,</a> <a href="#page-16-1">CHM</a>+19, <a href="#page-17-1">GWC19,</a> [BFS19\\]](#page-16-2) when one desires a "universal and updatable" setup procedure <a href="#page-17-3">\\[GKM</a>+]. They "force" a prover to answer verifier queries according to a fixed polynomial of bounded degree.</p>

    <p class="text-gray-300">In blockchains such as Ethereum, the precise cost of verifiying a zk-SNARK is of crucial importance to applications such as "zk-rollups"[\\[But\\]](#page-16-3). In these recent constructions this cost mostly reduces to the verification cost of the open procedure of the PCS. In this procedure we verify the correctness of evaluations given to the verifier, of polynomials previously committed by the prover. In this work we give a novel method to reduce verifier cost when opening many commitments in a [\\[KZG10\\]](#page-17-0)-style PCS.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Overiew of method and comparison to previous techniques:</h3>

    <p class="text-gray-300">The original scheme of [\\[KZG10\\]](#page-17-0) requires two pairings to open a polynomial f at a point x ∈ F. If we wish to open several polynomials f0, . . . , ft−<sup>1</sup> at x - using [\\[KZG10\\]](#page-17-0) directly would require 2t verifier pairings. The common way to improve on this, used in [MBKM19, CHM<sup>+</sup>19, GWC19], has been to choose a random  <span class="math">\\gamma \\in \\mathbb{F}</span> , and instead only verify the value of  <span class="math">f(x) := \\sum_{i=0}^{t-1} \\gamma^i f_i(x)</span> .</p>

    <p class="text-gray-300">What verifier efficiency does this result in? The verifier only does two pairings as when opening a single polynomial. However, she must create the commitment for f out of the commitments of the  <span class="math">\\{f_i\\}</span> , which requires t-1 scalar multiplications to multiply the commitments by the scalars  <span class="math">\\{\\gamma^i\\}_{i\\in\\{0,\\dots,t-1\\}}</span> . Can we get rid of this dependence on t in the verifier performance?</p>

    <p class="text-gray-300">The work of Boneh, Drake, Fisch and Gabizon [BDFG20] suggests a route: They give an opening protocol for multiple points where the number of verifier group operations only depends on the number of polynomials but not the number of points (there is still a dependency in the number of verifier field operations, but these are 3 orders of magnitude cheaper than a scalar multiplication). Thus, if we could reduce opening many polynomials at a single point to opening a single polynomial at multiple points we could then use [BDFG20] to obtain our desired result.</p>

    <p class="text-gray-300"><strong>An illustration</strong> Suppose for a moment we only have two polynomials  <span class="math">f_0</span> ,  <span class="math">f_1</span>  to open at x. A straightforward attempt to avoid the scalar multiplication would be to only open  <span class="math">f_0 + f_1</span>  at x. Let  <span class="math">a := f_0(x)</span>  and  <span class="math">b := f_1(x)</span> . This would prove that the sum of values  <span class="math">(f_0 + f_1)(x) = c = a + b</span>  is correct. However, it doesn't constrain a, b individually: For any value  <span class="math">a&#x27; \\in \\mathbb{F}</span>  we could choose b' such that a' + b' = c, and the verifier would also accept (a', b'). We thus need a way to generate another linear constraint on (a, b) without resorting to using two polynomials.</p>

    <p class="text-gray-300">The well-known "FFT equation" comes to our aid. In the FFT setting, we represent a polynomial f by two polynomials  <span class="math">f_0</span> ,  <span class="math">f_1</span>  of half the degree derived from its even and odd powers:</p>

    <div class="my-4 text-center"><span class="math-block">f(X) = f_0(X^2) + X \\cdot f_1(X^2).</span></div>

    <p class="text-gray-300">Here, we use this equation in the reverse direction - starting from  <span class="math">f_0, f_1</span>  and deriving f. Suppose  <span class="math">x = z^2</span>  is a square. f will allow us to derive the desired second constraint on a, b. Specifically, we open f at  <span class="math">\\{z, -z\\}</span> . We have</p>

    <div class="my-4 text-center"><span class="math-block">b_0 = f(z) = f_0(x) + zf_1(x) = a + zb</span></div>

    <div class="my-4 text-center"><span class="math-block">b_1 = f(-z) = f_0(x) - zf_1(x) = a - zb</span></div>

    <p class="text-gray-300">Thus, these two openings of f have given us the desired two independent constraints on a, b and we can determine them. Using the natural extension to t'th roots of unity gives us the same thing for t polynomials.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.2 Our results:</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We compare the performance of our PCS to a more straightforward batched version of the [KZG10] scheme as in [GWC19]. For simplicity, we look at the case where we want to open t polynomials of degree smaller than n at a single point  <span class="math">x \\in \\mathbb{F}</span>  that is a t'th power, for  $t \\mid (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$ . The table clearly shows the tradeoff - while the verifier group operations</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for opening do not depend anymore on t, the prover's do - as opposed to more standard batching where the prover's group exponentations<sup>1</sup> only depend on the maximal degree amongst the polynomials. See Theorem 5.2 for the more detailed efficiency properties in the general case (where each polynomial is opened at an arbitrary subset of points).</p>

    <p class="text-gray-300">Table 1: Comparison of opening t polynomials of degree smaller than n, at a point  <span class="math">x \\in \\mathbb{F}</span>  of the form  <span class="math">x = z^t</span>  for some  <span class="math">z \\in \\mathbb{F}</span> . In prover/verifier work columns  <span class="math">\\mathbb{G}_i</span>  means scalar multiplication in  <span class="math">\\mathbb{G}_i</span> ,  <span class="math">\\mathbb{F}</span>  means addition or multiplication in  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\mathbf{P}</span>  means pairing.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof<br>length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier group operations</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n \\mathbb{G}_1, 2 \\mathbb{G}_2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">tn \\ \\mathbb{G}_1, \\ O(tn) \\ \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">2t <b>P</b></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Batched KZG as in [GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n \\mathbb{G}_1, 2 \\mathbb{G}_2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n \\mathbb{G}_1, O(tn) \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1 \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">t-1 \\mathbb{G}_1, 2 \\mathbf{P}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">tn \\mathbb{G}_1, 2 \\mathbb{G}_2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2tn \\ \\mathbb{G}_1, \\ O(tn) \\ \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2 \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3  \\mathbb{G}_1,  2  \\mathbf{P}</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Application to</strong>  <span class="math">\\mathscr{PlonK}</span> : The  <span class="math">\\mathscr{PlonK}</span>  proving system [GWC19] allows generating proofs of knowledge for assignments to fan-in two arithmetic circuits with a universal and updatable SRS (see the paragraph on this topic in Section 2.1). Plugging in our PCS into  <span class="math">\\mathscr{PlonK}</span>  allows saving in verifier work at the expense of increased prover computation. We compare the  <span class="math">\\mathscr{PlonK}</span>  scheme when using the [KZG10]-based PCS in [GWC19] and the PCS of this paper in Table 2.</p>

    <p class="text-gray-300"><span id="page-2-1"></span>Table 2: Comparison of  <span class="math">\\mathcal{Plon}\\mathcal{X}</span>  efficiency for fan-in two circuit with n gates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover group operations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof<br>length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier group operations</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3n \\mathbb{G}_1, 2 \\mathbb{G}_2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">11n \\ \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">7 \\mathbb{G}_1, 7 \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">16 \\; \\mathbb{G}_1, \\; 2 \\; \\mathbf{P}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">9n \\mathbb{G}_1, 2 \\mathbb{G}_2</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">35n \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">4 \\mathbb{G}_1, 15 \\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">5 \\mathbb{G}_1, 2 \\mathbf{P}</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">When is it worth it?</h4>

    <p class="text-gray-300">The zk-rollup setting motivates verifier-prover tradeoffs such as in this paper. We typically have "client proofs" computed by weak machines. These proofs are not posted on the blockchain, but usually only recursively verified by another SNARK. Thus, for these it makes sense to optimize prover efficiency at the expense of the verifier. On the other hand, the final proof put on chain is typically computed by a powerful machine, and is expensive to verify - since all network nodes must do so. For such proofs, it could be a good tradeoff to use the scheme of this paper.</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>&</sup>lt;sup>1</sup>Following (perhaps faulty) conventions, we interchangeably use the notions group exponetiation and scalar multiplication.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">2 Preliminaries</h4>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Terminology and conventions</h3>

    <p class="text-gray-300">We assume our field  <span class="math">\\mathbb{F}</span>  is of prime order. We denote by  <span class="math">\\mathbb{F}_{&lt; d}[X]</span>  the set of univariate polynomials over  <span class="math">\\mathbb{F}</span>  of degree smaller than d. In expressions involving both polynomials and constants, we will write f(X) instead of f for to distinguish the two; but in contexts where it is clear f is a polynomial, we will simply write f for brevity.</p>

    <p class="text-gray-300">We assume all algorithms described receive as an implicit parameter the security parameter  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">Whenever we use the term "efficient", we mean an algorithm running in time  <span class="math">\\operatorname{poly}(\\lambda)</span> . Furthermore, we assume an "object generator"  <span class="math">\\mathcal{O}</span>  that is run with input  <span class="math">\\lambda</span>  before all protocols, and returns all fields and groups used. Specifically, in our protocol  <span class="math">\\mathcal{O}(\\lambda) = (\\mathbb{F}, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t, e, g_1, g_2, g_t)</span>  where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span>  is a prime field of super-polynomial size  <span class="math">p = \\lambda^{\\omega(1)}</span>  .</li>

      <li><span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_t</span>  are all groups of size p, and e is an efficiently computable non-degenerate pairing  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_t</span> .</li>

      <li><span class="math">g_1, g_2</span>  are uniformly chosen generators such that  <span class="math">e(g_1, g_2) = g_t</span> .</li>

    </ul>

    <p class="text-gray-300">We usually let the  <span class="math">\\lambda</span>  parameter be implicit, i.e. write  <span class="math">\\mathbb{F}</span>  instead of  <span class="math">\\mathbb{F}(\\lambda)</span> . We write  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  additively. We use the notations  <span class="math">[x]_1 := x \\cdot g_1</span>  and  <span class="math">[x]_2 := x \\cdot g_2</span> .</p>

    <p class="text-gray-300">We often denote by [n] the integers  <span class="math">\\{1, \\ldots, n\\}</span> . We use the acronym e.w.p for "except with probability"; i.e. e.w.p  <span class="math">\\gamma</span>  means with probability at least  <span class="math">1 - \\gamma</span> .</p>

    <p class="text-gray-300"><strong>Universal SRS-based public-coin protocols</strong> We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the "proof length" of an interactive protocol.</p>

    <p class="text-gray-300">We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic  <span class="math">\\operatorname{poly}(\\lambda)</span> -time from an "SRS of monomials" of the form  <span class="math">\\left\\{\\begin{bmatrix}x^i\\end{bmatrix}_1\\right\\}_{a\\leq i\\leq b}, \\left\\{\\begin{bmatrix}x^i\\end{bmatrix}_2\\right\\}_{c\\leq i\\leq d}</span> , for uniform  <span class="math">x\\in\\mathbb{F}</span> , and some integers a,b,c,d with absolute value bounded by  <span class="math">\\operatorname{poly}(\\lambda)</span> . It then follows from Bowe et al. [BGM17] that the required SRS can be derived in a universal and updatable setup[GKM<sup>+</sup>] requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a  <span class="math">\\operatorname{negl}(\\lambda)</span>  advantage in its probability of producing a proof of any statement.</p>

    <p class="text-gray-300">For notational simplicity, we sometimes use the SRS srs as an implicit parameter in protocols, and do not explicitly write it.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3 Notation, definitions and operations on vectors and polynomials</h4>

    <p class="text-gray-300">Formally describing this paper's scheme in general form requires addressing opening multiple commitments, each committing to multiple polynomials, each opened at multiple points. To avoid this leading to very cumbersome notation and a "nightmare of indices", we define some operations on vectors and polynomials that enable more concise writing.</p>

    <p class="text-gray-300">For positive integer t we denote by [< t] the integers  <span class="math">\\{0, \\ldots, t-1\\}</span> . We use the convention for running indicies that the notation i < t e.g. in  <span class="math">\\sum_{i &lt; t}</span>  means the sum is over  <span class="math">i \\in [&lt; t]</span> .</p>

    <p class="text-gray-300"><strong>Vector notation:</strong> Let D be some domain. We denote the set of vectors over D by  <span class="math">D^{(1)}</span> , and similarly, the set of vectors of vectors, and vectors of vectors of vectors by  <span class="math">D^{(2)} = (D^{(1)})^{(1)}</span>  and  <span class="math">D^{(3)} = (D^{(2)})^{(1)}</span>  respectively.</p>

    <p class="text-gray-300">As suggestive notation, we denote elements of these sets by a corresponding number of overhead bars respectively; e.g.  <span class="math">\\bar{S} \\in \\mathbb{F}^{(1)}, \\bar{\\bar{S}} \\in \\mathbb{F}^{(2)}</span>  and  <span class="math">\\bar{\\bar{S}} \\in \\mathbb{F}^{(3)}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a vector  <span class="math">\\bar{f} \\in D^t</span> , we refer to the elements of  <span class="math">\\bar{f}</span>  by  <span class="math">f_i, 0 \\leq i &lt; t</span> . Similarly for  <span class="math">\\bar{f} \\in D^{(2)}</span> , we refer to the elements of  <span class="math">\\bar{f}</span> , which are vectors over D, by  $\\bar{f}_i, 0 \\leq i <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ; and the elements of the  </span>\\{\\bar{f}_i\\}<span class="math">  by  </span>\\{f_{i,j}\\}_{i<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,j<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{f}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . We denote by  </span>\\mathbb{F}_{< d}[X]<span class="math">  - elements of  </span>\\mathbb{F}[X]$  of degree smaller than d.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Operations on polynomials:</strong> For a vector of polynomials  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span>  and  <span class="math">x \\in \\mathbb{F}</span>  we denote by  <span class="math">\\bar{f}(x)</span>  the vector in  <span class="math">\\mathbb{F}^t</span> ,  <span class="math">\\bar{f}(x) := (f_0(x), \\dots, f_{t-1}(x))</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span>  and vector of points  <span class="math">\\bar{Z} \\in \\mathbb{F}^\\ell</span>  we denote by  <span class="math">\\bar{f}(\\bar{Z}) \\in \\mathbb{F}^{(2)}</span>  the element of  <span class="math">(\\mathbb{F}^t)^\\ell</span>  defined as  <span class="math">\\bar{f}(\\bar{Z}) := (\\bar{f}(Z_j))_{j &lt; \\ell}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a vector of vectors of polynomials  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^{(2)}</span>  and a vector of vectors of points  <span class="math">\\bar{Z} \\in \\mathbb{F}^{(2)}</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{Z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , we denote by  </span>\\bar{f}(\\bar{Z}) \\in \\mathbb{F}^{(3)}<span class="math">  the element  </span>\\bar{f}(\\bar{Z}) := (\\bar{f}_i(\\bar{Z}_i))_{i <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">4 Polynomial commitment schemes</h2>

    <p class="text-gray-300">We define polynomial commitment schemes similarly to [GWC19, BDFG20]. However, we make two modifications that enable capturing the scheme of this paper</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We allow the commit phase to take a <em>vector</em> of polynomials as input rather than just one. Although less general, for notational simplicity we allow the set of opening points to depend only on the vector in which the polynomial was committed in.</li>

      <li>We allow the scheme to be parameterized by a subset  <span class="math">S \\subset \\mathbb{F}</span>  such that the opening procedure is only required to succeed on points from S.</li>

    </ul>

    <p class="text-gray-300"><span id="page-4-0"></span><strong>Definition 4.1.</strong> Fix a finite subset of positive integers T and subset  <span class="math">\\mathbf{S} \\subset \\mathbb{F}</span> . A  <span class="math">(T, \\mathbf{S})</span> -polynomial commitment scheme is a 3-tuple  <span class="math">\\mathscr{S} = (\\mathsf{gen}, \\mathsf{com}, \\mathsf{open})</span>  such that</p>

    <p class="text-gray-300">• gen(d) - is a randomized algorithm that given positive integer d outputs a structured reference string (SRS) srs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{com}(t, \\bar{f}, \\operatorname{srs})</span>  is an algorithm that given  <span class="math">t \\in T</span> , a vector of polynomials  <span class="math">\\bar{f} \\in (\\mathbb{F}_{&lt; d}[X])^t</span>  and an output  <span class="math">\\operatorname{srs}</span>  of  <span class="math">\\operatorname{gen}(d)</span> , returns a commitment  <span class="math">\\operatorname{cm}</span>  to  <span class="math">\\bar{f}</span> .</li>

      <li>open is a public coin protocol between parties P and V. P is given  <span class="math">\\bar{f} \\in (\\mathbb{F}_{&lt; d}[X])^{(2)}</span> . P and V are both given</li>

      <li>1. Positive integer d and srs = gen(d),</li>

      <li>2. Positive integer r and  <span class="math">\\overline{\\mathsf{cm}} \\in \\mathbb{G}_1^r</span>  the alleged commitments to the  <span class="math">\\{\\bar{f}_i\\}</span> ,</li>

      <li>3. Vector  <span class="math">\\bar{t} \\in T^r</span>  the alleged lengths of the  <span class="math">\\{\\bar{f}_i\\}</span> .</li>

      <li>4.  <span class="math">\\bar{Z} \\in \\mathbf{S}^{(2)}</span> .</li>

      <li>5.  <span class="math">\\bar{\\bar{S}} \\in \\mathbb{F}^{(3)}</span>  the alleged values  <span class="math">\\bar{\\bar{f}}(\\bar{\\bar{Z}})</span> .</li>

    </ul>

    <p class="text-gray-300">At the end of the protocol V outputs acc or rej; such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: Fix any  <span class="math">\\bar{t}, \\bar{\\bar{f}}</span>  with  <span class="math">\\bar{f}_i \\in (\\mathbb{F}_{&lt; d}[X])^{t_i}, \\bar{\\bar{Z}} \\in \\mathbb{F}^{(2)}, \\bar{\\bar{\\bar{S}}} \\in \\mathbb{F}^{(3)}</span>  such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\bar{\\bar{f}}(\\bar{\\bar{Z}}) = \\bar{\\bar{\\bar{S}}}.</span></div>

    <p class="text-gray-300">Then if P and V follow the protocol with these inputs, V outputs acc with probability  <span class="math">1 - \\text{negl}(\\lambda)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness in the algebraic group model: There exists an efficient E such that for any algebraic adversary  <span class="math">\\mathcal A</span>  and any choice of  <span class="math">d = \\mathsf{poly}(\\lambda)</span>  the probability of  <span class="math">\\mathcal A</span>  winning the following game is  <span class="math">\\mathsf{negl}(\\lambda)</span>  over the randomness of  <span class="math">\\mathcal A</span> , V and  <span class="math">\\mathsf{gen}</span> .</li>

      <li>1. Given d and  <span class="math">\\operatorname{srs} = \\operatorname{gen}(d)</span> ,  <span class="math">\\mathscr A</span>  outputs  <span class="math">\\overline{t} \\in T^r, \\overline{\\operatorname{cm}} \\in \\mathbb G_1^r</span> .</li>

      <li>2. E, given access to the messages of  <span class="math">\\mathscr{A}</span>  during the previous step, outputs  <span class="math">\\bar{f}</span>  with  <span class="math">\\bar{f}_i \\in \\mathbb{F}_{&lt; d}[X]^{t_i}</span> .</li>

      <li>3. A outputs  <span class="math">\\bar{\\bar{Z}} \\in \\mathbf{S}^{(2)}, \\bar{\\bar{\\bar{S}}} \\in \\mathbb{F}^{(3)}</span> .</li>

      <li>4. A takes the part of P in the protocol open with the inputs  <span class="math">\\bar{t}, \\overline{\\text{cm}}, \\bar{\\bar{Z}}, \\bar{\\bar{\\bar{S}}}</span> .</li>

      <li>5. A wins if</li>

      <li>\\* V outputs acc at the end of the protocol.</li>

      <li>\\*  <span class="math">f(\\bar{Z}) \\neq \\bar{\\bar{S}}</span> .</li>

    </ul>

    <p class="text-gray-300">Notation: We usually omit d, srs and r, and write open <span class="math">(\\bar{t}, \\overline{\\mathsf{cm}}, \\bar{\\bar{Z}}, \\bar{\\bar{S}}; \\bar{\\bar{f}})</span> .</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.1 shplonk</h4>

    <p class="text-gray-300">From [BDFG20] we cite the following commitment scheme (that for historical reasons has become known as  <span class="math">\\mathfrak{shplon}\\mathfrak{K}</span> ). The commitment procedure is identical to [KZG10]. Its crucial advantage is that the verifier group operations do not grow with the number of evaluation points .</p>

    <p class="text-gray-300"><span id="page-6-0"></span>Lemma 4.2. There is a {1, F}-PCS SshplonK = (genshplonK, comshplonK, openshplonK) such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. genshplonK(d) is of the form: Choose uniform <sup>x</sup> <sup>∈</sup> <sup>F</sup>. Output srs = ([1]<sup>1</sup> , [x] 1 , . . . , x d−1 1 , [1]<sup>2</sup> , [x] 2 ).</li>

      <li>2. For integer n ≤ d and f ∈ F<n[X], computing comshplonK(1, f,srs) requires n G1 scalar multiplications.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 3. Fix ¯f,Z, ¯¯ S ¯¯. Let <sup>n</sup> := max<sup>i</sup> [deg(fi)]. Let k :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">¯f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. Then openshplonK 1 k , cm,Z, ¯¯ S ¯¯; ¯f requires</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) 2 G<sup>1</sup> elements sent from P to V.</li>

      <li>(b) at most 2n + 1 G1-scalar multiplications of P.</li>

      <li>(c) k + 2 G1-scalar multiplications and 2 pairings of V.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. This is Lemma 4.1 from [\\[BDFG20\\]](#page-16-4) - except that there V does k + 3 G1-scalar multiplications. However, it turns out the open protocol from there can be "normalized" to save one of the scalar multiplications, by dividing in many places by the constant ZT\\S<sup>1</sup> (z) that appears as one of the scalar multipliers. We present the [\\[BDFG20\\]](#page-16-4) open protocol here with this minor modification. To make the comparision with [\\[BDFG20\\]](#page-16-4) easier, we momentarily use the notation from that paper - where T denotes the union of opening points for all polynomials, S<sup>i</sup> denotes the opening set for the i'th polynomial , i ranges from one rather than zero; and r<sup>i</sup> denotes the polynomial of degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">− 1 that coincides with f<sup>i</sup> on S<sup>i</sup> . (See [\\[BDFG20\\]](#page-16-4) for more context and details.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}(\\left\\{\\mathsf{cm}_i\\right\\}_{i\\in[k]},\\left\\{S_i\\right\\}_{i\\in[k]},\\left\\{r_i\\right\\}_{i\\in[k]};\\left\\{f_i\\right\\}_{i\\in[k]}):</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. V sends a random challenge γ ∈ F.</li>

      <li>2. P sends W := [(f /Z<sup>T</sup> )(x)]<sup>1</sup> where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f := \\sum_{i \\in [k]} \\gamma^{i-1} \\cdot Z_{T \\setminus S_i}(f_i - r_i).</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3. V sends a random evaluation point z ∈ F</li>

      <li>4. P sends W<sup>0</sup> := h L(x) Z<sup>T</sup> \\S<sup>1</sup> (z)(x−z) i 1 where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">L := \\sum_{i \\in [k]} \\gamma^{i-1} Z_{T \\setminus S_i}(z) \\cdot (f_i - r_i(z)) - Z_T(z) \\cdot (f/Z_T).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V outputs acc iff e(F + zW<sup>0</sup> , [1]<sup>2</sup> ) = e(W<sup>0</sup> , [x] 2 ), where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F:=\\sum_{i\\in[k]}\\gamma^{i-1}\\frac{Z_{T\\backslash S_i}}{Z_{T\\backslash S_1}}(z)\\cdot\\operatorname{cm}_i-\\left[\\sum_{i\\in[k]}\\gamma^{i-1}\\frac{Z_{T\\backslash S_i}}{Z_{T\\backslash S_1}}(z)r_i(z)\\right]_1-\\frac{Z_T}{Z_{T\\backslash S_1}}(z)W.</span></div>

    <p class="text-gray-300">Observe that in this form the coefficient of  <span class="math">\\mathsf{cm}_1</span>  in the last equation is one - this is what saves a verifier scalar multiplication compared to [BDFG20]. At the same time, it is straightforward to carry over the knowledge soundness proof from [BDFG20], as terms have simply changed by the constant  <span class="math">Z_{T \\setminus S_1}(z)</span> .</p>

    <p class="text-gray-300"><strong>Remark 4.3.</strong> [BDFG] generalize the above result regarding opening efficiency from [KZG10] to any PCS with a linearly homomorphic commitment scheme. Combining their generalization with the reduction of the next section could improve verifier efficiency in the open procedures of such schemes.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">5 The new commitment scheme</h3>

    <p class="text-gray-300">We define a few final operations and notations needed for presenting the scheme.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">5.1 FFT-like operations on vectors and polynomials</h3>

    <p class="text-gray-300">We define operators <code>combine()</code> and <code>decompose()</code> to group together and decompose polynomials "FFT style":</p>

    <p class="text-gray-300">•  <span class="math">\\operatorname{combine}_t(\\bar{f}) : \\mathbb{F}[X]^t \\to \\mathbb{F}[X]</span>  - given  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span>  return</p>

    <div class="my-4 text-center"><span class="math-block">g(X) := \\sum_{i &lt; t} f_i(X^t) \\cdot X^i</span></div>

    <p class="text-gray-300">note that when  <span class="math">\\bar{f} \\in \\mathbb{F}_{&lt; d}[X]^t</span>  we have  <span class="math">\\mathsf{combine}_t(\\bar{f}) \\in \\mathbb{F}_{&lt; d \\cdot t}[X]</span> .</p>

    <p class="text-gray-300">•  <span class="math">\\mathsf{decompose}_t(g): \\mathbb{F}[X] \\to \\mathbb{F}[X]^t</span>  - given  <span class="math">g \\in \\mathbb{F}[X]</span>  return the unique  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">g(X) := \\sum_{i &lt; t} f_i(X^t) \\cdot X^i</span></div>

    <p class="text-gray-300">Note that these are injective and inverse operations. That is, for any  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span> ,  <span class="math">\\operatorname{decompose}_t(\\operatorname{combine}_t(\\bar{f})) = \\bar{f}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Notation regarding roots:</strong> We denote  $p :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . For positive integer t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(p-1), let  <span class="math">\\omega_t \\in \\mathbb{F}</span>  be a fixed primitive t'th root of unity, i.e.  <span class="math">\\omega_t^t = 1</span>  and  <span class="math">\\omega_t^i \\neq 1</span>  for i < t. For a t'th power  <span class="math">x \\in \\mathbb{F}</span> , fix  <span class="math">z \\in \\mathbb{F}</span>  such that  <span class="math">z^t = x</span>  and  <span class="math">z^i \\neq x</span>  for i < t in a standard way; e.g. take such z that has the smallest integer representative in [<p-1]. Now, define the vector roots <span class="math">_t(x) := (z\\omega_t^i)_{i &lt; t}</span></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Interpreting vectors as polynomials: For a vector  <span class="math">v \\in \\mathbb{F}^t</span>  and a point  <span class="math">x \\in \\mathbb{F}</span> , we denote  <span class="math">v(x) := \\sum_{i &lt; t} v_i x^i</span> . For vectors  <span class="math">v, S \\in \\mathbb{F}^{(1)}</span>  we denote  <span class="math">v(S) := (v(x))_{x \\in S}</span> .</p>

    <p class="text-gray-300">The following simple lemma is the basis of our scheme.</p>

    <p class="text-gray-300"><span id="page-8-0"></span><strong>Lemma 5.1.</strong> Fix any  <span class="math">x \\in \\mathbb{F}, \\bar{S} \\in \\mathbb{F}^t</span>  and  <span class="math">\\bar{f} \\in \\mathbb{F}[X]^t</span> . Define  <span class="math">\\bar{Z} := \\mathsf{roots}_t(x), g := \\mathsf{combine}_t(\\bar{f})</span>  and  <span class="math">\\bar{S}&#x27; := \\bar{S}(\\bar{Z})</span> .</p>

    <p class="text-gray-300">Then  <span class="math">\\bar{f}(x) = \\bar{S}</span>  if and only if  <span class="math">g(\\bar{Z}) = \\bar{S}&#x27;</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For  <span class="math">z \\in \\bar{Z}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">g(z) = \\sum_{i &lt; t} f_i(z^t) z^i = \\sum_{i &lt; t} f_i(x) z^i = \\bar{f}(x)(z).</span></div>

    <p class="text-gray-300">So  <span class="math">g(\\bar{Z}) = \\bar{f}(x)(\\bar{Z})</span> . Since distinct polynomials of degree less than t cannot agree on t points, we have that  <span class="math">\\bar{f}(x) = \\bar{S}</span>  if and only if  <span class="math">g(\\bar{Z}) = \\bar{S}&#x27;</span> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">5.2 The new scheme</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Choose a positive constant A dividing p-1. Let  $T := \\{0 < t \\le A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\}<span class="math"> . Let <strong>S</strong> be the set of A&#x27;th powers in  </span>\\mathbb{F}<span class="math"> . We present the following  </span>(T, \\mathbf{S})$ -polynomial commitment scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. gen(d) choose uniform  <span class="math">x \\in \\mathbb{F}</span> . Output  <span class="math">srs = ([1]_1, [x]_1, \\dots, [x^{A \\cdot (d-1)}]_1, [1]_2, [x]_2)</span> .</li>

      <li>2.  <span class="math">\\operatorname{com}(t, \\bar{f}, \\operatorname{srs})</span>  for  <span class="math">t \\in T</span>  and  <span class="math">\\bar{f} \\in (\\mathbb{F}_{&lt; d}[X])^t</span> . Let  <span class="math">g := \\operatorname{combine}_t(\\bar{f})</span> . Output  <span class="math">\\operatorname{com}(t, \\bar{f}, \\operatorname{srs}) := [g(x)]_1</span> .</li>

      <li>3. open: We first describe the open protocol for the simplest case of one commitment and one evaluation point.</li>

    </ul>

    <p class="text-gray-300">open  <span class="math">(t, \\operatorname{cm}, x, \\bar{S}; \\bar{f})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) P computes  <span class="math">g := \\mathsf{combine}_t(\\bar{f})</span> . (In practice P has this computed already from the commitment phase.)</li>

      <li>(b) P and V compute  <span class="math">\\bar{Z}&#x27; := \\mathsf{roots}_t(x)</span>  and  <span class="math">\\bar{S}&#x27; := \\bar{S}(\\bar{Z}&#x27;)</span> .</li>

      <li>(c) P and V engage in  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}(1,\\mathsf{cm},\\bar{Z}&#x27;,\\bar{S}&#x27;;g)</span>  and V outputs  <span class="math">\\mathsf{acc}</span>  if and only if she does so in the execution of  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span> .</li>

    </ul>

    <p class="text-gray-300">The general case is basically applying the same logic to each evaluation point and commitment.</p>

    <p class="text-gray-300">open  <span class="math">\\left(\\bar{t},\\overline{\\mathsf{cm}},\\bar{\\bar{Z}},\\bar{\\bar{\\bar{S}}};\\bar{f}\\right)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) For i < r, P computes  <span class="math">g_i := \\mathsf{combine}_{t_i}(\\bar{f}_i)</span> . Let  <span class="math">\\bar{g} := (g_i)_{i &lt; r}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (b) P and V compute  <span class="math">\\bar{Z}&#x27;</span>  where  <span class="math">\\bar{Z}&#x27;_i = \\bigcup_{x \\in \\bar{Z}_i} \\mathsf{roots}_{t_i}(x)</span> , and  <span class="math">\\bar{S}&#x27;</span>  where  $\\bar{S}'_i := \\bigcup_{j <</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{S}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\bar{S}_{i,j}(\\mathsf{roots}_{t_i}(Z_{i,j}))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(c) P and V engage in  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}(1^r,\\overline{\\mathsf{cm}},\\bar{\\bar{Z}}&#x27;,\\bar{\\bar{S}}&#x27;;\\bar{g})</span>  and V outputs acc if and only if she does so in the execution of  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span> .</li>

    </ul>

    <p class="text-gray-300">Knowledge soundness: We look first at the simple case of one commitment and evaluation point. In this case  <span class="math">\\mathscr A</span>  outputs an integer t, a  <span class="math">\\mathbb G_1</span> -element cm, and coefficients  <span class="math">\\{a_i\\}</span>  such that cm =  <span class="math">\\left[\\sum_{i&lt; A(d-1)} a_i x^i\\right]_1</span> . Let  <span class="math">g(X) := \\sum_{i&lt; A(d-1)} a_i X^i</span> . We define the extractor E to output  <span class="math">\\bar f = \\mathsf{decompose}_t(g)</span> . An important point is that the extractor  <span class="math">E_{\\mathfrak{shplong}}</span>  used in [BDFG20] for the knowledge soundness game of  <span class="math">\\mathsf{open}_{\\mathfrak{shplong}}</span>  outputs g when given  <span class="math">1, \\mathsf{cm}, \\{a_i\\}</span>  by an adversary. We must show that  <span class="math">\\mathscr A</span>  wins the knowledge soundness game with probability  <span class="math">\\mathsf{negl}(\\lambda)</span> . We will reduce to the knowledge soundness of  <span class="math">\\mathsf{open}_{\\mathfrak{shplong}}</span> : We construct an adversary  <span class="math">\\mathscr A&#x27;</span>  for  <span class="math">\\mathsf{open}_{\\mathfrak{shplong}}</span>  that works as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">\\mathscr{A}&#x27;</span>  starts running the adversary  <span class="math">\\mathscr{A}</span>  for the knowledge soundness game of open. She simulates the roles of V and E according to their correct behavior.</li>

      <li>2. When  <span class="math">\\mathscr{A}</span>  outputs t, a  <span class="math">\\mathbb{G}_1</span>  element cm, and coefficients  <span class="math">\\{a_i\\}</span>  such that cm =  <span class="math">\\left[\\sum_{i &lt; A(d-1)} a_i x^i\\right]_1</span> .  <span class="math">\\mathscr{A}&#x27;</span>  outputs 1 and the same element cm and coefficients  <span class="math">\\{a_i\\}</span> .</li>

      <li>3. Note that the extractor  <span class="math">E_{\\mathfrak{shplon}\\mathfrak{K}}</span>  from Lemma 4.2 for the knowledge soundness game of  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span>  would output g at this point; and that the extractor E we defined for the knowledge soundness game of  <span class="math">\\mathsf{open}</span>  outputs  <span class="math">\\bar{f} = \\mathsf{decompose}_t(g)</span>  at this point of the game with  <span class="math">\\mathscr{A}</span> .</li>

      <li>4. If  <span class="math">\\mathscr{A}</span>  now outputs  <span class="math">x, \\bar{S}, \\mathscr{A}&#x27;</span>  outputs  <span class="math">\\bar{Z}&#x27;, \\bar{S}&#x27;</span>  where  <span class="math">\\bar{Z}&#x27; := \\mathsf{roots}_t(x)</span>  and  <span class="math">\\bar{S}&#x27; := S(Z&#x27;)</span> .</li>

      <li>5. Now we must define how  <span class="math">\\mathscr{A}&#x27;</span>  behaves in  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}(1,\\mathsf{cm},\\bar{Z}&#x27;,\\bar{S}&#x27;)</span> . She will behave exactly as  <span class="math">\\mathscr{A}</span>  does in the call to  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span>  which is part of the  <span class="math">\\mathsf{open}</span>  procedure note that this is well defined as at this point V will use the same inputs  <span class="math">1,\\mathsf{cm},\\bar{Z}&#x27;,\\bar{S}&#x27;</span>  for the  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span>  subprocedure.</li>

    </ul>

    <p class="text-gray-300">We claim that the success probability of  <span class="math">\\mathscr{A}&#x27;</span>  and  <span class="math">\\mathscr{A}</span>  to win their respective knowledge soundness games is the same: By definition of the knowledge soundness game of  <span class="math">\\operatorname{\\mathsf{open}}_{\\mathfrak{shplon}\\mathfrak{K}}, \\mathscr{A}&#x27;</span>  wins if and only if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">V_{\\mathfrak{shplonR}}</span>  outputs acc</li>

      <li>2.  <span class="math">g(\\bar{S}&#x27;) \\neq \\bar{Z}&#x27;</span> .</li>

    </ul>

    <p class="text-gray-300">By definition of V and Lemma 5.1 this is equivalent to</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. V outputs acc</li>

      <li>2.  <span class="math">\\bar{f}(x) \\neq \\bar{Z}</span> , for the output  <span class="math">\\bar{f}</span>  of E.</li>

    </ul>

    <p class="text-gray-300">Hence knowledge soundness follows from the knowledge soundness of  <span class="math">\\mathsf{open}_{\\mathfrak{shplon}\\mathfrak{K}}</span> .</p>

    <p class="text-gray-300">The general case of multiple commitments and evaluation points is totally analogus. In summary, we get</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-9-0"></span><strong>Theorem 5.2.</strong> Fix positive integer A dividing p-1. Let T be the set of divisors of A; i.e.  $T:=\\{t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t\\leq A,t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\}<span class="math"> . Let <strong>S</strong> be the set of A&#x27;th powers in  </span>\\mathbb{F}<span class="math"> , i.e.  </span>\\mathbf{S}:=\\{x\\in\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists z\\in\\mathbb{F}\\ s.t.\\ z^t=x\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then there is a  <span class="math">(T, \\mathbf{S})</span> -PCS  <span class="math">\\mathscr{S} = (\\text{gen}, \\text{com}, \\text{open})</span>  over  <span class="math">\\mathbb{F}</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textit{1. } \\mathsf{gen}(d) \\textit{ is of the form: } \\textit{Choose uniform } x \\in \\mathbb{F}. \\textit{ Output } \\mathsf{srs} = ([1]_1, [x]_1, \\ldots, \\left[x^{A \\cdot d}\\right]_1, [1]_2, [x]_2).</span></li>

      <li>2. Let  <span class="math">\\bar{f} \\in (\\mathbb{F}_{&lt; d}[X])^t</span>  for  <span class="math">t \\in T</span> . Suppose  <span class="math">n = \\max_{i \\in [&lt; t]} [t \\cdot \\deg(f_i) + i]</span> . Then computing  <span class="math">\\operatorname{\\mathsf{com}}(1, f, \\operatorname{\\mathsf{srs}})</span>  requires n + 1  <span class="math">\\mathbb{G}_1</span> -exponentiations.</li>

      <li>3.  <span class="math">Fix\\ \\bar{t}, \\bar{\\bar{f}}, \\bar{\\bar{Z}}, \\bar{\\bar{\\bar{S}}}</span> .  <span class="math">Suppose\\ n_i = \\max_{j \\in [&lt; t_i]} [t \\cdot \\deg(f_{i,j}) + i]</span> .  <span class="math">Let\\ n := \\max_i [n_i]</span> . Then open  <span class="math">\\left(\\bar{t}, \\overline{\\mathsf{cm}}, \\bar{\\bar{Z}}, \\bar{\\bar{\\bar{S}}}; \\bar{f}\\right)</span>  requires</li>

      <li>(a)  <span class="math">2 \\mathbb{G}_1</span>  elements sent from P to V.</li>

      <li>(b) at most 2n + 1  <span class="math">\\mathbb{G}_1</span> -exponentiations of P.</li>

      <li>(c) r+2  <span class="math">\\mathbb{G}_1</span> -exponentiations and 2 pairings of V.</li>

    </ul>

    <h2 id="sec-15" class="text-2xl font-bold">6 Polynomial Protocols</h2>

    <p class="text-gray-300">At this point we move on to apply the new commitment scheme to the  <span class="math">\\mathscr{PlonK}</span>  proving system. We need to slightly alter some components from [GWC19] for this purpose. We warn that the following sections are hard to follow without an understanding of [GWC19].</p>

    <p class="text-gray-300">We begin by modifying the definition of polynomial protocols from [GWC19]. The changes are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We enable compiling protocols using a PCS where the opening set is limited by requiring the  <span class="math">\\{v_{i,j}\\}</span>  below do not map out of the set.</li>

      <li>We explicitly track the number of rounds of the protocol, as with the PCS of this paper this ends up being a crucial parameter for verifier efficiency.</li>

      <li>We don't assume the verifier only checks <em>one</em> polynomial identity, and this makes the notation a little more cumbersome. The reason we could assume this from a certain point in [GWC19] is that the compilation from ranged protocols always produced one identity. But using that compilation will hurt verifier efficiency here.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 6.1.</strong> Fix positive integers d, D, r, a subset T of positive integers, a vector  <span class="math">\\bar{t} \\in T^r</span> , and a subset  <span class="math">\\mathbf{S} \\subset \\mathbb{F}</span> . A  <span class="math">(d, D, r, T, \\bar{t}, \\mathbf{S})</span> -polynomial protocol over  <span class="math">\\mathbb{F}</span>  is an r-round protocol between a prover  <span class="math">P_{\\mathsf{poly}}</span> , a verifier  <span class="math">V_{\\mathsf{poly}}</span>  and ideal party  <span class="math">\\mathcal{F}</span>  that proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The protocol definition includes a set of preprocessed polynomials  <span class="math">\\bar{f}_0 = (f_{0,0}, \\dots, f_{0,t_0-1}) \\in (\\mathbb{F}_{&lt; d}[X])^{t_0}</span> .</li>

      <li>2. Each of the r rounds of interaction has the following form:</li>

      <li>At round i,  <span class="math">P_{poly}</span>  sends to  <span class="math">\\mathcal{F}</span>  a message  <span class="math">\\bar{f}_i \\in (\\mathbb{F}_{\\leq d}[X])^{t_i}</span> . If  <span class="math">P_{poly}</span>  sends a message not of this form, the protocol is aborted.</li>

      <li>The verifier responds with public random coins.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let ¯¯<sup>f</sup> := ( ¯fi)i≤<sup>r</sup> consist of the set of preprocessed polynomials together with the polynomials sent by Ppoly. At the end of the protocol, Vpoly may ask I if certain polynomial identities hold between the polynomials in ¯¯f. More specifically, each identity is of the form</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F_i(X) := G_i(X, h_{i,1}(v_{i,1}(X)), \\dots, h_{i,M}(v_{i,M}(X))) \\equiv 0,</span></div>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) the hi,j are elements of {fi,j}</li>

      <li>(b) The {vi,j} are polynomials with the property that whenever x ∈ S, we also have vi,j (x) ∈ S.</li>

      <li>(c) <sup>F</sup><sup>i</sup> <sup>∈</sup> <sup>F</sup><D[X] for every choice of ¯¯<sup>f</sup> made by <sup>P</sup>poly when following the protocol correctly.</li>

      <li>4. After receiving the answers from I regarding the identities, Vpoly outputs acc if all identities hold, and outputs rej otherwise.</li>

    </ul>

    <p class="text-gray-300">As in [\\[GWC19\\]](#page-17-1), we define polynomial protocols for relations in the natural way.</p>

    <p class="text-gray-300"><span id="page-11-0"></span>Definition 6.2. Given a relation R, a polynomial protocol for R is a polynomial protocol with the following additional properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. At the beginning of the protocol, Ppoly and Vpoly are both additionally given an input x. The description of Ppoly assumes possession of ω such that (x, ω) ∈ R.</li>

      <li>2. Completeness: If Ppoly follows the protocol correctly using a witness ω for x, Vpoly accepts with probability one.</li>

      <li>3. Knowledge Soundness: There exists an efficient E, that given access to the messages of Ppoly to I outputs ω such that, for any strategy of Ppoly, the probability of the following event is negl(λ).</li>

      <li>(a) Vpoly outputs acc at the end of the protocol, and</li>

      <li>(b) (x, ω) ∈/ R.</li>

    </ul>

    <p class="text-gray-300">Remark 6.3. At this point in [\\[GWC19\\]](#page-17-1) we defined a further abstraction of polynomial protocols on ranges and showed a reduction from them to polynomial protocols. We do not do this here, as this reduction from [\\[GWC19\\]](#page-17-1) adds a round to the protocol, which, as already mentioned above, hurts verifier efficiency which is the focus of this paper.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">6.1 From polynomial protocols to protocols against algebraic adversaries</h4>

    <p class="text-gray-300">We wish to use the polynomial commitment scheme of Section <a href="#page-7-0">5.1</a> to compile a polynomial protocol into one with knowledge soundness in the algebraic group model.</p>

    <p class="text-gray-300">For the purpose of capturing the efficiency of the transformation, we first define somewhat technical measures of a (d, D, r, T,t,¯ S)-polynomial protocol P.</p>

    <p class="text-gray-300">Let  <span class="math">M^{<strong>}</span>  be the number of distinct polynomials  <span class="math">\\{h_{i,j}(v_{i,j}(X))\\}</span>  appearing in the protocol in the identities  <span class="math">G_i(X, h_{i,1}(v_{i,1}(X)), \\ldots, h_{i,M}(v_{i,M}(X))) \\equiv 0</span>  checked by  <span class="math">V_{poly}</span>  in  <span class="math">\\mathscr{P}</span> . Let  <span class="math">M^* = M^{</strong>} - K</span> , where K is the number of identities such that  <span class="math">G_i</span>  is linear in  <span class="math">X_M</span> . For  <span class="math">i \\in [r]</span> , suppose  <span class="math">n_i = \\max_{j \\in [&lt; t_i]} [t_i \\cdot \\deg(f_{i,j}) + i]</span> , where the maximum is over  <span class="math">\\bar{f}_i</span>  sent by the honest prover in round i.</p>

    <p class="text-gray-300">Let  <span class="math">n(\\mathscr{P}) := \\max_i [n_i]</span> . Finally, define  <span class="math">e(\\mathscr{P}) := \\sum_{i &lt; r} n_i + 2n(\\mathscr{P}) + r</span> .</p>

    <p class="text-gray-300"><span id="page-12-0"></span><strong>Lemma 6.4.</strong> Let  <span class="math">\\mathscr{P}</span>  be a  <span class="math">(d, D, r, T, \\bar{t}, \\mathbf{S})</span> -polynomial protocol over  <span class="math">\\mathbb{F}</span>  for a relation  <span class="math">\\mathscr{R}</span> , where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $T = \\{t \\leq A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A\\}$  for a constant A dividing p 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>S</strong> is the set of A'th powers in  <span class="math">\\mathbb{F}</span> .</li>

    </ul>

    <p class="text-gray-300">Then we can construct a protocol  <span class="math">\\mathscr{P}^*</span>  for  <span class="math">\\mathscr{R}</span>  with knowledge soundness in the Algebraic Group Model under  <span class="math">2n(\\mathscr{P})</span> -DLOG such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The prover <strong>P</strong> in  <span class="math">\\mathscr{P}^*</span>  requires  <span class="math">e(\\mathscr{P})</span>   <span class="math">\\mathbb{G}_1</span> -exponentiations.</li>

      <li>2. The total prover communication consists of r+2  <span class="math">\\mathbb{G}_1</span>  elements and  <span class="math">M^*</span>   <span class="math">\\mathbb{F}</span> -elements.</li>

      <li>3. The verifier  <span class="math">\\mathbf{V}</span>  requires r+3  <span class="math">\\mathbb{G}_1</span> -exponentiations, two pairings, one evaluation of each  <span class="math">G_i</span>  checked in  <span class="math">\\mathscr{P}</span> , and one evaluation of each  <span class="math">v_{i,j}</span> .</li>

    </ul>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathscr{S} = (\\mathsf{gen}, \\mathsf{com}, \\mathsf{open})</span>  be the  <span class="math">(T, \\mathbf{S})</span> -polynomial commitment scheme described in Theorem 5.2. Let  <span class="math">\\bar{g} := (g_1, \\ldots, g_\\ell)</span> . The SRS of  <span class="math">\\mathscr{P}^*</span>  includes  <span class="math">\\mathsf{srs} = \\mathsf{gen}(d)</span> , with the addition of  <span class="math">\\mathsf{com}(\\bar{q})</span> .</p>

    <p class="text-gray-300">Given  <span class="math">\\mathscr{P}</span>  we describe  <span class="math">\\mathscr{P}^*</span> . <strong>P</strong> and <strong>V</strong> behave identically to  <span class="math">P_{\\mathsf{poly}}</span>  and  <span class="math">V_{\\mathsf{poly}}</span> , except the following changes</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As preprocessing, we compute the commitment  <span class="math">com(t_0, \\bar{f}_0)</span>  to the preprocessed polynomials and give this in advance to  <span class="math">\\mathbf{V}</span> .</li>

      <li>If in round i of  <span class="math">\\mathscr{P}</span> ,  <span class="math">P_{\\mathsf{poly}}</span>  sends the vector of polynomials  <span class="math">\\bar{f}_i \\in (\\mathbb{F}_{&lt; d}[X])^{t_i}</span>  to  <span class="math">\\mathscr{S}</span> , in  <span class="math">\\mathscr{P}^*</span>   <span class="math">\\mathbf{P}</span>  sends  <span class="math">\\mathsf{cm}_i = \\mathsf{com}(t_i, \\bar{f}_i)</span>  to  <span class="math">\\mathbf{V}</span> .</li>

      <li>When  <span class="math">V_{poly}</span>  asks in  <span class="math">\\mathscr{P}</span>  about the k identities</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">F_i(X) := G_i(X, h_{i,1}(v_{i,1}(X)), \\dots, h_{i,M}(v_{i,M}(X))) \\equiv 0,</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Let  <span class="math">v_1^<em>, \\ldots, v_{t^</em>}^*</span>  be the distinct polynomials amongst  <span class="math">\\{v_{i,j}\\}</span>  among the different identities.</li>

      <li>2. V chooses random  <span class="math">x \\in \\mathbf{S}</span> , computes  <span class="math">v_1^<em>(x), \\ldots, v_{t^</em>}^*(x)</span> , and sends x to P.</li>

      <li>3. <strong>P</strong> generally replies with  <span class="math">\\{s_{i,j}\\}_{i\\in[k],j\\in[M]}</span> , which are the alleged values  <span class="math">\\{h_{i,j}(v_{i,j}(x))\\}</span> . Note though that when  <span class="math">G_i</span>  is linear in  <span class="math">X_M</span> , there is no need to send the value  <span class="math">s_{i,M}</span>  as the unique value that will cause the equation to be satisfied can be computed by  <span class="math">V_{\\mathsf{poly}}</span>  herself.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-13-0"></span>4. V engages in the protocol open with P to verify the correctness of  <span class="math">\\{s_{i,j}\\}</span></li>

      <li>5. V outputs acc if and only if for each  <span class="math">i \\in [k]</span></li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">G_i(x, s_{i,1}, \\dots, s_{i,M}) = 0.</span></div>

    <p class="text-gray-300">The efficiency claims about  <span class="math">\\mathscr{P}^*</span>  follow directly from Theorem 5.2.</p>

    <p class="text-gray-300">To prove the claim about knowledge soundness in the AGM we must describe the extractor E for the protocol  <span class="math">\\mathscr{P}^*</span> . For this purpose, let  <span class="math">E_{\\mathscr{P}}</span>  be the extractor of the protocol  <span class="math">\\mathscr{P}</span>  as guaranteed to exist from Definition 6.2, and  <span class="math">E_{\\mathscr{S}}</span>  be the extractor for the Knowledge Soundness game of  <span class="math">\\mathscr{S}</span>  as in Definition 4.1.</p>

    <p class="text-gray-300">Now assume an algebraic adversary  <span class="math">\\mathcal A</span>  is taking the role of  <span class="math">\\mathbf P</span>  in  <span class="math">\\mathscr P^*.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. E sends the commitments  <span class="math">\\overline{\\mathsf{cm}}</span>  to  <span class="math">E_{\\mathscr{S}}</span>  and receives in return  <span class="math">\\overline{\\bar{f}} \\in (\\mathbb{F}_{&lt; d}[X])^{(2)}</span> .</li>

      <li>2. E plays the role of  <span class="math">\\mathcal{I}</span>  in interaction with  <span class="math">E_{\\mathscr{P}}</span> , sending him the polynomials  <span class="math">\\bar{f}</span> .</li>

      <li>3. When  <span class="math">E_{\\mathscr{D}}</span>  outputs  <span class="math">\\omega</span> , E also outputs  <span class="math">\\omega</span> .</li>

    </ul>

    <p class="text-gray-300">Now let us define two events (over the randomness of  <span class="math">\\mathbf{V},\\mathcal{A}</span>  and  <span class="math">\\mathsf{gen}</span> ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. We think of an adversary  <span class="math">\\mathscr{A}_{\\mathscr{P}}</span>  participating in  <span class="math">\\mathscr{P}</span> , and using the polynomials  <span class="math">\\bar{f}</span>  as their messages to  <span class="math">\\mathscr{F}</span> . We define A to be the event that one of the identities  <span class="math">F_i</span>  held, but  <span class="math">(\\mathsf{x},\\omega) \\notin \\mathscr{R}</span> . By the KS of  <span class="math">\\mathscr{P}</span> ,  <span class="math">\\Pr(A) = \\mathsf{negl}(\\lambda)</span> .</li>

      <li>2. We let B be the event that for some  <span class="math">i \\in [k], j \\in [M], h_{i,j}(v_{i,j}(x)) \\neq s_{i,j}</span> , and at the same time V has output acc when open was run as a subroutine in Step 4. By the KS of  <span class="math">\\mathscr{S}</span> ,  <span class="math">\\Pr(B) = \\mathsf{negl}(\\lambda)</span> .</li>

    </ul>

    <p class="text-gray-300">Now look at the event C that  <span class="math">\\mathbf{V}</span>  outputs  <span class="math">\\mathsf{acc}</span> , but E failed in the sense that  <span class="math">(\\mathsf{x},\\omega) \\notin \\mathcal{R}</span> . We split C into two events.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. A or B also happened this has  <span class="math">negl(\\lambda)</span>  probability.</li>

      <li>2. C happened but not A or B. This means that for some  <span class="math">i \\in [k]</span> ,  <span class="math">F_i</span>  is not the zero polynomial, but  <span class="math">F_i(x) = 0</span> ; which happens w.p.  <span class="math">\\deg(F_i) \\cdot A/p</span>  which is  <span class="math">\\operatorname{negl}(\\lambda)</span> .</li>

    </ul>

    <h2 id="sec-17" class="text-2xl font-bold">7 Polynomial protocol for constraint system satisfiability</h2>

    <p class="text-gray-300">As in Section 6 and 7 of [GWC19], we work with a constraint system  <span class="math">\\mathscr{C} = (\\mathscr{V}, \\mathscr{Q})</span>  where  <span class="math">\\mathscr{Q} = (\\mathbf{q_L}, \\mathbf{q_R}, \\mathbf{q_O}, \\mathbf{q_M}, \\mathbf{q_C}) \\in (\\mathbb{F}^n)^5</span>  are our "Selector vectors"; and  <span class="math">\\mathscr{V}</span>  implicitly describe a permutation on [3n].</p>

    <p class="text-gray-300">We present a slightly modified polynomial protocol for the relation  <span class="math">\\mathscr{R}_{\\mathscr{C}}</span>  described in [GWC19]; which is the set of pairs  <span class="math">(\\mathsf{x},\\omega)</span>  with  <span class="math">\\mathsf{x}\\in\\mathbb{F}^\\ell,\\omega\\in\\mathbb{F}^{m-\\ell}</span>  such that  <span class="math">\\mathsf{x}:=(\\mathsf{x},\\omega)</span>  satisfies  <span class="math">\\mathscr{C}</span> . The difference from [GWC19] is that we do not wish to use their reduction from ranged polynomial protocols to polynomial protocols, as this adds a round of</p>

    <p class="text-gray-300">interaction, which ends up adding a verifier scalar multiplication in the compiled protocol against algebraic adversaries. Instead, we need to explicitly describe sending the quotient polynomial involved in each of three identities checked. We assume below n is a power of two such that 24n divides p − 1, and H ⊂ F is a multiplicative subgroup of F of order n with generator g. Note that our divisibility assumption implies g is a 24'th power inF.</p>

    <p class="text-gray-300">Preprocessed polynomials: The polynomials Sσ<sup>1</sup> , Sσ<sup>2</sup> , Sσ<sup>3</sup> describing the permutation derived from C as in Section 8 of [\\[GWC19\\]](#page-17-1). (As explained there, the polynomials describing the identity permutation can be computed in log n time directly by the verifier.) The polynomials qL, qR, qO, qM, q<sup>C</sup> ∈ F<n[X] (as in [\\[GWC19\\]](#page-17-1), we identify the vectors with polynomials obtaining the vector values on H).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Protocol:</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let x ∈ F <sup>m</sup> be Ppoly's assignment consistent with the public input x. Ppoly computes the three polynomials fL, fR, f<sup>O</sup> ∈ F<n[X], where for i ∈ [n]</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f_L(i) = \\mathbf{x}_{\\mathbf{a}_i}, f_R(i) = \\mathbf{x}_{\\mathbf{b}_i}, f_O(i) = \\mathbf{x}_{\\mathbf{c}_i}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ppoly and Vpoly compute the "Public input polynomial"</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PI}(X) := \\sum_{i \\in [\\ell]} -\\mathsf{x}_i \\cdot L_i(X).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ppoly computes the quotient polynomial T0(X) showing fL, fR, f<sup>O</sup> satisfy the arithmetic constraint; i.e.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\mathbf{q_L}(X) \\cdot f_L(X) + \\mathbf{q_R}(X) \\cdot f_R(X) + \\mathbf{q_O}(X) \\cdot f_O(X) + \\mathbf{q_M}(X) \\cdot f_L(X) \\cdot f_R(X) + (\\mathbf{q_C}(X) + \\mathsf{PI}(X))}{Z_H(X)}</span></div>

    <p class="text-gray-300">Ppoly sends ¯f<sup>1</sup> = (fL, fR, fO, T0) to I.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4. Ppoly and Vpoly run an extended permutation check protocol as in [\\[GWC19\\]](#page-17-1), using the permutation σ between (fL, fR, fO) and itself. As explained in Section 5 of [\\[GWC19\\]](#page-17-1), this exactly checks whether (fL, fR, fO) copy-satisfies T<sup>C</sup> . More precisely,</li>

      <li>(a) Vpoly chooses random β, γ ∈ F and sends them to Ppoly.</li>

      <li>(b) Let f 0 j := f<sup>j</sup> + β · SID<sup>j</sup> + γ, and g 0 j := g<sup>j</sup> + β · Sσj + γ. That is, for j ∈ {L, R, O} , i ∈ [n]</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f_j&#x27;(\\mathbf{g}^i) = f_j(\\mathbf{g}^i) + \\beta((j-1)\\cdot n + i) + \\gamma, g_j&#x27;(\\mathbf{g}^i) = g_j(\\mathbf{g}^i) + \\beta\\cdot\\sigma((j-1)\\cdot n + i) + \\gamma</span></div>

    <p class="text-gray-300">(c) Define f 0 , g<sup>0</sup> ∈ F<3n[X] by</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;(X) := \\prod_{j \\in \\{L,R,O\\}} f&#x27;_j(X), g&#x27;(X) := \\prod_{j \\in \\{L,R,O\\}} g&#x27;_j(X).</span></div>

    <p class="text-gray-300">(d) Ppoly computes Z ∈ F<n[X], such that Z(g) = 1; and for i ∈ {2, . . . , n}</p>

    <div class="my-4 text-center"><span class="math-block">Z(\\mathbf{g}^i) = \\prod_{1 \\le \\ell &lt; i} f&#x27;(\\mathbf{g}^j) / g&#x27;(\\mathbf{g}^j).</span></div>

    <p class="text-gray-300">(e) Ppoly computes the quotients T1, T<sup>2</sup> showing that Z "starts from one" and that Z accumulates the values of f /g. Namely,</p>

    <div class="my-4 text-center"><span class="math-block">T_1(X) := (L_1(X)(Z(X) - 1))/Z_H(X) = 0</span></div>

    <div class="my-4 text-center"><span class="math-block">T_2(X) := (Z(X)f&#x27;(X) - g&#x27;(X)Z(X \\cdot \\mathbf{g}))/Z_H(X)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(f) Ppoly sends ¯f<sup>1</sup> = (Z, T1, T2) to I.</li>

      <li>(g) Vpoly checks the following three identities i.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{q_L}(X) \\cdot f_L(X) + \\mathbf{q_R}(X) \\cdot f_R(X) + \\mathbf{q_O}(X) \\cdot f_O(X) + \\mathbf{q_M}(X) \\cdot f_L(X) \\cdot f_R(X) + (\\mathbf{q_C}(X) + \\mathsf{PI}(X))</span></div>

    <div class="my-4 text-center"><span class="math-block">= T_0(X) \\cdot Z_H(X)</span></div>

    <p class="text-gray-300">ii.</p>

    <div class="my-4 text-center"><span class="math-block">L_1(X)(Z(X) - 1) = T_1(X)Z_H(X)</span></div>

    <p class="text-gray-300">iii.</p>

    <div class="my-4 text-center"><span class="math-block">Z(X)f&#x27;(X) - g&#x27;(X)Z(X \\cdot \\mathbf{g}) = T_2(X)Z_H(X)</span></div>

    <p class="text-gray-300">and outputs acc iff all checks hold.</p>

    <p class="text-gray-300">Using the analysis of [\\[GWC19\\]](#page-17-1) we get</p>

    <p class="text-gray-300">Theorem 7.1. The above is a polynomial protocol for the relation R<sup>C</sup> .</p>

    <p class="text-gray-300">Now using Lemma <a href="#page-12-0">6.4</a> we get</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 7.2. Assume the Q-DLOG for Q = 18 · n. Assume 24</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(p − 1). Then there is a protocol for the relation R<sup>C</sup> with Knowledge Soundness in the Algebraic Group Model such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The prover P requires 35n G1-exponentiations.</li>

      <li>2. The total prover communication consists of 4 G1-elements and 15 F-elements.</li>

      <li>3. The verifier requires 6 G1-exponentiations and two pairings.</li>

    </ul>

    <p class="text-gray-300">Proof. We need to simply compute the parameters we are plugging into Lemma <a href="#page-12-0">6.4</a> when using the above protocol P. The number of rounds r is two. We have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>n<sup>0</sup> = maxj<<sup>8</sup> [8 · (n − 1) + j] < 8n</li>

      <li>n<sup>1</sup> = max {4 · deg(fL), 4 · deg(fR) + 1, 4 · deg(fO) + 2, 4 · deg(T0) + 2} < 8n</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>n<sup>2</sup> = max {3 · deg(Z), 3 · deg(T1) + 1, 3 · deg(T2) + 2} < 9n</li>

      <li>n(P) = max {n0, n1, n2} < 9n</li>

    </ul>

    <p class="text-gray-300">Now, from Lemma <a href="#page-12-0">6.4</a> we know that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The prover requires e(P) = n<sup>1</sup> + n<sup>2</sup> + 2n(P) + r ≤ 35n G1-exponentiations.</li>

      <li>2. The total prover communication consists of r + 2 = 4 G<sup>1</sup> elements and M<sup>∗</sup> = 15 F-elements.(Opening qL, qR, qO, qM, qC, Sσ<sup>1</sup> , Sσ<sup>2</sup> , Sσ<sup>3</sup> , fL, fR, fO, Z at x and Z, T1, T<sup>2</sup> at gx.)</li>

      <li>3. The verifier V requires r + 3 = 5 G1-exponentiations.</li>

    </ul>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">Acknowledgements</h3>

    <p class="text-gray-300">We thank Sergey Vasilyev for a correction.</p>

    <h2 id="sec-20" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-16-6"></span>[BDFG] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Halo infinite: Proof-carrying data from additive polynomial commitments. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part I.</li>

      <li><span id="page-16-4"></span>[BDFG20] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. IACR Cryptol. ePrint Arch., page 81, 2020.</li>

      <li><span id="page-16-2"></span>[BFS19] B. B¨unz, B. Fisch, and A. Szepieniec. Transparent snarks from DARK compilers. IACR Cryptology ePrint Archive, 2019:1229, 2019.</li>

      <li><span id="page-16-5"></span>[BGM17] S. Bowe, A. Gabizon, and I. Miers. Scalable multi-party computation for zksnark parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. <https://eprint.iacr.org/2017/1050>.</li>

      <li><span id="page-16-3"></span>[But] V. Buterin. https://vitalik.ca/general/2021/01/05/rollup.html.</li>

      <li><span id="page-16-1"></span>[CHM+19] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. P. Ward. Marlin: Preprocessing zksnarks with universal and updatable SRS. IACR Cryptology ePrint Archive, 2019:1047, 2019.</li>

      <li><span id="page-16-0"></span>[Gab19] A. Gabizon. Auroralight:improved prover efficiency and SRS size in a soniclike system. IACR Cryptology ePrint Archive, 2019:601, 2019.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-17-3"></span>[GKM+] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers. Updatable and universal common reference strings with applications to zk-snarks. IACR Cryptology ePrint Archive, 2018.</li>

      <li><span id="page-17-1"></span>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. PLONK: permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptology ePrint Archive, 2019:953, 2019.</li>

      <li><span id="page-17-0"></span>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size commitments to polynomials and their applications. Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings, pages 177–194, 2010.</li>

      <li><span id="page-17-2"></span>[MBKM19] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zeroknowledge snarks from linear-size universal and updateable structured reference strings. IACR Cryptology ePrint Archive, 2019:99, 2019.</li>

    </ul>`;
---

<BaseLayout title="fflonk: a Fast-Fourier inspired verifier efficient version o... (2021/1167)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/1167
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="fflonk-a-fast-fourier-inspired-verifier-efficient-version-2021" />
  </article>
</BaseLayout>
