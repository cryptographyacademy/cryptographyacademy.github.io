---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1245';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Garuda and Pari: Faster and Smaller SNARKs via Equifficient Polynomial Commitments';
const AUTHORS_HTML = 'Michel Dellepere, Pratyush Mishra, Alireza Shirzad';

const CONTENT = `    <p class="text-gray-300">Michel Dellepere michel@provable.com Provable Pratyush Mishra prat@upenn.edu UPenn Alireza Shirzad alrshir@upenn.edu UPenn</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">SNARKs are powerful cryptographic primitives that allow a prover to produce a succinct proof of a computation. Two key goals of SNARK research are to minimize the size of the proof and to minimize the time required to generate the proof. In this work, we present new SNARK constructions that push the frontier on both of these goals.</p>

    <p class="text-gray-300">Our first construction, PARI, is a SNARK that achieves the smallest proof size amongst <em>all</em> known SNARKs. Specifically, PARI achieves a proof size of just two group elements and two field elements, which, when instantiated with the BLS12-381 curve, totals just 160 bytes, smaller than that of Groth16 <em>[Groth, EUROCRYPT ’16]</em> and Polymath <em>[x10]</em>.</p>

    <p class="text-gray-300">Our second construction, GARUDA, is a SNARK that reduces proof generation time by supporting, for the first time, arbitrary “custom” gates and <em>free</em> linear gates. To demonstrate GARUDA’s performance, we implement and evaluate it, and show that it provides significant prover-time savings compared to both the state-of-the-art SNARKs (Groth16 and HyperPlonk <em>[EUROCRYPT ’23]</em>)</p>

    <p class="text-gray-300">Both constructions rely on a new cryptographic primitive: “equifficient” polynomial commitment schemes that enforce that committed polynomials have the same representation in particular bases. We provide both rigorous security definitions for this primitive as well as efficient constructions for univariate and multilinear polynomials.</p>

    <p class="text-gray-300">Keywords: succinct arguments; polynomial interactive oracle proofs; custom gates; equifficient polynomial commitments</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Our contributions  3 1.2 Related work  4</p>

    <p class="text-gray-300">2  Techniques  7 2.1 Generalizing R1CS  8 2.2 New tool: Equfficient polynomial commitments  9 2.3 SNARKs from equfficient polynomial commitments  10 2.4 Constructing PARI  12 2.5 Constructing GARUDA  14 2.6 Implementation  15 2.7 Evaluation  15</p>

    <p class="text-gray-300">3  Preliminaries  19 3.1 Algebraic background  19 3.2 Cryptographic assumptions  20 3.3 Indexed relations  21 3.4 Polynomial interactive oracle proofs  23 3.5 Succinct arguments of knowledge  24</p>

    <p class="text-gray-300">4  Equfficient polynomial commitments  25 4.1 Definition  25 4.2 EPC scheme for univariate polynomials  27 4.3 EPC scheme for multilinear polynomials  33</p>

    <p class="text-gray-300">5  SNARKs for GR1CS from EPC schemes  39 5.1 Construction  39</p>

    <p class="text-gray-300">6  PARI: a 2-group element SNARK for NP  44 6.1 Univariate PIOP for SR1CS rowcheck  44 6.2 Unrolled SNARK  44</p>

    <p class="text-gray-300">7  GARUDA: a linear-time prover SNARK for GR1CS  47 7.1 Multilinear PIOP for Stacked rowcheck  47 7.2 Unrolled SNARK  48</p>

    <p class="text-gray-300">Acknowledgments  51</p>

    <p class="text-gray-300">References  51</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300"><em>Succinct Non-interactive ARguments of Knowledge</em> (SNARKs) are cryptographic proofs that enable a prover to efficiently convince a computationally weak verifier of claims of the form “Given a program <span class="math">P</span> and public input <span class="math">\\mathtt{x}</span>, I know a private input <span class="math">\\mathtt{w}</span> such that <span class="math">P(\\mathtt{x},\\mathtt{w})=1</span>”. Two fundamental metrics in the study of SNARKs are <em>proof size</em> and <em>prover time</em>.</p>

    <p class="text-gray-300">Proof size. From the proof-size perspective, the state-of-the-art SNARK is that of Groth <em>[x13]</em>, henceforth referred to as Groth16. The latter achieves the smallest proof size amongst all known SNARKs: just three group elements. When instantiated with the BLS12-381 curve, Groth16 proofs are just <span class="math">1536</span> bits.</p>

    <p class="text-gray-300">An important open question has thus been: what is the shortest proof size for a SNARK for NP?</p>

    <p class="text-gray-300">Prover time. From a prover time perspective, all known SNARKs require time at least linear in the size of the circuit <span class="math">C</span> being proven, and so much effort has been invested in reducing the size of <span class="math">C</span>. An important line of work in this direction has been the study of more expressive circuits that support “custom” gates that can compute arbitrary functions of their inputs, rather than just addition and multiplication. Examples of such gates include high-degree polynomial gates <em>[x12]</em> and lookup gates <em>[x14]</em>. State-of-the-art SNARKs are able to prove such expressive circuits in time linear in the circuit size <em>[x5, x27]</em>. Unfortunately, the proving algorithms of these SNARKs perform cryptographic operations that scale with the number of linear <em>and</em> non-linear gates in the circuit. In contrast, prior SNARKs for simpler circuit models <em>[x11, x13]</em> only pay cryptographic costs for non-linear gates, and are able to prove linear gates “for free”. A key open question in the literature has been whether we can obtain the best of both worlds and construct SNARKs that support both custom gates <em>and</em> free linear gates.</p>

    <p class="text-gray-300">This question is interesting from both theoretical and practical perspectives. From a theory standpoint, cheap linear gates would align custom-gate SNARKs not only with prior SNARKs <em>[x11, x13]</em>, but also with other cryptographic primitives such as MPC <em>[x6, x19]</em> and FHE <em>[x10]</em> where linear operations are often much cheaper than non-linear ones. From a practical perspective, linear gates can impose a significant cost in practice, and so eliminating cryptographic costs for them can lead to significant performance improvements. Indeed, we show in Section 2.7 that constraint systems that support free linear gates can be much smaller than those that do not.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our contributions</h3>

    <p class="text-gray-300">In this work, we answer all the foregoing questions in the affirmative by constructing two new SNARKs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Pari: a SNARK whose proofs consist of <span class="math">2</span> group elements and <span class="math">2</span> field elements; over BLS12-381 this requires just <span class="math">1280</span> bits.</li>

      <li>Garuda: a SNARK that supports custom gates and free linear gates with a linear-time prover.</li>

    </ul>

    <p class="text-gray-300">We detail the ideas behind these SNARKs next.</p>

    <p class="text-gray-300">Pari: a 2-group element SNARK. Pari is a new SNARK for ‘square’ R1CS <em>[x15]</em> that achieves a proof size of two group elements (and two field elements). When instantiated with the BLS12-381 curve, Pari achieves a proof size of just 1280 bits, which is the smallest in the literature. More generally, no matter the choice of pairing-friendly curve, Pari’s proof size is always smaller than that of the state-of-the-art prior work <em>[x13, x16]</em>. The prover and verifier times for Pari are also similar to those for Groth16 <em>[x13]</em>: for a circuit of size <span class="math">n</span>, Pari’s prover requires <span class="math">O(n\\log n)</span> field operations and <span class="math">O(n)</span> group operations, while its verifier requires <span class="math">O(1)</span> pairings. We prove (an interactive version of) Pari secure in the algebraic group model (AGM) <em>[x10]</em>.</p>

    <p class="text-gray-300">###</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Garuda: custom gates and free linear gates.</h5>

    <p class="text-gray-300">Garuda is a SNARK for Generalized Rank-1 Constraint Satisfiability (GR1CS), an NP-complete language that we introduce, and which extends the popular Rank-1 Constraint Satisfiability (R1CS) language with support for custom gates. For a constraint system of size <span class="math">n</span>, Garuda achieves <span class="math">O(n)</span> prover time and <span class="math">O(\\log n)</span> proof size and verifier time. Like Pari, we prove an interactive version of Garuda secure in the AGM.</p>

    <h5 id="sec-6" class="text-base font-semibold mt-4">New methodology: SNARKs from equifficient polynomial commitments.</h5>

    <p class="text-gray-300">We present a methodology for constructing SNARKs for GR1CS that extends the popular ‘PIOP + PC <span class="math">\\rightarrow</span> SNARK’ framework <em>[CHMMV+20, BFS+20]</em> to work with a new kind of polynomial commitment scheme that enforces “equal-coefficient”, or <em>equifficient</em>, constraints. Roughly, such equifficient polynomial commitment (EPC) schemes enforce the additional property that given a batch of polynomials <span class="math">p_{1},\\ldots,p_{n}</span> and associated bases <span class="math">\\mathscr{B}_{1},\\ldots,\\mathscr{B}_{n}</span>, the coefficient vectors of these polynomials in their respective bases are equal.</p>

    <p class="text-gray-300">Our new ‘PIOP + EPC <span class="math">\\rightarrow</span> SNARK’ methodology leverages EPC schemes to enforce linear constraints, as opposed to prior PIOP-based SNARKs <em>[CHMMV+20, Set20]</em> which use complex PIOPs for this task. This shift enables SNARK constructions that can use simpler PIOPs that are responsible only for non-linear checks.</p>

    <p class="text-gray-300">We extend the popular KZG <em>[KZG+10]</em> and PST <em>[PST+13]</em> PC schemes to construct EPC schemes for univariate and multilinear polynomials respectively. Our constructions support commitment batching, which is crucial for attaining the small proof size in our construction of Pari. Our constructions are inspired by techniques from prior “Linear PCP”-based SNARKs <em>[BCIO+13]</em>. We believe that our EPC schemes could find application in places where PC schemes are used today (e.g., verifiable secret sharing); we leave these explorations to future work.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Implementation and evaluation.</h5>

    <p class="text-gray-300">We implement Garuda in a new library built atop the arkworks framework <em>[arkworks]</em>. Our library flexibly extends the constraint-writing framework of arkworks to support GR1CS. We use our implementation to compare the performance of Garuda to two baselines: Groth16, a SNARK with free linear gates but no support for custom gates, and HyperPlonk <em>[CBBZ+23]</em>, a SNARK that supports custom gates, but does not have free linear gates. When benchmarked on the same computation (iterations of the Rescue-Prime <em>[SAD+20]</em> hash function), our implementation of Garuda is almost <span class="math">5\\times</span> faster than Groth16 and <span class="math">2.67\\times</span> faster than HyperPlonk, thus demonstrating that the combination of free linear gates and custom gates indeed leads to much faster proving times.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Remark 1.1 (circuit-specific setup).</h6>

    <p class="text-gray-300">Garuda, unlike all prior SNARKs for custom gates, requires <em>circuit-specific</em> setup to sample the proving and verification keys. Indeed, universal setup suffices for all prior SNARKs that support custom gates <em>[GWC+19, CBBZ+23]</em>, and in fact some prior works <em>[STW+23]</em> can even be instantiated with a <em>transparent</em> setup. However, as stated above, none of these works are able to avoid cryptographic prover work for linear gates. In fact, it is an important open problem to construct a universal-setup SNARK even for <em>standard</em> circuits (i.e. without custom gates) that is able to avoid the latter costs.</p>

    <p class="text-gray-300">Pari also requires a circuit-specific trusted setup, but the relevant prior work (namely, Groth16) also require such a setup. Achieving proof size similar to Groth16 without a circuit-specific setup is again an important open problem.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <p class="text-gray-300">Campanelli et al. <em>[CFQ+19]</em> describe a “linear-subspace” SNARK that shows that multiple commitments commit to the same vector. Their technique is similar to how our equifficient polynomial commitment schemes enforce that the coefficients of committed polynomials are equal, but does not seem to support</p>

    <p class="text-gray-300">important features such as commitment batching and enforcing that the committed polynomials are in particular bases.</p>

    <p class="text-gray-300">In the rest of this section, we discuss work related to our specific SNARKs.</p>

    <p class="text-gray-300">As discussed in Section 1, Groth16 [Gro16] is the state-of-the-art SNARK with the smallest proof size: just three group elements. PARI improves upon this as its proof consists of just two group elements and two scalar field elements, and is always at most as large as a Groth16 proof. As noted above, PARI's proof size is smaller than Groth16 when instantiated with the BLS12-381 curve. Groth also proved a lower bound on the size of pairing-based SNARKs: every such SNARK must have a proof size of at least two group elements [Gro16]. However, Groth's lower bound only applies to SNARKs that rely only on the generic group model, and so does not apply to PARI which relies on the AGM and the ROM. Interesting open questions include achieving a two-group element SNARK in the generic group model and extending Groth's lower bound to apply also in the joint AGM + ROM. Either result would demonstrate the tightness of Groth's lower bound (either via the new construction, or via PARI).</p>

    <p class="text-gray-300">Concurrent work. A concurrent work [Lip24] constructs Polymath, a SNARK with proof size consisting of three  <span class="math">\\mathbb{G}_1</span>  elements and one  <span class="math">\\mathbb{F}</span>  element. Over the BLS12-381 curve, Polymath proofs require 1408 bits, which is smaller than Groth16 proofs (1536 bits), but is larger than PARI proofs (1280 bits). Polymath implicitly uses similar "equal-coefficient" checks as PARI, but does not formalize these into a separate primitive as we do, and also does not support commitment batching. On the other hand, Polymath supports zero-knowledge, and proves security directly in the AGM with oblivious sampling (AGMOS) [LPS23], whereas we prove security only in the AGM. While we believe that PARI can be extended to support zero-knowledge and can be proven secure in the AGMOS, we leave this for future work.</p>

    <p class="text-gray-300">We provide an asymptotic comparison of PARI with Groth16 and Polymath in Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Groth16 [Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 MSMs of size m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">) muls + 3 pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 MSM of size m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Polymath [Lip24]</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">14 MSMs of size m</td>

            <td class="px-3 py-2 border-b border-gray-700">3 pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PARI [ours]</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4 MSMs of size 2m</td>

            <td class="px-3 py-2 border-b border-gray-700">3 pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of small-proof-size SNARKs. Above  <span class="math">m</span>  is the number of multiplication gates.</p>

    <p class="text-gray-300">Other related work. Barta et al. [BIOW20] constructed a designated-verifier SNARK that achieves two-group elements in the designated verifier setting, but by relaxing their soundness error to be nonnegligible. They also provide a construction that achieves a single group element SNARK, but by relying on a non-standard assumption, and furthermore by settling for non-negligible completeness error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, a line of work [BISW17; BISW18] constructed succinct designated-verifier proofs from lattice assumptions. They are able to achieve "quasi-optimal" SNARKs where the proof size is  <span class="math">O(\\lambda)</span>  and the prover time is  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathrm{polylog}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Nitulescu [Nit19] showed how to construct an LIP for Square Arithmetic Programs [GM17] that achieves a query complexity of just two. Nitulescu shows that when after applying to this LIP the methodology of Bitansky et al. [BCIOP13], the resulting SNARK achieves a proof size of two lattice ciphertexts. Groth [Gro16] and Groth and Maller [GM17] note that applying this idea to groups with Type-I pairings results in a two-group element SNARK. This work focuses on the more challenging setting of Type-III pairings, for which no prior two-group element SNARK was known.</p>

    <p class="text-gray-300">TurboPlonk [GW19] introduced the concept of "high-degree" polynomial gates in circuits. These gates compute arbitrary (fixed) polynomials of the input wires, and can be used to construct smaller circuits for certain computations. Plookup [GW20] introduced the concept of "lookup" gates, which check whether the input wires are in a predefined table. Subsequent work showed how to combine these two kinds of gates in a single constraint system [PFBM22; XCZBFKC23]. All these works require quasilinear prover time, and so we next discuss the works that improve upon this to achieve linear prover time.</p>

    <p class="text-gray-300">HyperPlonk [CBBZ23] constructed the first SNARK for custom gates with linear prover time. We provide an asymptotic comparison of HyperPlonk with GARUDA in Table 2.</p>

    <p class="text-gray-300">Setty, Thaler, and Wahby [STW23] introduced a generalization of R1CS that they call "Customizable Constraint Systems" (CCS), and described how to generalize the Spartan SNARK [Set20] to support CCS. The resulting SNARK, SuperSpartan, also achieves linear prover time. Our generalization of R1CS (GR1CS) subsumes both CCS and its variant  <span class="math">\\mathrm{CCS + }</span>  which additionally supports lookup gates, and we find it easier to work with. Indeed, we were able to easily extend the arkworks framework to support GR1CS, inheriting all the existent gadgets for R1CS "for free." Notably, we know of no implementations of CCS or  <span class="math">\\mathrm{CCS + }</span> .</p>

    <p class="text-gray-300">As noted in Section 1, all the foregoing works must pay cryptographic proving costs (e.g., group scalar multiplications) for linear gates. In contrast, GARUDA avoids these costs. We provide an asymptotic comparison of GARUDA with HyperPlonk and SuperSpartan in Table 2. We provide an empirical comparison of GARUDA with HyperPlonk in Section 2.7 which demonstrates that GARUDA achieves almost  <span class="math">3 \\times</span>  lower proving times.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">construction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">universal setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperPlonk [CBBZ23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(η(t+d log2d))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+t log η)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+d log η)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t) MSMs of size η</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t) muls + O(log η) pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+ log η)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSpartan [STW23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m(t+d log2d)+ηt)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+t log η)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+d log η)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) MSMs of size tη</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log tη) pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log tη)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GARUDA [ours]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m(t+d log2d)+ηt)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+t log η)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+d log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t) MSMs of size m</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+ log m) pairings</td>

            <td class="px-3 py-2 border-b border-gray-700">O(t+ log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">m</span>  : number of non-linear gates  <span class="math">\\eta</span>  : total number of gates  <span class="math">(= \\Omega (m))</span> <span class="math">t</span> : maximum arity of any custom gate  <span class="math">d</span> : maximum degree of any (polynomial) custom gate</p>

    <p class="text-gray-300">Table 2: Comparison of SNARKs with custom gate support. Here MSM (multi-scalar multiplication) denotes the time to compute the sum  <span class="math">\\sum_{i} s_{i} P_{i}</span> , where  <span class="math">s_{i}</span>  are scalars and  <span class="math">G_{i}</span>  are group elements.</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We obtain both Garuda and Pari by instantiating a generic framework for constructing SNARKs for GR1CS, a straightforward generalization of Rank-1 Constraint Satisfiability (R1CS), which is the constraint system of choice for many SNARKs <em>[x13, x12, x14, x15, x16]</em>. To describe our generalization and how we construct SNARKs for it, we first recall R1CS and how SNARKs for R1CS are constructed.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Background: R1CS.</h4>

    <p class="text-gray-300">Recall that the indexed NP relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of triples <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})=((\\mathbb{F},m,A,B,C),x,w)</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">A,B,C</span> are matrices in <span class="math">\\mathbb{F}^{m\\times m}</span>, and <span class="math">z:=(x,w)\\in\\mathbb{F}^{m}</span> satisfies <span class="math">Az\\circ Bz=Cz</span>.</p>

    <p class="text-gray-300">In R1CS, addition gates are captured via the linear combinations introduced by the matrix-vector products <span class="math">Az,Bz,Cz</span>, while multiplication gates are captured by the Hadamard product relation between the latter. Thus, a SNARK with “free” addition gates for R1CS would pay cryptographic prover costs that scale only with the cost of the Hadamard product, as opposed to costs that scale also with those of the matrix-vector multiplications. In other words, the cryptographic work of such a SNARK scales with the number of rows in the matrix, as opposed to the number of non-zero entries in the matrix.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Background: circuit-specific-SNARKs for R1CS.</h4>

    <p class="text-gray-300">The checks performed by all existing SNARKs for R1CS can be decomposed into two complimentary kinds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Linear checks (linchecks) that enforce that there exist vectors <span class="math">z,z_{A},z_{B},z_{C}</span> satisfying <span class="math">z_{A}=Az</span>, <span class="math">z_{B}=Bz</span>, and <span class="math">z_{C}=Cz</span>, and</li>

      <li>Non-linear row-wise checks (rowchecks) that enforce that <span class="math">z_{A}\\circ z_{B}=z_{C}</span>.</li>

    </ul>

    <p class="text-gray-300">Existing circuit-specific SNARKs perform these checks as follows.</p>

    <p class="text-gray-300">For linear checks, these SNARKs rely on the following probabilistic test for each matrix <span class="math">M\\in\\{A,B,C\\}</span>: <span class="math">\\langle\\bm{r},z_{M}\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\langle\\bm{r}^{\\top}M,z\\rangle</span>, where <span class="math">\\bm{r}</span> is a random vector sampled uniformly at random from <span class="math">\\mathbb{F}^{m}</span>. In fact, for efficiency, the random vector <span class="math">\\bm{r}</span> is replaced by <span class="math">\\bm{\\mathcal{L}}^{K}(\\tau)</span>, which is a vector whose <span class="math">i</span>-th element is the <span class="math">i</span>-th Lagrange polynomial <span class="math">\\mathcal{L}^{K}_{i}(X)</span> evaluated at a field element <span class="math">\\tau</span> sampled uniformly at random from <span class="math">\\mathbb{F}\\setminus K</span> (<span class="math">K</span> is an appropriate subset of <span class="math">\\mathbb{F}</span> of size equal to the number of constraints <span class="math">m</span>). The check thus becomes <span class="math">\\langle\\bm{\\mathcal{L}}^{K}(\\tau),z_{M}\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\langle\\bm{\\mathcal{L}}^{K}(\\tau)^{\\top}M,z\\rangle</span>, and its soundness follows from the Schwartz–Zippel lemma <em>[x25, x26]</em>.</p>

    <p class="text-gray-300">To construct a SNARK from this check, the key insight in prior work <em>[x13]</em> is that the special form of the vector <span class="math">\\bm{\\mathcal{L}}^{K}(X)</span> allows us to write the foregoing check as <span class="math">\\langle\\bm{\\mathcal{L}}^{K}(\\tau),z_{M}\\rangle=\\langle\\bm{m}(\\tau),z\\rangle</span>, where <span class="math">\\bm{m}(X)</span> is the vector whose <span class="math">i</span>-th element <span class="math">m_{i}(X)=\\langle\\bm{\\mathcal{L}}^{K}(X),M_{i}\\rangle</span> is the polynomial interpolating the <span class="math">i</span>-th column of <span class="math">M</span>. For efficiency, these checks can then be further batched together via random coefficients <span class="math">\\alpha_{A},\\alpha_{B},\\alpha_{C}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\sum_{M\\in\\{A,B,C\\}}\\alpha_{M}\\cdot\\langle\\bm{\\mathcal{L}}^{K}(\\tau),z_{M}\\rangle=\\langle\\sum_{M\\in\\{A,B,C\\}}\\alpha_{M}\\cdot\\bm{m}(\\tau),z\\rangle</span></p>

    <p class="text-gray-300">To compile this into a SNARK, existing works <em>[x13, x12]</em> rely on a pairing-friendly group <span class="math">\\langle\\mathsf{group}\\rangle=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},G,H,e)</span> as follows. A setup phase, on input the R1CS index <span class="math">(\\mathbb{F},m,A,B,C)</span>, samples <span class="math">\\alpha_{A},\\alpha_{B},\\alpha_{C}\\leftarrow\\mathbb{F}</span> and <span class="math">\\tau\\leftarrow\\mathbb{F}\\setminus K</span>, and constructs the proving key <span class="math">\\mathsf{pk}=(\\bm{\\Sigma}_{1}=\\bm{\\mathcal{L}}^{K}(\\tau)\\cdot G,\\bm{\\Sigma}_{2}=(\\sum_{M}\\alpha_{M}\\bm{m}(\\tau))\\cdot G)</span> and the verifying key <span class="math">\\mathsf{vk}=(\\alpha_{A}H,\\alpha_{B}H,\\alpha_{C}H)</span>. To produce a proof, the prover, for each <span class="math">M\\in\\{A,B,C\\}</span>, commits to <span class="math">z_{M}</span> via the Pedersen <em>[x21]</em> commitment <span class="math">c_{M}:=\\langle z_{M},\\bm{\\Sigma}_{1}\\rangle</span> and to <span class="math">z</span> via the Pedersen commitment <span class="math">c:=\\langle z,\\bm{\\Sigma}_{2}\\rangle</span>. The verifier then checks that the linear relation is satisfied via the following pairing check:</p>

    <p class="text-gray-300"><span class="math">\\prod_{M\\in\\{A,B,C\\}}e(c_{M},\\alpha_{M}H)=e(c,H)\\quad.</span> (1)</p>

    <p class="text-gray-300">The soundness of this SNARK can be proven in the Algebraic Group Model <em>[x10]</em>. This SNARK is highly efficient, requiring only <span class="math">4</span> <span class="math">m</span>-sized <span class="math">\\mathbb{G}_{1}</span>-MSMs from the prover, and <span class="math">4</span> pairings from the verifier.</p>

    <p class="text-gray-300">For non-linear row-wise checks, SNARKs for R1CS rely on the following polynomial identity:</p>

    <p class="text-gray-300"><span class="math">\\hat{z}_{A}(X)\\cdot\\hat{z}_{B}(X)-\\hat{z}_{C}(X)=0\\mod v_{K}(X)\\quad.</span> (2)</p>

    <p class="text-gray-300">Here <span class="math">\\hat{z}_{M}(X)=\\langle\\mathcal{L}^{K}(X),z_{M}\\rangle</span> is the polynomial interpolating <span class="math">z_{M}</span>, and <span class="math">v_{K}(X)=\\prod_{k\\in K}(X-k)</span> is the polynomial that is <span class="math">0</span> at every point in <span class="math">K</span>. (For an exposition of this identity, see prior work <em>[x13, x1]</em>). To see how we can compile this check into a SNARK, notice that the group elements <span class="math">c_{A},c_{B},c_{C}</span> in the lincheck SNARK are Pedersen commitments to <span class="math">\\hat{z}_{A},\\hat{z}_{B},\\hat{z}_{C}</span> respectively. Prior work <em>[x13, x2]</em> performs the check directly over these commitments by relying on pairings as follows.</p>

    <p class="text-gray-300">First, the prover’s commitment <span class="math">c_{B}</span> to <span class="math">\\hat{z}_{B}</span> is changed to be over <span class="math">\\mathbb{G}_{2}</span> instead of <span class="math">\\mathbb{G}_{1}</span>. Second, the prover provides a commitment <span class="math">c_{h}\\in\\mathbb{G}_{1}</span> to the polynomial <span class="math">h(X):=(\\hat{z}_{A}(X)\\cdot\\hat{z}_{B}(X)-\\hat{z}_{C}(X))/v_{K}(X)</span>.</p>

    <p class="text-gray-300">Then, the verifier uses the following pairing equation to check Equation (2) at a random point <span class="math">\\tau</span> in the exponent:</p>

    <p class="text-gray-300"><span class="math">e(c_{A},c_{B})=e(c_{C},H)\\cdot e(c_{h},v_{K}(\\tau)\\cdot H)</span> (3)</p>

    <p class="text-gray-300">As above, the soundness of this check can be proven in the AGM <em>[x10]</em>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.1 Generalizing R1CS</h3>

    <p class="text-gray-300">A natural way to extend R1CS to support custom gates would be to consider more complex predicates on the witness. For example, one could ask that each entry of <span class="math">(Az,Bz,Cz)</span> is an element of a table <span class="math">T</span>. As another example, instead of asking that <span class="math">Az\\circ Bz=Cz</span>, we could ask <span class="math">z</span> to satisfy more complex polynomial equations (e.g., <span class="math">Az\\circ Bz\\circ Cz=Dz</span>). More generally, one can imagine enforcing an arbitrary predicate <span class="math">L</span> on vectors <span class="math">M_{1}z,\\ldots,M_{t}z</span> for some matrices <span class="math">M_{1},\\ldots,M_{t}</span> that depend on the predicate <span class="math">L</span>. Formalizing this ideation leads to Generalized R1CS (GR1CS), our extension of R1CS that supports arbitrary custom gates.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2.1 (informal version of Definition 3.3).</h6>

    <p class="text-gray-300">The NP relation GR1CS is the set of triples <span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=((\\mathbb{F},m,\\mathscr{C}),x,w)</span> where <span class="math">\\mathbb{F}</span> is a finite field and <span class="math">\\mathscr{C}</span> is a set of constraints, each of which is a tuple <span class="math">(M_{1},\\ldots,M_{t},L)</span> such that <span class="math">z:=(x,w)\\in\\mathbb{F}^{m}</span> satisfies <span class="math">L(M_{1}z,\\ldots,M_{t}z)=0</span>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">SNARKs for GR1CS.</h4>

    <p class="text-gray-300">Let us attempt to construct a SNARK for GR1CS. We begin by noticing that, like for R1CS, the checks for GR1CS can also be decomposed into linchecks and (generalized) rowcheck checks. We can then try to adapt the foregoing SNARKs for these checks to work for GR1CS:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Linchecks: In GR1CS, we also need to compute matrix-vector products. We can adapt the foregoing linear-check SNARK to work with GR1CS by simply increasing the number of matrices in the check of Eq. (1): <span class="math">\\prod_{M\\in\\{M_{1},\\ldots,M_{t}\\}}e(c_{M},\\alpha_{M}H)=e(c,H)</span>.</li>

      <li>Rowchecks: Instead of proving the R1CS identity of Equation (2), GR1CS requires proving the custom gate <span class="math">L(\\hat{z}_{1}(X),\\ldots,\\hat{z}_{t}(X))=0</span> over a domain <span class="math">K</span>. Unfortunately, this is not straightforward: while Eq. (2) can be straightforwardly adapted to this more complex check, its cryptographic realization in Eq. (3) cannot: the bilinear map only allows us to check quadratic relations, which rules out custom gates that enforce higher-degree polynomial relations, and also completely rules out non-algebraic gates like table lookups.</li>

    </ul>

    <p class="text-gray-300">It thus seems that trying to generalize existing circuit-specific SNARKs for R1CS to work with GR1CS does not work because these perform the non-linear check in Eq. (2) “in the exponent” by using pairings to multiply polynomials, and then checking that the resulting products are equal as group elements.</p>

    <p class="text-gray-300">An alternative approach that has been developed in the past few years instead directly checks polynomial identities like those of Eq. (2) directly in plain, outside the exponent. This approach follows the popular ‘PIOP + PC scheme <span class="math">\\rightarrow</span> SNARK’ methodology <em>[CHMMV+20, BFS+20]</em>. Briefly, this methodology combines two components: a Polynomial Interactive Oracle Proof (PIOP), and a Polynomial Commitment (PC) scheme. The former is an interactive proof system where the prover’s messages are polynomials, and the verifier does not read these messages but instead queries them at evaluation points of its choice. The latter is a cryptographic tool that allows the prover to commit to a polynomial and later prove that it evaluates to a claimed value at a claimed point. The methodology constructs a SNARK from these components by replacing the PIOP prover’s polynomials with commitments to them, and then uses the PC scheme to prove that the commitments are consistent with the PIOP verifier’s queries.</p>

    <p class="text-gray-300">In existing constructions <em>[CHMMV+20, Set+20, ST+23]</em>, the PIOP is responsible for both the linear and non-linear checks. While non-linear checks like those of Eq. (2) have efficient PIOPs, linear checks require PIOPs whose proving costs scale with the number of non-zero entries in the matrix, and which require the prover to compute numerous oracles. After compilation to a SNARK, this results in proving costs that require cryptographic work for addition gates, and also result in larger proof sizes.</p>

    <p class="text-gray-300">To overcome these issues, we propose a new methodology that combines the best of both worlds: we use efficient PIOPs for non-linear custom gates, and rely on efficient linear-check SNARKs for linear gates. To do so, we introduce a new notion of <em>equifficient</em> polynomial commitments that allows us to link the two components cleanly. We devote the rest of this section to describing our new notion, and describing how to construct SNARKs for GR1CS using it.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.2 New tool: Equifficient polynomial commitments</h3>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Background: polynomial commitments.</h4>

    <p class="text-gray-300">Recall that a (standard) polynomial commitment (PC) scheme allows a <em>committer</em> to commit to a polynomial <span class="math">p</span> in a commitment <span class="math">c</span>, and to then later prove to a <em>verifier</em> an “evaluation claim” that asserts that the committed polynomial evaluates to a claimed evaluation <span class="math">v</span> at a given point <span class="math">u</span>. For use in SNARKs, the PC scheme is required to satisfy additional properties, with the relevant one being <em>extractability</em> <em>[CHMMV+20]</em>. Roughly, the latter says that whenever the verifier is convinced by an adversarial committer’s evaluation claim, then the committer must “know” a polynomial underlying the commitment that is consistent with the evaluation claim (i.e., evaluates to the claimed value at the claimed point). This is formalized by requiring the existence of an efficient extractor that is able to extract such a polynomial from any adversary that convinces the verifier with non-negligible probability. (See <em>[CHMMV+20]</em> for a formal definition of extractability.)</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Coefficient-equality constraints.</h4>

    <p class="text-gray-300">We extend the standard notion of extractability by enforcing a new property called <em>coefficient equality</em>. Let <span class="math">\\mathbb{K}</span> be a <span class="math">D</span>-dimensional vector space of polynomials over a field <span class="math">\\mathbb{F}</span>, and let <span class="math">p_{1},\\ldots,p_{n}</span> be polynomials in <span class="math">\\mathbb{K}</span>. Associate with each <span class="math">p_{i}</span> a basis <span class="math">\\mathscr{B}_{i}</span> of <span class="math">\\mathbb{K}</span>, and denote by <span class="math">[p_{i}]_{\\mathscr{B}_{i}}</span> the list of coefficients of <span class="math">p_{i}</span> when expressed in the basis <span class="math">\\mathscr{B}_{i}</span>. Then, a coefficient-equality (or <em>equifficient</em>) constraint <span class="math">\\Lambda</span> on polynomials <span class="math">\\bm{p}=[p_{1},\\ldots,p_{n}]</span> in <span class="math">\\mathbb{K}</span> is a list <span class="math">[\\mathscr{B}_{1},\\ldots,\\mathscr{B}_{n}]</span> of bases for <span class="math">\\mathbb{K}</span> that enforces that the coefficient vectors of the polynomials in their respective bases are equal; that is, <span class="math">[p_{1}]_{\\mathscr{B}_{1}}=\\cdots=[p_{n}]_{\\mathscr{B}_{n}}</span>. We denote this constraint satisfaction by the predicate <span class="math">\\Lambda(\\bm{p})=1</span>. If <span class="math">\\Lambda</span> is specified by a single basis, then we call the constraint <em>trivial</em>, and assume without loss of generality the basis is the canonical basis for <span class="math">\\mathbb{K}</span>, denoted by <span class="math">\\mathscr{U}</span>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Definition: equifficient PC schemes.</h4>

    <p class="text-gray-300">An <em>equifficient polynomial commitment scheme</em> (<span class="math">\\mathsf{EPC}</span>) is a PC scheme in the standard sense with the additional property that equifficient constraints are enforced on committed polynomials. Formally, an <span class="math">\\mathsf{EPC}</span> scheme for the <span class="math">D</span>-dimensional vector space <span class="math">\\mathbb{K}</span> over a field <span class="math">\\mathbb{F}</span> in the field family <span class="math">\\mathcal{F}</span> consists of algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Specialize},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span> whose syntax and properties are</p>

    <p class="text-gray-300">as follows.</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">Syntax.</h5>

    <p class="text-gray-300">EPC.Setup samples public parameters pp containing a description of <span class="math">\\mathbb{K}</span> along with its canonical basis <span class="math">\\mathscr{U}</span>. The algorithm EPC.Specialize then specializes these public parameters pp for a set of equifficient constraints <span class="math">\\bm{\\Omega}=\\{\\Omega_{1},\\ldots,\\Omega_{s}\\}</span>, constructing committer, opener, and verifier keys <span class="math">(\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})</span> that collectively enforce the constraints in <span class="math">\\bm{\\Omega}</span> on committed polynomials.</p>

    <p class="text-gray-300">The committer can then use EPC.Commit to commit to a list of polynomials <span class="math">\\bm{p}=[p_{1},\\ldots,p_{n}]</span> while enforcing that these polynomials are subject to an equifficient constraint <span class="math">\\Lambda\\in\\bm{\\Omega}</span>. Later on, the committer can use EPC.Open to produce a proof that the committed polynomials evaluate to claimed evaluations <span class="math">\\bm{v}=[v_{1},\\ldots,v_{n}]</span> at a claimed point <span class="math">u</span>. Finally, the verifier can use EPC.Verify to check this proof, with the guarantee that if the proof passes, then the resulting evaluations are correct, and moreover that the committed polynomials satisfy the equifficient constraint <span class="math">\\Lambda</span>.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Extractability.</h5>

    <p class="text-gray-300">EPC schemes are required to satisfy strong <em>equifficient</em> extractability guarantees. Roughly, this means that, given an equifficient constraint <span class="math">\\Lambda\\in\\bm{\\Omega}</span>, for every adversarial committer who can produce a commitment-proof pair that causes EPC.Verify to accept, there exists an efficient extractor that outputs the polynomials in the adversarial commitment that satisfy the evaluation claims <em>and</em> the claimed equifficient constraints.</p>

    <p class="text-gray-300">Formalizing the foregoing informal description in a way that suffices for our application of constructing SNARKs for GR1CS requires some care. For instance, we generalize our definition to support committing to batches of polynomials such that each batch is subject to a different equifficient constraint. We also consider a strong extractability definition that supports multiple commitments produced across multiple rounds of interaction. All of these changes require a more detailed formalization, which we provide in Section 4.1.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.3 SNARKs from equifficient polynomial commitments</h3>

    <p class="text-gray-300">We now describe how to use equifficient polynomial commitments to construct SNARKs for GR1CS. We begin with an intuitive explanation, and then provide a more detail description. We make two simplifying assumptions when discussing the techniques.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>We assume that there is a single custom gate.</li>

      <li>We assume that the NP instance <span class="math">\\bm{\\pi}</span> is empty, and defer describing the modifications required to handle non-empty instances to Remark 2.2.</li>

    </ul>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Construction intuition.</h5>

    <p class="text-gray-300">At a high level, our construction follows the ‘PIOP + PC <span class="math">\\rightarrow</span> SNARK’ recipe <em>[CHMMV+20, GW+19]</em>, but replaces the standard PC scheme used in that recipe with an <em>equifficient</em> PC scheme. This EPC scheme is then used to enforce linear constraints, while the PIOP is tasked only with enforcing non-linear constraints. We explain the intuition behind this reasoning next.</p>

    <p class="text-gray-300">Recall that the construction attempt in Section 2.1 enforces linear constraints via the randomized check <span class="math">\\sum_{i=1}^{t}\\alpha_{i}\\cdot\\langle\\bm{\\mathcal{L}}^{K}(\\tau),z_{M_{i}}\\rangle\\stackrel{{\\scriptstyle?}}{{=}}\\langle\\sum_{i=1}^{t}\\alpha_{i}\\cdot\\bm{m}_{i}(\\tau),z\\rangle</span>. Our insight is that this check can be viewed as an <em>equifficient constraint</em> on the polynomials <span class="math">z_{M_{1}},\\ldots,z_{M_{t}}</span>: they are required to have the same coefficient representation (i.e., <span class="math">z</span>) in their respective “matrix” bases (<span class="math">\\bm{m}_{1},\\ldots,\\bm{m}_{t}</span>). Therefore, to enforce these constraints, we can just require the argument prover to commit to the polynomials <span class="math">\\hat{z}_{M_{1}},\\ldots,\\hat{z}_{M_{t}}</span> with an EPC scheme under the equifficient constraint <span class="math">\\Lambda=(\\bm{m}_{1},\\ldots,\\bm{m}_{t})</span>. We can then use a PIOP that enforces non-linear constraints over these committed polynomials to complete the argument.</p>

    <p class="text-gray-300">The security of this approach is ensured by the extractability property of the EPC scheme (which guarantees that if the prover can produce a valid evaluation proof, then it must know polynomials that satisfy the linear constraints), and by the soundness of the PIOP.</p>

    <p class="text-gray-300">We provide a detailed overview of the construction below.</p>

    <p class="text-gray-300">Construction overview. We begin by introducing some notation. A GR1CS index <span class="math">\\mathbb{i} = (\\mathbb{F}, m, \\mathcal{C})</span> is satisfied by an instance-witness pair <span class="math">(\\mathbb{x}, \\mathbb{w}) = (x, w)</span> if the local predicate <span class="math">L</span> is satisfied by the vectors <span class="math">M_1z, \\ldots, M_tz</span>. In the exposition below, we assume that the matrices <span class="math">M_1, \\ldots, M_t</span> are square matrices of size <span class="math">m</span>, and moreover that their columns are linearly-independent (and hence form a basis for <span class="math">\\mathbb{F}^m</span>). Below <span class="math">\\mathcal{D}</span> will be a subset of the field <span class="math">\\mathbb{F}</span> of size <span class="math">m</span>. (The particular choice of subset depends on whether we are using univariate or multilinear polynomials; it does not affect the exposition.)</p>

    <p class="text-gray-300">Our construction will rely on PIOPs for the non-linear component of GR1CS, which we characterize via the following NP relation:</p>

    <p class="text-gray-300"><strong>Definition 1 (informal version of Definition 5.1).</strong> The rowcheck NP oracle relation is a tuple <span class="math">(\\mathbb{i}, \\mathbb{x}, \\mathbb{w}) = ((\\mathbb{F}, L, \\mathcal{D}), [[\\mathbb{i}, \\mathbb{x}]_{i=1}^{t}, [\\hat{z}_i]_{i=1}^{t})</span>, where the index consists of a field description <span class="math">\\mathbb{F}</span>, a local predicate <span class="math">L</span>, and a subset <span class="math">\\mathcal{D}</span> of <span class="math">\\mathbb{F}</span>. The instance contains polynomial oracles <span class="math">[\\mathbb{i}, \\mathbb{x}]_{i=1}^{t}, \\ldots, [\\mathbb{i}, \\mathbb{x}]_{i=1}^{t}</span>, while the witness contains the corresponding polynomials. A triple is in the relation if the local predicate is satisfied by the polynomials at all points in <span class="math">\\mathcal{D}</span>, i.e., for all <span class="math">x \\in \\mathcal{D}</span>, <span class="math">L(\\hat{z}_1(x), \\ldots, \\hat{z}_t(x)) = 0</span>.</p>

    <p class="text-gray-300">Given a PIOP for rowcheck, and an appropriate compatible equifficient polynomial commitment scheme EPC, we are now ready to describe our SNARK construction.</p>

    <p class="text-gray-300"><strong>Generator.</strong> On input the GR1CS index <span class="math">\\mathbb{i} = (\\mathbb{F}, m, ([M_i]_{i=1}^t, L))</span>, the argument generator <span class="math">\\mathcal{G}</span> samples proving and verification keys <span class="math">(\\mathsf{ipk}, \\mathsf{ivk})</span> as follows.</p>

    <p class="text-gray-300">First, <span class="math">\\mathcal{G}</span> samples EPC public parameters via EPC.Setup. Then, for each matrix <span class="math">M_i</span>, <span class="math">\\mathcal{G}</span> constructs the basis set <span class="math">\\mathcal{M}_i := [\\hat{m}_{i,j}]_{j=1}^k</span> where <span class="math">\\hat{m}_{i,j}</span> is a polynomial that interpolates the <span class="math">j</span>-th column of <span class="math">M_i</span> over the domain <span class="math">\\mathcal{D}</span>. It then invokes the EPC specialization algorithm with input the equifficient constraint <span class="math">\\Lambda := (\\mathcal{M}_1, \\ldots, \\mathcal{M}_t)</span> to obtain the commitment keys <span class="math">(\\mathsf{ck}, \\mathsf{ok}, \\mathsf{vk})</span> specialized to these constraints. (It also ensures that these keys allow committing to unconstrained polynomials.) Next, it constructs from the GR1CS index <span class="math">\\mathbb{i}</span> a corresponding rowcheck index, and invokes the PIOP indexer on the latter to obtain indexer polynomials <span class="math">\\pmb{p}_0</span>. It commits to these via EPC.Commit to obtain the commitment <span class="math">c_0</span>.</p>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{G}</span> constructs the proving key <span class="math">\\mathsf{ipk} = (\\mathsf{ck}, \\mathsf{ok}, \\pmb{p}_0)</span> and the verification key <span class="math">\\mathsf{ivk} = (\\mathsf{vk}, c_0)</span>, and outputs these.</p>

    <p class="text-gray-300"><strong>Prover and verifier.</strong> We describe the interaction between the argument prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. The prover gets as input the proving key ipk, the GR1CS instance <span class="math">x</span>, and the GR1CS witness <span class="math">w</span>, while the verifier gets as input the verifying key ivk and the instance <span class="math">x</span>. (Recall that in this high-level exposition, we make the simplifying assumption that the GR1CS instance <span class="math">x</span> is empty. We include it here syntactically anyway for familiarity.)</p>

    <p class="text-gray-300">The prover <span class="math">\\mathcal{P}</span> starts by setting <span class="math">z := (x, w)</span>, and then computing the vectors <span class="math">z_i := M_i \\cdot z \\in \\mathbb{F}^m</span> for each <span class="math">i</span> in <span class="math">1, \\ldots, t</span>. It then low-degree extends these vectors over the domain <span class="math">\\mathcal{D}</span> to get the polynomials <span class="math">\\hat{z}_1, \\dots, \\hat{z}_t</span>. <span class="math">\\mathcal{P}</span> uses EPC.Commit to commit to these polynomials under the equifficient constraint <span class="math">\\Lambda</span>, and sends the resulting commitments to the verifier <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">The prover and verifier then proceed as in the methodology of Chiesa et al. [CHMMVW20], i.e., by simulating the rowcheck PIOP prover and verifier respectively. In each round, instead of sending the polynomials produced by the PIOP prover in the plain, <span class="math">\\mathcal{P}</span> instead commits to these using EPC.Commit, but without enforcing any equifficient constraints. At the end of the interaction, when the PIOP verifier wishes to query the committed polynomials, <span class="math">\\mathcal{V}</span> sends the query set to <span class="math">\\mathcal{P}</span>, who responds with the claimed evaluations and the evaluation proofs produced by EPC.Open. <span class="math">\\mathcal{V}</span> concludes the protocol by checking that these evaluation proofs are valid using EPC.Verify, and by checking that the claimed evaluations satisfy the PIOP verifier's checks.</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">To compile this to a <em>non-interactive</em> argument, we can invoke the Fiat–Shamir transform <em>[x10]</em> as in prior work.</p>

    <p class="text-gray-300">To prove this construction secure, it suffices to require equifficient extractability of the EPC scheme and soundness of the PIOP for rowcheck. This is unlike prior work <em>[x11]</em>, which requires extractability from both components. We can get away with this weaker requirement because, informally, our SNARK guarantees that the witness is committed via the EPC scheme, and only relies on the PIOP to check some constraints on the committed witness. In contrast, in prior work <em>[x11]</em>, the prover only commits to PIOP prover polynomials, and because these could encode the witness in an arbitrary manner, one needs a PIOP extractor to be able to recover the witness. We provide a formal proof of this argument in Section 5.1.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 2.2 (handing non-empty public inputs).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our discussion thus far has only considered the case where the GR1CS instance is empty. When the instance is non-empty, the GR1CS variable assignment <span class="math">z</span> does not equal the witness <span class="math">w</span>, but instead is the concatenation $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math">. This change means that the verifier must now additionally check that each polynomial </span>\\hat{z}_{i}<span class="math"> is indeed an LDE of </span>M_{i}\\cdot z$, and not of some other vector.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our approach to this problem will allow the verifier to directly obtain oracle access to the correct <span class="math">\\hat{z}_{i}</span> by construction. The key idea is to force the prover to leave “empty slots” in the commitments to these polynomials that can be filled in by the verifier with information derived from the instance. In more detail, we leverage the linearity of the low-degree extension operation to write <span class="math">\\hat{z}_{i}</span> as the sum of <span class="math">\\hat{x}_{i}</span> and <span class="math">\\hat{w}_{i}</span>, where <span class="math">\\hat{x}_{i}</span> and <span class="math">\\hat{w}_{i}</span> are the low-degree extensions of $M_{i}\\cdot(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0)<span class="math"> and </span>M_{i}\\cdot(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)$ respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, if the prover can be forced to send commitments to <span class="math">\\hat{w}_{i}</span>, the verifier can evaluate <span class="math">\\hat{z}_{i}</span> at any point <span class="math">u</span> by computing the sum <span class="math">\\hat{x}_{i}(u)+\\hat{w}_{i}(u)</span>: the first part the verifier can compute itself, while the second part will be provided by the prover (along with a corresponding evaluation proof).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To enable this sketch to work, we need to modify the EPC layer to enable equifficient constraints that support “punctured bases”: roughly, the latter enable us to enforce coefficient-equality constraints only for certain coefficients, while enforcing that the remaining “punctured” coefficients are zero. EPC schemes that support these new equifficient constraints can enforce that the prover indeed commits to the vector $(0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)$, and not to other vectors that have non-zero initial coefficients. For a detailed discussion of punctured bases and EPC schemes that support these, see Sections 3.1 and 4.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinct verification requires an additional change: the ability for the verifier to evaluate the polynomials <span class="math">\\hat{x}_{i}</span> in time that scales with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (as opposed to time that scales with the number of constraints </span>m$). This is possible when the corresponding matrix bases elements are efficiently evaluatable, e.g. when they are Lagrange polynomials (or are a sparse linear combination of a constant number of these). To enable this, we adapt a technique from Lipmaa <em>[x16]</em> that introduces new witness variables whose values are supposed to equal the instance variables, and then enforces this equality via equality constraints; we refer the reader to <em>[x16, Section 3, page 11]</em> for details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">2.4 Constructing Pari</h3>

    <p class="text-gray-300">To construct Pari, we instantiate the blueprint from Section 2.3 with a new univariate EPC scheme (Section 2.4.1) and a univariate PIOP for rowcheck specialized to ‘Square’ R1CS (Section 6.1). We briefly describe this PIOP below, and provide details about the EPC scheme construction in Section 2.4.1.</p>

    <p class="text-gray-300">Square R1CS <em>[x15]</em> is a special case of GR1CS that enforces constraints of the form <span class="math">Az\\circ Az=Bz</span>. This translates to a rowcheck relation where the local predicate is the claim that <span class="math">\\hat{z}_{A}^{2}(X)-\\hat{z}_{B}(X)=0</span> on <span class="math">\\mathcal{D}</span>. A PIOP for this relation follows by adapting PIOPs for R1CS ‘rowcheck’ from prior work e.g. Aurora <em>[x3]</em> or Marlin <em>[x11]</em>. See Section 6 for details.</p>

    <p class="text-gray-300">Applying the blueprint from Section 2.3 with the univariate EPC scheme and this univariate PIOP for Square R1CS, along with optimizations in Section 6.2 gives us the following theorem:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300"><span class="math">\\textsc{ pari }is\\ a\\ SNARK\\ for\\ NP\\ with\\ proof\\ size\\ consisting\\ of\\ 2\\ \\mathbb{G}_{1}\\ and\\ 2\\ \\mathbb{F}\\ elements.</span></p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Remark 2.3.</h6>

    <p class="text-gray-300">We note that it is possible to construct a variant of Pari that is specialized to R1CS by changing the rowcheck to enforce that <span class="math">\\hat{z}_{A}(X)\\hat{z}_{B}(X)-\\hat{z}_{C}(X)=0</span> on <span class="math">\\mathcal{D}</span>. The resulting proof would achieve improved prover time compared to Pari by avoiding the overhead of SR1CS, but would have a worse proof size of <span class="math">2</span> <span class="math">\\mathbb{G}_{1}</span> and <span class="math">3</span> <span class="math">\\mathbb{F}</span> elements. We remark that over BLS12-381, this proof size is equal to that of Groth16, while over larger curves (e.g., BW6-761 <em>[x10]</em>), it is smaller.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">2.4.1 An EPC scheme for univariate polynomials</h4>

    <p class="text-gray-300">We construct an EPC scheme for univariate polynomials by building upon the popular KZG polynomial commitment scheme <em>[x16]</em>. Recall that in the latter, the committer can commit to a polynomial and prove its evaluation claim in a constant number of group elements, and our EPC construction will inherit these attractive properties.</p>

    <p class="text-gray-300">We now provide a high-level sketch of our construction. Note that our description below first describes a variant that omits any discussion of the ‘commitment batching’ property that is necessary to obtain the proof size in Theorem 1, and then discusses how to add this property in Remark 2.5. We do so because it makes the exposition simpler, and also because it makes it easier to discuss the multilinear version in Section 2.5. We provide full details on the batched construction in Section 4.2.</p>

    <p class="text-gray-300">Define the <span class="math">D</span>-dimensional vector space of univariate polynomials <span class="math">\\mathbb{K}:=\\mathbb{F}^{&lt;D}[X]</span> where <span class="math">\\mathbb{F}=\\mathbb{F}_{q}</span> is a prime field.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Background: KZG polynomial commitments.</h5>

    <p class="text-gray-300">Let <span class="math">\\langle\\textsf{group}\\rangle=(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},G,H,e)</span> be a pairing-friendly group and <span class="math">D\\in\\mathbb{N}</span> an upper-bound on the degree of the polynomials over <span class="math">\\mathbb{F}_{q}</span> that commitments are supported to. The setup phase consists of sampling <span class="math">\\tau\\leftarrow\\mathbb{F}_{q}</span> uniformly at random and constructing the SRS as the list <span class="math">\\bm{\\Sigma}=[\\tau^{j}G]_{j=0}^{D-1}</span>. To commit to <span class="math">p</span> under <span class="math">\\bm{\\Sigma}</span>, the committer expresses <span class="math">p</span> as a coefficient vector in the monomial basis and computes the Pedersen <em>[x22]</em> commitment <span class="math">c:=\\langle p,\\bm{\\Sigma}\\rangle=p(\\tau)G</span>.</p>

    <p class="text-gray-300">To prove that the committed polynomial in <span class="math">c</span> evaluates to a claimed evaluation <span class="math">v</span> at the point <span class="math">u</span>, the committer opens <span class="math">c</span> by computing the unique witness polynomial <span class="math">w(X):=(p(X)-p(u))/(X-u)\\in\\mathbb{F}_{q}^{&lt;D}[X]</span>, and then commits to it under <span class="math">\\bm{\\Sigma}</span> via the Pedersen commitment <span class="math">\\mathsf{w}:=\\langle w,\\bm{\\Sigma}\\rangle=w(\\tau)G</span>.</p>

    <p class="text-gray-300">To verify the proof, the verifier takes the claimed evaluation <span class="math">v</span> and checks <span class="math">e(c,-vH)=e(\\mathsf{w},\\tau H-uH)</span>.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Our construction.</h5>

    <p class="text-gray-300">The key differences between our KZG-based EPC scheme and the standard KZG scheme arise from the equifficient properties imbued by the specialization algorithm; we describe this next.</p>

    <p class="text-gray-300">EPC.Specialize, when given as input an equifficient constraint <span class="math">\\Lambda=[\\mathscr{B}_{1},\\ldots,\\mathscr{B}_{t}]</span> of size <span class="math">t</span>, starts by creating basis-specific SRSes as follows. Let <span class="math">T_{i}</span> denote the linear transformation from the monomial basis to the basis <span class="math">\\mathscr{B}_{i}</span>. Then the specialized committer key for <span class="math">\\mathscr{B}_{i}</span> is computed as <span class="math">\\mathsf{ck}_{i}:=T_{i}\\cdot\\bm{\\Sigma}=(b_{1}^{(i)}(\\tau)\\cdot G,\\ldots,b_{D}^{(i)}(\\tau)\\cdot G)</span>, where <span class="math">(b_{1}^{(i)}(X),\\ldots,b_{D}^{(i)}(X))</span> are the basis elements that comprise <span class="math">\\mathscr{B}_{i}</span>.</p>

    <p class="text-gray-300">Next, EPC.Specialize computes an additional consistency key that will eventually force the committer to commit the same coefficient under these keys with a single coefficient vector. The consistency key <span class="math">\\mathsf{ck}_{\\Lambda}</span> is computed as a linear combination of the basis-specific committer keys with respect to powers of a random element <span class="math">\\alpha\\leftarrow\\mathbb{F}</span>: <span class="math">\\mathsf{ck}_{\\Lambda}:=\\sum_{i=1}^{t}\\alpha^{i-1}\\cdot\\mathsf{ck}_{i}</span>. The opening key <span class="math">\\mathsf{ok}</span> is simply <span class="math">\\bm{\\Sigma}</span>, while the verifier key <span class="math">\\mathsf{vk}</span> consists of the <span class="math">\\mathbb{G}_{2}</span>-encodings of the random coefficients, i.e., <span class="math">\\alpha^{i-1}\\cdot H</span>.</p>

    <p class="text-gray-300">EPC.Commit commits to input polynomials <span class="math">p_{1},\\ldots,p_{t}</span> by first committing to these under the basis-specific committer keys: <span class="math">c_{i}:=\\langle\\mathsf{ck}_{i},p_{i}\\rangle</span>. It additionally computes a consistency commitment to these under</p>

    <p class="text-gray-300">the key <span class="math">\\mathsf{ck}_{\\Lambda}</span>: letting <span class="math">p</span> denote the coefficient vector of <span class="math">p_1</span> in the <span class="math">\\mathcal{B}_1</span>-basis, it commits to <span class="math">p</span> via the Pedersen commitment <span class="math">c_{\\Lambda} := \\langle \\mathsf{ck}_{\\Lambda}, p \\rangle</span>. The full commitment to <span class="math">p_1, \\ldots, p_t</span> is then the tuple <span class="math">(c_1, \\ldots, c_t, c_{\\Lambda})</span>.</p>

    <p class="text-gray-300">In the opening phase, the committer opens each <span class="math">c_i</span> by computing the witness polynomial <span class="math">w_i(X) = (p_i(X) - v) / (X - u)</span> and committing to it under <span class="math">\\Sigma</span>, exactly like in KZG. Note that the consistency commitment <span class="math">c_{\\Lambda}</span> is not opened.</p>

    <p class="text-gray-300">In the verification phase, the verifier verifies the evaluation proof for each commitment <span class="math">c_i</span> as in KZG, and additionally checks that the basis-specific commitments are consistent with each other and satisfy the equilibrium constraint <span class="math">\\Lambda</span> via the pairing product check <span class="math">e(c_{\\Lambda}, H) \\stackrel{?}{=} \\prod_{i=1}^{t} e(c_i, \\alpha^{i-1} \\cdot H)</span>.</p>

    <p class="text-gray-300"><strong>Security.</strong> The extractability of this construction follows in the AGM from a straightforward application of the Schwartz-Zippel lemma [Zip79; Sch80]. We provide a formal proof in Theorem 4.3.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> Commitment cost is dominated by the cost to compute the commitments <span class="math">c_1, \\ldots, c_t</span> and <span class="math">c_{\\Lambda}</span>, i.e., a total of <span class="math">t + 1</span> <span class="math">D</span>-sized multi-scalar multiplications (MSMs) in <span class="math">\\mathbb{G}_1</span>. Similarly, opening cost is dominated by the cost to commit to the witness polynomials, which is <span class="math">t</span> <span class="math">D</span>-sized MSMs in <span class="math">\\mathbb{G}_1</span>. Finally, the verifier cost is <span class="math">t + 1</span> pairings, while the commitment size is <span class="math">t + 1</span> <span class="math">\\mathbb{G}_1</span> elements.</p>

    <p class="text-gray-300"><strong>Remark 2.4 (connections with linear interactive proofs).</strong> One can view our EPC scheme as implicitly constructing a "trivial" Linear Interactive Proof (LIP) [BCIOP13]. Briefly, in the latter, the verifier specifies vectors that are queries to a linear function, and the prover responds by applying its linear function to these queries. In our case, the prover's linear function is the coefficient vector of the polynomials under their respective bases, while the verifier queries are the bases evaluated at the point <span class="math">\\tau</span>. Bitansky et al. ensure that the prover answers multiple queries to its linear function consistently by having the verifier specify a "consistency query" that is a linear combination of the original queries; this corresponds to our consistency key <span class="math">\\mathsf{ck}_{\\Lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark 2.5 (commitment batching).</strong> In the foregoing construction, the consistency commitment <span class="math">c_{\\Lambda}</span> can be viewed as a batch commitment to the polynomials $p_1, \\ldots, p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> with respect to the commitment key </span>\\mathsf{ck}_{\\Lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\mathsf{ck}_{\\Lambda}, p \\rangle = \\langle \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha^{i-1} \\cdot \\mathsf{ck}_i, p_1 \\rangle = \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha^{i-1} \\cdot \\langle \\mathsf{ck}_i, p_i \\rangle = \\sum_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha^{i-1} \\cdot c_i</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This observation enables us to directly use this consistency commitment as the only commitment to the polynomials $p_1, \\ldots, p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. After appropriate changes to the commitment, opening, and verification keys, we can ensure that opening these polynomials at a point </span>u$ can be achieved via a single "batch" evaluation proof, thus allowing us to commit to and then open multiple polynomials with just two group elements. We provide details in Section 4.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-32" class="text-2xl font-bold">2.5 Constructing GARUDA</h2>

    <p class="text-gray-300">To construct GARUDA, we instantiate the blueprint from Section 2.3 with a new multilinear EPC scheme and a multilinear PIOP for rowcheck that supports multiple predicates. We describe these components next.</p>

    <p class="text-gray-300"><strong>Multilinear PIOP for rowcheck.</strong> To support multiple predicates, we propose to "stack" the matrices for different predicates together to get a single set of matrices <span class="math">M_1^<em>, \\ldots, M_t^</em></span>. Then, the prover's oracles consist of the multilinear LDEs <span class="math">\\hat{z}_1, \\ldots, \\hat{z}_t</span> of the matrix-vector products <span class="math">M_i^<em> \\cdot z</span>. To enforce the <span class="math">j</span>-th local predicate <span class="math">L_j</span>, the PIOP leverages selector polynomials <span class="math">S_j</span> that activate the entries of <span class="math">M_i^</em> \\cdot z</span> that correspond to the <span class="math">j</span>-th predicate. That is, instead of directly checking <span class="math">L_j(\\hat{z}_1, \\ldots, \\hat{z}_t) = 0</span> in checking the satisfaction of (which would not work), we instead use the polynomials <span class="math">S_j \\cdot \\hat{z}_1, \\ldots, S_j \\cdot \\hat{z}_t</span>. The satisfaction of each local predicate</p>

    <p class="text-gray-300">2In fact, when <span class="math">L_j</span> is a polynomial predicate, we can leverage a better strategy that avoids doubling the individual degree of each polynomial by simply applying the selector to the entire expression <span class="math">L_j(\\hat{z}_1, \\ldots, \\hat{z}_t)</span>.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300"><span class="math">L_{j}</span> is then enforced by a separate PIOP for rowcheck that checks that the polynomials <span class="math">S_{j}\\cdot\\hat{z}_{1},\\ldots,S_{j}\\cdot\\hat{z}_{t}</span> satisfy the predicate at all points in <span class="math">\\mathcal{D}</span>. We choose multivariate-sumcheck-based PIOPs for this purpose, as they allow us to obtain the desired linear prover time.</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Multilinear EPC scheme.</h5>

    <p class="text-gray-300">The unbatched univariate construction described in Section 2.4.1 can be naturally extended to multilinear polynomials by using as a starting point the multilinear PC scheme of Papamanthou et al. <em>[x20]</em>, instead of the univariate KZG scheme.</p>

    <p class="text-gray-300">Overall, after applying the optimizations in Section 7.2, we obtain the following theorem:</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <p class="text-gray-300">Garuda is a SNARK for GR1CS that achieves linear prover complexity and logarithmic proof size and verifier time.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">2.6 Implementation</h3>

    <p class="text-gray-300">We implemented Garuda as a Rust library in only 900 lines of code. Our library is built atop the arkworks framework, and also uses some components from the HyperPlonk implementation. We did not implement Pari because the relevant metric for it (proof size) is easily inferred from the protocol description, and does not vary with the implementation. Our implementation contributions are twofold.</p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Interface for programming GR1CS.</h5>

    <p class="text-gray-300">We extend the R1CS programming interface provided by the ark-relations crate to also support programming GR1CS constraints in just 1500 lines of code. Our extension is user-friendly, and can take advantage of arkworks’ strong library of R1CS constraint “gadgets”. Indeed, our benchmarks use this feature to ensure consistency across all the SNARKs we consider.</p>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Implementation of Garuda.</h5>

    <p class="text-gray-300">We implement Garuda atop the multilinear polynomial framework offered by the ark-poly library. Our implementation consumes constraint systems produced by the foregoing constraint-writing interface. For the time being, our implementation supports multiple polynomial predicates/custom gates, but we plan to extend it to support more general custom gates in the future. This change would require updating the aforementioned GR1CS programming interface to support these gates as well.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">2.7 Evaluation</h3>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Experimental setup.</h5>

    <p class="text-gray-300">All measurements were conducted using a MacBook Pro with 18 GB of RAM and a 12-core Apple M3 Pro chip. All times except verifying are reported in both the single-threaded and multithreaded settings. When using multithreading, we set the number of threads used by the prover to be 4.</p>

    <p class="text-gray-300">Our benchmark circuit consists of iterations of the popular arithmetization-oriented Rescue-Prime hash function <em>[x23]</em>. Our implementation of the latter builds upon the general interface for sponge-based hashes in the ark-crypto-primitives crate. The configuration of each hash function is as follows: it has a 12-round permutation, a rate of 3, and a capacity of 1. The hash function operates over the 256-bit prime scalar field of the BLS12-381 curve, with the S-box exponent <span class="math">\\alpha</span> set to 5 in the forward S-boxes. The linear operator parameters are derived from the rescue_prime.sage script provided in the Marvellous repository.</p>

    <p class="text-gray-300">To implement the hash function circuit, we utilized two types of local predicates: a standard R1CS predicate and a polynomial predicate of degree 5 that evaluates the exponentiation by <span class="math">\\alpha</span>. The latter predicate is used to check the correct evaluation of both the forward and inverse S-boxes.</p>

    <p class="text-gray-300">To evaluate the efficiency benefits of GARUDA, we compared it against two state-of-the-art baselines: HyperPlonk [CBBZ23] and Groth16 [Gro16]. Our experiments tested various metrics including prover time, verification time, setup time, verifying key size, and proving key size, and also the number of constraints required by the native constraint systems of each SNARK.</p>

    <p class="text-gray-300">Number of constraints. We illustrate the expressive power of GR1CS by comparing in Fig. 1 the number of constraints required to express our computation ( <span class="math">N</span>  iterations of Rescue-Prime for some integer  <span class="math">N</span> ) in GR1CS with the number required to do so in R1CS and Plonkish. Our measurements demonstrate that GR1CS consistently requires fewer constraints: the number of GR1CS constraints is  <span class="math">0.28 \\times</span>  the number of R1CS constraints, and is  <span class="math">0.63 \\times</span>  the number of Plonkish constraints.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Number of constraints for a circuit invoking  <span class="math">N</span>  iterations of Rescue-Prime.</p>

    <p class="text-gray-300">Setup time. Our experiments demonstrate that the setup time of GARUDA is comparable to the setup time of Groth16 and the (deterministic) indexing time of HyperPlonk.</p>

    <p class="text-gray-300">Proving and verifying key sizes. Our measurements indicate that the size of GARUDA's proving key is consistently smaller than that of Groth16  <span class="math">(0.75\\times)</span>  and of HyperPlonk  <span class="math">(0.81\\times)</span> . The size of the verifying key grows logarithmically with the number of constraints, topping out at  <span class="math">14.78\\mathrm{kB}</span>  for the largest circuit size we benchmarked. This is approximately  <span class="math">1.05\\times</span>  smaller than that of HyperPlonk, but is significantly larger  <span class="math">(\\approx 13\\times)</span>  than that of Groth16.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (a) Proving key size</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (b) Verification key size Figure 2: Comparison of proving and verifying key sizes for GARUDA, HyperPlonk, and Groth16 over BLS12-381.</p>

    <p class="text-gray-300">Scalability of proving. We provide a comparison of the proving latency for Groth16, HyperPlonk, and GARUDA in Fig. 3. In both the single-thread and multithreaded cases, GARUDA achieves significantly lower latency than both baselines.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Number of threads  <span class="math">= 1</span> Figure 3: Comparison of prover time for GARUDA, HyperPlonk, and Groth16 over BLS12-381.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Number of threads  <span class="math">= 4</span></p>

    <p class="text-gray-300">In particular, GARUDA's prover time, using 1 thread, is approximately  <span class="math">0.37 - 0.47 \\times</span>  that of HyperPlonk and  <span class="math">0.22 - 0.32 \\times</span>  that of Groth16. Our measurements show that increasing the number of threads to 4, reduces the prover time of all three SNARKs consistently by a factor of 2.5-3.5.</p>

    <p class="text-gray-300">Verifier time and proof size. By Keeping the input size constant and increasing the number of constraints, The verifier time of Groth16 stays the same; However, the verifier time of GARUDA and HyperPlonk SNARKs grows logarithmically, as shown in Fig. 4. Moreover, Groth16 consistently demonstrates the best verification time (1 ms  <span class="math">\\sim</span>  1.5 ms) across all invocation counts. In contrast, HyperPlonk and GARUDA show more variability in their verification times and are comparable in performance.</p>

    <p class="text-gray-300">Groth16 consistently has the smallest proof size of  <span class="math">192\\mathrm{B}</span>  regardless of invocation counts. GARUDA's proof size, though larger  <span class="math">(29 - 43\\times)</span>  than that of Groth16, is consistently  <span class="math">0.24\\times</span>  smaller than that of HyperPlonk.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a) Verification time.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (b) Proof size. Figure 4: Comparison of verification time and proof size of GARUDA, HyperPlonk, and Groth16 over BLS12-381.</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <p class="text-gray-300">We denote by <span class="math">\\lambda\\in\\mathbb{N}</span> a security parameter. When we state that <span class="math">n\\in\\mathbb{N}</span> for some variable <span class="math">n</span>, we implicitly assume that <span class="math">n=\\operatorname{poly}(\\lambda)</span>. We denote by <span class="math">\\operatorname{negl}(\\lambda)</span> an unspecified function that is <em>negligible</em> in <span class="math">\\lambda</span>. When a function can be expressed in the form <span class="math">1-\\operatorname{negl}(\\lambda)</span>, we say that it is <em>overwhelming</em> in <span class="math">\\lambda</span>. When we say that <span class="math">\\mathcal{A}</span> is an <em>efficient adversary</em> we mean that <span class="math">\\mathcal{A}</span> is a family <span class="math">\\{\\mathcal{A}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> of non-uniform polynomial-size circuits. If the adversary consists of multiple circuit families <span class="math">\\mathcal{A}_{1},\\mathcal{A}_{2},\\dots</span> then we write <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2},\\dots)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">[n]</span> the set <span class="math">\\{1,\\dots,n\\}\\subseteq\\mathbb{N}</span>. We use <span class="math">\\bm{a}=[a_{i}]_{i=1}^{n}</span> as a shorthand for the tuple/list <span class="math">(a_{1},\\dots,a_{n})</span>; $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of entries in </span>\\bm{a}<span class="math">. If </span>M<span class="math"> is a matrix then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of nonzero entries in </span>M<span class="math">. If </span>S<span class="math"> is a finite set then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its cardinality and </span>x\\leftarrow S<span class="math"> denotes that </span>x<span class="math"> is an element sampled at random from </span>S<span class="math">. If each element </span>v_{i}<span class="math"> in the list </span>\\bm{v}<span class="math"> is a vector, then </span>\\bm{v}[j]<span class="math"> denotes the list containing the </span>j<span class="math">-th element of each vector, i.e., </span>\\bm{v}[j]=[v_{i}[j]]_{i=1}^{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">f</span> is a function, the <span class="math">[\\![f]\\!]</span> is an oracle for the function. Also, we sometimes abuse the notation and write <span class="math">[\\![\\bm{f}]\\!]</span> to denote the list of oracles <span class="math">[\\![f_{i}]\\!]</span> for each function <span class="math">f_{i}</span> in the list <span class="math">\\bm{f}</span>.</p>

    <p class="text-gray-300">We generally denote variables by the uppercase letters <span class="math">X_{1},\\dots,X_{n}</span>, while points, or values that the variables can take on, are denoted by the lowercase letters <span class="math">x_{1},\\dots,x_{n}</span>. As shorthand, we write <span class="math">\\bm{X}=(X_{1},\\dots,X_{n})</span> and <span class="math">\\bm{x}=(x_{1},\\dots,x_{n})</span>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Random oracles.</h4>

    <p class="text-gray-300">We denote by <span class="math">\\mathcal{U}_{\\lambda}</span> the set of all functions that map <span class="math">\\{0,1\\}^{<em>}</span> to <span class="math">\\{0,1\\}^{\\lambda}</span>. We denote by <span class="math">\\mathcal{U}_{\\star}</span> the set <span class="math">\\bigcup_{\\lambda\\in\\mathbb{N}}\\mathcal{U}_{\\lambda}</span>. A </em>random oracle<em> with security parameter <span class="math">\\lambda</span> is a function <span class="math">\\rho\\colon\\{0,1\\}^{</em>}\\to\\{0,1\\}^{\\lambda}</span> sampled uniformly at random from <span class="math">\\mathcal{U}_{\\lambda}</span>.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">3.1 Algebraic background</h3>

    <p class="text-gray-300">We denote by <span class="math">\\mathbb{F}</span> a finite field and by <span class="math">\\mathbb{K}</span> a finite-dimensional vector space of polynomials over <span class="math">\\mathbb{F}</span>. The notation <span class="math">\\mathbb{F}_{n}</span> is used to denote the field is of size <span class="math">n</span>. Let <span class="math">\\mathbb{K}</span> be of dimension <span class="math">D\\in\\mathbb{N}</span>. Then, denote by <span class="math">\\mathscr{B}</span> an ordered basis of <span class="math">\\mathbb{K}</span> consisting of <span class="math">D</span> linearly independent elements <span class="math">\\{b_{i}\\}_{i\\in[D]}</span>. For a polynomial <span class="math">p\\in\\mathbb{K}</span> and choice of basis <span class="math">\\mathscr{B}</span>, denote by <span class="math">[p]_{\\mathscr{B}}</span> the list of coefficients when <span class="math">p</span> is expressed in <span class="math">\\mathscr{B}</span>. More precisely, <span class="math">[p]_{\\mathscr{B}}:=[a_{1},\\dots,a_{D}]</span> when <span class="math">p</span> is written as <span class="math">\\sum_{i\\in[D]}a_{i}\\cdot b_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We define a <em>punctured basis</em> to be any subset of the basis elements of a specified ambient basis <span class="math">\\mathscr{B}</span>. Formally, a punctured basis <span class="math">\\mathscr{P}</span> is a tuple <span class="math">(\\mathcal{J},\\mathscr{B})</span> where <span class="math">\\mathcal{J}\\subset[D]</span> is an indexing set that enumerates the basis elements of <span class="math">\\mathscr{B}</span> appearing in <span class="math">\\mathscr{P}</span>. We denote by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathscr{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{J}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the size of the punctured basis, and say that a polynomial </span>p<span class="math"> is expressible in a punctured basis </span>\\mathscr{P}<span class="math"> if it can be written as </span>p=\\sum_{j\\in\\mathcal{J}}a_{j}\\cdot b_{j}<span class="math"> for coefficients </span>a_{j}\\in\\mathbb{F}<span class="math"> and basis elements </span>b_{j}\\in\\mathscr{B}<span class="math">. As before, we denote by </span>[p]_{\\mathscr{P}}<span class="math"> the coefficient vector of </span>p<span class="math"> when expressed in </span>\\mathscr{P}<span class="math">, i.e. the list of coefficients </span>[a_{j}]_{j\\in\\mathcal{J}}<span class="math">. We emphasize that </span>p<span class="math"> is expressible in a punctured basis </span>\\mathscr{P}<span class="math"> if and only if all its coefficients with respect to basis elements </span>b_{j}<span class="math"> for </span>j\\notin\\mathcal{J}$ are zero.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">3.1.1 Background on univariate polynomials</h4>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Smooth multiplicative subgroups of finite fields.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our protocols for univariate polynomials work with subgroups <span class="math">K</span> of the multiplicative group <span class="math">\\mathbb{F}^{<em>}</span> of a finite field <span class="math">\\mathbb{F}</span>, and will be most efficient when <span class="math">K</span> has order equal to a power of two. Such domains allow for optimized interpolation techniques via the use of Fast-Fourier Transforms (FFTs). We call such subgroups </em>smooth<em>, or </em>FFT-friendly*, and associate with them an ordering <span class="math">\\phi_{{}_{K}}</span> that is a bijection from <span class="math">K</span> to the set $\\{0,1,\\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Polynomial encodings.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a finite field <span class="math">\\mathbb{F}</span>, multiplicative subgroup <span class="math">K\\subseteq\\mathbb{F}^{*}</span>, and function $f\\colon\\{0,1,\\dots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}\\to\\mathbb{F}<span class="math"> we denote by </span>\\hat{f}<span class="math"> the (unique) univariate polynomial over </span>\\mathbb{F}<span class="math"> with degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{f}(a)=f(\\phi_{{}_{K}}(a))</span> for every <span class="math">a\\in K</span>. That is, if <span class="math">a_{i}</span> is the <span class="math">i</span>-th element of <span class="math">K</span> according to the ordering <span class="math">\\phi_{{}_{K}}</span>, then <span class="math">\\hat{f}(a_{i})=f(i)</span>. We sometimes abuse notation and write <span class="math">\\hat{f}</span> to denote some polynomial that agrees with <span class="math">f</span> on <span class="math">K</span>, which need not equal the (unique) such polynomial of minimal degree.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vanishing polynomials. For a finite field <span class="math">\\mathbb{F}</span> and subgroup <span class="math">S\\subseteq\\mathbb{F}</span>, we denote by <span class="math">v_{S}</span> the unique non-zero monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero everywhere on </span>S<span class="math">; </span>v_{S}<span class="math"> is called the vanishing polynomial of </span>S<span class="math">. If </span>S<span class="math"> is a multiplicative coset in </span>\\mathbb{F}<span class="math"> then </span>v_{S}<span class="math"> can be evaluated in </span>\\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations. For example, if </span>S<span class="math"> is a multiplicative subgroup of </span>\\mathbb{F}<span class="math"> then </span>v_{S}(X)=X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1<span class="math"> and, more generally, if </span>S<span class="math"> is a </span>\\xi<span class="math">-coset of a multiplicative subgroup </span>K<span class="math"> (i.e., </span>S=\\xi K<span class="math">) then </span>v_{S}(X)=\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}v_{K}(X/\\xi)=X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\xi^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">; in either case, </span>v_{S}<span class="math"> can be evaluated in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lagrange polynomials. For <span class="math">\\mathbb{F}</span> a finite field, <span class="math">S\\subseteq\\mathbb{F}</span>, <span class="math">a\\in S</span>, we denote by <span class="math">\\mathcal{L}^{S}_{a}</span> the unique polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> such that </span>\\mathcal{L}^{S}_{a}(a)=1<span class="math"> and </span>\\mathcal{L}^{S}_{a}(b)=0<span class="math"> for all </span>b\\in S\\setminus\\{a\\}$. Note that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{L}^{S}_{a}(X)=\\frac{a\\cdot v_{S}(X)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(X-a)}$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This means that if <span class="math">S</span> is a multiplicative subgroup, and <span class="math">a\\in S</span>, we can evaluate <span class="math">\\mathcal{L}^{S}_{a}(X)</span> at any <span class="math">\\alpha\\in\\mathbb{F}</span> in $\\mathrm{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">3.1.2 Background on multivariate and multilinear polynomials</h4>

    <p class="text-gray-300">A multivariate polynomial <span class="math">p</span> in <span class="math">\\nu</span> variables <span class="math">\\bm{X}=(X_{1},X_{2},\\ldots,X_{\\nu})</span> over a field <span class="math">\\mathbb{F}</span> is a sum of terms of the form <span class="math">p(\\bm{X})=\\sum_{i_{1},i_{2},\\ldots,i_{\\nu}\\in\\mathbb{N}}a_{i_{1},i_{2},\\ldots,i_{\\nu}}X_{1}^{i_{1}}X_{2}^{i_{2}}\\cdots X_{\\nu}^{i_{\\nu}}</span> where <span class="math">a_{i_{1},i_{2},\\ldots,i_{\\nu}}\\in\\mathbb{F}</span> and only finitely many <span class="math">a_{i_{1},i_{2},\\ldots,i_{\\nu}}</span> are non-zero. We denote by <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{\\nu}]</span> the ring of multivariate polynomials over <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Total degree and individual degree. The individual degree of a variable <span class="math">X_{j}</span> in a term <span class="math">a_{i_{1},i_{2},\\ldots,i_{n}}X_{1}^{i_{1}}X_{2}^{i_{2}}\\cdots X_{\\nu}^{i_{\\nu}}</span> is defined as <span class="math">\\deg_{j}(p):=i_{j}</span>. The maximum individual degree is defined as <span class="math">\\deg^{*}(p):=\\max_{i\\in[n]}\\deg_{i}(p)</span>. The total degree of a term <span class="math">a_{i_{1},i_{2},\\ldots,i_{\\nu}}X_{1}^{i_{1}}X_{2}^{i_{2}}\\cdots X_{\\nu}^{i_{\\nu}}</span> is the sum of the exponents <span class="math">i_{1}+i_{2}+\\cdots+i_{\\nu}</span>. The total degree of the polynomial <span class="math">p</span>, denoted by <span class="math">\\deg(p)</span>, is the maximum total degree of any term.</p>

    <p class="text-gray-300">Boolean hypercube. The boolean hypercube of dimension <span class="math">\\nu</span> is the set of all binary vectors of length <span class="math">n</span>. Formally, it is defined as <span class="math">\\mathcal{B}_{\\nu}:=\\{0,1\\}^{\\nu}=\\{(x_{1},x_{2},\\ldots,x_{\\nu})\\mid x_{i}\\in\\{0,1\\}</span> for all <span class="math">i\\in\\{1,2,\\ldots,\\nu\\}\\}</span> .</p>

    <p class="text-gray-300">Multilinear extension (MLE). A multivariate polynomial <span class="math">p(\\bm{X})</span> is multilinear if it is a linear function in each variable <span class="math">X_{i}</span> when the remainder of the variables are held constant. This implies that the individual degree of each variable in <span class="math">p</span> is at most one. Furthermore, any function <span class="math">f:\\mathcal{B}_{\\nu}\\rightarrow\\mathbb{F}</span> has a unique multilinear extension defined as the polynomial <span class="math">\\hat{f}(\\bm{X})</span> such that <span class="math">\\hat{f}</span> agrees with <span class="math">f</span> on all points in <span class="math">\\mathcal{B}_{\\nu}</span>.</p>

    <p class="text-gray-300">Multilinear polynomial vector space. We denote the <span class="math">2^{\\nu}</span>-dimensional vector space of multilinear polynomials over <span class="math">\\mathbb{F}</span> in the ring <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{\\nu}]</span> by <span class="math">\\text{Mult}(\\mathbb{F}[X_{1},\\ldots,X_{\\nu}])</span>.</p>

    <p class="text-gray-300">Lagrange multilinear polynomials. For a given point <span class="math">\\alpha=(\\alpha_{1},\\alpha_{2},\\ldots,\\alpha_{\\nu})\\in\\mathcal{B}_{\\nu}</span>, the Lagrange multilinear basis polynomial <span class="math">\\chi_{\\alpha}</span> is defined as <span class="math">\\chi_{\\alpha}(\\bm{X}):=\\prod_{i=1}^{\\nu}(1-(1-2\\alpha_{i})X_{i})</span></p>

    <p class="text-gray-300">Computing the MLE using Lagrange polynomials. The unique multilinear extension of any function <span class="math">f:\\mathcal{B}_{\\nu}\\rightarrow\\mathbb{F}</span> is <span class="math">\\hat{f}(\\bm{X}):=\\sum_{\\alpha\\in\\{0,1\\}^{\\nu}}f(\\alpha)\\cdot\\chi_{\\alpha}(\\bm{X})</span>. Note <span class="math">\\hat{f}</span> can be computed in <span class="math">O(2^{\\nu})</span> field operations.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">3.2 Cryptographic assumptions</h3>

    <p class="text-gray-300">We describe the cryptographic assumptions that underlie the constructions of the polynomial commitment schemes (Section 4) and SNARKs (Section 5) in this paper. In Section 3.2.1 we provide background on</p>

    <p class="text-gray-300">bilinear groups and define the bilinear group sampler. In Section 3.2.2 we define (a minor variant of) the Strong Diffie-Hellman Assumption. In Section 3.2.3 we recall the Algebraic Group Model.</p>

    <p class="text-gray-300">The cryptographic primitives that we construct rely on cryptographic assumptions about bilinear groups. We formalize these via a bilinear group sampler, which is a probabilistic polynomial-time algorithm SampleGrp that, on input a security parameter  <span class="math">\\lambda</span>  (represented in unary), outputs a tuple  <span class="math">\\langle \\mathrm{group} \\rangle = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, G, H, e)</span>  where  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  are cyclic groups of a prime order  <span class="math">q \\in \\mathbb{N}</span> ,  <span class="math">G</span>  generates  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">H</span>  generates  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  is a (non-degenerate) bilinear map. In more detail,  <span class="math">e</span>  satisfies the following two properties: (i) bilinearity: for all nonzero elements  <span class="math">\\alpha, \\beta \\in \\mathbb{F}_q</span> , it holds that  <span class="math">e(\\alpha G, \\beta H) = e(G, H)^{\\alpha \\beta}</span> ; (ii) non-degeneracy:  <span class="math">e(G, H)</span>  is not the identity element in  <span class="math">\\mathbb{G}_T</span> . Moreover,  <span class="math">e</span>  is called a cryptographic pairing if it is efficiently computable. The SNARK constructions presented in this paper are based on cryptographic pairings.</p>

    <p class="text-gray-300">Assumption 1 ([BB04]). The Strong Diffie-Hellman (SDH) assumption states that for every efficient adversary  <span class="math">\\mathcal{A}</span>  and degree bound  <span class="math">d\\in \\mathbb{N}</span> , the following probability is negligible in the security parameter  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} C = \\frac {1}{\\beta + c} G &amp;amp; \\begin{array}{c} \\langle \\mathsf {g r o u p} \\rangle \\leftarrow \\mathsf {S a m p l e G r p} (1 ^ {\\lambda}) \\\\ \\beta \\leftarrow \\mathbb {F} _ {q} \\\\ \\boldsymbol {\\Sigma} \\leftarrow \\{\\{\\beta^ {i} G \\} _ {i = 0} ^ {d}, \\beta H \\} \\\\ (c, C) \\leftarrow \\mathcal {A} (\\langle \\mathsf {g r o u p} \\rangle , \\boldsymbol {\\Sigma}) \\end{array} \\end{array} \\right]</span></div>

    <p class="text-gray-300">In order to achieve additional efficiency, we construct polynomial commitment schemes in the Algebraic Group Model (AGM) [FKL18] which replaces specific knowledge assumptions (such as Power Knowledge of Exponent [Gro10] assumptions). In the AGM, all algorithms are modeled as algebraic, which means that whenever an algorithm outputs a group element  <span class="math">G</span> , the algorithm must also output an "explanation" of  <span class="math">G</span>  in terms of the group elements it has seen.</p>

    <p class="text-gray-300">Definition 3.1 (algebraic algorithm). Let  <span class="math">\\mathbb{G}</span>  be cyclic group of prime order  <span class="math">q</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  a probabilistic algorithm run on initial inputs including description  <span class="math">\\langle \\mathrm{group} \\rangle</span>  of  <span class="math">\\mathbb{G}</span> . During its execution  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  may interact with oracles or other parties and receive further inputs including obliviously sampled group elements (which it cannot sample directly). Let  <span class="math">\\pmb{L} \\in \\mathbb{G}^n</span>  be the list of all group elements  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  has been given so far such that all other inputs it has received do not depend in any way on group elements. We call  <span class="math">\\mathcal{A}_{\\mathrm{alg}}</span>  algebraic if whenever it outputs a group element  <span class="math">G \\in \\mathbb{G}</span>  it also outputs a vector  <span class="math">\\pmb{a} = [a_i]_{i=1}^n \\in \\mathbb{F}_q^n</span>  such that  <span class="math">G = \\sum_{i=1}^n a_i L_i</span> . The coefficients  <span class="math">\\pmb{a}</span>  are called the "representation" of  <span class="math">G</span>  with respect to  <span class="math">\\pmb{L}</span> , denoted  <span class="math">G := \\langle \\pmb{a}, \\pmb{L} \\rangle</span> .</p>

    <p class="text-gray-300">An indexed relation  <span class="math">\\mathcal{R}</span>  is a set of triples  <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w})</span>  where  <span class="math">\\mathfrak{i}</span>  is the index,  <span class="math">\\mathfrak{x}</span>  is the instance, and  <span class="math">\\mathfrak{w}</span>  is the witness. An indexed oracle relation is an indexed relation where the index  <span class="math">\\mathfrak{i}</span>  and the instance  <span class="math">\\mathfrak{x}</span>  contain "implicit"</p>

    <p class="text-gray-300">inputs that are specified as oracles, i.e., the membership-checking algorithm for such a relation has only query access to these oracles. We adopt notation from <em>[x1]</em> and use <span class="math">\\llbracket z\\rrbracket</span> to denote when the input <span class="math">z</span> is provided as an oracle.</p>

    <p class="text-gray-300">In this work, we will consider constraint systems that support a rich variety of constraints. We begin by formalizing these constraints first, and then describe our new constraint system relation, which we call the Generalized Rank-1 Constraint System (GR1CS) relation.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 3.2 (local predicate).</h6>

    <p class="text-gray-300">Given a finite field <span class="math">\\mathbb{F}</span> and an input arity <span class="math">t\\in\\mathbb{N}</span>, a local predicate <span class="math">L</span> is a function <span class="math">L:\\mathbb{F}^{t}\\rightarrow\\{0,1\\}</span>. An input <span class="math">x\\in\\mathbb{F}^{t}</span> is said to satisfy <span class="math">L</span> if <span class="math">L(x)=0</span>.</p>

    <p class="text-gray-300">Examples of local predicates include:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Polynomial predicate <span class="math">P</span> defined by a polynomial <span class="math">p\\in\\mathbb{F}[X_{1},\\ldots,X_{t}]</span>, so that <span class="math">P(X_{1},\\ldots,X_{t})=0</span> if and only if <span class="math">p(X_{1},\\ldots,X_{t})=0</span>.</li>

      <li>Table membership predicate <span class="math">T</span> defined by a finite subset <span class="math">\\mathcal{T}\\subset\\mathbb{F}^{t}</span>, so that <span class="math">T(X_{1},\\ldots,X_{t})=0</span> if and only if <span class="math">(X_{1},\\ldots,X_{t})\\in\\mathcal{T}</span>.</li>

    </ul>

    <p class="text-gray-300">For simplicity, we will stipulate that all the local predicates considered in this paper have the same number of input variables <span class="math">n</span>, same number of total variables <span class="math">k</span>, and same arity <span class="math">t</span>.</p>

    <p class="text-gray-300">Generalized R1CS (GR1CS). To capture constraint systems that support richer kinds of constraints, we introduce a new NP relation that we call Generalized R1CS (GR1CS). Informally, GR1CS generalizes R1CS along two dimensions.</p>

    <p class="text-gray-300">First, instead of considering just a simple quadratic polynomial predicate of the form <span class="math">(Az)_{i}\\cdot(Bz)_{i}-(Cz)_{i}=0</span>, we support arbitrary local predicates (e.g., using a different polynomial predicate <span class="math">(Az)_{i}\\cdot(Bz)_{i}\\cdot(Cz)_{i}=0</span>, or using a lookup predicate), and furthermore support multiple different kinds of lookup predicates in the same instance. Second, instead of three constraint matrices, a GR1CS instance can contain an arbitrary natural number <span class="math">t</span> of matrices. This corresponds to the arity of the local predicates in an instance. We formalize this high-level description below.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 3.3 (generalized R1CS (GR1CS) indexed relation).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\text{GRICS}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})=\\big{(}\\,(\\mathbb{F},n,k,m,c,t,\\mathscr{C})\\,,x,w\\big{)}</span></p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li><span class="math">\\mathbb{F}</span> is a finite field,</li>

      <li><span class="math">n</span> is the number of public input (instance) variables,</li>

      <li><span class="math">k</span> is the total number of variables in the constraint system,</li>

      <li><span class="math">c</span> is the number of constraint sets.</li>

      <li><span class="math">t</span> is the arity of the predicates</li>

      <li><span class="math">\\mathscr{C}=[C]_{i=1}^{c}</span> is a set of custom constraints, where for each constraint <span class="math">C:=(L_{i},\\bm{M}_{i},m_{i})</span>,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bm{M}_{i}:=M_{i,1},\\ldots,M_{i,t}\\in\\mathbb{F}^{m_{i}\\times k}</span> are constraint matrices, and</li>

      <li><span class="math">L_{i}</span> is a local predicate (Definition 3.2).</li>

    </ul>

    <p class="text-gray-300">A triple <span class="math">(\\mathbb{i},\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}_{\\text{GRICS}}</span> if for each <span class="math">(L_{i},\\bm{M}_{i},m_{i})\\in\\mathscr{C}</span> and each <span class="math">j\\in[m_{i}]</span>,</p>

    <p class="text-gray-300"><span class="math">L((M_{i,1}z)[j],\\ldots,(M_{i,t}z)[j])=0</span></p>

    <p class="text-gray-300">where <span class="math">z:=(x,w)\\in\\mathbb{F}^{k}</span>.</p>

    <p class="text-gray-300">Note that the foregoing definition assumes that all predicates have the same arity <span class="math">t</span>. This is without loss of generality, as one can always pad the arity of the predicates with dummy variables.</p>

    <p class="text-gray-300">It is clear that GR1CS generalizes R1CS, as the latter is a special case of the former where <span class="math">t=3</span> and <span class="math">L</span> is the quadratic polynomial predicate <span class="math">L(a,b,c)=ab-c</span>. We will also consider the following special case of GR1CS called the <em>Square R1CS</em> (SR1CS) relation <em>[x13]</em>, which is a special case of GR1CS where <span class="math">t=2</span> and <span class="math">L</span> is the polynomial predicate <span class="math">L(a,b)=a^{2}-b</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 3.4 (Square R1CS <em>[x13]</em>).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{SR1CS}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})=\\big{(}(\\mathbb{F},n,k,m,A,B),x,w\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">n</span>, <span class="math">k</span>, and <span class="math">m</span> are natural numbers, <span class="math">x\\in\\mathbb{F}^{n}</span> and <span class="math">w\\in\\mathbb{F}^{k-n}</span> are vectors over <span class="math">\\mathbb{F}</span>, and <span class="math">A,B</span> are <span class="math">m\\times k</span> matrices over <span class="math">\\mathbb{F}</span> such that <span class="math">Az\\circ Az=Bz</span>, where <span class="math">z:=(x,w)</span> is a vector in <span class="math">\\mathbb{F}^{k}</span>.</p>

    <p class="text-gray-300">Groth and Maller <em>[x13]</em> show that R1CS can be reduced to SR1CS, thus making SR1CS NP-complete.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 3.5.</h6>

    <p class="text-gray-300">In this paper, we will consider instances of GR1CS where the matrices obtained by concatenating the constraint matrices all have rank at least equal to the number of variables in the GR1CS instance. This is without loss of generality, as one can always add a small number of dummy constraints to ensure this property. This requirement arises due to technicalities in the knowledge-soundness proof of our SNARK construction.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">3.4 Polynomial interactive oracle proofs</h3>

    <p class="text-gray-300">A polynomial interactive oracle proof (PIOP) <em>[x10, x1]</em> over a field family <span class="math">\\mathcal{F}</span> for an indexed oracle relation <span class="math">\\mathcal{R}</span> is a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PIOP}=(\\mathbb{F},\\mathbb{K},\\mathsf{r},\\mathsf{s},\\mathbf{I},\\mathbf{P},\\mathbf{V})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> is a finite field, <span class="math">\\mathbb{K}</span> is a polynomial vector space over <span class="math">\\mathbb{F}</span> with a canonical basis <span class="math">\\mathscr{U}</span> and dimension <span class="math">d</span>, <span class="math">\\mathsf{r},\\mathsf{s},:\\left\\{0,1\\right\\}^{<em>}\\to\\mathbb{N}</span> are polynomial-time computable functions and <span class="math">\\mathbf{I},\\mathbf{P},\\mathbf{V}</span> are three algorithms known as the </em>indexer<em>, </em>prover<em>, and </em>verifier*. The parameter <span class="math">\\mathsf{r}</span> specifies the number of interaction rounds and <span class="math">\\mathsf{s}</span> specifies the number of polynomials in each round.</p>

    <p class="text-gray-300">In the offline phase (“<span class="math">0</span>-th round”), the indexer <span class="math">\\mathbf{I}</span> receives as input a field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and an index <span class="math">\\mathfrak{i}</span> for <span class="math">\\mathcal{R}</span>, and outputs <span class="math">\\mathsf{s}(0)</span> polynomials <span class="math">p_{0,1},\\ldots,p_{0,\\mathsf{s}(0)}\\in\\mathbb{K}</span>. Note that the offline phase does not depend on any particular instance or witness, and merely considers the task of encoding the given index <span class="math">\\mathfrak{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an instance <span class="math">\\mathtt{x}</span> and witness <span class="math">\\mathtt{w}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span>, the prover <span class="math">\\mathbf{P}</span> receives <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> and the verifier <span class="math">\\mathbf{V}</span> receives <span class="math">(\\mathbb{F},\\mathtt{x})</span> with oracle access to the polynomials output by <span class="math">\\mathbf{I}(\\mathbb{F},\\mathtt{w})</span>. If <span class="math">\\mathcal{R}</span> is an oracle relation, then the verifier also has oracle access to the polynomials in the instance. The prover <span class="math">\\mathbf{P}</span> and the verifier <span class="math">\\mathbf{V}</span> interact over $\\mathsf{r}=\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds, where in the </span>i<span class="math">-th round, the verifier </span>\\mathbf{V}<span class="math"> sends a message </span>\\rho_{i}\\in\\mathbb{F}^{*}<span class="math"> to the prover </span>\\mathbf{P}<span class="math">; then the prover </span>\\mathbf{P}<span class="math"> replies with </span>\\mathsf{s}(i)<span class="math"> oracle polynomials </span>p_{i,1},\\ldots,p_{i,\\mathsf{s}(i)}\\in\\mathbb{K}<span class="math">. After the interaction, the verifier invokes the query algorithm </span>\\mathbf{Q}_{\\mathbf{V}}<span class="math"> to form a query set </span>Q<span class="math"> that contains queries to all of the polynomials provided to the verifier. Afterward, The verifier invokes the decision algorithm </span>\\mathbf{D}_{\\mathbf{V}}$ to decide whether to accept or reject on the basis of the responses to these queries and its internal state.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this paper, we only consider PIOPs that are public-coin and where the verifier’s queries are non-adaptive. PIOPs must satisfy standard notions of completeness, soundness, knowledge-soundness and zero knowledge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{w},\\mathtt{x})\\in\\mathcal{R}</span>, the probability that <span class="math">\\mathbf{P}(\\mathbb{F},\\mathfrak{i},\\mathtt{w},\\mathtt{x})</span> convinces <span class="math">\\mathbf{V}(\\mathbb{F},\\mathtt{x})</span> to accept in the interactive oracle protocol is 1.</li>

      <li>Soundness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index-instance pair <span class="math">(\\mathfrak{i},\\mathtt{x})\\notin\\mathcal{L}(\\mathcal{R})</span>, and prover <span class="math">\\mathbf{P}</span>, the probability that <span class="math">\\mathbf{P}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathbb{F},\\mathfrak{i})}(\\mathbb{F},\\mathtt{x})</span> to accept in the interactive oracle protocol does not exceed <span class="math">\\epsilon</span>, defined as the soundness error.</li>

    </ul>

    <p class="text-gray-300">We note that prover's strategy can be characterized by the next-message functions (one for each round) that given the inputs so far and an internal state, outputs the next message to be sent to the verifier. We denote the next message function for the  <span class="math">i</span> -th round as  <span class="math">\\mathbf{P}_i(\\mathsf{st},[\\rho_j]_{j=1}^{i-1}) \\to (\\mathsf{st}&#x27;,[p_{i,j}]_{j=1}^{\\mathsf{s}(i)})</span></p>

    <p class="text-gray-300">An argument of knowledge ARG for an indexed NP relation  <span class="math">\\mathcal{R}</span>  is a tuple of algorithms  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  that satisfies the following syntax and properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The generator  <span class="math">\\mathcal{G}</span>  is a probabilistic algorithm that takes as input a security parameter  <span class="math">\\lambda</span>  (in unary) and an index  <span class="math">\\mathbb{1}</span>  and outputs the proving and verifying keys  <span class="math">(\\mathrm{ipk},\\mathrm{ivk})</span> .</li>

      <li>The prover  <span class="math">\\mathcal{P}</span>  is a probabilistic algorithm that takes as input the proving key  <span class="math">\\mathrm{ipk}</span> , an instance  <span class="math">\\mathbf{x}</span> , and a witness  <span class="math">\\mathbf{w}</span>  and outputs a proof  <span class="math">\\pi</span> .</li>

      <li>The verifier  <span class="math">\\mathcal{V}</span>  is a deterministic algorithm that takes as input the verifying key  <span class="math">\\mathrm{ivk}</span> , an instance  <span class="math">\\mathbf{x}</span> , and a proof  <span class="math">\\pi</span>  and outputs a bit indicating whether  <span class="math">\\pi</span>  is valid.</li>

    </ul>

    <p class="text-gray-300">These above algorithms must satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all size bounds  <span class="math">\\mathsf{N} \\in \\mathbb{N}</span>  and efficient adversaries  <span class="math">\\mathcal{A}</span> ,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\mathbb {1}, \\mathbb {x}, \\mathbb {w}) \\in \\mathcal {R} _ {\\mathsf {N}} &amp;amp; (\\mathbb {1}, \\mathbb {x}, \\mathbb {w}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathbb {p k}, \\mathbb {w}) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathbb {1}) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. For every size bound  <span class="math">\\mathsf{N} \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1, \\tilde{\\mathcal{P}}_2, \\tilde{\\mathcal{P}}_3)</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that the following holds:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} (\\mathbb {1}, \\mathbb {x}, \\mathbb {w}) \\notin \\mathcal {R} _ {\\mathsf {N}} &amp;amp; (\\mathbb {1}, \\mathsf {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathbb {p k}, \\mathsf {i v k}) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathbb {1}) \\\\ \\langle \\tilde {\\mathcal {P}} _ {3} (\\mathsf {s t} ^ {\\prime}), \\mathcal {V} (\\mathsf {i v k}, \\mathbb {x}) \\rangle = 1 &amp;amp; (\\mathbb {x}, \\mathsf {s t} ^ {\\prime}) \\leftarrow \\tilde {\\mathcal {P}} _ {2} (\\mathsf {s t}, \\mathsf {i p k}) \\\\ &amp;amp; \\mathbb {w} \\leftarrow \\mathcal {E} (\\mathsf {i p k}, \\mathbb {x}) \\end{array} \\right] = \\operatorname {n e g l} (\\lambda) \\quad .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness. The size of the communication transcript between the prover  <span class="math">\\mathcal{P}(\\mathrm{ipk},\\mathbb{x},\\mathbb{w})</span>  and verifier  <span class="math">\\mathcal{V}(\\mathrm{ivk},\\mathbb{x})</span>  is  $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda)<span class="math">  and the running time of  </span>\\mathcal{V}(\\mathrm{ivk},\\mathbb{x})<span class="math">  is  </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public-coin. ARG is public-coin if every message output by the verifier  <span class="math">\\mathcal{V}</span>  is a uniform random string of some prescribed length. All constructions in this paper are public-coin, and have sublinear length, hence can be transformed into SNARKs using the Fiat-Shamir transformation [FS86].</li>

    </ul>

    <p class="text-gray-300">4 Equifficient polynomial commitments</p>

    <p class="text-gray-300">We describe our new notion of polynomial commitment (PC) schemes that enforce coefficient-equality (or <em>equifficient</em>) constraints on committed polynomials. We begin by defining <em>equifficient</em> constraints, and then use this definition to formally define our notion of <em>equifficient</em> polynomial commitment (EPC) schemes in Section 4.1. We then provide constructions of EPC schemes for univariate and multivariate polynomials in Sections 4.2 and 4.3, respectively.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Coefficient-equality constraints.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{K}</span> be a <span class="math">D</span>-dimensional vector space of polynomials over a field <span class="math">\\mathbb{F}</span>. Then, a coefficient-equality (or <em>equifficient</em>) constraint <span class="math">\\Lambda</span> on polynomials in <span class="math">\\mathbb{K}</span> is a list $[\\mathcal{P}_{1},\\ldots,\\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> of punctured bases (Section 3.1) for </span>\\mathbb{K}<span class="math">. We say that </span>\\Lambda<span class="math"> is satisfied for a list of polynomials </span>\\bm{p}=[p_{1},\\ldots,p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> if and only if these polynomials are expressible in their respective punctured bases, and that the coefficient vectors of the polynomials in these punctured bases are equal: </span>[p_{1}]_{\\mathcal{P}_{1}}=\\cdots=[p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]_{\\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">. We denote this constraint satisfaction by the predicate </span>\\Lambda(\\bm{p})=1<span class="math">. If </span>\\Lambda<span class="math"> is specified by a single punctured basis, then we call the constraint <em>trivial</em>, and assume without loss of generality the basis is the unpunctured canonical basis for </span>\\mathbb{K}<span class="math">, denoted by </span>\\mathscr{U}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">4.1 Definition</h3>

    <p class="text-gray-300">An <em>equifficient polynomial commitment</em> scheme <span class="math">\\mathsf{EPC}=(\\mathsf{Setup},\\mathsf{Specialize},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span> over the field family <span class="math">\\mathcal{F}</span> for univariate or multilinear polynomials is a tuple of algorithms with the following syntax and properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{EPC.Setup}(1^{\\lambda},D)\\to\\mathsf{pp}</span>. On input a security parameter <span class="math">1^{\\lambda}</span> (in unary) and a maximum dimension <span class="math">D</span>, <span class="math">\\mathsf{EPC.Setup}</span> samples public parameters <span class="math">\\mathsf{pp}</span> containing a description of a finite field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and a polynomial vector space <span class="math">\\mathbb{K}</span> over <span class="math">\\mathbb{F}</span> of dimension <span class="math">D</span>, along with a canonical basis <span class="math">\\mathscr{U}</span> for <span class="math">\\mathbb{K}</span>.</li>

      <li><span class="math">\\mathsf{EPC.Specialize}^{\\mathsf{pp}}(\\bm{\\Omega})\\to(\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})</span>. Given oracle access to the parameters <span class="math">\\mathsf{pp}</span>, and input a set <span class="math">\\bm{\\Omega}=\\{\\Omega_{1},\\ldots,\\Omega_{n}\\}</span> of <em>equifficient</em> constraints, <span class="math">\\mathsf{EPC.Specialize}</span> specializes <span class="math">\\mathsf{pp}</span> to create <em>committer</em>, <em>opener</em>, and <em>verifier</em> keys <span class="math">(\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})</span> that enable enforcing the constraints in <span class="math">\\bm{\\Omega}</span> on committed polynomials. The keys contain a description of the vector space <span class="math">\\mathbb{K}</span> and the constraints <span class="math">\\bm{\\Omega}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{EPC.Commit}(\\mathsf{ck},\\bm{P},\\bm{\\Lambda})\\to c</span>. On input a <em>committer</em> key <span class="math">\\mathsf{ck}</span>, a list <span class="math">\\bm{P}=[\\bm{p}_{1},\\ldots,\\bm{p}_{m}]</span> whose <span class="math">i</span>-th element $\\bm{p}_{i}=[p_{i,1},\\ldots,p_{i,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> is a list of polynomials, and a set of <em>equifficient</em> constraints </span>\\bm{\\Lambda}=\\{\\Lambda_{1},\\ldots,\\Lambda_{m}\\}<span class="math"> indicating that </span>\\bm{p}_{i}<span class="math"> is subject to the constraint </span>\\Lambda_{i}<span class="math">, </span>\\mathsf{EPC.Commit}<span class="math"> outputs a commitment </span>c<span class="math"> to </span>\\bm{P}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{EPC.Open}(\\mathsf{ok},\\bm{P},\\bm{\\Lambda},u)\\to\\pi</span>. On input an <em>opener</em> key <span class="math">\\mathsf{ok}</span>, a list <span class="math">\\bm{P}=[\\bm{p}_{1},\\ldots,\\bm{p}_{m}]</span>, a set of <em>equifficient</em> constraints <span class="math">\\bm{\\Lambda}=\\{\\Lambda_{1},\\ldots,\\Lambda_{m}\\}</span>, and an evaluation point <span class="math">u</span>, <span class="math">\\mathsf{EPC.Open}</span> outputs an evaluation proof <span class="math">\\pi</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{EPC.Verify}(\\mathsf{vk},c,u,\\bm{V},\\bm{\\Lambda},\\pi)\\to b</span>. On input a <em>verifier</em> key <span class="math">\\mathsf{vk}</span>, a commitment <span class="math">c</span>, an evaluation point <span class="math">u</span>, a list <span class="math">\\bm{V}=[\\bm{v}_{1},\\ldots,\\bm{v}_{m}]</span> whose <span class="math">i</span>-th element $\\bm{v}_{i}=[v_{i,1},\\ldots,v_{i,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> is a list of claimed evaluations, a set of <em>equifficient</em> constraints </span>\\bm{\\Lambda}=\\{\\Lambda_{1},\\ldots,\\Lambda_{m}\\}<span class="math"> indicating that </span>\\bm{v}_{i}<span class="math"> is associated to the constraint </span>\\Lambda_{i}<span class="math">, and an evaluation proof </span>\\pi<span class="math">, </span>\\mathsf{EPC.Verify}<span class="math"> accepts if and only if for every </span>i\\in[m]$, the following conditions hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the constraint <span class="math">\\Lambda_{i}</span> is contained in the <span class="math">\\mathsf{vk}</span>; that is, <span class="math">\\Lambda_{i}\\in\\bm{\\Omega}</span>.</li>

      <li>for each evaluation <span class="math">v_{i,j}\\in\\bm{v}_{i}</span>, the polynomial <span class="math">p_{i,j}</span> committed to in <span class="math">c</span> evaluates to <span class="math">v_{i,j}</span> at <span class="math">u</span>.</li>

      <li>the polynomials associated to <span class="math">\\bm{v}_{i}</span> are <em>equifficient</em> with respect to <span class="math">\\Lambda_{i}</span>, that is, <span class="math">\\Lambda_{i}(\\bm{p}_{i})=1</span>.</li>

    </ul>

    <p class="text-gray-300">We now define our new notions of completeness and <em>equfficient extractability</em> for EPC schemes that extend the standard notions for standard PC schemes <em>[x10]</em>. We often tactfully abuse notation by denoting <span class="math">\\bm{P}</span> as the vector <span class="math">\\bm{p}_{1}\\mid\\cdots\\mid\\bm{p}_{m}</span> and <span class="math">\\bm{V}</span> as the vector <span class="math">\\bm{v}_{1}\\mid\\cdots\\mid\\bm{v}_{m}</span>.</p>

    <h5 id="sec-59" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300">For every maximum dimension <span class="math">D</span> and efficient adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\dim(\\bm{P})\\leq D\\\\ \\Downarrow\\\\ \\text{EPC.Verify}(\\mathsf{vk},c,u,\\bm{V},\\bm{\\Lambda},\\pi)=1\\end{array}\\right]\\begin{array}[]{c}\\mathsf{pp}\\leftarrow\\text{EPC.Setup}(1^{\\lambda},D)\\\\ \\bm{\\Omega}\\leftarrow\\mathcal{A}_{1}(1^{\\lambda},\\mathsf{pp})\\\\ (\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})\\leftarrow\\text{EPC.Specialize}^{\\mathsf{pp}}(\\bm{\\Omega})\\\\ (\\bm{P},\\bm{\\Lambda},u)\\leftarrow\\mathcal{A}_{2}(\\mathsf{ck},\\mathsf{ok})\\\\ c\\leftarrow\\text{EPC.Commit}(\\mathsf{ck},\\bm{P},\\bm{\\Lambda})\\\\ \\pi\\leftarrow\\text{EPC.Open}(\\mathsf{ok},\\bm{P},\\bm{\\Lambda},u)\\\\ \\bm{V}:=\\bm{P}(u)\\end{array}\\right]=1\\ . \\]</p>

    <h5 id="sec-60" class="text-base font-semibold mt-4">Extractability.</h5>

    <p class="text-gray-300">For every maximum dimension <span class="math">D</span>, and every efficient stateful adversary <span class="math">(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>, there exists an efficient extractor <span class="math">\\mathcal{E}</span> such that for every round bound <span class="math">\\mathsf{r}\\in\\mathbb{N}</span>, efficient public-coin sampler <span class="math">\\mathcal{C}</span>, efficient query sampler <span class="math">\\mathcal{Q}</span>, efficient constraint sampler <span class="math">\\mathcal{S}</span>, and efficient adversary <span class="math">\\mathcal{A}_{3}</span>, the probability below is negligibly close to <span class="math">1</span> (as a function of <span class="math">\\lambda</span>):</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\forall i\\in\\{1,\\ldots,r\\}:\\\\ \\text{EPC.Verify}(\\mathsf{vk},c_{i},u,\\bm{V}_{i},\\bm{\\Lambda}_{i},\\pi_{i})=1\\\\ \\Downarrow\\\\ \\bm{P}_{i}(u)=\\bm{V}_{i}\\\\ \\wedge\\\\ \\bigwedge_{j=1}^{m_{i}}\\Lambda_{i,j}(\\bm{p}_{i,j})=1\\end{array}\\right]\\begin{array}[]{c}\\mathsf{pp}\\leftarrow\\text{EPC.Setup}(1^{\\lambda},D)\\\\ \\bm{\\Omega}\\leftarrow\\mathcal{A}_{1}(1^{\\lambda},\\mathsf{pp})\\\\ (\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})\\leftarrow\\text{EPC.Specialize}^{\\mathsf{pp}}(\\bm{\\Omega})\\\\ \\hline\\cr\\text{For }i\\in\\{1,\\ldots,r\\}:\\\\ \\bm{\\Lambda}_{i}=\\{\\Lambda_{i,1},\\ldots,\\Lambda_{i,m_{i}}\\}\\leftarrow\\mathcal{S}(\\mathsf{ck},\\mathsf{ok})\\\\ \\rho_{i}\\leftarrow\\mathcal{C}(\\mathsf{ck},\\mathsf{ok},i)\\\\ c_{i}\\leftarrow\\mathcal{A}_{2}(\\mathsf{ck},\\mathsf{ok},[\\bm{\\Lambda}_{j}]_{j=1}^{i},[\\rho_{j}]_{j=1}^{i})\\\\ \\bm{P}_{i}=[\\bm{p}_{i,1},\\ldots,\\bm{p}_{i,m_{i}}]\\leftarrow\\mathcal{E}(\\mathsf{ck},\\mathsf{ok},[\\bm{\\Lambda}_{j}]_{j=1}^{i},[\\rho_{j}]_{j=1}^{i})\\\\ u\\leftarrow\\mathcal{Q}(\\mathsf{ck},\\mathsf{ok},[\\bm{\\Lambda}_{i}]_{i=1}^{t},[c_{i}]_{i=1}^{t},[\\rho_{i}]_{i=1}^{t})\\\\ ([\\bm{V}_{i}]_{i=1}^{t},[\\pi_{i}]_{i=1}^{t})\\leftarrow\\mathcal{A}_{3}(u)\\end{array}\\right]. \\]</p>

    <p class="text-gray-300">The foregoing definition assumes that the adversary <span class="math">\\mathcal{A}_{3}</span> shares state with the adversaries <span class="math">\\mathcal{A}_{1}</span> and <span class="math">\\mathcal{A}_{2}</span>.</p>

    <h5 id="sec-61" class="text-base font-semibold mt-4">Succinctness.</h5>

    <p class="text-gray-300">An equifficient polynomial commitment scheme is succinct if the size of the commitments, the size of the evaluation proofs, the time to check an opening, and the representation of the lists of punctured bases <span class="math">\\Lambda_{1},\\ldots,\\Lambda_{m}</span> are all independent of the dimension of <span class="math">\\mathbb{K}</span>. Note that achieving succinct verification cost requires EPC.Verify to take as input a succinct representation of the punctured bases <span class="math">\\Lambda_{1},\\ldots,\\Lambda_{m}</span>. This can be achieved by modifying EPC.Verify so that instead of taking as input the equifficient constraints <span class="math">\\{\\Lambda_{1},\\ldots,\\Lambda_{m}\\}</span> directly, it instead takes as input their indices in <span class="math">\\bm{\\Omega}</span>. In this section we stick to the original syntax as we found it easier to use, but briefly describe the modified syntax below, with differences highlighted in blue.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- EPC.Verify(<span class="math">\\mathsf{vk},c,u,\\bm{V},\\bm{\\Lambda},\\pi)\\rightarrow b</span>. On input a verifier key <span class="math">\\mathsf{vk}</span>, a commitment <span class="math">c</span>, an evaluation point <span class="math">u</span>, a list <span class="math">\\bm{V}=[\\bm{v}_{1},\\ldots,\\bm{v}_{m}]</span> whose <span class="math">i</span>-th element $\\bm{v}_{i}=[v_{i,1},\\ldots,v_{i,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> is a list of claimed evaluations, a set of indices </span>\\bm{\\Lambda}=\\{\\mathsf{ind}_{1},\\ldots,\\mathsf{ind}_{m}\\}<span class="math"> indicating that </span>\\bm{v}_{i}<span class="math"> is associated to the constraint </span>\\Omega_{\\mathsf{ind}_{i}}<span class="math">, and an evaluation proof </span>\\pi<span class="math">, EPC.Verify accepts if and only if for every </span>i\\in[m]$, the following conditions hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the index <span class="math">\\mathsf{ind}_{i}</span> references a constraint in <span class="math">\\bm{\\Omega}</span>; that is, <span class="math">1\\leq\\mathsf{ind}_{i}\\leq n</span>.</li>

      <li>for each evaluation <span class="math">v_{i,j}\\in\\bm{v}_{i}</span>, the polynomial <span class="math">p_{i,j}</span> committed to in <span class="math">c</span> evaluates to <span class="math">v_{i,j}</span> at <span class="math">u</span>.</li>

      <li>the polynomials associated to <span class="math">\\bm{v}_{i}</span> are equifficient with respect to <span class="math">\\Omega_{\\mathsf{ind}_{i}}</span>; that is, <span class="math">\\Omega_{\\mathsf{ind}_{i}}(\\bm{p}_{i})=1</span>.</li>

    </ul>

    <p class="text-gray-300">For completeness, we describe the corresponding required modifications to equifficient extractability for this succinct verifier below.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; \\text {pp} \\leftarrow \\text {EPC.Setup}(1 ^ {\\lambda}, D) \\\\ \\forall i \\in \\{1, \\dots , r \\}: &amp;amp; \\Omega \\leftarrow A _ {1} \\left(1 ^ {\\lambda}, \\text {pp}\\right) \\\\ \\text {EPC.Verify(vk, c _ {i} , u , V _ {i} , \\Lambda_ {i} , \\pi_ {i}) = 1} \\\\ \\Downarrow &amp;amp; (\\text {ck, ok, vk}) \\leftarrow \\text {EPC.Specialize} ^ {\\text {pp}} (\\Omega) \\\\ P _ {i} (u) = V _ {i} &amp;amp; \\text {For } i \\in \\{1, \\dots , r \\}: \\\\ \\wedge &amp;amp; \\Lambda_ {i} = \\{\\text {ind} _ {i, 1}, \\dots , \\text {ind} _ {i, m _ {i}} \\} \\leftarrow S (\\text {ck}, \\text {ok}) \\\\ &amp;amp; \\rho_ {i} \\leftarrow C (\\text {ck}, \\text {ok}, i) \\\\ &amp;amp; c _ {i} \\leftarrow A _ {2} (\\text {ck}, \\text {ok}, [ \\Lambda_ {j} ] _ {j = 1} ^ {i}, [ \\rho_ {j} ] _ {j = 1} ^ {i}) \\\\ P _ {i} = [ p _ {i, 1}, \\dots , p _ {i, m _ {i}} ] \\leftarrow \\mathcal {E} (\\text {ck}, \\text {ok}, [ \\Lambda_ {j} ] _ {j = 1} ^ {i}, [ \\rho_ {j} ] _ {j = 1} ^ {i}) \\\\ &amp;amp; u \\leftarrow \\mathcal {Q} (\\text {ck}, \\text {ok}, [ \\Lambda_ {i} ] _ {i = 1} ^ {r}, [ c _ {i} ] _ {i = 1} ^ {r}, [ \\rho_ {i} ] _ {i = 1} ^ {r}) \\\\ &amp;amp; ([ V _ {i} ] _ {i = 1} ^ {r}, [ \\pi_ {i} ] _ {i = 1} ^ {r}) \\leftarrow A _ {3} (u) \\end{array} \\right]</span></div>

    <p class="text-gray-300">In this section, we describe a construction of EPC schemes for univariate polynomials that supports batched commitments.</p>

    <p class="text-gray-300">Setup. On input a security parameter  <span class="math">\\lambda</span>  (in unary) and a maximum dimension  <span class="math">D\\in \\mathbb{N}</span> , EPC.Setup samples public parameters pp as follows. Sample a bilinear group  <span class="math">\\langle \\mathrm{group}\\rangle \\gets \\mathrm{SampleGrp}(1^{\\lambda},q)</span>  and parse  <span class="math">\\langle \\mathrm{group}\\rangle</span>  as a tuple  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,G,H,e)</span> . Let  <span class="math">\\mathbb{K}</span>  be the vector space  <span class="math">\\mathbb{F}_q^{\\leq D}[X]</span>  whose canonical basis  <span class="math">\\mathcal{U}</span>  is the set of monomials  <span class="math">\\{1,x,x^{2},\\ldots ,x^{D - 1}\\}</span> . Sample a uniformly random field element  <span class="math">\\tau \\gets \\mathbb{F}_q</span> , and compute the vector of monomial encodings:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} := \\left(G, \\tau \\cdot G, \\tau^ {2} \\cdot G, \\dots , \\tau^ {D - 1} \\cdot G\\right) \\in \\mathbb {G} _ {1} ^ {D} \\tag {5}</span></div>

    <p class="text-gray-300">Set  <span class="math">\\mathsf{pp} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Sigma, \\tau \\cdot H)</span>  and output the public parameters  <span class="math">\\mathsf{pp}</span> . These public parameters will support univariate polynomials over the field  <span class="math">\\mathbb{F}_q</span>  of degree at most  <span class="math">D - 1</span> .</p>

    <p class="text-gray-300"><strong>Specialize.</strong> Given oracle access to public parameters pp and input a set of equiﬁcient constraints  <span class="math">\\Omega = \\{\\Omega_i\\}_{i=1}^n</span> , EPC.Specialize will compute committer, opener, and verifier keys as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sample randomness as follows. For every non-trivial constraint  <span class="math">S \\in \\Omega</span> , sample uniformly random field elements  $\\alpha_{S} := (1, \\alpha_{S}, \\alpha_{S}^{2}, \\ldots, \\alpha_{S}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}) \\gets \\mathbb{F}_{q}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  and  </span>\\gamma_{S}, \\delta_{S} \\gets \\mathbb{F}_{q}<span class="math"> . Then, for every trivial constraint  </span>V \\in \\Omega<span class="math"> , sample the uniformly random field element  </span>\\alpha_{V} := (\\alpha_{V}) \\gets \\mathbb{F}_{q}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Construct the committer key  <span class="math">\\mathbf{ck}</span>  as follows. First, for each non-trivial constraint  <span class="math">S\\in \\Omega</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse  <span class="math">S</span>  as  $[\\mathcal{P}_1,\\dots ,\\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> , and each  </span>\\mathcal{P}_i<span class="math">  as  </span>(\\mathcal{J}_i,\\mathcal{B}_i)<span class="math"> , and each  </span>\\mathcal{B}_i<span class="math">  as the basis elements  </span>\\{b_s^{(i)}\\}_{s = 1}^D$  (expressed in the monomial basis).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Construct the 'consistency' committer key  <span class="math">\\mathsf{ck}_S</span>  for  <span class="math">S</span>  by taking a linear combination of the vectors  $\\pmb{b}_{S}^{(1)},\\dots,\\pmb{b}_{S}^{(</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">)}<span class="math">  with respect to the coefficients  </span>\\alpha_{S}$ :</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c k} _ {S} := \\frac {\\sum_ {i = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_ {S} ^ {i - 1} \\cdot \\boldsymbol {b} _ {S} ^ {(i)}}{\\delta_ {S}} \\in \\mathbb {G} _ {1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {P} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, to construct keys for trivial constraints, denote by <span class="math">W</span> the first non-trivial constraint in <span class="math">\\Omega</span>; commitments to polynomials with trivial constraints will be batched with commitments to polynomials constrained by <span class="math">W</span>. (Note that <span class="math">W</span> is not necessarily the first constraint <span class="math">\\Omega_1</span>.) For every trivial constraint <span class="math">V \\in \\Omega</span>, compute the committer key for <span class="math">V</span> as <span class="math">\\mathsf{ck}_V := \\frac{\\alpha_V}{\\delta_W} \\cdot \\Sigma \\in \\mathbb{G}_1^D</span>. (Recall that we assume that all trivial constraints are just the canonical monomial basis.)</p>

    <p class="text-gray-300">Finally, construct the committer key <span class="math">\\mathsf{ck} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma, (\\mathsf{ck}_T)_{T \\in \\Omega})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, construct the opener key <span class="math">\\mathsf{ok}</span> as follows. For each non-trivial constraint <span class="math">S \\in \\Omega</span>, compute the opener key for <span class="math">S</span> as $\\mathsf{ok}_S := \\left(\\frac{1}{\\gamma_S} \\cdot \\Sigma, \\frac{\\alpha_S}{\\gamma_S} \\cdot \\Sigma, \\ldots, \\frac{\\alpha_S^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}}{\\gamma_S} \\cdot \\Sigma\\right) \\in \\mathbb{G}_1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot D}<span class="math">, while for every trivial constraint </span>V \\in \\Omega<span class="math">, construct the opener key as </span>\\mathsf{ok}_V := \\frac{\\alpha_V}{\\gamma_W} \\cdot \\Sigma \\in \\mathbb{G}_1^D<span class="math">. Set the opener key to be </span>\\mathsf{ok} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma, (\\mathsf{ok}_T)_{T \\in \\Omega})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, construct the verifier key as follows. Denote by <span class="math">\\Theta</span> the set of non-trivial constraints in <span class="math">\\Omega</span>. Then the verifier key <span class="math">\\mathsf{vk}</span> is defined as <span class="math">\\mathsf{vk} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, (\\frac{\\alpha_V \\cdot G}{\\gamma_W})_{V \\in \\Omega \\setminus \\Theta}, \\{(\\frac{\\alpha_S \\cdot G}{\\gamma_S}), (\\gamma_S \\cdot H), (\\gamma_S \\tau \\cdot H), (\\delta_S \\cdot G)\\}_{S \\in \\Theta})</span>.</p>

    <p class="text-gray-300"><strong>Commit.</strong> On input the committer key <span class="math">\\mathsf{ck} = (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma, (\\mathsf{ck}_T)_{T \\in \\Omega})</span>, a list of polynomial lists <span class="math">P = [p_i]_{i=1}^m</span>, and a set of equidfficient constraints <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i=1}^m</span>, EPC. Commit computes a commitment <span class="math">c</span> as follows.</p>

    <p class="text-gray-300">First, if for any <span class="math">p_{i,j} \\in P</span>, <span class="math">\\deg(p_{i,j}) \\geq D</span>, output <span class="math">\\bot</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, compute the commitments to the constrained polynomials. For every list <span class="math">p_j \\in P</span> such that <span class="math">\\Lambda_j</span> is a non-trivial constraint, proceed as follows. For notational convenience, set <span class="math">g := p_j</span> and <span class="math">S := \\Lambda_j</span>. Parse <span class="math">g</span> as $[g_1, \\ldots, g_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> and </span>S<span class="math"> as </span>[\\mathcal{P}_1, \\ldots, \\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">. Denote by </span>g<span class="math"> the coefficient vector of the polynomial </span>g_1<span class="math"> in </span>\\mathcal{P}_1<span class="math">. Construct the &#x27;consistency&#x27; commitment of </span>g<span class="math"> with respect to </span>S<span class="math"> as </span>c_S := \\langle g, \\mathsf{ck}_S \\rangle \\in \\mathbb{G}_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, compute the commitments to the unconstrained polynomials. For every list <span class="math">p_k \\in P</span> such that <span class="math">\\Lambda_k</span> is a trivial constraint, proceed as follows. Parse <span class="math">p_k</span> as <span class="math">h</span> and set <span class="math">V := \\Lambda_k</span>. Commit to <span class="math">h</span> under <span class="math">\\mathsf{ck}_V</span> via the Pedersen commitment <span class="math">c_V := \\langle h, \\mathsf{ck}_V \\rangle \\in \\mathbb{G}_1</span>.</p>

    <p class="text-gray-300">Let <span class="math">W</span> be the first non-trivial constraint in <span class="math">\\Omega</span> and let <span class="math">c_W</span> be the commitment to the polynomials in <span class="math">P</span> constrained by <span class="math">W</span> (if there are no such polynomials, i.e., <span class="math">W \\notin \\Lambda</span>, then set <span class="math">c_W := 0 \\cdot G</span>). Update <span class="math">c_W</span> to <span class="math">c_W + \\sum_{V \\in \\Omega \\setminus \\Theta} c_V</span>.</p>

    <p class="text-gray-300">Finally, output the commitment <span class="math">c := (c_S)_{S \\in \\Lambda \\cap \\Theta} \\cup (c_W)</span>, where <span class="math">\\Lambda \\cap \\Theta</span> denotes the set of non-trivial constraints in <span class="math">\\Lambda</span>.</p>

    <p class="text-gray-300"><strong>Open.</strong> On input opener key <span class="math">\\mathsf{ok}</span> parsed as <span class="math">\\mathsf{ok} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma, (\\mathsf{ok}_T)_{T \\in \\Omega})</span>, a list of polynomial lists <span class="math">P = [p_i]_{i=1}^m</span>, a set of equidfficient constraints <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i=1}^m</span>, and an evaluation point <span class="math">u</span>, EPC. Open outputs an evaluation proof <span class="math">\\pi</span> computed as follows.</p>

    <p class="text-gray-300">First, if for any <span class="math">p_{i,j} \\in P</span>, <span class="math">\\deg(p_{i,j}) \\geq D</span>, output <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Next, compute the evaluation proofs for the constrained polynomials. For every list <span class="math">p_j \\in P</span> such that <span class="math">\\Lambda_j</span> is a non-trivial constraint, proceed as follows. For notational convenience, set <span class="math">g := p_j</span> and <span class="math">S := \\Lambda_j</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">g</span> as $[g_1, \\ldots, g_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> and </span>\\mathsf{ok}_S<span class="math"> as </span>(\\mathsf{ok}_1, \\ldots, \\mathsf{ok}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">10Note that if the polynomials in <span class="math">\\pmb{g}</span> are equidfficient, then <span class="math">g</span> is the coefficient vector for each <span class="math">g_j</span> in the <span class="math">\\mathcal{P}_j</span> punctured basis.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Compute the batched evaluation proof for the polynomials in  <span class="math">\\pmb{g}</span>  as  $\\mathsf{w}_S\\coloneqq \\sum_{i = 1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\hat{\\mathsf{w}}_i$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, compute the evaluation proofs for the unconstrained polynomials. For every list  <span class="math">\\pmb{p}_k \\in \\pmb{P}</span>  such that  <span class="math">\\Lambda_k</span>  is a non-trivial constraint, proceed as follows. Parse  <span class="math">\\pmb{p}_k</span>  as  <span class="math">h</span>  and set  <span class="math">V := \\Lambda_k</span> . Compute the unique witness polynomial  <span class="math">w(X) = (h(X) - h(u)) / (X - u) \\in \\mathbb{F}^{&amp;lt;D}[X]</span> , and commit to  <span class="math">w</span>  under the opener key  <span class="math">\\mathsf{ok}_V</span>  via the Pedersen commitment  <span class="math">\\mathsf{w}_V := \\langle w, \\mathsf{ok}_V \\rangle \\in \\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">Let  <span class="math">W</span>  be the first non-trivial constraint in  <span class="math">\\Omega</span>  and let  <span class="math">\\mathsf{w}_W</span>  be the evaluation proof for the polynomials in  <span class="math">P</span>  constrained by  <span class="math">W</span>  (if  <span class="math">W \\notin \\Lambda</span> , then set  <span class="math">\\mathsf{w}_W := 0 \\cdot G</span> ). Update  <span class="math">\\mathsf{w}_W</span>  to  <span class="math">\\mathsf{w}_W + \\sum_{V \\in \\Omega \\setminus \\Theta} \\mathsf{w}_V</span> .</p>

    <p class="text-gray-300">Finally, output the proof  <span class="math">\\pi := (\\mathsf{w}_S)_{S \\in \\Lambda \\cap \\Theta} \\cup (\\mathsf{w}_W)</span> , where  <span class="math">\\Lambda \\cap \\Theta</span>  denotes the set of non-trivial constraints in  <span class="math">\\Lambda</span> .</p>

    <p class="text-gray-300">Verify. On input the verifier key  <span class="math">\\mathsf{vk}</span>  parsed as  <span class="math">(\\mathbb{K},\\langle \\mathrm{group}\\rangle ,\\Omega ,(\\frac{\\alpha_V\\cdot G}{\\gamma_W})_{V\\in \\Omega \\setminus \\Theta},\\{(\\frac{\\alpha_S\\cdot G}{\\gamma_S}),(\\gamma_S\\cdot H),(\\gamma_S\\tau \\cdot H),(\\delta_S\\cdot G)\\}_{S\\in \\Theta})</span>  , a commitment  <span class="math">c = (c_{S})_{S\\in \\Lambda \\cap \\Theta}\\cup (c_{W})</span>  , an evaluation point  <span class="math">u</span>  , claimed evaluations  <span class="math">V = [v_{i}]_{i = 1}^{m}</span>  , a set of equilibrium constraints  <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i = 1}^m</span>  , and a proof  <span class="math">\\pi = (\\mathsf{w}_S)_{S\\in \\Lambda \\cap \\Theta}\\cup (\\mathsf{w}_W)</span>  EPC.Verify proceeds as follows.</p>

    <p class="text-gray-300">First, check that the constraint  <span class="math">\\Lambda_{i}</span>  is contained in the vk; that is,  <span class="math">\\Lambda_{i} \\in \\Omega</span> .</p>

    <p class="text-gray-300">Next, let  <span class="math">W</span>  denote the first non-trivial constraint appearing in  <span class="math">\\Omega</span> . For notational clarity, let  <span class="math">\\pmb{v}_T</span>  denote  <span class="math">\\pmb{v}_i</span>  where  <span class="math">i</span>  is the index of  <span class="math">T</span>  in  <span class="math">\\Lambda</span> . If there are no polynomials constrained by  <span class="math">W</span>  (that is,  <span class="math">W \\notin \\Lambda</span> ), then set  <span class="math">\\pmb{v}_W := \\mathbf{0}</span> .</p>

    <p class="text-gray-300">For each non-trivial constraint  <span class="math">S \\in \\Lambda \\cap \\Theta \\setminus \\{W\\}</span> , check the pairing equality:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(c _ {S}, \\delta_ {S} \\cdot H\\right) = e \\left(\\frac {\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} \\rangle}{\\gamma_ {S}} \\cdot G, \\gamma_ {S} \\cdot H\\right) \\cdot e \\left(\\mathrm {w} _ {S}, \\gamma_ {S} \\tau \\cdot H - \\gamma_ {S} u \\cdot H\\right)</span></div>

    <p class="text-gray-300">Else for  <span class="math">S = W</span> , check the pairing equality:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(c _ {W}, \\delta_ {W} \\cdot H\\right) = e \\left(\\frac {\\langle \\boldsymbol {\\alpha} _ {W} , \\boldsymbol {v} _ {W} \\rangle}{\\gamma_ {W}} \\cdot G + \\sum_ {V \\in \\boldsymbol {\\Lambda} \\backslash \\boldsymbol {\\Theta}} \\frac {\\langle \\boldsymbol {\\alpha} _ {V} , \\boldsymbol {v} _ {V} \\rangle}{\\gamma_ {W}}, \\gamma_ {W} \\cdot H\\right) \\cdot e \\left(\\mathrm {w} _ {W}, \\gamma_ {W} \\tau \\cdot H - \\gamma_ {W} u \\cdot H\\right)</span></div>

    <h2 id="sec-64" class="text-2xl font-bold">4.2.2 Extractability</h2>

    <p class="text-gray-300">We begin by arguing, in Lemma 4.2, that the construction of EPC in Section 4.2.1 satisfies evaluation binding, a property stating that for any point  <span class="math">u \\in \\mathbb{F}_q</span>  and a commitment  <span class="math">c</span> , no efficient adversary can produce valid proofs that open  <span class="math">c</span>  to different values at  <span class="math">u</span> . Then, in Theorem 4.3, we use this lemma to show EPC achieves equilibrium extractability.</p>

    <p class="text-gray-300">Formally, we adapt the definition of evaluation binding from [CHMMVW20] to EPC schemes as follows.</p>

    <p class="text-gray-300"><strong>Definition 4.1 (Evaluation binding). EPC satisfies evaluation binding if for every maximum dimension  <span class="math">D</span>  and efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span> , the following probability is negligible in the security parameter  <span class="math">\\lambda</span> :</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\boldsymbol {V} \\neq \\boldsymbol {V} ^ {\\prime} &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {E P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ \\wedge &amp;amp; \\boldsymbol {\\Omega} \\leftarrow \\mathcal {A} _ {1} (1 ^ {\\lambda}, \\mathsf {p p}) \\\\ \\mathsf {E P C . V e r i f y} (\\mathsf {v k}, c, u, \\boldsymbol {V}, \\boldsymbol {\\Lambda}, \\pi) = 1 &amp;amp; (\\mathsf {c k}, \\mathsf {o k}, \\mathsf {v k}) \\leftarrow \\mathsf {E P C . S p e c i a l i z e} ^ {\\mathsf {p p}} (\\boldsymbol {\\Omega}) \\\\ \\wedge &amp;amp; (c, u, \\boldsymbol {V}, \\boldsymbol {V} ^ {\\prime}, \\boldsymbol {\\Lambda}, \\mathsf {s t}) \\leftarrow \\mathcal {A} _ {2} (\\mathsf {c k}, \\mathsf {o k}) \\\\ \\mathsf {E P C . V e r i f y} (\\mathsf {v k}, c, u, \\boldsymbol {V} ^ {\\prime}, \\boldsymbol {\\Lambda}, \\pi^ {\\prime}) = 1 &amp;amp; (\\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} _ {3} (\\mathsf {s t}) \\end{array} \\right].</span></div>

    <p class="text-gray-300"><strong>Lemma 4.2.</strong> If the bilinear group sampler SampleGrp satisfies the SDH assumption (Assumption 1), the construction EPC from Section 4.2.1 achieves evaluation binding (Definition 4.1).</p>

    <p class="text-gray-300">Proof. Suppose for contradiction there exists a maximum dimension  <span class="math">D</span>  and efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span>  that breaks the evaluation binding of EPC with non-negligible probability (Definition 4.1). We describe how to use  <span class="math">\\mathcal{A}</span>  to construct an efficient adversary  <span class="math">\\mathcal{B}</span>  that breaks SDH (Assumption 1) with non-negligible probability.</p>

    <p class="text-gray-300">Denote by  <span class="math">\\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Omega</span> , and by  <span class="math">\\Lambda \\cap \\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Lambda</span> , and by  <span class="math">W</span>  the first non-trivial constraint appearing in  <span class="math">\\Omega</span> . We often abuse notation by denoting  <span class="math">\\pmb{v}_i</span>  as  <span class="math">\\pmb{v}_{\\Lambda_i}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(\\langle \\mathrm{group}\\rangle ,\\Sigma^{\\prime})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\pmb{\\Sigma}^{\\prime}</span>  as  <span class="math">\\{\\{\\tau^{i}G\\}_{i = 0}^{D - 1},\\tau H\\}</span> , and set  <span class="math">\\pmb {\\Sigma}:= \\{\\tau^i G\\}_{i = 0}^{D - 1}</span> , and set  <span class="math">\\mathbb{K}:= \\mathbb{F}_q^{&amp;lt; D}[X]</span> .</li>

      <li>Set the public parameters  <span class="math">\\mathsf{pp} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Sigma, \\tau H)</span> .</li>

      <li>Invoke the adversary against EPC to compute  <span class="math">\\Omega \\gets \\mathcal{A}_1(1^\\lambda, \\mathsf{pp})</span> .</li>

      <li>Compute the committer, opener, and verifier keys  <span class="math">(\\mathsf{ck},\\mathsf{ok},\\mathsf{vk})\\gets \\mathsf{EPC.Specialize}^{\\mathsf{pp}}(\\Omega)</span></li>

      <li>Invoke the adversary against EPC to compute  <span class="math">(c, u, V, V&#x27;, \\Lambda, \\mathsf{st}) \\gets \\mathcal{A}_2(\\mathsf{ck}, \\mathsf{ok})</span> .</li>

      <li>Invoke the adversary against EPC to compute  <span class="math">(\\pi, \\pi&#x27;) \\gets \\mathcal{A}_3(\\mathsf{st})</span> .</li>

      <li>Parse  <span class="math">\\pmb{\\Lambda}</span>  as  <span class="math">\\{\\Lambda_1,\\dots ,\\Lambda_m\\}</span></li>

      <li>Parse  <span class="math">\\pi</span>  as  <span class="math">(\\mathsf{w}_S)_{S\\in \\Lambda \\cap \\Theta}\\cup (\\mathsf{w}_W)</span>  and  <span class="math">\\pi^\\prime</span>  as  <span class="math">(\\mathsf{w}_S^{\\prime})_{S\\in \\Lambda \\cap \\Theta}\\cup (\\mathsf{w}_W^{\\prime})</span></li>

      <li>If  <span class="math">uG = \\tau G</span>  (i.e.  <span class="math">u = \\tau</span> ), choose any  <span class="math">a \\in \\mathbb{F}_q \\setminus \\{u\\}</span>  and output  <span class="math">\\left(a, \\frac{1}{a + u} G\\right)</span> .</li>

      <li>Else if  <span class="math">uG \\neq \\tau G</span> , do as follows. For each  <span class="math">i \\in [m]</span> ,</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">S\\coloneqq \\Lambda_{i}</span>  is a non-trivial constraint, and if  <span class="math">\\mathsf{w}_S\\neq \\mathsf{w}_S^{\\prime}</span>  and  <span class="math">\\pmb {v}_S\\neq \\pmb {v}_S^{\\prime}</span>  , output:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(- u, \\frac {\\gamma_ {S}}{\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} - \\boldsymbol {v} _ {S} ^ {\\prime} \\rangle} (\\mathrm {w} _ {S} ^ {\\prime} - \\mathrm {w} _ {S})\\right)</span></div>

    <p class="text-gray-300">(b) Else if  <span class="math">V\\coloneqq \\Lambda_{i}</span>  is a trivial constraint, and if  <span class="math">\\mathsf{w}_W\\neq \\mathsf{w}_W^{\\prime}</span>  and  <span class="math">\\pmb {v}_V\\neq \\pmb {v}_V^{\\prime}</span>  , output:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(- u, \\frac {\\gamma_ {W}}{\\langle \\boldsymbol {\\alpha} _ {V} , \\boldsymbol {v} _ {V} - \\boldsymbol {v} _ {V} ^ {\\prime} \\rangle} (\\mathrm {w} _ {W} ^ {\\prime} - \\mathrm {w} _ {W})\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Else output  <span class="math">\\perp</span></li>

    </ol>

    <p class="text-gray-300">Whenever  <span class="math">\\mathcal{A}</span>  wins the evaluation binding game against EPC with non-negligible probability, we show that  <span class="math">\\mathcal{B}</span>  outputs a valid tuple to break SDH with the same non-negligible probability. First, we show that  <span class="math">\\mathcal{B}</span>  outputs a valid SDH tuple if the predicates from Step 9, Step 10a, or Step 10b are satisfied. Second, we show that the probability these predicates are not satisfied, i.e., that  <span class="math">\\mathcal{B}</span>  fails by outputting  <span class="math">\\perp</span> , is negligible.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  succeeds if it outputs a valid SDH tuple. Note that if  <span class="math">u = \\tau</span> , then  <span class="math">\\mathcal{B}</span>  can construct an arbitrary solution to the SDH problem (Step 9). Otherwise, suppose  <span class="math">uG \\neq \\tau G</span>  and there exists a non-trivial constraint  <span class="math">S := \\Lambda_i</span>  such that  <span class="math">\\mathsf{w}_S \\neq \\mathsf{w}_S&#x27;</span>  and  <span class="math">\\pmb{v}_S \\neq \\pmb{v}_S&#x27;</span>  (Step 10). (Note we forego the analysis for trivial constraints, as it is similarly done with the corresponding pairing check.) Since EPC.Verify(vk, c, V,  <span class="math">\\Lambda, \\pi</span> ) and EPC.Verify(vk, c,  <span class="math">V&#x27;, \\Lambda, \\pi&#x27;</span> ) accept, the pairing checks produce the following equalities, respectively, over random choice of  <span class="math">\\delta_S</span>  and  <span class="math">\\gamma_S</span> :</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(c _ {S}, \\delta_ {S} \\cdot H\\right) = e \\left(\\frac {\\left\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} \\right\\rangle}{\\gamma_ {S}} \\cdot G, \\gamma_ {S} \\cdot H\\right) \\cdot e \\left(\\mathrm {w} _ {S}, \\gamma_ {S} \\tau \\cdot H - \\gamma_ {S} u \\cdot H\\right) \\tag {6}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(c _ {S}, \\delta_ {S} \\cdot H\\right) = e \\left(\\frac {\\left\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} ^ {\\prime} \\right\\rangle}{\\gamma_ {S}} \\cdot G, \\gamma_ {S} \\cdot H\\right) \\cdot e \\left(\\mathrm {w} _ {S} ^ {\\prime}, \\gamma_ {S} \\tau \\cdot H - \\gamma_ {S} u \\cdot H\\right) \\tag {7}</span></div>

    <p class="text-gray-300">The above equations together imply, when written in  <span class="math">\\mathbb{G}_1</span> , that:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\gamma_ {S}}{\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} - \\boldsymbol {v} _ {S} ^ {\\prime} \\rangle} \\cdot (\\mathrm {w} _ {S} ^ {\\prime} - \\mathrm {w} _ {S}) = \\frac {1}{\\tau - u} \\cdot G</span></div>

    <p class="text-gray-300">making  <span class="math">\\left(-u, \\frac{\\gamma_S}{\\langle \\alpha_S, v_S - v_S&#x27; \\rangle} \\cdot (w_S&#x27; - w_S)\\right)</span>  a pair that breaks the SDH assumption.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  fails if it outputs  <span class="math">\\perp</span> . We analyze the probability that  <span class="math">\\mathcal{B}</span>  outputs  <span class="math">\\perp</span> , i.e., that  <span class="math">uG \\neq \\tau G</span>  and  <span class="math">\\mathsf{w}_T = \\mathsf{w}_T&#x27;</span>  or  <span class="math">\\pmb{v}_T = \\pmb{v}_T&#x27;</span>  for all  <span class="math">T \\in \\Lambda</span> . (As above, we only perform the analysis below for non-trivial constraints; the analysis for trivial constraints is similarly done with the corresponding pairing check.) By assumption we have  <span class="math">\\pmb{V} \\neq \\pmb{V}&#x27;</span> , so suppose  <span class="math">\\pmb{v}_S \\neq \\pmb{v}_S&#x27;</span>  for some non-trivial constraint  <span class="math">S</span> . By hypothesis, it must be that  <span class="math">\\mathsf{w}_S = \\mathsf{w}_S&#x27;</span> . Since the verification algorithms accept, Eq. (6) and Eq. (7) together imply:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\frac {\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} \\rangle}{\\gamma_ {S}} \\cdot G, \\gamma_ {S} \\cdot H\\right) = e \\left(\\frac {\\langle \\boldsymbol {\\alpha} _ {S} , \\boldsymbol {v} _ {S} ^ {\\prime} \\rangle}{\\gamma_ {S}} \\cdot G, \\gamma_ {S} \\cdot H\\right) \\tag {8}</span></div>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\left\\langle \\boldsymbol {\\alpha} _ {S}, \\boldsymbol {v} _ {S} \\right\\rangle \\cdot G, H\\right) = e \\left(\\left\\langle \\boldsymbol {\\alpha} _ {S}, \\boldsymbol {v} _ {S} ^ {\\prime} \\right\\rangle \\cdot G, H\\right) \\tag {9}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying the Schwartz-Zippel lemma [Zip79; Sch80], since  <span class="math">\\pmb{v}_S \\neq \\pmb{v}_S&#x27;</span>  then Eq. (9) holds with probability at most  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over random choice of  </span>\\alpha_S<span class="math"> . Hence  </span>\\mathcal{B}<span class="math">  fails with probability at most  </span>\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 4.3. If the bilinear group sampler SampleGrp satisfies the SDH assumption against algebraic adversaries (Assumption 1), the construction EPC in Section 4.2.1 achieves equfficient extractability (Section 4.1) in the Algebraic Group Model (AGM).</p>

    <p class="text-gray-300">Proof. Let  <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span>  be an efficient stateful adversary against EPC. We show how to construct an efficient extractor  <span class="math">\\mathcal{E}</span>  against  <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span>  that succeeds with overwhelming probability, such that for every round bound  <span class="math">r \\in \\mathbb{N}</span> , efficient public-coin sampler  <span class="math">\\mathcal{C}</span> , query sampler  <span class="math">\\mathcal{Q}</span> , constraint sampler  <span class="math">\\mathcal{S}</span> , and adversary  <span class="math">\\mathcal{A}_3</span> , the following probability is negligibly close to 1 (as a function of  <span class="math">\\lambda</span> ):</p>

    <p class="text-gray-300">Pr</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{1, \\ldots , r \\}: \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {E P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ \\Omega \\leftarrow \\mathcal {A} _ {1} (1 ^ {\\lambda}, \\mathsf {p p}) \\\\ (\\mathsf {c k}, \\mathsf {o k}, \\mathsf {v k}) \\leftarrow \\mathsf {E P C . S p e c i a l i z e} ^ {\\mathsf {p p}} (\\Omega) \\end{array}</span></div>

    <p class="text-gray-300">For  <span class="math">i\\in \\{1,\\dots ,r\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {E P C . V e r i f y} (\\mathsf {v k}, c _ {i}, u, \\mathbf {V} _ {i}, \\boldsymbol {\\Lambda} _ {i}, \\pi_ {i}) = 1 \\\\ \\Downarrow \\\\ \\boldsymbol {P} _ {i} (u) = \\boldsymbol {V} _ {i} \\\\ \\wedge \\\\ \\bigwedge_ {j = 1} ^ {m _ {i}} \\Lambda_ {i, j} (\\boldsymbol {p} _ {i, j}) = 1 \\end{array}</span></div>

    <p class="text-gray-300">For  <span class="math">i\\in \\{1,\\dots ,r\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Lambda_ {i} = \\left\\{\\Lambda_ {i, 1}, \\dots , \\Lambda_ {i, m _ {i}} \\right\\} \\leftarrow S (\\mathrm {c k}, \\mathrm {o k}) \\\\ \\rho_ {i} \\leftarrow \\mathcal {C} (\\mathrm {c k}, \\mathrm {o k}, i) \\\\ c _ {i} \\leftarrow \\mathcal {A} _ {2} (\\mathrm {c k}, \\mathrm {o k}, [ \\boldsymbol {\\Lambda} _ {j} ] _ {j = 1} ^ {i}, [ \\rho_ {j} ] _ {j = 1} ^ {i}) \\\\ \\boldsymbol {P} _ {i} = \\left[ \\boldsymbol {p} _ {i, 1}, \\dots , \\boldsymbol {p} _ {i, m _ {i}} \\right] \\leftarrow \\mathcal {E} (\\mathrm {c k}, \\mathrm {o k}, [ \\boldsymbol {\\Lambda} _ {j} ] _ {j = 1} ^ {i}, [ \\rho_ {j} ] _ {j = 1} ^ {i}) \\\\ u \\leftarrow \\mathcal {Q} (\\mathrm {c k}, \\mathrm {o k}, [ \\boldsymbol {\\Lambda} _ {i} ] _ {i = 1} ^ {r}, [ c _ {i} ] _ {i = 1} ^ {r}, [ \\rho_ {i} ] _ {i = 1} ^ {r}) \\\\ \\left(\\left[ \\boldsymbol {V} _ {i} \\right] _ {i = 1} ^ {r}, \\left[ \\pi_ {i} \\right] _ {i = 1} ^ {r}\\right) \\leftarrow \\mathcal {A} _ {3} (u) \\end{array}</span></div>

    <p class="text-gray-300">Denote by  <span class="math">\\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Omega</span> , and by  <span class="math">W</span>  the first non-trivial constraint appearing in  <span class="math">\\Omega</span> . Also, denote by  <span class="math">\\Lambda_i \\cap \\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Lambda_i</span> , and by  <span class="math">m_i</span>  the number of constraints output by the constraint sampler  <span class="math">S</span>  for round  <span class="math">i</span> .</p>

    <p class="text-gray-300">For each round  <span class="math">i \\in [r]</span> , we construct the extractor  <span class="math">\\mathcal{E}</span>  for EPC below and argue that it succeeds with overwhelming probability.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{ck},\\mathrm{ok},[\\Lambda_j]_{j = 1}^i,[\\rho_j]_{j = 1}^i)\\to P:</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the committer key  <span class="math">\\mathsf{ck}</span>  as  <span class="math">(\\mathbb{K},\\langle \\mathrm{group}\\rangle ,\\Omega ,\\Sigma ,(\\mathrm{ck}_T)_{T\\in \\Omega})</span></li>

      <li>Parse  <span class="math">\\Lambda_{i}</span>  as  <span class="math">\\{\\Lambda_1,\\dots ,\\Lambda_{m_i}\\}</span></li>

      <li>Invoke the algebraic adversary:  <span class="math">\\{\\langle \\pmb{a}_{\\Lambda_i},\\pmb{L}_{\\Lambda_j}\\rangle \\}_{j = 1}^{m_i}\\gets \\mathcal{A}_2(\\mathrm{ck},\\mathrm{ok},[\\pmb {\\Lambda}_j]_{j = 1}^i,[\\rho_j]_{j = 1}^i).</span></li>

      <li>If  <span class="math">L_{S} \\neq \\mathrm{ck}_{S}</span>  for any  <span class="math">S \\in \\Lambda_{i} \\cap \\Theta \\cup \\{W\\}</span> , output  <span class="math">\\perp</span> .</li>

      <li>For each non-trivial constraint  <span class="math">S \\in \\Lambda_i \\cap \\Theta \\cup \\{W\\}</span> , proceed as follows.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Parse  <span class="math">S</span>  as  $[\\mathcal{P}_1,\\dots ,\\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> , and parse each  </span>\\mathcal{P}_j<span class="math">  as  </span>(\\mathcal{I}_j,\\mathcal{B}_j)<span class="math"> , and each  </span>\\mathcal{B}_j<span class="math">  as  </span>\\{b_s^{(j)}\\}_{s = 1}^D$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">i. Set the punctured basis vector  <span class="math">\\pmb{B}_j \\coloneqq [b_s^{(j)}]_{s \\in \\mathcal{J}_j}</span> . ii. Define the constrained polynomial  <span class="math">p_j \\coloneqq \\langle \\pmb{a}_S, \\pmb{B}_j \\rangle</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) Set the list of polynomials  $\\pmb{p}_k \\coloneqq [p_1, \\dots, p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> , where  </span>k<span class="math">  is the index of  </span>S<span class="math">  in  </span>\\Lambda_i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(d) If  <span class="math">S = W</span> , additionally define the unconstrained polynomial  <span class="math">\\pmb{p}_{\\ell} = [\\langle \\pmb{a}_V, \\mathcal{U} \\rangle]</span>  for each trivial constraint  <span class="math">V \\in \\Lambda_i \\setminus \\Theta</span> , where  <span class="math">\\ell</span>  is the index of  <span class="math">V</span>  in  <span class="math">\\Lambda_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the list  <span class="math">\\pmb{P} \\coloneqq [\\pmb{p}_1, \\dots, \\pmb{p}_{m_i}]</span> .</li>

    </ol>

    <p class="text-gray-300">The extractor  <span class="math">\\mathcal{E}</span>  can fail with non-negligible probability due to at least one of three reasons. We analyze each case separately and argue it occurs with negligible probability, or that it contradicts our original assumptions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Incorrect evaluation: there exists a polynomial  <span class="math">p_{i,j} \\in P</span>  whose evaluation is incorrect.</li>

      <li>Coefficient non-equality: the equiﬁcient property fails, i.e., there exists a round  <span class="math">i \\in [r]</span>  and a (non-trivial) constraint  <span class="math">\\Lambda_j \\in \\Lambda_i</span>  such that  <span class="math">\\Lambda_j(\\pmb{p}_j) = 0</span> .</li>

      <li><span class="math">\\mathcal{E}</span>  outputs  <span class="math">\\perp</span> : there exists a round  <span class="math">i \\in [r]</span>  in which the adversary  <span class="math">\\mathcal{A}_2</span>  outputs a group element corresponding to a non-trivial constraint  <span class="math">\\Lambda_j \\in \\Lambda_i</span>  such that  <span class="math">L_{\\Lambda_j} \\neq \\mathrm{ck}_{\\Lambda_j}</span> .</li>

    </ol>

    <p class="text-gray-300">(1) Incorrect evaluation. Suppose that with non-negligible probability there exists a round  <span class="math">i \\in [r]</span>  where the extractor  <span class="math">\\mathcal{E}</span>  outputs the polynomials  <span class="math">P_{i}</span> , and suppose that the adversary  <span class="math">\\mathcal{A}_{3}</span>  outputs the claimed evaluations  <span class="math">V_{i}</span> , such that  <span class="math">P_{i}(u) \\neq V_{i}</span>  holds. We argue this scenario would break evaluation binding of EPC with the same non-negligible probability, a contradiction to Lemma 4.2. We use the adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3)</span> , the extractor  <span class="math">\\mathcal{E}</span> , the constraint sampler  <span class="math">S</span> , the public-coin challenger  <span class="math">\\mathcal{C}</span> , and the query sampler  <span class="math">\\mathcal{Q}</span>  to construct the efficient adversary  <span class="math">\\mathcal{B} = (\\mathcal{B}_1, \\mathcal{B}_2, \\mathcal{B}_3)</span>  against evaluation binding defined as follows.</p>

    <p class="text-gray-300">|  B1(1λ, pp):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Invoke the adversary Ω←A1(1λ, pp).  |</p>

    <p class="text-gray-300">|  2. Output Ω.  |</p>

    <p class="text-gray-300">|  B2(ck, ok):  |</p>

    <p class="text-gray-300">|  1. For j ∈{1,...,r}: (a) Sample the constraints: Λj←S(ck, ok). (b) Sample the challenge: ρj←C(ck, ok, j). (c) Obtain the commitment: cj←A2(ck, ok, [Λk]k=1, [ρk]k=1). (d) Extract the polynomials Pj←E(ck, ok, [Λk]k=1, [ρk]k=1).  |</p>

    <p class="text-gray-300">|  2. Sample the query: u←Q(ck, ok, [Λj]j=1, [cj]j=1, [ρj]j=1).  |</p>

    <p class="text-gray-300">|  3. Obtain the evaluations: ([Vj]j=1, [πj]j=1)←A3(u).  |</p>

    <p class="text-gray-300">|  4. Compute the alternate evaluation vector: Vi' := Pi(u).  |</p>

    <p class="text-gray-300">|  5. Set st := (ck, ok, Pi, Λi, u, πi).  |</p>

    <p class="text-gray-300">|  6. Output (ci, u, Vi, Vi', Λi, st).  |</p>

    <p class="text-gray-300">|  B3(st):  |</p>

    <p class="text-gray-300">|  1. Parse st as (ck, ok, Pi, Λi, u, πi).  |</p>

    <p class="text-gray-300">|  2. Compute the alternate proof πi'← EPC.Open(ok, Pi, Λi, u).  |</p>

    <p class="text-gray-300">|  3. Output (πi, πi').  |</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{A}</span>  causes EPC.Verify(vk,  <span class="math">c_{i}, u, V_{i}, \\Lambda_{i}, \\pi_{i}</span> ) to accept with non-negligible probability and  <span class="math">P_{i}</span>  is the polynomials extracted from the commitment  <span class="math">c_{i}</span> , then  <span class="math">\\mathcal{B}</span>  causes EPC.Verify(vk,  <span class="math">c_{i}, u, V_{i}&#x27;, \\Lambda_{i}, \\pi_{i}&#x27;</span> ) to accept by the completeness property (since  <span class="math">V_{i}&#x27;</span>  are the corresponding evaluations of the polynomials in  <span class="math">P_{i}</span>  and  <span class="math">\\pi_{i}&#x27;</span>  is computed from EPC.Open) with the same non-negligible probability. This is a contradiction to Lemma 4.2.</p>

    <p class="text-gray-300">(2) Coefficient non-equality. Note that if the extractor  <span class="math">\\mathcal{E}</span>  does not output  <span class="math">\\perp</span> , the equiﬁcient property must be satisfied for every round  <span class="math">i \\in [r]</span> , as by construction for every list of polynomials  <span class="math">\\pmb{p}_j \\in \\pmb{P}_i</span>  and every</p>

    <p class="text-gray-300">polynomial <span class="math">p_{j,k}\\in\\boldsymbol{p}_{j}</span> corresponding to the (non-trivial) constraint <span class="math">\\Lambda_{j}</span>, we have <span class="math">[p_{j,k}]_{\\mathscr{P}_{k}}=\\boldsymbol{a}_{\\Lambda_{j}}</span> (Step 5).</p>

    <p class="text-gray-300">(3) <span class="math">\\boldsymbol{\\mathcal{E}}</span> outputs <span class="math">\\perp</span>. Fix a round <span class="math">i\\in[r]</span>. The extractor <span class="math">\\mathcal{E}</span> outputs <span class="math">\\perp</span> whenever it receives a commitment <span class="math">c_{S}</span> for a non-trivial constraint <span class="math">S</span> from the algebraic adversary <span class="math">\\mathcal{A}_{2}</span> such that the corresponding vector of coefficients <span class="math">\\boldsymbol{a}_{S}</span> has non-zero coefficients for group elements outside <span class="math">\\mathsf{ck}_{S}</span>. We now show that this happens with negligible probability whenever EPC.Verify accepts. (Note the analysis below applies to any <span class="math">S\\in\\boldsymbol{\\Lambda}_{i}\\cap\\boldsymbol{\\Theta}\\setminus\\{W\\}</span>; for the case <span class="math">S=W</span>, we forego this analysis as it is similarly done using the corresponding pairing check.)</p>

    <p class="text-gray-300">Recall the ‘consistency’ check in EPC.Verify for the non-trivial constraint <span class="math">S\\in\\boldsymbol{\\Lambda}_{i}\\cap\\boldsymbol{\\Theta}\\setminus\\{W\\}</span>:</p>

    <p class="text-gray-300"><span class="math">e\\left(c_{S},\\delta_{S}\\cdot H\\right)=e\\left(\\frac{\\langle\\boldsymbol{\\alpha}_{S},\\boldsymbol{v}_{S}\\rangle}{\\gamma_{S}}\\cdot G,\\gamma_{S}\\cdot H\\right)\\cdot e\\left(\\mathsf{w}_{S},\\gamma_{S}\\tau\\cdot H-\\gamma_{S}u\\cdot H\\right)</span> (10)</p>

    <p class="text-gray-300">The commitment <span class="math">c_{S}</span> that the extractor <span class="math">\\mathcal{E}</span> receives from the algebraic adversary <span class="math">\\mathcal{A}_{2}</span> is expressed via the linear combination of group elements <span class="math">\\langle\\boldsymbol{a}_{S},\\boldsymbol{L}_{S}\\rangle</span> (Step 3). Rewriting Eq. (10) in terms of this representation, we obtain the following equation in <span class="math">\\mathbb{G}_{1}</span>:</p>

    <p class="text-gray-300"><span class="math">\\langle\\boldsymbol{a}_{S},\\boldsymbol{L}_{S}\\rangle\\cdot\\delta_{S}=\\frac{\\langle\\boldsymbol{\\alpha}_{S},\\boldsymbol{v}_{S}\\rangle}{\\gamma_{S}}\\cdot\\gamma_{S}\\cdot G+\\mathsf{w}_{S}\\cdot\\gamma_{S}\\cdot(\\tau-u)</span></p>

    <p class="text-gray-300">Expressing <span class="math">\\langle\\boldsymbol{a}_{S},\\boldsymbol{L}_{S}\\rangle</span> as <span class="math">\\sum_{j}a_{j}L_{j}\\cdot G</span> and factoring out <span class="math">\\gamma_{S}</span>, we obtain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta_{S}\\cdot\\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathscr{P}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}a_{j}L_{j}\\cdot G=\\gamma_{S}\\cdot\\left[\\frac{\\langle\\boldsymbol{\\alpha}_{S},\\boldsymbol{v}_{S}\\rangle}{\\gamma_{S}}\\cdot G+\\mathsf{w}_{S}\\cdot(\\tau-u)\\right]$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By viewing Eq. (11) as an equality of polynomials (in the exponent of <span class="math">\\mathbb{G}_{1}</span>) in the indeterminates <span class="math">\\delta_{S}</span> and <span class="math">\\gamma_{S}</span>, we apply the Schwartz–Zippel lemma to deduce the left-hand side must be constant as a function of <span class="math">\\delta_{S}</span>, and similarly the right-hand side must be constant as a function of <span class="math">\\gamma_{S}</span>, except with negligible probability. Hence, each <span class="math">L_{j}</span> is of the form <span class="math">\\frac{L_{j}^{\\prime}}{\\delta_{S}}\\in\\mathbb{F}_{q}</span>. Crucially, this implies <span class="math">\\boldsymbol{L}_{S}=\\mathsf{ck}_{S}</span>. To see this, note the only committer key in the <span class="math">\\mathsf{ck}</span> written in terms of the component <span class="math">\\delta_{S}</span> is <span class="math">\\mathsf{ck}_{S}</span>. Since <span class="math">\\delta_{S}</span> is independent randomness, except with negligible probability, <span class="math">\\mathcal{A}_{2}</span> can express <span class="math">\\frac{L_{j}^{\\prime}}{\\delta_{S}}\\cdot G</span> exclusively with linear combinations of the group elements in <span class="math">\\mathsf{ck}_{S}</span>. ∎</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">4.3 EPC scheme for multilinear polynomials</h3>

    <p class="text-gray-300">We now describe our construction of an EPC scheme that supports multilinear polynomials.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">4.3.1 Construction</h4>

    <h5 id="sec-67" class="text-base font-semibold mt-4">Setup.</h5>

    <p class="text-gray-300">On input a security parameter <span class="math">\\lambda</span> (in unary) and a maximum dimension <span class="math">D</span>, EPC.Setup samples public parameters <span class="math">\\mathsf{pp}</span> as follows. Sample a bilinear group <span class="math">\\langle\\mathsf{group}\\rangle\\leftarrow\\mathsf{SampleGrp}(1^{\\lambda},q)</span> and parse <span class="math">\\langle\\mathsf{group}\\rangle</span> as a tuple <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},G,H,e)</span>. Define <span class="math">\\nu:=\\log_{2}D</span> to be the number of variables, and let <span class="math">\\mathbb{K}</span> be the <span class="math">D</span>-dimensional vector space <span class="math">\\mathsf{Mult}(\\mathbb{F}[X_{1},\\ldots,X_{\\nu}])</span> whose canonical basis <span class="math">\\mathscr{U}</span> is the set of Lagrange multilinear polynomials <span class="math">\\{\\chi_{1},\\ldots,\\chi_{\\nu}\\}</span>. Sample a uniformly random vector <span class="math">\\boldsymbol{\\beta}\\leftarrow\\mathbb{F}_{q}^{\\nu}</span>, and compute the vector of multilinear Lagrange basis encodings:</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{\\Sigma}:=(\\chi_{1}(\\boldsymbol{\\beta})\\cdot G,\\chi_{2}\\cdot(\\boldsymbol{\\beta})G,\\ldots,\\chi_{D}(\\boldsymbol{\\beta})\\cdot G)\\in\\mathbb{G}_{1}^{D}</span></p>

    <p class="text-gray-300">Construct and output the public parameters <span class="math">\\mathsf{pp}:=(D,\\langle\\mathsf{group}\\rangle,\\boldsymbol{\\Sigma},\\boldsymbol{\\beta}\\cdot H)</span>.</p>

    <p class="text-gray-300">34</p>

    <p class="text-gray-300"><strong>Specialize.</strong> Given oracle access to public parameters <span class="math">\\mathsf{pp}</span> and input a set of equifficient constraints <span class="math">\\Omega = \\{\\Omega_i\\}_{i=1}^n</span>, EPC.Specialize will compute committer, opener, and verifier keys as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Sample randomness</strong> as follows. For each non-trivial constraint <span class="math">S \\in \\Omega</span>, sample uniformly random field elements $\\alpha_{S} := (1, \\alpha_{S}, \\alpha_{S}^{2}, \\ldots, \\alpha_{S}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}) \\gets \\mathbb{F}_{q}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and </span>\\delta_{S} \\gets \\mathbb{F}_{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Construct the <strong>committer key</strong> ck as follows. First, for each non-trivial constraint <span class="math">S \\in \\Omega</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">S</span> as $[\\mathcal{P}_1, \\ldots, \\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> and each </span>\\mathcal{P}_i<span class="math"> as </span>(\\mathcal{J}_i, \\mathcal{B}_i)<span class="math">, and each </span>\\mathcal{B}_i<span class="math"> as the basis elements </span>\\{b_s^{(i)}\\}_{s=1}^D$ (expressed in the Lagrange basis).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Construct the 'consistency' committer key <span class="math">\\mathsf{ck}_S</span> for <span class="math">S</span> by taking a linear combination of the vectors $\\pmb{b}_{S}^{(1)},\\dots,\\pmb{b}_{S}^{(</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">)}<span class="math"> with respect to the coefficients </span>\\alpha_{S}$:</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c k} _ {S} := \\sum_ {i = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_ {S} ^ {i - 1} \\cdot \\boldsymbol {b} _ {S} ^ {(i)} \\in \\mathbb {G} _ {1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {P} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\tag {12}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, the key for every trivial constraint <span class="math">V \\in \\Omega</span> is <span class="math">\\Sigma</span>. Construct the committer key <span class="math">\\mathsf{ck} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma, (\\mathsf{ck}_S)_{S \\in \\Theta})</span>, where <span class="math">\\Theta</span> denotes the non-trivial constraints in <span class="math">\\Omega</span>.</p>

    <p class="text-gray-300">Next, construct the <strong>opener key</strong> ok as <span class="math">\\mathsf{ok} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\Sigma)</span>.</p>

    <p class="text-gray-300">Finally, construct the <strong>verifier key</strong> vk as <span class="math">\\mathsf{vk} := (\\mathbb{K}, \\langle \\mathsf{group} \\rangle, \\Omega, \\beta \\cdot H, (\\alpha_S \\cdot H)_{S \\in \\Theta})</span>.</p>

    <p class="text-gray-300"><strong>Commit.</strong> On input the committer key ck parsed as <span class="math">(\\mathbb{K}, \\langle \\mathrm{group} \\rangle, \\Omega, \\Sigma, (\\mathrm{ck}_S)_{S \\in \\Theta})</span>, a list of polynomial lists <span class="math">P = [p_i]_{i=1}^m</span>, and a set of equifficient constraints <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i=1}^m</span>, EPC.Commit computes the commitment <span class="math">c</span> as follows.</p>

    <p class="text-gray-300">First, if any <span class="math">p_{i,j} \\in P</span> is not multilinear in at most <span class="math">\\nu</span> variables, output <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Compute the <strong>commitments</strong> to the <strong>constrained polynomials</strong>. For every list <span class="math">\\pmb{p}_j \\in \\pmb{P}</span> such that <span class="math">\\Lambda_j</span> is a non-trivial constraint, proceed as follows. For notational convenience, set <span class="math">\\pmb{g} \\coloneqq \\pmb{p}_j</span> and <span class="math">S \\coloneqq \\Lambda_j</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">\\pmb{g}</span> as $[g_1, \\dots, g_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">, </span>S<span class="math"> as </span>[\\mathcal{P}_1, \\dots, \\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">, each </span>\\mathcal{P}_i<span class="math"> as </span>(\\mathcal{J}_i, \\mathcal{B}_i)<span class="math">, and each </span>\\mathcal{B}_i<span class="math"> as the basis elements </span>\\{b_s^{(i)}\\}_{s=1}^D$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote by <span class="math">g</span> the coefficient vector of the polynomial <span class="math">g_{1}</span> in <span class="math">\\mathcal{P}_1</span>. Commit to <span class="math">g</span> under the 'consistency' key <span class="math">\\mathsf{ck}_S</span> via the Pedersen commitment <span class="math">\\widetilde{c}_{S} := \\langle g,\\mathsf{ck}_{S}\\rangle \\in \\mathbb{G}_{1}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. For each $i\\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">, commit to </span>g_{i}<span class="math"> under </span>\\pmb{b}_{S}^{(i)}<span class="math"> via the Pedersen commitment </span>\\hat{c}_i\\coloneqq \\langle g_i,\\pmb{b}_S^{(i)}\\rangle \\in \\mathbb{G}_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, compute the <strong>commitments</strong> to the <strong>unconstrained polynomials</strong>. For every list <span class="math">\\pmb{p}_k \\in \\pmb{P}</span> such that <span class="math">\\Lambda_k</span> is a trivial constraint, proceed as follows. Parse <span class="math">\\pmb{p}_k</span> as <span class="math">h</span> and set <span class="math">V := \\overline{\\Lambda}_k</span>. Commit to <span class="math">h</span> under <span class="math">\\pmb{\\Sigma}</span> via the Pedersen commitment <span class="math">c_V := \\langle h, \\pmb{\\Sigma} \\rangle</span>.</p>

    <p class="text-gray-300">Finally, output the commitment <span class="math">c \\coloneqq (c_{T})_{T \\in \\Lambda}</span>.</p>

    <p class="text-gray-300"><strong>Open.</strong> On input opener key ok parsed as <span class="math">(\\mathbb{K}, \\langle \\mathrm{group} \\rangle, \\Omega, \\Sigma)</span>, a list of polynomial lists <span class="math">P = [p_i]_{i=1}^m</span>, a set of equifficient constraints <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i=1}^m</span>, and an evaluation point <span class="math">u = (u_i)_{i=1}^\\nu</span>, EPC.Open outputs an evaluation proof <span class="math">\\pi</span> computed as follows.</p>

    <p class="text-gray-300">First, if any <span class="math">p_{i,j} \\in \\mathbf{P}</span> is not multilinear in at most <span class="math">D</span> variables, output <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Compute the evaluation proofs to the polynomials as follows. For each <span class="math">i \\in [m]</span>, set <span class="math">T \\coloneqq \\Lambda_i</span> and proceed as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse <span class="math">\\pmb{p}_i</span> as $[p_1, \\dots, p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">. (Recall that if </span>T<span class="math"> is a trivial constraint, </span>\\pmb{p}_i$ consists of a single polynomial.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) Compute the unique witness polynomials <span class="math">w_{i,1}, \\ldots, w_{i,\\nu}</span> satisfying <span class="math">p_i(\\mathbf{X}) - p_i(u) = \\sum_{j=1}^{\\nu} (X_j - u_j) \\cdot w_{i,j}(\\mathbf{X})</span>. (b) For each <span class="math">j \\in [\\nu]</span>, commit to <span class="math">w_{i,j}</span> under <span class="math">\\pmb{\\Sigma}</span> via the Pedersen commitment <span class="math">\\mathsf{w}_{i,j} := \\langle w_{i,j}, \\pmb{\\Sigma} \\rangle \\in \\mathbb{G}_1</span>. (c) Set <span class="math">\\hat{\\mathsf{w}}_i := (\\mathsf{w}_{i,1}, \\ldots, \\mathsf{w}_{i,\\nu}) \\in \\mathbb{G}_1^\\nu</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Set $\\mathsf{w}_T := (\\hat{\\mathsf{w}}_1, \\ldots, \\hat{\\mathsf{w}}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) \\in \\mathbb{G}_1^{\\nu \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, output the proof <span class="math">\\pi := (\\mathsf{w}_T)_{T \\in \\Lambda}</span>.</p>

    <p class="text-gray-300"><strong>Verify.</strong> On input verifier key <span class="math">\\mathsf{vk}</span> parsed as <span class="math">(\\mathbb{K}, \\langle \\text{group} \\rangle, \\Omega, \\beta \\cdot H, (\\alpha_S \\cdot H)_{S \\in \\Theta})</span>, a commitment <span class="math">c = (c_i)_{i=1}^m</span>, an evaluation point <span class="math">u = (u_i)_{i=1}^\\nu</span>, claimed evaluations <span class="math">\\mathbf{V} = [\\mathbf{v}_i]_{i=1}^m</span>, a set of equidfficient constraints <span class="math">\\Lambda = \\{\\Lambda_i\\}_{i=1}^m</span>, and a proof <span class="math">\\pi = (\\mathsf{w}_T)_{T \\in \\Lambda}</span>, EPC. Verify proceeds as follows.</p>

    <p class="text-gray-300">First, check that the constraint <span class="math">\\Lambda_{i}</span> is contained in the <span class="math">\\mathsf{vk}</span>; that is, <span class="math">\\Lambda_{i} \\in \\Omega</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, for each constraint <span class="math">T \\in \\Lambda</span>, where <span class="math">i</span> is the index of <span class="math">T</span> in <span class="math">\\Lambda</span>, parse <span class="math">c_{T}</span> as $(\\hat{c}_1, \\dots, \\hat{c}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\widetilde{c}_T)<span class="math">, and parse </span>\\mathbf{v}_i<span class="math"> as </span>[v_j]_{j=1}^\\nu<span class="math">, and parse </span>\\mathbf{w}_T<span class="math"> as </span>(\\hat{\\mathbf{w}}_j)_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and parse each </span>\\hat{\\mathbf{w}}_j<span class="math"> as </span>(\\mathbf{w}_{j,k})_{k=1}^\\nu$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each $j \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$, check the following equality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">e \\left(\\hat {c _ {j}}, - v _ {j} \\cdot H\\right) = \\prod_ {k = 1} ^ {\\nu} e \\left(\\mathrm {w} _ {j, k}, \\beta_ {k} \\cdot H - u _ {k} \\cdot H\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, denote by <span class="math">\\Lambda \\cap \\Theta</span> the set of non-trivial constraints in <span class="math">\\Lambda</span>. For each non-trivial constraint <span class="math">S \\in \\Lambda \\cap \\Theta</span>, parse <span class="math">\\alpha_S \\cdot H</span> as $(\\alpha_S^{j-1} \\cdot H)_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and perform the &#x27;consistency&#x27; check with respect to </span>S$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e \\left(\\widetilde {c} _ {S}, H\\right) = \\prod_ {j = 1} ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} e \\left(\\hat {c} _ {j}, \\alpha_ {S} ^ {j - 1} \\cdot H\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-68" class="text-2xl font-bold">4.3.2 Extractability</h2>

    <p class="text-gray-300"><strong>Theorem 4.4.</strong> If the bilinear group sampler SampleGrp satisfies the SDH assumption against algebraic adversaries (Assumption 1), the construction EPC in Section 4.3.1 achieves equidfficient extractability (Section 4.1) in the Algebraic Group Model (AGM).</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> be an efficient stateful adversary against EPC. We show how to construct an efficient extractor <span class="math">\\mathcal{E}</span> against <span class="math">(\\mathcal{A}_1, \\mathcal{A}_2)</span> that succeeds with overwhelming probability, such that for every round bound <span class="math">r \\in \\mathbb{N}</span>, efficient public-coin sampler <span class="math">\\mathcal{C}</span>, query sampler <span class="math">\\mathcal{Q}</span>, constraint sampler <span class="math">\\mathcal{S}</span>, and adversary <span class="math">\\mathcal{A}_3</span>, the</p>

    <p class="text-gray-300">following probability is negligibly close to 1 (as a function of  <span class="math">\\lambda</span> ):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀i∈{1,...,r}: EPC.Verify(vk,ci,u,Vi,Λi,πi)=1 ↓ Pi(u)=Vi ∧ Λmij=1λi,j(pi,j)=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp←EPC.Setup(1λ,D) Ω←A1(1λ,pp) (ck,ok,vk)←EPC.Specializepp(Ω) For i∈{1,...,r}: Λi={λi,1,...,λi,m}←S(ck,ok) ρi←C(ck,ok,i) ci←A2(ck,ok,[Λj]i=1,[ρj]i=1) Pi=[pi,1,...,pi,m]←E(ck,ok,[Λj]i=1,[ρj]i=1) u←Q(ck,ok,[Λi]i=1,[ci]i=1,[ρi]i=1) ([Vi]i=1,[πi]i=1)←A3(u)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Denote by  <span class="math">\\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Omega</span> , and by  <span class="math">W</span>  the first non-trivial constraint appearing in  <span class="math">\\Omega</span> . Also, denote by  <span class="math">\\Lambda_i \\cap \\Theta</span>  the set of non-trivial constraints in  <span class="math">\\Lambda_i</span> , and by  <span class="math">m_i</span>  the number of constraints output by the constraint sampler  <span class="math">\\mathcal{S}</span>  for round  <span class="math">i</span> .</p>

    <p class="text-gray-300">For each round  <span class="math">i \\in [r]</span> , we construct the extractor  <span class="math">\\mathcal{E}</span>  for EPC below and argue that it succeeds with overwhelming probability.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{ck},\\mathrm{ok},[\\Lambda_j]_j^i = 1,[\\rho_j]_j^i = 1)\\to P:</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse the committer key  <span class="math">\\mathbf{ck}</span>  as  <span class="math">(\\mathbb{K},\\langle \\mathrm{group}\\rangle ,\\Omega ,\\Sigma ,(\\mathrm{ck}_S)_{S\\in \\Theta})</span></li>

      <li>Parse  <span class="math">\\Lambda_{i}</span>  as  <span class="math">\\{\\Lambda_1,\\dots ,\\Lambda_{m_i}\\}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Invoke the adversary:  $\\{\\langle \\hat{\\pmb{a}}_{\\Lambda_j,1},\\hat{\\pmb{L}}_{\\Lambda_j,1}\\rangle ,\\dots ,\\langle \\hat{\\pmb{a}}_{\\Lambda_j,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\hat{\\pmb{L}}_{\\Lambda_j,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\rangle ,\\langle \\widetilde{\\pmb{a}}_{\\Lambda_j},\\widetilde{\\pmb{L}}_{\\Lambda_j}\\rangle \\}_{j = 1}^{m_i}\\gets \\mathcal{A}_2(\\mathrm{ck},\\mathrm{ok},[\\Lambda_j]_j^i = 1,[p_j]_j^i = 1)^S.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">L_S \\neq \\mathrm{ck}_S</span>  for any  <span class="math">S \\in \\Lambda_i \\cap \\Theta</span> , output  <span class="math">\\perp</span> .</li>

      <li>For each non-trivial constraint  <span class="math">S \\in \\Lambda_i \\cap \\Theta</span> ,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Parse  <span class="math">S</span>  as  $[\\mathcal{P}_1,\\dots ,\\mathcal{P}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> , and each  </span>\\mathcal{P}_j<span class="math">  as  </span>(\\mathcal{I}_j,\\mathcal{B}_j)<span class="math"> , and each  </span>\\mathcal{B}_j<span class="math">  as  </span>\\{b_s^{(j)}\\}_{s = 1}^D$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">i. Set the vector of punctured basis elements  <span class="math">\\pmb{B}_j \\coloneqq [b_s^{(j)}]_{s \\in \\mathcal{I}_j}</span> , and their encodings  <span class="math">\\pmb{b}_j \\coloneqq \\pmb{B}_j(\\beta) \\cdot G</span> . ii. Perform a change of basis to solve the following equation for  <span class="math">\\pmb{y}</span> :  <span class="math">\\langle \\hat{\\pmb{a}}_{S,j},\\pmb{\\Sigma}\\rangle = \\langle \\pmb {y},\\pmb {b}_j\\rangle</span> . If there is no solution, output  <span class="math">\\perp</span> . Else, update  <span class="math">\\hat{\\pmb{a}}_{S,j}</span>  to  <span class="math">\\pmb{y}</span> . iii. Define the constrained polynomial  <span class="math">p_j \\coloneqq \\langle \\hat{\\mathbf{a}}_{S,j}, \\mathbf{B}_j \\rangle</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) Set  $\\pmb{p}_k \\coloneqq [p_1, \\dots, p_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> , where  </span>k<span class="math">  is the index of  </span>S<span class="math">  in  </span>\\Lambda_i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each trivial constraint  <span class="math">V \\in \\Lambda_i \\setminus \\Theta</span> , define the unconstrained polynomial  <span class="math">\\pmb{p}_{\\ell} = [\\langle \\pmb{a}_V, \\mathcal{U} \\rangle]</span> , where  <span class="math">\\ell</span>  is the index of  <span class="math">V</span>  in  <span class="math">\\Lambda_i</span> .</li>

      <li>Output the polynomials  <span class="math">P \\coloneqq [p_1, \\ldots, p_{m_i}]</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">aIf  <span class="math">\\Lambda_{j}</span>  is a trivial constraint, i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Lambda_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">  , then omit  </span>\\langle \\widetilde{\\pmb{a}}_{\\Lambda_j},\\widetilde{\\pmb{L}}_{\\Lambda_j}\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The extractor  <span class="math">\\mathcal{E}</span>  can fail with non-negligible probability due to at least one of three reasons. We analyze each case separately and argue it occurs with negligible probability, or that it contradicts our original assumptions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Incorrect evaluation: there exists a polynomial  <span class="math">p_{i,j} \\in P</span>  whose evaluation is incorrect.</li>

      <li>Coefficient non-equality: the equi-fficient property fails, i.e., there exists a round  <span class="math">i \\in [r]</span>  and a (non-trivial) constraint  <span class="math">\\Lambda_j \\in \\Lambda_i</span>  such that  <span class="math">\\Lambda_j(\\pmb{p}_j) = 0</span> .</li>

      <li><span class="math">\\mathcal{E}</span>  outputs  <span class="math">\\perp</span> : there exists a round  <span class="math">i \\in [r]</span>  in which the adversary  <span class="math">\\mathcal{A}_2</span>  outputs a group element corresponding to a non-trivial constraint  <span class="math">\\Lambda_j \\in \\Lambda_i</span>  such that  <span class="math">L_{\\Lambda_j} \\neq \\mathrm{ck}_{\\Lambda_j}</span>  (Step 4), or there is a polynomial  <span class="math">p_{j,k}</span>  associated to the non-trivial constraint  <span class="math">\\Lambda_j</span>  that cannot be written in terms of its designated punctured basis  <span class="math">\\mathcal{P}_j</span>  (Step 5(b)ii).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1) Incorrect evaluation. Recall that the following evaluation proof verification is performed for each constraint <span class="math">T\\in\\bm{\\Lambda}_{i}</span>, for every $j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">e(\\hat{c_{j}},-v_{j}\\cdot H)=\\prod_{k=1}^{\\nu}e\\left(\\mathsf{w}_{j,k},\\beta_{k}\\cdot H-u_{k}\\cdot H\\right)</span></p>

    <p class="text-gray-300">For each polynomial contained in the commitment <span class="math">\\hat{c}_{j}</span>, this a multilinear KZG verification. Thus by the evaluation binding of <em>[x20]</em>, the evaluations are correct with overwhelming probability.</p>

    <p class="text-gray-300">(2) Coefficient non-equality. Fix a round <span class="math">i\\in[r]</span>. If <span class="math">\\mathsf{EPC}</span>.Verify accepts and the extractor <span class="math">\\mathcal{E}</span> does not output <span class="math">\\bot</span> for round <span class="math">i</span>, we argue that the probability any list of extracted polynomials <span class="math">\\bm{p}_{j}\\in\\bm{P}_{i}</span> fails to be equifficient with respect to <span class="math">\\Lambda_{j}\\in\\bm{\\Lambda}_{i}</span> is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, we recall the ‘consistency’ check for each non-trivial constraint <span class="math">S\\in\\bm{\\Lambda}_{i}\\cap\\bm{\\Theta}</span> for the commitment $c_{S}=(\\hat{c}_{1},\\ldots,\\hat{c}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\widetilde{c}_{S})$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$e\\left(\\widetilde{c}_{S},H\\right)=\\prod_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}e\\left(\\hat{c}_{k},\\alpha_{S}^{k-1}\\cdot H\\right)$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The commitment <span class="math">c_{S}</span> that the extractor <span class="math">\\mathcal{E}</span> receives from the algebraic adversary <span class="math">\\mathcal{A}_{2}</span> is expressed via linear combinations of group elements: $\\langle\\hat{\\bm{a}}_{1},\\hat{\\bm{L}}_{1}\\rangle,\\ldots,\\langle\\hat{\\bm{a}}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\hat{\\bm{L}}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\rangle,\\langle\\widetilde{\\bm{a}}_{S},\\widetilde{\\bm{L}}_{S}\\rangle<span class="math"> (Step 3). Rewriting Eq. (13) in terms of these representations, we obtain the following equation in </span>\\mathbb{G}_{1}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\langle\\widetilde{\\bm{a}}_{S},\\widetilde{\\bm{L}}_{S}\\rangle=\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\langle\\hat{\\bm{a}}_{k},\\hat{\\bm{L}}_{k}\\rangle$ (14)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From Step 4 it holds that <span class="math">\\widetilde{\\bm{L}}_{S}=\\mathsf{ck}_{S}</span> and from Step 5(b)ii we can assume without loss of generality that <span class="math">\\hat{\\bm{L}}_{k}=\\bm{b}_{k}</span>. Recall <span class="math">\\mathsf{ck}_{S}</span> is computed as $\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\bm{b}_{k}$, thus rewriting the above we obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\langle\\widetilde{\\bm{a}}_{S},\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\bm{b}_{k}\\right\\rangle=\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\langle\\hat{\\bm{a}}_{k},\\bm{b}_{k}\\rangle$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Rewriting the inner product as a sum over the coefficients <span class="math">\\alpha_{S}^{k}</span>, we obtain:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\langle\\widetilde{\\bm{a}}_{S},\\bm{b}_{k}\\rangle=\\sum_{k=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{S}^{k-1}\\cdot\\langle\\hat{\\bm{a}}_{k},\\bm{b}_{k}\\rangle$ (15)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying the Schwartz–Zippel lemma <em>[x24, x23]</em> to the exponent of Eq. (15) by treating the coefficients <span class="math">\\alpha_{S}^{k}</span> as indeterminates, with probability greater than $1-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> it holds that </span>\\langle\\widetilde{\\bm{a}}_{S},\\bm{b}_{k}\\rangle=\\langle\\hat{\\bm{a}}_{k},\\bm{b}_{k}\\rangle<span class="math"> for all </span>k\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math">. Recall that each </span>\\bm{b}_{k}<span class="math"> is an encoding of linearly independent basis elements, hence </span>\\langle\\widetilde{\\bm{a}}_{S},\\bm{b}_{k}\\rangle=\\langle\\hat{\\bm{a}}_{k},\\bm{b}_{k}\\rangle<span class="math"> implies </span>\\widetilde{\\bm{a}}_{S}=\\hat{\\bm{a}}_{k}<span class="math"> with probability greater than </span>1-\\frac{\\nu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. To see the foregoing statement, express </span>\\langle\\widetilde{\\bm{a}}_{S}-\\hat{\\bm{a}}_{k},\\bm{b}_{k}\\rangle<span class="math"> as </span>\\sum_{j}(\\widetilde{a}_{j}-\\hat{a}_{j})b_{j}(\\bm{\\beta})\\cdot G<span class="math"> and apply the Schwartz–Zippel lemma to the polynomial </span>\\sum_{j}(\\widetilde{a}_{j}-\\hat{a}_{j})b_{j}(\\bm{\\beta})<span class="math"> in the indeterminates </span>b_{j}(\\bm{\\beta})$, which are independently random due to the linear independence of the underlying basis elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(3) <span class="math">\\bm{\\mathcal{E}}</span> outputs <span class="math">\\bot</span>. We follow the strategy from Theorem 4.3 and thereby omit details for the sake of brevity. The extractor <span class="math">\\mathcal{E}</span> outputs <span class="math">\\bot</span> in the <span class="math">i</span>th round if <span class="math">\\widetilde{\\bm{L}}_{S}\\neq\\mathsf{ck}_{S}</span> for some non-trivial constraint <span class="math">S\\in\\bm{\\Lambda}_{i}\\cap\\bm{\\Theta}</span> (Step 4),</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or if for some $j \\in [</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]<span class="math"> the system </span>\\langle \\hat{\\pmb{a}}_{S,j}, \\pmb{\\Sigma} \\rangle = \\langle \\pmb{y}, \\pmb{b}_j \\rangle<span class="math"> is unsolvable for </span>\\pmb{y}$ (Step 5(b)ii). We proceed to argue that if EPC.Verify accepts, this occurs with negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From Eq. (14), we deduce that except with negligible probability the <span class="math">j</span>th entry of <span class="math">\\widetilde{L}_S</span> must be expressed exclusively with linear combinations of group elements from <span class="math">\\mathsf{ck}_S</span> since <span class="math">\\mathsf{ck}_S</span> is the only key expressed in terms of the components <span class="math">\\alpha_S^k</span>.</p>

    <p class="text-gray-300">For notational clarity, denote <span class="math">\\hat{\\pmb{a}}_{S,j}</span> by <span class="math">\\hat{\\pmb{a}}_j</span>. Now, suppose <span class="math">\\langle \\hat{\\pmb{a}}_j,\\pmb {\\Sigma}\\rangle = \\langle \\pmb {y},\\pmb {b}_j\\rangle</span> is unsolvable for <span class="math">\\pmb{y}</span> (Step 5(b)ii). Letting <span class="math">\\pmb{\\Sigma}_{j}</span> be the <span class="math">\\mathcal{B}_j</span> encodings, solve the equation <span class="math">\\langle \\hat{\\pmb{a}}_j,\\pmb {\\Sigma}\\rangle = \\langle \\pmb {y}&#x27;,\\pmb {\\Sigma}_j\\rangle</span> for <span class="math">\\pmb{y}&#x27;</span>. (Note this is simply a change-of-basis from <span class="math">\\mathcal{U}</span> to <span class="math">\\mathcal{B}_j</span>.) Since the prior equation had no solution, there must exist some index <span class="math">\\kappa \\in [D]\\setminus \\mathcal{J}_j</span> such that <span class="math">y_{\\kappa}^{\\prime}\\neq 0</span>. Furthermore, since the verifier accepts, using Eq. (15) and isolating in terms of <span class="math">\\alpha_S^{j - 1}</span>, by the Schwartz-Zippel lemma <span class="math">\\langle \\widetilde{\\pmb{a}}_S,\\pmb {b}_j\\rangle = \\langle \\pmb {y}&#x27;,\\pmb {\\Sigma}_j\\rangle</span> holds with high probability. Since the left and right-hand side of this equation are linear combinations of different basis element encodings of <span class="math">\\mathcal{B}_j</span> (e.g., they differ at <span class="math">\\kappa</span>), this contradicts the linear independence of <span class="math">\\mathcal{B}_j</span>.</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">5 SNARKs for GR1CS from EPC schemes</p>

    <p class="text-gray-300">We now describe and prove secure our blueprint for designing SNARKs with a circuit-specific setup for GR1CS. We begin by introducing a new oracle relation, rowcheck, which captures the non-linear constraints in a GR1CS instance. To construct our SNARK, we will rely on a PIOP for rowcheck and an equifficient polynomial commitment scheme.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">Rowcheck is the indexed oracle relation consisting of all triples of the form</p>

    <p class="text-gray-300"><span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})=((\\mathbb{F},\\mathbb{K},t,c,[L_{i},\\mathcal{D}_{i}]_{i=1}^{c}),[\\llbracket\\hat{\\bm{z}}_{i}\\rrbracket]_{i=1}^{c},[\\hat{\\bm{z}}_{i}]_{i=1}^{c})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\mathbb{K}</span> is a <span class="math">m</span>-dimensional vector space of polynomials over <span class="math">\\mathbb{F}</span>, <span class="math">L_{i}</span> is a local predicate (Definition 3.2) with arity <span class="math">t</span>, and <span class="math">\\mathcal{D}_{i}</span> is a domain consisting of elements from <span class="math">\\mathbb{F}</span>. Also, each element <span class="math">\\hat{\\bm{z}}_{i}</span> of the witness consists of a list of polynomials <span class="math">[\\hat{z}_{i,j}]_{j=1}^{t}</span> in <span class="math">\\mathbb{K}</span> such that for all <span class="math">i\\in[c]</span> and for all <span class="math">x\\in\\mathcal{D}_{i}</span> it holds that <span class="math">L_{i}(\\hat{\\bm{z}}_{i}(x))=0</span>. The instance contains the oracles corresponding to the witness polynomials.</p>

    <p class="text-gray-300">Without loss of generality, we assume that the domains <span class="math">\\mathcal{D}_{1},\\ldots,\\mathcal{D}_{c}</span> are disjoint, namely for all <span class="math">i\\neq j</span>, we have that <span class="math">\\mathcal{D}_{i}\\cap\\mathcal{D}_{j}=\\varnothing</span>. In our instantiations, each domain <span class="math">\\mathcal{D}_{i}</span> is either a subgroup of the multiplicative group <span class="math">\\mathbb{F}^{*}</span> (Section 6) or a subset of the boolean hypercube <span class="math">\\mathcal{B}_{\\nu}</span> (Section 7).</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">5.1 Construction</h3>

    <p class="text-gray-300">We describe our construction of a SNARK for GR1CS in Fig. 5 using two ingredients: a Polynomial Interactive Oracle Proof <span class="math">\\mathsf{PIOP}=(\\mathbb{F},\\mathbb{K},\\mathsf{r},\\mathsf{s},\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for rowcheck, and an equifficient polynomial commitment scheme <span class="math">\\mathsf{EPC}=(\\mathsf{Setup},\\mathsf{Specialize},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span>. To enable the verifier to succinctly handle public inputs, we assume that the GR1CS instance has been transformed as per Remark 2.2.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Remark 5.2.</h6>

    <p class="text-gray-300">In Fig. 5, we assume in Step 8 that the query set <span class="math">Q</span> consists of a single point, as this suffices for our instantiations in Sections 6 and 7. To handle the general case, one would need to generalize the EPC definition to handle arbitrary query sets. We believe that this can be done in straightforward manner by adapting the transformations of <em>[x10]</em>; we leave this to future work.</p>

    <p class="text-gray-300">The following theorem captures key properties of our construction:</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Theorem 5.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}</span> be a field family. Consider the following components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PIOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> is a complete and sound PIOP (Section 3.4) over <span class="math">\\mathcal{F}</span> for rowcheck (Definition 5.1),</li>

      <li><span class="math">\\mathsf{EPC}=(\\mathsf{Setup},\\mathsf{Specialize},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Verify})</span> is a complete and multi-round extractable (Section 4.1) equifficient polynomial commitment scheme (Section 4) over <span class="math">\\mathcal{F}</span>.</li>

    </ul>

    <p class="text-gray-300">Then, the construction <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> in Fig. 5 is a public-coin succinct interactive argument of knowledge with a circuit-specific trusted setup for GR1CS.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness and the public-coin property follows straightforwardly by construction; therefore, we only prove succinctness and knowledge soundness.</p>

    <p class="text-gray-300">Succinctness. Suppose <span class="math">d</span> is the maximum degree of the predicates. The verification key is of size <span class="math">O(dc)</span>. The verifier performs the vector-matrix product in Step 3d which due to the technique introduced in Remark 2.2 becomes sublinear in <span class="math">m</span>. Invoking the PIOP verifier for is also assumed to be sublinear. At last, <span class="math">\\mathcal{V}</span> verifies the opening of the commitments which is discussed in Section 4.1 to be sublinear. Hence, the verification process of the above blueprint is asymptotically sublinear in the number of constraints, but is linear to the</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 5: Our generic SNARK for GR1CS.</p>

    <p class="text-gray-300">number of predicates  <span class="math">(c)</span> , the degree of the predicates  <span class="math">(d)</span>  and the arity of the predicates  <span class="math">(t)</span> . The proof size is consequently succinct.</p>

    <p class="text-gray-300">Knowledge soundness. Suppose for contradiction that there exists an efficient adversarial prover  <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1, \\tilde{\\mathcal{P}}_2, \\tilde{\\mathcal{P}}_3)</span>  for ARG that breaks knowledge soundness of ARG with non-negligible probability  <span class="math">\\epsilon_{\\mathsf{ARG}}(\\lambda)</span> . That is, for every efficient extractor  <span class="math">\\mathcal{E}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathrm {i}, \\mathrm {x}, \\mathrm {w}) \\notin \\mathcal {R} _ {\\mathrm {N}} &amp;amp; (\\mathrm {i}, \\mathrm {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} \\left(1 ^ {\\lambda}\\right) \\\\ \\wedge &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {G} \\left(1 ^ {\\lambda}, \\mathrm {i}\\right) \\\\ \\langle \\tilde {\\mathcal {P}} _ {3} (\\mathrm {s t} ^ {\\prime}), \\mathcal {V} (\\mathrm {i v k}, \\mathrm {x}) \\rangle = 1 &amp;amp; (\\mathrm {x}, \\mathrm {s t} ^ {\\prime}) \\leftarrow \\tilde {\\mathcal {P}} _ {2} (\\mathrm {s t}, \\mathrm {i p k}) \\\\ &amp;amp; \\mathrm {w} \\leftarrow \\mathcal {E} (\\mathrm {i p k}, \\mathrm {x}) \\end{array} \\right] &amp;gt; \\epsilon_ {\\mathsf {A R G}} (\\lambda) \\quad . \\tag {16}</span></div>

    <p class="text-gray-300">We will use  <span class="math">\\tilde{\\mathcal{P}}</span>  to construct efficient adversaries  <span class="math">\\tilde{\\mathbf{P}}</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{EPC}} = (\\mathcal{A}_1,\\mathcal{A}_2)</span>  against the soundness of the PIOP and extractability of EPC, respectively. That is, the following will hold for  <span class="math">\\tilde{\\mathbf{P}}</span>  and  <span class="math">\\mathcal{A}_{\\mathrm{EPC}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} (\\mathrm {i}, \\mathrm {x}) \\notin \\mathcal {L} (\\mathcal {R} _ {\\mathrm {N}}) &amp;amp; (\\mathrm {i}, \\mathrm {s t}) \\leftarrow \\tilde {\\mathcal {P}} _ {1} (1 ^ {\\lambda}) \\\\ \\wedge &amp;amp; (\\mathrm {i p k}, \\mathrm {i v k}) \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, \\mathrm {i}) \\\\ \\langle \\tilde {\\mathbf {P}} (\\mathrm {s t} ^ {\\prime}), \\mathbf {V} ^ {\\mathbf {I} (\\mathrm {i})} (\\mathrm {i v k}, \\mathrm {x}) \\rangle = 1 &amp;amp; (\\mathrm {x}, \\mathrm {s t} ^ {\\prime}) \\leftarrow \\tilde {\\mathcal {P}} _ {2} (\\mathrm {s t}, \\mathrm {i p k}) \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} \\mathcal {A} _ {\\mathrm {E P C}} \\text {w i n s t h e E P C} \\\\ \\text {e x t r a c t a b i l i t y g a m e} \\end{array} \\right] &amp;gt; \\epsilon_ {\\mathsf {A R G}} (\\lambda) \\quad .</span></div>

    <p class="text-gray-300">This suffices because either (i) by averaging there exists a choice of prover key  <span class="math">\\mathsf{ipk}</span>  that yields prover state  <span class="math">\\mathsf{st}&#x27;</span>  and  <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x})\\notin \\mathcal{L}(\\mathcal{R}_{\\mathbb{N}})</span>  such that  <span class="math">\\tilde{\\mathbf{P}}</span>  wins the PIOP soundness game, or (ii)  <span class="math">\\mathcal{A}_{\\mathrm{EPC}}</span>  wins the EPC extractability game for any efficient extractor. In either case, we derive a contradiction against our assumptions.</p>

    <p class="text-gray-300">Constructing  <span class="math">\\mathcal{A}_{\\mathrm{EPC}}</span> . We begin by describing how we will construct the adversary  <span class="math">\\mathcal{A}_2</span>  against EPC:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}_2(\\mathrm{ck},\\mathrm{ok},[\\Lambda_j]_{j = 0}^i,[\\rho_j]_{j = 0}^i)\\to c_i</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assume that  <span class="math">\\mathcal{A}_2</span>  is passed  <span class="math">\\dot{\\mathbf{i}}</span> ,  <span class="math">\\mathrm{st}</span>  from  <span class="math">\\mathcal{A}_1</span></li>

      <li>Run Steps 8 to 10 of the generator  <span class="math">\\mathcal{G}</span>  to (deterministically) construct the keys (ipk, ivk).</li>

      <li>Run the prover  <span class="math">\\tilde{\\mathcal{P}}_2(\\mathsf{st},\\mathsf{ipk})</span>  to obtain the instance  <span class="math">\\mathbf{x}</span>  and the prover state  <span class="math">\\mathsf{st}&#x27;</span> .</li>

      <li>If  <span class="math">i = 0</span> : obtain the index polynomial commitments  <span class="math">c_{0}</span>  from ivk, and output these.</li>

      <li>If  <span class="math">i \\in \\{1, \\dots, r(\\dot{\\mathfrak{i}}) + 1\\}</span> , run  <span class="math">\\tilde{\\mathcal{P}}_3(\\mathsf{st}&#x27;, \\mathsf{ipk}, \\rho_1, \\dots, \\rho_i)</span>  and output the commitment generated by  <span class="math">\\tilde{\\mathcal{P}}_3</span> .</li>

    </ol>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{E}_{\\mathrm{EPC}}</span>  be the extractor for  <span class="math">\\mathcal{A}_2</span> . We now describe how to use  <span class="math">\\mathcal{E}_{\\mathrm{EPC}}</span>  to construct the adversary  <span class="math">\\tilde{\\mathbf{P}}</span>  against the soundness of the PIOP.</p>

    <p class="text-gray-300">Constructing  <span class="math">\\tilde{\\mathbf{P}}</span> .  <span class="math">\\tilde{\\mathbf{P}}</span>  invokes  <span class="math">\\mathcal{E}_{\\mathrm{EPC}}</span>  to obtain each round polynomial:</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathbf{P}} (\\mathsf{st},\\rho_2,\\ldots ,\\rho_i)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">\\rho_0 = \\rho_1\\coloneqq \\bot</span></li>

      <li>Run  <span class="math">\\mathcal{E}_{\\mathrm{EPC}}(\\mathrm{ck},\\mathrm{ok},\\Omega ,[\\rho_j]_{j = 0}^i)</span>  to obtain the  <span class="math">i</span>  -th round polynomials.</li>

    </ol>

    <p class="text-gray-300">We can use these algorithms to construct an extractor  <span class="math">\\mathcal{E}</span>  for ARG as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}(\\mathrm{ipk},\\mathbb{x})\\to \\mathbb{W}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse ipk as  <span class="math">(\\dot{\\mathbf{i}},\\mathrm{ivk},[p_{0,j}]_{j = 1}^{\\mathbf{s}(0)},\\mathrm{ck},\\mathrm{ok})</span>  and ivk as  <span class="math">(\\dot{\\mathbf{i}}_s,c_0,\\mathbf{vk})</span> . Also parse ck to get  <span class="math">\\Omega_w</span> .</li>

      <li>For  <span class="math">i\\in \\{0,\\dots ,\\mathsf{r}(\\dot{\\mathbf{i}})\\}</span></li>

    </ol>

    <p class="text-gray-300">(a) Run the challenger  <span class="math">\\mathcal{C}</span>  to obtain the randomness  <span class="math">\\rho_{i}</span> . (b) Invoke  <span class="math">\\mathcal{E}_{\\mathrm{EPC}}(\\mathrm{ck},\\mathrm{ok},\\Omega_w,[\\rho_j]_{j = 0}^i)</span>  to obtain the  <span class="math">i</span>  -th round polynomials  <span class="math">P_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve for the witness  <span class="math">\\mathbb{W}</span>  by solving the system of linear equations implied by the extracted polynomials  <span class="math">P_{1}</span>  and the matrix-basis polynomials in  <span class="math">\\Omega_{1}</span> . (The condition in Remark 3.5 ensures that we only deal with GR1CS instances where this system has a solution.)</li>

      <li>Output w.</li>

    </ol>

    <p class="text-gray-300">With this definition of  <span class="math">\\mathcal{E}</span> , let us now analyze the knowledge soundness of ARG. We begin by rewriting Equation (16) in three steps. First, we inline the definition of  <span class="math">\\mathcal{E}</span> . Next, we fully write out the execution of the protocol between  <span class="math">\\tilde{\\mathcal{P}}</span>  and  <span class="math">\\mathcal{V}</span> . Then, we move the interactive portion of this interaction to the conditional part of the probability expression. (This change results in the inequality.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">εARG(λ) ≤ Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ˆ, x, w)∉RN ∧ Dv([Vj]r(i)+1)=1 ∀i∈{0,...,r(i)+1}: EPC.Verify(vk, ci, u, Vi, Ωi, πi)=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i←ˆP1(1λ) pp←EPC.Setup(1λ,D) form Ω as in G (ck, ok, vk)←EPC.Specialize(pp, Ω)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  set ρ0 := ⊥ P0 = [p0,j]s(0)←I(F, i) c0←EPC.Commit(ck, P0, W)  |</p>

    <p class="text-gray-300">|   |   |  ivk := (i_s, c0, vk) ipk := (i, ivk, [p0,j]s(0), ck, ok) x←ˆP2(ipk)  |</p>

    <p class="text-gray-300">|   |   |  set ρ1 := ⊥ c1←ˆP3(ipk) P1←EPEC(ck, ok, Ω)  |</p>

    <p class="text-gray-300">|   |   |  for i ∈ {1,..., r(i)}: ρi+1← V(ivk, x, ρw, [ρj]i=1) ci+1←ˆP3(ipk, ρw, [ρj]i+1) Pi+1←EPEC(ck, ok, Ω, [ρj]i+1)  |</p>

    <p class="text-gray-300">|   |   |  set w to be the coefficients of Pi u← V(ivk, x, [ρi]r(i)+1) ([Vj]r(i)+1, [πi]r(i)+1)←ˆP3(ipk, [ρi]r(i)+1, u)  |</p>

    <p class="text-gray-300">Note that the extracted witness  <span class="math">\\mathbb{W}</span>  can be invalid if either (1) the equifficient constraints on it are not satisfied, or (2) the polynomials  <span class="math">\\hat{z}_i = \\hat{w}_i + \\hat{x}_i</span>  formed from it do not satisfy rowcheck. We can now consider two cases, depending on the success or failure of the EPC extractor.</p>

    <p class="text-gray-300">If the EPC extractor succeeds, then we know that Condition (1) cannot occur, and that the evaluations  <span class="math">[V_i]_{i=0}^{r(\\dot{\\mathbf{i}}) + 1}</span>  are correct. This means that Condition (2) can only occur if the PIOP prover  <span class="math">\\tilde{\\mathbf{P}}</span>  (that is implicitly executed on the right side) breaks the soundness of the PIOP.</p>

    <p class="text-gray-300">On the other hand, if the EPC extractor fails, then it can either be because the equifficient constraints are not satisfied, or because the evaluations are incorrect. (Note that  <span class="math">\\tilde{\\mathbf{P}}</span>  could still succeed even if the EPC extractor fails, but the probability of this joint event is subsumed by the probability of just the EPC extractor failing.) In either situation, this would violate the extractability of the EPC scheme.</p>

    <p class="text-gray-300">Formally, we can write this as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon_{\\mathsf{ARG}}(\\lambda) \\leq \\Pr \\left[ \\begin{array}{c} \\mathbf{D}_{\\mathbf{V}}([\\mathbf{V}_{i}]_{i=0}^{r(\\mathrm{i})+1}) = 1 \\\\ \\text{and} \\\\ \\mathcal{E}_{\\mathsf{EPC}} \\text{ fails:} \\\\ \\mathsf{EPC}.\\text{Verify accepts, but either} \\\\ \\mathrm{w} = w \\text{ is not a solution to } \\Omega_{w}, \\text{ or} \\\\ \\exists i \\text{ such that } P_{i}(u) \\neq V_{i} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\text{same as} \\\\ \\text{Eq. (17)} \\end{array} \\right] + \\Pr \\left[ \\begin{array}{c} (\\mathrm{i}, \\mathrm{x}, \\mathrm{w}) \\notin \\mathcal{R}_{\\mathsf{N}} \\\\ \\text{and} \\\\ \\mathbf{D}_{\\mathbf{V}}([\\mathbf{V}_{i}]_{i=0}^{r(\\mathrm{i})+1}) = 1 \\\\ \\text{and} \\\\ \\mathcal{E}_{\\mathsf{EPC}} \\text{ succeeds} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\text{same as} \\\\ \\text{Eq. (17)} \\end{array} \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We are now able to write the second term as the PIOP soundness error <span class="math">\\epsilon_{\\mathsf{PIOP}}</span>, because it can be seen as an execution of the interaction between <span class="math">\\tilde{\\mathbf{P}}</span> and <span class="math">\\mathbf{V}</span> in the PIOP soundness game. This leaves us with the following inequality:</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon_{\\mathsf{ARG}}(\\lambda) \\leq \\Pr \\left[ \\begin{array}{c c} \\mathcal{E}_{\\mathsf{EPC}} \\text{ fails} &amp;amp; \\text{same as} \\\\ &amp;amp; \\text{Eq. (17)} \\end{array} \\right] + \\epsilon_{\\mathsf{PIOP}}</span></div>

    <p class="text-gray-300">Now notice that the conditional part of Eq. (17) can be viewed as an execution of an extractability game for the EPC scheme. In more detail, the adversary <span class="math">\\mathcal{A}_1</span>, on input security parameter and the public parameters <span class="math">\\mathsf{pp}</span>, invokes <span class="math">\\tilde{\\mathcal{P}}_1(1^\\lambda)</span> to compute the index <span class="math">(\\mathrm{i},\\mathrm{st})</span>, performs Steps 4 and 6 of the generator <span class="math">\\mathcal{G}</span> to compute the set of equidfficient constraints <span class="math">\\Omega</span>, and outputs these. The constraint sampler <span class="math">S</span> outputs the canonical basis <span class="math">\\mathcal{U}</span> in the 0-th round, outputs <span class="math">\\Omega</span> in the next round, and outputs <span class="math">\\mathcal{U}</span> thereafter. The public-coin challenger <span class="math">\\mathcal{C}</span> is defined to output <span class="math">\\perp</span> in rounds 0 and 1, and to equal the interactive phase of <span class="math">\\mathbf{V}</span> in the remaining rounds. This means that in the <span class="math">i</span>-th round of the EPC extractability game (for <span class="math">i \\in \\{2,\\dots,r(\\mathrm{i}) + 1\\}</span>) the challenger <span class="math">\\mathcal{C}</span> will output the randomness <span class="math">\\rho_{i-1}</span> output by <span class="math">\\mathbf{V}</span> in the PIOP round <span class="math">i - 1</span>. Finally, the adversary <span class="math">\\mathcal{A}_3</span> runs <span class="math">\\tilde{\\mathcal{P}}_3</span> and outputs the evaluations and evaluation proofs produced by the latter.</p>

    <p class="text-gray-300">This allows us to write the first term in the above inequality as the EPC extractability error <span class="math">\\epsilon_{\\mathsf{EPC}}(\\lambda)</span>. This completes the proof.</p>

    <p class="text-gray-300">43</p>

    <p class="text-gray-300">6 PARI: a 2-group element SNARK for NP</p>

    <p class="text-gray-300">We describe PARI, a SNARK for Square R1CS (Definition 3.4). PARI is obtained by instantiating the construction in Fig. 5 with the EPC scheme from Section 4.2 and a univariate PIOP for a variant of the rowcheck relation (Definition 5.1) specialized for the local polynomial predicate <span class="math">L(a,b)=a^{2}-b</span>, which we describe below (Section 6.1). After the optimizations in Section 6.2, the final construction has a proof size of just <em>two</em> group elements plus two scalar field elements, making it the smallest known SNARK for NP.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">6.1 Univariate PIOP for SR1CS rowcheck</h3>

    <p class="text-gray-300">PARI proves Square R1CS (SR1CS) statements; the corresponding rowcheck relation consists of tuples of the form:</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbf{x},\\mathbf{w})=((\\mathbb{F},\\mathbb{K},m,K),(\\llbracket\\hat{z}_{A}\\rrbracket,\\llbracket\\hat{z}_{B}\\rrbracket),(\\hat{z}_{A},\\hat{z}_{B}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">m</span> is the number of constraints, <span class="math">K</span> is a smooth multiplicative subgroup of <span class="math">\\mathbb{F}^{*}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math"> is a power of two, </span>\\mathbb{K}<span class="math"> is a </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-dimensional vector space of polynomials over </span>\\mathbb{F}<span class="math">, and </span>\\hat{z}_{A}<span class="math"> and </span>\\hat{z}_{B}$ are polynomials, such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{z}_{A}^{2}(\\kappa)-\\hat{z}_{B}(\\kappa)=0\\quad\\forall\\kappa\\in K</span></p>

    <p class="text-gray-300">A PIOP for SR1CS is described below, and underlies the PARI construction.</p>

    <p class="text-gray-300">PIOP 1: Univariate PIOP for SR1CS rowcheck</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{P}(\\mathbf{x},\\mathbf{w}),\\mathbf{V}(\\mathbf{x})\\rangle</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> receives as input the witness <span class="math">\\mathbf{w}=(\\hat{z}_{A},\\hat{z}_{B})</span>.</li>

      <li><span class="math">\\mathbf{P}</span> computes the quotient polynomial <span class="math">q:=\\frac{\\hat{z}_{A}^{2}-\\hat{z}_{B}}{v_{K}}</span>, and sends <span class="math">\\llbracket q\\rrbracket</span> to <span class="math">\\mathbf{V}</span>.</li>

      <li><span class="math">\\mathbf{V}</span> samples <span class="math">r\\leftarrow\\mathbb{F}\\setminus K</span>, and queries the oracles <span class="math">\\llbracket\\hat{z}_{A}\\rrbracket,\\llbracket\\hat{z}_{B}\\rrbracket,\\llbracket q\\rrbracket</span> at <span class="math">r</span>.</li>

      <li><span class="math">\\mathbf{V}</span> checks that <span class="math">q(r)=\\frac{\\hat{z}_{A}^{2}(r)-\\hat{z}_{B}(r)}{v_{K}(r)}</span></li>

    </ol>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">Security.</h4>

    <p class="text-gray-300">Completeness follows straightforwardly, and soundness follows by applying the Schwartz–Zippel lemma <em>[Zippel, Scholl, 2018]</em> to the check <span class="math">\\hat{z}_{A}^{2}-\\hat{z}_{B}=q\\cdot v_{K}</span>.</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">6.2 Unrolled SNARK</h3>

    <p class="text-gray-300">We describe the unrolled PARI construction in Fig. 6. For an SR1CS index <span class="math">(\\mathbb{F},n,k,m,A,B)</span> with <span class="math">k</span> variables, <span class="math">m</span> constraints, and <span class="math">n</span> instance variables, and letting <span class="math">\\eta</span> denote the number of non-zero entries in <span class="math">A</span> and <span class="math">B</span>, PARI has the following efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>setup time is <span class="math">O(\\eta+m\\log m)</span> <span class="math">\\mathbb{F}</span> operations plus <span class="math">4k</span> <span class="math">\\mathbb{G}_{1}</span> operations.</li>

      <li>prover time is <span class="math">O(\\eta+m\\log m)</span> <span class="math">\\mathbb{F}</span> operations, 1 MSM of size <span class="math">k-n</span> in <span class="math">\\mathbb{G}_{1}</span>, and 3 MSMs of size <span class="math">m</span> in <span class="math">\\mathbb{G}_{1}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- verifier time is dominated by $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>\\mathbb{F}<span class="math"> operations and </span>3$ pairings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>verification key size is <span class="math">O(n)\\,\\mathbb{F}+2\\mathbb{G}_{1}+5\\,\\mathbb{G}_{2}</span> elements.</li>

      <li>proving key size is <span class="math">O(\\eta)\\,\\mathbb{F}+(4k-n)\\,\\mathbb{G}_{1}</span> elements.</li>

      <li>proof size is <span class="math">2\\,\\mathbb{G}_{1}+2\\,\\mathbb{F}</span> elements.</li>

    </ul>

    <p class="text-gray-300">To obtain these efficiency figures, we make the following optimizations to the generic construction of Fig. 5.</p>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">Batch commitment and opening.</h4>

    <p class="text-gray-300">We designed the EPC scheme in Section 4.2 to allow the prover to ‘batch’ commitments and opening proofs for different polynomials, enabling us to reduce proof size in PARI. This batching allows PARI to commit to the polynomials <span class="math">\\hat{z}_{A},\\hat{z}_{B}</span> and the quotient polynomial <span class="math">q</span> with a single</p>

    <p class="text-gray-300">group element. Similarly, the opening proof for these polynomials also consists of a single group element, leading to the proof containing just two group elements, as required.</p>

    <p class="text-gray-300">Reducing the number of evaluations. Naively performing the verifier’s check in PIOP 1 would require the prover to send evaluations of <span class="math">\\hat{z}_{A},\\hat{z}_{B}</span> and the quotient polynomial <span class="math">q</span>. We eliminate one of these evaluations by having the verifier compute the evaluation of <span class="math">q</span> using the equation <span class="math">q(r):=\\frac{\\hat{z}_{A}^{2}(r)-\\hat{z}_{B}(r)}{v_{\\kappa}(r)}</span>. This requires the prover to only send the evaluations of <span class="math">\\hat{z}_{A},\\hat{z}_{B}</span> at the challenge point <span class="math">r</span>, thus reducing the number of field elements in the proof to two.</p>

    <p class="text-gray-300">|  G(1λ, i) → (ipk, ivk):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Parse the Square R1CS index i as (F, n, k, m, A, B) where A ∈ Fm×k, B ∈ Fm×k.  |</p>

    <p class="text-gray-300">|  2. Set the succinct index i_s := (F, n, k, m, A', B') where A' ∈ Fm×n, B' ∈ Fm×n.  |</p>

    <p class="text-gray-300">|  3. Sample a bilinear group ⟨group⟩ = (G1, G2, G_T, G, H, e) ← SampleGrp(1λ).  |</p>

    <p class="text-gray-300">|  4. Sample random field elements α, β, δ1, δ2, τ ← F.  |</p>

    <p class="text-gray-300">|  5. Interpolate the columns of A and B over K to obtain the bases A := [ai(X)]k_i=1 and B := [bi(X)]k_i=1.  |</p>

    <p class="text-gray-300">|  6. Compute the group elements ΣA := [ατ^i/δ1G]k_i=1, ΣB := [βτ^i/δ1G]k_i=1, and ΣQ := [τ^i/δ1G]k_i=1.  |</p>

    <p class="text-gray-300">|  7. Compute the commitment key Σ = [αa_i(τ)+βb_i(τ)/δ2G]k_i=n+1.  |</p>

    <p class="text-gray-300">|  8. Output ipk = (⟨group⟩, i, Σ, ΣA, ΣB, ΣQ) and ivk = (⟨group⟩, i_s, αG, βG, δ1H, δ2H, τH, δ1τH).  |</p>

    <p class="text-gray-300">|  P^ρ(ipk, x, w) → π:  |</p>

    <p class="text-gray-300">|  1. Parse ipk as (⟨group⟩, i, Σ, ΣA, ΣB, ΣQ).  |</p>

    <p class="text-gray-300">|  2. Parse the Square R1CS index i as (F, n, k, m, A, B) where A, B are matrices in Fm×k.  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Construct the variable assignment z by concatenating the instance and witness assignments: z := (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  4. Compute z_A := Az and z_B := Bz, and interpolate these over K to obtain polynomials z_A and z_B.  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Compute w_A := A · (0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w) and w_B := B · (0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w), and interpolate these over K to obtain polynomials w_A and w_B.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  6. Compute a batched commitment to the polynomials w_A and w_B: TAB := ∑i=n+1k wi · Σ[i].  |</p>

    <p class="text-gray-300">|  7. Compute the quotient polynomial q := z_A^2 - z_B/v_K, and commit to it: TQ := ∑i∈[m] q[i]ΣQ[i].  |</p>

    <p class="text-gray-300">|  8. Batch the commitments: T := TAB + TQ  |</p>

    <p class="text-gray-300">|  9. Sample an evaluation point from the random oracle: r := ρ(transcript).  |</p>

    <p class="text-gray-300">|  10. Evaluate w_A and w_B at r to get evaluations v_a := w_A(r) and v_b := w_B(r), respectively.  |</p>

    <p class="text-gray-300">|  11. Compute the opening witness polynomials:  |</p>

    <p class="text-gray-300">|  W_A(X) := w_A(X) - w_A(r)/(X - r); W_B(X) := w_B(X) - w_B(r)/(X - r); W_Q(X) := q(X) - q(r)/(X - r).  |</p>

    <p class="text-gray-300">|  12. Compute the separate opening proofs:  |</p>

    <p class="text-gray-300">|  W_A := ∑i∈[m] W_A[i] · ΣA[i]; W_B := ∑i∈[m] W_B[i] · ΣB[i]; W_Q := ∑i∈[m] W_Q[i] · ΣQ[i]  |</p>

    <p class="text-gray-300">|  13. Batch the opening proofs: U := W_A + W_B + W_Q  |</p>

    <p class="text-gray-300">|  14. Output proof π := (T, U, v_a, v_b).  |</p>

    <p class="text-gray-300">|  V^ρ(ivk, x, π) → b:  |</p>

    <p class="text-gray-300">|  1. Parse the verification key ivk = (⟨group⟩, i_s, αG, βG, δ1H, δ2H, τH, δ1τH).  |</p>

    <p class="text-gray-300">|  2. Parse the proof π as (T, U, v_a, v_b).  |</p>

    <p class="text-gray-300">|  3. Sample an evaluation point from the random oracle r := ρ(transcript).  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Compute the vectors x_A := A · (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0) and x_B := B · (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0), and interpolate them on K to obtain x_A and x_B.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5. Compute the quotient polynomial evaluation:  |</p>

    <p class="text-gray-300">|  v_q := (v_a + x_A(r))^2 - (v_b + x_B(r))/v_K(r).  |</p>

    <p class="text-gray-300">|  6. Check the following pairing equation:  |</p>

    <p class="text-gray-300">|  e(T, δ2H) = e(U, δ1τH - r · δ1H) · e(v_a · αG + v_b · βG + v_q · G, H).  |</p>

    <p class="text-gray-300">Figure 6: The unrolled PARI SNARK.</p>

    <p class="text-gray-300">7 GARUDA: a linear-time prover SNARK for GR1CS</p>

    <p class="text-gray-300">We describe GARUDA, a SNARK for GR1CS. GARUDA is obtained by instantiating the generic construction in Section 5.1 with the EPC scheme from Section 4.3 and a sumcheck-based PIOP for “Stacked” rowcheck, a variant of rowcheck that we introduce (see Section 2.5 for a high-level discussion of this relation). The key feature of GARUDA is a linear-time prover for GR1CS that avoids cryptographic costs for linear gates.</p>

    <p class="text-gray-300">We begin by describing in Section 7.1 our PIOP, and then describe in Section 7.2 the optimizations we make to obtain our concrete SNARK construction.</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">7.1 Multilinear PIOP for Stacked rowcheck</h3>

    <p class="text-gray-300">Before we describe our PIOP for the stacked rowcheck relation, we first recall key building blocks that we use to construct the latter, namely PIOPs for multivariate <em>sumcheck</em> and <em>zerocheck</em>.</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Tool: multivariate PIOP for sumcheck.</h5>

    <p class="text-gray-300">The sumcheck PIOP allows the prover to prove that the evaluations of a <span class="math">\\mu</span>-variate polynomial <span class="math">f\\in\\mathbb{K}</span> with maximum individual degree <span class="math">d:=\\deg^{*}(f)</span> over an appropriate Boolean hypercube sum to a claimed value, i.e. that <span class="math">\\sum_{\\mathbf{x}\\in\\{0,1\\}^{\\mu}}f(\\mathbf{x})=0</span>.</p>

    <p class="text-gray-300">[PIOP 2: Sumcheck [LFKN92]]</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{P}(\\mathbf{x},\\mathbf{w}),\\mathbf{V}(\\mathbf{x})\\rangle</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> receives as input a polynomial <span class="math">f</span>, and <span class="math">\\mathbf{V}</span> has oracle access to the same.</li>

      <li><span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> a univariate polynomial <span class="math">g_{1}(x_{1})</span> such that <span class="math">g_{1}(x_{1})=\\sum_{\\{x_{2},\\ldots,x_{\\mu}\\}\\in\\{0,1\\}^{\\mu-1}}f(x_{1},x_{2},\\ldots,x_{\\mu})</span></li>

      <li><span class="math">\\mathbf{V}</span> checks that the degree of <span class="math">g_{1}(x_{1})</span> is at most the degree of <span class="math">f</span> in <span class="math">x_{1}</span>. It computes <span class="math">S_{1}=g_{1}(0)+g_{1}(1)</span> and checks that <span class="math">S_{1}=S</span>. If not, <span class="math">\\mathbf{V}</span> rejects. It then picks a random <span class="math">r_{1}\\in\\mathbb{F}</span> and sends it to the Prover (P).</li>

      <li>For each <span class="math">i</span> from 2 to <span class="math">\\mu</span> (subsequent rounds):</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends to <span class="math">\\mathbf{V}</span> the univariate polynomial <span class="math">g_{i}(x_{i})=\\sum_{\\{x_{i+1},\\ldots,x_{\\mu}\\}\\in\\{0,1\\}^{\\mu-1}}f(r_{1},\\ldots,r_{i-1},x_{i},\\ldots,x_{\\mu})</span></li>

      <li><span class="math">\\mathbf{V}</span> checks that the degree of <span class="math">g_{i}(x_{i})</span> is at most the degree of <span class="math">f</span> in <span class="math">x_{i}</span>. It computes <span class="math">S_{i}=g_{i}(0)+g_{i}(1)</span> and checks that <span class="math">S_{i}=g_{i-1}(r_{i-1})</span>. If not, <span class="math">\\mathbf{V}</span> rejects. It picks a random <span class="math">r_{i}\\in\\mathbb{F}</span> and sends it to <span class="math">\\mathbf{P}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> sends the value <span class="math">f(r_{1},r_{2},\\ldots,r_{\\mu-1},r_{\\mu})</span> for the random values <span class="math">r_{1},r_{2},\\ldots,r_{\\mu}</span> chosen by <span class="math">\\mathbf{V}</span>.</li>

      <li><span class="math">\\mathbf{V}</span> checks that this value is correct by querying the instance oracle <span class="math">\\llbracket f\\rrbracket</span> at <span class="math">(r_{1},r_{2},\\ldots,r_{\\mu-1},r_{\\mu})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This PIOP enjoys perfect completeness and a soundness error of $O(\\frac{d\\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. The verifier time is </span>O(d\\mu)<span class="math"> field operations, the query complexity is </span>1<span class="math">, the round complexity is </span>\\mu<span class="math">, and the number of field elements sent by the prover is </span>d\\mu<span class="math">. Additionally, if </span>f<span class="math"> is a sum of products of multilinear polynomials (i.e., our case), then the prover’s running time is </span>O(d\\log^{2}d\\cdot 2^{\\mu})$ field operations <em>[2]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-80" class="text-base font-semibold mt-4">Tool: multivariate PIOP for Zerocheck.</h5>

    <p class="text-gray-300">A PIOP for zerocheck asserts that the evaluations of a <span class="math">\\mu</span>-variate polynomial <span class="math">f\\in\\mathbb{K}</span> with maximum individual degree <span class="math">d:=\\deg^{*}(f)</span> over the Boolean hypercube are all zero, i.e. that <span class="math">f(\\mathbf{x})=0</span> for all <span class="math">\\mathbf{x}\\in\\{0,1\\}^{\\mu}</span>.</p>

    <p class="text-gray-300">[PIOP 3: Zerocheck]</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{P}(\\mathbf{x},\\mathbf{w}),\\mathbf{V}(\\mathbf{x})\\rangle</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> receives as input a polynomial <span class="math">f</span>, and <span class="math">\\mathbf{V}</span> has oracle access to the same.</li>

      <li><span class="math">\\mathbf{V}</span> sends <span class="math">\\mathbf{P}</span> a random vector <span class="math">\\mathbf{r}\\stackrel{{\\scriptstyle\\mathbf{S}}}{{\\leftarrow}}\\mathbb{F}^{\\mu}</span>.</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> invoke PIOP 2 for the claim that <span class="math">\\sum_{\\mathbf{x}\\in\\{0,1\\}^{\\mu}}f(\\mathbf{x})\\cdot\\mathrm{eq}(\\mathbf{x},\\mathbf{r})=0</span>.</li>

    </ol>

    <p class="text-gray-300">This PIOP has completeness, soundness, and efficiency properties similar to those of the sumcheck PIOP,</p>

    <p class="text-gray-300">PIOP for stacked rowcheck.</p>

    <p class="text-gray-300">We are now ready to define a PIOP for the stacked rowcheck relation. We define this relation first, and then construct a PIOP for it.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Definition 7.1.</h6>

    <p class="text-gray-300">Stacked rowcheck is the indexed oracle relation consisting all triples of the form</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})=((\\mathbb{F},\\mathbb{K},t,c,(L_{i},K_{i})_{i\\in[c]}),[\\![\\hat{\\boldsymbol{z}}]\\!],\\hat{\\boldsymbol{z}})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">\\mathbb{K}</span> is a <span class="math">m</span>-dimensional vector space of polynomials over <span class="math">\\mathbb{F}</span>, <span class="math">\\hat{\\boldsymbol{z}}:=[\\hat{z}_{i}]_{i=1}^{t}</span> is a list of polynomials in <span class="math">\\mathbb{K}</span>, <span class="math">[\\![\\hat{\\boldsymbol{z}}]\\!]:=[[\\![\\hat{z}_{i}]\\!]_{i=1}^{t}</span> are oracles to these polynomials, <span class="math">L_{i}</span> is a local predicate with arity <span class="math">t</span>, and <span class="math">K_{i}</span> is a subset of the boolean hypercube <span class="math">\\mathcal{B}_{\\nu}</span> where <span class="math">\\nu:=\\lceil\\log m\\rceil</span>, such that for all <span class="math">i\\in[c]</span> it holds that <span class="math">L_{i}(\\hat{\\boldsymbol{z}}_{i}(x))=0</span> for each <span class="math">x\\in K_{i}</span>.</p>

    <p class="text-gray-300">For concreteness we restrict our attention to the <em>polynomial</em> stacked rowcheck relation where the local predicates are constrained to be polynomials, but replacing this with a more general rowcheck relation is straightforward. Below we present a PIOP for polynomial stacked rowcheck and describe its security and efficiency properties in Lemma 7.2.</p>

    <p class="text-gray-300">[PIOP 4: Polynomial stacked rowcheck]Indexer <span class="math">\\mathbf{I}(\\mathfrak{i})\\to\\{S_{i}\\}_{i\\in[c]}</span>: Parse the polynomial stacked rowcheck index <span class="math">\\mathfrak{i}</span> as <span class="math">(\\mathbb{F},\\mathbb{K},t,c,(L_{i},K_{i})_{i\\in[c]})</span>. Set <span class="math">\\nu=\\log_{2}m</span>. For <span class="math">i\\in[c]</span>, build the selector polynomials <span class="math">S_{i}:\\mathbb{F}^{\\nu}\\to\\{0,1\\}</span> of degree <span class="math">m</span> as:</p>

    <p class="text-gray-300">\\[ S_{i}(h)=\\begin{cases}1&\\text{if }h\\in K_{i}\\\\ 0&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">Output the set of selector polynomials <span class="math">\\{S_{i}\\}_{i\\in[c]}</span>.</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{P}(\\mathbf{I}(\\mathfrak{i}),\\mathtt{x},\\mathtt{w}),\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})\\rangle</span>: The prover <span class="math">\\mathbf{P}</span> parses the polynomial stacked rowcheck instance <span class="math">\\mathtt{x}</span> as the oracles <span class="math">[\\![\\hat{\\boldsymbol{z}}]\\!]:=[\\hat{z}_{i}]_{i=1}^{t}</span> and witness <span class="math">\\mathtt{w}</span> as the polynomials <span class="math">\\hat{\\boldsymbol{z}}:=[[\\![\\hat{z}_{i}]\\!]_{i=1}^{t}</span>. <span class="math">\\mathbf{P}</span> builds the grand polynomial <span class="math">P:\\mathbb{F}^{\\nu}\\to\\mathbb{F}</span> as:</p>

    <p class="text-gray-300"><span class="math">P(\\mathbf{x})=\\sum_{i\\in[c]}S_{i}(\\mathbf{x})\\cdot L_{i}(\\hat{z}_{1}(\\mathbf{x}),\\ldots,\\hat{z}_{t}(\\mathbf{x}))</span></p>

    <p class="text-gray-300"><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> then invoke PIOP 3 for the claim <span class="math">P(\\mathbf{x})=0</span> on all <span class="math">\\mathbf{x}\\in\\mathcal{B}_{\\nu}</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 7.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we denote the maximum degree of local predicates as <span class="math">d</span>, the foregoing PIOP for polynomial stacked rowcheck has a soundness error of $O(\\frac{d\\log(m)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ and the following efficiency properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{time}(\\mathbf{I})=O(m)</span>.</li>

      <li><span class="math">\\mathrm{time}(\\mathbf{P})=O(md\\log^{2}d)</span>.</li>

      <li><span class="math">\\mathrm{time}(\\mathbf{V})=O(\\log m)</span>.</li>

      <li>query complexity is <span class="math">O(1)</span>.</li>

      <li>round complexity is <span class="math">O(\\log m)</span>.</li>

      <li>number of field elements sent by the prover is <span class="math">O(\\log m)</span>.</li>

    </ul>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">7.2 Unrolled SNARK</h3>

    <p class="text-gray-300">We describe the unrolled Garuda construction in Fig. 7. For a GR1CS index <span class="math">(\\mathbb{F},n,k,m,c,t,\\mathscr{C})</span> with <span class="math">k</span> variables, <span class="math">m</span> constraints, and <span class="math">n</span> instance variables, and letting <span class="math">\\eta:=</span> denote the total number of non-zer</p>

    <p class="text-gray-300">etries across the constraint matrices and <span class="math">d</span> denote the maximum degree of the local predicates, Garuda has the following efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>setup time is <span class="math">O(m+\\eta t)</span> <span class="math">\\mathbb{F}</span> operations and <span class="math">(m+t+c)</span> <span class="math">\\mathbb{G}_{1}</span> operations.</li>

      <li>prover time is <span class="math">O(m(t+d\\log^{2}d)+\\eta t)</span> <span class="math">\\mathbb{F}</span> operations, <span class="math">O(t)</span> vMSMs of size <span class="math">m</span> in <span class="math">\\mathbb{G}_{1}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- verifier time is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+t\\log(\\eta))<span class="math"> </span>\\mathbb{F}<span class="math"> operations, and </span>O(t+\\log(m))$ pairings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>verification key size is <span class="math">O(c)</span> <span class="math">\\mathbb{G}_{1}</span> elements and <span class="math">O(t+\\log m)</span> <span class="math">\\mathbb{G}_{2}</span> elements.</li>

      <li>proving key size is <span class="math">m+c+k</span> <span class="math">\\mathbb{G}_{1}</span> elements.</li>

      <li>proof size is <span class="math">O(t+\\log(m))</span> <span class="math">\\mathbb{G}_{1}</span> elements and <span class="math">O(t+d\\cdot\\log(m))</span> <span class="math">\\mathbb{F}</span> elements.</li>

    </ul>

    <p class="text-gray-300">To obtain these efficiency numbers, we apply the following optimizations to the generic construction in Fig. 5.</p>

    <h5 id="sec-84" class="text-base font-semibold mt-4">Stacked GR1CS.</h5>

    <p class="text-gray-300">As discussed in Section 7.1, we reduce the number of oracles sent by the prover by stacking the matrices of different predicates on top of each other. This reduces the number of oracles sent by the prover from <span class="math">ct</span> to <span class="math">t</span>. This optimization is crucial for reducing the proof size and the prover time complexity.</p>

    <h5 id="sec-85" class="text-base font-semibold mt-4">Batch opening.</h5>

    <p class="text-gray-300">Garuda requires the prover to open multiple polynomials at a single point. To reduce prover cost and proof size we use standard batch opening techniques <em>[x10]</em> to provide a single evaluation proof for all these evaluation claims. Overall, this reduces the prover work by <span class="math">t-1</span> <span class="math">n</span>-sized MSMs, and shrinks the proof size by <span class="math">t-1</span> group elements.</p>

    <h5 id="sec-86" class="text-base font-semibold mt-4">Specializing for a single local predicate.</h5>

    <p class="text-gray-300">In the case where there is only a single local predicate (e.g., in R1CS), there is no need for stacking and using selector polynomials. This reduces proof size and (slightly) improves prover time complexity.</p>

    <p class="text-gray-300">|  Generator G(1λ, i) → (ipk, ivk):  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1. Parse the index i as (F, n, k, m, c, t, [Li, (Mi,1, ..., Mi,t), mi]i=1), and set ν := [log m].  |</p>

    <p class="text-gray-300">|  2. Construct the 'succinct' index i_s := (F, n, k, m, c, t, [Li, (Mi,1, ..., Mi,t), mi]i=1) where M_i,j only has the first n columns of M_i,j.  |</p>

    <p class="text-gray-300">|  3. Sample a bilinear group ⟨group⟩ = (G1, G2, G_T, G, H, e) ← SampleGrp(1^λ).  |</p>

    <p class="text-gray-300">|  4. Sample uniformly random field elements τ ← F^ν and α1, ..., αt ← F. Set ivk_α := (α1H, ..., αtH).  |</p>

    <p class="text-gray-300">|  5. Construct the unconstrained commitment key: ck_t := [χi(τ)]i=1^m.  |</p>

    <p class="text-gray-300">|  6. For each i ∈ [t], construct the stacked matrix M_i<em>, and extend its columns over B_ν to obtain basis polynomials M_i</em> = [m_i,j(X)]j∈[k].  |</p>

    <p class="text-gray-300">|  7. Construct the consistency commitment key ck_c := [(∑i=1^t αi m_i,j(τ))G]i=1^k.  |</p>

    <p class="text-gray-300">|  8. Construct the consistency verification key vk_c := [(∑i=1^t αi m_i,j(τ))G]i=1^n.  |</p>

    <p class="text-gray-300">|  9. Compute the selector polynomials ipk_s := [Si(X)]i=1^c as in PIOP 4, and commit to them: ivk_s := [Si(τ)G]i=1^c.  |</p>

    <p class="text-gray-300">|  10. Set ipk = (i, ⟨group⟩, ck_c, ck_t, ipk_s) and ivk = (i_s, ⟨group⟩, ivk_α, ivk_s, vk_c), and output the keys (ipk, ivk).  |</p>

    <p class="text-gray-300">|  Prover P^ρ(ipk, x, w) → π:  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Parse ipk as (i, ⟨group⟩, ck_c, ck_t, ipk_s), the instance x as x, the witness w as w, and define z := (x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2. Parse the GR1CS index as i = (F, n, k, m, c, t, [Li, (Mi,1, ..., Mi,t), mi]i=1^c).  |</p>

    <p class="text-gray-300">|  3. For each i ∈ [t],  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Construct the vectors zi := M_i<em>z and wi := M_i</em>(0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w), and their MLEs over B_ν: z_i(X) and w_i(X).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (b) Commit to w_i(X): cw,i := w_i(τ) · G.  |</p>

    <p class="text-gray-300">|  4. Compute the consistency commitment c_c := ∑i=1k-n w[i]·ck_c[i] and assemble the commitments c_w := [cw,i]i=1^t.  |</p>

    <p class="text-gray-300">|  5. Simulate the prover-verifier interaction for PIOP 3 for the polynomial P := ∑i=1c Si · Li(z_1, ..., z_t). Namely, in the i-th round of the PIOP where i ∈ [ν]:  |</p>

    <p class="text-gray-300">|  (a) Compute the next prover message and state: (pi, st_i+1) ← Pi(st_i, [ρ_i]i=1^t).  |</p>

    <p class="text-gray-300">|  (b) Sample a random field element from the random oracle ρ_i := ρ(transcript).  |</p>

    <p class="text-gray-300">|  6. Form the set of PIOP prover messages π_p := [pi]i=1^v.  |</p>

    <p class="text-gray-300">|  7. Compute the evaluations v := [w_i(ρ)]i=1^t ∪ [Si(ρ)]i=1^c.  |</p>

    <p class="text-gray-300">|  8. Sample linear combination coefficients ζ_1, ..., ζ_t+c := ρ(transcript), and use these to obtain the linearly combined polynomial B(X) := ∑i=1c ζ_iSi(X) + ∑i=0t ζ_i+c w_i(X).  |</p>

    <p class="text-gray-300">|  9. Compute the PST opening proof for B: π_α := [W_i(τ)G]i∈[ν], where the polynomials W_i are given by the equation B(X) - B(ρ) = ∑i∈[ν] (X[i] - ρ[i]) · W_i(X).  |</p>

    <p class="text-gray-300">|  10. Output the proof π := (cw, c_c, π_p, v, π_α)  |</p>

    <p class="text-gray-300">|  Verifier V^ρ(ivk, x, π) → {0,1}:  |</p>

    <p class="text-gray-300">|  1. Parse ivk as (i_s, ⟨group⟩, ivk_α, ivk_s, vk_c), and i_s as (F, n, k, m, c, t, [Li, (Mi,1, ..., Mi,t), mi]i=1^c).  |</p>

    <p class="text-gray-300">|  2. Parse the instance x as x and the proof π as (cw, c_c, π_p, v, π_α).  |</p>

    <p class="text-gray-300">|  3. Simulate the prover-verifier interaction for PIOP 3 for the polynomial P := ∑i=1c Si · Li(z_1, ..., z_t). Namely, in the i-th PIOP round where i ∈ [ν]:  |</p>

    <p class="text-gray-300">|  (a) Obtain the prover's next message from π_p, and add it to the transcript.  |</p>

    <p class="text-gray-300">|  (b) Sample a random field element from the random oracle: ρ_i := ρ(transcript).  |</p>

    <p class="text-gray-300">|  4. For each i ∈ [t]: compute the vector xi := M_i*x and the evaluation of its MLE: z_i(ρ) := w_i(ρ) + x_M_i(ρ).  |</p>

    <p class="text-gray-300">|  5. For the last round of the PIOP, provide v and [z_i(ρ)]i=1^t to the PIOP verifier V and check the PIOP decision.  |</p>

    <p class="text-gray-300">|  6. Check that the equifficient constraint is satisfied: (c_c, H) = ∑i=1t e(c_w[i], ivk_α[i])  |</p>

    <p class="text-gray-300">|  7. Sample coefficients ζ_1, ..., ζ_t+c := ρ(transcript), and use these to obtain a commitment c_B to B(X), and the evaluation v_B of B at ρ by linearly combining the commitments to, and evaluations of, Si and w_i.  |</p>

    <p class="text-gray-300">|  8. Check the evaluation proof for B: e(c_B - v_B G, H) = ∏i∈[ν] e(π_α[i], τ_iH - ρ[i] · H)  |</p>

    <p class="text-gray-300">Figure 7: The unrolled GARUDA SNARK.</p>

    <p class="text-gray-300">We thank Howard Wu and Jules de Smit for helpful discussions, and Victor Sint Nicolaas and Mary Maller for their help with the early stages of this work.</p>

    <h2 id="sec-87" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[arkworks] arkworks contributors. <em>arkworks zkSNARK ecosystem</em>. 2022. URL: https://arkworks.rs.</li>

      <li>[BB04] D. Boneh and X. Boyen. “Short Signatures Without Random Oracles”. In: EUROCRYPT ’04.</li>

      <li>[BCGGRS19] E. Ben-Sasson, A. Chiesa, L. Goldberg, T. Gur, M. Riabzev, and N. Spooner. “Linear-Size Constant-Query IOPs for Delegating Computation”. In: TCC ’19.</li>

      <li>[BCIOP13] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. “Succinct Non-Interactive Arguments via Linear Interactive Proofs”. In: TCC ’13.</li>

      <li>[BCRSVW19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: EUROCRYPT ’19.</li>

      <li>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. “Scalable Zero Knowledge via Cycles of Elliptic Curves”. In: CRYPTO ’14.</li>

      <li>[BFS20] B. Bünz, B. Fisch, and A. Szepieniec. “Transparent SNARKs from DARK Compilers”. In: EUROCRYPT ’20.</li>

      <li>[BIOW20] O. Barta, Y. Ishai, R. Ostrovsky, and D. J. Wu. “On Succinct Arguments and Witness Encryption from Groups”. In: CRYPTO ’20.</li>

      <li>[BISW17] D. Boneh, Y. Ishai, A. Sahai, and D. J. Wu. “Lattice-Based SNARGs and Their Application to More Efficient Obfuscation”. In: EUROCRYPT ’17.</li>

      <li>[BISW18] D. Boneh, Y. Ishai, A. Sahai, and D. J. Wu. “Quasi-Optimal SNARGs via Linear Multi-Prover Interactive Proofs”. In: EUROCRYPT ’18.</li>

      <li>[CBBZ23] B. Chen, B. Bünz, D. Boneh, and Z. Zhang. “HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates”. In: EUROCRYPT ’23.</li>

      <li>[CFQ19] M. Campanelli, D. Fiore, and A. Querol. “LegoSNARK: Modular Design and Composition of Succinct Zero-Knowledge Proofs”. In: CCS ’19.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: EUROCRYPT ’20.</li>

      <li>[DPSZ12] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. “Multiparty Computation from Somewhat Homomorphic Encryption”. In: CRYPTO ’12.</li>

      <li>[EG20] Y. El Housni and A. Guillevic. “Optimized and Secure Pairing-Friendly Elliptic Curves Suitable for One Layer Proof Composition”. In: CANS ’20.</li>

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. “The Algebraic Group Model and its Applications”. In: CRYPTO ’18.</li>

      <li>[FS86] A. Fiat and A. Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: CRYPTO ’86.</li>

      <li>[Gen09] C. Gentry. “Fully Homomorphic Encryption Using Ideal Lattices”. In: STOC ’09.</li>

      <li>[GGPR13] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: EUROCRYPT ’13.</li>

      <li>[GM17] J. Groth and M. Maller. “Snarky Signatures: Minimal Signatures of Knowledge from Simulation-Extractable SNARKs”. In: CRYPTO ’17.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Gro10] J. Groth. “Short Pairing-Based Non-interactive Zero-Knowledge Arguments”. In: ASIACRYPT ’10.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: EUROCRYPT ’16.</li>

      <li>[GW19] A. Gabizon and Z. J. Williamson. “The Turbo-Plonk Program Syntax for Specifying Snark Programs”. In: ZKProof Workshop 3.</li>

      <li>[GW20] A. Gabizon and Z. J. Williamson. “plookup: A simplified polynomial protocol for lookup tables”. Cryptology ePrint Archive, Report 2020/315.</li>

      <li>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. “PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge”. Cryptology ePrint Archive, Report 2019/953.</li>

      <li>[KS08] V. Kolesnikov and T. Schneider. “Improved Garbled Circuit: Free XOR Gates and Applications”. In: ICALP ’08.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: ASIACRYPT ’10.</li>

      <li>[LFKN92] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</li>

      <li>[Lip24] H. Lipmaa. “Polymath: Groth16 Is Not The Limit”. In: CRYPTO ’24.</li>

      <li>[LPS23] H. Lipmaa, R. Parisella, and J. Siim. “Algebraic Group Model with Oblivious Sampling”. In: TCC ’23.</li>

      <li>[Nit19] A. Nitulescu. “Lattice-Based Zero-Knowledge SNARGs for Arithmetic Circuits”. In: LATINCRYPT ’19.</li>

      <li>[Ped92] T. P. Pedersen. “Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing”. In: CRYPTO ’91.</li>

      <li>[PFMBM22] L. Pearson, J. Fitzgerald, H. Masip, M. Bellés-Muñoz, and J. L. Muñoz-Tapia. “PlonKup: Reconciling PlonK with plookup”. Cryptology ePrint Archive, Report 2022/086.</li>

      <li>[PST13] C. Papamanthou, E. Shi, and R. Tamassia. “Signatures of Correct Computation”. In: TCC ’13.</li>

      <li>[SAD20] A. Szepieniec, T. Ashur, and S. Dhooghe. “Rescue-Prime: a Standard Specification (SoK)”. Cryptology ePrint Archive, Report 2020/1143.</li>

      <li>[Sch80] J. T. Schwartz. “Fast Probabilistic Algorithms for Verification of Polynomial Identities”. In: Journal of the ACM 27.4 (1980), pp. 701–717.</li>

      <li>[Set20] S. Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: CRYPTO ’20.</li>

      <li>[STW23] S. Setty, J. Thaler, and R. Wahby. “Customizable constraint systems for succinct arguments”. Cryptology ePrint Archive, Report 2023/552.</li>

      <li>[XCZBFKC23] A. L. Xiong, B. Chen, Z. Zhang, B. Bünz, B. Fisch, F. Krell, and P. Camacho. “VeriZexe: Decentralized Private Computation with Universal Setup”. In: USENIX Security ’23.</li>

      <li>[Zip79] R. Zippel. “Probabilistic algorithms for sparse polynomials”. In: EUROSAM ’79.</li>

    </ul>`;
---

<BaseLayout title="Garuda and Pari: Faster and Smaller SNARKs via Equifficient ... (2024/1245)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1245
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
