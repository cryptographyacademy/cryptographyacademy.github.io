---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1318';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Poppins: A Direct Construction for Asymptotically Optimal zkSNARKs';
const AUTHORS_HTML = 'Abhiram Kothapalli, Elisaweta Masserova, Bryan Parno';

const CONTENT = `    <p class="text-gray-300">Abhiram Kothapalli <span class="math">^{1}</span>, Elisaweta Masserova <span class="math">^{2}</span>, and Bryan Parno <span class="math">^{3}</span></p>

    <p class="text-gray-300">Carnegie Mellon University</p>

    <p class="text-gray-300">Abstract. We present POPPINS, a direct construction of a zero-knowledge argument system for general computation that features an <span class="math">O_{\\lambda}(n)</span> time prover and an <span class="math">O_{\\lambda}(1)</span> time verifier (after a single <span class="math">O_{\\lambda}(n)</span> public setup) for computations of size <span class="math">n</span>. Our scheme utilizes a universal linear-size structured reference string (SRS) that allows a single trusted setup to be used across all computation instances of a bounded size. Concretely, for computations of size <span class="math">n</span>, our prover's cost is dominated by 35 multi-exponentiations of size <span class="math">n</span> and our verifier's cost is dominated by 34 pairings. To achieve the stated asymptotics, we first construct a nearly-optimal zkSNARK with a logarithmic verifier in the random oracle model. We then show how to achieve a constant-time verifier using (single-layer) proof composition. Along the way we design (1) a new polynomial commitment scheme for evaluation-based representations of polynomials, (2) an asymptotically optimal inner-product argument system, (3) an asymptotically optimal multi-Hadamard-product argument system, and (4) a new constraint system for NP that is particularly well-suited for our bundle of techniques.</p>

    <p class="text-gray-300">Verifiable computation [39] allows a weak client to outsource a computation and efficiently verify that the returned result is correct. Many recent verifiable computation schemes provide an orthogonal zero-knowledge guarantee, in which the server running the computation can provide a private input to the computation, and still prove correct execution without revealing any information about the input. Such powerful integrity and privacy guarantees have enabled an exciting class of applications, including anonymous credentials [34], verifiable storage outsourcing [4], blockchain applications [52,60], verifiable database operation [71], and voting [72].</p>

    <p class="text-gray-300">As shown by Goldwasser et al. [43], this class of interaction can be modeled as a zero-knowledge argument system. A zero-knowledge argument system is an interactive protocol in which a prover proves a "computational statement" (e.g. "Program <span class="math">P</span> outputs <span class="math">y</span>, on public input <span class="math">x</span> and secret input <span class="math">s</span>") to a verifier. Many</p>

    <p class="text-gray-300">1 akothapa@andrew.cmu.edu 2 elisawem@andrew.cmu.edu 3 parno@cmu.edu</p>

    <p class="text-gray-300">classical results address how to model and realize such an interaction <em>[3, 5, 7]</em>. These results however are not designed to be practical for the majority of interesting applications, which demand good concrete costs in addition to a sub-linear verifier with respect to the size of the original statement (succinctness) and non-interactivity. Modern performance-oriented argument systems that target these requirements and support a broad class of computational statements (such as NP) are typically dubbed <em>zero-knowledge succinct non-interactive arguments of knowledge</em> (zkSNARK) <em>[14]</em>. Generally these sorts of argument systems are achieved by putting together the following pieces: (1) a constraint system to represent computational statements as low-level algebraic constraints, (2) mathematical representations (e.g. polynomials) to encode constraints and purported satisfying assignments, (3) efficient algebraic tests (e.g. polynomial equality testing) to check that the encoded assignment satisfies the prescribed algebraic constraints, and (4) cryptographic machinery to prove in zero-knowledge that the prescribed algebraic tests are satisfied.</p>

    <p class="text-gray-300">Many performance-oriented zero-knowledge argument systems have proposed various bundles of techniques to address each of the listed pieces <em>[2, 23, 28, 58, 62, 68]</em>. However, all proposals make some combination of the following undesirable compromises: (1) a per-circuit trusted setup (which is especially problematic in settings such as the blockchain where there is no clear authority); (2) a super-linear prover and/or a (super)-logarithmic verifier which hurts practical efficiency and may defeat the purpose of outsourcing computation; (3) a restricted class of computations (such as circuits with repeated structure).</p>

    <p class="text-gray-300">In contrast, our system makes none of these compromises — Instead, by developing new techniques and extending techniques from several previous strands of work, we achieve an efficient zkSNARK for general computation.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">We present Poppins, a time-optimal zkSNARK for general computation that features an <span class="math">O_{\\lambda}(n)</span> time prover and an <span class="math">O_{\\lambda}(1)</span> verifier (after a single <span class="math">O_{\\lambda}(n)</span> public setup) for computations of size <span class="math">n</span>. As Lee et al. <em>[53]</em> and Bootle et al. <em>[20]</em> point out, the precise definition of “time-optimal” can vary. We adopt convention, and measure runtime in terms of the number of field and group operations performed <em>[23, 28, 58, 62]</em>. As such, we ensure that the prover performs a linear number of field/group operations, and that the verifier performs a constant number of field/group operations with respect to computation size <span class="math">n</span>. We show how our asymptotics compare to other popular zkSNARK systems in table 1.</p>

    <p class="text-gray-300">Our argument system utilizes a <em>universal</em> linear-size structured reference string (SRS) (i.e., a single trusted setup can be used across all computation instances of a bounded size). In terms of concrete costs, our prover is roughly <span class="math">2-3\\times</span> more expensive than existing universal zkSNARKs such as Spartan <em>[62]</em>, Marlin <em>[28]</em>, and Plonk <em>[38]</em>. In the algebraic group model <em>[37]</em>, for computations of size <span class="math">n</span>, the prover’s cost is dominated by 35 multi-exponentiations of size <span class="math">n</span>, the verifier’s cost is dominated by 34 pairings, and the total communication cost is estimated to be 93 group elements.</p>

    <p class="text-gray-300">Our core argument is constructed by modifying argument systems for linear algebraic statements (e.g., inner-product, Hadamard-product, polynomial evaluation) to match our desired asymptotics before composing them to create a argument system for general computation. In particular, existing argument systems typically feature either a non-constant-time verifier or a super-linear prover. To achieve a linear-time prover, we design new techniques to avoid super-linear operations (such as polynomial interpolation). Later, to achieve a constant-time verifier, we outsource the verifier’s non-constant-time work using a generic argument system. We give a high level overview of our core contributions leading to an argument system with optimal asymptotics:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Polynomial Commitments for Evaluation-Based Representations:</em> A polynomial commitment scheme allows a prover to commit to a polynomial and later verifiably evaluate it at a challenge point. We propose a new polynomial commitment scheme based on that of Zhang et al. <em>[71]</em> specifically tailored for evaluation-based representations of polynomials. This allows us to avoid expensive interpolation operations typically found in argument systems that rely on polynomial-based representations.</li>

      <li><em>Extended Inner-Product Argument:</em> An inner-product argument allows a prover to commit to two vectors and later verifiably evaluate their inner-product. We extend the inner-product argument presented by Bünz et al. <em>[26]</em> to operate over commitments to evaluation-based representations of polynomials. Additionally, we modify this argument system to support zero-knowledge.</li>

      <li><em>Asymptotically Optimal Multi-Hadamard-Product Argument:</em> A multi-Hadamard-product argument allows a prover to commit to a list of vectors and later verifiably evaluate the Hadamard product of these vectors. Bayer <em>[6]</em> presents a multi-Hadamard argument that features a linear-time prover and verifier. We show how to compose Bayer’s argument with our modified inner-product argument to achieve a constant-time verifier.</li>

      <li><em>A New Constraint System to Characterize <span class="math">\\mathsf{NP}</span>:</em> We design a new constraint system to capture <span class="math">\\mathsf{NP}</span> that allows us to piece together the previous argument systems in a novel way. We refer to the relation defining our constraint system as <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span>. We show how to encode <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> statements into polynomial representations that can be checked using the techniques described above.</li>

    </ol>

    <p class="text-gray-300">Putting together the listed pieces, we achieve a public-coin argument with a logarithmic number of rounds in the standard model using just a structured reference string. This argument can be made non-interactive with a logarithmic-time verifier in the random oracle model. To outsource the verifier’s non-constant-time work, we must heuristically instantiate the random oracle with a cryptographic hash function before representing the verifier’s checks as a circuit <em>[12, 21, 29, 30, 53]</em>. Part of the difficulty of outsourcing in our setting is that we must ensure that the outsourced circuit is small enough to preserve a concretely efficient prover. We carefully construct our suite of techniques to ensure that the verifier only has to outsource a small portion of its checks.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Model</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zkSTARK [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n polylog n</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">uniform circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ligero [2]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aurora [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax [68]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">d(g + c log c) + w</td>

            <td class="px-3 py-2 border-b border-gray-700">d log g + √w</td>

            <td class="px-3 py-2 border-b border-gray-700">√n</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Virgo [70]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n + n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">d log n + log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">d log n + log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">uniform circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SpartanSGRT [62]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">√n</td>

            <td class="px-3 py-2 border-b border-gray-700">√n</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">public</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonk [38]</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperSonic [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin [28]</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Libra [69]</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">d log n</td>

            <td class="px-3 py-2 border-b border-gray-700">d log n</td>

            <td class="px-3 py-2 border-b border-gray-700">uniform circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SpartanKZG [62]</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log2n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GGPR-based [58]</td>

            <td class="px-3 py-2 border-b border-gray-700">private</td>

            <td class="px-3 py-2 border-b border-gray-700">n log n</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">arithmetic circuits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PoppinsRO</td>

            <td class="px-3 py-2 border-b border-gray-700">private**</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">RACS</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poppins</td>

            <td class="px-3 py-2 border-b border-gray-700">private*</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">RACS</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Asymptotic costs of various zero-knowledge proof systems in terms of field and group operations.  <span class="math">n</span>  denotes the number of constraints.  <span class="math">d</span>  denotes the circuit depth.  <span class="math">x</span>  denotes the size of the circuit inputs and outputs.  <span class="math">w</span>  denotes the size of the provers private input.  <span class="math">c</span>  denotes the number of repeating identical subcircuits.  <span class="math">g</span>  denotes the width of the circuit. private* denotes a universal setup. private** denotes a universal and updatable trusted setup. R1CS is an algebraic constraint system based on Quadratic Arithmetic Programs [40]. We note that the total number of constraints can vary based on computational model.  <span class="math">\\mathrm{POPPINS}_{\\mathrm{RO}}</span>  represents our argument system before instantiating the random oracle.</p>

    <p class="text-gray-300">zkSNARKs for a Limited Class of Computation: In an effort to create practical systems, Goldwasser et al. [42] describe an interactive argument system (over layered arithmetic circuits), which consists of proving statements about each layer of the circuit using the sum-check protocol proposed by Lund et al. [55]. Following works [31, 66, 68] refines this approach by considering uniform circuits (i.e., descriptions of the circuit are asymptotically smaller than the circuit itself). Recent works additionally achieve zero-knowledge [68], and an asymptotically linear prover [69, 70]. Unfortunately, systems in this line rely on layered, uniform circuits, in order to achieve a logarithmic verifier, limiting the class of computations which can be efficiently encoded.</p>

    <p class="text-gray-300">zkSNARKs with a Trusted Setup: In a parallel vein, Gennaro et al. [40] achieve a constant-time verifier and a nearly linear prover for general computations by making use of a per-instance trusted setup. Core to their work is a new constraint system, Quadratic Arithmetic Programs, which inspires the constraint system designed in this work. Parno et al. optimize Gennaro et al.'s [40] protocol to produce a highly optimized implementation, Pinocchio [58]. A large line of work optimizes Pinocchio in various settings [32, 33, 36, 47, 60]. Systems in this line require a per-circuit structured reference string (SRS) generated privately by a trusted party, which can be problematic in practice [60]. Additionally, for computations of size  <span class="math">n</span> , these systems require  <span class="math">O_{\\lambda}(n\\log n)</span>  field operations which adds a non-trivial overhead in practice [58].</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Efforts To Remove a Trusted Setup:</h5>

    <p class="text-gray-300">Practical issues with private setup procedures have caused a recent surge in argument systems without a trusted setup, (i.e. <em>transparent</em> zkSNARKs). Using only the discrete logarithm assumption, Groth <em>[46]</em> proposes an argument system for statements in <span class="math">\\mathsf{NP}</span>, by combining zero-knowledge argument systems for linear-algebraic operations such as matrix product, Hadamard product, and inner-product. This system is implemented by Bootle et al. <em>[19]</em> and later refined by Bünz et al. <em>[23]</em>. Systems in this line require the verifier perform linear work in the size of the original computation making them useful only for their zero-knowledge properties, not for outsourcing.</p>

    <p class="text-gray-300">Aurora <em>[10]</em> and zkSTARKs <em>[8]</em> achieve a transparent setup by building upon a line of work initiated by Ben-Sasson et al. <em>[11]</em>. The soundness for both of these systems relies on non-standard assumptions related to Reed-Solomon Codes. Unfortunately, both Aurora and zkSTARKs also feature a linear verifier and a <em>nearly</em> linear prover. zkSTARKs achieves a polylogarithmic verifier when considering uniform circuits, but relies on a computational model which can add significant overhead in practice <em>[67]</em>.</p>

    <p class="text-gray-300">Ishai et al. construct transparent zero-knowledge argument systems using secure multi-party computation as a fundamental building block <em>[50]</em>. Several works refine this approach <em>[27, 41]</em>; however all of these works feature a linear-time verifier. Ames et al. <em>[2]</em> show how to achieve a sublinear verifier by amortizing over multiple instances of the same verification circuit.</p>

    <p class="text-gray-300">Recently, Setty proposed Spartan <em>[62]</em>, the first direct construction for a transparent zkSNARK with sublinear verifier without any assumptions about the circuit structure. In more detail, Spartan reduces matrix encodings of arithmetic circuits to a sum-check instance over sparse multivariate polynomials which are verifiably evaluated in zero-knowledge by using the argument system proposed by Wahby et al <em>[68]</em>. Unfortunately for computations of size <span class="math">n</span>, Spartan’s verifier still runs in time <span class="math">O_{\\lambda}(\\sqrt{n})</span>.</p>

    <h5 id="sec-6" class="text-base font-semibold mt-4">Universal Trusted Setups as an Alternate Solution:</h5>

    <p class="text-gray-300">The preceding discussion of transparent zkSNARKs indicates that it is unclear how to achieve an asymptotically optimal verifier without the use of a trusted setup. Two recent works, Sonic <em>[56]</em> and Marlin <em>[28]</em>, take a middle-ground approach and study the setting where a private trusted setup is performed <em>only once</em>, and the resulting SRS can be reused across all circuits that respect a certain size bound (i.e., a <em>universal</em> trusted setup). For computations of size <span class="math">n</span>, Sonic achieves an <span class="math">O_{\\lambda}(n\\log n)</span> prover and a constant time verifier, and Marlin achieves an <span class="math">O_{\\lambda}(n\\log n)</span> prover and an <span class="math">O_{\\lambda}(\\log n)</span> verifier (although Marlin is considerably cheaper in practice). Another recent work, Plonk, achieves the same asymptotics as Sonic, but with significantly better concrete costs by utilizing an improved permutation argument <em>[38]</em>. Setty describes a variant of Spartan that utilizes a universal trusted setup to achieve an <span class="math">O_{\\lambda}(\\log^{2}n)</span> verifier. Encouraged by these results, we also adopt this setting in our work.</p>

    <h5 id="sec-7" class="text-base font-semibold mt-4">Optimal Asymptotics via Recursive Composition:</h5>

    <p class="text-gray-300">A zkSNARK supports <em>recursive composition</em> if the verifier’s execution can be expressed as another com</p>

    <p class="text-gray-300">putation instance to be proved, thus allowing the prover to write proofs about proofs. Valiant [65] shows how to take any succinct argument system that supports recursive composition and achieve a linear time prover and a (practically) constant-time verifier. Roughly, Valiant's prover breaks down a large circuit into many small circuits and writes a proof of correct execution for each before "folding" all of these proofs into a single (constant-sized) proof using a tree-like structure. Both Bitansky et al. [15] and Ben-Sasson et al. [12] refine this transformation. Bitansky et al.'s transformation can be applied to two recent recursive proof systems, Halo [21] and Fractal [29] (and following generalizations [18, 24]) to achieve time-optimal zkSNARKs. Unfortunately, recursive composition applied in this manner incurs quite expensive overheads in practice. In contrast, our work achieves an optimal zkSNARK with significantly reduced overhead via a direct construction.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Overview of the techniques involved to construct our argument system for general computation. We achieve concrete optimizations by batching and instantiating in the Algebraic Group Model [37]. More details are provided in supplementary section F.</p>

    <p class="text-gray-300">The  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span>  Constraint System: We start by designing a novel linear algebraic constraint system,  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span> , that, unlike previous constraint systems, is carefully designed to only utilize asymptotically optimal argument systems. Formally,  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span>  is modeled as a relation that consists of a public statement (represented as matrices) and a private witness (represented as a vector). In an argument system for  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span> , the prover shows — in zero-knowledge — that it knows a witness that satisfies the constraints encoded in the statement. We show how to encode both the statement and witness of an  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span>  instance as polynomials (as part of a single linear-time public setup). To check that the prover's witness polynomial satisfies the given statement polynomials with respect to relation  <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span> , the verifier is tasked with checking that evaluations of a witness-dependent polynomial over a specified set of points sum to 0.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Argument System Overview:</h4>

    <p class="text-gray-300">The prior check can be viewed as a sum-check instance <em>[55]</em>, and indeed several recent systems have tackled similiar checks using a generic sum-check protocol <em>[68, 28, 62]</em>. However existing sum-check protocols do not meet our desired asymptotic goals: They either induce a super-linear prover <em>[28]</em> or a non-constant verifier <em>[69]</em>.</p>

    <p class="text-gray-300">In contrast, <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> is designed to avoid sumcheck protocols: We show how the task of checking an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance can be reduced to the task of checking (1) polynomial equality and (2) a <em>specialized</em> sum of the following form:</p>

    <p class="text-gray-300"><span class="math">\\sigma=\\sum_{h\\in H}A(h)\\cdot B(h)</span> (1)</p>

    <p class="text-gray-300">for some predefined set of points <span class="math">H</span>, claimed sum <span class="math">\\sigma</span>, and polynomials <span class="math">A(X)</span>, and <span class="math">B(X)</span>. Here we make a novel observation that the right-hand side of Equation 1 can be evaluated by taking an inner-product over evaluation representations of polynomials <span class="math">A</span> and <span class="math">B</span>, thus avoiding sumchecks entirely. This realization motivates us to represent polynomials using their <em>evaluation-based</em> representation rather than a coefficient-based representation.</p>

    <p class="text-gray-300">Thus, the verifier can efficiently check Equation 1 by using an argument system for inner-product (Construction 4). Unfortunately, the fastest existing inner-product argument <em>[26]</em> still features a logarithmic-time verifier, which seems to indicate that we’ve gained no advantage over sumcheck protocols. However, we show that the inner-product verifier is particularly well-suited to cheaply out-source its logarithmic work using (single-layer) proof composition.</p>

    <p class="text-gray-300">As for the polynomial equality check, we show how the verifier can reduce this task to another another (simpler) sum-check instance using the Schwartz-Zippel Lemma <em>[61]</em>. The verifier repeats this interaction over several rounds to reduce the original statement to checking the Hadamard-product over vectors generated during the interaction. Thus, in the final round, the verifier engages in an Hadamard-product argument over multiple vectors, which in turn relies on another inner-product argument (Construction 5). We summarize the key components of our construction in Figure 1.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Utilizing Polynomial Commitments:</h4>

    <p class="text-gray-300">We note that we cannot achieve a sublinear verifier if the prover directly sends the aforementioned polynomials, which are linear in the size of the <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance. Instead the prover sends commitments to these polynomials (Construction 1), and later engages in arguments regarding these commitments to convince the verifier that its checks would pass (a technique popularized by several recent works <em>[70, 71, 28, 68, 62]</em>). Traditionally polynomial commitments, as defined by Kate et al. <em>[51]</em>, refer to both the scheme to commit to a vector representing a polynomial and the argument system to evaluate polynomials “under” these commitments. However, in our setting we utilize the same commitment value in multiple contexts: Specifically we treat such commitments as vector commitments when involved in inner product arguments, and as polynomial commitments when involved in polynomial-evaluation arguments. To maintain a cleaner presentation we separate the schemes to com</p>

    <p class="text-gray-300">mit to a vector representing a polynomial (Construction 1) and the argument system to evaluate committed polynomials (Construction 2).</p>

    <p class="text-gray-300">Throughout the argument, the prover is required to evaluate polynomials (represented as vectors of evaluations) “under” its commitments at challenge points. Our polynomial-evaluation argument modifies that of Zhang et al. <em>[71]</em> which in turn is based on the scheme by Papamanthou et al. <em>[57]</em>, both of which achieve an <span class="math">O_{\\lambda}(n)</span> prover and an <span class="math">O_{\\lambda}(1)</span> verifier for degree <span class="math">n</span> univariate polynomials represented as coefficients. In order to efficiently evaluate univariate polynomials based on their evaluation representations, we design a structured key which utilizes the Lagrange basis (Definition 7).</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Instantiating the Random Oracle:</h5>

    <p class="text-gray-300">We prove our arguments for polynomial evaluation, inner-product, and multi-Hadamard product in the random oracle model. As a result, we achieve an argument for <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> with a logarithmic-time verifier in the random oracle model. In order to achieve a constant-time verifier, we outsource the verifier’s logarithmic work using <em>another</em> general-purpose argument system. Because it is impossible to prove relativized statements (i.e. statements about circuits that query random oracles), we must heuristically instantiate the random oracle with a cryptographic hash function, thus leaving the random oracle model. We stress that this instantiation step is taken by all existing systems that utilize any form of proof composition starting with Valiant’s incremental verifiable computation <em>[65]</em> and following generalizations <em>[12, 15, 30]</em>. Several recent general proof systems must also instantiate the random oracle in this fashion <em>[21, 29, 53]</em>.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Preserving a Universal/Updatable SRS and Non-Interactivity:</h5>

    <p class="text-gray-300">Several of the listed techniques require a structured reference string to be generated during a trusted setup phase. We ensure that these setup procedures are not instance dependent, which allows the overall argument system to maintain a universal SRS. Groth et al. <em>[49]</em> show that an SRS defined over the monomial basis is updatable, implying that our SRS, defined over the Lagrange basis, is also updatable. Specifically, updating parties can take a linear combination of the Lagrange basis terms to retrieve the monomial basis terms, perform an update generically, and convert back to the Lagrange basis. When we instantiate the random oracle and outsource the verifiers non-constant work, we must make use of a non-updatable CRS. This means that while we achieve updatability for our argument system with a logarithmic verifier, we do <em>not</em> achieve updatability for a constant time verifier. We additionally ensure that all the components used in our argument system for general computation are public-coin (the verifier only sends random challenges) thus ensuring that it can be made non-interactive using the Fiat-Shamir transform <em>[35]</em>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.1 Roadmap</h3>

    <p class="text-gray-300">In Section 3 we define argument systems, present several algebraic preliminaries, and define our cryptographic assumptions. In Section 4 we define and provide</p>

    <p class="text-gray-300">constructions for vector commitments (§4.1), polynomial-evaluation arguments (§4.2), inner-product arguments (§4.3), and multi-Hadamard arguments (§4.5). In Section 5 we define the <span class="math">\\mathcal{R}_{\\texttt{ACS}}</span> constraint system and our argument system for <span class="math">\\mathcal{R}_{\\texttt{ACS}}</span>. In Section 6 we describe proof-composition techniques to achieve a constant-time verifier.</p>

    <h2 id="sec-14" class="text-2xl font-bold">3 Preliminaries</h2>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 Argument System</h3>

    <p class="text-gray-300">An <em>argument system</em> is a protocol in which a <em>prover</em> proves a “computational statement” to a <em>verifier</em>. Formally we capture a computational statement as a ternary relation. For relation <span class="math">\\mathcal{R}</span>, given public parameters <span class="math">\\mathsf{pp}</span>, we call <span class="math">w</span> a witness for a statement <span class="math">u</span> if <span class="math">(\\mathsf{pp},w,u)\\in\\mathcal{R}</span>. In this section we define argument systems and their desired properties. We adapt the following notation and definitions from both <em>Chiesa et al. [28]</em> and <em>Bünz et al. [23]</em>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 1 (Interactive Argument System).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}\\subset\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}\\times\\{0,1\\}^{*}</span> be a polynomial-time-decidable ternary relation. An argument system for relation <span class="math">\\mathcal{R}</span> is a tuple of three probabilistic polynomial-time interactive algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>, denoted the generator, prover, and verifier respectively, with the following structure</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(\\lambda,\\mathsf{N})\\to\\mathsf{pp}</span>: Takes as input security parameter <span class="math">\\lambda</span> and the size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pp},u,w)</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, statement <span class="math">u</span>, and witness <span class="math">w</span>. Interactively proves that <span class="math">(\\mathsf{pp},u,w)\\in\\mathcal{R}</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pp},u)\\to 0/1</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span> and statement <span class="math">u</span>. Outputs <span class="math">0</span> for <span class="math">\\texttt{reject}</span> and <span class="math">1</span> for accept.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathsf{tr}\\leftarrow\\langle\\mathcal{P}(\\mathsf{pp},u,w),\\mathcal{V}(\\mathsf{pp},u)\\rangle</span> denote the transcript <span class="math">\\mathsf{tr}</span> produced by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> on their specified inputs. Let <span class="math">\\langle\\mathcal{P}(\\mathsf{pp},u,w),\\mathcal{V}(\\mathsf{pp},u)\\rangle=0/1</span> denote the verifier’s output at the end of the interaction. For relation <span class="math">\\mathcal{R}</span>, <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> satisfies perfect completeness if for any statement <span class="math">u</span> and witness <span class="math">w</span></p>

    <p class="text-gray-300">$\\Pr\\left[\\begin{subarray}{c}(\\mathsf{pp},u,w)\\in\\mathcal{R},\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathcal{P}(\\mathsf{pp},u,w),\\mathcal{V}(\\mathsf{pp},u)\\rangle=1\\end{subarray}\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,\\mathsf{N})\\right]=1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and satisfies soundness if for any non-satisfiable statement <span class="math">u</span> (i.e. there exists no <span class="math">w</span> such that <span class="math">(\\mathsf{pp},u,w)\\in\\mathcal{R}</span>.) and PPT adversary <span class="math">\\mathcal{P}^{*}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\begin{subarray}{c}\\langle\\mathcal{P}^{*}(\\mathsf{pp},u),\\mathcal{V}(\\mathsf{pp},u)\\rangle=1\\end{subarray}\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,\\mathsf{N})\\right]=\\mathsf{negl}(\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 2 (Knowledge-Soundness <em>[71]</em>).</h6>

    <p class="text-gray-300">Informally, knowledge soundness captures the notion that if the verifier is convinced of a specified statement, then the prover must possess the corresponding witness. Formally, an argument</p>

    <p class="text-gray-300">system for relation <span class="math">\\mathcal{R}</span>, <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{P})</span>, satisfies knowledge-soundness if for any probabilistic polynomial time prover <span class="math">\\mathcal{P}^*</span> there exists a probabilistic polynomial time extractor <span class="math">\\mathcal{E}</span> such for all inputs <span class="math">u</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr} \\left[ \\begin{array}{l} \\langle \\mathcal{P}^*(\\mathsf{pp}, u, \\rho), \\mathcal{V}(\\mathsf{pp}, u) \\rangle = 1, \\\\ (\\mathsf{pp}, u, w) \\notin \\mathcal{R} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(\\lambda, \\mathsf{N}), \\\\ w \\leftarrow \\mathcal{E}(\\mathsf{pp}, u, \\rho) \\end{array} \\right] = \\mathsf{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\rho</span> denotes the input randomness for <span class="math">\\mathcal{P}^*</span>.</p>

    <p class="text-gray-300"><strong>Definition 3 ((Special Honest-Verifier) Zero-Knowledge).</strong> Informally, (Special Honest-Verifier) Zero-Knowledge captures the property that an (honest) verifier gains no additional information after viewing a proof of correct execution. Formally, an interactive argument system <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> satisfies zero-knowledge for relation <span class="math">\\mathcal{R}</span> if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for any PPT adversary <span class="math">\\mathcal{V}^*</span>, pair of interactive adversaries <span class="math">\\mathcal{A}_1,\\mathcal{A}_2</span>, and auxiliary input <span class="math">z</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\operatorname{Pr} \\left[ \\begin{array}{l} (\\mathsf{pp}, u, w) \\in \\mathcal{R}, \\\\ \\mathcal{A}_2(\\mathsf{tr}) = 1 \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G}(\\lambda, \\mathsf{N}), \\\\ (u, w, \\mathsf{st}) \\leftarrow \\mathcal{A}_1(\\mathsf{pp}, z), \\\\ \\mathsf{tr} \\leftarrow \\langle \\mathcal{P}(\\mathsf{pp}, u, w), \\mathcal{V}^*(\\mathsf{pp}, u; \\mathsf{st}) \\rangle \\end{array} \\right] - \\\\ \\operatorname{Pr} \\left[ \\begin{array}{l} (\\mathsf{pp}, u, w) \\in \\mathcal{R}, \\\\ \\mathcal{A}_2(\\mathsf{tr}) = 1 \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf{pp}, \\mathsf{trap}) \\leftarrow \\mathcal{S}(\\lambda, \\mathsf{N}), \\\\ (u, w) \\leftarrow \\mathcal{A}_1(\\mathsf{pp}, z), \\\\ \\mathsf{tr} \\leftarrow \\mathcal{S}(\\mathsf{pp}, \\mathsf{trap}, u) \\end{array} \\right] \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> satisfies special honest-verifier zero-knowledge if <span class="math">\\mathcal{V}^*</span> is constrained to be the honest verifier.</p>

    <p class="text-gray-300"><strong>Definition 4 (Public Coin).</strong> An argument system <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is called public coin if all the messages sent from <span class="math">\\mathcal{V}</span> to <span class="math">\\mathcal{P}</span> are chosen uniformly at random and independently of the prover's messages.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3.2 Algebraic Preliminaries</h2>

    <p class="text-gray-300">The <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span> relation involves statements and witnesses represented as a set of polynomials over a field <span class="math">\\mathbb{F}</span>. <span class="math">\\mathcal{R}_{\\mathrm{ACS}}</span> efficiently encodes conditions that dictate a valid statement-witness polynomial pair using vanishing polynomials, and the formal derivative of vanishing polynomials. We borrow both notation and several of the following definitions from Chiesa et al. [28].</p>

    <p class="text-gray-300"><strong>Notation 1 (Vectors and Matrices).</strong> Throughout this work we denote vectors and matrices using a bold font (i.e. <span class="math">\\pmb{v}</span> and <span class="math">\\pmb{M}</span>). For matrix <span class="math">M</span> we let <span class="math">M[i,j]</span> denote the entry at row <span class="math">i</span> and column <span class="math">j</span>. We let <span class="math">v_{i}</span> denote element <span class="math">i</span> of vector <span class="math">\\pmb{v}</span>. We define vectors by their individual components using parenthesis (i.e. <span class="math">\\pmb{v} = (v_{1}, v_{2}, \\ldots, v_{n})</span>). We denote vector <span class="math">w</span> appended to vector <span class="math">v</span> as <span class="math">(\\pmb{v}, \\pmb{w})</span>. We define <span class="math">\\pmb{v} \\cdot \\pmb{w}</span> to be the inner-product and <span class="math">\\pmb{v} \\circ \\pmb{w}</span> to be the Hadamard product. For vectors <span class="math">\\pmb{g}</span> and <span class="math">\\pmb{x}</span> of the same length, let <span class="math">\\pmb{g}^{\\pmb{x}} = \\prod_{i} g_{i}^{x_{i}}</span>. We let <span class="math">[n]</span> denote the vector <span class="math">(1, 2, \\ldots, n)</span> and let <span class="math">[m,n]</span> denote the vector <span class="math">(m, m+1, \\ldots, n)</span>. Similarly we let <span class="math">\\{v_{i}\\}_{i \\in [n]}</span> denote the vector <span class="math">(v_{1}, v_{2}, \\ldots, v_{n})</span>.</p>

    <p class="text-gray-300">10</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Notation 2 (Evaluation-Based Polynomial Representation).</h6>

    <p class="text-gray-300">Throughout our work, we represent various degree <span class="math">n</span> polynomials as vectors of <span class="math">n+1</span> <em>evaluations</em> over a predefined set of points rather than as vectors of coefficients. For a polynomial <span class="math">p</span> we let <span class="math">\\bm{p}</span> denote its evaluation-based vector representation. We treat <span class="math">\\bm{p}</span> as a vector or a polynomial representation interchangably depending on context. For notational conciseness, we let <span class="math">\\bm{p}(x)</span> denote the evaluation <span class="math">p(x)</span>. Similiarly for indeterminate <span class="math">X</span>, we let <span class="math">\\bm{p}(X)</span> denote polynomial <span class="math">p(X)</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 5 (Vanishing Polynomial <em>[28]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a finite field <span class="math">\\mathbb{F}</span> and a subset <span class="math">S\\subseteq\\mathbb{F}</span>. Let <span class="math">v_{S}</span> denote the unique, non-zero, monic, polynomial of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero at every point on </span>S<span class="math">. If </span>S<span class="math"> is a multiplicative subgroup, then </span>v_{S}(X)=X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1<span class="math">, which can be computed in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 6 (Formal Derivative of the Vanishing Polynomial <em>[9, 28]</em>).</h6>

    <p class="text-gray-300">Given a finite field <span class="math">\\mathbb{F}</span> and a subset <span class="math">S\\subseteq\\mathbb{F}</span>, we define the polynomial</p>

    <p class="text-gray-300"><span class="math">u_{S}(X,Y)=\\frac{v_{S}(X)-v_{S}(Y)}{X-Y},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">X,Y\\in\\mathbb{F}</span>. Note that <span class="math">u_{S}</span> is a bivariate polynomial with degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> in each variable, because </span>X-Y<span class="math"> divides </span>v_{S}(X)-v_{S}(Y)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">S</span> is a multiplicative subgroup, we can compute <span class="math">u_{S}(X,Y)</span> as follows: If <span class="math">X\\neq Y</span> then the term <span class="math">(v_{S}(X)-v_{S}(Y))/(X-Y)</span> can be computed directly. If, on the other hand, <span class="math">X=Y</span>, then Chiesa et al. <em>[28]</em> show that $u_{S}(X,X)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math">. This property suggests that for all </span>X,Y\\in S<span class="math">, </span>u_{S}(X,Y)\\neq 0<span class="math"> when </span>X=Y<span class="math"> and </span>u_{S}(X,Y)=0$ otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Lemma 1 (Polynomial Decomposition <em>[57]</em>).</h6>

    <p class="text-gray-300">Consider degree <span class="math">d</span> polynomial <span class="math">p(X)</span> and arbitrary evaluation point <span class="math">u\\in\\mathbb{F}</span>. Then there exists degree <span class="math">d-1</span> polynomial <span class="math">q(X)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\frac{p(X)-p(u)}{X-u}=q(X)</span></p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 7 (Lagrange Basis).</h6>

    <p class="text-gray-300">For evaluation points <span class="math">x_{1},\\ldots,x_{k}</span> the Lagrange basis is defined as <span class="math">\\ell(x)=\\langle\\ell_{0}(x),\\ldots,\\ell_{k}(x)\\rangle^{\\top}</span> where</p>

    <p class="text-gray-300"><span class="math">\\ell_{j}(x)\\coloneqq\\prod_{0\\leq m\\leq k,m\\neq j}\\frac{x-x_{m}}{x_{j}-x_{m}}.</span></p>

    <p class="text-gray-300">Suppose a polynomial <span class="math">P</span> of degree <span class="math">k</span> is defined by points <span class="math">(x_{0},y_{0}),\\ldots,(x_{k},y_{k})</span> Then</p>

    <p class="text-gray-300"><span class="math">P(x)=\\sum_{j=0}^{k}y_{j}\\ell_{j}(x).</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">In order to achieve zero-knowledge we require additional cryptographic machinery overlayed on top of the core interaction. We define our cryptographic assumptions below.</p>

    <p class="text-gray-300">Assumption 1 (Discrete Logarithm Relation [23]). Consider group <span class="math">\\mathbb{G}</span>. The discrete logarithm assumption holds for <span class="math">\\mathbb{G}</span> if for all PPT adversaries <span class="math">\\mathcal{A}</span> and for all <span class="math">n \\geq 2</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\exists a_i \\neq 0, \\\\ \\prod_{i=1}^{n} g_i^{a_i} = 1 \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} g_1, \\ldots, g_n \\stackrel{\\$}{\\leftarrow} \\mathbb{G}, \\\\ a_1, \\ldots, a_n \\in \\mathbb{Z}_p \\leftarrow \\mathcal{A}(\\mathbb{G}, g_1, \\ldots, g_n) \\end{array} \\right] = \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Assumption 2 (n-Strong Diffie-Hellman (n-SDH)). Consider group <span class="math">\\mathbb{G}</span> of prime order <span class="math">p = O(2^{\\lambda})</span> and let <span class="math">\\mathbb{F} = \\mathbb{Z}_p^*</span>. The <span class="math">n</span>-SDH assumption [17] holds for <span class="math">\\mathbb{G}</span> if for all PPT adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} g \\stackrel{\\$}{\\leftarrow} \\mathbb{G}, \\\\ c \\neq -s, \\\\ C = g^{\\frac{1}{s + c}} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} s \\stackrel{\\$}{\\leftarrow} \\mathbb{F}, \\\\ \\sigma = (\\mathbb{G}, g, g^s, \\ldots, g^{s^n}), \\\\ (c, C) \\leftarrow \\mathcal{A}(\\sigma) \\end{array} \\right] = \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Assumption 3 (n-Bilinear Strong Diffie-Hellman (n-BSDH)). Consider two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p = O(2^{\\lambda})</span> such that there exists a symmetric bilinear pairing <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_{\\mathsf{T}}</span>. Let <span class="math">\\mathbb{F} = \\mathbb{Z}_p^*</span>. The <span class="math">n</span>-BSDH assumption [44] holds for <span class="math">(\\mathbb{G}, \\mathbb{G}_{\\mathsf{T}})</span> if for all PPT adversaries <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} g \\stackrel{\\$}{\\leftarrow} \\mathbb{G}, \\\\ c \\neq -s, \\\\ C = e(g, g)^{\\frac{1}{s + c}} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} s \\stackrel{\\$}{\\leftarrow} \\mathbb{F}, \\\\ \\sigma = ((\\mathbb{F}, \\mathbb{G}, \\mathbb{G}_{\\mathsf{T}}, e), g, g^s, \\ldots, g^{s^n}), \\\\ (c, C) \\leftarrow \\mathcal{A}(\\sigma) \\end{array} \\right] = \\operatorname{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Assumption 4 (n-EPKE for a Linearly Independent Basis). Consider a linearly independent basis of polynomials of degree up to <span class="math">n</span>: <span class="math">p_0(X), \\ldots, p_n(X)</span>. Consider two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p = O(2^{\\lambda})</span> such that there exists a symmetric bilinear pairing <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_{\\mathsf{T}}</span>. Let <span class="math">\\mathbb{F} = \\mathbb{Z}_p^*</span>. The <span class="math">n</span>-Extended Power Knowledge of Exponent holds for <span class="math">(\\mathbb{G}, \\mathbb{G}_{\\mathsf{T}})</span> if for any PPT adversary <span class="math">\\mathcal{A}</span> there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} e(A, g^{\\alpha}) = e(A', g), \\\\ A = \\left(\\prod_{i=0}^{n} g^{p_i(s) \\cdot a_i}\\right) \\cdot g^{t \\cdot b} \\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathbb{F}, \\mathbb{G}, \\mathbb{G}_{\\mathsf{T}}, e) \\leftarrow \\mathcal{G}(\\lambda), \\\\ \\alpha, s, t \\stackrel{\\<span class="math">}{\\leftarrow} \\mathbb{F}, g \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}, \\\\ \\boldsymbol{u} = (g, g^{p_0(s)}, \\ldots, g^{p_n(s)}, g^t), \\\\ \\boldsymbol{v} = (g^{\\alpha}, g^{\\alpha p_0(s)}, \\ldots, g^{\\alpha p_n(s)}, g^{\\alpha t}), \\\\ \\sigma = ((\\mathbb{F}, H, \\mathbb{G}, \\mathbb{G}_{\\mathsf{T}}, e), \\boldsymbol{u}, \\boldsymbol{v}), \\\\ (A, A') \\leftarrow \\mathcal{A}(\\lambda, \\sigma, z; \\rho), \\\\ (a_0, \\ldots, a_n, b) \\leftarrow \\mathcal{E}(\\lambda, \\sigma, z; \\rho) \\end{array} \\right] = 1 - \\operatorname{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for any <em>benign</em> auxiliary input <span class="math">z\\in\\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span>, and randomness <span class="math">\\rho</span>. In this setting we consider input <span class="math">z</span> benign if it is generated independently of <span class="math">\\alpha</span>. We prove that our variant of the <span class="math">n</span>-EPKE assumption is equivalent to that of of Zhang et al. <em>[71]</em> in supplementary section D.1</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 1 (Benign Auxiliary Distributions).</h6>

    <p class="text-gray-300">Boyle et al. <em>[22]</em> and Bitansky et al. <em>[16]</em> show the impossibility of knowledge assumptions with arbitrary auxiliary inputs. To circumvent this issue, we must assume that each of our subprotocols relying on the <span class="math">q</span>-EPKE assumption only receive benign auxiliary inputs. The precise definition of benign inputs can be found in Assumption 4. When composing subprotocols we are careful not to introduce any new terms that could break this requirement. Thus when using our final argument system as a subroutine in larger protocols, knowledge-soundness holds so long as the auxiliarly input is sampled benignly.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 Auxiliary Argument Systems</h2>

    <p class="text-gray-300">In this section we define and construct extractible vector commitments (§4.1), an argument system for polynomial evaluation (§4.2), an argument system for inner-product (§4.3), and an argument system for inner-product over the Lagrange basis (§4.4). While we present the Lagrange basis, we stress that our auxiliary constructions and corresponding proofs work with any basis by Assumption 4. For notational simplicity our constructions utilize symmetric (type 1) bilinear pairings; however, our constructions can be easily modified to handle asymmetric (type 2) bilinear pairings.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.1 Extractible Vector Commitments</h3>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 8 (Vector Commitments).</h6>

    <p class="text-gray-300">A vector commitment scheme over <span class="math">\\mathbb{F}^{n}</span> has the following structure</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(\\lambda,n)\\to\\mathsf{pp}</span>: Takes input security parameter <span class="math">\\lambda</span> size bound <span class="math">n</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{com}(\\mathsf{pp};\\bm{v};r)\\to c</span>. Takes input public parameters <span class="math">\\mathsf{pp}</span>, vector <span class="math">\\bm{v}\\in\\mathbb{F}^{n}</span> and randomness <span class="math">r</span>. Outputs commitment <span class="math">c</span>.</li>

      <li><span class="math">\\mathsf{checkcom}(\\mathsf{pp};c)\\to\\{0,1\\}</span>. Takes input public parameters <span class="math">\\mathsf{pp}</span>, and commitment <span class="math">c</span>. Outputs <span class="math">1</span> is <span class="math">c</span> is well-formed, <span class="math">0</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">A vector commitment scheme <span class="math">(\\mathcal{G},\\mathsf{com})</span> over <span class="math">\\mathbb{F}^{n}</span>, with randomness space <span class="math">\\mathsf{R}</span>, is said to be computationally binding if for any PPT adversary <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}\\mathsf{com}(\\bm{v_{0}};r_{0})=\\mathsf{com}(\\bm{v_{1}};r_{1}),\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{v_{0}}\\neq\\bm{v_{1}}\\end{matrix}\\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,n),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\bm{v_{0}},\\bm{v_{1}},r_{0},r_{1}\\leftarrow\\mathcal{A}(\\mathsf{pp})\\end{matrix}\\right]=\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">and is said to be unconditionally hiding if for any adversary <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[b = b^{\\prime}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}\\mathsf{pp}\\gets \\mathcal{G}(\\lambda ,n),(\\boldsymbol{v_{0}},\\boldsymbol{v_{1}})\\in \\mathbb{F}^{n}\\gets \\mathcal{A}(\\mathsf{pp}),\\\\ b\\stackrel {\\S}{\\leftarrow}\\{0,1\\}, r\\stackrel {\\S}{\\leftarrow}\\mathsf{R},c\\gets \\mathsf{com}(\\boldsymbol{v_{b}};r),b^{\\prime}\\gets \\mathcal{A}(\\mathsf{pp},c) \\end{array} \\right.\\right] = \\frac{1}{2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Definition 9 (Extractibility).</strong> We call a vector commitment scheme extractible if for any probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>, there exists a probabilistic polynomial time extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[\\begin{array}{l}\\mathsf{checkcom}(\\mathsf{pp};c) = 1,\\\\c\\neq \\mathsf{com}(\\mathsf{pp};v;r)\\end{array}\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}\\mathsf{pp}\\gets \\mathcal{G}(\\lambda ,n),\\\\ c\\gets \\mathcal{A}(\\mathsf{pp},z;\\rho),\\\\ (v,r)\\gets \\mathcal{E}(\\mathsf{pp},z;\\rho) \\end{array}\\right] = \\mathsf{negl}(\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">for any benign auxiliary input <span class="math">z\\in \\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span>, and randomness <span class="math">\\rho</span>.</p>

    <p class="text-gray-300"><strong>Definition 10 (Additively Homomorphic Commitment Scheme).</strong> Consider a vector commitment scheme <span class="math">(\\mathcal{G},\\mathsf{com})</span> over <span class="math">\\mathbb{F}^n</span>, with abelian groups <span class="math">(\\mathsf{C}, + _{\\mathsf{C}})</span>, <span class="math">(\\mathsf{R}, + _{\\mathsf{R}})</span> for the commitment space, and randomness space respectively. The commitment scheme is said to be homomorphic if for all <span class="math">\\pmb {v_1},\\pmb {v_2}\\in \\mathbb{F}^n</span> and <span class="math">\\pmb {r}_1,\\pmb {r}_2\\in \\mathbb{R}</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {com} \\left(\\boldsymbol {v} _ {1}; r _ {1}\\right) + _ {\\mathsf {C}} \\operatorname {com} \\left(\\boldsymbol {v} _ {2}; r _ {2}\\right) = \\operatorname {com} \\left(\\boldsymbol {v} _ {1} + \\boldsymbol {v} _ {2}; r _ {1} + _ {\\mathsf {R}} r _ {2}\\right).</span></div>

    <p class="text-gray-300"><strong>Construction 1 (Structured Polynomial Commitments).</strong> We design a scheme to commit to a vector of evaluations representing a polynomial. Similar to Tomescu et al. [64] we commit to evaluation-based representations of polynomials by utilizing the Lagrange basis as a part of the structured reference string. Using ideas from Zhang et al. [71] (and Chiesa et al. [28]), we achieve extractibility by enforcing that the prover provides an auxiliary "shifted" commitment, which ensures that the commitments were formed by using a linear combination of terms in the SRS. We define generator <span class="math">\\mathcal{G}</span>, <span class="math">\\mathsf{com}</span>, and <span class="math">\\mathsf{checkcom}</span> as follows for vectors over <span class="math">\\mathbb{Z}_p^n</span>:</p>

    <p class="text-gray-300"><strong>Generator <span class="math">(\\lambda ,n)\\to \\mathsf{pp}</span>:</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p</span> (with <span class="math">p \\geq 2^{\\lambda}</span>) such that there exists a symmetric bilinear pairing <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_{\\mathsf{T}}</span> where the <span class="math">(n - 1)</span>-SDH and <span class="math">(n - 1)</span>-EPKE assumptions hold.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Let <span class="math">H \\subseteq \\mathbb{F}</span> be such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> and let </span>\\ell_1, \\ldots, \\ell_n<span class="math"> be the Lagrange basis over evaluation points </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly sample generator <span class="math">g\\in \\mathbb{G}</span> and <span class="math">\\alpha ,s\\stackrel {\\S}{\\leftarrow}\\mathbb{F}</span></li>

      <li>Compute commitment keys <span class="math">\\pmb {u} = (g^{\\ell_1(s)},\\dots ,g^{\\ell_n(s)})</span> and <span class="math">\\pmb {v} = (g^{\\alpha \\ell_1(s)},\\dots ,g^{\\alpha \\ell_n(s)})</span></li>

      <li>Sample <span class="math">h\\stackrel {\\S}{\\leftarrow}\\mathbb{G}</span> and output public parameters <span class="math">\\mathsf{pp} = (\\mathbb{G},H,\\pmb {u},\\pmb {v},g,g^{\\alpha},h,h^{\\alpha})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{com}(\\mathsf{pp}; \\boldsymbol{p} \\in \\mathbb{F}^n, r \\in \\mathbb{F}) \\to P \\in \\mathbb{G}^n</span>: Interpret <span class="math">\\boldsymbol{p}</span> as a vector of polynomial evaluations over <span class="math">H</span>. Output <span class="math">P = (g^{\\boldsymbol{p}(s)} \\cdot h^r, g^{\\alpha \\cdot \\boldsymbol{p}(s)} \\cdot h^{\\alpha \\cdot r})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{checkcom}(\\mathsf{pp};P\\in \\mathbb{G}^2)\\to \\{0,1\\}</span>: Parse <span class="math">P</span> as <span class="math">(P_{1},P_{2})</span> and check <span class="math">e(P_1,g^\\alpha) = e(P_2,g)</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Lemma 2 (Structured Polynomial Commitments).</h6>

    <p class="text-gray-300">Construction 1 is a homomorphic vector commitment scheme that satisfies unconditional hiding, computational binding, and extractibility. For polynomials defined by <span class="math">n</span> evaluation points, the generator takes time <span class="math">O_{\\lambda}(n)</span>, <span class="math">\\mathsf{com}</span> takes time <span class="math">O_{\\lambda}(n)</span>, and <span class="math">\\mathsf{checkcom}</span> takes time <span class="math">O_{\\lambda}(1)</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Informally, hiding follows from the blinding terms, binding follows from the <span class="math">(n-1)</span>-SDH assumption, and extractibility holds from the <span class="math">(n-1)</span>-EPKE assumption. The generator can compute <span class="math">\\ell_{1}(s),\\ldots,\\ell_{1}(s)</span> in time <span class="math">O_{\\lambda}(n)</span> using the Barycentric representation <em>[13]</em>. Formally, we prove Lemma 2 in supplementary section D.2. ∎</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.2 An Argument System for Polynomial Evaluation</h3>

    <p class="text-gray-300">In our argument system for general computation, to prove desired properties about the committed witness and subsequent messages (all represented as polynomials), the prover is required to evaluate these polynomials (represented as vectors of evaluations) at challenge points. We modify the polynomial commitment scheme by Zhang et al. <em>[71]</em>, which in turn is based on the scheme by Papamanthou et al. <em>[57]</em>. To efficiently evaluate polynomials based on their evaluation representations, we create a structured key which utilizes the Lagrange basis.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 11 (Polynomial Evaluation Relation).</h6>

    <p class="text-gray-300">Consider group <span class="math">\\mathbb{G}</span> of order <span class="math">q</span> and let <span class="math">\\mathbb{F}=\\mathbb{Z}_{q}</span>. The polynomial evaluation relation (<span class="math">\\mathcal{R}_{\\mathsf{POLY}}</span>), with respect to vector commitment scheme <span class="math">\\mathsf{com}</span>, defined over subset <span class="math">H\\subseteq\\mathbb{F}</span> consists of commitments <span class="math">P\\in\\mathbb{G}^{2}</span>, <span class="math">Y\\in\\mathbb{G}</span>, evaluation point <span class="math">u</span>, and evaluation result <span class="math">y</span>. A vector <span class="math">\\bm{p}</span> and scalar <span class="math">y</span> satisfies an <span class="math">\\mathcal{R}_{\\mathsf{POLY}}</span> instance if <span class="math">\\bm{p}(u)=y</span>, <span class="math">Y=\\mathsf{com}(y)</span>, and <span class="math">P=\\mathsf{com}(\\bm{p})</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Construction 2 (Argument System for Polynomial Evaluation).</h6>

    <p class="text-gray-300">We define an argument system for polynomial evaluation (Definition 11) with respect to the structured polynomial commitment scheme (Definition 1)</p>

    <h6 id="sec-34" class="text-base font-medium mt-4"><span class="math">\\mathsf{Generator}(\\lambda,n)\\to\\mathsf{pp}</span>:</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the generator for structured polynomial commitments (Construction 1) and output its result.</li>

      <li>Additionally sample <span class="math">\\beta\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and output scalar commitment key <span class="math">\\mathsf{ck}_{y}=(g,h,g^{\\beta},h^{\\beta})</span></li>

    </ol>

    <h6 id="sec-35" class="text-base font-medium mt-4"><span class="math">\\langle\\mathsf{Prover},\\mathsf{Verifier}\\rangle</span>:</h6>

    <p class="text-gray-300">The prover and verifier are provided with statement <span class="math">(P\\in\\mathbb{G}^{2},Y\\in\\mathbb{G}^{2},u\\in\\mathbb{F})</span>. The prover is additionally provided with witness <span class="math">\\bm{p}\\in\\mathbb{F}^{n},y,r_{p},r_{y}\\in\\mathbb{F}</span>. The prover is tasked with proving that <span class="math">Y=(g^{y}\\cdot h^{r_{y}},g^{\\alpha}\\cdot h^{\\alpha r_{y}})</span>, <span class="math">P=(g^{\\bm{p}(s)}\\cdot h^{r_{p}},g^{\\alpha\\bm{p}(s)}\\cdot h^{\\alpha r_{p}})</span>, and that <span class="math">y=p(u)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using Lemma 1, the prover computes evaluations of polynomial <span class="math">\\bm{q}</span> over <span class="math">H</span> where <span class="math">\\bm{q}(X)=(\\bm{p}(X)-y)/(X-u)</span>. Next the prover samples <span class="math">r_{q}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and commits to <span class="math">\\bm{q}</span>, and the randomness:</li>

    </ol>

    <p class="text-gray-300"><span class="math">Q</span> <span class="math">=\\mathsf{com}(\\bm{q};r_{q})=(g^{\\bm{q}(s)}\\cdot h^{r_{q}},g^{\\alpha\\bm{q}(s)}\\cdot h^{\\alpha r_{q}})</span> <span class="math">R</span> <span class="math">=(g^{r_{p}-r_{y}-r_{q}(s-u)},g^{\\alpha\\cdot(r_{p}-r_{y}-r_{q}(s-u))}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier parses commitments <span class="math">P,Q,R,Y</span> as <span class="math">(P_{1},P_{2})</span>, <span class="math">(Q_{1},Q_{2})</span>, <span class="math">(R_{1},R_{2})</span> and <span class="math">(Y_{1},Y_{2})</span> respectively and checks that they are well formed using checkcom. Next the verifier checks that the prover was able to compute a valid commitment to <span class="math">\\bm{q}</span>: <span class="math">e(P_{1}/Y_{1},g)\\stackrel{{\\scriptstyle?}}{{=}}e(Q_{1},g^{s-u})e(R_{1},h)</span>.</li>

    </ol>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 1 (Polynomial Evaluation Argument)</h6>

    <p class="text-gray-300">Construction 2 satisfies completeness, knowledge soundness, and perfect zero-knowledge. For polynomials defined over <span class="math">n</span> evaluations, the polynomial evaluation argument features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(1)</span> verifier.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove Theorem 1 in supplementary section D.3. ∎</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">4.3 An Argument System for Inner-Product</h3>

    <p class="text-gray-300">We utilize the argument system for generalized inner-product from <em>Bünz et al. [26]</em>, specifically instantiated with the Pedersen-like vector commitment scheme and modified to support zero-knowledge. In Section 4.4, we extend this argument system to handle evaluation based polynomial commitments (Construction 1). Later in Section 6 we show how to achieve a constant-time verifier using proof composition.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 12 (The Inner-Product Relation <em>[26]</em>)</h6>

    <p class="text-gray-300">Consider group <span class="math">\\mathbb{G}</span> of order <span class="math">p</span> and let <span class="math">\\mathbb{F}=\\mathbb{Z}_{p}</span>. The inner-product relation (<span class="math">\\mathcal{R}_{\\text{IP}}</span>), characterized by commitment scheme <span class="math">\\mathsf{com}</span>, consists of hiding and binding commitments <span class="math">A,B,C\\in\\mathbb{G}</span>, and scalar <span class="math">r\\in\\mathbb{F}\\setminus\\{0\\}</span>. Vectors <span class="math">\\bm{a},\\bm{b}\\in\\mathbb{F}^{n}</span> and scalar <span class="math">c\\in\\mathbb{F}</span> satisfy an <span class="math">\\mathcal{R}_{\\text{IP}}</span> instance if <span class="math">c=\\bm{a}^{\\prime}\\cdot\\bm{b}</span>, where <span class="math">\\{\\bm{a}^{\\prime}_{i}=\\bm{a}_{i}\\cdot r^{i}\\}_{i=0}^{n-1}</span>, and <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> are commitments to <span class="math">\\bm{a}</span>, <span class="math">\\bm{b}</span>, and <span class="math">c</span> respectively.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Construction 3 (Argument System for Inner-Product <em>[26]</em>)</h6>

    <p class="text-gray-300">An argument system for the inner-product relation allows a prover to show that for commitments <span class="math">A,B,C\\in\\mathbb{G}</span> and scalar <span class="math">r\\in\\mathbb{F}\\setminus\\{0\\}</span> they know <span class="math">\\bm{a},\\bm{b}\\in\\mathbb{F}^{n}</span> and scalar <span class="math">c\\in\\mathbb{F}</span> such that <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> are commitments to <span class="math">\\bm{a},\\bm{b}</span>, and <span class="math">c</span> respectively, and that <span class="math">c=(\\bm{a}\\circ\\bm{r})\\cdot\\bm{b}</span> where <span class="math">\\bm{r}=(r^{0},r^{1},\\ldots,r^{n-1})</span>.</p>

    <p class="text-gray-300"><em>Bünz et al. [26]</em> present a <em>generalized inner-product argument</em> which allows a prover to prove the inner-product relation over any binding commitment scheme that is doubly homomorphic (i.e. homomorphic in both the message space and the key space). They additionally show how to achieve an <span class="math">O_{\\lambda}(\\log n)</span> verifier by utilizing a structured reference string and polynomial commitments. We derive</p>

    <p class="text-gray-300">an argument system for <span class="math">\\mathcal{R}_{\\mathsf{IP}}</span> by applying the following commitment scheme to the generalized inner-product argument:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c o m} (\\operatorname {c k}; \\boldsymbol {a}, \\boldsymbol {b}, c; r _ {a}, r _ {b}, r _ {c}) = \\left(\\boldsymbol {w} ^ {\\boldsymbol {a}} \\cdot h ^ {r _ {a}}, \\boldsymbol {w} ^ {\\boldsymbol {b}} \\cdot h ^ {r _ {b}}, g ^ {c} \\cdot h ^ {r _ {c}}\\right), \\tag {2}</span></div>

    <p class="text-gray-300">where the commitment key <span class="math">\\mathsf{ck} = (\\pmb {w},(g,h))</span> is created by the generator as described below. We further modify the generalized inner-product argument to be zero-knowledge using standard techniques.</p>

    <h2 id="sec-41" class="text-2xl font-bold">Generator <span class="math">(\\lambda ,n)\\to \\mathsf{pp}</span></h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p</span> (with <span class="math">p \\geq 2^{\\lambda}</span>) such that there exists a symmetric bilinear pairing <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_{\\mathsf{T}}</span> where the <span class="math">(n - 1)</span>-SDH, and the <span class="math">(n - 1)</span>-EPKE assumptions hold.</li>

      <li>Sample generator <span class="math">g \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span>, secret <span class="math">s \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and define commitment key <span class="math">\\boldsymbol{w} = (g, g^s, \\ldots, g^{s^{n-1}})</span>.</li>

      <li>Sample <span class="math">h \\stackrel{\\S}{\\leftarrow} \\mathbb{G}</span> and output public parameters <span class="math">\\mathsf{pp} = (e, \\boldsymbol{w}, h)</span>.</li>

    </ol>

    <h2 id="sec-42" class="text-2xl font-bold"><span class="math">\\langle</span> Prover, Verifier <span class="math">\\rangle</span></h2>

    <p class="text-gray-300">Both the prover and verifier are provided the statement consisting of commitments <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span> and scalar <span class="math">r</span>. The prover is additionally provided witness <span class="math">(\\pmb{a}, \\pmb{b}, c, r_a, r_b, r_c)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initially the prover computes <span class="math">\\pmb{r} = (r^0, r^1, \\dots, r^{n-1})</span>, rescales the commitment key <span class="math">\\pmb{v} = \\pmb{w}^{r^{-1}}</span>, and rescales the corresponding witness vector <span class="math">\\pmb{a} \\gets \\pmb{a} \\circ \\pmb{r}</span>.</li>

      <li>When <span class="math">n \\geq 2</span>, the prover defines <span class="math">\\pmb{a_1}</span> and <span class="math">\\pmb{a_2}</span> to be the first and second half of vector <span class="math">\\pmb{a}</span> (similarly for <span class="math">\\pmb{b}, \\pmb{v}</span>, and <span class="math">\\pmb{w}</span>). Next the prover samples randomness <span class="math">r_{\\mathsf{La}}, r_{\\mathsf{Ra}}, r_{\\mathsf{Lb}}, r_{\\mathsf{Rb}}, r_{\\mathsf{Lc}}, r_{\\mathsf{Rc}} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and sets</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A _ {L} = h ^ {r _ {\\mathrm {L a}}} \\cdot \\boldsymbol {v} _ {1} ^ {\\boldsymbol {a} _ {2}} \\quad B _ {L} = h ^ {r _ {\\mathrm {L b}}} \\cdot \\boldsymbol {w} _ {2} ^ {\\boldsymbol {b} _ {1}} \\quad C _ {L} = h ^ {r _ {\\mathrm {L c}}} \\cdot g ^ {\\boldsymbol {a} _ {2} \\cdot \\boldsymbol {b} _ {1}}</span></div>

    <div class="my-4 text-center"><span class="math-block">A _ {R} = h ^ {r _ {\\mathrm {R a}}} \\cdot \\boldsymbol {v} _ {2} ^ {\\boldsymbol {a} _ {1}} \\quad B _ {R} = h ^ {r _ {\\mathrm {R b}}} \\cdot \\boldsymbol {w} _ {1} ^ {\\boldsymbol {b} _ {2}} \\quad C _ {R} = h ^ {r _ {\\mathrm {R c}}} \\cdot g ^ {\\boldsymbol {a} _ {1} \\cdot \\boldsymbol {b} _ {2}}</span></div>

    <p class="text-gray-300">and sends these values to the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples <span class="math">x \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and sends <span class="math">x</span> to the prover.</li>

      <li>The prover and verifier each set</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} = A _ {L} ^ {x} \\cdot A \\cdot A _ {R} ^ {x ^ {- 1}} \\quad B ^ {\\prime} = B _ {L} ^ {x} \\cdot B \\cdot B _ {R} ^ {x ^ {- 1}} \\quad C ^ {\\prime} = C _ {L} ^ {x} \\cdot C \\cdot C _ {R} ^ {x ^ {- 1}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover additionally folds the commitment keys</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {v} ^ {\\prime} = \\boldsymbol {v} _ {1} \\circ \\boldsymbol {v} _ {2} ^ {x ^ {- 1}} \\quad \\boldsymbol {w} ^ {\\prime} = \\boldsymbol {w} _ {1} \\circ \\boldsymbol {w} _ {2} ^ {x},</span></div>

    <p class="text-gray-300">folds the witness vectors and associated randomness</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a} ^ {\\prime} = \\boldsymbol {a} _ {2} \\cdot x + \\boldsymbol {a} _ {1} \\quad \\boldsymbol {b} ^ {\\prime} = \\boldsymbol {b} _ {2} \\cdot x ^ {- 1} + \\boldsymbol {b} _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">r _ {a} ^ {\\prime} = r _ {\\mathrm {L a}} \\cdot x + r _ {a} + r _ {\\mathrm {R a}} \\cdot x ^ {- 1} \\quad r _ {b} ^ {\\prime} = r _ {\\mathrm {L b}} \\cdot x + r _ {b} + r _ {\\mathrm {R b}} \\cdot x ^ {- 1},</span></div>

    <p class="text-gray-300">and folds the claimed product and associated randomness</p>

    <div class="my-4 text-center"><span class="math-block">c ^ {\\prime} = \\left(\\boldsymbol {a} _ {2} \\cdot \\boldsymbol {b} _ {1}\\right) \\cdot x + c + \\left(\\boldsymbol {a} _ {1} \\cdot \\boldsymbol {b} _ {2}\\right) \\cdot x ^ {- 1} \\quad r _ {c} ^ {\\prime} = r _ {\\mathrm {L c}} \\cdot x + r _ {c} + r _ {\\mathrm {R c}} \\cdot x ^ {- 1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next if <span class="math">n \\geq 2</span> the prover and verifier recurse back to step 2 with statement <span class="math">(A&#x27;, B&#x27;, C&#x27;)</span>, witness <span class="math">(\\boldsymbol{a}&#x27;, \\boldsymbol{b}&#x27;, c&#x27;, r_a&#x27;, r_b&#x27;, r_c&#x27;)</span> and commitment keys <span class="math">(\\boldsymbol{v}&#x27;, \\boldsymbol{w}&#x27;)</span>. Otherwise the prover and verifier continue to step 7.</li>

      <li>In the final round when <span class="math">n = 1</span>, the prover sends the final commitment keys <span class="math">v, w \\in \\mathbb{G}</span>. The prover first proves to the verifier that <span class="math">(v, w)</span> have been computed correctly (subprotocol below). Next the prover proves that the product relation holds for commitments <span class="math">A&#x27;, B&#x27;, C&#x27;</span> with respect to commitment keys <span class="math">v, w</span> (subprotocol below).</li>

    </ol>

    <p class="text-gray-300">In the final round the verifier must check that the commitment keys <span class="math">v</span> and <span class="math">w</span> have been computed correctly. We continue to follow the general approach presented by Bünz et al. [26]. Suppose there were a total of <span class="math">\\ell</span> rounds. Let <span class="math">x_0, \\ldots, x_{\\ell-1}</span> denote the randomness sent by the verifier in each round. We first define</p>

    <div class="my-4 text-center"><span class="math-block">f _ {v} (X) = \\prod_ {j = 0} ^ {\\ell - 1} \\left(x _ {(\\ell - j)} ^ {- 1} + (r ^ {- 1} X) ^ {2 ^ {j}}\\right) \\qquad f _ {w} (X) = \\prod_ {j = 0} ^ {\\ell - 1} \\left(x _ {(\\ell - 1 - j)} + X ^ {2 ^ {j}}\\right).</span></div>

    <p class="text-gray-300">When <span class="math">w</span> and <span class="math">v</span> are computed correctly we have that <span class="math">v = g^{f_v(s)}</span> and <span class="math">w = g^{f_w(s)}</span> [26, Proposition B.1]. Given this observation, the verifier checks the commitment keys by engaging in the following procedure:</p>

    <p class="text-gray-300">Subprotocol to check <span class="math">(v,w)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the setup phase the generator additionally samples <span class="math">\\sigma \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and outputs keys <span class="math">\\boldsymbol{t} = (g^{\\alpha}, g^{\\alpha s}, \\ldots, g^{\\alpha s^{a - 1}})</span></li>

      <li>The prover begins the subprotocol by sending claimed evaluations <span class="math">v, w \\in \\mathbb{G}</span> along with terms <span class="math">v&#x27; = g^{\\alpha f_v(s)}</span>, and <span class="math">w&#x27; = g^{\\alpha f_w(s)}</span>.</li>

      <li>The verifier responds with challenge <span class="math">z \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and computes <span class="math">Y_v = g^{f_v(z)}</span>, and <span class="math">Y_w = g^{f_w(z)}</span>.</li>

      <li>Note that <span class="math">(v, v&#x27;)</span> and <span class="math">(w, w&#x27;)</span> can be treated as extractible polynomial commitments with respect to the standard monomial basis rather than the Lagrange basis (Construction 2). We note that in this setting our polynomial evaluation argument can be viewed as a simplified version of that of Zhang et al. [71]. To check the validity of <span class="math">v</span>, the prover and verifier treat <span class="math">V = (v, v&#x27;)</span> as a polynomial commitment and engage in an extractible polynomial evaluation argument over the statement <span class="math">(V, Y_v, z)</span> and the provided SRS. Note that the verifier does not need to check the validity of commitment <span class="math">Y_v</span>. Similarly, to check the validity of <span class="math">w</span>, the prover and verifier treat <span class="math">W = (w, w&#x27;)</span> as a polynomial commitment and engage in an extractible polynomial evaluation argument over the statement <span class="math">(W, Y_w, z)</span> and the provided SRS.</li>

    </ol>

    <p class="text-gray-300">Additionally, given commitments <span class="math">A = v^{a}h^{r_{a}}</span>, <span class="math">B = w^{b}h^{r_{b}}</span>, and <span class="math">C = g^{c}h^{r_{c}}</span> the verifier must check <span class="math">a \\cdot b = c</span>. We cannot use a textbook product argument due to the fact that <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> are committed to under different keys. To handle this setting, we use a simplified variant of a product argument presented by Bünz et al. [23]. For completeness we present this protocol in supplementary section A.</p>

    <p class="text-gray-300">18</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 2 (Inner-Product Argument).</h6>

    <p class="text-gray-300">Construction 3 is an argument system for <span class="math">\\mathcal{R}_{\\mathrm{IP}}</span> that satisfies completeness, knowledge-soundness, and honest-verifier zero-knowledge. For vectors of size <span class="math">n</span> construction 3 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(\\log n)</span> verifier.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove Theorem 2 in supplementary section D.4. ∎</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">4.4 Extending the Inner-Product Argument for the Lagrange Basis</h3>

    <h6 id="sec-46" class="text-base font-medium mt-4">Construction 4 (Argument System for Inner-Product for the Lagrange Basis).</h6>

    <p class="text-gray-300">For generator <span class="math">g\\in\\mathbb{G}</span> and random <span class="math">s\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> recall from Construction 3 that the commitment key has the form </span>\\bm{w}=(g,g^{s^{1}},\\ldots,g^{s^{n-1}})<span class="math">. Construction 3 allows a prover to prove that for vectors </span>\\bm{a},\\bm{b}\\in\\mathbb{F}^{n}<span class="math"> and </span>c\\in\\mathbb{F}<span class="math"> that </span>\\bm{a}\\cdot\\bm{b}=c<span class="math"> specifically when the commitments to </span>\\bm{a}<span class="math">, </span>\\bm{b}$, are of the form</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=\\bm{w}^{\\bm{a}}\\cdot h^{r_{a}}</span> <span class="math">B</span> <span class="math">=\\bm{w}^{\\bm{b}}\\cdot h^{r_{b}}</span></p>

    <p class="text-gray-300">However, as we show in section 5, we are particularly interested in proving the inner-product of vectors “under” evaluation-based polynomial commitments (Construction 1). In more detail, for random <span class="math">g\\in\\mathbb{G}</span> and <span class="math">t\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math">, and for subset </span>H\\subseteq\\mathbb{F}<span class="math">, consider the vector </span>\\bm{l}=(g^{\\ell_{0}(t)},g^{\\ell_{2}(t)},\\ldots,g^{\\ell_{n-1}(t)})<span class="math">, where </span>\\ell_{1},\\ldots,\\ell_{n}<span class="math"> are the lagrange basis over evaluation points </span>H<span class="math"> (Definition 7). We would like to prove that </span>\\bm{a}\\cdot\\bm{b}=c<span class="math"> where the commitments to </span>\\bm{a}<span class="math"> and </span>\\bm{b}$ are</p>

    <p class="text-gray-300"><span class="math">A^{\\prime}</span> <span class="math">=\\bm{l}^{\\bm{a}}\\cdot h^{r_{a}^{\\prime}}</span> <span class="math">B^{\\prime}</span> <span class="math">=\\bm{l}^{\\bm{b}}\\cdot h^{r_{b}^{\\prime}}</span></p>

    <p class="text-gray-300">for randomness <span class="math">r_{a}^{\\prime},r_{b}^{\\prime}</span>. While it is unclear how to directly reason about <span class="math">A^{\\prime}</span>, and <span class="math">B^{\\prime}</span> under construction 3, we can use an approach presented by Parno et al. <em>[58]</em> to check that <span class="math">A^{\\prime}</span> and <span class="math">A</span> (similiarly <span class="math">B^{\\prime}</span> and <span class="math">B</span>) commit to the same vector.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4"><span class="math">\\mathsf{Generator}(\\lambda,n)\\to\\mathsf{pp}</span>:</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p</span> (with <span class="math">p\\geq 2^{\\lambda}</span>) such that there exists a symmetric bilinear pairing <span class="math">e:\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{\\mathsf{T}}</span> where the <span class="math">(n-1)</span>-SDH, and <span class="math">(n-1)</span>-EPKE assumptions hold.</li>

      <li>Run the generator for the inner-product argument system (Construction 3). In particular, randomly sample generator <span class="math">g\\in\\mathbb{G}</span> and <span class="math">s\\in\\mathbb{F}</span> and define inner-product commitment keys over powers of <span class="math">s</span>: <span class="math">\\bm{w}=(g,g^{s},\\ldots,g^{s^{n-1}})</span>.</li>

      <li>Pick randomness commitment key <span class="math">h\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{G}$.</li>

      <li>Run the generator for polynomial commitments (Construction 1): In particular, pick random <span class="math">t,\\alpha\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> and create polynomial commitment keys </span>\\bm{l}=(g^{\\ell_{0}(t)},g^{\\ell_{1}(t)},\\ldots,g^{\\ell_{n-1}(t)})<span class="math">, and </span>\\bm{l}^{\\prime}=(g^{\\alpha\\ell_{0}(t)},g^{\\alpha\\ell_{1}(t)},\\ldots,g^{\\alpha\\ell_{n-1}(t)})$.</li>

      <li>Pick binding randomness <span class="math">\\gamma\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}$ and create binding keys</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\bm{t}=(\\bm{w}\\circ\\bm{l})^{\\gamma}=(g^{\\gamma(s^{0}+\\ell_{0}(t))},g^{\\gamma(s^{1}+\\ell_{1}(t))},\\ldots,g^{\\gamma(s^{n-1}+\\ell_{n-1}(t))})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output public parameters <span class="math">\\mathsf{pp} = (e, \\boldsymbol{w}, \\boldsymbol{l}, \\boldsymbol{l}&#x27;, \\boldsymbol{t}, (g, h), (g^\\alpha, h^\\alpha), (g^\\gamma, h^\\gamma))</span>.</li>

    </ol>

    <p class="text-gray-300"><Prover, Verifier>:</p>

    <p class="text-gray-300">The prover and verifier are provided with the statement consisting of commitments <span class="math">A&#x27;, B&#x27;, C</span> and scalar <span class="math">r</span>. The prover is additionally provided witness <span class="math">(\\boldsymbol{a}, \\boldsymbol{b}, c, r_a&#x27;, r_b&#x27;, r_c)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If computed correctly <span class="math">A&#x27;</span> and <span class="math">B&#x27;</span> are commitments to <span class="math">\\boldsymbol{a}</span> and <span class="math">\\boldsymbol{b}</span> respectively under the Lagrange-basis commitment key. That is <span class="math">A&#x27; = (\\boldsymbol{l}^a \\cdot h^{r_a&#x27;}, \\boldsymbol{l}&#x27;^a \\cdot h^{\\alpha r_a&#x27;})</span> and <span class="math">B&#x27; = (\\boldsymbol{l}^b \\cdot h^{r_b&#x27;}, \\boldsymbol{l}&#x27;^b \\cdot h^{\\alpha r_b&#x27;})</span>. The prover samples <span class="math">r_a, r_b \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and sends to the verifier commitments <span class="math">A, B \\in \\mathbb{G}</span>, where <span class="math">A</span> is the claimed commitment to <span class="math">\\boldsymbol{a}</span> under inner-product commitment key <span class="math">\\boldsymbol{w}</span>, and <span class="math">B</span> is the claimed commitment to <span class="math">\\boldsymbol{b}</span> under inner-commitment key <span class="math">\\boldsymbol{w}</span>. That is <span class="math">A = \\boldsymbol{w}^a \\cdot h^{r_a}</span> and <span class="math">B = \\boldsymbol{w}^b \\cdot h^{r_b}</span>.</li>

      <li>To prove that <span class="math">A&#x27;</span> and <span class="math">A</span> commit to the same vectors (similarly <span class="math">B&#x27;</span> and <span class="math">B</span>), the prover commits to <span class="math">\\boldsymbol{a}</span> and <span class="math">\\boldsymbol{b}</span> under the binding keys: <span class="math">A&#x27;&#x27; = \\boldsymbol{t}^a \\cdot h^{\\gamma \\cdot (r_a + r_a&#x27;)}</span>, and <span class="math">B&#x27;&#x27; = \\boldsymbol{t}^b \\cdot h^{\\gamma \\cdot (r_b + r_b&#x27;)}</span>.</li>

      <li>The verifier first checks that commitments <span class="math">A&#x27;</span> and <span class="math">B&#x27;</span> are well formed. Next the verifier checks <span class="math">e(A&#x27;&#x27;, g) \\stackrel{\\gamma}{=} e(A \\cdot A_1&#x27;, g^\\gamma)</span> and <span class="math">e(B&#x27;&#x27;, g) \\stackrel{\\gamma}{=} e(B \\cdot B_1&#x27;, g^\\gamma)</span>.</li>

      <li>If the verifier's check passes, both the prover and verifier engage in an inner-product argument (Construction 3) over statement <span class="math">(A, B, C, r)</span> and witness <span class="math">(\\boldsymbol{a}, \\boldsymbol{b}, c, r_a, r_b, r_c)</span>.</li>

    </ol>

    <p class="text-gray-300">Theorem 3 (Inner-Product Argument for the Lagrange Basis). Construction 4 is an argument system for <span class="math">\\mathcal{R}_{\\mathrm{IP}}</span> that satisfies completeness, knowledge-soundness, and honest-verifier zero-knowledge. For vectors of size <span class="math">n</span> construction 4 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(\\log n)</span> verifier.</p>

    <p class="text-gray-300">Proof. Completeness follows by observation and the completeness of the underlying inner-product argument. Informally, knowledge soundness follows from the <span class="math">(n - 1)</span>-EPKE assumption. Zero-knowledge follows due to the blinding terms. We formally prove Theorem 3 in supplementary section D.5.</p>

    <h2 id="sec-48" class="text-2xl font-bold">4.5 An Argument System for Multi-Hadamard Product</h2>

    <p class="text-gray-300">In the final round for our argument system for general computation (Section 5), we require an argument system for a multi-Hadamard product. We achieve a system with our desired asymptotics by composing the multi-Hadamard product argument system presented by Bayer [6] with our argument system for inner-product (Construction 4).</p>

    <p class="text-gray-300">Definition 13 (The Multi-Hadamard Relation). Consider group <span class="math">\\mathbb{G}</span> of order <span class="math">p</span> and let <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>. The multi-Hadamard relation <span class="math">(\\mathcal{R}_{\\mathrm{MHADM}})</span> defined over vector size <span class="math">n</span>, and instance size <span class="math">m</span> consists of <span class="math">m</span> commitments <span class="math">A_1, \\ldots, A_m</span>, and commitment <span class="math">B</span>. Vectors <span class="math">\\boldsymbol{a}_1, \\ldots, \\boldsymbol{a}_m</span> and vector <span class="math">\\boldsymbol{b}</span> satisfy the multi-Hadamard relation if <span class="math">A_i = \\operatorname{com}(\\boldsymbol{a}_i)</span> for all <span class="math">i \\in [m]</span>, <span class="math">B = \\operatorname{com}(\\boldsymbol{b})</span>, and <span class="math">\\boldsymbol{b} = \\boldsymbol{a}_1 \\circ \\boldsymbol{a}_2 \\circ \\ldots \\circ \\boldsymbol{a}_m</span>.</p>

    <p class="text-gray-300">20</Prover,></p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Construction 5 (Multi-Hadamard-Product Argument — Sketch).</h6>

    <p class="text-gray-300">Our construction composes the multi-Hadamard product argument system presented by Bayer <em>[6]</em> with the argument system for inner-product (Construction 4). At a high level, Bayer’s argument uses random linear combinations to reduce the original multi-Hadamard-product check into checking that</p>

    <p class="text-gray-300"><span class="math">A=\\mathsf{com}(\\overline{\\bm{a}},\\overline{r})\\qquad\\qquad B=\\mathsf{com}(\\overline{\\bm{b}},\\overline{s})\\qquad\\qquad D=\\mathsf{com}((\\overline{\\bm{a}}\\circ\\bm{y})\\cdot\\overline{\\bm{b}},\\overline{t})</span></p>

    <p class="text-gray-300">for commitments <span class="math">A,B,D</span>, vectors <span class="math">\\overline{\\bm{a}},\\overline{\\bm{b}},\\bm{y}</span>, and associated randomness <span class="math">\\overline{r},\\overline{s},\\overline{t}</span> generated during interaction. Our argument is identical to the one presented by Bayer <em>[6]</em> with the exception that in the final round of Bayer’s original argument the prover directly sends <span class="math">\\overline{\\bm{a}}</span>, <span class="math">\\overline{r}</span>, <span class="math">\\overline{\\bm{b}}</span>, <span class="math">\\overline{s}</span> and <span class="math">\\overline{t}</span> for the verifier to check. In our variant the verifier instead outsources this final check using an argument system for inner-product. For completeness we reproduce Bayer’s multi-Hadamard-product argument in supplementary section B, however we stress that the details are not important for understanding our argument system for general computation.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Construction 5 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{MHADM}}</span> that satisfies completeness, knowledge-soundness, and honest-verifier zero-knowledge. For <span class="math">m</span> vectors of size <span class="math">n</span>, Construction 5 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(nm^{2})</span> prover, and an <span class="math">O_{\\lambda}(\\log n+m)</span> verifier.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We formally prove Theorem 4 in supplementary section B. ∎</p>

    <h2 id="sec-52" class="text-2xl font-bold">5 Poppins: An Argument System for <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span></h2>

    <p class="text-gray-300">We start by defining a new constraint system for <span class="math">\\mathsf{NP}</span>, <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span>, that is carefully designed to work with our suite of techniques. Next, we build an interactive argument system for <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span>. We first show how to encode an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance as a sum-check instance. The verifier reduces the sum-check instance to checking an inner-product and polynomial equality, which in turn can be reduced into checking another (simpler) sum-check instance. The verifier repeats this interaction over several rounds to reduce the original statement into checking the Hadamard-product over vectors generated during interaction.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 14 (Algebraic Constraint Satisfiability Relation).</h6>

    <p class="text-gray-300">The Algebraic Constraint Satisfiability Relation (<span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span>) defined over field <span class="math">\\mathbb{F}</span>, instance size <span class="math">n</span>, witness size <span class="math">m</span>, and constraint size <span class="math">l</span> consists of matrices <span class="math">\\bm{M}_{1},\\ldots,\\bm{M}_{l}</span> in <span class="math">\\mathbb{F}^{n\\times n}</span>, and vector <span class="math">\\bm{x}\\in\\mathbb{F}^{n-m}</span>. A witness <span class="math">\\bm{w}\\in\\mathbb{F}^{m}</span> satisfies an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance if</p>

    <p class="text-gray-300"><span class="math">0=(\\bm{x},\\bm{w})\\bm{M}_{i}(\\bm{x},\\bm{w})^{\\top}\\quad\\forall i\\in\\{1,\\ldots,l\\}.</span></p>

    <p class="text-gray-300">We consider an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance sparse if there are <span class="math">O(n)</span> non-zero elements in all matrices <span class="math">M_{1},\\ldots,M_{l}</span>. We prove in supplementary section C that any relation in <span class="math">\\mathsf{NP}</span> can be reduced to a sparse <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction 6 (Argument System for Algebraic Constraint Satisfiability). Consider a sparse <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance of size <span class="math">n</span> with witness of size <span class="math">m</span> and constraints indexed by subset <span class="math">H\\subseteq\\mathbb{F}</span>. Let this instance be defined by matrices <span class="math">\\bm{M}_{i}\\in\\mathbb{F}^{n\\times n}</span> for <span class="math">i\\in H</span> and input vector <span class="math">\\bm{x}</span>. Let subset <span class="math">K\\subseteq\\mathbb{F}</span> index the <em>non-zero</em> entries in <em>all</em> $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> matrices </span>\\{\\bm{M}_{i}\\}_{i\\in H}<span class="math">. For notational simplicity let </span>N=(1,\\ldots,n)<span class="math">. Suppose a prover would like to prove in zero-knowledge that it possesses a vector </span>\\bm{w}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">0=(\\bm{x},\\bm{w})\\bm{M}_{i}(\\bm{x},\\bm{w})^{\\top}\\quad\\forall i\\in H.</span> (3)</p>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">Precomputation Phase</h4>

    <p class="text-gray-300">In the one-time precomputation phase, both the prover and verifier encode an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> statement as a collection of polynomials. In practice these polynomials only need to be computed and committed to once by a trusted party and can be reused across different input vectors <span class="math">\\bm{x}</span>. While the prover must hold on to the full polynomials, the verifier only has to hold on to the corresponding (constant-sized) commitments.</p>

    <p class="text-gray-300">In order to efficiently check an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance using standard algebraic techniques, both the prover and verifier encode matrices <span class="math">\\bm{M}_{i}</span> for <span class="math">i\\in H</span> as polynomials: For <span class="math">k\\in K</span> let polynomial <span class="math">\\mathsf{A}(k):K\\to H</span> return the particular matrix that <span class="math">k</span> is associated with. Similiarly, let <span class="math">\\mathsf{B}(k):K\\to N</span> return the particular row that <span class="math">k</span> is associated with and let <span class="math">\\mathsf{C}(k):K\\to N</span> return the particular column that <span class="math">k</span> is associated with. Finally, let <span class="math">\\mathsf{V}(k):K\\to\\mathbb{F}</span> return the value associated with index <span class="math">k</span>. Next, the prover and verifier compute commitments to polynomials <span class="math">\\mathsf{A}</span>, <span class="math">\\mathsf{B}</span>, <span class="math">\\mathsf{C}</span>, and <span class="math">\\mathsf{V}</span>. We stress that these polynomials are represented as vectors of evaluations throughout the argument and therefore do not need to be interpolated. As shown by Chiesa et al. <em>[28]</em>, polynomials <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C},\\mathsf{V}</span> allow us to encode matrices <span class="math">\\bm{M}_{a}</span> for <span class="math">a\\in H</span> as follows</p>

    <p class="text-gray-300"><span class="math">\\bm{M}_{a}[b,c]=\\sum_{k\\in K}u_{H}(a,\\mathsf{A}(k))\\cdot u_{N}(b,\\mathsf{B}(k))\\cdot u_{N}(c,\\mathsf{C}(k))\\cdot\\mathsf{V}(k).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that bivariate polynomial <span class="math">u_{H}(X,Y):H\\times H\\to\\mathbb{F}</span> returns non-zero if <span class="math">X=Y</span> and <span class="math">0</span> otherwise (Definition 6), and can be efficiently computed when <span class="math">H</span> is a multiplicative subgroup. For this reason index sets <span class="math">H</span>, and <span class="math">N</span> should be multiplicative subgroups for efficiency purposes. We also recognize that each variable has a single associated constraint in practice (i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">). This allows us to use the same subgroup to index both variables and constraints. For notational simplicity we define polynomial </span>P(k,a,b,c)$ as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P(k,a,b,c)\\coloneqq u_{H}(a,\\mathsf{A}(k))\\cdot u_{N}(b,\\mathsf{B}(k))\\cdot u_{N}(c,\\mathsf{C}(k))\\cdot\\mathsf{V}(k).</span></p>

    <p class="text-gray-300">At the end of the precomputation phase the prover holds on to polynomials <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C},\\mathsf{V}</span> and the verifier holds on to the corresponding commitments.</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">Argument Phase:</h4>

    <p class="text-gray-300">Let <span class="math">z</span> be the evaluation-based polynomial encoding for vector <span class="math">(\\bm{x},\\bm{w})</span> (i.e. <span class="math">z(i)=(\\bm{x},\\bm{w})_{i}</span> for all <span class="math">i\\in N</span>) Given the polynomial encodings, we first define</p>

    <p class="text-gray-300"><span class="math">Q(a)\\coloneqq\\sum_{b\\in N}\\sum_{c\\in N}\\sum_{k\\in K}P(k,a,b,c)z(b)z(c)</span></p>

    <p class="text-gray-300">and observe that equation 3 is true if and only if</p>

    <p class="text-gray-300"><span class="math">0=Q(a)\\quad\\forall a\\in H</span> (4)</p>

    <p class="text-gray-300">From the setup phase, the prover and verifier both have access to commitments to <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C},\\mathsf{V}</span>, <span class="math">v_{H}</span>, <span class="math">v_{N}</span>, <span class="math">v_{K}</span>, and <span class="math">v_{[n-m]}</span> represented as vectors of evaluations. The prover additionally has access to the underlying evaluation vectors for polynomials <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C},\\mathsf{V}</span> generated during the setup phase, and <span class="math">v_{H}</span>, <span class="math">v_{N}</span>, <span class="math">v_{K}</span>, and <span class="math">v_{[n-m]}</span> computed once globally by the generator. To begin the argument the prover sends extractible and hiding evaluation-based commitment to polynomial <span class="math">z</span>. Before checking equation 4 the verifier needs to check that <span class="math">\\bm{x}</span> has been correctly encoded in the prover’s commitment. To assist the verifier with this check, the prover additionally sends a commitment to evaluations of “shifted” witness polynomial (<em>[28]</em>), <span class="math">w^{\\prime}</span> such that for all <span class="math">i\\in[n-m+1,n]</span></p>

    <p class="text-gray-300"><span class="math">w^{\\prime}(i)=\\frac{\\bm{w}_{i}-\\bm{x}_{i}}{v_{[n-m]}(i)}</span></p>

    <p class="text-gray-300">where <span class="math">v_{[n-m]}</span> is the vanishing polynomial for the range <span class="math">[n-m]</span>. We observe that if the prover correctly computes <span class="math">w^{\\prime}</span>, we have</p>

    <p class="text-gray-300"><span class="math">z(X)=w^{\\prime}(X)v_{[n-m]}(X)+\\bm{x}(X)</span> (5)</p>

    <p class="text-gray-300">Additionally, equation 5 ensures that <span class="math">z(h)=\\bm{x}(h)</span> for <span class="math">h\\in[n-m]</span>, thus ensuring that <span class="math">\\bm{x}</span> has been embedded correctly. Thus the verifier can check that <span class="math">z</span> agrees with <span class="math">w^{\\prime}</span> and <span class="math">\\bm{x}</span> by accepting negligible soundness error, picking random <span class="math">\\tau\\in\\mathbb{F}</span>, and checking</p>

    <p class="text-gray-300"><span class="math">z(\\tau)=w^{\\prime}(\\tau)v_{[n-m]}(\\tau)+\\bm{x}(\\tau)</span></p>

    <p class="text-gray-300">In particular the verifier uses a polynomial evaluation argument to obtain commitments to <span class="math">z(\\tau)</span>, <span class="math">w^{\\prime}(\\tau)</span>, and <span class="math">v_{[n-m]}(\\tau)</span>, and then uses a standard product argument to check that the appropriate relationship holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To check equation 4, we first observe that polynomial <span class="math">P(k,a,b,c)</span> is degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> in </span>a<span class="math">, which implies that </span>Q(a)<span class="math"> is degree </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> in </span>a<span class="math">. Therefore, to check equation 4, it suffices to check that </span>Q<span class="math"> is the zero polynomial. To do so, the verifier accepts negligible soundness error, picks random </span>\\alpha\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{F}</span>, and checks</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">0=Q(\\alpha).</span></p>

    <p class="text-gray-300">By definition this requires the verifier check</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{b\\in N}\\sum_{c\\in N}\\sum_{k\\in K}P(k,\\alpha,b,c)z(b)z(c).</span> (6)</p>

    <p class="text-gray-300">The verifier can rewrite equation 6 as</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{b\\in N}z(b)\\sum_{c\\in N}\\sum_{k\\in K}P(k,\\alpha,b,c)z(c).</span> (7)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to assist the verifier in checking equation 7 the prover can (efficiently <em>[28]</em>) compute and commit to evaluations of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{1}(X)=\\sum_{c\\in N}\\sum_{k\\in K}P(k,\\alpha,X,c)z(c).</span> (8)</p>

    <p class="text-gray-300">We describe the prover’s specific technique for computing <span class="math">P_{1}</span> in supplementary section E. The verifier is now tasked with checking</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{b\\in N}z(b)P_{1}(b)</span> (9)</p>

    <p class="text-gray-300">and checking that equation 8 holds. Because both <span class="math">z</span> and <span class="math">P_{1}</span> are represented and committed to using their evaluation vectors, we know that the right-hand side of equation 9 is precisely the inner-product of the evaluation vectors. Therefore the verifier can use a proof of inner-product to check equation 9. What remains is for the verifier to check that equation 8 holds.</p>

    <p class="text-gray-300">To do so, the verifier accepts negligible soundness error, picks random <span class="math">\\beta\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}$, and reduces the task of checking equation 8 to the task of checking</p>

    <p class="text-gray-300"><span class="math">P_{1}(\\beta)=\\sum_{c\\in N}\\sum_{k\\in K}P(k,\\alpha,\\beta,c)z(c).</span> (10)</p>

    <p class="text-gray-300">The verifier can rewrite equation 10 as</p>

    <p class="text-gray-300"><span class="math">P_{1}(\\beta)=\\sum_{c\\in N}z(c)\\sum_{k\\in K}P(k,\\alpha,\\beta,c).</span> (11)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to assist the verifier in checking equation 11 the prover can efficiently compute and commit to evaluations of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{2}(X)=\\sum_{k\\in K}P(k,\\alpha,\\beta,X).</span> (12)</p>

    <p class="text-gray-300">The verifier is now tasked with checking</p>

    <p class="text-gray-300"><span class="math">P_{1}(\\beta)=\\sum_{c\\in N}z(c)P_{2}(c)</span> (13)</p>

    <p class="text-gray-300">and checking that equation 12 holds. The verifier can evaluate <span class="math">P_{1}(\\beta)</span> using a polynomial evaluation argument. Then, as observed earlier, the verifier can check equation 13 by checking the inner-product of the evaluation vectors of <span class="math">z</span> and <span class="math">P_{2}</span>. What remains is for the verifier to check equation 12 holds.</p>

    <p class="text-gray-300">To do so, the verifier accepts negligible soundness error, picks random <span class="math">\\gamma\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}$, and reduces the task of checking equation 12 to the task of checking</p>

    <p class="text-gray-300"><span class="math">P_{2}(\\gamma)=\\sum_{k\\in K}P(k,\\alpha,\\beta,\\gamma).</span> (14)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While the degree of <span class="math">P</span> in <span class="math">k</span> is $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the prover can efficiently compute and commit to evaluations of degree </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> polynomial </span>P_{3}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">P_{3}(k)=P(k,\\alpha,\\beta,\\gamma)\\quad\\forall k\\in K.</span> (15)</p>

    <p class="text-gray-300">The verifier is now tasked with checking</p>

    <p class="text-gray-300"><span class="math">P_{2}(\\gamma)=\\sum_{k\\in K}P_{3}(k)</span> (16)</p>

    <p class="text-gray-300">and checking that equation 15 holds. The verifier can evaluate <span class="math">P_{2}(\\gamma)</span> using a polynomial evaluation argument. Then the verifier can check equation 16 by checking the dot product of the evaluation vectors <span class="math">P_{3}</span> and <span class="math">\\mathbf{1}=(1,1,\\ldots,1)</span>. To check equation 15, we observe due to Chiesa et al. <em>[28]</em> that</p>

    <p class="text-gray-300"><span class="math">P(k,\\alpha,\\beta,\\gamma)</span> <span class="math">=u_{H}(\\alpha,\\mathsf{A}(k))\\cdot u_{N}(\\beta,\\mathsf{B}(k))\\cdot u_{N}(\\gamma,\\mathsf{C}(k))\\cdot\\mathsf{V}(k)</span> <span class="math">=\\frac{(v_{H}(\\alpha)-v_{H}(\\mathsf{A}(k))\\cdot(v_{N}(\\beta)-v_{N}(\\mathsf{B}(k)))\\cdot(v_{N}(\\gamma)-v_{N}(\\mathsf{C}(k)))\\cdot\\mathsf{V}(k)}{(\\alpha-\\mathsf{A}(k))(\\beta-\\mathsf{B}(k))(\\gamma-\\mathsf{C}(k))}</span> <span class="math">=\\frac{v_{H}(\\alpha)v_{N}(\\beta)v_{N}(\\gamma)\\mathsf{V}(k)}{(\\alpha-\\mathsf{A}(k))(\\beta-\\mathsf{B}(k))(\\gamma-\\mathsf{C}(k))}</span></p>

    <p class="text-gray-300">where the last equality holds because polynomials <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C}</span> map elements of <span class="math">K</span> to <span class="math">H</span> and <span class="math">N</span>. Therefore, the verifier can check equation 15 by checking</p>

    <p class="text-gray-300"><span class="math">P_{3}(k)(\\alpha-\\mathsf{A}(k))(\\beta-\\mathsf{B}(k))(\\gamma-\\mathsf{C}(k))=v_{H}(\\alpha)v_{N}(\\beta)v_{N}(\\gamma)\\mathsf{V}(k)\\quad\\forall k\\in K.</span> (17)</p>

    <p class="text-gray-300">The prover and verifier can efficiently compute commitments to <span class="math">\\mathsf{A}^{\\prime}(k)=\\alpha-\\mathsf{A}(k)</span>, <span class="math">\\mathsf{B}^{\\prime}(k)=\\beta-\\mathsf{B}(k)</span>, and <span class="math">\\mathsf{C}^{\\prime}(k)=\\gamma-\\mathsf{C}(k)</span>. The verifier can invoke a polynomial evaluation argument to evaluate <span class="math">v_{H}(\\alpha),v_{N}(\\beta),v_{N}(\\gamma)</span>, and the prover and verifier can compute the commitment to <span class="math">\\mathsf{V}^{\\prime}(k)=v_{H}(\\alpha)v_{N}(\\beta)v_{N}(\\gamma)\\mathsf{V}(k)</span>. Equation 17 can be rewritten as</p>

    <p class="text-gray-300"><span class="math">P_{3}(k)\\mathsf{A}^{\\prime}(k)\\mathsf{B}^{\\prime}(k)\\mathsf{C}^{\\prime}(k)=\\mathsf{V}^{\\prime}(k)\\quad\\forall k\\in K.</span> (18)</p>

    <p class="text-gray-300">The verifier can then check equation 18 using a proof of multi-Hadamard-product (construction 5).</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Construction 6 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> that satisfies completeness, knowledge-soundness, and honest-verifier zero-knowledge. Additionally, for a sparse size <span class="math">n</span> <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance with input vector size <span class="math">x</span>, Construction 6 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover and an <span class="math">O_{\\lambda}(\\log n+x)</span> verifier.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We formally prove Theorem 5 in supplementary section D.6. Intuitively, the stated asymptotic properties hold because the prover only makes use of linear-time sub-arguments. We provide more details on how the prover can compute polynomials <span class="math">P_{1},P_{2}</span>, and <span class="math">P_{3}</span> efficiently in supplementary section E. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">6 Achieving a Constant-Time Verifier</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Construction 7 (A Constant-Time Verifier).</h4>

    <p class="text-gray-300">The verifier’s work for Construction 6 is nearly constant-time, with the exception of the verifier’s logarithmic-time work for the inner-product arguments (Construction 3). We achieve a constant-time verifier by outsourcing it’s logarithmic work represented as a circuit using an argument system for general computation with a constant-time verifier and a quasi-linear prover (e.g. Pinocchio <em>[58]</em>).</p>

    <p class="text-gray-300">To preserve the desired asymptotic goals, we must ensure that the outsourced circuit is sub-linear and has a constant sized verifier input. In addition we must ensure that the circuit representing the verifiers work is concretely small. These constraints make it difficult to generically apply verification outsourcing to existing systems with a linear prover, which would involve either outsourcing a logarithmic number of pairings or <span class="math">O(\\sqrt{n})</span> group operations <em>[62, 63]</em>.</p>

    <p class="text-gray-300">Our solution is to design a hybrid verifier that can perform all of its pairing checks locally, and only outsource a logarithmic number of group operations which are significantly cheaper than pairings. In particular, recall that the verifier’s logarithmic work can be broken down into three distinct tasks: (1) Sample randomness <span class="math">x</span> for a logarithmic number of rounds. (2) Compute commitments <span class="math">A^{\\prime},B^{\\prime},C^{\\prime}</span> over a logarithmic number of rounds. (3) During the subprotocol to check the <span class="math">v</span> and <span class="math">w</span> terms, compute <span class="math">f_{v}(z)</span> and <span class="math">f_{w}(z)</span> for some challenge point <span class="math">z</span>. To ensure that the verifier’s input to the verification circuit is constant-sized, we instantiate the random oracle with an algebraic hash function <em>[45, 1]</em>, and have the circuit simulate the verifier’s randomness via the Fiat-Shamir heuristic <em>[35]</em>:</p>

    <p class="text-gray-300"><span class="math">O(\\log^{2}n)</span> Circuit to Outsource Verifier’s Inner-Product Checks:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\ell=\\log n</span> denote the total number rounds in the inner-product argument. The verifier’s input consists of commitments <span class="math">A,B,C\\in\\mathbb{G}</span> which represent the statement for the inner-product argument. The prover’s input consists of all logarithmic number of commitments <span class="math">A_{Li},A_{Ri},B_{Li},B_{Ri},C_{Li},C_{Ri}\\in\\mathbb{G}</span> terms for <span class="math">i\\in\\{0,\\ldots,\\ell-1\\}</span> generated in each recursive round, and the terms <span class="math">(v,v^{\\prime})</span>, <span class="math">(w,w^{\\prime})</span> generated in the final round. Initially set <span class="math">A_{0}=A</span>, <span class="math">B_{0}=B</span>, and <span class="math">C_{0}=C</span>.</li>

      <li>For <span class="math">i\\in\\{0,\\ldots,\\ell-1\\}</span> compute randomness <span class="math">x_{i}=\\mathsf{hash}(A_{Li},A_{Ri},B_{Li},B_{Ri},C_{Li},C_{Ri})</span> and compute the resulting commitments</li>

    </ol>

    <p class="text-gray-300"><span class="math">A_{i+1}=A_{Li}^{x_{i}}\\cdot A_{i}\\cdot A_{Ri}^{x_{i}^{-1}},\\quad B_{i+1}=B_{Li}^{x_{i}}\\cdot B_{i}\\cdot B_{Ri}^{x_{i}^{-1}},\\quad C_{i+1}=C_{Li}^{x_{i}}\\cdot C_{i}\\cdot C_{Ri}^{x_{i}^{-1}}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the verifier’s final challenge, <span class="math">z=\\mathsf{hash}(A_{\\ell},B_{\\ell},C_{\\ell},(v,v^{\\prime}),(w,w^{\\prime}))</span></li>

      <li>Compute <span class="math">f_{v}(z)</span> and <span class="math">f_{w}(z)</span> as defined in Construction 3 in a logarithmic number of exponentiations, and output <span class="math">A_{\\ell}</span>, <span class="math">B_{\\ell}</span>, <span class="math">C_{\\ell}</span>, <span class="math">f_{v}(z)</span>, <span class="math">f_{w}(z)</span>.</li>

    </ol>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">Acknowledgements</h3>

    <p class="text-gray-300">We thank Vipul Goyal, Andrew Miller, and Dario Fiore for insightful comments on earlier versions of this work.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Efficient symmetric primitives for advanced cryptographic protocols (a marvellous contribution). IACR Cryptol. ePrint Arch. 2019</li>

      <li>[2] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: CCS (2017)</li>

      <li>[3] Arora, S., Safra, S.: Probabilistic checking of proofs: A new characterization of NP. JACM 45(1) (1998)</li>

      <li>[4] Ateniese, G., Goodrich, M.T., Lekakis, V., Papamanthou, C., Paraskevas, E., Tamassia, R.: Accountable storage. In: ACNS (2017)</li>

      <li>[5] Babai, L.: Trading group theory for randomness. In: STOC (1985)</li>

      <li>[6] Bayer, S.G.M.: Practical Zero-Knowledge Protocols based on the Discrete Logarithm Assumption. Ph.D. thesis, University College London (2014)</li>

      <li>[7] Ben-Or, M., Goldreich, O., Goldwasser, S., Håstad, J., Kilian, J., Micali, S., Rogaway, P.: Everything provable is provable in zero-knowledge. In: CRYPTO (1988)</li>

      <li>[8] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046 (2018)</li>

      <li>[9] Ben-Sasson, E., Chiesa, A., Goldberg, L., Gur, T., Riabzev, M., Spooner, N.: Linear-size constant-query IOPs for delegating computation. In: TCC (2019)</li>

      <li>[10] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for R1CS. In: EUROCRYPT (2019)</li>

      <li>[11] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: TCC (2016)</li>

      <li>[12] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. Algorithmica 79(4) (2017)</li>

      <li>[13] Berrut, J.P., Trefethen, L.N.: Barycentric Lagrange interpolation. SIREV 46(3) (2004)</li>

      <li>[14] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: ITCS (2012)</li>

      <li>[15] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for snarks and proof-carrying data. In: STOC (2013)</li>

      <li>[16] Bitansky, N., Canetti, R., Paneth, O., Rosen, A.: On the existence of extractable one-way functions. SICOMP 45(5) (2016)</li>

      <li>[17] Boneh, D., Boyen, X.: Short signatures without random oracles. In: EUROCRYPT (2004)</li>

      <li>[18] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo infinite: Recursive zk-snarks from any additive polynomial commitment scheme. Tech. rep., Cryptology ePrint Archive, Report 2020/1536 (2020)</li>

    </ul>

    <p class="text-gray-300">[19] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: EUROCRYPT (2016)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] Bootle, J., Chiesa, A., Groth, J.: Linear-time arguments with sublinear verification from tensor codes. In: TCC (2020)</li>

      <li>[21] Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof composition without a trusted setup. IACR Cryptol. ePrint Arch. 2019</li>

      <li>[22] Boyle, E., Pass, R.: Limits of extractability assumptions with distributional auxiliary input. In: ASIACRYPT (2015)</li>

      <li>[23] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: IEEE S&P (2018)</li>

      <li>[24] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments (2020)</li>

      <li>[25] Bünz, B., Fisch, B., Szepieniec, A.: Transparent SNARKs from DARK compilers. In: EUROCRYPT (2020)</li>

      <li>[26] Bünz, B., Maller, M., Mishra, P., Vesely, N.: Proofs for inner pairing products and applications. Cryptology ePrint Archive, Report 2019/1177 (2019)</li>

      <li>[27] Chase, M., Derler, D., Goldfeder, S., Orlandi, C., Ramacher, S., Rechberger, C., Slamanig, D., Zaverucha, G.: Post-quantum zero-knowledge and signatures from symmetric-key primitives. In: CCS (2017)</li>

      <li>[28] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In: EUROCRYPT (2020)</li>

      <li>[29] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: EUROCRYPT (2020)</li>

      <li>[30] Chiesa, A., Tromer, E.: Proof-carrying data and hearsay arguments from signature cards. In: ICS (2010)</li>

      <li>[31] Cormode, G., Mitzenmacher, M., Thaler, J.: Practical verified computation with streaming interactive proofs. In: ITCS (2012)</li>

      <li>[32] Costello, C., Fournet, C., Howell, J., Kohlweiss, M., Kreuter, B., Naehrig, M., Parno, B., Zahur, S.: Geppetto: Versatile verifiable computation. In: 2015 IEEE Symposium on Security and Privacy (2015)</li>

      <li>[33] Danezis, G., Fournet, C., Groth, J., Kohlweiss, M.: Square span programs with applications to succinct NIZK arguments. In: ASIACRYPT (2014)</li>

      <li>[34] Delignat-Lavaud, A., Fournet, C., Kohlweiss, M., Parno, B.: Cinderella: Turning shabby X. 509 certificates into elegant anonymous credentials with the magic of verifiable computation. In: IEEE S&P (2016)</li>

      <li>[35] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: EUROCRYPT (1986)</li>

      <li>[36] Fiore, D., Fournet, C., Ghosh, E., Kohlweiss, M., Ohrimenko, O., Parno, B.: Hash first, argue later: Adaptive verifiable computations on outsourced data. In: CCS (2016)</li>

      <li>[37] Fuchsbauer, G., Kiltz, E., Loss, J.: The algebraic group model and its applications. In: CRYPTO (2018)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[38] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. IACR Cryptol. ePrint Arch. (2019)</li>

      <li>[39] Gennaro, R., Gentry, C., Parno, B.: Non-interactive verifiable computing: Outsourcing computation to untrusted workers. In: CRYPTO (2010)</li>

      <li>[40] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT (2013)</li>

      <li>[41] Giacomelli, I., Madsen, J., Orlandi, C.: ZKBoo: Faster zero-knowledge for boolean circuits. In: USENIX (2016)</li>

      <li>[42] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating computation: Interactive proofs for muggles. JACM 62(4) (2015)</li>

      <li>[43] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SICOMP 18(1) (1989)</li>

      <li>[44] Goyal, V.: Reducing trust in the PKG in identity based cryptosystems. In: CRYPTO (2007)</li>

      <li>[45] Grassi, L., Khovratovich, D., Roy, A., Rechberger, C., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. In: USENIX (2020)</li>

      <li>[46] Groth, J.: Linear algebra with sub-linear zero-knowledge arguments. In: CRYPTO (2009)</li>

      <li>[47] Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT (2016)</li>

      <li>[48] Groth, J., Ishai, Y.: Sub-linear zero-knowledge argument for correctness of a shuffle. In: EUROCRYPT (2008)</li>

      <li>[49] Groth, J., Kohlweiss, M., Maller, M., Meiklejohn, S., Miers, I.: Updatable and universal common reference strings with applications to zk-snarks. In: CRYPTO (2018)</li>

      <li>[50] Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure multiparty computation. In: STOC (2007)</li>

      <li>[51] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASIACRYPT (2010)</li>

      <li>[52] Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In: IEEE S&amp;P (2016)</li>

      <li>[53] Lee, J., Setty, S., Thaler, J., Wahby, R.: Linear-time zero-knowledge snarks for R1CS. Cryptology ePrint Archive, Report 2021/030 (2021)</li>

      <li>[54] Lindell, Y.: Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology 16(3) (2003)</li>

      <li>[55] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. JACM 39(4) (1992)</li>

      <li>[56] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In: CCS (2019)</li>

      <li>[57] Papamanthou, C., Shi, E., Tamassia, R.: Signatures of correct computation. In: TCC (2013)</li>

    </ul>

    <p class="text-gray-300">[58] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: IEEE S&P (2013)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[59] Pippenger, N.: On the evaluation of powers and related problems. In: SFCS (1976)</li>

      <li>[60] Sasson, E.B., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized anonymous payments from Bitcoin. In: IEEE S&P (2014)</li>

      <li>[61] Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. JACM 27(4) (1980)</li>

      <li>[62] Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: CRYPTO (2020)</li>

      <li>[63] Setty, S., Lee, J.: Quarks: Quadruple-efficient transparent zksnarks. Tech. rep., Cryptology ePrint Archive, Report 2020/1275 (2020)</li>

      <li>[64] Tomescu, A., Abraham, I., Buterin, V., Drake, J., Feist, D., Khovratovich, D.: Aggregatable subvector commitments for stateless cryptocurrencies. In: International Conference on Security and Cryptography for Networks (2020)</li>

      <li>[65] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: TCC (2008)</li>

      <li>[66] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: CCS (2017)</li>

      <li>[67] Wahby, R.S., Setty, S.T., Ren, Z., Blumberg, A.J., Walfish, M.: Efficient RAM and control flow in verifiable outsourced computation. In: NDSS (2015)</li>

      <li>[68] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: IEEE S&P (2018)</li>

      <li>[69] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: CRYPTO (2019)</li>

      <li>[70] Zhang, J., Xie, T., Zhang, Y., Song, D.: Transparent polynomial delegation and its applications to zero knowledge proof. In: IEEE S&P (2020)</li>

      <li>[71] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A zero-knowledge version of vSQL. Cryptology ePrint Archive, Report 2017/1146 (2017)</li>

      <li>[72] Zhao, Z., Chan, T.H.H.: How to vote privately using Bitcoin. In: ICICS (2015)</li>

    </ul>

    <p class="text-gray-300">Supplementary Materials</p>

    <h2 id="sec-61" class="text-2xl font-bold">Appendix A An Argument System for Simple Product</h2>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">Construction 8 (Argument System for Simple Product)</h3>

    <p class="text-gray-300">Both the prover and verifier are provided with commitment keys <span class="math">v,w,g,h,</span> and commitments <span class="math">A,B,C</span>. The prover is additionally provided witness <span class="math">a,b,c,r_{a},r_{b},r_{c}</span>. An argument system for simple product allows a prover to show that</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=v^{a}h^{r_{a}}</span> <span class="math">B</span> <span class="math">=w^{b}h^{r_{b}}</span> <span class="math">C</span> <span class="math">=g^{c}h^{r_{c}}</span></p>

    <p class="text-gray-300">and that <span class="math">a\\cdot b=c</span>. We present a simplified variant of a protocol presented by Bunz et al. <em>[23]</em>:</p>

    <p class="text-gray-300">Subprotocol to check product: Both the prover and verifier are provided with commitment keys <span class="math">v,w,g,h,</span> and commitments <span class="math">A,B,C</span>. The prover is additionally provided witness <span class="math">a,b,c,r_{a},r_{b},r_{c}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples blinding terms <span class="math">s_{a},s_{b}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>, and randomness <span class="math">\\rho\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and a commitment to the randomness <span class="math">S=v^{s_{a}}\\cdot w^{s_{b}}\\cdot h^{\\rho}</span>. Additionally the prover samples randomness <span class="math">\\tau_{1},\\tau_{2}\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and computes commitments to the error terms</li>

    </ol>

    <p class="text-gray-300"><span class="math">T_{1}</span> <span class="math">=g^{s_{a}b+as_{b}}\\cdot h^{\\tau_{1}}</span> <span class="math">T_{2}</span> <span class="math">=g^{s_{a}s_{b}}\\cdot h^{\\tau_{2}}.</span></p>

    <p class="text-gray-300">Finally the prover sends <span class="math">S,T_{1},T_{2}</span> to the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier responds with challenge <span class="math">z\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>.</li>

      <li>The prover computes</li>

    </ol>

    <p class="text-gray-300"><span class="math">a^{\\prime}</span> <span class="math">=a+s_{a}\\cdot z</span> <span class="math">b^{\\prime}</span> <span class="math">=b+s_{b}\\cdot zc^{\\prime}</span> <span class="math">=a^{\\prime}\\cdot b^{\\prime}</span></p>

    <p class="text-gray-300">Additionally the prover computes aggregated randomness terms</p>

    <p class="text-gray-300"><span class="math">\\tau=\\tau_{2}\\cdot z^{2}+\\tau_{1}\\cdot z+r_{c}</span> <span class="math">\\mu=(r_{a}+r_{b})+\\rho\\cdot z.</span></p>

    <p class="text-gray-300">The prover sends <span class="math">\\tau,\\mu,a^{\\prime},b^{\\prime},c^{\\prime}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier first checks that <span class="math">c^{\\prime}</span> agrees with <span class="math">C</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">g^{c^{\\prime}}h^{\\tau}\\stackrel{{\\scriptstyle\\ref{eq:1:1:1}}}{{=}}C\\cdot T_{1}^{z}\\cdot T_{2}^{z^{2}}.</span></p>

    <p class="text-gray-300">Next the verifier checks that <span class="math">a&#x27;</span> and <span class="math">b&#x27;</span> agree with <span class="math">A</span> and <span class="math">B</span>:</p>

    <div class="my-4 text-center"><span class="math-block">A \\cdot B \\cdot S ^ {z} \\stackrel {?} {=} v ^ {a ^ {\\prime}} w ^ {b ^ {\\prime}} \\cdot h ^ {\\mu}.</span></div>

    <p class="text-gray-300">Finally the verifier checks that the product relation holds:</p>

    <div class="my-4 text-center"><span class="math-block">c ^ {\\prime} \\stackrel {?} {=} a ^ {\\prime} \\cdot b ^ {\\prime}</span></div>

    <h2 id="sec-63" class="text-2xl font-bold">B An Argument System for Multi-Hadamard Product</h2>

    <p class="text-gray-300"><strong>Construction 9 (Argument System for Multi-Hadamard Product).</strong> Consider group <span class="math">\\mathbb{G}</span> of order <span class="math">p</span> and let <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>. An argument system for the multi-Hadamard production relation defined over vector size <span class="math">n</span>, and instance size <span class="math">m</span>, allows a prover to show that for commitments <span class="math">A_1, \\ldots, A_m</span> and commitment <span class="math">B</span>, it knows vectors <span class="math">\\boldsymbol{a}_1, \\ldots, \\boldsymbol{a}_m</span> and vector <span class="math">\\boldsymbol{b}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">A _ {i} = \\operatorname {c o m} (\\boldsymbol {a} _ {i})</span></div>

    <p class="text-gray-300">for all <span class="math">i\\in [m]</span></p>

    <div class="my-4 text-center"><span class="math-block">B = \\operatorname {c o m} (\\boldsymbol {b}),</span></div>

    <p class="text-gray-300">and <span class="math">\\boldsymbol{b} = \\boldsymbol{a}_1 \\circ \\boldsymbol{a}_2 \\circ \\ldots \\circ \\boldsymbol{a}_m</span>. Our construction composes the multi-Hadamard product argument system presented by Bayer [6] with the argument system for inner-product (Construction 4):</p>

    <p class="text-gray-300"><strong><Prover, Verifier="">:</strong></p>

    <p class="text-gray-300">The prover and verifier are provided with the statement consisting of a list of commitments <span class="math">A</span>, and commitment <span class="math">B</span>. The prover is additionally provided witness <span class="math">(\\{\\pmb{a}_i\\}_{i\\in [m]},\\{r_i\\}_{i\\in [m]},\\pmb {b},s)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initially the prover computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {b} _ {1} = \\boldsymbol {a} _ {1}, \\boldsymbol {b} _ {2} = \\boldsymbol {a} _ {1} \\circ \\boldsymbol {a} _ {2}, \\dots , \\boldsymbol {b} _ {m - 1} = \\boldsymbol {a} _ {1} \\circ \\dots \\circ \\boldsymbol {a} _ {m - 1}, \\boldsymbol {b} _ {m} = \\boldsymbol {b}.</span></div>

    <p class="text-gray-300">Now it is sufficient for the prover to show that for <span class="math">i \\in [m - 1]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {b} _ {i + 1} = \\boldsymbol {a} _ {i + 1} \\circ \\boldsymbol {b} _ {i} \\tag {19}</span></div>

    <p class="text-gray-300">so long as <span class="math">\\pmb{b}_1 = \\pmb{a}_1</span> and <span class="math">\\pmb{b}_m = \\pmb{b}</span>. Next the prover samples <span class="math">s_2, \\ldots, s_{m-1} \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and sets</p>

    <div class="my-4 text-center"><span class="math-block">B _ {2} = \\operatorname {c o m} (\\boldsymbol {b} _ {2}; s _ {2}), \\dots , B _ {m - 1} = \\operatorname {c o m} (\\boldsymbol {b} _ {m - 1}; s _ {m - 1}).</span></div>

    <p class="text-gray-300">The prover (and verifier) ensures that <span class="math">\\pmb{b}_1 = \\pmb{a}_1</span> and <span class="math">\\pmb{b}_m = \\pmb{b}</span> by setting <span class="math">B_1 = A_1</span> and <span class="math">B_m = B</span>. Finally the prover sends <span class="math">B_2, \\ldots, B_{m-1}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples and sends challenges <span class="math">x, y \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span></Prover,></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover can use randomness <span class="math">x</span> to simplify the argument by taking a random linear combination of the vectors: In particular, the prover can demonstrate that equation 19 holds with high probability by showing</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\sum_{i\\in[m-1]}x^{i}\\bm{b}_{i+1}=\\sum_{i\\in[m-1]}\\bm{a}_{i+1}\\circ(x^{i}\\bm{b}_{i}).</span> (20)</p>

    <p class="text-gray-300">To do so, the prover first computes vectors and associated randomness</p>

    <p class="text-gray-300"><span class="math">\\bm{d}_{i}=x^{i}\\bm{b}_{i}</span> <span class="math">\\bm{t}_{i}=x^{i}s_{i}\\quad\\forall i\\in[m-1]</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\bm{d}=\\sum_{i\\in[m-1]}x^{i}\\bm{b}_{i+1}</span> <span class="math">t=\\sum_{i\\in[m-1]}x^{i}s_{i+1}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, both the prover and verifier compute the corresponding commitments <span class="math">D_{i}=B_{i}^{x^{i}}</span> for all <span class="math">i\\in[m]</span> and <span class="math">D=\\prod_{i\\in[m-1]}B_{i+1}^{x^{i}}</span></li>

      <li>Now equation 20 can be rewritten as</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\bm{d}=\\sum_{i\\in[m-1]}\\bm{a}_{i+1}\\circ\\bm{d}_{i}</span> (21)</p>

    <p class="text-gray-300">To check that equation 21 holds with high probability, the verifier can engage in a zero argument (below) to check that</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{i\\in[m-1]}(\\bm{a}_{i+1}\\circ\\bm{y})\\cdot\\bm{d}_{i}-(\\bm{1}\\circ\\bm{y})\\cdot\\bm{d}.</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{y}=(y,y^{1},\\ldots,y^{n})</span>. In particular, the prover and verifier can first compute</p>

    <p class="text-gray-300"><span class="math">C_{-1}=\\mathsf{com}(-\\bm{1};0)</span></p>

    <p class="text-gray-300">and set the statement to be <span class="math">(A_{2},\\ldots,A_{m},C_{-1}),(D_{1},\\ldots,D_{m-1},D)</span>.</p>

    <p class="text-gray-300">The prover and verifier complete the multi-Hadamard product argument by engaging in an argument for the zero relation <em>[6]</em>. The zero relation (<span class="math">\\mathcal{R}_{\\mathsf{ZERO}}</span>) defined over vector size <span class="math">n</span>, and instance size <span class="math">m</span> consists of commitments <span class="math">A_{1},\\ldots,A_{m}</span> and commitments <span class="math">B_{0},\\ldots,B_{m-1}</span>, and scalar <span class="math">y\\in\\mathbb{F}</span>. Vectors <span class="math">\\bm{a}_{1},\\ldots,\\bm{a}_{m}</span> and <span class="math">\\bm{b}_{0},\\ldots,\\bm{b}_{m-1}</span> satisfy the zero relation if</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{i\\in[m]}(\\bm{a}_{i}\\circ\\bm{y})\\cdot\\bm{b}_{i-1}</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{y}=(y,y^{2},\\ldots,y^{m})</span>, and <span class="math">A_{i}=\\mathsf{com}(a_{i})</span> and <span class="math">B_{i-1}=\\mathsf{com}(b_{i-1})</span> for all <span class="math">i\\in[m]</span>.</p>

    <p class="text-gray-300">Using random linear combinations, Bayer’s argument for the zero relation reduces checking the original relation to checking that</p>

    <p class="text-gray-300"><span class="math">A=\\mathsf{com}(\\overline{\\bm{a}},\\overline{r})</span> (22)</p>

    <div class="my-4 text-center"><span class="math-block">B = \\operatorname {c o m} (\\bar {\\boldsymbol {b}}, \\bar {s}) \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">D = \\operatorname {c o m} \\left(\\left(\\bar {\\boldsymbol {a}} \\circ \\boldsymbol {y}\\right) \\cdot \\bar {\\boldsymbol {b}}, \\bar {t}\\right) \\tag {24}</span></div>

    <p class="text-gray-300">for commitments  <span class="math">A, B, D</span> , vectors  <span class="math">\\overline{\\mathbf{a}}, \\overline{\\mathbf{b}}, \\mathbf{y}</span>  and associated randomness  <span class="math">\\overline{r}, \\overline{s}, \\overline{t}</span>  generated during interaction. Our argument for the zero-relation is identical to the one presented by Bayer [6] with the exception that in the final round of Bayer's original argument the prover directly sends  <span class="math">\\overline{\\mathbf{a}}</span> ,  <span class="math">\\overline{r}</span> ,  <span class="math">\\overline{\\mathbf{b}}</span> ,  <span class="math">\\overline{s}</span>  and  <span class="math">\\overline{t}</span>  for the verifier to check. In our variant the verifier instead outsources this final check using an argument system for inner-product:</p>

    <p class="text-gray-300"><span class="math">\\langle \\text{Prover, Verifier} \\rangle</span> : The prover and verifier are provided with the statement consisting of lists of commitments  <span class="math">A, B</span>  and scalar  <span class="math">y</span> . The prover is additionally provided with witness  <span class="math">(\\{\\pmb{a}_i\\}_{i \\in [m]}, \\{r_i\\}_{i \\in [m]}, \\{\\pmb{b}_{i-1}\\}_{i \\in [m]}, \\{s_{i-1}\\}_{i \\in [m]})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover starts the argument by sampling blinding vectors  <span class="math">\\mathbf{a}_0, \\mathbf{b}_m \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^n</span>  and associated randomness  <span class="math">r_0</span>  and  <span class="math">s_m</span> . For  <span class="math">k \\in \\{0, \\dots, 2m\\}</span> , the prover computes</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">d_{k} = \\sum_{\\substack{0\\leq i,j\\leq m\\\\ j = (m - k) + i}}(\\boldsymbol{a}_{i}\\circ \\boldsymbol {y})\\cdot \\boldsymbol{b}_{j}</span></div>

    <p class="text-gray-300">where  <span class="math">\\pmb {y} = (y,y^{2},\\dots ,y^{n})</span>  . Next the prover samples randomness  <span class="math">t_0,\\ldots ,t_{2m + 1}\\stackrel {\\S}{\\leftarrow}</span> <span class="math">\\mathbb{F}</span>  and computes commitments</p>

    <div class="my-4 text-center"><span class="math-block">D _ {0} = \\operatorname {c o m} \\left(d _ {0}; t _ {0}\\right), \\dots , D _ {2 m} = \\operatorname {c o m} \\left(d _ {2 m}; t _ {2 m}\\right).</span></div>

    <p class="text-gray-300">Finally the prover sends  <span class="math">A_0, B_m</span>  and  <span class="math">D_0, \\ldots, D_{2m}</span>  to the verifier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier responds with challenge  <span class="math">x \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> .</li>

      <li>Using  <span class="math">x</span>  the prover computes a random linear combination of the witness vectors:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\boldsymbol {a}}} = \\sum_ {i = 0} ^ {m} x ^ {i} \\boldsymbol {a} _ {i} \\quad \\overline {{r}} = \\sum_ {i = 0} ^ {m} x ^ {i} r _ {i}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\boldsymbol {b}}} = \\sum_ {i = 0} ^ {m} x ^ {i} \\boldsymbol {b} _ {i} \\quad \\overline {{s}} = \\sum_ {i = 0} ^ {m} x ^ {i} s _ {i}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline {{d}} = \\sum_ {i = 0} ^ {2 m} x ^ {i} d _ {i} \\quad \\overline {{t}} = \\sum_ {i = 0} ^ {2 m} x ^ {i} t _ {i}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both the prover and the verifier compute the statement commitments</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">A = \\prod_ {i = 0} ^ {m} A _ {i} ^ {x ^ {i}} \\quad B = \\prod_ {i = 0} ^ {m} B _ {i} ^ {x ^ {i}} \\quad D = \\prod_ {i = 0} ^ {2 m} D _ {i} ^ {x ^ {i}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that  <span class="math">D_{m + 1} = \\mathsf{com}(0;0)</span> .</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally both the prover and verifier engage in an inner-product argument to convince the verifier that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {d} = (\\overline {{\\boldsymbol {a}}} \\circ \\boldsymbol {y}) \\cdot \\overline {{\\boldsymbol {b}}}</span></div>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Construction 9 is an argument system for <span class="math">\\mathcal{R}_{\\mathrm{MHADM}}</span> that satisfies knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By Bayer [6, Theorem 20] the core multi-Hadamard argument is knowledge sound so long as the underlying zero-argument is knowledge sound. We prove the knowledge soundness of our variant of the zero-argument using the knowledge soundness property of Bayer's original zero-argument [6, Theorem 21] and the knowledge soundness property of the underlying inner-product argument.</p>

    <p class="text-gray-300">In particular, given arbitrary prover <span class="math">\\mathcal{P}^*</span> we must construct an extractor <span class="math">\\mathcal{E}</span> such that for arbitrary statement consisting of vectors of commitments <span class="math">\\mathbf{A}</span>, <span class="math">\\mathbf{B}</span>, and scalar <span class="math">y</span>, if</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathcal {P} ^ {*} (\\boldsymbol {A}, \\boldsymbol {B}, y; \\rho), \\mathcal {V} (\\boldsymbol {A}, \\boldsymbol {B}, y) \\rangle = 1</span></div>

    <p class="text-gray-300">Then <span class="math">\\mathcal{E}(\\mathbf{A},\\mathbf{B},y;\\rho)</span> produces a witness consisting of lists of vectors <span class="math">\\{\\pmb {a}_i\\}_{i\\in [m]}</span>, <span class="math">\\{\\pmb {b}_{i - 1}\\}_{i\\in [m]}</span>, and associated lists of randomness <span class="math">\\{r_i\\}_{i\\in [m]}</span>, and <span class="math">\\{s_{i - 1}\\}_{i\\in [m]}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">A _ {i} = \\operatorname {c o m} \\left(\\boldsymbol {a} _ {i}, r _ {i}\\right) \\quad \\forall i \\in [ m ], \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">B _ {i - 1} = \\operatorname {c o m} \\left(\\boldsymbol {b} _ {i}, s _ {i}\\right) \\quad \\forall i \\in [ m ], \\tag {26}</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {i \\in [ m ]} \\left(\\boldsymbol {a} _ {i} \\circ \\boldsymbol {y}\\right) \\cdot \\boldsymbol {b} _ {i - 1} \\tag {27}</span></div>

    <p class="text-gray-300">with probability <span class="math">1 - \\mathsf{negl}(\\lambda)</span> Using <span class="math">\\mathcal{P}^<em></span> we construct a malicious prover for Bayer's zero-argument <span class="math">\\mathcal{P}_Z^</em></span> which succeeds in convincing the corresponding verifier <span class="math">\\mathcal{V}_Z</span> with the same probability. <span class="math">\\mathcal{E}</span> can then use <span class="math">\\mathcal{P}_Z^<em></span> to extract a valid witness. In more detail, <span class="math">\\mathcal{P}_Z^</em></span> behaves exactly like <span class="math">\\mathcal{P}^<em></span> with the exception of the final round. In the final round <span class="math">\\mathcal{P}^</em></span> engages in an inner product argument with <span class="math">\\mathcal{V}</span> over the statement <span class="math">(A,B,D,y)</span>. If <span class="math">\\mathcal{P}^<em></span> succeeds, by the knowledge soundness of the inner product argument <span class="math">\\mathcal{P}_Z^</em></span> can extract <span class="math">\\overline{a},\\overline{r},\\overline{b},\\overline{s},\\overline{t}</span> such that equations 22, 23, 24 hold. Thus in the final round <span class="math">\\mathcal{P}_Z^<em></span> can respond with these extracted terms to successfully convince <span class="math">\\mathcal{V}_Z^</em></span> that it holds a valid witness to the statement for Bayer's zero-argument. Then by the knowledge-soundness of Bayer's zero-argument, there exists an extractor <span class="math">\\mathcal{E}_Z</span> that can extract lists of vectors <span class="math">\\{\\pmb {a}_i\\}_{i\\in [m]}</span>, <span class="math">\\{\\pmb {b}_{i - 1}\\}_{i\\in [m]}</span>, and associated lists of randomness <span class="math">\\{r_i\\}_{i\\in [m]}</span>, and <span class="math">\\{s_{i - 1}\\}_{i\\in [m]}</span> such that equations 25, 26, 27 hold with probability <span class="math">1 - \\mathsf{negl}(\\lambda)</span>. Thus <span class="math">\\mathcal{E}</span> can use <span class="math">\\mathcal{E}_Z</span> to extract a valid witness with probability <span class="math">1 - \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">3 More precisely, Bayer's constructions are proven to be generalized special sound [6]. By the forking lemma [23], this implies witness-extended emulation [48, 54] which trivially implies our notion of knowledge soundness.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Construction 9 is an argument system for <span class="math">\\mathcal{R}_{\\text{\\tt MHADM}}</span> that is honest-verifier zero-knowledge</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows by the honest-verifier zero-knowledge property of the multi-Hadamard-product argument by Bayer <em>[6, Theorem 20]</em> and the honest-verifier zero-knowledge property of the inner-product argument for the Lagrange basis (Lemma 15). ∎</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 5 (Efficiency).</h6>

    <p class="text-gray-300">For <span class="math">m</span> vectors of size <span class="math">n</span>, Construction 9 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(nm^{2})</span> prover, and an <span class="math">O_{\\lambda}(\\log n+m)</span> verifier.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows by the properties discussed by Bayer and the asymptotics of the inner-product argument system (Construction 4). We provide more detail for the dominating concrete costs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: The generator’s cost consists of creating the structured reference string for the commitment scheme. When instantiated with our polynomial commitment scheme, the generators work is dominated by two multi-exponentiations of size <span class="math">n</span> which can be done in <span class="math">O(n/\\log n)</span> exponentiations by Pippenger’s algorithm <em>[59]</em>.</li>

      <li>Prover: To compute <span class="math">\\bm{b}_{1},\\ldots,\\bm{b}_{m}</span> the prover will need to compute <span class="math">nm</span> field multiplications. To compute <span class="math">B_{2},\\ldots,B_{m-1}</span> the prover will need to compute <span class="math">m</span> multi-exponentiations of size <span class="math">n</span>. To compute <span class="math">\\bm{d}_{i}</span> for <span class="math">i\\in[m-1]</span> and <span class="math">d</span> the prover will need to compute <span class="math">2nm</span> field multiplications. In the zero argument, to compute <span class="math">d_{k}</span> for <span class="math">i\\in\\{0,\\ldots,2m\\}</span> the prover will need to compute <span class="math">(m+1)^{2}\\cdot n</span> field multiplications. To compute <span class="math">D_{0},\\ldots,D_{2m}</span> the prover will need to compute <span class="math">4m</span> exponentiations. To compute <span class="math">\\overline{\\bm{a}}</span> and <span class="math">\\overline{\\bm{b}}</span> the prover will need to compute <span class="math">2mn</span> field multiplications. Finally the prover engages in an inner-product argument over <span class="math">\\overline{\\bm{a}}</span>, and <span class="math">\\overline{\\bm{b}}</span> which by Lemma 13 can be done in <span class="math">O(n)</span> time.</li>

      <li>Verifier: In the main argument, to compute <span class="math">D_{i}</span> for <span class="math">i\\in[m]</span> the verifier will need to compute <span class="math">m</span> exponentiations. In the zero argument, to compute <span class="math">A,B</span> and <span class="math">D</span> the verifier will need to compute <span class="math">4m</span> exponentiations total. Finally the verifier engages in an inner-product argument over commitments <span class="math">A,B</span> and <span class="math">D</span> which by Lemma 13 can be done in <span class="math">O(\\log n)</span> time.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-68" class="text-2xl font-bold">Appendix C Reducing Arithmetic Circuit Satisfiability to Algebraic Constraint Satisfiability</h2>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 15 (Arithmetic Circuit Satisfiability Relation).</h6>

    <p class="text-gray-300">The Arithmetic Circuit Satisfiability Relation (<span class="math">\\mathcal{R}_{\\text{\\tt CSAT}}</span>) defined over field <span class="math">\\mathbb{F}</span>, input size <span class="math">m</span>, witness size <span class="math">q</span>, output size <span class="math">p</span>, and constraint size <span class="math">n</span>, consists of arithmetic circuit <span class="math">\\mathcal{C}:\\mathbb{F}^{m+q}\\rightarrow\\mathbb{F}^{p}</span> consisting of <span class="math">n</span> gates, and vectors <span class="math">\\bm{x}\\in\\mathbb{F}^{m}</span>, <span class="math">\\bm{y}\\in\\mathbb{F}^{p}</span>. A witness <span class="math">\\bm{w}\\in\\mathbb{F}^{q}</span> satisfies an <span class="math">\\mathcal{R}_{\\text{\\tt CSAT}}</span> instance if <span class="math">\\mathcal{C}(\\bm{x},\\bm{w})=\\bm{y}</span></p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Any arithmetic circuit satisfiability instance over a circuit <span class="math">\\mathcal{C}</span> with <span class="math">n</span> gates can be reduced to a sparse <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance of size <span class="math">n+1</span> (Definition 14).</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider arithmetic circuit <span class="math">\\mathcal{C}</span> with <span class="math">n</span> canonically ordered gates, with public input vector <span class="math">\\bm{x}^{\\prime}</span>, output vector <span class="math">\\bm{y}^{\\prime}</span>, and witness vector <span class="math">\\bm{w}^{\\prime}</span>. We create an <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\bm{x}=(1,\\bm{x}^{\\prime},\\bm{y}^{\\prime})</span>.</li>

      <li>Including <span class="math">\\bm{w}^{\\prime}</span>, let <span class="math">\\bm{w}</span> be a canonically vector of all the computed gate values in <span class="math">\\mathcal{C}</span>.</li>

      <li>Create <span class="math">(n+1)\\times(n+1)</span> matrices <span class="math">M_{i}</span> for <span class="math">i\\in[n]</span> instantiated with zeros.</li>

      <li>For each gate <span class="math">i</span> let <span class="math">j</span> and <span class="math">k</span> be the indices of its left and right input gates. If gate <span class="math">i</span> is a multiplication gate set <span class="math">M_{i}[j,k]=1</span> and <span class="math">M_{i}[i,1]=-1</span>. Otherwise, if gate <span class="math">i</span> is an addition gate set <span class="math">M_{i}[j,1]=1</span>, <span class="math">M_{i}[k,1]=1</span>, and <span class="math">M_{i}[i,1]=-1</span></li>

      <li>Let the <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance be <span class="math">(\\{M_{i}\\}_{i\\in n},\\bm{x};\\bm{w})</span></li>

    </ol>

    <p class="text-gray-300">Intuitively each matrix <span class="math">M_{i}</span> captures the constraint of gate <span class="math">i</span>. In more detail, letting <span class="math">\\bm{z}=(\\bm{x},\\bm{w})</span>, we observe that if <span class="math">i</span> is a multiplication gate</p>

    <p class="text-gray-300"><span class="math">\\bm{z}\\bm{M}_{i}\\bm{z}^{\\top}=z_{j}\\cdot z_{k}+(z_{i}\\cdot-1).</span></p>

    <p class="text-gray-300">Similiarly if <span class="math">i</span> is an addition gate</p>

    <p class="text-gray-300"><span class="math">\\bm{z}\\bm{M}_{i}\\bm{z}^{\\top}=z_{j}\\cdot 1+z_{k}\\cdot 1+(z_{i}\\cdot-1)</span></p>

    <p class="text-gray-300">Thus <span class="math">\\bm{w}</span> satisfies the constructed <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance if and only if it satisfies the provided arithmetic circuit satisfiability instance. By design, each matrix is of size <span class="math">(n+1)\\times(n+1)</span> therefore the resulting <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> size is <span class="math">(n+1)</span>. Additionally there are a total of <span class="math">n</span> matrices and each matrix <span class="math">M_{i}</span> contains either <span class="math">2</span> non-zero values if <span class="math">i</span> is a multiplication gate, or <span class="math">3</span> non-zero values if <span class="math">i</span> is an addition gate. Therefore there are a total of <span class="math">O(n)</span> non-zero values in all <span class="math">n</span> matrices, implying that the constructed <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance is sparse. ∎</p>

    <h2 id="sec-72" class="text-2xl font-bold">Appendix D Deferred Proofs</h2>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">D.1 Justification of Assumption 4 (<span class="math">n</span>-EPKE for a Linearly Independent Basis)</h3>

    <p class="text-gray-300">We reproduce the <span class="math">n</span>-EPKE assumption from Zhang et al. below. Next we show that our variant, the <span class="math">n</span>-EPKE assumption for the linear basis (Assumption 4) is equivalent to that of Zhang et al.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Assumption 5 (<span class="math">n</span>-Extended Power Knowledge of Exponent (<span class="math">n</span>-EPKE) *[71]).</h6>

    <p class="text-gray-300">Consider two groups <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{G}_{\\mathsf{T}}</span> of prime order <span class="math">p=O(2^{\\lambda})</span> such that there exists a symmetric bilinear pairing <span class="math">e:\\mathbb{G}\\times\\mathbb{G}\\to\\mathbb{G}_{\\mathsf{T}}</span>. Let <span class="math">\\mathbb{F}=\\mathbb{Z}_{p}^{*}</span>. The <span class="math">n</span>-Extende</p>

    <p class="text-gray-300">Power Knowledge of Exponent holds for <span class="math">(\\mathbb{G},\\mathbb{G}_{\\mathsf{T}})</span> if for any PPT adversary <span class="math">\\mathcal{A}</span> there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\alpha,s,t\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{F},g\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{G},\\\\ \\boldsymbol{u}=(g,g^{s},\\ldots,g^{s^{n}},g^{t}),\\\\ \\boldsymbol{v}=(g^{\\alpha},g^{\\alpha s},\\ldots,g^{\\alpha s^{n}},g^{\\alpha t}),\\\\ \\sigma=((\\mathbb{F},\\mathbb{G},\\mathbb{G}_{\\mathsf{T}},e),\\boldsymbol{u},\\boldsymbol{v}),\\\\ (A,A^{\\prime})\\leftarrow\\mathcal{A}(\\lambda,\\sigma,z;\\rho),\\\\ (a_{0},\\ldots,a_{n},b)\\leftarrow\\mathcal{E}(\\lambda,\\sigma,z;\\rho)\\end{array}\\right]=1-\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">for any <em>benign</em> auxiliary input <span class="math">z\\in\\{0,1\\}^{\\mathsf{poly}(\\lambda)}</span>, and randomness <span class="math">\\rho</span>. In this setting we consider input <span class="math">z</span> benign if it is generated independently of <span class="math">\\alpha</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose we have adversary <span class="math">\\mathcal{A}</span> that outputs <span class="math">(A,A^{\\prime})</span> such that <span class="math">e(A,g^{\\alpha})=e(A^{\\prime},g)</span>. To show Assumption 4 is equivalent to Assumption 5, we must a construct a PPT extractor <span class="math">\\mathcal{E}</span> that outputs <span class="math">a_{0},\\ldots,a_{n},b</span> such that</p>

    <p class="text-gray-300"><span class="math">A=\\big{(}\\prod_{i=0}^{n}g^{p_{i}(s)\\cdot a_{i}}\\big{)}\\cdot g^{t\\cdot b}</span></p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. In particular, <span class="math">\\mathcal{E}</span> initially computes vectors</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{u}^{\\prime}</span> <span class="math">=(g,g^{s},\\ldots,g^{s^{n}},g^{t})</span> <span class="math">\\boldsymbol{v}^{\\prime}</span> <span class="math">=(g^{\\alpha},g^{\\alpha s},\\ldots,g^{\\alpha s^{n}},g^{\\alpha t}).</span></p>

    <p class="text-gray-300">This can be done efficiently because the monomials <span class="math">X^{0},\\ldots,X^{n}</span> are spanned by polynomials <span class="math">p_{0}(X),\\ldots,p_{n}(X)</span> due to their linear independence, and therefore the terms <span class="math">s^{0},\\ldots,s^{n}</span> are a linear combination of the terms <span class="math">p_{0}(s),\\ldots,p_{n}(s)</span>. By the <span class="math">n</span>-EPKE assumption (Assumption 5), there exists PPT extractor <span class="math">\\mathcal{E}^{\\prime}</span> that on input <span class="math">((\\mathbb{F},\\mathbb{G},\\mathbb{G}_{T},e),\\boldsymbol{u}^{\\prime},\\boldsymbol{v}^{\\prime})</span> outputs <span class="math">a_{0}^{\\prime},\\ldots,a_{n}^{\\prime},b</span> such that</p>

    <p class="text-gray-300"><span class="math">A=\\big{(}\\prod_{i=0}^{n}g^{s^{i}\\cdot a_{i}^{\\prime}}\\big{)}\\cdot g^{t\\cdot b}</span></p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. By interpreting <span class="math">a_{0}^{\\prime},\\ldots,a_{n}^{\\prime}</span> as coefficients of degree <span class="math">n</span> polynomial <span class="math">a</span>, we have that</p>

    <p class="text-gray-300"><span class="math">A=g^{a(s)}g^{tb}</span></p>

    <p class="text-gray-300">Once again, by the linear independence of polynomials <span class="math">p_{0}(X),\\ldots,p_{n}(X)</span>, degree <span class="math">n</span> polynomial <span class="math">a(X)</span> can be represented as a linear combination of <span class="math">p_{0}(X),\\ldots,p_{n}(X)</span>. Let this linear combination be <span class="math">a_{0},\\ldots,a_{n}</span>. This means that</p>

    <p class="text-gray-300"><span class="math">a(s)=a_{0}p_{0}(s)+\\ldots+a_{n}p_{n}(s)</span></p>

    <p class="text-gray-300">and therefore</p>

    <p class="text-gray-300"><span class="math">A=g^{a_{0}p_{0}(s)+\\ldots+a_{n}p_{n}(s)}g^{tb}.</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\mathcal{E}</span> can return <span class="math">a_{0},\\ldots,a_{n},b</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">D.2 Proof of Lemma 2 (Structured Polynomial Commitments)</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the desired properties of our structured polynomial commitment scheme:</p>

    <h5 id="sec-77" class="text-base font-semibold mt-4">Homomorphic</h5>

    <p class="text-gray-300">Construction 1 is homomorphic because</p>

    <p class="text-gray-300"><span class="math">\\mathsf{com}(\\bm{p};r_{p})\\cdot\\mathsf{com}(\\bm{p};r_{p})</span> <span class="math">=(g^{\\bm{p}(s)}\\cdot h^{r_{p}},g^{\\alpha\\bm{p}(s)}\\cdot h^{\\alpha r_{p}})\\cdot(g^{\\bm{q}(s)}\\cdot h^{r_{q}},g^{\\alpha\\bm{q}(s)}\\cdot h^{\\alpha r_{q}})</span> <span class="math">=(g^{\\bm{p}(s)+\\bm{q}(s)}\\cdot h^{r_{p}+r_{q}},g^{\\alpha(\\bm{p}(s)+\\bm{q}(s))}\\cdot h^{\\alpha(r_{p}+r_{q})})</span> <span class="math">=\\mathsf{com}(\\bm{p}+\\bm{q};r_{p}+r_{q})</span></p>

    <h5 id="sec-78" class="text-base font-semibold mt-4">Unconditional Hiding</h5>

    <p class="text-gray-300">To prove unconditional hiding we observe that arbitrary <span class="math">P_{1}</span> is indistinguishable from a random element <span class="math">R\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{G}</span> due to the <span class="math">h^{r}</span> term. Because <span class="math">P_{2}=(P_{1})^{\\alpha}</span>, we have that <span class="math">(P_{1},P_{2})</span> is indistinguishable from <span class="math">(R,R^{\\alpha})</span>.</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Extractibility</h5>

    <p class="text-gray-300">Extractibility follows directly from the <span class="math">(n-1)</span>-EPKE assumption and assumption 4.</p>

    <h5 id="sec-80" class="text-base font-semibold mt-4">Computational Binding</h5>

    <p class="text-gray-300">To prove computational binding, suppose there exists an adversary <span class="math">\\mathcal{A}</span> that outputs two vectors of polynomial evaluations <span class="math">\\bm{p}</span> and <span class="math">\\bm{q}</span> and associated randomness <span class="math">r_{p}</span> and <span class="math">r_{q}</span> such that <span class="math">\\bm{p}\\neq\\bm{q}</span> but</p>

    <p class="text-gray-300"><span class="math">\\mathsf{com}(\\bm{p};r_{p})=\\mathsf{com}(\\bm{q};r_{q}).</span></p>

    <p class="text-gray-300">with non-negligible probability <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">Then we can construct adversary <span class="math">\\mathcal{B}</span> that breaks the <span class="math">(n-1)</span>-SDH assumption with non-negligible probability: Suppose <span class="math">\\mathcal{B}</span> is provided challenge <span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}})</span>. <span class="math">\\mathcal{B}</span> begins by picking random bit <span class="math">b\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}</span> and proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=0</span>: Let <span class="math">h=g^{\\sigma}</span>. Sample secret <span class="math">s\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and generate the rest of the structured reference string accordingly.</li>

      <li>If <span class="math">b=1</span>: Use terms <span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}})</span> to efficiently compute commitment keys</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bm{u}</span> <span class="math">=(g^{\\ell_{1}(\\sigma)},\\ldots,g^{\\ell_{n}(\\sigma)})</span> <span class="math">\\bm{v}</span> <span class="math">=(g^{\\alpha\\ell_{1}(\\sigma)},\\ldots,g^{\\alpha\\ell_{n}(\\sigma)})</span></p>

    <p class="text-gray-300">Note that this implicitly sets <span class="math">s=\\sigma</span>. Generate the rest of the structured reference string accordingly.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> runs <span class="math">\\mathcal{A}</span> with this reference string, receives <span class="math">(\\bm{p},\\bm{q},r_{p},r_{q})</span>, and aborts if <span class="math">\\bm{p}=\\bm{q}</span>. Because <span class="math">\\mathsf{com}(\\bm{p};r_{p})=\\mathsf{com}(\\bm{q};r_{q})</span>, we have</p>

    <p class="text-gray-300"><span class="math">g^{\\bm{p}(s)+\\lambda r_{p}}=g^{\\bm{q}(s)+\\lambda r_{q}}</span> (28)</p>

    <p class="text-gray-300">We now have one of two cases: Either <span class="math">\\bm{p}(s)\\neq\\bm{q}(s)</span> or <span class="math">\\bm{p}(s)=\\bm{q}(s)</span>. We consider both cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\bm{p}(s) \\neq \\bm{q}(s)</span>: If <span class="math">b = 0</span>, we have that <span class="math">g^{\\sigma} = h</span> by design. Because <span class="math">\\bm{p}(s) \\neq \\bm{q}(s)</span> by equation 28, we have that <span class="math">r_p \\neq r_q</span>. Thus <span class="math">\\mathcal{B}</span> can compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\sigma = \\frac {\\bm {q} (s) - \\bm {p} (s)}{r _ {p} - r _ {q}}</span></div>

    <p class="text-gray-300">and output <span class="math">(0,e(g,g)^{\\frac{1}{\\sigma}})</span> breaking the <span class="math">(n - 1)</span>-SDH assumption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\bm{p}(s) = \\bm{q}(s)</span>: If <span class="math">b = 1</span>, we have <span class="math">s = \\sigma</span> by design. Now consider the polynomial</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">T (X) = \\boldsymbol {p} (X) - \\boldsymbol {q} (X).</span></div>

    <p class="text-gray-300">Because <span class="math">\\bm{p}(s) = \\bm{q}(s)</span>, we have that <span class="math">\\sigma = s</span> is a root of <span class="math">T</span>. Additionally, <span class="math">T</span> is not the zero polynomial by assumption that <span class="math">\\bm{p} \\neq \\bm{q}</span>. Thus <span class="math">\\mathcal{B}</span> can solve for the roots of <span class="math">T</span> and find <span class="math">\\sigma</span> that agrees with the provided challenge. <span class="math">\\mathcal{B}</span> can then output <span class="math">(0, e(g, g)^{\\frac{1}{\\sigma}})</span> breaking the <span class="math">(n - 1)</span>-SDH assumption.</p>

    <p class="text-gray-300">We now analyze <span class="math">\\mathcal{B}</span>'s success probability. Let <span class="math">\\delta</span> be the probability that <span class="math">\\mathcal{A}</span> successfully outputs <span class="math">(\\pmb{p},\\pmb{q},r_p,r_q)</span> such that <span class="math">\\mathsf{com}(\\pmb {p};r_p) = \\mathsf{com}(\\pmb {q};r_q)</span> but <span class="math">\\pmb {p}\\neq \\pmb{q}</span>. Let <span class="math">\\delta = \\delta_{1} + \\delta_{2}</span> where <span class="math">\\delta_{1}</span> is the probability that <span class="math">\\mathcal{A}</span> wins with <span class="math">\\pmb {p}(s)\\neq \\pmb {q}(s)</span> and <span class="math">\\delta_{2}</span> is the probability that <span class="math">\\mathcal{A}</span> wins with <span class="math">\\pmb {p}(s) = \\pmb {q}(s)</span>. <span class="math">\\mathcal{B}</span> succeeds when <span class="math">\\pmb {p}(s)\\neq \\pmb {q}(s)</span> and <span class="math">b = 0</span>, or when <span class="math">\\pmb {p}(s) = \\pmb {q}(s)</span> and <span class="math">b = 1</span>. For randomly chosen <span class="math">b</span>, <span class="math">\\operatorname<em>{Pr}[b = 0] = \\operatorname</em>{Pr}[b = 1] = 1 / 2</span>. Therefore the probability that <span class="math">\\mathcal{B}</span> succeeds is <span class="math">\\delta_1 / 2 + \\delta_2 / 2 = \\delta /2</span>. Therefore if <span class="math">\\delta</span> is a non-negligible probability, then <span class="math">\\mathcal{A}</span> succeeds in breaking the <span class="math">(n - 1)</span>-SDH assumption with non-negligible probability.</p>

    <p class="text-gray-300"><strong>Lemma 7 (Efficiency).</strong> For polynomials defined by <span class="math">n</span> evaluation points, the generator takes time <span class="math">O_{\\lambda}(n)</span>, <span class="math">\\mathsf{com}</span> takes time <span class="math">O_{\\lambda}(n)</span>, <span class="math">\\mathsf{checkcom}</span> takes time <span class="math">O_{\\lambda}(1)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> <span class="math">\\mathcal{G}</span> can compute <span class="math">\\ell_1(s),\\ldots ,\\ell_n(s)</span> in <span class="math">O_{\\lambda}(n)</span> time using the Barycentric representation. Specifically <span class="math">\\mathcal{G}</span> can first compute the Barycentric weights of polynomials <span class="math">\\ell_1,\\dots ,\\ell_n</span> in time <span class="math">O_{\\lambda}(n)</span> by strategically selecting evaluation points [58]. Next <span class="math">\\mathcal{G}</span> can use the approach described by Berrut et al [13] to compute evaluations <span class="math">\\ell_1(s),\\ldots ,\\ell_n(s)</span> in linear time given the Barycentric weights. Next <span class="math">\\mathcal{G}</span> can compute <span class="math">\\pmb{u}</span> and <span class="math">\\pmb{v}</span> using two multi-exponentiations of size <span class="math">n</span> which can be done in <span class="math">O_{\\lambda}(n / \\log n)</span> exponentiations by Pippenger's algorithm [59]. <span class="math">\\mathsf{com}</span> requires computing <span class="math">P_{1}</span> and <span class="math">P_{2}</span> which can be done using a multi-exponentiation of size <span class="math">n</span> for each. checkcom requires two pairings which can be done in <span class="math">O_{\\lambda}(1)</span> time.</p>

    <h2 id="sec-81" class="text-2xl font-bold">D.3 Proof of Theorem 1 (Polynomial Evaluation Argument)</h2>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Construction 2 satisfies knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given an arbitrary PPT prover <span class="math">\\mathcal{P}^*</span>, we must construct PPT extractor <span class="math">\\mathcal{E}</span> such that for an arbitrary statement <span class="math">(P\\in \\mathbb{G}^2,Y\\in \\mathbb{G},u\\in \\mathbb{F})</span> if</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathcal {P} ^ {*} (P, Y, u; \\rho), \\mathcal {V} (P, Y, u) \\rangle = 1</span></div>

    <p class="text-gray-300">then <span class="math">\\mathcal{E}(P,Y,u;\\rho)</span> produces a witness <span class="math">(\\boldsymbol{p}\\in\\mathbb{F}^{n},y\\in\\mathbb{F},r_{p},r_{y}\\in\\mathbb{F})</span> such that</p>

    <p class="text-gray-300"><span class="math">P</span> <span class="math">=\\mathsf{com}(\\boldsymbol{p};r_{p})</span> <span class="math">Y</span> <span class="math">=\\mathsf{com}(y;r_{y})</span> <span class="math">y</span> <span class="math">=\\boldsymbol{p}(u).</span></p>

    <p class="text-gray-300">Given a successful <span class="math">\\mathcal{P}^{*}</span>, we construct <span class="math">\\mathcal{E}</span> that extracts a valid witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>:</p>

    <p class="text-gray-300">Because the all verifier’s checks have passed, commitments <span class="math">P</span>, <span class="math">Q</span>, <span class="math">Y</span>, and <span class="math">R</span> are well-formed. Therefore, by Lemma 2, <span class="math">\\mathcal{E}</span> can extract evaluation vectors <span class="math">\\boldsymbol{p}=(p_{1},\\ldots,p_{n})</span>, <span class="math">\\boldsymbol{q}=(q_{1},\\ldots,q_{n})</span>, <span class="math">y</span>, and <span class="math">\\boldsymbol{r}=(r_{1},\\ldots,r_{n})</span> along with associated randomness <span class="math">r_{p}</span>, <span class="math">r_{q}</span>, <span class="math">r_{y}</span>, and <span class="math">r_{r}</span> such that</p>

    <p class="text-gray-300"><span class="math">P_{1}</span> <span class="math">=\\mathsf{com}(\\boldsymbol{p};r_{p})=\\boldsymbol{u}^{\\boldsymbol{p}}\\cdot h^{r_{p}}=g^{\\boldsymbol{p}(s)}h^{r_{p}}</span> <span class="math">Q_{1}</span> <span class="math">=\\mathsf{com}(\\boldsymbol{q};r_{q})=\\boldsymbol{u}^{\\boldsymbol{q}}\\cdot h^{r_{q}}=g^{\\boldsymbol{q}(s)}h^{r_{q}}</span> <span class="math">Y_{1}</span> <span class="math">=\\mathsf{com}(y;r_{y})=g^{y}h^{r_{y}}</span> <span class="math">R_{1}</span> <span class="math">=\\mathsf{com}(\\boldsymbol{r};r_{r})=\\boldsymbol{u}^{\\boldsymbol{r}}\\cdot h^{r_{r}}=g^{\\boldsymbol{r}(s)}h^{r_{r}}</span></p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. While the extractor has extracted all of the material required to construct a witness <span class="math">(\\boldsymbol{p},y,r_{p},r_{y})</span>, we must still show that <span class="math">\\boldsymbol{p}(u)=y</span>.</p>

    <p class="text-gray-300">Suppose, for contradiction, <span class="math">\\boldsymbol{p}(u)\\neq y</span> with non-negligible probability. Then we can construct adversary <span class="math">\\mathcal{A}</span> that uses <span class="math">\\mathcal{P}^{*}</span> and <span class="math">\\mathcal{E}</span> to break the <span class="math">(n-1)</span>-BSDH assumption. Suppose <span class="math">\\mathcal{A}</span> is provided with challenge <span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}})</span>. <span class="math">\\mathcal{A}</span> picks a random bit <span class="math">b\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}</span> and proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=0</span>: Let <span class="math">h=g^{\\sigma}</span>. Sample secret <span class="math">s\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and generate the rest of the structured reference string accordingly.</li>

      <li>If <span class="math">b=1</span>: Use terms <span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}})</span> to efficiently compute commitment keys</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\boldsymbol{u}</span> <span class="math">=(g^{\\ell_{1}(\\sigma)},\\ldots,g^{\\ell_{n}(\\sigma)})</span> <span class="math">\\boldsymbol{v}</span> <span class="math">=(g^{\\alpha\\ell_{1}(\\sigma)},\\ldots,g^{\\alpha\\ell_{n}(\\sigma)}).</span></p>

    <p class="text-gray-300">Note that this implicitly sets <span class="math">s=\\sigma</span>. Generate the rest of the structured reference string accordingly.</p>

    <p class="text-gray-300">Next <span class="math">\\mathcal{A}</span> runs <span class="math">\\mathcal{P}^{<em>}</span> and provided <span class="math">\\mathcal{P}^{</em>}</span> is successful, runs the extractor <span class="math">\\mathcal{E}</span> described above. If <span class="math">\\boldsymbol{p}(u)=y</span>, abort. Otherwise, because the verifier’s final check has passed we have</p>

    <p class="text-gray-300"><span class="math">e(P_{1}/Y,g)=e(Q_{1},g^{s-u})e(R_{1},h).</span></p>

    <p class="text-gray-300">Letting <span class="math">g^{t}=h</span>, for some unknown <span class="math">t</span>, we have</p>

    <p class="text-gray-300"><span class="math">e(g,g)^{\\boldsymbol{p}(s)+tr_{p}-(y+tr_{y})}=e(g,g)^{(\\boldsymbol{q}(s)+tr_{q})(s-u)+t(\\boldsymbol{r}(s)+tr_{r})}.</span> (29)</p>

    <p class="text-gray-300">Aggregating terms with respect to <span class="math">t</span>, we get</p>

    <p class="text-gray-300"><span class="math">e(g,g)^{(\\bm{p}(s)-y)+t(r_{p}-y)}=e(g,g)^{(\\bm{q}(s)(s-u))+t((\\bm{r}(s)+tr_{r})+r_{q}(s-u))}.</span> (30)</p>

    <p class="text-gray-300">We now have one of two cases: Either <span class="math">\\bm{p}(s)-y\\neq\\bm{q}(s)(s-u)</span> or <span class="math">\\bm{p}(s)-y=\\bm{q}(s)(s-u)</span>. We consider both cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose <span class="math">\\bm{p}(s)-y\\neq\\bm{q}(s)(s-u)</span>: If <span class="math">b=0</span>, we have that <span class="math">t=\\sigma</span> by design. Now consider the polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">T(X)=X((\\bm{r}(s)+Xr_{r})+r_{q}(s-u)-(r_{p}-y))+(\\bm{q}(s)(s-u))-(\\bm{p}(s)-y))</span></p>

    <p class="text-gray-300">By equation 30 we have that <span class="math">\\sigma</span> is a root of <span class="math">T</span>. Additionally because <span class="math">\\bm{p}(s)-y\\neq\\bm{q}(s)(s-u)</span> we have that <span class="math">T</span> is not the zero polynomial. Thus <span class="math">\\mathcal{A}</span> can solve for the roots of <span class="math">T</span> and find <span class="math">\\sigma</span> that agrees with the provided challenge. <span class="math">\\mathcal{A}</span> can then output <span class="math">(0,e(g,g)^{\\frac{1}{\\sigma}})</span> breaking the <span class="math">(n-1)</span>-BSDH assumption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose instead <span class="math">\\bm{p}(s)-y=\\bm{q}(s)(s-u)</span>: If <span class="math">b=1</span>, we have <span class="math">s=\\sigma</span> by design. Now consider the polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">T(X)=(\\bm{p}(X)-y)-\\bm{q}(X)(X-u)</span></p>

    <p class="text-gray-300">Because <span class="math">\\bm{p}(s)-y=\\bm{q}(s)(s-u)</span>, <span class="math">\\sigma=s</span> is a root of <span class="math">T</span>. Additionally, <span class="math">T</span> is not the zero polynomial because then otherwise we would have</p>

    <p class="text-gray-300"><span class="math">0=T(u)=\\bm{p}(u)-y-\\bm{q}(u)(u-u)=\\bm{p}(u)-y</span></p>

    <p class="text-gray-300">which contradicts the assumption that <span class="math">\\bm{p}(u)\\neq y</span>. Thus <span class="math">\\mathcal{A}</span> can solve for the roots of <span class="math">T</span> and find <span class="math">\\sigma</span> that agrees with the provided challenge. <span class="math">\\mathcal{A}</span> can then output <span class="math">(0,e(g,g)^{\\frac{1}{\\sigma}})</span> breaking the <span class="math">(n-1)</span>-BSDH assumption.</p>

    <p class="text-gray-300">We now analyze <span class="math">\\mathcal{A}</span>’s success probability. Let <span class="math">\\delta</span> be the probability that <span class="math">\\mathcal{P}^{<em>}</span> successfully convinces the verifier but the extractor <span class="math">\\mathcal{E}</span> outputs <span class="math">(\\bm{p},y)</span> such that <span class="math">\\bm{p}(u)\\neq y</span>. Let <span class="math">\\delta=\\delta_{1}+\\delta_{2}</span> where <span class="math">\\delta_{1}</span> is the the probability <span class="math">\\mathcal{P}^{</em>}</span> wins with <span class="math">\\bm{p}(s)-y\\neq\\bm{q}(s)(s-u)</span>, and <span class="math">\\delta_{2}</span> is the probability <span class="math">\\mathcal{P}^{*}</span> wins with <span class="math">\\bm{p}(s)-y=\\bm{q}(s)(s-u)</span>. <span class="math">\\mathcal{A}</span> succeeds when <span class="math">\\bm{p}(s)-y\\neq\\bm{q}(s)(s-u)</span> and <span class="math">b=0</span>, or when <span class="math">\\bm{p}(s)-y=\\bm{q}(s)(s-u)</span> and <span class="math">b=1</span>. For randomly chosen <span class="math">b</span>, <span class="math">\\Pr[b=0]=\\Pr[b=1]=1/2</span>. Therefore the probability that <span class="math">\\mathcal{A}</span> succeeds is <span class="math">\\delta_{1}/2+\\delta_{2}/2=\\delta/2</span>. Therefore if <span class="math">\\delta</span> is a non-negligible probability, then <span class="math">\\mathcal{A}</span> succeeds in breaking the <span class="math">(n-1)</span>-BSDH assumption with non-negligible probability. ∎</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Construction 2 is perfect zero-knowledge.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove perfect zero-knowledge we must construct a PPT simulator <span class="math">\\mathcal{S}</span> that can simulate a transcript indistinguishable from one generated by an honest prover for any given statement with a valid witness. We construct <span class="math">\\mathcal{S}</span> as follows:</p>

    <p class="text-gray-300">Consider arbitrary statement <em>with a valid witness</em> consisting of polynomial commitment <span class="math">P</span>, commitment <span class="math">Y</span>, and evaluation point <span class="math">u</span>. We argue that <span class="math">\\mathcal{S}</span> can compute <span class="math">Q</span> and <span class="math">R</span> <em>exactly</em> as dictated by the protocol using only <span class="math">P</span>, <span class="math">Y</span>, <span class="math">u</span>, and the trapdoor:</p>

    <p class="text-gray-300">First, <span class="math">\\mathcal{S}</span> generates the common reference string, and the associated trapdoor <span class="math">(\\alpha,s,t)</span> where <span class="math">g^{t}=h</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{S}</span> samples <span class="math">r_{q}^{\\prime}\\leftarrow\\mathbb{F}</span> and computes <span class="math">Q_{1}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">Q_{1}</span> <span class="math">=(P_{1}/Y_{1})^{1/(s-u)}\\cdot h^{r_{q}^{\\prime}}</span> <span class="math">=g^{\\frac{p(s)+tr_{p}-y-tr_{y}}{(s-u)}+tr_{q}^{\\prime}}</span> <span class="math">=g^{q(s)+t(\\frac{r_{p}-r_{y}}{s-u}+r_{q}^{\\prime})}</span></p>

    <p class="text-gray-300">where the last equality holds because an honest prover computes <span class="math">q(s)=(p(s)-y)/(s-u)</span>. We can set <span class="math">r_{q}=(r_{p}-r_{y})(s-u)+r_{q}^{\\prime}</span> and rewrite</p>

    <p class="text-gray-300"><span class="math">Q_{1}=g^{q(s)+tr_{q}}=g^{q(s)}h^{r_{q}}.</span></p>

    <p class="text-gray-300">We note that <span class="math">r_{q}</span> is indistinguishable from a random element in <span class="math">\\mathbb{F}</span> in both the real and ideal settings. <span class="math">\\mathcal{S}</span> computes <span class="math">Q_{2}=Q_{1}^{\\alpha}</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{S}</span> computes <span class="math">R_{1}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">R_{1}</span> <span class="math">=(P_{1}/Y_{1}/Q_{1}^{(s-u)})^{1/t}</span> <span class="math">=g^{(1/t)(p(s)+tr_{p})-(1/t)(y+tr_{y})-(1/t)(q(s)+tr_{q})(s-u)}</span> <span class="math">=g^{(1/t)(p(s)-y-q(s)(s-u))+(r_{p}-r_{y}-r_{q}(s-u))}</span> <span class="math">=g^{r_{p}-r_{y}-r_{q}(s-u)}</span></p>

    <p class="text-gray-300">where the last equality holds because <span class="math">p(s)-y-q(s)(s-u)=0</span> due to the fact that <span class="math">q(s)=\\frac{p(s)-y}{(s-u)}\\cdot\\mathcal{S}</span> computes <span class="math">R_{2}=R_{1}^{\\alpha}</span>.</p>

    <p class="text-gray-300">Thus, because <span class="math">Q</span> and <span class="math">R</span> satisfy identical relations in both the real and ideal setting, an unbounded adversary cannot distinguish between real and ideal transcripts.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Lemma 10 (Efficiency).</h6>

    <p class="text-gray-300">For polynomials defined over <span class="math">n</span> evaluations, the polynomial evaluation argument features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(1)</span> verifier.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We break down the dominating costs for each of the components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathcal{G}</span> can compute <span class="math">\\ell_{1}(s),\\ldots,\\ell_{n}(s)</span> in <span class="math">O_{\\lambda}(n)</span> time using reasoning similiar to the proof for lemma 7.</li>

      <li>Prover: Because <span class="math">\\bm{p}</span> represents a vector of polynomial evaluations, <span class="math">\\mathcal{P}</span> can compute the vector of polynomial evaluations <span class="math">\\bm{q}</span> in <span class="math">O_{\\lambda}(n)</span> time. (Specifically using <span class="math">O(n\\cdot\\mathsf{poly}(\\lambda))</span> field operations). Additionally, using commitment keys <span class="math">\\bm{u}</span> and <span class="math">\\bm{v}</span>, <span class="math">\\mathcal{P}</span> can compute <span class="math">Q</span> with two size <span class="math">n</span> multi-exponentiations.</li>

      <li>Verifier: The verifier’s final check is dominated by computing three pairings which can be done in <span class="math">O_{\\lambda}(1)</span> time.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">D.4 Proof of Theorem 2 (Inner-Product Argument)</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">Construction 3 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{IP}}</span> (Definition 12) that satisfies knowledge-soundness.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Construction 3 is derived by applying commitment scheme <span class="math">\\mathsf{com}</span> (Equation 2) to the generalized inner-product argument presented by Bünz et al. <em>[26]</em>. To be compatible with the generalized inner-product argument we must show that <span class="math">\\mathsf{com}</span> is doubly homomorphic (i.e. is homomorphic in both the message space and the key space) and binding. <span class="math">\\mathsf{com}</span> is doubly homomorphic by observation. Additionally <span class="math">\\mathsf{com}</span> is binding by the <span class="math">q</span>-SDH assumption and reasoning similiar to Lemma 2. Therefore <span class="math">\\mathsf{com}</span> is compatible with the generalized inner-product argument presented by Bünz et al. <em>[26]</em>. Thus the main interaction has knowledge soundness due Bünz et al. <em>[26, Theorem 5.4]</em> so long as the subprotocol to convince the verifier that <span class="math">(v,w)</span> are computed correctly is sound and the product relation holds is knowledge sound.</p>

    <p class="text-gray-300">The soundness of the <span class="math">(v,w)</span> argument holds by the Schwartz-Zippel Lemma and the soundness of the polynomial evaluation argument (Construction 2). In particular we consider the case of <span class="math">v</span> (the case for <span class="math">w</span> is symmetric): The soundness of the polynomial evaluation argument ensures that <span class="math">v</span> is of the form <span class="math">v=g_{1}^{f(\\alpha)}</span> for some degree <span class="math">n-1</span> polynomial <span class="math">f</span>. Additionally the the polynomial evaluation argument ensures that <span class="math">f(z)=f_{v}(z)</span>. Because <span class="math">z</span> is a random challenge provided by the verifier, <span class="math">f=f_{v}</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> by the Schwartz-Zippel lemma <em>[61]</em>.</p>

    <p class="text-gray-300">The final product argument a simplified version of a product argument presented by Bünz et al. <em>[23]</em>. Thus the final argument is knowledge sound by an argument similiar to Bünz et al. <em>[23, Theorem 3]</em>. ∎</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 12.</h6>

    <p class="text-gray-300">Construction 3 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{IP}}</span> that is honest-verifier zero-knowledge.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove honest-verifier zero-knowledge we must construct simulator <span class="math">\\mathcal{S}</span> that can simulate a transcript indistinguishable from one generated by an honest interaction for any given statement with a valid witness. We construct <span class="math">\\mathcal{S}</span> as follows:</p>

    <p class="text-gray-300">Consider arbitrary statement <em>with a valid witness</em> consisting of commitments <span class="math">A</span>, <span class="math">B</span>, <span class="math">C</span> and scalar <span class="math">r</span>. The simulator <span class="math">\\mathcal{S}</span> sets <span class="math">\\bm{a}</span>, <span class="math">\\bm{b}</span> to be <span class="math">\\bm{0}</span> and simulates an interaction between an honest prover and honest verifier for the main argument. In each round in both the real and ideal setting, the prover’s messages <span class="math">A_{L},A_{R},B_{L},B_{R},C_{L},C_{R}</span> are indistinguishable from random and independent of each other due to the blinding terms.</p>

    <p class="text-gray-300">Additionally the subprotocol for checking <span class="math">v</span> and <span class="math">w</span> is not witness dependent so can be simulated by running the honest prover.</p>

    <p class="text-gray-300">Thus, it suffices to show that the <span class="math">\\mathcal{S}</span> can simulate the final proof-of-product protocol with a statement consisting of commitments <span class="math">A,B,C</span> and unknown openings. <span class="math">\\mathcal{S}</span> sets <span class="math">a=b=c=0</span> and randomly samples <span class="math">r_{a},r_{b},r_{c}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math">. Next </span>\\mathcal{S}<span class="math"> simulates the honest prover and verifier. However instead of computing </span>S$ and</p>

    <p class="text-gray-300"><span class="math">T_{1}</span> as dictated by the protocol, <span class="math">\\mathcal{S}</span> uses the simulated challenge <span class="math">z</span> to forge these terms to satisfy the verifier’s checks:</p>

    <p class="text-gray-300"><span class="math">S</span> <span class="math">=(v^{a^{\\prime}}w^{b^{\\prime}}h^{\\mu}/A/B)^{\\frac{1}{c}}</span> <span class="math">T_{1}</span> <span class="math">=(g^{c^{\\prime}}h^{\\tau}/C/T_{2}^{\\tau^{2}})^{\\frac{1}{c}}</span></p>

    <p class="text-gray-300">Because <span class="math">\\tau_{1},\\tau_{2},\\rho,z,s_{a},s_{b}</span> are randomly sampled this implies that the provers message <span class="math">\\tau,\\mu,a^{\\prime},b^{\\prime},c^{\\prime}</span> is indistinguishable from random elements in <span class="math">\\mathbb{F}</span> in both the real and ideal settings. Additionally this implies that <span class="math">T_{2}</span> is indistinguishable from a random element in <span class="math">\\mathbb{G}</span> in both the real and the ideal setting. Finally <span class="math">S</span> and <span class="math">T_{1}</span> are uniquely fixed by elements which are indistinguishable from random in both the real and the ideal setting. Therefore, an adversary cannot distinguish between the real and ideal transcripts. ∎</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma 13 (Efficiency).</h6>

    <p class="text-gray-300">For vectors of size <span class="math">n</span>, Construction 3 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(\\log n)</span> verifier.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follow by properties discussed in <em>Bünz et al. [26]</em>. We provide more detail for the generalized inner-product argument instantiated with the Pedersen commitment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: <span class="math">\\mathcal{G}</span> can compute <span class="math">\\bm{w}</span> with a multi-exponentiation of size <span class="math">n</span> which can be done in <span class="math">O_{\\lambda}(n/\\log n)</span> exponentiations by Pippenger’s algorithm <em>[59]</em>.</li>

      <li>Prover: The prover can compute <span class="math">\\bm{r}</span> and rescale <span class="math">\\bm{a}</span> in <span class="math">O_{\\lambda}(n)</span> time. In each recursive round the prover’s work is dominated by the cost of exponentiations. In total to compute <span class="math">A_{L},A_{R},B_{L},B_{R},\\bm{v}^{\\prime},\\bm{w}^{\\prime}</span> in all rounds the prover incurs <span class="math">6n</span> exponentiations: <span class="math">3n</span> in the first round, <span class="math">3n/2</span> in the second round, and so on.</li>

    </ul>

    <p class="text-gray-300">In the subprotocol to check <span class="math">(v,w)</span>, the prover can evaluate <span class="math">v^{\\prime}</span> and <span class="math">w^{\\prime}</span> using two multi-exponentiations of size <span class="math">n</span>.</p>

    <p class="text-gray-300">Similarly the prover can compute <span class="math">f_{v}(z)</span> and <span class="math">f_{w}(z)</span> in a logarithmic number of multiplications. The prover can prove the validity of <span class="math">V</span> and <span class="math">W</span> using two polynomial evaluation arguments which incurs <span class="math">O_{\\lambda}(n)</span> overhead (Lemma 10)</p>

    <p class="text-gray-300">The subprotocol to check product requires <span class="math">O_{\\lambda}(1)</span> operations on the prover’s end by observation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier: To compute <span class="math">A^{\\prime},B^{\\prime},C^{\\prime}</span> over all the rounds the verifier performs <span class="math">6\\log n</span> exponentiations.</li>

    </ul>

    <p class="text-gray-300">In the subprotocol to check <span class="math">(v,w)</span>, the verifier can compute <span class="math">f_{v}(z)</span> and <span class="math">f_{w}(z)</span> in a logarithmic number of multiplications. Checking the two resulting polynomial evaluation arguments incurs <span class="math">O_{\\lambda}(1)</span> overhead (Lemma 10)</p>

    <p class="text-gray-300">By observation, the subprotocol to check product requires <span class="math">O_{\\lambda}(1)</span> operations on the verifier’s end.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">D.5 Proof of Theorem 3 (Inner-Product Argument for the Lagrange Basis)</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Lemma 14.</h6>

    <p class="text-gray-300">Construction 4 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{IP}}</span> (Definition 12) that satisfies knowledge-soundness.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Given arbitrary prover <span class="math">\\mathcal{P}^{*}</span> we must construct extractor <span class="math">\\mathcal{E}</span> such that for arbitrary statement consisting of commitments <span class="math">A^{\\prime},B^{\\prime},C</span> and scalar <span class="math">r</span>, if</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P}^{*}(A^{\\prime},B^{\\prime},C,r;\\rho),\\mathcal{V}(A^{\\prime},B^{\\prime},C,r)\\rangle=1</span></p>

    <p class="text-gray-300">then <span class="math">\\mathcal{E}(A,B,C,r;\\rho)</span> produces a witness consisting of vectors <span class="math">\\bm{a}^{\\prime},\\bm{b}^{\\prime}</span> and scalars <span class="math">c,r_{a},r_{b},r_{c}</span> such that</p>

    <p class="text-gray-300"><span class="math">A^{\\prime}</span> <span class="math">=\\mathsf{com}(\\bm{a}^{\\prime},r_{a})</span> <span class="math">B^{\\prime}</span> <span class="math">=\\mathsf{com}(\\bm{b}^{\\prime},r_{b})</span> <span class="math">C</span> <span class="math">=\\mathsf{com}(c,r_{c})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">c=(\\bm{a}^{\\prime}\\circ\\bm{r})\\cdot\\bm{b}^{\\prime}</span></p>

    <p class="text-gray-300">where <span class="math">\\bm{r}=(r^{0},r^{1},\\ldots,r^{n-1})</span>. We construct <span class="math">\\mathcal{E}</span> that extracts a valid witness with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> as follows:</p>

    <p class="text-gray-300">By assumption, because the verifier accepts, we have that it accepts the inner-product argument over commitments <span class="math">A,B,C</span> (generated during interaction) and <span class="math">r</span>. By the knowledge soundness property of the inner-product argument (Lemma 11) <span class="math">\\mathcal{E}</span> can extract the vectors “under” the commitments, namely <span class="math">\\bm{a},\\bm{b}</span> and scalar <span class="math">c</span> (along with associated randomness <span class="math">r_{a},r_{b},r_{c}</span>) such that</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=\\bm{w}^{\\bm{a}}\\cdot h^{r_{a}}</span> (31) <span class="math">B</span> <span class="math">=\\bm{w}^{\\bm{b}}\\cdot h^{r_{b}}</span> (32) <span class="math">C</span> <span class="math">=g^{c}h^{r_{c}}</span> (33)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">c=(\\bm{a}\\circ\\bm{r})\\cdot\\bm{b}</span></p>

    <p class="text-gray-300">What remains to show is that construction 4 additionally enforces that</p>

    <p class="text-gray-300"><span class="math">A^{\\prime}_{1}</span> <span class="math">=\\bm{l}^{\\bm{a}}\\cdot h^{r_{a}}</span> <span class="math">B^{\\prime}_{1}</span> <span class="math">=\\bm{l}^{\\bm{b}}\\cdot h^{r_{b}}</span></p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. This implies that <span class="math">(\\bm{a},\\bm{b},c,r_{a},r_{b},r_{c})</span> is a valid witness to statement <span class="math">(A^{\\prime},B^{\\prime},c,r)</span>.</p>

    <p class="text-gray-300">We focus on showing that <span class="math">A</span> and <span class="math">A^{\\prime}</span> must commit to the same vector with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>; the case for commitments <span class="math">B</span> and <span class="math">B^{\\prime}</span> is symmetric. Suppose, for contradiction, there exists adversary <span class="math">\\mathcal{A}</span> that outputs commitments <span class="math">(A,A^{\\prime\\prime})</span> such that</p>

    <p class="text-gray-300"><span class="math">e(A^{\\prime\\prime},g)=e(A\\cdot A^{\\prime}_{1},g^{\\gamma})</span></p>

    <p class="text-gray-300">but there exists no <span class="math">\\bm{a}</span> such that</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=\\bm{w^{\\bm{a}}}\\cdot h^{r_{a}}</span> <span class="math">A_{1}^{\\prime}</span> <span class="math">=\\bm{l^{\\bm{a}}}\\cdot h^{r_{a}}</span></p>

    <p class="text-gray-300">with non-negligible probability. Then we can construct adversary <span class="math">\\mathcal{B}</span> that can break the <span class="math">(n-1)</span>-SDH assumption. Suppose <span class="math">\\mathcal{B}</span> has the following challenge</p>

    <p class="text-gray-300"><span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}}).</span></p>

    <p class="text-gray-300">Additionally, suppose <span class="math">\\mathcal{B}</span> is provided the statement <span class="math">(A^{\\prime},B^{\\prime},C)</span> as auxiliary input. Because <span class="math">(A^{\\prime},B^{\\prime},C)</span> are perfectly hiding commitments, they are independent of <span class="math">s</span> and thus are a valid input for the <span class="math">(n-1)</span>-SDH assumption. <span class="math">\\mathcal{B}</span> initially picks random <span class="math">b\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\{0,1\\}</span> and proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=0</span>: Let</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bm{w}=(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}}).</span></p>

    <p class="text-gray-300">Note that this implicitly sets <span class="math">s=\\sigma</span>. Sample secret <span class="math">t\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and generate the rest of the structured reference string accordingly.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=1</span>: Use terms <span class="math">(g,g^{\\sigma},\\ldots,g^{\\sigma^{n-1}})</span> to efficiently compute commitment keys</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bm{l}</span> <span class="math">=(g^{\\ell_{0}(\\sigma)},g^{\\ell_{1}(\\sigma)},\\ldots,g^{\\ell_{n-1}(\\sigma)})</span> <span class="math">\\bm{l}^{\\prime}</span> <span class="math">=(g^{\\alpha\\ell_{0}(\\sigma)},g^{\\alpha\\ell_{1}(\\sigma)},\\ldots,g^{\\alpha\\ell_{n-1}(\\sigma)})</span></p>

    <p class="text-gray-300">Note that this implicitly sets <span class="math">t=s</span>. Sample secret <span class="math">s\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span> and generate the rest of the structured reference string accordingly. Note that <span class="math">\\bm{l}</span> and <span class="math">\\bm{l}^{\\prime}</span> can be computed efficiently by the reasoning in the proof for Assumption 4.</p>

    <p class="text-gray-300">Now <span class="math">\\mathcal{B}</span> runs <span class="math">\\mathcal{A}</span> on the statement <span class="math">(A^{\\prime},B^{\\prime},C)</span> and public parameters and recieves commitments <span class="math">(A,A^{\\prime\\prime})</span>. Because the verifier accepts that commitment <span class="math">A^{\\prime}</span> is well-formed, by Lemma 2, <span class="math">\\mathcal{E}</span> can extract vector <span class="math">\\bm{a}^{\\prime}</span> and scalar <span class="math">r_{a}^{\\prime}</span> such that</p>

    <p class="text-gray-300"><span class="math">A_{1}^{\\prime}=\\bm{l^{\\bm{a}}^{\\prime}}\\cdot h^{r_{a}^{\\prime}}</span> (34)</p>

    <p class="text-gray-300">Next, we observe that in the case that <span class="math">b=0</span>, <span class="math">\\bm{t}=(\\bm{w}\\circ\\bm{l})^{\\gamma}=\\{g^{U_{i}(s)}\\}_{i\\in\\{0,\\ldots,n-1\\}}</span>, where</p>

    <p class="text-gray-300"><span class="math">U_{i}(X)=\\gamma(X^{i}+\\ell_{i}(t)).</span></p>

    <p class="text-gray-300">Likewise, in the case that <span class="math">b=1</span>, <span class="math">\\bm{t}=\\{g^{V_{i}(s)}\\}_{i\\in\\{0,\\ldots,n-1\\}}</span>, where</p>

    <p class="text-gray-300"><span class="math">V_{i}(X)=\\gamma(s^{i}+\\ell_{i}(X)).</span></p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Both <span class="math">\\{U_{i}\\}_{i\\in\\{0,\\dots,n-1\\}}</span> and <span class="math">\\{V_{i}\\}_{i\\in\\{0,\\dots,n-1\\}}</span> define sets of linearly independent polynomials. Therefore, in either case, because</p>

    <p class="text-gray-300"><span class="math">e(A^{\\prime\\prime},g)=e(A\\cdot A^{\\prime}_{1},g^{\\gamma})</span></p>

    <p class="text-gray-300">by Assumption 4 which extends the <span class="math">(n-1)</span>-EPKE assumption for linearly independent polynomials, <span class="math">\\mathcal{E}</span> can extract vector <span class="math">\\bm{a}^{\\prime\\prime}</span> and scalar <span class="math">r^{\\prime\\prime}_{a}</span> such that</p>

    <p class="text-gray-300"><span class="math">A\\cdot A^{\\prime}_{1}=\\prod_{i=0}^{n-1}g^{(s^{i}+\\ell_{i}(t))a^{\\prime\\prime}_{i}}\\cdot h^{r^{\\prime\\prime}_{a}}</span> (35)</p>

    <p class="text-gray-300">Next observe that</p>

    <p class="text-gray-300"><span class="math">r^{\\prime\\prime}_{a}=r_{a}+r^{\\prime}_{a}</span> (36)</p>

    <p class="text-gray-300">with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> because otherwise we can construct adversary <span class="math">\\mathcal{C}</span> that can solve for <span class="math">\\mu</span> such that <span class="math">g^{\\mu}=h</span> breaking the discrete log assumption with non-negligible probability. In more detail, given discrete-logarithm challenge <span class="math">(g,h)</span>, adversary <span class="math">\\mathcal{C}</span> generates the SRS accordingly with known <span class="math">s</span> and <span class="math">t</span>. Then <span class="math">\\mathcal{C}</span> runs <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{E}</span> to extract <span class="math">\\bm{a},\\bm{a}^{\\prime},\\bm{a}^{\\prime\\prime},r_{a},r^{\\prime}_{a},r^{\\prime\\prime}_{a}</span> and by equations 31, 34, 35 solves for <span class="math">\\mu</span> such that <span class="math">h=g^{\\mu}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mu=\\frac{\\sum_{i=0}^{n-1}s^{i}a_{i}+\\ell_{i}(t)a^{\\prime}_{i}-(s^{i}+\\ell_{i}(t))a^{\\prime\\prime}_{i}}{r^{\\prime\\prime}_{a}-(r^{\\prime}_{a}+r_{a})}</span></p>

    <p class="text-gray-300">Returning to adversary <span class="math">\\mathcal{B}</span>, by assumption, because <span class="math">\\bm{a}\\neq\\bm{a}^{\\prime}</span>, we must have <span class="math">\\bm{a}\\neq\\bm{a}^{\\prime\\prime}</span> or <span class="math">\\bm{a}^{\\prime}\\neq\\bm{a}^{\\prime\\prime}</span>. We consider both cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that <span class="math">\\bm{a}\\neq\\bm{a}^{\\prime\\prime}</span>. If <span class="math">b\\neq 0</span> then abort. Otherwise, by equations 31, 34, 35 we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=\\prod_{i=0}^{n-1}g^{s^{i}a_{i}}\\cdot h^{r_{a}}</span> <span class="math">A^{\\prime}_{1}</span> <span class="math">=\\prod_{i=0}^{n-1}g^{\\ell_{i}(t)a^{\\prime}_{i}}\\cdot h^{r^{\\prime}_{a}}</span> <span class="math">A\\cdot A^{\\prime}_{1}</span> <span class="math">=\\prod_{i=0}^{n-1}g^{(s^{i}+\\ell_{i}(t))a^{\\prime\\prime}_{i}}\\cdot h^{r^{\\prime\\prime}_{a}}.</span></p>

    <p class="text-gray-300">Thus we have</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{n-1}g^{s^{i}a_{i}}\\cdot h^{r_{a}}\\cdot\\prod_{i=0}^{n-1}g^{\\ell_{i}(t)a^{\\prime}_{i}}\\cdot h^{r^{\\prime}_{a}}=\\prod_{i=0}^{n-1}g^{(s^{i}+\\ell_{i}(t))a^{\\prime\\prime}_{i}}\\cdot h^{r^{\\prime\\prime}_{a}}</span></p>

    <p class="text-gray-300">By equation 36 we have</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{n-1}g^{s^{i}a_{i}}\\cdot\\prod_{i=0}^{n-1}g^{\\ell_{i}(t)a^{\\prime}_{i}}=\\prod_{i=0}^{n-1}g^{(s^{i}+\\ell_{i}(t))a^{\\prime\\prime}_{i}}</span> (37)</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{n-1}g^{(s^{i}+\\ell_{i}(t))a_{i}^{\\prime\\prime}-s^{i}a_{i}-\\ell_{i}(t)a_{i}^{\\prime}}=g^{0}</span> (38)</p>

    <p class="text-gray-300">Now consider polynomial</p>

    <p class="text-gray-300"><span class="math">P(X)=\\sum_{i=0}^{n-1}(X^{i}+\\ell_{i}(t))a_{i}^{\\prime\\prime}-X^{i}a_{i}-\\ell_{i}(t)a_{i}^{\\prime}.</span></p>

    <p class="text-gray-300">Because <span class="math">b=0</span>, we have that <span class="math">s=\\sigma</span>. Therefore by equation 38 we have that <span class="math">P(\\sigma)=0</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. Additionally, because <span class="math">\\bm{a}^{\\prime\\prime}\\neq\\bm{a}</span>, we have that <span class="math">P</span> is not the zero polynomial. Therefore <span class="math">\\mathcal{E}</span> can solve efficiently for <span class="math">\\sigma</span> by iterating through the roots of <span class="math">P</span> until we find one that satisfies the challenge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose instead that <span class="math">\\bm{a}^{\\prime}\\neq\\bm{a}^{\\prime\\prime}</span>. If <span class="math">b\\neq 1</span> then abort. Consider polynomial</li>

    </ul>

    <p class="text-gray-300"><span class="math">Q(X)=\\sum_{i=0}^{n-1}(s^{i}+\\ell_{i}(X))a_{i}^{\\prime\\prime}-s^{i}a_{i}-\\ell_{i}(X)a_{i}^{\\prime}</span></p>

    <p class="text-gray-300">By equations 31, 34, 35, and 36, and a similiar argument as in the previous case, we have that <span class="math">Q(\\sigma)=0</span> with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>. Additionally, because <span class="math">\\bm{a}^{\\prime\\prime}\\neq\\bm{a}^{\\prime}</span>, we have that <span class="math">Q</span> is not the zero polynomial. Therefore <span class="math">\\mathcal{E}</span> can solve for <span class="math">\\sigma</span> by iterating through the roots of <span class="math">Q</span> until we find one that satisfies the challenge.</p>

    <p class="text-gray-300">Therefore either <span class="math">\\bm{a}=\\bm{a}^{\\prime\\prime}=\\bm{a}^{\\prime}</span> or <span class="math">\\mathcal{B}</span> succeeds in breaking the <span class="math">(n-1)</span>-SDH assumption with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We now analyze the success probability of <span class="math">\\mathcal{B}</span>. Let <span class="math">\\delta</span> be the success probability of <span class="math">\\mathcal{A}</span>. From the above reasoning we have that <span class="math">\\delta=\\delta_{1}+\\delta_{2}</span>, where <span class="math">\\delta_{1}</span> is the probability that <span class="math">\\mathcal{A}</span> succeeds with <span class="math">\\bm{a}\\neq\\bm{a}^{\\prime\\prime}</span>, and <span class="math">\\delta_{2}</span> is the probability that <span class="math">\\mathcal{A}</span> succeeds with <span class="math">\\bm{a}^{\\prime}\\neq\\bm{a}^{\\prime\\prime}</span>. <span class="math">\\mathcal{B}</span> is successful when <span class="math">\\bm{a}\\neq\\bm{a}^{\\prime\\prime}</span> and <span class="math">b=0</span>, or when <span class="math">\\bm{a}^{\\prime}\\neq\\bm{a}^{\\prime\\prime}</span> and <span class="math">b=1</span>. Thus, because <span class="math">\\Pr[b=0]=\\Pr[b=1]=1/2</span>, the probability that <span class="math">\\mathcal{B}</span> succeeds is <span class="math">\\delta_{1}/2+\\delta_{2}/2-\\mathsf{negl}(\\lambda)=\\delta/2-\\mathsf{negl}(\\lambda)</span>. Therefore if <span class="math">\\delta</span> is a non-negligible probability, <span class="math">\\mathcal{B}</span> succeeds in breaking the <span class="math">(n-1)</span>-SDH assumption with non-negligible probability.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Lemma 15.</h6>

    <p class="text-gray-300">Construction 4 is an argument system for <span class="math">\\mathcal{R}_{\\mathsf{IP}}</span> that is honest-verifier zero-knowledge.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prover honest-verifier zero-knowledge we must construct simulator <span class="math">\\mathcal{S}</span> that can simulate a transcript indistinguishable from one generated by an honest interaction for any given statement with a valid witness. We construct <span class="math">\\mathcal{S}</span> as follows:</p>

    <p class="text-gray-300">Consider arbitrary statement <em>with a valid witness</em> consisting of commitments <span class="math">A^{\\prime},B^{\\prime},C</span> and scalar <span class="math">r</span>. First, <span class="math">\\mathcal{S}</span> generates the common reference string and the</p>

    <p class="text-gray-300">associated trapdoor <span class="math">\\delta</span>. Next, <span class="math">\\mathcal{S}</span> sets <span class="math">\\boldsymbol{a}=\\boldsymbol{b}=\\boldsymbol{0}</span> and computes commitments <span class="math">A</span> and <span class="math">B</span> as dictated by the protocol. Next, <span class="math">\\mathcal{S}</span> uses trapdoor <span class="math">\\delta</span> to forge <span class="math">A^{\\prime\\prime}</span> and <span class="math">B^{\\prime\\prime}</span> such that the verifier’s checks pass:</p>

    <p class="text-gray-300"><span class="math">A^{\\prime\\prime}</span> <span class="math">\\coloneqq(A\\cdot A^{\\prime}_{1})^{\\frac{1}{2}}</span> <span class="math">B^{\\prime\\prime}</span> <span class="math">\\coloneqq(B\\cdot B^{\\prime}_{1})^{\\frac{1}{2}}.</span></p>

    <p class="text-gray-300">In the final round, <span class="math">\\mathcal{S}</span> can simulate a transcript indistinguishable from honest inner-product argument due to the honest-verifier zero-knowledge property of the inner product argument (Lemma 12).</p>

    <p class="text-gray-300">In both the real and ideal settings the terms <span class="math">A</span> and <span class="math">B</span> are indistinguishable from random elements in <span class="math">\\mathbb{G}</span> due to the blinding terms. Additionally, in both the real and ideal setting, terms <span class="math">A^{\\prime\\prime}</span> and <span class="math">B^{\\prime\\prime}</span> are uniquely fixed by <span class="math">A</span>, <span class="math">B</span>, and the statement under the same relation. Thus an adversary cannot use terms <span class="math">A^{\\prime\\prime}</span> and <span class="math">B^{\\prime\\prime}</span> to distinguish between the real and ideal setting.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Lemma 16 (Efficiency).</h6>

    <p class="text-gray-300">For vectors of size <span class="math">n</span> construction 4 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover, and an <span class="math">O_{\\lambda}(\\log n)</span> verifier.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">At a high level, construction 4 adds an <span class="math">O_{\\lambda}(n)</span> time overhead to the generator and prover and an <span class="math">O_{\\lambda}(1)</span> overhead to the verifier. Therefore by the asymptotics of construction 3 (Lemma 13), construction 4 achieves the stated asymptotics. In more detail:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generator: In addition to running the generator for the inner-product argument, <span class="math">\\mathcal{G}</span> needs to compute <span class="math">\\boldsymbol{l},\\boldsymbol{l}^{\\prime},\\boldsymbol{t}</span> which can be done with 3 multi-exponentiations of size <span class="math">n</span>, which can be done in <span class="math">O_{\\lambda}(n/\\log n)</span> exponentiations by Pippenger’s algorithm <em>[59]</em>.</li>

      <li>Prover: In addition to running the inner-product argument, which takes <span class="math">O_{\\lambda}(n)</span> time, <span class="math">\\mathcal{P}</span> can compute <span class="math">A,B,A^{\\prime\\prime},B^{\\prime\\prime}</span> with 4 multi-exponentiations of size <span class="math">n</span>.</li>

      <li>Verifier: In addition to running the inner-product argument which takes <span class="math">O_{\\lambda}(\\log n)</span> time, the verifier needs to perform 4 pairing operations which can be done in <span class="math">O_{\\lambda}(1)</span> time.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-98" class="text-xl font-semibold mt-8">D.6 Proof of Theorem 5 (Argument System for <span class="math">\\mathcal{R_{ACS}}</span>)</h3>

    <h6 id="sec-99" class="text-base font-medium mt-4">Lemma 17 (Correctness).</h6>

    <p class="text-gray-300">Construction 6 satisfies completeness and soundness.</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness and soundness follow from the description of construction 6 and the correctness and soundness of the underlying protocols ∎</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Lemma 18 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 6 satisfies knowledge soundness.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">By the soundness of construction 6 (Lemma 17), an accepting verifier implies a valid shifted witness <span class="math">w^{\\prime}</span> with negligible soundness error. By the extractibility of the polynomial commitment scheme (Construction 1), an extractor <span class="math">\\mathcal{E}</span> can extract <span class="math">w^{\\prime}</span> from the prover’s initial commitment, and return the reconstructed witness <span class="math">\\bm{w}</span>. ∎</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Lemma 19 (Zero Knowledge).</h6>

    <p class="text-gray-300">Construction 6 satisfies honest-verifier zero-knowledge</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Intuitively, honest-verifier zero-knowledge holds because the prover only sends perfectly hiding polynomial commitments to the verifier and engages in honest-verifier zero-knowledge arguments regarding these commitments. We formally argue honest-verifier zero-knowledge by constructing a simulator:</p>

    <p class="text-gray-300">To prove honest-verifier zero-knowledge we must construct a simulator <span class="math">\\mathcal{S}</span> that can simulate a transcript indistinguishable from one generated by an honest interaction for any given statement with a valid witness. We construct <span class="math">\\mathcal{S}</span> as follows:</p>

    <p class="text-gray-300">Consider arbitrary <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> statement <em>with a valid witness</em>. <span class="math">\\mathcal{S}</span> sets the witness <span class="math">\\bm{w}</span> to <span class="math">\\bm{0}</span> and proceeds to run an interaction between an honest prover and verifier as dictated by the protocol, with the following changes</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">\\mathcal{S}</span> needs to simulate a polynomial evaluation argument, it runs the simulator for the polynomial evaluation argument (Lemma 9).</li>

      <li>When <span class="math">\\mathcal{S}</span> needs to simulate an inner-product argument, it runs the simulator for the inner-product argument (Lemma 15).</li>

      <li>When <span class="math">\\mathcal{S}</span> needs to simulate the multi-Hadamard-product argument, it runs the simulator for the multi-Hadamard argument (Lemma 4)</li>

    </ul>

    <p class="text-gray-300">By the hiding property of the polynomial commitment scheme (Lemma 2) the honest prover’s commitments and the simulated commitments are indistinguishable. Next by lemma 9, lemma 15, and lemma 4 the simulator’s transcripts for the polynomial evaluation, inner-product, and multi-Hadamard-product arguments are indistinguishable from that of an honest interaction. This implies that the simulator’s overall transcript is indistinguishable from that of an honest interaction.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Lemma 20 (Efficiency).</h6>

    <p class="text-gray-300">For a sparse size <span class="math">n</span> <span class="math">\\mathcal{R}_{\\mathsf{ACS}}</span> instance with input vector size <span class="math">x</span>, Construction 6 features an <span class="math">O_{\\lambda}(n)</span> generator, <span class="math">O_{\\lambda}(n)</span> prover and an <span class="math">O_{\\lambda}(\\log n+x)</span> verifier.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The generator must run the generators for all the subarguments; this can be done in <span class="math">O_{\\lambda}(n)</span> time by Lemma 2, and Theorems 1, 2, 3, and 4. Additionally the generator must compute evaluations of auxiliary polynomials <span class="math">v_{H}</span>, <span class="math">v_{N}</span>, <span class="math">v_{K}</span>, <span class="math">v_{[n-m]}</span>, <span class="math">u_{H}</span>, and <span class="math">u_{N}</span>, which can be computed in <span class="math">O_{\\lambda}(n/\\log n)</span> exponentiations by Pippenger’s algorithm <em>[59]</em> if the associated vanishing domains are multiplicative subgroups (Definition 5).</p>

    <p class="text-gray-300">As claimed in Construction 6 the prover can efficiently compute polynomials <span class="math">P_{1}</span>, <span class="math">P_{2}</span>, and <span class="math">P_{3}</span> in linear time by constructing a lookup table, as discussed by Chiesa et al. <em>[28]</em>. For completeness, we describe how to construct such a lookup table for polynomial <span class="math">P_{1}</span> in supplementary section E. For the remainder of the argument the prover commits to evaluation-based representations of polynomials <span class="math">w^{\\prime}</span>, <span class="math">z</span>, <span class="math">P_{1}</span>, <span class="math">P_{2}</span>, <span class="math">P_{3}</span>. By Lemma 2 this is dominated by 10 multi-exponentiations of size <span class="math">O_{\\lambda}(n)</span> total. Next the prover engages in a polynomial-evaluation argument to verifiably evaluate <span class="math">z(\\tau)</span>, <span class="math">w^{\\prime}(\\tau)</span>, <span class="math">v_{[n-m]}(\\tau)</span>, <span class="math">P_{1}(\\beta)</span>, <span class="math">P_{2}(\\gamma)</span>, <span class="math">v_{H}(\\alpha)</span>, <span class="math">v_{N}(\\beta)</span>, and <span class="math">v_{N}(\\gamma)</span>. By Theorem 1, this is dominated by 16 multi-exponentiations of size <span class="math">n</span> total. The prover engages in three inner-product arguments over vector pairs <span class="math">(z,P_{1})</span>, <span class="math">(z,P_{2})</span>, and <span class="math">(\\mathbf{1},P_{3})</span>. By Theorem 2 and Theorem 3, this is dominated by 48 multi-exponentiations of size <span class="math">O(n)</span> total. Finally, the prover engages in an multi-Hadamard argument over vectors <span class="math">P_{3},\\mathsf{A}^{\\prime},\\mathsf{B}^{\\prime},\\mathsf{C}^{\\prime}</span> and <span class="math">\\mathsf{V}^{\\prime}</span>. By Theorem 4 and Theorem 3 this is dominated by 20 multi-exponentiations of size <span class="math">n</span> total.</p>

    <p class="text-gray-300">The verifier computes <span class="math">\\boldsymbol{x}(\\tau)</span> for some random <span class="math">\\tau\\stackrel{{\\scriptstyle\\S}}{{\\leftarrow}}\\mathbb{F}</span>, which takes linear time in the size of the input vector. Next, the verifier checks 8 polynomial-evaluation arguments. By Theorem 1, this can be one in <span class="math">O_{\\lambda}(1)</span> time. Next the verifier checks 3 inner-product arguments in the main interaction. By Theorem 2, this can be done in <span class="math">O_{\\lambda}(\\log n)</span> time. Finally the verifier checks a single multi-Hadamard argument. By Theorem 4 this can be done in <span class="math">O_{\\lambda}(\\log n)</span> time. We note that the core multi-Hadamard argument features a constant-time verifier, with the underlying inner-product argument incurring the logarithmic overhead. ∎</p>

    <h2 id="sec-106" class="text-2xl font-bold">Appendix E Using a Lookup Table to Efficiently Compute Polynomials <span class="math">P_{1}</span>, <span class="math">P_{2}</span>, <span class="math">P_{3}</span> in the Main Argument</h2>

    <p class="text-gray-300">As claimed in construction 6 polynomials <span class="math">P_{1}</span>, <span class="math">P_{2}</span>, and <span class="math">P_{3}</span> can be efficiently computed in linear time by constructing a lookup table as discussed by Chiesa et al. <em>[28]</em>. We demonstrate how to compute this lookup table for in order to efficiently compute <span class="math">P_{1}</span> (similiar strategies can be used for <span class="math">P_{2}</span> and <span class="math">P_{3}</span>). We first observe that by definition</p>

    <p class="text-gray-300"><span class="math">P_{1}(b)=\\sum_{c\\in N}\\sum_{k\\in K}P(k,\\alpha,b,c)z(c).</span></p>

    <p class="text-gray-300">Because <span class="math">u_{N}(c,\\mathsf{C}(k))</span> is non-zero only when <span class="math">c=\\mathsf{C}(k)</span> we have that</p>

    <p class="text-gray-300"><span class="math">P_{1}(b)=\\sum_{k\\in K}P(k,\\alpha,b,\\mathsf{C}(k))z(\\mathsf{C}(k)).</span></p>

    <p class="text-gray-300">Additionally, because <span class="math">u_{N}(b,\\mathsf{B}(k))</span> is non-zero only when <span class="math">b=\\mathsf{B}(k)</span> we have that</p>

    <p class="text-gray-300"><span class="math">P_{1}(b)=\\sum_{k\\text{ s.t. }b=\\mathsf{B}(k)}P(k,\\alpha,b,\\mathsf{C}(k))z(\\mathsf{C}(k)).</span></p>

    <p class="text-gray-300">Thus, to compute <span class="math">P_{1}(b)</span> for all <span class="math">b\\in N</span>, the prover first precomputes <span class="math">u_{H}(\\alpha,a)=v_{H}(\\alpha)/(\\alpha-a)</span> for all <span class="math">a\\in H</span>. By design, the prover is provided evaluations of</p>

    <p class="text-gray-300">polynomials <span class="math">\\mathsf{A},\\mathsf{B},\\mathsf{C}</span> and <span class="math">z</span>. Given the precomputed evaluations, the prover can efficiently compute <span class="math">P_{1}(b)</span> for all <span class="math">b\\in N</span> as follows</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initially set <span class="math">P_{1}(b)=0</span> for all <span class="math">b\\in N</span></li>

      <li>For all <span class="math">k\\in K</span> compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">P(k,\\alpha,\\mathsf{B}(k),\\mathsf{C}(k))z(\\mathsf{C}(k))</span></p>

    <p class="text-gray-300">in <span class="math">O_{\\lambda}(1)</span> time using the precomputations and add the resulting value to <span class="math">P_{1}(\\mathsf{B}(k))</span>.</p>

    <h2 id="sec-107" class="text-2xl font-bold">Appendix F Additional Concrete Optimizations</h2>

    <h6 id="sec-108" class="text-base font-medium mt-4">Construction 10 (Batched Inner Product).</h6>

    <p class="text-gray-300">The zero argument presented in construction 5 can be generalized to argue that the sum of inner-products of vectors sums to arbitrary value <span class="math">\\sigma</span>. Multiple arguments for the inner-product can be batched by taking random linear combinations of the vectors in question and applying the zero argument. In our main argument system, this reduces the total number of inner-product arguments from 3 to 1. Note that the multi-Hadamard product argument still requires it’s own separate inner-product argument.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Construction 11 (Batched Polynomial Evaluation).</h6>

    <p class="text-gray-300">As shown by Chiesa et al. <em>[28]</em>, multiple polynomial evaluation arguments over polynomials of the same degree over the same evaluation point can be batched by taking random linear combinations of the polynomials and evaluations in question. In our system, the sub-argument to check that <span class="math">(u,v)</span> were computed correctly as part of the inner-product argument (Construction 3) requires two polynomial evaluation arguments that matches this criteria. Therefore in each inner product argument batching enables a single polynomial evaluation argument instead of two.</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Construction 12 (Cheaper Polynomial Commitments in the Algebraic Group Model).</h6>

    <p class="text-gray-300">When proven secure in the Algebraic Group Model <em>[37]</em> in contrast to the plain model, we can modify our polynomial evaluation argument such that commitment and evaluation only costs a single multi-exponentiation of size <span class="math">n</span> using techniques similiar to Chiesa et al. <em>[28]</em>.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Remark 2 (Resulting Cost Breakdown).</h6>

    <p class="text-gray-300">In supplementary section F, we detail additional minor concrete optimizations. Applying these optimizations, the prover’s total cost breaks down as follows: 5 multi-exponentiations of size <span class="math">n</span> (<span class="math">n</span>-MEXP) for polynomial commitments, 4 <span class="math">n</span>-MEXPs for polynomial evaluations, 15 <span class="math">n</span>-MEXPs for the multi-Hadamard-product argument, and 11 <span class="math">n</span>-MEXPs for the inner-product arguments. This puts the prover’s total dominating cost at 35 <span class="math">n</span>-MEXPs. The verifier’s total dominating costs are 34 pairings.</p>`;
---

<BaseLayout title="Poppins: A Direct Construction for Asymptotically Optimal zk... (2020/1318)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1318
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
