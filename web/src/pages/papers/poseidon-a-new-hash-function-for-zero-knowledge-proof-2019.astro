---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/458';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Poseidon: A New Hash Function for Zero-Knowledge Proof Systems';
const AUTHORS_HTML = 'Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, Markus Schofnegger';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The area of practical computational integrity proof systems, like SNARKs, STARKs, Bulletproofs, is seeing a very dynamic development with several constructions having appeared recently with improved properties and relaxed setup requirements. Many use cases of such systems involve, often as their most expensive part, proving the knowledge of a preimage under a certain cryptographic hash function, which is expressed as a circuit over a large prime field. A notable example is a zero-knowledge proof of coin ownership in the Zcash cryptocurrency, where the inadequacy of the SHA-256 hash function for such a circuit caused a huge computational penalty.

In this paper, we present a modular framework and concrete instances of cryptographic hash functions which work natively with GF(p) objects. Our hash function Poseidon uses up to 8x fewer constraints per message bit than Pedersen Hash.

Our construction is not only expressed compactly as a circuit, but can also be tailored for various proof systems using specially crafted polynomials, thus bringing another boost in performance. We demonstrate this by implementing a 1-out-of-a-billion membership proof with Merkle trees in less than a second by using Bulletproofs.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Zero-Knowledge Proof Systems &middot; SNARK &middot; STARK &middot; Hash Function</p>
    </section>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The HADES Design Strategy for Hashing</h3>

    <p class="text-gray-300">Cryptographic permutations usually consist of an efficient round function which is applied sufficiently many times in order to make the permutation behave like a randomly drawn one. In general, the same round function is used throughout the permutation, in order to destroy all of its possible symmetries and structural properties.</p>

    <p class="text-gray-300">In HADES we consider different round functions within the same construction. More precisely, we mix rounds with <em>full S-box layers</em> and rounds with <em>partial S-box layers</em>. The motivation to have different types of rounds is that full S-box layers are expensive in software and ZK proof systems but are a good protection against statistical attacks, whereas partial layers are relatively cheap but are, in some cases, similarly good as full ones against algebraic attacks.</p>

    <p class="text-gray-300"><strong>Details on the HADES Strategy.</strong> The HADES design strategy consists of  <span class="math">R_f</span>  rounds in the beginning, in which S-boxes are applied to the full state. After these rounds,  <span class="math">R_P</span>  rounds in the middle contain only a single S-box in each round, and the rest of the state goes through the nonlinear layer unchanged (i.e., identity functions are used instead of the missing S-boxes). Finally,  <span class="math">R_f</span>  rounds at the end are applied by again using S-boxes for the full state.</p>

    <p class="text-gray-300">The idea of this approach is to provide arguments for the security against statistical attacks using the  <span class="math">R_F = 2R_f</span>  rounds with full S-box layers in the beginning and in the end together with the wide trail strategy [DR01], which is also used in, e.g., the AES [DR02]. On the other hand, the  <span class="math">R_P</span>  rounds with partial S-box layers are a more efficient way to increase the degree of the overall function, and are mainly used for arguments against algebraic attacks.</p>

    <p class="text-gray-300">A detailed overview of this approach is shown in Fig. 2.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>We present the Sponge construction over a binary field in order to follow the presentation made in [BDPA08]. It can easily be generalized for a prime field  <span class="math">\\mathbb{F}_p^l</span>  by replacing each (N/t)-bit word by a  <span class="math">(\\lceil \\log_2(p) \\rceil)</span> -bit one.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup>In other words, the permutation cannot be distinguished from a randomly drawn permutation.</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Construction of the HADES-based POSEIDON<sup> <span class="math">\\pi</span> </sup> permutation.</p>

    <p class="text-gray-300"><strong>The Round Function.</strong> Each round function of our POSEI-DON permutation consists of the following three components.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>AddRoundConstants, denoted by  <span class="math">ARC(\\cdot)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>SubWords</em>, denoted by S-box( <span class="math">\\cdot</span> ) or by  <span class="math">SB(\\cdot)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>MixLayer</em>, denoted by  <span class="math">M(\\cdot)</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The MixLayer operation is the linear layer of our construction, and it consists in multiplying the state with a  <span class="math">t \\times t</span>  MDS matrix in order to apply the wide trail strategy.</p>

    <p class="text-gray-300">In total we get:</p>

    <p class="text-gray-300"><span class="math">$\\underbrace{ARC \\to SB \\to M}_{\\text{First round}} \\to \\cdots \\to \\underbrace{ARC \\to SB \\to M}_{(R-1)\\text{-th round}} \\to \\underbrace{ARC \\to SB \\to M}_{R\\text{-th round}}</span>$</p>

    <p class="text-gray-300">While  <span class="math">ARC(\\cdot)</span>  and  <span class="math">M(\\cdot)</span>  are the same in each round, the number of S-boxes is not the same, namely</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">R_f + R_f = R_F</span>  rounds have <em>full</em> S-box layers, i.e., t S-box functions, and</li>
      <li><span class="math">R_P</span>  rounds have <em>partial</em> S-box layers, i.e., 1 S-box and (t-1) identity functions.</li>
    </ul>

    <p class="text-gray-300">We refer to [GLR<sup>+</sup>20] for more details about the HADES design strategy.</p>

    <p class="text-gray-300"><strong>Interaction Between Full and Partial Rounds.</strong> Note that the same number of full rounds can be used instead of the partial rounds without decreasing the security, but this leads to substantially higher costs in our target applications. However, replacing t partial rounds with one full round may keep the costs in our target applications similar, but the security may be severely decreased due to a significantly lower degree of 1 full round compared to t partial rounds.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 The Permutation Family Poseidon <span class="math">^{\\pi}</span></h3>

    <p class="text-gray-300">The HADES design strategy provides a good starting point for our new hash function. Indeed, the combination of full and partial rounds allows us to make strong arguments about the security, while also exploiting the smaller number of S-boxes in the partial rounds in order to gain efficiency in the target applications.</p>

    <p class="text-gray-300">The primary application of our design is hashing in large prime fields, hence  <span class="math">POSEIDON^{\\pi}</span>  takes inputs of  <span class="math">t \\ge 2</span>  words in  <span class="math">\\mathbb{F}_p</span> , where p is a prime of size  <span class="math">p \\approx 2^n &gt; 2^{30}</span>  (i.e.,  <span class="math">\\lceil \\log_2(p) \\rceil = n \\ge 31</span> ). We will now describe the components of each  <span class="math">POSEIDON^{\\pi}</span>  round in detail.</p>

    <p class="text-gray-300">The S-Box Layer. For the applications we have in mind, we focus on the  <span class="math">\\alpha</span> -power S-box, defined by S-box <span class="math">(x)=x^{\\alpha}</span> , where  <span class="math">\\alpha \\geq 3</span>  is the <strong>smallest</strong> positive integer that satisfies  <span class="math">\\gcd(\\alpha,p-1)=1</span> . In the following, these permutations are called &quot; <span class="math">x^{\\alpha}</span> -Poseidon&quot;. Examples are given by  <span class="math">\\alpha=3</span>  ( <span class="math">x^3</span> -Poseidon&quot;) if  <span class="math">p\\neq 1 \\mod 3</span> , or  <span class="math">\\alpha=5</span>  ( <span class="math">x^5</span> -Poseidon&quot;) if  <span class="math">p=1 \\mod 3</span>  and  <span class="math">p\\neq 1 \\mod 5</span> .</p>

    <p class="text-gray-300">It turns out that the S-box  <span class="math">x^5</span>  is suitable for two of the most popular prime fields in ZK applications, concretely the prime subfields of the scalar field of the BLS12-381 and BN254 curves, so we mainly consider this S-box, but try to present generic cryptanalytic results for other cases whenever possible.</p>

    <p class="text-gray-300"><strong>The Linear Layer.</strong> A  <span class="math">t \\times t</span>  MDS matrix with elements in  <span class="math">\\mathbb{F}_p</span>  exists if  <span class="math">2t + 1 \\le p</span>  (see [MS78] for details).</p>

    <p class="text-gray-300">Given p and t, there are several ways to construct an MDS matrix. One of them is using a Cauchy matrix [YMT97], which we recall here briefly. For  <span class="math">x_i, y_i \\in \\mathbb{F}_p</span> , where  <span class="math">i \\in [1, t]</span> , the entries of the matrix  <span class="math">\\mathcal{M}</span>  are defined by</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_{i,j} = \\frac{1}{x_i + y_j},</span>$</p>

    <p class="text-gray-300">where the entries of  <span class="math">\\{x_i\\}_{1 \\le i \\le t}</span>  and  <span class="math">\\{y_i\\}_{1 \\le i \\le t}</span>  are pairwise distinct and  <span class="math">x_i + y_i \\ne 0</span> , where  <span class="math">i \\in \\{1, ..., t\\}</span>  and  <span class="math">j \\in \\{1, ..., t\\}</span> .</p>

    <p class="text-gray-300"><strong>Avoiding Insecure Matrices.</strong> We emphasize that not every MDS matrix provides the same level of security. In particular, the matrix  <span class="math">\\mathcal{M}</span>  must prevent the possibility to set up</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>A matrix  <span class="math">M \\in \\mathbb{F}^{t \\times t}</span>  is called <em>maximum distance separable</em> (MDS) iff it has a branch number  <span class="math">\\mathcal{B}(M)</span>  equal to  <span class="math">\\mathcal{B}(M) = t + 1</span> . The branch number of M is defined as  <span class="math">\\mathcal{B}(M) = \\min_{x \\in \\mathbb{F}^t} \\{ \\operatorname{wt}(x) + \\operatorname{wt}(M(x)) \\}</span> , where wt is the Hamming weight in wide trail terminology. Equivalently, a matrix M is MDS iff every submatrix of M is non-singular.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) invariant (or iterative) subspace trails [GRR16a] (or equivalently, truncated differentials) with prob. 1 with inactive S-boxes over more than t-1 rounds<sup>8</sup> (more details are given in the following), or</li>
      <li>(2) invariant (or iterative) subspace trails with prob. 1 and with active S-boxes for any number of rounds.</li>
    </ul>

    <p class="text-gray-300">Regarding the first point, let  <span class="math">S^i</span>  be the subspace s.t. no S-box is active in the first i consecutive rounds, that is,</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{S}^{(i)} := \\left\\{ v \\in \\mathbb{F}^t \\mid [\\mathcal{M}^j \\cdot v]_0 = 0 \\in \\mathbb{F}, j &lt; i \\right\\}, \\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">[x]_0</span>  denotes the first word of  <span class="math">x \\in \\mathbb{F}^t</span> ,  <span class="math">\\mathcal{S}^{(0)} = \\mathbb{F}^t</span> , and  <span class="math">\\dim\\left(\\mathcal{S}^{(i)}\\right) \\geq t-i</span> . For each pair of texts (x,y) in the same coset of  <span class="math">\\mathcal{S}^i</span> , no S-boxes are active in the first i consecutive rounds. Hence, a truncated differential with prob. 1 (or equivalently, a subspace trail) can be set up for the first  <span class="math">i \\leq t-1</span>  rounds. The matrix  <span class="math">\\mathcal{M}</span>  must be chosen s.t. no subspace trail with inactive/active S-boxes can be set up for more than t-1 rounds.</p>

    <p class="text-gray-300">A detailed analysis of matrix properties related to this attack vector can be found in [GRS21]. With these results in mind, we suggest the following method to generate matrices:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Randomly select pairwise distinct  <span class="math">\\{x_i\\}_{1 \\le i \\le t}</span>  and  <span class="math">\\{y_i\\}_{1 \\le i \\le t}</span> , where  <span class="math">x_i + y_j \\ne 0</span>  and where  <span class="math">i \\in \\{1, ..., t\\}</span>  and  <span class="math">j \\in \\{1, ..., t\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Determine if the matrix is secure using Algorithm 1, Algorithm 2, and Algorithm 3 provided<sup>9</sup> in [GRS21]. For a secure matrix, no infinitely long (invariant and/or iterative) subspace trail (with or without active S-boxes) can be set up for all rounds with partial S-box layers.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Repeat this procedure until a secure matrix is found.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We used this method to generate the matrices for the instantiations given in Section 4. For [GRS21, Algorithm 3], we used a search period of l=4t, and we additionally made sure that no invariant subspace trails with active S-boxes exist for  <span class="math">M, M^2, \\ldots, M^l</span> . In our experiments, we observed that only a few trials are needed in order to find a secure matrix for sufficiently large fields.</p>

    <p class="text-gray-300">To summarize, this approach allows us to make sure that our MDS matrices do not exhibit the vulnerabilities discussed in [GRS21], and our instantiations are thus secure against this specific type of attack.</p>

    <p class="text-gray-300"><strong>Efficient Implementation.</strong> We refer to Supplementary Material B for details about efficient POSEIDON<sup> <span class="math">\\pi</span> </sup> implementa-</p>

    <p class="text-gray-300">tions. The main advantage of these strategies consists of reducing the number of constant multiplications in each round with a partial S-box layer from  <span class="math">t^2</span>  to 2t, which is particularly useful for large t and  <span class="math">R_P</span> . For example, we implemented  <span class="math">x^3</span> -Poseidon<sup> <span class="math">\\pi</span> </sup> with  <span class="math">(n,t,R_F,R_P)=(64,24,8,42)</span>  in Sage, and we could observe that the performance improves by a factor of about 5, with the average computation time being 4 ms for the optimized version.</p>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Applications</h2>

    <p class="text-gray-300">We suggest POSEIDON for all applications of zero-knowledgefriendly hashing, concretely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using POSEIDON for commitments in various protocols, where the knowledge of the committed value is proven in zero knowledge: For this we suggest a single-call permutation-based hashing with POSEIDON-128 and widths from 2 to 5 field elements. The advantage over the Pedersen hash, for example, is that POSEIDON is faster and can also be used in signature schemes which allows for a smaller code footprint.</li>
      <li>Hashing multi-element objects with certain fields encoded as field elements, so that statements about these fields are proven in zero knowledge: We suggest variable-length sponge-based hashing with POSEIDON-128 or POSEIDON-80 with width 5 (and rate 4).</li>
      <li>Using Poseidon in Merkle trees to enable zeroknowledge proofs of knowledge of a leaf in the tree with optional statements about the leaf content: We recommend Merkle trees of arity 4 (i.e., width 5) with Po-SEIDON-128 as the most performant, but trees of more conventional arities can be used as well.</li>
      <li>Verifiable encryption with POSEIDON within Integrated Encryption Scheme [GMHES&Aacute;10]: Put POSEIDON inside the DuplexSponge authenticated encryption framework [BDPA11] and initialize it with a session key based on the recipient's public key. Then one can prove that the recipient can decrypt the ciphertext into a plaintext with certain properties.</li>
    </ul>

    <p class="text-gray-300">There exist several third-party protocols that already use PO-SEIDON in these use cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Filecoin employs POSEIDON for Merkle tree proofs with different arities and for two-value commitments. <sup>10</sup></li>
      <li>Dusk Network uses Poseidon to build a Zcash-like protocol for securities trading. 11 It also uses Poseidon for encryption as described above.</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;8</sup>This fixes a weakness in the previous version of POSEIDON, where specific choices of  <span class="math">\\mathcal{M}</span>  over  <span class="math">(\\mathbb{F}_p)^t</span>  could have resulted in vulnerable instances. We refer to [KR21,BCD<sup>+</sup>20] for more details.</p>

    <p class="text-gray-300"><sup>9</sup>https://extgit.iaik.tugraz.at/krypto/linear-layer-tool</p>

    <p class="text-gray-300"><sup>10</sup>https://github.com/filecoin-project/neptune</p>

    <p class="text-gray-300"><sup>11</sup>https://github.com/dusk-network/Poseidon252</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sovrin uses POSEIDON for Merkle-tree based revocation <a href="#page-17-6">[Lod19]</a>.</li>
      <li>Loopring uses POSEIDON for private trading on Ethereum.<a href="#page-7-3">12</a></li>
    </ul>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Concrete Instantiations of POSEIDON<sup>&pi;</sup></h2>

    <p class="text-gray-300">As of mid-2020, many protocols that employ zero-knowledge proofs use (or plan to use) pairing-based proof systems <a href="#page-18-0">[PHGR13,</a> <a href="#page-16-4">Gro16,</a> <a href="#page-17-1">GWC19,</a> <a href="#page-15-1">CHM</a>+20] or Bulletproofs <a href="#page-15-2">[BBB</a>+18]. The elliptic curves used by these systems are predominantly BLS12-381, BN254, and Ed25519. A hash function friendly for such a system would operate in the scalar prime field of the curve, and they all have a size of around 2 255 .</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Main Instances</h3>

    <p class="text-gray-300">We present POSEIDON<sup>&pi;</sup> permutations for such prime fields, and leave the other cases to the appendix. The S-box function can be chosen as <em>x</em> 5 in all cases, i.e., we use <em>x</em> 5 -POSEIDON for hashing in all such protocols, though the concrete fields are slightly different (this affects only constants and matrices, but not the number of rounds).</p>

    <p class="text-gray-300">The security levels <em>M</em> of 80 and 128 bits correspond to a 255-bit capacity, i.e., one field element. We focus on two possible widths, namely <em>t</em> = 3 and <em>t</em> = 5, as they correspond to popular cases of 2-to-1 and 4-to-1 compression functions. In the Merkle tree case, this corresponds to trees of arity 2 and 4, respectively. The round numbers for 80- and 128-bit security levels are given in Table <a href="#page-7-4">2,</a> and a more extensive set is given in the appendix. For <em>M</em> = 256 we select a capacity and an output of 2 255-bit elements (one 510-bit element is possible too).</p>

    <p class="text-gray-300">All our MDS matrices are Cauchy matrices, and the method to construct them is further described in Section <a href="#page-5-3">2.3.</a> We use sequences of integers for the construction.</p>

    <p class="text-gray-300">The round constants and matrices are generated using the Grain LFSR <a href="#page-17-7">[HJMM08]</a> in a self-shrinking mode, and the detailed initialization and generation are described in Supplementary Material <a href="#page-26-0">E.</a> Using this method, the generation of round constants and matrices depends on the specific instance, and thus different round constants are used even if some of the chosen parameters (e.g., <em>n</em> and <em>t</em>) are the same. Note that by using the Grain LFSR and instance-specific seed values, this approach is reminiscent of nothing-up-my-sleeve (NUMS) numbers. Indeed, letting the attacker freely choose round constants and/or matrices can lead to attacks.</p>

    <p class="text-gray-300">Table 2: Concrete instantiations of POSEIDON<sup>&pi;</sup> (with security margin) over BLS12-381, BN254, Ed25519 scalar fields.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">5<br>Instance (S-box: f(x) = x<br>)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RF</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">RP</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">POSEIDON&pi;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">POSEIDON&pi;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">POSEIDON&pi;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">120</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">We provide the round constants, the matrices, and test vectors in auxiliary files for four primary instantiations. We also make reference implementations for these instantiations and scripts to calculate the round numbers, the round constants, and the MDS matrices available online.<a href="#page-7-5">13</a> We refer to Supplementary Material <a href="#page-19-0">A</a> for a more detailed overview of the auxiliary files.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Domain Separation for POSEIDON</h3>

    <p class="text-gray-300">POSEIDON can be used in a number of applications, and having the same instance for all of them is suboptimal. Also, some protocols explicitly require several different hash functions. We suggest using domain separation for this, concretely encoding the use case in the capacity element (which is fine as it is 256 bits large and has a lot of bits to fill) and using some padding to distiguish inputs of different lengths if they may happen. Although a concrete form of domain separation constants is not security critical, we suggest a common methodology to unify potential implementations.</p>

    <p class="text-gray-300">Concretely, we propose:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Merkle Tree (all leafs are present, up to arity 32). The capacity is 2 <em>arity</em> &minus; 1. A generic case is considered in Supplementary Material <a href="#page-28-0">H.</a> We use no padding here.</li>
      <li>Merkle Tree (some leafs may be empty). The capacity value equals the bitmask of which leafs are present. We use no padding here.</li>
      <li>Variable-Input-Length Hashing. The capacity value is 2 <sup>64</sup> + (<em>o</em>&minus;1) where <em>o</em> the output length. The padding consists of one field element being 1, and the remaining elements being 0.</li>
      <li>Constant-Input-Length Hashing. The capacity value is <em>length</em> &middot;(2 <sup>64</sup>)+ (<em>o</em>&minus;1) where <em>o</em> the output length. The padding consists of the field elements being 0.</li>
      <li>Encryption. The capacity value is 2 <sup>32</sup>. The padding consists of the field elements being 0.</li>
    </ul>

    <p class="text-gray-300"><sup>12</sup><a href="https://tinyurl.com/y7tl537o" target="_blank" rel="noopener noreferrer">https://tinyurl.com/y7tl537o</a></p>

    <p class="text-gray-300"><sup>13</sup> <a href="https://extgit.iaik.tugraz.at/krypto/hadeshash" target="_blank" rel="noopener noreferrer">https://extgit.iaik.tugraz.at/krypto/hadeshash</a></p>

    <p class="text-gray-300">&bull; Future Uses. The capacity value is <em>identifier</em>&middot;(2 <sup>32</sup>). The padding depends on the application.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Cryptanalysis Summary of POSEIDON</h2>

    <p class="text-gray-300">As for any new design, it is paramount to present a concrete security analysis. In the following, we provide an in-depth analysis of the security of our construction. Due to a lack of any method to ensure that a hash function based on a sponge construction is secure against all possible attacks, we base our argumentation on the following consideration. As we just recalled in the previous section, when the internal permutation <em>P</em> of an (<em>N</em> = <em>c</em>+<em>r</em>)-bit sponge function is modeled as a randomly chosen permutation, the sponge hash function is indifferentiable from a random oracle up to 2 <em>c</em>/2 calls to <em>P</em>. Thus, we choose the number of rounds of the inner permutation case in order to provide security against distinguishers relevant to collision/preimage attacks. Equivalently, this means that such a number of rounds guarantees that <em>P</em> does not exhibit any relevant non-random/structural properties (among the ones known in the literature).</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Definitions</h3>

    <p class="text-gray-300">Definition 5.1. The function <em>F</em> is <em>T</em>-secure against collisions if there is no algorithm with expected complexity smaller than <em>T</em> that finds <em>x</em>1, <em>x</em><sup>2</sup> such that <em>F</em>(<em>x</em>1) = <em>F</em>(<em>x</em>2).</p>

    <p class="text-gray-300">Definition 5.2. The function <em>F</em> is <em>T</em>-secure against preimages if there is no algorithm with expected complexity smaller than <em>T</em> that for given <em>y</em> finds <em>x</em> such that <em>F</em>(<em>x</em>) = <em>y</em>.</p>

    <p class="text-gray-300">Definition 5.3. The function <em>F</em> is <em>T</em>-secure against second preimages if there is no algorithm with expected complexity smaller than <em>T</em> that for given <em>x</em><sup>1</sup> finds <em>x</em><sup>2</sup> such that <em>F</em>(<em>x</em>1) = <em>F</em>(<em>x</em>2).</p>

    <p class="text-gray-300">Definition 5.4. The invertible function <em>P</em> is <em>T</em>-secure against the CICO (<em>m</em>1,<em>m</em>2)-problem if there is no algorithm with expected complexity smaller than <em>T</em> that for given <em>m</em>1-bit <em>I</em><sup>1</sup> and <em>m</em>2-bit <em>O</em><sup>1</sup> finds <em>I</em>2,<em>O</em><sup>2</sup> such that <em>P</em>(<em>I</em>1||<em>I</em>2) = <em>P</em>(<em>O</em>1||<em>O</em>2).</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Security Claims</h3>

    <p class="text-gray-300">In terms of concrete security, we claim that POSEIDON-<em>M</em> is 2 <em><sup>M</sup></em>-secure against collisions and (second) preimages. To help increase confidence in our design and simplify external cryptanalysis, we also explicitly state another claim about our internal permutation: POSEIDON<sup>&pi;</sup> is 2 min(<em>M</em>,<em>m</em>1,<em>m</em>2) -secure against the CICO (<em>m</em>1,<em>m</em>2)-problem.</p>

    <p class="text-gray-300">Even though an attack below these thresholds may not affect any concrete applications of our hash functions, we would still consider it an important cryptanalytic result.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Summary of Attacks</h3>

    <p class="text-gray-300">Here we list the main points of our cryptanalysis results. The number of rounds <em>R</em> = <em>R<sup>P</sup></em> + <em>R<sup>F</sup></em> we can break depends on the security level <em>M</em> and the number of S-boxes <em>t</em>, which we specify for each concrete hash function instance in the next section.</p>

    <p class="text-gray-300">Before going on, we point out that for all attacks that are in common to the ones proposed for the cipher HadesMiMC <a href="#page-16-6">[GLR</a>+20], here we limit ourselves to report the main idea and result. For all other cases (namely, higher-order differentials, zero-sum partitions, Gr&ouml;bner basis attacks, and preimage attacks), we present here more details. In any case, <em>all details are provided as supplementary material.</em></p>

    <p class="text-gray-300">We highlight that the following cryptanalysis is not equivalent to the one presented for the block cipher HADESMiMC. Indeed, the scenarios are different (in one case the goal is to guarantee the impossibility to find the secret key, while here there is no secret key material and the goal is to guarantee that the internal permutation looks like a pseudo-random permutation). This means that certain attacks that we consider here are not valid in the case of a block cipher and vice-versa. Just to give some examples, the rebound attack <a href="#page-17-8">[LMR</a>+09<a href="#page-17-9">,MRST09]</a> holds only in the context studied here, while a MitM scenario (crucial in the case of an SPN cipher) does not work in the context of a sponge function, since the attacker does not know the full output. More details are given in the following.</p>

    <p class="text-gray-300">Proposition 5.1 (Informal). The following number of rounds for <em>x</em> 5 -POSEIDON-128 over F<em><sup>p</sup></em> with &asymp; 256-bit <em>p</em> protects against statistical and algebraic attacks:</p>

    <p class="text-gray-300"><span class="math">$R_F = 6,</span>$
<span class="math">R = R_F + R_P = 56 + \\lceil \\log_5(t) \\rceil.</span></p>

    <p class="text-gray-300"><em>Proof.</em> We substitute &alpha; = 5,<em>M</em> = 128 and log<sup>2</sup> (<em>p</em>) = 255 to Equations <a href="#page-9-3">(2)</a>,<a href="#page-9-4">(3)</a>,<a href="#page-10-1">(4)</a> and see that no one is satisfied, i.e., the attacks do not work.</p>

    <p class="text-gray-300">Proposition 5.2 (Informal). The following number of rounds for <em>x</em> 5 -POSEIDON-80 over F<em><sup>p</sup></em> with &asymp; 256-bit <em>p</em> protects against statistical and algebraic attacks:</p>

    <p class="text-gray-300"><span class="math">$R_F = 6,</span>$
<span class="math">R = R_F + R_P = 35 + \\lceil \\log_5(t) \\rceil.</span></p>

    <p class="text-gray-300">Proposition 5.3 (Informal). The following number of rounds for <em>x</em> 5 -POSEIDON-256 over F<em><sup>p</sup></em> with &asymp; 256-bit <em>p</em> protects against statistical and algebraic attacks:</p>

    <p class="text-gray-300"><span class="math">$R_F = 6,</span>$
<span class="math">R = R_F + R_P = 111 + \\lceil \\log_5(t) \\rceil.</span></p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Security Margin</h3>

    <p class="text-gray-300">Given the <em>minimum</em> number of rounds necessary to provide security against all attacks known in the literature, we <em>arbitrarily</em> decided to add</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) two more rounds with full S-box layers, and</li>
      <li>(2) 7.5% more rounds with partial S-box layers,</li>
    </ul>

    <p class="text-gray-300">i.e.,  <span class="math">+2 R_F</span>  and  <span class="math">+7.5\\% R_P</span> . The resulting number of rounds for our primary instances is given in Table 2.</p>

      <h3 id="sec-5.5" class="text-xl font-semibold mt-8">5.5 Attack details</h3>

    <p class="text-gray-300">All the attacks below are applied to the internal permutation  <span class="math">POSEIDON^{\\pi}</span> . The sponge framework dictates that all the attacks on the hash function with complexity below  <span class="math">2^{c/2}</span>  must result from attacks on the permutation. Thus we show that no such attack on the permutation should exist.</p>

      <h4 id="sec-5.5.1" class="text-lg font-semibold mt-6">5.5.1 Statistical Attacks</h4>

    <p class="text-gray-300"><strong>Differential/Linear Distinguishers.</strong> As shown in the appendix, at least 6 rounds with full S-box layers are necessary to provide security against the statistical attacks we consider. In more detail, for</p>

    <p class="text-gray-300">
<span class="math">$R_F &lt; \\begin{cases} 6 &amp; \\text{if } M \\le (\\lfloor \\log_2 p \\rfloor - C) \\cdot (t+1) \\\\ 10 &amp; \\text{otherwise} \\end{cases}</span>$
(2)</p>

    <p class="text-gray-300">linear [Mat93] and differential [BS91, BS93] attacks may be possible, where  <span class="math">\\mathcal{C} = \\log_2(\\alpha - 1)</span>  for  <span class="math">S(x) = x^{\\alpha}</span>  (where remember that  <span class="math">\\alpha</span>  is an odd integer number), e.g.,  <span class="math">\\mathcal{C} = 1</span>  for  <span class="math">S(x) = x^3</span>  and  <span class="math">\\mathcal{C} = 2</span>  for  <span class="math">S(x) = x^5</span> .</p>

    <p class="text-gray-300">Before going on, we highlight that we exploit only rounds with full S-box layers in order to prevent statistical attacks (as done in [GLR+20]). As explained in [KR21], under the assumption made for the linear layer in Section 2.3, it is possible to exploit both the rounds with partial and full S-box layers in order to guarantee security against some statistical attacks, like differential and linear attacks. Our decision to consider only rounds with full S-box layers has been made since a similar condition on the rounds with full S-box layers (e.g.,  <span class="math">R_F \\ge 6</span> ) is necessary for the security against some algebraic attacks (e.g., Gr&ouml;bner basis attacks &ndash; see in the following) and in order to provide simple security arguments for all statistical attacks (including e.g. the rebound one).</p>

    <p class="text-gray-300">(Invariant) Subspace Trails. We emphasize that the choice of the matrix that defines the linear layer, made in Section 2.3, prevents the existence of subspaces S that generate infinitely long subspace trails, namely a finite collection of subspaces  <span class="math">\\{S_0, \\ldots, S_{r-1}\\}</span>  s.t. each coset of  <span class="math">S_i</span>  is mapped into a coset of  <span class="math">S_{i+1}</span>  with probability 1 (where the index is taken modulo r) an arbitrary number of times. This allows to fix the weakness of the previous version of POSEIDON.</p>

    <p class="text-gray-300"><strong>Other Attacks.</strong> Finally, we briefly mention that the same number of rounds given before for the case of differential/linear attacks guarantees security against other attacks as truncated differentials [Knu94], impossible differentials [BBS99], rebound attacks [LMR+09, MRST09], and so on. More details are given in the appendix.</p>

      <h4 id="sec-5.5.2" class="text-lg font-semibold mt-6">5.5.2 Algebraic Attacks</h4>

    <p class="text-gray-300">In order to estimate the security against algebraic attacks, we evaluate the degree of the reduced-round permutations and their inverses. Roughly speaking, our results can be summarized as follows, where  <span class="math">n \\simeq \\log_2(p)</span> .</p>

    <p class="text-gray-300"><strong>Interpolation Attack.</strong> The interpolation attack [JK97] depends on the number of different monomials in the interpolation polynomial, where (an upper/lower bound of) the number of different monomials can be estimated given the degree of the function. The idea of such an attack is to construct an interpolation polynomial that describes the function. If the number of unknown monomials is sufficiently large, then this cannot be done faster than via a brute-force attack.</p>

    <p class="text-gray-300">For a security level of <em>M</em> bits, the number of rounds that can be attacked is</p>

    <p class="text-gray-300">
<span class="math">$R \\le \\lceil \\log_{\\alpha}(2) \\cdot \\min\\{M, \\log_{2}(p)\\} \\rceil + \\lceil \\log_{\\alpha} t \\rceil. \\tag{3}</span>$</p>

    <p class="text-gray-300">In general, the number of unknown monomials does not decrease when increasing the number of rounds. Hence, a higher number of rounds likely leads to a higher (or equal) security against this attack. We also consider various approaches of the attack (such as the MitM one) in Supplementary Material C.2.1.</p>

    <p class="text-gray-300"><strong>Gr&ouml;bner Basis Attack.</strong> In a Gr&ouml;bner basis attack [CLO97], one tries to solve a system of nonlinear equations that describe the function. The cost of such an attack depends on the degree of the equations, but also on the number of equations and on the number of variables. Since there are several ways for describing the studied permutation, there are several ways to set up such a system of equations and so the attack. Here, we focus on two extreme cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the first case, the attacker derives equations, one for each word, for the entire <em>r</em>-round permutation. Assuming  <span class="math">S(x) = x^{\\alpha}</span>  (analogous for the others), we show that the attack complexity is about  <span class="math">\\alpha^{2t}</span>  (see below), therefore for a security level of <em>M</em> bits the attack works at most on  <span class="math">\\log_{\\alpha} 2^{\\min\\{n/2, M/2\\}}</span>  rounds.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the second case, since a partial S-box layer is used, it may be more efficient to consider degree- <span class="math">\\alpha</span>  equations</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">for single S-boxes. In this case, more rounds can be necessary to guarantee security against this attack.</p>

    <p class="text-gray-300">In both cases, it is possible to make use of the existence of the subspace  <span class="math">\\mathcal{S}^{(r)}</span>  defined as in Eq. (1) in order to improve the attack. As shown in [BCD+20], such a subspace can be exploited in order to replace some nonlinear equations of the system that we are trying to solve with linear equations. Indeed, given a text in a coset of the subspace  <span class="math">\\mathcal{S}^{(r)}</span> , the output of such a text after r rounds with partial S-box layers is simply the result of an affine map applied to the input (i.e., no S-box is involved). As explained in detail in Supplementary Material C.2.2, this issue can easily be fixed both by a careful choice of the matrix that defines the linear layer (see Section 2.3 for details) and, if necessary, by adjusting the number of rounds with partial S-box layers.</p>

    <p class="text-gray-300">With optimistic (for the adversary) complexity of the Gaussian elimination, we obtain three attacks which are faster than  <span class="math">2^{M}</span>  if either condition is satisfied:</p>

    <p class="text-gray-300">
<span class="math">$\\begin{cases} R_{F} + R_{P} \\leq \\log_{\\alpha}(2) \\cdot \\min \\left\\{ M, \\log_{2}(p) \\right\\}, \\\\ R_{F} + R_{P} \\leq t - 1 + \\log_{\\alpha}(2) \\cdot \\min \\left\\{ \\frac{M}{t+1}, \\frac{\\log_{2}(p)}{2} \\right\\}, \\\\ (t-1)R_{F} + R_{P} \\leq t - 2 + \\frac{M}{2 \\cdot \\log_{2}(\\alpha)}. \\end{cases}</span>$
(4)</p>

    <p class="text-gray-300"><strong>Higher-Order Differential Attack.</strong> Working over  <span class="math">\\mathbb{F}_{2^n}{}^t \\equiv \\mathbb{F}_2^{n \\cdot t}</span> , the higher-order differential attack [Knu94] depends on the <em>algebraic degree</em> of the polynomial function that defines the permutation, where the algebraic degree  <span class="math">\\delta</span>  of a function  <span class="math">f(x) = x^d</span>  of degree d over  <span class="math">\\mathbb{F}_{2^n}</span>  is defined as  <span class="math">\\delta = \\text{hw}(d)</span>  (where  <span class="math">\\text{hw}(\\cdot)</span>  is the Hamming weight). The idea of such an attack is based on the property that given a function  <span class="math">f(\\cdot)</span>  of algebraic degree  <span class="math">\\delta</span> ,  <span class="math">\\bigoplus_{x \\in \\mathcal{V} \\oplus \\phi} f(x) = 0</span>  if the dimension of the subspace  <span class="math">\\mathcal{V}</span>  satisfies  <span class="math">\\dim(\\mathcal{V}) \\geq \\delta + 1</span> . If the algebraic degree is sufficiently high, the attack does not work.</p>

    <p class="text-gray-300">At first thought, one may think that this attack does not apply (or is much less powerful) in  <span class="math">\\mathbb{F}_p^t</span>  (due to the fact that the only subspaces of  <span class="math">\\mathbb{F}_p</span>  are  <span class="math">\\{0\\}</span>  and  <span class="math">\\mathbb{F}_p</span>  itself). Recently, it has been shown in [BCD+20] how to set up an higher-order differential over  <span class="math">\\mathbb{F}_p^t</span> . Given f over  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">d \\leq p-2</span> ,  <span class="math">\\sum_{x \\in \\mathbb{F}_p} f(x) = 0</span> . Since this result is related to the degree of the polynomial that describes the permutation, we claim that the number of rounds necessary to provide security against the interpolation attack provides security against this attack as well.</p>

    <p class="text-gray-300">(We Do Not Care About) Zero-Sum Partitions. Another property that can be demonstrated for some inner primitive in a hash function (with a relatively low degree) is based on the <em>zero-sum partition</em>. This direction has been investigated e.g. in [BCD11] for two SHA-3 candidates, <em>Luffa</em> and KECCAK. More generally, a zero-sum structure for a function  <span class="math">f(\\cdot)</span>  is defined as a set Z of inputs  <span class="math">z_i</span>  that sum to zero, and for</p>

    <p class="text-gray-300">which the corresponding outputs  <span class="math">f(z_i)</span>  also sum to zero, i.e.,  <span class="math">\\sum_i z_i = \\sum_i f(z_i) = 0</span> . For an iterated function, the existence of zero sums is usually due to the particular structure of the round function or to a low degree. Since it is expected that a randomly chosen function does not have many zero sums, the existence of several such sets can be seen as a distinguishing property of the internal function.</p>

    <p class="text-gray-300"><strong>Definition 5.5</strong> (Zero-Sum Partition [BCD11]). Let P be a permutation over  <span class="math">\\mathbb{F}_q^t</span>  for a prime  <span class="math">q \\geq 2</span> . A zero-sum partition for P of size K &lt; t is a collection of K disjoint sets  <span class="math">\\{X_1, \\ldots, X_K\\}</span>  with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">X_i \\subset \\mathbb{F}^t</span>  for each i = 1, ..., k and  <span class="math">\\bigcup_{i=1}^k X_i = \\mathbb{F}^t</span> ,</li>
      <li><span class="math">\\forall i = 1, ..., K</span> : the set  <span class="math">X_i</span>  satisfies the zero-sum property  <span class="math">\\sum_{x \\in X_i} x = \\sum_{x \\in X_i} P(x) = 0</span> .</li>
    </ul>

    <p class="text-gray-300">Here we explicitly state that we do not make claims about the security of  <span class="math">\\mathsf{POSEIDON}^\\pi</span>  against zero-sum partitions. This choice is motivated by the gap present in the literature between the number of rounds of the internal permutation that can be covered by a zero-sum partition and by the number of rounds in the corresponding sponge hash function that can be broken e.g. via a preimage or a collision attack. As a concrete example, consider the case of KECCAK: While 24 rounds of KECCAK-f can be distinguished from a random permutation using a zero-sum partition [BCD11] (that is, <em>full</em> KECCAK-f), preimage/collision attacks on KECCAK can only be set up for up to 6 rounds of KECCAK-f [GLL+20]. This hints that zero-sum partitions should be largely ignored for practical applications.</p>

    <p class="text-gray-300">For completeness, we mention that a zero-sum partition on (a previous version of) reduced-round POSEIDON<sup> <span class="math">\\pi</span> </sup> has been proposed in [BCD<sup>+</sup>20]. Such a property can cover up to  <span class="math">R_F = 6</span>  rounds (i.e., 2 rounds at the beginning and 4 rounds at the end) by exploiting the inside-out approach and by choosing a subspace of texts after the first  <span class="math">R_f</span>  rounds with full S-box layers and before the  <span class="math">R_P</span>  rounds with partial S-box layers. Since the number of rounds of this new version is not smaller than the number of rounds of the previous one, and since  <span class="math">R_F \\geq 8</span>  (see Section 5.4), it seems that a zero-sum partition cannot be set up for full POSEIDON<sup> <span class="math">\\pi</span> </sup>.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 POSEIDON in Zero-Knowledge Proof Systems</h2>

    <p class="text-gray-300">Our hash functions have been designed to be friendly to zero-knowledge applications. Specifically, we aim to minimize the proof generation time, the proof size, and the verification time (when it varies). Before presenting concrete results, we give a small overview of ZK proof systems to date.</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 State of the Art</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{P}</span>  be a circuit over some finite field  <span class="math">\\mathbb{F}</span>  where gates are some (low-degree) polynomials over  <span class="math">\\mathbb{F}</span>  with I and O being input and output variables, respectively:  <span class="math">\\mathcal{P}(I) = O</span> . The <em>computational integrity problem</em> consists of proving that some given  <span class="math">O_0</span>  is the result of the execution of  <span class="math">\\mathcal{P}</span>  over some  <span class="math">I_0</span> :  <span class="math">\\mathcal{P}(I_0) = O_0</span> . It is not difficult to show that any limited-time program on a modern CPU can be converted to such a circuit [BCTV14], and making the proof zero-knowledge is often possible with little overhead.</p>

    <p class="text-gray-300">The seminal PCP series of papers states that for any program  <span class="math">\\mathcal{P}</span>  it is possible to construct a proof of computational integrity, which can be verified in time sublinear in the size of  <span class="math">\\mathcal{P}</span> . However, for a long time the prover algorithms were so inefficient that this result remained merely theoretical. Only recently, proof systems where the prover costs are polynomial in  <span class="math">|\\mathcal{P}|</span>  were constructed, but they required a trusted setup: a verifier or someone else (not the prover) must process the circuit with some secret s and output a reference string S, used both by the prover and the verifier. In this setting, the prover's work can even be made linear in  <span class="math">|\\mathcal{P}|</span> , and the verifier's costs are constant. These systems were called SNARKs for proof succinctness. The first generation of SNARKs, known as Pinocchio and Groth16 [PHGR13, Gro16], require a separate trusted setup for each circuit. The next generation, which includes Sonic [MBKM19], PLONK [GWC19], and Marlin [CHM <span class="math">^+</span> 20], can use one reference string of size d for all circuits with at most d gates, thus simplifying the setup and its reuse. Later on, proof systems without trusted setups appeared, of which we consider Bulletproofs [BBB<sup>+</sup>18], STARKs [BBHR19], and RedShift [KPV19] the most interesting, though all of them come with deficiencies: Bulletproofs have linear verifier times (but rather short proofs), STARKs work with iterative programs, and RedShift has large proofs (up to 1 MB for millions of gates).</p>

    <p class="text-gray-300">Current benchmarks demonstrate that programs with millions of gates can be processed within a few seconds with the fastest proof systems, which solves the computational integrity problem for some practical programs. Among them, privacy-preserving cryptocurrencies, mixers, and private voting are prominent examples. In short, such applications work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Various users add publicly hashes of some secret and public values to some set <em>V</em>, which is implemented as a Merkle tree. Hashes can be currency transaction digests, public keys, or other credentials.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Only those who know a secret behind some hash are declared eligible for an action (e.g., to vote or to spend money).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A user who wants to perform the action proves that they</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">know a tree leaf L and a secret K such that L is both the hash of K and a leaf in V. If the proof passes, the user is allowed to perform an action (e.g., to vote). If an action must be done only once, a deterministic hash of the secret and leaf position can be computed and published.</p>

    <p class="text-gray-300">This paradigm is behind the cryptocurrency Zcash and Ethereum mixers.</p>

    <p class="text-gray-300">The bottleneck of such a system is usually the proof creation time, which took 42 seconds in the early version of Zcash, and sometimes the verifier's time. Both are determined by the size of the circuit that describes a Merkle proof and are thus dependent on the hash function that constitutes the tree.</p>

    <p class="text-gray-300">Unfortunately, a single hash function cannot be optimal for all ZK proof systems, because they use different arithmetizations: STARKs can use prime and binary fields, Bulletproofs uses any prime field, whereas most SNARKs use a prime field based on a scalar field of a pairing-friendly elliptic curve. Therefore, for each proof system a new instance of POSEIDON may be needed. In the following we describe how this is done and how to optimize a circuit for some proof systems.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8"><strong>6.2</strong> SNARKs with Poseidon <span class="math">^{\\pi}</span></h3>

    <p class="text-gray-300">In SNARKs, the prime field is typically the scalar field of some pairing-friendly elliptic curve. The primitive Poseidon<sup> <span class="math">\\pi</span> </sup> can be represented as such a circuit with reasonably few gates, but the parameters of Poseidon<sup> <span class="math">\\pi</span> </sup> must have been determined first by p. Concretely, after p is fixed, we first check if  <span class="math">x^{\\alpha}</span>  is invertible in GF(p), which is true if  <span class="math">p \\mod \\alpha \\neq 1</span> .</p>

      <h4 id="sec-6.2.1" class="text-lg font-semibold mt-6">6.2.1 Groth16</h4>

    <p class="text-gray-300">Groth16 [Gro16] is an optimization of the Pinocchio proof system and currently the fastest SNARK with the smallest proofs. The Groth16 prover complexity is O(s), where s is the number of rank-1 constraints &ndash; quadratic equations of the form  <span class="math">(\\sum_i u_i X_i)(\\sum_i v_i X_i) = \\sum_i w_i X_i</span> , where  <span class="math">u_i, v_i, w_i</span>  are field elements and  <span class="math">X_i</span>  are program variables. It is easy to see that the S-box  <span class="math">x^3</span>  is represented by 2 constraints and the S-box  <span class="math">x^5</span>  by 3 constraints. Thus, in total we have</p>

    <p class="text-gray-300"><span class="math">2tR_F + 2R_P</span>  constraints for  <span class="math">x^3</span> -PoseIDON<sup> <span class="math">\\pi</span> </sup>,  <span class="math">3tR_F + 3R_P</span>  constraints for  <span class="math">x^5</span> -PoseIDON<sup> <span class="math">\\pi</span> </sup>.</p>

    <p class="text-gray-300">It requires a bit more effort to see that we do not need more constraints as the linear layers and round constants can be incorporated into these ones. However, it is necessary to do some preprocessing. For example, in the  <span class="math">POSEIDON^{\\pi}</span>  setting, the full S-box layers are followed by a linear transformation</p>

    <p class="text-gray-300">M. Each round with a full S-box layer can be represented by the following constraints in the SNARK setting:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{j} M_{i,j} x_{i,j}\\right) \\cdot \\left(\\sum_{j} M_{i,j} x_{i,j}\\right) = y_{i} \\quad 1 \\le i \\le t,</span>$
<span class="math">$y_{i} \\cdot \\left(\\sum_{j} M_{i,j} z_{i,j}\\right) = z_{i},</span>$</p>

    <p class="text-gray-300">where  <span class="math">M = I_{t \\times t}</span>  for the first round. However, in a round with a partial S-box layer, we will have only one such constraint for j = 1. For the rest of the t - 1 variables we will have linear constraints of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i} M_{i,j} x_{i,j} = u_i \\text{ ,where } 2 \\le i \\le t.</span>$</p>

    <p class="text-gray-300">Since the linear constraints have little complexity effect in Groth16, in the partial S-box rounds they can be composed with the ones from the previous round(s) using</p>

    <p class="text-gray-300"><span class="math">$\\sum_{k} M_{i,k} \\left( \\sum_{j} M_{i,j} x_{i,j} \\right) = v_k \\ 2 \\le k \\le t.</span>$</p>

    <p class="text-gray-300">We can now calculate the number of constraints for the sponge mode of operation and for Merkle trees. In sponges, the 2M bits are reserved for the capacity, so N-2M bits are fed with the message. Therefore, we get</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\frac{2tR_F + 2R_P}{N 2M}</span>  constraints per bit for  <span class="math">x^3</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup>,</li>
      <li><span class="math">\\frac{3tR_F + 3R_P}{N 2M}</span>  constraints per bit for  <span class="math">x^5</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup>.</li>
    </ul>

    <p class="text-gray-300">For the Merkle tree, we suggest a 1-call sponge where all branches must fit into the rate. Then a Merkle tree has arity  <span class="math">\\frac{N}{2M}-1</span> . Based on that we can calculate how many constraints we need to prove the opening in a Merkle tree of, for example,  <span class="math">2^{32}</span>  elements (the recent ZCash setting). The tree will have  <span class="math">\\frac{32}{\\log_2[N/(2M)-1]}</span>  levels with the number of constraints in each according to the above. The libsnark performance of the POSEIDON preimage prover (proof that for given y you know x such that H(x)=y) is given in Table 3. These experiments were performed on a desktop with an Intel Core i7-8700 CPU (@3.2GHz) and 32 GiB of memory.</p>

    <p class="text-gray-300">As an example, we calculate the concrete number of constraints for a Merkle tree proof, where the tree has  <span class="math">2^{30}</span>  elements, assuming a security level of 128 bits and a prime field of size close to  <span class="math">2^{256}</span> . We take the S-box equal to  <span class="math">x^5</span>  as it fits many prime fields: Ristretto (the prime group based on the scalar field of Ed25519), BN254, and BLS12-381 scalar fields. The results are in Table 4.</p>

      <h4 id="sec-6.2.2" class="text-lg font-semibold mt-6">6.2.2 Bulletproofs</h4>

    <p class="text-gray-300">Bulletproofs [BBB<sup>+</sup>18] is a proof system that does not require a trusted setup. It is notable for short proofs which are</p>

    <p class="text-gray-300">Table 3: libsnark [SCI] performance of the POSEIDON preimage prover (one permutation call). Here <em>t</em> denotes the width.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Field</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Arity (t)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">libsnark ZK proof time<br>for one hash<br>Prove Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R1CS constraints</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1 (3)<br>4:1 (5)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43.1ms<br>57.9ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2ms<br>1.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">276<br>440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon-80</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1 (3)<br>4:1 (5)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32.8ms<br>46.9ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2ms<br>1.1ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">180<br>290</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">logarithmic in the program size, and also for the shortest range proofs that do not require a trusted setup. However, its verifier is linear in the program size. For the use cases where the trusted setup is not an option, the Bulletproofs library &quot;dalek&quot; is among the most popular ZK primitives. We have implemented <sup>14</sup> a Merkle tree prover for POSEIDON in Bulletproofs using the same constraint system as for Groth16 with results outlined in Table 5. The performance varies since the underlying curves are based on prime fields of different size and weight: BN254 uses a 254-bit prime whereas BLS12-381 uses a 381-bit one (the reason for that is the recent reevaluation of discrete logarithm algorithms specific to pairing-friendly curves).</p>

      <h4 id="sec-6.2.3" class="text-lg font-semibold mt-6"><strong>6.2.3 PLONK</strong></h4>

    <p class="text-gray-300">PLONK [GWC19] is a novel but popular SNARK using a universal trusted setup, where a structured reference string of size d can be used for any circuit of d gates or less. The setup is pretty simple as for the secret k the values  <span class="math">\\{k^i \\cdot B\\}_{i \\le d}</span>  are stored, where B is an elliptic curve point and  <span class="math">\\cdot</span>  denotes scalar multiplication. A PLONK proof is a combination of KZG polynomial commitments [KZG10] and their openings, both using the SRS.</p>

    <p class="text-gray-300">The standard version of PLONK works with the same constraint system as we have described, plus it uses special machinery to lay out wires in the circuit. A prover first crafts three polynomials of degree equal to the number of gates, which are responsible for the left input, the right input, and the output, respectively. Then they allocate several supplementary polynomials to describe the wire layout. The prover complexity for a POSEIDON<sup> <span class="math">\\pi</span> </sup> permutation with the S-box  <span class="math">x^5</span>  of width w and R rounds is 11(w(w+6)+3)R point multiplications, and the proof has 7 group elements and 7 field</p>

    <p class="text-gray-300"><sup>14</sup>https://github.com/lovesh/bulletproofs-rlcs-gadgets/bl
ob/master/src/gadget_poseidon.rs</p>

    <p class="text-gray-300">Table 4: Number of R1CS constraints for a circuit proving a leaf knowledge in the Merkle tree of  <span class="math">2^{30}</span>  elements.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Poseidon-128</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Arity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Width</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R_F</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R_P</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Total constraints</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7290</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Resc</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ue-x <sup>5</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8640</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5400</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Peders</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">en has</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">sh</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">510</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41400</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">510</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">826020</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Blake2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">510</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">630180</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MiMC-2p/p (Feistel)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">324</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19440</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">elements. A third-party non-optimized implementation of a PLONK prover in Rust (Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz) gives us benchmarks, which we provide in Table 6.</p>

    <p class="text-gray-300">As we have almost identical rounds, the PLONK compiler can be heavily optimized. Concretely, we suggest the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define a separate polynomial for each S-box line.</li>
      <li>Get rid of wire layout polynomials.</li>
      <li>Express round transitions as a system of affine equations over polynomial values at adjacent points.</li>
    </ul>

    <p class="text-gray-300">As a result, our optimized PLONK compiler makes only (w+11)R point multiplications for a single permutation call, whereas the proof consists of (w+3) group elements and 2w field elements. This might bring a 25-40x increase in performance depending on w.</p>

      <h4 id="sec-6.2.4" class="text-lg font-semibold mt-6">6.2.4 RedShift</h4>

    <p class="text-gray-300">RedShift [KPV19] is a STARK-inspired proof system which works with an arbitrary set of constraints. It can be viewed as PLONK with pairing-based polynomial commitments with the trusted setup being replaced by Reed-Solomon trust-</p>

    <p class="text-gray-300">Table 5: Bulletproofs performance to prove 1 out of  <span class="math">2^{30}</span> -Merkle tree.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">11011110 11001</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Field</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Arity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Merkle<br>Bul<br>Prove</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">R1CS<br>constraints</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.8s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7290</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12-381</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13.8s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.65s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1 11s 1.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.2s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7290</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BN254</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.6s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.15s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.4s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.78s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7290</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ristretto</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.45s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.72s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4500</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.25s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.76s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4050</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256 [BBB <sup>+</sup> 18]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">GF(2^{256})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2:1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">582s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">762000</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: PLONK performance to prove a 1-out-of- <span class="math">2^n</span> -Merkle tree of arity 4.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Field</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Set size</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Merkle 2 <sup>n</sup> -tree ZK proof PLONK time Prove   Verify</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R1CS constraints</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon-128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS12-381</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{ c c } 2^{16} \\\\ 2^{34} \\\\ 2^{68} \\end{array}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.59s<br>6.3s<br>9.9s</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.7ms<br>1.55ms<br>2.7ms</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2400<br>5100<br>10200</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">less commitments. The RedShift proof is  <span class="math">c_{\\lambda} \\log d^2</span>  KB large, where d is the degree of the circuit polynomials and  <span class="math">c_{\\lambda} \\approx 2.5</span>  for a 120-bit security. Due to similarity, we can make the same optimizations as in PLONK, so that the entire Merkle tree proof requires polynomials of degree 4800 for width 5, resulting in the entire proof being around 12 KB in size. Unfortunately, no RedShift library is publicly available so far, and hence we could not measure the actual performance.</p>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Comparison with Other Hash Algorithms</h3>

    <p class="text-gray-300">Unfortunately, no zero-knowledge system implementation contains all the primitives we want to compare with. However, for all systems we are interested it, the prover performance increases monotonically (and in practice, almost linearly) with the number of multiplications or, equivalently, with the number of R1CS constraints. We thus provide a summary of constraint counts for various hash functions in the concrete case of a Merkle tree with 2<sup>30</sup> elements in Table 4. We take Blake2s and Pedersen hash estimates from [HBHW19], the SHA-256</p>

    <p class="text-gray-300">count from Hopwood's notes<sup>15</sup>, whereas for MiMC and <em>Rescue</em> we calculated them ourselves based on the round numbers provided in in [AGR<sup>+</sup>16, AABS<sup>+</sup>19]. The table implies that POSEIDON and <em>Rescue</em> should have the fastest provers, which is also confirmed for the STARK case [BSGL20]. However, <em>Rescue</em> has a slower performance in the non-ZK case (Table 1).</p>

      <h3 id="sec-6.4" class="text-xl font-semibold mt-8"><strong>6.4</strong> STARKs with Poseidon <span class="math">^{\\pi}</span></h3>

    <p class="text-gray-300">ZK-STARKs [BBHR19] is a proof system for the computational integrity, which is not vulnerable to quantum computers and does not use a trusted setup. STARKs operate with programs whose internal state can be represented as a set of w registers, each belonging to a binary field  <span class="math">GF(2^n)</span>  or to a  <span class="math">2^n</span> -subgroup  <span class="math">\\mathbb G</span>  of a prime-order group (this is our primary case, as the scalar fields of BLS12-381 and BN254 have such a big subgroup).</p>

    <p class="text-gray-300">The program execution is then represented as a set of T internal states. The computational integrity is defined as the set of all wT registers satisfying certain s polynomial equations (constraints) of degree d.</p>

    <p class="text-gray-300"><strong>STARK Costs.</strong> According to [Sta18], the number of constraints does not play a major role in the prover, verifier, or communication complexity, which are estimated as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">8w \\cdot T \\cdot d \\cdot \\log(wT)</span>  operations in  <span class="math">\\mathbb{G}</span>  for the prover,</li>
      <li>a prover memory in  <span class="math">\\Omega(w \\cdot T \\cdot n)</span> , and</li>
      <li>a communication (verifier time) of  <span class="math">n \\cdot (m + \\log^2(8Td))</span> ,</li>
    </ul>

    <p class="text-gray-300">where m is the maximum number of variables in a constraint polynomial.</p>

    <p class="text-gray-300">The primitive POSEIDON<sup> <span class="math">\\pi</span> </sup> can be represented as such a program with few registers, a small number of steps, and low degree. Following the same approach as for SNARKs in Section 6.2, we keep in registers only S-box inputs and the permutation outputs. Setting w = t, we get  <span class="math">T = R_F + \\lceil R_P/t \\rceil</span>  and  <span class="math">wT = tR_F + R_P</span> . Thus, the complexity is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">24(tR_F + R_P) \\cdot \\log_2(tR_F + R_P)</span>  operations in  <span class="math">\\mathbb{G}</span>  for the prover,</li>
      <li>a prover memory in  <span class="math">\\Omega(63 \\cdot (tR_F + R_P))</span> , and</li>
      <li>a communication (verifier time) of  <span class="math">63 \\cdot (t + \\log_2^2(24(tR_F + R_P)))</span> .</li>
    </ul>

    <p class="text-gray-300">We suggest  <span class="math">t \\in \\{3,5\\}</span>  in order to support the same Merkle tree cases as before. Thus, for our primary instance Poseidon-128, we get an AET cost of 20540 for each permutation call</p>

    <p class="text-gray-300">for a width of 3. As we process 510 bits per call, we obtain a prover complexity of 40 operations per bit. For a width of 5 we get an AET cost of 38214, which translates to 38 operations per bit in  <span class="math">\\mathbb{G}</span> .</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Acknowledgements</h2>

    <p class="text-gray-300">This work is partially supported by the Ethereum foundation, Starkware Ltd, and IOV42 Ltd. We thank Alexander Vlasov, Lovesh Harshandani, and Carlos Perez for benchmarking PoseIDON in various environments.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[A&Aring;BL12] Mohamed Ahmed Abdelraheem, Martin &Aring;gren, Peter Beelen, and Gregor Leander. On the Distribution of Linear Biases: Three Instructive Examples. In <em>CRYPTO 2012</em>, volume 7417 of <em>LNCS</em>, pages 50&ndash;67, 2012.</li>
      <li>[AABS<sup>+</sup>19] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. Cryptology ePrint Archive, Report 2019/426, 2019. https://eprint.iacr.org/2019/426.</li>
      <li>[ABM23] Tomer Ashur, Thomas Buschman, and Mohammad Mahzoun. Algebraic cryptanalysis of POSEIDON. <em>IACR Cryptol. ePrint Arch.</em>, page 537, 2023.</li>
      <li>[ACG<sup>+</sup>19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard L&uuml;ftenegger, Christian Rechberger, and Markus Schofnegger. Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC. In <em>ASIACRYPT 2019</em>, volume 11923 of <em>LNCS</em>, pages 371&ndash;397, 2019.</li>
      <li>[AD18] Tomer Ashur and Siemen Dhooghe. Marvellous: a stark-friendly family of cryptographic primitives. Cryptology ePrint Archive, Report 2018/1098, 2018. https://eprint.iacr.org/2018/1098.</li>
      <li>[AGR<sup>+</sup>16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In <em>ASIACRYPT 2016</em>, volume 10031 of <em>LNCS</em>, pages 191&ndash;219, 2016.</li>
    </ul>

    <p class="text-gray-300"><sup>15</sup>https://www.zfnd.org/zcon/0/workshop-notes/Zcon0%20Circuit%20Optimisation%20handout.pdf</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In <em>CCS</em>, pages 2087&ndash; 2104. ACM, 2017.</p></li>
      <li><p class="text-gray-300">[ARS+15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In <em>EUROCRYPT 2015</em>, volume 9056 of <em>LNCS</em>, pages 430&ndash;454, 2015.</p></li>
      <li><p class="text-gray-300">[BBB+18] Benedikt B&uuml;nz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In <em>IEEE Symposium on Security and Privacy</em>, pages 315&ndash; 334. IEEE Computer Society, 2018.</p></li>
      <li><p class="text-gray-300">[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In <em>CRYPTO (3)</em>, volume 11694 of <em>LNCS</em>, pages 701&ndash;732. Springer, 2019.</p></li>
      <li><p class="text-gray-300">[BBS99] Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In <em>EUROCRYPT 1999</em>, volume 1592 of <em>LNCS</em>, pages 12&ndash;23, 1999.</p></li>
      <li><p class="text-gray-300">[BCD11] Christina Boura, Anne Canteaut, and Christophe De Canni&egrave;re. Higher-Order Differential Properties of Keccak and <em>Luffa</em>. In <em>FSE 2011</em>, volume 6733 of <em>LNCS</em>, pages 252&ndash;269, 2011.</p></li>
      <li><p class="text-gray-300">[BCD+20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Ga&euml;tan Leurent, Mar&iacute;a Naya-Plasencia, L&eacute;o Perrin, Yu Sasaki, Yosuke Todo, and Friedrich Wiemer. Out of Oddity &ndash; New Cryptanalytic Techniques against Symmetric Primitives Optimized for Integrity Proof Systems. In <em>Advances in Cryptology - CRYPTO 2020</em>, volume 12172 of <em>LNCS</em>, pages 299&ndash;328. Springer, 2020.</p></li>
      <li><p class="text-gray-300">[BCLR17] Christof Beierle, Anne Canteaut, Gregor Leander, and Yann Rotella. Proving Resistance Against Invariant Attacks: How to Choose the Round Constants. In <em>CRYPTO 2017</em>, volume 10402 of <em>LNCS</em>, pages 647&ndash;678, 2017.</p></li>
      <li><p class="text-gray-300">[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct noninteractive zero knowledge for a von neumann architecture. In <em>USENIX Security Sym-</em></p></li>
      <li><p class="text-gray-300"><em>posium</em>, pages 781&ndash;796. USENIX Association, 2014.</p></li>
      <li><p class="text-gray-300">[BDPA08] Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, and Gilles Van Assche. On the Indifferentiability of the Sponge Construction. In <em>EUROCRYPT 2008</em>, volume 4965 of <em>LNCS</em>, pages 181&ndash;197, 2008.</p></li>
      <li><p class="text-gray-300">[BDPA11] Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, and Gilles Van Assche. Duplexing the sponge: Single-pass authenticated encryption and other applications. In <em>Selected Areas in Cryptography</em>, volume 7118 of <em>LNCS</em>, pages 320&ndash;337. Springer, 2011.</p></li>
      <li><p class="text-gray-300">[BFSY05] M Bardet, JC Faugere, B Salvy, and BY Yang. Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems. In <em>The Effective Methods in Algebraic Geometry Conference (MEGA)</em>, pages 1&ndash;14, 2005.</p></li>
      <li><p class="text-gray-300">[BS91] Eli Biham and Adi Shamir. Differential Cryptanalysis of DES-like Cryptosystems. <em>Journal of Cryptology</em>, 4(1):3&ndash;72, 1991.</p></li>
      <li><p class="text-gray-300">[BS93] Eli Biham and Adi Shamir. <em>Differential Cryptanalysis of the Data Encryption Standard</em>. Springer, 1993.</p></li>
      <li><p class="text-gray-300">[BSGL20] Eli Ben-Sasson, Lior Goldberg, and David Levit. Stark friendly hash &ndash; survey and recommendation. Cryptology ePrint Archive, Report 2020/948, 2020. <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">https://eprint</a> <a href="https://eprint.iacr.org/2020/948" target="_blank" rel="noopener noreferrer">.iacr.org/2020/948</a>.</p></li>
      <li><p class="text-gray-300">[CDG+17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Postquantum zero-knowledge and signatures from symmetric-key primitives. In <em>CCS</em>, pages 1825&ndash;1842. ACM, 2017.</p></li>
      <li><p class="text-gray-300">[CGL+20] Carlos Cid, Lorenzo Grassi, Reinhard L&uuml;ftenegger, Christian Rechberger, and Markus Schofnegger. Higher-order differentials of word-oriented spn schemes with low-degree s-boxes. <em>IACR Cryptol. ePrint Arch.</em>, 2020:536, 2020.</p></li>
      <li><p class="text-gray-300">[CHM+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zksnarks with universal and updatable srs. In Anne Canteaut and Yuval Ishai, editors, <em>Advances in Cryptology &ndash; EUROCRYPT 2020</em>,</p></li>
    </ul>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">pages 738&ndash;768, Cham, 2020. Springer Inter<br>national Publishing.<br>Jan<br>Camenisch, Markulf Kohlweiss, and<br>[GKR+21]<br>Claudio Soriente.<br>An accumulator based<br>on bilinear maps and efficient revocation for<br>anonymous credentials. In Public Key Cryp<br>tography, volume 5443 of LNCS, pages 481&ndash;<br>500. Springer, 2009.<br>Jan Camenisch and Anna Lysyanskaya. Dy<br>namic Accumulators and Application to Effi<br>[GKRS22]<br>cient Revocation of Anonymous Credentials.<br>In CRYPTO 2002, volume 2442 of LNCS,<br>pages 61&ndash;76. Springer, 2002.<br>David A. Cox, John Little, and Donal O'Shea.<br>Ideals, varieties, and algorithms - an intro<br>duction to computational algebraic geometry<br>[GLL+20]<br>and commutative algebra (2. ed.). Undergrad<br>uate texts in mathematics. Springer, 1997.<br>Thomas H. Cormen, Charles E. Leiserson,<br>Ronald L. Rivest, and Clifford Stein. Intro<br>duction to Algorithms, Third Edition.<br>The<br>[GLR+20]<br>MIT Press, 3rd edition, 2009.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Schofnegger. Poseidon: A New Hash Func<br>tion<br>for Zero-Knowledge Proof Systems.<br>IACR Cryptol. ePrint Arch., 2019:458, 2019.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CKS09]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Dmitry Khovratovich, Chris<br>tian Rechberger, Arnab Roy, and Markus<br>Schofnegger. Poseidon: A New Hash Func<br>tion for Zero-Knowledge Proof Systems. In<br>30th USENIX Security Symposium, USENIX</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CL02]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Security 2021, pages 519&ndash;535. USENIX As<br>sociation, 2021.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Dmitry Khovratovich, Son<br>dre R&oslash;njom, and Markus Schofnegger. The<br>Legendre Symbol and the Modulo-2 Opera</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CLO97]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">tor in Symmetric Schemes over Fnp Preimage<br>Attack on Full Grendel. IACR Trans. Sym<br>metric Cryptol., 2022(1):5&ndash;37, 2022.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Jian Guo, Guohong Liao, Guozhen Liu, Me<br>icheng Liu, Kexin Qiao, and Ling Song.<br>Practical Collision Attacks against Round</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CLRS09]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Journal of Cryptology,<br>Reduced SHA-3.<br>33(1):228&ndash;270, 2020.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Reinhard L&uuml;ftenegger, Chris<br>tian Rechberger, Dragos Rotaru, and Markus</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DKP+19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Itai Dinur, Daniel Kales, Angela Promitzer,<br>Sebastian Ramacher, and Christian Rech<br>berger. Linear Equivalence of Block Ciphers<br>with Partial Non-Linear Layers: Application<br>to LowMC. In EUROCRYPT 2019, volume<br>11476 of LNCS, pages 343&ndash;372, 2019.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Schofnegger.<br>On<br>a<br>Generalization<br>of<br>Substitution-Permutation<br>Networks:<br>The<br>HADES Design Strategy. In EUROCRYPT<br>2020, volume 12106 of LNCS, pages 674&ndash;<br>704, 2020.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DKR97]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Joan Daemen, Lars R. Knudsen, and Vincent<br>Rijmen. The Block Cipher Square. In FSE<br>1997, volume 1267 of LNCS, pages 149&ndash;165,<br>1997.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gayoso<br>Mart&iacute;nez, Luis<br>Hern&aacute;n<br>dez Encinas, and Carmen S&aacute;nchez &Aacute;vila. A<br>survey of the elliptic curve integrated encryp<br>tion scheme. 2010. available at https://co<br>re.ac.uk/download/pdf/36042967.pdf.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DR01]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Joan Daemen and Vincent Rijmen. The wide<br>trail design strategy. In IMACC, volume 2260<br>of LNCS, pages 222&ndash;238. Springer, 2001.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GMO16]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Irene Giacomelli, Jesper Madsen, and Clau<br>dio Orlandi. ZKBoo: Faster Zero-Knowledge<br>In USENIX Security<br>for Boolean Circuits.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DR02]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Joan Daemen and Vincent Rijmen. The De<br>sign of Rijndael: AES - The Advanced En</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Symposium, pages 1069&ndash;1083. USENIX As<br>sociation, 2016.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cryption Standard. Information Security and<br>Cryptography. Springer, 2002.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Gra18]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi. Mixture Differential Crypt<br>analysis: a New Approach to Distinguishers</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[EGL+20]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Maria Eichlseder, Lorenzo Grassi, Reinhard<br>L&uuml;ftenegger, Morten<br>&Oslash;ygarden, Christian<br>Rechberger, Markus Schofnegger, and Qingju</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GMHES&Aacute;10] V&iacute;ctor<br>2018.<br>[Gro16]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">and Attacks on round-reduced AES. IACR<br>Trans. Symmetric Cryptol., 2018(2):133&ndash;160,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Wang. An Algebraic Attack on Ciphers with<br>Low-Degree Round Functions: Application<br>to Full MiMC. IACR Cryptol. ePrint Arch.,<br>2020:182, 2020.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Jens Groth.<br>On the size of pairing-based<br>non-interactive arguments. In EUROCRYPT<br>2016, volume 9666 of LNCS, pages 305&ndash;326.<br>Springer, 2016.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GKR+19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Dmitry Khovratovich, Arnab</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GRR16a]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Christian Rechberger, and</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Sondre R&oslash;njom. Subspace Trail Cryptanaly-</p>

    <p class="text-gray-300">Roy, Christian Rechberger, and Markus</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">sis and its Applications to AES. IACR Trans.<br>Symmetric Cryptol., 2016(2):192&ndash;225, 2016.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">iops.<br>Cryptology ePrint Archive, Report<br>https://eprint.iac<br>2019/1400, 2019.<br>r.org/2019/1400.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GRR+16b]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Christian Rechberger, Dra<br>gos Rotaru, Peter Scholl, and Nigel P Smart.<br>MPC-friendly symmetric key primitives. In<br>CCS, pages 430&ndash;443. ACM, 2016.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[KR21]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Nathan Keller and Asaf Rosemarin.<br>Mind<br>the Middle Layer: The HADES Design Strat<br>egy Revisited. In Advances in Cryptology -</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GRR17]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Christian Rechberger, and<br>Sondre<br>R&oslash;njom.<br>A<br>New<br>Structural</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">EUROCRYPT 2021, volume 12697 of LNCS,<br>pages 35&ndash;63, 2021.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Differential Property of 5-Round AES.<br>In<br>EUROCRYPT 2017, volume 10211 of LNCS,<br>pages 289&ndash;317, 2017.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[KZG10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Aniket Kate, Gregory M. Zaverucha, and Ian<br>Goldberg.<br>Constant-size commitments to<br>polynomials and their applications. In ASI</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GRS21]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lorenzo Grassi, Christian Rechberger, and<br>Markus Schofnegger.<br>Proving Resistance</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ACRYPT, volume 6477 of LNCS, pages 177&ndash;<br>194. Springer, 2010.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Against Infinitely Long Subspace Trails: How<br>IACR Trans.<br>to Choose the Linear Layer.<br>Symmetric Cryptol., 2021(2):314&ndash;352, 2021.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[LAAZ11]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Gregor Leander, Mohamed Ahmed Abdelra<br>heem, Hoda AlKhzaimi, and Erik Zenner. A<br>Cryptanalysis of PRINTcipher: The Invariant</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GWC19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ariel Gabizon, Zachary J. Williamson, and<br>Oana Ciobotaru. PLONK: permutations over</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Subspace Attack. In CRYPTO 2011, volume<br>6841 of LNCS, pages 206&ndash;221, 2011.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">lagrange-bases for oecumenical noninterac<br>tive arguments of knowledge. IACR Cryptol<br>ogy ePrint Archive, 2019:953, 2019.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[LMR+09]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mario Lamberger, Florian Mendel, Chris<br>tian Rechberger, Vincent Rijmen, and Martin<br>Schl&auml;ffer. Rebound Distinguishers: Results</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[HBHW19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Daira Hopwood, Sean Bowe, Taylor Hornby,<br>and<br>Nathan<br>Wilcox.<br>Zcash<br>protocol<br>specification: Version 2020.1.14 [overwin</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on the Full Whirlpool Compression Function.<br>In ASIACRYPT 2009, volume 5912 of LNCS,<br>pages 126&ndash;143, 2009.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ter+sapling+blossom+heartwood+canopy].<br>Technical<br>report,<br>Zerocoin<br>Electric<br>Coin<br>Company, 2019.<br>available<br>at</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Lod19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mike Lodder, 2019. Mike Lodder, Sovrin's<br>principal cryptographer www.sovrin.org,<br>private communication.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">https://github.com/zcash/zips/blob<br>/master/protocol/protocol.pdf.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Mat93]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mitsuru<br>Matsui.<br>Linear Cryptanalysis<br>In EUROCRYPT<br>Method for DES Cipher.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[HJMM08]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Martin Hell, Thomas Johansson, Alexander<br>Maximov, and Willi Meier. The Grain Family<br>of Stream Ciphers. In The eSTREAM Final</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1993, volume 765 of LNCS, pages 386&ndash;397,<br>1993.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ists, volume 4986 of LNCS, pages 179&ndash;190.<br>Springer, 2008.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[MBKM19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Mary Maller, Sean Bowe, Markulf Kohlweiss,<br>and<br>Sarah<br>Meiklejohn.<br>Sonic:<br>Zero</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[JK97]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Thomas Jakobsen and Lars R. Knudsen. The<br>Interpolation Attack on Block Ciphers.<br>In<br>FSE 1997, volume 1267 of LNCS, pages 28&ndash;<br>40, 1997.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">knowledge snarks from linear-size universal<br>and updatable structured reference strings.<br>In Lorenzo Cavallaro, Johannes Kinder, Xi<br>aoFeng Wang, and Jonathan Katz, editors,<br>Proceedings of the 2019 ACM SIGSAC Con</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[JNP13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">J&eacute;r&eacute;my<br>Jean, Mar&iacute;a<br>Naya-Plasencia, and<br>Thomas Peyrin. Multiple Limited-Birthday<br>Distinguishers and Applications.<br>In SAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ference on Computer and Communications<br>Security, CCS 2019, London, UK, November<br>11-15, 2019, pages 2111&ndash;2128. ACM, 2019.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2013, volume 8282 of LNCS, pages 533&ndash;550,<br>2013.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[MRST09]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Florian Mendel, Christian Rechberger, Mar<br>tin Schl&auml;ffer, and S&oslash;ren S. Thomsen.<br>The</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Knu94]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Lars R. Knudsen. Truncated and Higher Or<br>der Differentials. In FSE 1994, volume 1008<br>of LNCS, pages 196&ndash;211, 1994.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rebound Attack: Cryptanalysis of Reduced<br>Whirlpool and Gr&oslash;stl. In FSE 2009, volume<br>5665 of LNCS, pages 260&ndash;276, 2009.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[KPV19]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Assimakis Kattis, Konstantin Panarin, and<br>Alexander Vlasov.<br>Redshift: Transparent</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[MS78]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">F. J. MacWilliams and N. J. A. Sloane. The<br>Theory of Error-Correcting Codes.<br>North</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">holland Publishing Company, 1978.</p>

    <p class="text-gray-300">snarks from list polynomial commitment</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[NK92] Kaisa Nyberg and Lars R. Knudsen. Provable Security Against Differential Cryptanalysis. In <em>CRYPTO 1992</em>, volume 740 of <em>LNCS</em>, pages 566&ndash;574, 1992.</li>
      <li>[Nyb94] Kaisa Nyberg. Differentially uniform mappings for cryptography. In <em>EUROCRYPT 1993</em>, volume 765 of <em>LNCS</em>, pages 55&ndash;64, 1994.</li>
      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>IEEE Symposium on Security and Privacy</em>, pages 238&ndash;252. IEEE Computer Society, 2013.</li>
      <li>[RDP+96] Vincent Rijmen, Joan Daemen, Bart Preneel, Antoon Bosselaers, and Erik De Win. The cipher SHARK. In <em>Fast Software Encryption &ndash; FSE 1996</em>, volume 1039 of <em>LNCS</em>, pages 99&ndash;111. Springer, 1996.</li>
      <li>[SCI] SCIPR Lab. C++ library for zkSNARK. <a href="https://github.com/scipr-lab/libsnark" target="_blank" rel="noopener noreferrer">ht</a> <a href="https://github.com/scipr-lab/libsnark" target="_blank" rel="noopener noreferrer">tps://github.com/scipr-lab/libsnar</a> <a href="https://github.com/scipr-lab/libsnark" target="_blank" rel="noopener noreferrer">k</a>.</li>
      <li>[Sta18] StarkWare Industries Ltd. The complexity of STARK-friendly cryptographic primitives. Private communication, 2018.</li>
      <li>[W+14] Gavin Wood et al. Ethereum: A secure decentralised generalised transaction ledger. ethereum project yellow paper.(2014), 2014.</li>
      <li>[YMT97] A. M. Youssef, S. Mister, and S. E. Tavares. On the Design of Linear Transformations for Substitution Permutation Encryption Networks. In <em>School of Computer Science, Carleton University</em>, pages 40&ndash;48, 1997.</li>
    </ul>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">SUPPLEMENTARY MATERIAL</h4>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Auxiliary Files</h2>

    <p class="text-gray-300">We provide the following files as supplementary material:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>generate_params_poseidon.sage</li>
      <li>poseidonperm_x5_254_3.sage</li>
      <li>poseidonperm_x5_254_5.sage</li>
      <li>poseidonperm_x5_255_3.sage</li>
      <li>poseidonperm_x5_255_5.sage</li>
      <li>test_vectors.txt</li>
      <li>poseidonperm_x3_64_24_optimized.sage</li>
    </ul>

    <p class="text-gray-300">The first script is used to calculate round numbers and generate round constants and matrices (we discourage using the deprecated calc_round_numbers.py and generate_parameters_grain.sage files). The next five files contain the reference implementations and test vectors. Finally, we provide an optimized implementation of  <span class="math">x^3</span> -POSEIDON <span class="math">^\\pi</span> , using the modifications shown in Supplementary Material B. All supplementary files are available online.  <span class="math">^{16}</span></p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B</strong> Efficient Implementation</h2>

    <p class="text-gray-300">Like for LowMC, the fact that the nonlinear layer is partial in  <span class="math">R_P</span>  rounds can be used to reduce the size of the round constants required in each partial round. Referring to [DKP<sup>+</sup>19], we recall here an equivalent representation of an SPN with partial nonlinear layers for an efficient implementation.</p>

    <p class="text-gray-300"><strong>Round Constants.</strong> In the description of an SPN, it is possible to swap the order of the linear layer and the round constant addition as both operations are linear. The round constant then needs to be exchanged with an equivalent one. For round constant  <span class="math">c^{(i)}</span> , the equivalent one can be written as  <span class="math">\\hat{c}^{(i)} = MC^{-1}(c^{(i)})</span> , where MC is the linear layer in the i-th round.</p>

    <p class="text-gray-300">If one works with partial nonlinear layers, it is possible to use this property to move parts of the original round constants from the last round all the way through the permutation to the beginning. In order to do this, it is sufficient to split the round constants in two parts, one that applies to the S-box part of the nonlinear layer and one that applies to the identity part of the nonlinear layer. The constant part that only applies to the nonlinear layer part can now move further up. Working in</p>

    <p class="text-gray-300">this way for all round constants, it is possible to finally end up with an equivalent representation in which round constants are only added to the output of the S-boxes apart from one constant which is applied to the entire state after the first  <span class="math">R_f</span>  full rounds.</p>

    <p class="text-gray-300"><strong>Linear Layer.</strong> The situation for our design is simpler than for LowMC, since it is always possible to guarantee the existence of invertible sub-matrices. Hence, a similar trick proposed for LowMC in [DKP<sup>+</sup>19] works here as well for the matrix multiplication.</p>

    <p class="text-gray-300">Focusing on the rounds with a single S-box, let  <span class="math">\\mathcal{M}</span>  be the  <span class="math">t \\times t</span>  MDS matrix of the linear layer:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathcal{M} &amp;= \\begin{bmatrix} \\begin{array}{c|cccc} \\mathcal{M}_{0,0} &amp; \\mathcal{M}_{0,1} &amp; \\mathcal{M}_{0,2} &amp; \\cdots &amp; \\mathcal{M}_{0,t-1} &amp; \\mathcal{M}_{0,t} \\\\ \\hline \\mathcal{M}_{1,0} &amp; &amp; &amp; &amp; &amp; \\\\ \\mathcal{M}_{2,0} &amp; &amp; &amp; &amp; &amp; \\\\ \\vdots &amp; &amp; &amp; &amp; \\hat{\\mathcal{M}} &amp; &amp; \\\\ \\mathcal{M}_{t-1,0} &amp; &amp; &amp; &amp; &amp; \\\\ \\mathcal{M}_{t,0} &amp; &amp; &amp; &amp; &amp; \\\\ \\end{array} \\right] = \\\\ &amp;= \\begin{bmatrix} \\begin{array}{c|cccc} \\mathcal{M}_{0,0} &amp; \\nu &amp; &amp; &amp; \\\\ \\hline w &amp; \\hat{\\mathcal{M}} &amp; &amp; &amp; &amp; \\\\ \\end{array} \\right], \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{\\mathcal{M}}</span>  is a  <span class="math">(t-1) \\times (t-1)</span>  MDS matrix (note that since  <span class="math">\\mathcal{M}</span>  is MDS, every submatrix of  <span class="math">\\mathcal{M}</span>  is also MDS), v is a  <span class="math">1 \\times (t-1)</span>  matrix and w is a  <span class="math">(t-1) \\times 1</span>  vector. By simple computation, the following equivalence holds:</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{M} = \\underbrace{\\left[\\begin{array}{c|c} 1 &amp; 0 \\\\ \\hline 0 &amp; \\hat{\\mathcal{M}} \\end{array}\\right]}_{\\mathcal{M}&#x27;} \\times \\underbrace{\\left[\\begin{array}{c|c} \\mathcal{M}_{0,0} &amp; v \\\\ \\hline \\hat{w} &amp; I \\end{array}\\right]}_{\\mathcal{M}&#x27;&#x27;}, \\tag{5}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\hat{w} = \\hat{\\mathcal{M}}^{-1} \\times w</span>$</p>

    <p class="text-gray-300">and I is the  <span class="math">(t-1) \\times (t-1)</span>  identity matrix. Note that both  <span class="math">\\mathcal{M}&#x27;</span>  and  <span class="math">\\mathcal{M}&#x27;&#x27;</span>  are two invertible matrices.<sup>17</sup></p>

    <p class="text-gray-300">As for the round constants discussed previously, it is possible to use Eq. (5) in order to swap the S-box layer (formed by a single S-box and t-1 identity functions) and the matrix multiplication with the matrix  <span class="math">\\mathcal{M}&#x27;</span> . As a result, each linear part in the  <span class="math">R_P</span>  partial rounds is defined only by a multiplication with a matrix of the form  <span class="math">\\mathcal{M}&#x27;&#x27;</span> , which is a sparse matrix, since  <span class="math">(t-1)^2-(t-1)=t^2-3t+2</span>  coefficients of  <span class="math">\\mathcal{M}&#x27;&#x27;</span>  are equal to zero (moreover, t-1 coefficients of  <span class="math">\\mathcal{M}&#x27;&#x27;</span>  are equal to one). It follows that this optimized representation can greatly reduce the number of operations needed to evaluate the linear layer.</p>

    <p class="text-gray-300"><sup>16</sup>https://extgit.iaik.tugraz.at/krypto/hadeshash</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;17</sup>First of all,  <span class="math">\\det(\\mathcal{M}&#x27;) = \\det(\\hat{\\mathcal{M}}) \\neq 0</span>  since  <span class="math">\\hat{M}</span>  is an MDS matrix, and so it is invertible. Secondly,  <span class="math">\\det(\\mathcal{M}) = \\det(\\mathcal{M}&#x27;) \\cdot \\det(\\mathcal{M}&#x27;&#x27;)</span> . Since  <span class="math">\\det(\\mathcal{M}) \\neq 0</span>  and  <span class="math">\\det(\\mathcal{M}&#x27;) \\neq 0</span> , it follows that  <span class="math">\\det(\\mathcal{M}&#x27;&#x27;) \\neq 0</span> .</p>

    <p class="text-gray-300">Computing Round Constants and Matrices. We provide an algorithmically optimized implementation of  <span class="math">x^3</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup> in the supplementary material (see Supplementary Material A). This file also contains functions to calculate the equivalent round constants and the equivalent matrices for the partial rounds. These functions can be used to generate these values for other instantiations of POSEIDON<sup> <span class="math">\\pi</span> </sup>.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Security Analysis: <span class="math">x^{\\alpha}</span> -Poseidon<sup> <span class="math">\\pi</span> </sup></h2>

    <p class="text-gray-300">In the following, we assume that  <span class="math">x \\mapsto x^{\\alpha}</span>  is invertible (that is,  <span class="math">gcd(\\alpha, p-1) = 1</span> ).</p>

    <p class="text-gray-300"><strong>Differences to the Analysis for HADESMiMC.</strong> Although some of our results are similar to those provided for HADESMiMC in [GLR<sup>+</sup>20], we emphasize that our analysis is more tailored towards our specific construction, which is a family of <em>unkeyed</em> permutations used in the context of a sponge function. This is why, for example, some MitM approaches do not work, as opposed to a (keyed) block cipher.</p>

    <p class="text-gray-300">We make further distinctions also in the case of algebraic attacks. For example, we assume settings with  <span class="math">\\chi &lt; t</span>  input and output words, since this reflects the situation an attacker has to deal with in a sponge setting. This distinction affects our analysis regarding interpolation attacks, and most prominently our analysis regarding Gr&ouml;bner basis attacks.</p>

    <p class="text-gray-300">Moreover, we consider the case of a combination of certain algebraic attacks with invariant subspace trails, which is not directly applicable in the keyed setting.</p>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8"><strong>C.1</strong> Statistical Attacks</h3>

    <p class="text-gray-300">Since the results w.r.t. impossible differentials [BBS99], the multiple-of-8 property [GRR17], mixture differentials [Gra18] and integral distinguishers [DKR97] are equivalent to the ones proposed for HADESMiMC, we omit their analysis here and we refer to [GLR+20] for all details.</p>

      <h4 id="app-c.1.1" class="text-lg font-semibold mt-6">C.1.1 Differential Cryptanalysis</h4>

    <p class="text-gray-300">Here we focus only on the S-boxes used in the paper, namely  <span class="math">x \\mapsto x^3</span>  and  <span class="math">x \\mapsto x^5</span> .</p>

    <p class="text-gray-300"><span class="math">S(x) = x^3</span> . Differential cryptanalysis [BS91, BS93] and its variations are the most widely used techniques to analyze symmetric-key primitives. The differential probability of any function over the finite field  <span class="math">\\mathbb{F}_p</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$Prob[\\alpha \\rightarrow \\beta] := |\\{x : f(x+\\alpha) - f(x) = \\beta\\}|/p.</span>$</p>

    <p class="text-gray-300">Since the cube function  <span class="math">f(x) = x^3</span>  is an almost perfect nonlinear (APN) permutation [NK92, Nyb94], its differential probability over a prime field is bounded above by  <span class="math">2/|\\mathbb{F}_p|</span> .</p>

    <p class="text-gray-300">As largely done in the literature, we claim that  <span class="math">POSEIDON^{\\pi}</span>  is secure against differential cryptanalysis if each differential has probability at most  <span class="math">p^{-t}</span> . Since it is in general hard to compute the probability of a differential, we assume that this fact is satisfied if each characteristic has probability at most  <span class="math">p^{-2t}</span> . In order to compute the minimum number of rounds to guarantee this, we work only with the rounds with full S-box layers. In other words, we limit ourselves to work with a &quot;weaker&quot; version of the permutation defined as</p>

    <p class="text-gray-300">
<span class="math">$R^{R_f} \\circ L \\circ R^{R_f}(\\cdot),</span>$
(6)</p>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>L</em> is an <em>invertible linear layer</em> (which is the &quot;weakest&quot; possible assumption), and</li>
      <li><span class="math">R(\\cdot) = M \\circ \\text{S-box} \\circ ARK(\\cdot)</span> , where  <span class="math">\\text{S-box}(\\cdot)</span>  is a full S-box layer (remember that M is an MDS matrix).</li>
    </ul>

    <p class="text-gray-300">We are going to show that this &quot;weaker&quot; permutation is secure against differential cryptanalysis for  <span class="math">R_F = 2R_f = 10</span> . As a result, it follows that also POSEIDON<sup> <span class="math">\\pi</span> </sup> (instantiated with  <span class="math">R_F</span>  rounds with full S-box layers) is secure against such an attack. Indeed, if the linear layer L (which we only assume to be invertible) is replaced by  <span class="math">R_P</span>  rounds of POSEIDON<sup> <span class="math">\\pi</span> </sup>, its security cannot decrease. The same strategy is exploited in the following in order to prove security against all attacks in this subsection.</p>

    <p class="text-gray-300">In order to prove the result just given, we need a lower bound for the number of active S-boxes. Observe that the minimum number of active S-boxes in the permutation</p>

    <p class="text-gray-300"><span class="math">$R^{s} \\circ L \\circ R^{r}(\\cdot) \\equiv SB \\circ \\underbrace{M \\circ SB}_{s-1 \\text{ times}} \\circ \\underbrace{L&#x27;}_{s-1 \\text{ times}} \\circ SB \\circ \\underbrace{M \\circ SB}_{r-1 \\text{ times}} (\\cdot)</span>$</p>

    <p class="text-gray-300">(where  <span class="math">s, r \\ge 1</span> ,  <span class="math">R(\\cdot)</span>  is a round with a full S-box layer and where L' is an invertible linear layer) is at least 18</p>

    <p class="text-gray-300">number <em>active</em> S-boxes
<span class="math">$\\geq \\underbrace{\\left(\\lfloor s/2\\rfloor + \\lfloor r/2\\rfloor\\right) \\cdot (t+1)}_{\\text{due to final/initial rounds}} + (s \\mod 2) + (r \\mod 2).</span>$</p>

    <p class="text-gray-300">We emphasize that the (middle) linear layer  <span class="math">L&#x27;(\\cdot) \\equiv L \\circ M(\\cdot)</span>  plays no role in the computation of the previous number. Since at least  <span class="math">2 \\cdot (t+1)</span>  S-boxes are active in the 4 middle rounds of  <span class="math">R^2 \\circ L \\circ R^2(\\cdot)</span> , and since the maximum differential probability of the cube S-box is  <span class="math">DP_{max} = 2/p</span> , each characteristic has a probability of at most  <span class="math">(2/p)^{2 \\cdot (t+1)}</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} p^{-2t} \\cdot (p^{-2} \\cdot 2^{2t+2}) \\le p^{-2t} &amp; \\text{if } \\log_2 p \\ge t+1, \\\\ p^{-1.25 \\cdot t} \\cdot (p^{-0.75 \\cdot t-2} \\cdot 2^{2t+2}) &lt; p^{-1.25 \\cdot t} &amp; \\text{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{18}&lt;/sup&gt;</span> If  <span class="math">s=2 \\cdot s&#x27;</span>  is even, the minimum number of active S-boxes over  <span class="math">R^s(\\cdot)</span>  is  <span class="math">\\lfloor s/2 \\rfloor \\cdot (t+1)</span> . Instead, if  <span class="math">s=2 \\cdot s&#x27;+1</span>  is odd, the minimum number of active S-boxes over  <span class="math">R^s(\\cdot)</span>  is  <span class="math">\\lfloor s/2 \\rfloor \\cdot (t+1)+1</span> .</p>

    <p class="text-gray-300">(where the second inequality holds since  <span class="math">\\log_2(p) \\cdot [0.75 \\cdot t + 2] \\ge 2t + 2</span> ) for each  <span class="math">t \\ge 2</span>  and  <span class="math">\\log_2(p) \\ge 3</span> . By doubling this number of rounds, we get that each characteristic has a probability of at most  <span class="math">p^{-2.5t}</span> . Finally, 1 more round guarantees that no differential attack can be set up.</p>

    <p class="text-gray-300">Security up to  <span class="math">2^M \\le p^t</span> . For completeness, we present the number of rounds necessary to provide security up to  <span class="math">2^M</span>  (that is, the data and the computational cost of the attacker are upper-bounded by  <span class="math">2^M</span> ). Using the same analysis as before, it turns out that</p>

    <p class="text-gray-300"><span class="math">$R_F = \\begin{cases} 6 &amp; \\text{if } M \\le (t+1) \\cdot (\\log_2 p - 1) \\\\ 10 &amp; \\text{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">guarantees that no differential attack can be set up.</p>

    <p class="text-gray-300"><span class="math">S(x)=x^5</span> . As before,  <span class="math">x^5</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup> instantiated by S-box <span class="math">(x)=x^5</span>  is secure against statistical attacks if and only if</p>

    <p class="text-gray-300"><span class="math">$R_F^{stat} \\geq 6</span>$
.</p>

    <p class="text-gray-300">The main difference here is due to differential and linear attacks. In particular, since  <span class="math">^{19}</span>   <span class="math">DP_{max}(S-box(x)=x^5)=4/p</span> , it follows that the minimum number of rounds necessary to guarantee security against linear and differential attacks is given by</p>

    <p class="text-gray-300"><span class="math">$R_F = \\begin{cases} 6 &amp; \\text{if } 2t + 2 &lt; N + \\lceil \\log_2(p) \\rceil - M \\\\ 10 &amp; \\text{if } 2t + 2 \\ge N + \\lceil \\log_2(p) \\rceil - M \\end{cases}</span>$</p>

    <p class="text-gray-300">for a security level up to  <span class="math">2^M \\le p^t</span>  (that is, the data and the computational cost of the attacker are upper-bounded by  <span class="math">2^M</span> ).</p>

      <h4 id="app-c.1.2" class="text-lg font-semibold mt-6">C.1.2 Linear Cryptanalysis</h4>

    <p class="text-gray-300">Similar to differential attacks, linear attacks [Mat93] pose no threat to the POSEIDON <span class="math">^{\\pi}</span>  family of permutations instantiated with the same number of rounds previously defined for classical differential cryptanalysis.</p>

    <p class="text-gray-300">In more detail, this follows from the fact that the maximum square correlation of the cube function is limited to 2/p (see [A&Aring;BL12] for details). As a result, it offers the best possible resistance against linear cryptanalysis much like an APN function provides optimal resistance against differential cryptanalysis.</p>

      <h4 id="app-c.1.3" class="text-lg font-semibold mt-6"><strong>C.1.3</strong> Truncated Differential</h4>

    <p class="text-gray-300">A variant of classical differential cryptanalysis is the truncated differential one [Knu94], in which the attacker can specify only part of the difference between pairs of texts.</p>

    <p class="text-gray-300">We consider the &quot;weaker&quot; permutation described in Eq. (6) again. Focusing only on active/passive bytes (and not on the actual differences), there exist several differentials with probability 1 for a maximum of 1 round of POSEIDON<sup> <span class="math">\\pi</span> </sup>, e.g.,</p>

    <p class="text-gray-300"><span class="math">$[\\alpha, 0, \\dots, 0]^T \\xrightarrow{R(\\cdot)} \\mathcal{M} \\times [\\beta, 0, \\dots, 0]^T,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha, \\beta</span>  denote non-zero differences. Due to the next S-box layer, the linear relations given by  <span class="math">\\mathcal{M} \\times (\\beta, 0, \\dots, 0)^T</span>  are destroyed in the next round. As a result, no probability-one truncated differential covers more than a single round.</p>

    <p class="text-gray-300">Since no linear relation survives the S-box layer, it seems hard to set up a truncated differential for more than 2 rounds. As a result, it turns out that 4 rounds with full S-box layers make  <span class="math">POSEIDON^{\\pi}</span>  secure against this attack.</p>

      <h4 id="app-c.1.4" class="text-lg font-semibold mt-6">C.1.4 Rebound Attacks</h4>

    <p class="text-gray-300">The rebound attacks [LMR<sup>+</sup>09, MRST09] have much improved the best known attacks on many hash functions, especially for AES-based schemes. The goal of this attack is to find two (input, output) pairs  <span class="math">(p^1,c^1)</span>  and  <span class="math">(p^2,c^2)</span>  such that the two inputs satisfy a certain (truncated) input difference and the corresponding outputs satisfy a certain (truncated) output difference.</p>

    <p class="text-gray-300">The rebound attack consists of two phases, called <em>inbound</em> and <em>outbound</em> phase. According to these phases, the internal permutation of the hash function is split into three sub-parts. Let f be the permutation, then we get  <span class="math">f = f_{fw} \\circ f_{in} \\circ f_{bw}</span> . The part of the inbound phase is placed in the middle of the permutation and the two parts of the outbound phase are placed next to the inbound part. In the outbound phase, two high-probability (truncated) differential trails are constructed, which are then connected in the inbound phase. Since the rebound attack is a differential attack, first the attacker needs to construct a &quot;good&quot; (truncated) differential trail. Such a trail should have a high probability in the outbound phases and can have a rather low probability in the inbound phase. In the first phase, the attacker uses the knowledge of the key to find pairs of texts that satisfy the middle rounds of the truncated differential trail. In the second one, they propagate the solutions found in the first phase in the forward and in the backward directions, and check if at least one of them satisfies the entire differential trail.</p>

    <p class="text-gray-300">The best rebound attack on AES proposed in [JNP13] covers 8 rounds. Here we claim that 6 rounds with full S-box</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>Note that  <span class="math">(x + \\Delta_I)^5 - x^5 = \\Delta_O</span>  is an equation of degree 4, hence there are at most 4 different solutions.</p>

    <p class="text-gray-300">layers are sufficient to protect POSEIDON<sup> <span class="math">\\pi</span> </sup> from this attack. To support it, note that (Ist) 1 round of POSEIDON<sup> <span class="math">\\pi</span> </sup> provides full diffusion while 2 rounds of AES are necessary to provide it and (2nd) the best truncated differential covers 1 round of POSEIDON<sup> <span class="math">\\pi</span> </sup>, but 3 rounds of AES. Since the best results on AES in the literature cover at most 8 rounds, due to the similarity between AES and POSEIDON<sup> <span class="math">\\pi</span> </sup> and due to the previous observations, we argue that it is not possible to mount a rebound attack on more than 5 rounds with full S-box layers of POSEIDON<sup> <span class="math">\\pi</span> </sup>. Hence, 6 rounds of POSEIDON<sup> <span class="math">\\pi</span> </sup> with full S-box layers are sufficient to guarantee security against this attack.</p>

      <h4 id="app-c.1.5" class="text-lg font-semibold mt-6">C.1.5 Invariant Subspace Attack</h4>

    <p class="text-gray-300">The invariant subspace attack [LAAZ11] makes use of affine subspaces that are invariant under the round function.</p>

    <p class="text-gray-300"><strong>Definition C.1</strong> (Invariant Subspace Trail). Let  <span class="math">K_{\\text{weak}}</span>  be a set of keys and  <span class="math">k \\in K_{\\text{weak}}</span> , with  <span class="math">k \\equiv (k^0, k^1, \\dots, k^r)</span>  where  <span class="math">k^j</span>  is the j-th round key. For each  <span class="math">k \\in K_{\\text{weak}}</span> , the subspace U generates an <em>invariant subspace trail</em> of length r for the function  <span class="math">F_k(\\cdot) \\equiv F(\\cdot) \\oplus k</span>  if for each  <span class="math">i = 1, \\dots, r</span>  there exists a non-empty set  <span class="math">A_i \\subseteq U^c</span>  for which the following property holds:</p>

    <p class="text-gray-300"><span class="math">$\\forall a_i \\in A_i</span>$
:  <span class="math">\\exists a_{i+1} \\in A_{i+1} \\text{ s.t. } F_{k^i}(U \\oplus a_i) = U \\oplus a_{i+1}.</span></p>

    <p class="text-gray-300">All keys in the set  <span class="math">K_{\\text{weak}}</span>  are weak keys.</p>

    <p class="text-gray-300"><strong>Definition C.2</strong> (Subspace Trails). Let  <span class="math">(U_1, U_2, \\ldots, U_{r+1})</span>  denote a set of r+1 subspaces with  <span class="math">\\dim(U_i) \\leq \\dim(U_{i+1})</span> . If for each  <span class="math">i=1,\\ldots,r</span>  and for each  <span class="math">a_i</span> , there exists (unique)  <span class="math">a_{i+1} \\in U_{i+1}^c</span>  such that</p>

    <p class="text-gray-300"><span class="math">$F(U_i \\oplus a_i) \\subseteq U_{i+1} \\oplus a_{i+1}</span>$
,</p>

    <p class="text-gray-300">then  <span class="math">(U_1, U_2, \\dots, U_{r+1})</span>  is a <em>subspace trail</em> of length r for the function F. If all the previous relations hold with equality, the trail is called a <em>constant-dimensional subspace trail</em>.</p>

    <p class="text-gray-300">Here we consider separately the two cases, namely rounds with full S-box layers and rounds with partial S-box layers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the first case, as the round constant addition translates this invariant subspace [BCLR17], random round constants provide a good protection against these attacks.</li>
      <li>In the second case, it is always possible to construct a subspace trail for (at least) t-1 rounds without activating any S-box and for any choice of the linear layer. Due to the assumption made in Section 2.3, t-1 is also an upper bound for the number of rounds for which such a trail can be constructed.</li>
    </ul>

    <p class="text-gray-300">In order words, due to the choice of the matrix that defines the linear layer (described in detail in Section 2.3), it is not possible to cover more than t-1 rounds with a subspace trail</p>

    <p class="text-gray-300">(or equivalently, a truncated differential with prob. 1) with active/inactive S-boxes. We refer to [GRS21] for more details about the possibility to set up infinitely long subspace trails for partial SPN schemes (equivalently, for the rounds with partial S-box layers in HADES-like schemes).</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Algebraic Attacks</h3>

    <p class="text-gray-300">First, we introduce a simple lemma which follows from the iterative structure of the Poseidon<sup> <span class="math">\\pi</span> </sup> permutation.</p>

    <p class="text-gray-300"><strong>Lemma C.1.</strong> The algebraic degree  <span class="math">D_{\\alpha}(r)</span>  of r-round POSEIDON<sup> <span class="math">\\pi</span> </sup> with the S-box  <span class="math">x^{\\alpha}</span>  as a function of input variables is at most  <span class="math">\\alpha^{r}</span> , and we expect it to reach this degree no matter if partial or full rounds are used.</p>

      <h4 id="app-c.2.1" class="text-lg font-semibold mt-6"><strong>C.2.1</strong> Interpolation Attack</h4>

    <p class="text-gray-300">One of the most powerful attacks is the interpolation attack, introduced by Jakobsen and Knudsen [JK97] in 1997. In the case of a keyed function  <span class="math">E_k : \\mathbb{F} \\to \\mathbb{F}</span> , the strategy of the attack is to construct a polynomial representation of the function without knowledge of the secret key. If an adversary can construct such a polynomial, they can compute any output without knowing the key, thus enabling forgeries (for MAC settings) and other attacks. The interpolation polynomial P(x) representing  <span class="math">E_k(x)</span>  can be constructed using e.g. the Vandermonde matrix (cost approximately in  <span class="math">O(t^2)</span> ) or Lagrange's theorem (cost approximately in  <span class="math">O(t \\cdot \\log t)</span> ), where x is the indeterminate corresponding to the input.</p>

    <p class="text-gray-300">Such an attack can be opportunely modified for the case of an unkeyed permutation  <span class="math">E(\\cdot)</span> . In such a case, assume it is possible to construct the interpolation polynomial without using the full code book. In this case, such a polynomial can be exploited to set up a forgery attack on the permutation E, which, in general, is not possible for a (pseudo-)random permutation.</p>

    <p class="text-gray-300">In more detail, each output word of an SPN permutation can be represented as a multivariate polynomial where the variables are the inputs to each S-box. Consider a permutation input where  <span class="math">\\chi</span>  input words are unknown to us, and the other  <span class="math">t-\\chi</span>  words are known.</p>

    <p class="text-gray-300">A (rough) estimation of the number of monomials of the interpolation polynomial (and so of the complexity of the attack) is given by</p>

    <p class="text-gray-300"><span class="math">$(D_{\\alpha}(R)+1)^{\\chi}</span>$</p>

    <p class="text-gray-300">where R is the number of rounds. As a result, by requiring the number of monomials to be close to the number of possible input values  <span class="math">\\min\\{2^M, p^{\\chi}\\}</span>  for each  <span class="math">\\chi</span> , the number of rounds must be at least</p>

    <p class="text-gray-300"><span class="math">$R \\geq \\max_{\\chi \\in \\{1, \\dots, t\\}} \\min\\{M/\\chi, \\log_{\\alpha}(p)\\} = \\min\\{M, \\log_{\\alpha}(p)\\}.</span>$</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{20}\\&lt;/sup&gt;mbox{The}</span>  best truncated differential distinguisher with prob. 1 covers 2 rounds of AES.</p>

    <p class="text-gray-300">However, just reaching the full degree is not sufficient to prevent the interpolation attack. First, the polynomial should be dense to guarantee that most monomials occur in it. As shown in detail in [GLR<sup>+</sup>20], one needs at least  <span class="math">1 + \\lceil \\log_{\\alpha}(p) \\rceil + \\lceil \\log_{\\alpha}(t) \\rceil</span>  rounds in order to guarantee that the interpolation polynomial  <span class="math">E_k</span>  is dense.</p>

    <p class="text-gray-300">Since S-box <span class="math">^{-1}(x) = x^{1/\\alpha}</span>  has a higher degree than S-box <span class="math">(x) = x^{\\alpha}</span>  (e.g.,  <span class="math">x^{1/3} = x^{(2p-1)/3}</span> ), we do not expect the attack to perform better when considering the backward direction instead of the forward one. In particular, we expect that 2 rounds are sufficient to reach the maximum degree in the backward direction. Moreover, we emphasize that we do not claim security w.r.t. the MitM variant of the interpolation attack. Indeed, since the permutation is used in a sponge construction, the attacker can only see part of the output of the permutation, which naturally prevents the MitM variant attack.</p>

    <p class="text-gray-300">Secondly, we consider the algebraic degree not at round r but at round r-1 to account for the partial S-box case where the degree increase is delayed for t-1 words by 1 round. As a result, the total number of rounds  <span class="math">R = R_P + R_F</span>  must satisfy r = r + r + r + r + r + r + r + r + r +</p>

    <p class="text-gray-300"><span class="math">$R_P + R_F \\ge 1 + \\lceil \\log_{\\alpha}(2) \\cdot \\min\\{M, \\log_2(p)\\} \\rceil + \\log_{\\alpha}(t)</span>$</p>

    <p class="text-gray-300">to thwart the interpolation attack.</p>

      <h4 id="app-c.2.2" class="text-lg font-semibold mt-6">C.2.2 Gr&ouml;bner Basis Attack</h4>

    <p class="text-gray-300">We consider the Gr&ouml;bner basis attack in the same setting: Some permutation inputs are unknown and the rest are known to the attacker. Given some words of the permutation output, they have to find the unknowns.</p>

    <p class="text-gray-300">A Gr&ouml;bner basis attack usually consists of three steps, namely,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) computing the Gr&ouml;bner basis in degrevlex order,</li>
      <li>(2) converting the result to the lexicographic order, and</li>
      <li>(3) factorizing the univariate polynomial, and back-substituting its roots.</li>
    </ul>

    <p class="text-gray-300">As largely done in the literature, we assume that the security of permutations against Gr&ouml;bner basis attacks follows from the infeasible complexity of computing the Gr&ouml;bner basis in <em>degrevlex</em> order. For generic systems, the complexity of this step for a system of  <span class="math">\\mathcal{N}</span>  polynomials  <span class="math">f_i</span>  in  <span class="math">\\mathcal{V}</span>  variables is  <span class="math">O\\left(\\binom{\\mathcal{V}+D_{\\text{reg}}}{D_{\\text{reg}}}\\right)^{\\omega}</span>  operations over the base field  <span class="math">\\mathbb{F}</span>  [CLO97], where  <span class="math">D_{\\text{reg}}</span>  is the <em>degree of regularity</em> and  <span class="math">2 \\leq \\omega &lt; 3</span>  is the linear algebra constant (note that the memory requirement of these algorithms is of the same order as the running time).</p>

    <p class="text-gray-300">The degree of regularity depends on the degrees of the polynomials d and the number of polynomials  <span class="math">\\mathcal{N}</span> . When  <span class="math">\\mathcal{V} = \\mathcal{N}</span> , we have the simple closed-form approximation</p>

    <p class="text-gray-300">
<span class="math">$D_{\\text{reg}} := 1 + \\sum_{i=0}^{\\mathcal{N}-1} (d_i - 1), \\tag{7}</span>$</p>

    <p class="text-gray-300">where  <span class="math">d_i</span>  is the degree of the i-th polynomial  <span class="math">f_i</span>  in the polynomial system we are trying to solve (see [BFSY05] for details). In the over-determined case, i.e.,  <span class="math">\\mathcal{V} &lt; \\mathcal{N}</span> , the degree of regularity can be estimated by developing the Hilbert series of an ideal generated by generic polynomials  <span class="math">\\langle f_0, \\ldots, f_{\\mathcal{N}-1} \\rangle</span>  of degrees  <span class="math">d_i</span>  (under the assumption that the polynomials behave like generic systems). Closed-form formulas for  <span class="math">D_{\\text{reg}}</span>  are known for some special cases, but not in general.</p>

    <p class="text-gray-300"><strong>Full-Permutation Equations.</strong> In the first case, we derive equations for the entire r-round permutation. We consider the case in which the number of unknown input variables  <span class="math">\\chi</span>  is equal to the number of known output variables. Then we get  <span class="math">\\chi</span>  equations of degree  <span class="math">D_{\\alpha}(r) = \\alpha^r</span>  in  <span class="math">\\chi</span>  variables. We now estimate the complexity of solving algorithms based on different values of  <span class="math">\\chi</span> .</p>

    <p class="text-gray-300">If  <span class="math">\\chi=1</span>  (i.e., we have one equation in one variable), the resulting system of equations is already a Gr&ouml;bner basis consisting of a single equation of degree  <span class="math">\\alpha&#x27;</span> . This means that we can omit the step of computing a Gr&ouml;bner basis and we focus on the final step, which consists of finding the roots of the corresponding polynomial. This can be done by exploiting the root finding approach described in e.g. [GKRS22, Section 2.3.1], whose cost for a degree-D polynomial over  <span class="math">\\mathbb{F}_p</span>  is</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} C &amp;\\in \\mathcal{O}\\left(D \\cdot \\log_2(D)^2 \\cdot (\\log_2(D) + \\log_2(p)) \\cdot \\log_2(\\log_2(D))\\right) \\\\ &amp;\\geq D \\cdot \\log_2(D)^2 \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">Hence, for a security level of  <span class="math">\\min\\{M, \\log_2(p)\\}</span>  bits, the maximum number of attacked round r satisfies</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp;\\alpha^r \\cdot r^2 \\cdot \\log_2(\\alpha)^2 \\leq 2^{\\min\\{M, \\log_2(p)\\}} \\\\ &amp;\\implies r \\leq \\log_\\alpha(2) \\cdot \\min\\{M, \\log_2(p)\\}\\,, \\end{aligned}</span>$</p>

    <p class="text-gray-300">or, in other words, the minimum number of rounds for providing security is</p>

    <p class="text-gray-300"><span class="math">$R_F + R_P \\ge \\left\\lceil \\frac{\\min\\{M, \\log_2(p)\\}}{\\log_2(\\alpha)} \\right\\rceil.</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\chi \\geq 2</span> , we consider multiple equations in multiple variables. Computing a Gr&ouml;bner basis for the resulting system of equations can be estimated by</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\mathcal{V} + D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}\\right)^2 \\approx \\left(\\frac{\\chi \\alpha^r}{\\chi}\\right)^2,</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;21</sup>We emphasize that in this analysis we do not take into account the cost to construct the interpolation polynomial, which is (in general) non-negligible.</p>

    <p class="text-gray-300">where the approximation is due to the definition of  <span class="math">D_{\\text{reg}} = 1 + \\sum_{i=1}^{\\chi} (\\alpha^r - 1) \\approx \\chi \\cdot (\\alpha^r - 1)</span>  in Eq. (7) and  <span class="math">\\mathcal{V} = \\chi</span> . In order to find the number of rounds for guaranteeing security, we propose the following lower bound of the cost:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\frac{\\chi\\alpha^r}{\\chi}\\right)^2 \\geq \\left(\\left(\\frac{\\chi\\alpha^r}{\\chi}\\right)^\\chi\\right)^2 = \\alpha^{2r\\chi},</span>$</p>

    <p class="text-gray-300">which follows from the inequality proposed in [CLRS09].<sup>22</sup> Focusing on the complexity of computing a Gr&ouml;bner basis and on an min{M,log<sub>2</sub>(p) <span class="math">\\chi</span> }-bit security level, the number of rounds to be attacked can be estimated as</p>

    <p class="text-gray-300"><span class="math">$\\alpha^{2r\\chi} \\leq 2^{\\min\\{M,\\log_2(p)\\chi\\}}.</span>$</p>

    <p class="text-gray-300">Since this value is maximized for  <span class="math">\\chi=2</span>  in this setting, we conjecture that security is provided by choosing</p>

    <p class="text-gray-300"><span class="math">$r = R_F + R_P \\ge \\min \\left\\{ \\left\\lceil \\frac{M}{4 \\log_2(\\alpha)} \\right\\rceil, \\left\\lceil \\frac{\\log_2(p)}{2 \\log_2(\\alpha)} \\right\\rceil \\right\\},\\,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\frac{1}{4\\log_2(3)}\\approx 0.16</span>  and  <span class="math">\\frac{1}{4\\log_2(5)}\\approx 0.11</span>  for the cases we focus on in this paper.</p>

    <p class="text-gray-300">By combining these two cases ( <span class="math">\\chi=1</span>  and  <span class="math">\\chi\\geq 2</span> ), we finally get</p>

    <p class="text-gray-300"><span class="math">$r = R_F + R_P \\ge \\left\\lceil \\frac{\\min\\{M, \\log_2(p)\\}}{\\log_2(\\alpha)} \\right\\rceil.</span>$</p>

    <p class="text-gray-300"><strong>Exploiting the Subspace</strong>  <span class="math">S^{(i)}</span>  <strong>to Improve the Attack.</strong> As shown in [BCD+20], the previous attack can be improved by exploiting the existence of the subspace  <span class="math">S^{(r)}</span>  defined as in Eq. (1). In particular, given a text in a coset of  <span class="math">S^{(r)}</span> , the output of this text after r rounds with partial S-box layers is just the result of an affine map applied to the input. As explained in detail in [BCD+20], this fact can be exploited in order to replace some nonlinear equations of the system that we are trying to solve with linear equations. In particular, by starting in the &quot;middle&quot; with texts in a coset of  <span class="math">S^{(r)}</span> , one faces the following scenario</p>

    <p class="text-gray-300"><span class="math">$\\text{input} \\xleftarrow{R_F^{-R_f}(\\cdot)} \\xleftarrow{R_P^{-\\frac{R_P-r}{2}}(\\cdot)} \\text{ text in coset of } \\mathcal{S}^{(r)} \\xrightarrow{\\text{&quot;linear&quot; equations}}</span>$</p>

    <p class="text-gray-300">text in coset of
<span class="math">$\\mathcal{M}&#x27;(\\mathcal{S}^{(r)}) \\xrightarrow{R_P^{R_P-r}} \\xrightarrow{R_F^{R_F}(\\cdot)} \\xrightarrow{R_F^{R_f}(\\cdot)} \\text{output},</span>$
(8)</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{M}&#x27;</span>  is a  <span class="math">t \\times t</span>  matrix that depends on the details of the cipher and on the subspace  <span class="math">\\mathcal{S}^{(r)}</span>  (and where  <span class="math">\\mathcal{M}&#x27;(\\mathcal{S}^{(r)}) = \\{\\mathcal{M}&#x27; \\times x \\mid x \\in \\mathcal{S}^{(r)}\\}</span> ).</p>

    <p class="text-gray-300"><span class="math">$\\binom{a \\cdot x}{x} = \\frac{(a \\cdot x)!}{x! \\cdot ((a-1) \\cdot x)!} = \\prod_{i=1}^{x} \\frac{(a-1) \\cdot x + i}{i} \\ge \\prod_{i=1}^{x} \\frac{a \\cdot x}{x} = \\left(\\frac{a \\cdot x}{x}\\right)^{x}.</span>$</p>

    <p class="text-gray-300">The number of rounds r described by linear equations is related to the dimension of the subspace  <span class="math">\\mathcal{S}^{(r)}</span> . This fact has an impact on the chance to find a solution of the system of equations we are trying to solve (indeed, the number of variables of such a system of equations is related to the dimension of the subspace). In any case, due to the assumption made in Section 2.3 on the matrix that defines the linear layer, this strategy does not allow the attacker to cover more than t-1 rounds with partial S-box layers.</p>

    <p class="text-gray-300">The scenario given in Eq. (8) can be described by</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(first part) t equations of degree  <span class="math">\\alpha^{R_f + \\frac{R_P r}{2}}</span> .</li>
      <li>(middle part) d linear equations and t d nonlinear equations of degree  <span class="math">\\alpha^r</span> , and</li>
      <li>(final part) t equations of degree  <span class="math">\\alpha^{R_f + \\frac{R_P r}{2}}</span> .</li>
    </ul>

    <p class="text-gray-300">Let us focus on the middle part (r rounds). Let  <span class="math">S = \\langle s_1, \\ldots, s_{\\lceil} \\rangle</span>  be the subspace of dimension d defined before, and let  <span class="math">S^c = \\langle w_1, \\ldots, w_{t-d} \\rangle</span> , where  <span class="math">S^c</span>  denotes the complementary space of S (obviously,  <span class="math">\\mathbb{F}^t = \\langle s_1, \\ldots, s_d, w_1, \\ldots, w_{t-d} \\rangle</span> ). Let x and y be resp. the input and the corresponding output of such a middle part, where y = F(x) for a specific function  <span class="math">F(\\cdot)</span>  of degree  <span class="math">\\alpha^r</span> . Given x in a coset of S and by definition of S, the output y is in a subspace of  <span class="math">\\mathcal{M}&#x27;(S^{(r)})</span>  for a particular matrix  <span class="math">\\mathcal{M}&#x27;</span> . Hence, the middle part can be described by a system of d linear equations of the form</p>

    <p class="text-gray-300"><span class="math">$s_i^T \\cdot y = s_i^T \\cdot (\\mathcal{M}&#x27; \\times x) \\quad \\forall i \\in \\{1, \\dots, d\\}</span>$</p>

    <p class="text-gray-300">and t - d nonlinear equations of the form</p>

    <p class="text-gray-300"><span class="math">$w_i^T \\cdot y = w_i^T \\cdot F(x) \\quad \\forall i \\in \\{1, \\dots, t - d\\},</span>$</p>

    <p class="text-gray-300">where  <span class="math">a^T \\cdot b</span>  denotes the scalar product between  <span class="math">a, b \\in \\mathbb{F}^t</span> .</p>

    <p class="text-gray-300">Working as before, this means that the attacker has to face a system of  <span class="math">t + (t - d) + \\chi</span>  equations in  <span class="math">t + (t - d) + \\chi</span>  variables. By adding constraints on the previous t - d nonlinear equations (which corresponds to &quot;fixing&quot; the coset of the subspace S), this number of equations and variables can be reduced to  <span class="math">t + \\chi</span> .</p>

    <p class="text-gray-300">By using the previous computation and since  <span class="math">D_{\\text{reg}} = 1 + (t + \\chi) \\cdot (\\alpha^{R_f + \\frac{R_p - r}{2}} - 1) \\approx (t + \\chi) \\cdot \\alpha^{\\frac{R_F + R_p - r}{2}}</span> , the cost can be approximated by</p>

    <p class="text-gray-300">for  <span class="math">\\omega \\ge 2</span> . If we target a security level of  <span class="math">\\min\\{M, \\log_2(p)\\chi\\}</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;22</sup>Note tha</p>

    <p class="text-gray-300">bits, the number of rounds to be attacked is calculated as</p>

    <p class="text-gray-300"><span class="math">$\\alpha^{(R_F+R_P-r)\\cdot(t+\\chi)} &lt; 2^{\\min\\{M,\\log_2(p)\\chi\\}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\implies R_F + R_P \\ge r + \\min \\left\\{ \\frac{M \\log_{\\alpha}(2)}{t + \\chi}, \\frac{\\log_2(p) \\chi \\log_{\\alpha}(2)}{t + \\chi} \\right\\}.</span>$</p>

    <p class="text-gray-300">Since the maximum number of rounds to be attacked is achieved resp. for  <span class="math">\\chi = 1</span>  in the first term and for  <span class="math">\\chi = t</span>  in the second one, the security is provided by choosing</p>

    <p class="text-gray-300"><span class="math">$R_F + R_P \\ge t - 1 + \\min \\left\\{ \\frac{\\log_{\\alpha}(2) \\cdot M}{t + 1}, \\frac{\\log_{\\alpha}(2) \\cdot \\log_2(p)}{2} \\right\\},\\,</span>$</p>

    <p class="text-gray-300">where remember that  <span class="math">r \\le t - 1</span> .</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8">Working at Round Level: Equations for Each S-Box.</h3>

    <p class="text-gray-300">Here we consider equations of degree  <span class="math">\\alpha</span>  for each S-box, which relate its inputs and outputs. Given  <span class="math">\\chi</span>  unknown permutation inputs and  <span class="math">\\chi</span>  known outputs, we get  <span class="math">(t-1)R_F + R_P + \\chi</span>  unknown S-boxes, and for each we use 1 variable (for its input). In total, we get  <span class="math">(t-1)R_F + R_P</span>  equations for the S-box inputs in all rounds, and  <span class="math">\\chi</span>  equations for the outputs of the last round. Denoting the number of variables  <span class="math">\\mathcal V</span>  by  <span class="math">q = (t-1)R_F + R_P + \\chi</span> , the degree of regularity is estimated by</p>

    <p class="text-gray-300"><span class="math">$D_{\\text{reg}} \\approx 1 + (\\alpha - 1) \\cdot q = 1 + (\\alpha - 1) \\cdot ((t - 1)R_F + R_P)</span>$</p>

    <p class="text-gray-300">by using Eq. (7). The attack complexity can then be estimated by</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} \\mathcal{V} + D_{\\mathrm{reg}} \\ D_{\\mathrm{reg}} \\end{pmatrix}^2 \\approx \\begin{pmatrix} \\alpha \\cdot q \\ q \\end{pmatrix}^2.</span>$</p>

    <p class="text-gray-300">Working as before, we get the following lower bound:</p>

    <p class="text-gray-300"><span class="math">$\\binom{\\alpha \\cdot q}{q}^2 \\geq \\left(\\frac{\\alpha \\cdot q}{q}\\right)^{2q} = \\alpha^{2 \\cdot q}.</span>$</p>

    <p class="text-gray-300">If we target a security level of  <span class="math">\\min\\{M, \\log_2(p)\\chi\\}</span>  bits, the number of rounds to be attacked is calculated as</p>

    <p class="text-gray-300"><span class="math">$\\alpha^{2 \\cdot ((t-1)R_F + R_P + \\chi)} \\le 2^{\\min\\{M, \\log_2(p)\\chi\\}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\implies (t-1)R_F + R_P \\le \\frac{\\min\\{M, \\log_2(p)\\chi\\}}{2 \\cdot \\log_2(\\alpha)} - \\chi</span>$</p>

    <p class="text-gray-300">for each  <span class="math">\\chi \\in \\{1, ..., t\\}</span> . Note that</p>

    <p class="text-gray-300"><span class="math">$\\max_{\\chi \\in \\{1,\\dots,t\\}} \\frac{\\min\\{M,\\log_2(p)\\chi\\}}{2 \\cdot \\log_2(\\alpha)} - \\chi \\leq \\frac{M}{2 \\cdot \\log_2(\\alpha)} - 1 \\,.</span>$</p>

    <p class="text-gray-300">We finally add t-1 rounds in order to prevent the version of the attack just described that makes use of the subspace  <span class="math">S^i</span>  in order to skip rounds without activating any S-box. As a result, we conjecture that security is provided by choosing</p>

    <p class="text-gray-300"><span class="math">$(t-1)R_F + R_P \\ge (t-2) + \\frac{M}{2 \\cdot \\log_2(\\alpha)}.</span>$
(9)</p>

    <p class="text-gray-300"><strong>Working at Round Level: Follow-Up Work.</strong> In a recent work [ABM23], the authors show that the previous  <span class="math">D_{\\text{reg}}</span>  is overestimated due to the fact that the system in consideration is not regular. In more details, they show that the system of equations can be actually set up via  <span class="math">(R_F - 1) \\cdot t + R_P + r</span>  equations in  <span class="math">(R_F - 1) \\cdot t + R_P + r</span>  variables, where  <span class="math">r \\ge t/3</span>  is the rate. In such a case, a better estimation of the degree of regularity is given by</p>

    <p class="text-gray-300"><span class="math">$D_{\\mathrm{reg}} \\approx r \\cdot \\frac{R_F}{2} + R_P + \\alpha</span>$
.</p>

    <p class="text-gray-300">We refer to [ABM23] for more details. Here, we limit ourselves to take this new result into account, and require (as before) that</p>

    <p class="text-gray-300"><span class="math">$\\left(\\begin{aligned} \\mathcal{V} + D_{\\mathrm{reg}} \\ D_{\\mathrm{reg}} \\end{aligned}\\right)^2 \\geq 2^M,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{V} = (R_F - 1) \\cdot t + R_P + r</span> .</p>

    <p class="text-gray-300"><em>Remark.</em> To the best of our knowledge, this new result does not affect instances currently used in practice. In particular, instances using a 128-bit security level and various compression ratios for primes of  <span class="math">\\approx 64</span>  and  <span class="math">\\approx 256</span>  bits are not affected. This includes popular instantiations with  <span class="math">t \\in \\{3,5\\}</span>  for SNARK protocols and  <span class="math">t \\in \\{12,24\\}</span>  for FRI-based approaches.</p>

    <p class="text-gray-300"><strong>Conclusion.</strong> Combining the strategies together, we get the following conditions:</p>

    <p class="text-gray-300"><span class="math">$R_{F} + R_{P} \\ge \\log_{\\alpha}(2) \\cdot \\min\\{M, \\log_{2}(p)\\},</span>$</p>

    <p class="text-gray-300"><span class="math">$R_{F} + R_{P} \\ge t - 1 + \\log_{\\alpha}(2) \\cdot \\min\\left\\{\\frac{M}{t+1}, \\frac{\\log_{2}(p)}{2}\\right\\},</span>$</p>

    <p class="text-gray-300"><span class="math">$(t-1)R_{F} + R_{P} \\ge (t-2) + \\frac{M}{2 \\cdot \\log_{2}(\\alpha)},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\binom{R_{F} \\cdot (t+r/2) + 2R_{P} + 2 \\cdot (r-t) + \\alpha}{r \\cdot R_{F}/2 + R_{P} + \\alpha} \\ge 2^{M/2},</span>$
(10)</p>

    <p class="text-gray-300">where r is the rate in the last inequality. We provide a script that given instance parameters returns both the number of rounds and the round constants and matrices.<sup>23</sup></p>

    <p class="text-gray-300">We point out that in the case in which  <span class="math">M \\le \\log_2(p)</span>  (that is,  <span class="math">\\min\\{M, \\log_2(p)\\} = M</span> ) and if  <span class="math">R_F \\ge 1</span> , the third inequality is always satisfied if the first one is satisfied.</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Compact Constraints for STARKs and SNARKs</h2>

    <p class="text-gray-300">In this section, we show how to generate constraints for S-boxes that depend only on a few variables. This is useful when t is relatively small compared to  <span class="math">R_P</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{23} \\&lt;/sup&gt;rm https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_params_poseidon.sage</span></p>

    <p class="text-gray-300">Let us denote the outputs of the ARK transformation in round r by  <span class="math">A_r^1, A_r^2, \\ldots, A_r^t</span> . Let us also denote the inputs to the MDS matrix in round r by  <span class="math">B_r^1, B_r^2, \\ldots, B_r^t</span> . We obtain that in full rounds</p>

    <p class="text-gray-300"><span class="math">$S(A_r^i) = B_r^i</span>$</p>

    <p class="text-gray-300">whereas in partial rounds</p>

    <p class="text-gray-300"><span class="math">$S(A_r^t) = B_r^t, \\quad A_r^i = B_r^i, i &lt; t.</span>$</p>

    <p class="text-gray-300">The S-box inputs will then be</p>

    <p class="text-gray-300"><span class="math">$A_r^i</span>$
for  <span class="math">i &lt; t</span> :  <span class="math">r \\in [1; R_F/2] \\cup [R_F/2 + 1 + R_P; R_F + R_P]</span>
<span class="math">A_r^t</span> :  <span class="math">r \\in [R_F/2 + 1; R_F/2 + R_P]</span> . (11)</p>

    <p class="text-gray-300">It is obvious that the equations above plus the MDS and ARK affine transformations</p>

    <p class="text-gray-300">
<span class="math">$M\\mathbf{B}_r + \\mathbf{K}_r = \\mathbf{A}_{r+1} \\tag{12}</span>$</p>

    <p class="text-gray-300">fully determine the permutation. Therefore, using 2Rt variables  <span class="math">\\{A_r^i, B_r^i\\}</span>  we can describe the permutation using constraints of degree equal to the S-box degree d.</p>

    <p class="text-gray-300">As we have mentioned, one can do better by substituting Eq. (12) for all  <span class="math">B_r^i</span> , thus getting equations in only Rt variables  <span class="math">\\{A_r^i\\}</span> . In the same way we can get rid of  <span class="math">A_r^i</span>  that are not inputs to S-boxes, thus leaving with equations in  <span class="math">R_Ft+R_P</span>  variables. However, this procedure creates equations with too many variables as S-box outputs in the first partial rounds now depend on the S-box inputs of all future partial rounds. Our goal is to construct compact equations in the same variables. We are going to work with two consecutive segments of t partial rounds each, let them be rounds from r to r+2t-1. We proceed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Express  <span class="math">A_j^t</span> ,  <span class="math">j \\in [r+t; r+2t-1]</span>  as affine functions of</li>
    </ol>

    <p class="text-gray-300"><span class="math">$A_{r+t}^1, A_{r+t}^2, \\dots, A_{r+t}^t, B_{r+t}^t, B_{r+t+1}^t, \\dots, B_{r+2t-1}^t.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using Gaussian elimination, express  <span class="math">(A_{r+t}^1, A_{r+t}^2, \\dots, A_{r+t}^t)</span>  as affine functions of</li>
    </ol>

    <p class="text-gray-300"><span class="math">$A_{r+t}^{t}, A_{r+t+1}^{t}, \\dots, A_{r+2t-1}^{t}, B_{r+t}^{t}, B_{r+t+1}^{t}, \\dots, B_{r+2t-1}^{t}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Express  <span class="math">B_i^t</span> ,  <span class="math">j \\in [r; r+t-1]</span>  as affine functions of</li>
    </ol>

    <p class="text-gray-300"><span class="math">$A_{r+t}^1, A_{r+t}^2, \\dots, A_{r+t}^t, A_{r+1}^t, A_{r+2}^t, \\dots, A_{r+t}^t.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Using Gaussian elimination, express  <span class="math">(A_{r+t}^1, A_{r+t}^2, \\dots, A_{r+t}^t)</span>  as affine functions of</li>
    </ol>

    <p class="text-gray-300"><span class="math">$A_{r+1}^{t}, A_{r+2}^{t}, \\dots, A_{r+t}^{t}, B_{r}^{t}, B_{r+1}^{t}, \\dots, B_{r+t-1}^{t}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Combine items 2 and 4 and get a system of <em>t</em> affine equations that link</li>
    </ol>

    <p class="text-gray-300"><span class="math">$A_{r+t}^{l}, A_{r+t+1}^{l}, \\dots, A_{r+2t-1}^{l}, B_{r+t}^{l}, B_{r+t+1}^{l}, \\dots, B_{r+2t-1}^{l}, A_{r+1}^{l}, A_{r+2}^{l}, \\dots, A_{r+t}^{l}, B_{r}^{l}, B_{r+1}^{l}, \\dots, B_{r+t-1}^{l}.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Substitute  <span class="math">B_j^t \\leftarrow S(A_j^t)</span>  and get a system of t degree-d polynomial constraints on  <span class="math">(A_{r+t}^t, A_{r+t+1}^t, \\dots, A_{r+2t-1}^t, A_{r+1}^t, A_{r+2}^t, \\dots, A_{r+t}^t)</span> .</li>
    </ol>

    <p class="text-gray-300">The resulting system  <span class="math">P_1</span>  of polynomial constraints does not depend on r except for the constant term, which is determined by round constants. We do not have a formal proof that the systems composed at steps 1 and 3 have rank t but experiments show that it is the case for all matrices we tried.</p>

    <p class="text-gray-300">We thus get the following system of constraints for the entire permutation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the first group of full rounds:  <span class="math">t(R_F/2 1)</span>  constraints of degree d that link  <span class="math">(A_r^1, A_r^2, \\dots, A_r^t, A_{r+1}^1, A_{r+1}^2, \\dots, A_{r+1}^t), r \\in [1; R_F/2 1]</span> . The constraints depend on r in the constant terms only.</li>
      <li>Bridging the last full and t first partial rounds: t constraints of degree d that link  <span class="math">(A_{RF/2}^1, A_{RF/2}^2, \\dots, A_{RF/2}^t, A_{RF/2+1}^t, A_{RF/2+1}^2, \\dots, A_{RF/2+t}^t)</span> . To get them, we express  <span class="math">A_{RF/2+1}^t, A_{RF/2+2}^2, \\dots, A_{RF/2+t}^t</span>  as affine functions of  <span class="math">(A_{RF/2}^1, A_{RF/2}^2, \\dots, A_{RF/2}^t, B_{RF/2}^t, B_{RF/2}^t, B_{RF/2+1}^t, \\dots, B_{RF/2+t-1}^t)</span>  and then substituting B as degree-d functions.</li>
      <li>For all  <span class="math">R_P</span>  partial rounds: Divide them into groups of t rounds and use the system  <span class="math">P_1</span>  (derived above) to link them consecutively, thus  <span class="math">R_P t</span>  constraints in total.</li>
      <li>Bridging the last t partial rounds and round  <span class="math">(R_P + R_F/2 + 1)</span>  (full one): t constraints of degree d.</li>
      <li>For the last group of full rounds:  <span class="math">t(R_F/2-1)</span>  constraints of degree d.</li>
    </ul>

    <p class="text-gray-300">This approach results in  <span class="math">tR_F + R_P - t</span>  constraints of degree d.</p>

    </section>

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold">E Initialization of the Grain LFSR Used for Parameter Generation</h2>

    <p class="text-gray-300">We use the Grain LFSR for the generation of pseudo-random numbers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First, the state is initialized with 80 bits  <span class="math">b_0, b_1, \\dots, b_{79}</span>  as follows:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">b_0, b_1</span>  describe the field,</li>
    </ul></li>
      <li><p class="text-gray-300">(b)  <span class="math">b_i</span>  for  <span class="math">2 \\le i \\le 5</span>  describe the S-box,</p></li>
      <li><p class="text-gray-300">(c)  <span class="math">b_i</span>  for  <span class="math">6 \\le i \\le 17</span>  are the binary representation of n,</p></li>
      <li><p class="text-gray-300">(d)  <span class="math">b_i</span>  for  <span class="math">18 \\le i \\le 29</span>  are the binary representation of t,</p></li>
      <li><p class="text-gray-300">(e)  <span class="math">b_i</span>  for  <span class="math">30 \\le i \\le 39</span>  are the binary representation of  <span class="math">R_E</span> .</p></li>
      <li><p class="text-gray-300">(f)  <span class="math">b_i</span>  for  <span class="math">40 \\le i \\le 49</span>  are the binary representation of  <span class="math">R_P</span> ,</p></li>
      <li><p class="text-gray-300">(g)  <span class="math">b_i</span>  for 50 &lt; i &lt; 79 are set to 1.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Update the bits using  <span class="math">b_{i+80} = b_{i+62} \\oplus b_{i+51} \\oplus b_{i+38} \\oplus b_{i+23} \\oplus b_{i+13} \\oplus b_i</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Discard the first 160 bits.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Evaluate bits in pairs: If the first bit is a 1, output the second bit. If it is a 0, discard the second bit.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If a randomly sampled integer is larger than or equal to p, we discard this value and take the next one. We generate numbers starting from the most significant bit (i.e., the first bit sampled represents the most significant bit of the first constant). However, starting from the least significant bit or the most significant one makes no difference regarding the security.</p>

    <p class="text-gray-300">Note that cryptographically strong randomness is not needed for the round constants or the matrices, and other methods can also be used.</p>

    </section>

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">F Concrete Instances with Security Margin</h2>

    <p class="text-gray-300">Concrete instances for  <span class="math">x^3</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup> and  <span class="math">x^5</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup>, including the security margin, are given in Table 7 and Table 8, respectively.</p>

    <p class="text-gray-300">Table 7: Concrete instances for  <span class="math">x^3</span> -Poseidon<sup> <span class="math">\\pi</span> </sup> over  <span class="math">\\mathbb{F}_p</span> , where S-box <span class="math">(x) = x^3</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security<br>M</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{ c c } \\hline \\textbf{Text Size} \\\\ N = n \\times t \\end{array}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-box Size <span class="math">(n \\text{ or } \\lceil \\log_2 p \\rceil)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># S-boxes (t)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>F</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>P</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cost<br>Eq. (13)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">99</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">116</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">132</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">84</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">148</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">170</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">186</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">203</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">171</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">219</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 8: Concrete instances for  <span class="math">x^5</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup> over  <span class="math">\\mathbb{F}_p</span> , where S-box <span class="math">(x) = x^5</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security<br>M</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{ c c } \\hline \\textbf{Text Size} \\\\ N = n \\times t \\end{array}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-box Size <span class="math">(n \\text{ or } \\lceil \\log_2 p \\rceil)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># S-boxes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>F</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>P</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cost<br>Eq. (13)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">72</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">121</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">170</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">116</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">132</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">116</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">148</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">117</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">165</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">150</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">170</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="app-g" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>G</strong> Selecting Number of Rounds in General Case</h2>

    <p class="text-gray-300">The design goal is to offer a family of hash functions which minimize the R1CS costs. It turns out that for the fixed S-box function the minimum costs are delivered by a primitive with the smallest number of S-boxes, though the field size also plays a role. For each combination (security level M, prime/binary field type, S-box size, S-box function) we minimize the number of S-boxes taking into account Eq. (3) and Eq. (4).</p>

    <p class="text-gray-300">Minimizing the Number of S-Boxes. In our design strategy, we always exploit the wide trail strategy in order to provide security against statistical attacks. In other words, for this class of attacks, we work only with rounds with full S-box layers. Our instances are secure against statistical attacks if</p>

    <p class="text-gray-300"><span class="math">$R_F^{stat} \\ge \\begin{cases} 6 &amp; \\text{if } M \\le (\\log_2 p - C) \\cdot (t+1) \\\\ 10 &amp; \\text{otherwise} \\end{cases}</span>$</p>

    <p class="text-gray-300">where  <span class="math">C = (\\alpha - 1)/2</span>  for  <span class="math">S(x) = x^{\\alpha}</span> . In order to minimize the number of S-boxes for given n and t, the goal is to find the best ratio between  <span class="math">R_F</span>  and  <span class="math">R_P</span>  that minimizes</p>

    <p class="text-gray-300">number of S-boxes =
<span class="math">$t \\cdot R_F + R_P</span>$
, (13)</p>

    <p class="text-gray-300">where  <span class="math">t \\ge 2</span>  and where the number of nonlinear operations is proportional to the number of S-boxes.</p>

    <p class="text-gray-300">Overall, the S-box type and the number of rounds should be chosen as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Choose the S-box  <span class="math">S(x) = x^{\\alpha}</span>  using the smallest  <span class="math">\\alpha</span>  such that  <span class="math">gcd(\\alpha, p-1) = 1</span> .</li>
      <li>(2) Select the minimum  <span class="math">R_F</span>  that provides security against statistical attacks (i.e., at least  <span class="math">R_F = 6</span> ).</li>
      <li>(3) Select  <span class="math">R_P</span>  that minimizes  <span class="math">tR_F + R_P</span>  such that Eq. (3) and Eq. (4) are not satisfied.</li>
    </ul>

    <p class="text-gray-300">We have set up a script that calculates the number of rounds accordingly, using the security margin further described at the end of Section 5. Our resulting instances are given in Table 7 and Table 8.</p>

    <p class="text-gray-300"><strong>Results via Script.</strong> A complete analysis on how to set up the script &ndash; in order to guarantee security and to find the best ratio between  <span class="math">R_P</span>  and  <span class="math">R_F</span>  &ndash; for this case has been proposed in [GLR<sup>+</sup>20]. For this reason, we refer to [GLR<sup>+</sup>20], and here we only report the minimum number of rounds necessary to provide security.</p>

    <p class="text-gray-300">For completeness, we mention that the simplest way to set up the script is to test (e.g., by brute force) all possible values  <span class="math">R_P</span>  and  <span class="math">R_F</span>  that provide security (equivalently, for which the previous inequalities are satisfied), and find the ones that minimize the cost.</p>

    </section>

    <section id="app-h" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>H</strong> Merkle Tree Instances of Poseidon</h2>

    <p class="text-gray-300">As a hash function used in a Merkle tree of a fixed arity always gets a message input of bounded length, it makes sense to have a compact padding of input elements. Concretely, we suggest the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>POSEIDON instances with width t are used for Merkle trees with arity t-c where c is the capacity (at word level, namely c elements in  <span class="math">\\mathbb{F}</span> ). As the hash output is equal in size to the capacity, we should have c|(t-c). In the prime field setting with 128-bit security and a 256-bit field we will have c=1 and arity t-1.</li>
      <li>A tree node may have 0 to t-c child elements. The missing child element is denoted by  <span class="math">\\emptyset</span>  and we denote  <span class="math">\\widehat{\\mathbb{F}} = \\mathbb{F} \\cup \\{\\emptyset\\}</span> .</li>
      <li>A node hash function  <span class="math">\\widehat{H}</span>  maps  <span class="math">\\widehat{\\mathbb{F}}^{t-c}</span>  to  <span class="math">\\mathbb{F}^c</span> . Therefore, a missing subtree of depth 1 (a single node) is represented as  <span class="math">\\emptyset</span> , a missing subtree of depth 2 has the hash  <span class="math">\\widehat{H}_0^2 = \\widehat{H}(\\emptyset, \\emptyset, \\dots, \\emptyset)</span> , and a missing subtree of depth d has the hash</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\widehat{H}^d_{\\emptyset} = \\widehat{H}(\\widehat{H}^{d-1}_{\\emptyset}, \\widehat{H}^{d-1}_{\\emptyset}, \\dots, \\widehat{H}^{d-1}_{\\emptyset}).</span>$</p>

    <p class="text-gray-300">&bull; The node hash function  <span class="math">\\widehat{H}</span> , based on the permutation  <span class="math">\\Pi</span>  of width t, is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{H}(X_{c+1}, X_{c+2}, \\dots, X_t) = \\prod_{c+1, \\dots, 2c} (\\widetilde{X}_1, \\widetilde{X}_2, \\widetilde{X}_3, \\dots, \\widetilde{X}_t),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\Pi_{c+1...2c}</span>  are the first c non-capacity elements of the output of  <span class="math">\\Pi</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{X}_1 = \\cdots = \\widetilde{X}_{c-1} = 0, \\quad \\widetilde{X}_c = \\sum_i 2^i [X_i \\neq \\emptyset];</span>$</p>

    <p class="text-gray-300"><span class="math">$\\widetilde{X}_{i&gt;c} = \\begin{cases} X_i, X_i \\neq \\emptyset; \\\\ 0, X_i = \\emptyset \\end{cases}</span>$</p>

    <p class="text-gray-300">where  <span class="math">[\\cdot]</span>  is the Iverson bracket (1 if the input is true, 0 otherwise).</p>

    <p class="text-gray-300"><strong>Sponge Padding.</strong> For a variable-length sponge instance of POSEIDON, we pad all message strings from  <span class="math">\\mathbb{F}^*</span>  with a single element  <span class="math">1 \\in \\mathbb{F}</span>  and then, if necessary, with as many zero elements as needed to make the message length a multiple of t-c</p>

    </section>

    <section id="app-i" class="mb-10">
      <h2 class="text-2xl font-bold">I About STARKAD (Currently Dismissed)</h2>

    <p class="text-gray-300">Besides POSEIDON, in the previous version of the paper [GKR<sup>+</sup>19, Version: 20200205:104144], we also proposed STARKAD, which is basically the counterpart of POSEIDON for the case of binary fields. As already mentioned in the introduction, for this new version of the paper, we decided to focus on POSEIDON only instantiated with  <span class="math">x \\mapsto x^{\\alpha}</span>  for  <span class="math">\\alpha \\ge 3</span>  being the smallest integer that satisfies  <span class="math">\\gcd(\\alpha, d-1) = 1</span> . The reason is that all applications we considered are more efficient when working with a prime field rather than a binary field.</p>

    <p class="text-gray-300">Here we recall a few details of STARKAD. Before going on, we highlight that &quot;weaker&quot; versions of STARKAD have recently been broken in [KR21,BCD+20]. In the following, we mention how to fix the design in order to prevent the attack presented in such papers.</p>

      <h3 id="app-i.1" class="text-xl font-semibold mt-8">I.1 The Permutation STARKAD <span class="math">^{\\pi}</span></h3>

    <p class="text-gray-300">The hash function<sup>24</sup> STARKAD-Hash for the <em>binary case</em> is constructed by instantiating a sponge construction [BDPA08] with the STARKAD permutation denoted by STARKAD <span class="math">^{\\pi}</span> . This permutation is equal to the permutation POSEIDON <span class="math">^{\\pi}</span>  defined in Section 2.3, with the following differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>It is defined over a binary field  <span class="math">\\mathbb{F}_{2^n}^t</span>  instead of a prime field  <span class="math">\\mathbb{F}_p^t</span> .</li>
      <li>In order to define the S-box as  <span class="math">S(x) = x^{\\alpha}</span> , the positive integer  <span class="math">\\alpha \\ge 3</span>  must be chosen as the smallest integer s.t.  <span class="math">gcd(\\alpha, 2^n 1) = 1</span>  (e.g.,  <span class="math">\\alpha = 3</span>  if and only if n is odd).</li>
    </ul>

    <p class="text-gray-300">In order to prevent the attacks presented in [KR21,BCD<sup>+</sup>20], it is sufficient to choose the MDS matrix that defines the MixLayer as described in Section 2.3. Namely, we assume that there exists no infinitely long subspace trail (either invariant or iterative and either with active or inactive S-boxes) for the rounds with partial S-box layer. In order to satisfy this assumption, it is sufficient to test the MDS matrix using the tools provided in [GRS21].</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{24}&lt;/sup&gt;</span> About the name: Starkad was a legendary hero in Norse mythology, who used to hash his enemies with  <span class="math">2^2</span>  swords in  <span class="math">2^3</span>  arms.</p>

    <p class="text-gray-300">Table 9: <strong>Old</strong> range of different parameter sets for STARKAD instantiated by S-box <span class="math">(x) = x^3</span>  (with security margin). We do <strong>not</strong> claim that STARKAD instantiated with these round numbers is secure.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security<br>M</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{ c c } \\hline \\textbf{Text Size} \\\\ N = n \\times t \\end{array}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-box Size (n)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># <b>S-boxes</b> (t)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>F</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>P</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Field</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1551</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1581</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1551</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1581</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbb{F}_{2^n}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="app-i.2" class="text-xl font-semibold mt-8">I.2 Cryptanalysis and Old Number of Rounds of <span class="math">STARKAD^{\\pi}</span></h3>

    <p class="text-gray-300">The security analysis of STARKAD<sup> <span class="math">\\pi</span> </sup> is similar to the one proposed for Poseidon<sup> <span class="math">\\pi</span> </sup>. In particular, the number of rounds necessary to guarantee the security of STARKAD over  <span class="math">\\mathbb{F}_{2^n}^t</span>  cannot be smaller than the number of rounds of Poseidon over  <span class="math">\\mathbb{F}_p^t</span> , where  <span class="math">p&gt;2^n</span>  is the prime closest to  <span class="math">2^n</span> .</p>

    <p class="text-gray-300">At the same time, some important differences arise:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We expect that the higher-order differential attack is more competitive (or at least, not less competitive) in the case of a binary field than in the case of a prime field. This means that, in principle, more rounds are necessary in order to provide the security of STARKAD<sup>&pi;</sup> compared to POSEIDON<sup>&pi;</sup>.</li>
      <li>The MDS matrices proposed for the previous version of STARKAD<sup>&pi;</sup> were weak matrices, in the sense that their squares were multiples of the identity. This weakness has been shown and exploited in [KR21, BCD<sup>+</sup>20]. The new assumption on the MDS matrix prevents this weakness.</li>
    </ul>

    <p class="text-gray-300">Regarding the first point, we decided not to present a complete analysis of the security of  <span class="math">STARKAD^{\\pi}</span>  w.r.t. higher-order differential attacks. We point out that several works have recently been published in the literature (see [EGL+20, CGL+20] for more details) whose goal is to better understand the growth of the degree in the case of schemes over binary fields with large S-boxes. An open problem is to better understand how the combination of rounds with full and rounds with partial S-box layers influences the growth of the algebraic degree.</p>

    <p class="text-gray-300">In Table 9, we recall the round numbers proposed in the previous version of the paper [GKR<sup>+</sup>19, Version: 20200205:104144]. We stress that we do not claim that STARKAD instantiated with these round numbers is secure, and we advice against using it.</p>

    <p class="text-gray-300">Table 10: <strong>Old</strong>  <span class="math">x^{-1}</span> -POSEIDON over  <span class="math">\\mathbb{F}_p^t</span> , where S-box <span class="math">(x) = x^{-1}</span>  (with security margin). We do <strong>not</strong> claim that  <span class="math">x^{-1}</span> -POSEIDON instantiated with these round numbers is secure.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security<br>M</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{ c c } \\hline \\textbf{Text Size} \\\\ N = n \\times t \\end{array}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">S-box Size <span class="math">(n \\text{ or } \\lceil \\log_2 p \\rceil)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># S-boxes (t)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>F</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R <sub>P</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Cost<br>Eq. (13)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">81</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">92</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">768</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">134</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">150</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">174</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">153</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1536</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="app-j" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>J</strong> About <span class="math">x^{-1}</span> -POSEIDON (Currently Dismissed)</h2>

    <p class="text-gray-300">Besides  <span class="math">x^{\\alpha}</span> -POSEIDON<sup> <span class="math">\\pi</span> </sup>, in the previous version of the paper [GKR<sup>+</sup>21], we proposed a version of POSEIDON instantiated with  <span class="math">x \\mapsto x^{-1}</span>  instead of  <span class="math">x \\mapsto x^{\\alpha}</span> . We emphasize that the only difference between these two versions regards the details of the S-box.</p>

    <p class="text-gray-300">We are not aware of any application that makes use of this version of POSEIDON. Moreover, mistakes in the security analysis have been found. For this reason, as we already pointed in the introduction, we consider this version as dismissed, and we advice against using it.</p>

    <p class="text-gray-300">Only for completeness, in Table 10 we recall the old number of rounds of this version proposed in the previous version of the paper [GKR<sup>+</sup>21]. One more time, we stress that we do not claim that POSEIDON with  <span class="math">x \\mapsto x^{-1}</span>  instantiated with these round numbers is secure.</p>

    </section>
`;
---

<BaseLayout title="Poseidon: A New Hash Function for Zero-Knowledge Proof Syste... (2019/458)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/458
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">The Poseidon Hash Function</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Sponge Construction for Poseidon^&#123;\pi&#125;</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The HADES Design Strategy for Hashing</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">The Permutation Family Poseidon^&#123;\pi&#125;</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Applications</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Concrete Instantiations of POSEIDON&pi;</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Main Instances</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Domain Separation for POSEIDON</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Cryptanalysis Summary of POSEIDON</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Definitions</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Security Claims</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Summary of Attacks</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Security Margin</a></li>
            <li><a href="#sec-5.5" class="hover:text-white">Attack details</a></li>
            <li><a href="#sec-5.5.1" class="hover:text-white">Statistical Attacks</a></li>
            <li><a href="#sec-5.5.2" class="hover:text-white">Algebraic Attacks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">POSEIDON in Zero-Knowledge Proof Systems</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">State of the Art</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">SNARKs with Poseidon^&#123;\pi&#125;</a></li>
            <li><a href="#sec-6.2.1" class="hover:text-white">Groth16</a></li>
            <li><a href="#sec-6.2.2" class="hover:text-white">Bulletproofs</a></li>
            <li><a href="#sec-6.2.3" class="hover:text-white">PLONK</a></li>
            <li><a href="#sec-6.2.4" class="hover:text-white">RedShift</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Comparison with Other Hash Algorithms</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">STARKs with Poseidon^&#123;\pi&#125;</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Acknowledgements</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Auxiliary Files</a></li>
        <li><a href="#app-b" class="hover:text-white">Efficient Implementation</a></li>
        <li>
          <a href="#app-c" class="hover:text-white">Security Analysis: x^&#123;\alpha&#125;-Poseidon&lt;sup&gt;\pi&lt;/sup&gt;</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Statistical Attacks</a></li>
            <li><a href="#app-c.1.1" class="hover:text-white">Differential Cryptanalysis</a></li>
            <li><a href="#app-c.1.2" class="hover:text-white">Linear Cryptanalysis</a></li>
            <li><a href="#app-c.1.3" class="hover:text-white">Truncated Differential</a></li>
            <li><a href="#app-c.1.4" class="hover:text-white">Rebound Attacks</a></li>
            <li><a href="#app-c.1.5" class="hover:text-white">Invariant Subspace Attack</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Algebraic Attacks</a></li>
            <li><a href="#app-c.2.1" class="hover:text-white">Interpolation Attack</a></li>
            <li><a href="#app-c.2.2" class="hover:text-white">Gr&ouml;bner Basis Attack</a></li>
          </ol>
        </li>
        <li><a href="#app-d" class="hover:text-white">Compact Constraints for STARKs and SNARKs</a></li>
        <li><a href="#app-e" class="hover:text-white">Initialization of the Grain LFSR Used for Parameter Generation</a></li>
        <li><a href="#app-f" class="hover:text-white">Concrete Instances with Security Margin</a></li>
        <li><a href="#app-g" class="hover:text-white">Selecting Number of Rounds in General Case</a></li>
        <li><a href="#app-h" class="hover:text-white">Merkle Tree Instances of Poseidon</a></li>
        <li>
          <a href="#app-i" class="hover:text-white">About STARKAD (Currently Dismissed)</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-i.1" class="hover:text-white">The Permutation STARKAD^&#123;\pi&#125;</a></li>
            <li><a href="#app-i.2" class="hover:text-white">Cryptanalysis and Old Number of Rounds of STARKAD^&#123;\pi&#125;</a></li>
          </ol>
        </li>
        <li><a href="#app-j" class="hover:text-white">About x^&#123;-1&#125;-POSEIDON (Currently Dismissed)</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="poseidon-a-new-hash-function-for-zero-knowledge-proof-2019" />
  </article>
</BaseLayout>
