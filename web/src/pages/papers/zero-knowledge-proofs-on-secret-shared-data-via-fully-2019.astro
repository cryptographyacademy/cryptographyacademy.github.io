---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/188';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs';
const AUTHORS_HTML = 'Dan Boneh, Elette Boyle, Henry Corrigan-Gibbs, Niv Gilboa, Yuval Ishai';

const CONTENT = `    <p class="text-gray-300">Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear PCPs*</p>

    <p class="text-gray-300">Dan Boneh† Elette Boyle‡ Henry Corrigan-Gibbs§ Niv Gilboa¶ Yuval Ishai‡</p>

    <p class="text-gray-300">August 21, 2022</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">We introduce and study the notion of <em>fully linear</em> probabilistically checkable proof systems. In such a proof system, the verifier can make a small number of linear queries that apply <em>jointly</em> to the input and a proof vector.</p>

    <p class="text-gray-300">Our new type of proof system is motivated by applications in which the input statement is not fully available to any single verifier, but can still be efficiently accessed via linear queries. This situation arises in scenarios where the input is partitioned or secret-shared between two or more parties, or alternatively is encoded using an additively homomorphic encryption or commitment scheme. This setting appears in the context of secure messaging platforms, verifiable outsourced computation, PIR writing, private computation of aggregate statistics, and secure multiparty computation (MPC). In all these applications, there is a need for fully linear proof systems with <em>short proofs</em>.</p>

    <p class="text-gray-300">While several efficient constructions of fully linear proof systems are implicit in the interactive proofs literature, many questions about their complexity are open. We present several new constructions of fully linear <em>zero-knowledge</em> proof systems with <em>sublinear</em> proof size for “simple” or “structured” languages. For example, in the <em>non-interactive</em> setting of fully linear PCPs, we show how to prove that an input vector <span class="math">x\\in\\mathbb{F}^{n}</span>, for a finite field <span class="math">\\mathbb{F}</span>, satisfies a single degree-2 equation with a proof of size <span class="math">O(\\sqrt{n})</span> and <span class="math">O(\\sqrt{n})</span> linear queries, which we show to be optimal. More generally, for languages that can be recognized by systems of constant-degree equations, we can reduce the proof size to <span class="math">O(\\log n)</span> at the cost of <span class="math">O(\\log n)</span> rounds of interaction.</p>

    <p class="text-gray-300">We use our new proof systems to construct new short zero-knowledge proofs on distributed and secret-shared data. These proofs can be used to improve the performance of the example systems mentioned above.</p>

    <p class="text-gray-300">Finally, we observe that zero-knowledge proofs on distributed data provide a general-purpose tool for protecting MPC protocols against malicious parties. Applying our short fully linear PCPs to “natural” MPC protocols in the honest-majority setting, we can achieve unconditional protection against malicious parties with sublinear additive communication cost. We use this to improve the communication complexity of recent honest-majority MPC protocols. For instance, using any pseudorandom generator, we obtain a 3-party protocol for Boolean circuits in which the amortized communication cost is only <em>one bit</em> per AND gate per party (compared to 7 bits in the best previous protocol), matching the best known protocols for semi-honest parties.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">In this work, we develop new techniques for proving in zero knowledge statements that are distributed (i.e., partitioned or secret-shared) across two or more verifiers. Recall that in a standard interactive proof system <em>[8, 10, 15, 77]</em> a verifier holds an input <span class="math">x\\in\\{0,1\\}^{<em>}</span> and a prover tries to convince the verifier that <span class="math">x</span> is a member of some language <span class="math">\\mathcal{L}\\subseteq\\{0,1\\}^{</em>}</span>. We consider instead the setting in which there are multiple verifiers, and each verifier holds only a piece of the input, such as a share of <span class="math">x</span> generated using a linear secret-sharing scheme. Critically, no single verifier holds the entire input <span class="math">x</span>. The prover, who holds the entire input <span class="math">x</span>, must convince the verifiers, who only hold pieces of <span class="math">x</span>, that <span class="math">x\\in\\mathcal{L}</span>. At the same time, we require that the proof system be strongly zero knowledge: every proper subset of the verifiers should learn nothing about <span class="math">x</span>, apart from the fact that <span class="math">x\\in\\mathcal{L}</span>.</p>

    <p class="text-gray-300">Special cases of this type of proof system appear in existing systems for anonymous messaging <em>[45]</em>, verifiable function secret sharing <em>[35]</em>, and systems for the private computation of aggregate statistics <em>[44]</em>. We observe that such proof systems also provide a powerful tool for protecting protocols for secure multiparty computation over point-to-point channels against malicious parties, analogous to the role that standard zero-knowledge proofs play in the GMW compiler <em>[72]</em>. Indeed, in protocols that involve point-to-point communication, the task of proving compliance with the protocol exactly requires executing a zero-knowledge proof on distributed data.</p>

    <p class="text-gray-300">We introduce the central new abstraction of a fully linear proof system. Such proof systems apply not only to efficiently proving (in zero-knowledge) statements on distributed or secret-shared data, but also to data that is encrypted or committed using a linearly homomorphic system. While several efficient constructions of fully linear proof systems are implicit in the literature on interactive and probabilistically checkable proofs (in particular, the linear PCPs from <em>[6, 67]</em> and the interactive proofs from <em>[75, 109]</em> can be cast as such proof systems), many questions about their complexity are open. We present several new constructions of fully linear zero-knowledge proof systems that achieve sublinear proof size for “simple” or “structured” languages. Finally, we present several applications of such proof systems in the context of the motivating applications discussed above.</p>

    <p class="text-gray-300">We now give a more detailed overview of our contributions.</p>

    <p class="text-gray-300">Contribution I: Fully linear proof systems. We begin by introducing the notion of a fully linear proof system, which captures the information-theoretic object at the core of all of our constructions. We consider the non-interactive variant of such proof systems, called fully linear PCPs, and then we describe a natural extension to the interactive setting.</p>

    <p class="text-gray-300">A fully linear PCP is a refinement of linear PCPs <em>[6, 27, 83]</em>. Recall that in a standard linear PCP over a finite field <span class="math">\\mathbb{F}</span>, a polynomial-time verifier holds an input <span class="math">x\\in\\mathbb{F}^{n}</span> and a prover produces a proof <span class="math">\\pi\\in\\mathbb{F}^{m}</span> to the assertion that <span class="math">x\\in\\mathcal{L}</span>, for some language <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span>. The verifier checks the proof by reading <span class="math">x</span> and making linear queries (i.e., inner-product queries) to the proof <span class="math">\\pi</span>. In particular, the verifier can make a bounded number of queries to the proof of the form <span class="math">q_{j}\\in\\mathbb{F}^{m}</span>, and receives answers <span class="math">a_{j}=\\langle q_{j},\\pi\\rangle\\in\\mathbb{F}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a fully linear PCP, we further restrict the verifier: the verifier cannot read the entire input <span class="math">x</span> directly, but only has access to it via linear queries. Concretely, the verifier in a fully linear PCP makes linear queries <span class="math">q_{j}</span> to the concatenated input-proof vector $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi)\\in\\mathbb{F}^{n+m}<span class="math"> and must accept or reject the assertion that </span>x\\in\\mathcal{L}<span class="math"> based on the answers </span>a_{j}<span class="math"> to these linear queries. Motivated by the applications we consider, we would also like fully linear PCPs to satisfy the following strong zero-knowledge requirement: the queries </span>q_{j}<span class="math"> together with the answers </span>a_{j}<span class="math"> reveal no additional information about </span>x<span class="math"> other than the fact that </span>x\\in\\mathcal{L}<span class="math">. This is stronger than the standard notion of zero-knowledge proofs in which </span>x<span class="math"> is essentially public and the interaction need not hide </span>x$. See Section 3 for formal definitions of fully linear PCPs and their strong zero knowledge variant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The full linearity restriction is naturally motivated by applications in which the input statement is not fully available to any single verifier, but can still be efficiently accessed via linear queries. This situation arises in scenarios where the input <span class="math">x</span> is distributed or secret-shared between two or more parties, or alternatively is encoded using an additively homomorphic encryption or commitment scheme. In these scenarios, verifiers can readily compute answers to public linear queries via <em>local</em> computations on their view of <span class="math">x</span>. While fully linear PCPs can be meaningfully applied in all of the above scenarios, we will primarily focus on their applications to proofs on distributed or secret-shared data.</p>

    <p class="text-gray-300">We stress again that in a fully linear PCP, the verifier only has <em>linear query access</em> to <span class="math">x</span>. An interesting consequence is that even if <span class="math">\\mathcal{L}</span> is an easy language that can be decided in polynomial time, a verifier making a bounded (e.g., constant) number of such queries typically cannot decide whether <span class="math">x\\in\\mathcal{L}</span> without the aid of a proof, even if the verifier can run in unbounded time. This makes the existence of fully linear proof systems with good parameters meaningful even for finite languages and even if, say, <span class="math">\\mathsf{P}=\\mathsf{PSPACE}</span>. The same fact makes possible a connection between fully linear PCPs and communication complexity <em>[3, 89, 91]</em>. Using this connection, we prove unconditional lower bounds on the efficiency properties of fully linear PCPs (Appendix B).</p>

    <p class="text-gray-300">Different kinds of linear PCPs were used, either explicitly or implicitly, in the vast literature on succinct arguments for <span class="math">\\mathsf{NP}</span> (see <em>[26, 27, 30, 34, 67, 80, 83, 93, 105, 111, 112, 122, 125]</em> and references therein). These linear PCPs, including the “Hadamard PCP” <em>[6, 83]</em> and ones obtained from quadratic span programs or quadratic arithmetic programs <em>[27, 67, 104]</em>, can be cast into the fully linear framework. This fact was implicitly used in previous proof systems on committed or secret-shared data <em>[11, 44, 46]</em>. Our notion of fully linear PCPs provides a convenient abstraction of the properties on which such systems can be based.</p>

    <p class="text-gray-300">Contribution II: Shorter proofs for structured and simple languages. When using fully linear PCPs to build zero-knowledge proof systems on distributed or secret-shared data, as discussed in Contribution IV below, the <em>proof length</em> determines the number of bits that the prover must send to the verifiers. As such, we aim to design short proofs. This goal is especially important when many different assertions are proved about the same input statement <span class="math">x</span>. In such a scenario, the initial setup cost of distributing <span class="math">x</span> is amortized away, in the sense that it is dominated by the cost of communicating the proofs. Having short fully linear PCPs yields similar efficiency benefits in the settings of encryption and commitments.</p>

    <p class="text-gray-300">These applications motivate the need for fully linear PCPs with <em>short proofs</em>. For general <span class="math">\\mathsf{NP}</span> relations, all known linear PCPs have size at least <em>linear</em> in the size of an arithmetic circuit recognizing the relation. In Section 4, we achieve significant length savings by designing new <em>sublinear</em> sized fully linear PCPs for languages recognized by deterministic circuits with repeated sub-structures (Theorem 4.3) or by a degree-2 polynomial (Corollary 4.7). In the latter case, we can even prove that the <span class="math">O(\\sqrt{n})</span> complexity of our construction is optimal up to low-order terms (Appendix B). These and other proof systems constructed in this work satisfy the notion of strong zero knowledge discussed above.</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Theorem 1.1 (Informal - short fully linear PCP for a degree-2 polynomial).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If membership in <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> can be recognized by a single degree-2 polynomial, then <span class="math">\\mathcal{L}</span> admits a fully linear PCP with strong zero knowledge that has proof length and query complexity <span class="math">\\tilde{O}(\\sqrt{n})</span> and soundness error $O(\\sqrt{n}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Furthermore, there exists a language </span>\\mathcal{L}$ as above such that the sum of the proof length and query</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">complexity must be <span class="math">\\Omega(\\sqrt{n})</span>, even when we allow constant soundness error and do not require zero knowledge.</p>

    <p class="text-gray-300">See Corollary 4.7 and Theorem B.1 for more precise and general statements.</p>

    <p class="text-gray-300">Contribution III: Reducing proof size by interaction. To further drive down the proof length, we consider a generalization of fully linear PCPs that allows multiple rounds of interaction between the prover and verifier. These fully linear interactive oracle proofs, or fully linear IOPs, are the linear analogue of interactive oracle proofs (IOP) <em>[23]</em>, also known as probabilistically checkable interactive proofs <em>[109]</em>. We note that without the zero-knowledge requirement, several existing interactive proof systems from the literature, including the GKR protocol <em>[74]</em>, the CMT protocol <em>[42]</em>, and the RRR protocol <em>[109]</em> can be viewed as fully linear IOPs.</p>

    <p class="text-gray-300">For the case of “well-structured” languages, we show in Section 5 that interaction can dramatically shrink the proof size, while maintaining the required strong zero-knowledge property. In particular, any language whose membership can be verified by a system of constant-degree equations over a finite field admits a fully linear IOP with strong zero-knowledge in <span class="math">O(\\log n)</span> rounds and only <span class="math">O(\\log n)</span> proof length, provided that the underlying field is sufficiently large. Even for degree-2 languages, this provably gives an exponential reduction in proof size over the non-interactive case.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Theorem 1.2 (Informal - fully linear zero-knowledge IOPs for low-degree languages).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> can be recognized by a system of constant-degree equations. Then, <span class="math">\\mathcal{L}</span> admits a fully linear IOP with strong zero knowledge, <span class="math">O(\\log n)</span> rounds, and proof length and query complexity <span class="math">O(\\log n)</span>.</p>

    <p class="text-gray-300">See Theorem 5.8 for a more precise and general statement, including an extension to rings.</p>

    <p class="text-gray-300">Contribution IV: Zero-knowledge proofs on distributed or secret-shared data. The primary motivation for our new types of proof systems is the fact that in many cases, data can be efficiently accessed via linear queries. This includes several different scenarios, but our main focus in this work is on the case of distributed or secret-shared data. (See Appendix C for application to proofs on encrypted or committed data.) More precisely, the prover knows <span class="math">x</span> in its entirety and each of <span class="math">k</span> verifiers <span class="math">V_{1},\\ldots,V_{k}</span> only has a piece (or a secret share) of <span class="math">x</span>.</p>

    <p class="text-gray-300">In Section 6, we show that any fully linear PCP and IOP can be compiled into a zero-knowledge proof system on distributed or secret-shared data in the following natural way. Instead of sending a proof vector <span class="math">\\pi</span> to a single verifier, the prover <span class="math">P</span> secret-shares the proof vector <span class="math">\\pi</span> between the <span class="math">k</span> verifiers using a linear secret-sharing scheme. The verifiers can now locally apply each linear query to the concatenation of their share of the input <span class="math">x</span> and their share of <span class="math">\\pi</span>, and exchange the resulting answer shares with the other verifiers. The verifiers then reconstruct the answers to the linear queries and apply the decision predicate to decide to accept or reject <span class="math">x</span>. We present different variants of this compiler that further optimize this approach and that achieve zero-knowledge even when up to <span class="math">k-1</span> verifiers are malicious.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1.3 (Informal - distributed zero-knowledge proofs for low-degree languages on secret-shared data: malicious prover or verifiers).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> can be recognized by a system of constant-degree equations. Then, assuming ideal coin-tossing, there is an <span class="math">O(\\log n)</span>-round distributed zero-knowledge protocol for proving that <span class="math">x\\in\\mathcal{L}</span>, where <span class="math">x</span> is additively shared between <span class="math">k</span> verifiers, with communication complexity <span class="math">O(k\\log n)</span>. The protocol is sound against a malicious prover and is strongly zero-knowledge against <span class="math">t=k-1</span> malicious verifiers.</p>

    <p class="text-gray-300">See Corollary 6.7 for a more precise and general statement. We also give a Fiat-Shamir-style compiler that uses a random oracle to collapse multiple rounds of interaction into a single message sent by <span class="math">P</span> to each <span class="math">V_{j}</span> over a private channel, followed by a single message by each <span class="math">V_{j}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Language</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof system</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comm. complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hamming weight 1: x̂ ∈ Fn, weight(x̂) = 1</td>

            <td class="px-3 py-2 border-b border-gray-700">Prio [44]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem A.2 via [54]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Riposte** [45]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Verifiable FSS** [35]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">x̂ ∈ {0,...,B}n ⊆ Fn</td>

            <td class="px-3 py-2 border-b border-gray-700">Prio [44]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(B·n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">O(B·√n)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">O(B·log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n Beaver triples: x̂, ŷ, ẑ ∈ Fn where xi·yi = zi for all i ∈ [n]</td>

            <td class="px-3 py-2 border-b border-gray-700">Prio [44]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√n)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem A.1 via GKR [75]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Corollary 5.5</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Arbitrary circuit C, C(x̂) = 1 (size n, depth d, fan-in 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">Prio [44]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem A.1 via GKR [75]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d log n)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1: Communication and round complexity for proof systems where the input data is secret shared among a number of parties. We assume the proofs are over a finite field  <span class="math">\\mathbb{F}</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg n$ . Prio [44] is a system for private data aggregation that uses proofs on secret shared data for data integrity. Riposte [45] is a system for anonymous communication that uses proofs on secret shared data to prevent data corruption. Verifiable function secret sharing (FSS) [35] enables secret sharing of simple functions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">** All systems in the table, except Riposte, verifiable FSS, and GKR, maintain zero knowledge when all but one of the verifiers are malicious. In contrast, 3-server Riposte tolerates only one corruption. Verifiable FSS tolerates only semi-honest verifiers and GKR does not provide zero-knowledge.</p>

    <p class="text-gray-300">Given a robust encoding (or robust secret sharing) of the input  <span class="math">x</span> , we present distributed zero-knowledge protocols that maintain their soundness even when a malicious prover colludes with  <span class="math">t &amp;lt; k / 2</span>  malicious verifiers (see Section 6.3 for details). In contrast, we note that previous sublinear proof systems on secret-shared data either do not attempt to protect against malicious verifiers [35], or assume a majority of honest verifiers [45]. Neither considers soundness against a malicious prover colluding with malicious verifiers.</p>

    <p class="text-gray-300">Table 1 summarizes the communication and round complexity of the proof systems on secret-shared data for languages that frequently come up in practice, for example in the Prio system [44] for privately aggregating data, and in the Riposte [45] system for anonymous communication. The table illustrates the strong benefits of interactive fully linear proof systems over non-interactive ones.</p>

    <p class="text-gray-300">We note that interactive proofs with distributed verifiers were recently studied in [90, 99] for the purpose of proving properties of a communication graph connecting a large number of verifiers. The relevance of the interactive proofs of GKR [74] and RRR [109] to this setting has been observed in [99]. Our focus here is quite different; we are motivated by the goal of proving in zero knowledge simple properties of data distributed among a small set of verifiers. As a result, our abstractions, constructions, and applications are very different from those in prior work [90, 99].</p>

    <p class="text-gray-300">Contribution V: Applications to honest-majority MPC. We next demonstrate applications of our zero-knowledge fully linear proof systems for protecting protocols for secure multiparty computation (MPC) in the honest-majority setting against malicious parties, with vanishing amortized communication overhead, and without resorting to the heavy machinery of succinct (two-party) zero-knowledge argument systems for NP.</p>

    <p class="text-gray-300">COMPILING "NATURAL" HONEST-MAJORITY PROTOCOLS. Dating back to the work of Goldreich,</p>

    <p class="text-gray-300">Micali, and Wigderson (GMW) <em>[72]</em>, the standard approach to secure protocol design begins by attaining semi-honest (passive) security, then compiling the protocol in some way to enforce semi-honest behavior. The GMW compiler relies on standard zero-knowledge proofs, which apply to <em>public</em> statements. As a result, it does not apply directly to the case of protocols that employ communication over secure point-to-point channels. To get around this limitation, we employ our distributed zero-knowledge proofs in the following way.</p>

    <p class="text-gray-300">As observed in recent works, the vast majority of semi-honest MPC protocols from the literature share the following natural form:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Up to the final exchange of messages, the protocol reveals <em>no</em> information about parties’ inputs, even if parties act maliciously.</li>

      <li>The messages sent by a party <span class="math">P_{i}</span> in each round are <em>degree-2</em> functions (or, more generally, low-degree functions) of messages received in previous rounds.</li>

    </ul>

    <p class="text-gray-300">The first property means that parties can safely execute all but the final round of the underlying protocol unchanged, and then simultaneously verify that in all prior rounds the parties acted semi-honestly. The second property means that this verification can be expressed as satisfaction of a collection of several degree-2 constraints on parties’ incoming and outgoing messages. More concretely, each party <span class="math">P_{i}</span> must convince the remaining parties in zero knowledge that the statement <span class="math">M_{i}</span> consisting of all his round-by-round incoming and outgoing messages—and which is <em>distributed</em> across the remaining parties—is indeed contained within some appropriate language <span class="math">\\mathcal{L}_{i}</span> verifiable by a degree-2 circuit. This is precisely the setting of our zero knowledge proofs on distributed data.</p>

    <p class="text-gray-300">We demonstrate an approach for compiling semi-honest protocols of the above “natural” form (formally defined in Section 7) in the honest-majority setting, to <em>malicious</em> security with abort, with <em>sublinear additive communication overhead</em>. This is achieved by adding a phase in the penultimate round of the base protocol, in which each party <span class="math">P_{i}</span> executes a single interactive proof on distributed data that the <em>entire</em> interaction thus far has been performed honestly. The necessary zero-knowledge protocols that we develop induce communication that is sublinear in the circuit size.</p>

    <p class="text-gray-300">Note that while many efficient MPC protocols from the literature implement batch-verification of shared secrets by revealing random linear combinations, this technique only applies to checking <em>linear</em> relations between the secrets. Fully linear proof systems provide a powerful extension of this approach to batch-verification of <em>non-linear</em> relations with sublinear communication cost.</p>

    <p class="text-gray-300">The case of 3-party computation. A specific motivated setting is that of 3-party computation with 1 malicious corruption (and security with abort). The task of minimizing communication in such protocols has attracted a significant amount of research effort (e.g., <em>[4, 5, 40, 58, 65, 78, 92, 98, 101]</em>). To date, the best protocols communicate: 2 field elements per multiplication gate per party over large fields (size comparable to <span class="math">2^{\\sigma}</span> for statistical security parameter <span class="math">\\sigma</span>) <em>[40, 101]</em>, or alternatively 7 bits per multiplication gate per party for Boolean circuits <em>[4]</em> (improving on 10 bits in <em>[65]</em>).</p>

    <p class="text-gray-300">Applying our compiler to a 3-party semi-honest protocol of Katz et al. <em>[87]</em> (see also e.g. <em>[5, 47, 56]</em>), we obtain a 3-party protocol guaranteeing security with abort against 1 malicious party, with <em>1 ring element</em> communicated per party per multiplication (amortized over large circuit size). Our result holds over any finite field or modular arithmetic ring <span class="math">\\mathbb{Z}_{w}</span>; in particular, also for Boolean circuits.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1.4 (Informal - Malicious 3PC, 1 ring element/gate/party).</h6>

    <p class="text-gray-300">There exists a 3-party protocol for securely computing any <span class="math">R</span>-arithmetic circuit <span class="math">C</span> (for <span class="math">R</span> field of arbitrary size or <span class="math">R=\\mathbb{Z}_{w}</span>) with the following features:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol makes black-box use of any pseudorandom generator. If <span class="math">R</span> is a field, it also makes a black-box use of <span class="math">R</span>.</li>

      <li>The protocol is computationally secure with abort against one malicious party.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The communication complexity is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> elements of </span>R<span class="math"> per party, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of multiplication and input gates in </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that one may apply trade-offs between communication and computation requirements in order to yield more appealing concrete parameters. In particular, directly applying our compiler to verify consistency of the entire protocol transcript as one large statement will induce an $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ computational overhead (due to the necessity of an FFT computation); however, the structure of the resulting protocol-compliance language directly supports verification in smaller blocks, enabling lower computation overhead at the expense of communicating a small number of separate proofs. From an asymptotic point of view, our theorem cannot be obtained via the general machinery of (single-verifier) succinct zero-knowledge arguments for NP, since the latter require stronger assumptions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We also describe an application of our compiler in the more general honest majority case where <span class="math">t&amp;lt;n/2</span> for constant <span class="math">n</span>, building from a semi-honest protocol à la Damgård and Nielsen <em>[55]</em>. Here more care must be taken to ensure the protocol satisfies the required natural condition, and in particular we augment the protocol with extra redundancy to ensure robustness (incurring <span class="math">{n\\choose i}</span> computation and storage overhead, thus limiting our construction to constant number of parties). Overall, our resulting protocol achieves malicious security with <span class="math">3t/(2t+1)</span> (always <span class="math">\\leq 1.5</span>) ring elements communicated per gate per party.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 A Taxonomy of Information-Theoretic Proof Systems</h2>

    <p class="text-gray-300">One of the contributions of this work is to introduce and formalize the notions of <em>fully linear</em> PCPs and IOPs. To situate these new types of proof systems in the context of prior work, we briefly survey the landscape of existing systems. This discussion will be relatively informal; see Section 3 for formal definitions of linear and fully linear proof systems.</p>

    <p class="text-gray-300">A tremendously successful paradigm for the construction of cryptographic proof systems is the following: First, construct a proof system that provides security guarantees (soundness and possibly zero-knowledge) against <em>computationally unbounded</em> parties. We will refer to this as an “information-theoretic proof system,” or sometimes as a probabilistically checkable proof (PCP). This information-theoretic system is often useless as a standlone object, since it typically makes idealized assumptions (such as independence between two messages or restricted access to the proof) that are difficult to enforce. Next, use cryptographic assumptions and/or an augmented model of computation (e.g., the random-oracle model <em>[13]</em>) to “compile” the information-theoretic proof system into one that can be directly implemented. This compiler may also provide extra desirable properties, such eliminating interaction, improved communication complexity, or sometimes even an extra zero knowledge property, at the possible cost of security against <em>computationally bounded</em> prover and/or verifier. We refer to this type of compiler as a “cryptographic compiler.”</p>

    <p class="text-gray-300">Different kinds of information-theoretic proof systems call for different cryptographic compilers. The main advantage of this separation is modularity: information-theoretic proof systems can be designed, analyzed and optimized independently of the cryptographic compilers, and their security properties (soundness and zero-knowledge) do not depend on any cryptographic assumptions. It may be beneficial to apply different cryptographic compilers to the same information-theoretic proof system, as different compilers may have incomparable efficiency and security features. For instance, they may trade succinctness for better computational complexity or post-quantum security or, more relevant to this work, apply to different representations of the input statement.</p>

    <p class="text-gray-300">To give just a few examples of this methodology: Micali <em>[96]</em> uses a random oracle to compile any classical PCP into a <em>succinct</em> non-interactive argument system for NP. As another example, Ben-Or et al. <em>[14]</em> compile any interactive proof system into a <em>zero-knowledge</em> interactive proof system</p>

    <p class="text-gray-300">using cryptographic commitments. Finally, Bitansky et al. <em>[27]</em> compile a linear PCP into a succinct non-interactive argument of knowledge (SNARK) using either a “linear-only encryption” for the designated-verifier setting or a “linear-only one-way encoding,” instantiated via bilinear groups, for the public verification setting. In this work we compile <em>fully linear</em> PCPs and IOPs into proofs on distributed, secret-shared, encrypted, or committed data.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Comparison with Other Proof Systems</h3>

    <p class="text-gray-300">In the following we survey some information-theoretic proof systems used in prior work. For simplicity, we ignore the zero-knowledge feature that is typically added to all proof systems.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}\\subseteq\\{0,1\\}^{<em>}</span> be a language. Speaking informally, a proof system for <span class="math">\\mathcal{L}</span> is a pair of (possibly interactive) algorithms <span class="math">(P,V)</span>. Both the prover <span class="math">P</span> and verifier <span class="math">V</span> take a string <span class="math">x\\in\\{0,1\\}^{</em>}</span> as input (e.g., a SAT formula), and the prover’s task is to convince the verifier that <span class="math">x\\in\\mathcal{L}</span> (e.g., that <span class="math">x</span> is satisfiable). We sometimes view <span class="math">x</span> as a vector over a finite field <span class="math">\\mathbb{F}</span>. We require the standard notions of <em>completeness</em> and <em>soundness</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the simplest such proof system, the prover sends the verifier a single proof string <span class="math">\\pi</span> of size $\\mathsf{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the verifier reads </span>x<span class="math"> and </span>\\pi$, and accepts or rejects. When the verifier is randomized and efficient, this setting corresponds to a Merlin-Arthur proof system <em>[8]</em>. There are a number of modifications to this basic paradigm that yield interesting alternative proof systems. In particular, we can:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Allow interaction between the prover and verifier</em>. In an interactive proof, the prover and verifier exchange many messages, after which the verifier must accept or reject. Allowing interaction may increase the power of the proof system <em>[115]</em> and makes it possible to provide zero-knowledge <em>[77]</em> in the plain model. (Alternatively, a common reference string is sufficient <em>[28]</em>.)</li>

      <li><em>Restrict the verifier’s access to the proof</em>. Another way to modify the basic paradigm is to restrict the means by which the verifier interacts with the proof. In particular, we can view the proof as an oracle, and only allow the verifier to make a bounded (e.g., constant) number of queries to the proof oracle.</li>

    </ul>

    <p class="text-gray-300">In the classical PCP model <em>[60, 62, 7]</em>, the proof is a string <span class="math">\\pi\\in\\Sigma^{m}</span>, for some finite alphabet <span class="math">\\Sigma</span>, and the verifier can only read a small number of symbols from the proof. On input <span class="math">i</span>, the oracle returns the <span class="math">i</span>th bit of the proof string <span class="math">\\pi</span>. (We call these “point queries.”)</p>

    <p class="text-gray-300">In the linear PCP model <em>[83, 27]</em>, the proof is a vector <span class="math">\\pi\\in\\mathbb{F}^{m}</span>, for some finite field <span class="math">\\mathbb{F}</span>, and the verifier can can only make a small number of “linear queries” to the proof. That is, the proof oracle takes as input a vector <span class="math">q\\in\\mathbb{F}^{m}</span> and returns the inner-product <span class="math">\\langle\\pi,q\\rangle\\in\\mathbb{F}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Restrict the verifier’s access to the input</em>. Yet another way to modify the basic paradigm is to restrict the verifier’s access to the input <span class="math">x</span>. In particular, we can view the <em>input</em> as an oracle, and only allow the verifier to make a bounded (e.g., constant) number of queries to the input oracle. The strong motivation for this is explained later in this section. We consider two variants.</li>

    </ul>

    <p class="text-gray-300">The model in which we view the input as a string, and only allow the verifier to make a limited number of point queries to the input, corresponds to a PCP of proximity <em>[24]</em>. With a few point queries, it is not possible to distinguish between an input <span class="math">x\\in\\mathcal{L}</span>, and an input <span class="math">x</span> “close to <span class="math">\\mathcal{L}</span>” (in Hamming distance). For this reason, PCPs of proximity necessarily provide only a relaxed notion of soundness: if <span class="math">x</span> is “far from <span class="math">\\mathcal{L}</span>,” then the verifier will likely reject.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Queries to input</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Queries to proof</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Representative compilers</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Non-interactive</td>

            <td class="px-3 py-2 border-b border-gray-700">Classical (MA) [8]</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PCP [6,7]</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700">Kilian [88], Micali [96]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Linear PCP [83]</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700">IKO [83], Pepper [114], GGPR [67], PHGR [104,105], BCIOP [27]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PCP of proximity [25]</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700">Kalai & Rothblum [85]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fully linear PCP</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700">This paper</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Interactive</td>

            <td class="px-3 py-2 border-b border-gray-700">Interactive proof (IP) [77]</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Ben Or et al. [14]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">IOP [23]</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700">BCS [23]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Linear IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">Read all</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">IOP of proximity [18,19]</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700">Point</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fully linear IOP</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700">Linear</td>

            <td class="px-3 py-2 border-b border-gray-700">This paper, Hyrax [122], vSQL [124,125]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: A comparison of information-theoretic proof systems. The bolded proof system models are ones that we introduce explicitly in this work. "Read all" refers to reading the entire data field, "Point" refers to reading a small number of cells of the data, and "Linear" refers to a small number of linear queries to the data.</p>

    <p class="text-gray-300">Alternatively, we can view the input as a vector  <span class="math">x \\in \\mathbb{F}^n</span> , for some finite field  <span class="math">\\mathbb{F}</span> , and only allow the verifier to make a small number of linear queries to the input  <span class="math">x</span> . That is, the input oracle takes as input a vector  <span class="math">q \\in \\mathbb{F}^n</span>  and returns the inner-product  <span class="math">\\langle x, q \\rangle \\in \\mathbb{F}</span> . We show that this notion, introduced and studied in this work, is sufficient to provide a standard notion of soundness (unlike the relaxed notion of soundness provided by PCPs of proximity).</p>

    <p class="text-gray-300">We now have three attributes by which we can classify information-theoretic proof systems: interactivity (yes/no), proof query type (read all/point/linear), and input query type (read all/point/linear). Taking the Cartesian product of these attributes yields 18 different possible proof systems, and we list ten of particular interest in Table 2.</p>

    <p class="text-gray-300">For example, interactive oracle proofs (IOPs) are interactive proofs in which the verifier has unrestricted access to the input but may make only point queries to proof strings [23]. Ben-Sasson et al. [23] show how to compile such proofs into SNARGs in the random-oracle model and recent hash-based SNARGs, including Ligero [2], STARK [17], and Aurora [22] are built using this technique.</p>

    <p class="text-gray-300">Why fully linear proof systems? It is often the case that the verifier only has access to an additively homomorphic encoding of a statement  <span class="math">x</span> , and the prover convinces the verifier that the encoded statement is true. For example the verifier may be given an additively homomorphic commitment or encryption of the statement  <span class="math">x</span> . Or the verifier may be implemented as a set of two or more servers who have a linear secret sharing of the statement  <span class="math">x</span> , or who hold different parts of  <span class="math">x</span> .</p>

    <p class="text-gray-300">In all these settings, the verifiers can easily compute an encoding of the inner product of the statement  <span class="math">x</span>  with a known query vector  <span class="math">q</span> . In some cases (such as the case of encrypted or committed data), the verifiers may need the prover's help help to "open" the resulting inner products.</p>

    <p class="text-gray-300">When we compile fully linear PCPs into proof systems on shared, encrypted, or committed data, our compilers have the same structure: the prover sends an additively homomorphic encoding of the proof to the verifier. The verifier makes linear queries to the proof and input, and (if necessary) the prover provides "openings" of these linear queries to the verifier. The verifier checks that the openings are consistent with the encodings it was given, and then runs the fully linear PCP verifier to decide whether to accept or reject the proof.</p>

    <p class="text-gray-300">The need for new constructions. In current applications of PCPs and linear PCPs, the length</p>

    <p class="text-gray-300">of the proof is not a complexity metric of much relevance. For example, in the BCIOP compiler <em>[27]</em> for compiling a linear PCP into a succinct non-interactive argument of knowledge (SNARK), the size of the proof corresponds to the prover’s running time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the language <span class="math">\\mathcal{L}</span> in question is decided by circuits of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then having proofs of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is acceptable, since the prover must run in time </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ no matter what. A similar property holds for Micali’s CS proofs <em>[96]</em>, Kilian’s PCP compiler <em>[88]</em>, the BCS compiler <em>[23]</em> of interactive oracle proofs, and so on.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In our compilers, the prover must materialize the entire fully linear PCP proof, encode it, and send it to the verifier. For us, the size of the fully linear PCP proof not only dictates the running time of the prover, but also dictates the number of bits that the prover must communicate to the verifier. For this reason, in our setting, minimizing the proof size is an important goal.</p>

    <p class="text-gray-300">Furthermore, when compiling linear PCPs into SNARKs using the existing compilers <em>[27, 81, 105]</em> it is critical that the linear PCP verifier be expressible as an arithmetic circuit of degree two. This is because the linear PCP verification checks are essentially run “in the exponent” of a bilinear group. In contrast, the settings we consider allow for more flexibility: the arithmetic degree of the verifier typically does not play a role in the final applications, except perhaps for a possible influence on proof verification time.</p>

    <p class="text-gray-300">Relating fully linear PCPs to streaming proof systems. The setting of <em>stream annotations</em> <em>[39]</em>, introduced by Chakrabarti, Cormode, McGregor, and Thaler, restricts not only the verifier’s access to the input and proof, but also the space usage of the verifier. In this model, the verifier is a space-bounded streaming algorithm: it may take a single pass over the input and proof, and must decide whether to accept or reject. For example, the verifier might be allowed only <span class="math">O(\\sqrt{n})</span> bits of working space to decide inputs of length <span class="math">n</span>. The <em>streaming interactive proof</em> model <em>[43]</em> is a generalization in which the prover and verifier may interact.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fully linear interactive proofs naturally give rise to stream annotation proof systems. The reason is that if a fully linear PCP verifier makes <span class="math">q_{\\pi}</span> linear proof queries and <span class="math">q_{x}</span> linear input queries, then the verifier can compute the responses to all of its queries by taking a single streaming pass over the input and proof while using $(q_{x}+q_{\\pi})\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ bits of space. Thus, fully linear PCPs with small proof size and query complexity give rise to stream annotation proof systems with small proof and space requirements. Similarly, fully linear IOPs give rise to streaming interactive proofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The implication in the other direction does not always hold, however, since stream annotation systems do not always give rise to fully linear PCPs with good parameters. The reason is that a streaming verifier may, in general, compute some non-linear function of the input that is difficult to simulate with linear queries.</p>

    <p class="text-gray-300">Other proof systems. We briefly mention a number of other important classes of proof systems in the literature that are out of scope of this discussion. <em>Linear interactive proofs</em> are a model of interactive proof in which each message that the prover sends is an affine function of all of the verifier’s previous messages (but is not necessarily an affine function of the input) <em>[27]</em>.</p>

    <p class="text-gray-300">The fully linear PCP model is well matched to the problem of proving statements on data encoded with an additively homomorphic encoding, such as Paillier encryption <em>[102]</em> or a linear secret-sharing scheme. A different type of encoding is a <em>succinct</em> encoding, in which the prover can commit to a vector in <span class="math">\\mathbb{F}^{m}</span> with a string of size sublinear in <span class="math">m</span> <em>[86, 38]</em>. Bootle et al. <em>[33]</em> introduce the “Ideal Linear Commitment” (ILC) model as an abstraction better suited to this setting. In the ILC proof model, the prover sends the verifier <em>multiple</em> proofs vectors <span class="math">\\pi_{1},\\ldots,\\pi_{k}\\in\\mathbb{F}^{m}</span> in each round. The verifier is given a proof oracle that takes as input a vector <span class="math">q\\in\\mathbb{F}^{k}</span> and returns the linear combination <span class="math">q^{T}\\cdot(\\pi_{1}\\ \\ldots\\ \\pi_{k})\\in\\mathbb{F}^{m}</span>. It is possible to translate linear IOP proofs into ILC proofs (and vice versa) up to some looseness in the parameters. A linear IOP in which the prover sends a length-<span class="math">m</span> proof</p>

    <p class="text-gray-300">in each round implies an ILC proof with the same query complexity in which the prover sends <span class="math">m</span> proofs of length <span class="math">1</span> in each round. An ILC proof in which the prover sends <span class="math">k</span> proofs of length <span class="math">m</span> and makes <span class="math">\\ell</span> queries in each round implies a linear IOP with proof length <span class="math">k\\cdot m</span> and query complexity <span class="math">\\ell\\cdot m</span>. ILC-type proofs underlie the recent succinct zero-knowledge arguments of Bootle et al. <em>[32]</em> and Bünz et al. <em>[36]</em>, whose security is premised on the hardness of the discrete-log problem.</p>

    <p class="text-gray-300">Finally, another related notion from the literature is that of a <em>holographic proof</em> <em>[82, 9]</em>, where the verifier gets oracle access to an <em>encoding</em> of the input using an arbitrary error-correcting code, typically a Reed-Muller code. Our notion of fully linear PCPs can be viewed as a variant of this model where the input is (implicitly) encoded by the Hadamard code and the proof can be accessed via <em>linear</em> queries (as opposed to point queries). In fact, our model allows a single linear query to apply <em>jointly</em> to the input and the proof.</p>

    <p class="text-gray-300">We have not discussed multi-prover interactive proofs <em>[15]</em>, in which multiple non-colluding provers interact with a single verifier, or more recently, multi-prover proofs in which a verifier gets access to multiple (possibly linear) proof oracles <em>[83, 31]</em>.</p>

    <p class="text-gray-300">“Best-of-both-worlds” proof systems. To conclude this section, we point to an interesting direction for future work on proof systems. A very desirable type of proof system, which is <em>not</em> listed in Table 2, would be one in which the verifier makes <em>linear</em> queries to the input and <em>point</em> queries to the proof. This type of proof system, which we call a <em>strongly linear</em> proof, achieves in some sense the “best of both worlds:” the verifier has restricted access to the input (as in a PCP of proximity or fully linear PCP) and yet achieves the standard notion of soundness (as in a classical PCP). While it is possible in principle to construct such strongly linear PCPs and IOPs by combining standard PCPs or IOPs of proximity <em>[20, 24]</em> with linear error-correcting codes, this generic combination may not yield the best achievable parameters.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Definitions</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. For <span class="math">n\\in\\mathbb{N}</span>, let <span class="math">[n]=\\{1,\\ldots,n\\}</span>. Let <span class="math">\\parallel</span> denote concatenation, <span class="math">\\langle\\cdot,\\cdot\\rangle</span> denote inner product and <span class="math">\\perp</span> denote the empty string. When <span class="math">C</span> is an arithmetic circuit over a finite field <span class="math">\\mathbb{F}</span>, we use $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to denote the number of multiplication gates in the circuit. When </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>n<span class="math">, we let </span>1,2,\\ldots,n$ denote distinct nonzero field elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On concrete vs. asymptotic treatment. Since our new types of proof systems are meaningful objects even when all of the algorithms involved are computationally unbounded, our definitions refer to languages and <span class="math">\\mathsf{NP}</span>-relations as finite objects and do not explicitly refer to the running time of algorithms. All of our definitions can be naturally extended to the standard asymptotic setting of infinite languages and relations with polynomial-time verifiers, honest provers, simulators, and knowledge extractors. Our positive results satisfy these asymptotic efficiency requirements.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Fully linear PCPs</h3>

    <p class="text-gray-300">Our new notion of <em>fully</em> linear PCPs build upon the definitions of standard linear PCPs from Ishai et al. <em>[83]</em> and Bitansky et al. <em>[27]</em>. We start by recalling the original notion.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.1 (Linear PCP).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field and let <span class="math">\\mathcal{R}\\subseteq\\mathbb{F}^{n}\\times\\mathbb{F}^{h}</span> be a binary relation. A linear probabilistically checkable proof system for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span> with proof length <span class="math">m</span>, soundness error <span class="math">\\epsilon</span>, and query complexity <span class="math">\\ell</span> is a pair of algorithms <span class="math">(P_{\\mathsf{LPCP}},V_{\\mathsf{LPCP}})</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">(x,w)\\in\\mathcal{R}</span>, the prover <span class="math">P_{\\mathsf{LPCP}}(x,w)</span> outputs a proof <span class="math">\\pi\\in\\mathbb{F}^{m}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">V_{\\mathsf{LPCP}}</span> consists of a query algorithm <span class="math">Q_{\\mathsf{LPCP}}</span> and a decision algorithm <span class="math">D_{\\mathsf{LPCP}}</span>. The query algorithm <span class="math">Q_{\\mathsf{LPCP}}</span> takes no input and outputs <span class="math">\\ell</span> queries <span class="math">q_{1},\\ldots,q_{\\ell}\\in\\mathbb{F}^{m}</span>, which are independent of <span class="math">x</span>, and state information <span class="math">\\mathsf{st}</span>. The decision algorithm <span class="math">D_{\\mathsf{LPCP}}</span> takes as input the state <span class="math">\\mathsf{st}</span>, the statement <span class="math">x</span>, and the <span class="math">\\ell</span> answers <span class="math">\\langle\\pi,q_{1}\\rangle,\\ldots,\\langle\\pi,q_{\\ell}\\rangle\\in\\mathbb{F}</span> to <span class="math">Q_{\\mathsf{LPCP}}</span>’s queries. It outputs “accept” or “reject.”</li>

    </ul>

    <p class="text-gray-300">The algorithms additionally satisfy the following requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all <span class="math">(x,w)\\in\\mathcal{R}</span>, the verifier accepts a valid proof:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\Big{[}D_{\\mathsf{LPCP}}(\\mathsf{st},x,\\langle\\pi,q_{1}\\rangle,\\ldots,\\langle\\pi,q_{\\ell}\\rangle)=\\text{\`\`accept''}\\ :\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\pi\\ \\ \\leftarrow P_{\\mathsf{LPCP}}(x,w)\\\\ (\\mathsf{st},q_{1},\\ldots,q_{\\ell})\\ \\leftarrow Q_{\\mathsf{LPCP}}()\\ \\Big{]}=1. \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For all <span class="math">x^{<em>}\\not\\in\\mathcal{L}(\\mathcal{R})</span>, and for all false proofs <span class="math">\\pi^{</em>}\\in\\mathbb{F}^{m}</span>, the probability that the verifier accepts is at most <span class="math">\\epsilon</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}D_{\\mathsf{LPCP}}(\\mathsf{st},x^{<em>},\\langle\\pi^{</em>},q_{1}\\rangle,\\ldots,\\langle\\pi^{*},q_{\\ell}\\rangle)=\\text{\`\`accept&#x27;&#x27;}\\ :\\ (\\mathsf{st},q_{1},\\ldots,q_{\\ell})\\leftarrow Q_{\\mathsf{LPCP}}()\\Big{]}\\leq\\epsilon.</span></p>

    <p class="text-gray-300">In some applications of linear PCPs, one also needs a knowledge property <em>[27]</em>: if <span class="math">V_{\\mathsf{LPCP}}(x)</span> accepts a proof <span class="math">\\pi</span>, then there exists an extractor <span class="math">E_{\\mathsf{LPCP}}</span> that, on input <span class="math">\\pi</span>, outputs a witness <span class="math">w</span> such that <span class="math">(x,w)\\in\\mathcal{R}</span>. The linear PCPs we introduce in this work all satisfy this property, though we prove the simpler soundness property.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 3.2 (Linear PCPs for languages).</h6>

    <p class="text-gray-300">On occasion we refer to linear PCPs for a <em>language</em> <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span>, rather than for a binary relation <span class="math">\\mathcal{R}\\subseteq\\mathbb{F}^{n}\\times\\mathbb{F}^{h}</span>. This will typically be the case when <span class="math">\\mathcal{L}</span> is efficiently recognizable, in which case the prover does not require an additional witness <span class="math">w</span>. Essentially the same notions of completeness and soundness apply in this setting: if <span class="math">x\\in\\mathcal{L}</span>, the verifier always accepts and for all <span class="math">x\\not\\in\\mathcal{L}</span> the verifier rejects except with at most <span class="math">\\epsilon</span> probability.</p>

    <p class="text-gray-300">We now define our main new notion of <em>fully linear PCPs</em> and their associated <em>strong zero knowledge</em> property.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3.3 (Fully linear PCP - FLPCP).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a linear PCP is <em>fully linear</em> if the decision predicate <span class="math">D_{\\mathsf{LPCP}}</span> makes only linear queries to both the statement <span class="math">x</span> and to the proof <span class="math">\\pi</span>. More formally, the query algorithm <span class="math">Q_{\\mathsf{LPCP}}</span> outputs queries <span class="math">q_{1},\\ldots,q_{\\ell}\\in\\mathbb{F}^{m+n}</span>, and state information <span class="math">\\mathsf{st}</span>. The decision algorithm <span class="math">D_{\\mathsf{LPCP}}</span> takes as input the query answers $a_{1}=\\langle(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi),q_{1}\\rangle,\\ldots,a_{\\ell}=\\langle(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi),q_{\\ell}\\rangle<span class="math">, along with the state </span>\\mathsf{st}$, and outputs an accept/reject bit.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-13" class="text-base font-medium mt-4">Remark 3.4.</h6>

    <p class="text-gray-300">If we do not restrict the running time of the linear PCP verifier and we do not restrict the manner in which the verifier can access the statement <span class="math">x</span>, then all relations have trivial a linear PCPs: an inefficient linear PCP verifier can simply iterate over every possible witness <span class="math">w</span> and test whether <span class="math">(x,w)\\in\\mathcal{R}</span>. To make the definition non-trivial, the standard notion of PCPs <em>[118]</em> (and also linear PCPs <em>[27, 83]</em>) restricts the verifier to run in polynomial time. In contrast, a fully linear PCP restricts the <em>verifier’s access to the statement</em> <span class="math">x</span> by permitting the verifier to make a bounded number of linear queries to <span class="math">x</span>. This restriction makes the definition non-trivial: even if the verifier can run in unbounded time, it cannot necessarily decide whether <span class="math">x\\in\\mathcal{L}(\\mathcal{R})</span> without the help of a proof <span class="math">\\pi</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3.5 (Degree of FLPCPs).</h6>

    <p class="text-gray-300">We say that a fully linear PCP has a degree-<span class="math">d</span> verifier if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the state information <span class="math">\\mathsf{st}</span> that the query algorithm outputs is in <span class="math">\\mathbb{F}^{\\mu}</span> and</li>

      <li>the decision algorithm <span class="math">D_{\\mathsf{LPCP}}</span> is computed by an arithmetic circuit of degree <span class="math">d</span>. That is, there exists a test polynomial <span class="math">T:\\mathbb{F}^{\\mu+\\ell}\\to\\mathbb{F}^{\\eta}</span> of degree <span class="math">d</span> such that <span class="math">T(\\mathsf{st},a_{1},\\ldots,a_{\\ell})=0^{\\eta}</span> if and only if <span class="math">D_{\\mathsf{LPCP}}(\\mathsf{st},a_{1},\\ldots,a_{\\ell})</span> accepts.</li>

    </ul>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3.6 (Strong zero-knowledge fully linear PCPs).</h6>

    <p class="text-gray-300">A fully linear PCP is <em>strong honest-verifier zero knowledge</em> (strong HVZK) if there exists a simulator <span class="math">S_{\\mathsf{LPCP}}</span> such that for all <span class="math">(x,w)\\in\\mathcal{R}</span>, the following distributions are identical:</p>

    <p class="text-gray-300">\\[ S_{\\mathsf{LPCP}}()\\ \\ \\equiv\\ \\ \\left\\{\\begin{array}[]{c c c}(q_{1},\\ldots,q_{\\ell})&\\pi&\\leftarrow P_{\\mathsf{LPCP}}(x,w)\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\big{(}\\langle(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi),q_{1}\\rangle,\\ldots,\\langle(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi),q_{\\ell}\\rangle\\big{)}&:&(q_{1},\\ldots,q_{\\ell})&\\leftarrow Q_{\\mathsf{LPCP}}()\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array}\\right\\}. \\]</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 3.7.</h6>

    <p class="text-gray-300">The strong zero-knowledge property here departs from the traditional zero-knowledge notion in that it essentially requires that an honest verifier learn <em>nothing</em> about the statement <span class="math">x</span> by interacting with the prover, except that <span class="math">x\\in\\mathcal{L}(\\mathcal{R})</span>. This notion is meaningful in our applications, since the statement <span class="math">x</span> could be encrypted or secret-shared (for example), and thus it makes sense for a verifier to learn that <span class="math">x\\in\\mathcal{L}(\\mathcal{R})</span> without learning anything else about <span class="math">x</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.2 Fully Linear Interactive Oracle Proofs</h3>

    <p class="text-gray-300">In a linear PCP, the interaction between the prover and verifier is “one-shot:” the prover produces a proof <span class="math">\\pi</span>, the verifier makes queries to the proof, and the verifier either accepts or rejects the proof. We define <em>fully linear interactive oracle proofs</em> (“fully linear IOPs”), generalizing linear PCPs to several communication rounds. This sort of linear proof system is inspired by the notion of IOPs from <em>[23, 109]</em> (generalizing an earlier notion of interactive PCPs <em>[84]</em>) that use point queries instead of linear queries.</p>

    <p class="text-gray-300">We start by formalizing a general model of fully linear IOPs in which the verifier can use secret coins, and then specialize it to the case of <em>public-coin</em> IOPs that will be the most useful in this work.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 3.8 ((Fully) linear interactive protocol).</h6>

    <p class="text-gray-300">A <span class="math">t</span>-round <span class="math">\\ell</span>-query (fully) linear interactive linear protocol <span class="math">\\Pi</span> with message length <span class="math">(m_{1},\\ldots,m_{t})\\in\\mathbb{N}^{t}</span> and message complexity <span class="math">c=\\sum_{i=1}^{t}m_{i}</span> over a finite field <span class="math">\\mathbb{F}</span> consists of algorithms <span class="math">P</span> and <span class="math">V</span>. Let the initial state <span class="math">\\mathsf{st}_{0}^{P}</span> of <span class="math">P</span> to be the input to <span class="math">P</span> and let the initial state <span class="math">\\mathsf{st}_{0}^{V}</span> of <span class="math">V</span> to be the input <span class="math">x</span> to <span class="math">V</span>. Let the initial verifier-to-prover message <span class="math">r_{0}=\\bot</span> and let the output of such an interaction be: for each round <span class="math">i\\in\\{1,\\ldots,t\\}</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span> takes as input the round index <span class="math">i</span>, the verifier’s challenge <span class="math">r_{i-1}</span>, and state <span class="math">\\mathsf{st}_{i-1}^{P}</span>, and <span class="math">P</span> outputs a vector <span class="math">\\pi_{i}\\in\\mathbb{F}^{m_{i}}</span> along with state <span class="math">\\mathsf{st}_{i}^{P}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">V</span> takes as input the round index <span class="math">i</span>, state <span class="math">\\mathsf{st}_{i-1}^{V}</span>, makes <span class="math">\\ell</span> linear oracle queries to <span class="math">\\pi_{i}</span> (or to $x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{i}<span class="math"> if it is fully linear), and </span>V<span class="math"> outputs a challenge </span>r_{i}\\in\\mathbb{F}^{b_{i}}<span class="math">, for some parameter </span>b_{i}<span class="math">, along with state </span>\\mathsf{st}_{i}^{V}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol accepts if <span class="math">V</span> outputs “accept” in round <span class="math">t</span> and rejects otherwise.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3.9 (Fully linear interactive oracle proof - FLIOP).</h6>

    <p class="text-gray-300">A <span class="math">t</span>-round <span class="math">\\ell</span>-query interactive fully linear protocol <span class="math">(P_{\\mathsf{LIOP}},V_{\\mathsf{LIOP}})</span> over <span class="math">\\mathbb{F}</span> is a <em>fully linear interactive oracle proof</em> system (fully linear IOP) for a relation <span class="math">\\mathcal{R}</span> with soundness error <span class="math">\\epsilon</span> if it satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For all <span class="math">(x,w)\\in\\mathcal{R}</span>, the interaction <span class="math">[P_{\\mathsf{LIOP}}(x,w),V_{\\mathsf{LIOP}}(x)]</span> always accepts.</li>

      <li>Soundness. For all <span class="math">x\\not\\in\\mathcal{L}(\\mathcal{R})</span>, and for all (computationally unbounded) <span class="math">P^{<em>}</span>, <span class="math">[P^{</em>},V_{\\mathsf{LIOP}}(x)]</span> accepts with probability at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <p class="text-gray-300">As for the case of linear PCPs (Definition 3.1), we can define a knowledge property for linear IOPs <em>[23]</em>. The fully linear IOPs we construct also satisfy this property.</p>

    <p class="text-gray-300">A fully linear IOP is <em>honest-verifier zero knowledge</em> if it additionally satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Honest-verifier zero knowledge. There exists a simulator <span class="math">S_{\\mathsf{LIOP}}</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">S_{\\mathsf{LIOP}}(x)</span> <span class="math">\\equiv</span> <span class="math">\\mathsf{View}_{[P_{\\mathsf{LIOP}}(x,w),V_{\\mathsf{LIOP}}(x)]}(V_{\\mathsf{LIOP}})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Linear PCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Queries</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier deg.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness error</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hadamard LPCP [6,27]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">2)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GGPR-style [67]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G-gates (Thm. 4.3)</td>

            <td class="px-3 py-2 border-b border-gray-700">M·deg G</td>

            <td class="px-3 py-2 border-b border-gray-700">L+2</td>

            <td class="px-3 py-2 border-b border-gray-700">deg G</td>

            <td class="px-3 py-2 border-b border-gray-700">M·deg G/(</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-M)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Degree-two (Cor. 4.7)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">)/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: A comparison of existing and new fully linear PCP constructions for satisfiability of an arithmetic circuit  <span class="math">C:\\mathbb{F}^n\\to \\mathbb{F}</span> . Proof length measures the number of field elements in  <span class="math">\\mathbb{F}</span> . For the  <span class="math">G</span> -gates construction,  <span class="math">G:\\mathbb{F}^L\\to \\mathbb{F}</span>  is an arithmetic circuit of degree  <span class="math">\\deg G</span>  and  <span class="math">M</span>  is the number of  <span class="math">G</span> -gates in the circuit  <span class="math">C</span> .</p>

    <p class="text-gray-300">for all  <span class="math">(x, w) \\in \\mathcal{R}</span> . Here, we use the notation  <span class="math">\\mathrm{View}_{[P_{\\mathrm{LIOP}}(x, w), V_{\\mathrm{LIOP}}(x)]}(V_{\\mathrm{LIOP}})</span>  for the distribution of internal randomness and messages that  <span class="math">V_{\\mathrm{LIOP}}</span>  sees in its interaction with  <span class="math">P_{\\mathrm{LIOP}}(x, w)</span> . Furthermore, we say that a linear IOP satisfies strong zero knowledge (sometimes referred to as strong HVZK) if the simulator  <span class="math">S_{\\mathrm{LIOP}}</span>  takes no input.</p>

    <p class="text-gray-300">Definition 3.10 (Degree of linear IOP verifier). We say that a fully linear PCP has a degree- <span class="math">d</span>  verifier if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the state  <span class="math">\\mathfrak{st}_i^V</span>  that the verifier outputs in round  <span class="math">i</span>  is a vector in  <span class="math">\\mathbb{F}^{\\mu_i}</span> , and</li>

      <li>There exists a test polynomial  <span class="math">T: \\mathbb{F}^{\\sum_{i=1}^{t} (\\mu_i + \\ell)} \\to \\mathbb{F}^\\eta</span>  of degree  <span class="math">d</span>  that takes as input (1) the verifier's state at each round of the protocol and (2) the  <span class="math">\\ell</span>  query responses to the verifier's queries at each round. The verifier accepts if and only if  <span class="math">T</span>  evaluates to  <span class="math">0^\\eta</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 3.11 (Public-coin fully linear IOP). We say that a  <span class="math">t</span> -round  <span class="math">\\ell</span> -query fully linear IOP is public coin if it satisfies the following additional properties:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. In every round  <span class="math">i \\in \\{1, \\dots, t\\}</span>  of interaction, first the prover provides a proof  <span class="math">\\pi_i</span>  and then a public random challenge  <span class="math">r_i</span>  is picked uniformly at random from a finite set  <span class="math">S_i</span> . (The choice of  <span class="math">r_i</span>  is made independently of the proof  <span class="math">\\pi_i</span>  of the same round.) The verifier's  <span class="math">\\ell</span>  linear queries in the  <span class="math">i</span> th round  <span class="math">(q_{i,1}, \\ldots, q_{i,\\ell})</span>  (made to  $x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_i<span class="math"> ) are determined by the random challenges  </span>(r_1, \\ldots, r_i)<span class="math">  sampled so far. The public randomness  </span>r_i$  can influence the proofs generated by the prover in the following rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier's decision predicate is a function only of the public random challenges  <span class="math">(r_1, \\ldots, r_t)</span>  and the answers to the verifier's queries  <span class="math">\\{(q_{i,1}, \\ldots, q_{i,\\ell})\\}_{i \\in [t]}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">All of the fully linear IOPs we construct are public coin. When the first round does not involve a proof but only a random challenge  <span class="math">\\pi_i</span> , we deduct  <span class="math">1/2</span>  from the number of rounds. In particular, a 1.5-round public-coin fully linear IOP is one that involves (in this order): a random challenge  <span class="math">r</span> , a proof  <span class="math">\\pi</span>  (that may depend on  <span class="math">r</span> ), queries  <span class="math">(q_1, \\ldots, q_\\ell)</span>  to  $x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi<span class="math">  that may depend on fresh public randomness  </span>r'<span class="math"> , and decision based on  </span>r, r'$  and the answers to the queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we first show how to construct fully linear PCPs from existing linear PCPs. Next, we introduce a new fully linear PCP that yields shorter proofs for languages that are recognized by arithmetic circuits with certain repeated structure; the only cost is an increase in the algebraic degree of the verifier, which is irrelevant for the main applications we consider. This new fully linear PCP is an important building-block for our new efficient fully linear IOP constructions in Section 5.</p>

    <p class="text-gray-300">4.1 Existing Linear PCPs are Fully Linear and Strong HVZK</p>

    <p class="text-gray-300">We begin by observing that the Hadamard <em>[6, 27]</em> and GGPR-style linear PCPs <em>[21, 27, 67, 113]</em>, as described in the work of Bitansky et al. <em>[27, Appendix A]</em>, satisfy our new notions of full linearity and strong zero knowledge.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Claim 4.1 (Informal).</h6>

    <p class="text-gray-300">The Hadamard linear PCP and the GGPR-based linear PCP are constant-query fully linear PCPs, in the sense of Definition 3.3. Moreover, they yield fully linear PCPs with strong HVZK.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.2 A New Fully Linear PCP with Short Proofs for Structured Circuits</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now describe a fully linear PCP for arithmetic circuit satisfiability, for circuits <span class="math">C</span> with a certain type of repeated structure. When applied to arithmetic circuits of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, it can yield proofs of length </span>o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field elements. In contrast, the existing general-purpose linear PCPs in Claim 4.1 have proof size </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This new linear PCP construction applies to circuits that contain many instances of the same subcircuit, which we call a “<span class="math">G</span>-gate.” If the arithmetic degree of the <span class="math">G</span>-gate is small, then the resulting linear PCP is short. More formally, we define:</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 4.2 (Arithmetic circuit with <span class="math">G</span>-gates).</h6>

    <p class="text-gray-300">We say that a gate in an arithmetic circuit is an <em>affine gate</em> if (a) it is an addition gate, or (b) it is a multiplication gate in which one of the two input is a constant. Let <span class="math">G:\\mathbb{F}^{L}\\to\\mathbb{F}</span> be an arithmetic circuit composed of affine gates and multiplication gates. An <em>arithmetic circuit with <span class="math">G</span>-gates</em> is an arithmetic circuit composed of affine gates and <span class="math">G</span>-gates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following theorem is the main result of this section. Recall that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> refers to the number of non-constant multiplication gates in the arithmetic circuit for </span>G$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 4.3.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be an arithmetic circuit with <span class="math">G</span>-gates over <span class="math">\\mathbb{F}</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the gate <span class="math">G:\\mathbb{F}^{L}\\to\\mathbb{F}</span> has arithmetic degree <span class="math">\\deg G</span>,</li>

      <li>the circuit <span class="math">C</span> consists of <span class="math">M</span> instances of a <span class="math">G</span>-gate and any number of affine gates, and</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. the field <span class="math">\\mathbb{F}</span> is such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>M\\deg G$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, there exists a fully linear PCP with strong HVZK for the relation <span class="math">\\mathcal{R}_{C}=\\{(x,w)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\mid C(x,w)=0\\}</span> that has:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof length <span class="math">h+L+M\\deg G+1</span> elements of <span class="math">\\mathbb{F}</span>, where <span class="math">h</span> is the witness length and <span class="math">L</span> is the arity of the <span class="math">G</span>-gate,</li>

      <li>query complexity <span class="math">L+2</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $M\\deg G/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-M)$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, if we require a fully linear PCP that is not necessarily strong HVZK, then the proof length decreases to <span class="math">h+(M-1)\\deg G+1</span> elements of <span class="math">\\mathbb{F}</span> and the soundness error decreases to $M\\deg G/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of Theorem 4.3 uses the following simple fact about the linearity of polynomial interpolation and evaluation.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Fact 4.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field and let <span class="math">\\pi\\in\\mathbb{F}^{m}</span>. For some integer $n<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, let </span>A_{1},\\ldots,A_{n}<span class="math"> be affine functions that map </span>\\mathbb{F}^{m}<span class="math"> to </span>\\mathbb{F}<span class="math">. Define </span>f<span class="math"> to be the polynomial of lowest-degree such that </span>f(i)=A_{i}(\\pi)<span class="math"> for all </span>i\\in\\{1,\\ldots,n\\}<span class="math">. Then for all </span>r\\in\\mathbb{F}<span class="math"> and all choices of the </span>A_{i}<span class="math">, there exists a vector </span>\\lambda_{r}\\in\\mathbb{F}^{m}<span class="math"> and scalar </span>\\delta_{r}\\in\\mathbb{F}<span class="math">, such that </span>f(r)=\\langle\\lambda_{r},\\pi\\rangle+\\delta_{r}<span class="math"> for all </span>\\pi\\in\\mathbb{F}^{m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Fact 4.4 says that given the values of a polynomial <span class="math">f</span> at the points <span class="math">1,\\ldots,n</span> as affine functions of a vector <span class="math">\\pi\\in\\mathbb{F}^{m}</span>, we can express <span class="math">f(r)</span> as an affine function of <span class="math">\\pi</span>, and this affine function is independent of <span class="math">\\pi</span>. This follows from the fact that polynomial interpolation applied to the <span class="math">n</span> points <span class="math">\\big{\\{}(i,A_{i}(\\pi))\\big{\\}}_{i=1}^{n}</span> followed by polynomial evaluation at the point <span class="math">r</span> is an affine function of <span class="math">\\pi</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof of Theorem 4.3.</h6>

    <p class="text-gray-300">The construction that proves Theorem 4.3 is a generalization of the linear PCP implicit in the construction used in the Prio system <em>[44]</em> and is closely related to a Merlin-Arthur proof system of Williams for batch verification of circuit evaluation <em>[123]</em>. Figure 4 gives an example of the proof construction, applied to a particular simple circuit.</p>

    <p class="text-gray-300">Label the <span class="math">G</span>-gates of the circuit <span class="math">C</span> in topological order from inputs to outputs; there are <span class="math">M</span> such gates in the circuit. Without loss of generality, we assume that the output of the circuit <span class="math">C</span> is the value on the output wire of the last <span class="math">G</span>-gate in the circuit.</p>

    <p class="text-gray-300">FLPCP prover. On input <span class="math">(x,w)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{h}</span>, the prover evaluates the circuit <span class="math">C(\\cdot,\\cdot)</span> on the pair <span class="math">(x,w)</span>. The prover then defines <span class="math">L</span> polynomials <span class="math">f_{1},\\ldots,f_{L}\\in\\mathbb{F}[X]</span> such that, for every <span class="math">i\\in\\{1,\\ldots,L\\}</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the constant term <span class="math">f_{i}(0)</span> is a value chosen independently and uniformly at random from <span class="math">\\mathbb{F}</span>, and</li>

      <li>for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, <span class="math">f_{i}(j)\\in\\mathbb{F}</span> is the value on the <span class="math">i</span>-th input wire to the <span class="math">j</span>-th <span class="math">G</span>-gate when evaluating the circuit <span class="math">C</span> on the input-witness pair <span class="math">(x,w)</span>.</li>

    </ol>

    <p class="text-gray-300">Furthermore, the prover lets <span class="math">f_{1},\\ldots,f_{L}</span> be the polynomials of lowest degree that satisfy these relations. Observe that each of the polynomials <span class="math">f_{1},\\ldots,f_{L}</span> has degree at most <span class="math">M</span>.</p>

    <p class="text-gray-300">Next, the prover constructs a proof polynomial <span class="math">p=G(f_{1},\\ldots,f_{L})\\in\\mathbb{F}[X]</span>. By construction of <span class="math">p</span>, we know that, for <span class="math">j\\in\\{1,\\ldots,M\\}</span>, <span class="math">p(j)</span> is the value on the output wire from the <span class="math">j</span>-th <span class="math">G</span>-gate in the evaluation of <span class="math">C(x,w)</span>. Moreover, <span class="math">p(M)=C(x,w)</span>. Let <span class="math">d</span> be the degree of the polynomial <span class="math">p</span> and let <span class="math">c_{p}\\in\\mathbb{F}^{d+1}</span> be the vector of coeffcients of <span class="math">p\\in\\mathbb{F}[X]</span>. By construction, the degree of <span class="math">p</span> satisfies <span class="math">d\\leq M\\deg G</span>.</p>

    <p class="text-gray-300">The prover outputs <span class="math">\\pi=(w,\\ f_{1}(0),\\ldots,f_{L}(0),\\ c_{p})\\in\\mathbb{F}^{h+L+d+1}</span> as the linear PCP proof.</p>

    <p class="text-gray-300">(<em>Note:</em> If we do not require strong HVZK to hold, then the prover need not randomize the constant terms of the polynomials <span class="math">f_{1},\\ldots,f_{L}</span>. In this case, the prover does not include the values <span class="math">f_{1}(0),\\ldots,f_{L}(0)</span> in the proof, and the degree of the polynomial <span class="math">p</span> decreases to <span class="math">(M-1)\\deg G</span>. Thus, if we do not require strong HVZK, the proof length falls to <span class="math">h+(M-1)\\deg G+1</span>.)</p>

    <p class="text-gray-300">FLPCP queries. We can parse the (possibly maliciously crafted) proof <span class="math">\\pi\\in\\mathbb{F}^{h+L+d+1}</span> as: a purported witness <span class="math">w^{\\prime}\\in\\mathbb{F}^{h}</span>, the values <span class="math">(z^{\\prime}_{1},\\ldots,z^{\\prime}_{L})\\in\\mathbb{F}^{L}</span> representing the constant terms of some polynomials <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}</span>, and the coefficients <span class="math">c^{\\prime}_{p}\\in\\mathbb{F}^{d+1}</span> of a polynomial <span class="math">p^{\\prime}\\in\\mathbb{F}[X]</span> of degree at most <span class="math">d</span>. If the proof is well-formed, the polynomial <span class="math">p^{\\prime}</span> is such that <span class="math">p^{\\prime}(j)</span> encodes the output wire of the <span class="math">j</span>th <span class="math">G</span>-gate in the circuit <span class="math">C(\\cdot,\\cdot)</span> when evaluated on the pair <span class="math">(x,w^{\\prime})</span>.</p>

    <p class="text-gray-300">Given <span class="math">p^{\\prime}</span>, we define <span class="math">L</span> polynomials <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}\\in\\mathbb{F}[X]</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the constant term satisfies <span class="math">f^{\\prime}_{i}(0)=z^{\\prime}_{i}</span>, where <span class="math">z^{\\prime}_{i}</span> is the value included in the proof <span class="math">\\pi^{\\prime}</span>, and</li>

      <li><span class="math">f^{\\prime}_{i}(j)\\in\\mathbb{F}</span> is the value on the <span class="math">i</span>-th input wire to the <span class="math">j</span>-th <span class="math">G</span>-gate in the circuit, under the purported assignment of values to the output wires of the <span class="math">G</span>-gates implied by the polynomial <span class="math">p^{\\prime}</span> and witness <span class="math">w^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">More precisely, we define <span class="math">f^{\\prime}_{i}(j)</span> inductively: The value on the <span class="math">i</span>th input wire to the <span class="math">j</span>th <span class="math">G</span>-gate in the circuit <span class="math">C(x,w^{\\prime})</span> is some affine function <span class="math">A_{ij}</span> of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the input <span class="math">x\\in\\mathbb{F}^{n}</span>,</li>

      <li>the purported witness <span class="math">w^{\\prime}\\in\\mathbb{F}^{h}</span>, and</li>

      <li>the purported outputs of the first <span class="math">j-1</span> <span class="math">G</span>-gates in the circuit: <span class="math">p^{\\prime}(1),\\ldots,p^{\\prime}(j-1)\\in\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">So, for all <span class="math">i\\in\\{1,\\ldots,L\\}</span>, we define <span class="math">f^{\\prime}_{i}</span> to be the polynomial of least degree satisfying:</p>

    <p class="text-gray-300"><span class="math">f^{\\prime}_{i}(0)</span> <span class="math">=z^{\\prime}_{i}</span> <span class="math">f^{\\prime}_{i}(j)</span> <span class="math">=A_{ij}(x,w^{\\prime},p^{\\prime}(1),...,p^{\\prime}(j-1))\\qquad\\text{for}\\quad 1\\leq j\\leq M,</span></p>

    <p class="text-gray-300">where <span class="math">A_{ij}</span> is a fixed affine function defined by the circuit <span class="math">C</span>.</p>

    <p class="text-gray-300">The verifier’s goal is to check that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">p^{\\prime}=G(f^{\\prime}_{1},\\ldots,f^{\\prime}_{L})</span>, and,</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the circuit output <span class="math">p^{\\prime}(M)</span> satisfies <span class="math">p^{\\prime}(M)=0</span>.</li>

    </ol>

    <p class="text-gray-300">As we argue below, the first condition ensures that <span class="math">p^{\\prime}(M)</span> is equal to the output of the circuit <span class="math">C(x,w^{\\prime})</span>. The second check ensures that the output is <span class="math">0</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To implement the first check, the verifier samples a random point <span class="math">r\\stackrel{{\\scriptstyle u}}{{*}}~{}\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span> and outputs query vectors that allow evaluating <span class="math">p^{\\prime}</span> and <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}</span> at the point <span class="math">r</span>. (For the honest-verifier zero knowledge property to hold, it is important that we exclude the set <span class="math">\\{1,\\ldots,M\\}</span> from the set of choices for <span class="math">r</span>.) The verifier has linear access to the input <span class="math">x</span>, witness <span class="math">w^{\\prime}</span>, constant terms <span class="math">z^{\\prime}=(z^{\\prime}_{1},\\ldots,z^{\\prime}_{L})</span>, and the coefficients <span class="math">c^{\\prime}_{p}\\in\\mathbb{F}^{d+1}</span> of the polynomial <span class="math">p^{\\prime}</span>. Hence, using Fact 4.4, it follows that the query algorithm can compute vectors <span class="math">\\lambda_{1},\\ldots,\\lambda_{L}\\in\\mathbb{F}^{n+h+L+d+1}</span> and scalars <span class="math">\\delta_{1},\\ldots,\\delta_{L}\\in\\mathbb{F}</span> such that $f^{\\prime}_{i}(r)=\\langle\\lambda_{i},~{}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c^{\\prime})\\rangle+\\delta_{i}<span class="math"> for </span>i=1,\\ldots,L<span class="math">, where </span>r\\in\\mathbb{F}<span class="math"> is the random point chosen above. Similarly, the query algorithm can compute a vector </span>\\lambda\\in\\mathbb{F}^{n+h+L+d+1}<span class="math"> such that </span>p^{\\prime}(r)=\\langle\\lambda,~{}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c^{\\prime})\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The verifier can execute the second check, to ensure that <span class="math">p^{\\prime}(M)=0</span>, with a single linear query.</p>

    <p class="text-gray-300">FLPCP decision. The decision algorithm takes as input the state value <span class="math">r\\in\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span>, along with the query answers <span class="math">a,a_{1},\\ldots,a_{L},b\\in\\mathbb{F}</span>, where <span class="math">a=p^{\\prime}(r)</span>, <span class="math">a_{i}=f^{\\prime}_{i}(r)</span> for <span class="math">i\\in\\{1,\\ldots,\\ell\\}</span>, and <span class="math">b=p^{\\prime}(M)</span>. The verifier accepts if <span class="math">a=G(a_{1},\\ldots,a_{L})</span> and <span class="math">b=0</span>.</p>

    <p class="text-gray-300">Security arguments. We show completeness, soundness, and strong HVZK.</p>

    <p class="text-gray-300">Completeness. If the prover is honest, then <span class="math">p^{\\prime}=G(f^{\\prime}_{1},\\ldots,f^{\\prime}_{L})</span> and <span class="math">p^{\\prime}(M)=0</span> by construction. The verifier will always accept in this case.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Fix a circuit <span class="math">C</span>, a statement <span class="math">x\\in\\mathbb{F}^{n}</span>, and a proof <span class="math">\\pi^{\\prime}\\in\\mathbb{F}^{h+L+d+1}</span>. We show that if <span class="math">x\\not\\in\\mathcal{L}(\\mathcal{R}_{C})</span> then the verifier accepts with probability at most $M\\deg G/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-M)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As in the description of the query algorithm, we can view:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the first <span class="math">h</span> elements of the proof as a witness <span class="math">w^{\\prime}\\in\\mathbb{F}^{h}</span>,</li>

      <li>the next <span class="math">L</span> elements of the proof as constant terms <span class="math">z^{\\prime}_{1},\\ldots,z^{\\prime}_{L}\\in\\mathbb{F}</span>, and</li>

      <li>the latter elements as the coefficients of a polynomial <span class="math">p^{\\prime}</span> of degree at most <span class="math">d\\leq M\\deg G</span>.</li>

    </ul>

    <p class="text-gray-300">We may assume that <span class="math">p^{\\prime}(M)=0</span>, since otherwise the verifier always rejects. In the discussion that follows, let the polynomials <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}</span> be the ones defined in the description of the linear PCP query algorithm.</p>

    <p class="text-gray-300">We claim that if for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, it holds that <span class="math">p^{\\prime}(j)=G(f^{\\prime}_{1}(j),\\ldots,f^{\\prime}_{L}(j))</span>, then for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, <span class="math">p^{\\prime}(j)</span> encodes the value of the output wire of the <span class="math">j</span>th <span class="math">G</span>-gate in the circuit <span class="math">C</span> when evaluated on input <span class="math">(x,w^{\\prime})</span>.</p>

    <p class="text-gray-300">We prove this claim by induction on <span class="math">j</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Base case (<span class="math">j=1</span>). The values <span class="math">(f^{\\prime}_{1}(1),\\ldots,f^{\\prime}_{L}(1))</span> depend only on the pair <span class="math">(x,w^{\\prime})</span>. By construction, the values <span class="math">(f^{\\prime}_{1}(1),\\ldots,f^{\\prime}_{L}(1))</span> are exactly the values of the input wires to the first <span class="math">G</span>-gate in the evaluation of <span class="math">C(x,w^{\\prime})</span>. Then if <span class="math">p^{\\prime}(1)=G(f^{\\prime}_{1}(1),\\ldots,f^{\\prime}_{L}(1))</span>, <span class="math">p^{\\prime}(1)</span> encodes the value on the output wire of the first <span class="math">G</span>-gate.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Induction step. Assume that, for all <span class="math">k\\in\\{1,\\ldots,j-1\\}</span>, <span class="math">p^{\\prime}(k)=G(f_{1}^{\\prime}(k),\\ldots,f_{L}^{\\prime}(k))</span>. Then, by the induction hypothesis, <span class="math">(p^{\\prime}(1),\\ldots,p^{\\prime}(j-1))</span> are the values on the output wires of the first <span class="math">j-1</span> <span class="math">G</span>-gates of <span class="math">C</span>, when evaluated on <span class="math">(x,w^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">The values <span class="math">(f_{1}^{\\prime}(j),\\ldots,f_{L}^{\\prime}(j))</span> are affine functions of <span class="math">x</span>, <span class="math">w^{\\prime}</span> and the values <span class="math">p^{\\prime}(1),\\ldots,p^{\\prime}(j-1)</span>. Then, by construction of the polynomials <span class="math">(f_{1}^{\\prime},\\ldots,f_{L}^{\\prime})</span>, the values <span class="math">(f_{1}^{\\prime}(j),\\ldots,f_{L}^{\\prime}(j))</span> encode the values on the input wires to the <span class="math">j</span>-th <span class="math">G</span>-gate in the evaluation of the circuit <span class="math">C(x,w^{\\prime})</span>. Finally, if we assume that <span class="math">p^{\\prime}(j)=G(f_{1}^{\\prime}(j),\\ldots,f_{L}^{\\prime}(j))</span>, then <span class="math">p^{\\prime}(j)</span> must be the value on the output wire of the <span class="math">j</span>th <span class="math">G</span>-gate.</p>

    <p class="text-gray-300">We have thus proved the induction step.</p>

    <p class="text-gray-300">This completes the proof of the claim.</p>

    <p class="text-gray-300">If <span class="math">p^{\\prime}(M)=0</span> (as we have assumed), but there exists no witness <span class="math">w^{\\prime}</span> such that <span class="math">C(x,w^{\\prime})=0</span>, then <span class="math">p^{\\prime}(M)</span> does not encode the output value of the <span class="math">M</span>th <span class="math">G</span>-gate in the evaluation of the circuit <span class="math">C(x,w^{\\prime})</span>. By the claim just proved, this implies that for some <span class="math">j^{<em>}\\in\\{1,\\ldots,M\\}</span>, <span class="math">p^{\\prime}(j^{</em>})\\neq G(f_{1}^{\\prime}(j^{<em>}),\\ldots,f_{L}^{\\prime}(j^{</em>}))</span>. Thus, when we view <span class="math">p^{\\prime},f_{1}^{\\prime},\\ldots,f_{L}^{\\prime}\\in\\mathbb{F}[X]</span> as univariate polynomials, we have that <span class="math">p^{\\prime}\\neq G(f_{1}^{\\prime},\\ldots,f_{L}^{\\prime})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, if <span class="math">p^{\\prime}\\neq G(f_{1}^{\\prime},\\ldots,f_{L}^{\\prime})</span> then <span class="math">p^{\\prime}-G(f_{1}^{\\prime},\\ldots,f_{L}^{\\prime})\\in\\mathbb{F}[X]</span> is a non-zero univariate polynomial of degree at most <span class="math">M\\deg G</span>. Such a polynomial can have at most <span class="math">M\\deg G</span> roots over <span class="math">\\mathbb{F}</span>. Therefore the probability, over the verifier’s random choice of <span class="math">r\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span>, that <span class="math">p^{\\prime}(r)-G(f_{1}^{\\prime}(r),\\ldots,f_{L}^{\\prime}(r))=0</span> is at most $M\\deg G/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-M)<span class="math">. We conclude that the verifier accepts a false proof with probability at most </span>M\\deg G/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-M)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Strong honest-verifier zero knowledge. To show that the construction satisfies strong HVZK, we must produce a simulator <span class="math">S_{\\mathsf{LPCP}}()</span> that perfectly simulates the joint distribution of the honest verifier’s queries and the honest prover’s responses. The honest verifier’s queries are determined by the random choice of the point <span class="math">r\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span> at which the verifier evaluates the polynomials <span class="math">p,f_{1},\\ldots,f_{L}</span>. The simulator must then simulate the distribution of values <span class="math">\\langle r,\\ p(r),f_{1}(r),\\ldots,f_{L}(r),\\ p(M)\\rangle\\in\\mathbb{F}^{L+3}</span>.</p>

    <p class="text-gray-300">The simulator <span class="math">S_{\\mathsf{LPCP}}</span> takes no input and executes the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose <span class="math">r\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span>.</li>

      <li>Choose <span class="math">a_{1},\\ldots,a_{L}\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbb{F}</span>.</li>

      <li>Compute <span class="math">a\\leftarrow G(a_{1},\\ldots,a_{L})\\in\\mathbb{F}</span>.</li>

      <li>Output the tuple <span class="math">\\langle r,\\ a,a_{1},\\ldots,a_{L},\\ 0\\rangle\\in\\mathbb{F}^{L+3}</span>.</li>

    </ul>

    <p class="text-gray-300">The simulated value <span class="math">r</span> is distributed exactly as in the real interaction. Since <span class="math">p(M)=0</span> in the real interaction, the simulation of this value is also perfect. If the simulation <span class="math">(a_{1},\\ldots,a_{L})</span> of the values <span class="math">(f_{1}(r),\\ldots,f_{L}(r))</span> is perfect, then the simulation <span class="math">a</span> of the value <span class="math">p(r)</span> is also perfect, since <span class="math">a</span> is constructed exactly as in the real interaction.</p>

    <p class="text-gray-300">We must then only argue that the simulation <span class="math">(a_{1},\\ldots,a_{L})</span> of the values <span class="math">(f_{1}(r),\\ldots,f_{L}(r))</span> is correct. For every <span class="math">i\\in\\{1,\\ldots,L\\}</span>, we can write the value <span class="math">f_{i}(r)</span> in terms of the Lagrange interpolating polynomials <span class="math">\\lambda_{0}(\\cdot),\\lambda_{1}(\\cdot),\\ldots,\\lambda_{M}(\\cdot)</span>, evaluated at the point <span class="math">r</span>:</p>

    <p class="text-gray-300"><span class="math">f_{i}(r)=\\lambda_{0}(r)\\cdot f_{i}(0)+\\sum_{j=1}^{M}\\lambda_{j}(r)\\cdot f_{i}(j).</span></p>

    <p class="text-gray-300">When <span class="math">r\\not\\in\\{1,\\ldots,M\\}</span>, the value of the zero-th interpolating polynomial is non-zero: <span class="math">\\lambda_{0}(r)\\neq 0</span>. Since, by construction, the value <span class="math">f_{i}(0)</span> is distributed uniformly at random over <span class="math">\\mathbb{F}</span> and is independent of all other values, when <span class="math">r\\not\\in\\{1,\\ldots,M\\}</span>, <span class="math">f_{i}(r)</span> will be distributed uniformly over <span class="math">\\mathbb{F}</span> and independently of all other values.</p>

    <p class="text-gray-300">Since the honest verifier chooses <span class="math">r\\stackrel{{\\scriptstyle n}}{{\\leftarrow}}\\mathbb{F}\\setminus\\{1,\\ldots,M\\}</span>, we conclude that the joint distribution of <span class="math">(r,f_{1}(r),\\ldots,f_{L}(r))</span> will be uniform over <span class="math">(\\mathbb{F}\\setminus\\{1,\\ldots,M\\})\\times\\mathbb{F}^{L}</span> in the real interaction. The entire simulation is then perfect.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Circuit. An example circuit  <span class="math">C(x_{1},x_{2},x_{3},w)</span>  using an arbitrary three-input  <span class="math">G</span> -gate. The circuit takes as input the vector  <span class="math">(x_{1},x_{2},x_{3})\\in \\mathbb{F}^{3}</span> , and a witness  <span class="math">w\\in \\mathbb{F}</span> . The circuit  <span class="math">C</span>  outputs  <span class="math">v_{2}</span> , the value on the output wire of the topologically last  <span class="math">G</span> -gate. Figure 4: An example of the fully linear PCP proof of Theorem 4.3.</p>

    <p class="text-gray-300">Linear PCP proof. Using Theorem 4.3, we construct a fully linear PCP proof  <span class="math">\\pi</span>  that the input  <span class="math">(x_{1}, x_{2}, x_{3}) \\in \\mathbb{F}^{3}</span>  is in the language recognized by  <span class="math">C</span> . That is, the prover asserts that there exists a witness  <span class="math">w \\in \\mathbb{F}</span>  such that  <span class="math">C(x_{1}, x_{2}, x_{3}, w) = 0 \\in \\mathbb{F}</span> .</p>

    <p class="text-gray-300">The prover first constructs three polynomials  <span class="math">f_{1}, f_{2}, f_{3}</span> . The value  <span class="math">f_{i}(j)</span>  encodes the value on the  <span class="math">i</span> -th input to the  <span class="math">j</span> -th  <span class="math">G</span> -gate, in topological order from inputs to outputs. The constant terms are random elements  <span class="math">z_{1}, z_{2}, z_{3} \\stackrel{\\mathrm{gt}}{\\leftarrow} \\mathbb{F}</span> . That is:</p>

    <p class="text-gray-300"><span class="math">f_{1}(0) = z_{1}</span></p>

    <p class="text-gray-300"><span class="math">f_{2}(0) = z_{2}</span></p>

    <p class="text-gray-300"><span class="math">f_{3}(0) = z_{3}</span></p>

    <p class="text-gray-300"><span class="math">f_{1}(1) = x_{1}</span></p>

    <p class="text-gray-300"><span class="math">f_{2}(1) = x_{2}</span></p>

    <p class="text-gray-300"><span class="math">f_{3}(1) = x_{3}</span></p>

    <p class="text-gray-300"><span class="math">f_{1}(2) = v_{1} = G(x_{1},x_{2},x_{3})</span></p>

    <p class="text-gray-300"><span class="math">f_{2}(2) = x_{3}</span></p>

    <p class="text-gray-300"><span class="math">f_{3}(2) = x_{3} + w + 7</span></p>

    <p class="text-gray-300">Next, the prover constructs the polynomial  <span class="math">p</span> , which satisfies  <span class="math">p = G(f_1, f_2, f_3)</span> , and which has degree at most  <span class="math">d = 2\\deg G</span> . Notice that for  <span class="math">j \\in \\{1, 2\\}</span> ,  <span class="math">p(j)</span>  is the value on the output wire of the  <span class="math">j</span> -th  <span class="math">G</span> -gate. Letting  <span class="math">d = 3\\deg G</span> , we can write the values of  <span class="math">p</span>  as:</p>

    <p class="text-gray-300"><span class="math">p(0) = G(f_1(0),f_2(0),f_3(0)) = G(z_1,z_2,z_3)</span></p>

    <p class="text-gray-300"><span class="math">p(1) = G(f_1(1),f_2(1),f_3(1)) = v_1 = G(x_1,x_2,x_3)</span></p>

    <p class="text-gray-300"><span class="math">p(2) = G(f_1(2),f_2(2),f_3(2)) = v_2 = G(v_1,x_3,x_3 + w + 7)</span></p>

    <p class="text-gray-300"><span class="math">p(3) = G(f_1(3),f_2(3),f_3(3))</span></p>

    <p class="text-gray-300">：</p>

    <p class="text-gray-300"><span class="math">p(d)\\neq G(f_1(d),f_2(d),f_3(d))</span></p>

    <p class="text-gray-300">The linear PCP proof  <span class="math">\\pi</span>  consists of the elements:  <span class="math">(w, z_1, z_2, z_3, \\bar{p}) \\in \\mathbb{F}^{L + d + 2}</span> , where  <span class="math">\\bar{p} \\in \\mathbb{F}^{d + 1}</span>  is the vector of coefficients of the polynomial  <span class="math">p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we define the  <span class="math">G</span> -gate to be a multiplication gate, so that  <span class="math">\\deg G = 2</span> , then the construction of Theorem 4.3 matches the complexity of the GGPR-based linear PCP [67, 113] and provides what is essentially an alternative formulation of that proof system. In contrast, if  $\\deg G \\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , then this construction can yield significantly shorter proofs than the GGPR-based linear PCP, at the cost of increasing the algebraic degree of the verifier from 2 to  </span>\\deg G$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 4.5. We can generalize Theorem 4.3 to handle circuits with many distinct repeated subcircuits  <span class="math">G_{1}, \\ldots, G_{q}</span>  with  <span class="math">M_{i}</span>  instances of each gate  <span class="math">G_{i}: \\mathbb{F}^{L_{i}} \\to \\mathbb{F}</span> , for  <span class="math">i \\in \\{1, \\ldots, q\\}</span> . The resulting fully linear PCP with strong HVZK has proof length at most  <span class="math">h + (\\sum_{i=1}^{q} L_{i}) + (\\sum_{i=1}^{q} M_{i} \\deg G_{i}) + q</span>  elements of  <span class="math">\\mathbb{F}</span> , query complexity  <span class="math">1 + \\sum_{i=1}^{q} (L_{i} + 1)</span> , a verifier of algebraic degree  <span class="math">\\max_{i} \\deg G_{i}</span> , and soundness error  $\\sum_{i=1}^{q} \\left( M_{i} \\deg G_{i} / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- M_{i}) \\right)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 4.6. To get good soundness when applying the proof system of Theorem 4.3, the field  <span class="math">\\mathbb{F}</span>  must be such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg M \\deg G<span class="math"> . In many applications, the input  </span>x \\in \\mathbb{F}^n<span class="math">  is a vector in a small field, such as the binary field  </span>\\mathbb{F}_2<span class="math"> . In this case, we apply Theorem 4.3 by lifting  </span>x<span class="math">  into an extension field  </span>\\widetilde{\\mathbb{F}}<span class="math">  of  </span>\\mathbb{F}$ , and carrying out the linear PCP operations in the extension.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The randomization technique we use to achieve honest-verifier zero-knowledge in Theorem 4.3</p>

    <p class="text-gray-300">is inspired by the one that appears in the work of Bitansky et al. <em>[27]</em> for achieving HVZK in the Hadamard linear PCP construction.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 Application: Short Proofs for Degree-Two Relations</h3>

    <p class="text-gray-300">As an application of Theorem 4.3 we demonstrate a special-purpose fully linear PCP for relations recognized by arithmetic circuits of degree two. When applied to an arithmetic circuit <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}</span>, we obtain a proof that consists of only <span class="math">O(h+\\sqrt{n})</span> field elements and whose query complexity is only <span class="math">O(\\sqrt{n+h})</span>. For general-purpose linear PCPs, such as the Hadamard or GGPR-based linear PCPs, the proof length plus query complexity is much larger: <span class="math">\\Omega(n+h)</span>.</p>

    <p class="text-gray-300">A special case of this proof yields a linear PCP for the language of vectors whose inner product is equal to a certain value. To give one application of such a proof system: Given encryptions of two sets, represented by their characteristic vectors, this proof system would allow a prover to succinctly show that the sets are disjoint.</p>

    <p class="text-gray-300">This construction also reveals the close connection between fully linear PCPs and communication complexity. Without zero knowledge, this proof protocol boils down to the Merlin-Arthur communication complexity protocol of Aaronson and Wigderson <em>[1]</em>. Furthermore, as we show in Appendix B, we can use lower bounds on the communication complexity of inner-product to show that this fully linear PCP construction has essentially optimal parameters.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Corollary 4.7 (FLPCP for degree-two circuits).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, let <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}</span> be an arithmetic circuit of degree two, and let <span class="math">\\mathcal{R}_{C}=\\{(x,w)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\mid C(x,w)=0\\}</span>. There is a fully linear PCP with strong HVZK for <span class="math">\\mathcal{R}_{C}</span> that has proof length <span class="math">h+O(\\sqrt{n+h})</span> elements of <span class="math">\\mathbb{F}</span>, query complexity <span class="math">O(\\sqrt{n+h})</span>, a verifier of algebraic degree <span class="math">2</span>, and soundness error $\\frac{O(\\sqrt{n+h})}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{n+h}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The idea of Corollary 4.7 is that any degree-two circuit <span class="math">C:\\mathbb{F}^{n}\\to\\mathbb{F}</span> can be expressed as a circuit that computes an inner-product of dimension-<span class="math">n</span> vectors, along with some number of affine gates. This property is special to degree-two circuits—the idea does not apparently generalize to circuits of higher constant degree.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof of Corollary 4.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without loss of generality we can assume that <span class="math">C</span> implements a quadratic form $C(x,w)=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)^{T}\\cdot A\\cdot(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> for some matrix </span>A\\in\\mathbb{F}^{(n+h)\\times(n+h)}<span class="math">. Indeed, a proof system for quadratic forms yields a proof system for any circuit of degree </span>2<span class="math">. We can re-write </span>C(x,w)<span class="math"> as the inner-product of the vectors </span>y=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> and </span>z=A\\cdot(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> in </span>\\mathbb{F}^{n+h}<span class="math">. Hence, it suffices to design a fully linear PCP for the inner-product relation </span>\\mathcal{R}_{C}^{\\prime}=\\left\\{(x,w)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\ \\mid\\ \\left\\langle(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)\\ ,\\ A\\cdot(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)\\right\\rangle=0\\right\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">L^{2}</span> be the closest perfect square greater than or equal to <span class="math">n+h</span>, and pad the vectors $y=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> and </span>z=A(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)<span class="math"> with zeros so that both are in </span>\\mathbb{F}^{(L^{2})}<span class="math">. Next, arrange the vector </span>y<span class="math"> into a matrix </span>Y\\in\\mathbb{F}^{L\\times L}<span class="math">, and arrange </span>z<span class="math"> into a matrix </span>Z\\in\\mathbb{F}^{L\\times L}<span class="math"> in the same way. Then </span>C(x,w)=\\langle y,z\\rangle=\\text{trace}(Y\\cdot Z^{T})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Because the trace is a linear function, we can compute <span class="math">C(x,w)</span> using a circuit <span class="math">C^{\\prime}</span> consisting of only addition gates and a total of <span class="math">L</span> gates <span class="math">G:\\mathbb{F}^{L}\\times\\mathbb{F}^{L}\\to\\mathbb{F}</span> defined as <span class="math">G(u,v)=\\langle u,v\\rangle</span> for <span class="math">u,v\\in\\mathbb{F}^{L}</span>. Clearly <span class="math">\\deg G=2</span> and <span class="math">L=O(\\sqrt{n+h})</span>. Applying Theorem 4.3 to this <span class="math">G</span>-gate circuit gives a fully linear PCP for <span class="math">\\mathcal{R}_{C^{\\prime}}</span> with strong HVZK with the parameters stated in the corollary, as required. The proof needs at most <span class="math">2L</span> additional linear queries to verify that the padding in <span class="math">y</span> and <span class="math">z</span> is all zero, but this does not change the parameters in the corollary. ∎</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Remark 4.8.</h6>

    <p class="text-gray-300">A simple extension of Corollary 4.7 yields a two-round (in fact, 1.5-round) fully linear IOP for relations recognized by general degree-two circuits <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}^{k}</span>, for <span class="math">k\\geq 1</span>. To sketch the idea behind this extension, write the circuit <span class="math">C</span> as <span class="math">C(x)=(C_{1}(x),C_{2}(x),\\ldots,C_{k}(x))\\in\\mathbb{F}^{k}</span>, where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">each <span class="math">C_i</span> is a degree-two circuit. In the first round of the protocol, the verifier sends a random value <span class="math">r \\in \\mathbb{F}</span>. Then the prover and verifier define the degree-two circuit <span class="math">C_r(x) = \\sum_{i=1}^k r^i \\cdot C_i(x) \\in \\mathbb{F}</span>. The prover then uses the fully linear PCP of Corollary 4.7 to convince the verifier that <span class="math">C_r</span> accepts the input <span class="math">x \\in \\mathbb{F}^n</span>. The efficiency parameters match those of the corollary, except that the soundness error increases by an additive term $k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to account for the failure event that some </span>C_i(x)<span class="math"> outputs a non-zero value and yet the sum </span>C_r(x)$ is zero. See Theorem 5.8 for a more general version of this protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-31" class="text-2xl font-bold">4.4 Application: Short Proofs for Parallel-Sum Circuits</h2>

    <p class="text-gray-300">As a second application of Theorem 4.3, we give a special-purpose fully linear PCP for languages recognized by circuits that take as input a vector <span class="math">x \\in \\mathbb{F}^n</span> and:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>apply an affine transformation to the input,</li>

      <li>apply the same sub-circuit <span class="math">C: \\mathbb{F}^L \\to \\mathbb{F}</span> in parallel to each block of <span class="math">L</span> values, and</li>

      <li>sum the outputs of the <span class="math">C</span> circuits.</li>

    </ul>

    <p class="text-gray-300">More formally, let <span class="math">C: \\mathbb{F}^L \\to \\mathbb{F}</span> be an arithmetic circuit. Let <span class="math">A: \\mathbb{F}^n \\to \\mathbb{F}</span> and <span class="math">A_1, \\ldots, A_M: \\mathbb{F}^n \\to \\mathbb{F}^L</span> be affine functions. This linear PCP construction applies to the language of values <span class="math">x \\in \\mathbb{F}^n</span> such that <span class="math">\\sum_{i=1}^{M} C(A_i(x)) = A(x)</span>.</p>

    <p class="text-gray-300"><strong>Corollary 4.9 (FLPCP for parallel-sum circuits).</strong> Let <span class="math">C: \\mathbb{F}^L \\to \\mathbb{F}</span> be an arithmetic circuit over <span class="math">\\mathbb{F}</span> that has arithmetic degree <span class="math">\\deg C</span>. Let <span class="math">A: \\mathbb{F}^n \\to \\mathbb{F}</span> and <span class="math">A_1, \\ldots, A_M \\in \\mathbb{F}^n \\to \\mathbb{F}^L</span> be affine functions. Then, there exists a strong HVZK fully linear PCP for the language <span class="math">\\mathcal{L}_{C,A,A_1,\\ldots,A_M} = \\{x \\in \\mathbb{F}^n \\mid \\sum_{i=1}^{M} C(A_i(x)) = A(x)\\}</span> that has:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof length <span class="math">O(\\sqrt{M} \\cdot (L + \\deg C))</span> elements of <span class="math">\\mathbb{F}</span>,</li>

      <li>query complexity <span class="math">O(\\sqrt{M} \\cdot L)</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $\\frac{\\sqrt{M} \\cdot \\deg C}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\sqrt{M}}$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof of Corollary 4.9.</strong> We define an appropriate <span class="math">G</span>-gate and then invoke Theorem 4.3. Assume that <span class="math">M</span> is a perfect square, since otherwise we can pad <span class="math">M</span> up to the nearest square. The gadget <span class="math">G: \\mathbb{F}^{\\sqrt{M}L} \\to \\mathbb{F}</span> applies the circuit <span class="math">C</span> to <span class="math">\\sqrt{M}</span> blocks of <span class="math">L</span> inputs. So, on input <span class="math">(\\bar{x}_1, \\ldots, \\bar{x}_{\\sqrt{M}}) \\in \\mathbb{F}^{\\sqrt{M}L}</span>, where <span class="math">\\bar{x}_j \\in \\mathbb{F}^L</span> for all <span class="math">j \\in \\{1, \\ldots, \\sqrt{M}\\}</span>, the <span class="math">G</span>-gate outputs:</p>

    <div class="my-4 text-center"><span class="math-block">G(\\bar{x}_1, \\ldots, \\bar{x}_{\\sqrt{M}}) \\stackrel{\\text{def}}{=} \\sum_{j=1}^{\\sqrt{M}} C(\\bar{x}_j) \\quad \\in \\mathbb{F}. \\tag{1}</span></div>

    <p class="text-gray-300">Then the language <span class="math">\\mathcal{L}_{C,A,A_1,\\ldots,A_M}</span> is recognized by a circuit containing <span class="math">M&#x27; = \\sqrt{M}</span> instances of the <span class="math">G</span>-gate, along with some number of affine gates. Applying Theorem 4.3 using this <span class="math">G</span>-gate yields a fully linear PCP with the desired efficiency properties.</p>

    <p class="text-gray-300"><strong>Example 4.10.</strong> Corollary 4.9 gives a short fully linear PCP for proving that a vector <span class="math">x \\in \\mathbb{F}^n</span> has <span class="math">L_p</span>-norm <span class="math">y</span>, for any integer <span class="math">p \\geq 2</span>. For this application, <span class="math">C(x_i) \\stackrel{\\text{def}}{=} x_i^p \\in \\mathbb{F}</span> and <span class="math">\\deg C = p</span>. The linear PCP implied by the corollary has length <span class="math">O(p \\cdot \\sqrt{n})</span>, whereas the standard linear PCPs from Section 4.1 would have proofs of length <span class="math">\\Omega(n \\log p)</span>. Thus, the construction of the corollary has shorter proof size for all <span class="math">p = o(\\sqrt{n})</span>.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">A sum-check-style protocol, along the lines of Cormode, Thaler, and Yi’s protocol <em>[43, Section 3.2]</em> for checking the <span class="math">k</span>-th frequency moment in a data stream, achieves the same asymptotic complexity as the protocol of Example 4.10. However, that sum-check protocol does not natively provide zero knowledge. We thank Justin Thaler for pointing out this alternative construction.</p>

    <h2 id="sec-32" class="text-2xl font-bold">5 Constructions: Fully Linear Interactive Oracle Proofs</h2>

    <p class="text-gray-300">In this section, we demonstrate how to use linear PCPs and other existing cryptographic protocols to construct linear interactive oracle proofs (linear IOPs). While linear IOPs in general require more rounds of prover-to-verifier interaction, these extra rounds of interaction can buy efficiency improvements in total proof length and verifier time.</p>

    <p class="text-gray-300">For example, a corollary of our general construction gives an <span class="math">O(\\log n)</span> round strong HVZK fully linear IOP for proving that a vector <span class="math">x\\in\\mathbb{F}^{n}</span> consists entirely of <span class="math">0/1</span> entries, where the proof size is only <span class="math">O(\\log n)</span> field elements. See Example 5.6. In comparison, linear PCPs yield proofs of size <span class="math">\\Omega(n)</span>.</p>

    <p class="text-gray-300">Several protocols from the literature, including notably the “Muggles” protocol of Goldwasser, Kalai, and Rothblum <em>[74, 75]</em> are implicitly linear IOPs. We describe the connection between our notion and these protocols in Appendix A.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">5.1 A Recursive Linear IOP for Parallel-Sum Circuits</h3>

    <p class="text-gray-300">Corollary 4.9 gives a linear PCP for “parallel-sum” circuits whose length grows as the square root of the degree of parallelism. Here, we show that by increasing the number of rounds of interaction between the prover and verifier, we can decrease the proof size to <em>logarithmic</em> in the degree of parallelism. The key observation is that in Corollary 4.9, the linear PCP verifier is itself a parallel-sum circuit. So rather than having the verifier evaluate this circuit on its own, the verifier can outsource the work of evaluating the verification circuit to the prover. The prover then uses a secondary linear PCP to convince the verifier that it executed this step correctly.</p>

    <p class="text-gray-300">To get the optimal bounds we rebalance the parameters used in the proof of Corollary 4.9. Instead of a <span class="math">G</span>-gate containing <span class="math">\\sqrt{M}</span> copies of <span class="math">C</span>, as in (1), we use a <span class="math">G</span>-gate containing <span class="math">M/2</span> copies of <span class="math">C</span>, and then recursively verify one input/output pair for that <span class="math">G</span>-gate.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">C:\\mathbb{F}^{L}\\to\\mathbb{F}</span> be an arithmetic circuit over <span class="math">\\mathbb{F}</span> that has arithmetic degree <span class="math">\\deg C</span>. Let <span class="math">A:\\mathbb{F}^{n}\\to\\mathbb{F}</span> and <span class="math">A_{1},\\ldots,A_{M}:\\mathbb{F}^{n}\\to\\mathbb{F}^{L}</span> be affine functions. Then, there exists an <span class="math">O(\\log M)</span>-round strong HVZK fully linear IOP for the language <span class="math">\\mathcal{L}_{C,A,A_{1},\\ldots,A_{M}}=\\{x\\in\\mathbb{F}^{n}\\mid\\ \\sum_{i=1}^{M}C(A_{i}(x))=A(x)\\}</span> that has:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof length <span class="math">L+O(\\deg C\\cdot\\log M)</span> elements of <span class="math">\\mathbb{F}</span>,</li>

      <li>query complexity <span class="math">L+O(\\log M)</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O\\left(\\frac{\\deg C\\cdot\\log M}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5 gives a graphical depiction of the protocol flow.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof of Theorem 5.1.</h6>

    <p class="text-gray-300">We prove the theorem by induction on <span class="math">M</span>. For simplicity, we assume that <span class="math">M</span> is a power of two.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Base case (<span class="math">M=1</span>).</em> When <span class="math">M=1</span>, we can invoke Theorem 4.3 using the circuit <span class="math">C</span> as the <span class="math">G</span>-gate of the theorem. Theorem 4.3 implies that there exists a one-round fully linear IOP with strong HVZK that has proof length <span class="math">L+\\deg C+1</span>, query complexity <span class="math">L+2</span>, soundness error $\\deg C/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<span class="math">, and a verification circuit containing </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ multiplication gates. This proves the base case.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1a. Generate a linear PCP proof  <span class="math">\\pi_1</span>  that  <span class="math">x\\in \\mathcal{L}_1</span></p>

    <p class="text-gray-300"><span class="math">\\begin{array}{rl}\\xrightarrow{\\pi_1} &amp;amp; 1\\mathrm{b.}\\mathrm{Sample~a~random~value~}r_1\\stackrel {\\mathrm{a}}{\\leftarrow}\\mathrm{F}\\mathrm{~and}\\\\ &amp;amp; \\mathrm{send~it~to~the~prover.~Make~one~linear}\\\\ &amp;amp; \\mathrm{query~to~the~proof.}\\\\ \\end{array}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2a. Generate a proof  <span class="math">\\pi_2</span>  that  $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1)\\in \\mathcal{L}_2<span class="math">  where  </span>\\mathcal{L}_2<span class="math">  is the language of vectors  </span>(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi)<span class="math">  such that  </span>V_{\\mathcal{L}}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1;r_1) = 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\begin{array}{rl}\\stackrel {\\pi_2}{\\longleftarrow} &amp;amp; 2\\mathrm{b.}\\mathrm{Sample~a~random~value~}r_2\\stackrel {\\mathrm{a}}{\\leftarrow}\\mathrm{F}\\mathrm{~and}\\\\ &amp;amp; \\mathrm{send~it~to~the~prover.~Make~one~linear}\\\\ &amp;amp; \\mathrm{query~to~the~proof.}\\\\ \\end{array}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3a. Generate a proof  <span class="math">\\pi_3</span>  that  $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_2)\\in \\mathcal{L}_3<span class="math">  , where  </span>\\mathcal{L}_3<span class="math">  is the language of vectors  </span>(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_2)<span class="math">  such that  </span>V_{\\mathcal{L}_2}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_2;r_1,r_2) = 1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\dots</span>  continue for  <span class="math">R = O(\\log M)</span>  rounds ...</p>

    <p class="text-gray-300"><span class="math">R a</span>  . Generate linear PCP proof  <span class="math">\\pi_R</span>  that  <span class="math">x\\in \\mathcal{L}_R</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\begin{array}{rl}\\stackrel {\\pi_R}{\\longrightarrow}&amp;R\\mathrm{b.}\\mathrm{Check~}\\pi_R\\mathrm{~by~explicitly~running~the}\\\\&amp;{\\mathrm{verifier}~V_{\\mathcal{L}_R}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_R;r_1,\\ldots,r_R).}\\\\&amp;{\\mathrm{Verifier}~V_{\\mathcal{L}_R}\\mathrm{makes}~L+2\\mathrm{~queries}.}\\end{array}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 5: A depiction of the protocol flow for the linear IOP of Theorem 5.1. The initial language  <span class="math">\\mathcal{L}_1</span>  is the language of vectors  <span class="math">x\\in \\mathbb{F}^n</span>  such that  <span class="math">\\sum_{i = 1}^{M}C(A_i(x)) = A(x)</span> , where  <span class="math">C</span>  and  <span class="math">A,A_1,\\ldots ,A_M</span>  are as in Theorem 5.1. The expression  $V_{\\mathcal{L}}(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi ;r)<span class="math">  denotes the output of the linear PCP verifier of Theorem 4.3 for some language  </span>\\mathcal{L}<span class="math">  run on input  </span>(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi)<span class="math">  using randomness  </span>r$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For all  <span class="math">i \\in \\{1, \\dots, R - 1\\}</span> : (1) the proof  <span class="math">\\pi_i</span>  has length  <span class="math">2\\deg C + 1</span> , and (2) the verifier  <span class="math">V_{\\mathcal{L}_i}</span>  is a circuit containing  $(M / 2^i)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  multiplication gates. In the last step, the proof  </span>\\pi_R<span class="math">  has length  </span>L + \\deg C + 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Induction step. We define a gadget <span class="math">G</span>, as in (1). The difference is that we now use a gadget <span class="math">G</span>, whose width is <span class="math">M/2</span> rather than <span class="math">\\sqrt{M}</span>. Specifically, using the notation in (1), we define <span class="math">G</span> as:</p>

    <p class="text-gray-300"><span class="math">G(\\bar{x}_{1},\\ldots,\\bar{x}_{M/2})\\ \\approxeq\\ \\sum_{i=1}^{M/2}C(\\bar{x}_{i})\\ \\ \\ \\ \\in\\mathbb{F}.</span></p>

    <p class="text-gray-300">The language <span class="math">\\mathcal{L}_{C,A,A_{1},\\ldots,A_{M}}</span> is recognized by a circuit composed of two such <span class="math">G</span>-gates, along with some number of affine gates.</p>

    <p class="text-gray-300">The <span class="math">O(\\log M)</span>-round protocol then proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover sends a fully linear PCP proof <span class="math">\\pi</span> asserting that <span class="math">x\\in\\mathbb{F}^{n}</span> is in <span class="math">\\mathcal{L}_{C,A,A_{1},\\ldots,A_{M}}</span>. That is, the proof asserts that <span class="math">x</span> satisfies the relation <span class="math">\\sum_{i=1}^{M}C(A_{i}(x))=A(x)</span>. To generate the proof, the prover uses the construction of Theorem 4.3 without strong HVZK. When invoking Theorem 4.3, the prover uses a <span class="math">G</span>-gate as in (1), except that it has width <span class="math">M/2</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof has length <span class="math">2\\deg G+1=2\\deg C+1</span>, query complexity <span class="math">(M/2)L+2</span>, soundness error $2\\deg C/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2)<span class="math">, and requires the verifier to evaluate a circuit of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(M/2)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ on the query answers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The FLPCP verifier of Theorem 4.3 makes <span class="math">ML/2+2</span> linear queries and receives answers <span class="math">a,a_{1},\\ldots,a_{ML/2},b\\in\\mathbb{F}</span>. The verifier must then check that: (1) <span class="math">a=G(a_{1},\\ldots,a_{ML/2})</span> and (2) <span class="math">b=0</span>.</li>

    </ul>

    <p class="text-gray-300">The FLIOP verifier we construct does not operate exactly as the FLPCP verifier does. Instead, the FLIOP verifier we construct uses a single linear query to check that the second relation holds (i.e., that <span class="math">b=0</span>).</p>

    <p class="text-gray-300">The FLIOP verifier now outsources the work of performing the first check to the prover. More precisely:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The FLIOP verifier sends to the prover the randomness <span class="math">r</span> it used to generate its linear queries. In the construction of Theorem 4.3, this randomness consists of a single field element.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. This randomness defines an affine map <span class="math">Q_{r}:\\mathbb{F}^{n+m}\\to\\mathbb{F}^{ML/2+1}</span> from the proof-input pair $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{m}<span class="math"> to the query answers </span>(a,\\bar{a}_{1},\\ldots,\\bar{a}_{M/2})\\in\\mathbb{F}\\times(\\mathbb{F}^{L})^{M/2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the induction hypothesis, the prover and verifier then can recursively invoke the FLIOP protocol to check this relation.</p>

    <p class="text-gray-300">Security arguments. Completeness follows by construction. Soundness follows from an inductive argument. All that remains is to show that the protocol satisfies strong HVZK. To show this, note that at every level of the induction except the base case, the honest verifier makes a single query whose response should be zero. These answers are trivial to simulate. In the base case, we can invoke the strong HVZK simulator of the linear PCP of Theorem 4.3. ∎</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.2 Short Linear IOPs for SIMD Circuits</h3>

    <p class="text-gray-300">Many interesting languages are recognized by arithmetic circuits that (1) apply the same small subcircuit to each block of inputs and (2) accept iff all of the subcircuits accept. For example,</p>

    <p class="text-gray-300">the language <span class="math">\\mathcal{L}=\\{0,1\\}^{n}\\subseteq\\mathbb{F}^{n}</span> of zero/one vectors in <span class="math">\\mathbb{F}^{n}</span> is recognized by a circuit that on input <span class="math">(x_{1},\\ldots,x_{n})\\in\\mathbb{F}^{n}</span> computes <span class="math">\\forall i\\ b_{i}\\leftarrow x_{i}(x_{i}-1)</span> and accepts iff all <span class="math">b_{i}</span> are zero. We call this type of circuit a “same-instruction multiple-data” (SIMD) circuit.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Implementing the logical-AND of the <span class="math">n</span> values <span class="math">(b_{1},\\ldots,b_{n})</span> in an arithmetic circuit is relatively expensive. The standard technique for this requires applying the mapping $b_{i}\\mapsto b_{i}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> which, by Fermat’s Little Theorem, takes </span>0\\mapsto 0<span class="math"> and any non-zero value </span>x\\mapsto 1<span class="math">. Then we can take the sum </span>\\sum_{i}b_{i}<span class="math"> (as long as </span>n<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) to check whether all </span>b_{i}<span class="math"> are zero. Directly applying the linear PCPs of Section 4 to this circuit will give a proof of size </span>\\Omega(n\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. By adding interaction, we can shrink the proof length to </span>O(\\log n)<span class="math"> for this language at the cost of increasing the number of communication rounds to </span>O(\\log n)<span class="math">. More generally, for a SIMD circuit composed of </span>M<span class="math"> copies of a circuit </span>C:\\mathbb{F}^{L}\\to\\mathbb{F}<span class="math"> of degree </span>\\deg C<span class="math">, we get a proof of size </span>L+O(\\deg C\\cdot\\log M)<span class="math"> that has query complexity </span>L+O(\\log M)<span class="math"> and a verifier containing </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ multiplication gates.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Other trade-offs between proof size and verifier complexity are possible, though when compiling fully linear PCPs into proofs on secret-shared data (as in Section 6), we minimize the communication cost by minimizing the sum of the proof size and verifier complexity.</p>

    <p class="text-gray-300">We give a general transformation that turns any linear IOP for a language recognized by parallel-sum circuits (e.g., Corollary 4.9 and Theorem 5.1) into a linear IOP for SIMD circuits at the cost of increasing the number of rounds by one. The idea of the construction is to replace the logical-AND operation in the SIMD circuit by a linear combination chosen by the verifier. If any one of the SIMD subcircuits outputs a non-zero value, then with high probability the linear combination will be non-zero and the overall circuit will reject. To make the result more general, we consider circuits that apply an arbitrary linear transformation to the input wires before applying the SIMD gates to the inputs.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 5.2 (SIMD Circuit).</h6>

    <p class="text-gray-300">Let <span class="math">C:\\mathbb{F}^{L}\\to\\mathbb{F}</span> be an arithmetic circuit. Let <span class="math">A_{1},\\ldots,A_{M}:\\mathbb{F}^{n}\\to\\mathbb{F}^{L}</span> be affine functions. Then define the SIMD circuit <span class="math">C^{\\textbf{simd}}_{A_{1},\\ldots,A_{M}}:\\mathbb{F}^{n}\\to\\mathbb{F}</span> as: <span class="math">C^{\\textbf{simd}}_{A_{1},\\ldots,A_{M}}(x)\\stackrel{{\\scriptstyle\\textrm{\\tiny def}}}{{\\bigwedge}}_{i=1}^{M}\\left(C(A_{i}(x))=0\\right)</span> for <span class="math">x\\in\\mathbb{F}^{n}</span>. Here, the logical-AND operator returns <span class="math">0\\in\\mathbb{F}</span> if the statement is true, and it returns an arbitrary non-zero value otherwise.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 5.3 (FLIOPs for SIMD circuits).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a fully linear strong HVZK IOP for the language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{\\widetilde{C},\\tilde{A}_{1},\\ldots,\\tilde{A}_{M}}=\\big{\\{}x\\in\\mathbb{F}^{n+M}\\mid\\sum_{i=1}^{M}\\widetilde{C}(\\tilde{A}_{i}(x))=0\\big{\\}},</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{C}:\\mathbb{F}^{L+1}\\to\\mathbb{F}</span> is an arithmetic circuit and <span class="math">\\tilde{A}_{1},\\ldots,\\tilde{A}_{M}:\\mathbb{F}^{n+M}\\to\\mathbb{F}^{L+1}</span> are affine functions. Furthermore, say that <span class="math">\\Pi</span> has soundness error <span class="math">\\epsilon_{\\Pi}</span> and round complexity <span class="math">r_{\\Pi}</span>.</p>

    <p class="text-gray-300">Then, there exists a strong HVZK fully linear IOP for the language</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{C^{\\textbf{simd}}_{A_{1},\\ldots,A_{M}}}=\\big{\\{}x\\in\\mathbb{F}^{n}\\mid C^{\\textbf{simd}}_{A_{1},\\ldots,A_{M}}(x)=0\\big{\\}},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">C:\\mathbb{F}^{L}\\to\\mathbb{F}</span> is an arithmetic circuit, <span class="math">A_{1},\\ldots,A_{M}:\\mathbb{F}^{n}\\to\\mathbb{F}^{L}</span> are affine functions, and <span class="math">C^{\\textbf{simd}}_{A_{1},\\ldots,A_{M}}</span> is as in Definition 5.2. The resulting linear IOP has the same proof length, query complexity, and verification circuit size as <span class="math">\\Pi</span>, soundness error $\\epsilon=\\epsilon_{\\Pi}+M/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and round complexity </span>r_{\\Pi}+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof of Theorem 5.3.</h6>

    <p class="text-gray-300">We construct the linear IOP implied by the theorem and then prove that it satisfies the desired properties.</p>

    <p class="text-gray-300">The idea of the proof is that in the first round of interaction, the verifier chooses a random value <span class="math">r\\stackrel{{\\scriptstyle\\textrm{\\tiny n}}}{{\\leftarrow}}\\mathbb{F}</span>. Then, in the second round, the prover uses the fully linear IOP <span class="math">\\Pi</span> to convince the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier that the linear combination <span class="math">\\sum_{i=1}^{M} r^i \\cdot C(A_i(x))</span> of the outputs of the <span class="math">C</span> subcircuits is zero. If <span class="math">x \\notin \\mathcal{L}_{C_{A_1, \\ldots, A_M}^{\\mathrm{simd}}}</span>, then at least one of the <span class="math">C(\\cdot)</span> subcircuits outputs a non-zero value. In this case, the value of this linear combination is equal to the evaluation of a non-zero polynomial of degree at most <span class="math">M</span> at the point <span class="math">r</span>. Such a polynomial has at most $M /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> zeros, so the verifier will catch a cheating prover with good probability (over the random choice of </span>r$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol operates as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover's first message is the empty string <span class="math">\\perp</span>.</li>

      <li>The verifier's first message is a random field element <span class="math">r \\xleftarrow{\\mathrm{n}} \\mathbb{F}</span>. The prover and verifier both compute the vector <span class="math">(r, r^2, r^3, \\ldots, r^M) \\in \\mathbb{F}^M</span>.</li>

      <li>Define an arithmetic circuit <span class="math">C_{A_1,\\ldots,A_M}^{\\mathrm{rand}}: \\mathbb{F}^{n+M} \\to \\mathbb{F}</span> as:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">C_{A_1, \\ldots, A_M}^{\\mathrm{rand}}(x, r_1, r_2, \\ldots, r_M) \\stackrel{\\mathrm{def}}{=} \\sum_{i=1}^{M} r_i \\cdot C(A_i(x)) \\in \\mathbb{F} \\qquad \\text{where} \\qquad \\begin{array}{cc} x &amp;amp; \\in \\mathbb{F}^n \\\\ r_1, \\ldots, r_M &amp;amp; \\in \\mathbb{F} \\end{array} .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, define a circuit <span class="math">\\widetilde{C}: \\mathbb{F}^{L+1} \\to \\mathbb{F}</span> as <span class="math">\\widetilde{C}(x,r) \\stackrel{\\mathrm{def}}{=} r \\cdot C(x)</span>. Define affine functions <span class="math">\\tilde{A}_1, \\ldots, \\tilde{A}_M: \\mathbb{F}^{n+M} \\to \\mathbb{F}^{L+1}</span> such that for all <span class="math">i \\in \\{1, \\ldots, M\\}</span>, $\\tilde{A}_i(x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_1, \\ldots, r_M) \\stackrel{\\mathrm{def}}{=} (A_i(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_i)<span class="math">. Then we can rewrite </span>C_{A_1, \\ldots, A_M}^{\\mathrm{rand}}$ as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">C_{A_1, \\ldots, A_M}^{\\mathrm{rand}}(x, r_1, r_2, \\ldots, r_M) = \\sum_{i=1}^{M} \\widetilde{C}(\\tilde{A}_i(x, r_1, \\ldots, r_M)) \\in \\mathbb{F}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Now, the prover and verifier engage in the fully linear IOP protocol <span class="math">\\Pi</span>, implied by the hypothesis of the theorem, to check that $(x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_1, \\ldots, r_M) \\in \\mathbb{F}^{n+M}<span class="math"> is in the language accepted by the circuit </span>C_{A_1, \\ldots, A_M}^{\\mathrm{rand}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The claimed efficiency properties, along with completeness and strong HVZK, follow immediately from the construction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show soundness: If <span class="math">x \\in \\mathbb{F}^n</span> is not an accepting input, then the output of at least one SIMD subcircuit <span class="math">C</span> is non-zero. The output of the verification circuit <span class="math">C_{A_1,\\ldots,A_M}^{\\mathrm{rand}}</span> is the value <span class="math">\\sum_{i=1}^{M} r^i \\cdot C(A_i(x))</span>, which is then the evaluation of a non-zero polynomial of degree at most <span class="math">M</span> at a random point <span class="math">r \\xleftarrow{\\mathrm{n}} \\mathbb{F}</span>. The probability then, over the verifier's choice of <span class="math">r</span>, that the circuit <span class="math">C_{A_1,\\ldots,A_M}^{\\mathrm{rand}}</span> outputs zero is at most $M /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Conditioned on the output of </span>C_{A_1,\\ldots,A_M}^{\\mathrm{rand}}<span class="math"> being non-zero, the probability that the linear PCP verifier accepts is at most </span>\\epsilon_{\\Pi}<span class="math">. Therefore, the overall soundness error is </span>\\epsilon = M /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\epsilon_{\\Pi}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Applying Theorem 5.3 to our earlier constructions of fully linear proof systems for parallel-sum circuits immediately yields efficient proof systems for SIMD relations:</p>

    <p class="text-gray-300">Corollary 5.4. Let <span class="math">C_{A_1,\\ldots,A_M}^{\\mathrm{simd}}</span> be the SIMD circuit of Definition 5.2. There is a 1.5-round fully linear IOP with strong HVZK for the language <span class="math">\\mathcal{L}_{C_{A_1,\\ldots,A_M}^{\\mathrm{simd}}}</span> whose efficiency parameters match those of Corollary 4.9.</p>

    <p class="text-gray-300">Corollary 5.5. Let <span class="math">C_{A_1,\\ldots,A_M}^{\\mathrm{simd}}</span> be the SIMD circuit of Definition 5.2. There is an <span class="math">O(\\log M)</span>-round fully linear IOP with strong HVZK for the language <span class="math">\\mathcal{L}_{C_{A_1,\\ldots,A_M}^{\\mathrm{simd}}}</span> whose efficiency parameters match those of Theorem 5.1.</p>

    <p class="text-gray-300">We give an example for how to use Corollary 5.5 to construct a strong HVZK fully linear IOP for an interesting circuit.</p>

    <p class="text-gray-300">26</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Example 5.6.</h6>

    <p class="text-gray-300">Corollary 5.5 gives an <span class="math">O(\\log n)</span>-round protocol for proving that a vector <span class="math">x\\in\\mathbb{F}^{n}</span> consists entirely of zero/one values (i.e., that <span class="math">x\\in\\{0,1\\}^{n}\\subset\\mathbb{F}^{n}</span>), with proof complexity <span class="math">O(\\log n)</span> and a verification circuit of degree-two. In contrast, applying Theorem 4.3 or standard linear PCPs directly yields proofs of size <span class="math">\\Omega(n)</span>. Hence, using <span class="math">O(\\log n)</span>-rounds instead of a single round, we obtain an exponential reduction in the proof size.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 5.7.</h6>

    <p class="text-gray-300">Application of a sum-check-style protocol <em>[94]</em> can achieve the same complexity as the protocol of Example 5.6. (We thank Justin Thaler for this observation.) To sketch the protocol: the verifier first sends the prover a random vector <span class="math">r=(r_{1},\\ldots,r_{n})\\in\\mathbb{F}^{n}</span>. The prover then uses a sum-check protocol to convince the verifier that <span class="math">\\sum_{i=1}^{n}r_{i}x_{i}(x_{i}-1)=0\\in\\mathbb{F}</span>. The asymptotic complexity of this protocol matches our own, though this protocol does not provide strong HVZK, whereas ours does.</p>

    <p class="text-gray-300">A useful generalization of the above example is the case of “low-degree languages,” namely languages in which membership can be checked by a system of low-degree equations. The following theorem, whose proof appears in Appendix E, describes fully linear IOPs for such low-degree languages, over both finite fields and rings of the form <span class="math">\\mathbb{Z}_{2^{k}}</span> (see Appendix D and Appendix E for variants over more general rings).</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Theorem 5.8 (ZK-FLIOP for low-degree languages).</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be a ring, let <span class="math">C:R^{n}\\to R^{m}</span> be an arithmetic multi-output circuit of degree <span class="math">d</span> defined by <span class="math">C(x)=(C_{1}(x),\\ldots,C_{m}(x))</span> and let <span class="math">M</span> be the number of distinct monomials in the representation of <span class="math">C_{1},\\ldots,C_{m}</span> as polynomials. Let <span class="math">\\mathcal{L}_{C}=\\{x\\in R^{n}\\mid C(x)=0^{m}\\}</span> and let <span class="math">\\epsilon</span> be a required soundness error bound. Then, there is a fully linear IOP <span class="math">\\Pi</span> over <span class="math">R</span> with strong HVZK for the language <span class="math">\\mathcal{L}_{C}</span> that has the following efficiency features.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Degree <span class="math">d=2</span>, constant rounds: If <span class="math">d=2</span> then <span class="math">\\Pi</span> has 1.5 rounds, proof length <span class="math">O(\\eta\\sqrt{n})</span>, challenge length <span class="math">O(\\eta)</span>, and query complexity <span class="math">O(\\sqrt{n})</span>, where $\\eta=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}((m+\\sqrt{n})/\\epsilon)<span class="math"> if </span>R<span class="math"> is a finite field or </span>\\eta=\\log_{2}((m+(1+\\epsilon)\\sqrt{n})/\\epsilon)<span class="math"> if </span>R=\\mathbb{Z}_{2^{k}}<span class="math">. The computational complexity is </span>\\tilde{O}(M)<span class="math"> and the proof generation is a degree-2 function of the input </span>x<span class="math"> and secret randomness, determined by the circuit </span>C$ and public randomness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Trading communication for computation. Most of our motivating applications involve low-degree verification circuits that have constant output locality. For instance, this is the case for checking that <span class="math">x\\in\\{0,1\\}^{n}</span> or for languages corresponding to standard MPC protocols (e.g., checking Beaver triples). In this case, we can reduce computational cost while maintaining sublinear communication via the following simple tradeoff technique. Chop the <span class="math">m</span> outputs into blocks of size <span class="math">\\ell</span>, viewing each block as a low-degree circuit with <span class="math">O(\\ell)</span> inputs and <span class="math">\\ell</span> outputs, and apply a separate FLIOP to each block. This gives a smooth tradeoff between communication and computation, which may be useful for tuning concrete efficiency depending on the available bandwidth and computational power.</p>

    <h2 id="sec-45" class="text-2xl font-bold">6 Application: ZK Proofs on Distributed or Secret-Shared Data</h2>

    <p class="text-gray-300">In this section, we apply fully linear zero-knowledge PCPs and IOPs and the results of Sections 4 and 5 to the problem of proving in zero-knowledge statements on data held in a distributed fashion across parties. Such proofs are motivated by their applications to proving properties of sensitive data</p>

    <p class="text-gray-300">that is partitioned among different parties, proofs on secret-shared data, and protecting protocols for secure multiparty computation against malicious parties.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">6.1 Preliminaries</h3>

    <p class="text-gray-300">In the classical setting for interactive zero-knowledge proofs <em>[77]</em>, there is a single prover <span class="math">P</span> interacting with a single verifier <span class="math">V</span>. Both the prover and the verifier hold a common input <span class="math">x</span>, and the prover’s goal is to convince the verifier that <span class="math">x\\in\\mathcal{L}</span> for some language <span class="math">\\mathcal{L}</span>. In the typical case of an NP-language <span class="math">\\mathcal{L}</span>, the proof system applies to some <em>NP-relation</em> <span class="math">\\mathcal{R}(x,w)</span> where the witness <span class="math">w</span> is only known to <span class="math">P</span>. In this setting, the zero-knowledge requirement only refers to hiding the witness <span class="math">w</span>. A primary motivation for our notion of fully-linear proof systems is to capture the case where the statement <span class="math">x</span> is not known to any single verifier. In this case, the notion of zero-knowledge if meaningful even for polynomial-time languages <span class="math">\\mathcal{L}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our distributed model. We consider a distributed model in which a single prover <span class="math">P</span> interacts with <em>multiple</em> verifiers <span class="math">V_{1},V_{2},\\ldots,V_{k}</span> over a network that includes secure point-to-point channels. Each verifier <span class="math">V_{j}</span> holds a <em>piece</em> <span class="math">x^{(j)}\\in\\mathbb{F}^{n_{j}}</span> of an input $x=x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}\\in\\mathbb{F}^{n}<span class="math">, and the prover’s task is to convince the verifiers that the concatenated input </span>x<span class="math"> is in some language </span>\\mathcal{L}\\subseteq\\mathbb{F}^{n}<span class="math">. We assume by default that </span>x<span class="math"> is known in its entirety to the prover; however, it will later be useful to also consider a more general setting in which </span>x<span class="math"> <em>encodes</em> an input </span>x^{\\prime}<span class="math"> known to the prover, but </span>x<span class="math"> itself is not entirely known. Informally, a zero-knowledge proof on distributed data is an interactive protocol between </span>P<span class="math"> and the </span>k<span class="math"> verifiers </span>V_{j}<span class="math"> that satisfies the following properties. The proof system must be <em>complete</em>, in the sense that if </span>x\\in\\mathcal{L}<span class="math"> and all parties are honest, all verifiers accept. The proof system must be <em>sound</em>, in the sense that if </span>x\\not\\in\\mathcal{L}<span class="math">, then all verifiers reject with high probability. Finally, the proof system must have <em>strong zero knowledge</em>: any proper subset of the verifiers should learn no additional information about </span>x<span class="math">, apart from what follows from their own pieces and the fact that </span>x\\in\\mathcal{L}<span class="math">. Note that this notion of zero knowledge is stronger than the traditional one. In a standard zero-knowledge interactive proof, the verifier learns the statement </span>x<span class="math"> and learns that </span>x\\in\\mathcal{L}<span class="math">, but the verifier learns nothing else. In our setting, <em>any proper subset of the verifiers does not even learn the statement </span>x<span class="math"></em>: such a collection of verifiers just learn that they are jointly holding pieces </span>x^{(j)}<span class="math"> of some input </span>x\\in\\mathcal{L}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Up to now, we have implicitly considered an honest-verifier setting, where soundness must hold against a potentially malicious prover, but (strong) zero knowledge is required only with respect to honest verifiers. For later applications, we will need to consider two more stringent adversarial settings:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setting I: Either the prover <em>or</em> a subset of up to <span class="math">t</span> verifiers may be malicious (not both). Here we will typically let <span class="math">t=k-1</span>.</li>

      <li>Setting II: The prover <em>and</em> a subset of up to <span class="math">t</span> verifiers may be malicious, and collude. Here we will typically let <span class="math">t&lt;k/2</span>.</li>

    </ul>

    <p class="text-gray-300">Note that Setting I introduces challenges in guaranteeing zero knowledge against malicious verifiers, and Setting II further challenges in soundness, when malicious prover and verifiers collude.</p>

    <p class="text-gray-300">We now formalize the above discussion. We start by defining distributed analogues of the basic objects of zero-knowledge proofs: inputs, languages, and relations. As before, we focus for simplicity on the finite case, where languages are subsets of vectors in <span class="math">\\mathbb{F}^{n}</span>, and ignore computational efficiency issues. Except when explicitly noted otherwise, all definitions and results extend in a natural way to the usual asymptotic framework with polynomial-time parties and relations.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 6.1 (Distributed inputs, languages, and relations).</h6>

    <p class="text-gray-300">Let <span class="math">k</span> be a number of parties, <span class="math">\\mathbb{F}</span> be a finite field, and <span class="math">n,n_{1},\\ldots,n_{k}\\in\\mathbb{N}</span> be length parameters, where <span class="math">n=n_{1}+n_{2}+\\ldots+n_{k}</span>. A</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">k</span>-distributed input over <span class="math">\\mathbb{F}</span> (or just distributed input) is a vector $x=x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}\\in\\mathbb{F}^{n}<span class="math">, where </span>x^{(i)}\\in\\mathbb{F}^{n_{i}}<span class="math">. We refer to each </span>x^{(i)}<span class="math"> as a piece of </span>x<span class="math">. (In the context of secret sharing, we will sometimes refer to </span>x^{(i)}<span class="math"> as a share.) A </span>k<span class="math">-distributed language </span>\\mathcal{L}<span class="math"> is a set of </span>k<span class="math">-distributed inputs. A distributed NP relation with witness length </span>h<span class="math"> is a binary relation </span>\\mathcal{R}(x,w)<span class="math"> where </span>x<span class="math"> is a </span>k<span class="math">-distributed input and </span>w\\in\\mathbb{F}^{h}<span class="math">. We assume that all </span>x<span class="math"> in </span>\\mathcal{L}<span class="math"> and </span>(x,w)\\in\\mathcal{R}<span class="math"> share the same length parameters. Finally, we let </span>\\mathcal{L}(\\mathcal{R})=\\{\\,x\\,:\\,\\exists w\\,(x,w)\\in\\mathcal{R}\\,\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now define our protocol model for zero-knowledge proofs on distributed data. Our default network model allows synchronous communication over secure point-to-point channels. We will later also allow protocols to use an ideal broadcast primitive and an ideal coin-tossing primitive.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 6.2 (<span class="math">k</span>-verifier interactive proof protocol).</h6>

    <p class="text-gray-300">A <span class="math">k</span>-verifier interactive proof protocol over <span class="math">\\mathbb{F}</span> is an interactive protocol <span class="math">\\Pi=(P,V_{1},\\ldots,V_{k})</span> involving a prover <span class="math">P</span> and <span class="math">k</span> verifiers <span class="math">V_{1},V_{2},\\ldots,V_{k}</span>. The protocol proceeds as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In the beginning of the protocol the prover holds a <span class="math">k</span>-distributed input $x=x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}\\in\\mathbb{F}^{n}<span class="math"> and (possibly) a witness </span>w\\in\\mathbb{F}^{h}<span class="math">, and each verifier </span>V_{j}<span class="math"> holds an input piece </span>x^{(j)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol allows the parties to communicate in synchronous rounds over secure point-to-point channels. The role of each party in this interaction is defined by a next message function, which specifies the messages it sends in each round as a function of its local input, random input, and messages received in previous rounds. (The random inputs are picked independently from a distribution that will be implicit in the protocol description.) While honest parties send messages according to <span class="math">\\Pi</span>, malicious parties, which are all controlled by a central adversary, can send arbitrary messages. Moreover, the messages sent by malicious parties in each round can depend on all messages they receive from honest parties in the same round (namely, the adversary has a rushing capability).</li>

      <li>After some fixed number of rounds the protocol terminates. Upon termination, each verifier outputs either acc (accept) or rej (reject) based on its view, where the view of a verifier <span class="math">V_{j}</span> consists of its input piece <span class="math">x^{(j)}</span>, random input <span class="math">r^{(j)}</span>, and messages it received during the protocol execution. To ensure that all honest verifiers either simultaneously accept or reject, we will assume by default that the decision is determined by public information that was communicated over a broadcast channel (see below).</li>

    </ul>

    <p class="text-gray-300">We denote by <span class="math">\\Pi(x,w)</span> the probabilistic experiment of running <span class="math">\\Pi</span> on distributed input <span class="math">x</span> and witness <span class="math">w</span>, and say that <span class="math">\\Pi(x,w)</span> accepts (respectively, rejects) if in the end of this experiment all verifiers output acc (resp., rej). We denote by <span class="math">\\mathsf{View}_{\\Pi,T}(x,w)</span> the (joint distribution of) views of verifiers <span class="math">V_{j}</span> with <span class="math">j\\in T</span> in the execution of <span class="math">\\Pi</span> on the distributed input <span class="math">x</span> and witness <span class="math">w</span>.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Helper functionalities.</h4>

    <p class="text-gray-300">For modularity, we factor out two standard primitives that are useful for obtaining security against malicious verifiers: a broadcast primitive, allowing a party to send an identical message to all parties (where even a malicious sender cannot make different honest parties receive different messages), and a coin-toss primitive, which generates unpredictable, public randomness. We model these two primitives by using ideal multi-party functionalities formally defined below. We assume by default that a <span class="math">k</span>-verifier interactive proof protocol can make oracle calls to these functionalities.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 6.3 (Ideal broadcast and coin-toss functionalities).</h6>

    <p class="text-gray-300">We define the two helper functionalities <span class="math">\\mathcal{F}_{\\mathsf{bcast}}</span> and <span class="math">\\mathcal{F}_{\\mathsf{coin}}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The broadcast functionality <span class="math">\\mathcal{F}_{\\mathsf{bcast}}</span> receives an input message <span class="math">m</span> from a verifier <span class="math">V_{j}</span> and delivers the output <span class="math">(j,m)</span> to all parties. When considering protocols that should be secure in the</li>

    </ul>

    <p class="text-gray-300">presence of malicious verifiers, we assume that each verifier’s decision whether to accept or reject is determined in the same way based on (public) messages sent via <span class="math">\\mathcal{F}_{\\mathsf{bcast}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>coin-toss</em> functionality <span class="math">\\mathcal{F}_{\\mathsf{coin}}^{\\mathcal{S}}</span>, for a finite set <span class="math">\\mathcal{S}</span>, is a randomized, input-less functionality that outputs to all parties (prover and verifiers) a uniformly random element <span class="math">r\\in_{R}\\mathcal{S}</span>.</li>

    </ul>

    <p class="text-gray-300">The requirement that accepting or rejecting depends only on public information ensures agreement between honest verifiers on whether to accept, and effectively forces a simulator of the view of malicious verifiers to know whether honest verifiers accept.</p>

    <p class="text-gray-300">On realizing <span class="math">\\mathcal{F}_{\\mathsf{coin}}</span> and <span class="math">\\mathcal{F}_{\\mathsf{bcast}}</span>. In the honest-verifier case, both functionalities can be trivially realized: for instance, <span class="math">\\mathcal{F}_{\\mathsf{coin}}^{\\mathcal{S}}</span> can be realized by having <span class="math">V_{1}</span> pick <span class="math">r</span> uniformly from <span class="math">\\mathcal{S}</span> and send it to all other parties. When the verifiers can be malicious, one can use standard (composable) implementations of these primitives over secure point-to-point channels, providing different tradeoffs between security type and efficiency (see, e.g., <em>[41, 76]</em> and references therein). We note that our protocols will make a minimal use of these two ideal primitives. In particular, the total size of all instances will be sublinear in the size of the distributed input <span class="math">x</span>. Thus, for distributed zero-knowledge proofs on large inputs, the implementation of these helper functionalities will not form an efficiency bottleneck.</p>

    <p class="text-gray-300">For the purpose of measuring round complexity of protocols, we will separately count “standard” rounds of point-to-point communication and rounds in which the above oracles are invoked. For communication complexity, we will count the length of the input of <span class="math">\\mathcal{F}_{\\mathsf{bcast}}</span> or output of <span class="math">\\mathcal{F}_{\\mathsf{coin}}^{\\mathcal{S}}</span>.</p>

    <p class="text-gray-300">We now separately address the two distinct adversarial settings discussed above.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">6.2 Setting I: Malicious Prover <em>or</em> Verifiers</h3>

    <p class="text-gray-300">We begin with the first setting, where we must protect against either a malicious prover in the presence of honest verifiers, or honest prover in the presence of (a subset of) malicious verifiers.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 6.4 (Zero-knowledge proofs on distributed data: malicious prover <em>or</em> verifiers).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}(x,w)</span> be a <span class="math">k</span>-distributed relation over finite field <span class="math">\\mathbb{F}</span>. We say that a <span class="math">k</span>-verifier interactive proof protocol <span class="math">\\Pi=(P,V_{1},\\ldots,V_{k})</span> is a <em>distributed strong zero-knowledge proof protocol for <span class="math">\\mathcal{R}</span> with security against malicious prover</em> or <em><span class="math">t</span> verifiers</em> and soundness error <span class="math">\\epsilon</span>, if <span class="math">\\Pi</span> satisfies the following:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Completeness. For every <span class="math">k</span>-distributed input $x=x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}\\in\\mathbb{F}^{n}<span class="math"> and witness </span>w\\in\\mathbb{F}^{h}<span class="math"> such that </span>(x,w)\\in\\mathcal{R}<span class="math">, the execution of </span>\\Pi(x,w)<span class="math"> accepts with probability </span>1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For every malicious prover <span class="math">P^{<em>}</span>, <span class="math">k</span>-distributed input <span class="math">x</span> and witness <span class="math">w</span> such that <span class="math">x\\not\\in\\mathcal{L}(\\mathcal{R})</span>, the execution of <span class="math">\\Pi^{</em>}(x,w)</span> rejects except with at most <span class="math">\\epsilon</span> probability (where <span class="math">\\Pi^{<em>}</span> denotes the interaction of <span class="math">P^{</em>}</span> with the honest verifiers <span class="math">(V_{1},\\ldots,V_{k})</span>).</li>

    </ul>

    <p class="text-gray-300">We define a zero-knowledge property similar to the one used in our linear IOP definition:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Strong zero knowledge. For every <span class="math">T\\subseteq[k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math"> and a malicious adversary </span>A<span class="math"> controlling the verifiers </span>\\{V_{j}\\}_{j\\in T}<span class="math">, there exists a simulator </span>S<span class="math"> such that for every </span>k<span class="math">-distributed input </span>x=x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}<span class="math"> and witness </span>w<span class="math"> such that </span>(x,w)\\in\\mathcal{R}$ we have:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">S((x^{(j)})_{j\\in T})\\quad\\equiv\\quad\\mathsf{View}_{\\Pi^{*},T}(x,w),</span></p>

    <p class="text-gray-300">where here <span class="math">\\Pi^{*}</span> denotes the interaction of the malicious adversary <span class="math">A</span> with the honest prover <span class="math">P</span> and the honest verifiers <span class="math">\\{V_{j}\\}_{j\\not\\in T}</span>. When the threshold <span class="math">t</span> is omitted, we assume that <span class="math">t=k-1</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Remark 6.5 (Honest-verifier variant).</h6>

    <p class="text-gray-300">One may consider a relaxed notion of strong <em>honest-verifier</em> zero knowledge, defined identically to the above, but where the subset of verifiers <span class="math">\\{V_{j}^{*}\\}_{j\\in T}</span> is stipulated to honestly follow the protocol.</p>

    <p class="text-gray-300">If we do not consider a zero-knowledge requirement, then any interactive proof system for <span class="math">\\mathcal{R}</span> immediately yields a <span class="math">k</span>-verifier interactive proof system for <span class="math">\\mathcal{R}</span>: Indeed, verifiers <span class="math">V_{2},\\ldots,V_{k}</span> can simply send their pieces of <span class="math">x</span> to <span class="math">V_{1}</span>, who then engages with <span class="math">P</span> in a standard interactive proof protocol for <span class="math">\\mathcal{R}</span>. This approach does not respect strong zero knowledge. Moreover, it cannot not meet our goal of making communication complexity sublinear in the input length. We now show a similar compiler that allows us to get around both limitations by starting with a (public-coin, strong HVZK) fully linear IOP.</p>

    <p class="text-gray-300">A compiler for Setting I. At a high level, we convert a public-coin, fully linear IOP with strong HVZK <span class="math">\\Pi</span> into a zero-knowledge proof on distributed data <span class="math">\\Pi_{\\mathsf{dist}}</span> by exploiting the fact that the task of answering public linear queries can be easily distributed. Recall that the prover holds <span class="math">(x,w)\\in\\mathcal{R}</span>, where <span class="math">x</span> is partitioned into pieces <span class="math">x^{(j)}</span> held by different verifiers. The prover in <span class="math">\\Pi_{\\mathsf{dist}}</span> will execute the fully linear IOP on its input <span class="math">(x,w)</span>, where in each round <span class="math">i</span> she splits the proof <span class="math">\\pi_{i}</span> for this round into additive secret shares, and sends one share to each verifier over a secure channel. The fresh public random challenge <span class="math">r_{i}</span>, which determines the query vectors <span class="math">q_{i,1},\\ldots,q_{i,\\ell_{i}}</span>, is generated using the ideal coin-tossing oracle <span class="math">\\mathcal{F}_{\\mathsf{coin}}</span>. Since each query defines a linear combination of the input <span class="math">x</span> and the proof <span class="math">\\pi_{i}</span>, the verifiers can use their input pieces and additive shares of <span class="math">\\pi_{i}</span> to compute additive shares of the answers to the queries, which they send to <span class="math">V_{1}</span>. At the conclusion, <span class="math">V_{1}</span> reconstructs the answers <span class="math">a_{i}</span>, feeds them into the IOP decision predicate, and broadcasts the decision (acc or rej) to the other verifiers.</p>

    <p class="text-gray-300">The above construction directly preserves completeness as well as soundness against a malicious prover (since, in essence, the secret shares of each <span class="math">\\pi_{i}</span> commit the prover to a fixed proof). Proving zero knowledge against <span class="math">t=k-1</span> malicious verifiers is more subtle. The random challenges generated by <span class="math">\\mathcal{F}_{\\mathsf{coin}}</span> and the proof shares received from the prover are easy to simulate. To complete the simulation, we distinguish between two cases. If <span class="math">V_{1}</span> is not corrupted, then we only need to simulate the final decision received by <span class="math">V_{1}</span>. Since other verifiers can be malicious, they have control over the answers <span class="math">a_{i}</span> reconstructed by <span class="math">V_{1}</span>. However, since the honest answers <span class="math">a_{i}</span> can be simulated without knowing the input (by the strong zero knowledge of <span class="math">\\Pi</span>), and since the effect of the malicious verifiers on the answers reconstructed by <span class="math">V_{1}</span> can be predicted based on their inputs, the final decision computed by <span class="math">V_{1}</span> can be simulated. For the case where <span class="math">V_{1}</span> is corrupted, we can assume without loss of generality that in each round <span class="math">i</span> of <span class="math">\\Pi</span>, each set of queries (viewed as linear functions of the input <span class="math">x</span> together with a proof vector <span class="math">\\pi_{i}</span>) are linearly independent. Then we use the strong zero-knowledge property to deduce that linear independence must hold even when restricted to the <span class="math">\\pi_{i}</span> coefficients. The latter implies that the answer shares of any strict subset of the verifiers are uniformly and independently distributed, which allows us to obtain a distributed simulator for <span class="math">\\Pi_{\\mathsf{dist}}</span> from the IOP simulator.</p>

    <p class="text-gray-300">We now give the formal description of <span class="math">\\Pi_{\\mathsf{dist}}</span> and its analysis. We assume that <span class="math">\\Pi=(P_{\\mathsf{LIOP}},V_{\\mathsf{LIOP}})</span> is a <span class="math">\\rho</span>-round public-coin fully linear IOP for <span class="math">\\mathcal{R}</span> (viewed as a non-distributed relation) with total proof length <span class="math">\\mu=\\sum_{i=1}^{\\rho}\\mu_{i}</span>, random challenges <span class="math">r_{i}\\in\\mathbb{F}^{b_{i}}</span>, total query complexity <span class="math">\\ell=\\sum_{i=1}^{\\rho}\\ell_{i}</span>, soundness error <span class="math">\\epsilon</span>, and strong HVZK.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathsf{dist}}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: The prover <span class="math">P</span> has input <span class="math">(x,w)</span>. Each verifier <span class="math">V_{j}</span>, <span class="math">1\\leq j\\leq k</span>, has input piece <span class="math">x^{(j)}</span>.</li>

      <li>Interaction: For <span class="math">i=1,2,\\ldots,\\rho</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=1</span>, <span class="math">P</span> lets <span class="math">(\\pi_{1},\\mathsf{st}_{1}^{P})\\leftarrow P_{\\mathsf{LIOP}}((x,w),\\bot)</span>, else it lets <span class="math">(\\pi_{i},\\mathsf{st}_{i}^{P})\\leftarrow P_{\\mathsf{LIOP}}(\\mathsf{st}_{i-1}^{P},r_{i-1})</span>.</li>

      <li><span class="math">P</span> splits <span class="math">\\pi_{i}</span> into additive shares by sampling random <span class="math">\\pi_{i1},\\ldots,\\pi_{ik}\\in\\mathbb{F}^{\\mu_{i}}</span> such that <span class="math">\\pi_{i}=\\sum_{j=1}^{k}\\pi_{ij}\\in\\mathbb{F}^{\\mu_{i}}</span> and sends proof share <span class="math">\\pi_{ij}</span> to <span class="math">V_{j}</span>.</li>

      <li>The <span class="math">k+1</span> parties invoke <span class="math">r_{i}\\leftarrow\\mathcal{F}_{\\mathsf{coin}}^{\\mathcal{S}}</span> for <span class="math">\\mathcal{S}=\\mathbb{F}^{b_{i}}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All <span class="math">k</span> verifiers let <span class="math">(q_{i,1},\\ldots,q_{i,\\ell_i})</span> be the query vectors determined by <span class="math">r_1,\\ldots,r_i</span>, where <span class="math">q_{i,\\alpha}\\in \\mathbb{F}^{n + \\mu_i}</span> for <span class="math">1\\leq \\alpha \\leq \\ell_{i}</span>. Let <span class="math">Q_{i}\\in \\mathbb{F}^{(n + \\mu_{i})\\times \\ell_{i}}</span> be the matrix whose columns are <span class="math">q_{i,\\alpha}</span>, and let <span class="math">Q_{i}^{(j)}\\in \\mathbb{F}^{(n_{j} + \\mu_{i})\\times \\ell_{i}}</span> be the matrix <span class="math">Q_{i}</span> with the first <span class="math">n</span> rows restricted to the <span class="math">x^{(j)}</span>-entries.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Each verifier <span class="math">V_{j}</span> sends to <span class="math">V_{1}</span> the answer share $a_{ij} = (x^{(j)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{ij})\\cdot Q_i^{(j)}<span class="math"> and </span>V_{1}<span class="math"> computes </span>a_{i} = \\sum_{j = 1}^{k}a_{ij}<span class="math">, where </span>a_{i}\\in \\mathbb{F}^{\\ell_{i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs: Verifier <span class="math">V_{1}</span> applies the decision predicate of <span class="math">V_{\\text{LOP}}</span> to the random challenges <span class="math">r_1, \\ldots, r_\\rho</span> and the answers <span class="math">a_1, \\ldots, a_\\rho</span>, and broadcasts its decision (acc or rej). All verifiers output the decision broadcasted by <span class="math">V_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Efficiency. Note that the communication between verifiers in the end of round <span class="math">i</span> can be merged with the prover's communication to the verifiers in the beginning of round <span class="math">i + 1</span>. This gives an implementation of <span class="math">\\Pi_{\\mathrm{dist}}</span> with the following efficiency features:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The round complexity involves <span class="math">\\rho + 1</span> rounds of point-to-point communication, as well as <span class="math">\\rho</span> sequential invocations of <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span>;</li>

      <li>The communication includes a total of <span class="math">\\mu k + \\ell (k - 1)</span> field elements and a single bit of broadcast;</li>

      <li>There are <span class="math">\\rho</span> invocations of <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> that generate a total of <span class="math">b = \\sum_{i=1}^{\\rho} b_i</span> random field elements;</li>

      <li>The arithmetic circuit complexity of <span class="math">P</span> (resp., of each <span class="math">V_{i}</span>) is <span class="math">s_P + O(\\mu k)</span> (resp., <span class="math">s_V + O(\\ell k)</span>), where <span class="math">s_P</span> and <span class="math">s_V</span> are the arithmetic circuit complexity of <span class="math">P_{\\text{LOP}}</span> and <span class="math">V_{\\text{LOP}}</span>, respectively.</li>

    </ul>

    <p class="text-gray-300">We now state and prove the security properties of <span class="math">\\Pi_{\\mathrm{dist}}</span>.</p>

    <p class="text-gray-300">Theorem 6.6 (Zero-knowledge proof on distributed data: malicious prover or verifiers). Let <span class="math">\\mathcal{R}</span> be a <span class="math">k</span>-distributed relation over <span class="math">\\mathbb{F}</span>. Suppose <span class="math">\\Pi = (P_{\\text{LOP}}, V_{\\text{LOP}})</span> is a <span class="math">\\rho</span>-round public-coin fully linear IOP for <span class="math">\\mathcal{R}</span> (viewed as a non-distributed relation) with soundness error <span class="math">\\epsilon</span> and strong HVZK. Then, the protocol <span class="math">\\Pi_{\\text{dist}} = (P, V_1, \\ldots, V_k)</span> described above is a distributed strong zero-knowledge proof protocol for <span class="math">\\mathcal{R}</span> in the <span class="math">(\\mathcal{F}_{\\text{coin}}, \\mathcal{F}_{\\text{bcast}})</span>-hybrid model, with security against malicious prover or <span class="math">t = k - 1</span> verifiers and soundness error <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Proof of Theorem 6.6. We separately argue completeness, soundness, and zero knowledge.</p>

    <p class="text-gray-300">COMPLETENESS. Follows easily from the completeness of <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">SOUNDNESS. Here we assume that the <span class="math">k</span> verifiers <span class="math">V_{j}</span> are honest but the prover <span class="math">P^{<em>}</span> is malicious. For any malicious strategy of <span class="math">P^{</em>}</span> in <span class="math">\\Pi_{\\mathrm{dist}}</span> we define a corresponding malicious strategy of <span class="math">P_{\\mathrm{LOP}}^{<em>}</span> in <span class="math">\\Pi</span> so that the probability of all verifiers rejecting in <span class="math">\\Pi_{\\mathrm{dist}}</span> is equal to the probability of <span class="math">V_{\\mathrm{LOP}}</span> rejecting in <span class="math">\\Pi</span>. Concretely, each (badly formed) proof generated by <span class="math">P_{\\mathrm{LOP}}^{</em>}</span> is the sum of the corresponding proof shares generated by <span class="math">P^{*}</span> on the same random challenges. It follows that <span class="math">\\Pi_{\\mathrm{dist}}</span> has the same soundness error as <span class="math">\\Pi</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ZERO KNOWLEDGE. We show that the protocol satisfies the strong zero knowledge requirement for <span class="math">t = k - 1</span>. Here we consider the case where <span class="math">P</span> is honest, and up to <span class="math">t</span> verifiers can be malicious. Let <span class="math">T \\subseteq [k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math"> and let </span>A<span class="math"> be a malicious adversary controlling the verifiers </span>\\{V_j\\}_{j \\in T}<span class="math">. Let </span>x = x^{(1)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)}<span class="math"> and </span>w<span class="math"> such that </span>(x, w) \\in \\mathcal{R}<span class="math">. We describe a simulator </span>S<span class="math"> such that </span>S((x^{(j)})_{j \\in T})<span class="math"> perfectly generates the view of the verifiers in </span>T<span class="math"> in the interaction of </span>A<span class="math"> with </span>P<span class="math"> and the honest verifiers on inputs </span>(x, w)<span class="math">. Note that because </span>\\Pi_{\\mathrm{dist}}<span class="math"> uses the ideal coin toss functionality </span>\\mathcal{F}_{\\mathrm{coin}}<span class="math">, the malicious verifiers have no effect on the choice of the random challenges. The simulation now depends on whether </span>V_1$ is corrupted.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">1 \\notin T</span>. In this case, <span class="math">S</span> starts by invoking the simulator <span class="math">S_{\\text{LOP}}</span> implied by the strong HVZK property of <span class="math">\\Pi</span> to generate the random challenges <span class="math">r_i</span> together with the answers <span class="math">a_i</span> for</li>

    </ul>

    <p class="text-gray-300">each round <span class="math">1\\leq i\\leq\\rho</span>. Then, for each round <span class="math">i</span> and corrupted verifier <span class="math">V_{j}</span>, <span class="math">j\\in T</span>, it simulates the message <span class="math">V_{j}</span> receives from <span class="math">P</span> by picking a proof share <span class="math">\\pi_{ij}</span> uniformly at random from <span class="math">\\mathbb{F}^{\\mu_{j}}</span>. The message from <span class="math">V_{1}</span> received in the final round is simulated as follows. First, for each round <span class="math">i</span> and malicious verifier <span class="math">j\\in T</span>, the simulator <span class="math">S</span> uses the simulated values <span class="math">x^{(j)},r_{i},\\pi_{ij}</span> to compute two values: the answer share <span class="math">a_{ij}</span> that <span class="math">V_{j}</span> should have sent to <span class="math">V_{1}</span> and the answer <span class="math">a_{ij}^{<em>}</span> it actually sent. (The latter is obtained by running <span class="math">A</span> on the view containing the input pieces <span class="math">x^{(j)}</span> and the simulated values up to round <span class="math">i</span>.) Then, <span class="math">S</span> simulates the answers computed by <span class="math">V_{1}</span> as <span class="math">a_{i}^{</em>}=a_{i}+\\sum_{j\\in T}(a_{ij}^{<em>}-a_{ij})</span>, applies the decision predicate of <span class="math">V_{\\mathsf{LIOP}}</span> to the random challenges <span class="math">r_{1},\\ldots,r_{\\rho}</span> and the answers <span class="math">a_{1}^{</em>},\\ldots,a_{\\rho}^{*}</span>, and uses the result (acc or rej) to simulate the final broadcast message received from <span class="math">V_{1}</span>.</p>

    <p class="text-gray-300">To see that this perfectly simulates the view of malicious verifiers, first note that the joint simulation of <span class="math">r_{i},a_{i}</span> and <span class="math">(\\pi_{ij})_{j\\in T}</span> perfectly emulates the real execution, since the proof shares <span class="math">(\\pi_{ij})_{j\\in T}</span> in the real execution are uniformly random independently of <span class="math">r_{i},\\pi_{i}</span>. It follows that the simulated value of <span class="math">\\sum_{j\\in T}(a_{ij}^{*}-a_{ij})</span>, which captures the difference between the correct answer and the one obtained by <span class="math">V_{1}</span>, is also distributed identically to the real protocol even when conditioned on all <span class="math">r_{i},\\pi_{i},(\\pi_{ij})_{j\\in T}</span>. This implies the correctness of the simulation of the final decision bit of <span class="math">V_{1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2: <span class="math">1\\in T</span>. The proof shares <span class="math">\\pi_{ji}</span> are simulated as before. We simulate the challenges <span class="math">r_{i}</span> and answer shares <span class="math">a_{ij}</span> jointly by using the simulator <span class="math">S_{\\mathsf{LIOP}}</span> implied by the strong HVZK property of <span class="math">\\Pi</span>. First, we use <span class="math">S_{\\mathsf{LIOP}}</span> to simulate the joint distribution of the random challenges <span class="math">r_{i}</span> and answers <span class="math">a_{i}</span>. The challenges <span class="math">r_{i}</span> determine query matrices <span class="math">Q_{i}</span> as in <span class="math">\\Pi</span>. Assume without loss of generality that each <span class="math">Q_{i}</span> has full rank. (Otherwise queries are redundant in the sense that there is a query whose answer can be inferred from the other answers.) Given the answers <span class="math">a_{i}</span>, the answer shares <span class="math">a_{ij}</span> received by <span class="math">V_{1}</span> from honest provers <span class="math">V_{j}</span>, <span class="math">j\\not\\in T</span>, are computed as follows: first, the answer shares <span class="math">a_{ij}</span> for <span class="math">j\\in T</span> are computed from <span class="math">\\pi_{ij}</span> and <span class="math">Q_{i}</span> as in <span class="math">\\Pi_{\\mathsf{dist}}</span>, namely $a_{ij}=(x^{(j)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{ij})\\cdot Q_{i}^{(j)}<span class="math">. Then the messages </span>a_{ij}<span class="math">, </span>j\\not\\in T<span class="math">, are picked at random subject to the restriction </span>\\sum_{j=1}^{k}a_{ij}=a_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To prove that the simulation is perfect, we prove that in an honest execution of <span class="math">\\Pi_{\\mathsf{dist}}</span>, the answer shares <span class="math">a_{ij}</span> are uniformly distributed subject to the restriction that they add up to <span class="math">a_{i}</span>. This reduces to showing that in every round <span class="math">i</span>, each strict subset of the <span class="math">a_{ij}</span> are uniform and independent. Somewhat unexpectedly, this relies not only on the above full rank assumption but also on the strong zero knowledge property of <span class="math">\\Pi</span>. Indeed, the description of <span class="math">\\Pi_{\\mathsf{dist}}</span> directly implies that any strict subset of the <span class="math">\\pi_{ij}</span> is uniformly distributed. Since $a_{ij}=(x^{(j)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{ij})\\cdot Q_{i}^{(j)}<span class="math">, it suffices to show that if we restrict the rows of </span>Q_{i}<span class="math"> to their </span>\\pi_{i}<span class="math">-entries (namely, remove the first </span>n<span class="math"> rows), the columns are still linearly independent. Suppose towards contradiction that the columns are linearly dependent with positive probability. Conditioned on this event, we can compute (with certainty) a corresponding linear combination of the entries of </span>x<span class="math"> from the answers </span>a_{i}=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{i})\\cdot Q_{i}<span class="math">, since the </span>\\pi_{i}<span class="math"> parts can be cancelled out. This contradicts the strong zero knowledge property of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This concludes the proof of Theorem 6.6. ∎</p>

    <p class="text-gray-300">To give a concrete application, consider the class of degree-<span class="math">d</span> distributed languages, namely ones whose membership can be tested by a set of degree-<span class="math">d</span> equations. Combining Theorem 6.6 with Corollary E.3, we get the following corollary.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Corollary 6.7 (Sublinear zero-knowledge proofs for distributed low-degree languages: malicious prover or verifiers).</h6>

    <p class="text-gray-300">Let <span class="math">d\\geq 2</span> be a positive integer, <span class="math">\\epsilon&gt;0</span> an error bound, and <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> a <span class="math">k</span>-distributed</p>

    <p class="text-gray-300">language whose membership is tested by <span class="math">m</span> degree-<span class="math">d</span> polynomials. Then, there exists an <span class="math">O(d\\log n)</span>-round strong zero-knowledge proof protocol for <span class="math">\\mathcal{L}</span> in the <span class="math">(\\mathcal{F}_{\\mathsf{coin}},\\mathcal{F}_{\\mathsf{bcast}})</span>-hybrid model, with security against malicious prover or <span class="math">t=k-1</span> verifiers, soundness error <span class="math">\\epsilon</span>, and communication complexity of <span class="math">O(kd^{2}\\log n\\cdot\\log(m/\\epsilon))</span> field elements.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">6.2.1 Application: Proofs on secret-shared data</h4>

    <p class="text-gray-300">Several recent works, including <em>[35, 44]</em>, consider a setting in which a client secret-shares a big input <span class="math">x</span> among two or more servers, and the servers want to be assured that the input shared by the client is in some sense “well-formed.” The notion of zero-knowledge proofs on distributed data can capture this setting as a special case. Here we let the client play the role of the prover <span class="math">P</span> and each of the <span class="math">k</span> servers play the role of a verifier <span class="math">V_{i}</span>. The input pieces <span class="math">x^{(1)},\\ldots,x^{(k)}</span> are the shares of <span class="math">x</span> that were generated by some secret-sharing scheme and distributed among the servers.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a secret sharing scheme is <span class="math">t</span>-private if any set of <span class="math">t</span> shares reveal nothing about the secret. Our notion of zero-knowledge proofs on distributed data can be used to prove statements on the secret-shared input <span class="math">x</span>, while completely hiding <span class="math">x</span> from any set of <span class="math">t</span> verifiers, in the following generic way. To prove that <span class="math">x\\in\\mathcal{L}(\\mathcal{R})</span>, for a (non-distributed) relation <span class="math">\\mathcal{R}(x,w)</span>, the prover <span class="math">P</span> and the <span class="math">k</span> verifiers <span class="math">V_{i}</span> engage in a zero-knowledge proof for the <span class="math">k</span>-distributed relation <span class="math">\\mathcal{R}^{\\prime}</span> defined by $\\mathcal{R}^{\\prime}(x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)},w)=\\mathcal{R}(\\mathsf{Rec}(x^{(1)},\\ldots,x^{(k)}),w)<span class="math">, where </span>\\mathsf{Rec}<span class="math"> is the reconstruction algorithm of the secret-sharing scheme. If the scheme is </span>t<span class="math">-private and we use a zero-knowledge proof on distributed data with security against </span>t<span class="math"> verifiers (such as the ones obtained via Theorem 6.6), a set of </span>t<span class="math"> malicious verifiers cannot learn any information about the secret </span>x<span class="math"> other than the fact that </span>x\\in\\mathcal{L}(\\mathcal{R})<span class="math">. Indeed, the view of the </span>t<span class="math"> verifiers can be simulated from scratch by first simulating their shares (which can be done by sharing a dummy secret) and then invoking the distributed zero-knowledge simulator on these shares. Note that for the typical case of linear secret sharing scheme, the algebraic degree of </span>\\mathcal{R}^{\\prime}<span class="math"> is the same as that of </span>\\mathcal{R}<span class="math">. Thus, our sublinear IOPs for low-degree languages can be applied to get sublinear protocols for proving in zero-knowledge that a secret-shared input </span>x$ satisfies a set of low-degree constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the case where each entry of <span class="math">x</span> is secret-shared independently using some linear secret-sharing scheme (for instance, <span class="math">x</span> is randomly split into <span class="math">k</span> additive shares <span class="math">x^{(1)},\\ldots,x^{(k)}</span> such that <span class="math">x=x^{(1)}+\\ldots+x^{(k)}</span>), one can simplify the above approach as follows. Instead of defining a new relation <span class="math">\\mathcal{R}^{\\prime}</span> that includes the reconstruction of <span class="math">x</span> from its shares, one can directly apply a fully linear IOP for <span class="math">\\mathcal{R}</span> to the shares of <span class="math">x</span> by letting each verifier locally apply each IOP query to the concatenation of its share of <span class="math">x</span> and the share of the proof. This leaner variant can be proved secure similarly to the security proof of the protocol <span class="math">\\Pi_{\\mathsf{dist}}</span> from Theorem 6.6, and can be seen as a special case of the protocol for zero-knowledge proofs on encoded data we present in Section 6.3.3.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">6.2.2 Generically achieving honest-verifier zero knowledge</h4>

    <p class="text-gray-300">Theorem 6.6 compiles a fully linear IOP with strong HVZK into a (strong) zero-knowledge proof on distributed data. It turns out that if we settle for (strong) honest-verifier zero knowledge, we can get a similar conclusion (with a small additional overhead) even if we start with a fully linear IOP that does not provide any form of zero knowledge.</p>

    <p class="text-gray-300">The high level idea, which was previously used in related contexts <em>[35, 44]</em>, is to avoid a direct reconstruction of the answers <span class="math">a_{i}</span>, and instead apply a general-purpose MPC protocol for computing the verification predicate from the answer shares <span class="math">a_{ij}</span>. The communication complexity of this protocol scales linearly with the circuit complexity of the verification predicate, which in the cases we are interested in will be sublinear. If <span class="math">t&lt;k/2</span>, this MPC protocol can be realized directly, without any</p>

    <p class="text-gray-300">help from the prover <em>[16]</em>. To handle an arbitrary subset of semi-honest verifiers, the prover can provide correlated randomness to the verifiers (e.g., in the form of multiplication triples <em>[12]</em>) to enable MPC with dishonest majority. The verifiers then use this correlated randomness to compute the output of the linear IOP verification circuit without revealing any additional information about their inputs.</p>

    <p class="text-gray-300">Note that if the prover is malicious, it can provide malformed correlated randomness. However, for natural MPC protocols and linear IOPs, such a malicious strategy will not give the prover any advantage in violating soundness. The high level reason is that the effect of malformed randomness is equivalent to an “additive attack” on the IOP verification circuit, and such an attack cannot reduce the entropy of the output of the verification circuit in case the proof is incorrect (see <em>[35, 44]</em> for more details).</p>

    <p class="text-gray-300">The amount of correlated randomness that the prover must provide is linear in the number of multiplication gates of the linear IOP verification circuit. For example, for the GKR-based linear IOP of Theorem A.1, the verifier provides <span class="math">O(1)</span> field elements worth of correlated randomness to each verifier in each protocol round.</p>

    <p class="text-gray-300">Finally, we note that the above transformation fails to provide zero knowledge against malicious verifiers even if the MPC protocol is secure against malicious parties, since by changing their input to the IOP verification circuit and observing the output, the verifiers can potentially learn additional information about <span class="math">x</span>, beyond the fact that <span class="math">x\\in\\mathcal{L}(\\mathcal{R})</span>.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">6.2.3 Fiat-Shamir transform for proofs on distributed data</h4>

    <p class="text-gray-300">A commonly used heuristic for eliminating interaction in interactive proofs is the Fiat-Shamir transform <em>[61]</em>. Analyzed in the random oracle model (ROM), this transform applies to <em>public-coin</em> protocols and proceeds as follows: whenever the protocol generates a random challenge, the prover generates this challenge on its own by applying a random oracle <span class="math">H</span> to the concatenation of the input <span class="math">x</span> and the communication transcript up to this point. The Fiat-Shamir transform can be applied for converting PCPs and IOPs into succinct non-interactive argument system for NP <em>[23, 97]</em>.</p>

    <p class="text-gray-300">Applying the Fiat-Shamir transform in our distributed setting poses the following difficulty. While the random challenges <span class="math">r_{i}</span> are indeed public, both the input and the communication transcript are distributed and cannot be revealed to any single verifier. To get around this difficulty, we generate each random challenge <span class="math">r_{i}</span> based on the <em>joint</em> view of the verifiers in previous rounds. Another advantage of the resulting protocol, other than minimizing round complexity, is that it no longer needs to rely on a coin-tossing oracle <span class="math">\\mathcal{F}_{\\mathsf{coin}}</span> (or an interactive protocol that emulates it).</p>

    <p class="text-gray-300">Our distributed variant of the Fiat-Shamir transform, when applied to the distributed zero-knowledge protocol of Theorem 6.6, proceeds as follows. The prover derives each random challenge <span class="math">r_{i}</span> as the hash of <span class="math">k</span> random challenges <span class="math">r_{ij}</span>, where <span class="math">r_{ij}</span> is obtained by hashing the view of <span class="math">V_{j}</span> up to this point. Concretely, let <span class="math">H:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span> be a random hash function, where <span class="math">\\lambda</span> is a security parameter. For each round <span class="math">i=1,2,\\ldots,\\rho</span> and verifier index <span class="math">1\\leq j\\leq k</span>, the prover <span class="math">P</span> computes <span class="math">r_{ij}\\leftarrow H(i,j,x^{(j)},\\nu_{ij},\\pi_{ij})</span>, where <span class="math">\\nu_{ij}\\in_{R}\\{0,1\\}^{\\lambda}</span> is a random blinding value chosen by the prover, and then lets <span class="math">r_{i}\\leftarrow H(i,\\bot,r_{i1},\\ldots,r_{ik})</span>. The blinding values <span class="math">\\nu_{ij}</span> are used to ensure that the hashes <span class="math">r_{ij}</span> leak no information about <span class="math">\\pi_{ij}</span>.</p>

    <p class="text-gray-300">The verifiers can deterministically replay this process as long as the prover sends to each <span class="math">V_{j}</span> the blinding values <span class="math">(\\nu_{1j},\\ldots,\\nu_{\\rho j})</span> it used to generate the responses. Concretely, the verifiers exchange all information distributed by the prover <em>except</em> the proof shares <span class="math">\\pi_{i}</span>. Instead of these proof shares, the verifiers exchange the corresponding answer shares. They check that all information provided by the prover is consistent with their local views (where the proof shares are used to check the correctness of the random challenges <span class="math">r_{ij}</span>) and then accept or reject based on the random challenges <span class="math">r_{i}</span> and the</p>

    <p class="text-gray-300">reconstructed answers.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">6.3 Setting II: Malicious Prover and Verifiers</h3>

    <p class="text-gray-300">In the second and most stringent adversarial setting we consider, a possibly malicious prover may collude with a subset of malicious verifiers. In addition to the requirements from the previous setting, we must now further address the possibility of a false statement being wrongfully accepted due to the actions of malicious verifiers. Note that we do not consider here robustness of the completeness property when the prover is honest but some verifiers may be malicious. This stronger requirement can be realized in some settings, but is not useful for our main motivating applications.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition 6.8 (Zero-knowledge proofs on distributed data: malicious prover and verifiers).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}(x,w)</span> be a <span class="math">k</span>-distributed relation over finite field <span class="math">\\mathbb{F}</span>. We say that a <span class="math">k</span>-verifier interactive proof protocol <span class="math">\\Pi=(P,V_{1},\\ldots,V_{k})</span> is a distributed strong zero-knowledge proof protocol for <span class="math">\\mathcal{R}</span> with <span class="math">t</span>-security against malicious prover and malicious verifiers, and with soundness error <span class="math">\\epsilon</span>, if <span class="math">\\Pi</span> satisfies the Completeness and Strong Zero Knowledge properties as in Definition 6.4, as well as the following soundness property:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness against prover and <span class="math">t-1</span> verifiers. For every <span class="math">T\\subseteq[k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t-1<span class="math">, a malicious adversary </span>A<span class="math"> controlling the prover </span>P<span class="math"> and verifiers </span>\\{V_{j}\\}_{j\\in T}<span class="math">, </span>k<span class="math">-distributed input </span>x=(x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)})<span class="math"> and witness </span>w<span class="math">, the following holds. If there is no </span>k<span class="math">-distributed input </span>x^{\\prime}\\in\\mathcal{L}(\\mathcal{R})<span class="math"> such that </span>x^{\\prime}_{H}=x_{H}<span class="math">, where </span>H=[k]\\setminus T<span class="math">, the execution of </span>\\Pi^{<em>}(x,w)<span class="math"> rejects except with at most </span>\\epsilon<span class="math"> probability, where here </span>\\Pi^{</em>}<span class="math"> denotes the interaction of </span>A$ with the honest verifiers.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">6.3.1 General feasibility</h4>

    <p class="text-gray-300">We start by addressing the general feasibility question for arbitrary distributed relations. A first observation is that if we make no succinctness requirements, namely we allow the communication complexity to grow polynomially with the size of <span class="math">x</span> and <span class="math">w</span>, then Definition 6.8 can be efficiently realized with <span class="math">t&lt;k/2</span> for arbitrary NP-relations by using general-purpose MPC protocols in the information-theoretic setting <em>[107]</em>.</p>

    <p class="text-gray-300">The main downside of the above approach is that its communication complexity grows linearly with the size of the verification circuit. From here on, we focus on the goal of sublinear-communication proofs. For simplicity, we will consider the case of distributed languages <span class="math">\\mathcal{L}</span> (i.e., deterministic relations in which the witness <span class="math">w</span> is empty), and will be mainly interested in “simple” distributed languages whose non-distributed versions admit fully linear proof system with sublinear proof length.</p>

    <p class="text-gray-300">Our next observation is that membership testing in <span class="math">\\mathcal{L}</span> with security against malicious prover and verifiers can be reduced to the easier case of a malicious prover or verifiers (Theorem 6.6) by running an independent instance of the protocol with every potential set <span class="math">H</span> of <span class="math">k-t+1</span> honest verifiers, where each instance applies to the natural restriction of <span class="math">\\mathcal{L}</span> to <span class="math">H</span> defined below.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 6.9 (Restriction of a distributed language).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a <span class="math">k</span>-distributed language <span class="math">\\mathcal{L}</span> and set <span class="math">H\\subseteq[k]</span>, define the restricted language $\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> to be the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-distributed language defined by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}=\\{x_{H}\\,:\\,x\\in\\mathcal{L}\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, let <span class="math">\\mathcal{L}</span> be an arbitrary <span class="math">k</span>-distributed language, <span class="math">1\\leq t&lt;k</span> be a security threshold, and <span class="math">h=k-t+1</span>. For each <span class="math">H\\subseteq[k]</span> of size <span class="math">h</span>, let <span class="math">\\Pi_{H}</span> be a protocol for <span class="math">\\mathcal{L}_{H}</span> with security against malicious prover or <span class="math">t</span> malicious verifiers, as per Definition 6.4. We describe a distributed zero-knowledge protocol <span class="math">\\Pi</span> for <span class="math">\\mathcal{L}</span> that has <span class="math">t</span>-security against malicious prover and verifiers whenever <span class="math">k\\geq 2t</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Protocol II:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: The prover <span class="math">P</span> has a distributed input <span class="math">x\\in\\mathbb{F}^{n}</span>. Each verifier <span class="math">V_{j}</span>, <span class="math">1\\leq j\\leq k</span>, has an input piece <span class="math">x^{(j)}\\in\\mathbb{F}^{n_{j}}</span>.</li>

      <li>Interaction:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For each <span class="math">H\\subseteq[k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq h<span class="math">, the prover </span>P<span class="math"> interacts with verifiers </span>V_{j}<span class="math">, </span>j\\in H<span class="math">, using the protocol </span>\\Pi_{H}<span class="math"> to prove membership of </span>x_{H}<span class="math"> in </span>\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If any of these interactions rejects, the verifiers in <span class="math">H</span> broadcast a complaint.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs: Each verifier <span class="math">V_{j}</span> accepts if no verifier broadcasted a complaint.</li>

    </ul>

    <p class="text-gray-300">The security of the protocol <span class="math">\\Pi</span> depends on the assumption that instances of <span class="math">\\Pi_{H}</span> <em>compose,</em> in the sense they can be simulated jointly and the soundness guarantee of each protocol holds regardless of other executions. While our definitions guarantee composition in this weak sense when allowing computationally unbounded simulation (also known as <em>witness indistinguishability</em>), this may not be the case in the computational setting when simulation should be done in probabilistic polynomial time (cf. <em>[70]</em>, Section 4.3.3). However, a mild strengthening of Definition 6.4 that incorporates auxiliary inputs generically supports <em>sequential</em> composition (i.e., when different instances of <span class="math">\\Pi_{H}</span> are executed one after another). Moreover, natural protocols in the information-theoretic setting, including all protocols obtained in this work (in particular, those obtained via Theorem 6.6 and Corollary 6.7) also compose when executed <em>in parallel</em>. From here on we assume that the protocols <span class="math">\\Pi_{H}</span> compose in the above sense.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Theorem 6.10 (Zero-knowledge proof on distributed data: malicious prover <em>and</em> verifiers).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{L}</span> be a <span class="math">k</span>-distributed language, <span class="math">t\\geq 1</span> be a security threshold such that <span class="math">k\\geq 2t</span>, and <span class="math">h=k-t+1</span>. For each <span class="math">H\\subseteq[k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq h<span class="math">, let </span>\\Pi_{H}<span class="math"> be a protocol for </span>\\mathcal{L}_{H}<span class="math"> with (composable) security against malicious prover or </span>t<span class="math"> malicious verifiers, as per Definition 6.4. Then the protocol </span>\\Pi<span class="math"> described above is a distributed strong zero-knowledge protocol for </span>\\mathcal{L}<span class="math"> with </span>t<span class="math">-security against malicious prover and verifiers, and with soundness error </span>\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The completeness of <span class="math">\\Pi</span> follows from the completeness of the protocols <span class="math">\\Pi_{H}</span> and the fact that if <span class="math">x\\in\\mathcal{L}</span> then $x_{H}\\in\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> for all </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The strong zero knowledge of <span class="math">\\Pi</span> follows from the fact that <span class="math">h&gt;t</span>. Indeed, it follows from this fact that for any set <span class="math">T\\subseteq[k]</span> of <span class="math">t</span> malicious verifiers and every set <span class="math">H</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq h<span class="math"> there are at most </span>t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> malicious verifiers in the execution of </span>\\Pi_{H}<span class="math"> and hence, by the strong HVZK of </span>\\Pi_{H}<span class="math">, their view can be perfectly simulated given their inputs. (Here we rely on the composition assumption that different instances of </span>\\Pi_{H}$ involving overlapping sets of verifiers can be simulated jointly.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, the soundness of <span class="math">\\Pi</span> is argued as follows. Let <span class="math">T\\subseteq[k]</span> be a set of corrupted verifiers of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t-1<span class="math">, and let </span>A<span class="math"> be a malicious adversary controlling the prover </span>P<span class="math"> and verifiers </span>\\{V_{j}\\}_{j\\in T}<span class="math">. Suppose </span>x=(x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k)})<span class="math"> is a </span>k<span class="math">-distributed input for which there is no </span>x^{\\prime}\\in\\mathcal{L}<span class="math"> such that </span>x^{\\prime}_{H}=x_{H}<span class="math">, where </span>H=[k]\\setminus T<span class="math">. Then, since </span>x_{H}\\not\\in\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">, the soundness of </span>\\Pi_{H}<span class="math"> implies that in the execution of </span>\\Pi_{H}<span class="math"> on </span>x_{H}<span class="math"> the honest provers will broadcast a complaint except with at most </span>\\epsilon<span class="math"> probability. It follows that the execution of </span>\\Pi<span class="math"> on </span>x<span class="math"> in the presence of </span>A<span class="math"> will reject except with at most </span>\\epsilon$ probability, as required by Definition 6.8. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above protocol <span class="math">\\Pi</span> has two limitations. First, its complexity may grow exponentially with the number of verifiers <span class="math">k</span>. This overhead is arguably tolerable when <span class="math">k</span> is small and when the communication complexity of each <span class="math">\\Pi_{H}</span> is sublinear in the input length <span class="math">n</span>. Second, and perhaps more importantly, even if <span class="math">\\mathcal{L}</span> is “simple” (e.g., can be verified by low-degree equations), its restricted languages $\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}$ may be complex. In the following we show that the latter limitation is in a sense</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">inherent, and show how to get around both limitations by restricting the attention to distributed languages <span class="math">\\mathcal{L}</span> that are in some sense <em>robust</em>.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">6.3.2 A negative result</h4>

    <p class="text-gray-300">Recall that we are interested in protocols for simple distributed languages <span class="math">\\mathcal{L}</span> (i.e., deterministic relations in which the witness <span class="math">w</span> is empty) whose communication complexity is sublinear in the input size. We show that even for simple distributed languages for which we have sublinear-communication zero-knowledge protocols in the case of malicious prover <em>or <span class="math">t</span></em> malicious verifiers (cf. Corollary 6.7), similar protocols are unlikely to exist when a malicious prover can collude with (even a single) malicious verifier. The high level idea is that such a strong distributed proof system for <span class="math">\\mathcal{L}</span> can be turned into standard (single-verifier) interactive proof systems for a related <em>non-deterministic</em> relation <span class="math">\\mathcal{R}</span>, where the witness in <span class="math">\\mathcal{R}</span> is one of the input pieces in <span class="math">\\mathcal{L}</span>. It will then follow from negative results on laconic proof systems for NP <em>[73]</em> that there are some simple languages <span class="math">\\mathcal{L}</span> which separate between the two settings. In other words, there exist distributed languages <span class="math">\\mathcal{L}</span> that admit succinct proof protocols on distributed data in Setting I (malicious prover <em>or</em> verifiers), but do not admit similar protocols in in Setting II (malicious prover <em>and</em> verifiers) under standard complexity theoretic assumptions.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Claim 6.11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{L}</span> be a <span class="math">k</span>-distributed language over <span class="math">\\mathbb{F}</span>, consisting of distributed inputs $x=(x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">~{}x^{(k)})\\in\\mathbb{F}^{n}<span class="math">. Let </span>\\Pi=(P,V_{1},\\ldots,V_{k})<span class="math"> be a distributed proof protocol for </span>\\mathcal{L}<span class="math"> (without zero-knowledge) with soundness error </span>\\epsilon<span class="math"> against a malicious adversary </span>A<span class="math"> controlling </span>P<span class="math"> and </span>V_{k}<span class="math">. Let </span>\\mathcal{R}<span class="math"> be a (non-distributed) NP-relation defined by </span>\\mathcal{R}((x^{(1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(2)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{(k-1)}),x^{(k)})=\\mathcal{L}(x)<span class="math">. Then there exists a two-party interactive proof protocol </span>\\Pi_{\\mathsf{dist}}=(P^{\\prime},V^{\\prime})<span class="math"> for </span>\\mathcal{R}<span class="math">, where the communication and computation costs of </span>\\Pi_{\\mathsf{dist}}<span class="math"> are bounded by those of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The protocol <span class="math">\\Pi_{\\mathsf{dist}}</span> is obtained by letting <span class="math">V^{\\prime}</span> emulate the roles of verifiers <span class="math">V_{1},\\ldots,V_{k-1}</span> in <span class="math">\\Pi</span> and <span class="math">P^{\\prime}</span> emulate the roles <span class="math">P</span> and <span class="math">V_{k}</span> in <span class="math">\\Pi</span>. The output of <span class="math">V^{\\prime}</span> in <span class="math">\\Pi_{\\mathsf{dist}}</span> is the same as that of <span class="math">V_{1}</span> in <span class="math">\\Pi</span>. The soundness of <span class="math">\\Pi_{\\mathsf{dist}}</span> follows from the distributed soundness requirement (see Definition 6.8) by observing that for any malicious prover <span class="math">P^{\\prime}</span> in <span class="math">\\Pi_{\\mathsf{dist}}</span> there is a corresponding malicious adversary <span class="math">A</span> attacking <span class="math">P</span> and <span class="math">V_{k}</span> in <span class="math">\\Pi</span> such that <span class="math">V^{\\prime}</span> accepts in <span class="math">\\Pi_{\\mathsf{dist}}</span> whenever <span class="math">V_{1}</span> accepts in <span class="math">\\Pi</span>. ∎</p>

    <p class="text-gray-300">Now, consider a deterministic degree-3 <span class="math">k</span>-distributed language <span class="math">\\mathcal{L}</span> in which the first input piece <span class="math">x^{(1)}</span> defines a set <span class="math">Q</span> of <span class="math">m</span> degree-2 equations in variables <span class="math">X_{1},\\ldots,X_{\\ell}</span>, the last input piece <span class="math">x^{(k)}\\in\\mathbb{F}^{\\ell}</span> defines an assignment to these variables, and <span class="math">\\mathcal{L}(x)</span> holds if <span class="math">Q(X)=0^{m}</span>. While Corollary 6.7 implies a computationally efficient, sublinear-communication protocol for <span class="math">\\mathcal{L}</span> in the presence of malicious prover <em>or <span class="math">t=k-1</span></em> verifiers, it follows from Claim 6.11 and <em>[73]</em> that obtaining a similar protocol for the case of malicious prover <em>and</em> (even a single) malicious verifier is unlikely.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">6.3.3 Efficient protocols over linearly encoded inputs</h4>

    <p class="text-gray-300">To get around the previous impossibility, we restrict the attention to relations for which the distributed input <span class="math">x</span> is <em>encoded</em> in a way that the pieces held by the honest verifiers determine the entire input. (This encoding will typically be produced by an underlying linear secret-sharing scheme; however, our protocols do not make any assumption about the distribution from which this encoding is picked.) We will be mainly interested in robust linear encodings in which for each piece <span class="math">x^{(j)}</span> of <span class="math">x</span> and each set <span class="math">H</span> of honest parties, <span class="math">x^{(j)}</span> can be obtained by applying a linear function to the pieces of <span class="math">H</span>. We capture this by the notion of a <em>distributed linear code</em> (DLC) <em>[52]</em>, defined below.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 6.12 (Distributed linear code (DLC)).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}\\subseteq\\mathbb{F}^{K}</span> be a <span class="math">k</span>-distributed language over <span class="math">\\mathbb{F}</span>. We say that <span class="math">\\mathcal{C}</span> is a <em><span class="math">k</span>-distributed linear code</em> (or <span class="math">k</span>-DLC) over <span class="math">\\mathbb{F}</span> if it is closed under (piecewise) addition and scalar multiplication over <span class="math">\\mathbb{F}</span>. We say that <span class="math">\\mathcal{C}</span> has minimal distance (at least) <span class="math">d</span> if for every <span class="math">u,v\\in\\mathcal{C}</span>, there are at most <span class="math">d</span> pieces <span class="math">j\\in[k]</span> such that <span class="math">u^{(j)}\\neq v^{(j)}</span>. We associate with <span class="math">\\mathcal{C}</span> the assignment of the input coordinates in <span class="math">[K]</span> to verifiers in <span class="math">[k]</span> and make it implicit in the notation. By default, we will let <span class="math">K=k</span> and assign the <span class="math">i</span>-th entry of each codeword to <span class="math">V_{i}</span>.</p>

    <p class="text-gray-300">As noted above, we will typically use a distributed codeword of a DLC to capture a vector of shares in a linear secret-sharing scheme, such as Shamir’s scheme. In this case, we associate with each <span class="math">c\\in\\mathcal{C}</span> a corresponding message <span class="math">s\\in\\mathbb{F}</span> (a “secret”), defined by a linear decoder <span class="math">D:\\mathbb{F}^{K}\\to\\mathbb{F}</span>. Note that the same message <span class="math">s</span> will typically have many different codewords. Given <span class="math">\\mathcal{C},D</span>, we let <span class="math">[s]_{\\mathcal{C},D}</span>, or just <span class="math">[s]</span> when there is no ambiguity, denote the set of codewords that decode to <span class="math">s</span>. We say that <span class="math">\\mathcal{C},D</span> is <span class="math">t</span>-private if any <span class="math">t</span> pieces in a randomly chosen <span class="math">\\hat{s}\\in_{R}[s]</span> hide <span class="math">s</span>. One can naturally extend the above to a linear decoder <span class="math">D:\\mathbb{F}^{K}\\to\\mathbb{F}^{\\ell}</span>, which outputs multiple field elements. This is useful to capture the case of <em>packed</em> secret sharing <em>[64]</em>, which which can be used for batch-verification of <span class="math">\\ell</span> statements. The results of this section extend naturally to this more general case. The above discussion is formalized below.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 6.13 (Decoding, encoding, and <span class="math">t</span>-privacy).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}\\subseteq\\mathbb{F}^{K}</span> be a <span class="math">k</span>-DLC over <span class="math">\\mathbb{F}</span> and let <span class="math">D:\\mathbb{F}^{K}\\to\\mathbb{F}</span> be a linear decoder. For <span class="math">s\\in\\mathbb{F}</span>, we define the set of valid encodings of <span class="math">s</span> to be <span class="math">[s]_{\\mathcal{C},D}=\\{\\hat{s}\\in\\mathcal{C}\\,:\\,D(\\hat{s})=s\\}</span>. We will omit the <span class="math">\\mathcal{C},D</span> subscripts when they are clear from the context. We say that the randomized encoding scheme defined by <span class="math">(\\mathcal{C},D)</span> is <em><span class="math">t</span>-private</em> if for any <span class="math">s,s^{\\prime}\\in\\mathbb{F}</span>, and any fixed <span class="math">T\\subset[k]</span> of size <span class="math">t</span>, the distributions <span class="math">S_{T}</span> and <span class="math">S^{\\prime}_{T}</span> are identical, where <span class="math">S</span> (resp., <span class="math">S^{\\prime}</span>) is distributed as a random encoding <span class="math">\\hat{s}\\in_{R}[s]</span> (resp., <span class="math">\\hat{s}^{\\prime}\\in_{R}[s^{\\prime}]</span>) and the subscript <span class="math">T</span> denotes restriction to pieces with indices in <span class="math">T</span>. Equivalently, <span class="math">t</span>-privacy can be defined by considering any generating matrix <span class="math">G\\in\\mathbb{F}^{M\\times K}</span> of <span class="math">\\mathcal{C}</span>. The randomized encoding scheme <span class="math">(\\mathcal{C},D)</span> is <span class="math">t</span>-private if the <span class="math">T</span>-columns of <span class="math">G</span> span the vector in <span class="math">\\mathbb{F}^{M}</span> obtained by applying <span class="math">D</span> to each row of <span class="math">G</span>.</p>

    <p class="text-gray-300">Locally encoded languages. Our first distributed zero-knowledge protocol applies to <em>locally encoded languages</em>, namely ones that separately encode each entry of an input <span class="math">x</span> in some (non-distributed) language <span class="math">\\mathcal{L}</span>. This special class of encoded languages is motivated by applications in which each entry of an input <span class="math">x</span> is individually encoded via some robust linear secret sharing scheme such as Shamir’s scheme. We denote the set of such possible encodings by <span class="math">[x]</span>. We denote by <span class="math">\\hat{\\mathcal{L}}</span> the encoded version of <span class="math">\\mathcal{L}</span>, namely the union of all <span class="math">[x]</span> with <span class="math">x\\in\\mathcal{L}</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 6.14 (Locally encoded language).</h6>

    <p class="text-gray-300">Let <span class="math">k,\\mathbb{F},\\mathcal{C},D</span> be as in Definition 6.13. Let <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> be a (non-distributed) language. Let <span class="math">\\hat{x}\\in\\mathbb{F}^{K\\times n}</span> be a <span class="math">k</span>-distributed matrix whose <span class="math">n</span> columns are all in <span class="math">\\mathcal{C}</span>. We extend <span class="math">D</span> to such matrices by letting <span class="math">D(\\hat{x})</span> be the vector <span class="math">x\\in\\mathbb{F}^{n}</span> defined by <span class="math">x_{j}=D(\\hat{x}_{j})</span>, where <span class="math">\\hat{x}_{j}</span> is the <span class="math">j</span>-th column of <span class="math">\\hat{x}</span>. Let <span class="math">[x]_{\\mathcal{C},D}=\\{\\hat{x}\\in\\mathbb{F}^{K\\times n}\\,:\\,D(\\hat{x})=x\\text{ and }\\hat{x}_{j}\\in\\mathcal{C}\\text{ for all }j\\ \\}</span>. Finally, define the (locally) encoded language <span class="math">\\hat{\\mathcal{L}}_{\\mathcal{C},D}=\\{\\hat{x}\\in\\mathbb{F}^{K\\times n}\\,:\\,\\hat{x}\\in[x]_{\\mathcal{C},D}\\text{ for some }x\\in\\mathcal{L}\\}</span>. We will omit the <span class="math">\\mathcal{C},D</span> subscripts when they are clear from the context.</p>

    <p class="text-gray-300">We now describe a distributed zero-knowledge protocol in Setting II for <span class="math">\\hat{\\mathcal{L}}_{\\mathcal{C},D}</span>, namely one whose soundness holds even if the prover can collude with up to <span class="math">t-1</span> verifiers. The high level idea is similar to the protocol for Setting I (Theorem 6.6), except that the prover distributes each entry in a proof <span class="math">\\pi</span> using the secret sharing scheme defined by <span class="math">(\\mathcal{C},D)</span>. Here we rely on the minimal distance of <span class="math">\\mathcal{C}</span> being at least <span class="math">t</span> to ensure that the answer pieces of <span class="math">k-t+1</span> honest verifiers are sufficient to determine the correct answers, and on the <span class="math">t</span>-privacy of <span class="math">(\\mathcal{C},D)</span> to ensure that any <span class="math">t</span> verifiers do not learn from their shares of <span class="math">\\pi</span> any information except the PCP answers.</p>

    <p class="text-gray-300">Formally, let <span class="math">\\mathcal{L} \\subseteq \\mathbb{F}^n</span> be a (non-distributed) language. Suppose <span class="math">\\Pi = (P_{\\mathrm{LIOP}}, V_{\\mathrm{LIOP}})</span> is a <span class="math">\\rho</span>-round public-coin fully linear IOP for <span class="math">\\mathcal{L}</span> with strong zero knowledge, soundness error <span class="math">\\epsilon</span>, proof length <span class="math">c = \\sum_{i=1}^{\\rho} c_i</span>, random challenges <span class="math">r_i \\in \\mathbb{F}^{b_i}</span>, and query complexity <span class="math">\\ell = \\sum_{i=1}^{\\rho} \\ell_i</span>. Let <span class="math">\\mathcal{C} \\subset \\mathbb{F}^K</span> be a <span class="math">k</span>-DLC over <span class="math">\\mathbb{F}</span> of minimal distance <span class="math">t</span> and let <span class="math">D: \\mathcal{C} \\to \\mathbb{F}</span> be a linear decoder such that the encoding scheme defined by <span class="math">(\\mathcal{C}, D)</span> is <span class="math">t</span>-private. We describe a distributed strong zero-knowledge proof protocol <span class="math">\\Pi_{\\mathrm{dist}} = (P, V_1, \\ldots, V_k)</span> for <span class="math">\\hat{\\mathcal{L}}_{\\mathcal{C}, D}</span> in the <span class="math">(\\mathcal{F}_{\\mathrm{coin}}, \\mathcal{F}_{\\mathrm{bcast}})</span>-hybrid model with <span class="math">t</span>-security against malicious prover and verifiers and the same soundness error. Unlike most of our proof systems, here we do not require the (honest) prover to know the full input <span class="math">X \\in \\hat{\\mathcal{L}}_{\\mathcal{C}, D}</span>, but rather only the instance <span class="math">x = D(X)</span> it encodes.</p>

    <p class="text-gray-300"><strong>Protocol <span class="math">\\Pi_{\\mathrm{dist}}</span></strong>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Parameters</strong>: A DLC <span class="math">\\mathcal{C}</span> and decoder <span class="math">D</span> such that <span class="math">\\mathcal{C}</span> has minimal distance <span class="math">t</span> and <span class="math">(\\mathcal{C}, D)</span> is <span class="math">t</span>-private.</li>

      <li><strong>Inputs</strong>: The distributed input is a matrix <span class="math">X \\in \\mathbb{F}^{K \\times n}</span>. Each verifier <span class="math">V_j</span>, <span class="math">1 \\leq j \\leq k</span>, has input piece <span class="math">X^{(j)}</span> consisting of one or more rows of <span class="math">X</span> (where the row assignment corresponds to the coordinate partition of <span class="math">\\mathcal{C}</span>). The prover <span class="math">P</span> knows <span class="math">x = D(X)</span>. (Presumably <span class="math">x \\in \\mathcal{L}</span> and <span class="math">X \\in [x]_{\\mathcal{C}, D}</span>.)</li>

      <li><strong>Interaction</strong>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <strong>(Testing membership in <span class="math">\\mathcal{C}</span>)</strong> Repeat $\\gamma = \\lceil \\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1 / \\epsilon) \\rceil$ times:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span> picks a random <span class="math">c \\in \\mathcal{C}</span> and sends to each <span class="math">V_j</span> its piece <span class="math">c^{(j)}</span>.</li>

      <li>The <span class="math">k</span> verifiers let <span class="math">r \\gets \\mathcal{F}_{\\mathrm{coin}}^{\\mathcal{S}}</span> for <span class="math">\\mathcal{S} = \\mathbb{F}^n</span>. (Alternatively, as in [52], <span class="math">r</span> can be deterministically generated from a shorter random vector via a small-bias generator over <span class="math">\\mathbb{F}</span>; this requires slightly increasing <span class="math">\\gamma</span>.)</li>

      <li>Each <span class="math">V_j</span> computes its share <span class="math">y_j</span> of <span class="math">X \\cdot r + c</span> and sends <span class="math">y_j</span> to the other verifiers.</li>

      <li>Each <span class="math">V_j</span> checks that the <span class="math">k</span> shares <span class="math">(y_1, \\ldots, y_k)</span> are in <span class="math">\\mathcal{C}</span>, and otherwise broadcasts a complaint. If any verifier broadcasts a complaint, all verifiers reject.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>(Emulating <span class="math">\\Pi</span>)</strong> For <span class="math">i = 1, 2, \\ldots, \\rho</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i = 1</span>, <span class="math">P</span> lets <span class="math">(\\pi_1, \\mathsf{st}_1^P) \\gets P_{\\mathrm{LIOP}}(x, \\bot)</span>, else it lets <span class="math">(\\pi_i, \\mathsf{st}_i^P) \\gets P_{\\mathrm{LIOP}}(\\mathsf{st}_{i-1}^P, r_{i-1})</span>, where <span class="math">\\pi_i \\in \\mathbb{F}^{\\mu_i}</span>.</li>

      <li><span class="math">P</span> secret-shares <span class="math">\\pi_i</span> using <span class="math">(\\mathcal{C}, D)</span> by picking a random matrix <span class="math">\\hat{\\pi}_i \\in \\mathbb{F}^{K \\times \\mu_i}</span> uniformly at random from <span class="math">[\\pi_i]</span>, and sends proof shares <span class="math">\\hat{\\pi}_{ij}</span> to <span class="math">V_j</span> consisting of the rows of <span class="math">\\hat{\\pi}_i</span> assigned to <span class="math">V_j</span>;</li>

      <li>The <span class="math">k + 1</span> parties invoke <span class="math">r_i \\gets \\mathcal{F}_{\\mathrm{coin}}^{\\mathcal{S}}</span> for <span class="math">\\mathcal{S} = \\mathbb{F}^{b_i}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- All <span class="math">k</span> verifiers let <span class="math">(q_{i,1},\\ldots ,q_{i,\\ell_i})</span> be the query vectors determined by <span class="math">r_1,\\dots ,r_i</span>, where <span class="math">q_{i,\\alpha}\\in \\mathbb{F}^{n + \\mu_i}</span> for <span class="math">1\\leq \\alpha \\leq \\ell_{i}</span>. The verifiers locally compute their entries of $a_{i,1} = (X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi})\\cdot q_{i,1},\\ldots ,a_{i,\\ell_i} = (X\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi})\\cdot q_{i,\\ell_i}<span class="math">. Let </span>a_{i,\\alpha ,j}<span class="math"> denote the answer shares of </span>V_{j}<span class="math"> for </span>1\\leq \\alpha \\leq \\ell_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each verifier <span class="math">V_j</span> sends to all other verifiers the <span class="math">\\ell_i</span> answer shares <span class="math">a_{i,\\alpha,j}</span>, for <span class="math">1 \\leq \\alpha \\leq \\ell_i</span>. It then checks that the <span class="math">k</span> answer shares <span class="math">(a_{i,\\alpha,1}, \\ldots, a_{i,\\alpha,k})</span> are in <span class="math">\\mathcal{C}</span>, and otherwise broadcasts a complaint. It reconstructs an answer <span class="math">a_{i,\\alpha} = D(a_{i,\\alpha,1}, \\ldots, a_{i,\\alpha,k})</span> for <span class="math">1 \\leq \\alpha \\leq \\ell_i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Outputs</strong>: Each verifier <span class="math">V_j</span> computes its output as follows. If any verifier broadcasted a complaint, it rejects. Otherwise, it applies the decision predicate of <span class="math">V_{\\mathrm{LIOP}}</span> to the random challenges <span class="math">r_1, \\ldots, r_\\rho</span> and the answers <span class="math">a_{i,\\alpha}</span>, and accepts or rejects accordingly.</li>

    </ul>

    <p class="text-gray-300">40</p>

    <p class="text-gray-300">As before, we can minimize round complexity by checking membership in <span class="math">\\mathcal{C}</span> in parallel to simulating <span class="math">\\Pi</span>, and can combine the verifier messages of round <span class="math">i</span> with the prover messages of round <span class="math">i + 1</span>. This gives an implementation with <span class="math">\\rho + 1</span> point-to-point rounds (involving messages from <span class="math">P</span> to each verifier) and a single broadcast round (for possible complaints). Note that unlike the protocol from Theorem 6.6 (for the case of malicious prover or verifiers), here we cannot use <span class="math">V_{1}</span> alone for recovering the PCP answers, since this would violate soundness in case <span class="math">V_{1}</span> is corrupted.</p>

    <p class="text-gray-300">Before formally proving the soundness and zero-knowledge properties of <span class="math">\\Pi_{\\mathrm{dist}}</span>, we provide some intuition. The protocol <span class="math">\\Pi_{\\mathrm{dist}}</span> is sound against the prover together with <span class="math">t - 1</span> malicious verifiers for the following reason. The code membership testing via random linear combination ensures that the rows of <span class="math">X</span> held by the honest verifiers are a valid <span class="math">(\\mathcal{C}, D)</span>-encoding of an input <span class="math">x \\in \\mathbb{F}^n</span>, except with at most <span class="math">\\epsilon</span> probability.³ The fact that <span class="math">\\mathcal{C}</span> has minimal distance at least <span class="math">t</span> ensures that there is an alternative linear decoding function <span class="math">D&#x27;</span> that depends only on the input pieces of honest verifiers and agrees with <span class="math">D</span> on all valid codewords. Thus, <span class="math">D&#x27;</span> defines an input <span class="math">x</span> and proofs <span class="math">\\pi_i</span> such that if the shares of the answers are consistent with <span class="math">\\mathcal{C}</span>, they must be consistent with the answers of <span class="math">\\Pi</span> on input <span class="math">x</span>, proofs <span class="math">\\pi_i</span> and the queries <span class="math">q_{i,\\alpha}</span>.</p>

    <p class="text-gray-300">The zero knowledge property of <span class="math">\\Pi_{\\mathrm{dist}}</span> follows from the following observations. Recall that we consider here the case where the prover <span class="math">P</span> is honest but there is a set <span class="math">T</span> of <span class="math">t</span> malicious verifiers. First, the masking of the initial membership test in <span class="math">\\mathcal{C}</span> by a random codeword guarantees that the test is zero knowledge. For the simulation of <span class="math">\\Pi</span>, the minimal distance property of <span class="math">\\mathcal{C}</span> guarantees that (since <span class="math">P</span> is honest) the answer shares of the honest verifiers are consistent with a unique codeword. Thus, if a malicious verifier <span class="math">V_j</span> sends an incorrect answer share to an honest verifier <span class="math">V_h</span>, this will necessarily lead to <span class="math">V_h</span> broadcasting a (predictable) complaint. This effectively restricts verifiers in <span class="math">T</span> to be honest. In this case, zero knowledge follows from the fact that when the PCP queries (restricted to the proof component) are linearly independent, the answer shares are fresh independent encodings of the PCP answers. Moreover, the same holds even when conditioned on the proof shares of a set <span class="math">T</span> of <span class="math">t</span> verifiers. This is formalized by the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 6.15.</strong> Let <span class="math">(\\mathcal{C}, D)</span> be a <span class="math">t</span>-private encoding as in Definition 6.13 and let <span class="math">T \\subset [k]</span> be a set of size <span class="math">t</span>. Let <span class="math">x \\in \\mathbb{F}^n</span> and <span class="math">\\pi \\in \\mathbb{F}^\\mu</span>. Let <span class="math">\\hat{x} \\in <a href="=[x]_{\\mathcal{C},D}">x</a></span> be some fixed encoding of <span class="math">x</span>, where <span class="math">\\hat{x} \\in \\mathbb{F}^{K \\times n}</span>. Let <span class="math">Q \\in \\mathbb{F}^{(n + \\mu) \\times \\ell}</span> be a matrix, and let <span class="math">Q&#x27;</span> be the sub-matrix consisting of the last <span class="math">\\mu</span> rows of <span class="math">Q</span>. If <span class="math">\\text{rank}(Q&#x27;) = \\ell</span> then the following two distributions are identical:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Real: <span class="math">(\\hat{\\pi}_T, \\hat{a})</span>, where <span class="math">\\hat{\\pi} \\in \\mathbb{F}^{K \\times \\mu}</span> is picked at random from <span class="math">[\\pi]</span> and $\\hat{a} = (\\hat{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi}) \\cdot Q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> The <span class="math">t</span>-privacy of <span class="math">(\\mathcal{C}, D)</span> implies that <span class="math">\\hat{\\pi}_T</span> and <span class="math">\\hat{\\pi}_T&#x27;</span> are identically distributed. It remains to show that the distribution <span class="math">R_\\alpha</span> of <span class="math">\\text{Real}</span> conditioned on <span class="math">\\hat{\\pi}_T = \\alpha</span> is identical to the distribution <span class="math">I_\\alpha</span> of <span class="math">\\text{Ideal}</span> conditioned on <span class="math">\\hat{\\pi}_T&#x27; = \\alpha</span>. By linearity of <span class="math">(\\mathcal{C}, D)</span>, the output of $\\hat{a} = (\\hat{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi}) \\cdot Q<span class="math"> must be in </span>[a]<span class="math">. Moreover, conditioned on </span>\\alpha<span class="math"> we have </span>\\hat{a}_T = \\hat{a}_T' = \\beta<span class="math"> for </span>\\beta = (\\hat{x}_T \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha) \\cdot Q<span class="math">. Note that </span>I_\\alpha<span class="math"> is uniformly distributed over </span>\\{\\hat{a} \\in [a] : \\hat{a}_T = \\beta\\}<span class="math">, and the support of </span>R_\\alpha<span class="math"> is contained in the same set. It remains to show that </span>R_\\alpha<span class="math"> is also uniformly distributed over this set. Let </span>\\hat{a}, \\hat{a}' \\in [a]<span class="math"> such that </span>\\hat{a}_T = \\hat{a}_T' = \\beta<span class="math">. We show a bijection mapping any encodings </span>\\hat{\\pi}<span class="math"> of </span>\\pi<span class="math"> such that </span>\\hat{\\pi}_T = \\alpha<span class="math"> and </span>(\\hat{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi}) \\cdot Q = \\hat{a}<span class="math"> to another encoding </span>\\hat{\\pi}'<span class="math"> of </span>\\pi<span class="math"> such that </span>\\hat{\\pi}_T' = \\alpha<span class="math"> and </span>(\\hat{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat{\\pi}') \\cdot Q = \\hat{a}'<span class="math">. Let </span>\\hat{z} = \\hat{a}' - \\hat{a} \\in \\mathbb{F}^{K \\times \\ell}<span class="math"> and let </span>A<span class="math"> be an invertible </span>\\ell \\times \\ell<span class="math"> sub-matrix consisting of distinct rows of </span>Q'<span class="math"> (such </span>A<span class="math"> exists since </span>\\text{rank}(Q') = \\ell<span class="math">). We show a mapping </span>\\chi<span class="math"> that maps any </span>\\hat{\\pi}<span class="math"> leading to </span>\\hat{a}<span class="math"> into </span>\\hat{\\pi}'<span class="math"> leading to </span>\\hat{a}'<span class="math"> by changing the columns of </span>\\hat{\\pi}$ corresponding to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">³This type of test is standard in the MPC literature; see, e.g., [52]. Note that here we only consider soundness against a non-adaptive adversary who picks the set of corrupted verifiers before the random challenge is known; see [2] for a concrete soundness analysis of a similar test in the presence of adaptive corruptions.</p>

    <p class="text-gray-300">the rows of <span class="math">A</span> in <span class="math">Q</span>. (By symmetry, <span class="math">\\chi</span> is invertible and hence injective.) Letting <span class="math">\\hat{z}^{\\prime}=\\hat{z}\\cdot A^{-1}</span>, we have <span class="math">\\hat{z}^{\\prime}\\cdot A=\\hat{z}</span>, and so the bijection <span class="math">\\chi</span> that adds <span class="math">\\hat{z}^{\\prime}</span> to the <span class="math">A</span>-columns of <span class="math">\\hat{\\pi}</span> yields <span class="math">\\hat{\\pi}^{\\prime}</span> as required. ∎</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 6.16 (Zero-knowledge proof for locally encoded languages: malicious prover <em>and</em> verifiers).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> be a (non-distributed) language. Suppose <span class="math">\\Pi=(P_{\\textsf{LIOP}},V_{\\textsf{LIOP}})</span> is a <span class="math">\\rho</span>-round public-coin fully linear IOP for <span class="math">\\mathcal{L}</span> with soundness error <span class="math">\\epsilon</span> and strong HVZK. Let <span class="math">\\mathcal{C}\\subset\\mathbb{F}^{K}</span> be a <span class="math">k</span>-DLC over <span class="math">\\mathbb{F}</span> of minimal distance <span class="math">t</span> and let <span class="math">D:\\mathcal{C}\\to\\mathbb{F}</span> be a linear decoding function such that the encoding scheme defined by <span class="math">(\\mathcal{C},D)</span> is <span class="math">t</span>-private. Then, the protocol <span class="math">\\Pi_{\\textsf{dist}}=(P,V_{1},\\ldots,V_{k})</span> described above is a distributed strong zero-knowledge proof protocol for <span class="math">\\hat{\\mathcal{L}}_{\\mathcal{C},D}</span> in the <span class="math">(\\mathcal{F}_{\\textsf{coin}},\\mathcal{F}_{\\textsf{bcast}})</span>-hybrid model with <span class="math">t</span>-security against malicious prover and verifiers, and with soundness error <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof of Theorem 6.16.</h6>

    <p class="text-gray-300">We separately argue completeness, soundness, and zero knowledge.</p>

    <p class="text-gray-300">Completeness. Follows easily from the completeness of <span class="math">\\Pi</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Here we assume that a malicious adversary <span class="math">A</span> corrupts <span class="math">P</span> together with <span class="math">t-1</span> verifiers <span class="math">V_{j}</span>, <span class="math">j\\in T</span>. Let <span class="math">H=[k]\\setminus T</span>, and consider a distributed input <span class="math">X</span> for which there is no <span class="math">X^{\\prime}\\in\\hat{\\mathcal{L}}_{\\mathcal{C},D}</span> such that <span class="math">X^{\\prime}_{H}=X_{H}</span>. We argue that when <span class="math">A</span> interacts with the honest verifiers in <span class="math">\\Pi_{\\textsf{dist}}</span> on input <span class="math">X</span>, all honest verifiers reject except with at most <span class="math">\\epsilon</span> probability. Consider two cases. (1) There is no <span class="math">X^{\\prime}\\in\\mathcal{C}</span> such that <span class="math">X^{\\prime}_{H}=X_{H}</span>. In this case, the membership testing phase will lead the honest verifiers to reject except with at most <span class="math">\\epsilon</span> probability. This follows from the fact that each atomic random linear combination test will detect non-membership except with $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> probability (see, e.g., proof of Lemma 2 from <em>[52]</em>) and from the choice of </span>\\gamma<span class="math">. (2) There is </span>X^{\\prime}\\in\\mathcal{C}<span class="math">, where </span>X^{\\prime}\\in[x]_{\\mathcal{C},D}<span class="math">, such that </span>X^{\\prime}_{H}=X_{H}<span class="math"> but </span>x\\not\\in\\mathcal{L}<span class="math">. Since </span>\\mathcal{C}<span class="math"> is linear and has minimal distance </span>t<span class="math">, we can define an alternative linear decoding function </span>D^{\\prime}<span class="math"> that depends only on pieces of verifiers in </span>H<span class="math"> and agrees with </span>D<span class="math"> on all distributed codewords in </span>\\mathcal{C}<span class="math">. In particular, </span>D^{\\prime}(X^{\\prime})=x<span class="math">. Thus, for any (malformed) proofs shares </span>\\hat{\\pi}_{i}^{<em>}<span class="math"> distributed by </span>A<span class="math">, the decoder </span>D^{\\prime}<span class="math"> defines effective proof vectors </span>\\pi_{i}^{</em>}\\in\\mathbb{F}^{n}<span class="math">, such that if the answer shares </span>(a_{i,\\alpha,1},\\ldots,a_{i,\\alpha,k})<span class="math"> are in </span>\\mathcal{C}<span class="math"> then we have </span>D^{\\prime}(a_{i,\\alpha,1},\\ldots,a_{i,\\alpha,k})=(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{i}^{<em>})\\cdot q_{i,\\alpha}<span class="math">. Letting </span>P^{</em>}<span class="math"> be a malicious prover in </span>\\Pi<span class="math"> whose proofs are distributed as </span>\\pi_{i}^{<em>}<span class="math">, the probability of </span>A<span class="math"> making honest verifiers accept in </span>\\Pi_{\\textsf{dist}}<span class="math"> is bounded by the probability of </span>P^{</em>}<span class="math"> making the verifier in </span>\\Pi<span class="math"> accept. By the </span>\\epsilon<span class="math"> soundness of </span>\\Pi<span class="math"> and the assumption that </span>x\\not\\in\\mathcal{L}<span class="math">, this probability is bounded by </span>\\epsilon$ as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Strong zero knowledge. Let <span class="math">X\\in\\hat{\\mathcal{L}}_{\\mathcal{C},D}</span>. We show how to simulate the view of any set <span class="math">T</span> of <span class="math">t</span> malicious verifiers given their input pieces <span class="math">X_{T}</span> alone. The view during DLC membership testing is simulated by computing some <span class="math">X^{\\prime}\\in\\mathbb{F}^{K\\times n}</span> such that each column of <span class="math">X^{\\prime}</span> is in <span class="math">\\mathcal{C}</span> and <span class="math">X^{\\prime}_{T}=X_{T}</span>, and running the honest prover’s algorithm on <span class="math">X^{\\prime}</span>. (Such <span class="math">X^{\\prime}</span> can be found efficiently due to linearity.) The correctness of this DLC membership simulation is standard, and can be proved via a similar matching argument to the proof of Lemma 6.15: let <span class="math">z=X\\cdot r</span> and <span class="math">z^{\\prime}=X^{\\prime}\\cdot r</span>. Let <span class="math">(c_{T},y_{\\bar{T}})</span> denote the messages received by <span class="math">T</span> in the real world and <span class="math">(c^{\\prime}_{T},y^{\\prime}_{\\bar{T}})</span> be the messages received by <span class="math">T</span> in the ideal world. Clearly, <span class="math">c_{T}</span> and <span class="math">c^{\\prime}_{T}</span> are identically distributed. It thus suffices to prove that the conditional distribution $[y_{\\bar{T}}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,c_{T}]<span class="math"> is identical to </span>[y^{\\prime}_{T}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,c^{\\prime}_{T}]<span class="math">. The mapping </span>c\\mapsto c^{\\prime}=c+z^{\\prime}-z<span class="math"> defines a bijection mapping </span>c\\in\\mathcal{C}<span class="math"> leading to </span>y_{\\bar{T}}<span class="math"> in the former distribution to </span>c^{\\prime}\\in\\mathcal{C}<span class="math"> leading to </span>y^{\\prime}_{\\bar{T}}<span class="math"> in the latter distribution. Note that since </span>X^{\\prime}_{T}=X_{T}<span class="math"> we have </span>z^{\\prime}_{T}=z_{T}<span class="math">, and hence </span>c^{\\prime}_{T}=c_{T}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The simulation of the view of <span class="math">T</span> in the second phase of <span class="math">\\Pi_{\\textsf{dist}}</span> (emulation of <span class="math">\\Pi</span>) proceeds as follows. As in the proof of Theorem 6.6, we assume (without loss of generality) that the queries made by <span class="math">\\Pi</span> to each proof <span class="math">\\pi_{i}</span> are linearly independent. Letting <span class="math">X^{\\prime}</span> a valid encoding of <span class="math">x=0</span> (namely, <span class="math">X^{\\prime}\\in[0]</span>) with <span class="math">X^{\\prime}_{T}=X_{T}</span>. The existence of such an encoding is implied by the <span class="math">t</span>-privacy of <span class="math">(\\mathcal{C},D)</span>, and it can be found efficiently by solving a system of linear equations. The simulator can now jointly simulate the proof shares from <span class="math">P</span> and answer shares from the other verifiers as follows. It starts by invoking the simulator <span class="math">S_{\\textsf{LIOP}}</span> implied by the strong HVZK property of <span class="math">\\Pi</span> to generate the random challenges</p>

    <p class="text-gray-300"><span class="math">r_{i}</span> (defining queries <span class="math">q_{i,\\alpha}</span>) together with the answers <span class="math">a_{i}</span> for each round <span class="math">1\\leq i\\leq\\rho</span>. Then, for each round <span class="math">i</span>, it finds <span class="math">\\pi_{i}\\in\\mathbb{F}^{n}</span> which is consistent with the input <span class="math">x=0</span> and the queries <span class="math">q_{i,\\alpha}</span>. Such <span class="math">\\pi_{i}</span> exist because of the linear independence assumption and can be found efficiently by solving a system of linear equations. Finally, it runs the entire protocol with the simulated values of <span class="math">X^{\\prime},\\pi_{i},r_{i},q_{i}</span> to obtain a simulation of the incoming messages from <span class="math">P</span> and the other verifiers. The correctness of this part of the simulation follows from Lemma 6.15. Finally, we need to simulate possible complaints that originate from other verifiers. Note that we have already simulated all answer shares received from honest verifiers. The simulator runs the adversary to extract the answer shares <span class="math">y_{j}^{*}</span> it sends to honest verifiers. It can now simulate complaint messages by honest verifiers by checking, for each such verifier, whether the <span class="math">k</span> answer shares it received are in <span class="math">\\mathcal{C}</span>. This concludes the description of the simulator.</p>

    <p class="text-gray-300">This concludes the proof of Theorem 6.16. ∎</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Remark 6.17.</h6>

    <p class="text-gray-300">It is sometimes useful to consider a more general version of locally encoded languages in which different entries of an input <span class="math">x\\in\\mathbb{F}^{n}</span> can be encoded using different DLCs. Protocol <span class="math">\\Pi_{\\mathsf{dist}}</span> and Theorem 6.16 can be naturally generalized to such languages, where the complexity of the generalized version of <span class="math">\\Pi_{\\mathsf{dist}}</span> scales linearly with the number of distinct DLCs. In particular, when the number of DLCs is constant, the asymptotic complexity remains the same.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Globally encoded languages. We now turn from the previous case of locally encoded languages, where each entry in an input vector <span class="math">x\\in\\mathcal{L}</span> is encoded separately, to the more general case of a globally encoded language. In this case there is a robust DLC <span class="math">\\tilde{C}</span>, which encodes a language <span class="math">\\mathcal{L}</span> via some arbitrary linear decoder <span class="math">D</span> that may apply an arbitrary linear function to the codewords. In this case we have the guarantee that if <span class="math">\\mathcal{L}</span> can be verified by low-degree polynomials then so can its restrictions $\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math">, for sufficiently big sets of honest verifiers. This allows us to apply Theorem 6.10 for low-degree languages with sublinear communication. Note that for this general case we still have an overhead that may grow exponentially with </span>k<span class="math">. However, in the context of our motivating applications, this overhead will tolerable when </span>k$ is small, since it only applies to a sublinear additive term of the communication complexity, and to cheap (“symmetric crypto”) local computations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We formalize the notion of a globally encoded language below.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Definition 6.18 (Globally encoded language).</h6>

    <p class="text-gray-300">Fix an arbitrary <span class="math">k</span>-DLC <span class="math">\\tilde{\\mathcal{C}}\\subseteq\\mathbb{F}^{M}</span>, a non-distributed <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span>, and a linear decoder <span class="math">D:\\mathbb{F}^{M}\\to\\mathbb{F}^{n}</span>. The global encoding <span class="math">\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}</span> of <span class="math">\\mathcal{L}</span> is the <span class="math">k</span>-distributed language <span class="math">\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}</span> defined by</p>

    <p class="text-gray-300"><span class="math">\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}=\\{\\hat{x}\\in\\tilde{\\mathcal{C}}\\,:\\,D(\\hat{x})\\in\\mathcal{L}\\}.</span></p>

    <p class="text-gray-300">We now show that for a sufficiently robust <span class="math">\\tilde{\\mathcal{C}}</span>, if <span class="math">\\mathcal{L}</span> is “simple” then so are the restrictions of <span class="math">\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}</span> to sets <span class="math">H</span> of honest parties.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Lemma 6.19.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span> be a language whose membership can be verified (deterministically) by degree-<span class="math">d</span> equations. Let <span class="math">\\tilde{\\mathcal{C}}\\subseteq\\mathbb{F}^{M}</span> be a <span class="math">k</span>-DLC with minimal distance <span class="math">t</span>, and <span class="math">D:\\mathbb{F}^{M}\\to\\mathbb{F}^{n}</span> be a linear function. Then for any <span class="math">H\\subseteq[k]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>k-t<span class="math">, membership in </span>\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H}<span class="math"> can also be verified by degree-</span>d$ equations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix a set <span class="math">H</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>k-t<span class="math">. First, note that by the linearity of </span>\\tilde{\\mathcal{C}}<span class="math">, testing whether </span>\\hat{x}_{H}\\in\\tilde{\\mathcal{C}}_{H}<span class="math"> (namely whether </span>\\hat{x}<span class="math"> restricted to </span>H<span class="math"> is consistent with a codeword of </span>\\tilde{\\mathcal{C}}<span class="math">) can be implemented by linear equations. Since the minimal distance of </span>\\tilde{\\mathcal{C}}<span class="math"> is </span>t<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>k-t<span class="math">, if this condition is met then there must be a unique codeword </span>\\hat{x}\\in\\tilde{\\mathcal{C}}<span class="math"> which is consistent with </span>\\hat{x}_{H}<span class="math">, and this codeword can be expressed as a linear function of </span>\\hat{x}_{H}<span class="math">. It follows that </span>D(\\hat{x})<span class="math"> can be written as </span>D_{H}(\\hat{x}_{H})<span class="math"> for a linear function </span>D_{H}<span class="math"> determined by </span>H<span class="math">, and whether </span>D_{H}(\\hat{x}_{H})\\in\\mathcal{L}<span class="math"> can be tested by degree-</span>d$ equations as required. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using Lemma 6.19, we can apply Theorem 6.10 to test membership in low-degree languages with sublinear communication complexity, given any robust encoding of inputs in this language. The price we pay is that we need to apply a separate protocol for each potential subset <span class="math">H</span> of honest parties. We can thus use Lemma 6.19 together with Theorem 6.10 to match the efficiency of Corollary 6.7, up to a <span class="math">\\binom{k}{h}</span> multiplicative communication overhead, obtaining the stronger guarantee of <span class="math">t</span>-security against malicious prover and verifiers when <span class="math">\\tilde{\\mathcal{C}}</span> is of minimal distance <span class="math">t</span>.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Corollary 6.20 (Sublinear zero-knowledge proofs for distributed low-degree languages: malicious prover and verifiers).</h6>

    <p class="text-gray-300">Let <span class="math">d\\geq 2</span> be a positive integer, <span class="math">\\epsilon&gt;0</span> an error bound, and <span class="math">\\mathcal{L}\\subset\\mathbb{F}^{n}</span> a non-distributed language whose membership is tested by <span class="math">m</span> degree-<span class="math">d</span> polynomials. Let <span class="math">k,t</span> be positive integers such that <span class="math">k\\geq 2t</span>, let <span class="math">\\tilde{\\mathcal{C}}\\subseteq\\mathbb{F}^{M}</span> be a <span class="math">k</span>-DLC of minimal distance <span class="math">t</span>, and let <span class="math">D:\\mathbb{F}^{M}\\to\\mathbb{F}^{n}</span> be a linear decoder. Then, there exists an <span class="math">O(d\\log n)</span>-round strong zero-knowledge proof protocol for <span class="math">\\tilde{\\mathcal{L}}_{\\tilde{\\mathcal{C}},D}</span> in the <span class="math">(\\mathcal{F}_{\\mathsf{coin}},\\mathcal{F}_{\\mathsf{bcast}})</span>-hybrid model, with <span class="math">t</span>-security against malicious prover and verifiers, soundness error <span class="math">\\epsilon</span>, and communication complexity of <span class="math">O(\\binom{k}{t}\\cdot kd^{2}\\log n\\cdot\\log(m/\\epsilon))</span> field elements.</p>

    <h2 id="sec-78" class="text-2xl font-bold">7 Application: Honest-Majority MPC</h2>

    <p class="text-gray-300">In this section, we demonstrate applications of zero-knowledge proofs on distributed data to guaranteeing security against malicious parties in secure multi-party computation (MPC) protocols. Combined with our constructions of such proof systems from linear zero-knowledge PCPs (Section 6) we improve the communication complexity of existing information-theoretic MPC protocols in the honest-majority setting.</p>

    <p class="text-gray-300">Since the original feasibility results of Goldreich, Micali, and Wigderson <em>[72]</em>, a nearly universal approach to obtaining secure computation protocols follows a basic blueprint: (1) First, design a protocol attaining the simpler goal of “semi-honest” security: that is, security against parties who may collude and try to learn additional information about inputs of other parties, but who are otherwise assumed to honestly follow the protocol as prescribed. (2) Then, compile to full malicious security by providing a means to enforce honest behavior within the protocol execution. Several such Step 2 transformations exist in the literature, such as having the parties accompany each message with a zero-knowledge proof of its correctness, or various forms of “cut and choose” where the base protocol interaction is duplicated may times over and a subset is “opened” to verify correctness. In each case, the communication overhead in converting from semi-honest to malicious is at least a multiplicative factor of 2.</p>

    <p class="text-gray-300">In what follows, we demonstrate an alternative Step 2 approach that enables any semi-honest protocol of a particular “natural” form (formalized in Definition 7.2) to be upgraded to malicious security with <em>sublinear additive communication overhead</em>. At a high level, this is achieved by adding a phase in the penultimate round of the base protocol, in which each party <span class="math">P_{i}</span> executes a single interactive proof on distributed data (corresponding to the messages communicated to/from <span class="math">P_{i}</span> held by the other parties) that the <em>entire</em> interaction thus far has been performed honestly.</p>

    <p class="text-gray-300">In the following subsections, we introduce some preliminaries and notation, discuss and present a formal definition of “natural” protocols to which our techniques apply, and then present the compiler in the 3-party and general <span class="math">n</span>-party honest majority settings.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">7.1 Preliminaries</p>

    <p class="text-gray-300">We use here the definition of standalone MPC from <em>[37, 71]</em>. By default we consider security with abort. We consider protocols for arithmetic circuits over a finite ring <span class="math">R</span>. We denote the number of parties by <span class="math">m</span> and the parties by <span class="math">P_{1},\\ldots,P_{m}</span>. Without loss of generality, we restrict our attention to deterministic <span class="math">m</span>-party functionalities that only deliver an output to <span class="math">P_{1}</span> (each other party outputs <span class="math">\\bot</span>). This is without loss of generality, since the case of randomized, multi-output functionalities (or even reactive functionalities) can be reduced to this case via standard reductions <em>[71]</em>. We assume that the functionality <span class="math">f</span> is represented by an arithmetic circuit <span class="math">C_{f}</span> over <span class="math">R</span>, where <span class="math">C_{f}</span> may contain addition, subtraction and multiplication gates, as well as constants from <span class="math">R</span>.</p>

    <p class="text-gray-300">We assume that each party <span class="math">P_{i}</span> starts the protocol with an input <span class="math">x_{i}</span> for <span class="math">f</span> and a random input <span class="math">r_{i}</span>, where both <span class="math">x_{i}</span> and <span class="math">r_{i}</span> are vectors over <span class="math">R</span>.</p>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> is defined by its <em>next-message function</em> <span class="math">\\Pi(i,j,x_{i},r_{i},\\vec{m}_{1..j-1})</span>. This function determines the messages sent by <span class="math">P_{i}</span> in round <span class="math">j</span> based on its input, its random inputs, and messages <em>received</em> from all parties in rounds <span class="math">1,2,\\ldots,j-1</span>. We assume that each message is a vector over <span class="math">R</span> and allow each party to send a virtual message to itself. If the output of <span class="math">\\Pi</span> is of the form <span class="math">(\\mathsf{out},y)</span> where <span class="math">y</span> is either a vector over <span class="math">R</span> or <span class="math">y=\\bot</span>, then <span class="math">P_{i}</span> terminates the protocol with output <span class="math">y</span>. We assume that all parties terminate after the same number of rounds, where this number depends only on the representation <span class="math">C_{f}</span> of the functionality being computed but not on the inputs. For the single-output functionalities we consider, all parties other than <span class="math">P_{1}</span> output <span class="math">\\bot</span>.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Definition 7.1 (Protocol Notation).</h6>

    <p class="text-gray-300">We adopt the following notations for a protocol <span class="math">\\Pi</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi(i,j,x_{i},r_{i},\\vec{m}_{1..j-1})</span> denotes the next-message function of <span class="math">\\Pi</span> (as described above).</li>

      <li><span class="math">\\Pi^{\\prime}</span> denotes the protocol obtained by removing the last round of communication from <span class="math">\\Pi</span>.</li>

      <li>Notations regarding transcript message vectors within <span class="math">\\Pi^{\\prime}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_{ij}^{out}</span> denotes the vector of messages sent by <span class="math">P_{i}</span> to party <span class="math">P_{j}</span> in <span class="math">\\Pi^{\\prime}</span>.</li>

      <li><span class="math">M_{i}^{out}=(M_{ij}^{out})_{j\\in[N]}</span> messages sent by <span class="math">P_{i}</span> to <em>all</em> parties.</li>

      <li><span class="math">M_{ij}^{in}</span> and <span class="math">M_{i}^{in}</span> are defined similarly, for <em>incoming</em> messages, received by <span class="math">P_{i}</span> from parties.</li>

      <li><span class="math">M_{i}=(M_{i}^{in},M_{i}^{out})</span> the vector of all incoming <em>and</em> outgoing messages of party <span class="math">P_{i}</span> in <span class="math">\\Pi^{\\prime}</span>.</li>

      <li>For <span class="math">T\\subseteq[N]</span>, denote <span class="math">M_{T}=(M_{i})_{i\\in T}</span>.</li>

      <li>For <span class="math">T\\subseteq[N]</span>, denote <span class="math">M_{\\mathsf{TH}}=(M_{ij}^{in},M_{ij}^{out})_{i\\in T,j\\notin T}</span> the “threshold-crossing” messages, constituting those messages sent/received by a party within <span class="math">T</span> to/from a party outside.</li>

    </ul>

    <h3 id="sec-80" class="text-xl font-semibold mt-8">7.2 Compiling natural protocols</h3>

    <p class="text-gray-300">As with recent works, the core observation in our transformation is that constructions of semi-honest protocols tend to all share a common useful form:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Up to the final exchange of messages, the protocol reveals <em>no</em> information about parties’ inputs, even if parties act maliciously. Indeed, in all “standard” MPC protocols, we can simulate the view of a malicious adversary by running the protocol honestly with default inputs for honest parties. This property means that we are safe to proceed to the end of this phase before needing to prove correctness of actions, which can then be proved all at once.</li>

      <li>The messages sent by a party <span class="math">P_{i}</span> in each round are <em>degree-2</em> functions of messages received in previous rounds. This means that verification of all rounds of interaction can be expressed as satisfaction of a collection of several degree-2 constraints. This is precisely a setting in which our interactive proof techniques perform well.</li>

    </ul>

    <p class="text-gray-300">More formally, we consider the following formal notion of natural protocols in the honest-majority setting. We present the definition and transformation for the case of information theoretic security: in particular, where the truncated protocol excluding the final round is perfectly secure. However, as we later discuss, these results can be easily extended to the relaxed setting of statistical security (with negligible simulation error), and can further yield comparable implications in useful cases where computational tools are used to compress communication bandwidth (e.g., sending a seed to a pseudorandom generator in the place of a long random string).</p>

    <p class="text-gray-300"><strong>Definition 7.2 (Natural Protocol).</strong> We refer to an <span class="math">N</span>-party interactive protocol <span class="math">\\Pi</span> for computing <span class="math">f</span> as a natural protocol against <span class="math">t</span> corruptions if it satisfies the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The execution of <span class="math">\\Pi&#x27;</span> (i.e., <span class="math">\\Pi</span> without the final round) is a perfectly secure realization of the empty functionality <span class="math">\\mathcal{F}_{\\emptyset}</span> which takes no inputs and gives no output, even against malicious corruptions (as per [37, 71]). Denote the corresponding PPT simulator by <span class="math">\\mathsf{Sim}_{\\Pi&#x27;}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a degree-2 encoded language (as per Definition 6.14) <span class="math">\\mathcal{L}_i</span> for each <span class="math">i \\in [N]</span>, such that:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs to <span class="math">\\mathcal{L}_i</span> are of the form <span class="math">M_i = (M_i^{in}, M_i^{out}) \\in R^n</span> (see Notation 7.1).</li>

    </ul>

    <p class="text-gray-300">Note that <span class="math">M_i</span> is known in full to party <span class="math">P_i</span>, and is held distributively across <span class="math">\\{P_j\\}_{j \\neq i}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">M_T = (M_i)_{i \\in T}</span> where <span class="math">\\forall i, M_i \\in \\mathcal{L}_i</span>, then <span class="math">M_T</span> occurs with nonzero probability in some honest execution of <span class="math">\\Pi&#x27;</span> with <span class="math">\\mathcal{A}</span> and honest inputs (corresponding to some choice of randomness of honest parties). (Note that perfect security of <span class="math">\\Pi&#x27;</span> implies that <span class="math">M_T</span> must then lie in the support for any choice of honest inputs.)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a simulator <span class="math">\\mathsf{Sim}_{\\mathrm{final}} = (\\mathsf{Sim}_{in}, \\mathsf{Sim}_{out})</span> composed of a deterministic input extractor <span class="math">\\mathsf{Sim}_{in}</span>, and procedure <span class="math">\\mathsf{Sim}_{out}</span> for simulating the final output messages received by party <span class="math">P_1</span> in <span class="math">\\Pi</span> given any “<span class="math">\\mathcal{L}_i</span>-compatible” protocol execution prefix.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Formally: for any <span class="math">\\mathcal{A}</span> corrupting <span class="math">T \\subset [N]</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">, there exists </span>(\\mathsf{Sim}_{in}, \\mathsf{Sim}_{out})<span class="math"> such that for any honest inputs </span>x_H := (x_i)_{i \\notin T}<span class="math">, and given any “corrupt-honest threshold” messages </span>M_{\\mathsf{TH}} = (M_{ij}^{in}, M_{ij}^{out})_{i \\in T, j \\notin T}<span class="math"> consistent with some </span>M_T = (M_i)_{i \\in T} = (M_{ij}^{in}, M_{ij}^{out})_{i \\in T, j \\in [N]}<span class="math"> (containing also corrupt-corrupt messages) for which </span>\\forall i \\in T, M_i \\in \\mathcal{L}_i$, then it holds that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1 <span class="math">\\in T</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} (x _ {i} ^ {\\prime}) _ {i \\in T} = \\mathsf {S i m} _ {i n} (M _ {\\mathsf {T H}}); \\\\ \\mathsf {S i m} _ {o u t} (y, M _ {\\mathsf {T H}}): \\quad \\forall i \\notin T, x _ {i} ^ {\\prime} = x _ {i}; \\\\ y = f (x _ {1} ^ {\\prime}, \\ldots , x _ {N} ^ {\\prime}) \\end{array} \\right\\} \\approx \\left\\{\\mathsf {F i n a l M s g} _ {P _ {1}} (x _ {H}, \\mathcal {A}) \\mid \\mathrm {p r e f i x} M _ {\\mathsf {T H}} \\right\\}.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1 <span class="math">\\notin T</span>:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{r l} &amp;amp; (x _ {i} ^ {\\prime}) _ {i \\in T} = \\mathsf {S i m} _ {i n} (M _ {\\mathsf {T H}}); \\\\ y &amp;amp; \\text {if } b = \\text {&quot;deliver&quot;} \\\\ \\perp &amp;amp; \\text {if } b = \\perp \\end{array} : \\begin{array}{l} \\forall i \\notin T, x _ {i} ^ {\\prime} = x _ {i}; \\\\ y = f (x _ {1} ^ {\\prime}, \\ldots , x _ {N} ^ {\\prime}); \\\\ b \\leftarrow \\mathsf {S i m} _ {o u t} (y, M _ {\\mathsf {T H}}) \\end{array} \\right\\} \\approx \\left\\{\\mathsf {O u t p u t} _ {P _ {1}} (x _ {H}, \\mathcal {A}) \\mid \\mathrm {p r e f i x} M _ {\\mathsf {T H}} \\right\\}.</span></div>

    <p class="text-gray-300">Here, <span class="math">\\{\\mathsf{FinalMsg}_{P_1}(x_H,\\mathcal{A})\\mid \\mathrm{prefix}M_{\\mathsf{TH}}\\}</span> (respectively, <span class="math">\\mathsf{Output}_{P_1}</span>) denotes the distribution of the <span class="math">N</span> final messages received by <span class="math">P_{1}</span> from all parties in the final round of <span class="math">\\Pi</span> (respectively, final output of <span class="math">P_{1}</span> in <span class="math">\\Pi</span>) when executed with honest inputs <span class="math">x_{H}</span> and (w.l.o.g. deterministic and input-less) adversary <span class="math">\\mathcal{A}</span> over the choice of honest random coins, conditioned on transcript prefix consistent with <span class="math">M_{\\mathsf{TH}}</span>.</p>

    <p class="text-gray-300">We next prove a general transformation, which combines any such natural protocol (with semi-honest security) together with a distributed strong zero-knowledge proof system to obtain a maliciously secure protocol with minimal overhead.</p>

    <p class="text-gray-300">46</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 7.3 (Malicious Security for Natural Protocols).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi_{nat}</span> be any natural <span class="math">N</span>-party protocol computing <span class="math">f</span> against <span class="math">t&lt;N/2</span> corruptions, in the sense of Definition 7.2. Let <span class="math">\\Pi_{\\mathsf{ZK}}=(P,V_{1},\\ldots,V_{N-1})</span> be a distributed strong zero-knowledge proof protocol supporting degree-2 encoded languages with (“Type II”) security against malicious prover and <span class="math">t</span> verifiers (and negligible soundness error), as in Definition 6.8.</p>

    <p class="text-gray-300">Then there exists an <span class="math">N</span>-party protocol <span class="math">\\Pi_{mal}</span> which securely realizes <span class="math">f</span> against <span class="math">t</span> malicious corruptions, with the following complexities:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Round complexity: <span class="math">\\mathsf{rounds}(\\Pi_{mal})=\\mathsf{rounds}(\\Pi_{nat})+\\mathsf{rounds}(\\Pi_{\\mathsf{ZK}})</span>.</li>

      <li>Communication complexity: <span class="math">\\mathsf{CC}(\\Pi_{mal})=\\mathsf{CC}(\\Pi_{nat})+N\\cdot\\mathsf{CC}(\\Pi_{\\mathsf{ZK}})</span>.</li>

    </ul>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the following protocol <span class="math">\\Pi_{mal}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute <span class="math">\\Pi_{nat}^{\\prime}</span>: i.e., <span class="math">\\Pi_{nat}</span> excluding the final round. Denote the corresponding incoming/outgoing per-party message vectors as <span class="math">M_{i}=(M_{i}^{in},M_{i}^{out})</span> as in Definition 7.1, and <span class="math">M_{T}=(M_{i})_{i\\in T}</span> .</li>

      <li>For each <span class="math">i\\in[N]</span> in parallel, conduct an execution of <span class="math">\\Pi_{\\mathsf{ZK}}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Party <span class="math">P_{i}</span> emulates prover <span class="math">P</span> on input <span class="math">M_{i}=(M_{i}^{in},M_{i}^{out})</span>.</li>

      <li>Parties <span class="math">(P_{j})_{j\\neq i}</span> each emulate corresponding verifier <span class="math">V_{j}</span> on input piece <span class="math">x^{(j)}=(M_{ji}^{in},M_{ji}^{out})</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[N]</span>: If any of the <span class="math">N</span> parallel executions of <span class="math">\\Pi_{\\mathsf{ZK}}</span> above resulted in “reject,” then <span class="math">P_{i}</span> sends no further messages in the protocol. Otherwise, compute and send the final message as dictated by <span class="math">\\Pi_{nat}</span>, and <span class="math">P_{1}</span> outputs accordingly.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove that <span class="math">\\Pi_{mal}</span> is maliciously secure by demonstrating a simulator, <span class="math">\\mathsf{Sim}_{mal}</span>. Fix adversary <span class="math">\\mathcal{A}</span> (without loss of generality, input-less and deterministic), and corrupted set <span class="math">T\\subset[N]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Simulator <span class="math">\\mathsf{Sim}_{mal}^{\\mathcal{A}}((x_{i})_{i\\in T})</span>:</p>

    <p class="text-gray-300">We begin by defining some notation and sub-algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> notation: Interpret adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{\\Pi^{\\prime}},\\mathcal{A}_{\\mathsf{ZK}},\\mathcal{A}_{\\mathsf{final}})</span>, corresponding to the actions of <span class="math">\\mathcal{A}</span> within the three phases of the protocol <span class="math">\\Pi_{mal}</span> as above. Each sub-adversary can be viewed as a separate program which takes as input the view from the previous phases of execution.</li>

      <li><span class="math">\\mathsf{Sim}_{\\mathsf{ZK}}</span>: Define sub-simulator <span class="math">\\mathsf{Sim}_{\\mathsf{ZK}}</span> for simulating the interactive proofs (interleaved round by round) as follows. The input of <span class="math">\\mathsf{Sim}_{\\mathsf{ZK}}</span> is a partial transcript <span class="math">M_{T}=(M_{ij}^{in},M_{ij}^{out})_{i\\in T,j\\in[N]}</span> parsed as vectors of messages received/sent by corrupted parties <span class="math">i\\in T</span> in the prefix protocol <span class="math">\\Pi^{\\prime}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each prover <span class="math">i\\in T</span>: Honestly simulate execution of <span class="math">\\Pi_{\\mathsf{ZK}}</span> generating messages on behalf of honest parties <span class="math">P_{j}</span> using respective input pieces <span class="math">x^{(j)}=(M_{ji}^{in},M_{ji}^{out})</span> (from above), and generating messages of corrupt parties by executing <span class="math">\\mathcal{A}</span> on behalf of corrupt parties.</li>

    </ul>

    <p class="text-gray-300">Denote the simulated transcript by <span class="math">M_{\\mathsf{ZK}}^{(i)}</span> and accept/reject values as <span class="math">(\\mathsf{output}_{V_{j}}^{(i)})_{j\\notin T}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each prover <span class="math">i\\notin T</span>: For each corrupt party <span class="math">j\\in T</span>, denote <span class="math">x^{(j)}=(M_{ji}^{in},M_{ji}^{out})</span> the incoming and outgoing messages between <span class="math">j</span> and honest prover party <span class="math">P_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">Use the simulator of <span class="math">\\Pi_{\\mathsf{ZK}}</span>: run <span class="math">(M_{\\mathsf{ZK}}^{(i)},(\\mathsf{output}_{V_{j}}^{(i)})_{j\\notin T})\\leftarrow\\mathsf{Sim}_{\\Pi_{\\mathsf{ZK}}}((x^{(j)})_{j\\in T})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}_{\\mathsf{ZK}}</span> outputs <span class="math">\\big{(}M_{\\mathsf{ZK}},c)</span>, where <span class="math">M_{\\mathsf{ZK}}=(M_{\\mathsf{ZK}}^{(i)})_{i\\in[N]}</span> and <span class="math">c</span> is defined as follows. If any simulated verifier output is “reject” within any of the <span class="math">N</span> executions, <span class="math">c=</span> “reject”; otherwise, <span class="math">c=</span> “accept.”</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Sim}_{\\Pi^{\\prime}},\\mathsf{Sim}_{\\mathsf{final}}</span>: Given adversary <span class="math">\\mathcal{A}=(\\mathcal{A}_{\\Pi^{\\prime}},\\mathcal{A}_{\\mathsf{ZK}},\\mathcal{A}_{\\mathsf{final}})</span> in <span class="math">\\Pi_{mal}</span>, we consider the projection of this adversary to an adversary <span class="math">\\mathcal{A}_{nat}=(\\mathcal{A}_{\\Pi^{\\prime}},\\mathsf{Sim}_{\\mathsf{ZK}},\\mathcal{A}_{\\mathsf{final}})</span> in the underlying protocol <span class="math">\\Pi_{nat}</span>, which itself executes <span class="math">\\mathsf{Sim}_{\\mathsf{ZK}}</span> on the transcript generated from executing <span class="math">\\Pi^{\\prime}</span>, and passes the simulated output transcript <span class="math">M_{\\mathsf{ZK}}</span> to <span class="math">\\mathcal{A}_{\\mathsf{final}}</span> (who executes as usual).</li>

    </ul>

    <p class="text-gray-300">By condition 2 of the natural protocol <span class="math">\\Pi_{nat}</span>, this adversary <span class="math">\\mathcal{A}_{nat}</span> induces a collection of simulators (<span class="math">\\mathsf{Sim}_{\\Pi^{\\prime}}</span> and <span class="math">\\mathsf{Sim}_{\\mathsf{final}}=(\\mathsf{Sim}_{in},\\mathsf{Sim}_{out})</span>).</p>

    <p class="text-gray-300">We now present the specification of <span class="math">\\mathsf{Sim}_{mal}^{\\mathcal{A}}((x_i)_{i\\in T})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">M_T \\gets \\mathsf{Sim}_{\\Pi&#x27;}((x_i)_{i \\in T})</span>. Let <span class="math">M_{\\mathsf{TH}}</span> denote the corresponding subset of "corrupt-honest threshold" messages (removing corrupt-corrupt communications).</li>

      <li>Run <span class="math">(M_{\\mathsf{ZK}}, c) \\gets \\mathsf{Sim}_{\\mathsf{ZK}}(M_T)</span>. If <span class="math">c = \\text{&quot;reject&quot;}</span> then <span class="math">\\mathsf{Sim}_{mal}</span> terminates with output <span class="math">\\bot</span>.</li>

      <li>Otherwise, simulate the final step of the protocol <span class="math">\\Pi_{mal}</span> as follows (using <span class="math">M_{\\mathsf{TH}}</span>).</li>

    </ol>

    <p class="text-gray-300">(a) Run <span class="math">(x_i&#x27;)_{i \\in T} \\gets \\mathsf{Sim}_{in}(M_{\\mathsf{TH}})</span> to extract corrupt party inputs from the simulated transcript prefix from Step 2. (b) Call the ideal <span class="math">f</span> functionality on the extracted corrupt inputs: <span class="math">y = \\mathcal{F}_f((x_i&#x27;)_{i\\in T})</span> (c) Simulate the final step depending on whether party <span class="math">P_{1}</span> is corrupt or honest:</p>

    <p class="text-gray-300">Case <span class="math">1 \\in T</span>:</p>

    <p class="text-gray-300">i. Simulate final-round messages from honest parties to <span class="math">P_{1}</span> as <span class="math">(\\mathsf{msg}_i)_{i \\notin T} \\gets \\mathsf{Sim}_{out}(y, M_{\\mathsf{TH}})</span>. ii. Emulate <span class="math">\\mathcal{A}_{\\mathrm{final}}</span> to simulate the final output of <span class="math">P_{1}</span> on these inputs.</p>

    <p class="text-gray-300">Case <span class="math">1 \\notin T</span>:</p>

    <p class="text-gray-300">i. Run <span class="math">b \\gets \\mathsf{Sim}_{out}(y, M_{\\mathsf{TH}})</span> ii. If <span class="math">b = \\text{&quot;deliver,&quot;}</span> simulate the adversary allowing output delivery to honest parties. If <span class="math">b = \\bot</span>, simulate adversarial abort.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The final simulated output distribution of <span class="math">\\mathsf{Sim}_{mal}^{\\mathcal{A}}</span> is the concatenation of <span class="math">(M_T, M_{\\mathsf{ZK}}, M_{\\mathsf{final}})</span>, where <span class="math">M_{\\mathsf{final}}</span> is either <span class="math">(\\mathsf{msg}_i)_{i \\notin T}</span> if <span class="math">1 \\in T</span> or <span class="math">b \\in \\{\\bot, \\text{&quot;deliver&quot;}\\}</span> if <span class="math">1 \\notin T</span>.</li>

    </ol>

    <p class="text-gray-300">We now demonstrate that the output distribution <span class="math">(M_T, M_{\\mathsf{ZK}}, M_{\\mathsf{final}})</span> of <span class="math">\\mathsf{Sim}_{mal}</span> is indistinguishable from that of a real execution <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, \\mathsf{Exec}_{\\mathsf{ZK}}, \\mathsf{Exec}_{\\mathsf{final}})</span>. This is done via a sequence of claims. In the analysis below, we use the terminology of a tuple of distributions (e.g., <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, M_{\\mathsf{ZK}})</span>) to denote the distribution resulting in executing each procedure on input the output generated by the previous.</p>

    <p class="text-gray-300">Claim 7.4. <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, M_{\\mathsf{ZK}}) \\equiv (M_T, M_{\\mathsf{ZK}})</span>.</p>

    <p class="text-gray-300">Proof. By property 1 of natural protocols, <span class="math">\\mathsf{Exec}_{\\Pi&#x27;} \\equiv M_T</span>. Thus applying <span class="math">M_{\\mathsf{ZK}}</span> on the respective outputs preserves this equivalence.</p>

    <p class="text-gray-300">Claim 7.5. <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, M_{\\mathsf{ZK}}, \\mathsf{Exec}_{\\mathsf{final}}) \\approx (M_T, M_{\\mathsf{ZK}}, M_{\\mathsf{final}})</span>.</p>

    <p class="text-gray-300">Proof. For any execution in which the output of <span class="math">M_{\\mathsf{ZK}}</span> is "reject," then both <span class="math">\\mathsf{Exec}_{\\mathsf{final}} = M_{\\mathsf{final}} = \\bot</span>, and the claim holds. Consider then the case that all proofs in the simulation <span class="math">M_{\\mathsf{ZK}}</span> result in "accept."</p>

    <p class="text-gray-300">By soundness of the proof system <span class="math">\\Pi_{\\mathsf{ZK}}</span> (against prover and <span class="math">t</span> verifiers), then with overwhelming probability, for each corrupt prover <span class="math">P_{i}</span> there exist input pieces <span class="math">x^{(j)} = (M_{ji}^{<em>in}, M_{ji}^{</em>out})</span> for corrupt parties <span class="math">j \\in T</span> which together with the <span class="math">x^{(j)}</span> for honest parties <span class="math">j \\notin T</span> form <span class="math">M_{i}</span> that is <span class="math">\\mathcal{L}_{i}</span>-compliant. That is, combining all <span class="math">i \\in T</span>, the given "corrupt-honest threshold" messages <span class="math">M_{\\mathsf{TH}}</span> satisfies the requirements for simulation of natural protocols (namely, existence of a consistent extension to a full <span class="math">M_{T} = (M_{i})_{i \\in T}</span> that is <span class="math">\\mathcal{L}_{i}</span>-compliant <span class="math">\\forall i \\in T</span>). Thus, by property 2 of natural protocols for the adversary <span class="math">\\mathcal{A}_{nat} = (\\mathcal{A}_{\\Pi&#x27;}, \\mathsf{Sim}_{\\mathsf{ZK}}, \\mathcal{A}_{\\mathsf{final}})</span>, we have with overwhelming probability over the choice of <span class="math">M_{T}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">M_{\\text{final}} \\approx \\{\\mathsf{Exec}_{\\text{final}} \\mid \\text{prefix } M_{\\mathsf{TH}}\\}.</span></div>

    <p class="text-gray-300">Thus, combining with Claim 7.4 (as well as the fact that the output of <span class="math">\\mathsf{Exec}_{\\mathsf{final}}</span> or <span class="math">M_{\\mathsf{final}}</span> is independent of corrupt-corrupt messages - <span class="math">M_{\\mathsf{TH}}</span> vs <span class="math">M_T</span>), we have <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, M_{\\mathsf{ZK}}, \\mathsf{Exec}_{\\mathsf{final}}) \\approx (M_T, M_{\\mathsf{ZK}}, M_{\\mathsf{final}})</span>.</p>

    <p class="text-gray-300">Claim 7.6. <span class="math">(\\mathsf{Exec}_{\\Pi&#x27;}, \\mathsf{Exec}_{\\mathsf{ZK}}, \\mathsf{Exec}_{\\mathsf{final}}) \\approx (\\mathsf{Exec}_{\\Pi&#x27;}, M_{\\mathsf{ZK}}, \\mathsf{Exec}_{\\mathsf{final}})</span>.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows by the strong zero knowledge property of <span class="math">\\Pi_{\\mathsf{ZK}}</span>, via <span class="math">(N-t)</span> hybrids, wherein each <span class="math">P_{i}</span>-prover execution (<span class="math">i\\notin T</span>) is replaced by its simulated version. In each step, all remaining components of the distribution can be simulated consistently without knowledge of honest verifiers’ pieces of <span class="math">P_{i}</span>’s input to <span class="math">\\Pi_{\\mathsf{ZK}}</span>, namely <span class="math">x^{(j)}=(M_{ji}^{in},M_{ji}^{out})</span> corresponding to honest-honest communications between honest parties <span class="math">P_{i}</span> and <span class="math">P_{j}</span>. ∎</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Remark 7.7 (Computational Compression).</h6>

    <p class="text-gray-300">The theorem above is proved within the information theoretic setting: in particular, assuming the protocol prefix <span class="math">\\Pi^{\\prime}</span> is perfectly secure. Relaxing this requirement to statistical security with negligible simulation error follows from a simple adjustment. But more interestingly, our transformation further has direct implications to protocols which utilize computational tools in order to achieve communication compression.</p>

    <p class="text-gray-300">More explicitly, a common technique for decreasing communication complexity in MPC protocols is to replace long strings of communicated randomness by short seeds which can locally be expanded by a pseudorandom generator, in which case the resulting protocol provides only computational security. In such case, we can first analyze and compile the information theoretic uncompressed version of the protocol, and then appeal to computational arguments within the compiled malicious-secure protocol. We refer the reader to the following section for more details.</p>

    <h3 id="sec-85" class="text-xl font-semibold mt-8">7.3 The 3-party case</h3>

    <p class="text-gray-300">We begin by considering the specific setting of 3-party secure computation with a single malicious corruption. This setting will already showcase our basic transformation framework, and, since only a single party can be malicious, will require only the (slightly cleaner) proof system with security against either a malicious prover or malicious verifier. The resulting maliciously secure protocol over a ring <span class="math">R</span> will require communication of only one <span class="math">R</span>-element per party per gate in the computed <span class="math">R</span>-circuit.</p>

    <p class="text-gray-300">We begin in Section 7.3.1 by presenting the 3-party semi-honest secure protocol, and proving it is “natural” against a single corruption. Then in Section 7.3.2 we compile the protocol to the malicious setting, and use a common pseudorandomness trick in the compiled protocol to decrease the required communication.</p>

    <h4 id="sec-86" class="text-lg font-semibold mt-6">7.3.1 A natural 3PC protocol</h4>

    <p class="text-gray-300">We adapt the semi-honest protocol of <em>Katz et al. [87]</em> (see also e.g. <em>[5, 47, 56]</em>) to the case of 3PC over general rings in the information-theoretic setting. In <em>[87]</em> a dealer interacts with <span class="math">n</span> parties in a preprocessing stage, supplying them with correlated random field elements that act as masks for wire values in the online stage. In the online stage the dealer publishes masked inputs for every gate output. The <span class="math">n</span> parties then securely evaluate the circuit, maintaining the invariant that for each wire the parties hold the public masked value of the wire and shares of the mask.</p>

    <p class="text-gray-300">In our adaptation, there are three parties: <span class="math">P_{0}</span>, <span class="math">P_{1}</span>, and <span class="math">P_{2}</span>, who have inputs <span class="math">x_{0},x_{1}</span>, and <span class="math">x_{2}</span> over a ring <span class="math">R</span>. <span class="math">P_{0}</span> acts as the dealer in the protocol of <em>[87]</em>, distributing correlated randomness and secret shares of its inputs. Note that the correlated randomness distribution depends on the arithmetic circuit <span class="math">C</span> to be securely evaluated. For <span class="math">\\lambda\\in R</span>, we denote by <span class="math">[\\lambda]</span> additive secret shares of <span class="math">\\lambda</span> over <span class="math">R</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{0}</span> generates and distributes correlated randomness as per the protocol preprocessing phase:</li>

    </ol>

    <p class="text-gray-300">Define <span class="math">\\lambda_{\\alpha}</span> values:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each input or multiplication gate <span class="math">\\alpha</span> in the circuit, party <span class="math">P_{0}</span> samples a random mask <span class="math">\\lambda_{\\alpha}\\in R</span>, and provides additive secret shares <span class="math">[\\lambda_{\\alpha}]</span> of the value <span class="math">\\lambda_{\\alpha}</span> to <span class="math">P_{1}</span> and <span class="math">P_{2}</span>.</li>

      <li>For each addition gate <span class="math">\\gamma</span> in the circuit with inputs coming from gates <span class="math">\\alpha,\\beta</span>, <span class="math">P_{0}</span> defines <span class="math">\\lambda_{\\gamma}=\\lambda_{\\alpha}+\\lambda_{\\beta}</span>. Note that additive shares of <span class="math">\\lambda_{\\gamma}</span> are derivable as <span class="math">[\\lambda_{\\gamma}]=[\\lambda_{\\alpha}]+[\\lambda_{\\beta}]</span>.</li>

    </ul>

    <p class="text-gray-300">Generate correlated randomness:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each input gate <span class="math">\\alpha</span>:</li>

    </ul>

    <p class="text-gray-300">If the gate is owned by <span class="math">P_{i}</span> for <span class="math">i\\in\\{1,2\\}</span>, party <span class="math">P_{0}</span> sends <span class="math">\\lambda_{\\alpha}</span> to <span class="math">P_{i}</span>. If the gate is owned by <span class="math">P_{0}</span>, party <span class="math">P_{0}</span> sends his masked input <span class="math">x_{0}+\\lambda_{\\alpha}</span> to both <span class="math">P_{1}</span> and <span class="math">P_{2}</span>. In addition, he sends additive secret shares <span class="math">[\\lambda_{\\alpha}]</span> of the mask.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every multiplication gate with <span class="math">\\lambda_{\\alpha}</span> and <span class="math">\\lambda_{\\beta}</span> on the input wires <span class="math">\\alpha,\\beta</span>, <span class="math">P_{0}</span> sets <span class="math">\\lambda_{\\alpha,\\beta}=\\lambda_{\\alpha}\\cdot\\lambda_{\\beta}</span> and provides additive secret shares <span class="math">[\\lambda_{\\alpha,\\beta}]</span> to <span class="math">P_{1}</span> and <span class="math">P_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Ultimately, the distribution is as follows. Denote the set of input gates owned by party <span class="math">P_{i}</span> (for <span class="math">i\\in\\{0,1,2\\}</span>) by <span class="math">\\mathsf{Inp}_{i}</span>; denote the set of multiplication gates indexed by inputs <span class="math">(\\alpha,\\beta)</span> and output <span class="math">\\gamma</span> as <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}</span>; and, denote the <span class="math">i</span>th party’s share from <span class="math">[a]</span> as <span class="math">a^{(i)}</span>. (Later we will also denote the set of output gates as <span class="math">\\gamma\\in\\mathsf{Out}</span> and the set of addition gates as <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Add}</span>.) The final distribution given to party <span class="math">P_{i}</span> (for <span class="math">i\\in\\{1,2\\}</span>) is thus:</p>

    <p class="text-gray-300"><span class="math">D_{i}=\\Big{(}\\{\\lambda_{\\alpha}^{(i)},(x_{\\alpha}+\\lambda_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{i}},\\{\\lambda_{\\gamma}^{(i)},\\lambda_{\\alpha,\\beta}^{(i)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the online phase, parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> proceed in topological order over the gates of the circuit. For each input gate:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each input gate <span class="math">\\alpha</span> owned by <span class="math">P_{i}</span>, <span class="math">i\\in\\{1,2\\}</span>, party <span class="math">P_{i}</span> sends his masked input <span class="math">(x_{\\alpha}+\\lambda_{\\alpha})</span> to <span class="math">P_{2-i}</span>. (Note that the value of <span class="math">(x_{\\beta}+\\lambda_{\\beta})</span> for each input gate <span class="math">\\beta</span> owned by <span class="math">P_{0}</span> is already known by both <span class="math">P_{1}</span> and <span class="math">P_{2}</span>.)</li>

    </ul>

    <p class="text-gray-300">Throughout execution of the circuit, the maintained invariant is that after the evaluation of each gate <span class="math">\\gamma</span>, the parties <span class="math">P_{1},P_{2}</span> hold in the clear the masked computation value <span class="math">(x_{\\gamma}+\\lambda_{\\gamma})</span>. Note that after Step 2a above, this invariant holds for all input gates.</p>

    <p class="text-gray-300">Note as well that for every non-input gate <span class="math">\\gamma</span> with inputs <span class="math">\\alpha,\\beta</span>, the parties hold additive shares <span class="math">[\\lambda_{\\alpha}],[\\lambda_{\\beta}],[\\lambda_{\\gamma}]</span>. (This holds as all wires are outputs from some gate. For the case where <span class="math">\\alpha</span> or <span class="math">\\beta</span> is the output of an input gate owned by <span class="math">P_{i}</span> for either <span class="math">i=1,2</span>, then they can canonically set shares <span class="math">\\lambda_{\\alpha}^{(i)}=\\lambda_{\\alpha}</span> and <span class="math">\\lambda_{\\alpha}^{(2-i)}=0</span>.) In addition, for multiplication gates, they also hold <span class="math">[\\lambda_{\\alpha,\\beta}]</span>.</p>

    <p class="text-gray-300">For each non-input gate (in topological order), the parties jointly evaluate as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each addition gate with input wires <span class="math">\\alpha,\\beta</span> and output wire <span class="math">\\gamma</span>, parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> each locally compute <span class="math">x_{\\gamma}+\\lambda_{\\gamma}=(x_{\\alpha}+\\lambda_{\\alpha})+(x_{\\beta}+\\lambda_{\\beta})</span> and <span class="math">[\\lambda_{\\gamma}]=[\\lambda_{\\alpha}]+[\\lambda_{\\beta}]</span>.</li>

    </ul>

    <p class="text-gray-300">(Recall <span class="math">\\lambda_{\\gamma}:=\\lambda_{\\alpha}+\\lambda_{\\beta}</span>.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each multiplication gate with inputs <span class="math">\\alpha,\\beta</span> and output <span class="math">\\gamma</span>, parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">[x_{\\gamma}+\\lambda_{\\gamma}]=(x_{\\alpha}+\\lambda_{\\alpha})(x_{\\beta}+\\lambda_{\\beta})-<a href="x_{\\alpha}+\\lambda_{\\alpha}">\\lambda_{\\beta}</a>-<a href="x_{\\beta}+\\lambda_{\\beta}">\\lambda_{\\alpha}</a>+[\\lambda_{\\alpha,\\beta}]+[\\lambda_{\\gamma}].</span> (2)</p>

    <p class="text-gray-300">Then, <span class="math">P_{1}</span> and <span class="math">P_{2}</span> exchange their shares of <span class="math">[x_{\\gamma}+\\lambda_{\\gamma}]</span> enabling both to learn the value.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each output gate, the two parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> exchange their shares of the masked output value <span class="math">x_{\\gamma}+\\lambda_{\\gamma}</span> to reconstruct this value.</li>

    </ul>

    <p class="text-gray-300">In the final round of communication, <span class="math">P_{1}</span> and <span class="math">P_{2}</span> each send the reconstructed (masked) output values to <span class="math">P_{0}</span>.</p>

    <p class="text-gray-300">For each output gate <span class="math">\\gamma</span>, <span class="math">P_{0}</span> reconstructs output <span class="math">x_{\\gamma}</span> by removing the mask: <span class="math">x_{\\gamma}=(x_{\\gamma}+\\lambda_{\\gamma})-\\lambda_{\\gamma}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication complexity. In the preprocessing stage of this protocol, <span class="math">P_{0}</span> sends no more than two <span class="math">R</span>-elements to each party for each gate (total: $\\leq 4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$). In the online phase:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>One <span class="math">R</span>-element is sent in total for each input gate (namely, <span class="math">x_{\\alpha}+\\lambda_{\\alpha}</span>).</li>

      <li>No communication for an addition gate.</li>

      <li>One <span class="math">R</span>-element is sent by each of <span class="math">P_{1}</span> and <span class="math">P_{2}</span> (to one another) for each multiplication gate (to reconstruct <span class="math">[x_{\\gamma}+\\lambda_{\\gamma}]</span>). (<span class="math">=2</span> <span class="math">R</span>-elements per mult gate)</li>

      <li>One <span class="math">R</span>-element is sent by each of <span class="math">P_{1},P_{2}</span> for each output (the masked output <span class="math">x_{\\gamma}+\\lambda_{\\gamma}</span>, to <span class="math">P_{0}</span>). (<span class="math">=2</span> <span class="math">R</span>-elements per output gate)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In total, the protocol requires no more than $4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R<span class="math">-elements in the preprocessing phase, and </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R<span class="math">-elements in the online phase. In total, </span>6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R$-elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the protocol as described is information theoretic and does not leverage any pseudo-random communication compression. In what follows, we first compile <span class="math">\\Pi_{\\mathsf{3PC}}</span> to a maliciously secure version via Theorem 7.3, and then will apply PRG techniques to the resulting protocol to drop the communication complexity to <span class="math">1</span> <span class="math">R</span>-element per party per gate. We begin by proving that <span class="math">\\Pi_{\\mathsf{3PC}}</span> is natural, so that Theorem 7.3 will apply.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 7.8.</h6>

    <p class="text-gray-300">The 3-party protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span> is a natural protocol against 1 corruption (Definition 7.2).</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We address the required properties.</p>

    <p class="text-gray-300">Simulation of <span class="math">\\Pi^{\\prime}_{\\mathsf{3PC}}</span>. Consider <span class="math">\\Pi^{\\prime}_{\\mathsf{3PC}}</span>: i.e., the protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span> above with the final communication message removed (of masked outputs <span class="math">(x_{\\gamma}+\\lambda_{\\gamma})</span> from parties <span class="math">P_{1},P_{2}</span> back to <span class="math">P_{0}</span>). We demonstrate a simulator <span class="math">\\mathsf{Sim}_{\\Pi^{\\prime}_{\\mathsf{3PC}}}</span> for execution of <span class="math">\\Pi^{\\prime}_{\\mathsf{3PC}}</span> with a single malicious corruption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{0}</span> corrupt. Simulation is trivial: honest <span class="math">P_{1},P_{2}</span> do not communicate anything to <span class="math">P_{0}</span> in <span class="math">\\Pi^{\\prime}_{\\mathsf{3PC}}</span>.</li>

      <li><span class="math">P_{1}</span> or <span class="math">P_{2}</span> corrupt. Without loss of generality (by symmetry), say <span class="math">P_{2}</span> is corrupt. Simulate actions on behalf of <span class="math">P_{0}</span> and <span class="math">P_{1}</span> each with default input <span class="math">0</span>; equivalently, in each case <span class="math">P_{2}</span> sends a message of correct syntax (e.g., an <span class="math">R</span>-element when such element is expected), respond with random values for each <span class="math">R</span>-element that is to be sent. More explicitly, <span class="math">\\mathsf{Sim}_{\\Pi^{\\prime}_{\\mathsf{3PC}}}</span> is as below.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}_{\\Pi^{\\prime}_{\\mathsf{3PC}}}</span>(): Simulate <span class="math">P_{0}</span>’s message to <span class="math">P_{2}</span> honestly on default input <span class="math">x=0</span>: equivalently,</p>

    <p class="text-gray-300"><span class="math">\\left(\\{\\lambda_{\\alpha}^{(i)},(0+\\lambda_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{i}},\\{\\lambda_{\\gamma}^{(i)},\\lambda_{\\alpha,\\beta}^{(i)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\right),</span></p>

    <p class="text-gray-300">where each element is an independent and uniformly random element from <span class="math">R</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the messages of honest <span class="math">P_{1}</span> as follows.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each input gate belonging to <span class="math">P_{1}</span> (<span class="math">\\alpha\\in\\mathsf{Inp}_{1}</span>): Sample and send random <span class="math">\\hat{x}_{\\alpha}\\leftarrow R</span>. Each such message is properly simulated, as the real <span class="math">\\hat{x}_{\\alpha}</span> is equal to <span class="math">x_{\\alpha}+\\lambda_{\\alpha}</span>, where <span class="math">\\lambda_{\\alpha}\\in R</span> is uniformly distributed conditioned on all values of the simulation thus far.</li>

      <li>For each input gate belonging to <span class="math">P_{2}</span> (<span class="math">\\alpha\\in\\mathsf{Inp}_{2}</span>): If party <span class="math">P_{2}</span> does not send a valid <span class="math">R</span>-element (allegedly <span class="math">x_{\\alpha}+\\lambda_{\\alpha}</span>), then abort.</li>

      <li>For each addition gate <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Add}</span>: No values communicated. If any message is sent by <span class="math">P_{2}</span>, then abort.</li>

      <li>For each multiplication gate <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}</span>: Sample and send random <span class="math">\\hat{x}_{\\gamma}^{(1)}\\leftarrow R</span>. Each such message is properly simulated, as the real <span class="math">\\hat{x}_{\\gamma}^{(1)}</span> is equal to <span class="math">(x_{\\gamma}+\\lambda_{\\gamma})-\\hat{x}_{\\gamma}^{(2)}</span>, where <span class="math">\\lambda_{\\gamma}\\in R</span> is uniformly distributed conditioned on <span class="math">x_{\\gamma}</span>, on <span class="math">\\hat{x}_{\\gamma}^{(2)}</span>, and all values of the simulation thus far.</li>

    </ol>

    <p class="text-gray-300">If party <span class="math">P_{2}</span> does not send a valid <span class="math">R</span>-element (allegedly <span class="math">\\hat{x}_{\\gamma}^{(2)}</span>), then abort.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each output gate <span class="math">\\gamma\\in\\mathsf{Out}</span>: Same procedure and analysis as for a multiplication gate. Sample and send random <span class="math">\\hat{x}_{\\gamma}^{(1)}\\leftarrow R</span>; if party <span class="math">P_{2}</span> does not send a valid <span class="math">R</span>-element, then abort. Simulation is proper, as the honest value is masked by random <span class="math">\\lambda_{\\gamma}</span>, which is uniform given all values of the simulation thus far.</li>

    </ul>

    <p class="text-gray-300">Degree-2 encoded <span class="math">\\mathcal{L}_{i}</span> and <span class="math">(\\mathsf{Sim}_{in},\\mathsf{Sim}_{out})</span>. We now address the second requirement of natural protocols: existence of per-party degree-2 encoded languages <span class="math">\\mathcal{L}_{i}</span> with required simulation properties. We treat the cases of <span class="math">P_{0}</span> corrupt and <span class="math">P_{1}/P_{2}</span> corrupt separately. For brevity, we use the terminology <span class="math">\\hat{x}_{\\alpha}\\in R</span> to denote a value allegedly equal to <span class="math">x_{\\alpha}+\\lambda_{\\alpha}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{0}</span> corrupt. Consider the following language:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{0}:=\\Big{\\{}M_{01}^{out}=\\Big{(}\\{\\lambda_{\\alpha}^{(1)},(\\hat{x}_{\\alpha})_{1}\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{1}},\\{\\lambda_{\\gamma}^{(1)},\\lambda_{\\alpha,\\beta}^{(1)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}\\,,</span> <span class="math">M_{02}^{out}=\\Big{(}\\{\\lambda_{\\alpha}^{(2)},(\\hat{x}_{\\alpha})_{2}\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{2}},\\{\\lambda_{\\gamma}^{(2)},\\lambda_{\\alpha,\\beta}^{(2)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}\\,\\Big{)}</span> <span class="math">\\quad:\\ \\forall\\alpha\\in\\mathsf{Inp}_{0}\\Big{(}(\\hat{x}_{\\alpha})_{1}=(\\hat{x}_{\\alpha})_{2}\\Big{)},</span> <span class="math">\\quad\\forall((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}\\Big{(}(\\lambda_{\\alpha,\\beta}^{(1)}+\\lambda_{\\alpha,\\beta}^{(2)})=(\\lambda_{\\alpha}^{(1)}+\\lambda_{\\alpha}^{(2)})\\cdot(\\lambda_{\\beta}^{(1)}+\\lambda_{\\beta}^{(2)})\\Big{)}\\Big{\\}}.</span></p>

    <p class="text-gray-300">In this case, the prefix transcript <span class="math">M_{0}=(M_{01}^{out},M_{02}^{out})</span> of <span class="math">P_{0}</span> in <span class="math">\\Pi^{\\prime}_{3\\mathsf{PC}}</span> consists solely of the initial message from <span class="math">P_{0}</span> to parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> (and no received messages). The consistency language <span class="math">\\mathcal{L}_{0}</span> requires: (1) consistency between the alleged masked input values <span class="math">\\hat{x}_{\\alpha}</span> given to the two parties (for inputs <span class="math">\\alpha\\in\\mathsf{Inp}_{0}</span> owned by party <span class="math">P_{0}</span>), as well as (2) the required structure of multiplication-gate mask shares <span class="math">\\lambda_{\\alpha},\\lambda_{\\beta},\\lambda_{\\alpha,\\beta}</span> for multiplication gates <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}</span>.</p>

    <p class="text-gray-300">Consider any such set of messages <span class="math">M_{0}=(M_{01}^{out},M_{02}^{out})\\in\\mathcal{L}_{0}</span> as above. Observe that an honest execution of <span class="math">\\Pi^{\\prime}</span> for random <span class="math">P_{0}</span> inputs <span class="math">\\{x_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{0}}</span> induces a prefix transcript precisely equivalent to a uniform choice of element <span class="math">M_{0}</span> from this language <span class="math">\\mathcal{L}_{0}</span>. Thus, any such <span class="math">M_{0}</span>, there exists a choice of inputs <span class="math">\\{x_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{0}}</span> for which <span class="math">M_{0}</span> occurs in an honest execution with nonzero probability. Consider the following simulators <span class="math">\\mathsf{Sim}_{in},\\mathsf{Sim}_{out}</span> on input <span class="math">M_{0}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Sim}_{in}</span>: Extract each input <span class="math">x_{\\alpha}</span> with <span class="math">\\alpha\\in\\mathsf{Inp}_{0}</span> (of party <span class="math">P_{0}</span>) as <span class="math">x_{\\alpha}:=(\\hat{x}_{\\alpha})-(\\lambda_{\\alpha}^{(1)}+\\lambda_{\\alpha}^{(2)})</span>.</li>

      <li><span class="math">\\mathsf{Sim}_{out}</span>: Execute the ideal functionality on this extracted input (<span class="math">\\{x_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{0}}=\\mathsf{Sim}_{in}(M_{0})</span>); denote the resulting output by <span class="math">y:=\\{y_{\\gamma}\\}_{\\gamma\\in\\mathsf{Out}}</span>. Given this information, the task of <span class="math">\\mathsf{Sim}_{out}</span> is to simulate the final message of (uncorrupted) parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> back to <span class="math">P_{0}</span>.</li>

    </ul>

    <p class="text-gray-300">For each output gate <span class="math">\\gamma</span>, <span class="math">\\mathsf{Sim}_{out}</span> simulates on behalf of each party <span class="math">P_{1},P_{2}</span> sending the correct masked output value, where the appropriate mask <span class="math">\\lambda_{\\gamma}</span> is determined by combining the two parties’ shares.</p>

    <p class="text-gray-300">Namely, <span class="math">\\mathsf{Sim}_{out}(y,M_{0})=\\Big{\\{}y_{\\gamma}+(\\lambda_{\\gamma}^{(1)}+\\lambda_{\\gamma}^{(2)})\\Big{\\}}_{\\gamma\\in\\mathsf{Out}}</span>.</p>

    <p class="text-gray-300">We prove correctness of this simulation by induction on the topology of circuit <span class="math">C</span>. Consider a fixed input <span class="math">x=(\\{x_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{i}})_{i\\in\\{0,1,2\\}}</span>. For each gate in the circuit <span class="math">C</span> with output <span class="math">\\gamma</span>, denote by <span class="math">x_{\\gamma}</span> the correct partial computation value, obtained by executing the circuit up to gate <span class="math">\\gamma</span> on input <span class="math">x</span>. The invariant maintained is that (in an honest execution of the online portion of <span class="math">\\Pi_{3\\mathsf{PC}}</span> between <span class="math">P_{1}</span> and <span class="math">P_{2}</span> given correlated randomness <span class="math">M_{0}=(M_{01}^{out},M_{02}^{out})\\in\\mathcal{L}_{0}</span>), for each gate <span class="math">\\gamma</span>, the exchanged shares <span class="math">\\hat{x}_{\\gamma}^{(1)}</span> and <span class="math">\\hat{x}_{\\gamma}^{(2)}</span> dictated by <span class="math">\\Pi_{3\\mathsf{PC}}</span> satisfy <span class="math">\\hat{x}_{\\gamma}:=(\\hat{x}_{\\gamma}^{(1)}+\\hat{x}_{\\gamma}^{(2)})=x_{\\gamma}+(\\lambda_{\\gamma}^{(1)}+\\lambda_{\\gamma}^{(2)})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Base Case: Consider the input gates.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\alpha\\in\\mathsf{Inp}_{0}</span>, the values <span class="math">\\lambda_{\\alpha}^{(1)},\\lambda_{\\alpha}^{(2)}</span> together with <span class="math">\\hat{x}_{\\alpha}:=(\\hat{x}_{\\alpha})_{1}=(\\hat{x}_{\\alpha})_{2}</span> (where this equality holds by <span class="math">\\mathcal{L}_{0}</span>), satisfy the required condition, for the implicitly defined input</li>

    </ul>

    <p class="text-gray-300">value <span class="math">x_{\\alpha} = \\hat{x}_{\\alpha} - (\\lambda_{\\alpha}^{(1)} + \\lambda_{\\alpha}^{(2)})</span>. Note this is precisely the input as extracted by <span class="math">\\mathsf{Sim}_{in}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">\\alpha \\in \\mathsf{Inp}_1</span> (<span class="math">\\mathsf{Inp}_2</span> follows symmetrically), the sent <span class="math">\\hat{x}_{\\alpha}</span> is precisely computed as the value <span class="math">\\hat{x}_{\\alpha} = x_{\\alpha} + (\\lambda_{\\alpha}^{(1)} + \\lambda_{\\alpha}^{(2)})</span>, where <span class="math">\\lambda_{\\alpha}^{(1)} \\coloneqq \\lambda_{\\alpha}</span> as given in <span class="math">M_{02}^{out}</span> and <span class="math">\\lambda_{\\alpha}^{(2)} \\coloneqq 0</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Induction step:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each addition gate <span class="math">((\\alpha, \\beta), \\gamma) \\in \\mathsf{Add}</span>: Here, the parties locally evaluate <span class="math">\\hat{x}_{\\gamma} = \\hat{x}_{\\alpha} + \\hat{x}_{\\beta}</span>. Recall the masks are defined by <span class="math">\\lambda_{\\gamma} \\coloneqq \\lambda_{\\alpha} + \\lambda_{\\beta}</span>. Thus, by the inductive hypothesis, <span class="math">\\hat{x}_{\\gamma} = (x_{\\alpha} + \\lambda_{\\alpha}) + (x_{\\beta} + \\lambda_{\\beta}) = x_{\\gamma} + \\lambda_{\\gamma}</span>, since <span class="math">x_{\\gamma} = x_{\\alpha} + x_{\\beta}</span> for addition gates.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each multiplication gate <span class="math">((\\alpha, \\beta), \\gamma) \\in \\mathsf{Mult}</span>: The language <span class="math">\\mathcal{L}_0</span> guarantees the required consistency <span class="math">\\lambda_{\\alpha, \\beta} = \\lambda_{\\alpha} \\cdot \\lambda_{\\beta}</span> (where these values are defined by combining their respective secret shares).</li>

    </ul>

    <p class="text-gray-300">Thus, combining this guarantee with the inductive hypothesis on <span class="math">\\hat{x}_{\\alpha}, \\hat{x}_{\\beta}</span>, the computation of (exchanged shares of) <span class="math">\\hat{x}_{\\gamma}</span> of the multiplied value dictated by Equation (2) of <span class="math">\\Pi_{3PC}</span> preserves the requirement <span class="math">\\hat{x}_{\\gamma} = (x_{\\alpha} \\cdot x_{\\beta}) + \\lambda_{\\gamma} = x_{\\gamma} + \\lambda_{\\gamma}</span>.</p>

    <p class="text-gray-300">Thus, by induction, it holds that the final messages, corresponding to the case of each output gate <span class="math">\\gamma \\in \\mathrm{Out}</span> indeed satisfy the requirement that <span class="math">\\hat{x}_{\\gamma} = x_{\\gamma} + (\\lambda_{\\gamma}^{(1)} + \\lambda_{\\gamma}^{(2)})</span>. That is, simulation in the case of corrupt <span class="math">P_0</span> is correct.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_0</span> honest. (Wlog assume <span class="math">P_2</span> is corrupt.) Consider the following language:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_2 := \\left\\{ \\begin{array}{l} M_{20}^{in} = \\left(\\{\\lambda_{\\alpha}^{(2)}, (\\hat{x}_{\\alpha})\\}_{\\alpha \\in \\mathsf{Inp}_0}, \\{\\lambda_{\\alpha}\\}_{\\alpha \\in \\mathsf{Inp}_2}, \\{\\lambda_{\\gamma}^{(2)}, \\lambda_{\\alpha,\\beta}^{(2)}\\}_{((\\alpha,\\beta),\\gamma) \\in \\mathsf{Mult}}\\right), \\\\ M_{21}^{in} = \\left(\\{\\hat{x}_{\\alpha}\\}_{\\alpha \\in \\mathsf{Inp}_1}, \\{\\hat{x}_{\\gamma}^{(1)}\\}_{((\\alpha,\\beta),\\gamma) \\in \\mathsf{Mult}}, \\{\\hat{x}_{\\gamma}^{(1)}\\}_{\\gamma \\in \\mathsf{Out}}\\right), \\\\ M_{21}^{out} = \\left(\\{\\hat{x}_{\\alpha}\\}_{\\alpha \\in \\mathsf{Inp}_2}, \\{\\hat{x}_{\\gamma}^{(2)}\\}_{((\\alpha,\\beta),\\gamma) \\in \\mathsf{Mult}}, \\{\\hat{x}_{\\gamma}^{(2)}\\}_{\\gamma \\in \\mathsf{Out}}\\right) \\\\ : \\quad \\forall ((\\alpha,\\beta),\\gamma) \\in \\mathsf{Mult} \\left(\\hat{x}_{\\gamma}^{(2)} = (\\hat{x}_{\\alpha})(\\hat{x}_{\\beta}) - \\lambda_{\\beta}^{(2)}(\\hat{x}_{\\alpha}) - \\lambda_{\\alpha}^{(2)}(\\hat{x}_{\\beta}) + \\lambda_{\\alpha,\\beta}^{(2)} + \\lambda_{\\gamma}^{(2)}\\right), \\\\ \\quad \\forall ((\\alpha,\\beta),\\gamma) \\in \\mathsf{Mult} \\left(\\hat{x}_{\\gamma} = \\hat{x}_{\\gamma}^{(1)} + \\hat{x}_{\\gamma}^{(2)}\\right) \\right\\},</span></div>

    <p class="text-gray-300">(where for each addition gate <span class="math">((\\alpha, \\beta), \\gamma) \\in \\mathsf{Add}</span>, we implicitly define <span class="math">\\hat{x}_{\\gamma} = \\hat{x}_{\\alpha} + \\hat{x}_{\\beta}</span>). The first constraints enforce that the shares <span class="math">\\hat{x}_{\\gamma}^{(2)}</span> sent by <span class="math">P_2</span> for each multiplication gate are computed as directed by the protocol Equation (2); the second constraints simply correspond to local computations combining these exchanged shares (note the <span class="math">\\hat{x}_{\\gamma}</span> exist in the description of <span class="math">\\mathcal{L}_2</span> primarily for ease of notation). Note that all constraints are degree <span class="math">\\leq 2</span>.</p>

    <p class="text-gray-300">Let <span class="math">M_2 = (M_{20}^{in}, M_{21}^{in}, M_{21}^{out}) \\in \\mathcal{L}_2</span>. Consider the simulators <span class="math">\\mathsf{Sim}_{in}, \\mathsf{Sim}_{out}</span> below, on input <span class="math">M_2</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Sim}_{in}</span>: Extract each input of party <span class="math">P_2</span> (<span class="math">x_{\\alpha}</span> with <span class="math">\\alpha \\in \\mathsf{Inp}_2</span>), as <span class="math">x_{\\alpha} := (\\hat{x}_{\\alpha} - \\lambda_{\\alpha})</span>, for the values <span class="math">\\hat{x}_{\\alpha} \\in M_{21}^{out}</span> and <span class="math">\\lambda_{\\alpha} \\in M_{20}^{in}</span>.</li>

      <li><span class="math">\\mathsf{Sim}_{out}</span>: Recall that only the uncorrupted party <span class="math">P_0</span> receives any messages in the final round, and thus the task of <span class="math">\\mathsf{Sim}_{out}</span> is to simulate whether <span class="math">P_0</span> outputs or aborts. In addition, we must argue in the case that <span class="math">P_0</span> outputs that the resulting output value is indeed correct.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}_{out}(M_2)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the execution of the truncated protocol <span class="math">\\Pi_{3PC}^{\\prime}</span> with <span class="math">\\mathcal{A}</span> to attain transcript state <span class="math">M_2</span>. Namely, for each communication round, send the corresponding messages to <span class="math">P_2</span> on behalf of <span class="math">P_0</span> and <span class="math">P_1</span>, as described in <span class="math">M_{20}^{in}</span> and <span class="math">M_{21}^{in}</span>. (Note that since <span class="math">M_2</span> occurs with nonzero probability in an honest execution of <span class="math">\\Pi_{3PC}^{\\prime}</span>, and that <span class="math">\\mathcal{A}</span> is wlog deterministic, then the entirety of <span class="math">M_2</span> will indeed be reconstructed.)</li>

    </ol>

    <p class="text-gray-300">Recall that <span class="math">\\Pi_{3PC}^{\\prime}</span> concludes with the parties <span class="math">P_1</span> and <span class="math">P_2</span> exchanging their secret shares</p>

    <p class="text-gray-300"><span class="math">\\hat{x}_{\\gamma}^{(1)},\\hat{x}_{\\gamma}^{(2)}</span> of the alleged masked output value <span class="math">\\hat{x}_{\\gamma}</span>, for each output gate <span class="math">\\gamma\\in\\mathsf{Out}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute the final step of <span class="math">\\mathcal{A}</span> to obtain the final message <span class="math">\\mathsf{msg}_{\\mathsf{final}}</span> from the corrupt party <span class="math">P_{2}</span> to the honest <span class="math">P_{0}</span>.</li>

      <li>Let <span class="math">\\mathsf{msg}_{\\mathsf{final}}^{good}:=(\\hat{x}_{\\gamma}=\\hat{x}_{\\gamma}^{(1)}+\\hat{x}_{\\gamma}^{(2)})_{\\gamma\\in\\mathsf{Out}}</span> (i.e., the correct message that <span class="math">P_{2}</span> should be sending). If <span class="math">\\mathsf{msg}_{\\mathsf{final}}=\\mathsf{msg}_{\\mathsf{final}}^{good}</span>, then output <span class="math">b=</span> “deliver.” Otherwise, output <span class="math">b=\\bot</span>.</li>

    </ol>

    <p class="text-gray-300">Consider the above simulation in comparison to a real execution of <span class="math">\\Pi_{\\mathsf{3PC}}</span>. In a real execution, if <span class="math">\\mathsf{msg}_{\\mathsf{final}}\\neq\\mathsf{msg}_{\\mathsf{final}}^{good}</span>, then <span class="math">P_{0}</span> will receive disagreeing final messages from <span class="math">P_{1}</span> and <span class="math">P_{2}</span>, in which case <span class="math">P_{0}</span> will output <span class="math">\\bot</span> (as simulated). In the case that <span class="math">\\mathsf{msg}_{\\mathsf{final}}=\\mathsf{msg}_{\\mathsf{final}}^{good}=(\\hat{x}_{\\gamma})_{\\gamma\\in\\mathsf{Out}}</span> in the real execution, then <span class="math">P_{0}</span> will output the value <span class="math">(x_{\\gamma}:=\\hat{x}_{\\gamma}-\\lambda_{\\gamma})_{\\gamma\\in\\mathsf{Out}}</span>, where <span class="math">\\lambda_{\\gamma}</span> is the mask value assigned to the corresponding output gate.</p>

    <p class="text-gray-300">Note that the requirements on communication transcripts <span class="math">M_{2}\\in\\mathcal{L}_{2}</span> directly enforces that <span class="math">P_{2}</span> must send values directly as required by <span class="math">\\Pi^{\\prime}</span> for each multiplication gate, and that the messages sent by honest <span class="math">P_{0}</span> will necessarily comply with <span class="math">\\mathcal{L}_{0}</span> as considered from the previous case. Thus, the same inductive proof applies here as well, concluding that the values <span class="math">\\hat{x}_{\\gamma}</span> for each output gate <span class="math">\\gamma\\in\\mathsf{Out}</span> satisfy the requirement that <span class="math">\\hat{x}_{\\gamma}=x_{\\gamma}+\\lambda_{\\gamma}</span>, where <span class="math">\\lambda_{\\gamma}</span> is the mask held by <span class="math">P_{0}</span>, and <span class="math">x_{\\gamma}</span> is the correct evaluation output. That is, the value <span class="math">\\hat{x}_{\\gamma}-\\lambda_{\\gamma}</span> output by <span class="math">P_{0}</span> in the real execution will be the correct evaluation.</p>

    <p class="text-gray-300">Thus, simulation is complete.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">7.3.2 Compressing communication via pseudorandomness</h4>

    <p class="text-gray-300">We now compile the protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span> from the previous section to one with malicious security where the amortized communication complexity (over a large circuit) involves just one ring element per party per gate. This is done via two steps: first leveraging Theorem 7.3 on the information theoretic <span class="math">\\Pi_{\\mathsf{3PC}}</span> to yield a new protocol with (statistical) security against malicious adversaries (but with higher communication), and then compressing the communication of random values via computational pseudorandomness.</p>

    <p class="text-gray-300">The latter step can be applied in a semi-generic manner to protocols in which subsets of parties exchange long random strings. We formalize this via the random-string exchange model.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Definition 7.9 (Random-String Exchange Model).</h6>

    <p class="text-gray-300">An <span class="math">n</span>-party protocol in the random-string exchange model over ring <span class="math">R</span> is defined by two phases of communication:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random-String Exchange. The first round of communication, denoted by <span class="math">\\Pi_{\\mathsf{rand}}</span>, consists purely of messages of the following form, for a collection <span class="math">\\mathcal{S}</span> of subsets <span class="math">S\\subseteq[n]</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">S\\in\\mathcal{S}</span>, a designated representative party <span class="math">P_{i}</span> with <span class="math">i\\in S</span> (denoted <span class="math">i=\\mathsf{rep}(S)</span>) samples a random <span class="math">r_{S}\\leftarrow R^{\\ell_{S}}</span> and sends <span class="math">r_{S}</span> to all parties in <span class="math">S</span>.</li>

    </ul>

    <p class="text-gray-300">In particular, in an honest execution of <span class="math">\\Pi_{\\mathsf{rand}}</span>, all <span class="math">r_{S}</span> strings are jointly uniform.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Standard Communication. After this initial round, communication proceeds as usual (over secure point-to-point channels). The remainder of the protocol is denoted by <span class="math">\\Pi_{\\mathsf{rest}}</span>.</li>

    </ol>

    <h6 id="sec-91" class="text-base font-medium mt-4">Definition 7.10 (Malicious String Choice).</h6>

    <p class="text-gray-300">We say a protocol <span class="math">\\Pi</span> in the random-string exchange model secure against <span class="math">t</span> (static) corruptions is further secure against malicious string choice if simulation holds (as per <em>[37, 71]</em>) even for a modified real-world experiment <span class="math">\\mathsf{Real}</span>-<span class="math">\\mathsf{MalRand}</span>, where the adversary is able to select the value of all strings <span class="math">r_{S}</span> for which <span class="math">S</span> contains a corrupted party.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">More formally: for every adversary <span class="math">\\mathcal{A}^{\\prime}=(\\mathcal{A}_{\\mathsf{rand}},\\mathcal{A})</span>, where <span class="math">\\mathcal{A}_{\\mathsf{rand}}</span> selects strings <span class="math">r_{S}</span> for <span class="math">S\\in\\SS</span> with <span class="math">S\\cap T\\neq\\emptyset</span>, and <span class="math">\\mathcal{A}</span> is an adversarial strategy for protocol <span class="math">\\Pi_{\\mathsf{rest}}</span>, there exists a simulator <span class="math">\\mathsf{Sim}</span> for which</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{Real}\\text{-}\\mathsf{Mal}\\mathsf{Rand}_{\\Pi}(1^{\\lambda},T,\\mathcal{A}^{\\prime},\\vec{x},z)\\right\\}\\overset{c}{\\approx}\\left\\{\\mathsf{Ideal}(1^{\\lambda},T,\\mathsf{Sim},\\{x_{i}\\}_{i\\in T},z)\\right\\}.</span></p>

    <p class="text-gray-300">Intuitively, we can reduce communication complexity of such a protocol by replacing the long random strings in the initial random-string exchange phase with short random seeds, which parties can then locally expand via a pseudorandom generator.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Theorem 7.11 (Computational Compression).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\Pi_{\\mathsf{rand}},\\Pi_{\\mathsf{rest}})</span> be an <span class="math">n</span>-party protocol in the Random-String Exchange model which evaluates circuit <span class="math">C</span> over ring <span class="math">R</span> with (computational) security against <span class="math">t</span> malicious (static) corruptions, against malicious string choice. Let <span class="math">\\SS</span> denote the collection of subsets performing random-string exchange in <span class="math">\\Pi_{\\mathsf{rand}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then there exists an <span class="math">n</span>-party protocol <span class="math">\\Pi^{\\mathsf{PRG}}</span> evaluating <span class="math">C</span> with computational security against <span class="math">t</span> malicious (static) corruptions, with communication $CC(\\Pi_{\\mathsf{rest}})\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\sum_{S\\in\\SS}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\lambda$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-93" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The required protocol <span class="math">\\Pi^{\\mathsf{PRG}}</span> is obtained by replacing each (possibly long) random string <span class="math">r_{S}</span> communicated in the random-string exchange round with a <span class="math">\\lambda</span>-bit seed to a pseudorandom generator. Explicitly, <span class="math">\\Pi^{\\mathsf{PRG}}</span> executes in three phases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Modified Random-String Exchange. For each set <span class="math">S\\in\\SS</span>, and <span class="math">i\\in S</span> for which party <span class="math">P_{i}</span> is instructed in <span class="math">\\Pi_{\\mathsf{rand}}</span> to sample and send a random <span class="math">r_{S}\\leftarrow R^{\\ell_{S}}</span>, this party <span class="math">P_{i}</span> instead samples and sends a seed <span class="math">s_{S}\\leftarrow\\{0,1\\}^{\\lambda}</span> to each party in <span class="math">S</span>.</li>

      <li>Locally Expand Seeds. For each <span class="math">S\\in\\SS</span>, each party <span class="math">j\\in S</span> locally expands the corresponding received seed using a pseudorandom generator: <span class="math">r_{S}=PRG(s_{S})</span>, where <span class="math">r_{S}\\in R^{\\ell_{S}}</span> as per <span class="math">\\Pi_{\\mathsf{rest}}</span>.</li>

      <li>Execute <span class="math">\\Pi_{\\mathsf{rest}}</span>, using strings <span class="math">r_{S}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the communication complexity of the modified protocol <span class="math">\\Pi^{\\mathsf{PRG}}</span> is comprised of the communication induced by <span class="math">\\Pi_{\\mathsf{rest}}</span>, in addition to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\lambda<span class="math"> bits for each set </span>S\\in\\SS<span class="math">, corresponding to the communication of the seed </span>s_{S}<span class="math"> to each party in </span>S<span class="math">. It thus remains to prove </span>\\Pi^{\\mathsf{PRG}}<span class="math"> securely computes </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}^{\\mathsf{PRG}}=(\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rand}},\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rest}})</span> be an adversary for the protocol <span class="math">\\Pi^{\\mathsf{PRG}}</span>. Note that the input/output communication syntax of <span class="math">\\Pi^{\\mathsf{PRG}}</span> is identical to that in <span class="math">\\Pi</span>; thus, we may interpret <span class="math">\\mathcal{A}^{\\mathsf{PRG}}</span> also as an adversarial strategy in the <span class="math">\\mathsf{Real}</span> experiment for protocol <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">We define a related adversary <span class="math">\\mathcal{A}^{\\prime}=(\\mathcal{A}_{\\mathsf{rand}},\\mathcal{A})</span>, to be executed in the <span class="math">\\mathsf{Real}\\text{-}\\mathsf{Mal}\\mathsf{Rand}</span> experiment for protocol <span class="math">\\Pi</span>. <span class="math">\\mathcal{A}</span> exactly executes <span class="math">\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rest}}</span>. In comparison to <span class="math">\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rand}}</span>, the sub-adversary <span class="math">\\mathcal{A}_{\\mathsf{rand}}</span> must also select strings <span class="math">r_{S}</span> for subsets <span class="math">S\\in\\SS</span> with <span class="math">S\\cap T\\neq\\emptyset</span> (i.e., containing corrupt parties) for which the representative <span class="math">\\mathsf{rep}(S)</span> is not corrupt. <span class="math">\\mathcal{A}^{\\mathsf{PRG}}_{r}and</span> will choose all such <span class="math">r_{S}</span> pseudorandomly. That is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">S</span> with <span class="math">S\\cap T\\neq\\emptyset</span> but <span class="math">\\mathsf{rep}(S)\\notin T</span>: Choose <span class="math">r_{S}</span> pseudorandomly. That is, sample <span class="math">s_{S}\\leftarrow\\{0,1\\}^{\\lambda}</span>, and evaluate <span class="math">r_{S}=\\mathsf{PRG}(s_{S})</span>. Simulate sending <span class="math">r_{S}</span> to all (corrupt) parties in <span class="math">S</span>.</li>

      <li>For <span class="math">S^{\\prime}</span> with <span class="math">\\mathsf{rep}(S^{\\prime})\\in T</span>: Run <span class="math">\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rand}}</span> given the strings <span class="math">r_{S}</span> from the previous bullet, to jointly select all such <span class="math">r_{S^{\\prime}}</span>.</li>

    </ul>

    <h6 id="sec-94" class="text-base font-medium mt-4">Claim 7.12.</h6>

    <p class="text-gray-300">There exists a simulator <span class="math">\\mathsf{Sim}</span> such that for any inputs <span class="math">\\vec{x}</span> and auxiliary input <span class="math">z</span>,</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{Real}\\text{-}\\mathsf{Mal}\\mathsf{Rand}_{\\Pi}(1^{\\lambda},T,\\mathcal{A}^{\\prime},\\vec{x},z)\\right\\}\\overset{c}{\\approx}\\left\\{\\mathsf{Ideal}_{\\Pi}(1^{\\lambda},T,\\mathsf{Sim},\\{x_{i}\\}_{i\\in T},z)\\right\\}.</span></p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Proof of Claim 7.12.</h6>

    <p class="text-gray-300">Follows directly by the assumption that the original protocol <span class="math">\\Pi</span> is secure against malicious string choice (Definition 7.10). In particular, the value <span class="math">r_{S}=PRG(s_{S})</span> for randomly chosen <span class="math">s_{S}\\leftarrow\\{0,1\\}^{\\lambda}</span> is one particular such adversarial choice of <span class="math">r_{S}</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Claim 7.13.</h6>

    <p class="text-gray-300">By construction of <span class="math">\\mathcal{A}^{\\prime}=(\\mathcal{A}_{\\mathsf{rand}},\\mathcal{A})</span> from <span class="math">\\mathcal{A}^{\\mathsf{PRG}}=(\\mathsf{rand}^{\\mathsf{PRG}},\\mathcal{A}^{\\mathsf{PRG}}_{\\mathsf{rest}})</span> as above, and by the security of the pseudorandom generator, it holds that for any inputs <span class="math">\\vec{x}</span> and auxiliary input <span class="math">z</span>,</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{Real}_{\\Pi^{\\mathsf{PRG}}}(1^{\\lambda},T,\\mathcal{A}^{\\mathsf{PRG}},\\vec{x},z)\\right\\}\\stackrel{{\\scriptstyle c}}{{\\approx}}\\left\\{\\mathsf{Real}\\text{-}\\mathsf{Mal}\\mathsf{Rand}_{\\Pi}(1^{\\lambda},T,\\mathcal{A}^{\\prime},\\vec{x},z)\\right\\}.</span></p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof of Claim 7.13.</h6>

    <p class="text-gray-300">Suppose, to the contrary, there exist <span class="math">\\vec{x}</span>, <span class="math">z</span>, polynomial-time distinguisher <span class="math">\\mathcal{D}</span>, and non-negligible <span class="math">\\alpha(\\lambda)</span> for which <span class="math">\\mathcal{D}</span> successfully distinguishes the two distributions above. Such distinguisher <span class="math">\\mathcal{D}</span> can be used to violate the security of the underlying pseudorandom generator.</p>

    <p class="text-gray-300">Recall the distinction between <span class="math">\\mathsf{Real}_{\\Pi^{\\mathsf{PRG}}}</span> executing with <span class="math">\\mathcal{A}^{\\mathsf{PRG}}</span>, as compared to <span class="math">\\mathsf{Real}\\text{-}\\mathsf{Mal}\\mathsf{Rand}_{\\Pi}</span> with <span class="math">\\mathcal{A}^{\\prime}</span>. Both experiments are identical aside from the generation of random strings <span class="math">r_{S}</span>, <span class="math">S\\in\\$$. In the former experiment, all strings </span>r_{S}<span class="math"> for which </span>\\mathsf{rep}(S)\\notin T<span class="math"> (i.e., the representative is honest) are generated pseudorandomly; in particular, such </span>S<span class="math"> containing a mix of honest and corrupt parties, and those containing only honest parties. In the latter experiment, the adversary </span>\\mathcal{A}^{\\prime}<span class="math"> is able to (“maliciously”) choose strings </span>r_{S}<span class="math"> with </span>\\mathsf{rep}(S)\\notin T<span class="math"> where </span>S<span class="math"> contains corrupt parties, and makes such choice pseudoranomly; however, for </span>S\\in\\<span class="math"> containing only honest parties, the corresponding strings </span>r_{S}$ are still chosen truly randomly.</p>

    <p class="text-gray-300">Thus, given a random versus pseudorandom challenge, we can embed it into a simulated execution of the experiment(s) above, on inputs <span class="math">\\vec{x}</span> and auxiliary input <span class="math">z</span>, and the distinguisher <span class="math">\\mathcal{D}</span> (together with a standard hybrid argument) will directly enable us to identify the random vs pseudorandom cases with advantage comparable to <span class="math">\\alpha</span>. It follows that such a distinguisher <span class="math">\\mathcal{D}</span> cannot exist.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Finally, we observe that the protocol <span class="math">\\Pi^{\\mathsf{PRG}}</span> and original <span class="math">\\Pi</span> both attempt to securely realize the same functionality, and thus their corresponding ideal-world experiments are identical. That is:</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Claim 7.14.</h6>

    <p class="text-gray-300">For any corrupt subset <span class="math">T</span>, simulator <span class="math">\\mathsf{Sim}</span>, corrupt inputs <span class="math">\\{x_{i}\\}_{i\\in T}</span>, and auxiliary <span class="math">z</span>,</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{Ideal}_{\\Pi}(1^{\\lambda},T,\\mathsf{Sim},\\{x_{i}\\}_{i\\in T},z)\\right\\}\\equiv\\left\\{\\mathsf{Ideal}_{\\Pi^{\\mathsf{PRG}}}(1^{\\lambda},T,\\mathsf{Sim},\\{x_{i}\\}_{i\\in T},z)\\right\\}.</span></p>

    <p class="text-gray-300">Theorem 7.11 follows from the combination of Claims 7.12-7.14.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">Three-party computation. We now return to the task of achieving low-communication secure 3-party computation. In what follows, we combine the pieces from the previous subsections, beginning with protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span>, to prove the following final theorem.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Theorem 7.15 (Malicious 3PC with 1 ring element per multiplication per party).</h6>

    <p class="text-gray-300">Let <span class="math">R</span> be either a finite field or a ring of the form <span class="math">\\mathbb{Z}_{w}</span>. Then, for any <span class="math">R</span>-arithmetic circuit <span class="math">C</span>, there exists a 3-party protocol for computing <span class="math">C</span>, with the following features:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol makes a black-box use of any pseudorandom generator. If <span class="math">R</span> is a field, it also makes a black-box use of <span class="math">R</span>.</li>

      <li>The protocol is computationally secure with abort against one malicious party.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The communication complexity is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> elements of </span>R<span class="math"> per party, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of multiplication gates in </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-100" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">At a high level, the proof takes the following approach.</p>

    <p class="text-gray-300">We begin with the protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span> from Section 7.3.1, which was proved (Lemma 7.8) to be natural against 1 corruption. Since <span class="math">\\Pi_{\\mathsf{3PC}}</span> is natural, then by our general compiler (Theorem 7.3), together with the existence of sublinear-communication zero-knowledge proofs for distributed low-degree</p>

    <p class="text-gray-300">languages (Corollary 6.7), we can convert <span class="math">\\Pi_{3\\mathsf{PC}}</span> to a related protocol <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span> secure against <span class="math">1</span> malicious corruption, with small communication overhead. (Note that Corollary 6.7 suffices, since in the <span class="math">3</span>-party case only prover or verifier can be corrupt.) The remaining goal is to leverage the computational randomness compression techniques developed in this section to decrease the communication in <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span>, while maintaining (malicious) security.</p>

    <p class="text-gray-300">In doing so, we must show two items: (1) <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span> can be expressed in the random-string exchange model (Definition 7.9), with a large portion of communication pushed to the random-string exchange phase; (2) <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span> is further secure against malicious string choice (Definition 7.10). Given these, the theorem will follow, by Theorem 7.11.</p>

    <p class="text-gray-300">To show these properties of <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span>, we turn back to <span class="math">\\Pi_{3\\mathsf{PC}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- We demonstrate in Claim 7.16 that <span class="math">\\Pi_{3\\mathsf{PC}}</span> can be expressed in the random-string exchange model with a large portion of communication in the random-string exchange phase. Opening the box of our Theorem 7.3 natural protocol compiler, we then observe (Claim 7.17) that <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span> can be expressed in the same structure, with a small (sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$) additional interaction at the end (running the interactive zero-knowledge proofs). This establishes (1).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To assert (2), we analyze modified versions of the original protocol <span class="math">\\Pi_{3\\mathsf{PC}}^{mal}</span>, where the role of selecting the random strings in the initial exchange phase is shifted from the “dealer” party <span class="math">P_{0}</span> to a corresponding recipient party <span class="math">P_{1}</span> or <span class="math">P_{2}</span>. In each case, the modified malicious-security protocol is shown secure by showing that the corresponding modified version of the underlying protocol <span class="math">\\Pi_{3\\mathsf{PC}}</span> remains natural; thus, the compiler of Theorem 7.3 gives us precisely the needed security claims.</li>

    </ul>

    <p class="text-gray-300">Formally, we prove the theorem via a sequence of intermediate claims.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Claim 7.16.</h6>

    <p class="text-gray-300">The 3-party protocol <span class="math">\\Pi_{3\\mathsf{PC}}</span> (from Section 7.3.1) for computing circuit <span class="math">C</span> over <span class="math">R</span> is a natural protocol against 1 corruption, which can be expressed in the Random-String Exchange model with communication pattern:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random-String Exchange. Party <span class="math">P_{0}</span> samples and sends random strings <span class="math">r_{S}</span> to sets <span class="math">S\\in\\SS=\\{\\{0,1\\},\\{0,2\\},\\{0,1,2\\}\\}</span>.</li>

      <li>Standard Communication. <span class="math">P_{0}</span> sends additional strings computed as a function of these strings <span class="math">(r_{S})_{S\\in\\SS}</span> and his inputs. Then <span class="math">P_{1}</span> and <span class="math">P_{2}</span> execute the online portion of the protocol <span class="math">\\Pi_{3\\mathsf{PC}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and where the communication complexity of the Standard Communication phase is $3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R$-elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof of Claim 7.16.</h6>

    <p class="text-gray-300">The natural property of <span class="math">\\Pi_{3\\mathsf{PC}}</span> was proved in Lemma 7.8. Recall the first message of <span class="math">\\Pi_{3\\mathsf{PC}}</span> consists of “dealer” party <span class="math">P_{0}</span> sending the following messages to <span class="math">P_{1}</span> and <span class="math">P_{2}</span>, respectively:</p>

    <p class="text-gray-300"><span class="math">M_{01}^{out}=\\left(\\{\\lambda_{\\alpha}^{(1)},(\\hat{x}_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{1}},\\{\\lambda_{\\gamma}^{(1)},\\lambda_{\\alpha,\\beta}^{(1)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\right),</span> <span class="math">M_{02}^{out}=\\left(\\{\\lambda_{\\alpha}^{(2)},(\\hat{x}_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{\\lambda_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{2}},\\{\\lambda_{\\gamma}^{(2)},\\lambda_{\\alpha,\\beta}^{(2)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\right),</span></p>

    <p class="text-gray-300">where each <span class="math">\\lambda_{\\alpha}^{(1)},\\lambda_{\\alpha}^{(2)}</span> are additive secret shares of a fixed value <span class="math">\\lambda_{\\alpha}</span> (same for <span class="math">\\lambda_{\\alpha,\\beta}^{(1)},\\lambda_{\\alpha,\\beta}^{(2)}</span>), and each <span class="math">(\\hat{x}_{\\alpha})</span> is the masked input <span class="math">x_{\\alpha}+\\lambda_{\\alpha}</span>. Note that this distribution is identically distributed to the following:</p>

    <p class="text-gray-300"><span class="math">M_{01}^{out}=\\left(\\{r_{\\alpha}^{(1)},(\\hat{r}_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{r_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{1}},\\{r_{\\gamma}^{(1)},r_{\\alpha,\\beta}^{(1)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\right),</span> <span class="math">M_{02}^{out}=\\left(\\{(\\hat{r}_{\\alpha}-x_{\\alpha}-r_{\\alpha}^{(1)}),(\\hat{r}_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{r_{\\alpha}^{\\prime}\\}_{\\alpha\\in\\mathsf{Inp}_{2}},\\{r_{\\gamma}^{(2)},\\left((r_{\\alpha}^{(1)}+r_{\\alpha}^{(2)})(r_{\\beta}^{(1)}+r_{\\beta}^{(2)})-r_{\\alpha,\\beta}^{(1)}\\right)\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\right),</span></p>

    <p class="text-gray-300">where all distinct <span class="math">r</span> values are sampled uniformly.</p>

    <p class="text-gray-300">Thus, the random-string exchange claim holds precisely where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">S=\\{0,1\\}</span>: <span class="math">r_{\\{0,1\\}}=\\Big{(}\\{r_{\\alpha}^{(1)}\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{r_{\\alpha}\\}_{\\alpha\\in\\mathsf{Inp}_{1}},\\{r_{\\gamma}^{(1)},r_{\\alpha,\\beta}^{(1)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}</span>.</li>

      <li>For <span class="math">S=\\{0,2\\}</span>: <span class="math">r_{\\{0,2\\}}=\\Big{(}\\{r_{\\alpha}^{\\prime}\\}_{\\alpha\\in\\mathsf{Inp}_{2}}\\{r_{\\gamma}^{(2)}\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}</span>.</li>

      <li>For <span class="math">S=\\{0,1,2\\}</span>: <span class="math">r_{\\{0,1,2\\}}=\\{(\\hat{r}_{\\alpha})\\}_{\\alpha\\in\\mathsf{Inp}_{0}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The remaining communication of the protocol consists of: (1) the non-random remainder of the correlated randomness sent to <span class="math">P_{2}</span>: <span class="math">\\Big{(}\\{(\\hat{r}_{\\alpha}-x_{\\alpha}-r_{\\alpha}^{(1)})\\}_{\\alpha\\in\\mathsf{Inp}_{0}},\\{((r_{\\alpha}^{(1)}+r_{\\alpha}^{(2)})(r_{\\beta}^{(1)}+r_{\\beta}^{(2)})-r_{\\alpha,\\beta}^{(1)})\\}_{((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}}\\Big{)}</span>, and (2) the online portion of the protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span>. Item (1) constitutes no more than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R<span class="math">-elements. Item (2) consists of no more than </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>R$-elements, as analyzed in Section 7.3.1. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-103" class="text-base font-medium mt-4">Claim 7.17.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a three-party protocol <span class="math">\\Pi_{\\mathsf{3PC}}^{mal}</span> in the Random-String Exchange model computing circuit <span class="math">C</span> over <span class="math">R</span>, (statistically) secure against <span class="math">1</span> malicious corruption, with communication pattern as in Claim 7.16, and where the communication complexity of the Standard Communication phase is $3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>R$-elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-104" class="text-base font-medium mt-4">Proof of Claim 7.17.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying the compiler from Theorem 7.3 to <span class="math">\\Pi_{\\mathsf{3PC}}</span>, together with the succinct zero knowledge distributed proof protocol implied by the combination of Theorems 6.6 and 5.8 (for the case of degree <span class="math">d=2</span>), there exists a <span class="math">3</span>-party protocol <span class="math">\\Pi_{\\mathsf{3PC}}^{mal}</span>, which preserves the random-string exchange phase of <span class="math">\\Pi_{\\mathsf{3PC}}</span>, and increases the communication complexity of the Standard Communication phase by $3\\cdot\\mathbf{C}(\\Pi_{\\mathsf{ZK}})\\in o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. The claim follows. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-105" class="text-base font-medium mt-4">Claim 7.18.</h6>

    <p class="text-gray-300">The protocol <span class="math">\\Pi_{\\mathsf{3PC}}^{mal}</span> from Claim 7.17 above is further secure against malicious string choice.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Proof of Claim 7.18.</h6>

    <p class="text-gray-300">Recall the structure of the random-string exchange phase of <span class="math">\\Pi_{\\mathsf{3PC}}</span> (and thus <span class="math">\\Pi_{\\mathsf{3PC}}^{mal}</span>) from Claim 7.16 above: random strings <span class="math">r_{S}</span> are sent for <span class="math">S_{1}:=\\{0,1\\},S_{2}:=\\{0,2\\},S_{3}:=\\{0,1,2\\}</span>, where each string is chosen by representative <span class="math">\\mathsf{rep}(S_{i})=0</span> “dealer” party <span class="math">P_{0}</span>. Proving that <span class="math">\\Pi_{\\mathsf{3PC}}^{mal}</span> is secure against malicious string choice will follow by showing that two modified versions of the protocol remain (malicious) secure, where <span class="math">P_{1}</span> (or <span class="math">P_{2}</span>) selects <span class="math">r_{S}</span> for sets <span class="math">S_{i}</span> in which he is contained:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi_{1}^{mal}</span>, where <span class="math">\\mathsf{rep}(S_{2})=0</span> but <span class="math">\\mathsf{rep}(S_{1})=\\mathsf{rep}(S_{3})=1</span>,</li>

      <li><span class="math">\\Pi_{2}^{mal}</span>, where <span class="math">\\mathsf{rep}(S_{1})=0</span> but <span class="math">\\mathsf{rep}(S_{2})=\\mathsf{rep}(S_{3})=2</span>.</li>

    </ol>

    <p class="text-gray-300">We focus on <span class="math">\\Pi_{1}^{mal}</span>, as this in particular implies security for <span class="math">\\Pi_{2}^{mal}</span>.</p>

    <p class="text-gray-300">Observe that the protocol <span class="math">\\Pi_{1}^{mal}</span> is equivalent to the (Theorem 7.3)-compiled version of a corresponding underlying protocol <span class="math">\\Pi_{1}</span>, defined as <span class="math">\\Pi_{\\mathsf{3PC}}</span> with the modification <span class="math">\\mathsf{rep}(S_{1})=\\mathsf{rep}(S_{3})=1</span>. (Formally, the only difference between <span class="math">\\Pi_{1}^{mal}</span> and <span class="math">\\mathsf{Compile}(\\Pi_{1})</span> is that the strings <span class="math">r_{S_{1}},r_{S_{3}}</span> appear in <span class="math">M_{01}^{out},M_{01}^{in}</span> in the former and <span class="math">M_{10}^{out},M_{10}^{in}</span> in the latter; however, the language structure remains identical.) Thus, by Theorem 7.3, to prove malicious security of <span class="math">\\Pi_{1}^{mal}</span>, it suffices to prove that <span class="math">\\Pi_{1}</span> remains natural.</p>

    <p class="text-gray-300">To prove <span class="math">\\Pi_{1}</span> is natural, as per Definition 7.2, we prove the two required properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulation of <span class="math">\\Pi_{1}^{\\prime}</span> without final round.</li>

    </ul>

    <p class="text-gray-300">Note that simulation directly still holds for corrupt <span class="math">P_{0}</span> or <span class="math">P_{2}</span>. At a very high level, privacy of honest inputs (more formally, simulation) against corrupt <span class="math">P_{1}</span> still holds as for <span class="math">\\Pi_{\\mathsf{3PC}}</span> because all sensitive values are masked by randomness generated and held only by parties <span class="math">P_{0}</span> and <span class="math">P_{2}</span>, which remains untouched in this modified protocol <span class="math">\\Pi_{1}</span>.</p>

    <p class="text-gray-300">In more detail, consider simulation of honest party messages in <span class="math">\\Pi_{1}^{\\prime}</span> in the case of corrupt <span class="math">P_{1}</span> (mirroring the simulation within the proof of Lemma 7.8, except that here <span class="math">P_{1}</span> is corrupt whereas there <span class="math">P_{2}</span> was corrupt):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{0}</span> no longer communicates information to <span class="math">P_{1}</span> in the first round. Instead, receive the corresponding values chosen by <span class="math">P_{1}</span>.</li>

      <li>Simulate messages of honest <span class="math">P_{2}</span> sent to <span class="math">P_{1}</span> in the protocol in an identical manner as in Lemma 7.8:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each input gate <span class="math">\\alpha</span> owned by <span class="math">P_{2}</span>: Sample and send random <span class="math">\\hat{x}_{\\alpha}\\leftarrow R</span>. This is the correct distribution because of the random mask <span class="math">\\lambda_{\\alpha}</span> generated by honest <span class="math">P_{0}</span> and known only to <span class="math">P_{0}</span> and <span class="math">P_{2}</span>.</li>

      <li>For each input gate <span class="math">\\alpha</span> owned by <span class="math">P_{1}</span>: If <span class="math">P_{1}</span> does not send valid <span class="math">R</span>-element, abort.</li>

      <li>For each addition gate: No values communicated.</li>

      <li>For each multiplication gate <span class="math">((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult}</span>: sample and send random <span class="math">\\hat{x}_{\\gamma}^{(2)}</span>. This is the correct distribution of <span class="math">P_{2}</span>’s share of the masked output <span class="math">(x_{\\gamma}+\\lambda_{\\gamma})</span> because <span class="math">P_{2}</span>’s share <span class="math">\\lambda_{\\gamma}^{(2)}</span> of the mask itself is generated by <span class="math">P_{0}</span> and known only to <span class="math">P_{0}</span> and <span class="math">P_{2}</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">P_{1}</span> does not send a valid <span class="math">R</span>-element (allegedly his share <span class="math">\\hat{x}_{\\gamma}^{(2)}</span>), then abort.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each output gate <span class="math">\\gamma\\in\\mathsf{Out}</span>: Same procedure and analysis as for multiplication gate, where a random ring element is sampled and sent. Here, this is the correct distribution, as the correct output value is masked by random <span class="math">\\lambda_{\\gamma}</span>, generated and held only by <span class="math">P_{0}</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Degree-2 encoded languages <span class="math">\\mathcal{L}_{i}</span> which enable simulation of final round.</li>

    </ul>

    <p class="text-gray-300">In Lemma 7.8, degree-2 encoded languages <span class="math">\\mathcal{L}_{0},\\mathcal{L}_{1},\\mathcal{L}_{2}</span> of per-party incoming and outgoing messages were demonstrated for the original protocol <span class="math">\\Pi_{\\mathsf{3PC}}</span> so that given any “<span class="math">\\mathcal{L}_{i}</span>-compatible” transcript, the final message of the protocol can be consistently simulated as required (see Definition 7.2 for the formal requirement description).</p>

    <p class="text-gray-300">For the case of <span class="math">\\Pi_{1}</span>, the only difference from <span class="math">Pi_{\\mathsf{3PC}}</span> is that a subset of strings which were previously contained as outgoing messages from <span class="math">P_{0}</span> and incoming to <span class="math">P_{1}</span>, are now instead contained as outgoing messages from <span class="math">P_{1}</span> and incoming to <span class="math">P_{0}</span>. This means we can restrict to an identical set of <span class="math">\\mathcal{L}_{i}</span> compatible transcripts as for <span class="math">\\Pi_{\\mathsf{3PC}}</span> by means of the tweaked languages <span class="math">\\mathcal{L}_{0}^{\\prime},\\mathcal{L}_{1}^{\\prime},\\mathcal{L}_{2}^{\\prime}</span> with <span class="math">\\mathcal{L}_{2}^{\\prime}\\equiv\\mathcal{L}_{2}</span> and <span class="math">\\mathcal{L}_{0}^{\\prime},\\mathcal{L}_{1}^{\\prime}</span> identical to their counterparts aside from the above syntactic switch between incoming versus outgoing messages. Hence, for any such transcript, simulation of the final round will equivalently be guaranteed.</p>

    <p class="text-gray-300">Combined, this implies that <span class="math">\\Pi_{1}</span> is natural; the claim follows. ∎</p>

    <p class="text-gray-300">Altogether, this concludes the proof of Theorem 7.15. ∎</p>

    <h3 id="sec-107" class="text-xl font-semibold mt-8">7.4 Honest-majority MPC: Beyond 3 parties</h3>

    <p class="text-gray-300">In this section we generalize the 3-party protocol from Section 7.3 by constructing an MPC protocol for <span class="math">n=2t+1</span> parties with security against <span class="math">t</span> malicious parties for evaluating an arithmetic circuit over a ring <span class="math">R</span>. Using a pseudorandom generator for compressing common randomness, the protocol has amortized communication complexity of <span class="math">3t/(2t+1)</span> <span class="math">R</span>-elements per multiplication gate (e.g., 6/5 in the 5-party case, 9/7 in the 7-party case, and less than 1.5 in general). Here <span class="math">R</span> can be any finite field (in particular, <span class="math">R=\\mathbb{F}_{2}</span> for Boolean circuits) as well as a ring of the form <span class="math">\\mathbb{Z}_{w}</span>. As in the 3-party case, our protocol is obtained by applying a rate-1 GMW-style compiler to a similar protocol with security against <span class="math">t</span> semi-honest parties.</p>

    <p class="text-gray-300">Recall that in the 3-party case, we could get away with using distributed zero-knowledge protocols for the simpler “Setting I”, where security is against either a malicious prover or malicious verifier. Here we will need to use protocols for the more challenging “Setting II”, where soundness needs to</p>

    <p class="text-gray-300">hold against a malicious prover who colludes with <span class="math">t-1</span> malicious verifiers. In turn, we must modify the transformation to support this additional malicious behavior.</p>

    <p class="text-gray-300">In particular, this setting requires the statements proved to be robustly encoded, in the sense that they each form a DLC of minimal distance <span class="math">t</span> (see Definition 6.12). However, we then find ourselves in a situation where parties <span class="math">P_{i}</span> no longer know the complete (encoded) statements that justify their proper behavior—a property that was necessary for our generic compiler. For example, consider the following protocol: parties <span class="math">P</span> and <span class="math">P^{\\prime}</span> first <span class="math">t</span>-robustly secret share inputs <span class="math">x</span> and <span class="math">x^{\\prime}</span> across all <span class="math">n</span> parties, then each party <span class="math">P_{i}</span> is instructed to compute and send some function <span class="math">f(x_{i},x_{i}^{\\prime})</span> of his respective shares. The corresponding robust statement to be proved (for the “Setting II” ZK protocol) consists of all parties’ shares of these values, <span class="math">X_{i}:=((x_{1},\\ldots,x_{n}),(x_{1}^{\\prime},\\ldots,x_{n}^{\\prime}),f(x_{i},x_{i}^{\\prime}))</span>. But <span class="math">P_{i}</span> himself only knows <span class="math">x_{i},x_{i}^{\\prime},f(x_{i},x_{i}^{\\prime})</span>. Because of this, here we will make a different type of use of the proof system, where the parties jointly emulate the role of the prover to generate (shares of) the proof, and then play the roles of verifiers to jointly verify. Here we crucially rely on the fact that even though corrupt parties can “additively” tamper with the proof (namely, by adding a known value to each proof entry), this cannot make honest parties accept a false statement nor can it make corrupt parties learn anything they couldn’t have learned via an honestly generated proof. We give the details below.</p>

    <p class="text-gray-300">Protocol overview. At a high level, our protocol roughly follows the template of the protocol of Damgård and Nielsen <em>[55]</em> (see also <em>[66]</em>, Section 5.8 of full version). For circuit <span class="math">C</span>, denote by <span class="math">\\mathsf{Inp},\\mathsf{Add},\\mathsf{Mult},\\mathsf{Out}</span> the set of input, addition, multiplication, and output gates in <span class="math">C</span>. We are interested in proving that for each output gate <span class="math">\\gamma</span>, the shares <span class="math">[x_{\\gamma}]_{t}</span> are indeed robust shares of the correctly evaluated output <span class="math">x_{\\gamma}</span>. Let <span class="math">\\mathcal{L}_{C}</span> denote the <span class="math">C</span>-consistency language, where values of <span class="math">x_{\\gamma}</span> correspond to evaluations on wires of the circuit <span class="math">C</span>:</p>

    <p class="text-gray-300">\\[ \\mathcal{L}_{C}=\\left\\{(x_{\\gamma})_{\\gamma\\in\\mathsf{Wire}}\\ :\\ \\ \\ \\ \\forall((\\alpha,\\beta),\\gamma)\\in\\mathsf{Add},x_{\\gamma}=x_{\\alpha}+x_{\\beta},\\\\ \\ \\ \\ \\forall((\\alpha,\\beta),\\gamma)\\in\\mathsf{Mult},x_{\\gamma}=x_{\\alpha}\\cdot x_{\\beta}.\\right\\}.\\\\ \\] (3)</p>

    <p class="text-gray-300">Note that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{L}_{C}</span> is a degree-2 language.</li>

      <li>Given <span class="math">(x_{\\gamma})_{\\gamma\\in\\mathsf{Wire}}\\in\\mathcal{L}_{C}</span>, it follows that <span class="math">(x_{\\gamma})_{\\gamma\\in\\mathsf{Out}}=C\\big{(}(x_{\\alpha})_{\\alpha\\in\\mathsf{Inp}}\\big{)}</span>; that is, the outputs are correctly <span class="math">C</span>-evaluated on the given input values.</li>

      <li>At the conclusion of execution of <span class="math">\\Pi^{\\prime}</span>, the <span class="math">N</span> parties hold a robust encoding of the relevant statement <span class="math">\\vec{x}:=(x_{\\alpha})_{\\alpha\\in\\mathsf{Wire}}</span>. Note, however, that no single party knows <span class="math">\\vec{x}</span> in the clear.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Analogous to before, the idea will be to run the DN protocol to its penultimate round (denoted by <span class="math">\\Pi^{\\prime}</span>), and then to first prove correctness of computation before exchanging final messages. However, unlike the previous setting, to do so, we will have the parties jointly emulate the prover in generating the proof. In order to emulate this in low communication, we leverage the specific simple structure of the language and corresponding prover algorithm. In particular, the language <span class="math">\\mathcal{L}_{C}</span> is degree 2. By Theorem 5.8, the generation of a succinct ZK-FLPCP for membership in <span class="math">\\mathcal{L}_{C}</span> can itself be computed as a degree-2 function in the statement <span class="math">\\vec{x}</span> and the secret prover randomness, determined by a public random challenge. Thus, the parties can locally convert their robust secret shares of the statement <span class="math">\\vec{x}</span> into additive shares <span class="math">\\langle\\pi\\rangle</span> of the proof, just as in a standard multiplication procedure on shares. These shares are not robust; however, since the size of the ZK-FLPCP is small (in particular, sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">), the parties can afford to each re-share their shares of </span>\\langle\\pi\\rangle<span class="math">, to generate a robust linear encoding of the proof </span>\\pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At this point, the parties now hold robust shares of the alleged <span class="math">C</span>-compliant statement <span class="math">\\vec{x}</span>, as well as robust shares of an alleged proof string <span class="math">\\pi</span> asserting membership <span class="math">\\vec{x}\\in\\mathcal{L}_{C}</span>. (Note that the robust encoding of <span class="math">\\pi</span> can be made to use the same linear decoding function as the encoding of <span class="math">\\vec{x}</span>.) At this</p>

    <p class="text-gray-300">point, the parties can directly emulate the roles of <span class="math">n</span> verifiers in the distributed-verifier protocol of Theorem 6.16 (Section 6.3, plugging in the ZK-FLPCP from Theorem 5.8 for degree 2) to verify in zero knowledge that <span class="math">\\pi</span> indeed asserts the desired membership <span class="math">\\vec{x}\\in\\mathcal{L}_{C}</span>.</p>

    <p class="text-gray-300">CNF sharing. In the protocol description, we use <span class="math">[s]_{t}</span> to denote a <span class="math">t</span>-private secret sharing of a ring element <span class="math">s\\in R</span>, where no <span class="math">t</span> parties know anything about <span class="math">s</span> but every <span class="math">t+1</span> parties can fully reconstruct <span class="math">s</span>. Concretely, we will split a secret <span class="math">s</span> into CNF shares (also known as replicated shares) in the following way: <span class="math">s</span> is first split into <span class="math">\\binom{n}{t}</span> additive shares <span class="math">s_{H}</span>, where <span class="math">H</span> ranges over all potential sets of <span class="math">n-t</span> parties, and each share <span class="math">s_{H}</span> is given to all parties in <span class="math">H</span>. When <span class="math">s</span> is random, all additive shares <span class="math">s_{H}</span> are random and independent ring elements. Note that since an additive share in a CNF sharing is given to <span class="math">n-t=t+1</span> honest parties, then even if we exclude the party acting as a prover the minimal distance of the resulting code is <span class="math">t</span> as required. Hence, from here on the notation <span class="math">[s]_{t}</span> refers to a distributed input in which additive shares <span class="math">s_{H}</span> are replicated among <span class="math">n</span> parties as specified above.</p>

    <p class="text-gray-300">Similarly to Shamir’s secret-sharing scheme, the CNF scheme has the following multiplication property: given arbitrary <span class="math">n</span>-tuples of shares in the support <span class="math">[a]_{t}</span> and <span class="math">[b]_{t}</span>, one can locally compute additive shares <span class="math">\\langle ab\\rangle</span> of <span class="math">ab</span>. Namely, each party <span class="math">P_{i}</span>, based on its share of <span class="math">[a]_{t}</span> and its share of <span class="math">[b]_{t}</span> alone, can compute a ring element <span class="math">c_{i}</span> such that <span class="math">\\sum_{j=0}^{n-1}c_{j}=ab</span>.</p>

    <p class="text-gray-300">A useful feature of CNF sharing is that shares of a random secret can be compressed by replicating <span class="math">\\binom{n}{t}</span> PRF seeds (or keys for a block cipher such as AES in practice). Moreover, such shares can then be locally converted into Shamir shares without any interaction <em>[50, 69]</em>. As in the 3-party case, this type of compression can be used to generate a correlated randomness setup with low communication cost. However, because of the <span class="math">\\binom{n}{t}</span> overhead this method is applicable only when the number of parties <span class="math">n</span> is relatively small.</p>

    <p class="text-gray-300">Distributively generating the ZK proof. Recall more explicitly the structure of the distributed proof system from Section 6.3 against malicious prover and verifiers, for the case of degree-2 locally encoded languages. That is, the language in question <span class="math">\\mathcal{L}_{C}</span> can be expressed via a collection of several degree-2 constraints, as induced by the circuit <span class="math">C</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{\\textsf{coin}}</span> and <span class="math">\\mathcal{F}_{\\textsf{bcast}}</span> denote ideal (public) coin-tossing and broadcast functionalities, as in previous sections. Inputs: The prover holds the statement <span class="math">\\vec{x}</span>. The verifiers hold robust CNF shares <span class="math">[\\vec{x}]</span> of <span class="math">\\vec{x}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifiers run <span class="math">\\mathcal{F}_{\\textsf{coin}}</span> to jointly learn randomness <span class="math">r</span>, used to define a random linear combination of the output values of the constraint circuit <span class="math">C</span> for the prover (in Step 2).</li>

      <li>The prover samples private randomness <span class="math">r_{P}</span> and random CNF shares <span class="math">[r_{P}^{\\textsf{test}}]</span>.</li>

    </ol>

    <p class="text-gray-300">He computes a degree-2 function <span class="math">\\pi=\\textsf{Prove}_{C,r}(\\vec{x};r_{P})</span> of the input <span class="math">\\vec{x}</span> and <span class="math">r_{P}</span>.</p>

    <p class="text-gray-300">He then robustly CNF shares <span class="math">\\pi</span>, as <span class="math">[\\pi]</span>. He distributes the shares <span class="math">[r_{P}^{\\textsf{test}}]</span> and <span class="math">[\\pi]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifiers run <span class="math">\\mathcal{F}_{\\textsf{coin}}</span> to jointly learn randomness <span class="math">r^{\\prime}</span> to define verifier queries (linear functions of statement <span class="math">[\\vec{x}]</span> and proof <span class="math">[\\pi]</span>), exchange shares of the corresponding answers via <span class="math">\\mathcal{F}_{\\textsf{bcast}}</span>. This incorporates both the “Test membership of <span class="math">\\vec{x}</span> in <span class="math">\\mathcal{C}</span>” linear code step, as well as the verifier queries for the underlying ZK-FLPCP. Based on the answers, each verifier accepts or rejects.</li>

    </ol>

    <p class="text-gray-300">Section 6.3 addressed a setting with a single prover and multiple verifiers. In the present setting, the role of the prover itself will be jointly emulated by the parties. Concretely, the actions of verifiers in Steps 1 and 3 remain unchanged, and the single-prover Step 2 is replaced by the multi-party emulation Step 2^{′} below.</p>

    <p class="text-gray-300">Here, <span class="math">\\mathcal{F}_{\\textsf{coin}}^{\\text{priv}}</span> denotes a private coin-tossing functionality, where the parties receive secret shares of the random string. <span class="math">\\mathcal{F}_{\\textsf{coin}}^{\\text{priv}}</span> can be securely realized via a standard coin-tossing protocol based on</p>

    <p class="text-gray-300">verifiable secret sharing, with the final “reveal” communication round removed.</p>

    <p class="text-gray-300">Inputs: The parties hold robust CNF shares <span class="math">[\\vec{x}]</span> of the statement <span class="math">\\vec{x}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties run <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> to jointly learn public verifier randomness <span class="math">r</span>.</li>

    </ol>

    <p class="text-gray-300">2'. The parties run <span class="math">\\mathcal{F}_{\\mathrm{coin}}^{\\mathrm{priv}}</span> to receive robust linear shares <span class="math">[r_P]</span> and <span class="math">[r_P^{\\mathrm{test}}]</span> of private prover randomness.</p>

    <p class="text-gray-300">Each party evaluates the degree-2 function <span class="math">\\mathsf{Prove}_{C,r}</span> on his robust shares <span class="math">[\\vec{x}]</span> and <span class="math">[r_P]</span> to yield an additive share <span class="math">\\langle \\pi \\rangle = \\mathsf{Prove}_{C,r}([\\vec{x}],[r_P])</span>.</p>

    <p class="text-gray-300">In order to proceed, the parties need robust shares of <span class="math">\\pi</span>. To do so:</p>

    <p class="text-gray-300">(a) Each party verifiably secret shares (VSS) robust CNF shares <span class="math">[\\pi_i]</span> of his additive share <span class="math">\\pi_{i}</span>. (b) Locally, each party computes his robust linear share of <span class="math">\\pi</span> by adding the shares of each <span class="math">\\pi_{i}</span>. That is, <span class="math">[\\pi] := \\sum_{i \\in [n]} [\\pi_i]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties run <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> to jointly learn public verifier query randomness <span class="math">r&#x27;</span>, compute and exchange shares of the corresponding answers (as a function of <span class="math">[\\vec{x}], [r_P^{\\mathrm{test}}]</span>, and <span class="math">[\\pi])</span> via <span class="math">\\mathcal{F}_{\\mathrm{bcast}}</span>. Based on the answers, each verifier accepts or rejects.</li>

    </ol>

    <p class="text-gray-300">Note that the verifiable secret sharing (VSS) protocol is run only for secrets the size of the proof length, which will be sublinear in the circuit size (and thus its communication amortized away).⁵</p>

    <p class="text-gray-300">As mentioned earlier, this yields a slightly larger attack space here than in the single-prover setting, in that corrupt parties can also “additively” tamper with the proof (namely, adding a known value to each proof entry) while it is in the non-robust shared form <span class="math">\\langle \\pi \\rangle</span>. However, this will still preserve the necessary soundness and zero knowledge: with soundness following from the “Type II” guarantees (since the corrupt parties will ultimately be committed to a single malicious proof string <span class="math">\\pi</span> via the VSS of robust <span class="math">[\\pi]_t</span>), and zero knowledge holding in the same manner as in the “Type I” protocol analysis (where corrupt verifiers anyway held additive shares of the honest proof <span class="math">\\langle \\pi \\rangle</span>).</p>

    <p class="text-gray-300">The <span class="math">n</span>-party protocol. We now combine all the pieces. Let <span class="math">C</span> be an arithmetic circuit over a ring <span class="math">R</span>. We describe a protocol <span class="math">\\Pi_t</span> with <span class="math">n = 2t + 1</span> parties, denoted <span class="math">P_0, P_1, \\ldots, P_{n-1}</span>, that computes <span class="math">C</span> with security against <span class="math">t</span> semi-honest parties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">\\mathsf{Prove}_{C,r}</span> the degree-2 mapping over <span class="math">R</span> that converts the statement $\\vec{x} = (x_{\\alpha})_{\\alpha \\in \\mathsf{Wire}} \\in R^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and (private) randomness </span>r_P<span class="math"> into a FLPCP proof </span>\\pi \\in R^m<span class="math"> asserting membership </span>\\vec{x} \\in \\mathcal{L}_C<span class="math"> for the </span>C<span class="math">-compliance language </span>\\mathcal{L}_C$ as in Equation (3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Protocol <span class="math">\\Pi_{nPC}</span></strong>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Inputs: Ring elements <span class="math">x_{1}, \\ldots, x_{m} \\in R</span> are partitioned between the <span class="math">n</span> parties <span class="math">P_{0}, P_{1}, \\ldots, P_{n-1}</span>, where each input <span class="math">x_{i}</span> is owned by a single party <span class="math">P_{j}</span>.</li>

      <li>Correlated randomness setup: For each multiplication gate <span class="math">\\gamma</span>, we have the following types of shares:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">[\\lambda_{\\gamma}]_t</span>, for random <span class="math">\\lambda_{\\gamma} \\in R</span>;</li>

      <li>Additive shares <span class="math">\\langle \\lambda_{\\gamma} \\rangle</span> of <span class="math">\\lambda_{\\gamma}</span>.</li>

      <li><span class="math">[s_{\\gamma}]_t</span>, for random <span class="math">s_{\\gamma} \\in R</span>, where <span class="math">s_{\\gamma}</span> is shared between <span class="math">P_{1}, \\ldots, P_{n-1}</span> and is known to <span class="math">P_{0}</span>.</li>

    </ol>

    <p class="text-gray-300">// CNF shares of (many) random values can be generated by using <span class="math">\\binom{n}{t}</span> independent vectors of random ring elements, where each vector is known to <span class="math">t + 1</span> parties (selected and communicated by a canonically chosen party within the corresponding <span class="math">(t + 1)</span>-size set). In the final protocol, each of the vectors will be generated pseudo-randomly from a short PRF seed given to the corresponding subset of parties.</p>

    <p class="text-gray-300">⁵ VSS of a value <span class="math">x</span> can be achieved, e.g., by sending robust shares <span class="math">[x]_t</span> and of a random value <span class="math">[r]_t</span> and then revealing a public random linear combination of these shares, as in the DLC membership test.</p>

    <p class="text-gray-300">// Note that additive shares of <span class="math">\\langle \\lambda_{\\gamma} \\rangle</span> can be generated freshly from the CNF shares <span class="math">[\\lambda_{\\gamma}]_t</span> together with fresh additive secret shares of 0. The latter can be compressed, e.g., by giving each pair of parties a short PRF seed, and defining each party's additive share as the sum of all his PRF evaluations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Online phase:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>INPUT SHARING: For each <span class="math">x_i</span> owned by <span class="math">P_j</span>, <span class="math">P_j</span> shares <span class="math">x_i</span> by generating shares <span class="math">[x_i]_t</span> and distributing the shares between the <span class="math">n</span> parties.</li>

    </ol>

    <p class="text-gray-300">// Optional optimization: if <span class="math">[s_i]_t</span> for a random <span class="math">s_i \\in R</span> known to <span class="math">P_j</span> is distributed during the setup, then it suffices to send the correction value <span class="math">\\Delta_i = x_i - s_i</span> to the set of <span class="math">t</span> parties <span class="math">T = \\{i + 1, i + 2, \\ldots, i + t\\}</span>, where party indices are taken modulo <span class="math">n</span>. Given this correction information, the parties can locally compute valid shares of <span class="math">[\\Delta_i]_t</span> (where the shares of <span class="math">i - 1, \\ldots, i - t</span> are set to 0) and obtain the shares <span class="math">[x_i]_t</span> by locally adding <span class="math">[s_i]_t</span> and <span class="math">[\\Delta_i]_t</span>. This optimization reduces the online communication per input to a total of <span class="math">t</span> ring elements and makes the input sharing part of the online phase deterministic.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GATE-BY-GATE EVALUATION: Suppose gate <span class="math">\\gamma</span> takes inputs <span class="math">\\alpha</span> and <span class="math">\\beta</span>, where the shares <span class="math">[x_{\\alpha}]_t</span> and <span class="math">[x_{\\beta}]_t</span> of the gate inputs have already been computed. The shares <span class="math">[x_{\\gamma}]_t</span> are computed as follows.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Addition: If <span class="math">\\gamma = \\alpha + \\beta</span>, the parties locally compute <span class="math">[x_{\\gamma}]_t \\gets [x_{\\alpha}]_t + [x_{\\beta}]_t</span> (similarly for subtraction).</li>

    </ul>

    <p class="text-gray-300">// Deterministic local computation</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Multiplication: If <span class="math">\\gamma = \\alpha \\cdot \\beta</span>, the parties perform the following:</li>

    </ul>

    <p class="text-gray-300">(a) Using the multiplication property of CNF shares, the <span class="math">n</span> parties compute an additive sharing <span class="math">\\langle x_{\\gamma} \\rangle</span> of <span class="math">x_{\\gamma}</span> from <span class="math">[x_{\\alpha}]_t</span> and <span class="math">[x_{\\beta}]_t</span>. // Deterministic local computation</p>

    <p class="text-gray-300">(b) Parties <span class="math">P_1, \\ldots, P_{n-1}</span> send to <span class="math">P_0</span> their shares of <span class="math">\\langle x_{\\gamma} \\rangle + \\langle \\lambda_{\\gamma} \\rangle</span>. // Communicating <span class="math">n - 1</span> ring elements</p>

    <p class="text-gray-300">(c) <span class="math">P_0</span> reconstructs <span class="math">x_{\\gamma} + \\lambda_{\\gamma}</span> by adding its <span class="math">n</span> shares and re-shares it as <span class="math">[x_{\\gamma} + \\lambda_{\\gamma}]_t</span>. // Communicating <span class="math">t</span> ring elements given the random <span class="math">[s_{\\gamma}]_t</span> generated in setup</p>

    <p class="text-gray-300">(d) Parties locally compute <span class="math">[x_{\\gamma}]_t = [x_{\\gamma} + \\lambda_{\\gamma}]_t - [\\lambda_{\\gamma}]_t</span>. // Deterministic local computation</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PROVE CORRECTNESS: Denote by <span class="math">[\\vec{x}]_t = ([x_\\alpha]_t)_{\\alpha \\in \\mathsf{Wire}}</span> the (robust) shares of the alleged wire values for each wire in the circuit <span class="math">C</span>, as produced by the Gate-by-Gate Evaluation. The parties jointly emulate the prover and verifiers of the <span class="math">n</span>-verifier zero-knowledge distributed proof system Protocol <span class="math">\\Pi_{\\mathrm{dist}}</span> from Theorem 6.16 (Section 6.3.3), for proving <span class="math">[\\vec{x}] \\in \\mathcal{L}_C</span>. This takes place as follows.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Emulate Verifier Phase I: Run <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> to jointly learn public verifier randomness <span class="math">r</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Emulate Prover: Run <span class="math">\\mathcal{F}_{\\mathrm{coin}}^{\\mathrm{priv}}</span> to receive random robust linear shares <span class="math">[r_P^{\\mathrm{test}}]_t</span>.</li>

    </ul>

    <p class="text-gray-300">Jointly generate (robust shares of) proof <span class="math">\\pi</span> for asserting <span class="math">[\\vec{x}]_t \\in \\mathcal{L}_C</span>:</p>

    <p class="text-gray-300">(a) Run <span class="math">\\mathcal{F}_{\\mathrm{coin}}^{\\mathrm{priv}}</span> to receive robust linear shares <span class="math">[r_P]_t</span> of private prover randomness <span class="math">r_P</span>.</p>

    <p class="text-gray-300">(b) Each party evaluates the degree-2 function <span class="math">\\mathsf{Prove}_{C,r}</span> on his robust shares <span class="math">[\\vec{x}]_t</span> and <span class="math">[r_P]_t</span> to yield an additive share <span class="math">\\langle \\pi \\rangle = \\mathsf{Prove}_{C,r}([\\vec{x}]_t, [r_P]_t)</span>.</p>

    <p class="text-gray-300">(c) Each party Verifiably Secret Shares robust CNF shares <span class="math">[\\pi_i]_t</span> of his additive share <span class="math">\\pi_i</span>.</p>

    <p class="text-gray-300">(d) Locally, each party computes his robust linear share of <span class="math">\\pi</span> by adding the shares of</p>

    <p class="text-gray-300">each <span class="math">\\pi_i</span>. That is, <span class="math">[\\pi]_t := \\sum_{i=0}^n [\\pi_i]_t</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Emulate Verifier Phase II: Jointly verify <span class="math">[\\pi]_t</span> as asserting <span class="math">[\\vec{x}]_t \\in \\mathcal{L}_C</span>:</li>

    </ul>

    <p class="text-gray-300">(a) Run <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> to learn public verifier randomness <span class="math">r&#x27; = (r_1&#x27;, r_2&#x27;)</span>, received by all parties.</p>

    <p class="text-gray-300">(b) (Test membership of <span class="math">[\\vec{x}]_t</span> in DLC) Each party broadcasts (via <span class="math">\\mathcal{F}_{\\mathrm{bcast}}</span>) linear combinations of <span class="math">[\\vec{x}]_t</span> and <span class="math">[r_P^{\\mathrm{test}}]_t</span> as dictated by randomness <span class="math">r_1&#x27;</span>. If the resulting shares do not form a valid robust CNF codeword, then abort. Otherwise, continue.</p>

    <p class="text-gray-300">(c) (Test membership of <span class="math">[\\vec{x}]_t</span> in <span class="math">\\mathcal{L}_C</span>) The parties emulate verifiers <span class="math">V_0, \\ldots, V_{n-1}</span> in the "Emulating II" step of the <span class="math">n</span>-verifier zero-knowledge protocol for locally encoded languages on common randomness <span class="math">r</span> (Protocol <span class="math">\\Pi_{\\mathrm{dist}}</span> from Section 6.16). Namely, broadcast (via <span class="math">\\mathcal{F}_{\\mathrm{bcast}}</span>) linear combinations of <span class="math">[\\vec{x}]_t</span> and <span class="math">[\\pi]_t</span> as dictated by public randomness <span class="math">r_2&#x27;</span>.</p>

    <p class="text-gray-300">(d) If the verifier output given these values is "reject," then abort. (Recall that all honest verifiers will agree on accept/reject.) Otherwise, continue to Output Reconstruction below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>OUTPUT RECONSTRUCTION:</li>

    </ol>

    <p class="text-gray-300">(a) For each output gate <span class="math">\\gamma</span> whose shares <span class="math">[x_{\\gamma}]_t</span> have been computed, all parties send their shares to <span class="math">P_0</span>.</p>

    <p class="text-gray-300">(b) If the received set of shares is inconsistent, <span class="math">P_0</span> aborts. Otherwise he reconstructs <span class="math">x_{\\gamma}</span> from the shares and outputs <span class="math">x_{\\gamma}</span>.</p>

    <p class="text-gray-300">Communication complexity. We consider the amortized communication complexity per multiplication gate (which is not sensitive to the above optional optimizations for input and output gates), and ignore the cost of the setup. The latter will be amortized away in the final protocol by using pseudorandomness. This leaves the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Processing a multiplication gate involves communication of <span class="math">(n - 1) + t = 3t</span> ring elements: namely, <span class="math">(n - 1)</span> additive shares <span class="math">\\langle x_{\\gamma} + \\lambda_{\\gamma} \\rangle</span> communicated to party <span class="math">P_0</span>, as well as <span class="math">(n - 1) - t = t</span> elements returned from <span class="math">P_0</span> to determine the <span class="math">t</span>-robust shares <span class="math">[x_{\\gamma} + \\lambda_{\\gamma}]_t</span> (since <span class="math">t</span> shares may be pseudorandom).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving &amp; verifying correctness of computation requires the following communication:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execution of <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span> and <span class="math">\\mathcal{F}_{\\mathrm{coin}}^{\\mathrm{priv}}</span> to generate verifier and prover randomness.</li>

    </ol>

    <p class="text-gray-300">(This communication can be amortized away using pseudorandomness.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As part of the membership test of the linear code, each party executes <span class="math">\\mathcal{F}_{\\mathrm{bcast}}</span> of his CNF share of the linear combinations of <span class="math">[\\vec{x}]</span> and <span class="math">[r_P^{\\mathrm{test}}]</span>. The resulting communication is independent of the circuit size.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each party VSS distributes robust shares of his (additive) share of the proof, <span class="math">[\\pi_i]_t</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The communication scales with $n^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By Theorem 5.8, the proof size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is sublinear in the circuit size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The parties emulate verifiers within the <span class="math">n</span>-verifier zero-knowledge interactive argument (capturing both Phase I and Phase II in the description above).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From Theorem 6.16, the required verifier-verifier communication is sublinear in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Overall, we have (amortized) <span class="math">3t / (2t + 1) &amp;lt; 1.5</span> ring elements per multiplication gate per party.</p>

    <p class="text-gray-300">Theorem 7.19 (Malicious honest-majority MPC for a constant number of parties). Let <span class="math">R</span> be either a finite field or a ring of the form <span class="math">\\mathbb{Z}_w</span> and let <span class="math">t \\geq 1</span> be a positive integer. Then, for any <span class="math">R</span>-arithmetic</p>

    <p class="text-gray-300">64</p>

    <p class="text-gray-300">circuit <span class="math">C</span>, there exists an <span class="math">n</span>-party protocol for computing <span class="math">C</span>, where <span class="math">n = 2t + 1</span>, with the following features:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol makes a black-box use of any pseudorandom generator. If <span class="math">R</span> is a field, it also makes a black-box use of <span class="math">R</span>.</li>

      <li>The protocol is computationally secure with abort against <span class="math">t</span> malicious parties.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The communication complexity is $\\frac{3t}{2t + 1} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> elements of </span>R<span class="math"> per party, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the number of multiplication gates in </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof Sketch. We describe a simulator for the above-specified protocol, loosely analogous to our semi-honest to malicious compiler (Theorem 7.3) together with our construction of sublinear zero-knowledge proofs for distributed low-degree languages in the "Type II" setting of malicious prover and verifiers (Theorem 6.16), and standard pseudorandom compression.</p>

    <p class="text-gray-300">At a high level, note that (1) <span class="math">\\Pi&#x27;</span> is fully simulatable on its own, (2) by strong zero knowledge, the view of the parties acting as verifiers is simulatable, and (3) the final exchange of messages consists only of robust secret shares of the output values. Thus in order to simulate, it suffices to guarantee that the output shares held by honest parties are either consistent shares of the correct output value (with respect to the inputs extracted by the simulator), or that the protocol will catch the inconsistency and abort before these messages are exchanged.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove that <span class="math">\\Pi_{mal}</span> is maliciously secure by demonstrating a simulator, <span class="math">\\mathsf{Sim}_{mal}</span>. Fix adversary <span class="math">\\mathcal{A}</span> (without loss of generality, input-less and deterministic), and corrupted set <span class="math">T \\subset [N]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">. Let </span>H = [n] \\setminus T$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Simulator <span class="math">\\mathsf{Sim}_{mal}^{\\mathcal{A}}((x_i)_{i\\in T})</span>:</p>

    <p class="text-gray-300">We will sometimes denote by <span class="math">[x]_T, [x]_H</span> (respectively, <span class="math">\\langle x \\rangle_T, \\langle x \\rangle_H</span>) the corresponding corrupt-party and honest-party shares of the CNF-shared value <span class="math">x</span> (resp., additively shared).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate CORRELATED RANDOMNESS SETUP. Sample bogus CNF shares of 0 for each of <span class="math">[\\lambda_{\\gamma}]_T, [s_{\\gamma}]_T</span> and bogus additive shares of 0 for each <span class="math">\\langle \\lambda_{\\gamma} \\rangle_T</span>.</li>

      <li>Simulate INPUT SHARING and GATE-BY-GATE EVALUATION steps—i.e., the truncated protocol <span class="math">\\Pi&#x27;</span>—using the simulator <span class="math">S_{\\Pi&#x27;}</span>. More concretely, the simulation takes place as follows.</li>

    </ol>

    <p class="text-gray-300">A maintained invariant is that for each evaluated gate output, corresponding to a wire value <span class="math">x_i</span>, the simulator simulator knows the "correct" corrupt-party set of shares <span class="math">[x_i]_T</span>.</p>

    <p class="text-gray-300">(a) INPUT SHARING</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input gate owned by honest party: Generate and send bogus CNF shares <span class="math">[x_i]_T</span> of 0.</li>

      <li>Input gate owned by corrupt party: Receive CNF shares <span class="math">[x_i]_H</span> from corresponding corrupt party. Extract the input value as <span class="math">x_i&#x27; = \\mathsf{Recon}([x_i]_H)</span>. Extrapolate the corrupt-party shares <span class="math">[x_i]_T</span> given these honest party shares.</li>

    </ul>

    <p class="text-gray-300">(b) GATE-BY-GATE EVALUATION.</p>

    <p class="text-gray-300">For each addition gate: locally update corrupt-party shares as <span class="math">[x_{\\gamma}]_T = [x_{\\alpha}]_T + [x_{\\beta}]_T</span>.</p>

    <p class="text-gray-300">Each multiplication gate: Note that at each gate, the simulator knows the corrupt-party CNF shares <span class="math">[x_{\\alpha}]_T</span>, <span class="math">[x_{\\beta}]_T</span> of the two input values <span class="math">x_{\\alpha}</span> and <span class="math">x_{\\beta}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">P_0</span> is corrupt: Sample and send to <span class="math">P_0</span> random additive shares <span class="math">\\langle x_{\\gamma} + \\lambda_{\\gamma} \\rangle_H</span> on behalf of the honest parties. Receive back CNF shares <span class="math">[x_{\\gamma} + \\lambda_{\\gamma}]_H</span>; extrapolate the corrupt-party shares <span class="math">[x_{\\gamma} + \\lambda_{\\gamma}]_T</span>.</li>

      <li>If <span class="math">P_0</span> is honest: Receive shares <span class="math">\\langle x_{\\gamma} \\rangle_T</span> from corrupt parties. Ignore these values, and sample and distribute fresh CNF shares <span class="math">[x_{\\gamma} + \\lambda_{\\gamma}]_T</span> of 0 to the corrupt parties.</li>

    </ul>

    <p class="text-gray-300">Note that the simulated view includes the "correct" corrupt-party shares of all wire values:</p>

    <p class="text-gray-300">65</p>

    <p class="text-gray-300">either reconstructed from the shares sent to honest parties by corrupt party <span class="math">P_0</span>, or as sent out directly by honest <span class="math">P_0</span> to the corrupt parties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate Prove Correctness step:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate Verifier Phase I: Sample random <span class="math">r</span>; simulate this as the public output of <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span>.</li>

      <li>Simulate Prover Emulation:</li>

    </ul>

    <p class="text-gray-300">(a) Sample bogus CNF shares of 0 for <span class="math">[r_P^{\\mathrm{test}}]_T</span> and <span class="math">[r_P]_T</span>. Simulate these values as the output of the calls to the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{coin}}^{\\mathrm{priv}}</span>.</p>

    <p class="text-gray-300">(b) For each honest party: VSS the bogus value 0, resulting in corrupt-party shares <span class="math">[\\pi_i]_T</span>.</p>

    <p class="text-gray-300">(c) For each corrupt party <span class="math">i</span>:</p>

    <p class="text-gray-300">i. Compute the expected correct share <span class="math">\\pi_i = \\mathsf{Prove}_{C,r}([\\vec{x}], [\\pi])</span> that party <span class="math">i</span> should have computed, given his shares (as known by the simulator from <span class="math">[\\vec{x}]_T, [\\pi]_T</span>).</p>

    <p class="text-gray-300">ii. Extract the shared value <span class="math">\\pi_i&#x27;</span> from party <span class="math">i</span>'s VSS.</p>

    <p class="text-gray-300">iii. Let <span class="math">\\pi_i^* := \\pi_i&#x27; - \\pi_i</span>.</p>

    <p class="text-gray-300">Compute the overall adversarial additive offset to <span class="math">\\pi</span>: i.e., let <span class="math">\\pi^<em> = \\sum_{i \\in T} \\pi_i^</em></span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate Verifier Phase II:</li>

    </ul>

    <p class="text-gray-300">(a) Denote by <span class="math">\\mathcal{A}_{\\mathsf{ZK}}</span> the adversarial verifier strategy for corrupt verifiers <span class="math">T \\subset [n]</span> in the security game of the distributed-verifier strong ZK proof induced by executing <span class="math">\\mathcal{A}</span> on the simulated view up to this point.</p>

    <p class="text-gray-300">Execute the strong zero-knowledge simulator for this adversary <span class="math">\\mathcal{A}_{\\mathsf{ZK}}</span> to simulate the view of corrupted verifiers with respect to the correct proof <span class="math">\\pi</span>, given the corrupt-party shares of the statement <span class="math">[\\vec{x}]_T = ([x_i]_T)_{i \\in \\mathsf{Wire}}</span>. Note that this consists of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier randomness <span class="math">r&#x27; = (r_1&#x27;, r_2&#x27;)</span>,</li>

      <li>Broadcasted DLC test shares <span class="math">\\{v_i\\}_{i \\in H}</span> (as a function of <span class="math">r_1&#x27;</span>, <span class="math">[\\vec{x}]</span>, and <span class="math">[r_P^{\\mathrm{test}}]</span>),</li>

      <li>Broadcasted verifier answers <span class="math">\\{a_i\\}_{i \\in H}</span> (as a function of <span class="math">r_2&#x27;</span>, <span class="math">[\\vec{x}]</span>, and <span class="math">[\\pi]</span>).</li>

    </ul>

    <p class="text-gray-300">(b) Simulate messages as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate <span class="math">r&#x27;</span> as the output of <span class="math">\\mathcal{F}_{\\mathrm{coin}}</span>.</li>

      <li>Simulate the honest parties broadcasting <span class="math">\\{v_i\\}_{i \\in H}</span> as their DLC test shares.</li>

      <li>Simulate the honest parties broadcasting <span class="math">\\{a_i + \\langle r_2&#x27;, \\pi^<em> \\rangle\\}_{i \\in H}</span> as their verifier answers. This incorporates the (simulatable) effect of the additive-offset attack <span class="math">\\pi&#x27; = \\pi + \\pi^</em></span> on the proof <span class="math">\\pi</span>. (Denote <span class="math">a_i&#x27; = a_i + \\langle r_2&#x27;, \\pi^* \\rangle</span>.)</li>

    </ul>

    <p class="text-gray-300">(c) Receive values <span class="math">\\{v_i&#x27;\\}_{i \\in T}</span> and <span class="math">\\{a_i&#x27;\\}_{i \\in T}</span> from corrupt parties. For each corrupt party <span class="math">i</span>:</p>

    <p class="text-gray-300">i. Compute the expected correct DLC-test share <span class="math">v_i</span> that party <span class="math">i</span> should have computed, given <span class="math">r_1&#x27;</span> and his shares of <span class="math">[\\vec{x}]</span> and <span class="math">[r_P^{\\mathrm{test}}]</span> (as known by the simulator from <span class="math">[\\vec{x}]_T, [r_P^{\\mathrm{test}}]_T</span>).</p>

    <p class="text-gray-300">If <span class="math">v_i&#x27; \\neq v_i</span>, then simulate verifier rejection (and simulation terminates).</p>

    <p class="text-gray-300">ii. Simulate the honest verifier accept/reject output given the full set of answer shares <span class="math">\\{a_i&#x27;\\}_{i \\in [n]}</span>. If any party rejects as verifier, terminate simulation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, simulate the final step of the protocol as follows.</li>

    </ol>

    <p class="text-gray-300">(a) Denote the set of all extracted corrupt-party inputs (from the Input Sharing simulation step above) by <span class="math">x_T&#x27;</span>.</p>

    <p class="text-gray-300">(b) Call the ideal functionality <span class="math">\\mathcal{F}_C</span> on the extracted corrupt-party inputs, obtaining output</p>

    <p class="text-gray-300">66</p>

    <p class="text-gray-300"><span class="math">y=\\mathcal{F}_{C}((x^{\\prime}_{i})_{i\\in T},(x_{i})_{i\\not\\in T})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the final step depending on whether party <span class="math">P_{0}</span> is corrupt or honest:</li>

    </ol>

    <p class="text-gray-300">For each output gate <span class="math">\\gamma</span>: Denote by <span class="math">[x_{\\gamma}]_{T}</span> the shares of <span class="math">x_{\\gamma}</span> held by corrupt parties from the <span class="math">\\Pi^{\\prime}</span> simulation above.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">P_{0}</span> is corrupt: Reverse sample a set of robust CNF shares for honest parties <span class="math">[x_{\\gamma}]_{H}</span>, consistent with corrupt shares <span class="math">[x_{\\gamma}]_{T}</span> and the corresponding reconstructed value <span class="math">y_{\\gamma}</span>.</li>

    </ul>

    <p class="text-gray-300">Simulate sending <span class="math">[x_{\\gamma}]_{H}</span> to <span class="math">P_{0}</span>, on behalf of the corresponding honest parties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">P_{0}</span> is honest: If the corrupt parties send exactly the values <span class="math">[x_{\\gamma}]_{T}</span>, then simulate the adversary allowing output delivery to honest parties. Otherwise, simulate adversarial abort.</li>

    </ul>

    <p class="text-gray-300">This concludes the description of the simulator.</p>

    <p class="text-gray-300">To demonstrate indistinguishability of the simulated execution, consider the parts of the protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup, Input Sharing, Gate-by-gate Evaluation. The preprocessing and “truncated DN” protocol are perfectly simulated. The setup and honest-party input sharing consist of secret shares where corrupt parties form an unauthorized set. For each multiplication, the value <span class="math">x_{\\gamma}+\\lambda_{\\gamma}</span> communicated from honest parties and reconstructed is perfectly masked by a fresh random string <span class="math">\\lambda_{\\gamma}</span> from the preprocessing.</li>

      <li>Prove Correctness. Correct simulation holds by the hiding of the CNF shares together with the strong zero knowledge of the underlying distributed-verifier protocol. Note that the effect of additive-offset attack is properly simulated, as in the “Setting I” proof protocol from Theorem 6.6 (see Section 6.2).</li>

      <li>Output Reconstruction. Completeness: If <span class="math">[\\vec{x}]</span> is indeed contained within <span class="math">\\mathcal{L}_{C}</span> and all parties compute <span class="math">\\mathsf{Prove}_{C,r}</span> honestly, then correctness of degree-2 computations on CNF robust secret shares implies that the additive shares <span class="math">\\langle\\pi\\rangle</span> indeed add to a valid proof <span class="math">\\pi</span> that will be accepted within verification.</li>

    </ul>

    <p class="text-gray-300">Suppose, then, the parties accept the proof of <span class="math">[\\vec{x}]\\in\\mathcal{L}_{C}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By soundness of the distributed-verifier interactive proof system, then (with overwhelming probability) it holds that indeed <span class="math">[\\vec{x}]</span> is contained within the language <span class="math">\\mathcal{L}_{C}</span>. By definition of <span class="math">\\mathcal{L}_{C}</span> (together with robustness of the CNF shares), this implies that the final set of CNF output shares encodes the correct output <span class="math">y</span> of the circuit on the input values that were secret shared in the Input Sharing phase. These input values are precisely the honest party inputs <span class="math">x_{\\alpha}</span>, together with the inputs of corrupt parties <span class="math">x^{\\prime}_{\\alpha}</span> extracted by the simulator within this phase.</li>

      <li>Suppose, then, that the parties hold a valid (consistent) set of CNF shares of <span class="math">y</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">P_{0}</span> is corrupt: Then in an honest execution, the corrupt party <span class="math">P_{0}</span> receives (fresh random) CNF shares from honest parties of the output value <span class="math">y</span>, subject to being consistent with the shares <span class="math">[y]_{T}</span> that are held by corrupt parties. This is precisely as simulated.</li>

      <li>If <span class="math">P_{0}</span> is honest: Recall that CNF shares consist of a collection of random values, given to each of the different subsets of <span class="math">(t+1)</span> parties. Since the corruption threshold is <span class="math">t</span>, this implies that each secret value held by a corrupt party is also held by at least one honest party. In particular, in order to send a fully consistent set of shares of <span class="math">y</span>, there is no cheating space for the corrupt parties: they must send precisely the share values given in the previous part of execution, otherwise they will be identified and</li>

    </ul>

    <p class="text-gray-300">rejected. Thus, simulation again matches.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-108" class="text-2xl font-bold">8 Conclusions</h2>

    <p class="text-gray-300">We have demonstrated that fully linear proof systems capture many existing techniques for zero-knowledge proof on secret-shared, encrypted, or committed data. We presented new constructions of zero-knowledge fully linear PCPs and IOPs for “simple” languages with sublinear proof size, and demonstrated the usefulness of such proof systems to protecting secret-sharing based MPC protocols against malicious parties with low communication overhead.</p>

    <p class="text-gray-300">Despite some progress obtained in this work and in prior related works, there is a lot more to understand about the power of (fully) linear PCPs and their interactive variants. We mention a couple of concrete open questions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>To what extent are the tradeoffs we obtain for low-degree languages optimal? In particular, is there a linear PCP of size <span class="math">o(n)</span> for the language $\\mathcal{L}_{\\{0,1\\}^{n}}\\stackrel{{\\scriptstyle\\rm{\\scriptstyle{\\rm{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[5] Araki, T., Furukawa, J., Lindell, Y., Nof, A., Ohara, K.: High-throughput semi-honest secure three-party computation with an honest majority. In: ACM CCS (2016)</li>

      <li>[6] Arora, S., Lund, C., Motwani, R., Sudan, M., Szegedy, M.: Proof verification and the hardness of approximation problems. Journal of the ACM 45(3), 501–555 (1998)</li>

      <li>[7] Arora, S., Safra, S.: Probabilistic checking of proofs: A new characterization of NP. Journal of the ACM 45(1), 70–122 (1998)</li>

      <li>[8] Babai, L.: Trading group theory for randomness. In: STOC (1985)</li>

      <li>[9] Babai, L., Fortnow, L., Levin, L.A., Szegedy, M.: Checking computations in polylogarithmic time. In: STOC (1991)</li>

      <li>[10] Babai, L., Moran, S.: Arthur-merlin games: a randomized proof system, and a hierarchy of complexity classes. Journal of Computer and System Sciences 36(2), 254–276 (1988)</li>

      <li>[11] Backes, M., Barbosa, M., Fiore, D., Reischuk, R.M.: ADSNARK: nearly practical and privacy-preserving proofs on authenticated data. In: 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015 (2015)</li>

      <li>[12] Beaver, D.: Efficient multiparty protocols using circuit randomization. In: CRYPTO ’91 (1991)</li>

      <li>[13] Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing efficient protocols. In: CCS (1993)</li>

      <li>[14] Ben-Or, M., Goldreich, O., Goldwasser, S., Håstad, J., Kilian, J., Micali, S., Rogaway, P.: Everything provable is provable in zero-knowledge. In: CRYPTO (1988)</li>

      <li>[15] Ben-Or, M., Goldwasser, S., Kilian, J., Wigderson, A.: Multi-prover interactive proofs: How to remove intractability assumptions. In: STOC (1988)</li>

      <li>[16] Ben-Or, M., Goldwasser, S., Wigderson, A.: Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract). In: Proceedings of the 20th Annual ACM Symposium on Theory of Computing, May 2-4, 1988, Chicago, Illinois, USA (1988)</li>

      <li>[17] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046 (2018)</li>

      <li>[18] Ben-Sasson, E., Chiesa, A., Forbes, M.A., Gabizon, A., Riabzev, M., , Spooner, N.: On probabilistic checking in perfect zero knowledge. In: Electronic Colloquium on Computational Complexity (ECCC). No. 156 (2016)</li>

      <li>[19] Ben-Sasson, E., Chiesa, A., Gabizon, A., Riabzev, M., Spooner, N.: Interactive oracle proofs with constant rate and query complexity. In: ICALP (2017)</li>

      <li>[20] Ben-Sasson, E., Chiesa, A., Gabizon, A., Riabzev, M., Spooner, N.: Interactive oracle proofs with constant rate and query complexity. In: 44th International Colloquium on Automata, Languages, and Programming, ICALP 2017, July 10-14, 2017, Warsaw, Poland (2017)</li>

      <li>[21] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: Verifying program executions succinctly and in zero knowledge. In: CRYPTO (2013)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for R1CS. Cryptology ePrint Archive, Report 2018/828 (2018), https://eprint.iacr.org/2018/828</li>

      <li>[23] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: Theory of Cryptography Conference (2016)</li>

      <li>[24] Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.: Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM Journal on Computing 36(4), 889–974 (2006)</li>

      <li>[25] Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.: Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM Journal on Computing 36(4), 889–974 (2006)</li>

      <li>[26] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: Innovations in Theoretical Computer Science 2012, Cambridge, MA, USA, January 8-10, 2012 (2012)</li>

      <li>[27] Bitansky, N., Chiesa, A., Ishai, Y., Paneth, O., Ostrovsky, R.: Succinct non-interactive arguments via linear interactive proofs. In: Theory of Cryptography (2013)</li>

      <li>[28] Blum, M., Feldman, P., Micali, S.: Non-interactive zero-knowledge and its applications (extended abstract). In: Proceedings of the 20th Annual ACM Symposium on Theory of Computing, May 2-4, 1988, Chicago, Illinois, USA (1988)</li>

      <li>[29] Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., Ishai, Y.: Zero-knowledge proofs on secret-shared data via fully linear pcps. In: Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III (2019)</li>

      <li>[30] Boneh, D., Ishai, Y., Sahai, A., Wu, D.J.: Lattice-based SNARGs and their application to more efficient obfuscation. In: EUROCRYPT (2017)</li>

      <li>[31] Boneh, D., Ishai, Y., Sahai, A., Wu, D.J.: Quasi-optimal SNARGs via linear multi-prover interactive proofs. In: EUROCRYPT (2018)</li>

      <li>[32] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: EUROCRYPT (2016)</li>

      <li>[33] Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajiabadi, M., Jakobsen, S.K.: Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In: ASIACRYPT (2017)</li>

      <li>[34] Bootle, J., Groth, J.: Efficient batch zero-knowledge arguments for low degree polynomials. In: Proc. of Public-Key Cryptography (2018)</li>

      <li>[35] Boyle, E., Gilboa, N., Ishai, Y.: Function secret sharing: Improvements and extensions. In: CCS (2016)</li>

      <li>[36] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Efficient range proofs for confidential transactions. Cryptology ePrint Archive, Report 2017/1066 (2017)</li>

      <li>[37] Canetti, R.: Security and composition of multiparty cryptographic protocols. J. Cryptology 13(1), 143–202 (2000)</li>

      <li>[38] Catalano, D., Fiore, D.: Vector commitments and their applications. In: PKC (2013)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[39] Chakrabarti, A., Cormode, G., McGregor, A., Thaler, J.: Annotations in data streams. ACM Transactions on Algorithms 11(1), 7 (2014)</li>

      <li>[40] Chida, K., Genkin, D., Hamada, K., Ikarashi, D., Kikuchi, R., Lindell, Y., Nof, A.: Fast large-scale honest-majority MPC for malicious adversaries. In: CRYPTO (2018)</li>

      <li>[41] Cohen, R., Haitner, I., Omri, E., Rotem, L.: Characterization of secure multiparty computation without broadcast. J. Cryptology 31(2), 587–609 (2018)</li>

      <li>[42] Cormode, G., Mitzenmacher, M., Thaler, J.: Practical verified computation with streaming interactive proofs. In: ITCS (2012)</li>

      <li>[43] Cormode, G., Thaler, J., Yi, K.: Verifying computations with streaming interactive proofs. Proceedings of the VLDB Endowment 5(1), 25–36 (2011)</li>

      <li>[44] Corrigan-Gibbs, H., Boneh, D.: Prio: Private, robust, and scalable computation of aggregate statistics. In: NSDI (2017)</li>

      <li>[45] Corrigan-Gibbs, H., Boneh, D., Mazières, D.: Riposte: An anonymous messaging system handling millions of users. In: Symposium on Security and Privacy (2015)</li>

      <li>[46] Costello, C., Fournet, C., Howell, J., Kohlweiss, M., Kreuter, B., Naehrig, M., Parno, B., Zahur, S.: Geppetto: Versatile verifiable computation. In: 2015 IEEE Symposium on Security and Privacy, SP 2015, San Jose, CA, USA, May 17-21, 2015 (2015)</li>

      <li>[47] Couteau, G.: A note on the communication complexity of multiparty computation in the correlated randomness model. IACR Cryptology ePrint Archive 2018, 465 (2018)</li>

      <li>[48] Cramer, R., Damgård, I.: Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In: CRYPTO (1998)</li>

      <li>[49] Cramer, R., Damgård, I., Escudero, D., Scholl, P., Xing, C.: SPDZ<span class="math">{}_{2^{k}}</span>: Efficient mpc mod <span class="math">2^{k}</span> for dishonest majority. In: Annual International Cryptology Conference - CRYPTO 2018 (2018)</li>

      <li>[50] Cramer, R., Damgård, I., Ishai, Y.: Share conversion, pseudorandom secret-sharing and applications to secure computation. In: Theory of Cryptography, Second Theory of Cryptography Conference, TCC 2005, Cambridge, MA, USA, February 10-12, 2005, Proceedings (2005)</li>

      <li>[51] Cramer, R., Fehr, S., Ishai, Y., Kushilevitz, E.: Efficient multi-party computation over rings. In: International Conference on the Theory and Applications of Cryptographic Techniques (2003)</li>

      <li>[52] Damgård, I., Ishai, Y.: Scalable secure multiparty computation. In: Advances in Cryptology - CRYPTO 2006, 26th Annual International Cryptology Conference, Santa Barbara, California, USA, August 20-24, 2006, Proceedings (2006)</li>

      <li>[53] Damgård, I., Jurik, M.: A generalisation, a simplification and some applications of Paillier’s probabilistic public-key system. In: PKC (2001)</li>

      <li>[54] Damgård, I., Luo, J., Oechsner, S., Scholl, P., Simkin, M.: Compact zero-knowledge proofs of small Hamming weight. In: PKC (2018)</li>

      <li>[55] Damgård, I., Nielsen, J.B.: Scalable and unconditionally secure multiparty computation. In: CRYPTO 2007 (2007)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[56] Damgård, I., Nielsen, J.B., Nielsen, M., Ranellucci, S.: The tinytable protocol for 2-party secure computation, or: Gate-scrambling revisited. In: CRYPTO (2017)</li>

      <li>[57] Damgård, I., Orlandi, C., Simkin, M.: Yet another compiler for active security or: efficient mpc over arbitrary rings. In: Annual International Cryptology Conference - CRYPTO 2018 (2018)</li>

      <li>[58] Eerikson, H., Orlandi, C., Pullonen, P., Puura, J., Simkin, M.: Use your brain! arithmetic 3pc for any modulus with active security. IACR Cryptology ePrint Archive 2019, 164 (2019)</li>

      <li>[59] Elahi, T., Danezis, G., Goldberg, I.: Privex: Private collection of traffic statistics for anonymous communication networks. In: CCS (2014)</li>

      <li>[60] Feige, U., Goldwasser, S., Lovász, L., Safra, S., Szegedy, M.: Approximating clique is almost NP-complete. In: FOCS (1991)</li>

      <li>[61] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: CRYPTO (1986)</li>

      <li>[62] Fortnow, L., Rompel, J., Sipser, M.: On the power of multi-prover interactive protocols. Theoretical Computer Science 134(2), 545–557 (1994)</li>

      <li>[63] Fortnow, L., Santhanam, R.: Infeasibility of instance compression and succinct PCPs for NP. In: STOC (2008)</li>

      <li>[64] Franklin, M.K., Yung, M.: Communication complexity of secure computation (extended abstract). In: Proceedings of the 24th Annual ACM Symposium on Theory of Computing, May 4-6, 1992, Victoria, British Columbia, Canada (1992)</li>

      <li>[65] Furukawa, J., Lindell, Y., Nof, A., Weinstein, O.: High-throughput secure three-party computation for malicious adversaries and an honest majority. In: EUROCRYPT (2017)</li>

      <li>[66] Genkin, D., Ishai, Y., Prabhakaran, M., Sahai, A., Tromer, E.: Circuits resilient to additive attacks with applications to secure computation. In: STOC 2014 (2014)</li>

      <li>[67] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: CRYPTO (2013)</li>

      <li>[68] Gertner, Y., Ishai, Y., Kushilevitz, E., Malkin, T.: Protecting data privacy in private information retrieval schemes. Journal of Computer and System Sciences 60(3), 592–629 (2000)</li>

      <li>[69] Gilboa, N., Ishai, Y.: Compressing cryptographic resources. In: Advances in Cryptology - CRYPTO ’99, 19th Annual International Cryptology Conference, Santa Barbara, California, USA, August 15-19, 1999, Proceedings (1999)</li>

      <li>[70] Goldreich, O.: The Foundations of Cryptography - Volume 1, Basic Techniques (2001)</li>

      <li>[71] Goldreich, O.: The Foundations of Cryptography - Volume 2, Basic Applications (2004)</li>

      <li>[72] Goldreich, O., Micali, S., Wigderson, A.: How to play any mental game or A completeness theorem for protocols with honest majority. In: STOC (1987)</li>

      <li>[73] Goldreich, O., Vadhan, S.P., Wigderson, A.: On interactive proofs with a laconic prover. Computational Complexity 11(1-2), 1–53 (2002)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[74] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating computation: interactive proofs for muggles. In: STOC (2008)</li>

      <li>[75] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating computation: Interactive proofs for Muggles. Journal of the ACM 62(4), 27 (2015)</li>

      <li>[76] Goldwasser, S., Lindell, Y.: Secure multi-party computation without agreement. J. Cryptology 18(3), 247–287 (2005)</li>

      <li>[77] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on Computing 18(1), 186–208 (1989)</li>

      <li>[78] Gordon, S.D., Ranellucci, S., Wang, X.: Secure computation with low communication from cross-checking. IACR Cryptology ePrint Archive 2018, 216 (2018)</li>

      <li>[79] Green, M., Ladd, W., Miers, I.: A protocol for privately reporting ad impressions at scale. In: CCS (2016)</li>

      <li>[80] Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings (2010)</li>

      <li>[81] Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT (2016)</li>

      <li>[82] Gur, T., Rothblum, R.D.: A hierarchy theorem for interactive proofs of proximity. In: 8th Innovations in Theoretical Computer Science Conference, ITCS 2017, January 9-11, 2017, Berkeley, CA, USA (2017)</li>

      <li>[83] Ishai, Y., Kushilevitz, E., Ostrovsky, R.: Efficient arguments without short PCPs. In: Conference on Computational Complexity (2007)</li>

      <li>[84] Kalai, Y.T., Raz, R.: Interactive PCP. In: ICALP (2008)</li>

      <li>[85] Kalai, Y.T., Rothblum, R.D.: Arguments of proximity. In: CRYPTO (2015)</li>

      <li>[86] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASIACRYPT (2010)</li>

      <li>[87] Katz, J., Kolesnikov, V., Wang, X.: Improved non-interactive zero knowledge with applications to post-quantum signatures. Tech. rep., Cryptology ePrint Archive, Report 2018/475 (2018)</li>

      <li>[88] Kilian, J.: A note on efficient zero-knowledge proofs and arguments. In: STOC (1992)</li>

      <li>[89] Klauck, H.: Rectangle size bounds and threshold covers in communication complexity. In: Conference on Computational Complexity (2003)</li>

      <li>[90] Kol, G., Oshman, R., Saxena, R.R.: Interactive distributed proofs. In: Proceedings of the 2018 ACM Symposium on Principles of Distributed Computing, PODC 2018, Egham, United Kingdom, July 23-27, 2018 (2018)</li>

      <li>[91] Kushilevitz, E.: Communication complexity. In: Advances in Computers, vol. 44 (1997)</li>

      <li>[92] Lindell, Y., Nof, A.: A framework for constructing fast MPC over arithmetic circuits with malicious adversaries and an honest-majority. In: ACM SIGSAC Conference on Computer and Communications Security, CCS (2017)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[93] Lipmaa, H.: Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In: Theory of Cryptography Conference (2012)</li>

      <li>[94] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. Journal of the ACM 39(4), 859–868 (1992)</li>

      <li>[95] Melis, L., Danezis, G., De Cristofaro, E.: Efficient private statistics with succinct sketches. In: NDSS (2016)</li>

      <li>[96] Micali, S.: CS proofs. In: FOCS (1994)</li>

      <li>[97] Micali, S.: Computationally sound proofs. SIAM J. Comput. 30(4), 1253–1298 (2000)</li>

      <li>[98] Mohassel, P., Rosulek, M., Zhang, Y.: Fast and secure three-party computation: The garbled circuit approach. In: ACM SIGSAC Conference on Computer and Communications Security, CCS (2015)</li>

      <li>[99] Naor, M., Parter, M., Yogev, E.: The power of distributed verifiers in interactive proofs. https://arxiv.org/abs/1812.10917 (2018)</li>

      <li>[100] Naor, M., Pinkas, B.: Computationally secure oblivious transfer. Journal of Cryptology 18(1), 1–35 (2005)</li>

      <li>[101] Nordholt, P.S., Veeningen, M.: Minimising communication in honest-majority MPC by batch-wise multiplication verification. In: ACNS (2018)</li>

      <li>[102] Paillier, P.: Public-key cryptosystems based on composite degree residuosity classes. In: EUROCRYPT (1999)</li>

      <li>[103] Paillier, P., Pointcheval, D.: Efficient public-key cryptosystems provably secure against active adversaries. In: EUROCRYPT (1999)</li>

      <li>[104] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: Symposium on Security and Privacy (2013)</li>

      <li>[105] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: nearly practical verifiable computation. Commun. ACM 59(2), 103–112 (2016)</li>

      <li>[106] Pedersen, T.P.: Non-interactive and information-theoretic secure verifiable secret sharing. In: CRYPTO (1991)</li>

      <li>[107] Rabin, T., Ben-Or, M.: Verifiable secret sharing and multiparty protocols with honest majority (extended abstract). In: Proceedings of the 21st Annual ACM Symposium on Theory of Computing, May 14-17, 1989, Seattle, Washigton, USA (1989)</li>

      <li>[108] Rackoff, C., Simon, D.R.: Non-interactive zero-knowledge proof of knowledge and chosen ciphertext attack. In: CRYPTO (1991)</li>

      <li>[109] Reingold, O., Rothblum, G.N., Rothblum, R.D.: Constant-round interactive proofs for delegating computation. In: Proceedings of the forty-eighth annual ACM symposium on Theory of Computing (2016)</li>

      <li>[110] Rothblum, G.N.: Delegating Computation Reliably: Paradigms and Constructions. Ph.D. thesis, Massachusetts Institute of Technology (9 2009)</li>

    </ul>

    <p class="text-gray-300">[111] Rothblum, G.N., Vadhan, S.P.: Are PCPs inherent in efficient arguments? Computational Complexity 19(2), 265–304 (2010)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[112] Sasson, E.B., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized anonymous payments from Bitcoin. In: Symposium on Security and Privacy (2014)</li>

      <li>[113] Setty, S., Braun, B., Vu, V., Blumberg, A.J., Parno, B., Walfish, M.: Resolving the conflict between generality and plausibility in verified computation. In: EuroSys (2013)</li>

      <li>[114] Setty, S.T., McPherson, R., Blumberg, A.J., Walfish, M.: Making argument systems for outsourced computation practical (sometimes). In: NDSS (2012)</li>

      <li>[115] Shamir, A.: IP = PSPACE. Journal of the ACM 39(4), 869–877 (1992)</li>

      <li>[116] Shi, E., Chan, H., Rieffel, E., Chow, R., Song, D.: Privacy-preserving aggregation of time-series data. In: NDSS (2011)</li>

      <li>[117] Shoup, V.: New algorithms for finding irreducible polynomials over finite fields. Mathematics of Computation 54(189), 435–447 (1990)</li>

      <li>[118] Sudan, M.: Probabilistically checkable proofs. Communications of the ACM 52(3), 76–84 (2009)</li>

      <li>[119] Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: CRYPTO (2013)</li>

      <li>[120] Toubiana, V., Narayanan, A., Boneh, D., Nissenbaum, H., Barocas, S.: Adnostic: Privacy preserving targeted advertising. In: NDSS (2010)</li>

      <li>[121] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: CCS (2017)</li>

      <li>[122] Wahby, R.S., Tzialla, I., shelat, a., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup (2018)</li>

      <li>[123] Williams, R.: Strong ETH breaks with Merlin and Arthur: Short non-interactive proofs of batch evaluation. arXiv preprint arXiv:1601.04743 (2016)</li>

      <li>[124] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: Symposium on Security and Privacy (2017)</li>

      <li>[125] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A zero-knowledge version of vSQL. Cryptology ePrint Archive, Report 2017/1146 (2017)</li>

    </ul>

    <h2 id="sec-109" class="text-2xl font-bold">Appendix A Linear IOP Constructions from the Literature</h2>

    <p class="text-gray-300">We now demonstrate that a number of existing proof systems in the literature implicitly construct linear IOPs.</p>

    <p class="text-gray-300">Short linear IOPs for low-depth circuits from Muggles. The “Muggles” protocol of Goldwasser, Kalai, and Rothblum <em>[74, 75]</em> is an interactive proof system for languages <span class="math">\\mathcal{L}</span> recognized by low-depth boolean circuits with a certain regular structure (specifically: log-space uniform circuits of polylogarithmic depth). Unlike many classical interactive proofs <em>[8, 10, 77, 94, 115]</em>, the GKR protocol</p>

    <p class="text-gray-300">is doubly efficient: both prover and verifier run in polynomial time. In addition the verifier runs in <em>near-linear</em> time: <span class="math">n\\cdot\\mathsf{polylog}(n)</span>, on inputs of length <span class="math">n</span>.</p>

    <p class="text-gray-300">We observe that the GKR protocol gives rise to a linear IOP for arithmetic circuit satisfiability. The benefit of the GKR-based linear IOP is that it has very low proof length, as long as the relation in question is recognized by a shallow arithmetic circuit. Unlike in GKR’s original setting, we need not impose any uniformity restrictions on the circuit.</p>

    <p class="text-gray-300">The construction applies to <em>layered</em> arithmetic circuits of fan-in two. Consult the GKR paper <em>[75]</em> for a formal definition of such circuits.</p>

    <p class="text-gray-300">We have:</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Theorem A.1 (Goldwasser, Kalai, and Rothblum <em>[74, 75]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C:\\mathbb{F}^{n}\\times\\mathbb{F}^{h}\\to\\mathbb{F}</span> be a layered arithmetic circuit of fan-in two over a finite field <span class="math">\\mathbb{F}</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and depth </span>d<span class="math"> (where the size and depth also include the addition gates). Let </span>\\mathcal{R}_{C}=\\{(x,w)\\mid C(x,w)=0\\}<span class="math">. There exists a </span>O(d\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-round fully linear IOP for </span>\\mathcal{R}_{C}<span class="math"> over </span>\\mathbb{F}$ with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- proof length $h+O(d\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> elements of </span>\\mathbb{F}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>query complexity <span class="math">O(1)</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(d\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a verifier of algebraic degree <span class="math">2</span>.</li>

    </ul>

    <p class="text-gray-300">This IOP does not provide honest-verifier zero knowledge.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Proof idea.</h6>

    <p class="text-gray-300">We sketch how we can interpret the “bare-bones” GKR protocol, as described in Rothblum’s thesis <em>[110, Section 3.3.2]</em>, as a fully linear IOP.</p>

    <p class="text-gray-300">The GKR protocol runs in <span class="math">d</span> phases—one for each layer of the circuit. In the each phase:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the prover and verifier engage in a sum-check protocol over a sum with $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ terms,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the verifier evaluates a degree-two polynomial on prover-provided values,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the verifier evaluates a prover-provided polynomial of degree $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ at two points, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the verifier sends the prover a random challenge.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Each sum-check protocol requires $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds of interaction, so the total number of rounds of interaction is </span>O(d\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. In the fully linear IOP setting, the verifier can execute each step of the sumcheck interaction using only </span>O(1)$ linear queries to prover-provided values. Furthermore, each of these steps only requires the verifier to compute degree-two relations on the prover-provided values.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the final phase of the the GKR protocol, the verifier must evaluate the multilinear extension of the input-witness pair $(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w)\\in\\mathbb{F}^{n+h}<span class="math">. To achieve this in the fully linear IOP setting, the prover sends the verifier the witness </span>w\\in\\mathbb{F}^{h}<span class="math"> and the verifier can evaluate the multilinear extension of the input-witness pair with one linear query to the prover-provided witness </span>w<span class="math"> and one linear query to the input </span>x$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The GKR fully linear IOP will be useful for checking satisfiability of wide and shallow circuits with non-regular structure.</p>

    <p class="text-gray-300">More recent refinements to the GKR protocol, such as those of Cormode, Mitzenmacher, and Thaler <em>[42]</em>, Thaler <em>[119]</em>, and Wahby et al. <em>[121]</em> also yield fully linear IOPs with corresponding efficiency benefits. Finally, the RRR protocol <em>[109]</em> (giving a constant-round interactive proofs for space-bounded computations) can also be cast into the fully linear IOP framework.</p>

    <p class="text-gray-300">A constant-size linear IOP for vectors of small Hamming weight. In recent work <em>[54]</em>, Damgård et al. give a <span class="math">\\Sigma</span>-protocol for proving that a vector of commitments commits to a vector with low Hamming weight. Their protocol has applications to symmetrically private information</p>

    <p class="text-gray-300">retrieval <em>[68]</em> and maliciously secure <span class="math">d</span>-out-of-<span class="math">n</span> oblivious transfer <em>[100]</em>. We can view their construction as a two-round linear IOP for the language of vectors in <span class="math">\\mathbb{F}^{n}</span> of low Hamming weight:</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Theorem A.2 (Damgård, Luo, Oechsner, Scholl, and Simkin <em>[54]</em>).</h6>

    <p class="text-gray-300">Fix a finite field <span class="math">\\mathbb{F}</span> and define: <span class="math">\\mathcal{L}_{\\mathsf{HW}(d)}\\stackrel{{\\scriptstyle\\rm\\scriptscriptstyle def}}{{=}}\\big{\\{}x\\in\\mathbb{F}^{n}\\mid x</span> has at most <span class="math">d</span> non-zero entries<span class="math">\\big{\\}}</span>. Then there exists a fully linear two-round IOP for <span class="math">\\mathcal{L}_{\\mathsf{HW}(d)}</span> over <span class="math">\\mathbb{F}</span> with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>proof length <span class="math">O(d)</span> elements of <span class="math">\\mathbb{F}</span>,</li>

      <li>query complexity <span class="math">O(d)</span>,</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(n)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a verifier of algebraic degree <span class="math">2</span>.</li>

    </ul>

    <h2 id="sec-113" class="text-2xl font-bold">Appendix B Proving Optimality Using Communication Complexity</h2>

    <p class="text-gray-300">We now show a connection between fully linear PCPs and Merlin-Arthur communuication complexity <em>[1, 89]</em> that allows us to prove lower bounds on the size and query complexity of fully linear PCPs. One advantage of restricting our focus to fully linear PCPs (rather than arbitrary linear PCPs), is that we can prove unconditional lower bounds on their efficiency. In contrast, proving lower bounds on the size of linear PCPs necessarily implies some complexity assumption, since if <span class="math">\\mathsf{P}=\\mathsf{NP}</span>, all languages in <span class="math">\\mathsf{NP}</span> have trivial linear PCPs.</p>

    <p class="text-gray-300">In this section, we prove the following result, which puts a lower bound on the efficiency of fully linear PCPs:</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Theorem B.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{L}_{\\mathsf{IP}}\\subseteq\\mathbb{F}^{n}\\times\\mathbb{F}^{n}</span> be the language of pairs of vectors <span class="math">(x,y)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{n}</span> such that <span class="math">\\sum_{i=1}^{n}x_{i}y_{i}=0\\in\\mathbb{F}</span>. Any fully linear PCP for <span class="math">\\mathcal{L}_{\\mathsf{IP}}</span> over a finite field <span class="math">\\mathbb{F}</span> of size greater than <span class="math">n</span> and soundness error at most <span class="math">1/3</span> must have proof size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and query complexity </span>\\ell<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell=\\Omega(\\sqrt{n})/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-115" class="text-base font-medium mt-4">Remark B.2.</h6>

    <p class="text-gray-300">The technique we use to prove Theorem B.1 is very similar to the technique that Chakrabarti et al. <em>[39]</em> use to get lower bounds on the efficiency of stream annotation systems (see discussion in Section 2). In fact, we could also prove Theorem 2 by showing that any fully linear PCP for <span class="math">\\mathcal{L}_{\\mathsf{IP}}</span> implies a stream annotation system for <span class="math">\\mathcal{L}_{\\mathsf{IP}}</span>. To make this discussion self contained, we prove the theorem directly.</p>

    <p class="text-gray-300">To prove Theorem B.1, we show a relationship between fully linear PCPs and Merlin-Arthur communication games <em>[1, 89]</em>. In the Merlin-Arthur communication complexity game, Alice holds an input <span class="math">x\\in\\{0,1\\}^{n}</span>, Bob holds an input <span class="math">y\\in\\{0,1\\}^{n}</span>, and Merlin holds both <span class="math">x</span> and <span class="math">y</span>. Merlin sends a proof <span class="math">\\pi</span> to Alice and Bob asserting that <span class="math">f(x,y)=1</span>, for some <span class="math">f:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}</span>. Alice and Bob then communicate to check the proof (using shared randomness, perhaps). If <span class="math">f(x,y)=1</span>, there should exist a proof that causes Alice and Bob to accept with probability at least <span class="math">2/3</span>, over the coins of the players. If <span class="math">f(x,y)=0</span>, then Alice and Bob must reject all proofs with probability at least <span class="math">2/3</span>.</p>

    <p class="text-gray-300">The <em>MA communication complexity</em> of <span class="math">f</span> is the minimum number of bits that the parties must communicate to implement such a protocol (See Klauck <em>[89]</em> for a formal definition.) The <em>randomized communication complexity</em> of <span class="math">f</span> is the minimum number of bits that the parties must communicate to implement such a protocol with no proof from Merlin.</p>

    <p class="text-gray-300">We then have:</p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Lemma B.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If there is a fully linear PCP for the language <span class="math">\\mathcal{L}_{f}=\\{(x,y)\\subseteq\\mathbb{F}^{n}\\times\\mathbb{F}^{n}\\mid f(x,y)=1\\}</span> over a finite field <span class="math">\\mathbb{F}</span> with proof length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, query complexity </span>\\ell<span class="math">, and soundness error at most </span>1/3<span class="math">, then the function </span>f<span class="math"> has Merlin-Arthur communication complexity at most </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We construct an MA protocol for <span class="math">\\mathcal{L}_{f}</span>. On input <span class="math">(x,y)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{n}</span>, Merlin runs the linear PCP prover for <span class="math">\\mathcal{L}_{f}</span> to get the proof <span class="math">\\pi</span>. Merlin sends the proof to Alice and Bob using $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Alice and Bob use their common source of randomness to generate the linear PCP queries $q_{1},\\ldots,q_{\\ell}\\in\\mathbb{F}^{2n+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. We can write the </span>i<span class="math">th query </span>q_{i}<span class="math"> as a triple </span>(q_{i,x},q_{i,y},q_{i,\\pi})\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{n}\\times\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Then the answer to the </span>i$th query is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a_{i}=\\langle q_{i},(x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi)\\rangle=\\langle q_{i,x},x\\rangle+\\langle q_{i,y},y\\rangle+\\langle q_{i,\\pi},\\pi\\rangle=a_{i,x}+a_{i,y}+a_{i,\\pi}\\quad\\in\\mathbb{F},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for <span class="math">a_{i,x},a_{i,y},a_{i,\\pi}\\in\\mathbb{F}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each <span class="math">i\\in[\\ell]</span>, Alice can compute <span class="math">a_{i,\\pi}</span> and <span class="math">a_{i,x}</span> on her own. For each <span class="math">i\\in[\\ell]</span>, Bob can compute <span class="math">a_{i,y}</span> on his own and can send these values to Alice using $\\ell\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> bits. Given these values, Alice can use the linear PCP decision routine to decide whether </span>(x,y)\\in\\mathcal{L}_{f}<span class="math">. The total communication complexity is </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove Theorem B.1, we need the following definition:</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Definition B.4 (Disjointness).</h6>

    <p class="text-gray-300">Define the function <span class="math">f_{\\textsf{Disj}}:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\to\\{0,1\\}</span> to be the one that, on inputs <span class="math">x_{1}x_{2}\\ldots x_{n}\\in\\{0,1\\}^{n}</span> and <span class="math">y_{1}y_{2}\\ldots y_{n}\\in\\{0,1\\}^{n}</span>, outputs <span class="math">0</span> if and only if there exists an index <span class="math">i\\in[n]</span> such that <span class="math">x_{i}=y_{i}=1</span>.</p>

    <p class="text-gray-300">Now we can use Lemma B.3 to prove that the linear PCP of Corollary 4.7 has optimal proof length and query complexity, up to a logarithmic factor in the field size:</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Proof of Theorem B.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Towards a contradiction, assume that there exists a fully linear PCP for <span class="math">\\mathcal{L}_{\\textsf{IP}}</span> over a finite field of size greater than <span class="math">n</span> with soundness error <span class="math">1/3</span> and proof size and query complexity $o(\\sqrt{n})/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By Lemma B.3, such a linear PCP implies the existence of an MA protocol for function </span>f_{IP}:\\mathbb{F}^{n}\\times\\mathbb{F}^{n}\\to\\{0,1\\}<span class="math"> that returns “1” if and only the two input vectors have a inner product equal to zero. Furthermore, by Lemma B.3, this MA protocol has communication complexity </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot o(\\sqrt{n})/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=o(\\sqrt{n})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An MA protocol for <span class="math">f_{IP}</span> over a field <span class="math">\\mathbb{F}</span> of size greater than <span class="math">n</span> suffices for deciding disjointness on <span class="math">n</span>-bit strings <em>[1]</em>. Thus, we have constructed an MA protocol for disjointness on <span class="math">n</span>-bit strings that has communication complexity <span class="math">o(\\sqrt{n})</span>. Klauck <em>[89]</em> has proved that any MA protocol for disjointness on <span class="math">n</span>-bit strings requires communication <span class="math">\\Omega(\\sqrt{n})</span>, which yields a contradiction. ∎</p>

    <p class="text-gray-300">Aaronson and Wigderson <em>[1]</em> show that the MA communication complexity of <span class="math">\\mathcal{L}_{\\textsf{IP}}</span> (and thus of the disjointness problem) is <span class="math">O(\\sqrt{n}\\log n)</span>. Combining the linear PCP of Corollary 4.7 with the statement of Lemma B.3 and the observation that deciding inner product is enough to decide disjointness, yields this result as a special case:</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Corollary B.5 (Corollary of Corollary 4.7 and Lemma B.3).</h6>

    <p class="text-gray-300">The MA communication complexity of <span class="math">f_{\\textsf{Disj}}</span> is <span class="math">O(\\sqrt{n}\\log n)</span>.</p>

    <h2 id="sec-121" class="text-2xl font-bold">Appendix C Application: ZK Proofs on Encrypted or Committed Data</h2>

    <p class="text-gray-300">While we are primarily interested in fully linear proof systems for their application to proofs on secret-shared data, we note that they also have applications to proofs on encrypted and committed data. In particular, we envision a scenario in which a verifier holds an encoding of <em>each element</em> of a vector <span class="math">x\\in\\mathbb{F}^{n}</span> under an additively homomorphic encryption scheme <em>[53, 102]</em> or additively homomorphic commitment scheme <em>[106]</em>. A prover, who knows <span class="math">x</span> and the randomness used to encode it, would like to convince the verifier that <span class="math">x\\in\\mathcal{L}</span>, for some language <span class="math">\\mathcal{L}\\subseteq\\mathbb{F}^{n}</span></p>

    <p class="text-gray-300">Let us define an <em>additively homomorphic encoding scheme</em> as a function <span class="math">E(x;r)</span> that takes as input a message <span class="math">x\\in\\mathbb{F}</span> with randomness <span class="math">r\\in\\mathbb{F}</span>. The encoding scheme <span class="math">E</span> has the additional property that, for all messages <span class="math">x_{1}</span> and <span class="math">x_{2}</span>, and for all choices of the randomness <span class="math">r_{1}</span> and <span class="math">r_{2}</span>, we have <span class="math">E(x_{1};r_{1})\\cdot E(x_{2};r_{2})=E(x_{1}+x_{2};r_{1}+r_{2})</span>, where multiplication and addition are computed in a field, for example. Examples of such encoding schemes are the Paillier <em>[102]</em> and Damgård-Jurik <em>[53]</em> cryptosystems, and the Pedersen commitment scheme <em>[106]</em>.</p>

    <p class="text-gray-300">This variant of the problem of proving statements on encoded data comes up in a number of practical applications of zero-knowledge proofs to privacy-preserving system design. We recall a few of these applications here:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Private advertising and private statistics <em>[59, 79, 95, 120]</em>. The Adnostic system <em>[120]</em> and the system of Green et al. <em>[79]</em> are mechanisms for adding privacy to today’s online ad ecosystem. In these systems, every user’s web browser holds a local library of ads and the browser uses local information about the user’s preferences and demographic information to decide which ads to show to the user. Every time a user views the <span class="math">i</span>th advertisement in the library, the browser encrypts the basis vector <span class="math">e_{i}\\in\\mathbb{F}^{n}</span> (the vector of all zeros with a one at index <span class="math">i</span>) using an additively homomorphic cryptosystem and submits the ciphertext to an aggregator. To protect against malicious users, each user also proves that its submission really encrypts a basis vector.</li>

      <li>Private aggregation of integers <em>[116]</em>. In systems for private aggregation of numerical data, users submit encryptions of integers <span class="math">x\\in\\mathbb{F}</span> that should lie in some range <span class="math">\\{0,\\ldots,B\\}\\subseteq\\mathbb{F}</span>. To prevent a user from submitting a malformed value, these systems use zero-knowledge proofs over the encrypted values.</li>

    </ul>

    <p class="text-gray-300">The following informal claim shows that fully linear PCPs imply efficient non-interactive zero-knowledge arguments of knowledge (NIZKs) in the random-oracle model <em>[13]</em> for proving statements on data encrypted with additive homomorphic encryption schemes.</p>

    <h6 id="sec-122" class="text-base font-medium mt-4">Informal Claim C.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a binary relation over a finite field <span class="math">\\mathbb{F}</span>. Let <span class="math">(P_{LPCP},V_{LPCP})</span> be a strong HVZK fully linear PCP for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span> with proof length <span class="math">m</span> and query complexity <span class="math">\\ell</span>. Let <span class="math">\\mathsf{Enc}(x;r_{x})</span> be an additively homomorphic encryption scheme that encrypts a message <span class="math">x\\in\\mathbb{F}</span> with randomness <span class="math">r_{x}</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the message space of <span class="math">\\mathsf{Enc}</span> is the set of elements of <span class="math">\\mathbb{F}</span>, and</li>

      <li>there is a non-interactive argument-of-knowledge of correct decryption <em>[103, 108]</em> consisting of a constant number of ciphertext elements.</li>

    </ul>

    <p class="text-gray-300">Then there is a NIZK in the random-oracle model for the relation <span class="math">\\mathcal{R}_{\\mathsf{ct}_{x}}=\\left\\{((x,r_{x}),w)\\mid\\mathsf{ct}_{x}=E(x;r_{x})\\wedge(x,w)\\in\\mathcal{R}\\right\\}</span>, such that the NIZK has length <span class="math">m+O(\\ell)</span> ciphertext elements.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Proof idea for Claim C.1.</h6>

    <p class="text-gray-300">Given a vector <span class="math">x=(x_{1},\\ldots,x_{n})\\in\\mathbb{F}^{n}</span> we denote the component-wise encryption of <span class="math">x</span> under <span class="math">\\mathsf{Enc}</span> as <span class="math">\\mathsf{Enc}_{n}(x)\\stackrel{{\\scriptstyle\\rm def}}{{=}}(\\mathsf{Enc}(x_{1}),\\ldots,\\mathsf{Enc}(x_{n}))</span>.</p>

    <p class="text-gray-300">We (informally) construct the NIZK scheme implied by the claim. The verifier takes as input a ciphertext <span class="math">\\mathsf{ct}_{x}=\\mathsf{Enc}_{n}(x)</span>, for some <span class="math">x\\in\\mathbb{F}^{n}</span>. The prover takes as input the encryption of a statement-witness pair <span class="math">(x,w)\\in\\mathbb{F}^{n}\\times\\mathbb{F}^{h}</span> and wants to convince the verifier that <span class="math">(x,w)\\in\\mathcal{R}</span>. We assume that the public key for the encryption scheme, which we leave implicit, is part of a common reference string provided to the prover and verifier.</p>

    <p class="text-gray-300">We sketch the protocol here:</p>

    <p class="text-gray-300">Prover.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover runs <span class="math">\\pi\\leftarrow P_{\\mathsf{LPCP}}(x,w)</span>, encrypts the proof element by element, and sends the encrypted proof <span class="math">\\mathsf{ct}_{\\pi}\\leftarrow\\mathsf{Enc}_{m}(\\pi)</span> to the verifier.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover hashes the encrypted proof <span class="math">\\mathsf{ct}_{\\pi}</span> and instance <span class="math">\\mathsf{ct}_{x}</span> using the random oracle and uses the resulting value to derive the randomness it uses to run the linear PCP query algorithm <span class="math">Q_{\\mathsf{LPCP}}</span>.</li>

      <li>Given the encrypted proof <span class="math">\\mathsf{ct}_{\\pi}</span> and the query vectors <span class="math">(q_{1},\\ldots,q_{\\ell})</span>, the prover can use the additive homomorphism of the cryptosystem to produce encryptions of the query answers <span class="math">(\\mathsf{ct}_{a_{1}},\\ldots,\\mathsf{ct}_{a_{\\ell}})</span>.</li>

      <li>The prover sends the openings (decryptions) of these query answers to the verifier. The prover also proves, using one NIZK per ciphertext, that it opened each ciphertext correctly. The prover can construct these NIZKs because the prover knows the randomness used in each of the encryptions, and we are assuming that the encryption scheme is homomorphic in the randomness.</li>

    </ul>

    <h5 id="sec-124" class="text-base font-semibold mt-4">Verifier.</h5>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier hashes the encrypted proof <span class="math">\\mathsf{ct}_{\\pi}</span> to derive the randomness it uses to run the linear PCP query algorithm <span class="math">Q_{\\mathsf{LPCP}}</span>.</li>

      <li>The verifier computes the encrypted query answers <span class="math">(\\mathsf{ct}_{a_{1}},\\ldots,\\mathsf{ct}_{a_{\\ell}})</span> by applying these queries to the encryptions of <span class="math">\\pi</span> and <span class="math">x</span>.</li>

      <li>The verifier checks that the encrypted answers match the values the prover sent and that the proofs of decryption are correct.</li>

      <li>The verifier evaluates the linear PCP decision predicate <span class="math">D_{\\mathsf{LPCP}}</span> on the decrypted answers <span class="math">(a_{1},\\ldots,a_{\\ell})</span> and accepts iff the linear PCP decision predicate accepts.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Remark C.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A variant of Claim C.1 applies even if the underlying linear PCP is not HVZK. In this case, the prover does not provide decryptions of the query answers, but uses a standard NIZK <em>[48]</em> to prove in zero knowledge that the answers satisfy the linear PCP decision predicate. If the linear PCP has proof length <span class="math">m</span> and has a verifier that can be represented as an arithmetic circuit over <span class="math">\\mathbb{F}</span> with size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{\\mathsf{LPCP}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then the resulting NIZK has size </span>m+O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{\\mathsf{LPCP}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A simple variation of the protcol described in the proof of Claim C.1 applies to proving statements on data to with an additively homomorphic commitment scheme. The only difference is that prover need not produce NIZKs of correct decryption of the query answers—the prover can just send the verifier openings of the commitments to the query answers.</p>

    <p class="text-gray-300">We can extend the construction of Claim C.1 to compile multi-round linear IOPs into NIZKs as well. In this case, the resulting NIZK has proof size that scales with the proof length of the linear IOP. Recent work of <em>Wahby et al. [122]</em> compiles a variant of the CMT protocol <em>[42]</em> into a NIZK using a technique along these lines. <em>Zhang et al. [125]</em> also compile the CMT protocol into an argument system using different cryptographic techniques.</p>

    <h5 id="sec-126" class="text-base font-semibold mt-4">Comparison with prior proof systems.</h5>

    <p class="text-gray-300">Table 1, in the introduction, gives quantitative comparisons of the proof systems resulting from Claim C.1 to others in the literature.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Roughly speaking, when it is possible to use a succinct discrete-log based commitment (i.e., commiting to the input <span class="math">x\\in\\mathbb{F}^{n}</span> using a string of size sublinear in <span class="math">n</span>), there zero-knowledge interactive proof systems that achieve $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> proof length for languages recognized by arithmetic circuits of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ <em>[32, 36]</em>. For general circuits, these proof systems will be preferable to our own. In contrast, for proving <em>simple</em> zero-knowledge statements, such as proving that a committed vector has Hamming weight one—using our abstraction of the proof system of <em>Damgård et al. [54]</em>—the proofs obtained via our framework are shorter. (See Table 1.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In contrast, for the problem of proving statements on data encrypted with an additively homomorphic encryption scheme, the proofs produced using this framework will be significantly shorter</p>

    <p class="text-gray-300">than those using the standard techniques. For example, standard techniques for proving that an encrypted vector <span class="math">x\\in\\mathbb{F}^{n}</span> is in the subset <span class="math">x\\in\\{0,1\\}^{n}\\subseteq\\mathbb{F}^{n}</span> requires <span class="math">\\Omega(n)</span>-length proofs <em>[48]</em>. By applying our techniques (Theorems 4.3 and 5.1) to this problem, we achieve <span class="math">O(\\log n)</span>-length proofs for this, and other simple, languages. (See Table 1.)</p>

    <h2 id="sec-127" class="text-2xl font-bold">Appendix D Proofs over Rings</h2>

    <p class="text-gray-300">In this section, we show a fully linear PCP and a fully linear IOP over rings <span class="math">\\mathbb{Z}_{w}</span>, focusing on <span class="math">w</span> a power of two. The fully linear PCP of Theorem 4.3 and the proof systems derived from it are all defined for circuits over finite fields. An interesting application of these proof systems is in transforming MPC in the semi-honest setting to MPC in the malicious setting. MPC is typically defined for circuits over finite fields. However, circuits defined over rings are interesting both theoretically, as a generalization of circuits over fields, and due to practical considerations. Arithmetic modulo <span class="math">2^{k}</span> is implemented in the hardware of most computing devices, unlike finite field operations, and MPC protocols that reflect actual hardware architecture are more efficient. Furthermore, specific operations, such as bit decomposition and comparisons are more efficient in <span class="math">\\mathbb{Z}_{2^{k}}</span>. We refer the reader to additional discussion in <em>[49]</em>. The feasibility of MPC over general rings was shown in <em>[51]</em> while recent work <em>[49, 57]</em> presents efficient MPC constructions in the malicious setting over <span class="math">\\mathbb{Z}_{2^{k}}</span>.</p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Notation D.1.</h6>

    <p class="text-gray-300">For an integer <span class="math">w\\geq 1</span> let <span class="math">w=p_{1}^{e_{1}}\\cdot\\ldots\\cdot p_{k}^{e_{k}}</span> be the unique factorization of <span class="math">w</span> into distinct prime powers, let <span class="math">\\mathbb{Z}_{w}</span> be the ring of integers modulo <span class="math">w</span>, let <span class="math">\\mathbb{Z}_{w}[x]</span> denote the polynomial ring over <span class="math">\\mathbb{Z}_{w}</span> and for <span class="math">f(x)\\in\\mathbb{Z}_{w}[x]</span> let <span class="math">\\mathbb{Z}_{w}[x]/f(x)</span> denote the quotient ring of polynomials over <span class="math">\\mathbb{Z}_{w}</span> modulo <span class="math">f(x)</span>. For any prime power <span class="math">q</span> let <span class="math">\\mathbb{F}_{q}</span> denote the finite field with <span class="math">q</span> elements. Given a polynomial <span class="math">f(x)\\in\\mathbb{Z}_{w}[x]</span> define <span class="math">f_{q}(x)</span> by reducing each coefficient of <span class="math">f</span> modulo <span class="math">q</span>. A zero divisor in a ring <span class="math">R</span> is an element <span class="math">a\\in R</span> such that <span class="math">ab=0</span> for some <span class="math">b\\in R</span>, where <span class="math">0</span> is the neutral element for addition. A unit is any <span class="math">a\\in R</span> which has a multiplicative inverse.</p>

    <h6 id="sec-129" class="text-base font-medium mt-4">Claim D.2.</h6>

    <p class="text-gray-300">Let <span class="math">w=p_{1}^{e_{1}}\\cdot\\ldots\\cdot p_{k}^{e_{k}}</span> be an integer and let <span class="math">f(x)\\in\\mathbb{Z}_{w}[x]</span> be a degree-<span class="math">\\delta</span> polynomial such that <span class="math">f_{p_{i}}(x)</span> is irreducible over <span class="math">\\mathbb{F}_{p_{i}}</span> for every <span class="math">i=1,\\ldots,k</span>. Then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any element <span class="math">g(x)\\in\\mathbb{Z}_{w}[x]/f(x)</span> such that <span class="math">g_{p_{i}}(x)\\not\\equiv 0\\in\\mathbb{F}_{p_{i}}</span> for all <span class="math">i=1,\\ldots,k</span> is a unit in <span class="math">\\mathbb{Z}_{w}[x]/f(x)</span>.</li>

      <li>The number of units in <span class="math">\\mathbb{Z}_{w}[x]/f(x)</span> is at least <span class="math">w^{\\delta}-\\sum_{i=1}^{k}(w/p_{i})^{\\delta}</span>.</li>

    </ul>

    <h6 id="sec-130" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By definition, <span class="math">\\mathbb{Z}_{w}[x]/f(x)</span> is a ring and each element is a polynomial over <span class="math">\\mathbb{Z}_{w}</span> with degree less than <span class="math">\\delta</span>. Let <span class="math">g(x)\\in\\mathbb{Z}_{w}[x]/f(x)</span> and consider the reduction of the coefficients of <span class="math">g(x)</span> modulo a prime power. Let <span class="math">p=p_{i}</span>, <span class="math">e=e_{i}</span> and <span class="math">q=p_{i}^{e_{i}}</span> for some <span class="math">i\\in\\{1,\\ldots,k\\}</span>.</p>

    <p class="text-gray-300">We prove that <span class="math">g_{q}(x)</span> is invertible in <span class="math">\\mathbb{Z}_{q}[x]/f_{q}(x)</span> if and only if <span class="math">g_{p}(x)</span> is not the zero polynomial in <span class="math">\\mathbb{F}_{p}[x]</span>. If <span class="math">g_{p}(x)=0\\in\\mathbb{F}_{p}[x]</span> then <span class="math">g_{q}(x)=pg^{\\prime}(x)</span> for some polynomial <span class="math">g^{\\prime}(x)</span>. The degree of <span class="math">f_{q}(x)</span> is at least <span class="math">1</span> since <span class="math">f_{p}(x)</span> is irreducible and therefore not a constant. It follows that <span class="math">g_{q}(x)</span> is not invertible in <span class="math">\\mathbb{Z}_{q}[x]/f_{q}(x)</span> and therefore <span class="math">g(x)</span> is not invertible in <span class="math">\\mathbb{Z}_{w}[x]/f(x)</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">g_{p}(x)\\neq 0\\in\\mathbb{F}_{p}[x]</span>. Since <span class="math">f_{p}(x)</span> is irreducible modulo <span class="math">p</span> there exist <span class="math">a(x),b(x)\\in\\mathbb{F}_{p}[x]</span> such that <span class="math">a(x)f_{p}(x)+b(x)g_{p}(x)=1</span> over <span class="math">\\mathbb{F}_{p}</span>. Therefore, there exists a polynomial <span class="math">h(x)</span> such that <span class="math">a(x)f_{q}(x)+b(x)g_{q}(x)=1+ph(x)</span> over <span class="math">\\mathbb{Z}_{q}</span>. Define</p>

    <p class="text-gray-300"><span class="math">A(x)=a(x)\\sum_{j=0}^{e-1}(-ph(x))^{j}\\text{ and }B(x)=b(x)\\sum_{j=0}^{e-1}(-ph(x))^{j}.</span></p>

    <p class="text-gray-300">Computing over <span class="math">\\mathbb{Z}_{q}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A(x)f_q(x) + B(x)g_q(x) = \\sum_{j=0}^{e-1} (-ph(x))^j \\left(a(x)f_q(x) + b(x)g_q(x)\\right) \\\\ = \\sum_{j=0}^{e-1} ((-ph(x))^j - (-ph(x))^{j+1}) \\\\ = 1 - (-p)^e h^e(x) \\equiv 1 \\bmod q \\end{array}</span></div>

    <p class="text-gray-300">Therefore, <span class="math">g_q(x)</span> is invertible in <span class="math">\\mathbb{Z}_q[x]/f_q(x)</span>. It follows that if <span class="math">g(x) \\not\\equiv 0 \\bmod p_i</span> for every <span class="math">i</span> then <span class="math">g(x)</span> has an inverse modulo <span class="math">f(x)</span> over <span class="math">\\mathbb{Z}_{p_i^{e_i}}</span> for every <span class="math">i</span>. In this case, by the Chinese Remainder Theorem, <span class="math">g(x)</span> is invertible and hence a unit in <span class="math">\\mathbb{Z}_w/f(x)</span>.</p>

    <p class="text-gray-300">The number of elements in <span class="math">\\mathbb{Z}_w[x]/f(x)</span> is <span class="math">w^\\delta</span>. Since <span class="math">\\mathbb{Z}_w[x]/f(x)</span> is finite, any element <span class="math">r</span> which is not a zero divisor must be a unit<span class="math">^6</span>. If <span class="math">g(x)</span> is a zero divisor then <span class="math">g_{p_i}(x) = 0</span> for some <span class="math">i</span> which implies that each of the <span class="math">\\delta</span> coefficients of <span class="math">g(x)</span> is a multiple of <span class="math">p_i</span>. There are <span class="math">(w/p_i)^\\delta</span> polynomials for which <span class="math">g_{p_i}(x) = 0</span> and therefore there are at most <span class="math">\\sum_{i=1}^k (w/p_i)^\\delta</span> zero divisors and at least <span class="math">w^\\delta - \\sum_{i=1}^k (w/p_i)^\\delta</span> units in <span class="math">\\mathbb{Z}_w[x]/f(x)</span>.</p>

    <p class="text-gray-300"><strong>Claim D.3.</strong> Let <span class="math">R</span> be a commutative ring with unity, such that there are <span class="math">z</span> zero divisors in <span class="math">R</span> and let <span class="math">f(x)</span> be a polynomial of degree <span class="math">\\delta \\geq 0</span> over <span class="math">R</span>, which is not equal to the zero polynomial. Then, <span class="math">f(x)</span> has at most <span class="math">z\\delta</span> roots in <span class="math">R</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We prove the claim by induction on <span class="math">\\delta</span>. For <span class="math">\\delta = 0</span> the statement of the claim is obvious. For <span class="math">\\delta &amp;gt; 0</span>, assume that the statement holds for <span class="math">\\delta - 1</span>. If all the roots of <span class="math">f(x)</span> are zero divisors then the claim is true. Otherwise, there is a ring element <span class="math">r</span>, which is not a zero divisor, such that <span class="math">f(r) = 0</span>. Hence, <span class="math">f(x) = (x - r)g(x)</span> for <span class="math">g(x)</span> of degree <span class="math">\\delta - 1</span>.</p>

    <p class="text-gray-300">By the induction hypothesis, <span class="math">g(x)</span> has at most <span class="math">z(\\delta - 1)</span> roots. Let <span class="math">u</span> be a root of <span class="math">f(x)</span>, which is not a root of <span class="math">g(x)</span>. Then <span class="math">0 = (r - u)g(u)</span> and therefore <span class="math">u - r</span> is a zero divisor. There are at most <span class="math">z</span> such roots and as a consequence <span class="math">f</span> has at most <span class="math">z(\\delta - 1) + z = z\\delta</span> roots.</p>

    <p class="text-gray-300"><strong>Remark D.4.</strong> Theorem D.5 is an analog of Theorem 4.3 for Fully Linear PCP over certain rings. The proof of Theorem D.5 takes into account the fact that a ring element may not have an inverse, preventing polynomial interpolation, and that polynomials of degree <span class="math">d</span> over the ring may have more than <span class="math">d</span> roots. The approach of the proof is to work with rings with a small number of zero divisors and argue that in this case the techniques of Theorem 4.3 succeed with good probability. While the Theorem could be stated more generally for any finite, commutative ring with a small fraction of zero divisors we restrict ourselves to the concrete case of an extension of <span class="math">\\mathbb{Z}_w</span> using the tools that Claims D.3 and D.2 provide to estimate the number of units and the number of roots of a polynomial in such rings. Where necessary, the theorem states results for both general integers <span class="math">w</span> and for the most useful case, that of <span class="math">w = 2^e</span> for some positive integer <span class="math">e</span>.</p>

    <p class="text-gray-300">The interesting case for Theorem D.5 (and for Theorem 4.3) is <span class="math">\\deg G &amp;gt; 1</span>, i.e. <span class="math">G</span> is a non-linear gate and <span class="math">C</span> is a non-linear circuit. In this case, we denote the number of <span class="math">G</span> gates in the circuit by <span class="math">M</span>, with <span class="math">L</span> inputs to each gate. If <span class="math">C</span> is a linear circuit then we view it as a single <span class="math">G</span>-gate of degree 1, i.e. <span class="math">M = 1</span>, and the results of Theorem D.5 hold in this case as well.</p>

    <p class="text-gray-300"><strong>Theorem D.5.</strong> Let <span class="math">w</span> be a positive integer with prime factorization <span class="math">w = p_1^{e_1} \\cdot \\ldots \\cdot p_k^{e_k}</span>, let <span class="math">f(x)</span> be a polynomial of degree <span class="math">\\delta</span> which is irreducible over <span class="math">\\mathbb{F}_{p_i}</span> for all <span class="math">i</span> and let <span class="math">R = \\mathbb{Z}_w / f(x)</span>. Let <span class="math">C</span> be an arithmetic circuit with <span class="math">n</span> inputs over <span class="math">R</span> such that:</p>

    <p class="text-gray-300"><span class="math">^6</span>If <span class="math">ry \\neq 1</span> for any <span class="math">y</span> in the ring then there exist two different elements <span class="math">a, b</span> such that <span class="math">ra = rb</span> and therefore <span class="math">r(a - b) = 0</span> and <span class="math">r</span> is a zero divisor.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the gate <span class="math">G:R^{L}\\to R</span> has arithmetic degree <span class="math">\\deg G</span></li>

      <li>the circuit <span class="math">C</span> consists of <span class="math">M</span> instances of a <span class="math">G</span>-gate and any number of affine gates, and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\delta</span> is such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=w^{\\delta}>\\sum_{i=1}^{k}(w/p_{i})^{\\delta}M\\deg G<span class="math"> (if </span>w=2^{e}<span class="math"> then </span>2^{\\delta}>M\\deg G$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, there exists a fully linear PCP with strong HVZK for the language <span class="math">\\mathcal{L}_{C}=\\{x\\in R^{n}\\mid C(x)=0\\}</span> that has proof length <span class="math">L+M\\deg G+1</span> elements of <span class="math">R</span>, query complexity <span class="math">L+2</span>, an arithmetic verification circuit of degree <span class="math">\\deg G</span> containing $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> multiplication gates, and soundness error for general </span>w$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{O((\\sum_{i=1}^{k}(w/p_{i})^{\\delta})M\\deg G)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-M\\sum_{i=1}^{k}(w/p_{i})^{\\delta}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and for <span class="math">w=2^{e}</span> the soundness error is</p>

    <p class="text-gray-300"><span class="math">\\frac{O(M\\deg G)}{2^{\\delta}-M}.</span></p>

    <h6 id="sec-131" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Every element in <span class="math">R</span> can be represented as a polynomial of degree less than <span class="math">\\delta</span> with coefficients in <span class="math">\\mathbb{Z}_{w}</span>. Let <span class="math">D\\subseteq R</span> be the subset of <span class="math">R</span> that includes all polynomials of degree less than <span class="math">\\delta</span> with all coefficients in the range <span class="math">0,\\ldots,p-1</span> for <span class="math">p=\\min\\{p_{1},\\ldots,p_{k}\\}</span>. It follows from the choice of <span class="math">\\delta</span> in the theorem that <span class="math">w^{\\delta}&gt;(w/p)^{\\delta}M\\deg G</span> and therefore $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p^{\\delta}\\geq M+1<span class="math">. Let </span>\\{\\alpha_{0},\\alpha_{1},\\ldots,\\alpha_{M}\\}\\subseteq D<span class="math"> be </span>M+1<span class="math"> arbitrary elements in </span>D<span class="math">. Claim D.2 proves that </span>\\alpha_{i}-\\alpha_{j}<span class="math"> is a unit in </span>R<span class="math"> for every two different </span>\\alpha_{i},\\alpha_{j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It follows that interpolation is possible over <span class="math">D</span>. That is, for any sequence of values <span class="math">\\beta_{0},\\ldots,\\beta_{M}\\in R</span> there exists a polynomial <span class="math">g(x)\\in R[x]</span> of degree at most <span class="math">M</span> such that <span class="math">g(\\alpha_{i})=\\beta_{i}</span> for <span class="math">i=0,1,\\ldots,M</span>. <span class="math">g(x)</span> is simply the Lagrange interpolation polynomial <span class="math">g(x)=\\sum_{i=0}^{M}\\prod_{j\\neq i}\\frac{x-\\alpha_{j}}{\\alpha_{i}-\\alpha_{j}}\\beta_{i}</span> which is well-defined given the choice of <span class="math">\\alpha_{0},\\ldots,\\alpha_{M}</span>.</p>

    <p class="text-gray-300">Define the set <span class="math">E</span> by <span class="math">E=\\{\\alpha_{i}+\\zeta\\mid i\\in\\{1,\\ldots,M\\},\\zeta</span> a zero divisor in <span class="math">R\\}</span>. By this definition, for any <span class="math">r\\in R\\setminus E</span>, the difference <span class="math">r-\\alpha_{i},i\\in\\{1,\\ldots,M\\}</span>, is not a zero divisor in R and is therefore a unit.</p>

    <p class="text-gray-300">Linear PCP prover. On input <span class="math">x\\in R^{n}</span>, the prover evaluates <span class="math">C(x)</span> and defines <span class="math">L</span> polynomials <span class="math">f_{1},\\ldots,f_{L}\\in R[X]</span> such that, for every <span class="math">i\\in\\{1,\\ldots,L\\}</span>,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_{i}(\\alpha_{0})</span> is chosen independently and uniformly at random from <span class="math">R</span>, and</li>

      <li>for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, <span class="math">f_{i}(\\alpha_{j})\\in R</span> is the value on the <span class="math">i</span>-th input wire to the <span class="math">j</span>-th <span class="math">G</span>-gate when evaluating <span class="math">C(x)</span>.</li>

    </ul>

    <p class="text-gray-300">The prover proceeds identically to the proof of Theorem 4.3 by constructing a proof polynomial <span class="math">p=G(f_{1},\\ldots,f_{L})\\in R[X]</span> of degree <span class="math">d\\leq M\\deg G</span> with coefficients <span class="math">c_{p}\\in R^{d+1}</span> and outputs <span class="math">\\pi=(f_{1}(\\alpha_{0}),\\ldots,f_{L}(\\alpha_{0}),\\ c_{p})\\in\\mathbb{F}^{L+d+1}</span> as the linear PCP proof.</p>

    <p class="text-gray-300">Linear PCP queries and LPCP decision. The verifier mimics the verifier in the proof of Theorem 4.3 except for two differences. The first is that the polynomials <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}</span> are interpolated based on their values in <span class="math">\\alpha_{0},\\alpha_{1},\\ldots,\\alpha_{M}</span> instead of their values in <span class="math">0,1,\\ldots,M</span>. The second difference is that <span class="math">r</span> is chosen randomly in the set <span class="math">R\\setminus E</span>. The linear queries can be constructed because Fact 4.4 on the linearity of polynomial interpolation and evaluation holds in a ring <span class="math">R</span> in which the interpolation points are <span class="math">\\alpha_{0},\\alpha_{1},\\ldots,\\alpha_{M}</span> such that <span class="math">\\alpha_{i}-\\alpha_{j}</span> is a unit for all <span class="math">i\\neq j</span>.</p>

    <p class="text-gray-300">Security arguments. Completeness is argued identically to the proof of Theorem 4.3. For the soundness argument, assume that <span class="math">\\pi</span> defines a polynomial <span class="math">p^{\\prime}</span> and <span class="math">L</span> polynomials <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{L}</span>. The same induction as in the proof of Theorem 4.3 shows that if for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, it holds that <span class="math">p^{\\prime}(\\alpha_{j})=G(f^{\\prime}_{1}(\\alpha_{j}),\\ldots,f^{\\prime}_{L}(\\alpha_{j}))</span>, then for all <span class="math">j\\in\\{1,\\ldots,M\\}</span>, <span class="math">p^{\\prime}(\\alpha_{j})</span> encodes the value of the output wire of the <span class="math">j</span>th <span class="math">G</span>-gate in the evaluation of <span class="math">C</span> on <span class="math">x</span>.</p>

    <p class="text-gray-300">If <span class="math">p^{\\prime}(\\alpha_{M})=0</span> (otherwise <span class="math">p^{\\prime}</span> is not accepted), but <span class="math">C(x)\\neq 0</span>, then <span class="math">p^{\\prime}(\\alpha_{M})</span> does not encode the output value of the <span class="math">M</span>th <span class="math">G</span>-gate in the evaluation of <span class="math">C(x)</span> and therefore <span class="math">p^{\\prime}(\\alpha_{j^{<em>}})\\neq G(f^{\\prime}_{1}(\\alpha_{j^{</em>}}),\\ldots,f^{\\prime}_{L}(\\alpha_{j^{*}}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for some <span class="math">j^{*} \\in \\{1, \\ldots, M\\}</span>. We have that <span class="math">p&#x27; - G(f_1&#x27;, \\ldots, f_L&#x27;) \\in R[X]</span> is a non-zero univariate polynomial of degree at most <span class="math">M \\deg G</span>. By Claim D.2 the number of zero divisors in <span class="math">R = \\mathbb{Z}_w / f(x)</span> is <span class="math">z \\leq \\sum_{i=1}^{k} (w / p_i)^{\\delta}</span> and by Claim D.3 the number of roots of a polynomial of degree <span class="math">M \\deg G</span> in <span class="math">R</span> is at most <span class="math">zM \\deg G</span>. Since <span class="math">r</span> is drawn at random from <span class="math">R \\setminus E</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= zM<span class="math">, the probability that the verifier accepts a false proof is at most </span>zM \\deg G / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Mz)<span class="math">. In the interesting case of </span>w = 2^e<span class="math"> the number of zero divisors in the ring is </span>2^{(e-1)\\delta}<span class="math"> and the probability of soundness error is </span>2^{(e-1)\\delta}M \\deg G / (2^{e\\delta} - 2^{(e-1)\\delta}M) = M \\deg G / (2^{\\delta} - M)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove strong honest-verifier zero knowledge it suffices to produce a simulator that perfectly generates the distribution of <span class="math">\\langle r, p(r), f_1(r), \\ldots, f_L(r), p(M) \\rangle</span>. To do so, the simulator chooses <span class="math">r \\stackrel{\\circ}{\\leftarrow} R \\setminus E</span>, chooses <span class="math">a_1, \\ldots, a_L \\stackrel{\\circ}{\\leftarrow} R</span>, computes <span class="math">a \\gets G(a_1, \\ldots, a_L) \\in R</span> and outputs the tuple <span class="math">\\langle r, a, a_1, \\ldots, a_L, 0 \\rangle \\in R^{L+3}</span>. To prove that the simulation is perfect for an honest verifier and an honest prover note that the simulator chooses <span class="math">r</span> identically to the honest verifier, that if <span class="math">a_1, \\ldots, a_L</span> are chosen correctly then the simulation computes <span class="math">a</span> correctly and that an honest prover returns <span class="math">p(M) = 0</span> as the output of the circuit.</p>

    <p class="text-gray-300">Therefore, it is only necessary to show that <span class="math">a_1, \\ldots, a_L</span> are chosen identically to <span class="math">f_1(r), \\ldots, f_L(r)</span>. By interpolation, the value <span class="math">f_i(r)</span> is <span class="math">f_i(r) = \\sum_{k=0}^{M} \\prod_{j \\neq k} \\frac{r - \\alpha_j}{\\alpha_k - \\alpha_j} f_i(\\alpha_j)</span>. Recall that the values <span class="math">f_i(\\alpha_1), \\ldots, f_i(\\alpha_M)</span> are determined by the circuit <span class="math">C</span> and the value <span class="math">f_i(\\alpha_0)</span> is chosen uniformly at random from <span class="math">R</span>. The ring element <span class="math">\\prod_{j \\neq 0} \\frac{r - \\alpha_j}{\\alpha_0 - \\alpha_j}</span> is a unit since <span class="math">r \\in R \\setminus E</span> and <span class="math">\\alpha_0, \\ldots, \\alpha_M \\in D</span>. Therefore, <span class="math">\\prod_{j \\neq 0} \\frac{r - \\alpha_j}{\\alpha_0 - \\alpha_j} f_i(\\alpha_0)</span> is randomly distributed in <span class="math">R</span> and as a consequence <span class="math">f_i(r)</span> is randomly distributed in <span class="math">R</span>, which completes the proof.</p>

    <h2 id="sec-132" class="text-2xl font-bold">E Proofs for Low-Degree Languages</h2>

    <p class="text-gray-300">In this section we spell out the parameters of fully linear IOPs for "low-degree languages," namely languages in which membership can be checked by a system of low-degree equations.</p>

    <p class="text-gray-300"><strong>Corollary E.1 (IOP for multi-output degree-two circuits).</strong> Let <span class="math">R</span> be a ring, let <span class="math">C: R^n \\to R^m</span> be an arithmetic multi-output circuit of degree two defined by <span class="math">C(x) = (C_1(x), \\ldots, C_m(x))</span>. Let <span class="math">\\mathcal{L}_C = \\{x \\in R^n \\mid C(x) = 0^m\\}</span> and let <span class="math">\\epsilon</span> be a required soundness error. Then, there is a fully linear IOP over <span class="math">R</span> with strong HVZK for the language <span class="math">\\mathcal{L}_C</span> that has 1.5 communication rounds, computational complexity <span class="math">\\tilde{O}(n + m)</span>, and the following additional efficiency features.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">R</span> is a finite field <span class="math">\\mathbb{F}</span> then the IOP has proof length <span class="math">O(\\eta \\sqrt{n})</span> elements of <span class="math">\\mathbb{F}</span>, for $\\eta = \\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}((m + \\sqrt{n}) / \\epsilon)<span class="math">, challenge length </span>\\eta + O(1)<span class="math"> elements of </span>\\mathbb{F}<span class="math">, total query complexity </span>O(\\sqrt{n})$, and a verifier of algebraic degree 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">R = \\mathbb{Z}_w</span> for an integer with prime factorization <span class="math">w = p_1^{e_1} \\cdot \\ldots \\cdot p_k^{e_k}</span>, such that <span class="math">p = \\min \\{p_1, \\ldots, p_k\\}</span>, then we get a similar IOP with <span class="math">\\eta = \\log_p \\frac{k(m + (1 + \\epsilon) \\sqrt{n})}{\\epsilon}</span>. If <span class="math">w = 2^e</span> then <span class="math">\\eta = \\log_2 \\frac{m + (1 + \\epsilon) \\sqrt{n}}{\\epsilon}</span>.</li>

    </ul>

    <p class="text-gray-300">Furthermore, the proof is a degree-2 function of the input <span class="math">x</span> and the secret randomness determined by the public randomness and the circuit <span class="math">C</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> If <span class="math">R = \\mathbb{F}</span> then let <span class="math">\\mathbb{E}</span> be an extension field of degree <span class="math">\\eta + O(1)</span> over <span class="math">\\mathbb{F}</span>, i.e $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\eta + O(1)}<span class="math">. Write the circuit </span>C<span class="math"> as </span>C(x) = (C_1(x), C_2(x), \\ldots, C_m(x)) \\in \\mathbb{E}^m<span class="math">, where each </span>C_i<span class="math"> is a degree-two circuit. In the first (half) round of the protocol, the verifier sends a random </span>r \\in \\mathbb{E}<span class="math">. Then the prover and the verifier let </span>C_r<span class="math"> be the degree-two circuit over </span>\\mathbb{E}<span class="math"> defined by </span>C_r(x) = \\sum_{i=1}^{m} r^i \\cdot C_i(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover uses the fully linear PCP of Corollary 4.7 to convince the verifier that <span class="math">C_r(x) = 0</span>. The efficiency parameters, including the proof length, the challenge length, the query complexity and the algebraic degree of the verifier all match those of the corollary. The soundness error has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">two possible causes: the proof that <span class="math">C_r(x) = 0</span> could be incorrect or the proof that <span class="math">C_r(x) = 0</span> could be correct, but <span class="math">C_i(x) \\neq 0</span> for some <span class="math">i \\in \\{1, \\ldots, m\\}</span>. Corollary 4.7 bounds the first type of error by $O(\\sqrt{n}) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\sqrt{n})<span class="math">. If the second type of error occurs then </span>C_r(x)<span class="math"> can be viewed as a polynomial of degree </span>m<span class="math"> in </span>r<span class="math">, which is not identically zero and therefore has at most </span>m<span class="math"> roots. Since </span>r<span class="math"> is chosen at random, the probability that the verifier chooses one of the roots is at most </span>m /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. The union bound on the two types of error implies that the soundness error is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {O (\\sqrt {n}) + m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\sqrt {n}} \\leq \\epsilon .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">If <span class="math">R = \\mathbb{Z}_w</span> then for every prime <span class="math">p_i \\mid w</span> it is easy to compute an irreducible polynomial <span class="math">f_{p_i}(x)</span> of a given degree <span class="math">\\eta + O(1)</span> over <span class="math">\\mathbb{F}_{p_i}</span> [117]. Let <span class="math">f(x) \\in \\mathbb{Z}_w[x]</span> be the mapping of <span class="math">(f_{p_1}(x), \\ldots, f_{p_k}(x))</span> defined by the Chinese Remainder Theorem, i.e. <span class="math">f(x) \\equiv f_{p_i}(x) \\bmod p_i</span> for all <span class="math">i</span>. Let <span class="math">ER = \\mathbb{Z}_w / f(x)</span> be the ring of polynomials modulo <span class="math">f(x)</span> over <span class="math">\\mathbb{Z}_w</span>.</p>

    <p class="text-gray-300">The verifier sends a random <span class="math">r \\in ER</span> and the parties define the circuit <span class="math">C_r(x) = \\sum_{i=1}^m r^i \\cdot C_i(x)</span> over <span class="math">ER</span>. Using the same argument as in the proof to Corollary 4.7 the circuit <span class="math">C_r</span> can be represented as affine gates and <span class="math">O(\\sqrt{n})</span> gates <span class="math">G: ER^{O(\\sqrt{n})} \\times ER^{O}(\\sqrt{n}) \\to ER</span> defined by <span class="math">G(u, v) = \\langle u, v \\rangle</span> for <span class="math">L = \\lceil \\sqrt{n} \\rceil</span>, for <span class="math">u, v</span> that are part of the input <span class="math">x</span>. By Theorem D.5 a proof that <span class="math">C_r(x) = 0</span> can be constructed with the efficiency measures in the corollary and with soundness error <span class="math">\\frac{\\sum_{i=1}^{k} (w/p_i)^{\\eta + O(1)} \\sqrt{n}}{w^{\\eta + O(1)} - \\sqrt{n} \\sum_{i=1}^{k} (w/p_i)^{\\eta + O(1)}}</span>. As in the previous case of fields an additional error term must be added to account for the case <span class="math">C_r(x) = 0</span> but <span class="math">C_i(x) \\neq 0</span> for some <span class="math">i \\in \\{1, \\ldots, m\\}</span>. In this case, <span class="math">C_r(x)</span> is a polynomial of degree <span class="math">m</span> over <span class="math">ER</span> that by Claim D.3 has at most <span class="math">zm</span> roots in <span class="math">ER</span> for <span class="math">z</span> zero divisors in the ring. By Claim D.2 <span class="math">ER</span> has at most <span class="math">\\sum_{i=1}^{k} (w/p_i)^{\\eta + O(1)}</span> zero divisors and hence the number of roots of <span class="math">C_r(x)</span> is at most <span class="math">m \\sum_{i=1}^{k} (w/p_i)^{\\eta + O(1)}</span>. Therefore, the soundness error is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\frac {(m + \\sqrt {n}) \\sum_ {i = 1} ^ {k} (w / p _ {i}) ^ {\\eta + O (1)}}{w ^ {\\eta + O (1)} - \\sqrt {n} \\sum_ {i = 1} ^ {k} (w / p _ {i}) ^ {\\eta + O (1)}} \\leq \\frac {(m + \\sqrt {n}) k (w / p) ^ {\\eta + O (1)}}{w ^ {\\eta + O (1)} - k \\sqrt {n} (w / p) ^ {\\eta + O (1)}} \\\\ \\leq \\frac {(m + \\sqrt {n}) k}{p ^ {\\eta + O (1)} - k \\sqrt {n}} \\leq \\epsilon \\end{array}</span></div>

    <p class="text-gray-300">Recall that the prover must compute the circuit <span class="math">C_r(x)</span> from <span class="math">C</span> and then compute the polynomials <span class="math">f_1(x), \\ldots, f_L(x)</span> (in this case <span class="math">L = O(\\sqrt{n})</span>) and <span class="math">p = G(f_1, \\ldots, f_L)</span>. Each polynomial <span class="math">f_i</span> is defined by the values <span class="math">f_i(\\alpha_j)</span> for <span class="math">O(\\sqrt{n})</span> points <span class="math">\\alpha_1, \\ldots, \\alpha_{O(\\sqrt{n})}</span>. The value <span class="math">f_i(\\alpha_j)</span> is exactly the <span class="math">i</span>-th input to the <span class="math">j</span>-th <span class="math">G</span>-gate of <span class="math">C_r</span>, which is a linear function in the input to the proof and the secret randomness <span class="math">r</span>. Since interpolation is a linear operation, <span class="math">f_i</span> is a linear operation over the input and the secret randomness. Since <span class="math">G</span> computes the inner product, it is a degree-two mapping over its input. Therefore, <span class="math">p</span> is a degree-two polynomial and the whole proof can be obtained by computing a degree-two mapping of the input and the secret randomness determined by the circuit <span class="math">C</span> and by the public randomness.</p>

    <p class="text-gray-300">The computational complexity of the prover is dominated by computing <span class="math">C_r(x)</span> in <span class="math">O(m)</span> time and by the interpolation step required to compute the polynomial <span class="math">p</span> (originally from Theorem 4.3), in <span class="math">\\tilde{O}(n)</span> time, using FFT, which proves the statement of the theorem on computational complexity. <span class="math">\\square</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark E.2. The protocol offers a possible tradeoff between the number of the verifier's random bits and the soundness error. Instead of sending a random <span class="math">r</span> the verifier can send a sequence of random elements <span class="math">r_1, \\ldots, r_m</span> and then <span class="math">C_r</span> is defined by <span class="math">C_r(x) = \\sum_{i=1}^m r_i \\cdot C_i(x)</span>. In this case the number of random bits increases by a factor of <span class="math">m</span> while the additive error term for the case <span class="math">C_r(x) = 0</span> but <span class="math">C_i(x) \\neq 0</span> is reduced to $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for fields and </span>\\sum_{i=1}^k (w / p_i)^{\\eta + O(1)} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for a ring </span>\\mathbb{Z}_w$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">85</p>

    <p class="text-gray-300">Corollary E.3 (Multi-round IOP for multi-output degree-<span class="math">d</span> circuits).</p>

    <p class="text-gray-300">Let <span class="math">R</span> be a ring, let <span class="math">C:R^{n}\\to R^{m}</span> be an arithmetic multi-output circuit of degree <span class="math">d</span> defined by <span class="math">C(x)=(C_{1}(x),\\ldots,C_{m}(x))</span> and let <span class="math">M</span> be the sum of the number of monomials in the representations of <span class="math">C_{1},\\ldots,C_{m}</span> as polynomials. Let <span class="math">\\mathcal{L}_{C}=\\{x\\in R^{n}\\mid C(x)=0^{m}\\}</span> and let <span class="math">\\epsilon</span> be a required soundness error. Then, there is a fully linear IOP over <span class="math">R</span> with strong HVZK for the language <span class="math">\\mathcal{L}_{C}</span> that has <span class="math">O(\\log M)</span> communication rounds, computational complexity <span class="math">\\tilde{O}(dM)</span> and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">R</span> is a finite field then the IOP has proof length <span class="math">O(\\eta d\\log M)</span> elements of <span class="math">\\mathbb{F}</span>, for $\\eta=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}((m+d\\log M)/\\epsilon)<span class="math">, challenge length </span>O(\\eta\\log M)<span class="math"> elements of </span>\\mathbb{F}<span class="math">, total query complexity </span>d+O(\\log M)<span class="math">, and a verifier of algebraic degree </span>O(d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">R=\\mathbb{Z}_{w}</span> for an integer with prime factorization <span class="math">w=p_{1}^{e_{1}}\\cdot\\ldots\\cdot p_{k}^{e_{k}}</span>, such that <span class="math">p=\\min\\{p_{1},\\ldots,p_{k}\\}</span>, then we get a similar IOP with <span class="math">\\eta=\\log_{p}\\frac{k(2\\epsilon+m+d\\log M)}{\\epsilon}</span>. If <span class="math">w=2^{e}</span> then <span class="math">\\eta=\\log_{2}\\frac{2\\epsilon+m+d\\log M}{\\epsilon}</span>.</li>

    </ul>

    <h6 id="sec-133" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If <span class="math">R=\\mathbb{F}</span> then let <span class="math">\\mathbb{E}</span> be an extension field of degree <span class="math">\\eta+O(1)</span> over <span class="math">\\mathbb{F}</span>, write <span class="math">C=(C_{1},\\ldots,C_{m})</span> over <span class="math">\\mathbb{E}</span>, and let <span class="math">C_{r}(x)=\\sum_{i=1}^{m}r^{i}\\cdot C_{i}(x)</span> over <span class="math">\\mathbb{E}</span> for a random <span class="math">r\\in\\mathbb{E}</span> that the verifier sends in the first round of the protocol.</p>

    <p class="text-gray-300"><span class="math">C_{r}</span> is of degree <span class="math">d</span> and can be represented as a sum of at most <span class="math">M</span> multivariate monomials over <span class="math">\\mathbb{E}</span>. Let <span class="math">Q</span> be the set of <span class="math">M</span> monomials that determine <span class="math">C_{r}</span>. Define a circuit <span class="math">C^{\\prime}(x_{1},\\ldots,x_{d})=\\prod_{i=1}^{d}x_{i}</span> and note that</p>

    <p class="text-gray-300"><span class="math">C_{r}=\\sum_{I=x_{i_{1}}\\cdot\\ldots\\cdot x_{i_{d}}\\in Q}C^{\\prime}(A_{I}(x_{1},\\ldots,x_{n})),</span></p>

    <p class="text-gray-300">for some affine functions <span class="math">A_{I}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">C_{r}</span> has this representation as a parallel sum, there is a fully linear IOP over <span class="math">\\mathbb{E}</span> for <span class="math">\\mathcal{L}_{C}</span> based on Theorem 5.1. The number of executions of <span class="math">C^{\\prime}</span> in <span class="math">C_{r}</span> is <span class="math">O(M)</span>, the degree of <span class="math">C^{\\prime}</span> is <span class="math">d</span> and each element in <span class="math">\\mathbb{E}</span> can be viewed as <span class="math">\\eta</span> elements of <span class="math">\\mathbb{F}</span>. Therefore, by the statement of Theorem 5.1, the number of rounds in the IOP is <span class="math">O(\\log M)</span>, the proof length is <span class="math">O(d\\eta\\log M)</span> elements of <span class="math">\\mathbb{F}</span>, the query complexity is <span class="math">d+O(\\log M)</span> and the algebraic degree of the verification circuit is <span class="math">d</span>. Based on the proof of Theorem 5.1, at each round the verifier sends as challenge one element of <span class="math">\\mathbb{E}</span>, leading to challenge length <span class="math">O(\\eta\\log M)</span> elements of <span class="math">\\mathbb{F}</span>. The computational complexity of the prover is dominated by <span class="math">\\log M</span> interpolations and evaluations of at most <span class="math">M</span> constant-degree polynomials, and by computing the output of each monomial which together require <span class="math">\\tilde{O}(dM)</span> time. Similarly to Corollary E.1 the soundness error is the sum of the probability that the proof that <span class="math">C_{r}(x)=0</span> is incorrect and the probability that <span class="math">C_{r}(x)=0</span> but <span class="math">C_{i}(x)\\neq 0</span> for some <span class="math">i</span>. By Theorem 5.1 the first term is bounded by $O(\\frac{m+d\\log M}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> and using a similar argument to Corollary E.1 the second term is bounded by </span>O(m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Taken together, the soundness error is </span>\\frac{m+d\\log M}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\eta+O(1)}\\leq\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">R=\\mathbb{Z}_{w}</span> then let <span class="math">f(x)</span> be a polynomial of degree <span class="math">\\eta+O(1)</span> over <span class="math">\\mathbb{Z}_{w}</span>, such that <span class="math">f_{p_{i}}(x)</span> is of the same degree and is irreducible over <span class="math">\\mathbb{F}_{p_{i}}</span> for every <span class="math">i</span>. Let <span class="math">ER=\\mathbb{Z}_{w}/f(x)</span> and represent <span class="math">C</span> and <span class="math">C_{r}</span> over <span class="math">ER</span>. We repeat the proof of Theorem 5.1 for the case of a circuit over the ring <span class="math">ER</span>, by plugging in the Fully Linear PCP of Theorem D.5 as the basic building block instead of the Fully Linear PCP for fields described by Theorem 4.3. The result is an IOP with similar complexity to the IOP over fields in all the measures stated in the corollary: number of communication rounds, proof length, challenge length, query complexity, algebraic degree and computational complexity of the prover.</p>

    <p class="text-gray-300">To analyze the probability that the proof that <span class="math">C_{r}(x)=0</span> is incorrect, note that the proof proceeds in <span class="math">\\log M</span> rounds, and in each the number of <span class="math">g</span> gates is two. Bounding the error for each round based on Theorem D.5 and taking a union bound results in <span class="math">\\frac{d\\log M\\sum_{i=1}^{k}(w/p_{i})^{\\eta+O(1)}}{w^{\\eta+O(1)}-2\\sum_{i=1}^{k}(w/p_{i})^{\\eta+O(1)}}</span>. Adding the term for the case that <span class="math">C_{r}(x)=0</span>, but <span class="math">C_{i}(x)\\neq 0</span> for some <span class="math">i</span>, which is <span class="math">\\frac{m\\sum_{i=1}^{k}(w/p_{i})^{\\eta+O(1)}}{w^{\\eta+O(1)}}</span>, we get that the</p>

    <p class="text-gray-300">soundness error is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\frac{(m + d \\log M) \\sum_{i=1}^{k} (w / p_i)^{\\eta + O(1)}}{w^{\\eta + O(1)} - 2 \\sum_{i=1}^{k} (w / p_i)^{\\eta + O(1)}} \\leq \\frac{(m + d \\log M) k (w / p)^{\\eta + O(1)}}{w^{\\eta + O(1)} - 2 k (w / p)^{\\eta + O(1)}} \\\\ \\leq \\frac{(m + d \\log M) k}{p^{\\eta + O(1)} - 2k} \\leq \\epsilon \\end{array}</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">87</p>`;
---

<BaseLayout title="Zero-Knowledge Proofs on Secret-Shared Data via Fully Linear... (2019/188)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/188
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
