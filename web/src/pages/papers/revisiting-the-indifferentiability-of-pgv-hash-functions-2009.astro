---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/265';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Revisiting the Indifferentiability of PGV Hash Functions';
const AUTHORS_HTML = 'Yiyuan Luo, Zheng Gong, Ming Duan, Bo Zhu, Xuejia Lai';

const CONTENT = `    <p class="text-gray-300">Yiyuan Luo^{1}, Zheng Gong^{2}, Ming Duan^{1}, Bo Zhu^{1} and Xuejia Lai^{1} ^{1}Department of Computer Science and Engineering Shanghai Jiaotong University, China luoyiyuan@sjtu.edu.cn ^{2}Faculty of EEMCS University of Twente, The Netherlands z.gong@utwente.nl</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In this paper, first we point out some flaws in the existing indifferentiability simulations of the pf-MD and the NMAC constructions, and provide new differentiable attacks on the hash functions based these schemes. Afterthat, the indifferentiability of the 20 collision resistant PGV hash functions, which are padded under the pf-MD, the NMAC/HMAC and the chop-MD constructions, are reconsidered. Moreover, we disclose that there exist 4 PGV schemes can be differentiable from a random oracle with the pf-MD among 16 indifferentiable PGV schemes proven by Chang et al. Finally, new indifferentiability simulations are provided for 20 collision-resistant PGV schemes. The simulations exploit that 20 collision-resistant PGV hash functions, which implemented with the NMAC/HMAC and the chop-MD, are indifferentiable from a random oracle. Our result implies that same compression functions under MD variants might have the same security bound with respect to the collision resistance, but quite different in the view of indifferentiability.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Cryptographic Hash Functions. Cryptographic hash function, which is defined as an admissible algorithm that uniformly maps arbitrary length inputs to fixed length outputs, is widely used as a pivotal primitive for ensuring the integrity of information. In nowadays, the popular design of cryptographic hash functions still follows the well-known Merkle-Damgård (MD) construction <em>[12, 21]</em>, by iterating a compression function on an input message to realize a domain extension transform and yields a collision resistant hash function if the underlying compression function is. The primary security goal for cryptographic hash functions has historically been collision resistance. Unfortunately, hash functions have been used for all kinds of applications which the security requirements are not only satisfied by collision resistance, but also pseudo-randomness, and even to be a random oracle <em>[2]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In recent years, the hash community starts to argue that the traditional Merkle-Damgård (MD) construction is not a good design in the security view as a random oracle <em>[9]</em>. Since the well-known extension attack allows one to take a value <span class="math">H(x)</span> for <span class="math">x</span>, and then computes the value $H(x,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,y)<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the length of </span>x<span class="math"> and </span>y<span class="math"> is an arbitrary suffix. But this extension property is not allowed for any truly random oracle. For instance, even if the underlying compression function </span>f<span class="math"> is assumed to be a fixed-length random oracle, any hash function </span>H^{f}$ under MD construction will unlikely to be indifferentiable with a random oracle. From those counter-examples, people realize that collision resistance alone is insufficient for the security of so many different applications of hash functions. For this reason, a rich literature analyzed the security of hash functions obtaining variable-input-length (VIL) from an ideal fixed-input-length (FIL) compression function, such as <em>[1, 2, 3, 9, 17]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In practice, there exist two main approaches to design a compression function for an iterated hash function. One is to implicitly design a compression function by implicitly using the idea of block ciphers, which is called <em>dedicated</em> hash function. The other is to explicitly compose a compression function from block ciphers, which is called <em>block-cipher-based</em> hash function. By now, it seems still hard to design a dedicated compression function by witnessing the</p>

    <p class="text-gray-300">recent collision attacks on serval popular hash functions <em>[23, 24]</em>. The advantage of block-cipher-based hash functions is that one can conveniently choose an extensively studied block cipher (e.g., DES, IDEA, AES, etc) to construct a compression function, so that the design and implementation efforts could be minimized. Also the latest cryptanalysis on such a block cipher can be used to avoid the potential weakness in the compression function. Discussions of hash functions constructed from <span class="math">n</span>-bit block ciphers are mainly divided into single block length (SBL) such as 64 PGV schemes <em>[22]</em>, and double block length (DBL) such as MDC2 <em>[6]</em>, where single and double are related to the output range of the underlying block cipher.</p>

    <p class="text-gray-300">The original proposals of block-cipher-based hash functions usually focus on attacks, not formal proofs. As the development of provable security, some works have focused on the provable security of hash function based on block ciphers by modeling the underlying block cipher as a black box <em>[5, 16]</em>. In <em>[5]</em>, Black et al. described a black-box analysis of all 64 PGV hash functions and proved that in the black box model, there exist 20 out of 64 PGV hash functions are collision resistant.</p>

    <p class="text-gray-300">Indifferentiability Methodology. In TCC’04, Maurer et al. introduced a strong security notion called as indifferentiability <em>[19]</em> for a hash function based on a compression function which is an extension of the classical indistinguishability security notion. The advantage of the indifferentiability is that one can built a secure VIL-RO from smaller (FIL) idealized components(such as an ideal compression function or ideal cipher). In Crypto’05, Coron et al. first implemented the indifferentiability in analysis of hash functions and suggested four secure constructions <em>[9]</em>, which were the prefix-free padding(pf-MD), the NMAC/HMAC and the chop construction(chop-MD). The compression function is viewed as a fixed-length random oracle or built from an ideal block cipher with Davies-Meyer structure. After that, several works followed to investigate the indifferentiability of a hash construction, such as <em>[2, 3, 4, 7, 13, 14]</em>.</p>

    <p class="text-gray-300">At Asiacrypt’06, Chang et al. presented a unified way to prove the indifferentiability for block-cipher-based hash functions <em>[7]</em>. They analyzed 20 collision resistant PGV hash functions with pf-MD and found there are sixteen schemes are indifferentiable from random oracle and other four schemes are differentiable in the ideal cipher model. In <em>[15]</em>, Gong et al. provided a synthetic indifferentiability analysis of some block-cipher-based hash functions and claimed that all 20 collision resistant PGV schemes are indifferentiable from random oracle with the pf-MD, the NMAC/HMAC and the chop-MD constructions, where the length padding should be used in the constructions.</p>

    <p class="text-gray-300">Our Contributions. In this paper, by using the indifferentiability methodology, we revisit the indifferentiability of hash functions with pf-MD, NMAC/HMAC and chop-MD construction when the compression function is based on collision resistant PGV structures. We find that there exist 8 PGV schemes are differentiable from random oracle with pf-MD, but indifferentiable from random oracle with NMAC/HMAC and chop-MD. And this give evidence that the four constructions are not the same in the view of the indifferentiability. In the analysis, we revise the flaws in Coron et al.<em>[9]</em> and Chang et al.<em>[7]</em>’s proofs of Davies-Meyer compression function with pf-MD and NMAC, which allow an adversary can implement differentiable attacks on them. Furthermore, we find that in the 16 collision resistant PGV hash functions which are proved indifferentiable from a random oracle in the ideal cipher model with pf-MD in Chang et al.’s analysis, there are still 4 are really differentiable. According to our analysis, although all of the 20 collision resistant PGV hash function with NMAC/HMAC and chop-MD are indifferentiable from a random oracle in the ideal cipher model, the chop-MD construction has a better indifferentiability bound in advance.</p>

    <p class="text-gray-300">Organization. The organization of this paper is as follows. In Section 2, the notation of indifferentiability and some previous works are reviewed. In Section 3, formal methods of the indifferentiability of a hash function in the ideal cipher model are described. In Section 4, Coron et al.’s and Chang et al.’s proofs of indifferentiability of hash functions based on the Davies-Meyer structure with pf-MD and NMAC construction are described and flaws in their works are pointed out, and the right proofs for pf-MD and NMAC construction are given. In Section 5, the indifferentiability of 20 collision resistant PGV hash functions with pf-MD, NMAC/HMAC, chop-MD construction are revisited. Finally we draw a conclusion in Section 6.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">|  Group-1 schemes  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh_i-1(mi) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(h_i-1) ⊕ hi-1</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(mi) ⊕ mi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh_i-1(wi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(h_i-1) ⊕ hi-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh_i-1(mi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(h_i-1) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(mi) ⊕ hi-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh_i-1(wi) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ hi-1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(h_i-1) ⊕ mi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2.1 Group-1 schemes in [5].</p>

    <p class="text-gray-300">Ideal cipher model, which is often called black box model as well, is a formal model for the security analysis of block-cipher-based hash functions. An ideal cipher is an ideal primitive that models a random block-cipher  <span class="math">E: \\{0,1\\}^k \\times \\{0,1\\}^n \\mapsto \\{0,1\\}^n</span> . Each key  <span class="math">k \\in \\{0,1\\}^k</span>  defines a random permutation  <span class="math">E_k = E(k,\\cdot)</span>  on  <span class="math">\\{0,1\\}^n</span> . An adversary is given forward or inverse queries to oracles  <span class="math">E</span> , when he makes a forward query to  <span class="math">E</span>  with  <span class="math">(+,k,p)</span> , it returns the point  <span class="math">c</span>  such that  <span class="math">E_k(p) = c</span> , when he makes an inverse query to  <span class="math">E</span>  with  <span class="math">(-,k,c)</span> , it returns the point  <span class="math">p</span>  such that  <span class="math">E_k(p) = c</span> .</p>

    <p class="text-gray-300">As the ideal cipher model, the random oracle model(ROM) is also a method of developing provably secure cryptosystems. Simply says, A random oracle (RO) is an ideal primitive which provides a random output for each new query. Identical input queries are given the same answer. Recently, it was proven by Coron et al. [11] that the ideal cipher model is equivalent to the random oracle model by using the indifferentiability methodology.</p>

    <p class="text-gray-300">At Crypto'93, Preneel, Govaerts and Vandewalle (PGV) [22] proposed a synthetic approach to design single block length hash function based on block ciphers. They considered the method of turning a block cipher  <span class="math">E: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  into a hash function  <span class="math">H: \\{0,1\\}^* \\to \\{0,1\\}^n</span>  using a compression function  <span class="math">f: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  derived from  <span class="math">E</span> . For a fixed  <span class="math">n</span> -bit constant  <span class="math">v</span> , PGV considered all 64 compression functions  <span class="math">f</span>  of the form  <span class="math">f(h_{i-1},m_i) = E_k(p) \\oplus a</span>  where  <span class="math">k,p,a \\in \\{h_{i-1},m_i,h_{i-1} \\oplus m_i,v\\}</span> , where  <span class="math">w_i = h_{i-1} \\oplus m_i</span>  and  <span class="math">v</span>  is a constant. The hash function  <span class="math">H(m_1,\\ldots,m_l)</span>  can subsequently be described as follows:</p>

    <div class="my-4 text-center"><span class="math-block">h _ {i} = f \\left(h _ {i - 1}, m _ {i}\\right), i = 1, 2, \\dots , l</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here  <span class="math">f</span>  is the underlying compression function,  <span class="math">h_0</span>  is equal to a fixed initial value IV,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">  for each  </span>i \\in [1 \\cdots l]<span class="math">  and  </span>h_l$  is the hashcode. Of the 64 such schemes, PGV regards 12 schemes as secure in the sense of both the preimage resistance and the collision resistance. Another 13 schemes they classified as backward-attackable, which means they are subject to a potential attack. The remaining 39 schemes are subject to fatal attacks. Afterthat, Black et al. [5] revisited all the 64 PGV schemes in the ideal cipher model. They proved that the 12 secure schemes that PGV had singled out remain secure in the black-box analysis, which are denoted as the Group-1 schemes (listed in Table 2.1). Additionally, there are 8 schemes are also secure after iteration, they denoted these 8 schemes as the Group-2 schemes (listed in Table 2.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In [9], Coron et al. proposed four Merkle-Damgård variants such that the arbitrary length hash function  <span class="math">H</span>  must behave as a random oracle when the fixed-length building block is viewed as a random oracle or an ideal block cipher, namely, the prefix-free padding, the NMAC/HMAC and the chop constructions. In this paper only compression function based on PGV schemes is considered. The four variants are described in Table 2.3.</p>

    <p class="text-gray-300">|  Group-2 schemes  |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(mi) ⊕ v</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(hi-1) ⊕ v</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ v</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(mi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(hi-1) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ mi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(hi-1) ⊕ v</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">Ewi(hi-1) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2.2 Group-2 schemes in [5].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pf-MDf(IV,M): M=m1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mi,h0=IV1 For i=1 to i do hi=f(g(mi),hi-1) Return hi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NMACf1,f2(IV1,M): M=m1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mi,h0=IV For i=1 to i do hi=f1(mi,hi-1) Return f2(hi,IV2)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HMACf(IV,M): M=m1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">mi,h0=f(0n,IV) For i=1 to i do hi=f(mi,hi-1) Return hi+1=f(hi,IV)</td>

            <td class="px-3 py-2 border-b border-gray-700">chop-MDsf(IV,M): M=m1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">mi,h0=IV For i=1 to i do hi=f(mi,hi-1) Return the first n-s bit of hi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2.3 Definitions of the four MD variants [9].1</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The famous Davis-Meyer scheme is an instance of PGV schemes, which can be denoted as  <span class="math">f(h_{i-1}, m_i) = E_{m_i}(h_{i-1}) \\oplus h_{i-1}</span> . In the pf-MD construction, the message  <span class="math">(m_1, \\ldots, m_l)</span>  are guaranteed to be prefix-free. This is because prefix-free encoding enables to eliminate the message expansion attack on hash functions, such as extension attack on MAC. For example, if a MAC is built from a hash function like  $\\mathrm{MAC}(k, m) = H(k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math">  where  </span>k<span class="math">  is the secret key. Then this MAC scheme is completely insecure for any Merkle-Damgård construction (including Merkle-Damgård strengthening). That is to say, given  </span>\\mathrm{MAC}(k, m) = H(k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m)<span class="math"> , we can extend the message  </span>m<span class="math">  with any single arbitrary block  </span>m'<span class="math">  and obtain  </span>\\mathrm{MAC}(k, m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m') = H(k \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m')<span class="math">  without knowing the secret key  </span>k$ . If we apply a prefix-free encoding to a message and then call the hash function to get its hash value, we can eliminate the message expansion attack. In fact, NMAC/HMAC and chop-MD are the same as pf-MD by references to avoid the message expansion attack.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this part, we recall the definition for indifferentiability[9, 19], which will be used in the following security analysis of PGV hash functions on the four MD variants.</p>

    <p class="text-gray-300">Definition 1 A Turing machine  <span class="math">H</span>  with oracle access to an ideal primitive  <span class="math">E</span>  is said to be  <span class="math">(t_D, t_S, q, \\epsilon)</span> -indifferentiable from an ideal primitive  <span class="math">\\mathcal{F}</span>  if there exists a simulator  <span class="math">S</span>  with oracle access to  <span class="math">\\mathcal{F}</span>  and running in time at most  <span class="math">t_S</span> , such that for any distinguisher  <span class="math">D</span>  it holds that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P r [ D ^ {H, E} = 1 ] - P r [ D ^ {\\mathcal {F}, S} = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;   \\epsilon</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The simulator has oracle access to  <span class="math">\\mathcal{F}</span>  and runs in time at most  <span class="math">t_S</span> . The distinguisher runs in time at most  <span class="math">t_D</span>  and makes at most  <span class="math">q</span>  queries. Similarly,  <span class="math">H^E</span>  is said to be (computationally) indifferentiable from  <span class="math">\\mathcal{F}</span>  if  <span class="math">\\epsilon</span>  is a negligible function of the security parameter  <span class="math">k</span>  (for polynomially bounded  <span class="math">t_D</span>  and  <span class="math">t_S</span> ).</p>

    <p class="text-gray-300">The role of the simulator is to simulate the ideal primitive  <span class="math">E</span>  so that no distinguisher can tell whether it is interacting with  <span class="math">H</span>  and  <span class="math">E</span> , or with  <span class="math">\\mathcal{F}</span>  and  <span class="math">S</span> ; In other words, the output of  <span class="math">S</span>  should look consistent with what the</p>

    <p class="text-gray-300">distinguisher can obtain from <span class="math">\\mathcal{F}</span>. Note that the simulator does not see the distinguisher’s queries to <span class="math">\\mathcal{F}</span>; however, it can call <span class="math">\\mathcal{F}</span> directly when it is required for the simulation. Here the algorithm <span class="math">H</span> will represent the construction of an iterative hash function based on <span class="math">E</span>. The ideal primitive <span class="math">E</span> will represent the underlying primitive used to build the hash function. In this paper, we assume <span class="math">E</span> is an ideal block cipher. <span class="math">\\mathcal{F}</span> is a random oracle with same domain and range as the hash function. In the case of ideal cipher model the distinguisher can access both <span class="math">E</span> and <span class="math">E^{-1}</span> oracles and the simulator has to simulate the both.</p>

    <p class="text-gray-300">It was proven by Maurer et al. that if <span class="math">H^{E}</span> is indifferentiable from <span class="math">\\mathcal{F}</span>, then <span class="math">H^{E}</span> can replace <span class="math">\\mathcal{F}</span> in any cryptosystem. The original theorem stated in below is a generic statement of the indifferentiability.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 1</h6>

    <p class="text-gray-300">Let <span class="math">P</span> be a cryptosystem with oracle access to an ideal primitive <span class="math">\\mathcal{F}</span>. Let <span class="math">H</span> be an algorithm such that <span class="math">H^{E}</span> is indifferentiable from <span class="math">\\mathcal{F}</span>. Then cryptosystem <span class="math">P</span> is at least as secure in the <span class="math">E</span> model with algorithm <span class="math">H</span> as in the <span class="math">\\mathcal{F}</span> model.</p>

    <p class="text-gray-300">Coron et al. stated the indifferentiability of Davies-Meyer block cipher based construction with four MD variants in the ideal cipher model, the theorem is stated in <em>[9]</em> as follows.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 2</h6>

    <p class="text-gray-300">The Davis-Meyer scheme is <span class="math">f(h_{i-1},m_{i})=E_{m_{i}}(h_{i-1})\\oplus h_{i-1}</span>) pf-MD, chop-MD, NMAC and HMAC are <span class="math">(t_{D},t_{S},q,\\epsilon)</span>-indifferentiable from a random oracle in the ideal cipher model. For any <span class="math">t_{D}</span> ,with <span class="math">t_{S}=O(q^{2})</span>, with <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for pf-MD, <span class="math">\\epsilon=2^{-s}\\cdot l^{2}\\cdot O(q^{2})</span> for chop-MD, <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for NMAC and HMAC, where <span class="math">l</span> is the maximum length of a query made by the distinguisher <span class="math">D</span>.</p>

    <p class="text-gray-300">It was observed that Coron et al.’s bound of chop-MD is not tight. In <em>[8]</em>, Chang and Nandi presented an improved indifferentiability security bound for chop-MD and stated the following theorem:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Theorem 3</h6>

    <p class="text-gray-300">The chop-MD construction is <span class="math">(t_{D},t_{S},q,\\sigma,\\epsilon)</span>-indifferentiable from a random oracle, in the random oracle model for the compression function, for any <span class="math">t_{D}</span>, with <span class="math">t_{S}=l\\cdot O(q^{2})</span> and <span class="math">\\epsilon=\\frac{(3(n-s)+1)q_{2}+(n-s)q_{1}}{2^{s}}+\\frac{q}{2^{n-s-1}}+\\frac{\\sigma^{2}}{2^{n+1}}=O(\\frac{nq}{2^{s}}+\\frac{q}{2^{n-s}}+\\frac{\\sigma^{2}}{2^{n}})</span>, where <span class="math">q=q_{1}+q_{2}</span> is the total number of queries and <span class="math">\\sigma</span> is the total number of queried message blocks.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3 Proofs of Indifferentiability of PGV Hash Functions</h2>

    <p class="text-gray-300">It is easy to see that any PGV compression functions are not indifferentiable from a random oracle <em>[18]</em>. But when the initial value IV is fixed, then there exist some PGV hash functions are indifferentiable from random oracle. To prove a scheme indifferentiable from a random oracle is not trivial. In Coron et al.’s paper <em>[9]</em>, the proof of indifferentiability involved two steps. First, a simulator is built to simulate the task of the ideal cipher. Secondly, they showed that the view of any distinguisher in the random oracle model, with oracle access to the actual random oracle and the ideal cipher simulator, didn’t differ from its view in the ideal cipher model, with oracle access to the RO construction and the ideal cipher, by more than a negligible amount. Each proofs of indifferentiability consisted of a hybrid argument that presented a sequence of mutually indistinguishable games starting in the random oracle model, with the RO <span class="math">\\mathcal{F}</span> and the ideal cipher simulator <span class="math">S</span>(denoted by <span class="math">S^{\\mathcal{F}}</span>), leading up to the ideal cipher model, with the RO construction and the ideal cipher <span class="math">E</span> (denoted by <span class="math">H^{E}</span>). To prove the indifferentiability of a construction, they played six games and the proof is complicated.</p>

    <p class="text-gray-300">Later Chang et al. presented a formal method to prove the indifferentiability for many designs of hash functions with pf-MD construction which was in fact the same to Coron et al.’s proof. Since Chang et al.’s proof is more mathematical and formal, we adopt their method in our analysis. Here we describe Chang et al.’s proof on pf-MD in below.</p>

    <p class="text-gray-300">Let <span class="math">D</span> be a distinguisher and <span class="math">S</span> be a simulator for the formal analysis of indifferentiability. By following Definition 1, <span class="math">D</span> is interacting with two cryptosystems <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span>, where either <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})=(H,E)</span> or <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})=(\\mathcal{F},S)</span>. The distinguisher’s goal is to distinguish which scenario it involves after the queries to <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span>. <span class="math">H:\\mathcal{M}\\rightarrow\\mathcal{Y}</span> denotes a hash function constructed from a block-cipher <span class="math">E:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span> where <span class="math">\\mathcal{M}\\in\\{0,1\\}^{*}</span> and <span class="math">\\mathcal{Y}\\in\\{0,1\\}^{n}</span>. <span class="math">\\mathcal{F}</span> is a random oracle which has the same domain and range with <span class="math">H</span>. <span class="math">h_{i}</span> denotes the hash value of the <span class="math">i</span>-th</p>

    <p class="text-gray-300">query. Let <span class="math">r_i \\leftarrow (h_{i-1} \\xrightarrow{m_i} h_i)</span> be the <span class="math">i</span>-th query-response obtain from the query to the oracle <span class="math">\\mathcal{O}_2</span> where <span class="math">m_i \\in \\{0,1\\}^n</span>. <span class="math">\\mathcal{R}_i = (r_1, \\dots, r_i)</span> denotes the query-response set on the oracles <span class="math">\\mathcal{O}_2</span> after the <span class="math">i</span>-th query. Let <span class="math">r_i&#x27; \\leftarrow (IV \\xrightarrow{M} h_i)</span> be the <span class="math">i</span>-th query-response to the oracles <span class="math">\\mathcal{O}_1</span> where <span class="math">M \\in \\mathcal{M}</span>. <span class="math">\\mathcal{R}_i&#x27; = (r_1&#x27;, \\dots, r_i&#x27;)</span> denotes the query-response set on the oracles <span class="math">\\mathcal{O}_1</span> after the <span class="math">i</span>-th query. A functional closure <span class="math">\\mathcal{R}^*</span> on <span class="math">\\mathcal{R}</span> is the set with the following properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. If <span class="math">h_{i-1} \\xrightarrow{m_i} h_i, h_i \\xrightarrow{m_{i+1}} h_{i+1} \\in \\mathcal{R}_{i+1}</span>, then $h_{i-1} \\xrightarrow{m_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_{i+1}} h_{i+1} \\in \\mathcal{R}_{i+1}^*$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <span class="math">\\mathcal{O}_1</span>-query inputs an arbitrary length message and outputs a fixed length hash value, while the <span class="math">\\mathcal{O}_2</span>-query inputs a fixed length key and plaintext or ciphertext and outputs the corresponding ciphertext or plaintext, respectively. The details of the two categories of queries are described in below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query on <span class="math">\\mathcal{O}_1 = H</span> or <span class="math">\\mathcal{O}_1 = \\mathcal{F}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query on <span class="math">\\mathcal{O}_1</span>, distinguish <span class="math">D</span> selects an arbitrary length message <span class="math">M_i \\in \\mathcal{M}</span>. The response of <span class="math">\\mathcal{O}_1</span> is <span class="math">h_i = H(IV, M_i)</span> or <span class="math">h_i = \\mathcal{F}(M_i)</span> where <span class="math">h_i \\in \\mathcal{Y}</span>.</li>

      <li>Let <span class="math">\\mathcal{R}_i&#x27; = \\mathcal{R}_{i-1}&#x27; \\cup (IV \\xrightarrow{M_i} h_i)</span> be the query-response set on the oracles <span class="math">\\mathcal{O}_1</span> after the <span class="math">i</span>-th query. The query-response set <span class="math">\\mathcal{R}_q&#x27;</span> is the complete view of distinguish <span class="math">D</span> on the oracles <span class="math">\\mathcal{O}_1</span> after the maximum <span class="math">q</span> queries. Note that the simulator <span class="math">S</span> never sees the distinguish 's queries to <span class="math">\\mathcal{O}_1</span>'.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query on <span class="math">\\mathcal{O}_2 = E</span> or <span class="math">\\mathcal{O}_2 = S</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th forward query on <span class="math">\\mathcal{O}_2</span>, distinguish <span class="math">D</span> queries <span class="math">(+, k_i, p_i)</span> where <span class="math">k_i, p_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i, v\\}</span> and the response is <span class="math">c_i = E_{k_i}(p_i)</span> or <span class="math">c_i = S(k_i, p_i)</span>, where <span class="math">c_i \\in \\{0, 1\\}^n</span>. By computing the hash value <span class="math">h_i</span> from the tuple <span class="math">(k_i, p_i, c_i)</span>, the <span class="math">i</span>-th query-response set <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup (h_{i-1} \\xrightarrow{m_i} h_i)</span>.</li>

      <li>For the <span class="math">i</span>-th inverse query on <span class="math">\\mathcal{O}_2</span>, distinguish <span class="math">D</span> queries <span class="math">(-, k_i, c_i)</span> where <span class="math">k_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i, v\\}</span> and <span class="math">c_i \\in \\{0, 1\\}^n</span> and the response is <span class="math">p_i = E_{k_i}^{-1}(c_i)</span> or <span class="math">p_i = S^{-1}(k_i, c_i)</span>, where <span class="math">p_i \\in \\{0, 1\\}^n</span>. By computing <span class="math">h_{i-1}, h_i</span> from the tuple <span class="math">(k_i, p_i, c_i)</span>, the <span class="math">i</span>-th query-response set <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup (h_{i-1} \\xrightarrow{m_i} h_i)</span>.</li>

      <li>Let <span class="math">\\mathcal{R}_q</span> be the query-response set of the oracle <span class="math">\\mathcal{O}_2</span> after the maximum <span class="math">q</span> queries. According to the transitive and substitute properties of <span class="math">\\mathcal{R}_q</span>, the functional closure <span class="math">\\mathcal{R}_q^*</span> is the complete view of distinguish <span class="math">D</span> on the oracles <span class="math">\\mathcal{O}_2</span>. Here the simulator <span class="math">S</span> also has this view.</li>

    </ul>

    <p class="text-gray-300">When <span class="math">D</span> interacts with <span class="math">(\\mathcal{F}, S)</span>, the simulator should simulate the ideal cipher <span class="math">E</span> perfectly except a negligible probability. When <span class="math">D</span> makes queries to the oracle <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>, there may be some bad events happen, and the distinguish <span class="math">D</span> can exploit these bad events to decide which scenario it is in. If bad events don't happen, the distinguish <span class="math">D</span> can never distinguish which scenario it is in except for a negligible probability.</p>

    <p class="text-gray-300">In Chang et al.'s indifferentability analysis, <span class="math">E_1, E_2</span> are the bad events when <span class="math">D</span> interacts with <span class="math">(H, E)</span> and <span class="math">(\\mathcal{F}, S)</span>, respectively. The oracles <span class="math">(H, E)</span> and <span class="math">(\\mathcal{F}, S)</span> are identically distributed in the past view of the distinguish <span class="math">D</span> when <span class="math">E_1, E_2</span> do not happen. <span class="math">Adv(\\mathcal{D})</span> is the measure of the maximal advantage of indifferentability over all distinguishers <span class="math">\\mathcal{D}</span>. For brevity, <span class="math">D_1</span> denotes the event <span class="math">\\mathcal{D}^{H, E} = 1</span> and <span class="math">D_2</span> denotes the event <span class="math">\\mathcal{D}^{\\mathcal{F}, S} = 1</span>. Let the function <span class="math">max()</span> return the largest value of inputs. The advantage of <span class="math">D</span> is given in [7] as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adv(\\mathcal{D}) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[\\mathcal{D}_1] - Pr[\\mathcal{D}_2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\times \\max(Pr[E_1], Pr[E_2]).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Now the proof of indifferentability of a scheme is clear. First, one should construct a simulator <span class="math">S</span> such that <span class="math">D</span> interacting with <span class="math">(\\mathcal{F}, S)</span> is indifferentable with <span class="math">(H, E)</span>. Next, one must calculate the upper bound of the probability of the differentiable events, when <span class="math">D</span> interacts with <span class="math">(\\mathcal{F}, S)</span> and <span class="math">(H, E)</span> respectively. Finally, one can deduce the maximal advantage of the differentiability over all distinguishers <span class="math">D</span>.</p>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">4 Flaws in Previous Indifferentiability Analysis of the Davies-Meyer Scheme.</p>

    <p class="text-gray-300">The Davies-Meyer scheme is a well-known construction in the design of compression function based on block ciphers, which also belongs to 20 collision resistant PGV structures. It is also used implicitly implemented in the constructions of MD5 and SHA-1. Coron et al.’s full paper <em>[9]</em> presented the detailed proof of the indifferentiability of the pf-MD, the chop-MD and NMAC based on the Davies-Meyer scheme. Chang et al. <em>[7]</em> also proposed a proof of the indifferentiability of pf-MD, which uses the Davis-Meyer scheme as the underlying compression function. Unfortunately, we find that there exist some flaws in Coron et al.’s proofs of pf-MD and NMAC, and also Chang et al.’s proof of the pf-MD such that a new type distinguisher can implement differentiable attacks on the Davies-Meyer scheme while extends its domain by using the pf-MD and the NMAC construction. This section will be divided into three parts. In the first part, Coron et al’s and Chang et al’s simulators for pf-MD and NMAC are recalled. In the second part, new differentiable attacks on these simulators are presented. Finally, according to our new attacks, the indifferentiability simulations for the Davies-Meyer scheme with pf-MD and NMAC are refined in the third part.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Previous Simulators of pf-MD and NMAC</h3>

    <p class="text-gray-300">Coron et al.’s and Chang et al.’s simulators of pf-MD and NMAC based on Davies-Meyer structure are described in the appendix A. When these simulators are built, then the advantages of the distinguishers can be calculated by using the method in <em>[9]</em> or <em>[7]</em>. In the next part, we will show how to differentiable attack these simulations and refine the simulations to against this type of attacks.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.2 A New Type of Differentiable Attacks on the Simulations of pf-MD and NMAC.</h3>

    <p class="text-gray-300">In this part, some differentiable attacks are presented to disclose the fact that the plausible simulations(which are recalled in Appendix A) will be failed in the ideal cipher model. After pointed out the attacks, the simulations and the proofs for pf-MD and NMAC are refined to avoid the above attacks. The following distinguishers demonstrate how to attack Coron et al’s and Chang et al’s simulators.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Attack on the Simulations of pf-MD.</h4>

    <p class="text-gray-300">The following distinguisher can distinguish <span class="math">(H,E)</span> and <span class="math">(\\mathcal{F},S)</span> with a non-negligible probability when the simulator behaves as Coron et al.’s and Chang et al.’s simulator of pf-MD construction.</p>

    <p class="text-gray-300">Distinguisher <span class="math">D</span> can access to oracles <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> where <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> is <span class="math">(H,E)</span> or <span class="math">(\\mathcal{F},S)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">D</span> selects a message <span class="math">M</span> such that <span class="math">g(M)=m</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, then he makes the query </span>M<span class="math"> to </span>\\mathcal{O}_{1}<span class="math"> and receives </span>h$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D</span> makes an inverse query <span class="math">(-,m,h\\oplus IV)</span> to <span class="math">\\mathcal{O}_{2}</span> and receives <span class="math">IV^{*}</span>.</li>

      <li>If <span class="math">IV=IV^{*}</span> output 1, otherwise output 0.</li>

    </ol>

    <p class="text-gray-300">If the <span class="math">D</span> outputs 1, then <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> is <span class="math">(H,E)</span>, otherwise <span class="math">(\\mathcal{F},S)</span>. Since receiving an inverse query by the first time and there does not exist <span class="math">IV\\xrightarrow{M^{\\prime}}h_{i-1}\\in\\mathcal{R}_{i-1}^{*}</span>, the simulator <span class="math">S^{-1}</span> can output the right <span class="math">IV</span> with a negligible probability <span class="math">2^{-n}</span>, such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Adv(D)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[D^{H,E}=1]-Pr[D^{\\mathcal{F},S}=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1-2^{-n}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The reason why this attack can be succeed is that Coron et al. didn’t consider the scenario when the distinguisher makes an inverse query to the simulator and the goal of the distinguisher is to receive a value he already knows. So the response of the simulator <span class="math">S</span> can’t be random for each inverse query. Chang et al. may observe Coron et al.’s flaw</p>

    <p class="text-gray-300">in pf-MD since their simulator is different from Coron et al.’s. Their correction has avoided attacks which involve queries which the length are at least two blocks . But they didn’t consider the scenario that an attack which applied in only one block length and the distinguisher’s goal is to receive the initial value <span class="math">IV</span>. We can see the distinguisher can distinguish <span class="math">(H,E)</span> from <span class="math">(\\mathcal{F},S)</span> with an overwhelming probability. The similar attack can be extended to Coron et al.’s simulator of NMAC.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Attack on Coron et al’s Simulation of NMAC.</h4>

    <p class="text-gray-300">The following distinguisher can distinguish <span class="math">(H,E)</span> and <span class="math">(\\mathcal{F},S)</span> with a non-negligible probability when the simulator behaves as Coron et al’s simulator of NMAC construction.</p>

    <p class="text-gray-300">Distinguisher <span class="math">D</span> can access to oracles <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> where <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> is <span class="math">(H,\\{E1,E2\\})</span> or <span class="math">(\\mathcal{F},\\{S1,S2\\})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">D</span> selects a message <span class="math">m</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, then he makes the query </span>m<span class="math"> to </span>\\mathcal{O}_{1}<span class="math"> and receives </span>h$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D</span> makes a forward query <span class="math">(1,+,m,IV_{1})</span> to <span class="math">\\mathcal{O}_{2}</span> and receives <span class="math">c_{1}</span>, then he gets <span class="math">h_{1}=IV_{1}\\oplus c_{1}</span>.</li>

      <li><span class="math">D</span> makes an inverse query <span class="math">(2,-,h_{1},h\\oplus IV_{2})</span> to <span class="math">\\mathcal{O}_{2}</span> and receives <span class="math">IV_{2}^{*}</span>.</li>

      <li>If <span class="math">IV_{2}=IV_{2}^{*}</span> output 1, otherwise output 0.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">D</span> outputs 1, then <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> is <span class="math">(H,\\{E1,E2\\})</span>, otherwise it is <span class="math">(\\mathcal{F},\\{S1,S2\\})</span>. Since the inverse is never queried before, the simulator <span class="math">S2</span> can output the right <span class="math">IV_{2}</span> with a negligible probability of <span class="math">2^{-n}</span>, whilst</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Adv(D)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[D^{H,E1,E2}=1]-Pr[D^{\\mathcal{F},S1,S2}=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1-2^{-n}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, the distinguisher <span class="math">D</span> can distinguish <span class="math">(H,\\{E1,E2\\})</span> from <span class="math">(\\mathcal{F},\\{S1,S2\\})</span> with an overwhelming probability.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3 Corrections</h3>

    <p class="text-gray-300">Though there are some flaws in simulators mentioned above, they can be corrected easily. In fact, all problems are from the inverse queries of the last block of a message. So the simulator’s response to an inverse query to the last block needs to be treated with caution. Now corrections for each of the simulators mentioned above are given in below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Corrections on Coron et al.’s and Chang et al.’s simulator of pf-MD.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(-,k_{i},c_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}=m_{i}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{j-1}\\xrightarrow{m_{i}}(h_{j-1}\\oplus c_{i})\\in\\mathcal{R}_{i-1}</span> for <span class="math">j&lt;i</span>, this is a repetition query, <span class="math">S</span> returns <span class="math">h_{j-1}</span>.</li>

      <li>Else <span class="math">S</span> runs <span class="math">\\mathcal{F}(m_{i})</span> and obtains the response <span class="math">h</span>. If <span class="math">h\\oplus c_{i}=IV</span>, then returns <span class="math">IV</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{IV\\xrightarrow{m_{i}}h\\}</span>.</li>

      <li>Else for each <span class="math">IV\\xrightarrow{M^{\\prime}}h_{i-1}\\in\\mathcal{R}_{i-1}^{*}</span> and <span class="math">g(M)=M^{\\prime}\\parallel m_{i}</span>, runs <span class="math">\\mathcal{F}(M)=h_{i}</span>. If <span class="math">h_{i}\\oplus h_{i-1}=c_{i}</span>, returns <span class="math">h_{i-1}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span></li>

      <li>Else <span class="math">S</span> randomly selects an intermediate value <span class="math">h_{i-1}^{\\prime}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}^{\\prime}\\xrightarrow{m_{i}}c_{i}\\oplus h_{i-1}^{\\prime}\\}</span>, then returns <span class="math">h_{i-1}^{\\prime}</span>.</li>

      <li>Corrections on Coron et al.’s simulator of NMAC.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">j</span>-th query <span class="math">(2,-,k_{j},c_{j})</span> on <span class="math">S2</span> where <span class="math">k_{j}=m_{j}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{k-1}\\overset{m_{j}}{\\longrightarrow}(h_{k-1}\\oplus c_{j})\\in\\mathcal{Q}_{j-1}</span> where <span class="math">k&lt;j</span>, this is a repetition query, <span class="math">S</span> returns <span class="math">h_{k-1}</span>.</li>

      <li>Else If <span class="math">\\exists IV_{1}\\overset{M}{\\longrightarrow}(k_{j})\\in\\mathcal{R}_{i}^{<em>}</span> where <span class="math">\\mathcal{R}_{i}^{</em>}</span> is the simulator’s view of the past queries on <span class="math">S1</span> and then <span class="math">S</span> runs <span class="math">\\mathcal{F}(M)</span> and gets <span class="math">h</span>. If <span class="math">IV_{2}\\oplus h=c_{j}</span>, <span class="math">S</span> updates <span class="math">\\mathcal{Q}_{j}=\\mathcal{Q}_{j-1}\\cup\\{IV_{2}\\overset{m_{j}}{\\longrightarrow}h\\}</span>, then returns <span class="math">IV_{2}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects an intermediate value <span class="math">h_{j-1}^{{}^{\\prime}}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{Q}_{j}=\\mathcal{Q}_{j-1}\\cup\\{h_{j-1}^{{}^{\\prime}}\\overset{m_{j}}{\\longrightarrow}c_{j}\\oplus h_{j-1}^{{}^{\\prime}}\\}</span>, then returns <span class="math">h_{j-1}^{{}^{\\prime}}</span>.</li>

    </ol>

    <p class="text-gray-300">When these simulators are corrected, then the advantage of any distinguisher can be calculated as in <em>[9]</em> or <em>[7]</em>. It is easy to see that the time complexity of the simulator and the advantage of any distinguishers are not affected. Thus one can easily obtain the following corollary.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">The Davis-Meyer scheme with pf-MD, chop-MD, NMAC and HMAC are <span class="math">(t_{D},t_{S},q,\\epsilon)</span>-indifferentiable from a random oracle in the ideal cipher model. For any <span class="math">t_{D}</span> ,with <span class="math">t_{S}=O(q^{2})</span>, with <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for pf-MD, <span class="math">\\epsilon=2^{-s}\\cdot l^{2}\\cdot O(q^{2})</span> for chop-MD, <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for NMAC and HMAC, where <span class="math">l</span> is the maximum length of a query made by the distinguisher <span class="math">D</span>.</p>

    <p class="text-gray-300">In <em>[15]</em>, Gong et al. also provided an indifferentiability analysis of 20 PGV schemes with pf-MD and claimed that all 20 schemes are indifferentiable from random oracles with prefix-free padding (the length padding is also implemented). There is an obvious error in their simulators that the simulators needed to record the distinguisher’s queries to the random oracle <span class="math">\\mathcal{F}</span>. In fact, the simulator can never have the record of the distinguisher’s queries, which can be derived from the definition of indifferentiability.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 Indifferentiability Analysis of PGV Hash Functions</h2>

    <p class="text-gray-300">Due to the new flaws disclosed in the our analysis, the indifferentiability of PGV schemes with pf-MD, NMAC/HMAC and chop-MD are reconsidered in this section. Based on our analysis of pf-MD, the necessary conditions for a PGV hash construction to be indifferentiable from a random oracle are analyzed. Filtered by those necessary conditions, there are only twelve schemes survived in 64 PGV schemes, which include eight of the Group-1 and four of the Group-2 schemes. <em>[5]</em>.</p>

    <p class="text-gray-300">At AsiaCrypt’06, Chang et al.<em>[7]</em> presented an indifferentiability security analysis of these schemes with pf-MD. They claimed that there are 4 schemes among 20 collision-resistant PGV schemes are differentiable from random oracle with pf-MD. And the remaining 16 schemes are indifferentiable from a random oracle with pf-MD. The four insecure schemes(in the sense of indifferentiability with pf-MD) are case 1, 2, 3 and 4 of the Group-1 schemes. Here we find that in the remaining 16 schemes, there are another four schemes are differentiable from random oracle with pf-MD. These four schemes are case 15, 17, 19 and 20 from the Group-2 schemes.</p>

    <p class="text-gray-300">When analyze these 20 collision resistant PGV hash function for NMAC/HMAC and chop-MD construction, we found all of them are indifferentiable from a random oracle in the ideal cipher model, and the chop-MD construction has the better indifferentiability security bound than NMAC/HMAC construction. This exploits that the four MD variants are not the same in the sense of indifferentiability. According to our synthetic analysis, we exploit the fact that in 20 PGV collision resistant constructions, there exist schemes that are differentiable from random oracle for the pf-MD construction, but are indifferentiable from random oracle for the NMAC/HMAC and chop-MD construction, while the chop-MD construction has the better indifferentiability security bound. This fact gives the evidence that the four popular MD variants, namely pf-MD, NMAC/HMAC, the chop construction, are not the same in the sense of indifferentiability.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.1 Indifferentiability of PGV Hash Functions with pf-MD</h3>

    <p class="text-gray-300">Here we use the indifferentiability methodology to revisit PGV schemes with the pf-MD construction. We analyze the properties of 64 PGV schemes and find the necessary conditions for a PGV schemes to be indifferentiable from a random oracle. The necessary conditions are described as follows. First we present the theorem with respect to the compression function which is not a collision resistant PGV scheme.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 4</h6>

    <p class="text-gray-300">A hash function <span class="math">H</span> built from any PGV scheme <span class="math">h_{i}=f(h_{i-1},m_{i})</span> with pf-MD is differentiable from a random oracle if <span class="math">H</span> is not collision resistant.</p>

    <p class="text-gray-300">The proof is given in Appendix B.1. Based on Theorem 4, it is easy to see that 44 out of the total 64 PGV schemes are not collision resistant, thus they are differentiable from random oracle with pf-MD.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 5</h6>

    <p class="text-gray-300">A hash function <span class="math">H</span> built from any PGV construction <span class="math">h_{i}=f(h_{i-1},m_{i})</span> with pf-MD is differentiable from a random oracle if <span class="math">(h_{i},m_{i})\\Rightarrow h_{i-1}</span>. That is to say, it is trival to deduce <span class="math">h_{i-1}</span> from <span class="math">(h_{i},m_{i})</span> with access to the block cipher. For example, <span class="math">h_{i}=E_{m_{i}}(h_{i-1})</span>, if we know the value of <span class="math">(h_{i},m_{i})</span>, then <span class="math">h_{i-1}=E_{m_{i}}^{-1}(h_{i})</span>.</p>

    <p class="text-gray-300">The proof is given in Appendix B.2. Based on Theorem 5, the 4 PGV schemes, which are case 15, 17, 19 and 20 of the Group-2 schemes, are differentiable from a random oracle.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 6</h6>

    <p class="text-gray-300">A hash function <span class="math">H</span> built from any PGV schemes <span class="math">h_{i}=f(h_{i-1},m_{i})</span> with pf-MD is differentiable from a random oracle if given <span class="math">(h_{i-1},k,c)</span> where <span class="math">k\\in\\{h_{i-1},v\\}</span> is the key to the block cipher <span class="math">E</span> and <span class="math">c</span> is a linear combination of <span class="math">\\{h_{i-1},m_{i},h_{i},v\\}</span> and the cipher text of the block cipher <span class="math">E</span>, it is infeasible to deduce <span class="math">m_{i}</span> without access to the block cipher. For example, if <span class="math">h_{i}=E_{h_{i-1}}(m_{i})\\oplus m_{i}</span>, then <span class="math">k=h_{i-1}</span> and <span class="math">c=h_{i}\\oplus m_{i}</span>, from the triple <span class="math">(h_{i-1},h_{i-1},h_{i}\\oplus m_{i})</span>, it is infeasible to deduce <span class="math">m_{i}</span> without access to <span class="math">E</span>.</p>

    <p class="text-gray-300">The proof is given in Appendix B.3. Based on theorem 6, the 4 PGV schemes, which are case 1, 2, 3, 4 of the group-1 schemes, are differentiable from a random oracle. From the the above analysis, one can easily get the following corollary.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Corollary 2</h6>

    <p class="text-gray-300">A hash function <span class="math">H</span> built from the PGV compression function <span class="math">h_{i}=f(h_{i-1},m_{i})</span> with pf-MD is differentiable from a random oracle if it satisfies one of the following conditions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The hash function <span class="math">H</span> is not collision resistant.</li>

      <li><span class="math">(h_{i},m_{i})\\Rightarrow h_{i-1}</span>. That is to say, it is trival to deduce <span class="math">h_{i-1}</span> from <span class="math">(h_{i},m_{i})</span> with access to the block cipher.</li>

      <li>Given <span class="math">(h_{i-1},k,c)</span> where <span class="math">k\\in\\{h_{i-1},v\\}</span> is the key to the block cipher <span class="math">E</span> and <span class="math">c</span> is a linear combination of <span class="math">\\{h_{i-1},m_{i},h_{i},v\\}</span> and the cipher text of the block cipher <span class="math">E</span>, it is infeasible to deduce <span class="math">m_{i}</span> without access to the block cipher.</li>

    </ul>

    <p class="text-gray-300">The case 15, 17, 19, 20 of the group-2 schemes(see table 1.2) satisfy the condition <span class="math">B</span>, and the case 1, 2, 3, 4 of the group-1 schemes(see table 1.1) satisfy the condition <span class="math">C</span>, so they are differentiable from a random oracle with pf-MD construction. Those 8 differentiable schemes are listed in Table C.1.</p>

    <p class="text-gray-300">Since the necessary conditions for the indifferentiability of a PGV structure with the pf-MD construction are given, it is easy to analyze a construction by checking if it satisfies any one of the conditions mentioned above. If anyone of these conditions holds, then the PGV scheme is differentiable from a random oracle with the pf-MD construction. After checking these conditions for every 64 PGV construction, there are only 12 PGV schemes are secure against differentiable attack with pf-MD construction, which are listed in table C.2. The following theorem is proven in Appendix B.4.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 7</h6>

    <p class="text-gray-300">The twelve PGV schemes, which are list in table C.2, are <span class="math">(t_{D},t_{S},q,\\epsilon)</span> indifferentiable from a random oracle in the ideal cipher model. For any <span class="math">t_{D}</span>, with <span class="math">t_{S}=l\\cdot O(q^{2})</span>, with <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for pf-MD, where <span class="math">l</span> is the maximum length of a query made by the distinguisher <span class="math">D</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.2 Indifferentiability of PGV Hash Functions with NMAC/HMAC</h3>

    <p class="text-gray-300">In the above analysis, there are only 12 of the 20 collision-resistant PGV schemes are indifferentiable from random oracle with pf-MD construction. In this part we will show it is not the same in the analysis of NMAC/HMAC construction. For brevity, we only analyze the NMAC construction. The results can be easily extended to the HMAC</p>

    <p class="text-gray-300">construction because HMAC is a special case of NMAC. In our analysis, all of 20 collision-resistant PGV constructions are indifferentiable from random oracle with NMAC/HMAC construction, which implies that the NMAC/HMAC construction is better than the pf-MD construction.</p>

    <p class="text-gray-300">Furthermore, we will show even if a collision resistant PGV construction satisfies condition B or C in corollary 2, it can be indifferentiable from random oracle with NMAC/HMAC construction. For simplicity, we only show the case 15 from group-2 schemes(table 2.2) satisfies condition B, but is indifferentiable from a random oracle for the NMAC construction. For other cases, one can make a similar analysis and the proof of the indifferentiability will be deduced similarly.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 1</h6>

    <p class="text-gray-300">The collision resistant PGV compression function <span class="math">h_{i}=E_{m_{i}}(h_{i-1})</span> which satisfies condition B in theorem 3 is <span class="math">(t_{D},t_{S},q,\\epsilon)</span> indifferentiable from a random oracle in the ideal cipher model. For any <span class="math">t_{D}</span>, with <span class="math">t_{S}=O(q^{2})</span>, with <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for NMAC, where <span class="math">l</span> is the maximum length of a query made by the distinguisher <span class="math">D</span>.</p>

    <p class="text-gray-300">Lemma 1 is proven in Appendix B.5. In fact, for any one of the 20 collision resistant PGV constructions, one can build the similar simulator with NMAC/HMAC construction such that any distinguisher fails. Since the proof of the indifferentiability for each PGV scheme is similar to the proof of Lemma 1, we have the following theorem.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 8</h6>

    <p class="text-gray-300">The 20 collision resistant PGV schemes are <span class="math">(t_{D},t_{S},q,\\epsilon)</span> indifferentiable from a random oracle in the ideal cipher model. For any <span class="math">t_{D}</span>, with <span class="math">t_{S}=O(q^{2})</span>, with <span class="math">\\epsilon=2^{-n}\\cdot l^{2}\\cdot O(q^{2})</span> for NMAC/HMAC, where <span class="math">l</span> is the maximum length of a query made by the distinguisher <span class="math">D</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 Indifferentiability of PGV Hash Functions with chop-MD</h3>

    <p class="text-gray-300">In this part the indifferentiability of chop-MD for the 20 collision resistant PGV schemes will be analyzed. We show that all the 20 collision resistant PGV schemes are indifferentiable from random oracle in the ideal cipher model for the chop-MD construction. In <em>[10]</em>, Coron et al. analyzed the indifferentiability of chop-MD based on the Davies-Meyer construction. They had the following lemma:</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 2</h6>

    <p class="text-gray-300">The Merkle-Damgård construction with truncated output chop-MD<span class="math">{}_{s}^{E}</span> based on the Davies-Meyer construction applied to an ideal cipher <span class="math">E:\\{0,1\\}^{n}\\times\\{0,1\\}^{n}\\rightarrow\\{0,1\\}^{n}</span> is <span class="math">(t_{D},t_{S},q,\\epsilon)</span> indifferentiable from a random oracle <span class="math">F:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{n-s}</span> in the ideal cipher model for <span class="math">E</span>, for any <span class="math">t_{D}</span> and <span class="math">t_{S}=l\\cdot O(q^{2})</span>, with <span class="math">\\epsilon=2^{-s}\\cdot l^{2}\\cdot O(q^{2})</span>.</p>

    <p class="text-gray-300">Coron et al.’s bound of chop-MD is not very tight. In <em>[20]</em>, Maurer and Tessaro firstly presented a prefix-free chop-MD construction which has indifferentiability security beyond the birthday barrier. Later, Chang and Nandi presented an improved indifferentiability security bound for chop-MD which stated in theorem 3. Though Chang and Nandi’s improved indifferentiability security bound is proved when looks the compression function as a random oracle, their proof of the security bound can be applied in the ideal cipher model when the compression function is based on Davies-Meyer structure. Some collision resistant PGV schemes satisfy condition B or C in theorem 2 can be indifferentiable from random oracle for chop-MD in the ideal cipher model. Take the PGV scheme <span class="math">h_{i}=E_{h_{i-1}}(m_{i})\\oplus m_{i}</span> as an example, if <span class="math">n=2s</span>, we can build the following distinguisher:</p>

    <p class="text-gray-300">Distinguisher <span class="math">D</span> can access to oracles <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> where <span class="math">(\\mathcal{O}_{1},\\mathcal{O}_{2})</span> is <span class="math">(\\text{chop-MD}_{s}^{E},E)</span> or <span class="math">(\\mathcal{F},S)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">D</span> selects a message <span class="math">M</span> such that <span class="math">g(M)=m</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, then makes the query </span>M<span class="math"> to </span>\\mathcal{O}_{1}<span class="math"> and receives </span>h$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">h^{\\prime}</span> from <span class="math">0</span> to <span class="math">2^{s}-1</span> , <span class="math">D</span> makes an inverse query <span class="math">(-,IV,m\\oplus(h\\parallel h^{\\prime}))</span> to <span class="math">\\mathcal{O}_{2}</span> and receives <span class="math">m^{\\prime}</span>.</li>

      <li>If there exist an <span class="math">m^{\\prime}</span> such that <span class="math">m^{\\prime}=m</span>, <span class="math">D</span> output 1, otherwise output 0.</li>

    </ol>

    <p class="text-gray-300">Since the simulator never knows the right message <span class="math">m</span>, it gives the right response only with probability <span class="math">2^{-s}</span> after <span class="math">q=2^{s}</span> queries. After queried <span class="math">q</span> times to <span class="math">\\mathcal{O}_{2}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$Adv(D)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[D^{H,E,E^{-1}}=1]-Pr[D^{\\mathcal{F},S,S^{-1}}=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{q}{2^{s}}-\\frac{q}{2^{2s}}\\approx\\frac{q}{2^{s}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It is obvious that the advantage of the distinguisher is less than the birthday bound, and this advantage is less than Chang and Nandi’s improved security bound and so that this type of differentiable attack fails. The result can be extended to other 19 collision resistant PGV schemes. For any one of 20 collision resistant PGV schemes, the following simulator can be built such that the advantage of any distinguisher is in Chang and Nandi’s improved bound.</p>

    <p class="text-gray-300">Simulator:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(+,k_{i},p_{i})</span> on <span class="math">S</span> where <span class="math">k_{i},p_{i}\\in\\{h_{i-1},m_{i},h_{i-1}\\oplus m_{i}\\}</span>, <span class="math">h_{i-1}</span> and <span class="math">m_{i}</span> can be deduced from <span class="math">(k_{i},p_{i})</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{i-1}\\xrightarrow{m_{i}}h_{i}\\in\\mathcal{R}_{i-1}</span>, then this is a repetition query, deduces <span class="math">c_{i}</span> from <span class="math">(h_{i-1},h_{i},m_{i})</span>, <span class="math">S</span> returns <span class="math">c_{i}</span>.</li>

      <li>Else if <span class="math">\\exists IV\\xrightarrow{M^{\\prime}}h_{i-1}\\in\\mathcal{R}_{i-1}^{*}</span> and <span class="math">g(M)=M^{\\prime}\\parallel m_{i}</span>, <span class="math">S</span> runs <span class="math">\\mathcal{F}(M)</span> and obtains the response <span class="math">h_{i}</span>, randomly choose a <span class="math">s</span>-bit string <span class="math">h^{\\prime}</span>, updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}(h_{i}\\parallel h^{\\prime})\\}</span>, then deduces <span class="math">c_{i}</span> from <span class="math">\\{h_{i-1},m_{i},(h_{i}\\parallel h^{\\prime}),v\\}</span> and returns <span class="math">c_{i}</span>;</li>

      <li>Else <span class="math">S</span> randomly selects a hash value <span class="math">h_{i}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span>, then deduces <span class="math">c_{i}</span> from <span class="math">\\{h_{i-1},m_{i},h_{i},v\\}</span> and returns <span class="math">c_{i}</span>.</li>

      <li>For the <span class="math">i</span>-th query <span class="math">(-,k_{i},c_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}\\in\\{h_{i-1},m_{i},h_{i-1}\\oplus m_{i}\\}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{i-1}\\xrightarrow{m_{i}}h_{i}\\in\\mathcal{R}_{i-1}</span> where <span class="math">k_{i},c_{i}</span> can be deduced from <span class="math">(h_{i-1},m_{i},h_{i})</span> , then this is a repetition query, <span class="math">S</span> deduces <span class="math">p_{i}</span> from <span class="math">(h_{i-1},m_{i},h_{i})</span>, then returns the <span class="math">p_{i}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects a message <span class="math">h_{i-1}\\in\\{0,1\\}^{n}</span>, deduces <span class="math">m_{i},h_{i}</span> from <span class="math">\\{h_{i-1},k_{i},c_{i}\\}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span>, then returns <span class="math">h_{i-1}</span>.</li>

    </ol>

    <p class="text-gray-300">For anyone of the 20 collision PGV schemes, we can calculate the advantage of any distinguisher using the method explained in <em>[8]</em>. So combined our analysis of PGV schemes and Chang and Nandi’s improved bound. We get the following theorem:</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 9</h6>

    <p class="text-gray-300">The chop-MD^{E} construction based on anyone of 20 collision resistant collision PGV schemes is <span class="math">(t_{D},t_{S},q,\\sigma,\\epsilon)</span> indifferentiable from a random oracle, in the ideal cipher model for any <span class="math">t_{D}</span>, with <span class="math">t_{S}=l\\cdot O(q^{2})</span> and <span class="math">\\epsilon=O(\\frac{nq}{2^{s}}+\\frac{q}{2^{n-s}}+\\frac{\\sigma^{2}}{2^{n}})</span>, where <span class="math">q</span> is the total number of queries and <span class="math">\\sigma</span> is the total number of message blocks queried.</p>

    <p class="text-gray-300">The above theorem shows that the distinguisher needs at least <span class="math">2^{s}/(3s+1)</span> query complexity to have an indifferentiability attack when <span class="math">n=2s</span>. In <em>[8]</em>, the result implies the chop-MD hash function is almost optimally secure with respect to second preimage and multicollision attack. Note that it doesn’t improve the security bound for resisting collisions to chop-MD, but does improve the bound for indifferentiability in the ideal cipher model.</p>

    <h2 id="sec-32" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">The indifferentiability of 20 collision resistant PGV hash functions for pf-MD, NMAC/HMAC and chop-MD construction are revisited. It is shown that the indifferentiability is really a method to verify the security of a construction. There are some schemes can be differentiable from random oracle with pf-MD, but are indifferentiable from random oracle with NMAC/HMAC and chop-MD construction. Our results exploit that the four Merkle-Damgård variants are not the same in the sense of the indifferentiability. And the later two constructions are better than pf-MD. Since the pf-MD construction has lower input domain and the chop-MD construction has lower output range, the NMAC/HMAC would be a better choice for practice use. We also suggest that one should take care of the proof of the indifferentiability of a construction, since some flaws have been found in previous works.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Andreeva, E., Neven, G., Preneel, B., Shrimpton, T.: Seven-property-preserving hashing: ROX. In: Kurosawa, K. (ed.) ASIACRYPT’2007. LNCS 4833, pp. 130-146. Springer, 2007.</li>

      <li>[2] Bellare, M., Ristenpart, T.: Multi-property-preserving hash domain extension: The EMD transform. In: Lai, X., Chen, K. (eds.) ASIACRYPT’2006. LNCS 4284, pp. 299-314. Springer, 2006.</li>

      <li>[3] M. Bellare and T. Ristenpart. Hash Functions in the Dedicated-key Setting: Design Choices and MPP Transforms. In: ICALP’07, LNCS 4596, pp. 339-410. Springer, 2007.</li>

      <li>[4] G. Bertoni, J. Daemen, M. Peeters, G. Van Assche: On the indifferentiability of the sponge construction. In: Smart, N. (ed.) EUROCRYPT’2008. LNCS 4965, pp. 181-197. 2008.</li>

      <li>[5] J. Black, P. Rogaway, and T. Shrimpton. Black-box analysis of the blockcipher- based hash function constructions from PGV. In Crypto2002, LNCS 2442, pp. 320-335. Springer, 2002.</li>

      <li>[6] B. O. Brachtl, D. Coppersmith, M.M. Hyden, S.M. Matyas, C.H. Meyer, J. Oseas, S. Pilpel and M. Schilling. Data Authentication Using Modification Detection Codes Based on a Public One Way Encryption Function. U.S. Patent Number 4,908,861, March 13, 1990.</li>

      <li>[7] D. H. Chang, S. J. Lee, M. Nandi and M. Yung. Indifferentiable Security Analysis of Popular Hash Functions with Prefix-Free Padding. In: X. Lai and K. Chen(eds): ASIACRYPT’2006, LNCS 4284, pp. 283-298. Springer, 2006.</li>

      <li>[8] D. H. Chang and M. Nandi. Improved Indifferentiability Security Analysis of chopMD Hash Function. In: K. Nyberg(ed.): FSE’2008, LNCS 5086, pp. 429-443, Springer, 2008.</li>

      <li>[9] J. S. Coron, Y. Dodis, C. Malinaud and P. Puniya. Merkle-Damgard Revisited: How to Construct a Hash Function. In: CRYPTO’05, LNCS 3621, pp. 21-39. 2005.</li>

      <li>[10] J. S. Coron, Y. Dodis, C. Malinaud and P. Puniya. Merkle-Damgard Revisited: How to Construct a Hash Function (Full Version). In http://people.csail.mit.edu/dodis/ps/merkle.ps. 2007. A preliminary version was accepted by Crypto’05, LNCS 3621, pp. 21-39. 2005.</li>

      <li>[11] J. S. Coron, J. Patarin, and Y. Seurin. The random oracle model and the ideal cipher model are equivalent. In D. Wagner(ed.), CRYPTO’2008, LNCS 5157, pp. 1-20. Springer, 2008.</li>

      <li>[12] I. Damgard. A Design Principle for Hash Functions, In:Cyrpto’89, LNCS 435, pp. 416-427. Springer, 1989.</li>

      <li>[13] Y. Dodis, L. Reyzin, R. L. Rivest and E. Shen. Indifferentiability of Permutation-Based Compression Functions and Tree-Based Modes of Operation, with Applications to MD6. FSE’09, Appear soon.</li>

      <li>[14] Y. Dodis, T. Ristenpart, and T. Shrimpton. Salvaging Merkle-Damgard for Practical Applications. In: EuroCrypt’09, LNCS 5479, pp. 371-388. Springer.</li>

      <li>[15] Z. Gong, X. Lai, and K. Chen. A Synthetic Indifferentiability Analysis of Some Block-Cipher-Based Hash Functions. Designs, Codes and Cryptography, Springer. 48(3), Sept 2008.</li>

      <li>[16] S. Hirose. Some Plausible Constructions of Double-Length Hash Functions. In: FSE’06, LNCS 4047, pp. 210-225. Springer, 2006.</li>

      <li>[17] S. Hirose, J. Park, and A. Yun. A Simple Variant of the Merkle-Damgard Scheme with a Permutation. In: ASIACRYPT’07, LNCS vol. 4833, pp. 113-129. Springer, 2007.</li>

      <li>[18] H. Kuwakado , M. Morii: Indifferentiability of single-block-length and rate-1 compression functions. IEICE Trans Fundamentals, vol.e90-A, pp. 2301-2308. 2007.</li>

    </ul>

    <p class="text-gray-300">[19] U. Maurer, R. Renner, and C. Holenstein. Indifferentiability, Impossibility Results on Reductions, and Applications to the Random Oracle Methodology. In: TCC’2004, LNCS 2951, pp. 21-39. Springer, 2004.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] U. Maurer and S. Tessaro. Domain Extension of Public Random Functions: Beyond the Birthday Barrier. In: Menezes, A. (ed.) CRYPTO’2007. LNCS 4622, pp. 187-204. Springer, 2007</li>

      <li>[21] R.C. Merkle. One way hash functions and DES, In: Crypto’89, LNCS 435, pp. 428-446. Springer, 1989.</li>

      <li>[22] B. Preneel, R. Govaerts and J. Vandewalle. Hash functions based on block ciphers: A synthetic approach. In: CRYPTO’93, LNCS 773, pp. 368-378. Springer, 1994.</li>

      <li>[23] X. Wang, Y. Yin and H. Yu. Finding Collision in the Full SHA-1. In: CRYPTO’05, LNCS 3621, pp. 17-36. Springer, 2005.</li>

      <li>[24] X. Wang and H. Yu. How to Break MD5 and Other Hash Functions. In: EUROCRYPT’05, LNCS 3494, pp. 19-35. Springer, 2005.</li>

    </ul>

    <h2 id="sec-34" class="text-2xl font-bold">Appendix A Previous Simulators of pf-MD and NMAC</h2>

    <p class="text-gray-300">Coron et al.’s and Chang et al.’s simulators of pf-MD and NMAC based on Davies-Meyer structure are described as follows:</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Coron et al.’s Simulation of pf-MD.</h4>

    <p class="text-gray-300">The simulator <span class="math">S</span> accepts either forward ideal cipher queries, <span class="math">(+,k_{i},p_{i})</span>, or inverse ideal cipher queries, <span class="math">(-,k_{i},c_{i})</span>, such that <span class="math">k_{i}\\in\\{0,1\\}^{n}</span> and <span class="math">p_{i},c_{i}\\in\\{0,1\\}^{n}</span>. In either case, the simulator <span class="math">S</span> responses with a <span class="math">n</span>-bit string that is interpreted as <span class="math">E_{k_{i}}(p_{i})</span> in the case of a forward query <span class="math">(+,k_{i},p_{i})</span> and as <span class="math">E_{k_{i}}^{-1}(c_{i})</span> in the case of an inverse query. The simulator keeps the relations <span class="math">(\\mathcal{R}_{1},\\ldots,\\mathcal{R}_{i-1})</span>. To answer the distinguisher <span class="math">D</span>’s forward and inverse queries, the simulator <span class="math">S</span> responses as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(+,k_{i},p_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}=m_{i}</span> and <span class="math">p_{i}=h_{i-1}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{i-1}\\xrightarrow{m_{i}}h_{i}\\in\\mathcal{R}_{i-1}</span>, then this is a repetition query which the response is already known. <span class="math">S</span> returns <span class="math">c_{i}=h_{i}\\oplus h_{i-1}</span>.</li>

      <li>Else if <span class="math">\\exists IV\\xrightarrow{M^{\\prime}}h_{i-1}\\in\\mathcal{R}_{i-1}^{*}</span> and <span class="math">g(M)=M^{\\prime}\\parallel m_{i}</span>, <span class="math">S</span> runs <span class="math">\\mathcal{F}(M)</span> and obtains the response <span class="math">h_{i}</span>, updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span>, then returns <span class="math">c_{i}=h_{i}\\oplus h_{i-1}</span>;</li>

      <li>Else <span class="math">S</span> randomly selects a hash value <span class="math">h_{i}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span>, then returns <span class="math">c_{i}=h_{i}\\oplus h_{i-1}</span>.</li>

      <li>For the <span class="math">i</span>-th query <span class="math">(-,k_{i},c_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}=m_{i}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{j-1}\\xrightarrow{m_{i}}(h_{j-1}\\oplus c_{i})\\in\\mathcal{R}_{i-1}</span> for <span class="math">j&lt;i</span>, then this is a repetition query. <span class="math">S</span> returns <span class="math">h_{j-1}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects a message <span class="math">h_{i-1}^{\\prime}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}^{\\prime}\\xrightarrow{m_{i}}c_{i}\\oplus h_{i-1}^{\\prime}\\}</span>, then returns <span class="math">h_{i-1}^{\\prime}</span>.</li>

    </ol>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Chang et al.’s Simulation of pf-MD</h4>

    <p class="text-gray-300">Generally speaking, Chang et al.’s simulator is the same as Coron et al.’s except for the inverse query. To answer the distinguisher <span class="math">D</span>’s forward and inverse queries, the simulator <span class="math">S</span> responses as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(+,k_{i},p_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}=m_{i}</span> and <span class="math">p_{i}=h_{i-1}</span>: <span class="math">S</span> behaves the same as Coron et al.’s simulator.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(-,k_{i},c_{i})</span> on <span class="math">S</span> where <span class="math">k_{i}=m_{i}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{j-1}\\xrightarrow{m_{i}}(h_{j-1}\\oplus c_{i})\\in\\mathcal{R}_{i-1}</span> for <span class="math">j&lt;i</span>, this is a repetition query. <span class="math">S</span> returns <span class="math">h_{j-1}</span>.</li>

      <li>Else for each <span class="math">IV\\xrightarrow{M^{\\prime}}h_{i-1}\\in\\mathcal{R}_{i-1}</span> and <span class="math">g(M)=M^{\\prime}\\parallel m_{i}</span>, run <span class="math">\\mathcal{F}(M)=h_{i}</span>. If <span class="math">h_{i}\\oplus h_{i-1}=c_{i}</span>, return <span class="math">h_{i-1}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span></li>

      <li>Else <span class="math">S</span> randomly selects a message <span class="math">h_{i-1}^{\\prime}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}^{\\prime}\\xrightarrow{m_{i}}c_{i}\\oplus h_{i-1}^{\\prime}\\}</span>, then returns <span class="math">h_{i-1}^{\\prime}</span>.</li>

    </ol>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Coron et al.’s Simulation of NMAC.</h4>

    <p class="text-gray-300">The NMAC construction NMAC^{E1,E2} essentially applies the Davies-Meyer construction using the block cipher <span class="math">E1</span> to the input <span class="math">m_{1}\\parallel\\ldots\\parallel m_{l}</span> to get the final output <span class="math">h_{l}</span>. It then applies another independent the Davies-Meyer construction using <span class="math">E2</span> to this output <span class="math">h_{l}</span>. For simplicity the output length <span class="math">n</span> of <span class="math">E1</span> is the same as the key length of <span class="math">E2</span>. And one use <span class="math">IV_{1}</span> for the Davies-Meyer construction applied to <span class="math">E1</span>, and use <span class="math">IV_{2}</span> for the Davies-Meyer construction with <span class="math">E2</span>.</p>

    <p class="text-gray-300">The simulator gets forward/inverse queries for either of the block ciphers <span class="math">E1</span> and <span class="math">E2</span>. Thus the queries that simulator <span class="math">S</span> responds to are as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(1,+,k_{i},p_{i})</span>: A forwards <span class="math">E1</span> query ,where <span class="math">(k_{i},p_{i})\\in\\{0,1\\}^{n}\\times\\{0,1\\}^{n}</span>. The expected response is <span class="math">E1_{k_{i}}(p_{i})</span>.</li>

      <li><span class="math">(1,-,k_{i},c_{i})</span>: A inverses <span class="math">E1</span> query ,where <span class="math">(k_{i},c_{i})\\in\\{0,1\\}^{n}\\times\\{0,1\\}^{n}</span>. The expected response is <span class="math">E1_{k_{i}}^{-1}(c_{i})</span>.</li>

      <li><span class="math">(2,+,k_{i},p_{i})</span>: A forwards <span class="math">E2</span> query ,where <span class="math">(k_{i},p_{i})\\in\\{0,1\\}^{n}\\times\\{0,1\\}^{n}</span>. The expected response is <span class="math">E2_{k_{i}}(p_{i})</span>.</li>

      <li><span class="math">(2,-,k_{i},c_{i})</span>: A inverses <span class="math">E2</span> query ,where <span class="math">(k_{i},c_{i})\\in\\{0,1\\}^{n}\\times\\{0,1\\}^{n}</span>. The expected response is <span class="math">E2_{k_{i}}^{-1}(c_{i})</span>.</li>

    </ol>

    <p class="text-gray-300">The simulator <span class="math">S</span> also maintains the relations <span class="math">(\\mathcal{R}_{1},\\ldots,\\mathcal{R}_{i-1})</span> and <span class="math">(\\mathcal{Q}_{1},\\ldots,\\mathcal{Q}_{j-1})</span> where <span class="math">(\\mathcal{R}_{1},\\ldots,\\mathcal{R}_{i-1})</span> records the triples that obtained from queries on <span class="math">E1</span> and <span class="math">(\\mathcal{Q}_{1},\\ldots,\\mathcal{Q}_{j-1})</span> records the triples that obtained from queries on <span class="math">E2</span>. To answer the distinguisher <span class="math">D</span>’s forward and inverse queries on <span class="math">E1</span> or <span class="math">E2</span>, the simulator <span class="math">S</span> should simulate <span class="math">E1,E2</span> as <span class="math">S1,S2</span> and responses as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query on <span class="math">S1</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">i</span>-th query <span class="math">(1,+,k_{i},p_{i})</span> on <span class="math">S1</span> where <span class="math">k_{i}=m_{i}</span> and <span class="math">p_{i}=h_{i-1}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{i-1}\\xrightarrow{m_{i}}h_{i}\\in\\mathcal{R}_{i-1}</span>, then this is a repetition query. <span class="math">S</span> returns <span class="math">c_{i}=h_{i}\\oplus h_{i-1}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects a hash value <span class="math">h_{i}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}\\xrightarrow{m_{i}}h_{i}\\}</span>, then returns <span class="math">c_{i}=h_{i}\\oplus h_{i-1}</span>.</li>

      <li>For the <span class="math">i</span>-th query <span class="math">(1,-,k_{i},c_{i})</span> on <span class="math">S1</span> where <span class="math">k_{i}=m_{i}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{j-1}\\xrightarrow{m_{i}}(h_{j-1}\\oplus c_{i})\\in\\mathcal{R}_{i-1}</span> where <span class="math">j&lt;i</span>, <span class="math">S</span> returns <span class="math">h_{j-1}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects a message <span class="math">h_{i-1}^{\\prime}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{R}_{i}=\\mathcal{R}_{i-1}\\cup\\{h_{i-1}^{\\prime}\\xrightarrow{m_{i}}c_{i}\\oplus h_{i-1}^{\\prime}\\}</span>, then returns <span class="math">h_{i-1}^{\\prime}</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query on <span class="math">S2</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">j</span>-th query <span class="math">(2,+,k_{j},p_{j})</span> on <span class="math">S2</span> where <span class="math">k_{j}=m_{j}</span> and <span class="math">p_{j}=h_{j-1}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\exists h_{j-1}\\xrightarrow{m_{j}}h_{j}\\in\\mathcal{Q}_{j-1}</span>, then this is a repetition query. <span class="math">S2</span> returns <span class="math">c_{j}=h_{j}\\oplus h_{j-1}</span>.</li>

      <li>Else if <span class="math">\\exists IV_{1}\\xrightarrow{M^{\\prime}}m_{j}\\in\\mathcal{R}_{i}^{*}</span> and <span class="math">p_{j}=IV_{2}</span>, <span class="math">S</span> runs <span class="math">\\mathcal{F}(M^{\\prime}\\parallel m_{j})</span> and obtains the response <span class="math">h_{j}</span>, updates <span class="math">\\mathcal{Q}_{j}=\\mathcal{Q}_{j-1}\\cup\\{IV_{2}\\xrightarrow{m_{j}}h_{j}\\}</span>, then returns <span class="math">c_{j}=IV_{2}\\oplus h_{j}</span>.</li>

      <li>Else <span class="math">S</span> randomly selects a hash value <span class="math">h_{j}\\in\\{0,1\\}^{n}</span> and updates <span class="math">\\mathcal{Q}_{j}=\\mathcal{Q}_{i-1}\\cup\\{h_{j-1}\\xrightarrow{m_{j}}h_{j}\\}</span>, then returns <span class="math">c_{j}=h_{j}\\oplus h_{j-1}</span>.</li>

    </ol>

    <p class="text-gray-300">2</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the <span class="math">j</span>-th query <span class="math">(2, -, k_j, c_j)</span> on <span class="math">S2</span> where <span class="math">k_j = m_j</span>:</li>

    </ol>

    <p class="text-gray-300">(a) If <span class="math">\\exists h_{k-1} \\xrightarrow{m_j} (h_{k-1} \\oplus c_j) \\in \\mathcal{Q}_{j-1}</span> where <span class="math">k &amp;lt; j</span>, <span class="math">S</span> returns <span class="math">h_{k-1}</span>.</p>

    <p class="text-gray-300">(b) Else <span class="math">S</span> randomly selects a message <span class="math">h_{j-1}&#x27; \\in \\{0,1\\}^n</span> and updates <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{h_{j-1}&#x27; \\xrightarrow{m_j} c_j \\oplus h_{j-1}&#x27;\\}</span>, then returns <span class="math">h_{j-1}&#x27;</span>.</p>

    <h2 id="sec-38" class="text-2xl font-bold">B Proofs</h2>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">B.1 Proof of Theorem 4</h3>

    <p class="text-gray-300">The distinguisher <span class="math">D</span> accesses to oracles <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> where <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> is <span class="math">(H, E)</span> or <span class="math">(\\mathcal{F}, S)</span>. If it is easy to find a collision <span class="math">(M, M&#x27;)</span> such that <span class="math">H(M) = H(M&#x27;)</span> when makes queries to <span class="math">E</span>, <span class="math">D</span> can query <span class="math">M</span> and <span class="math">M&#x27;</span> to <span class="math">\\mathcal{O}_1</span> and receive the responses. If the responses are different, then <span class="math">D</span> is interacting with <span class="math">(\\mathcal{F}, S)</span>, otherwise it is interacting with <span class="math">(H, E)</span>. Then we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adv(D) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[D^{H,E} = 1] - Pr[D^{\\mathcal{F},S} = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - 2^{-n}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since the advantage is non-negligible, so the construction is differentiable from a random oracle.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">B.2 Proof of Theorem 5</h3>

    <p class="text-gray-300">If a PGV scheme satisfies <span class="math">(h_i, m_i) \\Rightarrow h_{i-1}</span>, then we know the key <span class="math">k_i</span> to the block cipher <span class="math">E</span> must be a linear combination of <span class="math">\\{m_i, v\\}</span> and <span class="math">c_i</span> is a linear combination of <span class="math">\\{h_i, m_i, v\\}</span>, here <span class="math">v</span> is a constant, then we can build the following distinguisher <span class="math">D</span> such that any simulator fails.</p>

    <p class="text-gray-300">Distinguisher <span class="math">D</span> can access to oracles <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> where <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> is <span class="math">(H, E)</span> or <span class="math">(\\mathcal{F}, S)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">D</span> selects a message <span class="math">M, M&#x27;</span> such that <span class="math">g(M) = (m_1 \\parallel m_2)</span> and <span class="math">g(M&#x27;) = (m_1 \\parallel m_2&#x27;)</span> where <span class="math">m_2 \\neq m_2&#x27;</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m_2'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math">, then makes the query </span>M<span class="math"> to </span>\\mathcal{O}_1<span class="math"> and receives </span>h_2<span class="math"> and the query </span>M'<span class="math"> to </span>\\mathcal{O}_1<span class="math"> and receives </span>h_2'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D</span> computes <span class="math">(k_2, c_2)</span> from <span class="math">(m_2, h_2)</span> and <span class="math">(k_2&#x27;, c_2&#x27;)</span> from <span class="math">(m_2&#x27;, h_2&#x27;)</span>, then makes an inverse query <span class="math">(-, k_2, c_2)</span> to <span class="math">\\mathcal{O}_2</span> and receives <span class="math">p_2</span> and computes <span class="math">h_1</span> from <span class="math">(m_2, k_2, h_2, p_2)</span>, then makes an inverse query <span class="math">(-, k_2&#x27;, c_2&#x27;)</span> to <span class="math">\\mathcal{O}_2</span> and receives <span class="math">p_2&#x27;</span> and computes <span class="math">h_1&#x27;</span> from <span class="math">(m_2&#x27;, k_2&#x27;, h_2&#x27;, p_2&#x27;)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">h_1 = h_1&#x27;</span> output 1, otherwise output 0.</li>

    </ol>

    <p class="text-gray-300">Since the simulator doesn't know whether the two inverse queries lead to a same internal value, the simulator <span class="math">S</span> can output the right response only with probability <span class="math">2^{-n}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Adv(D) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[D^{H,E,E^{-1}} = 1] - Pr[D^{\\mathcal{F},S,S^{-1}} = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - 2^{-n}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This is not negligible. So the construction is differentiable from a random oracle.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">B.3 Proof of Theorem 6</h3>

    <p class="text-gray-300">In this case, the following distinguisher is built.</p>

    <p class="text-gray-300">Distinguisher  <span class="math">D</span>  can access to oracles  <span class="math">(\\mathcal{O}_1,\\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1,\\mathcal{O}_2)</span>  is  <span class="math">(H,E)</span>  or  <span class="math">(\\mathcal{F},S)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1.  <span class="math">D</span>  selects a message  <span class="math">M</span>  such that  <span class="math">g(M) = m</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n<span class="math"> , then makes the query  </span>M<span class="math">  to  </span>\\mathcal{O}_1<span class="math">  and receives  </span>h$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">D</span>  computes  <span class="math">(k, c)</span>  from  <span class="math">(h, m, IV, v)</span> , then makes an inverse query  <span class="math">(-, k, c)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">p</span> , then computes  <span class="math">m&#x27;</span>  from  <span class="math">(IV, k, c, p)</span> .</li>

      <li>If  <span class="math">m = m&#x27;</span>  output 1, otherwise output 0.</li>

    </ol>

    <p class="text-gray-300">Since the simulator never knows the right message  <span class="math">m</span> , it gives the right response only with probability  <span class="math">2^{-n}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A d v (D) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P r \\left[ D ^ {H, E, E ^ {- 1}} = 1 \\right] - P r \\left[ D ^ {\\mathcal {F}, S, S ^ {- 1}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - 2 ^ {- n}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">So the construction is differentiable from a random oracle.</p>

    <p class="text-gray-300">The Davies-Meyer construction(case 5) has been shown to be indifferentiable from random oracle with pf-MD. For the other 11 cases, we can make similar analysis. Thus, we can define a general simulator for these 12 PGV functions. The simulator is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">i</span> -th query  <span class="math">(+,k_i,p_i)</span>  on  <span class="math">S</span>  where  <span class="math">k_{i},p_{i}\\in \\{h_{i - 1},m_{i},h_{i - 1}\\oplus m_{i}\\}</span> , we can deduce  <span class="math">h_{i - 1}</span>  and  <span class="math">m_{i}</span>  from  <span class="math">(k_{i},p_{i})</span> :</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">\\exists h_{i - 1}\\xrightarrow{m_i}h_i\\in \\mathcal{R}_{i - 1}</span> , then this is a repetition query.  <span class="math">S</span>  deduces  <span class="math">c_{i}</span>  from  <span class="math">\\{h_{i - 1},m_i,h_i\\}</span>  and returns  <span class="math">c_{i}</span> . (b) Else if  <span class="math">\\exists IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> ,  <span class="math">S</span>  runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_i</span> , updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then deduces  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and returns  <span class="math">c_i</span> ; (c) Else  <span class="math">S</span>  randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then deduce  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and returns  <span class="math">c_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">i</span> -th query  <span class="math">(-,k_i,c_i)</span>  on  <span class="math">S</span>  where  <span class="math">k_{i}\\in \\{h_{i - 1},m_{i},h_{i - 1}\\oplus m_{i}\\}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) For each  <span class="math">M&#x27;</span>  such that  <span class="math">IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*(M&#x27;</span>  can be the empty string, in that case,  <span class="math">h_{i-1} = IV</span> ), deduce  <span class="math">m_i</span>  from  <span class="math">\\{h_{i-1}, k_i\\}</span> . If  <span class="math">\\exists M</span>  such that  <span class="math">g(M) = M&#x27; \\parallel m_i</span> , runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_i&#x27;</span> . At the same time, we can deduce  <span class="math">h_i</span>  from  <span class="math">\\{h_{i-1}, m_i, c_i\\}</span>  for each PGV scheme. (b) If  <span class="math">h_i = h_i&#x27;</span> ,  <span class="math">S</span>  returns the corresponding plaintext which belongs to  <span class="math">\\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> . (c) Else  <span class="math">S</span>  randomly selects a message  <span class="math">h_{i-1} \\in \\{0,1\\}^n</span> , deduce  <span class="math">m_i, h_i</span>  from  <span class="math">\\{h_{i-1}, k_i, c_i\\}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">h_{i-1}</span> .</p>

    <p class="text-gray-300">By using Theorem 4 and Theorem 5 in [7], or Theorem 4.1 in [10], we can compute  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span> , where  <span class="math">l</span>  is the maximum length of a query made by the distinguisher  <span class="math">D</span> .</p>

    <p class="text-gray-300">The  <span class="math">\\mathrm{NMAC}^{E_1,E_2}</span>  applies this compression function using the block cipher  <span class="math">E1</span>  to the input  <span class="math">m_{1}\\parallel \\ldots \\parallel m_{l}</span>  to get the final output  <span class="math">h_l</span> , then applies another independent compression function using  <span class="math">E2</span>  to this output  <span class="math">h_l</span> . We can build the following simulator:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">i</span> -th query  <span class="math">(1, +, k_i, p_i)</span>  on  <span class="math">S1</span>  where  <span class="math">k_i = m_i</span>  and  <span class="math">p_i = h_{i-1}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">\\exists h_{i - 1}\\xrightarrow{m_i}h_i\\in \\mathcal{R}_{i - 1}</span> , then this is a repetition query.  <span class="math">S</span>  returns  <span class="math">h_i</span> . (b) Else  <span class="math">S</span>  randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">h_i</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">i</span> -th query  <span class="math">(1, -, k_i, c_i)</span>  on  <span class="math">S1</span>  where  <span class="math">k_i = m_i</span> :</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_i} (c_i) \\in \\mathcal{R}_{i-1}</span>  where  <span class="math">j &amp;lt; i</span> ,  <span class="math">S</span>  returns  <span class="math">h_{j-1}</span> . (b) Else  <span class="math">S</span>  randomly selects a message  <span class="math">h_{i-1}&#x27; \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1}&#x27; \\xrightarrow{m_i} c_i\\}</span> , then returns  <span class="math">h_{i-1}&#x27;</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">j</span> -th query  <span class="math">(2, +, k_j, p_j)</span>  on  <span class="math">S2</span>  where  <span class="math">k_j = m_j</span>  and  <span class="math">p_j = h_{j-1}</span> :</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_j} h_j \\in \\mathcal{Q}_{j-1}</span> , then this is a repetition query.  <span class="math">S2</span>  returns  <span class="math">c_j = h_j</span> . (b) Else if  <span class="math">\\exists IV_1 \\xrightarrow{M} m_j \\in \\mathcal{R}_i^*</span>  and  <span class="math">p_j = IV_2</span> ,  <span class="math">S</span>  runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_j</span> , updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = h_j</span> . (c) Else  <span class="math">S</span>  randomly selects a hash value  <span class="math">h_j \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{i-1} \\cup \\{h_{j-1} \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = h_j</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For the  <span class="math">j</span> -th query  <span class="math">(2, -, k_j, c_j)</span>  on  <span class="math">S2</span>  where  <span class="math">k_j = m_j</span> :</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">\\exists h_{k - 1}\\xrightarrow{m_j}(c_j)\\in \\mathcal{Q}_{j - 1}</span>  where  <span class="math">k &amp;lt;   j</span>  , this is a repetition query,  <span class="math">S</span>  returns  <span class="math">h_{k - 1}</span> (b) Else If  <span class="math">\\exists IV_1 \\xrightarrow{M} (k_j) \\in \\mathcal{R}_i^*</span>  then  <span class="math">S</span>  runs  <span class="math">\\mathcal{F}(M)</span>  and gets  <span class="math">h</span> . If  <span class="math">h = c_j</span> ,  <span class="math">S</span>  updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h\\}</span> , then returns  <span class="math">IV_2</span> . (c) Else  <span class="math">S</span>  randomly selects a message  <span class="math">h_{j-1}&#x27; \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{h_{j-1}&#x27; \\xrightarrow{m_j} c_j\\}</span> , then returns  <span class="math">h_{j-1}&#x27;</span> .</p>

    <p class="text-gray-300">It is easy to show the distinguisher which was succeeding in the pf-MD will fail in the NMAC construction.  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  are calculated according the proof of Lemma A.8 in [10], where  <span class="math">l</span>  is the maximum length of a query made by the distinguisher  <span class="math">D</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh i-1(mi) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh i-1(wi) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ v</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh i-1(wi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(hi-1) ⊕ v</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(wi) ⊕ mi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Eh i-1(mi) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">Emi(hi-1) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table C.1 Eight differentiable PGV schemes with pf-MD.  <span class="math">w_{i} = h_{i - 1}\\oplus m_{i}</span> <span class="math">v</span>  is a constant.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PGV</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Em_i(h_i-1) ⊕ hi</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(mi) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(mi) ⊕ v</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Em_i(w_i) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(h_i-1) ⊕ hi-1</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(mi) ⊕ wi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Em_i(h_i-1) ⊕ wi</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(mi) ⊕ hi-1</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(h_i-1) ⊕ v</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Em_i(w_i) ⊕ hi-1</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(h_i-1) ⊕ mi</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">Ew_i(h_i-1) ⊕ wi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table C.2 Twelve Indifferentiable PGV schemes with pf-MD.  <span class="math">w_{i} = h_{i - 1}\\oplus m_{i}</span> <span class="math">v</span>  is a constant.</p>`;
---

<BaseLayout title="Revisiting the Indifferentiability of PGV Hash Functions (2009/265)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/265
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
