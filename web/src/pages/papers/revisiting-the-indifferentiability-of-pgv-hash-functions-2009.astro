---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/265';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Revisiting the Indifferentiability of PGV Hash Functions';
const AUTHORS_HTML = 'Yiyuan Luo, Zheng Gong, Ming Duan, Bo Zhu, Xuejia Lai';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In this paper, first we point out some flaws in the existing indifferentiability simulations of the pf-MD and the NMAC constructions, and provide new differentiable attacks on the hash functions based these schemes. Afterthat, the indifferentiability of
the 20 collision resistant PGV hash functions, which are padded
under the pf-MD, the NMAC/HMAC and the chop-MD constructions, are
reconsidered. Moreover, we disclose that there exist 4 PGV schemes
can be differentiable from a random oracle with the pf-MD among 16
indifferentiable PGV schemes proven by Chang et al. Finally, new indifferentiability simulations are provided for 20 collision-resistant PGV schemes. The simulations exploit that 20 collision-resistant PGV hash functions, which implemented with the NMAC/HMAC and the chop-MD, are indifferentiable from a random oracle. Our result implies that same compression functions under MD variants might have the same security bound with respect to the collision resistance, but quite different in the view of indifferentiability.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Indifferentiability &middot; PGV &middot; hash functions</p>
    </section>

    <p class="text-gray-300">Cryptographic Hash Functions. Cryptographic hash function, which is defined as an admissible algorithm that uniformly maps arbitrary length inputs to fixed length outputs, is widely used as a pivotal primitive for ensuring the integrity of information. In nowadays, the popular design of cryptographic hash functions still follows the well-known Merkle-Damgard (MD) construction <a href="#page-12-0">[12,</a> <a href="#page-13-0">21]</a>, by iterating a compression function on an input message to realize a &#730; domain extension transform and yields a collision resistant hash function if the underlying compression function is. The primary security goal for cryptographic hash functions has historically been collision resistance. Unfortunately, hash functions have been used for all kinds of applications which the security requirements are not only satisfied by collision resistance, but also pseudo-randomness, and even to be a random oracle <a href="#page-12-1">[2]</a>.</p>

    <p class="text-gray-300">In recent years, the hash community starts to argue that the traditional Merkle-Damgard (MD) construction is &#730; not a good design in the security view as a random oracle <a href="#page-12-2">[9]</a>. Since the well-known extension attack allows one to take a value H(x) for x, and then computes the value H(x, |x|, y), where |x| is the length of x and y is an arbitrary suffix. But this extension property is not allowed for any truly random oracle. For instance, even if the underlying compression function f is assumed to be a fixed-length random oracle, any hash function H<sup>f</sup> under MD construction will unlikely to be indifferentiable with a random oracle. From those counter-examples, people realize that collision resistance alone is insufficient for the security of so many different applications of hash functions. For this reason, a rich literature analyzed the security of hash functions obtaining variable-input-length (VIL) from an ideal fixed-inputlength (FIL) compression function, such as <a href="#page-12-3">[1,</a> <a href="#page-12-1">2,</a> <a href="#page-12-4">3,</a> <a href="#page-12-2">9,</a> <a href="#page-12-5">17]</a>.</p>

    <p class="text-gray-300">In practice, there exist two main approaches to design a compression function for an iterated hash function. One is to implicitly design a compression function by implicitly using the idea of block ciphers, which is called <em>dedicated</em> hash function. The other is to explicitly compose a compression function from block ciphers, which is called <em>blockcipher-based</em> hash function. By now, it seems still hard to design a dedicated compression function by witnessing the recent collision attacks on serval popular hash functions <a href="#page-13-1">[23,</a> <a href="#page-13-2">24]</a>. The advantage of block-cipher-based hash functions is that one can conveniently choose an extensively studied block cipher (e.g., DES, IDEA, AES, etc) to construct a compression function, so that the design and implementation efforts could be minimized. Also the latest cryptanalysis on such a block cipher can be used to avoid the potential weakness in the compression function. Discussions of hash functions constructed from n-bit block ciphers are mainly divided into <em>single block length</em> (SBL) such as 64 PGV schemes <a href="#page-13-3">[22]</a>, and <em>double block length</em> (DBL) such as MDC2 <a href="#page-12-6">[6]</a>, where single and double are related to the output range of the underlying block cipher.</p>

    <p class="text-gray-300">The original proposals of block-cipher-based hash functions usually focus on attacks, not formal proofs. As the development of provable security, some works have focused on the provable security of hash function based on block ciphers by modeling the underlying block cipher as a black box <a href="#page-12-7">[5,</a> <a href="#page-12-8">16]</a>. In <a href="#page-12-7">[5]</a>, Black <em>et al.</em> described a black-box analysis of all 64 PGV hash functions and proved that in the black box model, there exist 20 out of 64 PGV hash functions are collision resistant.</p>

    <p class="text-gray-300">Indifferentiability Methodology. In TCC'04, Maurer <em>et al.</em> introduced a strong security notion called as indifferentiability <a href="#page-13-4">[19]</a> for a hash function based on a compression function which is an extension of the classical indistinguishability security notion. The advantage of the indifferentiability is that one can built a secure VIL-RO from smaller (FIL) idealized components(such as an ideal compression function or ideal cipher). In Crypto'05, Coron <em>et al.</em> first implemented the indifferentiability in analysis of hash functions and suggested four secure constructions <a href="#page-12-2">[9]</a>, which were the prefix-free padding(pf-MD), the NMAC/HMAC and the chop construction(chop-MD). The compression function is viewed as a fixed-length random oracle or built from an ideal block cipher with Davies-Meyer structure. After that, several works followed to investigate the indifferentiability of a hash construction, such as <a href="#page-12-1">[2,</a> <a href="#page-12-4">3,</a> <a href="#page-12-9">4,</a> <a href="#page-12-10">7,</a> <a href="#page-12-11">13,</a> <a href="#page-12-12">14]</a>.</p>

    <p class="text-gray-300">At Asiacrypt'06, Chang <em>et al</em>. presented a unified way to prove the indifferentiability for block-cipher-based hash functions <a href="#page-12-10">[7]</a>. They analyzed 20 collision resistant PGV hash functions with pf-MD and found there are sixteen schemes are indifferentiable from random oracle and other four schemes are differentiable in the ideal cipher model. In <a href="#page-12-13">[15]</a>, Gong <em>et al</em>. provided a synthetic indifferentiability analysis of some block-cipher-based hash functions and claimed that all 20 collision resistant PGV schemes are indifferentiable from random oracle with the pf-MD, the NMAC/HMAC and the chop-MD constructions, where the length padding should be used in the constructions.</p>

    <p class="text-gray-300">Our Contributions. In this paper, by using the indifferentiability methodology, we revisit the indifferentiability of hash functions with pf-MD, NMAC/HMAC and chop-MD construction when the compression function is based on collision resistant PGV structures. We find that there exist 8 PGV schemes are differentiable from random oracle with pf-MD, but indifferentiable from random oracle with NMAC/HMAC and chop-MD. And this give evidence that the four constructions are not the same in the view of the indifferentiability. In the analysis, we revise the flaws in Coron et al.<a href="#page-12-2">[9]</a> and Chang <em>et al</em>.<a href="#page-12-10">[7]</a>'s proofs of Davies-Meyer compression function with pf-MD and NMAC, which allow an adversary can implement differentiable attacks on them. Furthermore, we find that in the 16 collision resistant PGV hash functions which are proved indifferentiable from a random oracle in the ideal cipher model with pf-MD in Chang <em>et al</em>.'s analysis, there are still 4 are really differentiable. According to our analysis, although all of the 20 collision resistant PGV hash function with NMAC/HMAC and chop-MD are indifferentiable from a random oracle in the ideal cipher model, the chop-MD construction has a better indifferentiability bound in advance.</p>

    <p class="text-gray-300">Organization. The organization of this paper is as follows. In Section 2, the notation of indifferentiability and some previous works are reviewed. In Section 3, formal methods of the indifferentiability of a hash function in the ideal cipher model are described. In Section 4, Coron <em>et al.</em>'s and Chang <em>et al</em>.'s proofs of indifferentiability of hash functions based on the Davies-Meyer structure with pf-MD and NMAC construction are described and flaws in their works are pointed out, and the right proofs for pf-MD and NMAC construction are given. In Section 5, the indifferentiability of 20 collision resistant PGV hash functions with pf-MD, NMAC/HMAC, chop-MD construction are revisited. Finally we draw a conclusion in Section 6.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Group-1 schemes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ehi&minus;1<br>(mi)<br>mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Emi<br>(hi&minus;1)<br>hi&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(mi)<br>mi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ehi&minus;1<br>(wi)<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Emi<br>(wi)<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(hi&minus;1)<br>hi&minus;1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ehi&minus;1<br>(mi)<br>&oplus;<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(hi&minus;1)<br>&oplus;<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(mi)<br>&oplus;<br>hi&minus;1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ehi&minus;1<br>(wi)<br>&oplus;<br>mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(wi)<br>&oplus;<br>hi&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(hi&minus;1)<br>&oplus;<br>mi</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2.1 Group-1 schemes in <a href="#page-12-7">[5]</a>.</p>

    <p class="text-gray-300">Ideal cipher model, which is often called black box model as well, is a formal model for the security analysis of block-cipher-based hash functions. An ideal cipher is an ideal primitive that models a random block-cipher E : {0, 1} <sup>k</sup> &times; {0, 1} n 7&rarr; {0, 1} n . Each key k &isin; {0, 1} <sup>k</sup> defines a random permutation E<sup>k</sup> = E(k, &middot;) on {0, 1} n . An adversary is given forward or inverse queries to oracles E, when he makes a forward query to E with (+, k, p), it returns the point c such that Ek(p) = c, when he makes an inverse query to E with (&minus;, k, c), it returns the point p such that Ek(p) = c.</p>

    <p class="text-gray-300">As the ideal cipher model, the random oracle model(ROM) is also a method of developing provably secure cryptosystems. Simply says, A random oracle (RO) is an ideal primitive which provides a random output for each new query. Identical input queries are given the same answer. Recently, it was proven by Coron <em>et al.</em> <a href="#page-12-14">[11]</a> that the ideal cipher model is equivalent to the random oracle model by using the indifferentiability methodology.</p>

    <p class="text-gray-300">At Crypto'93, Preneel, Govaerts and Vandewalle (PGV) <a href="#page-13-3">[22]</a> proposed a synthetic approach to design single block length hash function based on block ciphers. They considered the method of turning a block cipher E : {0, 1} <sup>n</sup> &times; {0, 1} <sup>n</sup> &rarr; {0, 1} n into a hash function H : {0, 1} <sup>&lowast;</sup> &rarr; {0, 1} <sup>n</sup> using a compression function f : {0, 1} <sup>n</sup> &times; {0, 1} <sup>n</sup> &rarr; {0, 1} <sup>n</sup> derived from E. For a fixed n-bit constant v, PGV considered all 64 compression functions f of the form f(hi&minus;1, mi) = Ek(p) &oplus; a where k, p, a &isin; {hi&minus;1, m<sup>i</sup> , hi&minus;<sup>1</sup> &oplus; m<sup>i</sup> , v}, where w<sup>i</sup> = hi&minus;<sup>1</sup> &oplus; m<sup>i</sup> and v is a constant. The hash function H(m1, . . . , ml) can subsequently be described as follows:</p>

    <p class="text-gray-300"><span class="math">$h_i = f(h_{i-1}, m_i), i = 1, 2, \\dots, l</span>$</p>

    <p class="text-gray-300">Here f is the underlying compression function, h<sup>0</sup> is equal to a fixed initial value IV, |m<sup>i</sup> | = n for each i &isin; [1 &middot; &middot; &middot; l] and h<sup>l</sup> is the hashcode. Of the 64 such schemes, PGV regards 12 schemes as secure in the sense of both the preimage resistance and the collision resistance. Another 13 schemes they classified as backward-attackable, which means they are subject to a potential attack. The remaining 39 schemes are subject to fatal attacks. Afterthat, Black <em>et al.</em> <a href="#page-12-7">[5]</a> revisited all the 64 PGV schemes in the ideal cipher model. They proved that the 12 secure schemes that PGV had singled out remain secure in the black-box analysis, which are denoted as the Group-1 schemes (listed in Table 2.1). Additionally, there are 8 schemes are also secure after iteration, they denoted these 8 schemes as the Group-2 schemes (listed in Table 2.2).</p>

    <p class="text-gray-300">In <a href="#page-12-2">[9]</a>, Coron <em>et al</em>. proposed four Merkle-Damgard variants such that the arbitrary length hash function &#730; H must behave as a random oracle when the fixed-length building block is viewed as a random oracle or an ideal block cipher, namely, the prefix-free padding, the NMAC/HMAC and the chop constructions. In this paper only compression function based on PGV schemes is considered. The four variants are described in Table 2.3.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Group-2 schemes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Case</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PGV</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(mi)<br>v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(hi&minus;1)<br>v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Emi<br>(wi)<br>v</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(mi)<br>&oplus;<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(hi&minus;1)<br>&oplus;<br>mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(wi)<br>&oplus;<br>mi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(hi&minus;1)<br>&oplus;<br>v</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(hi&minus;1)<br>&oplus;<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2.2 Group-2 schemes in <a href="#page-12-7">[5]</a>.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">pf-MDf<br>(IV, M) :</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">NMACf1,f2 (IV1, M) :</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">m1   &middot; &middot; &middot;   mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">m1   &middot; &middot; &middot;   mi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">, h0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">, h0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IV1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IV</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">For<br>i<br>= 1<br>to<br>i<br>do<br>hi<br>=<br>f(g(mi), hi&minus;1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">For<br>i<br>= 1<br>to<br>i<br>do<br>hi<br>=<br>f1(mi<br>, hi&minus;1)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Return<br>hi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Return<br>f2(hi<br>, IV2)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">HMACf</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">chop-MDf</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(IV, M) :</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s (IV, M) :</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">f(0n<br>M<br>=<br>m1   &middot; &middot; &middot;   mi<br>, h0<br>=<br>, IV<br>)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">M<br>=<br>m1   &middot; &middot; &middot;   mi<br>, h0<br>=<br>IV</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">= 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">= 1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">i</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">f(mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">f(mi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">, hi&minus;1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">, hi&minus;1)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">For</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">For</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">to</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">to</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">do</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">do</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hi+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">=</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">f(hi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">s</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">, IV</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Return the first</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Return</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">bit of</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2.3 Definitions of the four MD variants <a href="#page-12-2">[9]</a>.<sup>1</sup></p>

    <p class="text-gray-300">The famous Davis-Meyer scheme is an instance of PGV schemes, which can be denoted as f(hi&minus;1, mi) = Em<sup>i</sup> (hi&minus;1) &oplus; hi&minus;1. In the pf-MD construction, the message (m1, . . . , ml) are guaranteed to be prefix-free. This is because prefix-free encoding enables to eliminate the message expansion attack on hash functions, such as extension attack on MAC. For example, if a MAC is built from a hash function like MAC(k, m) = H(k k m) where k is the secret key. Then this MAC scheme is completely insecure for any Merkle-Damgard construction(including Merkle- &#730; Damgard strengthening). That is to say, given MAC &#730; (k, m) = H(k k m), we can extend the message m with any single arbitrary block m<sup>0</sup> and obtain MAC(k, m k m<sup>0</sup> ) = H(k k m k m<sup>0</sup> ) without knowing the secret key k. If we apply a prefix-free encoding to a message and then call the hash function to get its hash value, we can eliminate the message expansion attack. In fact, NMAC/HMAC and chop-MD are the same as pf-MD by references to avoid the message expansion attack.</p>

    <p class="text-gray-300">In this part, we recall the definition for indifferentiability<a href="#page-12-2">[9,</a> <a href="#page-13-4">19]</a>, which will be used in the following security analysis of PGV hash functions on the four MD variants.</p>

    <p class="text-gray-300">Definition 1 <em>A Turing machine</em> H <em>with oracle access to an ideal primitive</em> E <em>is said to be</em> (tD, tS, q, )<em>-indifferentiable from an ideal primitive</em> F <em>if there exists a simulator</em> S <em>with oracle access to</em> F <em>and running in time at most</em> tS<em>, such that for any distinguisher</em> D <em>it holds that:</em></p>

    <p class="text-gray-300"><span class="math">$|Pr[D^{H,E}=1] - Pr[D^{\\mathcal{F},S}=1]| &lt; \\epsilon</span>$</p>

    <p class="text-gray-300"><em>The simulator has oracle access to</em> F <em>and runs in time at most</em> tS<em>. The distinguisher runs in time at most</em> t<sup>D</sup> <em>and makes at most</em> q <em>queries. Similarly,</em> H<sup>E</sup> <em>is said to be (computationally) indifferentiable from</em> F <em>if is a negligible function of the security parameter</em> k <em>(for polynomially bounded</em> t<sup>D</sup> <em>and</em> tS<em>).</em></p>

    <p class="text-gray-300">The role of the simulator is to simulate the ideal primitive E so that no distinguisher can tell whether it is interacting with H and E, or with F and S; In other words, the output of S should look consistent with what the</p>

    <p class="text-gray-300"><sup>1</sup> g(mi) is the prefix-free padding, returns 1||m<sup>i</sup> if m<sup>i</sup> is the last block, else returns 0||mi. f1, f<sup>2</sup> are two independent compression functions, IV1, IV<sup>2</sup> are two distinct initial values.</p>

    <p class="text-gray-300">distinguisher can obtain from  <span class="math">\\mathcal{F}</span> . Note that the simulator does not see the distinguisher's queries to  <span class="math">\\mathcal{F}</span> ; however, it can call  <span class="math">\\mathcal{F}</span>  directly when it is required for the simulation. Here the algorithm H will represent the construction of an iterative hash function based on E. The ideal primitive E will represent the underlying primitive used to build the hash function. In this paper, we assume E is an ideal block cipher.  <span class="math">\\mathcal{F}</span>  is a random oracle with same domain and range as the hash function. In the case of ideal cipher model the distinguisher can access both E and  <span class="math">E^{-1}</span>  oracles and the simulator has to simulate the both.</p>

    <p class="text-gray-300">It was proven by Maurer <em>et al.</em> that if  <span class="math">H^E</span>  is indifferentiable from  <span class="math">\\mathcal{F}</span> , then  <span class="math">H^E</span>  can replace  <span class="math">\\mathcal{F}</span>  in any cryptosystem. The original theorem stated in below is a generic statement of the indifferentiability.</p>

    <p class="text-gray-300"><strong>Theorem 1</strong> Let P be a cryptosystem with oracle access to an ideal primitive  <span class="math">\\mathcal{F}</span> . Let H be an algorithm such that  <span class="math">H^E</span>  is indifferentiable from  <span class="math">\\mathcal{F}</span> . Then cryptosystem P is at least as secure in the E model with algorithm H as in the  <span class="math">\\mathcal{F}</span>  model.</p>

    <p class="text-gray-300">Coron <em>et al.</em> stated the indifferentiability of Davies-Meyer block cipher based construction with four MD variants in the ideal cipher model, the theorem is stated in [9] as follows.</p>

    <p class="text-gray-300"><strong>Theorem 2</strong> The Davis-Meyer scheme is  <span class="math">f(h_{i-1}, m_i) = E_{m_i}(h_{i-1}) \\oplus h_{i-1}</span> ) pf-MD, chop-MD, NMAC and HMAC are  <span class="math">(t_D, t_S, q, \\epsilon)</span> -indifferentiable from a random oracle in the ideal cipher model. For any  <span class="math">t_D</span> , with  <span class="math">t_S = O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for pf-MD,  <span class="math">\\epsilon = 2^{-s} \\cdot l^2 \\cdot O(q^2)</span>  for chop-MD,  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for NMAC and HMAC, where l is the maximum length of a query made by the distinguisher D.</p>

    <p class="text-gray-300">It was observed that Coron <em>et al.</em>'s bound of chop-MD is not tight. In [8], Chang and Nandi presented an improved indifferentiability security bound for chop-MD and stated the following theorem:</p>

    <p class="text-gray-300"><strong>Theorem 3</strong> The chop-MD construction is  <span class="math">(t_D, t_S, q, \\sigma, \\epsilon)</span> -indifferentiable from a random oracle, in the random oracle model for the compression function, for any  <span class="math">t_D</span> , with  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = \\frac{(3(n-s)+1)q_2+(n-s)q_1}{2^s} + \\frac{q}{2^{n-s-1}} + \\frac{\\sigma^2}{2^{n+1}} = O(\\frac{nq}{2^s} + \\frac{q}{2^{n-s}} + \\frac{q}{2^n})</span> , where  <span class="math">q = q_1 + q_2</span>  is the total number of queries and  <span class="math">\\sigma</span>  is the total number of queried message blocks.</p>

    <p class="text-gray-300">It is easy to see that any PGV compression functions are not indifferentiable from a random oracle [18]. But when the initial value IV is fixed, then there exist some PGV hash functions are indifferentiable from random oracle. To prove a scheme indifferentiable from a random oracle is not trivial. In Coron  <span class="math">et\\ al</span> .'s paper [9], the proof of indifferentiability involved two steps. First, a simulator is built to simulate the task of the ideal cipher. Secondly, they showed that the view of any distinguisher in the random oracle model, with oracle access to the actual random oracle and the ideal cipher simulator, didn't differ from its view in the ideal cipher model, with oracle access to the RO construction and the ideal cipher, by more than a negligible amount. Each proofs of indifferentiability consisted of a hybrid argument that presented a sequence of mutually indistinguishable games starting in the random oracle model, with the RO  <span class="math">\\mathcal F</span>  and the ideal cipher simulator  <span class="math">S(\\text{denoted by }S^{\\mathcal F})</span> , leading up to the ideal cipher model, with the RO construction and the ideal cipher E (denoted by  <span class="math">H^E</span> ). To prove the indifferentiability of a construction, they played six games and the proof is complicated.</p>

    <p class="text-gray-300">Later Chang <em>et al.</em> presented a formal method to prove the indifferentiability for many designs of hash functions with pf-MD construction which was in fact the same to Coron <em>et al.</em>'s proof. Since Chang <em>et al.</em>'s proof is more mathematical and formal, we adopt their method in our analysis. Here we describe Chang <em>et al.</em>'s proof on pf-MD in below.</p>

    <p class="text-gray-300">Let D be a distinguisher and S be a simulator for the formal analysis of indifferentiability. By following Definition 1, D is interacting with two cryptosystems  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> , where either  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2) = (H, E)</span>  or  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2) = (\\mathcal{F}, S)</span> . The distinguisher's goal is to distinguish which scenario it involves after the queries to  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> .  <span class="math">H: \\mathcal{M} \\to \\mathcal{Y}</span>  denotes a hash function constructed from a block-cipher  <span class="math">E: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  where  <span class="math">\\mathcal{M} \\in \\{0,1\\}^*</span>  and  <span class="math">\\mathcal{Y} \\in \\{0,1\\}^n</span> .  <span class="math">\\mathcal{F}</span>  is a random oracle which has the same domain and range with H.  <span class="math">h_i</span>  denotes the hash value of the i-th</p>

    <p class="text-gray-300">query. Let  <span class="math">r_i \\leftarrow (h_{i-1} \\xrightarrow{m_i} h_i)</span>  be the <em>i</em>-th query-response obtain from the query to the oracle  <span class="math">\\mathcal{O}_2</span>  where  <span class="math">m_i \\in \\{0,1\\}^n</span> .  <span class="math">\\mathcal{R}_i = (r_1, \\cdots, r_i)</span>  denotes the query-response set on the oracles  <span class="math">\\mathcal{O}_2</span>  after the <em>i</em>-th query. Let  <span class="math">r_i&#x27; \\leftarrow (IV \\xrightarrow{M} h_i)</span>  be the <em>i</em>-th query-response to the oracles  <span class="math">\\mathcal{O}_1</span>  where  <span class="math">M \\in \\mathcal{M}</span> .  <span class="math">\\mathcal{R}_i&#x27; = (r_1&#x27;, \\cdots, r_i&#x27;)</span>  denotes the query-response set on the oracles  <span class="math">\\mathcal{O}_1</span>  after the <em>i</em>-th query. A functional closure  <span class="math">\\mathcal{R}^*</span>  on  <span class="math">\\mathcal{R}</span>  is the set with the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">If
<span class="math">$h_{i-1} \\xrightarrow{m_i} h_i</span>$
,  <span class="math">h_i \\xrightarrow{m_{i+1}} h_{i+1} \\in \\mathcal{R}_{i+1}</span> , then  <span class="math">h_{i-1} \\xrightarrow{m_i \\mid |m_{i+1}|} h_{i+1} \\in \\mathcal{R}_{i+1}^*</span> .</p></li>
      <li><p class="text-gray-300">If
<span class="math">$h_{i-1} \\xrightarrow{m_i} h_i</span>$
,  <span class="math">h_{i-1} \\xrightarrow{m_i || m_{i+1}} h_{i+1} \\in \\mathcal{R}_{i+1}</span> , then  <span class="math">h_i \\xrightarrow{m_{i+1}} h_{i+1} \\in \\mathcal{R}_{i+1}^*</span> .</p></li>
    </ol>

    <p class="text-gray-300">The  <span class="math">\\mathcal{O}_1</span> -query inputs an arbitrary length message and outputs a fixed length hash value, while the  <span class="math">\\mathcal{O}_2</span> -query inputs a fixed length key and plaintext or ciphertext and outputs the corresponding ciphertext or plaintext, respectively. The details of the two categories of queries are described in below.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">&bull; Query on <span class="math">\\mathcal{O}_1 = H</span> or <span class="math">\\mathcal{O}_1 = \\mathcal{F}</span> :</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query on  <span class="math">\\mathcal{O}_1</span> , distinguisher D selects an arbitrary length message  <span class="math">M_i \\in \\mathcal{M}</span> . The response of  <span class="math">\\mathcal{O}_1</span>  is  <span class="math">h_i = H(IV, M_i)</span>  or  <span class="math">h_i = \\mathcal{F}(M_i)</span>  where  <span class="math">h_i \\in \\mathcal{Y}</span> .</li>
      <li>Let  <span class="math">\\mathcal{R}&#x27;_i = \\mathcal{R}&#x27;_{i-1} \\cup (IV \\xrightarrow{M_i} h_i)</span>  be the query-response set on the oracles  <span class="math">\\mathcal{O}_1</span>  after the <em>i</em>-th query. The query-response set  <span class="math">\\mathcal{R}&#x27;_q</span>  is the complete view of distinguisher D on the oracles  <span class="math">\\mathcal{O}_1</span>  after the maximum q queries. Note that the simulator S never see the distinguisher's queries to  <span class="math">\\mathcal{O}_1</span> .</li>
    </ul>

    <h2 id="sec-misc-2" class="text-2xl font-bold">&bull; Query on <span class="math">\\mathcal{O}_2 = E</span> or <span class="math">\\mathcal{O}_2 = S</span> :</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th forward query on  <span class="math">\\mathcal{O}_2</span> , distinguisher D queries  <span class="math">(+, k_i, p_i)</span>  where  <span class="math">k_i, p_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i, v\\}</span>  and the response is  <span class="math">c_i = E_{k_i}(p_i)</span>  or  <span class="math">c_i = S(k_i, p_i)</span> , where  <span class="math">c_i \\in \\{0, 1\\}^n</span> . By computing the hash value  <span class="math">h_i</span>  from the tuple  <span class="math">(k_i, p_i, c_i)</span> , the <em>i</em>-th query-response set  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup (h_{i-1} \\xrightarrow{m_i} h_i)</span> .</li>
      <li>For the <em>i</em>-th inverse query on  <span class="math">\\mathcal{O}_2</span> , distinguisher D queries  <span class="math">(-, k_i, c_i)</span>  where  <span class="math">k_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i, v\\}</span>  and  <span class="math">c_i \\in \\{0, 1\\}^n</span>  and the response is  <span class="math">p_i = E_{k_i}^{-1}(c_i)</span>  or  <span class="math">p_i = S^{-1}(k_i, c_i)</span> , where  <span class="math">p_i \\in \\{0, 1\\}^n</span> . By computing  <span class="math">h_{i-1}, h_i</span>  from the tuple  <span class="math">(k_i, p_i, c_i)</span> , the <em>i</em>-th query-response set  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup (h_{i-1} \\xrightarrow{m_i} h_i)</span> .</li>
      <li>Let  <span class="math">\\mathcal{R}_q</span>  be the query-response set of the oracle  <span class="math">\\mathcal{O}_2</span>  after the maximum q queries. According to the transitive and substitute properties of  <span class="math">\\mathcal{R}_q</span> , the functional closure  <span class="math">\\mathcal{R}_q^*</span>  is the complete view of distinguisher D on the oracles  <span class="math">\\mathcal{O}_2</span> . Here the simulator S also has this view.</li>
    </ul>

    <p class="text-gray-300">When D interacts with  <span class="math">(\\mathcal{F}, S)</span> , the simulator should simulate the ideal cipher E perfectly except a negligible probability. When D makes queries to the oracle  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span> , there may be some bad events happen, and the distinguisher D can exploit these bad events to decide which scenario it is in. If bad events don't happen, the distinguisher can never distinguish which scenario it is in except for a negligible probability.</p>

    <p class="text-gray-300">In Chang <em>et al.</em>'s indifferentiability analysis,  <span class="math">E_1, E_2</span>  are the bad events when D interacts with (H, E) and  <span class="math">(\\mathcal{F}, S)</span> , respectively. The oracles (H, E) and  <span class="math">(\\mathcal{F}, S)</span>  are identically distributed in the past view of the distinguisher when  <span class="math">E_1, E_2</span>  do not happen.  <span class="math">Adv(\\mathcal{D})</span>  is the measure of the maximal advantage of indifferentiability over all distinguishers  <span class="math">\\mathcal{D}</span> . For brevity,  <span class="math">D_1</span>  denotes the event  <span class="math">\\mathcal{D}^{H,E}=1</span>  and  <span class="math">D_2</span>  denotes the event  <span class="math">\\mathcal{D}^{\\mathcal{F},S}=1</span> . Let the function max() returns the largest value of inputs, The advantage of D is given in [7] as follows.</p>

    <p class="text-gray-300"><span class="math">$Adv(\\mathcal{D}) = |Pr[\\mathcal{D}_1] - Pr[\\mathcal{D}_2]| \\le 2 \\times max(Pr[E_1], Pr[E_2]).</span>$</p>

    <p class="text-gray-300">Now the proof of indifferentiability of a scheme is clear. First, one should construct a simulator S such that D interacting with  <span class="math">(\\mathcal{F}, S)</span>  is indifferentiable with (H, E). Next, one must calculate the upper bound of the probability of the differentiable events, when D interacts with  <span class="math">(\\mathcal{F}, S)</span>  and (H, E) respectively. Finally, one can deduce the maximal advantage of the differentiability over all distinguishers D.</p>

    <p class="text-gray-300">The Davies-Meyer scheme is a well-known construction in the design of compression function based on block ciphers, which also belongs to 20 collision resistant PGV structures. It is also used implicitly implemented in the constructions of MD5 and SHA-1. Coron <em>et al.</em>'s full paper [9] presented the detailed proof of the indifferentiability of the pf-MD, the chop-MD and NMAC based on the Davies-Meyer scheme. Chang <em>et al.</em> [7] also proposed a proof of the indifferentiability of pf-MD, which uses the Davis-Meyer scheme as the underlying compression function. Unfortunately, we find that there exist some flaws in Coron <em>et al.</em>'s proofs of pf-MD and NMAC, and also Chang <em>et al.</em>'s proof of the pf-MD such that a new type distinguisher can implement differentiable attacks on the Davies-Meyer scheme while extends its domain by using the pf-MD and the NMAC construction. This section will be divided into three parts. In the first part, Coron <em>et al</em>'s and Chang <em>et al</em>'s simulators for pf-MD and NMAC are recalled. In the second part, new differentiable attacks on these simulators are presented. Finally, according to our new attacks, the indifferentiability simulations for the Davies-Meyer scheme with pf-MD and NMAC are refined in the third part.</p>

    <p class="text-gray-300">Coron <em>et al.</em>'s and Chang <em>et al.</em>'s simulators of pf-MD and NMAC based on Davies-Meyer structure are described in the appendix A. When these simulators are built, then the advantages of the distinguishers can be calculated by using the method in [9] or [7]. In the next part, we will show how to differentiable attack these simulations and refine the simulations to against this type of attacks.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 A New Type of Differentiable Attacks on the Simulations of pf-MD and NMAC.</h3>

    <p class="text-gray-300">In this part, some differentiable attacks are presented to disclose the fact that the plausible simulations (which are recalled in Appendix A) will be failed in the ideal cipher model. After pointed out the attacks, the simulations and the proofs for pf-MD and NMAC are refined to avoid the above attacks. The following distinguishers demonstrate how to attack Coron <em>et al</em>'s and Chang <em>et al</em>'s simulators.</p>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">Attack on the Simulations of pf-MD.</h3>

    <p class="text-gray-300">The following distinguisher can distinguish (H, E) and  <span class="math">(\\mathcal{F}, S)</span>  with a non-negligible probability when the simulator behaves as Coron <em>et al.</em>'s and Chang <em>et al.</em>'s simulator of pf-MD construction.</p>

    <p class="text-gray-300">Distinguisher D can access to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is (H, E) or  <span class="math">(\\mathcal{F}, S)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D selects a message M such that g(M) = m where |m| = n, then he makes the query M to  <span class="math">\\mathcal{O}_1</span>  and receives h.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D makes an inverse query  <span class="math">(-, m, h \\oplus IV)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">IV^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">IV = IV^*</span>  output 1, otherwise output 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If the D outputs 1, then  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is (H, E), otherwise  <span class="math">(\\mathcal{F}, S)</span> . Since receiving an inverse query by the first time and there does not exist  <span class="math">IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span> , the simulator  <span class="math">S^{-1}</span>  can output the right IV with a negligible probability  <span class="math">2^{-n}</span> , such that</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E} = 1] - Pr[D^{\\mathcal{F},S} = 1]| = 1 - 2^{-n}.</span>$</p>

    <p class="text-gray-300">The reason why this attack can be succeed is that Coron  <span class="math">et\\,al</span> . didn't consider the scenario when the distinguisher makes an inverse query to the simulator and the goal of the distinguisher is to receive a value he already knows. So the response of the simulator S can't be random for each inverse query. Chang  <span class="math">et\\,al</span>  may observe Coron  <span class="math">et\\,al</span>  flaw</p>

    <p class="text-gray-300">in pf-MD since their simulator is different from Coron <em>et al.</em>'s. Their correction has avoided attacks which involve queries which the length are at least two blocks. But they didn't consider the scenario that an attack which applied in only one block length and the distinguisher's goal is to receive the initial value IV. We can see the distinguisher can distinguish (H, E) from  <span class="math">(\\mathcal{F}, S)</span>  with an overwhelming probability. The similar attack can be extended to Coron <em>et al.</em>'s simulator of NMAC.</p>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8">Attack on Coron et al's Simulation of NMAC.</h3>

    <p class="text-gray-300">The following distinguisher can distinguish (H, E) and  <span class="math">(\\mathcal{F}, S)</span>  with a non-negligible probability when the simulator behaves as Coron <em>et al</em>'s simulator of NMAC construction.</p>

    <p class="text-gray-300">Distinguisher D can access to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is  <span class="math">(H, \\{E1, E2\\})</span>  or  <span class="math">(\\mathcal{F}, \\{S1, S2\\})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D selects a message m where |m| = n, then he makes the query m to  <span class="math">\\mathcal{O}_1</span>  and receives h.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D makes a forward query  <span class="math">(1, +, m, IV_1)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">c_1</span> , then he gets  <span class="math">h_1 = IV_1 \\oplus c_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D makes an inverse query  <span class="math">(2, -, h_1, h \\oplus IV_2)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">IV_2^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">IV_2 = IV_2^*</span>  output 1, otherwise output 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If D outputs 1, then  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is  <span class="math">(H, \\{E1, E2\\})</span> , otherwise it is  <span class="math">(\\mathcal{F}, \\{S1, S2\\})</span> . Since the inverse is never queried before, the simulator S2 can output the right  <span class="math">IV_2</span>  with a negligible probability of  <span class="math">2^{-n}</span> , whilst</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E1,E2} = 1] - Pr[D^{\\mathcal{F},S1,S2} = 1]| = 1 - 2^{-n}.</span>$</p>

    <p class="text-gray-300">Hence, the distinguisher D can distinguish  <span class="math">(H, \\{E1, E2\\})</span>  from  <span class="math">(\\mathcal{F}, \\{S1, S2\\})</span>  with an overwhelming probability.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Corrections</h3>

    <p class="text-gray-300">Though there are some flaws in simulators mentioned above, they can be corrected easily. In fact, all problems are from the inverse queries of the last block of a message. So the simulator's response to an inverse query to the last block needs to be treated with caution. Now corrections for each of the simulators mentioned above are given in below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Corrections on Coron et al.'s and Chang et al.'s simulator of pf-MD.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(-, k_i, c_i)</span>  on S where  <span class="math">k_i = m_i</span> :    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_i} (h_{j-1} \\oplus c_i) \\in \\mathcal{R}_{i-1}</span>  for j &lt; i, this is a repetition query, S returns  <span class="math">h_{j-1}</span> .</li>
      <li>(b) Else S runs  <span class="math">\\mathcal{F}(m_i)</span>  and obtains the response h. If  <span class="math">h \\oplus c_i = IV</span> , then returns IV and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{IV \\xrightarrow{m_i} h\\}</span> .</li>
      <li>(c) Else for each  <span class="math">IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> , runs  <span class="math">\\mathcal{F}(M) = h_i</span> . If  <span class="math">h_i \\oplus h_{i-1} = c_i</span> , returns  <span class="math">h_{i-1}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span></li>
      <li>(d) Else S randomly selects an intermediate value  <span class="math">h&#x27;_{i-1} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h&#x27;_{i-1} \\xrightarrow{m_i} c_i \\oplus h&#x27;_{i-1}\\}</span> , then returns  <span class="math">h&#x27;_{i-1}</span> .</li>
    </ul></li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Corrections on Coron et al.'s simulator of NMAC.</li>
    </ol></li>
      <li><p class="text-gray-300">For the j-th query  <span class="math">(2, -, k_j, c_j)</span>  on S2 where  <span class="math">k_j = m_j</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{k-1} \\xrightarrow{m_j} (h_{k-1} \\oplus c_j) \\in \\mathcal{Q}_{j-1}</span>  where k &lt; j, this is a repetition query, S returns  <span class="math">h_{k-1}</span> .</li>
      <li>(b) Else If  <span class="math">\\exists IV_1 \\xrightarrow{M} (k_j) \\in \\mathcal{R}_i^*</span>  where  <span class="math">\\mathcal{R}_i^*</span>  is the simulator's view of the past queries on S1 and then S runs  <span class="math">\\mathcal{F}(M)</span>  and gets h. If  <span class="math">IV_2 \\oplus h = c_j</span> , S updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h\\}</span> , then returns  <span class="math">IV_2</span> .</li>
      <li>(c) Else S randomly selects an intermediate value  <span class="math">h&#x27;_{j-1} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{h&#x27;_{j-1} \\xrightarrow{m_j} c_j \\oplus h&#x27;_{j-1}\\}</span> , then returns  <span class="math">h&#x27;_{j-1}</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">When these simulators are corrected, then the advantage of any distinguisher can be calculated as in [9] or [7]. It is easy to see that the time complexity of the simulator and the advantage of any distinguishers are not affected. Thus one can easily obtain the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary 1</strong> The Davis-Meyer scheme with pf-MD, chop-MD, NMAC and HMAC are  <span class="math">(t_D, t_S, q, \\epsilon)</span> -indifferentiable from a random oracle in the ideal cipher model. For any  <span class="math">t_D</span> , with  <span class="math">t_S = O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for pf-MD,  <span class="math">\\epsilon = 2^{-s} \\cdot l^2 \\cdot O(q^2)</span>  for chop-MD,  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for NMAC and HMAC, where l is the maximum length of a query made by the distinguisher D.</p>

    <p class="text-gray-300">In [15], Gong <em>et al.</em> also provided an indifferentiability analysis of 20 PGV schemes with pf-MD and claimed that all 20 schemes are indifferentiable from random oracles with prefix-free padding (the length padding is also implemented). There is an obvious error in their simulators that the simulators needed to record the distinguisher's queries to the random oracle  <span class="math">\\mathcal{F}</span> . In fact, the simulator can never have the record of the distinguisher's queries, which can be derived from the definition of indifferentiability.</p>

    <p class="text-gray-300">Due to the new flaws disclosed in the our analysis, the indifferentiability of PGV schemes with pf-MD, NMAC/HMAC and chop-MD are reconsidered in this section. Based on our analysis of pf-MD, the necessary conditions for a PGV hash construction to be indifferentiable from a random oracle are analyzed. Filtered by those necessary conditions, there are only twelve schemes survived in 64 PGV schemes, which include eight of the Group-1 and four of the Group-2 schemes. [5].</p>

    <p class="text-gray-300">At AsiaCrypt'06, Chang <em>et al.</em>[7] presented an indifferentiability security analysis of these schemes with pf-MD. They claimed that there are 4 schemes among 20 collision-resistant PGV schemes are differentiable from random oracle with pf-MD. And the remaining 16 schemes are indifferentiable from a random oracle with pf-MD. The four insecure schemes(in the sense of indifferentiability with pf-MD) are case 1, 2, 3 and 4 of the Group-1 schemes. Here we find that in the remaining 16 schemes, there are another four schemes are differentiable from random oracle with pf-MD. These four schemes are case 15, 17, 19 and 20 from the Group-2 schemes.</p>

    <p class="text-gray-300">When analyze these 20 collision resistant PGV hash function for NMAC/HMAC and chop-MD construction, we found all of them are indifferentiable from a random oracle in the ideal cipher model, and the chop-MD construction has the better indifferentiability security bound than NMAC/HMAC construction. This exploits that the four MD variants are not the same in the sense of indifferentiability. According to our synthetic analysis, we exploit the fact that in 20 PGV collision resistant constructions, there exist schemes that are differentiable from random oracle for the pf-MD construction, but are indifferentiable from random oracle for the NMAC/HMAC and chop-MD construction, while the chop-MD construction has the better indifferentiability security bound. This fact gives the evidence that the four popular MD variants, namely pf-MD, NMAC/HMAC, the chop construction, are not the same in the sense of indifferentiability.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Indifferentiability of PGV Hash Functions with pf-MD</h3>

    <p class="text-gray-300">Here we use the indifferentiability methodology to revisit PGV schemes with the pf-MD construction. We analyze the properties of 64 PGV schemes and find the necessary conditions for a PGV schemes to be indifferentiable from a random oracle. The necessary conditions are described as follows. First we present the theorem with respect to the compression function which is not a collision resistant PGV scheme.</p>

    <p class="text-gray-300"><strong>Theorem 4</strong> A hash function H built from any PGV scheme  <span class="math">h_i = f(h_{i-1}, m_i)</span>  with pf-MD is differentiable from a random oracle if H is not collision resistant.</p>

    <p class="text-gray-300">The proof is given in Appendix B.1. Based on Theorem 4, it is easy to see that 44 out of the total 64 PGV schemes are not collision resistant, thus they are differentiable from random oracle with pf-MD.</p>

    <p class="text-gray-300"><strong>Theorem 5</strong> A hash function H built from any PGV construction  <span class="math">h_i = f(h_{i-1}, m_i)</span>  with pf-MD is differentiable from a random oracle if  <span class="math">(h_i, m_i) \\Rightarrow h_{i-1}</span> . That is to say, it is trival to deduce  <span class="math">h_{i-1}</span>  from  <span class="math">(h_i, m_i)</span>  with access to the block cipher. For example,  <span class="math">h_i = E_{m_i}(h_{i-1})</span> , if we know the value of  <span class="math">(h_i, m_i)</span> , then  <span class="math">h_{i-1} = E_{m_i}^{-1}(h_i)</span> .</p>

    <p class="text-gray-300">The proof is given in Appendix B.2. Based on Theorem 5, the 4 PGV schemes, which are case 15, 17, 19 and 20 of the Group-2 schemes, are differentiable from a random oracle.</p>

    <p class="text-gray-300"><strong>Theorem 6</strong> A hash function H built from any PGV schemes  <span class="math">h_i = f(h_{i-1}, m_i)</span>  with pf-MD is differentiable from a random oracle if given  <span class="math">(h_{i-1}, k, c)</span>  where  <span class="math">k \\in \\{h_{i-1}, v\\}</span>  is the key to the block cipher E and c is a linear combination of  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and the cipher text of the block cipher E, it is infeasible to deduce  <span class="math">m_i</span>  without access to the block cipher. For example, if  <span class="math">h_i = E_{h_{i-1}}(m_i) \\oplus m_i</span> , then  <span class="math">k = h_{i-1}</span>  and  <span class="math">c = h_i \\oplus m_i</span> , from the triple  <span class="math">(h_{i-1}, h_{i-1}, h_i \\oplus m_i)</span> , it is infeasible to deduce  <span class="math">m_i</span>  without access to E.</p>

    <p class="text-gray-300">The proof is given in Appendix B.3. Based on theorem 6, the 4 PGV schemes, which are case 1, 2, 3, 4 of the group-1 schemes, are differentiable from a random oracle. From the above analysis, one can easily get the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary 2</strong> A hash function H built from the PGV compression function  <span class="math">h_i = f(h_{i-1}, m_i)</span>  with pf-MD is differentiable from a random oracle if it satisfies one of the following conditions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>A.</strong> The hash function H is not collision resistant.</li>
      <li><strong>B.</strong>  <span class="math">(h_i, m_i) \\Rightarrow h_{i-1}</span> . That is to say, it is trival to deduce  <span class="math">h_{i-1}</span>  from  <span class="math">(h_i, m_i)</span>  with access to the block cipher.</li>
      <li><strong>C.</strong> Given  <span class="math">(h_{i-1}, k, c)</span>  where  <span class="math">k \\in \\{h_{i-1}, v\\}</span>  is the key to the block cipher E and c is a linear combination of  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and the cipher text of the block cipher E, it is infeasible to deduce  <span class="math">m_i</span>  without access to the block cipher.</li>
    </ul>

    <p class="text-gray-300">The case 15, 17, 19, 20 of the group-2 schemes(see table 1.2) satisfy the condition B, and the case 1, 2, 3, 4 of the group-1 schemes(see table 1.1) satisfy the condition C, so they are differentiable from a random oracle with pf-MD construction. Those 8 differentiable schemes are listed in Table C.1.</p>

    <p class="text-gray-300">Since the necessary conditions for the indifferentiability of a PGV structure with the pf-MD construction are given, it is easy to analyze a construction by checking if it satisfies any one of the conditions mentioned above. If anyone of these conditions holds, then the PGV scheme is differentiable from a random oracle with the pf-MD construction. After checking these conditions for every 64 PGV construction, there are only 12 PGV schemes are secure against differentiable attack with pf-MD construction, which are listed in table C.2. The following theorem is proven in Appendix B.4.</p>

    <p class="text-gray-300"><strong>Theorem 7</strong> The twelve PGV schemes, which are list in table C.2, are  <span class="math">(t_D, t_S, q, \\epsilon)</span>  indifferentiable from a random oracle in the ideal cipher model. For any  <span class="math">t_D</span> , with  <span class="math">t_S = l \\cdot O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for pf-MD, where l is the maximum length of a query made by the distinguisher D.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Indifferentiability of PGV Hash Functions with NMAC/HMAC</h3>

    <p class="text-gray-300">In the above analysis, there are only 12 of the 20 collision-resistant PGV schemes are indifferentiable from random oracle with pf-MD construction. In this part we will show it is not the same in the analysis of NMAC/HMAC construction. For brevity, we only analyze the NMAC construction. The results can be easily extended to the HMAC</p>

    <p class="text-gray-300">construction because HMAC is a special case of NMAC. In our analysis, all of 20 collision-resistant PGV constructions are indifferentiable from random oracle with NMAC/HMAC construction, which implies that the NMAC/HMAC construction is better than the pf-MD construction.</p>

    <p class="text-gray-300">Furthermore, we will show even if a collision resistant PGV construction satisfies condition B or C in corollary 2, it can be indifferentiable from random oracle with NMAC/HMAC construction. For simplicity, we only show the case 15 from group-2 schemes(table 2.2) satisfies condition B, but is indifferentiable from a random oracle for the NMAC construction. For other cases, one can make a similar analysis and the proof of the indifferentiability will be deduced similarly.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> The collision resistant PGV compression function  <span class="math">h_i = E_{m_i}(h_{i-1})</span>  which satisfies condition B in theorem 3 is  <span class="math">(t_D, t_S, q, \\epsilon)</span>  indifferentiable from a random oracle in the ideal cipher model. For any  <span class="math">t_D</span> , with  <span class="math">t_S = O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for NMAC, where l is the maximum length of a query made by the distinguisher D.</p>

    <p class="text-gray-300">Lemma 1 is proven in Appendix B.5. In fact, for any one of the 20 collision resistant PGV constructions, one can build the similar simulator with NMAC/HMAC construction such that any distinguisher fails. Since the proof of the indifferentiability for each PGV scheme is similar to the proof of Lemma 1, we have the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 8</strong> The 20 collision resistant PGV schemes are  <span class="math">(t_D, t_S, q, \\epsilon)</span>  indifferentiable from a random oracle in the ideal cipher model. For any  <span class="math">t_D</span> , with  <span class="math">t_S = O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  for NMAC/HMAC, where l is the maximum length of a query made by the distinguisher D.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Indifferentiability of PGV Hash Functions with chop-MD</h3>

    <p class="text-gray-300">In this part the indifferentiability of chop-MD for the 20 collision resistant PGV schemes will be analyzed. We show that all the 20 collision resistant PGV schemes are indifferentiable from random oracle in the ideal cipher model for the chop-MD construction. In [10], Coron <em>et al.</em> analyzed the indifferentiability of chop-MD based on the Davies-Meyer construction. They had the following lemma:</p>

    <p class="text-gray-300"><strong>Lemma 2</strong> The Merkle-Damg&aring;rd construction with truncated output chop-MD<sub>s</sub><sup>E</sup> based on the Davies-Meyer construction applied to an ideal cipher  <span class="math">E: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span>  is  <span class="math">(t_D,t_S,q,\\epsilon)</span>  indifferentiable from a random oracle  <span class="math">F: \\{0,1\\}^* \\to \\{0,1\\}^{n-s}</span>  in the ideal cipher model for E, for any  <span class="math">t_D</span>  and  <span class="math">t_S = l \\cdot O(q^2)</span> , with  <span class="math">\\epsilon = 2^{-s} \\cdot l^2 \\cdot O(q^2)</span> .</p>

    <p class="text-gray-300">Coron <em>et al.</em>'s bound of chop-MD is not very tight. In [20], Maurer and Tessaro firstly presented a prefix-free chop-MD construction which has indifferentiability security beyond the birthday barrier. Later, Chang and Nandi presented an improved indifferentiability security bound for chop-MD which stated in theorem 3. Though Chang and Nandi's improved indifferentiability security bound is proved when looks the compression function as a random oracle, their proof of the security bound can be applied in the ideal cipher model when the compression function is based on Davies-Meyer structure. Some collision resistant PGV schemes satisfy condition B or C in theorem 2 can be indifferentiable from random oracle for chop-MD in the ideal cipher model. Take the PGV scheme  <span class="math">h_i = E_{h_{i-1}}(m_i) \\oplus m_i</span>  as an example, if n = 2s, we can build the following distinguisher:</p>

    <p class="text-gray-300">Distinguisher D can access to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is  <span class="math">(\\text{chop-MD}_s^E, E)</span>  or  <span class="math">(\\mathcal{F}, S)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D selects a message M such that g(M) = m where |m| = n, then makes the query M to  <span class="math">\\mathcal{O}_1</span>  and receives h.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each h' from 0 to  <span class="math">2^s-1</span> , D makes an inverse query  <span class="math">(-, IV, m \\oplus (h \\parallel h&#x27;))</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives m'.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If there exist an m' such that m' = m, D output 1, otherwise output 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Since the simulator never knows the right message m, it gives the right response only with probability  <span class="math">2^{-s}</span>  after  <span class="math">q = 2^s</span>  queries. After queried q times to  <span class="math">\\mathcal{O}_2</span> ,</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E,E^{-1}} = 1] - Pr[D^{\\mathcal{F},S,S^{-1}} = 1]| = \\frac{q}{2^s} - \\frac{q}{2^{2s}} \\approx \\frac{q}{2^s}.</span>$</p>

    <p class="text-gray-300">It is obvious that the advantage of the distinguisher is less than the birthday bound, and this advantage is less than Chang and Nandi's improved security bound and so that this type of differentiable attack fails. The result can be extended to other 19 collision resistant PGV schemes. For any one of 20 collision resistant PGV schemes, the following simulator can be built such that the advantage of any distinguisher is in Chang and Nandi's improved bound.</p>

    <h3 id="sec-misc-5" class="text-xl font-semibold mt-8"><strong>Simulator:</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(+, k_i, p_i)</span>  on S where  <span class="math">k_i, p_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span> ,  <span class="math">h_{i-1}</span>  and  <span class="math">m_i</span>  can be deduced from  <span class="math">(k_i, p_i)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span> , then this is a repetition query, deduces  <span class="math">c_i</span>  from  <span class="math">(h_{i-1}, h_i, m_i)</span> , S returns  <span class="math">c_i</span> .</li>
      <li>(b) Else if  <span class="math">\\exists IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> ,  <span class="math">S \\text{ runs } \\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_i</span> , randomly choose a s-bit string h', updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} (h_i \\parallel h&#x27;)\\}</span> , then deduces  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, (h_i \\parallel h&#x27;), v\\}</span>  and returns  <span class="math">c_i</span> ;</li>
      <li>(c) Else S randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then deduces  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and returns  <span class="math">c_i</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(-, k_i, c_i)</span>  on S where  <span class="math">k_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span>  where  <span class="math">k_i, c_i</span>  can be deduced from  <span class="math">(h_{i-1}, m_i, h_i)</span> , then this is a repetition query, S deduces  <span class="math">p_i</span>  from  <span class="math">(h_{i-1}, m_i, h_i)</span> , then returns the  <span class="math">p_i</span> .</li>
      <li>(b) Else S randomly selects a message  <span class="math">h_{i-1} \\in \\{0,1\\}^n</span> , deduces  <span class="math">m_i, h_i</span>  from  <span class="math">\\{h_{i-1}, k_i, c_i\\}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">h_{i-1}</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">For anyone of the 20 collision PGV schemes, we can calculate the advantage of any distinguisher using the method explained in [8]. So combined our analysis of PGV schemes and Chang and Nandi's improved bound. We get the following theorem:</p>

    <p class="text-gray-300"><strong>Theorem 9</strong> The chop- <span class="math">MD_s^E</span>  construction based on anyone of 20 collision resistant collision PGV schemes is  <span class="math">(t_D, t_S, q, \\sigma, \\epsilon)</span>  indifferentiable from a random oracle, in the ideal cipher model for any  <span class="math">t_D</span> , with  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = O(\\frac{nq}{2^s} + \\frac{q}{2^{n-s}} + \\frac{\\sigma^2}{2^n})</span> , where q is the total number of queries and  <span class="math">\\sigma</span>  is the total number of message blocks queried.</p>

    <p class="text-gray-300">The above theorem shows that the distinguisher needs at least  <span class="math">2^s/(3s+1)</span>  query complexity to have an indifferentiability attack when n=2s. In [8], the result implies the chop-MD hash function is almost optimally secure with respect to second preimage and multicollision attack. Note that it doesn't improve the security bound for resisting collisions to chop-MD, but does improve the bound for indifferentiability in the ideal cipher model.</p>

    <p class="text-gray-300">The indifferentiability of 20 collision resistant PGV hash functions for pf-MD, NMAC/HMAC and chop-MD construction are revisited. It is shown that the indifferentiability is really a method to verify the security of a construction. There are some schemes can be differentiable from random oracle with pf-MD, but are indifferentiable from random oracle with NMAC/HMAC and chop-MD construction. Our results exploit that the four Merkle-Damg&aring;rd variants are not the same in the sense of the indifferentiability. And the later two constructions are better than pf-MD. Since the pf-MD construction has lower input domain and the chop-MD construction has lower output range, the NMAC/HMAC would be a better choice for practice use. We also suggest that one should take care of the proof of the indifferentiability of a construction, since some flaws have been found in previous works.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] Andreeva, E., Neven, G., Preneel, B., Shrimpton, T.: Seven-property-preserving hashing: ROX. In: Kurosawa, K. (ed.) ASIACRYPT'2007. LNCS 4833, pp. 130-146. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[2] Bellare, M., Ristenpart, T.: Multi-property-preserving hash domain extension: The EMD transform. In: Lai, X., Chen, K. (eds.) ASIACRYPT'2006. LNCS 4284, pp. 299-314. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[3] M. Bellare and T. Ristenpart. Hash Functions in the Dedicated-key Setting: Design Choices and MPP Transforms. In: ICALP'07, LNCS 4596, pp. 339-410. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[4] G. Bertoni, J. Daemen, M. Peeters, G. Van Assche: On the indifferentiability of the sponge construction. In: Smart, N. (ed.) EUROCRYPT'2008. LNCS 4965, pp. 181-197. 2008.</p></li>
      <li><p class="text-gray-300">[5] J. Black, P. Rogaway, and T. Shrimpton. Black-box analysis of the blockcipher- based hash function constructions from PGV. In Crypto2002, LNCS 2442, pp. 320-335. Springer, 2002.</p></li>
      <li><p class="text-gray-300">[6] B. O. Brachtl, D. Coppersmith, M.M. Hyden, S.M. Matyas, C.H. Meyer, J. Oseas, S. Pilpel and M. Schilling. Data Authentication Using Modification Detection Codes Based on a Public One Way Encryption Function. U.S. Patent Number 4,908,861, March 13, 1990.</p></li>
      <li><p class="text-gray-300">[7] D. H. Chang, S. J. Lee, M. Nandi and M. Yung. Indifferentiable Security Analysis of Popular Hash Functions with Prefix-Free Padding. In: X. Lai and K. Chen(eds): ASIACRYPT'2006, LNCS 4284, pp. 283-298. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[8] D. H. Chang and M. Nandi. Improved Indifferentiability Security Analysis of chopMD Hash Function. In: K. Nyberg(ed.): FSE'2008, LNCS 5086, pp. 429-443, Springer, 2008.</p></li>
      <li><p class="text-gray-300">[9] J. S. Coron, Y. Dodis, C. Malinaud and P. Puniya. Merkle-Damgard Revisited: How to Construct a Hash Function. In: CRYPTO'05, LNCS 3621, pp. 21-39. 2005.</p></li>
      <li><p class="text-gray-300">[10] J. S. Coron, Y. Dodis, C. Malinaud and P. Puniya. Merkle-Damgard Revisited: How to Construct a Hash Function (Full Version). In http://people.csail.mit.edu/dodis/ps/merkle.ps. 2007. A preliminary version was accepted by Crypto'05, LNCS 3621, pp. 21-39. 2005.</p></li>
      <li><p class="text-gray-300">[11] J. S. Coron, J. Patarin, and Y. Seurin. The random oracle model and the ideal cipher model are equivalent. In D. Wagner(ed.), CRYPTO'2008, LNCS 5157, pp. 1-20. Springer, 2008.</p></li>
      <li><p class="text-gray-300">[12] I. Damgard. A Design Principle for Hash Functions, In:Cyrpto'89, LNCS 435, pp. 416-427. Springer, 1989.</p></li>
      <li><p class="text-gray-300">[13] Y. Dodis, L. Reyzin, R. L. Rivest and E. Shen. Indifferentiability of Permutation-Based Compression Functions and Tree-Based Modes of Operation, with Applications to MD6. FSE'09, Appear soon.</p></li>
      <li><p class="text-gray-300">[14] Y. Dodis, T. Ristenpart, and T. Shrimpton. Salvaging Merkle-Damgard for Practical Applications. In: Euro-Crypt'09, LNCS 5479, pp. 371-388. Springer.</p></li>
      <li><p class="text-gray-300">[15] Z. Gong, X. Lai, and K. Chen. A Synthetic Indifferentiability Analysis of Some Block-Cipher-Based Hash Functions. Designs, Codes and Cryptography, Springer. 48(3), Sept 2008.</p></li>
      <li><p class="text-gray-300">[16] S. Hirose. Some Plausible Constructions of Double-Length Hash Functions. In: FSE'06, LNCS 4047, pp. 210- 225. Springer, 2006.</p></li>
      <li><p class="text-gray-300">[17] S. Hirose, J. Park, and A. Yun. A Simple Variant of the Merkle-Damgard Scheme with a Permutation. In: ASIACRYPT'07, LNCS vol. 4833, pp. 113-129. Springer, 2007.</p></li>
      <li><p class="text-gray-300">[18] H. Kuwakado , M. Morii: Indifferentiability of single-block-length and rate-1 compression functions. IEICE Trans Fundamentals, vol.e90-A, pp. 2301-2308. 2007.</p></li>
      <li><p class="text-gray-300">[19] U. Maurer, R. Renner, and C. Holenstein. Indifferentiability, Impossibility Results on Reductions, and Applications to the Random Oracle Methodology. In: <em>TCC</em>'2004, LNCS 2951, pp. 21-39. Springer, 2004.</p></li>
      <li><p class="text-gray-300">[20] U. Maurer and S. Tessaro. Domain Extension of Public Random Functions: Beyond the Birthday Barrier. In: Menezes, A. (ed.) <em>CRYPTO</em> '2007. LNCS 4622, pp. 187-204. Springer, 2007</p></li>
      <li><p class="text-gray-300">[21] R.C. Merkle. One way hash functions and DES, In: Crypto'89, LNCS 435, pp. 428-446. Springer, 1989.</p></li>
      <li><p class="text-gray-300">[22] B. Preneel, R. Govaerts and J. Vandewalle. Hash functions based on block ciphers: A synthetic approach. In: <em>CRYPTO'93</em>, LNCS 773, pp. 368-378. Springer, 1994.</p></li>
      <li><p class="text-gray-300">[23] X. Wang, Y. Yin and H. Yu. Finding Collision in the Full SHA-1. In: <em>CRYPTO'05</em>, LNCS 3621, pp. 17-36. Springer, 2005.</p></li>
      <li><p class="text-gray-300">[24] X. Wang and H. Yu. How to Break MD5 and Other Hash Functions. In: <em>EUROCRYPT'05</em>, LNCS 3494, pp. 19-35. Springer, 2005.</p></li>
    </ul>

    <p class="text-gray-300">Coron et al.'s and Chang et al.'s simulators of pf-MD and NMAC based on Davies-Meyer structure are described as follows:</p>

    <h3 id="sec-misc-6" class="text-xl font-semibold mt-8">Coron et al.'s Simulation of pf-MD.</h3>

    <p class="text-gray-300">The simulator S accepts either forward ideal cipher queries,  <span class="math">(+, k_i, p_i)</span> , or inverse ideal cipher queries,  <span class="math">(-, k_i, c_i)</span> , such that  <span class="math">k_i \\in \\{0, 1\\}^n</span>  and  <span class="math">p_i, c_i \\in \\{0, 1\\}^n</span> . In either case, the simulator S responses with a n-bit string that is interpreted as  <span class="math">E_{k_i}(p_i)</span>  in the case of a forward query  <span class="math">(+, k_i, p_i)</span>  and as  <span class="math">E_{k_i}^{-1}(c_i)</span>  in the case of an inverse query. The simulator keeps the relations  <span class="math">(\\mathcal{R}_1, \\ldots, \\mathcal{R}_{i-1})</span> . To answer the distinguisher D's forward and inverse queries, the simulator S responses as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(+, k_i, p_i)</span>  on S where  <span class="math">k_i = m_i</span>  and  <span class="math">p_i = h_{i-1}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span> , then this is a repetition query which the response is already known. S returns  <span class="math">c_i = h_i \\oplus h_{i-1}</span> .</li>
      <li>(b) Else if  <span class="math">\\exists IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> , S runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_i</span> , updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">c_i = h_i \\oplus h_{i-1}</span> ;</li>
      <li>(c) Else S randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">c_i = h_i \\oplus h_{i-1}</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(-, k_i, c_i)</span>  on S where  <span class="math">k_i = m_i</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_i} (h_{j-1} \\oplus c_i) \\in \\mathcal{R}_{i-1}</span>  for j &lt; i, then this is a repetition query. S returns  <span class="math">h_{j-1}</span> .</li>
      <li>(b) Else S randomly selects a message  <span class="math">h_{i-1}^{&#x27;} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1}^{&#x27;} \\xrightarrow{m_i} c_i \\oplus h_{i-1}^{&#x27;}\\}</span> , then returns  <span class="math">h_{i-1}^{&#x27;}</span> .</li>
    </ul></li>
    </ul>

    <h3 id="sec-misc-7" class="text-xl font-semibold mt-8">Chang et al.'s Simulation of pf-MD</h3>

    <p class="text-gray-300">Generally speaking, Chang et al.'s simulator is the same as Coron et al.'s except for the inverse query. To answer the distinguisher D's forward and inverse queries, the simulator S responses as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(+, k_i, p_i)</span>  on S where  <span class="math">k_i = m_i</span>  and  <span class="math">p_i = h_{i-1}</span> : S behaves the same as Coron <em>et al.</em>'s simulator.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(-, k_i, c_i)</span>  on S where  <span class="math">k_i = m_i</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_i} (h_{j-1} \\oplus c_i) \\in \\mathcal{R}_{i-1}</span>  for j &lt; i, this is a repetition query. S returns  <span class="math">h_{j-1}</span> .</li>
      <li>(b) Else for each  <span class="math">IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> , run  <span class="math">\\mathcal{F}(M) = h_i</span> . If  <span class="math">h_i \\oplus h_{i-1} = c_i</span> , return  <span class="math">h_{i-1}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span></li>
      <li>(c) Else S randomly selects a message  <span class="math">h&#x27;_{i-1} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h&#x27;_{i-1} \\xrightarrow{m_i} c_i \\oplus h&#x27;_{i-1}\\}</span> , then returns  <span class="math">h&#x27;_{i-1}</span> .</li>
    </ul></li>
    </ul>

    <h3 id="sec-misc-8" class="text-xl font-semibold mt-8">Coron et al.'s Simulation of NMAC.</h3>

    <p class="text-gray-300">The NMAC construction NMAC<sup>E1,E2</sup> essentially applies the Davies-Meyer construction using the block cipher E1 to the input  <span class="math">m_1 \\parallel \\ldots \\parallel m_l</span>  to get the final output  <span class="math">h_l</span> . It then applies another independent the Davies-Meyer construction using E2 to this output  <span class="math">h_l</span> . For simplicity the output length n of E1 is the same as the key length of E2. And one use  <span class="math">IV_1</span>  for the Davies-Meyer construction applied to E1, and use  <span class="math">IV_2</span>  for the Davies-Meyer construction with E2.</p>

    <p class="text-gray-300">The simulator gets forward/inverse queries for either of the block ciphers E1 and E2. Thus the queries that simulator S responds to are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(1, +, k_i, p_i)</span> : A forwards E1 query ,where  <span class="math">(k_i, p_i) \\in \\{0, 1\\}^n \\times \\{0, 1\\}^n</span> . The expected response is  <span class="math">E1_{k_i}(p_i)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(1, -, k_i, c_i)</span> : A inverses E1 query ,where  <span class="math">(k_i, c_i) \\in \\{0, 1\\}^n \\times \\{0, 1\\}^n</span> . The expected response is  <span class="math">E1_{k_i}^{-1}(c_i)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(2, +, k_i, p_i)</span> : A forwards E2 query ,where  <span class="math">(k_i, p_i) \\in \\{0, 1\\}^n \\times \\{0, 1\\}^n</span> . The expected response is  <span class="math">E2_{k_i}(p_i)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(2, -, k_i, c_i)</span> : A inverses E2 query ,where  <span class="math">(k_i, c_i) \\in \\{0, 1\\}^n \\times \\{0, 1\\}^n</span> . The expected response is  <span class="math">E2_{k_i}^{-1}(c_i)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The simulator S also maintains the relations  <span class="math">(\\mathcal{R}_1, \\ldots, \\mathcal{R}_{i-1})</span>  and  <span class="math">(\\mathcal{Q}_1, \\ldots, \\mathcal{Q}_{j-1})</span>  where  <span class="math">(\\mathcal{R}_1, \\ldots, \\mathcal{R}_{i-1})</span>  records the triples that obtained from queries on E1 and  <span class="math">(\\mathcal{Q}_1, \\ldots, \\mathcal{Q}_{j-1})</span>  records the triples that obtained from queries on E2. To answer the distinguisher D's forward and inverse queries on E1 or E2, the simulator S should simulate E1, E2 as S1, S2 and responses as follows.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">&bull; Query on S1:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(1, +, k_i, p_i)</span>  on S1 where  <span class="math">k_i = m_i</span>  and  <span class="math">p_i = h_{i-1}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span> , then this is a repetition query. S returns  <span class="math">c_i = h_i \\oplus h_{i-1}</span> .</li>
      <li>(b) Else S randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">c_i = h_i \\oplus h_{i-1}</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(1, -, k_i, c_i)</span>  on S1 where  <span class="math">k_i = m_i</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_i} (h_{j-1} \\oplus c_i) \\in \\mathcal{R}_{i-1}</span>  where j &lt; i, S returns  <span class="math">h_{j-1}</span> .</li>
      <li>(b) Else S randomly selects a message  <span class="math">h_{i-1}&#x27; \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1}&#x27; \\xrightarrow{m_i} c_i \\oplus h_{i-1}&#x27;\\}</span> , then returns  <span class="math">h_{i-1}&#x27;</span> .</li>
    </ul></li>
    </ul>

    <h3 id="sec-misc-10" class="text-xl font-semibold mt-8">&bull; <strong>Query on</strong> <em>S</em>2:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the j-th query  <span class="math">(2, +, k_j, p_j)</span>  on S2 where  <span class="math">k_j = m_j</span>  and  <span class="math">p_j = h_{j-1}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_j} h_j \\in \\mathcal{Q}_{j-1}</span> , then this is a repetition query. S2 returns  <span class="math">c_j = h_j \\oplus h_{j-1}</span> .</li>
      <li>(b) Else if  <span class="math">\\exists IV_1 \\xrightarrow{M&#x27;} m_j \\in \\mathcal{R}_i^*</span>  and  <span class="math">p_j = IV_2</span> , S runs  <span class="math">\\mathcal{F}(M&#x27; \\parallel m_j)</span>  and obtains the response  <span class="math">h_j</span> , updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = IV_2 \\oplus h_j</span> .</li>
      <li>(c) Else S randomly selects a hash value  <span class="math">h_j \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{i-1} \\cup \\{h_{j-1} \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = h_j \\oplus h_{j-1}</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the j-th query  <span class="math">(2, -, k_i, c_i)</span>  on S2 where  <span class="math">k_i = m_i</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{k-1} \\xrightarrow{m_j} (h_{k-1} \\oplus c_j) \\in \\mathcal{Q}_{j-1}</span>  where k &lt; j, S returns  <span class="math">h_{k-1}</span> .</li>
      <li>(b) Else S randomly selects a message  <span class="math">h_{j-1}&#x27; \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{h_{j-1}&#x27; \\xrightarrow{m_j} c_j \\oplus h_{j-1}&#x27;\\}</span> , then returns  <span class="math">h_{j-1}&#x27;</span> .</li>
    </ul></li>
    </ul>

      <h3 id="app-b.1" class="text-xl font-semibold mt-8"><strong>B.1</strong> Proof of Theorem 4</h3>

    <p class="text-gray-300">The distinguisher D accesses to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is (H, E) or  <span class="math">(\\mathcal{F}, S)</span> . If it is easy to find a collision (M, M') such that H(M) = H(M') when makes queries to E, D can query M and M' to  <span class="math">\\mathcal{O}_1</span>  and receive the responses. If the responses are different, then D is interacting with  <span class="math">(\\mathcal{F}, S)</span> , otherwise it is interacting with (H, E). Then we have</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E} = 1] - Pr[D^{\\mathcal{F},S} = 1]| = 1 - 2^{-n}.</span>$</p>

    <p class="text-gray-300">Since the advantage is non-negligible, so the construction is differentiable from a random oracle.  <span class="math">\\Box</span></p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8"><strong>B.2</strong> Proof of Theorem 5</h3>

    <p class="text-gray-300">If a PGV scheme satisfies  <span class="math">(h_i, m_i) \\Rightarrow h_{i-1}</span> , then we know the key  <span class="math">k_i</span>  to the block cipher E must be a linear combination of  <span class="math">\\{m_i, v\\}</span>  and  <span class="math">c_i</span>  is a linear combination of  <span class="math">\\{h_i, m_i, v\\}</span> , here v is a constant, then we can build the following distinguisher D such that any simulator fails.</p>

    <p class="text-gray-300">Distinguisher D can access to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is (H, E) or  <span class="math">(\\mathcal{F}, S)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D selects a message M, M' such that  <span class="math">g(M) = (m_1 \\parallel m_2)</span>  and  <span class="math">g(M&#x27;) = (m_1 \\parallel m&#x27;_2)</span>  where  <span class="math">m_2 \\neq m&#x27;_2</span>  and  <span class="math">|m_1| = |m_2| = |m&#x27;_2| = n</span> , then makes the query M to  <span class="math">\\mathcal{O}_1</span>  and receives  <span class="math">h_2</span>  and the query M' to  <span class="math">\\mathcal{O}_1</span>  and receives  <span class="math">h&#x27;_2</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D computes  <span class="math">(k_2,c_2)</span>  from  <span class="math">(m_2,h_2)</span>  and  <span class="math">(k_2&#x27;,c_2&#x27;)</span>  from  <span class="math">(m_2&#x27;,h_2&#x27;)</span> , then makes an inverse query  <span class="math">(-,k_2,c_2)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">p_2</span>  and computes  <span class="math">h_1</span>  from  <span class="math">(m_2,k_2,h_2,p_2)</span> , then makes an inverse query  <span class="math">(-,k_2&#x27;,c_2&#x27;)</span>  to  <span class="math">\\mathcal{O}_2</span>  and receives  <span class="math">p_2&#x27;</span>  and computes  <span class="math">h_1&#x27;</span>  from  <span class="math">(m_2&#x27;,k_2&#x27;,h_2&#x27;,p_2&#x27;)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">h_1 = h&#x27;_1</span>  output 1, otherwise output 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Since the simulator doesn't know whether the two inverse queries lead to a same internal value, the simulator S can output the right response only with probability  <span class="math">2^{-n}</span> ,</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E,E^{-1}} = 1] - Pr[D^{\\mathcal{F},S,S^{-1}} = 1]| = 1 - 2^{-n}</span>$</p>

    <p class="text-gray-300">This is not negligible. So the construction is differentiable from a random oracle.</p>

      <h3 id="app-b.3" class="text-xl font-semibold mt-8"><strong>B.3</strong> Proof of Theorem 6</h3>

    <p class="text-gray-300">In this case, the following distinguisher is built.</p>

    <p class="text-gray-300">Distinguisher D can access to oracles  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  where  <span class="math">(\\mathcal{O}_1, \\mathcal{O}_2)</span>  is (H, E) or  <span class="math">(\\mathcal{F}, S)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D selects a message M such that g(M) = m where |m| = n, then makes the query M to  <span class="math">\\mathcal{O}_1</span>  and receives h.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>D computes (k, c) from (h, m, IV, v), then makes an inverse query (-, k, c) to  <span class="math">\\mathcal{O}_2</span>  and receives p, then computes m' from (IV, k, c, p).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If m = m' output 1, otherwise output 0.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Since the simulator never knows the right message m, it gives the right response only with probability  <span class="math">2^{-n}</span> ,</p>

    <p class="text-gray-300"><span class="math">$Adv(D) = |Pr[D^{H,E,E^{-1}} = 1] - Pr[D^{\\mathcal{F},S,S^{-1}} = 1]| = 1 - 2^{-n}.</span>$</p>

    <p class="text-gray-300">So the construction is differentiable from a random oracle.</p>

      <h3 id="app-b.4" class="text-xl font-semibold mt-8"><strong>B.4</strong> Proof of Theorem 7</h3>

    <p class="text-gray-300">The Davies-Meyer construction(case 5) has been shown to be indifferentiable from random oracle with pf-MD. For the other 11 cases, we can make similar analysis. Thus, we can define a general simulator for these 12 PGV functions. The simulator is defined as follows:</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6"><strong>Simulator:</strong></h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(+, k_i, p_i)</span>  on S where  <span class="math">k_i, p_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span> , we can deduce  <span class="math">h_{i-1}</span>  and  <span class="math">m_i</span>  from  <span class="math">(k_i, p_i)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span> , then this is a repetition query. S deduces  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i\\}</span>  and returns  <span class="math">c_i</span> .</li>
      <li>(b) Else if  <span class="math">\\exists IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*</span>  and  <span class="math">g(M) = M&#x27; \\parallel m_i</span> ,  <span class="math">S \\text{ runs } \\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_i</span> , updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then deduces  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and returns  <span class="math">c_i</span> ;</li>
      <li>(c) Else S randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then deduce  <span class="math">c_i</span>  from  <span class="math">\\{h_{i-1}, m_i, h_i, v\\}</span>  and returns  <span class="math">c_i</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(-, k_i, c_i)</span>  on S where  <span class="math">k_i \\in \\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) For each M' such that  <span class="math">IV \\xrightarrow{M&#x27;} h_{i-1} \\in \\mathcal{R}_{i-1}^*(M&#x27;)</span>  can be the empty string, in that case,  <span class="math">h_{i-1} = IV</span> ), deduce  <span class="math">m_i</span>  from  <span class="math">\\{h_{i-1}, k_i\\}</span> . If  <span class="math">\\exists M</span>  such that  <span class="math">g(M) = M&#x27; \\parallel m_i</span> , runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h&#x27;_i</span> . At the same time, we can deduce  <span class="math">h_i</span>  from  <span class="math">\\{h_{i-1}, m_i, c_i\\}</span>  for each PGV scheme.</li>
      <li>(b) If  <span class="math">h_i = h_i&#x27;</span> , S returns the corresponding plaintext which belongs to  <span class="math">\\{h_{i-1}, m_i, h_{i-1} \\oplus m_i\\}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> .</li>
      <li>(c) Else S randomly selects a message  <span class="math">h_{i-1} \\in \\{0,1\\}^n</span> , deduce  <span class="math">m_i, h_i</span>  from  <span class="math">\\{h_{i-1}, k_i, c_i\\}</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">h_{i-1}</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">By using Theorem 4 and Theorem 5 in [7], or Theorem 4.1 in [10], we can compute  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span> , where l is the maximum length of a query made by the distinguisher D.</p>

      <h3 id="app-b.5" class="text-xl font-semibold mt-8"><strong>B.5</strong> Proof of Lemma 1</h3>

    <p class="text-gray-300">The NMAC<sup> <span class="math">E_1,E_2</span> </sup> applies this compression function using the block cipher E1 to the input  <span class="math">m_1 \\parallel \\ldots \\parallel m_l</span>  to get the final output  <span class="math">h_l</span> , then applies another independent compression function using E2 to this output  <span class="math">h_l</span> . We can build the following simulator:</p>

    <h3 id="sec-misc-12" class="text-xl font-semibold mt-8"><strong>Simulator:</strong></h3>

    <h3 id="sec-misc-13" class="text-xl font-semibold mt-8">&bull; Query on S1:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(1, +, k_i, p_i)</span>  on S1 where  <span class="math">k_i = m_i</span>  and  <span class="math">p_i = h_{i-1}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} h_i \\in \\mathcal{R}_{i-1}</span> , then this is a repetition query. S returns  <span class="math">h_i</span> .</li>
      <li>(b) Else S randomly selects a hash value  <span class="math">h_i \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h_{i-1} \\xrightarrow{m_i} h_i\\}</span> , then returns  <span class="math">h_i</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the <em>i</em>-th query  <span class="math">(1, -, k_i, c_i)</span>  on S1 where  <span class="math">k_i = m_i</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{i-1} \\xrightarrow{m_i} (c_i) \\in \\mathcal{R}_{i-1}</span>  where j &lt; i, S returns  <span class="math">h_{i-1}</span> .</li>
      <li>(b) Else S randomly selects a message  <span class="math">h&#x27;_{i-1} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{R}_i = \\mathcal{R}_{i-1} \\cup \\{h&#x27;_{i-1} \\xrightarrow{m_i} c_i\\}</span> , then returns  <span class="math">h&#x27;_{i-1}</span> .</li>
    </ul></li>
    </ul>

    <h2 id="sec-misc-14" class="text-2xl font-bold">&bull; Query on S2:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the j-th query  <span class="math">(2, +, k_j, p_j)</span>  on S2 where  <span class="math">k_j = m_j</span>  and  <span class="math">p_j = h_{j-1}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{j-1} \\xrightarrow{m_j} h_j \\in \\mathcal{Q}_{j-1}</span> , then this is a repetition query. S2 returns  <span class="math">c_j = h_j</span> .</li>
      <li>(b) Else if  <span class="math">\\exists IV_1 \\xrightarrow{M} m_j \\in \\mathcal{R}_i^*</span>  and  <span class="math">p_j = IV_2</span> , S runs  <span class="math">\\mathcal{F}(M)</span>  and obtains the response  <span class="math">h_j</span> , updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = h_j</span> .</li>
      <li>(c) Else S randomly selects a hash value  <span class="math">h_j \\in \\{0,1\\}^n</span>  and updates  <span class="math">Q_j = Q_{i-1} \\cup \\{h_{j-1} \\xrightarrow{m_j} h_j\\}</span> , then returns  <span class="math">c_j = h_j</span> .</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For the j-th query  <span class="math">(2, -, k_j, c_j)</span>  on S2 where  <span class="math">k_j = m_j</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If  <span class="math">\\exists h_{k-1} \\xrightarrow{m_j} (c_j) \\in \\mathcal{Q}_{j-1}</span>  where k &lt; j, this is a repetition query, S returns  <span class="math">h_{k-1}</span> .</li>
      <li>(b) Else If  <span class="math">\\exists IV_1 \\xrightarrow{M} (k_j) \\in \\mathcal{R}_i^*</span>  then S runs  <span class="math">\\mathcal{F}(M)</span>  and gets h. If  <span class="math">h = c_j</span> , S updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{IV_2 \\xrightarrow{m_j} h\\}</span> , then returns  <span class="math">IV_2</span> .</li>
      <li>(c) Else S randomly selects a message  <span class="math">h&#x27;_{j-1} \\in \\{0,1\\}^n</span>  and updates  <span class="math">\\mathcal{Q}_j = \\mathcal{Q}_{j-1} \\cup \\{h&#x27;_{j-1} \\xrightarrow{m_j} c_j\\}</span> , then returns  <span class="math">h&#x27;_{j-1}</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">It is easy to show the distinguisher which was succeeding in the pf-MD will fail in the NMAC construction.  <span class="math">t_S = l \\cdot O(q^2)</span>  and  <span class="math">\\epsilon = 2^{-n} \\cdot l^2 \\cdot O(q^2)</span>  are calculated according the proof of Lemma A.8 in [10], where l is the maximum length of a query made by the distinguisher D.</p>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>C</strong> Tables</h2>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{h_{i-1}}(m_i) \\oplus m_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{h_{i-1}}(w_i) \\oplus m_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{m_i}(w_i) \\oplus v</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{h_{i-1}}(w_i) \\oplus w_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{m_i}(h_{i-1}) \\oplus v</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{m_i}(w_i) \\oplus m_i</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{h_{i-1}}(m_i) \\oplus w_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E_{m_i}(h_{i-1}) \\oplus m_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table C.1</strong> Eight differentiable PGV schemes with pf-MD.  <span class="math">w_i = h_{i-1} \\oplus m_i</span> , v is a constant.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Case</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">PGV</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(hi&minus;1)<br>&oplus;<br>hi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(mi)<br>&oplus;<br>mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(mi)<br>&oplus;<br>v</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(wi)<br>&oplus;<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(hi&minus;1)<br>&oplus;<br>hi&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(mi)<br>&oplus;<br>wi</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Emi<br>(hi&minus;1)<br>wi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(mi)<br>hi&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&oplus;<br>Ewi<br>(hi&minus;1)<br>v</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Emi<br>(wi)<br>&oplus;<br>hi&minus;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(hi&minus;1)<br>&oplus;<br>mi</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ewi<br>(hi&minus;1)<br>&oplus;<br>wi</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table C.2 Twelve Indifferentiable PGV schemes with pf-MD. w<sup>i</sup> = hi&minus;<sup>1</sup> &oplus; m<sup>i</sup> , v is a constant.</p>

    </section>
`;
---

<BaseLayout title="Revisiting the Indifferentiability of PGV Hash Functions (2009/265)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/265
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="revisiting-the-indifferentiability-of-pgv-hash-functions-2009" />
  </article>
</BaseLayout>
