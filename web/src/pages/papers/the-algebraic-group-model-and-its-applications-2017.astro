---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/620';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Algebraic Group Model and its Applications';
const AUTHORS_HTML = 'Georg Fuchsbauer, Eike Kiltz, Julian Loss';

const CONTENT = `    <p class="text-gray-300">Georg Fuchsbauer^{1} Eike Kiltz^{2} Julian Loss^{2} [ ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">One of the most important and successful tools for assessing hardness assumptions in cryptography is the Generic Group Model (GGM). Over the past two decades, numerous assumptions and protocols have been analyzed within this model. While a proof in the GGM can certainly provide some measure of confidence in an assumption, its scope is rather limited since it does not capture group-specific algorithms that make use of the representation of the group.</p>

    <p class="text-gray-300">To overcome this limitation, we propose the Algebraic Group Model (AGM), a model that lies in between the Standard Model and the GGM. It is the first restricted model of computation covering group-specific algorithms yet allowing to derive simple and meaningful security statements. To prove its usefulness, we show that several important assumptions, among them the Computational Diffie-Hellman, the Strong Diffie-Hellman, and the interactive LRSW assumptions, are equivalent to the Discrete Logarithm (DLog) assumption in the AGM. On the more practical side, we prove tight security reductions for two important schemes in the AGM to DLog or a variant thereof: the BLS signature scheme and Groth’s zero-knowledge SNARK (EUROCRYPT 2016), which is the most efficient SNARK for which only a proof in the GGM was known. Our proofs are quite simple and therefore less prone to subtle errors than those in the GGM.</p>

    <p class="text-gray-300">Moreover, in combination with known lower bounds on the Discrete Logarithm assumption in the GGM, our results can be used to derive lower bounds for all the above-mentioned results in the GGM.</p>

    <p class="text-gray-300">Keywords: Algebraic algorithms, generic group model, security reductions, cryptographic assumptions.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Starting with Nechaev <em>[x14]</em> and Shoup <em>[x16]</em>, much work has been devoted to studying the computational complexity of problems with respect to generic group algorithms over cyclic groups <em>[x1, x18, x17]</em>. At the highest level, generic group algorithms are algorithms that do not exploit any special structure of the representation of the group elements and can thus be applied in any cyclic group. More concretely, a generic algorithm may use only the abstract group operation and test whether two group elements are equal. This property makes it possible to prove information-theoretic lower bounds on the running time for generic algorithms.</p>

    <p class="text-gray-300">Such lower bounds are of great interest since for many important groups, in particular for elliptic curves, no helpful exploitation of the representation is currently known.</p>

    <p class="text-gray-300">The class of generic algorithms encompasses many important algorithms such as the baby-step giant-step algorithm and its generalization for composite-order groups (also known as Pohlig-Hellman algorithm <em>[x10]</em>) as well as Pollard’s rho algorithm <em>[x23]</em>. However, part of the common criticism against the generic group model is that many algorithms of practical interest are in fact not generic. Perhaps most notably, index-calculus and some factoring attacks fall outside the family of generic algorithms, as they are applicable only over groups in which the elements are represented as <em>integers</em>. Another example is the “trivial” discrete logarithm algorithm over the additive group <span class="math">\\mathbb{Z}_{p}</span>, which is the identity function.</p>

    <p class="text-gray-300">With this motivation in mind, a number of previous works considered extensions of the generic group model <em>[x20, x16, x1, x11]</em>. Jager and Rupp <em>[x11]</em> considered assumptions over groups equipped with a bilinear map <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\longrightarrow\\mathbb{G}_{3}</span>, where <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are modeled as generic groups, and <span class="math">\\mathbb{G}_{3}</span> is modeled in the Standard Model. (This is motivated by the fact that in all practical bilinear groups, <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are elliptic curves whereas <span class="math">\\mathbb{G}_{3}</span> is a sub-group of a finite field). However, none of these models so far capture algorithms that can freely exploit the representation of the group. In this work, we propose a restricted model of computation which does exactly this.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Algebraic Algorithms</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> be a cyclic group of prime order <span class="math">p</span>. Informally, we call an algorithm <span class="math">\\mathsf{A_{alg}}</span> <em>algebraic</em> if it fulfills the following requirement: whenever <span class="math">\\mathsf{A_{alg}}</span> outputs a group element <span class="math">\\mathbf{Z}\\in\\mathbb{G}</span>, it also outputs a “representation” <span class="math">\\vec{z}=(z_{1},\\ldots,z_{t})\\in\\mathbb{Z}_{p}^{t}</span> such that <span class="math">\\mathbf{Z}=\\prod_{i}\\mathbf{L}_{i}^{z_{i}}</span>, where <span class="math">\\vec{\\mathbf{L}}=(\\mathbf{L}_{1},\\ldots,\\mathbf{L}_{t})</span> is the list of all group elements that were given to <span class="math">\\mathsf{A_{alg}}</span> during its execution so far.</p>

    <p class="text-gray-300">Such algebraic algorithms were first considered by Boneh and Venkatesan <em>[x5]</em> in the context of straight-line programs computing polynomials over the ring of integers <span class="math">\\mathbb{Z}_{n}</span>, where <span class="math">n=pq</span>. Later, Paillier and Vergnaud <em>[x22]</em> gave a more formal and general definition of algebraic algorithms using the notion of an <em>extractor algorithm</em> which efficiently computes the representation <span class="math">\\vec{z}</span>.</p>

    <p class="text-gray-300">In our formalization of algebraic algorithms, we distinguish group elements from all other parameters at a <em>syntactical level</em>, that is, other parameters must not depend on any group elements. This is to rule out pathological exploits of the model, see below. While this class of algebraic algorithms certainly captures a much broader class of algorithms than the class of generic algorithms (e.g., index-calculus algorithms), it was first noted in <em>[x22]</em> that the class of algebraic algorithms actually <em>includes</em> the class of generic algorithms.</p>

    <p class="text-gray-300">Algebraic algorithms have mostly been studied so far in the context of proving <em>impossibility results</em> <em>[x5, x13, x22, x1, x12, x14, x15]</em>, i.e., to disprove the existence of an algebraic security reduction between two cryptographic primitives (with certain good parameters). Only quite recently, a small number of works have considered the idea of proving statements with respect to <em>algebraic adversaries</em> <em>[x1, x2]</em>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Algebraic Group Model</h3>

    <p class="text-gray-300">We propose the <em>algebraic group model</em> (AGM) — a computational model in which all adversaries are modeled as algebraic. In contrast to the GGM, the AGM does not allow for proving information-theoretic lower bounds on the complexity of an algebraic adversary. Similar to the Standard Model, in the AGM one proves security implications via reductions. Specifically, <span class="math">H\\Rightarrow_{\\mathsf{alg}}G</span> for two primitives <span class="math">H</span> and <span class="math">G</span> means that every algebraic adversary <span class="math">\\mathsf{A_{alg}}</span> against <span class="math">G</span> can be transformed into an algebraic adversary <span class="math">\\mathsf{B_{alg}}</span> against <span class="math">H</span> with (polynomially) related running</p>

    <p class="text-gray-300">times and success probabilities. It follows that if <span class="math">H</span> is secure against algebraic adversaries, so is <span class="math">G</span>. While algebraic adversaries have been considered before (see above), to the best of our knowledge, our work is the first to provide a clean and formal framework for security proofs with respect to algebraic adversaries. We elaborate further on our model below.</p>

    <p class="text-gray-300">Concrete Security Implications in the AGM. Indeed, one can exploit the algebraic nature of an adversary in the AGM to obtain stronger security implications than in the Standard Model. The first trivial observation is that the classical knowledge of exponent assumption <em>[x10]</em> holds by definition in the AGM.</p>

    <p class="text-gray-300">We are able to show that several important computational assumptions are in fact equivalent to the Discrete Logarithm assumption over prime-order groups in the AGM, including the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Diffie-Hellman assumption <em>[x13]</em></li>

      <li>(Interactive) strong Diffie-Hellman assumption <em>[x1]</em></li>

      <li>(Interactive) LRSW assumption <em>[x22, x12]</em>.</li>

    </ul>

    <p class="text-gray-300">The significance of the Strong Diffie-Hellman Assumption comes from its equivalence to the IND-CCA security of Hashed ElGamal encryption (also known as Diffie-Hellman Integrated Encryption Standard) in the random oracle model <em>[x1]</em>. The LSRW assumption (named after its authors <em>[x22]</em>) is of importance since it is equivalent to the (UF-CMA) security of Camenisch-Lysyanskaya (CL) signatures <em>[x12]</em>. CL signatures are a central building block for anonymous credentials <em>[x12, x3, x4]</em>, group signatures <em>[x12, x1]</em>, e-cash <em>[x6]</em>, unclonable functions <em>[CHK^{+}06]</em>, batch verification <em>[x7]</em>, and RFID encryption <em>[x2]</em>. Via our results, the security of all these schemes is implied by the discrete logarithm assumption in the AGM.</p>

    <p class="text-gray-300">Our result can be interpreted as follows. Every algorithm attacking one of the above-mentioned problems and schemes must solve the standard discrete logarithm problem directly, unless the algorithm relies on inherently non-algebraic operations. In particular, powerful techniques such as the index-calculus algorithms do not help in solving these problems any better then they do for solving the discrete logarithm problem directly.</p>

    <p class="text-gray-300">Moreover, we show the tight equivalence of the security of the following schemes to the underlying hardness assumptions in the AGM:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IND-CCA1 (aka lunchtime) security of the standard ElGamal Encryption to a parametrized variant of Decisional Diffie-Hellman assumption where in addition to <span class="math">g^{x},g^{y}</span> the adversary receives <span class="math">g^{x^{2}},\\ldots,g^{x^{q}}</span>, where <span class="math">q</span> is the maximal number of decryption queries.</li>

      <li>The UF-CMA security of the BLS signature scheme <em>[x5]</em> to the discrete logarithm problem in the random oracle model. Previous reductions non-tightly reduced from the CDH problem, with a tightness loss linear in the number of signing queries. This loss is known to be inherent <em>[x11, x21]</em>, even in the random oracle model.</li>

      <li>The security of the so far most efficient zero-knowledge SNARK scheme by Groth <em>[x16]</em> to a parametrized variant of the discrete logarithm problem, where in addition to <span class="math">g^{x}</span> the adversary receives <span class="math">g^{x^{2}},\\ldots,g^{x^{2n-1}}</span>, where <span class="math">n</span> is the degree of the quadratic arithmetic programs. The only previous proof of the security of this scheme is in the generic group model.</li>

    </ul>

    <p class="text-gray-300">Relation to the Generic Group Model. The AGM is stronger (in the sense that it puts more restrictions on the attackers) than the Standard Model, but weaker than the GGM. In spite of this, all of our reductions are purely generic algorithms. As mentioned above, any generic algorithm can be modeled within the AGM. In particular, combining arbitrary generic operations with algebraic ones will yield an algebraic algorithm. This suggests the following idea. Let <span class="math">H</span> and <span class="math">G</span> be two computational problems and let <span class="math">\\mathsf{A_{alg}}</span> be an algebraic algorithm that solves problem <span class="math">G</span>. If we can convert <span class="math">\\mathsf{A_{alg}}</span> by means of a generic reduction algorithm <span class="math">\\mathsf{R_{gen}}</span> into an algorithm <span class="math">\\mathsf{B_{alg}}</span> for problem <span class="math">H</span>, then clearly, <span class="math">\\mathsf{B_{alg}}</span> is also an algebraic algorithm. However, we obtain an even stronger statement for free: Namely, if <span class="math">\\mathsf{A_{gen}}</span> is a generic algorithm solving <span class="math">G</span>, then <span class="math">\\mathsf{B_{gen}}</span> is a generic algorithm solving <span class="math">H</span>. This means that results in the AGM directly carry over to the GGM.</p>

    <p class="text-gray-300">For this reason, we believe that our model offers an alternative, perhaps simpler method of proving the hardness of computational problems within the GGM. This applies in particular to interactive assumptions, which can be rather difficult to analyze in the GGM. For example, we prove that the discrete logarithm assumption implies the LRSW assumption in the AGM. As the discrete logarithm assumption holds in the GGM, we instantly obtain that the LRSW assumption holds in the GGM. The first (rigorous) proof of the LRSW assumption within the GGM was presented in the work of <em>[BFF^{+}14]</em> (the original work <em>[x10]</em> provided only a proof sketch), but was derived from a more general theorem and proven using an automated proof verification tool. We hope that our proof can offer some additional insight over the proof of <em>[BFF^{+}14]</em>. Another example is our tight equivalence of the IND-CCA1 security of ElGamal and our parametrized variant of the Decisional Diffie-Hellman (DDH) assumption in the algebraic group model. Together with the known generic <span class="math">\\sqrt{p/q}</span> attack on ElGamal <em>[x2]</em> for certain primes <span class="math">p</span> (see also <em>[x4]</em>), our result proves the tight generic bound <span class="math">\\tilde{\\Theta}(\\sqrt{p/q})</span> on the complexity of breaking IND-CCA1 security of ElGamal in the GGM.</p>

    <p class="text-gray-300">We also remark that proofs in the AGM have an inherently different interpretation than proofs in the GGM. To analyze the hardness of an assumption in the GGM, one must explicitly augment the model by any functionality that is offered by the structure of the group. As a simple example, let us consider a group <span class="math">\\mathbb{G}</span> which is equipped with a symmetric bilinear map <span class="math">e\\colon\\mathbb{G}\\times\\mathbb{G}\\longrightarrow\\mathbb{G}_{T}</span>. The bilinear map can be modeled in the GGM via an oracle. However, it is not clear whether <span class="math">e</span> can be used to gather even further information about the elements of <span class="math">\\mathbb{G}</span>. Though it is widely believed that this is not the case, a proof in the GGM provides no answer to this question, because the GGM itself is based on the conjecture that <span class="math">e</span> does not offer any functionality beyond a bilinear map. In contrast, the AGM captures any such exploit without the need of having to model it explicitly and considers the relation between two problems instead of their <em>individual hardness</em>. This means that if one can reduce <span class="math">H</span> to <span class="math">G</span> in the AGM and <span class="math">H</span> is conjectured to remain hard with respect to algebraic algorithms, even when given <span class="math">e</span>, then also <span class="math">G</span> remains hard. No similar statement can be inferred in the GGM. Thus, the AGM allows for a more fine grained assessment of the hardness of computational problems than the GGM.</p>

    <p class="text-gray-300">The gap between the two models becomes even more apparent if one considers structural properties of <span class="math">\\mathbb{G}</span> which cannot be meaningfully modeled as an oracle in the GGM. As an example, consider the Jacobi symbol, which was shown to be generically hard to compute in <em>[x11]</em>. Indeed, it was left as an open problem in <em>[x1]</em> to re-examine the equivalence of factoring and breaking the RSA assumption if an additional oracle for the Jacobi symbol were given. Though their results are stated in the <em>generic ring model</em> rather than the GGM, it seems they are similarly confronted with the issue of explicitly modeling such an oracle.</p>

    <p class="text-gray-300">Limitations of the AGM. As already noted, one of the main benefits of our model over the GGM is the ability to reason about algorithms that arbitrarily exploit the structure of</p>

    <p class="text-gray-300">the group. So which algorithms are not covered in this manner? Obviously, outputting an obliviously sampled group element (with unknown representation) is forbidden. This coincides with the GGM of Maurer <em>[x13]</em> and which also excludes the possibility of obliviously sampling a random group element. For this reason, our model is strictly weaker than the one from <em>[x13]</em> in the sense that any security reduction derived in Maurer’s GGM also holds in the AGM. In contrast, the GGM defined by Shoup <em>[x17]</em> does allow for such a sampling process. Similar to Maurer’s GGM, we can allow obliviously sampling a random group element <span class="math">\\mathbf{X}</span> through an additional oracle <span class="math">\\mathsf{O}()</span> that can be called during the execution of <span class="math">\\mathsf{A_{alg}}</span>. By definition, the outputs of <span class="math">\\mathsf{O}()</span> are added to the list <span class="math">\\mathbf{\\vec{L}}</span>. We have thus argued that both versions of the GGM (i.e., the ones by Maurer and Shoup) are strictly stronger than the AGM. Also note that simulating <span class="math">\\mathsf{O}()</span> to <span class="math">\\mathsf{A_{alg}}</span> as part of a reduction is straight-forward and always possible; the reduction simply samples <span class="math">r</span> and returns <span class="math">g^{r}</span> to the adversary. As the reduction knows <span class="math">r</span>, adding <span class="math">\\mathsf{O}()</span> to an experiment does not change it and is completely without loss of generality. From a practical point of view, it seems that generating and outputting a random group element without knowing a representation is generally not of much help. We therefore believe that the AGM captures most algorithms of practical interest.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Related Work and Open Questions</h3>

    <p class="text-gray-300">We have already mentioned the semi generic group model (SGGM) <em>[x11]</em> as related work, but we discuss here some key differences of their model to ours in more detail. First, the SGGM is a very restrictive model in the sense that the class of problems it captures is limited. The main theorem of <em>[x11]</em> (Theorem 3) holds only for pairing-based computational problems in which the output consists of a single element in either one of the base groups. In contrast, the AGM does not require a pairing group setting and thus applies to a much broader class of computational problems. Second, by extending the AGM to pairing groups, we are able to model all three groups as algebraic and reason again about a broader class of problems, in which the output can also consist of elements in the target group. To extend the AGM to the pairing setting, we allow the algebraic adversary to compute any element in the target group by applying the pairing to elements in the respective base groups.</p>

    <p class="text-gray-300">Dent <em>[x6]</em> shows that the generic group model as proposed Shoup <em>[x17]</em> inherits the known weaknesses in the random oracle model <em>[x10]</em>. Thus, there exist schemes which can be proven secure in Shoup’s GGM, but are pathologically insecure when viewed in the standard model. An interesting open question is whether the AGM bears similar weaknesses. A promising line of research related to this question has recently been initiated by Bitansky et al. <em>[x2]</em>. Namely, they show that indistinguishability obfuscation (iO) implies the existence of non-extractable one-way functions. If these non-extractable one-way functions were furthermore algebraic (such as the knowledge of exponent assumption <em>[x7]</em>), then this would invalidate the AGM (under the assumption that iO exists).</p>

    <p class="text-gray-300">Another promising direction for future research is to prove further reductions between common computational assumptions in the AGM. In particular, it would be interesting to classify different such assumptions within the AGM, for example along the lines of work <em>[x15, x12, x5, x9, x1, x16]</em>.</p>

    <p class="text-gray-300">At a technical level, the main difficulty in this task arises from the fact that an algorithm, i.e., distinguisher, in a decisional problem is asked to output a bit rather than a group element. Therefore, such an algorithm is trivially considered algebraic in our framework. It would therefore be interesting to develop a model which captures the algebraic properties of such algorithms in more detail.</p>

    <p class="text-gray-300">A further potential for follow-up work would be to investigate whether it is possible to</p>

    <p class="text-gray-300">automate proofs in the AGM. Indeed, for the case of the GGM this has been considered in <em>[BFF^{+}14, x1]</em> and it would be interesting to see if similar automated tools can be derived for the AGM.</p>

    <p class="text-gray-300">Finally, we remark that all of our results require prime-order groups and do not yet extend to the setting of pairing groups. When generalizing our results to composite-order groups, we expect to encounter the following technical difficulty: Given, e.g., an equation of the form <span class="math">ax\\equiv_{n}b</span>, where <span class="math">n</span> is composite, there might be (exponentially) many solutions for the unknown <span class="math">x</span> in case <span class="math">\\mathsf{gcd}(a,n)&gt;1</span>. This interferes with the proof strategies presented in this work and requires a more involved analysis. In fact, proving a reduction from the discrete logarithm problem to the CDH problem in the AGM for group orders containing multiple prime factors (eg, <span class="math">n=p^{2}</span>) is excluded by <em>[x10]</em>. Hardness bounds in the GGM for composite-order groups have been considered in <em>[x15, x11, x12]</em>. Generalizing the GGM to pairing groups has been the subject, e.g., of the works of <em>[x3, x14, RLB^{+}08]</em>. Extending the AGM to either one of these regimes is an interesting line of research for future work.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Algebraic Algorithms</h2>

    <p class="text-gray-300">Algorithms. We denote by <span class="math">s\\not\\leftrightarrows S</span> the uniform sampling of the variable <span class="math">s</span> from the (finite) set <span class="math">S</span>. All our algorithms are probabilistic (unless stated otherwise) and written in uppercase letters <span class="math">\\mathsf{A},\\mathsf{B}</span>. To indicate that algorithm <span class="math">\\mathsf{A}</span> runs on some inputs <span class="math">(x_{1},\\ldots,x_{n})</span> and returns <span class="math">y</span>, we write <span class="math">y\\not\\leftrightarrows\\mathsf{A}(x_{1},\\ldots,x_{n})</span>. If <span class="math">\\mathsf{A}</span> has access to an algorithm <span class="math">\\mathsf{B}</span> (via oracle access) during its execution, we write <span class="math">y\\not\\leftrightarrows\\mathsf{A}^{\\mathsf{B}}(x_{1},\\ldots,x_{n})</span>.</p>

    <p class="text-gray-300">Security games. We use a variant of (code-based) <em>security games</em> <em>[x2]</em>. In game <span class="math">\\mathbf{G}_{par}</span> (defined relative to a set of parameters <span class="math">par</span>), an adversary <span class="math">\\mathsf{A}</span> interacts with a challenger that answers oracle queries issued by <span class="math">\\mathsf{A}</span>. It has a main procedure and (possibly zero) oracle procedures which describe how oracle queries are answered. We denote the output of a game <span class="math">\\mathbf{G}_{par}</span> between a challenger and an adversary <span class="math">\\mathsf{A}</span> via <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span>. <span class="math">\\mathsf{A}</span> is said to <em>win</em> if <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}=1.</span> We define the <em>advantage</em> of <span class="math">\\mathsf{A}</span> in <span class="math">\\mathbf{G}_{par}</span> as <span class="math">\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}}:=\\Pr\\left[\\mathbf{G}_{par}^{\\mathsf{A}}=1\\right]</span> and the running time of <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span> as <span class="math">\\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}</span>.</p>

    <p class="text-gray-300">Security Reductions. Let <span class="math">\\mathbf{G},\\mathbf{H}</span> be security games. We write <span class="math">\\mathbf{H}_{par}\\stackrel{{\\scriptstyle(\\Delta_{c},\\Delta_{t})}}{{\\Longrightarrow}}\\mathbf{G}_{par}</span> if there exists an algorithm <span class="math">\\mathsf{R}</span> (called <span class="math">(\\Delta_{\\varepsilon},\\Delta_{t})</span>-reduction) such that for all algorithms <span class="math">\\mathsf{A}</span>, algorithm <span class="math">\\mathsf{B}</span> defined as <span class="math">\\mathsf{B}:=\\mathsf{R}^{\\mathsf{A}}</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{par,\\mathsf{B}}^{\\mathbf{H}}\\geq\\frac{1}{\\Delta_{\\varepsilon}}\\cdot\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}},\\quad\\mathbf{Time}_{par,\\mathsf{B}}^{\\mathbf{H}}\\leq\\Delta_{t}\\cdot\\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}.</span></p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Algebraic Security Games and Algorithms</h3>

    <p class="text-gray-300">We consider <em>algebraic security games</em> <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> for which we set <span class="math">par</span> to a fixed group description <span class="math">\\mathcal{G}=(\\mathbb{G},g,p)</span>, where <span class="math">\\mathbb{G}</span> is a cyclic group of prime order <span class="math">p</span> generated by <span class="math">g</span>. In algebraic security games, we syntactically distinguish between elements of group <span class="math">\\mathbb{G}</span> (written in bold, uppercase letters, e.g., <span class="math">\\mathbf{A}</span>) and all other elements, which must not depend on any group elements. As an example of an algebraic security game, consider the Computational Diffie-Hellman game <span class="math">\\mathbf{cdh}_{\\mathcal{G}}^{\\mathsf{A}}</span>, depicted in Figure 1 (left).</p>

    <p class="text-gray-300">We now define algebraic algorithms. Intuitively, the only way for an algebraic algorithm to output a new group element <span class="math">\\mathbf{Z}</span> is to derive it via group multiplications from known group elements.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.1 (Algebraic algorithm)</h6>

    <p class="text-gray-300">An algorithm <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> executed in an algebraic game <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> is called <em>algebraic</em> if for all group elements <span class="math">\\mathbf{Z}</span> that <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> outputs (i.e., the elements in bold uppercase</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cdhA G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cdhAalg G</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x,y←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">00 x,y←Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 (X,Y) := (gx,gy)</td>

            <td class="px-3 py-2 border-b border-gray-700">01 (X,Y) := (gx,gy)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Z←A(X,Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">02 [Z]z←Aalg(X,Y)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Return (Z = gxy)</td>

            <td class="px-3 py-2 border-b border-gray-700">03 Return (Z = gxy)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Left: Algebraic game cdh relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and adversary A. All group elements are written in bold, uppercase letters. Right: Algebraic game cdh relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and algebraic adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> . The algebraic adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  additionally returns a representation  <span class="math">\\vec{z} = (a, b, c)</span>  of  <span class="math">\\mathbf{Z}</span>  such that  <span class="math">\\mathbf{Z} = g^{a}\\mathbf{X}^{b}\\mathbf{Y}^{c}</span> .</p>

    <p class="text-gray-300">letters), it additionally provides the representation of  <span class="math">\\mathbf{Z}</span>  relative to all previously received group elements. That is, if  <span class="math">\\vec{\\mathbf{L}}</span>  is the list of group elements  <span class="math">\\mathbf{L}_0,\\ldots ,\\mathbf{L}_m\\in \\mathbb{G}</span>  that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  has received so far (w.l.o.g.  <span class="math">\\mathbf{L}_0 = g</span> ), then  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  must also provide a vector  <span class="math">\\vec{z}</span>  such that  <span class="math">\\mathbf{Z} = \\prod_{i}\\mathbf{L}_{i}^{z_{i}}</span> . We denote such an output as  <span class="math">[\\mathbf{Z}]_{\\vec{z}}</span> .</p>

    <p class="text-gray-300">REMARKS ON OUR MODEL. Algebraic algorithms were first considered in [BV98, PV05], where they are defined using an additional extractor algorithm which computes for an output group element a representation in basis  <span class="math">\\vec{\\mathbf{L}}</span> . We believe that our definition gives a simpler and cleaner definition of algebraic algorithms. If one assumes that the extractor algorithm has constant running time, then our definition is easily seen to be equivalent to theirs. Indeed, this view makes sense for algorithms in the GGM since the representation  <span class="math">\\vec{z}</span>  trivially follows from the description of the algorithm. However, if running the extractor algorithm imposes some additional cost, then this will clearly affect the running times of our reductions. If the cost of the extractor is similar to that of the solver adversary, then reductions in our model that neither call an algebraic solver multiple times nor receive from it a non-constant amount of group elements (along with their representations) will remain largely the same in both models.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the inputs to algebraic adversaries we syntactically distinguish group elements from other inputs and require that the latter not depend on any group elements. This is necessary to rule out pathological cases in which an algorithm receives "disguised" group elements and is forced to output an algebraic representation of them (which it might not know). To illustrate the issue, consider an efficient algorithm  <span class="math">\\mathsf{A}</span> , which on input  $X' := \\mathbf{X} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bot<span class="math">  returns  </span>\\mathbf{X}<span class="math"> , where  </span>\\mathbf{X}<span class="math">  is a group element, but  </span>X'<span class="math">  is not. If  </span>\\mathsf{A}<span class="math">  is algebraic then it must return a representation of  </span>\\mathbf{X}<span class="math">  in  </span>g<span class="math">  (the only group element previously seen), which would be the discrete logarithm of  </span>\\mathbf{X}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Allowing inputs of form  <span class="math">X&#x27;</span>  while requiring algorithms to be algebraic leads to contradictions. (E.g., one could use  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  to compute discrete logarithms: given a challenge  <span class="math">\\mathbf{X} = g^x</span> , run  $[\\mathbf{X}]_x \\stackrel{\\mathrm{a}}{\\leftarrow} \\mathsf{A}_{\\mathrm{alg}}(\\mathbf{X} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bot)<span class="math">  and return  </span>x<span class="math"> .) We therefore demand that non-group-element inputs must not depend on group elements. (Note that if  </span>\\mathsf{A}_{\\mathrm{alg}}<span class="math"> &#x27;s input contains  </span>\\mathbf{X}<span class="math">  explicitly then it can output  </span>[\\mathbf{X}]_{(0,1)}<span class="math">  with a valid representation of  </span>\\mathbf{X}<span class="math">  relative to  </span>\\vec{\\mathbf{L}} = (g, \\mathbf{X})$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we slightly abuse notation and let an algebraic algorithm also represent output group elements as combinations of previous outputs. This makes some of our proofs easier and is justified since all previous outputs must themselves have been given along with an according representation. Therefore, one can always recompute a representation that depends only on the initial inputs to the algebraic algorithm.</p>

    <p class="text-gray-300">INTEGRATING WITH RANDOM ORACLES IN THE AGM. As mentioned above, an algorithm  <span class="math">\\mathsf{A}</span>  that samples (and outputs) a group element  <span class="math">\\mathbf{X}</span>  obliviously, i.e., without knowing its representation, is not algebraic. This appears to be problematic if one wishes to combine the AGM with the Random Oracle Model [BR93]. However, group elements output by the random oracle are</p>

    <p class="text-gray-300">included by definition in the list <span class="math">\\vec{\\mathbf{L}}</span>. This means that for any such element, a representation is trivially available to <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Generic Security Games and Algorithms</h3>

    <p class="text-gray-300">Generic algorithms <span class="math">\\mathsf{A}_{\\mathsf{gen}}</span> are only allowed to use generic properties of group <span class="math">\\mathcal{G}</span>. Informally, an algorithm is generic if it works regardless of what group it is run in. This is usually modeled by giving an algorithm indirect access to group elements via abstract handles. It is straight-forward to translate all of our algebraic games into games that are syntactically compatible with generic algorithms accessing group elements only via abstract handles.</p>

    <p class="text-gray-300">We say that winning algebraic game <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> is <span class="math">(\\varepsilon,t)</span>-hard in the generic group model if for every generic algorithm <span class="math">\\mathsf{A}_{\\mathsf{gen}}</span> it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Time}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}}\\leq t\\implies\\mathbf{Adv}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}}\\leq\\varepsilon.</span></p>

    <p class="text-gray-300">We remark that usually in the generic group model one considers group operations (i.e., oracle calls) instead of the running time. In our context it is more convenient to measure the running time instead, assuming every oracle call takes one unit time.</p>

    <p class="text-gray-300">As an important example, consider the algebraic Discrete Logarithm Game <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span> in Figure 2 which is <span class="math">(t^{2}/p,t)</span>-hard in the generic group model <em>[x20, x16]</em>.</p>

    <p class="text-gray-300">We assume that a generic algorithm <span class="math">\\mathsf{A}_{\\mathsf{gen}}</span> additionally provides the representation of <span class="math">\\mathbf{Z}</span> relative to all previously received group elements, for all group elements <span class="math">\\mathbf{Z}</span> that it outputs. This assumption is w.l.o.g. since a generic algorithm can only obtain new group elements by multiplying two known group elements; hence it always knows a valid representation. This way, every generic algorithm is also an algebraic algorithm.</p>

    <p class="text-gray-300">Furthermore, if <span class="math">\\mathsf{B}_{\\mathsf{gen}}</span> is a generic algorithm and <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is an algebraic algorithm, then <span class="math">\\mathsf{B}_{\\mathsf{alg}}:=\\mathsf{B}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> is also is an algebraic algorithm. We refer to <em>[x16]</em> for more on generic algorithms.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.3 Generic Reductions Between Algebraic Security Games</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> and <span class="math">\\mathbf{H}_{\\mathcal{G}}</span> be two algebraic security games. We write <span class="math">\\mathbf{H}_{\\mathcal{G}}\\stackrel{{\\scriptstyle(\\Delta_{i},\\Delta_{t})}}{{\\Longrightarrow}}\\mathbf{G}_{\\mathcal{G}}</span> if there exists a generic algorithm <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span> (called generic <span class="math">(\\Delta_{\\varepsilon},\\Delta_{t})</span>-reduction) such that for every algebraic algorithm <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>, algorithm <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> defined as <span class="math">\\mathsf{B}_{\\mathsf{alg}}:=\\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> satisfies</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\mathcal{U},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}}\\geq\\frac{1}{\\Delta_{\\varepsilon}}\\cdot\\mathbf{Adv}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}},\\quad\\mathbf{Time}_{\\mathcal{U},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}}\\leq\\Delta_{t}\\cdot\\mathbf{Time}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span></p>

    <p class="text-gray-300">Note that we deliberately require reduction <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span> to be generic. Hence, if <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is algebraic, then <span class="math">\\mathsf{B}_{\\mathsf{alg}}:=\\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> is algebraic; if <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is generic, then <span class="math">\\mathsf{B}_{\\mathsf{alg}}:=\\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> is generic. If one is only interested in algebraic adversaries, then it suffices to require reduction <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span> to be algebraic. But in that case one can no longer infer that <span class="math">\\mathsf{B}_{\\mathsf{alg}}:=\\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> is generic in case <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is generic.</p>

    <p class="text-gray-300">Composing information-theoretic lower bounds with reductions in the AGM. The following lemma explains how statements in the AGM carry over to the GGM.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 2.2</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> and <span class="math">\\mathbf{H}_{\\mathcal{G}}</span> be algebraic security games such that <span class="math">\\mathbf{H}_{\\mathcal{G}}\\stackrel{{\\scriptstyle(\\Delta_{i},\\Delta_{t})}}{{\\Longrightarrow}}\\mathbf{G}_{\\mathcal{G}}</span> and winning <span class="math">\\mathbf{H}_{\\mathcal{G}}</span> is <span class="math">(\\varepsilon,t)</span>-hard in the GGM. Then, <span class="math">\\mathbf{G}_{\\mathcal{G}}</span> is <span class="math">(\\varepsilon\\cdot\\Delta_{\\varepsilon},t/\\Delta_{t})</span>-hard in the GGM.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{A}_{\\mathsf{gen}}</span> be a generic algorithm playing in game <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>. Then by our premise there exists a generic algorithm <span class="math">\\mathsf{B}_{\\mathsf{alg}}=\\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}_{\\mathcal{U},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}}\\geq\\frac{1}{\\Delta_{\\varepsilon}}\\cdot\\mathbf{Adv}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}},\\quad\\mathbf{Time}_{\\mathcal{U},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}}\\leq\\Delta_{t}\\cdot\\mathbf{Time}_{\\mathcal{U},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">dlogA G 00 x←Zp 01 X := gx 02 z←A(X) 03 Return (z=x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lc-dhA G 00 x,y←Zp 01 (X,Y) := (gx,gy) 02 (Z,u,v,w)←A(X,Y) 03 Return (Z=gux2+vxy+wy2 ∧ (u≠0 ∨ v≠0 ∨ w≠0))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sq-dhA G 00 x←Zp 01 X := gx 02 Z←A(X) 03 Return (Z=gx2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Discrete Logarithm Game dlog, Square Diffie-Hellman Game sq-dh, and Linear Combination Diffie-Hellman Game lc-dh relative to group  <span class="math">\\mathcal{G}</span>  and adversary A. Figure 3: Algebraic adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  playing in  <span class="math">\\mathbf{sq - dh}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Assume  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G}}\\leq t / \\Delta_t</span>  ; then  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathrm{alg}}}^{\\mathbf{H}}\\leq \\Delta_t\\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G}}\\leq t</span>  . Since winning  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon ,t)</span>  -hard in the GGM, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon \\geq \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {B a l g}} ^ {\\mathbf {H}} \\geq \\frac {1}{\\Delta_ {\\varepsilon}} \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {A a l g}} ^ {\\mathbf {G}}</span></div>

    <p class="text-gray-300">and thus  <span class="math">\\varepsilon \\cdot \\Delta_{\\varepsilon} \\geq \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G}}</span> , which proves that  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon \\Delta_{\\varepsilon}, t / \\Delta_t)</span> -hard in the GGM.</p>

    <p class="text-gray-300">In this section we consider some variants of the standard Diffie-Hellman assumption [DH76] and prove them to be equivalent to the discrete logarithm assumption (defined via algebraic game  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}}</span>  of Figure 2) in the Algebraic Group Model.</p>

    <p class="text-gray-300">Consider the Square Diffie-Hellman Assumption [MW99] described in algebraic game  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  and the Linear Combination Diffie-Hellman Assumption described in algebraic game  <span class="math">\\mathbf{lc} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  (both in Figure 2), which will be convenient for the proof of Theorem 3.3.</p>

    <p class="text-gray-300">As a warm-up we now prove that the Discrete Logarithm assumption is tightly equivalent to the Diffie-Hellman, the Square Diffie-Hellman, and the Linear Combination Diffie-Hellman Assumption in the Algebraic Group Model. The equivalence of the Square Diffie-Hellman and Diffie-Hellman problems was previously proven in [MW99, BDZ03].</p>

    <p class="text-gray-300">Theorem 3.1  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}}\\stackrel {(1,1)}{\\Longrightarrow}_{\\mathrm{alg}}\\{\\mathbf{cdh}_{\\mathcal{G}},\\mathbf{sq}\\cdot \\mathbf{dh}_{\\mathcal{G}}\\}</span>  and  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}}\\stackrel {(3,1)}{\\Longrightarrow}_{\\mathrm{alg}}\\mathbf{lc}\\cdot \\mathbf{dh}_{\\mathcal{G}}</span></p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary executed in game  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span> ; cf. Figure 3.</p>

    <p class="text-gray-300">As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is an algebraic adversary, it returns a solution  <span class="math">\\mathbf{Z}</span>  together with a representation  <span class="math">(a,b)\\in \\mathbb{Z}_p^2</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {Z} = g ^ {x ^ {2}} = g ^ {a} \\left(g ^ {x}\\right) ^ {b}. \\tag {1}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sdhA 00 x,y←Zp 01 (X,Y) := (g^x,gy) 02 Z←A O(·,·)(X,Y) 03 Return (Z = gxy)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(Y',Z') 04 Return (Z' = (Y')^x)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Strong Diffie-Hellman Game sdh relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now show how to construct a generic reduction  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  that calls  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  exactly once such that for  <span class="math">\\mathsf{B}_{\\mathrm{alg}} := \\mathsf{R}_{\\mathrm{gen}}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {d l o g}} = \\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {s q - d h}}.</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  works as follows. On input a discrete logarithm instance  <span class="math">\\mathbf{X}</span> , it runs  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  on  <span class="math">\\mathbf{X}</span> . Suppose  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is successful. Equation (1) is equivalent to the quadratic equation  <span class="math">x^{2} - bx - a \\equiv_{p} 0</span>  with at most two solutions in  <span class="math">x</span> . (In general such equations are not guaranteed to have a solution but since the representation is valid and  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is assumed to be correct, there exists at least one solution for  <span class="math">x</span> .)  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  can test which one (out of the two) is the correct solution  <span class="math">x</span>  by testing against  <span class="math">\\mathbf{X} = g^{x}</span> . Moreover, it is easy to see that  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  only performs generic group operations and is therefore generic. Hence,  <span class="math">\\mathsf{B}_{\\mathrm{alg}} := \\mathsf{R}_{\\mathrm{gen}}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  is algebraic, which proves</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {d l o g} _ {\\mathcal {G}} \\xrightarrow {(1 , 1)} _ {\\text {a l g}} \\mathbf {s q} \\cdot \\mathbf {d h} _ {\\mathcal {G}}.</span></div>

    <p class="text-gray-300">The statement  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}} \\xrightarrow{(1,1)} \\mathbf{cdh}_{\\mathcal{G}}</span>  follows, since given an adversary against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  (see Figure 1), we can easily construct an adversary against  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  that runs in the same time and has the same probability of success (given  <span class="math">\\mathbf{X} = g^{x}</span> , sample  <span class="math">r \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_{p}</span> , run the  <span class="math">\\mathbf{cdh}</span>  adversary on  <span class="math">(\\mathbf{X}, \\mathbf{X}^{r})</span> , obtain  <span class="math">\\mathbf{Z}</span>  and return  <span class="math">\\mathbf{Z}^{\\frac{1}{r}}</span> ).</p>

    <p class="text-gray-300">It remains to show that  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}} \\stackrel{(3,1)}{\\Longrightarrow}_{\\mathrm{alg}} \\mathbf{lc} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span> . Given an algebraic solver  <span class="math">C_{\\mathrm{alg}}</span>  executed in game  <span class="math">\\mathbf{lc} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span> , we construct an adversary  <span class="math">A_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  as follows: On input  <span class="math">\\mathbf{X} = g^{x}</span> ,  <span class="math">A_{\\mathrm{alg}}</span>  samples  <span class="math">r \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_{p}</span>  and computes either  <span class="math">(\\mathbf{X}, g^{r})</span> ,  <span class="math">(g^{r}, \\mathbf{X})</span> , or  <span class="math">(\\mathbf{X}, \\mathbf{X}^{r})</span>  each with probability  <span class="math">1/3</span> . Note that this instance is correctly distributed. It then runs  <span class="math">C_{\\mathrm{alg}}</span>  on the resulting tuple  <span class="math">(\\mathbf{X}_{1}, \\mathbf{X}_{2})</span>  and receives  <span class="math">(\\mathbf{Z}, u, v, w)</span>  together with  <span class="math">(a, b, c)</span>  s.t.  <span class="math">\\mathbf{Z} = g^{a} \\mathbf{X}_{1}^{b} \\mathbf{X}_{2}^{c}</span> . If  <span class="math">u \\neq 0</span> , then the choice  <span class="math">\\mathbf{X}_{1} = \\mathbf{X}</span> ,  <span class="math">\\mathbf{X}_{2} = g^{r}</span>  yields  <span class="math">\\mathbf{Z} = g^{ux^{2} + vxr + wr^{2}}</span> , from which  <span class="math">g^{x^{2}}</span>  can be computed as  <span class="math">g^{x^{2}} = (\\mathbf{Z} \\mathbf{X}^{-vr} g^{-wr^{2}})^{\\frac{1}{n}}</span> . Clearly,  <span class="math">A_{\\mathrm{alg}}</span>  is able to compute an algebraic representation of  <span class="math">g^{x^{2}}</span>  from the values  <span class="math">(a, b, c)</span>  and thus is algebraic itself. The cases  <span class="math">v \\neq 0, w \\neq 0</span>  follow in a similar fashion.</p>

    <p class="text-gray-300">Corollary 3.2  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  and  <span class="math">\\mathbf{sq} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  are  <span class="math">(t^2 / p, t)</span> -hard in the generic group model and  <span class="math">\\mathbf{lc} \\cdot \\mathbf{dh}_{\\mathcal{G}}</span>  is  <span class="math">(3t^2 / p, t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">For the subsequent sections and proofs, we will not make explicit the reduction algorithm  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  every time (as done above).</p>

    <p class="text-gray-300">Consider the Strong Diffie-Hellman Assumption [ABR01] described via game  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  in Figure 4. We now prove that the Discrete Logarithm Assumption (non-tightly) implies the Strong Diffie-Hellman Assumption in the Algebraic Group Model. We briefly present the main ideas of the proof. The full proof of Theorem 3.3 can be found in Appendix A.1. Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^{z}</span>  denote the Discrete Logarithm challenge. We show an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  that simulates  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> .  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  appropriately answers</p>

    <p class="text-gray-300"><span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  's queries to the oracle  <span class="math">\\mathsf{O}(\\cdot ,\\cdot)</span>  by using the algebraic representation of the queried elements provided by  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> . Namely, when  <span class="math">(\\mathbf{Y}^{\\prime},\\mathbf{Z}^{\\prime})</span>  is asked to the oracle,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  obtains vectors  <span class="math">\\vec{b},\\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}\\mathbf{X}^{b_2}\\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1}\\mathbf{X}^{c_2}\\mathbf{Y}^{c_3}</span> . As long as  <span class="math">b_{2} = b_{3} = 0</span> ,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  can answer all of  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  's queries by checking whether  <span class="math">\\mathbf{X}^{b_1} = \\mathbf{Z}&#x27;</span> . On the other hand, if  <span class="math">b_{2}\\neq 0</span>  or  <span class="math">b_{3}\\neq 0</span> , then  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  simply returns 0. Informally, the simulation will be perfect unless  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  manages to compute a valid solution to  <span class="math">\\mathbf{lc - dh}_{\\mathcal{G}}</span> . All of these games can be efficiently simulated by  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span> , as we have shown in the previous section.</p>

    <p class="text-gray-300">Theorem 3.3  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}} \\stackrel{(4q,1)}{\\Longrightarrow}_{\\mathrm{alg}} \\mathbf{s}\\mathbf{d}\\mathbf{h}_{\\mathcal{G}}</span> , where  <span class="math">q</span>  is the maximum number of queries to oracle  <span class="math">\\mathsf{O}(\\cdot, \\cdot)</span>  in  <span class="math">\\mathbf{s}\\mathbf{d}\\mathbf{h}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 3.4  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  is  <span class="math">(\\frac{t^2}{4pq}, t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The interactive LRSW assumption [LRSW99, CL04] is defined via the algebraic security game  <span class="math">\\mathbf{lrsw}</span>  in Figure 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">lrswA 00 Q := ∅ 01 x, y ← Zp 02 X := g^x, Y := g^y 03 (m<em>, A</em>, B<em>, C</em>) ← A O(·)(X, Y) 04 Return (m<em>∉ Q ∧ m</em> ≠ 0 ∧ A<em> ≠ 1 ∧ B</em> = (A<em>)^y ∧ C</em> = (A<em>)^m</em>xy+x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(mj) //For query j 05 rj ← Zp; 06 Aj := g^rj 07 Bj := g^rjy 08 Cj := g^rjmjxy+rjx 09 Q := Q ∪ {mj} 10 Return (Aj, Bj, Cj)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: Game lrsw relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now prove that the LRSW assumption is (non-tightly) implied by the Discrete Logarithm Assumption in the Algebraic Group Model. We give a high-level sketch of the main ideas here and defer the full proof of Theorem 4.1 to Appendix A.2. Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^{z}</span>  denote the Discrete Logarithm challenge. We construct an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span> , which simulate  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  by embedding the value of  <span class="math">z</span>  in one of three possible ways. Namely, it either sets  <span class="math">\\mathbf{X} := \\mathbf{Z}</span>  or  <span class="math">\\mathbf{Y} := \\mathbf{Z}</span> , or it chooses a random the query by  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  to the oracle  <span class="math">\\mathsf{O}(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to embed the value of  <span class="math">z</span> . These behaviours correspond in our proof to the adversaries  <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}</span> , and  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span> , respectively. After obtaining a solution  <span class="math">(m^{<em>}, [\\mathbf{A}^{</em>}]_{\\vec{a}}, [\\mathbf{B}^{<em>}]_{\\vec{b}}, [\\mathbf{C}^{</em>}]_{\\vec{c}})</span>  on a fresh value  <span class="math">m^{<em>} \\neq 0</span>  from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> , the adversaries use the algebraic representations  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  obtained from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  to suitably rewrite the values of  <span class="math">\\mathbf{A}^{</em>}, \\mathbf{C}^{<em>}</span>  (Lemma A.1). They then make use of the relation  <span class="math">(\\mathbf{A}^{</em>})^{(xm^{<em>}y + x)} = \\mathbf{C}^{</em>}</span>  to obtain an equation mod  <span class="math">p</span> , which in turn gives  <span class="math">z</span> .</p>

    <p class="text-gray-300">Theorem 4.1  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}} \\stackrel{(6q,1)}{\\Longrightarrow}_{\\mathrm{alg}} \\mathbf{lrsw}_{\\mathcal{G}}</span> , where  <span class="math">q \\geq 6</span>  is the maximum number of queries to  <span class="math">\\mathsf{O}(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 4.2  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  is  <span class="math">(t, \\frac{t^2}{6pq})</span> -hard in the generic group model.</p>

    <p class="text-gray-300">In this section we prove that the IND-CCA1 (aka. lunchtime security) of the ElGamal encryption scheme (in its abstraction as a KEM) is implied by a parametrized (" <span class="math">q</span> -type") variant of the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ind-cca1A KEM,par,b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dec(C)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc() //One time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 (pk,sk)←Gen(par)</td>

            <td class="px-3 py-2 border-b border-gray-700">//Before Enc is called</td>

            <td class="px-3 py-2 border-b border-gray-700">05 (Kb<em>,C</em>)←Enc(pk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 b'←A Dec,Enc(pk)</td>

            <td class="px-3 py-2 border-b border-gray-700">03 K←Dec(C,sk)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Kb*←K</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return b'</td>

            <td class="px-3 py-2 border-b border-gray-700">04 Return K</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Return (Kb<em>,C</em>)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Decision Diffie-Hellman Assumption in the Algebraic Group Model.</p>

    <p class="text-gray-300">ADVANTAGE FOR DECISIONAL ALGEBRAIC SECURITY GAMES. We parameterize a decisional algebraic game  <span class="math">\\mathbf{G}</span>  (such as the game in Figure 7) with a parameter bit  <span class="math">b</span> . We define the advantage of adversary  <span class="math">\\mathsf{A}</span>  in  <span class="math">\\mathbf{G}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A d v} _ {p a r, \\mathsf {A}} ^ {\\mathbf {G}} :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathbf {G} _ {p a r, 0} ^ {\\mathsf {A}} = 1 ] - \\Pr [ \\mathbf {G} _ {p a r, 1} ^ {\\mathsf {A}} = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We define  <span class="math">\\mathbf{Time}_{par,\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G}}</span>  independently of the parameter bit  <span class="math">b</span> , i.e., we consider only the worst-case running time of  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  in either game. In order to cover games that define the security of schemes (rather than assumptions), instead of  <span class="math">par = \\mathcal{G}</span> , we only require that  <span class="math">\\mathcal{G}</span>  be included in  <span class="math">par</span> . Let  <span class="math">\\mathbf{G}_{par},\\mathbf{H}_{par}</span>  be decisional algebraic security games. As before, we write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta, \\Delta)}{\\Longrightarrow}_{\\mathrm{alg}} \\mathbf{G}_{par}</span>  if there exists a generic algorithm  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  (called generic  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for algebraic algorithm  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathrm{alg}} := \\mathsf{R}_{\\mathrm{gen}}^{\\mathsf{A}_{\\mathrm{alg}}}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {p a r, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {H}} \\geq \\frac {1}{\\Delta_ {\\varepsilon}} \\cdot \\mathbf {A d v} _ {p a r, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G}}, \\quad \\mathbf {T i m e} _ {p a r, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {H}} \\leq \\Delta_ {t} \\cdot \\mathbf {T i m e} _ {p a r, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G}}.</span></div>

    <p class="text-gray-300">KEY ENCAPSULATION MECHANISMS. A key encapsulation mechanism (KEM for short)  <span class="math">\\mathsf{KEM} =</span>  Gen, Enc, Dec) is a triple of algorithms together with a symmetric-key space  <span class="math">\\kappa</span> . The randomized key generation algorithm Gen takes as input a set of parameters,  <span class="math">par</span> , and outputs a public/secret key pair  <span class="math">(pk, sk)</span> . The encapsulation algorithm Enc takes as input a public key  <span class="math">pk</span>  and outputs a key/ciphertext pair  <span class="math">(K, C)</span>  such that  <span class="math">K \\stackrel{\\mathcal{A}}{\\rightarrow} \\mathcal{K}</span> . The deterministic decapsulation algorithm Dec takes as input a secret key  <span class="math">sk</span>  and a ciphertext  <span class="math">C</span>  and outputs a key  <span class="math">K \\in \\mathcal{K}</span>  or a special symbol  <span class="math">\\perp</span>  if  <span class="math">C</span>  is invalid. We require that KEM be correct: For all possible pairs  <span class="math">(K, C)</span>  output by  <span class="math">\\mathsf{Enc}(pk)</span> , we have  <span class="math">\\mathsf{Dec}(sk, C) = K</span> . We formalize IND-CCA1 security of a KEM via the games (for  <span class="math">b = 0, 1</span> ) depicted in Figure 6.</p>

    <p class="text-gray-300">In the following, we consider the ElGamal KEM EG defined in Figure 8. We also consider a stronger variant of the well-known Decisional Diffie-Hellman (DDH) assumption that is parametrized by an integer  <span class="math">q</span> . In the  <span class="math">q</span> -DDH game, defined in Figure 7, the adversary receives, in addition to  <span class="math">(g^x, g^r)</span> , the values  <span class="math">g^{x^2}, \\ldots, g^{x^q}</span> .</p>

    <p class="text-gray-300">Lemma 5.1 [Che06] For  <span class="math">q &amp;lt; p^{1/3}</span> ,  <span class="math">\\mathbf{q} \\cdot \\mathbf{ddh}_{\\mathcal{G}}</span>  is  <span class="math">\\left(\\frac{t^2q}{p\\log p}, t\\right)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The proof of the following theorem can be found in Appendix A.3.</p>

    <p class="text-gray-300">Figure 6: IND-CCA1 Game ind-cca1 relative to KEM KEM = (Gen, Enc, Dec), parameters par, and adversary A.</p>

    <p class="text-gray-300">|  q-ddhA G,b  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  00 x,r,z←Zp  |</p>

    <p class="text-gray-300">|  01 b'←A(gx,gx2,...,gxq,gr,gxr+zb)  |</p>

    <p class="text-gray-300">|  02 Return b'  |</p>

    <p class="text-gray-300">Figure 7:  <span class="math">q</span> -Decisional Diffie-Hellman Game  <span class="math">\\mathbf{q}</span> -ddh relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gen(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc(pk):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dec(C,sk):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">03 r←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">07 If C∉G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 X := gx</td>

            <td class="px-3 py-2 border-b border-gray-700">04 C := gr</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Return ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return (pk,sk) := (X,x)</td>

            <td class="px-3 py-2 border-b border-gray-700">05 K := Xr</td>

            <td class="px-3 py-2 border-b border-gray-700">09 K := Cx</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return (K,C)</td>

            <td class="px-3 py-2 border-b border-gray-700">10 Return K</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 5.2 ind-cca1 <span class="math">_{\\text{EG},\\mathcal{G}} \\stackrel{(1,1)}{\\Longleftrightarrow}_{\\text{alg}} \\mathbf{q} \\cdot \\mathbf{ddh}_{\\mathcal{G}}</span> , where  <span class="math">q - 1</span>  is the maximal number of queries to Dec( <span class="math">\\cdot</span> ) in ind-cca1 <span class="math">_{\\text{EG},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Figure 8: ElGamal KEM EG = (Gen, Enc, Dec)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ind-cca1AEG,G,0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ind-cca1AEG,G,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dec([C]d)/Before Enc is called</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc() //One time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">04 K := Cx</td>

            <td class="px-3 py-2 border-b border-gray-700">06 r←Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 X := gx</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">05 Return K</td>

            <td class="px-3 py-2 border-b border-gray-700">07 C* := gr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 b'←AdagDec,Enc(X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">08 K* := Xr</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Return b'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">09 K*←K</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  |  | 10 Return (K<em>, C</em>)  |</p>

    <p class="text-gray-300">Figure 9: Games ind-cca1 <span class="math">_{\\text{EG}, \\mathcal{G}, 0}^{\\mathsf{A}}</span>  and ind-cca1 <span class="math">_{\\text{EG}, \\mathcal{G}, 1}^{\\mathsf{A}}</span>  with algebraic adversary  <span class="math">\\mathsf{A}_{\\text{alg}}</span> . The boxed statement is only executed in ind-cca1 <span class="math">_{\\text{EG}, \\mathcal{G}, 1}^{\\mathsf{A}}</span> .</p>

    <p class="text-gray-300">Corollary 5.3 For  <span class="math">q &amp;lt; p^{1/3}</span> , ind-cca1 <span class="math">_{\\text{EG},\\mathcal{G}}</span>  is  <span class="math">\\left(\\frac{t^2q}{p\\log p}, t\\right)</span> -hard in the generic group model, where  <span class="math">q - 1</span>  is the maximal number of queries to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  in ind-cca1 <span class="math">_{\\text{EG},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">For this section, we introduce the notion of groups  <span class="math">\\mathbb{G}</span>  equipped with a symmetric, (nondegenerate) bilinear map  <span class="math">e\\colon \\mathbb{G}\\times \\mathbb{G}\\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  denotes the so-called target group. We now set  <span class="math">\\mathcal{G} = (p,\\mathbb{G},\\mathbb{G}_T,g,e)</span> .</p>

    <p class="text-gray-300">SIGNATURE SCHEMES. A signature scheme  <span class="math">\\mathsf{SIG} = (\\mathsf{SIGGen},\\mathsf{SIGSig},\\mathsf{SIGVer})</span>  is a triple of algorithms. The randomized key generation algorithm SIGGen takes as input a set of parameters, par, and outputs a public/secret key pair  <span class="math">(pk,sk)</span> . The randomized signing algorithm SIGSig takes as input a secret key  <span class="math">sk</span>  and a message  <span class="math">m</span>  in the message space  <span class="math">\\mathcal{M}</span>  and outputs a signature  <span class="math">\\sigma</span>  in the signature space  <span class="math">\\mathcal{S}</span> . The deterministic signature verification algorithm SIGVer takes as input a public key  <span class="math">pk</span> , a message  <span class="math">m</span> , and a signature  <span class="math">\\sigma</span>  and outputs  <span class="math">b\\in \\{0,1\\}</span> . We require that SIG be correct: For all possible pairs  <span class="math">(pk,sk)</span>  output by SIGGen and all messages  <span class="math">m\\in \\mathcal{M}</span> , we have  <span class="math">\\operatorname*{Pr}[\\mathsf{SIGVer}(pk,m,\\mathsf{SIGSig}(m,sk)) = 1] = 1</span> . We formalize unforgeability under chosen message attacks for SIG via game  <span class="math">\\mathbf{uf - cma}_{\\mathsf{SIG,par}}</span>  depicted in Figure 10.</p>

    <p class="text-gray-300">In the following, we show how in the AGM with a random oracle, the security of the BLS signature scheme [BLS04], depicted in Figure 11, can be tightly reduced to the discrete logarithm problem. Boneh, Lynn and Shacham [BLS04] only prove a loose reduction to the CDH problem. In the AGM we can improve the quality of the reduction by leveraging the fact that a forgery comes with a representation in the basis of all previously answered random-oracle and signature queries. We embed a discrete logarithm challenge in either the secret key or inside the random oracle queries—a choice that remains hidden from the adversary. Depending on the adversary's behavior we always solve the discrete logarithm challenge in one of the cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uf-cmaA SIG,par</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(m)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 (pk,sk) ← SIGGen</td>

            <td class="px-3 py-2 border-b border-gray-700">04 Q := Q ∪ {m}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 Q := ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">05 σ ← SIGSig(m,sk)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 (m<em>,σ</em>) ← AO(·)(pk)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return σ</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  03 Return (m<em>∉ Q ∧ SIGVer(m</em>,σ*)) |   |</p>

    <p class="text-gray-300">Figure 10: Game uf-cma defining (existential) unforgeability under chosen-message attacks for signature scheme SIG, parameters par and adversary A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLSGen(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLSSig(m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLSVer(m,Σ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">05 Σ := H(m)x</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Return (e(H(m),X) = e(Σ,g))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 X := gx</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return Σ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  02 sk := x |  |   |</p>

    <p class="text-gray-300">|  03 pk := X |  |   |</p>

    <p class="text-gray-300">|  04 Return (pk,sk) |  |   |</p>

    <p class="text-gray-300">Theorem 6.1  <span class="math">\\mathrm{dlog}_{\\mathcal{G}} \\xrightarrow{(4,1)}_{\\mathrm{alg}} \\mathrm{uf - cma}_{\\mathrm{BLS},\\mathcal{G}}</span>  in the random oracle model.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G} \\coloneqq \\mathbf{uf - cma}_{\\mathrm{BLS},\\mathcal{G}}^{\\mathsf{A}_{\\mathrm{alg}}}</span> , depicted in Figure 12.</p>

    <p class="text-gray-300">As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is an algebraic adversary, at the end of  <span class="math">\\mathbf{G}</span>  it returns a forgery  <span class="math">\\pmb{\\Sigma}^{<em>}</span>  on a message  <span class="math">m^{</em>} \\notin Q</span>  together with a representation  <span class="math">\\vec{a} = (\\hat{a}, a&#x27;, \\tilde{a}_1, \\dots, \\tilde{a}_q, \\tilde{a}_1, \\dots, \\tilde{a}_q)</span>  s.t.</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} ^ {*} = H (m ^ {*}) ^ {x} = g ^ {\\hat {a}} \\mathbf {X} ^ {a ^ {\\prime}} \\prod_ {i = 1} ^ {q} \\mathbf {H} _ {i} ^ {\\tilde {a} _ {i}} \\prod_ {i = 1} ^ {q} \\boldsymbol {\\Sigma} _ {i} ^ {\\tilde {a} _ {i}}. \\tag {2}</span></div>

    <p class="text-gray-300">Here, the representation is split (from left to right) into powers of the generator  <span class="math">g</span> , the public key  <span class="math">\\mathbf{X}</span> , all of the answers to hash queries  <span class="math">\\mathbf{H}_i, i \\in [q]</span> , and the signatures  <span class="math">\\boldsymbol{\\Sigma}_i, i \\in [q]</span> , returned by the signing oracle. In the following, we let  <span class="math">r^<em></span>  and  <span class="math">r_i</span> , for  <span class="math">i \\in [q]</span> , be such that  <span class="math">H(m^</em>) = g^{r^*}</span>  and  <span class="math">H(m_i) = g^{r_i}</span> . Equation (2) is thus equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">x r ^ {*} \\equiv_ {p} x \\left(a ^ {\\prime} + \\Sigma_ {i} r _ {i} \\tilde {a} _ {i}\\right) + \\left(\\hat {a} + \\Sigma_ {i} r _ {i} \\tilde {a} _ {i}\\right). \\tag {3}</span></div>

    <p class="text-gray-300">We remark that since  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  wins  <span class="math">\\mathbf{G}</span> , the sum  <span class="math">\\Sigma_{i}r_{i}\\tilde{a}_{i}</span>  may not include a term of the form  <span class="math">r^{<em>}\\tilde{a}^{</em>}</span>  (since  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  may not query the signing oracle on  <span class="math">m^{*}</span> ). We will now describe the behavior of adversaries  <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}</span>  (depicted in Figures 13 and 14, respectively) playing in the discrete logarithm game. Each of these adversaries simulates  <span class="math">\\mathbf{G}</span>  to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  in a different way.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">GAalg 00 x←Zp 01 X := gx 02 Q := ∅ 03 (m<em>, [Σ</em>]a) ← AO(·),H(·)(X) 04 Return (m<em>∉ Q ∧ Σ</em> = H(m*)x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(mi) 05 Q := Q ∪ {mi} 06 Σi← H(mi)x 07 Return Σi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H(mi) 08 Hi← H(mi) 09 Return Hi</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 12: Game  <span class="math">\\mathbf{G} = \\mathbf{uf - cma}_{\\mathrm{BLS},\\mathcal{G}}^{\\mathrm{A_{alg}}}</span>  relative to adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Calg(Z = gz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(mi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H(mi)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 X := Z</td>

            <td class="px-3 py-2 border-b border-gray-700">04 If H(mi) = ⊥</td>

            <td class="px-3 py-2 border-b border-gray-700">09 If H(mi) ≠ ⊥</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 (m<em>, [Σ</em>]d) <^S A^O(-), H(-)(X)</td>

            <td class="px-3 py-2 border-b border-gray-700">05 ri <^S Z_p</td>

            <td class="px-3 py-2 border-b border-gray-700">10 Return H(mi)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Compute z (see description)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 H(mi) ← gri</td>

            <td class="px-3 py-2 border-b border-gray-700">11 ri <^S Z_p</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Return z</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Σi ← X^ri</td>

            <td class="px-3 py-2 border-b border-gray-700">12 H(mi) ← gri</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">08 Return Σi</td>

            <td class="px-3 py-2 border-b border-gray-700">13 Return H(mi)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 13: Adversary  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300">Lemma 6.2 Let  <span class="math">\\mathbf{G}</span>  be as defined in Figure 12 and, with  <span class="math">a&#x27;, \\tilde{a}_i, r^<em></span>  and  <span class="math">r_i</span>  defined as above, let  <span class="math">F</span>  denote the event that  <span class="math">a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^</em> \\neq_p 0</span> . Then there exist  <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}</span>  playing in the discrete logarithm game such that:</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[\\mathbf{d}\\log^{\\mathsf{C}_{\\mathrm{alg}}} = 1\\right] = \\operatorname</em>{Pr}\\left[\\mathbf{G} = 1\\mid F\\right]</span>  (4)</p>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[\\mathbf{d}\\log^{\\mathsf{D}_{\\mathrm{alg}}} = 1\\right] \\geq \\frac{p - 1}{p} \\operatorname</em>{Pr}\\left[\\mathbf{G} = 1 \\mid \\neg F\\right]</span>  (5)</p>

    <p class="text-gray-300">Proof. Let  <span class="math">\\mathbf{Z}</span>  denote the discrete logarithm instance.  <span class="math">C_{\\mathrm{alg}}</span>  and  <span class="math">D_{\\mathrm{alg}}</span>  simulate  <span class="math">\\mathbf{G}</span>  to  <span class="math">A_{\\mathrm{alg}}</span> .</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{C}_{\\mathrm{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  is depicted in Figure 13 and works as follows. It sets  <span class="math">\\mathbf{X} \\coloneqq \\mathbf{Z}</span> , which implicitly sets  <span class="math">x \\coloneqq z</span> . To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">r_i \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_i</span>  and sets  <span class="math">H(m_i) \\coloneqq g^{r_i}</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first calls  <span class="math">\\mathsf{H}(m_i)</span>  which defines  <span class="math">H(m_i)</span>  (and thus  <span class="math">r_i</span> ). It then computes and returns  <span class="math">\\boldsymbol{\\Sigma}_i \\coloneqq \\mathbf{X}^{r_i}</span> . It is easy to see that  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span> 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 1 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^<em> \\neq_p 0</span> . If  <span class="math">r^</em></span>  has not been defined at this point,  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  makes an additional query  <span class="math">\\mathsf{H}(m^<em>)</span>  which defines  <span class="math">r^</em></span> . Now, by (3) we have:</p>

    <p class="text-gray-300"><span class="math">zr^{*}\\equiv_{p}z(a^{\\prime} + \\Sigma_{i}r_{i}\\tilde{a}_{i}) + (\\hat{a} +\\Sigma_{i}r_{i}\\bar{a}_{i}).</span>  (6)</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  efficiently computes  <span class="math">z</span>  from (6) as  <span class="math">z = (\\hat{a} + \\Sigma_{i} r_{i} \\tilde{a}_{i})(r^{*} - a&#x27; - \\Sigma_{i} r_{i} \\tilde{a}_{i})^{-1} \\bmod p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dalg(Z = gz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(mi)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H(mi)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">05 Σi := H(mi)x</td>

            <td class="px-3 py-2 border-b border-gray-700">07 bi, r̂i←Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 X := gx</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return Σi</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Return gzbi+ r̂i</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  02 (m<em>, [Σ</em>]d)←A O(-),H(X) |  |   |</p>

    <p class="text-gray-300">|  03 Compute z (see above) |  |   |</p>

    <p class="text-gray-300">|  04 Return z |  |   |</p>

    <p class="text-gray-300">Figure 14: Adversary  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{d}\\log_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{D}_{\\mathrm{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  is depicted in Figure 14 and works as follows. It samples its own secret key  <span class="math">x \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_p</span>  and sets  <span class="math">\\mathbf{X} := g^x</span> . To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">\\hat{r}_i \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_p</span>  and  <span class="math">b_i \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_p</span>  and sets  <span class="math">H(m_i) = g^{r_i} := \\mathbf{Z}^{b_i} g^{\\hat{r}_i}</span> , which implicitly sets  <span class="math">r_i := \\hat{r}_i + z b_i</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first queries  <span class="math">\\mathsf{H}(m_i)</span> , which defines  <span class="math">H(m_i)</span>  and the values  <span class="math">\\hat{r}_i \\in \\mathbb{Z}_p, b_i \\in \\mathbb{Z}_p</span> , and  <span class="math">r_i = \\hat{r}_i + z b_i</span> . It then computes and returns  <span class="math">\\boldsymbol{\\Sigma}_i := H(m_i)^x</span> . Again, it is straightforward to verify that  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span> 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 0 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^* \\equiv_p 0</span> . Now,</p>

    <div class="my-4 text-center"><span class="math-block">z b ^ {*} + \\hat {r} ^ {*} \\equiv_ {p} r ^ {*} \\equiv_ {p} a ^ {\\prime} + \\Sigma_ {i} r _ {i} \\tilde {a} _ {i} \\equiv_ {p} \\left(a ^ {\\prime} + \\Sigma_ {i} \\hat {r} _ {i} \\tilde {a} _ {i}\\right) + z \\left(\\Sigma_ {i} b _ {i} \\tilde {a} _ {i}\\right) \\equiv_ {p} A z + B, \\tag {7}</span></div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 15:  <span class="math">q</span> -Discrete Logarithm Game  <span class="math">q</span> -dlog relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">where  <span class="math">A \\coloneqq \\Sigma_{i}b_{i}\\tilde{a}_{i}</span>  and  <span class="math">B \\coloneqq (a&#x27; + \\Sigma_{i}\\hat{r}_{i}\\tilde{a}_{i})</span> . Note that the value of  <span class="math">b^{<em>}</span>  is information-theoretically hidden from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  and thus independent from the value of  <span class="math">A</span> . As we have argued, the sum  <span class="math">\\Sigma_{i}r_{i}\\tilde{a}_{i}</span>  may not contain a term of the form  <span class="math">a^{</em>}r^{<em>}</span> . This means in particular that  <span class="math">a&#x27; + \\Sigma_{i}r_{i}\\tilde{a}_{i}</span>  is not composed of the singleton term  <span class="math">r^{</em>} \\equiv_{p}zb^{<em>} + \\hat{r}^{</em>}</span> . Therefore, with probability  <span class="math">1 - \\frac{1}{p}</span> , we have  <span class="math">b^{<em>} - A \\not\\equiv_{p}0</span>  and thus  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  can compute  <span class="math">z</span>  as  <span class="math">z \\coloneqq (B - \\hat{r}^{</em>})(b^{*} - A)^{-1} \\bmod p</span> .</p>

    <p class="text-gray-300">Now, we can simply let an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  choose to emulate one of the described adversaries  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  or  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  with probability  <span class="math">\\frac{1}{2}</span>  each. All in all,  <span class="math">\\mathbf{Adv}_{\\mathrm{dlog}}^{\\mathsf{B}_{\\mathrm{alg}},\\mathcal{G}} \\geq \\frac{p - 1}{2p} \\mathbf{Adv}_{\\mathrm{uf - cma}_{\\mathrm{BLS}}}^{\\mathsf{A}_{\\mathrm{alg}},\\mathcal{G}} \\geq \\frac{1}{4} \\mathbf{Adv}_{\\mathrm{uf - cma}_{\\mathrm{BLS}}}^{\\mathsf{A}_{\\mathrm{alg}},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 6.3  <span class="math">\\mathbf{uf - cma}_{\\mathsf{BLS},\\mathcal{G}}</span>  is  <span class="math">(t,\\frac{t^2}{4p})</span> -hard in the generic group model with a random oracle.</p>

    <p class="text-gray-300">In order to cover notions such as knowledge soundness, which are defined via games for two algorithms, we generalize the notion of algebraic games and reductions between them. We write  <span class="math">\\mathbf{G}_{par}^{\\mathbf{A},\\mathbf{X}}</span>  to denote that  <span class="math">\\mathsf{A}</span>  and  <span class="math">\\mathsf{X}</span>  play in  <span class="math">\\mathbf{G}_{par}</span>  and define the advantage  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}} := \\operatorname*{Pr}[\\mathbf{G}_{par}^{\\mathbf{A},\\mathbf{X}} = 1]</span>  and the running time  <span class="math">\\mathbf{Time}_{\\mathbf{par},\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  as before. To capture definitions that require that for every  <span class="math">\\mathsf{A}</span>  there exists some  <span class="math">\\mathsf{X}</span>  (which has black-box access to  <span class="math">\\mathsf{A}</span> ) such that  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  is small, we define algebraic reductions for games  <span class="math">\\mathbf{G}_{par}</span>  of this type as follows.</p>

    <p class="text-gray-300">We write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta, \\Delta_i)}{\\Longrightarrow}_{\\mathrm{alg}} \\mathbf{G}_{par}</span>  if there exist generic algorithms  <span class="math">\\mathsf{R}_{\\mathrm{gen}}</span>  and  <span class="math">\\mathsf{S}_{\\mathrm{gen}}</span>  such that for all algebraic algorithms  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {p a r, \\mathsf {B} _ {\\mathsf {a l g}}} ^ {\\mathbf {H}} \\geq \\frac {1}{\\Delta_ {\\varepsilon}} \\cdot \\mathbf {A d v} _ {p a r, \\mathsf {A} _ {\\mathsf {a l g}}, \\mathsf {X} _ {\\mathsf {a l g}}} ^ {\\mathbf {G}}, \\quad \\mathbf {T i m e} _ {p a r, \\mathsf {B} _ {\\mathsf {a l g}}} ^ {\\mathbf {H}} \\leq \\Delta_ {t} \\cdot \\mathbf {T i m e} _ {p a r, \\mathsf {A} _ {\\mathsf {a l g}}, \\mathsf {X} _ {\\mathsf {a l g}}} ^ {\\mathbf {G}},</span></div>

    <p class="text-gray-300">with  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathrm{alg}} := \\mathsf{R}_{\\mathrm{gen}}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  and  <span class="math">\\mathsf{X}_{\\mathrm{alg}}</span>  defined as  <span class="math">\\mathsf{X}_{\\mathrm{alg}} := \\mathsf{S}_{\\mathrm{gen}}^{\\mathsf{A}_{\\mathrm{alg}}}</span> .</p>

    <p class="text-gray-300">THE  <span class="math">q</span> -DISCRETE LOGARITHM ASSUMPTION. We define a parametrized (" <span class="math">q</span> -type") variant of the DLog assumption via the algebraic security game  <span class="math">q</span> -dlog in Figure 15. We will show that Groth's [Gro16] scheme, which is the most efficient SNARK system to date, is secure under  <span class="math">q</span> -DLog in the algebraic group model.</p>

    <p class="text-gray-300">NON-INTERACTIVE ZERO-KNOWLEDGE ARGUMENTS OF KNOWLEDGE. Groth [Gro16] considers proof systems for satisfiability of arithmetic circuits, which consist of addition and multiplication gates over a finite field  <span class="math">\\mathbb{F}</span> . As a tool, Gennaro et al. [GGPR13] show how to efficiently convert any arithmetic circuit into a quadratic arithmetic program (QAP)  <span class="math">R</span> , which is described by  <span class="math">\\mathbb{F}</span> , integers  <span class="math">\\ell \\leq m</span>  and polynomials  <span class="math">u_{i}, v_{i}, w_{i} \\in \\mathbb{F}[X]</span> , for  <span class="math">0 \\leq i \\leq m</span> , and  <span class="math">t \\in \\mathbb{F}[X]</span> , where the degrees of  <span class="math">u_{i}, v_{i}, w_{i}</span>  are less than the degree  <span class="math">n</span>  of  <span class="math">t</span> . (The relation  <span class="math">R</span>  can also contain additional information aux.) A QAP  <span class="math">R</span>  defines the following binary relation of statements  <span class="math">\\phi</span>  and witnesses  <span class="math">\\omega</span> , where we set  <span class="math">a_{0} := 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R = \\left\\{(\\phi , \\omega) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\phi = (a _ {1}, \\ldots , a _ {\\ell}) \\in \\mathbb {F} ^ {\\ell},   \\omega = (a _ {\\ell + 1}, \\ldots , a _ {m}) \\in \\mathbb {F} ^ {m - \\ell} \\\\ (\\sum_ {i = 0} ^ {m} a _ {i} u _ {i} (X)) \\cdot (\\sum_ {i = 0} ^ {m} a _ {i} v _ {i} (X)) \\equiv \\sum_ {i = 0} ^ {m} a _ {i} w _ {i} (X) \\pmod {t (X)} \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">knw-snd A,XA SNK,R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k-snd-aff X,A NILP,R</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 crs ← Setup(R)</td>

            <td class="px-3 py-2 border-b border-gray-700">03 σ ← LinSetup(R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 ((φ,π);ω) ← (A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">XA)(R, crs)</td>

            <td class="px-3 py-2 border-b border-gray-700">04 (φ,P) ← A(R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return ((φ,ω)∉ R</td>

            <td class="px-3 py-2 border-b border-gray-700">05 ω ← X(R,φ,P)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∧ Vfy(R, crs,φ,π) = 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return (P ∈ Fν×μ ∧ (φ,ω)∉ R ∧ LinVfy(R,σ,φ,Pσ) = 1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 16: Left: Knowledge soundness game knw-snd relative to SNK = (Setup, Prv, Vfy), adversary A and extractor XA. Right: Knowledge soundness game k-snd-aff relative to NILP = (LinSetup, PrfMtrx, Test), extractor X and affine adversary A (right).</p>

    <p class="text-gray-300">Relation  <span class="math">R</span>  defines an NP language  <span class="math">L_{R} \\coloneqq \\{\\phi \\in \\mathbb{F}^{\\ell} \\mid \\exists \\omega \\in \\mathbb{F}^{m - \\ell} : (\\phi, \\omega) \\in R\\}</span> .</p>

    <p class="text-gray-300">A non-interactive argument system for a class of relations  <span class="math">\\mathcal{R}</span>  is a tuple  <span class="math">\\mathsf{SNK} = (\\mathsf{Setup},\\mathsf{Prv},\\mathsf{Vfy})</span>  of algorithms. Setup on input a relation  <span class="math">R\\in \\mathcal{R}</span>  outputs a common reference string crs; prover algorithm  <span class="math">\\mathsf{Prv}</span>  on input crs and a statement/witness pair  <span class="math">(\\phi ,\\omega)\\in R</span>  returns an argument  <span class="math">\\pi</span> ; Verification Vfy on input crs,  <span class="math">\\phi</span>  and  <span class="math">\\pi</span>  returns either 0 (reject) or 1 (accept). We require SNK to be complete, i.e., for all crs output by Setup, all arguments for true statements produced by  <span class="math">\\mathsf{Prv}</span>  are accepted by Vfy.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Knowledge soundness requires that for every adversary  <span class="math">\\mathsf{A}</span>  there exists an extractor  <span class="math">\\mathsf{X}_{\\mathsf{A}}</span>  that extracts a witness from any valid argument output by  <span class="math">\\mathsf{A}</span> . We write  $(y;z)\\stackrel {\\mathrm{s}}{\\leftarrow}(\\mathsf{A}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{X}_{\\mathsf{A}})(x)<span class="math">  when  </span>\\mathsf{A}<span class="math">  on input  </span>x<span class="math">  outputs  </span>y<span class="math">  and  </span>\\mathsf{X}_{\\mathsf{A}}<span class="math">  on the same input (including  </span>\\mathsf{A}<span class="math"> &#x27;s coins) returns  </span>z<span class="math"> . Knowledge soundness is defined via game  </span>\\mathbf{knw - snd}_{\\mathsf{SNK},R}^{\\mathsf{A},\\mathsf{X}_{\\mathsf{A}}}$  in Figure 16.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge for SNK requires that arguments do not leak any information besides the truth of the statement. It is formalized by demanding the existence of a simulator which on input a trapdoor (which is an additional output of Setup) and a true statement  <span class="math">\\phi</span>  returns an argument that is indistinguishable from an argument for  <span class="math">\\phi</span>  output by  <span class="math">\\mathsf{Prv}</span>  when given a witness for  <span class="math">\\phi</span>  (see [Gro16] for a formal definition).</p>

    <p class="text-gray-300">A (preprocessing) succinct argument of knowledge (SNARK) is a knowledge-sound non-interactive argument system whose arguments are of size polynomial in the security parameter and can be verified in polynomial time in the security parameter and the length of the statement.</p>

    <p class="text-gray-300">NON-INTERACTIVE LINEAR PROOFS OF DEGREE 2. NILPs (in Groth's [Gro16] terminology) are an abstraction of many SNARK constructions introduced by Bitansky et al.  <span class="math">\\left[\\mathrm{BCI}^{+}13\\right]</span> . We only consider NILPs of degree 2 here. Such a system NILP is defined by three algorithms as follows. On input a quadratic arithmetic program  <span class="math">R</span> , LinSetup returns  <span class="math">\\vec{\\sigma} \\in \\mathbb{F}^{\\mu}</span>  for some  <span class="math">\\mu</span> . On input  <span class="math">R</span> ,  <span class="math">\\phi</span>  and  <span class="math">\\omega</span> , algorithm PrfMtrx generates a matrix  <span class="math">P \\in \\mathbb{F}^{\\nu \\times \\mu}</span>  (where  <span class="math">\\nu</span>  is the (short) proof length). And on input  <span class="math">R</span>  and  <span class="math">\\phi</span> , Test returns matrices  <span class="math">T_{1}, \\ldots, T_{\\eta} \\in \\mathbb{F}^{\\mu + \\nu}</span> . The last two algorithms implicitly define a prover and a verification algorithm as follows:</p>

    <p class="text-gray-300"><span class="math">\\circ \\vec{\\pi} \\stackrel{\\mathrm{s}}{\\leftarrow} \\operatorname{LinPrv}(R, \\vec{\\sigma}, \\phi, \\omega)</span> : run  <span class="math">P \\stackrel{\\mathrm{s}}{\\leftarrow} \\operatorname{PrfMtrx}(R, \\phi, \\omega)</span> ; return  <span class="math">\\vec{\\pi} := P\\vec{\\sigma}</span> . <span class="math">\\circ b \\stackrel{\\mathrm{s}}{\\leftarrow} \\operatorname{LinVfy}(R, \\vec{\\sigma}, \\phi, \\vec{\\pi})</span> :  <span class="math">(T_1, \\ldots, T_\\eta) \\stackrel{\\mathrm{s}}{\\leftarrow} \\operatorname{Test}(R, \\phi)</span> ; return 1 iff for all  <span class="math">1 \\leq k \\leq \\eta</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\vec {\\sigma} ^ {\\top} \\mid \\vec {\\pi} ^ {\\top}\\right) T _ {k} \\left(\\vec {\\sigma} ^ {\\top} \\mid \\vec {\\pi} ^ {\\top}\\right) ^ {\\top} = 0. \\tag {8}</span></div>

    <p class="text-gray-300">By symmetry of (8), for  <span class="math">T_{k} \\eqqcolon (t_{k,i,j})_{i,j=1}^{\\mu+\\nu}</span>  we can w.l.o.g. assume that  <span class="math">t_{k,i,j} = 0</span>  for all  <span class="math">k, i</span>  and  <span class="math">j &amp;lt; i</span> .</p>

    <p class="text-gray-300">We require a NILP to satisfy statistical knowledge soundness against affine prover strategies, which requires the existence of an (efficient) extractor  <span class="math">\\mathsf{X}</span>  that works for all (unbounded) adversaries  <span class="math">\\mathsf{A}</span> . Whenever  <span class="math">\\mathsf{A}</span>  returns a proof matrix  <span class="math">P</span>  which leads to a valid proof  <span class="math">P\\vec{\\sigma}</span>  for a freshly</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup(R) 00 g←G 01 σ←LinSetup(R) 02 Return Σ := ⟨σ⟩</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prv(R, Σ, φ, ω) 03 P←PrfMtrx(R, φ, ω) 04 Parse P = (pi,j)i,j 05 For i = 1...ν: 06 Πi := ∏j=1μ Σpi,j 07 π := (Π1, ..., Πν) 08 Return π // Note that π := ⟨Pσ⟩</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vfy(R, Σ, φ, Π) 09 T1, ..., Tη←Test(R, φ) 10 Parse Tk = (tk,i,j)i,j 11 Return 1 iff for all 1 ≤ k ≤ η: 0 = ∏i=1μ ∏j=iμ e(Σi, Σj)tk,i,j · ∏i=1μ ∏j=μ+ν e(Σi, Πj)tk,i,j · ∏i=μ+ν ∏j=iμ+ν e(Πi, Πj)tk,i,j // This evaluates (8) in the exponent</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 17: Argument system (Setup, Prv, Vfy) from a NILP (LinSetup, PrfMtrx, Test).</p>

    <p class="text-gray-300">|  LinSetup(R) 00 α,β,γ,δ,τ←F* 01 σ := (α,β,γ,δ, {τi}i=0n-1, {1/γ(βui(τ) + αvi(τ) + wi(τ))}i=0, {1/δ(βui(τ) + αvi(τ) + wi(τ))}m i=ℓ+1, {1/δ(τit(τ))}n-2) 02 Return σ ∈ Fμ with μ := m + 2n + 4  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  PrfMtrx(R,φ,ω) 03 Let h(X) be as in (10) 04 r, s←F 05 Return P ∈ F3×μ s.t. Pσ = (A,B,C) with 06 A := α + ∑i=0m a i u i(τ) + rδ 07 B := β + ∑i=0m a i v i(τ) + sδ 08 C := 1/δ(∑i=ℓ+1m a i(βui(τ) + αvi(τ) + wi(τ)) + h(τ)t(τ)) + As + rB - rsδ  |</p>

    <p class="text-gray-300">|  Test(R,φ) 09 Return T ∈ F(μ+3)×(μ+3) corresponding to the test A · B = α · β + ∑i=0l a i 1/γ(βui(τ) + αvi(τ) + wi(τ)) · γ + C · δ  |</p>

    <p class="text-gray-300">Figure 18: Groth's NILP (LinSetup, PrfMtrx, Test).</p>

    <p class="text-gray-300">sampled  <span class="math">\\vec{\\sigma}</span> ,  <span class="math">\\mathsf{X}</span>  can extract a witness from  <span class="math">P</span> . The notion is defined via game  <span class="math">\\mathbf{k}</span> -snd-aff <span class="math">_{\\mathrm{NILP},R}</span>  in Figure 16.</p>

    <p class="text-gray-300">NON-INTERACTIVE ARGUMENTS FROM NILPS. From a NILP for a quadratic arithmetic program over a finite field  <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>  for some prime  <span class="math">p</span> , one can construct an argument system over a bilinear group  <span class="math">\\mathcal{G} = (p, \\mathbb{G}, g, e)</span> . We thus consider QAP relations  <span class="math">R</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">R = \\left(\\mathcal {G}, \\mathbb {F} = \\mathbb {Z} _ {p}, \\ell , \\left\\{u _ {i} (X), v _ {i} (X), w _ {i} (X) \\right\\} _ {i = 0} ^ {m}, t (X)\\right), \\tag {9}</span></div>

    <p class="text-gray-300">and define the degree of  <span class="math">R</span>  as the degree of  <span class="math">n</span>  of  <span class="math">t(X)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The construction of  <span class="math">\\mathsf{SNK} = (\\mathsf{Setup},\\mathsf{Prv},\\mathsf{Vfy})</span>  from NILP  <span class="math">=</span>  (LinSetup, PrfMtrx, Test) is given in Figure 17, where we write  <span class="math">\\langle \\vec{x}\\rangle</span>  for  $(g^{x_1},\\ldots ,g^{x_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}})<span class="math"> . Setup samples a random group generator  </span>g<span class="math">  and embeds the NILP CRS &quot;in the exponent&quot;. Using group operations,  </span>\\mathsf{Prv}$  computes LinPrv in the exponent, and using the pairing, Vfy verifies LinVfy in the exponent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GROTH'S NEAR-OPTIMAL SNARK FOR QAPS. Groth [Gro16] obtains his SNARK system by constructing a NILP for QAPs and then applying the conversion in Figure 17. Recall that  <span class="math">R</span> , as in (9), defines a language of statements  <span class="math">\\phi = (a_{1},\\ldots ,a_{\\ell})\\in \\mathbb{F}^{\\ell}</span>  with witnesses of the form</p>

    <p class="text-gray-300"><span class="math">\\omega=(a_{\\ell+1},\\ldots,a_{m})\\in\\mathbb{F}^{m-\\ell}</span> such that (with <span class="math">a_{0}:=1</span>):</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\sum_{i=0}^{m}a_{i}u_{i}(X)\\big{)}\\cdot\\big{(}\\sum_{i=0}^{m}a_{i}v_{i}(X)\\big{)}=\\sum_{i=0}^{m}a_{i}w_{i}(X)+h(X)t(X)</span> (10)</p>

    <p class="text-gray-300">for some <span class="math">h(X)\\in\\mathbb{F}[X]</span> of degree at most <span class="math">n-2</span>. Groth’s NILP is given in Figure 18.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 7.1 (<em>[x13, Theorem 1]</em>).</h6>

    <p class="text-gray-300">The construction in Figure 18 is a NILP with perfect completeness, perfect zero knowledge and statistical knowledge soundness against affine prover strategies.</p>

    <p class="text-gray-300">Groth embeds his NILP in <em>asymmetric</em> bilinear groups, which yields a more efficient SNARK. He then shows that the scheme is knowledge-sound in the generic group model for <em>symmetric</em> bilinear groups (which is a stronger result, as the adversary is more powerful than in asymmetric groups). Since we aim at strengthening Groth’s security statement, we also consider the symmetric-group variant (which is what the transformation in Figure 17 yields). We now show how from an algebraic adversary breaking knowledge soundness one can construct an adversary against the <span class="math">q</span>-DLog assumption.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 7.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{SNK}</span> denote Groth’s <em>[x13]</em> SNARK for degree-<span class="math">n</span> QAPs defined over a (symmetric) bilinear group <span class="math">\\mathcal{G}</span> of order <span class="math">p</span> with <span class="math">n^{2}\\leq(p-1)/8</span>. Then we have <span class="math">q\\text{-}\\mathsf{dlog}\\ \\stackrel{{\\scriptstyle\\eqref{eq:NILP}}}{{\\Longrightarrow}}\\mathsf{alg}</span> <span class="math">\\mathsf{knw\\text{-}snd}_{\\mathsf{SNK}}</span> with <span class="math">q:=2n-1</span>.</p>

    <p class="text-gray-300">Let us start with a proof overview. Consider an algebraic adversary <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> against knowledge soundness (as defined in Figure 16): <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> has input <span class="math">(R,\\langle\\vec{\\sigma}\\rangle)</span> and returns a statement <span class="math">\\phi</span> and a proof <span class="math">\\vec{\\mathbf{\\Pi}}</span> consisting of <span class="math">3</span> group elements. Since <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is algebraic and its group-element inputs are <span class="math">\\vec{\\mathbf{\\Sigma}}=\\langle\\vec{\\sigma}\\rangle</span>, the adversary returns <span class="math">[\\mathbf{\\Pi}_{i}]_{\\vec{a}_{i}}</span> for <span class="math">1\\leq i\\leq 3</span> with <span class="math">\\mathbf{\\Pi}_{i}=\\prod_{i=1}^{\\mu}\\mathbf{\\Sigma}_{j}^{a_{i,j}}=\\langle\\sum_{i=1}^{\\mu}\\sigma_{j}a_{i,j}\\rangle</span>. Letting <span class="math">P:=(a_{i,j})_{i,j}\\in\\mathbb{F}^{3\\times\\mu}</span>, we have <span class="math">\\vec{\\mathbf{\\Pi}}=\\langle P\\vec{\\sigma}\\rangle</span> and we denote <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>’s group-element output as <span class="math">[\\vec{\\mathbf{\\Pi}}]_{P}</span>.</p>

    <p class="text-gray-300">By definition, <span class="math">\\vec{\\mathbf{\\Pi}}</span> passes <span class="math">\\mathsf{Vfy}</span> iff <span class="math">P\\vec{\\sigma}</span> satisfies <span class="math">\\mathsf{LinVfy}</span>. In this case, by Groth’s theorem (Theorem 7.1), there exists an extractor <span class="math">\\mathsf{X}</span>, which on input <span class="math">P</span> such that <span class="math">P\\vec{\\sigma}</span> satisfies <span class="math">\\mathsf{LinVfy}</span> extracts a witness (see game <span class="math">\\mathbf{k\\text{-}snd\\text{-}aff}_{\\mathsf{NILP},R}</span> in Figure 16).</p>

    <p class="text-gray-300">So it seems this extractor <span class="math">\\mathsf{X}</span> should also work for <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> (which returns <span class="math">P</span> as required). However, <span class="math">\\mathsf{X}</span> is only guaranteed to succeed if <span class="math">P\\vec{\\sigma}</span> verifies for a <em>randomly</em> sampled <span class="math">\\vec{\\sigma}</span>, whereas for <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> in <span class="math">\\mathsf{knw\\text{-}snd}_{\\mathsf{SNK},R}</span> it suffices to return <span class="math">P</span> so that <span class="math">P\\vec{\\sigma}</span> verifies for the specific <span class="math">\\vec{\\sigma}</span> for which it received <span class="math">\\langle\\vec{\\sigma}\\rangle</span>. To prove knowledge soundness, we must show that an adversary can only output <span class="math">P</span> which works for <em>all</em> choices of <span class="math">\\vec{\\sigma}</span> (from which <span class="math">\\mathsf{X}</span> will then extract a witness).</p>

    <p class="text-gray-300">In the generic group model this follows rather straight-forwardly, since the adversary has no information about the concrete <span class="math">\\vec{\\sigma}</span>. In the AGM however, <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> is given <span class="math">\\langle\\vec{\\sigma}\\rangle</span>, and if <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> could compute discrete logarithms, it could compute <span class="math">P</span> which only verifies for the specific <span class="math">\\vec{\\sigma}</span> (in the same way as proofs are simulated to show zero knowledge of the scheme <em>[x13]</em>). Our proof strategy is to show that computing discrete logarithms is basically the only way to compute <span class="math">P</span> which only works for the specific <span class="math">\\vec{\\sigma}</span>.</p>

    <p class="text-gray-300">Examining the structure of a NILP CRS <span class="math">\\vec{\\sigma}</span> (Figure 18), we see that its components are defined as multivariate (Laurent) polynomials evaluated at a random point <span class="math">\\vec{x}=(\\alpha,\\beta,\\gamma,\\delta,\\tau)</span>.</p>

    <p class="text-gray-300">Now what does it mean for <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> to output a valid <span class="math">P</span>? By the definition of <span class="math">\\mathsf{LinVfy}</span> via <span class="math">\\mathsf{Test}</span> (cf. Equation (8) with <span class="math">\\vec{\\pi}:=P\\vec{\\sigma}</span>), it means that <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> found <span class="math">P</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\vec{\\sigma}^{\\top}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,(P\\vec{\\sigma}))^{\\top})\\,T\\,(\\vec{\\sigma}^{\\top}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,(P\\vec{\\sigma})^{\\top})^{\\top}=0.$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If we interpret the components of <span class="math">\\vec{\\sigma}</span> as polynomials over <span class="math">X_{1},\\ldots,X_{5}</span> (corresponding to <span class="math">\\vec{x}=(\\alpha,\\beta,\\gamma,\\delta,\\tau)</span>) then the left-hand side of (11) defines a polynomial <span class="math">Q_{P}(\\vec{X})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">XA(R, ⟨σ⟩)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">knw-snd Aalg.XA SNK,R</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 (φ, [Π]P) ← Aalg(R, ⟨σ⟩)</td>

            <td class="px-3 py-2 border-b border-gray-700">03 σ ← LinSetup(R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 ω ← X(R, φ, P)</td>

            <td class="px-3 py-2 border-b border-gray-700">04 (φ, [Π]P) ← Aalg(R, ⟨σ⟩)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return ω.</td>

            <td class="px-3 py-2 border-b border-gray-700">05 ω ← X(R, φ, P)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 06 Return ((φ, ω)∉ R ∧ LinVfy(R, σ, φ, Pσ) = 1)  |</p>

    <p class="text-gray-300">Figure 19: Extractor  <span class="math">\\mathsf{X}_{\\mathsf{A}}</span>  defined from  <span class="math">\\mathsf{X}</span>  and  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  (left) and knowledge soundness game knw-snd for a SNARK built from NILP = (LinSetup, PrfMtrx, Test), algebraic adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  and  <span class="math">\\mathsf{X}_{\\mathsf{A}}</span>  (right).</p>

    <p class="text-gray-300">On the other hand, what does it mean that  <span class="math">P\\vec{\\sigma}</span>  verifies for the specific  <span class="math">\\vec{\\sigma}</span>  from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> 's input but not in general? It means that  <span class="math">Q_{P}(\\vec{x}) = 0</span> , but  <span class="math">Q_{P} \\neq 0</span> , that is,  <span class="math">Q_{P}</span>  is not the zero polynomial (since otherwise (11) would hold for any choice of  <span class="math">\\vec{x}</span> , that is,  <span class="math">P\\vec{\\sigma}&#x27;</span>  would verify for any  <span class="math">\\vec{\\sigma}&#x27;</span> ).</p>

    <p class="text-gray-300">We now bound the probability that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  behaves "badly", that is, it returns a proof that only holds with respect to its specific CRS. To do so, we bound the probability that given  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> ,  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  (implicitly) returns a nonzero polynomial  <span class="math">Q_{P}</span>  which vanishes at  <span class="math">\\vec{x}</span> , the point that defines  <span class="math">\\vec{\\sigma}</span> . By factoring  <span class="math">Q_{P}</span> , we can then extract information about  <span class="math">\\vec{x}</span> , which was only given as group elements  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> .</p>

    <p class="text-gray-300">Concretely, we embed a  <span class="math">q</span> -DLog instance simultaneously into  <span class="math">\\alpha, \\ldots, \\tau</span>  of a CRS  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> , for which we thus need  <span class="math">q</span>  to be at least the maximum of the total degrees of the polynomials defining  <span class="math">\\sigma</span> , which for Groth's NILP is  <span class="math">2n - 1</span> . The technical part of the proof is to show that the left-hand side of (11), when viewed as a univariate polynomial, one of whose roots is the DLog challenge, is non-zero. The reduction can then compute the DLog by factoring this polynomial to obtain its roots.</p>

    <p class="text-gray-300">Proof of Theorem 7.2. Let  <span class="math">R</span>  be a QAP of degree  <span class="math">n</span>  (cf. (9)). Let  <span class="math">\\mathsf{NILP} = (\\mathsf{LinSetup}, \\mathsf{PrfMtrx}, \\mathsf{Test})</span>  denote Groth's NILP (Figure 18). By Theorem 7.1 there exists an extractor  <span class="math">X</span> , which on input  <span class="math">R</span> , statement  <span class="math">\\phi \\in L_R</span> , and  <span class="math">P \\in \\mathbb{P}^{\\nu \\times \\mu}</span>  such that  <span class="math">\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1</span>  for  <span class="math">\\vec{\\sigma} \\gets \\mathsf{LinSetup}(R)</span>  returns a witness  <span class="math">\\omega</span>  with probability  <span class="math">\\mathbf{Adv}_{\\mathsf{NILP}, R, X, F}^{\\mathbf{k-snd-aff}}</span>  for any affine  <span class="math">F</span> .</p>

    <p class="text-gray-300">Let SNK denote Groth's SNARK obtained from NILP via the transformation in Figure 17 and let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary in the game  <span class="math">\\mathbf{knw - snd}_{\\mathsf{SNK},R}</span> . From  <span class="math">\\mathsf{X}</span>  we construct an extractor  <span class="math">\\mathsf{X}_{\\mathsf{A}}</span>  for  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  in Figure 19. Note that since  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is algebraic, we have  <span class="math">\\vec{\\Pi} = \\langle P\\vec{\\sigma}\\rangle</span> , for which we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {V f y} (R, \\vec {\\Sigma}, \\phi , \\vec {\\Pi}) = \\mathsf {V f y} (R, \\vec {\\Sigma}, \\phi , \\langle P \\vec {\\sigma} \\rangle) = \\mathsf {L i n V f y} (R, \\vec {\\sigma}, \\phi , P \\vec {\\sigma}) \\tag {12}</span></div>

    <p class="text-gray-300">by the definition of  <span class="math">\\mathsf{Vfy}</span>  (Figure 17). Using this, we write out Game  <span class="math">\\mathbf{knw - snd}_{\\mathsf{SNK},R}^{\\mathsf{A}_{\\mathrm{alg}},\\mathsf{X}_{\\mathsf{A}}}</span>  in Figure 19. Our goal is to upperbound  <span class="math">\\mathbf{Adv}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathrm{alg}},\\mathsf{X}_{\\mathsf{A}}}^{\\mathbf{knw - snd}}</span></p>

    <p class="text-gray-300">Consider the affine prover  <span class="math">\\mathsf{A}&#x27;</span>  in Figure 20 and  <span class="math">\\mathbf{k}</span> -snd-aff <span class="math">_{\\mathsf{NILP}}^{\\mathsf{X},\\mathsf{A}&#x27;}</span> , with the code of  <span class="math">\\mathsf{A}&#x27;</span>  written out, also in Figure 20. Comparing the right-hand sides of Figures 19 and 20, we see that the outputs of the games only differ in the following: if LinVfy returns 0 for  <span class="math">P\\vec{\\rho}</span>  w.r.t.  <span class="math">\\vec{\\rho}</span> , but it returns 1 for  <span class="math">P\\vec{\\sigma}</span>  w.r.t.  <span class="math">\\vec{\\sigma}</span> , then  <span class="math">\\mathbf{knw}</span> -snd returns 1 whereas  <span class="math">\\mathbf{k}</span> -snd-aff returns 0. Let bad denote the event when this happens; formally defined as a flag in game  <span class="math">\\mathbf{k}</span> -snd-aff in Figure 20. By definition, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {S N K}, R, \\mathsf {A} _ {\\mathrm {a l g}}, \\mathsf {X} _ {\\mathrm {A}}} ^ {\\mathbf {k n w - s n d}} \\leq \\mathbf {A d v} _ {\\mathsf {N I L P}, R, \\mathsf {X}, \\mathsf {A} ^ {\\prime}} ^ {\\mathbf {k - s n d - a f f}} + \\Pr [ \\mathbf {b a d} = 1 ]. \\tag {13}</span></div>

    <p class="text-gray-300">In order to simplify our analysis, we first make a syntactical change to NILP by multiplying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'(R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k-snd-affX,A'NILP,R</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 σ←LinSetup(R)</td>

            <td class="px-3 py-2 border-b border-gray-700">03 ρ←LinSetup(R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 (φ, [Π]P)←Aalg(R, ⟨σ⟩)</td>

            <td class="px-3 py-2 border-b border-gray-700">04 σ←LinSetup(R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return (φ, P).</td>

            <td class="px-3 py-2 border-b border-gray-700">05 (φ, [Π]P)←Aalg(R, ⟨σ⟩)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 06 ω←X(R, φ, P)  |</p>

    <p class="text-gray-300">|   | 07 If ((φ, ω)∉R ∧ LinVfy(R, σ, φ, Pσ) = 1 ∧ LinVfy(R, ρ, φ, Pρ) = 0)  |</p>

    <p class="text-gray-300">|   | 08 Then bad := 1  |</p>

    <p class="text-gray-300">|   | 09 Return ((φ, ω)∉R ∧ LinVfy(R, ρ, φ, Pρ) = 1)  |</p>

    <p class="text-gray-300">Figure 20: Affine prover  <span class="math">\\mathsf{A}&#x27;</span>  defined from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  (left) and game  <span class="math">\\mathbf{k}</span> -snd-aff for NILP, extractor  <span class="math">\\mathsf{X}</span>  and  <span class="math">\\mathsf{A}&#x27;</span>  (right).</p>

    <p class="text-gray-300">out all denominators, that is, we let LinSetup (cf. Figure 18) return</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\vec {\\sigma} := \\left(\\delta \\gamma , \\alpha \\delta \\gamma , \\beta \\delta \\gamma , \\delta \\gamma^ {2}, \\delta^ {2} \\gamma , \\{\\delta \\gamma \\tau^ {i} \\} _ {i = 0} ^ {n - 1}, \\{\\delta (\\beta u _ {i} (\\tau) + \\alpha v _ {i} (\\tau) + w _ {i} (\\tau)) \\} _ {i = 0} ^ {\\ell}, \\right. \\\\ \\left. \\left\\{\\gamma \\left(\\beta u _ {i} (\\tau) + \\alpha v _ {i} (\\tau) + w _ {i} (\\tau)\\right) \\right\\} _ {i = \\ell + 1} ^ {m}, \\left\\{\\gamma \\tau^ {i} t (\\tau) \\right\\} _ {i = 0} ^ {n - 2}\\right). \\tag {14} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Note that this does not affect the distribution of the SNARK CRS as running the modified LinSetup amounts to the same as choosing  <span class="math">g&#x27; \\stackrel{\\phi}{\\leftarrow} \\mathbb{G}</span>  and running the original setup with  <span class="math">g \\coloneqq (g&#x27;)^{\\delta \\gamma}</span> , which again is a uniformly random generator.</p>

    <p class="text-gray-300">Observe that the components of LinSetup defined in (14) can be described via multivariate polynomials  <span class="math">S_{i}(\\vec{x})</span> ,  <span class="math">1 \\leq i \\leq \\mu</span> , of total degree at most  <span class="math">2n - 1</span>  with  <span class="math">\\vec{x} \\coloneqq (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> , and LinSetup can be defined as picking a random point  <span class="math">\\vec{x} \\stackrel{\\phi}{\\leftarrow} (\\mathbb{F}^{*})^{5}</span>  and returning the evaluations  <span class="math">\\sigma_{i} \\coloneqq S_{i}(\\vec{x})</span>  of these polynomials.</p>

    <p class="text-gray-300">Let  <span class="math">T</span>  be as defined by Test in Figure 18. By (8) we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {L i n V f y} (R, \\vec {\\sigma}, \\phi , P \\vec {\\sigma}) = 1 \\iff \\vec {\\sigma} ^ {\\top} \\left(\\left(I d \\mid P ^ {\\top}\\right) \\cdot T \\cdot \\left(I d \\mid P ^ {\\top}\\right) ^ {\\top}\\right) \\vec {\\sigma} = 0.</span></div>

    <p class="text-gray-300">Let  <span class="math">\\vec{S}</span>  be the vector of polynomials defined by LinSetup. For a matrix  <span class="math">P\\in \\mathbb{F}^{3\\times \\mu}</span>  define the following multivariate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">Q _ {P} (\\vec {X}) := (\\vec {S} (\\vec {X})) ^ {\\top} \\left(\\left(I d \\mid P ^ {\\top}\\right) \\cdot T \\cdot \\left(I d \\mid P ^ {\\top}\\right) ^ {\\top}\\right) \\vec {S} (\\vec {X}) \\tag {15}</span></div>

    <p class="text-gray-300">of degree at most  <span class="math">(2n - 1)^{2}</span> . Then for any  <span class="math">\\vec{x} \\in (\\mathbb{F}^{*})^{5}</span>  and  <span class="math">\\vec{\\sigma} \\coloneqq \\vec{S}(\\vec{x})</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {L i n V f y} (R, \\vec {\\sigma}, \\phi , P \\vec {\\sigma})) = 1 \\iff Q _ {P} (\\vec {x}) = 0. \\tag {16}</span></div>

    <p class="text-gray-300">Groth [Gro16] proves Theorem 7.1 by showing that from a proof  <span class="math">P</span>  with  <span class="math">Q_P \\equiv 0</span>  (that is,  <span class="math">P</span>  verifies for any choice of  <span class="math">\\sigma</span> ), an extractor  <span class="math">X</span>  can efficiently compute a witness. Thus in order to win game  <span class="math">\\mathbf{k}</span> -snd-aff  <span class="math">NILP,R</span> , the adversary must return  <span class="math">P</span>  with  <span class="math">Q_P \\neq 0</span>  (thus the extractor fails), but which verifies for  <span class="math">\\sigma</span> , which by (16) means  <span class="math">Q_P(\\vec{x}) = 0</span> .</p>

    <p class="text-gray-300">The affine adversary has no information on  <span class="math">\\sigma</span>  and thus the polynomial  <span class="math">Q_{P}</span>  is independent of it. The Schwartz-Zippel lemma states that a non-zero multivariate polynomial over  <span class="math">\\mathbb{F}_p</span>  of total degree  <span class="math">d</span>  evaluates to 0 on a uniformly random point with probability at most  <span class="math">\\frac{d}{p - 1}</span> .</p>

    <p class="text-gray-300">Since the total degree of  <span class="math">Q_P</span>  is at most  <span class="math">d = (2n - 1)^2</span>  (using the modified  <span class="math">\\vec{\\sigma}</span>  from (14)), the probability that  <span class="math">Q_P(\\vec{x}) = 0</span>  for a random  <span class="math">\\vec{x} \\stackrel{\\phi}{\\leftarrow} (F^*)^5</span>  is thus bounded by  <span class="math">\\frac{d}{p - 1}</span> . This yields</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathrm {N I L P}, R, \\mathrm {X}, \\mathrm {A} ^ {\\prime}} ^ {\\mathbf {k} - \\mathbf {s n d} - \\mathbf {a f f}} \\leq \\frac {(2 n - 1) ^ {2}}{p - 1}. \\tag {17}</span></div>

    <p class="text-gray-300">In order to bound <span class="math">\\mathbf{Adv}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}^{\\mathbf{knw - snd}}</span> in (13), we will construct an adversary <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {b a d} = 1 \\right] \\leq \\left(1 - \\frac {(2 n - 1) ^ {2}}{p - 1}\\right) \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {B} _ {\\mathrm {a l g}}} ^ {q - \\mathrm {d l o g}} \\text{ with } q = 2 n - 1. \\tag {18}</span></div>

    <p class="text-gray-300">For <span class="math">\\mathbf{bad}</span> to be set to 1, <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>'s output <span class="math">P</span> must be such that <span class="math">Q_{P} \\neq 0</span>: otherwise, <span class="math">\\mathsf{LinVfy}</span> returns 1 for any <span class="math">\\vec{x}</span> and in particular <span class="math">\\mathsf{LinVfy}(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 1</span>.</p>

    <p class="text-gray-300">Event <span class="math">\\mathbf{bad} = 1</span> implies thus that <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> on input <span class="math">\\langle \\vec{\\sigma}\\rangle = \\langle \\vec{S} (\\vec{x})\\rangle</span> returns <span class="math">P</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">Q _ {P} \\neq 0 \\quad \\text{and} \\quad Q _ {P} (\\vec {x}) = 0. \\tag {19}</span></div>

    <p class="text-gray-300">We now use such <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> to construct an adversary <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> that solves <span class="math">q</span>-DLog with <span class="math">q := 2n - 1</span>.</p>

    <p class="text-gray-300"><strong>Adversary <span class="math">\\mathsf{B}_{\\mathsf{alg}}(\\langle z\\rangle ,\\langle z^2\\rangle ,\\dots,\\langle z^q\\rangle)</span></strong>: On input a <span class="math">q</span>-DLog instance, <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> simulates <span class="math">\\mathbf{k}</span>-snd-aff <span class="math">_{\\mathsf{NILP},R}^{\\mathsf{X},\\mathsf{A}&#x27;}</span> for <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>. It first picks a random value <span class="math">\\vec{r} \\gets (\\mathbb{F}^{*})^{5}</span> and <span class="math">\\vec{s} \\gets \\mathbb{F}^{5}</span> and (implicitly) sets <span class="math">x_{i} := r_{i}z + s_{i}</span>, that is:</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha := r _ {1} z + s _ {1} \\quad \\beta := r _ {2} z + s _ {2} \\quad \\gamma := r _ {3} z + s _ {3} \\quad \\delta := r _ {4} z + s _ {4} \\quad \\tau := r _ {5} z + s _ {5}</span></div>

    <p class="text-gray-300">If <span class="math">x_{i} = 0</span> for some <span class="math">i</span> (which <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> can check using <span class="math">\\langle z \\rangle</span>) then <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> stops and outputs <span class="math">z := -s_{i}r_{i}^{-1} \\bmod p</span>. (*)</p>

    <p class="text-gray-300">Otherwise, <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> generates a CRS <span class="math">\\langle \\vec{\\sigma} \\rangle \\coloneqq \\langle \\vec{S}(\\vec{x}) \\rangle = \\langle \\vec{S}(\\alpha, \\beta, \\gamma, \\delta, \\tau) \\rangle</span> as defined in (14). Since the total degree of the polynomials <span class="math">S_{i}</span> defining <span class="math">\\vec{\\sigma}</span> is bounded by <span class="math">2n - 1 = q</span> (the degree of the last component of <span class="math">\\vec{\\sigma}</span>), <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> can compute <span class="math">\\langle \\vec{\\sigma} \\rangle</span> from its <span class="math">q</span>-DLog instance.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> runs <span class="math">(\\phi, [\\vec{\\Pi}]_P) \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}(R, \\langle \\vec{\\sigma} \\rangle)</span> and from <span class="math">P</span> computes the multivariate polynomial <span class="math">Q_P(\\vec{X})</span> as defined in (15). If <span class="math">Q_P \\equiv 0</span> or <span class="math">Q_P(\\vec{x}) \\neq 0</span> (by (19) this means that event <span class="math">\\mathbf{bad}</span> has not occurred) then <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> aborts. (**)</p>

    <p class="text-gray-300">Otherwise <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> defines the univariate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">Q _ {P} ^ {\\prime} (Z) := Q _ {P} \\left(r _ {1} Z + s _ {1}, \\dots , r _ {5} Z + s _ {5}\\right).</span></div>

    <p class="text-gray-300">If <span class="math">Q_P&#x27; \\equiv 0</span> then <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> aborts. (**)</p>

    <p class="text-gray-300">Otherwise <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> factors <span class="math">Q_P&#x27;</span> to obtain its roots (of which by (15) there are at most <span class="math">(2n - 1)^2</span>), checks them against its DLog instance to determine whether <span class="math">z</span> is among them, and if so, returns <span class="math">z</span>.</p>

    <p class="text-gray-300">In case <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> does not stop at <span class="math">(<em>)</span>, it perfectly simulates <span class="math">\\mathbf{k}</span>-snd-aff <span class="math">_{\\mathsf{NILP},R}^{\\mathsf{X},\\mathsf{A}&#x27;}</span> for <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>. We now analyze the probability that <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> finds the target <span class="math">z</span> provided that <span class="math">\\mathbf{bad} = 1</span>. As in this case <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> will not abort at <span class="math">(<strong>)</span> it remains to bound the probability of aborting at <span class="math">(</strong></em>)</span>.</p>

    <p class="text-gray-300">Since <span class="math">Q_P&#x27;(z) = Q_P(r_1z + s_1, \\ldots, r_5z + s_5) = Q_P(\\vec{x})</span>, by (19) we have <span class="math">Q_P&#x27;(z) = 0</span>. Thus if <span class="math">Q_P&#x27; \\neq 0</span> then <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span> finds <span class="math">z</span> by factoring <span class="math">Q_P&#x27;</span>, and it remains to argue that <span class="math">Q_P&#x27; \\neq 0</span>.</p>

    <p class="text-gray-300"><span class="math">Q_{P}</span> is of the form <span class="math">Q_{P}(\\vec{X}) = \\sum_{i_{1},\\ldots ,i_{5}}c_{i_{1},\\ldots ,i_{5}}\\prod_{j = 1}^{5}X_{j}^{i_{j}}</span> for coefficients <span class="math">c_{i_1,\\dots ,i_5}</span> and thus</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} Q _ {P} ^ {\\prime} (Z) = \\sum_ {i _ {1}, \\dots , i _ {5}} c _ {i _ {1}, \\dots , i _ {5}} \\prod_ {j = 1} ^ {5} \\left(r _ {j} Z + s _ {j}\\right) ^ {i _ {j}} = \\sum_ {\\vec {i}} c _ {\\vec {i}} \\prod_ {j = 1} ^ {5} \\left(\\sum_ {k = 0} ^ {i _ {j}} \\binom {i _ {j}} {k} r _ {j} ^ {k} Z ^ {k} s _ {j} ^ {i _ {j} - k}\\right) \\\\ = \\sum_ {\\vec {i}} c _ {\\vec {i}} \\sum_ {k _ {1}, \\dots , k _ {5}} ^ {i _ {1}, \\dots , i _ {5}} \\prod_ {j = 1} ^ {5} \\binom {i _ {j}} {k _ {j}} r _ {j} ^ {k _ {j}} Z ^ {k _ {j}} s _ {j} ^ {i _ {j} - k _ {j}} = \\sum_ {\\ell} \\sum_ {\\vec {i}} c _ {\\vec {i}} \\sum_ {\\vec {k}: \\Sigma_ {j} k _ {j} = \\ell} ^ {\\vec {i}} \\prod_ {j = 1} ^ {5} \\binom {i _ {j}} {k _ {j}} r _ {j} ^ {k _ {j}} Z ^ {k _ {j}} s _ {j} ^ {i _ {j} - k _ {j}} \\\\ = \\sum_ {\\ell} c _ {\\ell} ^ {\\prime} Z ^ {\\ell} \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\text {with} \\quad c _ {\\ell} ^ {\\prime} := \\sum_ {\\vec {i}} c _ {\\vec {i}} \\sum_ {\\vec {k}: \\Sigma_ {j} k _ {j} = \\ell} ^ {\\vec {i}} \\prod_ {j = 1} ^ {5} \\binom {i _ {j}} {k _ {j}} r _ {j} ^ {k _ {j}} s _ {j} ^ {i _ {j} - k _ {j}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">By (19) we have <span class="math">Q_{P}\\not\\equiv 0</span>. Let <span class="math">d^{<em>}</span> be the total degree of <span class="math">Q_{P}</span>, thus for some <span class="math">i_{1},\\ldots,i_{5}\\geq 0</span> with <span class="math">\\sum_{j}i_{j}=d^{</em>}</span> we have <span class="math">c_{i_{1},\\ldots,i_{5}}\\neq 0</span>, while <span class="math">c_{i_{1},\\ldots,i_{5}}=0</span> when <span class="math">\\sum_{j}i_{j}&gt;d^{*}</span>. By the latter we have</p>

    <p class="text-gray-300"><span class="math">c^{\\prime}_{d^{<em>}}</span> <span class="math">=</span> <span class="math">\\sum_{\\vec{i}:\\Sigma_{j}i_{j}\\leq d^{</em>}}c_{\\vec{i}}\\sum_{\\vec{k}:\\Sigma_{j}k_{j}=d^{<em>}}^{\\vec{i}}\\prod_{j=1}^{5}\\binom{i_{j}}{k_{j}}r_{j}^{k_{j}}\\,s_{j}^{i_{j}-k_{j}}\\ =\\ \\sum_{\\vec{i}:\\Sigma_{j}i_{j}\\leq d^{</em>}}c_{\\vec{i}}\\ \\prod_{j=1}^{5}r_{j}^{i_{j}},</span></p>

    <p class="text-gray-300">since <span class="math">k_{j}\\leq i_{j}</span>, for all <span class="math">j</span>, and <span class="math">\\sum_{j}i_{j}\\leq d^{<em>}</span> and <span class="math">\\sum_{j}k_{j}=d^{</em>}</span> implies <span class="math">k_{j}=i_{j}</span> for all <span class="math">j</span>.</p>

    <p class="text-gray-300">We now lower-bound the probability that <span class="math">c^{\\prime}_{d^{<em>}}\\neq 0</span> and thus <span class="math">Q^{\\prime}_{P}\\not\\equiv 0</span>. First note that from <span class="math">\\langle\\vec{\\sigma}\\rangle=\\langle\\vec{S}(\\vec{x})\\rangle</span> the adversary obtains information on <span class="math">\\vec{x}</span>, which might influence its choice of <span class="math">Q_{P}</span>; however, the values <span class="math">s_{1},\\ldots,s_{5}</span> perfectly blind the values <span class="math">r_{1}z,\\ldots,r_{5}z</span>, and <span class="math">c^{\\prime}_{d^{</em>}}</span>, which is independent of <span class="math">(s_{1},\\ldots,s_{5})</span> is thus also independent of <span class="math">(r_{1},\\ldots,r_{5})</span>. Consider <span class="math">c^{\\prime}_{d^{<em>}}</span> as a polynomial in variables <span class="math">(R_{1},\\ldots,R_{n})</span> of degree <span class="math">d^{</em>}</span>, that is, <span class="math">C^{\\prime}_{d^{<em>}}(\\vec{R}):=\\sum_{\\vec{i}}c_{\\vec{i}}\\prod_{j=1}^{5}R_{j}^{i_{j}}</span>. By the Schwartz-Zippel lemma, the probability that for a random <span class="math">\\vec{r}\\nleftarrow(\\mathbb{F}^{</em>})^{5}</span> we have <span class="math">C^{\\prime}_{d^{<em>}}(\\vec{r})=0</span> is bounded by <span class="math">\\frac{d^{</em>}}{p-1}</span> where <span class="math">d^{*}</span> is upper-bounded by the total degree of <span class="math">Q_{P}</span>, which is at most <span class="math">(2n-1)^{2}</span>. We thus have <span class="math">Q^{\\prime}_{P}\\not\\equiv 0</span> with probability at least <span class="math">1-\\frac{(2n-1)^{2}}{p-1}</span>. Since, conditioned on <span class="math">\\mathbf{bad}=1</span>, the adversary returns the solution to the <span class="math">q</span>-DLog instance, with <span class="math">q=2n-1</span>, whenever <span class="math">Q^{\\prime}_{P}\\not\\equiv 0</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathbf{q-dlog}}_{\\mathcal{G},\\mathbf{B}_{\\mathbf{alg}}}\\geq\\big{(}1-\\frac{(2n-1)^{2}}{p-1}\\big{)}\\cdot\\Pr\\left[\\mathbf{bad}=1\\right]\\geq\\frac{1}{2}\\cdot\\Pr\\left[\\mathbf{bad}=1\\right],</span></p>

    <p class="text-gray-300">where the last inequality comes from <span class="math">n^{2}\\leq(p-1)/8</span>. Putting this together with (13) and (17), we have shown that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathbf{knw-snd}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathbf{alg}},\\mathsf{X}_{\\mathsf{A}}}\\leq\\frac{q^{2}}{p-1}+2\\cdot\\mathbf{Adv}^{\\mathbf{q-dlog}}_{\\mathcal{G},\\mathbf{B}_{\\mathbf{alg}}}.</span></p>

    <p class="text-gray-300">Following the generic bound for Boneh and Boyen’s SDH assumption <em>[x1]</em> (see below), we may assume that <span class="math">\\mathbf{Adv}^{\\mathbf{q-dlog}}_{\\mathcal{G},\\mathbf{B}_{\\mathbf{alg}}}\\geq\\frac{q^{2}}{p-1}</span>. The above equation thus implies</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Adv}^{\\mathbf{knw-snd}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathbf{alg}},\\mathsf{X}_{\\mathsf{A}}}\\leq 3\\cdot\\mathbf{Adv}^{\\mathbf{q-dlog}}_{\\mathcal{G},\\mathbf{B}_{\\mathbf{alg}}},</span></p>

    <p class="text-gray-300">which concludes the proof.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Corollary 7.3</h6>

    <p class="text-gray-300">In the generic group model breaking knowledge soundness of Groth’s SNARK <em>[x13]</em> for a degree-<span class="math">n</span> QAP is <span class="math">(\\frac{3t^{2}q+3q^{3}}{p},t)</span>-hard for <span class="math">q=2n-1</span>.</p>

    <p class="text-gray-300">The corollary follows from the generic <span class="math">(\\frac{t^{2}q+q^{3}}{p},t)</span>-hardness of <span class="math">q</span>-<span class="math">\\mathbf{dlog}</span>, which is derived analogously to the bound for Boneh and Boyen’s SDH assumption <em>[x1]</em>.</p>

    <p class="text-gray-300">We remark that the above result is not specific to Groth’s SNARK; it applies to any SNARK built from a NILP whose setup evaluates multivariate polynomials on a random position. The maximal total degree of these polynomials determines the parameter <span class="math">q</span> in the <span class="math">q</span>-DLog instance.</p>

    <h2 id="sec-24" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Balthazar Bauer for pointing out a flaw and a fix in the proof of Theorem 7.2. We also thank Dan Brown for valuable comments, Pooya Farshim for discussions on polynomiels and Helger Lipmaa for sharing with us his independent security proof for Groth’s SNARK. The first author is supported by the French ANR EfTrEC project (ANR-16-CE39-0002). The second author was supported in part by ERC Project ERCC (FP7/615074) and by DFG SPP 1736 Big Data. The third author was supported by ERC Project ERCC (FP7/615074).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABM15] Michel Abdalla, Fabrice Benhamouda, and Philip MacKenzie. Security of the J-PAKE password-authenticated key exchange protocol. In 2015 IEEE Symposium on Security and Privacy, pages 571–587. IEEE Computer Society Press, May 2015. (Cited on page 2.)</li>

      <li>[ABR01] Michel Abdalla, Mihir Bellare, and Phillip Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In David Naccache, editor, CT-RSA 2001, volume 2020 of LNCS, pages 143–158. Springer, Heidelberg, April 2001. (Cited on page 3, 10.)</li>

      <li>[ABS16] Miguel Ambrona, Gilles Barthe, and Benedikt Schmidt. Automated unbounded analysis of cryptographic constructions in the generic group model. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 822–851. Springer, Heidelberg, May 2016. (Cited on page 6.)</li>

      <li>[ACdM05] Giuseppe Ateniese, Jan Camenisch, and Breno de Medeiros. Untraceable RFID tags via insubvertible encryption. In Vijayalakshmi Atluri, Catherine Meadows, and Ari Juels, editors, ACM CCS 05, pages 92–101. ACM Press, November 2005. (Cited on page 3.)</li>

      <li>[ACHdM05] Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, and Breno de Medeiros. Practical group signatures without random oracles. Cryptology ePrint Archive, Report 2005/385, 2005. http://eprint.iacr.org/2005/385. (Cited on page 3.)</li>

      <li>[AGO11] Masayuki Abe, Jens Groth, and Miyako Ohkubo. Separating short structure-preserving signatures from non-interactive assumptions. In Dong Hoon Lee and Xiaoyun Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 628–646. Springer, Heidelberg, December 2011. (Cited on page 2.)</li>

      <li>[AM09] Divesh Aggarwal and Ueli Maurer. Breaking RSA generically is equivalent to factoring. In Antoine Joux, editor, EUROCRYPT 2009, volume 5479 of LNCS, pages 36–53. Springer, Heidelberg, April 2009. (Cited on page 2, 4.)</li>

      <li>[BB08] Dan Boneh and Xavier Boyen. Short signatures without random oracles and the SDH assumption in bilinear groups. Journal of Cryptology, 21(2):149–177, April 2008. (Cited on page 23.)</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, March 2013. (Cited on page 17.)</li>

      <li>[BCL04] E. Bangerter, J. Camenisch, and A. Lysyanskaya. A cryptographic framework for the controlled release of certified data. In Security Protocols Workshop, pages 20–24, 2004. (Cited on page 3.)</li>

      <li>[BCPR16] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. SIAM Journal on Computing, 2016. (Cited on page 5.)</li>

      <li>[BCS05] M. Backes, J. Camenisch, and D. Sommer. Anonymous yet accountable access control. In WPES, pages 40–46, 2005. (Cited on page 3.)</li>

    </ul>

    <p class="text-gray-300">[BDZ03] Feng Bao, Robert H. Deng, and Huafei Zhu. Variations of Diffie-Hellman problem. In Sihan Qing, Dieter Gollmann, and Jianying Zhou, editors, ICICS 03, volume 2836 of LNCS, pages 301–312. Springer, Heidelberg, October 2003. (Cited on page 9.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BFF^{+}14] Gilles Barthe, Edvard Fagerholm, Dario Fiore, John C. Mitchell, Andre Scedrov, and Benedikt Schmidt. Automated analysis of cryptographic assumptions in generic group models. In Juan A. Garay and Rosario Gennaro, editors, CRYPTO 2014, Part I, volume 8616 of LNCS, pages 95–112. Springer, Heidelberg, August 2014. (Cited on page 4, 6.)</li>

      <li>[BFW16] David Bernhard, Marc Fischlin, and Bogdan Warinschi. On the hardness of proving CCA-security of signed ElGamal. In Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang, editors, PKC 2016, Part I, volume 9614 of LNCS, pages 47–69. Springer, Heidelberg, March 2016. (Cited on page 2.)</li>

      <li>[BG04] Daniel R. L. Brown and Robert P. Gallant. The static diffie-hellman problem. Cryptology ePrint Archive, Report 2004/306, 2004. http://eprint.iacr.org/2004/306. (Cited on page 4.)</li>

      <li>[BL96] Dan Boneh and Richard J. Lipton. Algorithms for black-box fields and their application to cryptography (extended abstract). In Neal Koblitz, editor, CRYPTO’96, volume 1109 of LNCS, pages 283–297. Springer, Heidelberg, August 1996. (Cited on page 1.)</li>

      <li>[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing. Journal of Cryptology, 17(4):297–319, September 2004. (Cited on page 3, 13.)</li>

      <li>[BMV08] Emmanuel Bresson, Jean Monnerat, and Damien Vergnaud. Separation results on the “one-more” computational problems. In Tal Malkin, editor, CT-RSA 2008, volume 4964 of LNCS, pages 71–87. Springer, Heidelberg, April 2008. (Cited on page 2.)</li>

      <li>[Boy08] Xavier Boyen. The uber-assumption family (invited talk). In Steven D. Galbraith and Kenneth G. Paterson, editors, PAIRING 2008, volume 5209 of LNCS, pages 39–56. Springer, Heidelberg, September 2008. (Cited on page 5, 6.)</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, ACM CCS 93, pages 62–73. ACM Press, November 1993. (Cited on page 7.)</li>

      <li>[BR04] Mihir Bellare and Phillip Rogaway. Code-based game-playing proofs and the security of triple encryption. Cryptology ePrint Archive, Report 2004/331, 2004. http://eprint.iacr.org/2004/331. (Cited on page 6.)</li>

      <li>[BV98] Dan Boneh and Ramarathnam Venkatesan. Breaking RSA may not be equivalent to factoring. In Kaisa Nyberg, editor, EUROCRYPT’98, volume 1403 of LNCS, pages 59–71. Springer, Heidelberg, May / June 1998. (Cited on page 2, 7.)</li>

      <li>[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited (preliminary version). In 30th ACM STOC, pages 209–218. ACM Press, May 1998. (Cited on page 5.)</li>

    </ul>

    <p class="text-gray-300">[Che06] Jung Hee Cheon. Security analysis of the strong Diffie-Hellman problem. In Serge Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 1–11. Springer, Heidelberg, May / June 2006. (Cited on page 4, 12.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CHK^{+}06] Jan Camenisch, Susan Hohenberger, Markulf Kohlweiss, Anna Lysyanskaya, and Mira Meyerovich. How to win the clonewars: Efficient periodic n-times anonymous authentication. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, ACM CCS 06, pages 201–210. ACM Press, October / November 2006. (Cited on page 3.)</li>

      <li>[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Ronald Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 302–321. Springer, Heidelberg, May 2005. (Cited on page 3.)</li>

      <li>[CHP07] Jan Camenisch, Susan Hohenberger, and Michael Østergaard Pedersen. Batch verification of short signatures. In Moni Naor, editor, EUROCRYPT 2007, volume 4515 of LNCS, pages 246–263. Springer, Heidelberg, May 2007. (Cited on page 3.)</li>

      <li>[CL04] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Matthew Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 56–72. Springer, Heidelberg, August 2004. (Cited on page 3, 11.)</li>

      <li>[CM14] Melissa Chase and Sarah Meiklejohn. Déjà Q: Using dual systems to revisit q-type assumptions. In Phong Q. Nguyen and Elisabeth Oswald, editors, EUROCRYPT 2014, volume 8441 of LNCS, pages 622–639. Springer, Heidelberg, May 2014. (Cited on page 5.)</li>

      <li>[Cor02] Jean-Sébastien Coron. Optimal security proofs for PSS and other signature schemes. In Lars R. Knudsen, editor, EUROCRYPT 2002, volume 2332 of LNCS, pages 272–287. Springer, Heidelberg, April / May 2002. (Cited on page 2, 3.)</li>

      <li>[Dam92] Ivan Damgård. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, CRYPTO’91, volume 576 of LNCS, pages 445–456. Springer, Heidelberg, August 1992. (Cited on page 3, 5.)</li>

      <li>[Den02] Alexander W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In Yuliang Zheng, editor, ASIACRYPT 2002, volume 2501 of LNCS, pages 100–109. Springer, Heidelberg, December 2002. (Cited on page 5.)</li>

      <li>[DH76] Whitfield Diffie and Martin E. Hellman. New directions in cryptography. IEEE Transactions on Information Theory, 22(6):644–654, 1976. (Cited on page 3, 9.)</li>

      <li>[FKL17] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. Cryptology ePrint Archive, Report 2017/620, 2017. (Cited on page .)</li>

      <li>[GBL08] Sanjam Garg, Raghav Bhaskar, and Satyanarayana V. Lokam. Improved bounds on security reductions for discrete log based signatures. In David Wagner, editor, CRYPTO 2008, volume 5157 of LNCS, pages 93–107. Springer, Heidelberg, August 2008. (Cited on page 2.)</li>

      <li>[GG17] Jens Groth and Essam Ghadafi. Towards a classification of non-interactive computational assumptions in cyclic groups. In Tsuyoshi Takagi and Thomas Peyrin,</li>

    </ul>

    <p class="text-gray-300">editors, ASIACRYPT 2017, volume 10625 of LNCS, pages 66–96, Hong Kong, December 2017. Springer. (Cited on page 5.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013. (Cited on page 16.)</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016. (Cited on page 3, 16, 17, 18, 19, 21, 23.)</li>

      <li>[HP78] M. E. Hellman and S. C. Pohlig. An improved algorithm for computing logarithms over <span class="math">GF(p)</span> and its cryptographic significance. IEEE Transactions on Information Theory, 24(1):106–110, 1978. (Cited on page 2.)</li>

      <li>[JR10] Tibor Jager and Andy Rupp. The semi-generic group model and applications to pairing-based cryptography. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 539–556. Springer, Heidelberg, December 2010. (Cited on page 2, 5.)</li>

      <li>[JR15] Antoine Joux and Antoine Rojat. Security ranking among assumptions within the Uber Assumption framework. In Yvo Desmedt, editor, ISC 2013, volume 7807 of LNCS, pages 391–406. Springer, Heidelberg, November 2015. (Cited on page 5.)</li>

      <li>[JS09] Tibor Jager and Jörg Schwenk. On the analysis of cryptographic assumptions in the generic ring model. In Mitsuru Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 399–416. Springer, Heidelberg, December 2009. (Cited on page 4.)</li>

      <li>[Kil01] Eike Kiltz. A tool box of cryptographic functions related to the Diffie-Hellman function. In C. Pandu Rangan and Cunsheng Ding, editors, INDOCRYPT 2001, volume 2247 of LNCS, pages 339–350. Springer, Heidelberg, December 2001. (Cited on page 5.)</li>

      <li>[KK12] Saqib A. Kakvi and Eike Kiltz. Optimal security proofs for full domain hash, revisited. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 537–553. Springer, Heidelberg, April 2012. (Cited on page 3.)</li>

      <li>[KMP16] Eike Kiltz, Daniel Masny, and Jiaxin Pan. Optimal security proofs for signatures from identification schemes. In Matthew Robshaw and Jonathan Katz, editors, CRYPTO 2016, Part II, volume 9815 of LNCS, pages 33–61. Springer, Heidelberg, August 2016. (Cited on page 2.)</li>

      <li>[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In Nigel P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 146–162. Springer, Heidelberg, April 2008. (Cited on page 6.)</li>

      <li>[LR06] Gregor Leander and Andy Rupp. On the equivalence of RSA and factoring regarding generic ring algorithms. In Xuejia Lai and Kefei Chen, editors, ASIACRYPT 2006, volume 4284 of LNCS, pages 241–251. Springer, Heidelberg, December 2006. (Cited on page 2.)</li>

    </ul>

    <p class="text-gray-300">[LRSW99] Anna Lysyanskaya, Ronald L. Rivest, Amit Sahai, and Stefan Wolf. Pseudonym systems. In Howard M. Heys and Carlisle M. Adams, editors, SAC 1999, volume 1758 of LNCS, pages 184–199. Springer, Heidelberg, August 1999. (Cited on page 3, 4, 11.)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Mau05] Ueli M. Maurer. Abstract models of computation in cryptography (invited paper). In Nigel P. Smart, editor, 10th IMA International Conference on Cryptography and Coding, volume 3796 of LNCS, pages 1–12. Springer, Heidelberg, December 2005. (Cited on page 1, 5, 6, 8.)</li>

      <li>[MRV16] Paz Morillo, Carla Ràfols, and Jorge Luis Villar. The kernel matrix Diffie-Hellman assumption. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part I, volume 10031 of LNCS, pages 729–758. Springer, Heidelberg, December 2016. (Cited on page 5.)</li>

      <li>[MW98] Ueli M. Maurer and Stefan Wolf. Lower bounds on generic algorithms in groups. In Kaisa Nyberg, editor, EUROCRYPT’98, volume 1403 of LNCS, pages 72–84. Springer, Heidelberg, May / June 1998. (Cited on page 1, 6.)</li>

      <li>[MW99] Ueli Maurer and Stefan Wolf. The relationship between breaking the diffie-hellman protocol and computing discrete logarithms. SIAM Journal on Computing, 28(5):1689–1721, 1999. (Cited on page 9.)</li>

      <li>[Nec94] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. Mathematical Notes, 55(2):165–172, 1994. (Cited on page 1.)</li>

      <li>[Pol78] J. M. Pollard. Monte Carlo methods for index computation mod <span class="math">p</span>. Mathematics of Computation, 32:918–924, 1978. (Cited on page 2.)</li>

      <li>[PV05] Pascal Paillier and Damien Vergnaud. Discrete-log-based signatures may not be equivalent to discrete log. In Bimal K. Roy, editor, ASIACRYPT 2005, volume 3788 of LNCS, pages 1–20. Springer, Heidelberg, December 2005. (Cited on page 2, 7.)</li>

      <li>[Riv04] Ronald L. Rivest. On the notion of pseudo-free groups. In Moni Naor, editor, TCC 2004, volume 2951 of LNCS, pages 505–521. Springer, Heidelberg, February 2004. (Cited on page 2.)</li>

      <li>[RLB^{+}08] Andy Rupp, Gregor Leander, Endre Bangerter, Alexander W. Dent, and Ahmad-Reza Sadeghi. Sufficient conditions for intractability over black-box groups: Generic lower bounds for generalized DL and DH problems. In Josef Pieprzyk, editor, ASIACRYPT 2008, volume 5350 of LNCS, pages 489–505. Springer, Heidelberg, December 2008. (Cited on page 6.)</li>

      <li>[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, EUROCRYPT’97, volume 1233 of LNCS, pages 256–266. Springer, Heidelberg, May 1997. (Cited on page 1, 5, 6, 8.)</li>

      <li>[Sho04] Victor Shoup. Sequences of games: a tool for taming complexity in security proofs. Cryptology ePrint Archive, Report 2004/332, 2004. http://eprint.iacr.org/2004/332. (Cited on page 29.)</li>

    </ul>

    <p class="text-gray-300">[SS01] Ahmad-Reza Sadeghi and Michael Steiner. Assumptions related to discrete logarithms: Why subtleties make a real difference. In Birgit Pfitzmann, editor, EUROCRYPT 2001, volume 2045 of LNCS, pages 244-261. Springer, Heidelberg, May 2001. (Cited on page 5.)</p>

    <p class="text-gray-300">Proof. We prove that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {c d h}} \\geq \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {s d h}} - q \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {C} _ {\\mathrm {a l g}}} ^ {\\mathbf {l c} - \\mathbf {d h}}. \\tag {20}</span></div>

    <p class="text-gray-300">Applying Theorem 3.1 yields the theorem. We now prove (20) via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} \\coloneqq \\mathbf{sdh}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathrm{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is an algebraic adversary, it returns a vector  <span class="math">\\vec{a}</span>  along with  <span class="math">\\mathbf{Z}</span>  at the end of the game such that  <span class="math">\\mathbf{Z} = g^{a_1}\\mathbf{X}^{a_2}\\mathbf{Y}^{a_3}</span> . Furthermore, for any query asked to  <span class="math">\\mathsf{O}(\\cdot ,\\cdot)</span> , it includes vectors  <span class="math">\\vec{b},\\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}\\mathbf{X}^{b_2}\\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1}\\mathbf{X}^{c_2}\\mathbf{Y}^{c_3}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figure 21.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G0, G1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q([Y']b, [Z']c):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 x, y ⇌ Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">04 If b2 ≠ 0 ∨ b3 ≠ 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 (X, Y) := (gx, gy)</td>

            <td class="px-3 py-2 border-b border-gray-700">05 Return 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 [Z]a ⇌ Aol(·,·)(X, Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Return (Z' = (Y')x)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  03 Return Z = gxy |   |</p>

    <p class="text-gray-300">Figure 21: Games  <span class="math">\\mathbf{G_0}</span>  and  <span class="math">\\mathbf{G_1}</span> . The boxed statements are only executed in  <span class="math">\\mathbf{G_1}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : For game  <span class="math">\\mathbf{G_1}</span>  we alter the way that the oracle  <span class="math">\\mathsf{O}(\\cdot ,\\cdot)</span>  answers queries. Namely, if  <span class="math">b_{2}\\neq 0\\lor b_{3}\\neq 0</span> , it always returns 0. Game  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 21. The check performed by the oracle in  <span class="math">\\mathbf{G_1}</span>  amounts to checking whether  <span class="math">\\mathbf{Z}&#x27; = \\mathbf{X}^{b_1}</span> , since if  <span class="math">b_{2} = b_{3} = 0</span>  then  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}</span> . Using this property of  <span class="math">\\mathbf{G_1}</span> , we show an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  such that  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathrm{alg}}}^{\\mathbf{cdh}} = \\operatorname*{Pr}[\\mathbf{G_1} = 1]</span> .  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  is depicted in Figure 22.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Balg(X = gx, Y = gy)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q([Y']b, [Z']c):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 [Z]a ⇌ Aol(·,·)(X, Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">02 If b2 ≠ 0 ∨ b3 ≠ 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 Return Z</td>

            <td class="px-3 py-2 border-b border-gray-700">03 Return 0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 04 Return Z' = Xb1  |</p>

    <p class="text-gray-300">Figure 22: Behavior of adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span></p>

    <p class="text-gray-300">We now show the existence of adversary  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G} _ {0}} - \\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G} _ {1}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {C} _ {\\mathrm {a l g}}} ^ {\\mathbf {l c d h}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let  <span class="math">F</span>  denote the event that  <span class="math">\\mathbf{Z}&#x27; = (\\mathbf{Y}&#x27;)^x \\wedge (b_2 \\neq 0 \\lor b_3 \\neq 0)</span>  in at least one call to the oracle. Clearly, as long as  <span class="math">F</span>  does not occur, the games behave identically. By the difference lemma [Sho04], we obtain</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\mathbf {G _ {0}} = 1 ] - \\Pr [ \\mathbf {G _ {1}} = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr [ F ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We show the existence of  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ F ] \\leq q \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathrm {C} _ {\\mathrm {a l g}}} ^ {\\mathbf {l c - d h}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Calg(X=g^x,Y=gy)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q([Y']_b, [Z']_c):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 Q := ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">05 If b2 ≠ 0 ∨ b3 ≠ 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 [Z]a←A_algO(·,·)(X,Y)</td>

            <td class="px-3 py-2 border-b border-gray-700">06 If b2 ≠ 0 ∧ b3 ≠ 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Z←Q</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Q := Q ∪ {Z'}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Obtain b1,b2,b3 as described</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Return 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">04 Return (ZX-b1,b2,b3,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">09 Return (Z' = Xb1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 23: Behavior of adversary  <span class="math">C_{\\mathrm{alg}}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  is depicted in Figure 23.</p>

    <p class="text-gray-300">We now analyze  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span> . Clearly,  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span>  runs in the same time as  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> . Once  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  halts,  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  picks at random  <span class="math">\\tilde{\\mathbf{Z}}</span>  that was input by  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  as one of at most  <span class="math">q</span>  queries to  <span class="math">\\mathsf{O}(\\cdot, \\cdot)</span>  along with  <span class="math">\\tilde{\\mathbf{Y}}</span>  and  <span class="math">\\vec{b}, \\vec{c}</span>  such that  <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {Y}} = g ^ {b _ {1}} \\mathbf {X} ^ {b _ {2}} \\mathbf {Y} ^ {b _ {3}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {Z}} = g ^ {c _ {1}} \\mathbf {X} ^ {c _ {2}} \\mathbf {Y} ^ {c _ {3}}.</span></div>

    <p class="text-gray-300">Clearly, if  <span class="math">(\\tilde{\\mathbf{Y}})^x = \\tilde{\\mathbf{Z}}</span>  then  <span class="math">(\\tilde{\\mathbf{Z}}\\mathbf{X}^{-b_1},b_2,b_3,0)</span>  yields a winning solution for  <span class="math">\\mathbf{lc - dh}_{\\mathcal{G}}^{\\mathsf{C}_{\\mathrm{alg}}}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {Z}} \\mathbf {X} ^ {- b _ {1}} = (\\tilde {\\mathbf {Y}}) ^ {x} \\mathbf {X} ^ {- b _ {1}} = g ^ {b _ {2} x ^ {2} + b _ {3} x y}.</span></div>

    <p class="text-gray-300">As  <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>  picks  <span class="math">\\tilde{\\mathbf{Z}}</span>  at random from at most  <span class="math">q</span>  elements in  <span class="math">Q</span> , it picks a correct solution with probability at least  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathrm{alg}}}^{\\mathbf{lc - dh}} \\geq \\frac{\\operatorname<em>{Pr}[F]}{q}</span> . This yields  <span class="math">\\operatorname</em>{Pr}[F] \\leq q \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathrm{alg}}}^{\\mathbf{lc - dh}}</span> . Thus, we now have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathbf {A d v} _ {\\mathcal {G}, \\mathbf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {c d h}} = \\Pr [ \\mathbf {G} _ {\\mathbf {1}} = 1 ] \\\\ \\geq \\Pr [ \\mathbf {G} _ {\\mathbf {0}} = 1 ] -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {A d v} _ {\\mathcal {G}, \\mathbf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G} _ {\\mathbf {0}}} - \\mathbf {A d v} _ {\\mathcal {G}, \\mathbf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {G} _ {\\mathbf {1}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\geq \\mathbf {A d v} _ {\\mathcal {G}, \\mathbf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {c d h}} - q \\cdot \\mathbf {A d v} _ {\\mathcal {G}, \\mathbf {C} _ {\\mathrm {a l g}}} ^ {\\mathbf {l c - d h}}. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">It is straight forward to see that all the steps performed in the above simulations are generic. This proves (20).</p>

    <p class="text-gray-300">Proof. We prove the statement via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} \\coloneqq \\mathbf{lrsw}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathrm{alg}}}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figures 24. As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is an algebraic adversary, at the end of the game, it outputs a winning tuple  <span class="math">(m^{<em>},\\mathbf{A}^{</em>},\\mathbf{B}^{<em>},\\mathbf{C}^{</em>})</span>  along with vectors  <span class="math">\\vec{a},\\vec{b},\\vec{c}</span>  that provide the representation of  <span class="math">\\mathbf{A}^{<em>},\\mathbf{B}^{</em>},\\mathbf{C}^{*}</span>  relative to  <span class="math">g,\\mathbf{X},\\mathbf{Y}</span>  and the answers  <span class="math">\\mathbf{A}_1,\\dots,\\mathbf{A}_q,\\mathbf{B}_1,\\dots,\\mathbf{B}_q,\\mathbf{C}_1,\\dots,\\mathbf{C}_q</span>  from previous oracle queries, where  <span class="math">\\mathbf{A}_i = g^{r_i}</span> ,  <span class="math">\\mathbf{B}_i = g^{r_iy}</span> , and  <span class="math">\\mathbf{C}_i = g^{r_i(yxm_i + x)}</span> .</p>

    <p class="text-gray-300">Concretely, the representations of  <span class="math">\\mathbf{A}^<em></span> ,  <span class="math">\\mathbf{B}^</em></span> , and  <span class="math">\\mathbf{C}^*</span>  are as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {A} _ {i} ^ {a _ {i}} g ^ {a _ {q + 1}} \\prod_ {i = q + 2} ^ {2 q + 1} \\mathbf {B} _ {i - q - 1} ^ {a _ {i}} \\prod_ {i = 2 q + 2} ^ {3 q + 1} \\mathbf {C} _ {i - 2 q - 1} ^ {a _ {i}} \\mathbf {X} ^ {a _ {3 q + 2}} \\mathbf {Y} ^ {a _ {3 q + 3}}, \\tag {21}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {B} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {A} _ {i} ^ {b _ {i}} g ^ {b _ {q + 1}} \\prod_ {i = q + 2} ^ {2 q + 1} \\mathbf {B} _ {i - q - 1} ^ {b _ {i}} \\prod_ {i = 2 q + 2} ^ {3 q + 1} \\mathbf {C} _ {i - 2 q - 1} ^ {b _ {i}} \\mathbf {X} ^ {b _ {3 q + 2}} \\mathbf {Y} ^ {b _ {3 q + 3}}, \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {C} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {C} _ {i} ^ {c _ {i}} \\mathbf {X} ^ {c _ {q + 1}} \\prod_ {i = q + 2} ^ {2 q + 1} \\mathbf {A} _ {i - q - 1} ^ {c _ {i}} \\prod_ {i = 2 q + 2} ^ {3 q + 1} \\mathbf {B} _ {i - 2 q - 1} ^ {c _ {i}} g ^ {c _ {3 q + 2}} \\mathbf {Y} ^ {c _ {3 q + 3}}. \\tag {23}</span></div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 24: Games  <span class="math">\\mathbf{G_0}</span>  and  <span class="math">\\mathbf{G_1}</span>  with algebraic adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> . The boxed statements are only executed in  <span class="math">\\mathbf{G_1}</span> .</p>

    <p class="text-gray-300">We assume that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  never queries the oracle on the same message  <span class="math">m_{i}</span>  more than once. (Multiple queries can be simulated by rerandomization.)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : In  <span class="math">\\mathbf{G_1}</span>  we consider a slightly altered game that is defined as follows. Before the first query is asked, the challenger in  <span class="math">\\mathbf{G_1}</span>  also chooses values  <span class="math">k^{<em>},\\ell^{</em>},i^{<em>}\\stackrel {\\mathrm{a}}{\\leftarrow}\\{1,\\dots,q\\}</span> . If  <span class="math">k^{</em>} = \\ell^{<em>}\\lor k^{</em>} = i^{<em>}\\lor \\ell^{</em>} = i^{*}</span> , it aborts the game.  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 24. Clearly,  <span class="math">\\left(1 - \\frac{3}{q}\\right)\\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G_0}} = \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathrm{alg}}}^{\\mathbf{G_1}}</span> . By defining  <span class="math">s_1,s_2,t_1,t_2,u_1,u_2,v_1,v_2\\in \\mathbb{Z}_p</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">s _ {1} := a _ {3 q + 2} + \\sum_ {i = 2 q + 3} ^ {3 q + 2} a _ {i} r _ {i - 2 q - 2}, \\quad s _ {2} := c _ {q + 1} + \\sum_ {i = 1} ^ {q} c _ {i} r _ {i},</span></div>

    <div class="my-4 text-center"><span class="math-block">t _ {1} := \\sum_ {i = 2 q + 3} ^ {3 q + 2} a _ {i} m _ {i} r _ {i - 2 q - 2}, \\quad t _ {2} := \\sum_ {i = 1} ^ {q} c _ {i} m _ {i} r _ {i},</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {1} := a _ {3 q + 3} + \\sum_ {i = q + 2} ^ {2 q + 1} a _ {i} r _ {i - q - 1}, \\quad u _ {2} := c _ {3 q + 3} + \\sum_ {i = 2 q + 2} ^ {3 q + 1} c _ {i} r _ {i - q - 1},</span></div>

    <div class="my-4 text-center"><span class="math-block">v _ {1} := g ^ {a _ {q + 1}} + \\sum_ {i = 1} ^ {q} a _ {i} r _ {i}, \\quad v _ {2} := g ^ {c _ {3 q + 2}} + \\sum_ {i = q + 2} ^ {2 q + 1} c _ {i} r _ {i - q - 1},</span></div>

    <p class="text-gray-300">equations (21) and (23) can be further simplified to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {*} = g ^ {s _ {1} x + t _ {1} x y + u _ {1} y + v _ {1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {C} ^ {*} = g ^ {s _ {2} x + t _ {2} x y + u _ {2} y + v _ {2}}.</span></div>

    <p class="text-gray-300">We also define the parameters  <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta := m ^ {*} t _ {1} y ^ {2} + t _ {1} y + s _ {1} m ^ {*} y + s _ {1}, \\tag {24}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta^ {\\prime} := u _ {1} m ^ {*} y ^ {2} + m ^ {*} y v _ {1} + u _ {1} y - t _ {2} y - s _ {2} + v _ {1}, \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta^ {\\prime \\prime} := u _ {2} y + v _ {2}, \\tag {26}</span></div>

    <p class="text-gray-300">and the boolean variable  <span class="math">F^{*}</span>  as</p>

    <div class="my-4 text-center"><span class="math-block">F ^ {*} = 1 \\Leftrightarrow s _ {1} \\equiv_ {p} t _ {1} \\equiv_ {p} u _ {1} \\equiv_ {p} u _ {2} \\equiv_ {p} v _ {2} \\equiv_ {p} 0. \\tag {27}</span></div>

    <p class="text-gray-300">We prove the following lemma that allows us to rewrite  <span class="math">\\mathbf{A}^<em></span>  and  <span class="math">\\mathbf{C}^</em></span>  in a more convenient form.</p>

    <p class="text-gray-300">Lemma A.1 If <span class="math">F^{*} = 1</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {A} _ {i} ^ {\\varepsilon_ {i}}, \\quad \\mathbf {C} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {C} _ {i} ^ {\\delta_ {i}}</span></div>

    <p class="text-gray-300">holds for</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {i} := \\left\\{ \\begin{array}{l l} c _ {i} &amp;amp; i \\notin \\{k ^ {*}, \\ell^ {*} \\} \\\\ c _ {\\ell^ {*}} - \\frac {r _ {k ^ {*}} m _ {k ^ {*}} c _ {q + 1}}{(r _ {\\ell^ {*}} m _ {\\ell^ {*}}) (r _ {k ^ {*}} - r _ {k ^ {*}} \\frac {m _ {k ^ {*}}}{m _ {\\ell^ {*}}})} &amp;amp; i = \\ell^ {*} \\\\ c _ {k ^ {*}} + \\frac {c _ {q + 1}}{r _ {k ^ {*}} - r _ {k ^ {*}} \\frac {m _ {k ^ {*}}}{m _ {\\ell^ {*}}}} &amp;amp; i = k ^ {*} \\end{array} \\right.</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_ {i} := \\left\\{ \\begin{array}{l l} a _ {i} &amp;amp; i \\neq k ^ {*} \\\\ a _ {k ^ {*}} + \\frac {a _ {q + 1}}{r _ {k ^ {*}}} &amp;amp; i = k ^ {*} \\end{array} \\right..</span></div>

    <p class="text-gray-300">Using Lemma A.1, we can now formulate the following conditions whenever <span class="math">\\mathbf{G_1}</span> does not abort. To further simplify the notation, we define the following Boolean variables:</p>

    <div class="my-4 text-center"><span class="math-block">G ^ {*} = 1 \\Leftrightarrow \\Delta \\neq_ {p} 0 \\vee \\Delta^ {\\prime} \\neq_ {p} 0 \\vee \\Delta^ {\\prime \\prime} \\neq_ {p} 0</span></div>

    <div class="my-4 text-center"><span class="math-block">H ^ {*} := 1 \\Leftrightarrow \\forall j \\notin \\{\\ell^ {*}, k ^ {*} \\}: r _ {j} \\varepsilon_ {j} (1 + m ^ {*} y) - r _ {j} \\delta_ {j} (1 + y m _ {j}) \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">Note that <span class="math">H^{<em>}</span> is only well defined (by Lemma A.1) if <span class="math">F^{</em>} = 1</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Condition <span class="math">F_{1}</span>: This condition holds iff <span class="math">G^{*}</span>.</li>

      <li>Condition <span class="math">F_{2}</span>: This condition holds iff <span class="math">(\\neg G^{<em>} \\land \\neg F^{</em>}) \\lor (F^{<em>} \\land H^{</em>})</span>.</li>

      <li>Condition <span class="math">F_{3}</span>: This condition holds iff <span class="math">F^{<em>} \\wedge \\neg H^{</em>}</span>.</li>

    </ul>

    <p class="text-gray-300">It is easy to see that <span class="math">F_{1} \\vee F_{2} \\vee F_{3} = 1</span>. We will now describe the behavior of adversaries <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}, \\mathsf{E}_{\\mathrm{alg}}</span> playing in the discrete logarithm game. Each of these adversaries simulates <span class="math">\\mathbf{G_1}</span> to <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> in a different way. Concretely, we prove the following Lemma.</p>

    <p class="text-gray-300">Lemma A.2 There exist <span class="math">\\mathsf{C}_{\\mathrm{alg}},\\mathsf{D}_{\\mathrm{alg}},\\mathsf{E}_{\\mathrm{alg}}</span> playing in the discrete logarithm game such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {d l o g} ^ {\\mathrm {C} _ {\\text {a l g}}} = 1 \\right] = \\Pr \\left[ \\mathbf {G} _ {1} = 1 \\mid F _ {1} \\right] \\tag {28}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {d l o g} ^ {\\mathrm {D} _ {\\mathrm {a l g}}} = 1 \\right] \\geq (1 - \\frac {2}{q}) \\Pr \\left[ \\mathbf {G} _ {1} = 1 \\mid F _ {2} \\right] \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {d l o g} ^ {\\mathrm {E} _ {\\mathrm {a l g}}} = 1 \\right] \\geq \\frac {1}{q} \\Pr \\left[ \\mathbf {G} _ {1} = 1 \\mid F _ {3} \\right]. \\tag {30}</span></div>

    <p class="text-gray-300">of Lemma A.1. We first note that <span class="math">\\delta_{l^<em>},\\delta_{k^</em>}</span> are well defined, because <span class="math">\\ell^{<em>}\\neq k^{</em>}</span> and thus <span class="math">m_{\\ell^{<em>}}\\neq m_{k^{</em>}}</span>. Otherwise <span class="math">\\mathbf{G_1}</span> aborts and there is nothing to prove (since nothing is returned by <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> in this case). Observe that since <span class="math">F^{*} = 1\\Leftrightarrow s_{1}\\equiv_{p}t_{1}\\equiv_{p}u_{1}\\equiv_{p}u_{2}\\equiv_{p}v_{2}\\equiv_{p}0</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {*} = g ^ {a _ {q + 1}} \\prod_ {i = 1} ^ {q} \\mathbf {A} _ {i} ^ {a _ {i}} \\quad \\text{and} \\quad \\mathbf {C} ^ {*} = \\mathbf {X} ^ {c _ {q + 1}} \\prod_ {i = 1} ^ {q} \\mathbf {C} _ {i} ^ {c _ {i}}.</span></div>

    <p class="text-gray-300">Now, the choices of <span class="math">\\delta_1,\\ldots ,\\delta_q,\\epsilon_1,\\ldots ,\\epsilon_q</span> satisfy</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {A} _ {i} ^ {\\epsilon_ {i}} \\quad \\text{and} \\quad \\mathbf {C} ^ {*} = \\prod_ {i = 1} ^ {q} \\mathbf {C} _ {i} ^ {\\delta_ {i}}.</span></div>

    <p class="text-gray-300">To see this, first observe that <span class="math">\\mathbf{X}</span> can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{X} &amp;amp;= \\left(\\mathbf{X}^{r_{k^*}(1 - m_{k^*}/m_{\\ell^*})}\\right)^{\\frac{1}{r_{k^*}(1 - m_{k^*}/m_{\\ell^*})}} \\\\ &amp;amp;= \\left(g^{r_{k^*}(x + y x m_{k^*})} g^{-r_{\\ell^*}(x + y x m_{\\ell^*})(r_{k^*}m_{k^*})/(r_{\\ell^*}m_{\\ell^*})}\\right)^{\\frac{1}{r_{k^*}(1 - m_{k^*}/m_{\\ell^*})}} \\\\ &amp;amp;= \\left(\\mathbf{C}_{k^*} \\mathbf{C}_{\\ell^*}^{-(r_{k^*}m_{k^*})/(r_{\\ell^*}m_{\\ell^*})}\\right)^{\\frac{1}{r_{k^*}(1 - m_{k^*}/m_{\\ell^*})}}. \\end{aligned}</span></div>

    <p class="text-gray-300">Because of this, setting</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{k^*} := c_{k^*} + \\frac{c_{q+1}}{r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_{\\ell^*} := c_{\\ell^*} - \\frac{r_{k^*} m_{k^*} c_{q+1}}{(r_{\\ell^*} m_{\\ell^*})(r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}})}.</span></div>

    <p class="text-gray-300">and <span class="math">\\delta_i := c_i</span> for <span class="math">i \\notin \\{\\ell^<em>, k^</em>\\}</span> we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^*}^{c_{k^*} \\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}} = \\mathbf{C}_{k^*}^{c_{k^*} \\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}} \\left(\\mathbf{C}_{k^*} \\mathbf{C}_{\\ell^*}^{-(r_{k^*} m_{k^*}) / (r_{\\ell^*} m_{\\ell^*})}\\right)^{\\frac{c_{q+1}}{r_{k^*}(1 - m_{k^*}/m_{\\ell^*})}} = \\mathbf{C}_{k^*}^{\\delta_{k^*} \\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}}}.</span></div>

    <p class="text-gray-300">This means that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{X}^{c_{q+1}} \\prod_i \\mathbf{C}_i^{c_i} = \\left(\\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^*}^{c_{k^*} \\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}}\\right) \\prod_{i \\neq k^* \\ell^*} \\mathbf{C}_i^{c_i} = \\mathbf{C}_{k^*}^{\\delta_{k^*} \\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}}} \\prod_{i \\neq k^* \\ell^*} \\mathbf{C}_i^{\\delta_i} = \\prod_i \\mathbf{C}_i^{\\delta_i}.</span></div>

    <p class="text-gray-300">Also observe that <span class="math">\\mathbf{A}_{k^<em>}^{r_{k^</em>}} = \\mathbf{A}_{k^<em>}^{a_{k^</em>}} g^{a_{q+1}}</span> and thus</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^* = g^{a_{q+1}} \\prod_i \\mathbf{A}_i^{a_i} = \\prod_i \\mathbf{A}_i^{c_i}.</span></div>

    <p class="text-gray-300">Using Lemma A.2 and the fact that <span class="math">F_1 \\vee F_2 \\vee F_3 = 1</span>, it is now straightforward to construct an adversary <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[\\mathbf{d} \\log^{\\mathsf{B}_{\\mathrm{alg}}} = 1\\right] \\geq \\frac{1}{3q} \\Pr\\left[\\mathbf{G}_1 = 1\\right]</span></div>

    <p class="text-gray-300">by letting <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span> emulate one of the adversaries <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}, \\mathsf{E}_{\\mathrm{alg}}</span> (chosen uniformly at random).</p>

    <p class="text-gray-300">of Lemma A.2. Let <span class="math">\\mathbf{Z} = g^z</span> denote the discrete logarithm instance. <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}, \\mathsf{E}_{\\mathrm{alg}}</span> simulate <span class="math">\\mathbf{G}_1</span> to <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>. They begin by sampling <span class="math">k^<em>, \\ell^</em>, i^<em> \\not\\leftrightarrows \\{1, \\dots, q\\}</span>. If <span class="math">k^</em> = \\ell^<em> \\vee k^</em> = i^<em> \\vee \\ell^</em> = i^<em></span>, they abort the simulation. Thus, assume throughout the proof that <span class="math">k^</em> \\neq \\ell^<em>, k^</em> \\neq i^<em>, \\ell^</em> \\neq i^*</span></p>

    <p class="text-gray-300"><strong>Adversary <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span></strong>. Adversary <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span> samples <span class="math">\\alpha \\not\\leftrightarrows \\mathbb{Z}_p</span> and computes <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (\\mathbf{Z}, g^\\alpha)</span>. This implicitly sets <span class="math">x = z</span> and <span class="math">y = \\alpha</span>. Recall that</p>

    <div class="my-4 text-center"><span class="math-block">F_1 = 1 \\Leftrightarrow \\Delta \\not\\equiv_p 0 \\vee \\Delta&#x27; \\not\\equiv_p 0 \\vee \\Delta&#x27;&#x27; \\not\\equiv_p 0.</span></div>

    <p class="text-gray-300">We now analyze <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>. Suppose <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> wins <span class="math">\\mathbf{G}_1</span> given that <span class="math">F_1 = 1</span>. Then <span class="math">\\mathbf{C}^<em> = (\\mathbf{A}^</em>)^{x + m^* xy}</span> which is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">x^2 \\Delta + x \\Delta&#x27; - \\Delta&#x27;&#x27; \\equiv_p 0 \\tag{31}</span></div>

    <p class="text-gray-300">where <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span> are defined in (24)-(26). Quadratic equation (31) in indeterminate <span class="math">x</span> has exactly two (possibly equal) solutions, say <span class="math">x_1</span> and <span class="math">x_2</span>, that can be computed efficiently by <span class="math">\\mathsf{C}_{\\mathrm{alg}}</span>. One of them has to be equal to <span class="math">z = x</span>, which one can be tested by comparing <span class="math">g^{x_i}</span> to <span class="math">\\mathbf{Z}</span>. This proves equation (28).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Calg(Z = gz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(mj): //For query j</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 Q := ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">05 rj←Zp;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 α←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Aj := grj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 (m<em>, [A</em>]a, [B<em>]b, [C</em>]c) ←Aol(·)(Z, gα)</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Bj := gαrj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Solve for x: x2Δ + xΔ' - Δ'' ≡p 0</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Cj := Zrjmjα+rj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">04 Return x</td>

            <td class="px-3 py-2 border-b border-gray-700">09 Q := Q ∪ {mj}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 10 Return (Aj, Bj, Cj)  |</p>

    <p class="text-gray-300">Figure 25: Behavior of adversary  <span class="math">C_{\\mathrm{alg}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dalg(Z = gz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(mj): //For query j</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 Q := ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">05 rj←Zp;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 α←Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">06 Aj := grj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 (m<em>, [A</em>]a, [B<em>]b, [C</em>]c) ←Aol(·)(gα, Z)</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Bj := Zrj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Compute y as described below</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Cj := Zrjmjαgαrj</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">04 Return y</td>

            <td class="px-3 py-2 border-b border-gray-700">09 Q := Q ∪ {mj}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 10 Return (Aj, Bj, Cj)  |</p>

    <p class="text-gray-300">Figure 26: Behaviour of  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span></p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span> : Adversary  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  does the following. It samples  <span class="math">\\alpha \\stackrel{\\mathrm{s}}{\\leftarrow} \\mathbb{Z}_p</span>  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, \\mathbf{Z})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and  <span class="math">y = z</span> . Recall that  <span class="math">F_2 = 1</span>  iff</p>

    <div class="my-4 text-center"><span class="math-block">\\neg F ^ {*} \\wedge \\neg (\\Delta \\not \\equiv_ {p} 0 \\lor \\Delta^ {\\prime} \\not \\equiv_ {p} 0 \\lor \\Delta^ {\\prime \\prime} \\not \\equiv_ {p} 0) \\lor</span></div>

    <div class="my-4 text-center"><span class="math-block">F ^ {*} \\wedge \\forall j \\notin \\left\\{\\ell^ {*}, k ^ {*} \\right\\}: r _ {j} \\varepsilon_ {j} (1 + m ^ {*} y) - r _ {j} \\delta_ {j} (1 + y m _ {j}) \\equiv_ {p} 0,</span></div>

    <p class="text-gray-300">where  <span class="math">F^{*}</span>  is defined in (27).</p>

    <p class="text-gray-300">We analyze and describe  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span> . Suppose that  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  wins  <span class="math">\\mathbf{G_1}</span>  given that  <span class="math">F_{2} = 1</span> . As before, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {C} ^ {*} = \\left(\\mathbf {A} ^ {*}\\right) ^ {x + m ^ {*} x y} \\Leftrightarrow x ^ {2} \\Delta + x \\Delta^ {\\prime} - \\Delta^ {\\prime \\prime} \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">If  <span class="math">\\Delta \\equiv_p\\Delta &#x27;\\equiv_p\\Delta &#x27;&#x27;\\equiv_p0\\wedge \\neg F^*</span>  then  <span class="math">\\mathsf{D}_{\\mathrm{alg}}</span>  can efficiently solve one of the equations</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\equiv_ {p} 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta^ {\\prime} \\equiv_ {p} 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Delta^ {\\prime \\prime} \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">in indeterminate  <span class="math">y = z</span> . This can be seen as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">s_1 \\not\\equiv_p 0 \\lor t_1 \\not\\equiv_p 0</span> , it can solve the quadratic equation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\equiv_ {p} m ^ {*} t _ {1} y ^ {2} + t _ {1} y + s _ {1} m ^ {*} y + s _ {1} \\equiv_ {p} 0,</span></div>

    <p class="text-gray-300">because  <span class="math">m^{*}\\neq_{p}0</span>  by assumption.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">u_{1} \\neq_{p} 0</span> , it can solve the quadratic equation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Delta^ {\\prime} \\equiv_ {p} u _ {1} m ^ {*} y ^ {2} + m ^ {*} y v _ {1} - t _ {2} y + u _ {1} y + v _ {1} - s _ {2} \\equiv_ {p} 0,</span></div>

    <p class="text-gray-300">where again we use the fact that  <span class="math">m^{*}\\neq_{p}0</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v_{2} \\not\\equiv_{p} 0</span>, then since</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Delta^{\\prime\\prime} \\equiv_{p} v_{2} + u_{2}y \\equiv_{p} 0,</span></div>

    <p class="text-gray-300">also <span class="math">u_{2} \\not\\equiv_{p} 0</span> and so <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> can solve for <span class="math">y</span> the equation</p>

    <div class="my-4 text-center"><span class="math-block">v_{2} + u_{2}y \\equiv_{p} 0</span></div>

    <p class="text-gray-300">whenever <span class="math">v_{2} \\not\\equiv_{p} 0 \\vee u_{2} \\not\\equiv_{p} 0</span>.</p>

    <p class="text-gray-300">Given two possible solutions <span class="math">y_{1}, y_{2}</span> for a quadratic equation, <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> can determine the correct one by comparing <span class="math">g^{y_i}</span> to <span class="math">\\mathbf{Z}</span>.</p>

    <p class="text-gray-300">If <span class="math">F^{<em>} = 1</span>, Lemma A.1 guarantees that <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> can efficiently compute parameters <span class="math">\\delta_1, \\ldots, \\delta_q, \\varepsilon_1, \\ldots, \\varepsilon_q</span> such that <span class="math">\\mathbf{A}^</em> = \\prod_{i} \\mathbf{A}_i^{\\varepsilon_i}, \\mathbf{C}^* = \\prod_{i} \\mathbf{C}_i^{\\delta_i}</span>. We distinguish two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\exists j \\notin \\{\\ell^{<em>}, k^{</em>}\\} : \\varepsilon_{j} \\not\\equiv_{p} 0 \\vee \\delta_{j} \\not\\equiv_{p} 0</span>. Without loss of generality, assume that <span class="math">\\varepsilon_{j} \\not\\equiv_{p} 0</span>. Since</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\notin \\{\\ell^{*}, k^{*}\\} : r_{j} \\varepsilon_{j} (1 + m^{*}y) - r_{j} \\delta_{j} (1 + y m_{j}) \\equiv_{p} 0, \\tag{32}</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> solves the equation</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\delta_{j}}{\\varepsilon_{j}} - 1 \\equiv_{p} y \\left(m^{*} - m_{j} \\frac{\\delta_{j}}{\\varepsilon_{j}}\\right)</span></div>

    <p class="text-gray-300">for <span class="math">y</span>, which is obtained from rearranging terms in (32). This equation has a unique solution for <span class="math">y</span>, and its coefficient can not become zero; this would imply that <span class="math">m^{*} \\equiv_{p} m_{j}</span>, a contradiction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">\\forall j \\notin \\{\\ell^{<em>}, k^{</em>}\\} : \\varepsilon_{j} \\equiv_{p} \\delta_{j} \\equiv_{p} 0</span>. This means that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}^{*} = \\mathbf{A}_{\\ell^{*}}^{\\varepsilon_{\\ell^{*}}} \\mathbf{A}_{k^{*}}^{\\varepsilon_{k^{*}}} = g^{a_{q+1}} \\mathbf{A}_{k^{*}}^{a_{k^{*}}} \\mathbf{A}_{\\ell^{*}}^{a_{\\ell^{*}}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{C}^{*} = \\mathbf{C}_{k^{*}}^{\\delta_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{\\delta_{\\ell^{*}}} = \\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^{*}}^{c_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{c_{\\ell^{*}}}.</span></div>

    <p class="text-gray-300">If <span class="math">a_{\\ell^{<em>}} \\equiv_{p} a_{k^{</em>}} \\equiv_{p} c_{k^{<em>}} \\equiv_{p} c_{\\ell^{</em>}} \\equiv_{p} 0</span>, then <span class="math">\\mathbf{A}^{<em>} = g^{a_{q+1}}, \\mathbf{C}^{</em>} = \\mathbf{X}^{c_{q+1}}</span> and therefore</p>

    <div class="my-4 text-center"><span class="math-block">c_{q+1} - a_{q+1} \\equiv_{p} y m^{*} a_{q+1}.</span></div>

    <p class="text-gray-300">Again, this equation has a unique solution for <span class="math">y</span> and its coefficient can not become zero, because <span class="math">a_{q+1} \\not\\equiv_{p} 0</span> (recall that <span class="math">\\mathbf{A}^{<em>} \\not\\equiv_{p} 1</span>) and <span class="math">m^{</em>} \\not\\equiv_{p} 0</span>.</p>

    <p class="text-gray-300">Finally, we note that with probability at most <span class="math">\\frac{2}{q-1}</span>, <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> succeeds in setting</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (a_{\\ell^{*}} \\not\\equiv_{p} 0 \\vee a_{k^{*}} \\not\\equiv_{p} 0 \\vee c_{k^{*}} \\not\\equiv_{p} 0 \\vee c_{\\ell^{*}} \\not\\equiv_{p} 0) \\\\ \\wedge \\left(\\forall j \\notin \\{\\ell^{*}, k^{*}\\} : \\varepsilon_{j} \\equiv_{p} a_{j} \\equiv_{p} c_{j} \\equiv_{p} \\delta_{j} \\equiv_{p} 0\\right). \\end{array}</span></div>

    <p class="text-gray-300">This argument is true, because the indices <span class="math">\\ell^{<em>}, k^{</em>}</span> are information theoretically hidden from <span class="math">\\mathsf{A}_{\\mathsf{alg}}^{\\prime} s</span> view and so it guesses either of them with probability at most <span class="math">\\frac{2}{q-1}</span>. All in all, <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> succeeds in computing <span class="math">y</span> with probability at least <span class="math">1 - \\frac{2}{q-1}</span>. This proves equation (29).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ealg(Z = gz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q(mj): //For query j</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 Q := ∅</td>

            <td class="px-3 py-2 border-b border-gray-700">05 b := (j = i*)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 α,β <3Zp</td>

            <td class="px-3 py-2 border-b border-gray-700">06 r'j <5Zp;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 (m<em>, [A</em>]a, [B<em>]b, [C</em>]c) <5AQ(-)(gα, gβ)</td>

            <td class="px-3 py-2 border-b border-gray-700">07 Aj := gzbrj'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">03 Compute z as described below</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Bj := gzbβrj'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">04 Return z</td>

            <td class="px-3 py-2 border-b border-gray-700">09 Cj := gzbrj'mjβαgzbαrj'</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 10 Q := Q ∪ {mj}  |</p>

    <p class="text-gray-300">|   | 11 Return (Aj, Bj, Cj)  |</p>

    <p class="text-gray-300">Figure 27: Behaviour of  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span></p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span> : To simulate  <span class="math">\\mathbf{G_1}</span>  to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> , the adversary  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span>  does the following. It samples  <span class="math">\\alpha, \\beta \\ll \\mathbb{Z}_p</span>  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, g^{\\beta})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and  <span class="math">y = \\beta</span> . It embeds  <span class="math">z</span>  into the answer to the  <span class="math">i^{*}</span> th oracle query as shown in Figure 27. We now analyze  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span> . If  <span class="math">F_{3} = 1</span> , then</p>

    <div class="my-4 text-center"><span class="math-block">F ^ {*} \\wedge \\exists j \\notin \\{\\ell^ {*}, k ^ {*} \\}: r _ {j} \\varepsilon_ {j} (1 + m ^ {*} y) - r _ {j} \\delta_ {j} (1 + y m _ {j}) \\not \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">Lemma A.1 guarantees that  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span>  can efficiently compute the parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {1}, \\dots , \\delta_ {q}, \\varepsilon_ {1}, \\dots , \\varepsilon_ {q}</span></div>

    <p class="text-gray-300">such that  <span class="math">\\mathbf{A}^{<em>} = \\prod_{i}\\mathbf{A}_{i}^{\\varepsilon_{i}},\\mathbf{C}^{</em>} = \\prod_{i}\\mathbf{C}_{i}^{\\delta_{i}}</span>  . By assumption</p>

    <div class="my-4 text-center"><span class="math-block">\\exists j \\notin \\{\\ell^ {*}, k ^ {*} \\}: r _ {j} \\varepsilon_ {j} (1 + m ^ {*} y) - r _ {j} \\delta_ {j} (1 + y m _ {j}) \\not \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">With probability  <span class="math">\\frac{1}{q}, j = i^{<em>}</span> , because  <span class="math">i^{</em>}</span>  is information theoretically hidden from  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  and thus independent of its computation. This yields the equation</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\prod_ {i} g ^ {r _ {i} \\varepsilon_ {i}}\\right) ^ {x + m ^ {*} x y} = \\left(\\prod_ {i} \\mathbf {A} _ {i} ^ {\\varepsilon_ {i}}\\right) ^ {x + m ^ {*} x y} = \\left(\\mathbf {A} ^ {*}\\right) ^ {(x + m ^ {*} x y)} \\\\ = \\mathbf {C} ^ {*} = \\prod_ {i} \\mathbf {C} _ {i} ^ {\\delta_ {i}} = \\prod_ {i} g ^ {\\delta_ {i} r _ {i} (x + m _ {i} y x)}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i} r _ {i} \\varepsilon_ {i}\\right) \\left(x + m ^ {*} x y\\right) - \\sum_ {i} r _ {i} \\delta_ {i} \\left(x + m _ {i} y x\\right) \\equiv_ {p} 0.</span></div>

    <p class="text-gray-300">Rearranging terms yields</p>

    <div class="my-4 text-center"><span class="math-block">z \\left[ r _ {i ^ {*}} ^ {\\prime} \\varepsilon_ {i ^ {*}} \\left(1 + m ^ {*} y\\right) - r _ {i ^ {*}} ^ {\\prime} \\delta_ {i ^ {*}} \\left(1 + m _ {i ^ {*}} y\\right) \\right] \\equiv_ {p} \\sum_ {i \\neq i ^ {*}} r _ {i} \\delta_ {i} \\left(1 + y m _ {i}\\right) - \\left(\\sum_ {i \\neq i ^ {*}} r _ {i} \\varepsilon_ {i}\\right) \\left(1 + m ^ {*} y\\right).</span></div>

    <p class="text-gray-300">By assumption, the coefficient of  <span class="math">z</span>  in this expression is not zero. Therefore,  <span class="math">\\mathsf{E}_{\\mathrm{alg}}</span>  can efficiently solve the modular equation to obtain  <span class="math">z</span> . Putting things together, we obtain for the adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  emulating one of  <span class="math">\\mathsf{C}_{\\mathrm{alg}}, \\mathsf{D}_{\\mathrm{alg}}, \\mathsf{E}_{\\mathrm{alg}}</span>  the following bound on the advantage  <span class="math">\\mathbf{Adv}_{\\mathsf{B}_{\\mathrm{alg}}, \\mathcal{G}}^{\\mathrm{dlog}}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathsf {B} _ {\\mathrm {a l g}}, \\mathcal {G}} ^ {\\mathbf {d l o g}} \\geq \\frac {1}{3 q} \\mathbf {A d v} _ {\\mathsf {A} _ {\\mathrm {a l g}}, \\mathcal {G}} ^ {\\mathbf {G} _ {1}} = \\frac {q - 3}{3 q ^ {2}} \\mathbf {A d v} _ {\\mathsf {A} _ {\\mathrm {a l g}}, \\mathcal {G}} ^ {\\mathbf {G} _ {0}} \\geq \\frac {1}{6 q} \\mathbf {A d v} _ {\\mathsf {A} _ {\\mathrm {a l g}}, \\mathcal {G}} ^ {\\mathbf {G} _ {0}},</span></div>

    <p class="text-gray-300">where the last inequality holds for  <span class="math">q \\geq 6</span> .</p>

    <p class="text-gray-300">Proof. First note that given an adversary  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{q}</span> - <span class="math">\\mathbf{ddh}_{\\mathcal{G}}</span>  one can easily construct an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G}}</span> .  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  first calls  <span class="math">\\mathsf{Dec}(\\cdot)</span>  to compute the elements  <span class="math">(g^{x},\\dots,g^{x^{q}})</span> . When it is presented with a challenge  <span class="math">(\\mathbf{K}^{<em>},\\mathbf{C}^{</em>})</span> , it calls  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  on input  <span class="math">(g^{x},\\dots,g^{x^{q}},\\mathbf{C}^{<em>},\\mathbf{K}^{</em>})</span>  and then outputs  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  's output bit  <span class="math">b^{\\prime}</span> . Clearly,  <span class="math">(g^{x},\\dots,g^{x^{q}},\\mathbf{C}^{<em>},\\mathbf{K}^{</em>})</span>  is correctly distributed and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {q} - \\mathbf {d d h}} = \\mathbf {A d v} _ {\\mathsf {E G}, \\mathcal {G}, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {i n d - c c a 1}}, \\quad \\mathbf {T i m e} _ {\\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {q} - \\mathbf {d d h}} = \\mathbf {T i m e} _ {\\mathsf {E G}, \\mathcal {G}, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {i n d - c c a 1}}.</span></div>

    <p class="text-gray-300">For the converse, let  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  be an algebraic adversary playing in one of the games  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{\\mathrm{alg}}}</span> ,  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},1}^{\\mathsf{A}_{\\mathrm{alg}}}</span> . We construct an adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against  <span class="math">\\mathbf{q}</span> -ddh that interpolates between  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  and  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},1}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  by simulating one of these games to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> .  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  is depicted in Figure 28.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Balg(g, (Xi)i=1q,R, Z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dec([C]c)/Let this be the i-th query</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Enc() //One time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">00 X := gx</td>

            <td class="px-3 py-2 border-b border-gray-700">03 Compute a s.t.</td>

            <td class="px-3 py-2 border-b border-gray-700">06 C* := R</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">01 b' ← A Dec(·), Enc (X)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">07 K* := Z</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">02 Return b'</td>

            <td class="px-3 py-2 border-b border-gray-700">C = ∏i j=1 gajxj</td>

            <td class="px-3 py-2 border-b border-gray-700">08 Return (K<em>, C</em>)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 04 K := Cx = ∏i j=1 Xaj+1 |   |</p>

    <p class="text-gray-300">|   | 05 Return K |   |</p>

    <p class="text-gray-300">Figure 28: Adversary  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  against q-ddh.</p>

    <p class="text-gray-300">Let  <span class="math">(g, \\mathbf{X}_1 = g^x, \\mathbf{X}_2 = g^{x^2}, \\ldots, \\mathbf{X}_q = g^{x^q}, \\mathbf{R} = g^r, \\mathbf{Z} = g^{xr + zb})</span>  be the problem instance given to  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  in  <span class="math">\\mathbf{q}</span> - <span class="math">\\mathbf{ddh}_{\\mathcal{G},b}^{\\mathsf{B}_{\\mathrm{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  is algebraic, along with its  <span class="math">i</span> -th query  <span class="math">\\mathbf{C}</span>  to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  it sends a vector  <span class="math">\\vec{c}</span>  such that  <span class="math">\\mathbf{C} = \\prod_i \\mathbf{L}_i^{c_i}</span>  where  <span class="math">\\vec{\\mathbf{L}}</span>  consists of group elements  <span class="math">g, \\mathbf{X}, \\mathbf{K}_1, \\ldots, \\mathbf{K}_{i-1}</span> . Here,  <span class="math">\\mathbf{K}_1, \\ldots, \\mathbf{K}_{i-1}</span>  denote the answers to the first  <span class="math">i-1</span>  queries asked to  <span class="math">\\mathsf{Dec}(\\cdot)</span> .</p>

    <p class="text-gray-300">Observe that given  <span class="math">\\vec{c}</span> ,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  can express  <span class="math">\\mathbf{C}</span>  as  <span class="math">\\mathbf{C} = \\prod_{i\\geq j\\geq 0}g^{a_jx^j}</span> , for some known constants  <span class="math">a_{j}</span> . As  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  asks at most  <span class="math">q - 1</span>  such queries,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  can answer them using the group elements  <span class="math">(g,g^{x},g^{x^{2}},\\dots,g^{x^{q}})</span>  from its instance. When  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  queries  <span class="math">\\mathsf{Enc}()</span> ,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  returns  <span class="math">(g^{xr + zb},g^r)</span> . When  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span>  halts with output  <span class="math">b&#x27;</span> ,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  returns  <span class="math">b&#x27;</span> . Clearly,  <span class="math">\\mathsf{B}_{\\mathrm{alg}}</span>  perfectly simulates either  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  or  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},1}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  to  <span class="math">\\mathsf{A}_{\\mathrm{alg}}</span> . Finally,  <span class="math">\\mathbf{ind - cca1}_{\\mathsf{EG},\\mathcal{G},b}^{\\mathsf{A}_{\\mathrm{alg}}}</span>  returns 1 if and only if  <span class="math">\\mathbf{q - ddh}_{\\mathcal{G},b}^{\\mathsf{B}_{\\mathrm{alg}}}</span>  returns 1. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A d v} _ {\\mathcal {G}, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {q} - \\mathbf {d d h}} = \\mathbf {A d v} _ {\\mathsf {E G}, \\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {i n d - c c a 1}}, \\quad \\mathbf {T i m e} _ {\\mathcal {G}, \\mathsf {B} _ {\\mathrm {a l g}}} ^ {\\mathbf {q} - \\mathbf {d d h}} = \\mathbf {T i m e} _ {\\mathsf {E G}, \\mathcal {G}, \\mathsf {A} _ {\\mathrm {a l g}}} ^ {\\mathbf {i n d - c c a 1}}.</span></div>`;
---

<BaseLayout title="The Algebraic Group Model and its Applications (2017/620)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/620
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
