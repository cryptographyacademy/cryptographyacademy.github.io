---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/620';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = '**The Algebraic Group Model and its Applications**';
const AUTHORS_HTML = 'Georg Fuchsbauer&lt;sup&gt;1&lt;/sup&gt; Eike Kiltz&lt;sup&gt;2&lt;/sup&gt; Julian Loss&lt;sup&gt;2&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Georg Fuchsbauer&lt;sup&gt;1&lt;/sup&gt; Eike Kiltz&lt;sup&gt;2&lt;/sup&gt; Julian Loss&lt;sup&gt;2&lt;/sup&gt;</p>

    <p class="text-gray-300">April 15, 2019</p>

    <p class="text-gray-300">1 Inria, ENS, CNRS, PSL, France georg.fuchsbauer@ens.fr &lt;sup&gt;2&lt;/sup&gt; Ruhr University Bochum, Germany {eike.kiltz,julian.loss}@rub.de</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8"><strong>Abstract</strong></h3>

    <p class="text-gray-300">One of the most important and successful tools for assessing hardness assumptions in cryptography is the Generic Group Model (GGM). Over the past two decades, numerous assumptions and protocols have been analyzed within this model. While a proof in the GGM can certainly provide some measure of confidence in an assumption, its scope is rather limited since it does not capture group-specific algorithms that make use of the representation of the group.</p>

    <p class="text-gray-300">To overcome this limitation, we propose the Algebraic Group Model (AGM), a model that lies in between the Standard Model and the GGM. It is the first restricted model of computation covering group-specific algorithms yet allowing to derive simple and meaningful security statements. To prove its usefulness, we show that several important assumptions, among them the Computational Diffie-Hellman, the Strong Diffie-Hellman, and the interactive LRSW assumptions, are equivalent to the Discrete Logarithm (DLog) assumption in the AGM. On the more practical side, we prove tight security reductions for two important schemes in the AGM to DLog or a variant thereof: the BLS signature scheme and Groth's zero-knowledge SNARK (EUROCRYPT 2016), which is the most efficient SNARK for which only a proof in the GGM was known. Our proofs are quite simple and therefore less prone to subtle errors than those in the GGM.</p>

    <p class="text-gray-300">Moreover, in combination with known lower bounds on the Discrete Logarithm assumption in the GGM, our results can be used to derive lower bounds for all the above-mentioned results in the GGM.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> Algebraic algorithms, generic group model, security reductions, cryptographic assumptions.</p>

    <p class="text-gray-300">Starting with Nechaev <a href="#page-27-0">[Nec94]</a> and Shoup <a href="#page-27-1">[Sho97]</a>, much work has been devoted to studying the computational complexity of problems with respect to generic group algorithms over cyclic groups <a href="#page-24-0">[BL96,</a> <a href="#page-27-2">MW98,</a> <a href="#page-27-3">Mau05]</a>. At the highest level, generic group algorithms are algorithms that do not exploit any special structure of the representation of the group elements and can thus be applied in any cyclic group. More concretely, a generic algorithm may use only the abstract group operation and test whether two group elements are equal. This property makes it possible to prove information-theoretic lower bounds on the running time for generic algorithms. &lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;Such lower bounds are of great interest since for many important groups, in particular for elliptic curves, no helpful exploitation of the representation is currently known.</p>

    <p class="text-gray-300">The class of generic algorithms encompasses many important algorithms such as the babystep giant-step algorithm and its generalization for composite-order groups (also known as Pohlig-Hellman algorithm [HP78]) as well as Pollard's rho algorithm [Pol78]. However, part of the common criticism against the generic group model is that many algorithms of practical interest are in fact not generic. Perhaps most notably, index-calculus and some factoring attacks fall outside the family of generic algorithms, as they are applicable only over groups in which the elements are represented as <em>integers</em>. Another example is the &quot;trivial&quot; discrete logarithm algorithm over the additive group  <span class="math">\\mathbb{Z}_p</span> , which is the identity function.</p>

    <p class="text-gray-300">With this motivation in mind, a number of previous works considered extensions of the generic group model [Riv04, LR06, AM09, JR10]. Jager and Rupp [JR10] considered assumptions over groups equipped with a bilinear map  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\longrightarrow \\mathbb{G}_3</span> , where  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are modeled as generic groups, and  <span class="math">\\mathbb{G}_3</span>  is modeled in the Standard Model. (This is motivated by the fact that in all practical bilinear groups,  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are elliptic curves whereas  <span class="math">\\mathbb{G}_3</span>  is a sub-group of a finite field). However, none of these models so far capture algorithms that can freely exploit the representation of the group. In this work, we propose a restricted model of computation which does exactly this.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Algebraic Algorithms</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{G}</span>  be a cyclic group of prime order p. Informally, we call an algorithm  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  algebraic if it fulfills the following requirement: whenever  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  outputs a group element  <span class="math">\\mathbf{Z} \\in \\mathbb{G}</span> , it also outputs a &quot;representation&quot;  <span class="math">\\vec{z} = (z_1, \\ldots, z_t) \\in \\mathbb{Z}_p^t</span>  such that  <span class="math">\\mathbf{Z} = \\prod_i \\mathbf{L}_i^{z_i}</span> , where  <span class="math">\\vec{\\mathbf{L}} = (\\mathbf{L}_1, \\ldots, \\mathbf{L}_t)</span>  is the list of all group elements that were given to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  during its execution so far.</p>

    <p class="text-gray-300">Such algebraic algorithms were first considered by Boneh and Venkatesan [BV98] in the context of straight-line programs computing polynomials over the ring of integers  <span class="math">\\mathbb{Z}_n</span> , where n = pq. Later, Paillier and Vergnaud [PV05] gave a more formal and general definition of algebraic algorithms using the notion of an <em>extractor algorithm</em> which efficiently computes the representation  <span class="math">\\vec{z}</span> .</p>

    <p class="text-gray-300">In our formalization of algebraic algorithms, we distinguish group elements from all other parameters at a <em>syntactical level</em>, that is, other parameters must not depend on any group elements. This is to rule out pathological exploits of the model, see below. While this class of algebraic algorithms certainly captures a much broader class of algorithms than the class of generic algorithms (e.g., index-calculus algorithms), it was first noted in [PV05] that the class of algebraic algorithms actually <em>includes</em> the class of generic algorithms.</p>

    <p class="text-gray-300">Algebraic algorithms have mostly been studied so far in the context of proving <em>impossibility</em> results [BV98, Cor02, PV05, BMV08, GBL08, AGO11, KMP16], i.e., to disprove the existence of an algebraic security reduction between two cryptographic primitives (with certain good parameters). Only quite recently, a small number of works have considered the idea of proving statements with respect to algebraic adversaries [ABM15, BFW16].</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">1.2 Algebraic Group Model</h4>

    <p class="text-gray-300">We propose the algebraic group model (AGM) â€” a computational model in which all adversaries are modeled as algebraic. In contrast to the GGM, the AGM does not allow for proving information-theoretic lower bounds on the complexity of an algebraic adversary. Similar to the Standard Model, in the AGM one proves security implications via reductions. Specifically,  <span class="math">H \\Rightarrow_{\\mathsf{alg}} G</span>  for two primitives H and G means that every algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  against G can be transformed into an algebraic adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  against H with (polynomially) related running</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;times and success probabilities. It follows that if H is secure against algebraic adversaries, so is G. While algebraic adversaries have been considered before (see above), to the best of our knowledge, our work is the first to provide a clean and formal framework for security proofs with respect to algebraic adversaries. We elaborate further on our model below.</p>

    <p class="text-gray-300">CONCRETE SECURITY IMPLICATIONS IN THE AGM. Indeed, one can exploit the algebraic nature of an adversary in the AGM to obtain stronger security implications than in the Standard Model. The first trivial observation is that the classical <em>knowledge of exponent assumption</em>&lt;sup&gt;1&lt;/sup&gt; [Dam92] holds by definition in the AGM.</p>

    <p class="text-gray-300">We are able to show that several important computational assumptions are in fact equivalent to the Discrete Logarithm assumption over prime-order groups in the AGM, including the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Diffie-Hellman assumption [DH76]</li>
      <li><span class="math">\\bullet</span>  (Interactive) strong Diffie-Hellman assumption [ABR01]</li>
      <li>(Interactive) LRSW assumption [LRSW99, CL04].</li>
    </ul>

    <p class="text-gray-300">The significance of the Strong Diffie-Hellman Assumption comes from its equivalence to the IND-CCA security of Hashed ElGamal encryption (also known as Diffie-Hellman Integrated Encryption Standard) in the random oracle model [ABR01]. The LSRW assumption (named after its authors [LRSW99]) is of importance since it is equivalent to the (UF-CMA) security of Camenisch-Lysyanskaya (CL) signatures [CL04]. CL signatures are a central building block for anonymous credentials [CL04, BCL04, BCS05], group signatures [CL04, ACHdM05], e-cash [CHL05], unclonable functions [CHK+06], batch verification [CHP07], and RFID encryption [ACdM05]. Via our results, the security of all these schemes is implied by the discrete logarithm assumption in the AGM.</p>

    <p class="text-gray-300">Our result can be interpreted as follows. Every algorithm attacking one of the above-mentioned problems and schemes must solve the standard discrete logarithm problem directly, unless the algorithm relies on inherently non-algebraic operations. In particular, powerful techniques such as the index-calculus algorithms do not help in solving these problems any better then they do for solving the discrete logarithm problem directly.</p>

    <p class="text-gray-300">Moreover, we show the tight equivalence of the security of the following schemes to the underlying hardness assumptions in the AGM:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>IND-CCA1 (aka lunchtime) security of the standard ElGamal Encryption to a parametrized variant of Decisional Diffie-Hellman assumption where in addition to  <span class="math">g^x, g^y</span>  the adversary receives  <span class="math">g^{x^2}, \\ldots, g^{x^q}</span> , where q is the maximal number of decryption queries.</li>
      <li>The UF-CMA security of the BLS signature scheme [BLS04] to the discrete logarithm problem in the random oracle model. Previous reductions non-tightly reduced from the CDH problem, with a tightness loss linear in the number of signing queries. This loss is known to be inherent [Cor02, KK12], even in the random oracle model.</li>
      <li>The security of the so far most efficient zero-knowledge SNARK scheme by Groth [Gro16] to a parametrized variant of the discrete logarithm problem, where in addition to  <span class="math">g^x</span>  the adversary receives  <span class="math">g^{x^2}, \\ldots, g^{x^{2n-1}}</span> , where n is the degree of the quadratic arithmetic programs. The only previous proof of the security of this scheme is in the generic group model.</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt;The knowledge of exponent assumption states that for every algorithm A that, given g and  <span class="math">\\mathbf{X} = g^x</span> , outputs  <span class="math">(\\mathbf{A}, \\mathbf{B})</span>  with  <span class="math">\\mathbf{B} = \\mathbf{A}^x</span> , there exists an extractor algorithms that, given the same input, outputs a satisfying  <span class="math">(\\mathbf{A}, \\mathbf{B}) = (g^a, \\mathbf{X}^a)</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;RELATION TO THE GENERIC GROUP MODEL. The AGM is stronger (in the sense that it puts more restrictions on the attackers) than the Standard Model, but weaker than the GGM. In spite of this, all of our reductions are purely generic algorithms. As mentioned above, any generic algorithm can be modeled within the AGM. In particular, combining arbitrary generic operations with algebraic ones will yield an algebraic algorithm. This suggests the following idea. Let H and G be two computational problems and let  <span class="math">A_{alg}</span>  be an algebraic algorithm that solves problem G. If we can convert  <span class="math">A_{alg}</span>  by means of a generic reduction algorithm  <span class="math">R_{gen}</span>  into an algorithm  <span class="math">B_{alg}</span>  for problem H, then clearly,  <span class="math">B_{alg}</span>  is also an algebraic algorithm. However, we obtain an even stronger statement for free: Namely, if  <span class="math">A_{gen}</span>  is a generic algorithm solving G, then  <span class="math">B_{gen}</span>  is a generic algorithm solving H. This means that results in the AGM directly carry over to the GGM.</p>

    <p class="text-gray-300">For this reason, we believe that our model offers an alternative, perhaps simpler method of proving the hardness of computational problems within the GGM. This applies in particular to interactive assumptions, which can be rather difficult to analyze in the GGM. For example, we prove that the discrete logarithm assumption implies the LRSW assumption in the AGM. As the discrete logarithm assumption holds in the GGM, we instantly obtain that the LRSW assumption holds in the GGM. The first (rigorous) proof of the LRSW assumption within the GGM was presented in the work of [BFF&lt;sup&gt;+&lt;/sup&gt;14] (the original work [LRSW99] provided only a proof sketch), but was derived from a more general theorem and proven using an automated proof verification tool. We hope that our proof can offer some additional insight over the proof of [BFF&lt;sup&gt;+&lt;/sup&gt;14]. Another example is our tight equivalence of the IND-CCA1 security of ElGamal and our parametrized variant of the Decisional Diffie-Hellman (DDH) assumption in the algebraic group model. Together with the known generic  <span class="math">\\sqrt{p/q}</span>  attack on ElGamal [BG04] for certain primes p (see also [Che06]), our result proves the tight generic bound  <span class="math">\\tilde{\\Theta}(\\sqrt{p/q})</span>  on the complexity of breaking IND-CCA1 security of ElGamal in the GGM.</p>

    <p class="text-gray-300">We also remark that proofs in the AGM have an inherently different interpretation than proofs in the GGM. To analyze the hardness of an assumption in the GGM, one must explicitly augment the model by any functionality that is offered by the structure of the group. As a simple example, let us consider a group  <span class="math">\\mathbb{G}</span>  which is equipped with a symmetric bilinear map  <span class="math">e\\colon \\mathbb{G}\\times\\mathbb{G} \\longrightarrow \\mathbb{G}_T</span> . The bilinear map can be modeled in the GGM via an oracle. However, it is not clear whether e can be used to gather even further information about the elements of  <span class="math">\\mathbb{G}</span> . Though it is widely believed that this is not the case, a proof in the GGM provides no answer to this question, because the GGM itself is based on the conjecture that e does not offer any functionality beyond a bilinear map. In contrast, the AGM captures any such exploit without the need of having to model it explicitly and considers the relation between two problems instead of their <em>individual hardness</em>. This means that if one can reduce H to G in the AGM and H is conjectured to remain hard with respect to algebraic algorithms, even when given e, then also G remains hard. No similar statement can be inferred in the GGM. Thus, the AGM allows for a more fine grained assessment of the hardness of computational problems than the GGM.</p>

    <p class="text-gray-300">The gap between the two models becomes even more apparent if one considers structural properties of  <span class="math">\\mathbb{G}</span>  which cannot be meaningfully modeled as an oracle in the GGM. As an example, consider the Jacobi symbol, which was shown to be generically hard to compute in [JS09]. Indeed, it was left as an open problem in [AM09] to re-examine the equivalence of factoring and breaking the RSA assumption if an additional oracle for the Jacobi symbol were given. Though their results are stated in the <em>generic ring model</em> rather than the GGM, it seems they are similarly confronted with the issue of explicitly modeling such an oracle.</p>

    <p class="text-gray-300">LIMITATIONS OF THE AGM. As already noted, one of the main benefits of our model over the GGM is the ability to reason about algorithms that arbitrarily exploit the structure of &lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;the group. So which algorithms are not covered in this manner? Obviously, outputting an obliviously sampled group element (with unknown representation) is forbidden. This coincides with the GGM of Maurer <a href="#page-27-3">[Mau05]</a> and which also excludes the possibility of obliviously sampling a random group element. For this reason, our model is strictly weaker than the one from <a href="#page-27-3">[Mau05]</a> in the sense that any security reduction derived in Maurer's GGM also holds in the AGM. In contrast, the GGM defined by Shoup <a href="#page-27-1">[Sho97]</a> <em>does</em> allow for such a sampling process. Similar to Maurer's GGM, we can allow obliviously sampling a random group element <strong>X</strong> through an additional oracle O() that can be called during the execution of Aalg. By definition, the outputs of O() are added to the list **L***~* . We have thus argued that both versions of the GGM (i.e., the ones by Maurer and Shoup) are strictly stronger than the AGM. Also note that simulating O() to Aalg as part of a reduction is straight-forward and always possible; the reduction simply samples <em>r</em> and returns <em>g r</em> to the adversary. As the reduction knows <em>r</em>, adding O() to an experiment does not change it and is completely without loss of generality. From a practical point of view, it seems that generating and outputting a random group element without knowing a representation is generally not of much help. We therefore believe that the AGM captures most algorithms of practical interest.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8"><strong>1.3 Related Work and Open Questions</strong></h3>

    <p class="text-gray-300">We have already mentioned the semi generic group model (SGGM) <a href="#page-26-2">[JR10]</a> as related work, but we discuss here some key differences of their model to ours in more detail. First, the SGGM is a very restrictive model in the sense that the class of problems it captures is limited. The main theorem of <a href="#page-26-2">[JR10]</a> (Theorem 3) holds only for pairing-based computational problems in which the output consists of a single element in either one of the base groups. In contrast, the AGM does not require a pairing group setting and thus applies to a much broader class of computational problems. Second, by extending the AGM to pairing groups, we are able to model all three groups as algebraic and reason again about a broader class of problems, in which the output can also consist of elements in the target group. To extend the AGM to the pairing setting, we allow the algebraic adversary to compute any element in the target group by applying the pairing to elements in the respective base groups.</p>

    <p class="text-gray-300">Dent <a href="#page-25-9">[Den02]</a> shows that the generic group model as proposed Shoup <a href="#page-27-1">[Sho97]</a> inherits the known weaknesses in the random oracle model <a href="#page-24-7">[CGH98]</a>. Thus, there exist schemes which can be proven secure in Shoup's GGM, but are pathologically insecure when viewed in the standard model. An interesting open question is whether the AGM bears similar weaknesses. A promising line of research related to this question has recently been initiated by Bitansky et al. <a href="#page-23-8">[BCPR16]</a>. Namely, they show that indistinguishability obfuscation (iO) implies the existence of non-extractable one-way functions. If these non-extractable one-way functions were furthermore algebraic (such as the knowledge of exponent assumption <a href="#page-25-2">[Dam92]</a>), then this would invalidate the AGM (under the assumption that iO exists).</p>

    <p class="text-gray-300">Another promising direction for future research is to prove further reductions between common computational assumptions in the AGM. In particular, it would be interesting to classify different such assumptions within the AGM, for example along the lines of work <a href="#page-28-0">[SS01,</a> <a href="#page-26-7">Kil01,</a> <a href="#page-24-8">Boy08,</a> <a href="#page-26-8">JR15,</a> <a href="#page-25-10">CM14,</a> <a href="#page-27-8">MRV16,</a> <a href="#page-25-11">GG17]</a>.</p>

    <p class="text-gray-300">At a technical level, the main difficulty in this task arises from the fact that an algorithm, i.e., distinguisher, in a decisional problem is asked to output a <em>bit</em> rather than a group element. Therefore, such an algorithm is trivially considered algebraic in our framework. It would therefore be interesting to develop a model which captures the algebraic properties of such algorithms in more detail.</p>

    <p class="text-gray-300">A further potential for follow-up work would be to investigate whether it is possible to</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;automate proofs in the AGM. Indeed, for the case of the GGM this has been considered in [BFF&lt;sup&gt;+&lt;/sup&gt;14, ABS16] and it would be interesting to see if similar automated tools can be derived for the AGM.</p>

    <p class="text-gray-300">Finally, we remark that all of our results require prime-order groups and do not yet extend to the setting of pairing groups. When generalizing our results to composite-order groups, we expect to encounter the following technical difficulty: Given, e.g., an equation of the form  <span class="math">ax \\equiv_n b</span> , where n is composite, there might be (exponentially) many solutions for the unknown x in case gcd(a,n) &gt; 1. This interferes with the proof strategies presented in this work and requires a more involved analysis. In fact, proving a reduction from the discrete logarithm problem to the CDH problem in the AGM for group orders containing multiple prime factors (eg,  <span class="math">n = p^2</span> ) is excluded by [MW98]. Hardness bounds in the GGM for composite-order groups have been considered in [Sho97, MW98, Mau05]. Generalizing the GGM to pairing groups has been the subject, e.g., of the works of [Boy08, KSW08, RLB&lt;sup&gt;+&lt;/sup&gt;08]. Extending the AGM to either one of these regimes is an interesting line of research for future work.</p>

    <p class="text-gray-300">ALGORITHMS. We denote by  <span class="math">s \\stackrel{\\</span>}{\\leftarrow} S$  the uniform sampling of the variable s from the (finite) set S. All our algorithms are probabilistic (unless stated otherwise) and written in uppercase letters A, B. To indicate that algorithm A runs on some inputs  <span class="math">(x_1, \\ldots, x_n)</span>  and returns y, we write  <span class="math">y \\stackrel{\\</span>}{\\leftarrow} A(x_1, \\ldots, x_n)$ . If A has access to an algorithm B (via oracle access) during its execution, we write  <span class="math">y \\stackrel{\\</span>}{\\leftarrow} A^B(x_1, \\ldots, x_n)$ .</p>

    <p class="text-gray-300">SECURITY GAMES. We use a variant of (code-based) security games [BR04]. In game  <span class="math">\\mathbf{G}_{par}</span>  (defined relative to a set of parameters par), an adversary A interacts with a challenger that answers oracle queries issued by A. It has a main procedure and (possibly zero) oracle procedures which describe how oracle queries are answered. We denote the output of a game  <span class="math">\\mathbf{G}_{par}</span>  between a challenger and an adversary A via  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span> . A is said to win if  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}} = 1</span> . We define the advantage of A in  <span class="math">\\mathbf{G}_{par}</span>  as  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}} := \\Pr\\left[\\mathbf{G}_{par}^{\\mathsf{A}} = 1\\right]</span>  and the running time of  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span>  as  <span class="math">\\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}</span> .</p>

    <p class="text-gray-300">SECURITY REDUCTIONS. Let  <span class="math">\\mathbf{G}, \\mathbf{H}</span>  be security games. We write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow} \\mathbf{G}_{par}</span>  if there exists an algorithm R (called  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for all algorithms A, algorithm B defined as  <span class="math">\\mathsf{B} := \\mathsf{R}^\\mathsf{A}</span>  satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}.</span>$</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Algebraic Security Games and Algorithms</h3>

    <p class="text-gray-300">We consider algebraic security games  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  for which we set par to a fixed group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span> , where  <span class="math">\\mathbb{G}</span>  is a cyclic group of prime order p generated by g. In algebraic security games, we syntactically distinguish between elements of group  <span class="math">\\mathbb{G}</span>  (written in bold, uppercase letters, e.g.,  <span class="math">\\mathbf{A}</span> ) and all other elements, which must not depend on any group elements. As an example of an algebraic security game, consider the Computational Diffie-Hellman game  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}^{\\mathbf{A}}</span> , depicted in Figure 1 (left).</p>

    <p class="text-gray-300">We now define algebraic algorithms. Intuitively, the only way for an algebraic algorithm to output a new group element  <span class="math">\\mathbf{Z}</span>  is to derive it via group multiplications from known group elements.</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Algebraic algorithm) An algorithm  <span class="math">A_{alg}</span>  executed in an algebraic game  <span class="math">G_{\\mathcal{G}}</span>  is called <em>algebraic</em> if for all group elements  <span class="math">\\mathbf{Z}</span>  that  <span class="math">A_{alg}</span>  outputs (i.e., the elements in bold uppercase</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{cdh}}}\\nolimits_{\\mathcal{G}}^{A}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{cdh}}}_{\\mathcal{G}}^{A_{alg}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">(\\mathbf{X}, \\mathbf{Y}) := (g^x, g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\mathbf{X},\\mathbf{Y}):=(g^x,g^y)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\mathbf{Z} \\overset{\\</span>}{\\leftarrow} A(\\mathbf{X}, \\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">[\\mathbf{Z}]_{\\vec{z}} \\overset{\\</span>}{\\leftarrow} A_{alg}(\\mathbf{X},\\mathbf{Y})$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;Figure 1: <strong>Left:</strong> Algebraic game <strong>cdh</strong> relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and adversary A. All group elements are written in bold, uppercase letters. <strong>Right:</strong> Algebraic game <strong>cdh</strong> relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . The algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  additionally returns a representation  <span class="math">\\vec{z} = (a, b, c)</span>  of <strong>Z</strong> such that  <span class="math">\\mathbf{Z} = g^a \\mathbf{X}^b \\mathbf{Y}^c</span> .</p>

    <p class="text-gray-300">letters), it additionally provides the representation of  <span class="math">\\mathbf{Z}</span>  relative to all previously received group elements. That is, if  <span class="math">\\vec{\\mathbf{L}}</span>  is the list of group elements  <span class="math">\\mathbf{L}_0, \\dots, \\mathbf{L}_m \\in \\mathbb{G}</span>  that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  has received so far (w.l.o.g.  <span class="math">\\mathbf{L}_0 = g</span> ), then  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  must also provide a vector  <span class="math">\\vec{z}</span>  such that  <span class="math">\\mathbf{Z} = \\prod_i \\mathbf{L}_i^{z_i}</span> . We denote such an output as  <span class="math">[\\mathbf{Z}]_{\\vec{z}}</span> .</p>

    <p class="text-gray-300">REMARKS ON OUR MODEL. Algebraic algorithms were first considered in [BV98, PV05], where they are defined using an additional extractor algorithm which computes for an output group element a representation in basis  <span class="math">\\vec{\\mathbf{L}}</span> . We believe that our definition gives a simpler and cleaner definition of algebraic algorithms. If one assumes that the extractor algorithm has constant running time, then our definition is easily seen to be equivalent to theirs. Indeed, this view makes sense for algorithms in the GGM since the representation  <span class="math">\\vec{z}</span>  trivially follows from the description of the algorithm. However, if running the extractor algorithm imposes some additional cost, then this will clearly affect the running times of our reductions. If the cost of the extractor is similar to that of the solver adversary, then reductions in our model that neither call an algebraic solver multiple times nor receive from it a non-constant amount of group elements (along with their representations) will remain largely the same in both models.</p>

    <p class="text-gray-300">For the inputs to algebraic adversaries we syntactically distinguish group elements from other inputs and require that the latter not depend on any group elements. This is necessary to rule out pathological cases in which an algorithm receives &quot;disguised&quot; group elements and is forced to output an algebraic representation of them (which it might not know). To illustrate the issue, consider an efficient algorithm A, which on input  <span class="math">X&#x27; := \\mathbf{X} \\| \\bot \\text{ returns } \\mathbf{X}</span> , where  <span class="math">\\mathbf{X}</span>  is a group element, but X' is not. If A is algebraic then it must return a representation of  <span class="math">\\mathbf{X}</span>  in g (the only group element previously seen), which would be the discrete logarithm of  <span class="math">\\mathbf{X}</span> .</p>

    <p class="text-gray-300">Allowing inputs of form X' while requiring algorithms to be algebraic leads to contradictions. (E.g., one could use  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  to compute discrete logarithms: given a challenge  <span class="math">\\mathbf{X} = g^x</span> , run  <span class="math">[\\mathbf{X}]_x \\stackrel{\\</span>}{\\leftarrow} \\mathsf{A}<em>{\\mathsf{alg}}(\\mathbf{X}||\\bot)$  and return x.) We therefore demand that non-group-element inputs must not depend on group elements. (Note that if  $\\mathsf{A}</em>{\\mathsf{alg}}$ 's input contains  <span class="math">\\mathbf{X}</span>  explicitly then it can output  <span class="math">[\\mathbf{X}]_{(0,1)}</span>  with a valid representation of  <span class="math">\\mathbf{X}</span>  relative to  <span class="math">\\vec{\\mathbf{L}} = (g, \\mathbf{X})</span> .)</p>

    <p class="text-gray-300">Finally, we slightly abuse notation and let an algebraic algorithm also represent output group elements as combinations of previous <em>outputs</em>. This makes some of our proofs easier and is justified since all previous outputs must themselves have been given along with an according representation. Therefore, one can always recompute a representation that depends only on the initial inputs to the algebraic algorithm.</p>

    <p class="text-gray-300">INTEGRATING WITH RANDOM ORACLES IN THE AGM. As mentioned above, an algorithm A that samples (and outputs) a group element <strong>X</strong> obliviously, i.e., without knowing its representation, is not algebraic. This appears to be problematic if one wishes to combine the AGM with the Random Oracle Model [BR93]. However, group elements output by the random oracle are</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;included by definition in the list  <span class="math">\\vec{\\mathbf{L}}</span> . This means that for any such element, a representation is trivially available to  <span class="math">A_{alg}</span> .</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Generic Security Games and Algorithms</h3>

    <p class="text-gray-300">Generic algorithms  <span class="math">A_{gen}</span>  are only allowed to use generic properties of group  <span class="math">\\mathcal{G}</span> . Informally, an algorithm is generic if it works regardless of what group it is run in. This is usually modeled by giving an algorithm indirect access to group elements via abstract handles. It is straight-forward to translate all of our algebraic games into games that are syntactically compatible with generic algorithms accessing group elements only via abstract handles.</p>

    <p class="text-gray-300">We say that winning algebraic game  <span class="math">G_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon, t)</span> -hard in the generic group model if for every generic algorithm  <span class="math">A_{\\mathsf{gen}}</span>  it holds that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}} \\leq t \\implies \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}} \\leq \\varepsilon.</span>$</p>

    <p class="text-gray-300">We remark that usually in the generic group model one considers group operations (i.e., oracle calls) instead of the running time. In our context it is more convenient to measure the running time instead, assuming every oracle call takes one unit time.</p>

    <p class="text-gray-300">As an important example, consider the algebraic Discrete Logarithm Game  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in Figure 2 which is  <span class="math">(t^2/p, t)</span> -hard in the generic group model [Sho97, Mau05].</p>

    <p class="text-gray-300">We assume that a generic algorithm  <span class="math">A_{gen}</span>  additionally provides the representation of  <span class="math">\\mathbf{Z}</span>  relative to all previously received group elements, for all group elements  <span class="math">\\mathbf{Z}</span>  that it outputs. This assumption is w.l.o.g. since a generic algorithm can only obtain new group elements by multiplying two known group elements; hence it always knows a valid representation. This way, every generic algorithm is also an algebraic algorithm.</p>

    <p class="text-gray-300">Furthermore, if  <span class="math">B_{gen}</span>  is a generic algorithm and  <span class="math">A_{alg}</span>  is an algebraic algorithm, then  <span class="math">B_{alg} := B_{gen}^{A_{alg}}</span>  is also is an algebraic algorithm. We refer to [Mau05] for more on generic algorithms.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Generic Reductions Between Algebraic Security Games</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  and  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  be two algebraic security games. We write  <span class="math">\\mathbf{H}_{\\mathcal{G}} \\overset{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow} \\mathsf{alg} \\mathbf{G}_{\\mathcal{G}}</span>  if there exists a generic algorithm  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  (called generic  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for every algebraic algorithm  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> , algorithm  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{gen}}</span>  satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span>$</p>

    <p class="text-gray-300">Note that we deliberately require reduction  <span class="math">R_{gen}</span>  to be generic. Hence, if  <span class="math">A_{alg}</span>  is algebraic, then  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is algebraic; if  <span class="math">A_{alg}</span>  is generic, then  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is generic. If one is only interested in algebraic adversaries, then it suffices to require reduction  <span class="math">R_{gen}</span>  to be algebraic. But in that case one can no longer infer that  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is generic in case  <span class="math">A_{alg}</span>  is generic.</p>

    <p class="text-gray-300">Composing information-theoretic lower bounds with reductions in the AGM. The following lemma explains how statements in the AGM carry over to the GGM.</p>

    <p class="text-gray-300"><strong>Lemma 2.2</strong> Let  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  and  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  be algebraic security games such that  <span class="math">\\mathbf{H}_{\\mathcal{G}} \\stackrel{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{\\mathcal{G}}</span>  and winning  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon, t)</span> -hard in the GGM. Then,  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon \\cdot \\Delta_{\\varepsilon}, t/\\Delta_{t})</span> -hard in the GGM.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">A_{gen}</span>  be a generic algorithm playing in game  <span class="math">G_{\\mathcal{G}}</span> . Then by our premise there exists a generic algorithm  <span class="math">B_{alg} = R_{gen}^{A_{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-3&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{dlog}}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\mathbf{lc}\\text{-}dh}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\mathbf{sq}\\text{-}\\mathbf{dh}}^{A}_{\\mathcal{G}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} \\coloneqq g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\mathbf{X},\\mathbf{Y}) \\coloneqq (g^x,g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} \\coloneqq g^x</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">z \\stackrel{\\</span>}{\\leftarrow} A(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oz <span class="math">(\\mathbf{Z}, u, v, w) \\stackrel{\\</span>}{\\leftarrow} A(\\mathbf{X}, \\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\mathbf{Z} \\overset{\\</span>}{\\leftarrow} A(\\mathbf{X})$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(z=x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{ux^2 + vxy + wy^2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(\\mathbf{Z} = g^{x^2})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\wedge \\ (u \\neq 0 \\lor v \\neq 0 \\lor w \\neq 0))</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;Figure 2: Discrete Logarithm Game <strong>dlog</strong>, Square Diffie-Hellman Game <strong>sq-dh</strong>, and Linear Combination Diffie-Hellman Game <strong>lc-dh</strong> relative to group  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|}\\hline \\mathbf{sq\\text{-}dh}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}} \\\\ \\hline \\mathbf{00} &amp; x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ \\mathtt{01} &amp; \\mathbf{X} := g^x \\ \\mathtt{02} &amp; [\\mathbf{Z}]</em>{(a,b)} \\overset{$}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}(\\mathbf{X}) \\ \\mathtt{03} &amp; \\mathrm{Return} &amp; (\\mathbf{Z} = g^{x^2}) \\end{array}$$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-1&quot;&gt;&lt;/span&gt;Figure 3: Algebraic adversary  <span class="math">A_{alg}</span>  playing in  <span class="math">\\mathbf{sq}</span> - <span class="math">\\mathbf{dh}_{G}</span> .</p>

    <p class="text-gray-300">Assume  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}} \\leq t/\\Delta_t</span> ; then  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_t \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}} \\leq t</span> . Since winning  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon,t)</span> -hard in the GGM, it follows that</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\geq \\mathbf{Adv}^{\\mathbf{H}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}^{\\mathbf{G}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}</span>$</p>

    <p class="text-gray-300">and thus  <span class="math">\\varepsilon \\cdot \\Delta_{\\varepsilon} \\geq \\mathbf{Adv}_{\\mathcal{G}, \\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span> , which proves that  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon \\Delta_{\\varepsilon}, t/\\Delta_{t})</span> -hard in the GGM.</p>

    <p class="text-gray-300">In this section we consider some variants of the standard Diffie-Hellman assumption [DH76] and prove them to be equivalent to the discrete logarithm assumption (defined via algebraic game  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  of Figure 2) in the Algebraic Group Model.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.1 Computational Diffie-Hellman</h4>

    <p class="text-gray-300">Consider the Square Diffie-Hellman Assumption [MW99] described in algebraic game  <span class="math">\\mathbf{sq}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span>  and the Linear Combination Diffie-Hellman Assumption described in algebraic game  <span class="math">\\mathbf{lc}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span>  (both in Figure 2), which will be convenient for the proof of Theorem 3.3.</p>

    <p class="text-gray-300">As a warm-up we now prove that the Discrete Logarithm assumption is tightly equivalent to the Diffie-Hellman, the Square Diffie-Hellman, and the Linear Combination Diffie-Hellman Assumption in the Algebraic Group Model. The equivalence of the Square Diffie-Hellman and Diffie-Hellman problems was previously proven in [MW99, BDZ03].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-4&quot;&gt;&lt;/span&gt;
<span class="math">$\\textbf{Theorem 3.1 } \\textbf{dlog}_{\\mathcal{G}} \\overset{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\ \\left\\{ \\mathbf{cdh}_{\\mathcal{G}}, \\mathbf{sq\\text{-}dh}_{\\mathcal{G}} \\right\\} \\ \\textit{and} \\ \\mathbf{dlog}_{\\mathcal{G}} \\overset{(3,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\ \\mathbf{lc\\text{-}dh}_{\\mathcal{G}}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">A_{\\mathsf{alg}}</span>  be an algebraic adversary executed in game  <span class="math">\\mathbf{sq\\text{-}dh}_{\\mathcal{G}}</span> ; cf. Figure 3.</p>

    <p class="text-gray-300">As  <span class="math">A_{\\mathsf{alg}}</span>  is an algebraic adversary, it returns a solution  <span class="math">\\mathbf{Z}</span>  together with a representation  <span class="math">(a,b) \\in \\mathbb{Z}_p^2</span>  such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{Z} = g^{x^2} = g^a (g^x)^b. \\tag{1}</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{sdh}}}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{O}(\\mathbf{Y}&#x27;,\\mathbf{Z}&#x27;)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(\\mathbf{Z}&#x27; = (\\mathbf{Y}&#x27;)^x)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">(\\mathbf{X},\\mathbf{Y}):=(g^x,g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">o2 <span class="math">\\mathbf{Z} \\overset{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A^{O(\\cdot,\\cdot)}(\\mathbf{X},\\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;Figure 4: Strong Diffie-Hellman Game sdh relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now show how to construct a generic reduction  <span class="math">R_{gen}</span>  that calls  <span class="math">A_{alg}</span>  exactly once such that for  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Adv}^{\\mathbf{sq}\\text{-}\\mathbf{dh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  works as follows. On input a discrete logarithm instance  <span class="math">\\mathbf{X}</span> , it runs  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  on  <span class="math">\\mathbf{X}</span> . Suppose  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is successful. Equation (1) is equivalent to the quadratic equation  <span class="math">x^2 - bx - a \\equiv_p 0</span>  with at most two solutions in x. (In general such equations are not guaranteed to have a solution but since the representation is valid and  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is assumed to be correct, there exists at least one solution for x.)  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  can test which one (out of the two) is the correct solution x by testing against  <span class="math">\\mathbf{X} = g^x</span> . Moreover, it is easy to see that  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  only performs generic group operations and is therefore generic. Hence,  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span>  is algebraic, which proves</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{dlog}_{\\mathcal{G}} \\overset{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{sq}\\text{-}\\mathbf{dh}_{\\mathcal{G}}.</span>$</p>

    <p class="text-gray-300">The statement  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{cdh}_{\\mathcal{G}}</span>  follows, since given an adversary against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  (see Figure 1), we can easily construct an adversary against  <span class="math">\\mathbf{sq}\\text{-}\\mathbf{dh}_{\\mathcal{G}}</span>  that runs in the same time and has the same probability of success (given  <span class="math">\\mathbf{X} = g^x</span> , sample  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$ , run the  <span class="math">\\mathbf{cdh}</span>  adversary on  <span class="math">(\\mathbf{X}, \\mathbf{X}^r)</span> , obtain  <span class="math">\\mathbf{Z}</span>  and return  <span class="math">\\mathbf{Z}_r^{\\frac{1}{r}}</span> ).</p>

    <p class="text-gray-300">It remains to show that  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}} \\stackrel{(3,1)}{\\Longrightarrow}_{\\operatorname{alg}} \\operatorname{lc-dh}_{\\mathcal{G}}</span> . Given an algebraic solver  <span class="math">\\mathsf{C}_{\\operatorname{alg}}</span>  executed in game  <span class="math">\\operatorname{lc-dh}_{\\mathcal{G}}</span> , we construct an adversary  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  against  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}}</span>  as follows: On input  <span class="math">\\mathbf{X} = g^x</span> ,  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  samples  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and computes either  <span class="math">(\\mathbf{X}, g^r)</span> ,  <span class="math">(g^r, \\mathbf{X})</span> , or  <span class="math">(\\mathbf{X}, \\mathbf{X}^r)</span>  each with probability 1/3. Note that this instance is correctly distributed. It then runs  $\\mathsf{C}</em>{\\operatorname{alg}}$  on the resulting tuple  <span class="math">(\\mathbf{X}_1, \\mathbf{X}_2)</span>  and receives  <span class="math">(\\mathbf{Z}, u, v, w)</span>  together with (a, b, c) s.t.  <span class="math">\\mathbf{Z} = g^a \\mathbf{X}_1^b \\mathbf{X}_2^c</span> . If  <span class="math">u \\neq 0</span> , then the choice  <span class="math">\\mathbf{X}_1 = \\mathbf{X}</span> ,  <span class="math">\\mathbf{X}_2 = g^r</span>  yields  <span class="math">\\mathbf{Z} = g^{ux^2 + vxr + wr^2}</span> , from which  <span class="math">g^{x^2}</span>  can be computed as  <span class="math">g^{x^2} = (\\mathbf{Z}\\mathbf{X}^{-vr}g^{-wr^2})^{\\frac{1}{u}}</span> . Clearly,  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  is able to compute an algebraic representation of  <span class="math">g^{x^2}</span>  from the values (a, b, c) and thus is algebraic itself. The cases  <span class="math">v \\neq 0</span> ,  <span class="math">w \\neq 0</span>  follow in a similar fashion.</p>

    <p class="text-gray-300">Corollary 3.2  <span class="math">\\operatorname{cdh}_{\\mathcal{G}}</span>  and  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}}</span>  are  <span class="math">(t^2/p,t)</span> -hard in the generic group model and  <span class="math">\\operatorname{lc-dh}_{\\mathcal{G}}</span>  is  <span class="math">(3t^2/p,t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">For the subsequent sections and proofs, we will not make explicit the reduction algorithm  <span class="math">R_{\\sf gen}</span>  every time (as done above).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3.2 Strong Diffie-Hellman</h4>

    <p class="text-gray-300">Consider the Strong Diffie-Hellman Assumption [ABR01] described via game  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  in Figure 4. We now prove that the Discrete Logarithm Assumption (non-tightly) implies the Strong Diffie-Hellman Assumption in the Algebraic Group Model. We briefly present the main ideas of the proof. The full proof of Theorem 3.3 can be found in Appendix A.1. Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^z</span>  denote the Discrete Logarithm challenge. We show an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  that simulates  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> .  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  appropriately answers</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-3&quot;&gt;&lt;/span&gt; <span class="math">A_{alg}</span> 's queries to the oracle  <span class="math">O(\\cdot, \\cdot)</span>  by using the algebraic representation of the queried elements provided by  <span class="math">A_{alg}</span> . Namely, when  <span class="math">(\\mathbf{Y}&#x27;, \\mathbf{Z}&#x27;)</span>  is asked to the oracle,  <span class="math">B_{alg}</span>  obtains vectors  <span class="math">\\vec{b}, \\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1} \\mathbf{X}^{b_2} \\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1} \\mathbf{X}^{c_2} \\mathbf{Y}^{c_3}</span> . As long as  <span class="math">b_2 = b_3 = 0</span> ,  <span class="math">B_{alg}</span>  can answer all of  <span class="math">A_{alg}</span> 's queries by checking whether  <span class="math">\\mathbf{X}^{b_1} = \\mathbf{Z}&#x27;</span> . On the other hand, if  <span class="math">b_2 \\neq 0</span>  or  <span class="math">b_3 \\neq 0</span> , then  <span class="math">B_{alg}</span>  simply returns 0. Informally, the simulation will be perfect unless  <span class="math">A_{alg}</span>  manages to compute a valid solution to  <span class="math">\\mathbf{lc}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span> . All of these games can be efficiently simulated by  <span class="math">B_{alg}</span> , as we have shown in the previous section.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>Theorem 3.3</strong>  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(4q,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{sdh}_{\\mathcal{G}}</span> , where q is the maximum number of queries to oracle  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  in  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 3.4  <span class="math">\\operatorname{sdh}_{\\mathcal{G}}</span>  is  <span class="math">(\\frac{t^2}{4pq}, t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The interactive LRSW assumption [LRSW99, CL04] is defined via the algebraic security game <strong>lrsw</strong> in Figure 5.</p>

    <pre><code class="language-text"> \\begin{array}{|c|c|c|}\\hline \\mathbf{lrsw}_{\\mathcal{G}}^{\\mathsf{A}} &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 00 &amp; Q := \\emptyset &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 01 &amp; x, y \\overset{\\$}{\\leftarrow} \\mathbb{Z}_p &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 02 &amp; \\mathbf{X} := g^x, \\mathbf{Y} := g^y &amp; &amp; &amp; &amp; &amp; \\\\ 03 &amp; (m^*, \\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*) \\overset{\\$}{\\leftarrow} \\mathbf{A}^{\\mathsf{O}(\\cdot)}(\\mathbf{X}, \\mathbf{Y}) &amp; &amp; &amp; &amp; \\\\ 04 &amp; \\mathrm{Return} &amp; (m^* \\notin Q \\wedge m^* \\neq 0 \\wedge \\mathbf{A}^* \\neq 1 &amp; &amp; &amp; \\\\ &amp; &amp; \\wedge \\mathbf{B}^* = (\\mathbf{A}^*)^y \\wedge \\mathbf{C}^* = (\\mathbf{A}^*)^{m^*xy+x}) &amp; &amp; &amp; &amp; \\\\ \\end{array}
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;Figure 5: Game lrsw relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now prove that the LRSW assumption is (non-tightly) implied by the Discrete Logarithm Assumption in the Algebraic Group Model. We give a high-level sketch of the main ideas here and defer the full proof of Theorem 4.1 to Appendix A.2. Let  <span class="math">A_{alg}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^z</span>  denote the Discrete Logarithm challenge. We construct an adversary  <span class="math">B_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span> , which simulate  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to  <span class="math">A_{alg}</span>  by embedding the value of z in one of three possible ways. Namely, it either sets  <span class="math">\\mathbf{X} := \\mathbf{Z}</span>  or  <span class="math">\\mathbf{Y} := \\mathbf{Z}</span> , or it chooses a random the query by  <span class="math">A_{alg}</span>  to the oracle  <span class="math">O(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to embed the value of z. These behaviours correspond in our proof to the adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span> , and  <span class="math">E_{alg}</span> , respectively. After obtaining a solution  <span class="math">(m^*, [\\mathbf{A}^*]_{\\vec{c}}, [\\mathbf{B}^*]_{\\vec{b}}, [\\mathbf{C}^*]_{\\vec{c}})</span>  on a fresh value  <span class="math">m^* \\neq 0</span>  from  <span class="math">A_{alg}</span> , the adversaries use the algebraic representations  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  obtained from  <span class="math">A_{alg}</span>  to suitably rewrite the values of  <span class="math">\\mathbf{A}^*</span> ,  <span class="math">\\mathbf{C}^*</span>  (Lemma A.1). They then make use of the relation  <span class="math">(\\mathbf{A}^*)^{(xm^*y+x)} = \\mathbf{C}^*</span>  to obtain an equation mod p, which in turn gives z.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;<strong>Theorem 4.1</strong>  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(6q,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{lrsw}_{\\mathcal{G}}</span> , where  <span class="math">q \\geq 6</span>  is the maximum number of queries to  <span class="math">\\mathsf{O}(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 4.2  <span class="math">\\operatorname{lrsw}_{\\mathcal{G}}</span>  is  <span class="math">(t, \\frac{t^2}{6pq})</span> -hard in the generic group model.</p>

    <p class="text-gray-300">In this section we prove that the IND-CCA1 (aka. lunchtime security) of the ElGamal encryption scheme (in its abstraction as a KEM) is implied by a parametrized (&quot;q-type&quot;) variant of the</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{ind\\text{-}cca1}}_{KEM,par,b}^{A}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Dec}(C)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Enc() // One time</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ (pk, sk) \\stackrel{\\</span>}{\\leftarrow} Gen(par)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">//Before Enc is called</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">(K_0^*,C^*) \\stackrel{\\</span>}{\\leftarrow} Enc(pk)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">b&#x27; \\stackrel{\\</span>}{\\leftarrow} A^{Dec,Enc}(pk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 <span class="math">K \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} Dec(C,sk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">K_1^* \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} \\mathcal{K}$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return b'</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or Return <span class="math">(K_b^*, C^*)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;Figure 6: IND-CCA1 Game ind-cca1 relative to KEM KEM = (Gen, Enc, Dec), parameters par, and adversary A.</p>

    <p class="text-gray-300">Decision Diffie-Hellman Assumption in the Algebraic Group Model.</p>

    <p class="text-gray-300">ADVANTAGE FOR DECISIONAL ALGEBRAIC SECURITY GAMES. We parameterize a decisional algebraic game G (such as the game in Figure 7) with a parameter bit b. We define the advantage of adversary A in G as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}} := \\big| \\Pr \\left[ \\mathbf{G}_{par,0}^{\\mathsf{A}} = 1 \\right] - \\Pr \\left[ \\mathbf{G}_{par,1}^{\\mathsf{A}} = 1 \\right] \\big|.</span>$</p>

    <p class="text-gray-300">We define  <span class="math">\\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span>  independently of the parameter bit b, i.e., we consider only the worst-case running time of  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  in either game. In order to cover games that define the security of schemes (rather than assumptions), instead of  <span class="math">par = \\mathcal{G}</span> , we only require that  <span class="math">\\mathcal{G}</span>  be included in par. Let  <span class="math">\\mathbf{G}_{par}, \\mathbf{H}_{par}</span>  be decisional algebraic security games. As before, we write  <span class="math">\\mathbf{H}_{par} \\overset{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{par}</span>  if there exists a generic algorithm  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  (called generic  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for algebraic algorithm  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span>$</p>

    <p class="text-gray-300">KEY ENCAPSULATION MECHANISMS. A key encapsulation mechanism (KEM for short) KEM = (Gen, Enc, Dec) is a triple of algorithms together with a symmetric-key space  <span class="math">\\mathcal{K}</span> . The randomized key generation algorithm Gen takes as input a set of parameters, par, and outputs a public/secret key pair (pk, sk). The encapsulation algorithm Enc takes as input a public key pk and outputs a key/ciphertext pair (K, C) such that  <span class="math">K \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K}$ . The deterministic decapsulation algorithm Dec takes as input a secret key sk and a ciphertext C and outputs a key  <span class="math">K \\in \\mathcal{K}</span>  or a special symbol  <span class="math">\\bot</span>  if C is invalid. We require that KEM be correct: For all possible pairs (K, C) output by Enc(pk), we have Dec(sk, C) = K. We formalize IND-CCA1 security of a KEM via the games (for b = 0, 1) depicted in Figure 6.</p>

    <p class="text-gray-300">In the following, we consider the ElGamal KEM EG defined in Figure 8. We also consider a stronger variant of the well-known Decisional Diffie-Hellman (DDH) assumption that is parametrized by an integer q. In the q-DDH game, defined in Figure 7, the adversary receives, in addition to  <span class="math">(g^x, g^r)</span> , the values  <span class="math">g^{x^2}, \\ldots, g^{x^q}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.1</strong> [Che06] For  <span class="math">q &lt; p^{1/3}</span> ,  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G}}</span>  is  <span class="math">\\left(\\frac{t^2q}{p\\log p},t\\right)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The proof of the following theorem can be found in Appendix A.3.</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G},b}^{\\mathsf{A}}}{00 \\ x,r,z} \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_{p}$$
01  <span class="math">b&#x27; \\overset{\\</span>}{\\leftarrow} \\mathsf{A}(g^{x},g^{x^{2}},...,g^{x^{q}},g^{r},g^{xr+zb})$
02 Return  <span class="math">b&#x27;</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;Figure 7: q-Decisional Diffie-Hellman Game  <span class="math">\\mathbf{q}</span> - <span class="math">\\mathbf{ddh}</span>  relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Gen}(\\mathcal{G})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Enc}(pk)</span> :</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Dec}(\\mathbf{C},sk)</span> :</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">r \\overset{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 If <span class="math">\\mathbf{C} \\not\\in \\mathbb{G}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">\\mathbf{C} := g^r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return âŠ¥</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">(pk, sk) := (\\mathbf{X}, x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\mathbf{K} := \\mathbf{X}^r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 <span class="math">\\tilde{\\mathbf{K}} := \\mathbf{C}^x</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of Return <span class="math">(\\mathbf{K}, \\mathbf{C})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 Return <span class="math">\\tilde{\\mathbf{K}}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;Figure 8: ElGamal KEM EG = (Gen, Enc, Dec)</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;<strong>Theorem 5.2</strong> ind-cca1&lt;sub&gt;EG,G&lt;/sub&gt;  <span class="math">\\stackrel{(1,1)}{\\Longleftrightarrow}_{\\mathsf{alg}}</span>  q-ddh&lt;sub&gt;G&lt;/sub&gt;, where q-1 is the maximal number of queries to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  in ind-cca1&lt;sub&gt;EG,G&lt;/sub&gt;.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">03 Return <span class="math">\\vec{b}&#x27;</span> 09 <span class="math">\\mathbf{K}^* \\stackrel{\\mathcal{L}}{\\leftarrow} \\mathcal{K}</span> 10 Return <span class="math">(\\mathbf{K}^*, \\mathbf{C}^*)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">--------------------------------------------------------------------------------------------------------------------------------</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 9: Games  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},0}^\\mathsf{A}</span>  and  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^\\mathsf{A}</span>  with algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . The boxed statement is only executed in  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^\\mathsf{A}</span> .</p>

    <p class="text-gray-300"><strong>Corollary 5.3</strong> For  <span class="math">q &lt; p^{1/3}</span> ,  <span class="math">\\operatorname{ind-cca1}_{\\mathsf{EG},\\mathcal{G}}</span>  is  <span class="math">(\\frac{t^2q}{p\\log p},t)</span> -hard in the generic group model, where q-1 is the maximal number of queries to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  in  <span class="math">\\operatorname{ind-cca1}_{\\mathsf{EG},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">For this section, we introduce the notion of groups  <span class="math">\\mathbb{G}</span>  equipped with a symmetric, (non-degenerate) bilinear map  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  denotes the so-called <em>target group</em>. We now set  <span class="math">\\mathcal{G} = (p, \\mathbb{G}_T, g, e)</span> .</p>

    <p class="text-gray-300">SIGNATURE SCHEMES. A signature scheme SIG = (SIGGen, SIGSig, SIGVer) is a triple of algorithms. The randomized key generation algorithm SIGGen takes as input a set of parameters, par, and outputs a public/secret key pair (pk, sk). The randomized signing algorithm SIGSig takes as input a secret key sk and a message m in the message space  <span class="math">\\mathcal{M}</span>  and outputs a signature  <span class="math">\\sigma</span>  in the signature space  <span class="math">\\mathcal{S}</span> . The deterministic signature verification algorithm SIGVer takes as input a public key pk, a message m, and a signature  <span class="math">\\sigma</span>  and outputs  <span class="math">b \\in \\{0,1\\}</span> . We require that SIG be correct: For all possible pairs (pk, sk) output by SIGGen and all messages  <span class="math">m \\in \\mathcal{M}</span> , we have  <span class="math">\\Pr[\\mathsf{SIGVer}(pk, m, \\mathsf{SIGSig}(m, sk)) = 1] = 1</span> . We formalize unforgeability under chosen message attacks for SIG via game  <span class="math">\\mathsf{uf\\text{-cma}}_{\\mathsf{SIG},par}</span>  depicted in Figure 10.</p>

    <p class="text-gray-300">In the following, we show how in the AGM with a random oracle, the security of the BLS signature scheme [BLS04], depicted in Figure 11, can be tightly reduced to the discrete logarithm problem. Boneh, Lynn and Shacham [BLS04] only prove a loose reduction to the CDH problem. In the AGM we can improve the quality of the reduction by leveraging the fact that a forgery comes with a representation in the basis of all previously answered random-oracle and signature queries. We embed a discrete logarithm challenge in either the secret key or inside the random oracle queriesâ€”a choice that remains hidden from the adversary. Depending on the adversary's behavior we always solve the discrete logarithm challenge in one of the cases.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">uf-cma &lt;sup&gt;A&lt;/sup&gt; &lt;sub&gt;SIG,par&lt;/sub&gt;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&lt;u&gt;O&lt;/u&gt; (m)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">(pk,sk) \\stackrel{s}{\\leftarrow} SIGGen</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">Q \\mathrel{\\mathop:}= Q \\cup \\{m\\}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">Q:=\\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\sigma \\overset{\\</span>}{\\leftarrow} SIGSig(m,sk)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">(m^*,\\sigma^*) \\stackrel{\\</span>}{\\leftarrow} A^{O(\\cdot)}(pk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">\\sigma</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(m^* \\not\\in Q \\land SIGVer(m^*, \\sigma^*))</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 10: Game <strong>uf-cma</strong> defining (existential) unforgeability under chosen-message attacks for signature scheme SIG, parameters par and adversary A.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLSGen(G)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLSSig(m)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\tt BLSVer(m, \\boldsymbol{\\Sigma})</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\text{O5 } \\Sigma := H(m)^x}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or Return <span class="math">(e(H(m), \\mathbf{X}) = e(\\mathbf{\\Sigma}, g))</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">\\Sigma</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or <span class="math">sk := x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">pk := \\mathbf{X}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(pk, sk)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;Figure 11: Boneh, Lynn and Shacham's signature scheme  <span class="math">\\mathsf{BLS}_{\\mathcal{G}}</span> . Here, H is a hash function that is modeled as a random oracle.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-4&quot;&gt;&lt;/span&gt;Theorem 6.1  <span class="math">\\operatorname{dlog}_{\\mathcal{G}} \\stackrel{(4,1)}{\\Longrightarrow}_{\\operatorname{alg}} \\operatorname{uf-cma}_{\\operatorname{BLS},\\mathcal{G}} in the random oracle model.</span></p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G} := \\mathbf{uf\\text{-}cma}_{\\mathsf{BLS},\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> , depicted in Figure 12. As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is an algebraic adversary, at the end of  <span class="math">\\mathbf{G}</span>  it returns a forgery  <span class="math">\\mathbf{\\Sigma}^*</span>  on a message  <span class="math">m^* \\notin Q</span>  together with a representation  <span class="math">\\vec{a} = (\\hat{a}, a&#x27;, \\bar{a}_1, ..., \\bar{a}_a, \\tilde{a}_1, ..., \\tilde{a}_a)</span>  s.t.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-3&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{\\Sigma}^* = H(m^*)^x = g^{\\hat{a}} \\mathbf{X}^{a&#x27;} \\prod_{i=1}^q \\mathbf{H}_i^{\\tilde{a}_i} \\prod_{i=1}^q \\mathbf{\\Sigma}_i^{\\tilde{a}_i}.</span>$
(2)</p>

    <p class="text-gray-300">Here, the representation is split (from left to right) into powers of the generator g, the public key  <span class="math">\\mathbf{X}</span> , all of the answers to hash queries  <span class="math">\\mathbf{H}_i, i \\in [q]</span> , and the signatures  <span class="math">\\mathbf{\\Sigma}_i, i \\in [q]</span> , returned by the signing oracle. In the following, we let  <span class="math">r^*</span>  and  <span class="math">r_i</span> , for  <span class="math">i \\in [q]</span> , be such that  <span class="math">H(m^*) = g^{r^*}</span>  and  <span class="math">H(m_i) = g^{r_i}</span> . Equation (2) is thus equivalent to</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-5&quot;&gt;&lt;/span&gt;
<span class="math">$xr^* \\equiv_p x(a&#x27; + \\Sigma_i r_i \\tilde{a}_i) + (\\hat{a} + \\Sigma_i r_i \\bar{a}_i). \\tag{3}</span>$</p>

    <p class="text-gray-300">We remark that since  <span class="math">A_{alg}</span>  wins G, the sum  <span class="math">\\Sigma_i r_i \\tilde{a}_i</span>  may not include a term of the form  <span class="math">r^* \\tilde{a}^*</span>  (since  <span class="math">A_{alg}</span>  may not query the signing oracle on  <span class="math">m^*</span> ). We will now describe the behavior of adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span>  (depicted in Figures 13 and 14, respectively) playing in the discrete logarithm game. Each of these adversaries simulates G to  <span class="math">A_{alg}</span>  in a different way.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">- Â· A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">- /</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{G}^{A_{alg}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{O}(m_i)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{H}(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">Q := Q \\cup \\{m_i\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">\\mathbf{H}_i \\leftarrow H(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">\\mathbf{\\Sigma}_i \\leftarrow H(m_i)^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 Return <span class="math">\\mathbf{H}_i</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">Q := \\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 Return <span class="math">\\boldsymbol{\\Sigma}_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">(m^*, [\\mathbf{\\Sigma}^*]_{\\vec{a}}) \\overset{\\</span>}{\\leftarrow} A_{alg}^{O(\\cdot), H(\\cdot)}(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(m^* \\not\\in Q \\land \\Sigma^* = H(m^*)^x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-13-2&quot;&gt;&lt;/span&gt;Figure 12: Game  <span class="math">\\mathbf{G} = \\mathbf{uf\\text{-}cma}_{\\mathsf{BLS},\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span>  relative to adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">C_{alg}(\\mathbf{Z} = g^z)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">O(m_i)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">H(m_i)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{c} \\frac{2\\operatorname{dig}}{00} (\\mathbf{Z} + \\mathbf{S}) \\\\ \\end{array}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">04 \\text{ If } H(m_i) = \\bot</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">09 \\text{ If } H(m_i) \\neq \\bot</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(m^*, [\\mathbf{\\Sigma}^*]_{\\vec{a}}) \\overset{\\</span>}{\\leftarrow} A^{O(\\cdot), H(\\cdot)}(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">r_i \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 Return <span class="math">H(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Compute <span class="math">z</span> (see description)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">H(m_i) \\leftarrow g^{r_i}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11 <span class="math">r_i \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 Return z</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 <span class="math">\\mathbf{\\Sigma}_i \\leftarrow \\mathbf{X}^{r_i}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12 <span class="math">H(m_i) \\leftarrow g^{r_i}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return <span class="math">\\Sigma_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13 Return <span class="math">H(m_i)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;Figure 13: Adversary  <span class="math">C_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300"><strong>Lemma 6.2</strong> Let <strong>G</strong> be as defined in Figure 12 and, with  <span class="math">a&#x27;, \\tilde{a}_i, r^*</span>  and  <span class="math">r_i</span>  defined as above, let F denote the event that  <span class="math">a&#x27; + \\sum_i r_i \\tilde{a}_i - r^* \\not\\equiv_p 0</span> . Then there exist  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}</span>  playing in the discrete logarithm game such that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{dlog}^{\\mathsf{C}_{\\mathsf{alg}}} = 1] = \\Pr[\\mathbf{G} = 1 \\mid F] \\tag{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{dlog}^{\\mathsf{D}_{\\mathsf{alg}}} = 1] \\geq \\frac{p-1}{p} \\Pr[\\mathbf{G} = 1 \\mid \\neg F]</span>$
(5)</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">{\\bf Z}</span>  denote the discrete logarithm instance.  <span class="math">{\\sf C}_{\\sf alg}</span>  and  <span class="math">{\\sf D}_{\\sf alg}</span>  simulate  <span class="math">{\\bf G}</span>  to  <span class="math">{\\sf A}_{\\sf alg}</span> .</p>

    <p class="text-gray-300">Adversary  <span class="math">C_{\\mathsf{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">C_{\\mathsf{alg}}</span>  is depicted in Figure 13 and works as follows. It sets  <span class="math">\\mathbf{X} := \\mathbf{Z}</span> , which implicitly sets x := z. To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">r_i \\stackrel{\\</span>}{=} \\mathbb{Z}<em>i$  and sets  <span class="math">H(m_i) := g^{r_i}</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first calls  <span class="math">\\mathsf{H}(m_i)</span>  which defines  <span class="math">H(m_i)</span>  (and thus  <span class="math">r_i</span> ). It then computes and returns  <span class="math">\\Sigma_i := \\mathbf{X}^{r_i}</span> . It is easy to see that  $\\mathsf{C}</em>{\\mathsf{alg}}$ 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 1 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^* \\not\\equiv_p 0</span> . If  <span class="math">r^*</span>  has not been defined at this point,  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  makes an additional query  <span class="math">\\mathsf{H}(m^*)</span>  which defines  <span class="math">r^*</span> . Now, by (3) we have:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-2&quot;&gt;&lt;/span&gt;
<span class="math">$zr^* \\equiv_p z(a&#x27; + \\Sigma_i r_i \\tilde{a}_i) + (\\hat{a} + \\Sigma_i r_i \\bar{a}_i).</span>$
(6)</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  efficiently computes z from (6) as  <span class="math">z = (\\hat{a} + \\Sigma_i r_i \\bar{a}_i)(r^* - a&#x27; - \\Sigma_i r_i \\tilde{a}_i)^{-1} \\bmod p</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{c} \\underline{D_{alg}(\\mathbf{Z} = g^z)} \\\\ \\hline 00 \\ x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ 01 \\ \\mathbf{X} := g^x \\ 02 \\ (m^*, [\\mathbf{\\Sigma}^*]</em>{\\vec{a}}) \\overset{$}{\\leftarrow} A^{O(\\cdot),H}(\\mathbf{X}) \\end{array}$</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\underline{O}}(m_i)</span> 05 <span class="math">\\Sigma_i := H(m_i)^x</span> 06 Return <span class="math">\\Sigma_i</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\frac{\\underline{H}(m_i)}{07 \\ b_i, \\hat{r}_i} \\stackrel{$}{\\sim} \\mathbb{Z}_p \\ 08 \\ \\text{Return} \\ g^{zb_i + \\hat{r}_i} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 Compute <span class="math">z</span> (see above)&lt;br&gt;04 Return <span class="math">z</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;Figure 14: Adversary  <span class="math">D_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{D}_{\\mathsf{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  is depicted in Figure 14 and works as follows. It samples its own secret key  <span class="math">x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and sets  <span class="math">\\mathbf{X} := g^x</span> . To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  $\\mathsf{D}</em>{\\mathsf{alg}}$  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">\\hat{r}_i \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and  <span class="math">b_i \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and sets  <span class="math">H(m_i) = g^{r_i} := \\mathbf{Z}^{b_i} g^{\\hat{r}_i}</span> , which implicitly sets  <span class="math">r_i := \\hat{r}_i + zb_i</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first queries  <span class="math">\\mathsf{H}(m_i)</span> , which defines  <span class="math">H(m_i)</span>  and the values  <span class="math">\\hat{r}_i \\in \\mathbb{Z}_p</span> ,  <span class="math">b_i \\in \\mathbb{Z}_p</span> , and  <span class="math">r_i = \\hat{r}_i + zb_i</span> . It then computes and returns  <span class="math">\\mathbf{\\Sigma}_i := H(m_i)^x</span> . Again, it is straight-forward to verify that  $\\mathsf{D}</em>{\\mathsf{alg}}$ 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 0 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^* \\equiv_p 0</span> . Now,</p>

    <p class="text-gray-300"><span class="math">$zb^* + \\hat{r}^* \\equiv_p r^* \\equiv_p a&#x27; + \\sum_i r_i \\tilde{a}_i \\equiv_p (a&#x27; + \\sum_i \\hat{r}_i \\tilde{a}_i) + z(\\sum_i b_i \\tilde{a}_i) \\equiv_p Az + B, \\tag{7}</span>$</p>

    <p class="text-gray-300">$$\\begin{array}{c|c}
q-\\mathbf{dlog} \\overset{\\mathsf{A}}{\\mathcal{G}} \\
00 &amp; x \\overset{$}{\\leftarrow} \\mathbb{Z}_p^* \\
01 &amp; z \\overset{$}{\\leftarrow} \\mathsf{A}(g^x, g^{x^2}, ..., g^{x^q}) \\
02 &amp; \\text{Return } (z = x)
\\end{array}$$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;Figure 15: q-Discrete Logarithm Game q-dlog relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">where  <span class="math">A := \\Sigma_i b_i \\tilde{a}_i</span>  and  <span class="math">B := (a&#x27; + \\Sigma_i \\hat{r}_i \\tilde{a}_i)</span> . Note that the value of  <span class="math">b^*</span>  is information-theoretically hidden from  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  and thus independent from the value of A. As we have argued, the sum  <span class="math">\\Sigma_i r_i \\tilde{a}_i</span>  may not contain a term of the form  <span class="math">a^* r^*</span> . This means in particular that  <span class="math">a&#x27; + \\Sigma_i r_i \\tilde{a}_i</span>  is not composed of the singleton term  <span class="math">r^* \\equiv_p zb^* + \\hat{r}^*</span> . Therefore, with probability  <span class="math">1 - \\frac{1}{p}</span> , we have  <span class="math">b^* - A \\not\\equiv_p 0</span>  and thus  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can compute z as  <span class="math">z := (B - \\hat{r}^*)(b^* - A)^{-1} \\bmod p</span> .</p>

    <p class="text-gray-300">Now, we can simply let an adversary  <span class="math">B_{alg}</span>  choose to emulate one of the described adversaries  <span class="math">C_{alg}</span>  or  <span class="math">D_{alg}</span>  with probability  <span class="math">\\frac{1}{2}</span>  each. All in all,  <span class="math">\\mathbf{Adv}_{\\mathbf{dlog}}^{\\mathsf{B}_{alg},\\mathcal{G}} \\geq \\frac{p-1}{2p} \\mathbf{Adv}_{\\mathbf{uf-cma}_{\\mathsf{BLS}}}^{\\mathsf{A}_{alg},\\mathcal{G}} \\geq \\frac{1}{4} \\mathbf{Adv}_{\\mathbf{uf-cma}_{\\mathsf{BLS}}}^{\\mathsf{A}_{alg},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 6.3 uf-cma&lt;sub&gt;BLS,G&lt;/sub&gt; is  <span class="math">(t, \\frac{t^2}{4p})</span> -hard in the generic group model with a random oracle.</p>

    <p class="text-gray-300">In order to cover notions such as knowledge soundness, which are defined via games for two algorithms, we generalize the notion of algebraic games and reductions between them. We write  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A},\\mathsf{X}}</span>  to denote that A and X play in  <span class="math">\\mathbf{G}_{par}</span>  and define the advantage  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}} := \\Pr[\\mathbf{G}_{par}^{\\mathsf{A},\\mathsf{X}} = 1]</span>  and the running time  <span class="math">\\mathbf{Time}_{\\mathbf{par},\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  as before. To capture definitions that require that for every A there exists some X (which has black-box access to A) such that  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  is small, we define algebraic reductions for games  <span class="math">\\mathbf{G}_{par}</span>  of this type as follows.</p>

    <p class="text-gray-300">We write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta_{\\epsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{par}</span>  if there exist generic algorithms  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  and  <span class="math">\\mathsf{S}_{\\mathsf{gen}}</span>  such that for all algebraic algorithms  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{alg}}}^{\\mathbf{G}},</span>$</p>

    <p class="text-gray-300">with  <span class="math">B_{alg}</span>  defined as  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  and  <span class="math">X_{alg}</span>  defined as  <span class="math">X_{alg} := S_{gen}^{A_{alg}}.</span></p>

    <p class="text-gray-300">THE q-DISCRETE LOGARITHM ASSUMPTION. We define a parametrized (&quot;q-type&quot;) variant of the DLog assumption via the algebraic security game q-dlog in Figure 15. We will show that Groth's [Gro16] scheme, which is the most efficient SNARK system to date, is secure under q-DLog in the algebraic group model.</p>

    <p class="text-gray-300">Non-interactive zero-knowledge arguments of knowledge. Groth [Gro16] considers proof systems for satisfiability of arithmetic circuits, which consist of addition and multiplication gates over a finite field  <span class="math">\\mathbb{F}</span> . As a tool, Gennaro et al. [GGPR13] show how to efficiently convert any arithmetic circuit into a quadratic arithmetic program (QAP) R, which is described by  <span class="math">\\mathbb{F}</span> , integers  <span class="math">\\ell \\leq m</span>  and polynomials  <span class="math">u_i, v_i, w_i \\in \\mathbb{F}[X]</span> , for  <span class="math">0 \\leq i \\leq m</span> , and  <span class="math">t \\in \\mathbb{F}[X]</span> , where the degrees of  <span class="math">u_i, v_i, w_i</span>  are less than the degree n of t. (The relation R can also contain additional information aux.) A QAP R defines the following binary relation of statements  <span class="math">\\phi</span>  and witnesses  <span class="math">\\omega</span> , where we set  <span class="math">a_0 := 1</span> :</p>

    <p class="text-gray-300"><span class="math">$R = \\left\\{ (\\phi, \\omega) \\middle| \\begin{array}{l} \\phi = (a_1, \\dots, a_\\ell) \\in \\mathbb{F}^\\ell, \\ \\omega = (a_{\\ell+1}, \\dots, a_m) \\in \\mathbb{F}^{m-\\ell} \\\\ \\left( \\sum_{i=0}^m a_i u_i(X) \\right) \\cdot \\left( \\sum_{i=0}^m a_i v_i(X) \\right) \\equiv \\sum_{i=0}^m a_i w_i(X) \\pmod{t(X)} \\right\\}</span>$</p>

    <pre><code class="language-text">\\begin{array}{|c|c|c|}\\hline &amp; \\mathbf{knw\\text{-}\\mathbf{snd}} \\overset{\\mathsf{A},\\mathsf{X}_\\mathsf{A}}{\\mathsf{SNK},R} \\\\ &amp; \\texttt{00} &amp; \\mathit{crs} \\overset{\\$}{\\sim} \\mathsf{Setup}(R) \\\\ &amp; \\texttt{01} &amp; ((\\phi,\\pi);\\omega) \\overset{\\$}{\\sim} (\\mathsf{A} \\, \\| \\, \\mathsf{X}_\\mathsf{A})(R,\\mathit{crs}) \\\\ &amp; \\texttt{02} &amp; \\mathsf{Return} &amp; ((\\phi,\\omega) \\notin R \\\\ &amp; &amp; \\land \\mathsf{Vfy}(R,\\mathit{crs},\\phi,\\pi) = 1) \\\\ \\hline \\end{array} \\begin{array}{|c|c|c|c|}\\hline &amp; \\mathbf{k}\\text{-}\\mathbf{snd\\text{-}\\mathbf{aff}} \\overset{\\mathsf{X},\\mathsf{A}}{\\mathsf{NILP},R} \\\\ &amp; \\texttt{03} &amp; \\vec{\\sigma} \\overset{\\$}{\\sim} \\mathsf{LinSetup}(R) \\\\ &amp; \\texttt{04} &amp; (\\phi,P) \\overset{\\$}{\\sim} \\mathsf{A}(R) \\\\ &amp; \\texttt{05} &amp; \\omega \\overset{\\$}{\\sim} \\mathsf{X}(R,\\phi,P) \\\\ &amp; \\texttt{06} &amp; \\mathsf{Return} &amp; (P \\in \\mathbb{F}^{\\nu \\times \\mu} \\, \\land \\, (\\phi,\\omega) \\notin R \\\\ &amp; &amp; \\land \\; \\mathsf{LinVfy}(R,\\vec{\\sigma},\\phi,P\\vec{\\sigma}) = 1) \\\\ \\hline \\end{array}
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;Figure 16: Left: Knowledge soundness game knw-snd relative to SNK = (Setup, Prv, Vfy), adversary A and extractor  <span class="math">X_A</span> . Right: Knowledge soundness game k-snd-aff relative to NILP = (LinSetup, PrfMtrx, Test), extractor X and affine adversary A (right).</p>

    <p class="text-gray-300">Relation R defines an NP language  <span class="math">L_R := \\{ \\phi \\in \\mathbb{F}^\\ell \\mid \\exists \\omega \\in \\mathbb{F}^{m-\\ell} : (\\phi, \\omega) \\in R \\}</span> .</p>

    <p class="text-gray-300">A non-interactive argument system for a class of relations  <span class="math">\\mathcal{R}</span>  is a tuple  <span class="math">\\mathsf{SNK} = (\\mathsf{Setup}, \\mathsf{Prv}, \\mathsf{Vfy})</span>  of algorithms. Setup on input a relation  <span class="math">R \\in \\mathcal{R}</span>  outputs a common reference string  <span class="math">\\mathit{crs}</span> ; prover algorithm  <span class="math">\\mathsf{Prv}</span>  on input  <span class="math">\\mathit{crs}</span>  and a statement/witness pair  <span class="math">(\\phi, \\omega) \\in R</span>  returns an argument  <span class="math">\\pi</span> ; Verification  <span class="math">\\mathsf{Vfy}</span>  on input  <span class="math">\\mathit{crs}</span> ,  <span class="math">\\phi</span>  and  <span class="math">\\pi</span>  returns either 0 (reject) or 1 (accept). We require  <span class="math">\\mathsf{SNK}</span>  to be  <span class="math">\\mathit{complete}</span> , i.e., for all  <span class="math">\\mathit{crs}</span>  output by  <span class="math">\\mathsf{Setup}</span> , all arguments for true statements produced by  <span class="math">\\mathsf{Prv}</span>  are accepted by  <span class="math">\\mathsf{Vfy}</span> .</p>

    <p class="text-gray-300">Knowledge soundness requires that for every adversary A there exists an extractor  <span class="math">X_A</span>  that extracts a witness from any valid argument output by A. We write  <span class="math">(y; z) \\stackrel{\\</span>}{\\leftarrow} (A \\parallel X_A)(x)$  when A on input x outputs y and  <span class="math">X_A</span>  on the same input (including A's coins) returns z. Knowledge soundness is defined via game  <span class="math">\\mathbf{knw\\text{-snd}}_{SNK,R}^{A,X_A}</span>  in Figure 16.</p>

    <p class="text-gray-300">Zero knowledge for SNK requires that arguments do not leak any information besides the truth of the statement. It is formalized by demanding the existence of a simulator which on input a trapdoor (which is an additional output of Setup) and a true statement  <span class="math">\\phi</span>  returns an argument that is indistinguishable from an argument for  <span class="math">\\phi</span>  output by Prv when given a witness for  <span class="math">\\phi</span>  (see [Gro16] for a formal definition).</p>

    <p class="text-gray-300">A (preprocessing) succinct argument of knowledge (SNARK) is a knowledge-sound non-interactive argument system whose arguments are of size polynomial in the security parameter and can be verified in polynomial time in the security parameter and the length of the statement.</p>

    <p class="text-gray-300">NON-INTERACTIVE LINEAR PROOFS OF DEGREE 2. NILPs (in Groth's [Gro16] terminology) are an abstraction of many SNARK constructions introduced by Bitansky et al. [BCI&lt;sup&gt;+&lt;/sup&gt;13]. We only consider NILPs of degree 2 here. Such a system NILP is defined by three algorithms as follows. On input a quadratic arithmetic program R, LinSetup returns  <span class="math">\\vec{\\sigma} \\in \\mathbb{F}^{\\mu}</span>  for some  <span class="math">\\mu</span> . On input R,  <span class="math">\\phi</span>  and  <span class="math">\\omega</span> , algorithm PrfMtrx generates a matrix  <span class="math">P \\in \\mathbb{F}^{\\nu \\times \\mu}</span>  (where  <span class="math">\\nu</span>  is the (short) proof length). And on input R and  <span class="math">\\phi</span> , Test returns matrices  <span class="math">T_1, \\ldots, T_{\\eta} \\in \\mathbb{F}^{\\mu + \\nu}</span> . The last two algorithms implicitly define a prover and a verification algorithm as follows:</p>

    <pre><code class="language-text">\\circ \\ \\vec{\\pi} \\overset{\\$}{\\leftarrow} \\mathsf{LinPrv}(R, \\vec{\\sigma}, \\phi, \\omega) \\colon \\operatorname{run} \\ P \\overset{\\$}{\\leftarrow} \\mathsf{PrfMtrx}(R, \\phi, \\omega); \\ \\operatorname{return} \\ \\vec{\\pi} := P \\vec{\\sigma}.
\\circ \\ b \\overset{\\$}{\\leftarrow} \\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, \\vec{\\pi}) \\colon (T_1, \\dots, T_\\eta) \\overset{\\$}{\\leftarrow} \\mathsf{Test}(R, \\phi); \\ \\operatorname{return} \\ 1 \\ \\text{iff for all} \\ 1 \\le k \\le \\eta:
(\\vec{\\sigma}^\\top \\mid \\vec{\\pi}^\\top) \\ T_k \\ (\\vec{\\sigma}^\\top \\mid \\vec{\\pi}^\\top)^\\top = 0. \\tag{8}
</code></pre>

    <p class="text-gray-300">By symmetry of (8), for  <span class="math">T_k =: (t_{k,i,j})_{i,j=1}^{\\mu+\\nu}</span>  we can w.l.o.g. assume that  <span class="math">t_{k,i,j} = 0</span>  for all k, i and j &lt; i.</p>

    <p class="text-gray-300">We require a NILP to satisfy statistical knowledge soundness against affine prover strategies, which requires the existence of an (efficient) extractor X that works for all (unbounded) adversaries A. Whenever A returns a proof matrix P which leads to a valid proof  <span class="math">P\\vec{\\sigma}</span>  for a freshly</p>

    <pre><code class="language-text">\\mathsf{Setup}(R)
                                                                   Prv(R, \\vec{\\Sigma}, \\phi, \\omega)
                                                                                                                                                   Vfy(R, \\vec{\\Sigma}, \\phi, \\vec{\\Pi})
                                                                   03 P \\stackrel{\\$}{\\leftarrow} \\mathsf{PrfMtrx}(R, \\phi, \\omega)
                                                                                                                                                   og T_1, \\ldots, T_\\eta \\stackrel{\\$}{\\leftarrow} \\mathsf{Test}(R, \\phi)
oo q \\stackrel{\\$}{\\leftarrow} \\mathbb{G}
of \\vec{\\sigma} \\overset{\\$}{\\leftarrow} \\mathsf{LinSetup}(R)
                                                                   04 Parse P = (p_{i,i})_{i,j}
                                                                                                                                                   10 Parse T_k = (t_{k,i,j})_{i,j}
                                                                   of For i = 1 \\dots \\nu:
02 Return \\vec{\\Sigma} := \\langle \\vec{\\sigma} \\rangle
                                                                                                                                                   11 Return 1 iff for all 1 \\le k \\le \\eta:
                                                                  06 \\Pi_i \\coloneqq \\prod_{j=1}^{\\mu} \\Sigma_j^{p_{i,j}}07 \\pi \\coloneqq (\\Pi_1, \\dots, \\Pi_{\\nu})
                                                                                                                                                            0 = \\prod_{i=1}^{\\mu} \\prod_{j=i}^{\\mu} e(\\mathbf{\\Sigma}_{i}, \\mathbf{\\Sigma}_{j})^{t_{k,i,j}} \\cdot \\prod_{i=1}^{\\mu} \\prod_{j=\\mu+1}^{\\mu+\\nu} e(\\mathbf{\\Sigma}_{i}, \\mathbf{\\Pi}_{j})^{t_{k,i,j}} \\cdot \\prod_{i=\\mu+1}^{\\mu+\\nu} \\prod_{j=i}^{\\mu+\\nu} e(\\mathbf{\\Pi}_{i}, \\mathbf{\\Pi}_{j})^{t_{k,i,j}}
                                                                   08 Return \\pi
                                                                        // Note that \\pi := \\langle P\\vec{\\sigma} \\rangle
                                                                                                                                                         // This evaluates (8) in the exponent
</code></pre>

    <p class="text-gray-300">Figure 17: Argument system (Setup, Prv, Vfy) from a NILP (LinSetup, PrfMtrx, Test).</p>

    <pre><code class="language-text"> \\begin{array}{c} \\operatorname{LinSetup}(R) \\\\ \\text{00} \\ \\alpha, \\beta, \\gamma, \\delta, \\tau \\overset{\\$}{\\leftarrow} \\mathbb{F}^* \\\\ \\text{01} \\ \\vec{\\sigma} := \\left(\\alpha, \\beta, \\gamma, \\delta, \\{\\tau^i\\}_{i=0}^{n-1}, \\{\\frac{1}{\\gamma}(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=0}^{\\ell}, \\\\ \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-17-2&quot;&gt;&lt;/span&gt;Figure 18: Groth's NILP (LinSetup, PrfMtrx, Test).</p>

    <p class="text-gray-300">sampled  <span class="math">\\vec{\\sigma}</span> , X can extract a witness from P. The notion is defined via game <strong>k-snd-aff</strong>&lt;sub&gt;NILP,R&lt;/sub&gt; in Figure 16.</p>

    <p class="text-gray-300">NON-INTERACTIVE ARGUMENTS FROM NILPS. From a NILP for a quadratic arithmetic program over a finite field  <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>  for some prime p, one can construct an argument system over a bilinear group  <span class="math">\\mathcal{G} = (p, \\mathbb{G}, g, e)</span> . We thus consider QAP relations R of the form</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;
<span class="math">$R = (\\mathcal{G}, \\mathbb{F} = \\mathbb{Z}_p, \\ell, \\{u_i(X), v_i(X), w_i(X)\\}_{i=0}^m, t(X)),</span>$
(9)</p>

    <p class="text-gray-300">and define the <em>degree</em> of R as the degree of n of t(X).</p>

    <p class="text-gray-300">The construction of SNK = (Setup, Prv, Vfy) from NILP = (LinSetup, PrfMtrx, Test) is given in Figure 17, where we write  <span class="math">\\langle \\vec{x} \\rangle</span>  for  <span class="math">(g^{x_1}, \\ldots, g^{x_{|\\vec{x}|}})</span> . Setup samples a random group generator g and embeds the NILP CRS &quot;in the exponent&quot;. Using group operations, Prv computes LinPrv in the exponent, and using the pairing, Vfy verifies LinVfy in the exponent.</p>

    <p class="text-gray-300">GROTH'S NEAR-OPTIMAL SNARK FOR QAPS. Groth [Gro16] obtains his SNARK system by constructing a NILP for QAPs and then applying the conversion in Figure 17. Recall that R, as in (9), defines a language of statements  <span class="math">\\phi = (a_1, \\ldots, a_\\ell) \\in \\mathbb{F}^\\ell</span>  with witnesses of the form</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-4&quot;&gt;&lt;/span&gt; <span class="math">\\omega = (a_{\\ell+1}, \\dots, a_m) \\in \\mathbb{F}^{m-\\ell}</span>  such that (with  <span class="math">a_0 := 1</span> ):</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\left(\\sum_{i=0}^{m} a_i u_i(X)\\right) \\cdot \\left(\\sum_{i=0}^{m} a_i v_i(X)\\right) = \\sum_{i=0}^{m} a_i w_i(X) + h(X)t(X) \\tag{10}</span>$</p>

    <p class="text-gray-300">for some  <span class="math">h(X) \\in \\mathbb{F}[X]</span>  of degree at most n-2. Groth's NILP is given in Figure 18.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;<strong>Theorem 7.1</strong> ([Gro16, Theorem 1]). The construction in Figure 18 is a NILP with perfect completeness, perfect zero knowledge and statistical knowledge soundness against affine prover strategies.</p>

    <p class="text-gray-300">Groth embeds his NILP in asymmetric bilinear groups, which yields a more efficient SNARK. He then shows that the scheme is knowledge-sound in the generic group model for symmetric bilinear groups (which is a stronger result, as the adversary is more powerful than in asymmetric groups). Since we aim at strengthening Groth's security statement, we also consider the symmetric-group variant (which is what the transformation in Figure 17 yields). We now show how from an algebraic adversary breaking knowledge soundness one can construct an adversary against the q-DLog assumption.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-3&quot;&gt;&lt;/span&gt;<strong>Theorem 7.2</strong> Let SNK denote Groth's [Gro16] SNARK for degree-n QAPs defined over a (symmetric) bilinear group  <span class="math">\\mathcal{G}</span>  of order p with  <span class="math">n^2 \\leq (p-1)/8</span> . Then we have q-dlog  <span class="math">\\Longrightarrow_{\\mathsf{alg}}^{(3,1)}</span>  knw-snd&lt;sub&gt;SNK&lt;/sub&gt; with q := 2n-1.</p>

    <p class="text-gray-300">Let us start with a proof overview. Consider an algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  against knowledge soundness (as defined in Figure 16):  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  has input  <span class="math">(R, \\langle \\vec{\\sigma} \\rangle)</span>  and returns a statement  <span class="math">\\phi</span>  and a proof  <span class="math">\\vec{\\Pi}</span>  consisting of 3 group elements. Since  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is algebraic and its group-element inputs are  <span class="math">\\vec{\\Sigma} = \\langle \\vec{\\sigma} \\rangle</span> , the adversary returns  <span class="math">[\\mathbf{\\Pi}_i]_{\\vec{a}_i}</span>  for  <span class="math">1 \\leq i \\leq 3</span>  with  <span class="math">\\mathbf{\\Pi}_i = \\prod_{i=1}^{\\mu} \\mathbf{\\Sigma}_j^{a_{i,j}} = \\langle \\sum_{i=1}^{\\mu} \\sigma_j a_{i,j} \\rangle</span> . Letting  <span class="math">P := (a_{i,j})_{i,j} \\in \\mathbb{F}^{3 \\times \\mu}</span> , we have  <span class="math">\\vec{\\Pi} = \\langle P\\vec{\\sigma} \\rangle</span>  and we denote  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's group-element output as  <span class="math">[\\vec{\\Pi}]_P</span> .</p>

    <p class="text-gray-300">By definition,  <span class="math">\\vec{\\Pi}</span>  passes Vfy iff  <span class="math">P\\vec{\\sigma}</span>  satisfies LinVfy. In this case, by Groth's theorem (Theorem 7.1), there exists an extractor X, which on input P such that  <span class="math">P\\vec{\\sigma}</span>  satisfies LinVfy extracts a witness (see game <strong>k-snd-aff</strong>&lt;sub&gt;NILP,R&lt;/sub&gt; in Figure 16).</p>

    <p class="text-gray-300">So it seems this extractor X should also work for  <span class="math">A_{\\mathsf{alg}}</span>  (which returns P as required). However, X is only guaranteed to succeed if  <span class="math">P\\vec{\\sigma}</span>  verifies for a randomly sampled  <span class="math">\\vec{\\sigma}</span> , whereas for  <span class="math">A_{\\mathsf{alg}}</span>  in  <span class="math">\\mathbf{knw\\text{-snd}}_{\\mathsf{SNK},R}</span>  it suffices to return P so that  <span class="math">P\\vec{\\sigma}</span>  verifies for the specific  <span class="math">\\vec{\\sigma}</span>  for which it received  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> . To prove knowledge soundness, we must show that an adversary can only output P which works for all choices of  <span class="math">\\vec{\\sigma}</span>  (from which X will then extract a witness).</p>

    <p class="text-gray-300">In the generic group model this follows rather straight-forwardly, since the adversary has no information about the concrete  <span class="math">\\vec{\\sigma}</span> . In the AGM however,  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is given  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> , and if  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  could compute discrete logarithms, it could compute P which only verifies for the specific  <span class="math">\\vec{\\sigma}</span>  (in the same way as proofs are simulated to show zero knowledge of the scheme [Gro16]). Our proof strategy is to show that computing discrete logarithms is basically the only way to compute P which only works for the specific  <span class="math">\\vec{\\sigma}</span> .</p>

    <p class="text-gray-300">Examining the structure of a NILP CRS  <span class="math">\\vec{\\sigma}</span>  (Figure 18), we see that its components are defined as multivariate (Laurent) polynomials evaluated at a random point  <span class="math">\\vec{x} = (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> .</p>

    <p class="text-gray-300">Now what does it mean for  <span class="math">A_{alg}</span>  to output a valid P? By the definition of LinVfy via Test (cf. Equation (8) with  <span class="math">\\vec{\\pi} := P\\vec{\\sigma}</span> ), it means that  <span class="math">A_{alg}</span>  found P such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-2&quot;&gt;&lt;/span&gt;
<span class="math">$(\\vec{\\sigma}^{\\top} | (P\\vec{\\sigma}))^{\\top}) T (\\vec{\\sigma}^{\\top} | (P\\vec{\\sigma})^{\\top})^{\\top} = 0.</span>$</p>

    <p class="text-gray-300"><span class="math">$(11)</span>$</p>

    <p class="text-gray-300">If we interpret the components of  <span class="math">\\vec{\\sigma}</span>  as polynomials over  <span class="math">X_1, \\ldots, X_5</span>  (corresponding to  <span class="math">\\vec{x} = (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> ) then the left-hand side of (11) defines a polynomial  <span class="math">Q_P(\\vec{X})</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">X_A(R,\\langle \\vec{\\sigma} \\rangle)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{\\mathbf{knw\\text{-}snd}}{snk,R}^{A_{alg},X_{A}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\bigcirc} (\\phi, [\\vec{\\mathbf{\\Pi}}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\omega \\overset{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">(\\phi, [\\vec{\\Pi}]_P) \\stackrel{\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">\\omega</span> .</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\omega \\stackrel{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">((\\phi, \\omega) \\notin R \\land LinVfy(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;Figure 19: Extractor  <span class="math">X_A</span>  defined from X and  <span class="math">A_{alg}</span>  (left) and knowledge soundness game <strong>knw-snd</strong> for a SNARK built from NILP = (LinSetup, PrfMtrx, Test), algebraic adversary  <span class="math">A_{alg}</span>  and  <span class="math">X_A</span>  (right).</p>

    <p class="text-gray-300">On the other hand, what does it mean that  <span class="math">P\\vec{\\sigma}</span>  verifies for the specific  <span class="math">\\vec{\\sigma}</span>  from  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's input but not in general? It means that  <span class="math">Q_P(\\vec{x}) = 0</span> , but  <span class="math">Q_P \\not\\equiv 0</span> , that is,  <span class="math">Q_P</span>  is not the zero polynomial (since otherwise (11) would hold for any choice of  <span class="math">\\vec{x}</span> , that is,  <span class="math">P\\vec{\\sigma}&#x27;</span>  would verify for any  <span class="math">\\vec{\\sigma}&#x27;</span> ).</p>

    <p class="text-gray-300">We now bound the probability that  <span class="math">A_{alg}</span>  behaves &quot;badly&quot;, that is, it returns a proof that only holds with respect to its specific CRS. To do so, we bound the probability that given  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> ,  <span class="math">A_{alg}</span>  (implicitly) returns a nonzero polynomial  <span class="math">Q_P</span>  which vanishes at  <span class="math">\\vec{x}</span> , the point that defines  <span class="math">\\vec{\\sigma}</span> . By factoring  <span class="math">Q_P</span> , we can then extract information about  <span class="math">\\vec{x}</span> , which was only given as group elements  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> .</p>

    <p class="text-gray-300">Concretely, we embed a q-DLog instance simultaneously into  <span class="math">\\alpha, \\ldots, \\tau</span>  of a CRS  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> , for which we thus need q to be at least the maximum of the total degrees of the polynomials defining  <span class="math">\\sigma</span> , which for Groth's NILP is 2n-1. The technical part of the proof is to show that the left-hand side of (11), when viewed as a <em>univariate</em> polynomial, one of whose roots is the DLog challenge, is non-zero. The reduction can then compute the DLog by factoring this polynomial to obtain its roots.</p>

    <p class="text-gray-300">Proof of Theorem 7.2. Let R be a QAP of degree n (cf. (9)). Let NILP = (LinSetup, PrfMtrx, Test) denote Groth's NILP (Figure 18). By Theorem 7.1 there exists an extractor X, which on input R, statement  <span class="math">\\phi \\in L_R</span> , and  <span class="math">P \\in \\mathbb{F}^{\\nu \\times \\mu}</span>  such that  <span class="math">\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1</span>  for  <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} \\mathsf{LinSetup}(R)$  returns a witness  <span class="math">\\omega</span>  with probability  <span class="math">\\mathbf{Adv}^{\\mathbf{k-snd-aff}}_{\\mathsf{NILP},R,\\mathsf{X},\\mathsf{F}}</span>  for any affine  <span class="math">\\mathsf{F}</span> .</p>

    <p class="text-gray-300">Let SNK denote Groth's SNARK obtained from NILP via the transformation in Figure 17 and let  <span class="math">A_{alg}</span>  be an algebraic adversary in the game <strong>knw-snd</strong>  <span class="math">_{SNK,R}</span> . From X we construct an extractor  <span class="math">X_A</span>  for  <span class="math">A_{alg}</span>  in Figure 19. Note that since  <span class="math">A_{alg}</span>  is algebraic, we have  <span class="math">\\vec{\\Pi} = \\langle P\\vec{\\sigma} \\rangle</span> , for which we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Vfy}(R, \\vec{\\Sigma}, \\phi, \\vec{\\Pi}) = \\mathsf{Vfy}(R, \\vec{\\Sigma}, \\phi, \\langle P\\vec{\\sigma} \\rangle) = \\mathsf{Lin}\\mathsf{Vfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) \\tag{12}</span>$</p>

    <p class="text-gray-300">by the definition of Vfy (Figure 17). Using this, we write out Game  <span class="math">\\mathbf{knw\\text{-}snd}^{\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}_{\\mathsf{SNK},R}</span>  in Figure 19. Our goal is to upperbound  <span class="math">\\mathbf{Adv}^{\\mathbf{knw\\text{-}snd}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}</span> .</p>

    <p class="text-gray-300">Consider the affine prover A' in Figure 20 and <strong>k-snd-aff</strong>  <span class="math">^{\\mathsf{X},\\mathsf{A&#x27;}}_{\\mathsf{NILP}}</span> , with the code of A' written out, also in Figure 20. Comparing the right-hand sides of Figures 19 and 20, we see that the outputs of the games only differ in the following: if LinVfy returns 0 for  <span class="math">P\\vec{\\rho}</span>  w.r.t.  <span class="math">\\vec{\\rho}</span> , but it returns 1 for  <span class="math">P\\vec{\\sigma}</span>  w.r.t.  <span class="math">\\vec{\\sigma}</span> , then <strong>knw-snd</strong> returns 1 whereas <strong>k-snd-aff</strong> returns 0. Let <strong>bad</strong> denote the event when this happens; formally defined as a flag in game <strong>k-snd-aff</strong> in Figure 20. By definition, we have</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{Adv_{SNK}^{knw\\text{-snd}}}_{NK,R,A_{alg},X_A} \\le \\mathbf{Adv_{NILP,R,X,A&#x27;}^{k\\text{-snd-aff}}} + \\Pr[\\mathbf{bad} = 1].</span>$
(13)</p>

    <p class="text-gray-300">In order to simplify our analysis, we first make a syntactical change to NILP by multiplying</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-5&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A'(R)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{k}}</span> -snd-aff <span class="math">\\mathbf{n}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\circ} \\circ \\overrightarrow{\\sigma} \\stackrel{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">\\vec{\\rho} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\phi, [\\vec{\\bm{\\Pi}}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">(\\phi, P)</span> .</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">(\\phi, [\\vec{\\bf \\Pi}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">\\omega \\stackrel{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of If <span class="math">((\\phi,\\omega)\\notin R \\wedge LinVfy(R,\\vec{\\sigma},\\phi,P\\vec{\\sigma})=1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\wedge \\; LinVfy(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">08  \\text{Then } \\mathbf{bad} := 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 Return <span class="math">((\\phi, \\omega) \\notin R \\land LinVfy(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;Figure 20: Affine prover A' defined from  <span class="math">A_{alg}</span>  (left) and game <strong>k-snd-aff</strong> for NILP, extractor X and A' (right).</p>

    <p class="text-gray-300">out all denominators, that is, we let LinSetup (cf. Figure 18) return</p>

    <p class="text-gray-300"><span class="math">$\\vec{\\sigma} := \\left(\\delta\\gamma, \\alpha\\delta\\gamma, \\beta\\delta\\gamma, \\delta\\gamma^2, \\delta^2\\gamma, \\{\\delta\\gamma\\tau^i\\}_{i=0}^{n-1}, \\{\\delta(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=0}^{\\ell}, \\{\\gamma(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=\\ell+1}^{m}, \\{\\gamma\\tau^i t(\\tau)\\}_{i=0}^{n-2}\\right).</span>$
(14)</p>

    <p class="text-gray-300">Note that this does not affect the distribution of the SNARK CRS as running the modified LinSetup amounts to the same as choosing  <span class="math">g&#x27; \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}$  and running the original setup with  <span class="math">g := (g&#x27;)^{\\delta \\gamma}</span> , which again is a uniformly random generator.</p>

    <p class="text-gray-300">Observe that the components of LinSetup defined in (14) can be described via multivariate polynomials  <span class="math">S_i(\\vec{x})</span> ,  <span class="math">1 \\le i \\le \\mu</span> , of total degree at most 2n-1 with  <span class="math">\\vec{x} := (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> , and LinSetup can be defined as picking a random point  <span class="math">\\vec{x} \\stackrel{\\</span>}{\\leftarrow} (\\mathbb{F}^*)^5$  and returning the evaluations  <span class="math">\\sigma_i := S_i(\\vec{x})</span>  of these polynomials.</p>

    <p class="text-gray-300">Let T be as defined by Test in Figure 18. By (8) we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1 \\iff \\vec{\\sigma}^\\top \\big( (Id \\,|\\, P^\\top) \\cdot T \\cdot (Id \\,|\\, P^\\top)^\\top \\big) \\, \\vec{\\sigma} = 0.</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\vec{S}</span>  be the vector of polynomials defined by LinSetup. For a matrix  <span class="math">P \\in \\mathbb{F}^{3 \\times \\mu}</span>  define the following multivariate polynomial</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-3&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;
<span class="math">$Q_{P}(\\vec{X}) := (\\vec{S}(\\vec{X}))^{\\top} ((Id \\mid P^{\\top}) \\cdot T \\cdot (Id \\mid P^{\\top})^{\\top}) \\vec{S}(\\vec{X})</span>$
(15)</p>

    <p class="text-gray-300">of degree at most  <span class="math">(2n-1)^2</span> . Then for any  <span class="math">\\vec{x} \\in (\\mathbb{F}^*)^5</span>  and  <span class="math">\\vec{\\sigma} := \\vec{S}(\\vec{x})</span>  we have</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma})) = 1 \\iff Q_P(\\vec{x}) = 0. \\tag{16}</span>$</p>

    <p class="text-gray-300">Groth [Gro16] proves Theorem 7.1 by showing that from a proof P with  <span class="math">Q_P \\equiv 0</span>  (that is, P verifies for any choice of  <span class="math">\\sigma</span> ), an extractor X can efficiently compute a witness. Thus in order to win game <strong>k-snd-aff</strong> NILP,R, the adversary must return P with  <span class="math">Q_P \\not\\equiv 0</span>  (thus the extractor fails), but which verifies for  <span class="math">\\sigma</span> , which by (16) means  <span class="math">Q_P(\\vec{x}) = 0</span> .</p>

    <p class="text-gray-300">The affine adversary has no information on  <span class="math">\\sigma</span>  and thus the polynomial  <span class="math">Q_P</span>  is independent of it. The Schwartz-Zippel lemma states that a non-zero multivariate polynomial over  <span class="math">\\mathbb{F}_p</span>  of total degree d evaluates to 0 on a uniformly random point with probability at most  <span class="math">\\frac{d}{p-1}</span> .</p>

    <p class="text-gray-300">Since the total degree of  <span class="math">Q_P</span>  is at most  <span class="math">d = (2n-1)^2</span>  (using the modified  <span class="math">\\vec{\\sigma}</span>  from (14)), the probability that  <span class="math">Q_P(\\vec{x}) = 0</span>  for a random  <span class="math">\\vec{x} \\stackrel{\\</span>}{\\leftarrow} (F^*)^5$  is thus bounded by  <span class="math">\\frac{d}{p-1}</span> . This yields</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-4&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{Adv}_{\\mathsf{NILP},R,\\mathsf{X},\\mathsf{A&#x27;}}^{\\mathsf{k-snd-aff}} \\le \\frac{(2n-1)^2}{p-1}. \\tag{17}</span>$</p>

    <p class="text-gray-300">In order to bound  <span class="math">\\mathbf{Adv_{SNK}^{knw-snd}}_{SNK,R,A_{alg},X_{A}}</span>  in (13), we will construct an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{bad} = 1\\right] \\le \\left(1 - \\frac{(2n-1)^2}{p-1}\\right) \\cdot \\mathbf{Adv}_{\\mathcal{G}, \\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}} \\quad \\text{with} \\quad q = 2n - 1.</span>$
(18)</p>

    <p class="text-gray-300">For <strong>bad</strong> to be set to 1,  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's output P must be such that  <span class="math">Q_P \\not\\equiv 0</span> : otherwise,  <span class="math">\\mathsf{LinVfy}</span>  returns 1 for  <span class="math">any \\ \\vec{x}</span>  and in particular  <span class="math">\\mathsf{LinVfy}(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 1</span> .</p>

    <p class="text-gray-300">Event  <span class="math">\\mathbf{bad} = 1</span>  implies thus that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  on input  <span class="math">\\langle \\vec{\\sigma} \\rangle = \\langle \\vec{S}(\\vec{x}) \\rangle</span>  returns P such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;
<span class="math">$Q_P \\not\\equiv 0 \\quad \\text{and} \\quad Q_P(\\vec{x}) = 0.</span>$
(19)</p>

    <p class="text-gray-300">We now use such  <span class="math">A_{alg}</span>  to construct an adversary  <span class="math">B_{alg}</span>  that solves q-DLog with q := 2n - 1.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}(\\langle z \\rangle, \\langle z^2 \\rangle, ..., \\langle z^q \\rangle)</span> : On input a q-DLog instance,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  simulates  <span class="math">\\mathsf{k\\text{-snd-aff}}_{\\mathsf{NILP},R}^{\\mathsf{X},\\mathsf{A}&#x27;}</span>  for  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . It first picks a random values  <span class="math">\\vec{r} \\leftarrow (\\mathbb{F}^*)^5</span>  and  <span class="math">\\vec{s} \\leftarrow \\mathbb{F}^5</span>  and (implicitly) sets  <span class="math">x_i := r_i z + s_i</span> , that is:</p>

    <p class="text-gray-300"><span class="math">$\\alpha := r_1 z + s_1</span>$
<span class="math">\\beta := r_2 z + s_2</span>   <span class="math">\\gamma := r_3 z + s_3</span>   <span class="math">\\delta := r_4 z + s_4</span>   <span class="math">\\tau := r_5 z + s_5</span></p>

    <p class="text-gray-300">If  <span class="math">x_i=0</span>  for some i (which  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can check using  <span class="math">\\langle z \\rangle</span> ) then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  stops and outputs  <span class="math">z:=-s_i r_i^{-1} \\bmod p</span> .</p>

    <p class="text-gray-300">Otherwise,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  generates a CRS  <span class="math">\\langle \\vec{\\sigma} \\rangle := \\langle \\vec{S}(\\vec{x}) \\rangle = \\langle \\vec{S}(\\alpha, \\beta, \\gamma, \\delta, \\tau) \\rangle</span>  as defined in (14). Since the total degree of the polynomials  <span class="math">S_i</span>  defining  <span class="math">\\vec{\\sigma}</span>  is bounded by 2n-1=q (the degree of the last component of  <span class="math">\\vec{\\sigma}</span> ),  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can compute  <span class="math">\\langle \\vec{\\sigma} \\rangle</span>  from its q-DLog instance.</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  runs  <span class="math">(\\phi, [\\vec{\\mathbf{\\Pi}}]_P) \\overset{\\</span>}{\\leftarrow} \\mathsf{A}<em>{\\mathsf{alg}}(R, \\langle \\vec{\\sigma} \\rangle)$  and from P computes the multivariate polynomial  <span class="math">Q_P(\\vec{X})</span>  as defined in (15). If  <span class="math">Q_P \\equiv 0</span>  or  <span class="math">Q_P(\\vec{x}) \\neq 0</span>  (by (19) this means that event <strong>bad</strong> has not occurred) then  $\\mathsf{B}</em>{\\mathsf{alg}}$  aborts. (**)</p>

    <p class="text-gray-300">Otherwise  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defines the univariate polynomial</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;_P(Z) := Q_P(r_1Z + s_1, \\dots, r_5Z + s_5).</span>$</p>

    <p class="text-gray-300">If
<span class="math">$Q_P&#x27; \\equiv 0</span>$
then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  aborts.  <span class="math">(***)</span></p>

    <p class="text-gray-300">Otherwise  <span class="math">B_{alg}</span>  factors  <span class="math">Q&#x27;_P</span>  to obtain its roots (of which by (15) there are at most  <span class="math">(2n-1)^2</span> ), checks them against its DLog instance to determine whether z is among them, and if so, returns z.</p>

    <p class="text-gray-300">In case  <span class="math">B_{alg}</span>  does not stop at (*), it perfectly simulates <strong>k-snd-aff</strong>  <span class="math">^{X,A&#x27;}_{NILP,R}</span>  for  <span class="math">A_{alg}</span> . We now analyze the probability that  <span class="math">B_{alg}</span>  finds the target z provided that bad = 1. As in this case  <span class="math">B_{alg}</span>  will not abort at (**), it remains to bound the probability of aborting at (***).</p>

    <p class="text-gray-300">Since  <span class="math">Q&#x27;_P(z) = Q_P(r_1z + s_1, \\dots, r_5z + s_5) = Q_P(\\vec{x})</span> , by (19) we have  <span class="math">Q&#x27;_P(z) = 0</span> . Thus if  <span class="math">Q&#x27;_P \\not\\equiv 0</span>  then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  finds z by factoring  <span class="math">Q&#x27;_P</span> , and it remains to argue that  <span class="math">Q&#x27;_P \\not\\equiv 0</span> .</p>

    <p class="text-gray-300"><span class="math">Q_P</span>  is of the form  <span class="math">Q_P(\\vec{X}) = \\sum_{i_1,\\dots,i_5} c_{i_1,\\dots,i_5} \\prod_{j=1}^5 X_j^{i_j}</span>  for coefficients  <span class="math">c_{i_1,\\dots,i_5}</span>  and thus</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;_{P}(Z) = \\sum_{i_{1},\\dots,i_{5}} c_{i_{1},\\dots,i_{5}} \\prod_{j=1}^{5} (r_{j}Z + s_{j})^{i_{j}} = \\sum_{\\vec{i}} c_{\\vec{i}} \\prod_{j=1}^{5} \\left( \\sum_{k=0}^{i_{j}} \\binom{i_{j}}{k} r_{j}^{k} Z^{k} s_{j}^{i_{j}-k} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{k_{1},\\dots,k_{5}}^{i_{1},\\dots,i_{5}} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} Z^{k_{j}} s_{j}^{i_{j}-k_{j}} = \\sum_{\\ell} \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{\\vec{k}: \\sum_{j}k_{j}=\\ell}^{5} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} Z^{k_{j}} s_{j}^{i_{j}-k_{j}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\ell} c&#x27;_{\\ell} Z^{\\ell} \\qquad \\text{with} \\quad c&#x27;_{\\ell} := \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{\\vec{k}: \\sum_{j}k_{j}=\\ell}^{5} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} s_{j}^{i_{j}-k_{j}}.</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;By (19) we have  <span class="math">Q_P \\not\\equiv 0</span> . Let  <span class="math">d^*</span>  be the total degree of  <span class="math">Q_P</span> , thus for some  <span class="math">i_1, \\ldots, i_5 \\geq 0</span>  with  <span class="math">\\sum_i i_j = d^*</span>  we have  <span class="math">c_{i_1, \\ldots, i_5} \\neq 0</span> , while  <span class="math">c_{i_1, \\ldots, i_5} = 0</span>  when  <span class="math">\\sum_i i_j &gt; d^*</span> . By the latter we have</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{d^*} \\ = \\ \\sum_{\\vec{i}: \\, \\Sigma_j i_j \\leq d^*} c_{\\vec{i}} \\, \\sum_{\\vec{k}: \\, \\Sigma_j k_j = d^*}^{\\vec{i}} \\, \\prod_{j=1}^5 \\binom{i_j}{k_j} \\, r_j^{k_j} \\, s_j^{i_j - k_j} \\ = \\ \\sum_{\\vec{i}: \\, \\Sigma_j i_j \\leq d^*} c_{\\vec{i}} \\, \\prod_{j=1}^5 r_j^{i_j},</span>$</p>

    <p class="text-gray-300">since  <span class="math">k_j \\leq i_j</span> , for all j, and  <span class="math">\\sum_i i_j \\leq d^*</span>  and  <span class="math">\\sum_i k_j = d^*</span>  implies  <span class="math">k_j = i_j</span>  for all j.</p>

    <p class="text-gray-300">We now lower-bound the probability that  <span class="math">c&#x27;_{d^*} \\neq 0</span>  and thus  <span class="math">Q&#x27;_P \\not\\equiv 0</span> . First note that from  <span class="math">\\langle \\vec{\\sigma} \\rangle = \\langle \\vec{S}(\\vec{x}) \\rangle</span>  the adversary obtains information on  <span class="math">\\vec{x}</span> , which might influence its choice of  <span class="math">Q_P</span> ; however, the values  <span class="math">s_1, \\ldots, s_5</span>  perfectly blind the values  <span class="math">r_1 z, \\ldots, r_5 z</span> , and  <span class="math">c&#x27;_{d^*}</span> , which is independent of  <span class="math">(s_1, \\ldots, s_5)</span>  is thus also independent of  <span class="math">(r_1, \\ldots, r_5)</span> . Consider  <span class="math">c&#x27;_{d^*}</span>  as a polynomial in variables  <span class="math">(R_1, \\ldots, R_n)</span>  of degree  <span class="math">d^*</span> , that is,  <span class="math">C&#x27;_{d^*}(\\vec{R}) := \\sum_{\\vec{i}} c_{\\vec{i}} \\prod_{j=1}^5 R_j^{i_j}</span> . By the Schwartz-Zippel lemma, the probability that for a random  <span class="math">\\vec{r} \\stackrel{\\</span>}{\\leftarrow} (\\mathbb{F}^<em>)^5$  we have  $C'_{d^</em>}(\\vec{r}) = 0$  is bounded by  <span class="math">\\frac{d^*}{p-1}</span>  where  <span class="math">d^*</span>  is upper-bounded by the total degree of  <span class="math">Q_P</span> , which is at most  <span class="math">(2n-1)^2</span> . We thus have  <span class="math">Q&#x27;_P \\not\\equiv 0</span>  with probability at least  <span class="math">1 - \\frac{(2n-1)^2}{p-1}</span> . Since, conditioned on <strong>bad</strong> = 1, the adversary returns the solution to the q-DLog instance, with q = 2n - 1, whenever  <span class="math">Q&#x27;_P \\not\\equiv 0</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}} \\geq \\left(1 - \\frac{(2n-1)^2}{p-1}\\right) \\cdot \\Pr\\left[\\mathbf{bad} = 1\\right] \\geq \\frac{1}{2} \\cdot \\Pr\\left[\\mathbf{bad} = 1\\right],</span>$</p>

    <p class="text-gray-300">where the last inequality comes from  <span class="math">n^2 \\leq (p-1)/8</span> . Putting this together with (13) and (17), we have shown that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv_{\\mathsf{SNK},R}^{\\mathbf{knw\\text{-}snd}}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}} \\leq \\tfrac{q^2}{p-1} + 2 \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}}.</span>$</p>

    <p class="text-gray-300">Following the generic bound for Boneh and Boyen's SDH assumption [BB08] (see below), we may assume that  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q-\\mathsf{dlog}} \\geq \\frac{q^2}{p-1}</span> . The above equation thus implies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}^{\\mathbf{knw\\text{-}snd}} \\leq 3 \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}},</span>$</p>

    <p class="text-gray-300">which concludes the proof.</p>

    <p class="text-gray-300"><strong>Corollary 7.3</strong> In the generic group model breaking knowledge soundness of Groth's SNARK [Gro16] for a degree-n QAP is  <span class="math">(\\frac{3t^2q+3q^3}{p},t)</span> -hard for q=2n-1.</p>

    <p class="text-gray-300">The corollary follows from the generic  <span class="math">(\\frac{t^2q+q^3}{p},t)</span> -hardness of q-dlog, which is derived analogously to the bound for Boneh and Boyen's SDH assumption [BB08].</p>

    <p class="text-gray-300">We remark that the above result is not specific to Groth's SNARK; it applies to any SNARK built from a NILP whose setup evaluates multivariate polynomials on a random position. The maximal total degree of these polynomials determines the parameter q in the q-DLog instance.</p>

    <p class="text-gray-300">We thank Balthazar Bauer for pointing out a flaw and a fix in the proof of Theorem 7.2. We also thank Dan Brown for valuable comments, Pooya Farshim for discussions on polynomiels and Helger Lipmaa for sharing with us his independent security proof for Groth's SNARK. The first author is supported by the French ANR EfTrEC project (ANR-16-CE39-0002). The second author was supported in part by ERC Project ERCC (FP7/615074) and by DFG SPP 1736 Big Data. The third author was supported by ERC Project ERCC (FP7/615074).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8"><strong>References</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-2&quot;&gt;&lt;/span&gt;[ABM15] Michel Abdalla, Fabrice Benhamouda, and Philip MacKenzie. Security of the J-PAKE password-authenticated key exchange protocol. In <em>2015 IEEE Symposium on Security and Privacy</em>, pages 571â€“587. IEEE Computer Society Press, May 2015. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-3&quot;&gt;&lt;/span&gt;[ABR01] Michel Abdalla, Mihir Bellare, and Phillip Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In David Naccache, editor, <em>CT-RSA 2001</em>, volume 2020 of <em>LNCS</em>, pages 143â€“158. Springer, Heidelberg, April 2001. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-9-1">10.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-9&quot;&gt;&lt;/span&gt;[ABS16] Miguel Ambrona, Gilles Barthe, and Benedikt Schmidt. Automated unbounded analysis of cryptographic constructions in the generic group model. In Marc Fischlin and Jean-SÃ©bastien Coron, editors, <em>EUROCRYPT 2016, Part II</em>, volume 9666 of <em>LNCS</em>, pages 822â€“851. Springer, Heidelberg, May 2016. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-7&quot;&gt;&lt;/span&gt;[ACdM05] Giuseppe Ateniese, Jan Camenisch, and Breno de Medeiros. Untraceable RFID tags via insubvertible encryption. In Vijayalakshmi Atluri, Catherine Meadows, and Ari Juels, editors, <em>ACM CCS 05</em>, pages 92â€“101. ACM Press, November 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-6&quot;&gt;&lt;/span&gt;[ACHdM05] Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, and Breno de Medeiros. Practical group signatures without random oracles. Cryptology ePrint Archive, Report 2005/385, 2005. <a href="http://eprint.iacr.org/2005/385">http://eprint.iacr.org/2005/385</a>. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-1&quot;&gt;&lt;/span&gt;[AGO11] Masayuki Abe, Jens Groth, and Miyako Ohkubo. Separating short structurepreserving signatures from non-interactive assumptions. In Dong Hoon Lee and Xiaoyun Wang, editors, <em>ASIACRYPT 2011</em>, volume 7073 of <em>LNCS</em>, pages 628â€“646. Springer, Heidelberg, December 2011. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;[AM09] Divesh Aggarwal and Ueli Maurer. Breaking RSA generically is equivalent to factoring. In Antoine Joux, editor, <em>EUROCRYPT 2009</em>, volume 5479 of <em>LNCS</em>, pages 36â€“53. Springer, Heidelberg, April 2009. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-11&quot;&gt;&lt;/span&gt;[BB08] Dan Boneh and Xavier Boyen. Short signatures without random oracles and the SDH assumption in bilinear groups. <em>Journal of Cryptology</em>, 21(2):149â€“177, April 2008. (Cited on page <a href="#page-22-0">23.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-10&quot;&gt;&lt;/span&gt;[BCI+13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, <em>TCC 2013</em>, volume 7785 of <em>LNCS</em>, pages 315â€“333. Springer, Heidelberg, March 2013. (Cited on page <a href="#page-16-2">17.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-4&quot;&gt;&lt;/span&gt;[BCL04] E. Bangerter, J. Camenisch, and A. Lysyanskaya. A cryptographic framework for the controlled release of certified data. In <em>Security Protocols Workshop</em>, pages 20â€“24, 2004. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-8&quot;&gt;&lt;/span&gt;[BCPR16] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. <em>SIAM Journal on Computing</em>, 2016. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-23-5&quot;&gt;&lt;/span&gt;[BCS05] M. Backes, J. Camenisch, and D. Sommer. Anonymous yet accountable access control. In <em>WPES</em>, pages 40â€“46, 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-11&quot;&gt;&lt;/span&gt;[BDZ03] Feng Bao, Robert H. Deng, and Huafei Zhu. Variations of Diffie-Hellman problem. In Sihan Qing, Dieter Gollmann, and Jianying Zhou, editors, <em>ICICS 03</em>, volume 2836 of <em>LNCS</em>, pages 301â€“312. Springer, Heidelberg, October 2003. (Cited on page <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-5&quot;&gt;&lt;/span&gt;[BFF+14] Gilles Barthe, Edvard Fagerholm, Dario Fiore, John C. Mitchell, Andre Scedrov, and Benedikt Schmidt. Automated analysis of cryptographic assumptions in generic group models. In Juan A. Garay and Rosario Gennaro, editors, <em>CRYPTO 2014, Part I</em>, volume 8616 of <em>LNCS</em>, pages 95â€“112. Springer, Heidelberg, August 2014. (Cited on page <a href="#page-3-0">4,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-3&quot;&gt;&lt;/span&gt;[BFW16] David Bernhard, Marc Fischlin, and Bogdan Warinschi. On the hardness of proving CCA-security of signed ElGamal. In Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang, editors, <em>PKC 2016, Part I</em>, volume 9614 of <em>LNCS</em>, pages 47â€“69. Springer, Heidelberg, March 2016. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-6&quot;&gt;&lt;/span&gt;[BG04] Daniel R. L. Brown and Robert P. Gallant. The static diffie-hellman problem. Cryptology ePrint Archive, Report 2004/306, 2004. <a href="http://eprint.iacr.org/2004/306">http://eprint.iacr.org/</a> <a href="http://eprint.iacr.org/2004/306">2004/306</a>. (Cited on page <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;[BL96] Dan Boneh and Richard J. Lipton. Algorithms for black-box fields and their application to cryptography (extended abstract). In Neal Koblitz, editor, <em>CRYPTO'96</em>, volume 1109 of <em>LNCS</em>, pages 283â€“297. Springer, Heidelberg, August 1996. (Cited on page <a href="#page-0-0">1.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-4&quot;&gt;&lt;/span&gt;[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing. <em>Journal of Cryptology</em>, 17(4):297â€“319, September 2004. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-12-1">13.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;[BMV08] Emmanuel Bresson, Jean Monnerat, and Damien Vergnaud. Separation results on the &quot;one-more&quot; computational problems. In Tal Malkin, editor, <em>CT-RSA 2008</em>, volume 4964 of <em>LNCS</em>, pages 71â€“87. Springer, Heidelberg, April 2008. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-8&quot;&gt;&lt;/span&gt;[Boy08] Xavier Boyen. The uber-assumption family (invited talk). In Steven D. Galbraith and Kenneth G. Paterson, editors, <em>PAIRING 2008</em>, volume 5209 of <em>LNCS</em>, pages 39â€“56. Springer, Heidelberg, September 2008. (Cited on page <a href="#page-4-0">5,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-10&quot;&gt;&lt;/span&gt;[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, <em>ACM CCS 93</em>, pages 62â€“73. ACM Press, November 1993. (Cited on page <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-9&quot;&gt;&lt;/span&gt;[BR04] Mihir Bellare and Phillip Rogaway. Code-based game-playing proofs and the security of triple encryption. Cryptology ePrint Archive, Report 2004/331, 2004. <a href="http://eprint.iacr.org/2004/331">http://eprint.iacr.org/2004/331</a>. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;[BV98] Dan Boneh and Ramarathnam Venkatesan. Breaking RSA may not be equivalent to factoring. In Kaisa Nyberg, editor, <em>EUROCRYPT'98</em>, volume 1403 of <em>LNCS</em>, pages 59â€“71. Springer, Heidelberg, May / June 1998. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-24-7&quot;&gt;&lt;/span&gt;[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited (preliminary version). In <em>30th ACM STOC</em>, pages 209â€“218. ACM Press, May 1998. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-8&quot;&gt;&lt;/span&gt;[Che06] Jung Hee Cheon. Security analysis of the strong Diffie-Hellman problem. In Serge Vaudenay, editor, <em>EUROCRYPT 2006</em>, volume 4004 of <em>LNCS</em>, pages 1â€“11. Springer, Heidelberg, May / June 2006. (Cited on page <a href="#page-3-0">4,</a> <a href="#page-11-2">12.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-6&quot;&gt;&lt;/span&gt;[CHK+06] Jan Camenisch, Susan Hohenberger, Markulf Kohlweiss, Anna Lysyanskaya, and Mira Meyerovich. How to win the clonewars: Efficient periodic n-times anonymous authentication. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, <em>ACM CCS 06</em>, pages 201â€“210. ACM Press, October / November 2006. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-5&quot;&gt;&lt;/span&gt;[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Ronald Cramer, editor, <em>EUROCRYPT 2005</em>, volume 3494 of <em>LNCS</em>, pages 302â€“321. Springer, Heidelberg, May 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-7&quot;&gt;&lt;/span&gt;[CHP07] Jan Camenisch, Susan Hohenberger, and Michael Ã˜stergaard Pedersen. Batch verification of short signatures. In Moni Naor, editor, <em>EUROCRYPT 2007</em>, volume 4515 of <em>LNCS</em>, pages 246â€“263. Springer, Heidelberg, May 2007. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-4&quot;&gt;&lt;/span&gt;[CL04] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Matthew Franklin, editor, <em>CRYPTO 2004</em>, volume 3152 of <em>LNCS</em>, pages 56â€“72. Springer, Heidelberg, August 2004. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-10-3">11.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-10&quot;&gt;&lt;/span&gt;[CM14] Melissa Chase and Sarah Meiklejohn. DÃ©jÃ  Q: Using dual systems to revisit q-type assumptions. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>EURO-CRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 622â€“639. Springer, Heidelberg, May 2014. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;[Cor02] Jean-SÃ©bastien Coron. Optimal security proofs for PSS and other signature schemes. In Lars R. Knudsen, editor, <em>EUROCRYPT 2002</em>, volume 2332 of <em>LNCS</em>, pages 272â€“287. Springer, Heidelberg, April / May 2002. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;[Dam92] Ivan DamgÃ¥rd. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, <em>CRYPTO'91</em>, volume 576 of <em>LNCS</em>, pages 445â€“456. Springer, Heidelberg, August 1992. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-9&quot;&gt;&lt;/span&gt;[Den02] Alexander W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In Yuliang Zheng, editor, <em>ASIACRYPT 2002</em>, volume 2501 of <em>LNCS</em>, pages 100â€“109. Springer, Heidelberg, December 2002. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;[DH76] Whitfield Diffie and Martin E. Hellman. New directions in cryptography. <em>IEEE Transactions on Information Theory</em>, 22(6):644â€“654, 1976. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">[FKL17] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. <em>Cryptology ePrint Archive, Report 2017/620</em>, 2017. (Cited on page .)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;[GBL08] Sanjam Garg, Raghav Bhaskar, and Satyanarayana V. Lokam. Improved bounds on security reductions for discrete log based signatures. In David Wagner, editor, <em>CRYPTO 2008</em>, volume 5157 of <em>LNCS</em>, pages 93â€“107. Springer, Heidelberg, August 2008. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-11&quot;&gt;&lt;/span&gt;[GG17] Jens Groth and Essam Ghadafi. Towards a classification of non-interactive computational assumptions in cyclic groups. In Tsuyoshi Takagi and Thomas Peyrin,</p></li>
      <li><p class="text-gray-300">editors, <em>ASIACRYPT 2017</em>, volume 10625 of <em>LNCS</em>, pages 66â€“96, Hong Kong, December 2017. Springer. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-10&quot;&gt;&lt;/span&gt;[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, <em>EUROCRYPT 2013</em>, volume 7881 of <em>LNCS</em>, pages 626â€“645. Springer, Heidelberg, May 2013. (Cited on page <a href="#page-15-1">16.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-5&quot;&gt;&lt;/span&gt;[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-SÃ©bastien Coron, editors, <em>EUROCRYPT 2016, Part II</em>, volume 9666 of <em>LNCS</em>, pages 305â€“326. Springer, Heidelberg, May 2016. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-15-1">16,</a> <a href="#page-16-2">17,</a> <a href="#page-17-3">18,</a> <a href="#page-18-4">19,</a> <a href="#page-20-5">21,</a> <a href="#page-22-0">23.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;[HP78] M. E. Hellman and S. C. Pohlig. An improved algorithm for computing logarithms over <em>GF</em>(<em>p</em>) and its cryptographic significance. <em>IEEE Transactions on Information Theory</em>, 24(1):106â€“110, 1978. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;[JR10] Tibor Jager and Andy Rupp. The semi-generic group model and applications to pairing-based cryptography. In Masayuki Abe, editor, <em>ASIACRYPT 2010</em>, volume 6477 of <em>LNCS</em>, pages 539â€“556. Springer, Heidelberg, December 2010. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-8&quot;&gt;&lt;/span&gt;[JR15] Antoine Joux and Antoine Rojat. Security ranking among assumptions within the <em>Uber Assumption</em> framework. In Yvo Desmedt, editor, <em>ISC 2013</em>, volume 7807 of <em>LNCS</em>, pages 391â€“406. Springer, Heidelberg, November 2015. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-6&quot;&gt;&lt;/span&gt;[JS09] Tibor Jager and JÃ¶rg Schwenk. On the analysis of cryptographic assumptions in the generic ring model. In Mitsuru Matsui, editor, <em>ASIACRYPT 2009</em>, volume 5912 of <em>LNCS</em>, pages 399â€“416. Springer, Heidelberg, December 2009. (Cited on page <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-7&quot;&gt;&lt;/span&gt;[Kil01] Eike Kiltz. A tool box of cryptographic functions related to the Diffie-Hellman function. In C. Pandu Rangan and Cunsheng Ding, editors, <em>INDOCRYPT 2001</em>, volume 2247 of <em>LNCS</em>, pages 339â€“350. Springer, Heidelberg, December 2001. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-4&quot;&gt;&lt;/span&gt;[KK12] Saqib A. Kakvi and Eike Kiltz. Optimal security proofs for full domain hash, revisited. In David Pointcheval and Thomas Johansson, editors, <em>EUROCRYPT 2012</em>, volume 7237 of <em>LNCS</em>, pages 537â€“553. Springer, Heidelberg, April 2012. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;[KMP16] Eike Kiltz, Daniel Masny, and Jiaxin Pan. Optimal security proofs for signatures from identification schemes. In Matthew Robshaw and Jonathan Katz, editors, <em>CRYPTO 2016, Part II</em>, volume 9815 of <em>LNCS</em>, pages 33â€“61. Springer, Heidelberg, August 2016. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-9&quot;&gt;&lt;/span&gt;[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In Nigel P. Smart, editor, <em>EUROCRYPT 2008</em>, volume 4965 of <em>LNCS</em>, pages 146â€“162. Springer, Heidelberg, April 2008. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;[LR06] Gregor Leander and Andy Rupp. On the equivalence of RSA and factoring regarding generic ring algorithms. In Xuejia Lai and Kefei Chen, editors, <em>ASIACRYPT 2006</em>, volume 4284 of <em>LNCS</em>, pages 241â€“251. Springer, Heidelberg, December 2006. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-7&quot;&gt;&lt;/span&gt;[LRSW99] Anna Lysyanskaya, Ronald L. Rivest, Amit Sahai, and Stefan Wolf. Pseudonym systems. In Howard M. Heys and Carlisle M. Adams, editors, <em>SAC 1999</em>, volume 1758 of <em>LNCS</em>, pages 184â€“199. Springer, Heidelberg, August 1999. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-3-0">4,</a> <a href="#page-10-3">11.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;[Mau05] Ueli M. Maurer. Abstract models of computation in cryptography (invited paper). In Nigel P. Smart, editor, <em>10th IMA International Conference on Cryptography and Coding</em>, volume 3796 of <em>LNCS</em>, pages 1â€“12. Springer, Heidelberg, December 2005. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-4-0">5,</a> <a href="#page-5-0">6,</a> <a href="#page-7-0">8.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-8&quot;&gt;&lt;/span&gt;[MRV16] Paz Morillo, Carla RÃ fols, and Jorge Luis Villar. The kernel matrix Diffie-Hellman assumption. In Jung Hee Cheon and Tsuyoshi Takagi, editors, <em>ASIACRYPT 2016, Part I</em>, volume 10031 of <em>LNCS</em>, pages 729â€“758. Springer, Heidelberg, December 2016. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;[MW98] Ueli M. Maurer and Stefan Wolf. Lower bounds on generic algorithms in groups. In Kaisa Nyberg, editor, <em>EUROCRYPT'98</em>, volume 1403 of <em>LNCS</em>, pages 72â€“84. Springer, Heidelberg, May / June 1998. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-10&quot;&gt;&lt;/span&gt;[MW99] Ueli Maurer and Stefan Wolf. The relationship between breaking the diffiehellman protocol and computing discrete logarithms. <em>SIAM Journal on Computing</em>, 28(5):1689â€“1721, 1999. (Cited on page <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;[Nec94] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. <em>Mathematical Notes</em>, 55(2):165â€“172, 1994. (Cited on page <a href="#page-0-0">1.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-4&quot;&gt;&lt;/span&gt;[Pol78] J. M. Pollard. Monte Carlo methods for index computation mod <em>p</em>. <em>Mathematics of Computation</em>, 32:918â€“924, 1978. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-6&quot;&gt;&lt;/span&gt;[PV05] Pascal Paillier and Damien Vergnaud. Discrete-log-based signatures may not be equivalent to discrete log. In Bimal K. Roy, editor, <em>ASIACRYPT 2005</em>, volume 3788 of <em>LNCS</em>, pages 1â€“20. Springer, Heidelberg, December 2005. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-5&quot;&gt;&lt;/span&gt;[Riv04] Ronald L. Rivest. On the notion of pseudo-free groups. In Moni Naor, editor, <em>TCC 2004</em>, volume 2951 of <em>LNCS</em>, pages 505â€“521. Springer, Heidelberg, February 2004. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-9&quot;&gt;&lt;/span&gt;[RLB+08] Andy Rupp, Gregor Leander, Endre Bangerter, Alexander W. Dent, and Ahmad-Reza Sadeghi. Sufficient conditions for intractability over black-box groups: Generic lower bounds for generalized DL and DH problems. In Josef Pieprzyk, editor, <em>ASIACRYPT 2008</em>, volume 5350 of <em>LNCS</em>, pages 489â€“505. Springer, Heidelberg, December 2008. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, <em>EUROCRYPT'97</em>, volume 1233 of <em>LNCS</em>, pages 256â€“266. Springer, Heidelberg, May 1997. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-4-0">5,</a> <a href="#page-5-0">6,</a> <a href="#page-7-0">8.</a>)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-11&quot;&gt;&lt;/span&gt;[Sho04] Victor Shoup. Sequences of games: a tool for taming complexity in security proofs. Cryptology ePrint Archive, Report 2004/332, 2004. <a href="http://eprint.iacr.org/2004/332">http://eprint.iacr.org/</a> <a href="http://eprint.iacr.org/2004/332">2004/332</a>. (Cited on page <a href="#page-28-2">29.</a>)</p></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-28-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;[SS01] Ahmad-Reza Sadeghi and Michael Steiner. Assumptions related to discrete logarithms: Why subtleties make a real difference. In Birgit Pfitzmann, editor, <em>EUROCRYPT 2001</em>, volume 2045 of <em>LNCS</em>, pages 244â€“261. Springer, Heidelberg, May 2001. (Cited on page 5.)</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">A Deferred Proofs</h3>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;A.1 Proof of Theorem 3.3</h3>

    <p class="text-gray-300"><em>Proof.</em> We prove that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-3&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{cdh}} \\ge \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{sdh}} - q \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\cdot\\mathbf{dh}}.</span>$
(20)</p>

    <p class="text-gray-300">Applying Theorem 3.1 yields the theorem. We now prove (20) via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} := \\mathbf{sdh}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is an algebraic adversary, it returns a vector  <span class="math">\\vec{a}</span>  along with  <span class="math">\\mathbf{Z}</span>  at the end of the game such that  <span class="math">\\mathbf{Z} = g^{a_1}\\mathbf{X}^{a_2}\\mathbf{Y}^{a_3}</span> . Furthermore, for any query asked to  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span> , it includes vectors  <span class="math">\\vec{b},\\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}\\mathbf{X}^{b_2}\\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1}\\mathbf{X}^{c_2}\\mathbf{Y}^{c_3}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figure 21.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|c|}\\hline \\mathbf{G_0}, \\overline{\\mathbf{G_1}} &amp; \\underline{\\mathbf{O}}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}): \\\\ \\hline \\text{00 } x, y &amp; \\mathbb{Z}_p \\\\ \\hline \\text{01 } (\\mathbf{X}, \\mathbf{Y}) := (g^x, g^y) \\\\ \\hline \\text{02 } [\\mathbf{Z}]_{\\vec{a}} &amp; \\stackrel{\\</span>}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}(\\cdot, \\cdot)}(\\mathbf{X}, \\mathbf{Y}) \\ \\hline \\text{03 } \\text{Return } \\mathbf{Z} = g^{xy} \\ \\end{array} \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c$$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-4&quot;&gt;&lt;/span&gt;Figure 21: Games  <span class="math">G_0</span>  and  <span class="math">G_1</span> . The boxed statements are only executed in  <span class="math">G_1</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : For game  <span class="math">\\mathbf{G_1}</span>  we alter the way that the oracle  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  answers queries. Namely, if  <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span> , it always returns 0. Game  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 21. The check performed by the oracle in  <span class="math">\\mathbf{G_1}</span>  amounts to checking whether  <span class="math">\\mathbf{Z}&#x27; = \\mathbf{X}^{b_1}</span> , since if  <span class="math">b_2 = b_3 = 0</span>  then  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}</span> . Using this property of  <span class="math">\\mathbf{G_1}</span> , we show an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  such that  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathsf{cdh}} = \\Pr[\\mathbf{G_1} = 1]</span> .  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  is depicted in Figure 22.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|} \\hline \\textbf{B}_{\\mathsf{alg}}(\\mathbf{X} = g^x, \\mathbf{Y} = g^y) &amp; \\underline{\\mathbf{O}}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}): \\\\ \\hline \\textbf{00} &amp; [\\mathbf{Z}]_{\\vec{a}} \\overset{\\</span>}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}}(\\cdot, \\cdot)(\\mathbf{X}, \\mathbf{Y}) \\ \\hline \\textbf{01} &amp; \\mathrm{Return} \\ \\mathbf{Z} &amp; \\mathrm{03} \\quad \\mathrm{Return} \\ \\mathbf{0} \\ \\hline \\textbf{04} &amp; \\mathrm{Return} \\ \\mathbf{Z}' = \\mathbf{X}^{b_1} \\ \\hline \\end{array}$$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-5&quot;&gt;&lt;/span&gt;Figure 22: Behavior of adversary Balg.</p>

    <p class="text-gray-300">We now show the existence of adversary  <span class="math">C_{alg}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\left|\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - \\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}\\right| \\leq q \\cdot \\mathbf{Adv}^{\\mathbf{lcdh}}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}.</span>$</p>

    <p class="text-gray-300">Let F denote the event that  <span class="math">\\mathbf{Z}&#x27; = (\\mathbf{Y}&#x27;)^x \\wedge (b_2 \\neq 0 \\vee b_3 \\neq 0)</span>  in at least one call to the oracle. Clearly, as long as F does not occur, the games behave identically. By the difference lemma [Sho04], we obtain</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathbf{G_0} = 1] - \\Pr[\\mathbf{G_1} = 1]| \\le \\Pr[F].</span>$</p>

    <p class="text-gray-300">We show the existence of  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] \\leq q \\cdot \\mathbf{Adv^{lc\\text{-}dh}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}}</span>$</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">C_{alg}(\\mathbf{X} = g^x, \\mathbf{Y} = g^y)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{O}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}):</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\circ\\circ Q} := \\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os If <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">[\\mathbf{Z}]_{\\vec{a}} \\overset{\\</span>}{\\leftarrow} A_{alg}^{O(\\cdot,\\cdot)}(\\mathbf{X},\\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 If <span class="math">b_2 \\neq 0 \\land b_3 \\neq 0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\tilde{\\mathbf{Z}} \\overset{\\</span>}{\\leftarrow} Q$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Q := Q \\cup \\{\\mathbf{Z}&#x27;\\}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Obtain <span class="math">b_1, b_2, b_3</span> as described</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">o4 Return <span class="math">(\\widetilde{\\mathbf{Z}}X^{-b_1},b_2,b_3,0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">og Return <span class="math">(\\mathbf{Z}&#x27; = \\mathbf{X}^{b_1})</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-29-1&quot;&gt;&lt;/span&gt;Figure 23: Behavior of adversary  <span class="math">C_{\\mathsf{alg}}</span> .</p>

    <p class="text-gray-300"><span class="math">C_{alg}</span>  is depicted in Figure 23.</p>

    <p class="text-gray-300">We now analyze  <span class="math">C_{alg}</span> . Clearly,  <span class="math">E_{alg}</span>  runs in the same time as  <span class="math">A_{alg}</span> . Once  <span class="math">A_{alg}</span>  halts,  <span class="math">C_{alg}</span>  picks at random  <span class="math">\\hat{\\mathbf{Z}}</span>  that was input by  <span class="math">A_{\\mathsf{alg}}</span>  as one of at most q queries to  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  along with  <span class="math">\\hat{\\mathbf{Y}}</span>  and  <span class="math">\\hat{b},\\hat{c}</span> such that  <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span> , and</p>

    <p class="text-gray-300">$$\\tilde{\\mathbf{Y}} = g^{b_1} \\mathbf{X}^{b_2} \\mathbf{Y}^{b_3},
\\tilde{\\mathbf{Z}} = g^{c_1} \\mathbf{X}^{c_2} \\mathbf{Y}^{c_3}.$$</p>

    <p class="text-gray-300">Clearly, if  <span class="math">(\\tilde{\\mathbf{Y}})^x = \\tilde{\\mathbf{Z}}</span>  then  <span class="math">(\\tilde{\\mathbf{Z}}\\mathbf{X}^{-b_1}, b_2, b_3, 0)</span>  yields a winning solution for  <span class="math">\\mathbf{lc}\\text{-}\\mathbf{dh}_G^{\\mathsf{C}_{\\mathsf{alg}}}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\tilde{\\mathbf{Z}}\\mathbf{X}^{-b_1} = (\\tilde{\\mathbf{Y}})^x \\mathbf{X}^{-b_1} = g^{b_2 x^2 + b_3 xy}.</span>$</p>

    <p class="text-gray-300">As  <span class="math">C_{alg}</span>  picks  <span class="math">\\tilde{\\mathbf{Z}}</span>  at random from at most q elements in Q, it picks a correct solution with probability at least  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\text{-}\\mathbf{dh}} \\geq \\frac{\\Pr[F]}{q}</span> . This yields  <span class="math">\\Pr[F] \\leq q \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\text{-}\\mathbf{dh}}</span> ). Thus, we now have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}^{\\mathbf{cdh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} &amp;= &amp; \\Pr[\\mathbf{G_1} = 1] \\\\ &amp;\\geq &amp; \\Pr[\\mathbf{G_0} = 1] - |\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - \\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}| \\\\ &amp;\\geq &amp; \\mathbf{Adv}^{\\mathbf{sdh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - q \\cdot \\mathbf{Adv}^{\\mathbf{lc\\text{-}dh}}_{\\mathcal{G},\\mathsf{Calg}}. \\end{split}</span>$</p>

    <p class="text-gray-300">It is straight forward to see that all the steps performed in the above simulations are generic. This proves (20).</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;Proof of Theorem 4.1 A.2</h4>

    <p class="text-gray-300"><em>Proof.</em> We prove the statement via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} := \\mathbf{lrsw}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figures 24. As  <span class="math">A_{alg}</span>  is an algebraic adversary, at the end of the game, it outputs a winning tuple  <span class="math">(m^*, \\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*)</span>  along with vectors  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  that provide the representation of  <span class="math">\\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*</span>  relative to  <span class="math">g, \\mathbf{X}, \\mathbf{Y}</span>  and the answers  <span class="math">\\mathbf{A}_1, ..., \\mathbf{A}_q, \\mathbf{B}_1, ..., \\mathbf{B}_q, \\mathbf{C}_1, ..., \\mathbf{C}_q</span>  from previous oracle queries, where  <span class="math">\\mathbf{A}_{i} = g^{r_{i}}, \\ \\mathbf{B}_{i} = g^{r_{i}y}, \\ \\text{and} \\ \\mathbf{C}_{i} = g^{r_{i}(yxm_{i}+x)}.</span></p>

    <p class="text-gray-300">Concretely, the representations of  <span class="math">A^*</span> ,  <span class="math">B^*</span> , and  <span class="math">C^*</span>  are as follows:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-29-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\mathbf{A}^{*} = \\prod_{i=1}^{q} \\mathbf{A}_{i}^{a_{i}} g^{a_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{a_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{a_{i}} \\mathbf{X}^{a_{3q+2}} \\mathbf{Y}^{a_{3q+3}},</span>$
(21)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{B}^{*} = \\prod_{i=1}^{q} \\mathbf{A}_{i}^{b_{i}} g^{b_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{b_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{b_{i}} \\mathbf{X}^{b_{3q+2}} \\mathbf{Y}^{b_{3q+3}},</span>$
(22)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^{*} = \\prod_{i=1}^{q} \\mathbf{C}_{i}^{c_{i}} \\mathbf{X}^{c_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{A}_{i-q-1}^{c_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{B}_{i-2q-1}^{c_{i}} g^{c_{3q+2}} \\mathbf{Y}^{c_{3q+3}}.</span>$
(23)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{B}^* = \\prod_{i=1}^{q} \\mathbf{A}_i^{b_i} g^{b_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{b_i} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{b_i} \\mathbf{X}^{b_{3q+2}} \\mathbf{Y}^{b_{3q+3}},</span>$
(22)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^* = \\prod_{i=1}^{q} \\mathbf{C}_i^{c_i} \\mathbf{X}^{c_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{A}_{i-q-1}^{c_i} \\prod_{i=2q+2}^{3q+1} \\mathbf{B}_{i-2q-1}^{c_i} g^{c_{3q+2}} \\mathbf{Y}^{c_{3q+3}}.</span>$
(23)</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|c} \\mathbf{G_{0}}, \\boxed{\\mathbf{G_{1}}} \\\\ \\hline 00 &amp; \\ell^{*}, k^{*}, i^{*} \\overset{\\</span>}{\\leftarrow} {1, ..., q} \\ \\hline 01 &amp; \\mathbf{If } k^{<em>} = \\ell^{</em>} \\vee k^{<em>} = i^{</em>} \\vee \\ell^{<em>} = i^{</em>} \\ \\hline 02 &amp; \\mathbf{Abort} \\ \\hline 03 &amp; Q := \\emptyset \\ \\hline 04 &amp; x, y \\overset{$}{\\leftarrow} \\mathbb{Z}<em>{p} \\ \\hline 05 &amp; \\mathbf{X} := g^{x}, \\mathbf{Y} := g^{y} \\ \\hline 06 &amp; (m^{*}, [\\mathbf{A}^{*}]</em>{\\vec{a}}, [\\mathbf{B}^{<em>}]_{\\vec{b}}, [\\mathbf{C}^{</em>}]<em>{\\vec{c}}) \\overset{$}{\\leftarrow} \\mathbf{A}</em>{\\mathsf{alg}}^{\\mathsf{O}(\\cdot)}(\\mathbf{X}, \\mathbf{Y}) \\ \\hline 07 &amp; \\mathbf{Return } m^{<em>} \\notin Q \\wedge m^{</em>} \\neq 0 \\ &amp; \\wedge \\mathbf{A}^{<em>} \\neq 1 \\wedge \\mathbf{B}^{</em>} = (\\mathbf{A}^{<em>})^{y} \\wedge \\mathbf{C}^{</em>} = (\\mathbf{A}^{<em>})^{xm^{</em>}y + x} \\ \\hline \\end{array}$$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;Figure 24: Games  <span class="math">G_0</span>  and  <span class="math">G_1</span>  with algebraic adversary  <span class="math">A_{alg}</span> . The boxed statements are only executed in  <span class="math">G_1</span> .</p>

    <p class="text-gray-300">We assume that  <span class="math">A_{alg}</span>  never queries the oracle on the same message  <span class="math">m_i</span>  more than once. (Multiple queries can be simulated by rerandomization.)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : In  <span class="math">\\mathbf{G_1}</span>  we consider a slightly altered game that is defined as follows. Before the first query is asked, the challenger in  <span class="math">\\mathbf{G_1}</span>  also chooses values  <span class="math">k^*, \\ell^*, i^* \\overset{\\</span>}{\\leftarrow} {1, ..., q}$ . If  <span class="math">k^* = \\ell^* \\vee k^* = i^* \\vee \\ell^* = i^*</span> , it aborts the game.  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 24. Clearly,  <span class="math">\\left(1-\\frac{3}{q}\\right)\\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G_0}} = \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G_1}}</span> . By defining  <span class="math">s_1, s_2, t_1, t_2, u_1, u_2, v_1, v_2 \\in \\mathbb{Z}_p</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} s_1 &amp;\\coloneqq a_{3q+2} + \\sum_{i=2q+3}^{3q+2} a_i r_{i-2q-2}, &amp; s_2 &amp;\\coloneqq c_{q+1} + \\sum_{i=1}^q c_i r_i, \\\\ t_1 &amp;\\coloneqq \\sum_{i=2q+3}^{3q+2} a_i m_i r_{i-2q-2}, &amp; t_2 &amp;\\coloneqq \\sum_{i=1}^q c_i m_i r_i, \\\\ u_1 &amp;\\coloneqq a_{3q+3} + \\sum_{i=q+2}^{2q+1} a_i r_{i-q-1}, &amp; u_2 &amp;\\coloneqq c_{3q+3} + \\sum_{i=2q+2}^{3q+1} c_i r_{i-q-1}, \\\\ v_1 &amp;\\coloneqq g^{a_{q+1}} + \\sum_{i=1}^q a_i r_i, &amp; v_2 &amp;\\coloneqq g^{c_{3q+2}} + \\sum_{i=q+2}^{2q+1} c_i r_{i-q-1}, \\end{split}</span>$</p>

    <p class="text-gray-300">equations (21) and (23) can be further simplified to</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{rcl} \\mathbf{A}^* &amp; = &amp; g^{s_1x + t_1xy + u_1y + v_1} \\\\ \\mathbf{C}^* &amp; = &amp; g^{s_2x + t_2xy + u_2y + v_2} \\end{array}</span>$</p>

    <p class="text-gray-300">We also define the parameters  <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span>  as</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\Delta := m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1, \\tag{24}</span>$</p>

    <p class="text-gray-300">$$\\Delta := m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1,
\\Delta' := u_1 m^* y^2 + m^* y v_1 + u_1 y - t_2 y - s_2 + v_1,$$
(24)</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; := u_2 y + v_2, \\tag{26}</span>$</p>

    <p class="text-gray-300">and the boolean variable  <span class="math">F^*</span>  as</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-2&quot;&gt;&lt;/span&gt;
<span class="math">$F^* = 1 \\Leftrightarrow s_1 \\equiv_p t_1 \\equiv_p u_1 \\equiv_p u_2 \\equiv_p 0. \\tag{27}</span>$</p>

    <p class="text-gray-300">We prove the following lemma that allows us to rewrite  <span class="math">A^*</span>  and  <span class="math">C^*</span>  in a more convenient form.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;<strong>Lemma A.1</strong> <em>If F</em> &lt;sup&gt;âˆ—&lt;/sup&gt; = 1<em>, then</em></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = \\prod_{i=1}^q \\mathbf{A}_i^{\\varepsilon_i}, \\quad \\mathbf{C}^* = \\prod_{i=1}^q \\mathbf{C}_i^{\\delta_i}</span>$</p>

    <p class="text-gray-300"><em>holds for</em></p>

    <p class="text-gray-300"><span class="math">$\\delta_i := \\begin{cases} c_i &amp; i \\notin \\{k^*, \\ell^*\\} \\\\ c_{\\ell^*} - \\frac{r_{k^*} m_{k^*} c_{q+1}}{(r_{\\ell^*} m_{\\ell^*})(r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}})} &amp; i = \\ell^* \\\\ c_{k^*} + \\frac{c_{q+1}}{r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}}} &amp; i = k^* \\end{cases}</span>$</p>

    <p class="text-gray-300"><em>and</em></p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_i := \\begin{cases} a_i &amp; i \\neq k^* \\\\ a_{k^*} + \\frac{a_{q+1}}{r_{k^*}} &amp; i = k^* \\end{cases}.</span>$</p>

    <p class="text-gray-300">Using Lemma <a href="#page-31-0">A.1,</a> we can now formulate the following conditions whenever <strong>G&lt;sup&gt;1&lt;/sup&gt;</strong> does not abort. To further simplify the notation, we define the following Boolean variables:</p>

    <p class="text-gray-300"><span class="math">$G^* = 1 \\Leftrightarrow \\Delta \\not\\equiv_p 0 \\lor \\Delta&#x27; \\not\\equiv_p 0 \\lor \\Delta&#x27;&#x27; \\not\\equiv_p 0</span>$</p>

    <p class="text-gray-300"><span class="math">$H^* := 1 \\Leftrightarrow \\forall j \\not\\in \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">Note that <em>H</em>&lt;sup&gt;âˆ—&lt;/sup&gt; is only well defined (by Lemma <a href="#page-31-0">A.1)</a> if <em>F</em> &lt;sup&gt;âˆ—&lt;/sup&gt; = 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Condition <em>F</em>&lt;sup&gt;1&lt;/sup&gt; : This condition holds iff <em>G</em>&lt;sup&gt;âˆ—&lt;/sup&gt; <em>.</em></li>
      <li>Condition <em>F</em>&lt;sup&gt;2&lt;/sup&gt; : This condition holds iff (Â¬<em>G</em>&lt;sup&gt;âˆ—&lt;/sup&gt; âˆ§ Â¬<em>F</em> âˆ— ) âˆ¨ (<em>F</em> &lt;sup&gt;âˆ—&lt;/sup&gt; âˆ§ <em>H</em>&lt;sup&gt;âˆ—&lt;/sup&gt; )<em>.</em></li>
      <li>Condition <em>F</em>&lt;sup&gt;3&lt;/sup&gt; : This condition holds iff <em>F</em> &lt;sup&gt;âˆ—&lt;/sup&gt; âˆ§ Â¬<em>H</em>&lt;sup&gt;âˆ—&lt;/sup&gt; <em>.</em></li>
    </ul>

    <p class="text-gray-300">It is easy to see that <em>F</em>&lt;sup&gt;1&lt;/sup&gt; âˆ¨ <em>F</em>&lt;sup&gt;2&lt;/sup&gt; âˆ¨ <em>F</em>&lt;sup&gt;3&lt;/sup&gt; = 1<em>.</em> We will now describe the behavior of adversaries Calg<em>,</em> Dalg<em>,</em> Ealg playing in the discrete logarithm game. Each of these adversaries simulates <strong>G&lt;sup&gt;1&lt;/sup&gt;</strong> to Aalg in a different way. Concretely, we prove the following Lemma.</p>

    <p class="text-gray-300"><strong>Lemma A.2</strong> <em>There exist</em> Calg<em>,</em> Dalg<em>,</em> Ealg <em>playing in the discrete logarithm game such that:</em></p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-1&quot;&gt;&lt;/span&gt;
<span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{C}_{\\mathsf{alg}}} = 1\\right] = \\Pr\\left[\\mathbf{G_1} = 1 \\mid F_1\\right] \\tag{28}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{D}_{\\mathsf{alg}}} = 1\\right] \\geq (1 - \\frac{2}{q})\\Pr\\left[\\mathbf{G_1} = 1 \\mid F_2\\right]</span>$
(29)</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{E}_{\\mathsf{alg}}} = 1\\right] \\geq \\frac{1}{q}\\Pr[\\mathbf{G}_1 = 1 \\mid F_3]. \\tag{30}</span>$</p>

    <p class="text-gray-300"><em>of Lemma <a href="#page-31-0">A.1.</a></em> We first note that <em>Î´&lt;sup&gt;l&lt;/sup&gt;</em> &lt;sup&gt;âˆ—&lt;/sup&gt; <em>, Î´&lt;sup&gt;k&lt;/sup&gt;</em> &lt;sup&gt;âˆ—&lt;/sup&gt; are well defined, because *<code>* &lt;sup&gt;âˆ—&lt;/sup&gt; =6 *k* &lt;sup&gt;âˆ—&lt;/sup&gt; and thus *m</code>* &lt;sup&gt;âˆ—&lt;/sup&gt; 6= <em>m&lt;sup&gt;k&lt;/sup&gt;</em> âˆ— . Otherwise <strong>G&lt;sup&gt;1&lt;/sup&gt;</strong> aborts and there is nothing to prove (since nothing is returned by Aalg in this case). Observe that since <em>F</em> &lt;sup&gt;âˆ—&lt;/sup&gt; = 1 â‡” <em>s</em>&lt;sup&gt;1&lt;/sup&gt; â‰¡<em>&lt;sup&gt;p&lt;/sup&gt; t</em>&lt;sup&gt;1&lt;/sup&gt; â‰¡<em>&lt;sup&gt;p&lt;/sup&gt; u</em>&lt;sup&gt;1&lt;/sup&gt; â‰¡<em>&lt;sup&gt;p&lt;/sup&gt; u</em>&lt;sup&gt;2&lt;/sup&gt; â‰¡<em>&lt;sup&gt;p&lt;/sup&gt; v</em>&lt;sup&gt;2&lt;/sup&gt; â‰¡<em>&lt;sup&gt;p&lt;/sup&gt;</em> 0<em>,</em> we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = g^{a_{q+1}} \\prod_{i=1}^q \\mathbf{A}_i^{a_i} \\quad \\text{and} \\quad \\mathbf{C}^* = \\mathbf{X}^{c_{q+1}} \\prod_{i=1}^q \\mathbf{C}_i^{c_i}.</span>$</p>

    <p class="text-gray-300">Now, the choices of <em>Î´</em>1<em>, ..., Î´q,</em> 1<em>, ..., &lt;sup&gt;q&lt;/sup&gt;</em> satisfy</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = \\prod_{i=1}^q \\mathbf{A}_i^{\\epsilon_i}</span>$
and  <span class="math">\\mathbf{C}^* = \\prod_{i=1}^q \\mathbf{C}_i^{\\delta_i}</span> .</p>

    <p class="text-gray-300">To see this, first observe that X can be written as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X} = \\left(\\mathbf{X}^{r_{k}*(1-m_{k}*/m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\left(g^{r_{k}*(x+yxm_{k}*)}g^{-r_{\\ell}*(x+yxm_{\\ell}*)(r_{k}*m_{k}*)/(r_{\\ell}*m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\left(\\mathbf{C}_{k}^{*}\\mathbf{C}_{\\ell^{*}}^{-(r_{k}*m_{k}*)/(r_{\\ell}*m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}.</span>$</p>

    <p class="text-gray-300">Because of this, setting</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\delta_{k^*} &amp;:= c_{k^*} + \\frac{c_{q+1}}{r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}}}, \\\\ \\delta_{\\ell^*} &amp;:= c_{\\ell^*} - \\frac{r_{k^*} m_{k^*} c_{q+1}}{(r_{\\ell^*} m_{\\ell^*}) (r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}})}, \\end{split}</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\delta_i := c_i</span>  for  <span class="math">i \\notin \\{\\ell^*, k^*\\}</span>  we obtain</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}^{c_{q+1}}\\mathbf{C}_{k^*}^{c_{k^*}}\\mathbf{C}_{\\ell^*}^{c_{\\ell^*}} = \\mathbf{C}_{k^*}^{c_{k^*}}\\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}\\left(\\mathbf{C}_{k^*}\\mathbf{C}_{\\ell^*}^{-(r_{k^*}m_{k^*})/(r_{\\ell^*}m_{\\ell^*})}\\right)^{\\frac{c_{q+1}}{r_{k^*}(1-m_{k^*}/m_{\\ell^*})}} = \\mathbf{C}_{k^*}^{\\delta_{k^*}}\\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}}.</span>$</p>

    <p class="text-gray-300">This means that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}^{c_{q+1}} \\prod_{i} \\mathbf{C}_{i}^{c_{i}} = (\\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^{*}}^{c_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{c_{\\ell^{*}}}) \\prod_{i \\neq k^{*} \\ell^{*}} \\mathbf{C}_{i}^{c_{i}} = \\mathbf{C}_{k^{*}}^{\\delta_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{\\delta_{\\ell^{*}}} \\prod_{i \\neq k^{*} \\ell^{*}} \\mathbf{C}_{i}^{\\delta_{i}} = \\prod_{i} \\mathbf{C}_{i}^{\\delta_{i}}.</span>$</p>

    <p class="text-gray-300">Also observe that  <span class="math">\\mathbf{A}_{k^*}^{\\epsilon_{k^*}} = \\mathbf{A}_{k^*}^{a_{k^*}} g^{a_{q+1}}</span>  and thus</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = g^{a_{q+1}} \\prod_i \\mathbf{A}_i^{a_i} = \\prod_i \\mathbf{A}_i^{\\epsilon_i}.</span>$</p>

    <p class="text-gray-300">Using Lemma A.2 and the fact that  <span class="math">F_1 \\vee F_2 \\vee F_3 = 1</span> , it is now straightforward to construct an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\Big[\\mathbf{dlog}^{\\mathsf{B}_{\\mathsf{alg}}} = 1\\Big] \\geq \\frac{1}{3q}\\Pr[\\mathbf{G_1} = 1]</span>$</p>

    <p class="text-gray-300">by letting  <span class="math">B_{alg}</span>  emulate one of the adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span> ,  <span class="math">E_{alg}</span>  (chosen uniformly at random).</p>

    <p class="text-gray-300">of Lemma A.2. Let  <span class="math">\\mathbf{Z}=g^z</span>  denote the discrete logarithm instance.  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}, \\mathsf{E}_{\\mathsf{alg}}</span>  simulate  <span class="math">\\mathbf{G_1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . They begin by sampling  <span class="math">k^*, \\ell^*, i^* \\overset{\\</span>}{\\leftarrow} {1, ..., q}$ . If  <span class="math">k^* = \\ell^* \\vee k^* = i^* \\vee \\ell^* = i^*</span> , they abort the simulation. Thus, assume throughout the proof that  <span class="math">k^* \\neq \\ell^*, k^* \\neq i^*, \\ell^* \\neq i^*</span></p>

    <p class="text-gray-300"><strong>Adversary</strong>  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span> . Adversary  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  samples  <span class="math">\\alpha \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (\\mathbf{Z}, g^{\\alpha})</span> . This implicitly sets x = z and  <span class="math">y = \\alpha</span> . Recall that</p>

    <p class="text-gray-300"><span class="math">$F_1 = 1 \\Leftrightarrow \\Delta \\not\\equiv_p 0 \\lor \\Delta&#x27; \\not\\equiv_p 0 \\lor \\Delta&#x27;&#x27; \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">We now analyze  <span class="math">C_{alg}</span> . Suppose  <span class="math">A_{alg}</span>  wins  <span class="math">G_1</span>  given that  <span class="math">F_1 = 1</span> . Then  <span class="math">C^* = (\\mathbf{A}^*)^{x+m^*xy}</span>  which is equivalent to</p>

    <p class="text-gray-300">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;
<span class="math">$x^2 \\Delta + x \\Delta&#x27; - \\Delta&#x27;&#x27; \\equiv_p 0 \\tag{31}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span>  are defined in (24)-(26). Quadratic equation (31) in indeterminate x has exactly two (possibly equal) solutions, say  <span class="math">x_1</span>  and  <span class="math">x_2</span> , that can be computed efficiently by  <span class="math">C_{alg}</span> . One of them has to be equal to z = x, which one can be tested by comparing  <span class="math">g^{x_i}</span>  to  <span class="math">\\mathbf{Z}</span> . This proves equation (28).</p>

    <pre><code class="language-text">\\begin{array}{ll}
</code></pre>

    <p class="text-gray-300">Figure 25: Behavior of adversary C&lt;sub&gt;alg&lt;/sub&gt;.</p>

    <pre><code class="language-text">\\begin{array}{ll} \\mathsf{D}_{\\mathsf{alg}}(\\mathbf{Z} = g^z) &amp; \\mathsf{O}(m_j) : \\ //For \\ query \\ j \\\\ \\mathsf{00} \\ \\ Q := \\emptyset &amp; \\mathsf{05} \\ \\ r_j \\overset{\\$}{\\sim} \\mathbb{Z}_p; \\\\ \\mathsf{01} \\ \\ \\alpha \\overset{\\$}{\\sim} \\mathbb{Z}_p &amp; \\mathsf{06} \\ \\ \\mathbf{A}_j := g^{r_j} \\\\ \\mathsf{02} \\ \\ (m^*, [\\mathbf{A}^*]_{\\vec{a}}, [\\mathbf{B}^*]_{\\vec{b}}, [\\mathbf{C}^*]_{\\vec{c}}) \\overset{\\$}{\\sim} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}(\\cdot)}(g^\\alpha, \\mathbf{Z}) \\\\ \\mathsf{03} \\ \\ \\mathsf{Compute} \\ \\ y \\ \\ \\mathsf{as} \\ \\ \\mathsf{described} \\ \\ \\mathsf{below} \\\\ \\mathsf{04} \\ \\ \\mathsf{Return} \\ \\ y &amp; \\mathsf{09} \\ \\ Q := \\mathbf{Q} \\cup \\{m_j\\} \\\\ \\mathsf{10} \\ \\ \\mathsf{Return} \\ \\ (\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{C}_j) \\end{array}
</code></pre>

    <p class="text-gray-300">Figure 26: Behaviour of Dalg.</p>

    <p class="text-gray-300">Adversary  <span class="math">D_{\\mathsf{alg}}</span> : Adversary  <span class="math">D_{\\mathsf{alg}}</span>  does the following. It samples  <span class="math">\\alpha \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, \\mathbf{Z})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and y = z. Recall that  <span class="math">F_2 = 1</span>  iff</p>

    <p class="text-gray-300"><span class="math">$\\neg F^* \\wedge \\neg (\\Delta \\not\\equiv_p 0 \\vee \\Delta&#x27; \\not\\equiv_p 0 \\vee \\Delta&#x27;&#x27; \\not\\equiv_p 0) \\vee F^* \\wedge \\forall j \\not\\in \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">where  <span class="math">F^*</span>  is defined in (27).</p>

    <p class="text-gray-300">We analyze and describe  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> . Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathsf{G}_1</span>  given that  <span class="math">F_2=1</span> . As before, we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^* = (\\mathbf{A}^*)^{x+m^*xy} \\Leftrightarrow x^2 \\Delta + x \\Delta&#x27; - \\Delta&#x27;&#x27; \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\Delta \\equiv_p \\Delta&#x27; \\equiv_p \\Delta&#x27;&#x27; \\equiv_p 0 \\land \\neg F^*</span>  then  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can efficiently solve one of the equations</p>

    <p class="text-gray-300"><span class="math">$\\Delta \\equiv_p 0,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27; \\equiv_p 0,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">in indeterminate y = z. This can be seen as follows.</p>

    <p class="text-gray-300">â€¢ If  <span class="math">s_1 \\not\\equiv_p 0 \\lor t_1 \\not\\equiv_p 0</span> , it can solve the quadratic equation</p>

    <p class="text-gray-300"><span class="math">$\\Delta \\equiv_p m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1 \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">because  <span class="math">m^* \\not\\equiv_p 0</span>  by assumption.</p>

    <p class="text-gray-300">â€¢ If  <span class="math">u_1 \\not\\equiv_p 0</span> , it can solve the quadratic equation</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27; \\equiv_p u_1 m^* y^2 + m^* y v_1 - t_2 y + u_1 y + v_1 - s_2 \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">where again we use the fact that  <span class="math">m^* \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">â€¢ If  <span class="math">v_2 \\not\\equiv_p 0</span> , then since</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; \\equiv_p v_2 + u_2 y \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">also  <span class="math">u_2 \\not\\equiv_p 0</span>  and so  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can solve for y the equation</p>

    <p class="text-gray-300"><span class="math">$v_2 + u_2 y \\equiv_p 0</span>$</p>

    <p class="text-gray-300">whenever  <span class="math">v_2 \\not\\equiv_p 0 \\lor u_2 \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">Given two possible solutions  <span class="math">y_1, y_2</span>  for a quadratic equation,  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can determine the correct one by comparing  <span class="math">g^{y_i}</span>  to  <span class="math">\\mathbf{Z}</span> .</p>

    <p class="text-gray-300">If  <span class="math">F^* = 1</span> , Lemma A.1 guarantees that  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can efficiently compute parameters  <span class="math">\\delta_1, ..., \\delta_q, \\varepsilon_1, ..., \\varepsilon_q</span>  such that  <span class="math">\\mathbf{A}^* = \\prod_i \\mathbf{A}_i^{\\varepsilon_i}, \\mathbf{C}^* = \\prod_i \\mathbf{C}_i^{\\delta_i}</span> . We distinguish two cases.</p>

    <p class="text-gray-300">â€¢ Case 1:  <span class="math">\\exists j \\notin \\{\\ell^*, k^*\\} : \\varepsilon_j \\not\\equiv_p 0 \\lor \\delta_j \\not\\equiv_p 0</span> . Without loss of generality, assume that  <span class="math">\\varepsilon_j \\not\\equiv_p 0</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\forall j \\notin \\{\\ell^*, k^*\\} : r_i \\varepsilon_j (1 + m^* y) - r_i \\delta_j (1 + y m_j) \\equiv_p 0, \\tag{32}</span>$</p>

    <p class="text-gray-300"><span class="math">D_{alg}</span>  solves the equation</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\frac{\\delta_j}{\\varepsilon_j} - 1 \\equiv_p y \\left( m^* - m_j \\frac{\\delta_j}{\\varepsilon_j} \\right)</span>$</p>

    <p class="text-gray-300">for y, which is obtained from rearranging terms in (32). This equation has a unique solution for y, and its coefficient can not become zero; this would imply that  <span class="math">m^* \\equiv_p m_j</span> , a contradiction.</p>

    <p class="text-gray-300">â€¢ Case 2:  <span class="math">\\forall j \\notin \\{\\ell^*, k^*\\} : \\varepsilon_j \\equiv_p \\delta_j \\equiv_p 0</span> . This means that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{A}^* &amp;= \\mathbf{A}_{\\ell^*}^{\\varepsilon_{\\ell^*}} \\mathbf{A}_{k^*}^{\\varepsilon_{k^*}} = g^{a_{q+1}} \\mathbf{A}_{k^*}^{a_{k^*}} \\mathbf{A}_{\\ell^*}^{a_{\\ell^*}}, \\\\ \\mathbf{C}^* &amp;= \\mathbf{C}_{k^*}^{\\delta_{k^*}} \\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}} = \\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^*}^{c_{k^*}} \\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}. \\end{split}</span>$</p>

    <p class="text-gray-300">If  <span class="math">a_{\\ell^*} \\equiv_p a_{k^*} \\equiv_p c_{k^*} \\equiv_p c_{\\ell^*} \\equiv_p 0</span> , then  <span class="math">\\mathbf{A}^* = g^{a_{q+1}}, \\mathbf{C}^* = \\mathbf{X}^{c_{q+1}}</span>  and therefore</p>

    <p class="text-gray-300"><span class="math">$c_{q+1} - a_{q+1} \\equiv_p ym^* a_{q+1}.</span>$</p>

    <p class="text-gray-300">Again, this equation has a unique solution for y and its coefficient can not become zero, because  <span class="math">a_{q+1} \\not\\equiv_p 0</span>  (recall that  <span class="math">\\mathbf{A}^* \\not\\equiv_p 1</span> ) and  <span class="math">m^* \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">Finally, we note that with probability at most  <span class="math">\\frac{2}{q-1}</span> ,  <span class="math">A_{\\mathsf{alg}}</span>  succeeds in setting</p>

    <p class="text-gray-300"><span class="math">$(a_{\\ell^*} \\not\\equiv_p 0 \\lor a_{k^*} \\not\\equiv_p 0 \\lor c_{k^*} \\not\\equiv_p 0 \\lor c_{\\ell^*} \\not\\equiv_p 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\land (\\forall j \\not\\in \\{\\ell^*, k^*\\} : \\varepsilon_j \\equiv_p a_j \\equiv_p c_j \\equiv_p \\delta_j \\equiv_p 0).</span>$</p>

    <p class="text-gray-300">This argument is true, because the indices  <span class="math">\\ell^*</span> ,  <span class="math">k^*</span>  are information theoretically hidden from  <span class="math">\\mathsf{A}&#x27;_{\\mathsf{alg}}s</span>  view and so it guesses either of them with probability at most  <span class="math">\\frac{2}{q-1}</span> . All in all,  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  succeeds in computing y with probability at least  <span class="math">1-\\frac{2}{q-1}</span> . This proves equation (29).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{c} \\overline{E_{alg}(\\mathbf{Z}=g^z)} \\\\ \\hline 00 \\ Q := \\emptyset \\\\ 01 \\ \\alpha, \\beta \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ 02 \\ (m^*, [\\mathbf{A}^*]</em>{\\vec{a}}, [\\mathbf{B}^<em>]_{\\vec{b}}, [\\mathbf{C}^</em>]<em>{\\vec{c}}) \\overset{$}{\\leftarrow} A</em>{alg}^{O(\\cdot)}(g^\\alpha, g^\\beta) \\ 03 \\ Compute \\ z \\ as \\ described \\ below \\ 04 \\ Return \\ z \\end{array}$</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\underline{O}(m_{j}): //For \\ query \\ j $ $ 05 \\ b := (j = i^{*}) $ $ 06 \\ r'<em>{j} \\stackrel{$}{\\leftarrow} \\mathbb{Z}</em>{p}; $ $ 07 \\ \\mathbf{A}<em>{j} := g^{z^{b}r'</em>{j}} $ $ 08 \\ \\mathbf{B}<em>{j} := g^{z^{b}\\beta r'</em>{j}} $ $ 09 \\ \\mathbf{C}<em>{j} := g^{z^{b}r'</em>{j}m_{j}\\beta\\alpha}g^{z^{b}\\alpha r'_{j}} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 <span class="math">Q := g \\cup \\{m_j\\}</span>&lt;br&gt;11 Return <span class="math">(\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{C}_j)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-35-0&quot;&gt;&lt;/span&gt;Figure 27: Behaviour of E&lt;sub&gt;alg&lt;/sub&gt;.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span> : To simulate  <span class="math">\\mathbf{G_1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> , the adversary  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  does the following. It samples  <span class="math">\\alpha, \\beta \\overset{\\hspace{0.1em}\\mathsf{\\scriptscriptstyle\\</span>}}{\\leftarrow} \\mathbb{Z}<em>p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, g^{\\beta})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and  <span class="math">y = \\beta</span> . It embeds z into the answer to the  <span class="math">i^*</span> th oracle query as shown in Figure 27. We now analyze  $\\mathsf{E}</em>{\\mathsf{alg}}$ . If  <span class="math">F_3 = 1</span> , then</p>

    <p class="text-gray-300"><span class="math">$F^* \\wedge \\exists j \\notin \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">Lemma A.1 guarantees that  <span class="math">E_{alg}</span>  can efficiently compute the parameters</p>

    <p class="text-gray-300"><span class="math">$\\delta_1, ..., \\delta_q, \\varepsilon_1, ..., \\varepsilon_q</span>$</p>

    <p class="text-gray-300">such that  <span class="math">\\mathbf{A}^* = \\prod_i \\mathbf{A}_i^{\\varepsilon_i}, \\mathbf{C}^* = \\prod_i \\mathbf{C}_i^{\\delta_i}</span> . By assumption</p>

    <p class="text-gray-300"><span class="math">$\\exists j \\notin \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">With probability  <span class="math">\\frac{1}{q}</span> ,  <span class="math">j = i^*</span> , because  <span class="math">i^*</span>  is information theoretically hidden from  <span class="math">A_{alg}</span>  and thus independent of its computation. This yields the equation</p>

    <p class="text-gray-300"><span class="math">$(\\prod_{i} g^{r_{i}\\varepsilon_{i}})^{x+m^{*}xy} = (\\prod_{i} \\mathbf{A}_{i}^{\\varepsilon_{i}})^{x+m^{*}xy} = (\\mathbf{A}^{*})^{(x+m^{*}xy)}</span>$
<span class="math">$= \\mathbf{C}^{*} = \\prod_{i} \\mathbf{C}_{i}^{\\delta_{i}} = \\prod_{i} g^{\\delta_{i}r_{i}(x+m_{i}yx)},</span>$</p>

    <p class="text-gray-300">which is equivalent to</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{i} r_{i} \\varepsilon_{i}\\right)(x + m^{*}xy) - \\sum_{i} r_{i} \\delta_{i}(x + m_{i}yx) \\equiv_{p} 0.</span>$</p>

    <p class="text-gray-300">Rearranging terms yields</p>

    <p class="text-gray-300"><span class="math">$z[r&#x27;_{i^*}\\varepsilon_{i^*}(1+m^*y)-r&#x27;_{i^*}\\delta_{i^*}(1+m_{i^*}y)] \\equiv_p \\sum_{i\\neq i^*} r_i\\delta_i(1+ym_i)-(\\sum_{i\\neq i^*} r_i\\varepsilon_i)(1+m^*y).</span>$</p>

    <p class="text-gray-300">By assumption, the coefficient of z in this expression is not zero. Therefore,  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  can efficiently solve the modular equation to obtain z. Putting things together, we obtain for the adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  emulating one of  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}, \\mathsf{E}_{\\mathsf{alg}}</span>  the following bound on the advantage  <span class="math">\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathsf{B}_{\\mathsf{alg}},\\mathcal{G}}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathsf{B}_{\\mathsf{alg}},\\mathcal{G}} \\geq \\frac{1}{3q}\\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}} = \\frac{q-3}{3q^2}\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}} \\geq \\frac{1}{6q}\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}},</span>$</p>

    <p class="text-gray-300">where the last inequality holds for  <span class="math">q \\geq 6</span> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;A.3 Proof of Theroem 5.2</h4>

    <p class="text-gray-300"><em>Proof.</em> First note that given an adversary  <span class="math">A_{alg}</span>  against  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G}}</span>  one can easily construct an adversary  <span class="math">B_{alg}</span>  against  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G}}</span> .  <span class="math">B_{alg}</span>  first calls  <span class="math">\\mathsf{Dec}(\\cdot)</span>  to compute the elements  <span class="math">(g^x,...,g^{x^q})</span> . When it is presented with a challenge  <span class="math">(\\mathbf{K}^*,\\mathbf{C}^*)</span> , it calls  <span class="math">A_{alg}</span>  on input  <span class="math">(g^x,...,g^{x^q},\\mathbf{C}^*,\\mathbf{K}^*)</span>  and then outputs  <span class="math">A_{alg}</span> 's output bit b'. Clearly,  <span class="math">(g^x,...,g^{x^q},\\mathbf{C}^*,\\mathbf{K}^*)</span>  is correctly distributed and therefore</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{q\\text{-}ddh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} = \\mathbf{Adv}^{\\mathbf{ind\\text{-}cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}, \\quad \\mathbf{Time}^{\\mathbf{q\\text{-}ddh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} = \\mathbf{Time}^{\\mathbf{ind\\text{-}cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}.</span>$</p>

    <p class="text-gray-300">For the converse, let  <span class="math">A_{alg}</span>  be an algebraic adversary playing in one of the games  <span class="math">ind\\text{-}cca1_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span>  ind- <span class="math">cca1_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span> . We construct an adversary  <span class="math">\\mathsf{B}_{alg}</span>  against  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}</span>  that interpolates between  <span class="math">ind\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span>  and  <span class="math">ind\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^{\\mathsf{A}_{alg}}</span>  by simulating one of these games to  <span class="math">\\mathsf{A}_{alg}</span> .  <span class="math">\\mathsf{B}_{alg}</span>  is depicted in Figure 28.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\frac{B_{alg}(g, (\\mathbf{X}<em>i)</em>{i=1}^q, \\mathbf{R}, \\mathbf{Z})}{00 \\ \\mathbf{X} := g^x} \\ 01 \\ b' \\overset{$}{\\leftarrow} A_{alg}^{Dec(\\cdot), Enc}(\\mathbf{X}) \\ 02 \\ Return \\ b' $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{\\text{Dec}([\\mathbf{C}]_{\\vec{c}})}{//\\text{Let this be the } i\\text{-th query}}</span> 03 Compute <span class="math">\\vec{a}</span> s.t. <span class="math">\\mathbf{C} = \\prod_{j=1}^{i} g^{a_j x^j}</span> 04 <span class="math">\\mathbf{K} := \\mathbf{C}^x = \\prod_{j=1}^{i} \\mathbf{X}_{j+1}^{a_j}</span> 05 Return <span class="math">\\mathbf{K}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{Enc()}{o6} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ </span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-36-1&quot;&gt;&lt;/span&gt;Figure 28: Adversary B&lt;sub&gt;alg&lt;/sub&gt; against <strong>q-ddh</strong>.</p>

    <p class="text-gray-300">Let  <span class="math">(g, \\mathbf{X}_1 = g^x, \\mathbf{X}_2 = g^{x^2}, \\dots, \\mathbf{X}_q = g^{x^q}, \\mathbf{R} = g^r, \\mathbf{Z} = g^{xr+zb})</span>  be the problem instance given to  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  in  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G},b}^{\\mathsf{B}_{\\mathsf{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is algebraic, along with its  <span class="math">i\\text{-}\\mathsf{th}</span>  query  <span class="math">\\mathbf{C}</span>  to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  it sends a vector  <span class="math">\\vec{c}</span>  such that  <span class="math">\\mathbf{C} = \\prod_i \\mathbf{L}_i^{c_i}</span>  where  <span class="math">\\vec{\\mathbf{L}}</span>  consists of group elements  <span class="math">g, \\mathbf{X}, \\mathbf{K}_1, \\dots, \\mathbf{K}_{i-1}</span> . Here,  <span class="math">\\mathbf{K}_1, \\dots, \\mathbf{K}_{i-1}</span>  denote the answers to the first i-1 queries asked to  <span class="math">\\mathsf{Dec}(\\cdot)</span> .</p>

    <p class="text-gray-300">Observe that given  <span class="math">\\vec{c}</span> ,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can express  <span class="math">\\mathbf{C}</span>  as  <span class="math">\\mathbf{C} = \\prod_{i \\geq j \\geq 0} g^{a_j x^j}</span> , for some known constants  <span class="math">a_j</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  asks at most q-1 such queries,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can answer them using the group elements  <span class="math">(g, g^x, g^{x^2}, ..., g^{x^q})</span>  from its instance. When  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  queries  <span class="math">\\mathsf{Enc}()</span> ,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  returns  <span class="math">(g^{xr+zb}, g^r)</span> . When  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  halts with output b',  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  returns b'. Clearly,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  perfectly simulates either  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},0}</span>  or  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . Finally,  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},b}</span>  returns 1 if and only if  <span class="math">\\mathsf{q}\\text{-}\\mathsf{ddh}^{\\mathsf{B}_{\\mathsf{alg}}}_{\\mathcal{G},b}</span>  returns 1. Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{q\\text{-}\\mathbf{ddh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Adv}^{ind\\text{-}\\mathbf{cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}, \\quad \\mathbf{Time}^{q\\text{-}\\mathbf{ddh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Time}^{ind\\text{-}\\mathbf{cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}.</span>$</p>

`;
---

<BaseLayout title="**The Algebraic Group Model and its Applications** (2017/620)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/620
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-algebraic-group-model-and-its-applications-2017" />
  </article>
</BaseLayout>
