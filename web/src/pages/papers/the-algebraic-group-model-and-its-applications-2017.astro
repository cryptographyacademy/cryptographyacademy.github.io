---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/620';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'The Algebraic Group Model and its Applications';
const AUTHORS_HTML = 'Georg Fuchsbauer, Eike Kiltz, Julian Loss';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">One of the most important tools for assessing hardness assumptions in cryptography is the Generic Group Model (GGM). Over the past two decades, numerous assumptions have been analyzed within this model. While a proof in the GGM can certainly provide some measure of confidence in an assumption, its scope is rather limited since it does not capture group-specific algorithms that make use of the representation of the group.

To overcome this limitation, we propose the Algebraic Group Model (AGM), a model that lies in between the standard model and the GGM. It is the first restricted model of computation covering group-specific algorithms yet allowing to derive simple and meaningful security statements.
We show that several important assumptions, among them the Computational Diffie-Hellman, the Strong Diffie-Hellman, and the interactive LRSW assumptions, are equivalent to the Discrete Logarithm (DLog) assumption in the AGM. On the more practical side, we prove tight security reductions for two important schemes in the AGM to DLog or a variant thereof: the BLS signature scheme and Groth&#x27;s zero-knowledge SNARK (Eurocrypt &#x27;16), which is the most efficient SNARK for which only a proof in the GGM was known.

Moreover, in combination with known lower bounds on the Discrete Logarithm assumption in the GGM, our results can be used to derive lower bounds for all the above-mentioned results in the GGM.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> discrete logarithm problem</p>
    </section>

    <p class="text-gray-300">ALGORITHMS. We denote by  <span class="math">s \\stackrel{\\</span>}{\\leftarrow} S$  the uniform sampling of the variable s from the (finite) set S. All our algorithms are probabilistic (unless stated otherwise) and written in uppercase letters A, B. To indicate that algorithm A runs on some inputs  <span class="math">(x_1, \\ldots, x_n)</span>  and returns y, we write  <span class="math">y \\stackrel{\\</span>}{\\leftarrow} A(x_1, \\ldots, x_n)$ . If A has access to an algorithm B (via oracle access) during its execution, we write  <span class="math">y \\stackrel{\\</span>}{\\leftarrow} A^B(x_1, \\ldots, x_n)$ .</p>

    <p class="text-gray-300">SECURITY GAMES. We use a variant of (code-based) security games [BR04]. In game  <span class="math">\\mathbf{G}_{par}</span>  (defined relative to a set of parameters par), an adversary A interacts with a challenger that answers oracle queries issued by A. It has a main procedure and (possibly zero) oracle procedures which describe how oracle queries are answered. We denote the output of a game  <span class="math">\\mathbf{G}_{par}</span>  between a challenger and an adversary A via  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span> . A is said to win if  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}} = 1</span> . We define the advantage of A in  <span class="math">\\mathbf{G}_{par}</span>  as  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}} := \\Pr\\left[\\mathbf{G}_{par}^{\\mathsf{A}} = 1\\right]</span>  and the running time of  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A}}</span>  as  <span class="math">\\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}</span> .</p>

    <p class="text-gray-300">SECURITY REDUCTIONS. Let  <span class="math">\\mathbf{G}, \\mathbf{H}</span>  be security games. We write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow} \\mathbf{G}_{par}</span>  if there exists an algorithm R (called  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for all algorithms A, algorithm B defined as  <span class="math">\\mathsf{B} := \\mathsf{R}^\\mathsf{A}</span>  satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}}^{\\mathbf{G}}.</span>$</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Algebraic Security Games and Algorithms</h3>

    <p class="text-gray-300">We consider algebraic security games  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  for which we set par to a fixed group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span> , where  <span class="math">\\mathbb{G}</span>  is a cyclic group of prime order p generated by g. In algebraic security games, we syntactically distinguish between elements of group  <span class="math">\\mathbb{G}</span>  (written in bold, uppercase letters, e.g.,  <span class="math">\\mathbf{A}</span> ) and all other elements, which must not depend on any group elements. As an example of an algebraic security game, consider the Computational Diffie-Hellman game  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}^{\\mathbf{A}}</span> , depicted in Figure 1 (left).</p>

    <p class="text-gray-300">We now define algebraic algorithms. Intuitively, the only way for an algebraic algorithm to output a new group element  <span class="math">\\mathbf{Z}</span>  is to derive it via group multiplications from known group elements.</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Algebraic algorithm) An algorithm  <span class="math">A_{alg}</span>  executed in an algebraic game  <span class="math">G_{\\mathcal{G}}</span>  is called <em>algebraic</em> if for all group elements  <span class="math">\\mathbf{Z}</span>  that  <span class="math">A_{alg}</span>  outputs (i.e., the elements in bold uppercase</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{cdh}}}\\nolimits_{\\mathcal{G}}^{A}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{cdh}}}_{\\mathcal{G}}^{A_{alg}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">(\\mathbf{X}, \\mathbf{Y}) := (g^x, g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\mathbf{X},\\mathbf{Y}):=(g^x,g^y)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\mathbf{Z} \\overset{\\</span>}{\\leftarrow} A(\\mathbf{X}, \\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">[\\mathbf{Z}]_{\\vec{z}} \\overset{\\</span>}{\\leftarrow} A_{alg}(\\mathbf{X},\\mathbf{Y})$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 1: <strong>Left:</strong> Algebraic game <strong>cdh</strong> relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and adversary A. All group elements are written in bold, uppercase letters. <strong>Right:</strong> Algebraic game <strong>cdh</strong> relative to group description  <span class="math">\\mathcal{G} = (\\mathbb{G}, g, p)</span>  and algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . The algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  additionally returns a representation  <span class="math">\\vec{z} = (a, b, c)</span>  of <strong>Z</strong> such that  <span class="math">\\mathbf{Z} = g^a \\mathbf{X}^b \\mathbf{Y}^c</span> .</p>

    <p class="text-gray-300">letters), it additionally provides the representation of  <span class="math">\\mathbf{Z}</span>  relative to all previously received group elements. That is, if  <span class="math">\\vec{\\mathbf{L}}</span>  is the list of group elements  <span class="math">\\mathbf{L}_0, \\dots, \\mathbf{L}_m \\in \\mathbb{G}</span>  that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  has received so far (w.l.o.g.  <span class="math">\\mathbf{L}_0 = g</span> ), then  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  must also provide a vector  <span class="math">\\vec{z}</span>  such that  <span class="math">\\mathbf{Z} = \\prod_i \\mathbf{L}_i^{z_i}</span> . We denote such an output as  <span class="math">[\\mathbf{Z}]_{\\vec{z}}</span> .</p>

    <p class="text-gray-300">REMARKS ON OUR MODEL. Algebraic algorithms were first considered in [BV98, PV05], where they are defined using an additional extractor algorithm which computes for an output group element a representation in basis  <span class="math">\\vec{\\mathbf{L}}</span> . We believe that our definition gives a simpler and cleaner definition of algebraic algorithms. If one assumes that the extractor algorithm has constant running time, then our definition is easily seen to be equivalent to theirs. Indeed, this view makes sense for algorithms in the GGM since the representation  <span class="math">\\vec{z}</span>  trivially follows from the description of the algorithm. However, if running the extractor algorithm imposes some additional cost, then this will clearly affect the running times of our reductions. If the cost of the extractor is similar to that of the solver adversary, then reductions in our model that neither call an algebraic solver multiple times nor receive from it a non-constant amount of group elements (along with their representations) will remain largely the same in both models.</p>

    <p class="text-gray-300">For the inputs to algebraic adversaries we syntactically distinguish group elements from other inputs and require that the latter not depend on any group elements. This is necessary to rule out pathological cases in which an algorithm receives &quot;disguised&quot; group elements and is forced to output an algebraic representation of them (which it might not know). To illustrate the issue, consider an efficient algorithm A, which on input  <span class="math">X&#x27; := \\mathbf{X} \\| \\bot \\text{ returns } \\mathbf{X}</span> , where  <span class="math">\\mathbf{X}</span>  is a group element, but X' is not. If A is algebraic then it must return a representation of  <span class="math">\\mathbf{X}</span>  in g (the only group element previously seen), which would be the discrete logarithm of  <span class="math">\\mathbf{X}</span> .</p>

    <p class="text-gray-300">Allowing inputs of form X' while requiring algorithms to be algebraic leads to contradictions. (E.g., one could use  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  to compute discrete logarithms: given a challenge  <span class="math">\\mathbf{X} = g^x</span> , run  <span class="math">[\\mathbf{X}]_x \\stackrel{\\</span>}{\\leftarrow} \\mathsf{A}<em>{\\mathsf{alg}}(\\mathbf{X}||\\bot)$  and return x.) We therefore demand that non-group-element inputs must not depend on group elements. (Note that if  $\\mathsf{A}</em>{\\mathsf{alg}}$ 's input contains  <span class="math">\\mathbf{X}</span>  explicitly then it can output  <span class="math">[\\mathbf{X}]_{(0,1)}</span>  with a valid representation of  <span class="math">\\mathbf{X}</span>  relative to  <span class="math">\\vec{\\mathbf{L}} = (g, \\mathbf{X})</span> .)</p>

    <p class="text-gray-300">Finally, we slightly abuse notation and let an algebraic algorithm also represent output group elements as combinations of previous <em>outputs</em>. This makes some of our proofs easier and is justified since all previous outputs must themselves have been given along with an according representation. Therefore, one can always recompute a representation that depends only on the initial inputs to the algebraic algorithm.</p>

    <p class="text-gray-300">INTEGRATING WITH RANDOM ORACLES IN THE AGM. As mentioned above, an algorithm A that samples (and outputs) a group element <strong>X</strong> obliviously, i.e., without knowing its representation, is not algebraic. This appears to be problematic if one wishes to combine the AGM with the Random Oracle Model [BR93]. However, group elements output by the random oracle are</p>

    <p class="text-gray-300">included by definition in the list  <span class="math">\\vec{\\mathbf{L}}</span> . This means that for any such element, a representation is trivially available to  <span class="math">A_{alg}</span> .</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Generic Security Games and Algorithms</h3>

    <p class="text-gray-300">Generic algorithms  <span class="math">A_{gen}</span>  are only allowed to use generic properties of group  <span class="math">\\mathcal{G}</span> . Informally, an algorithm is generic if it works regardless of what group it is run in. This is usually modeled by giving an algorithm indirect access to group elements via abstract handles. It is straight-forward to translate all of our algebraic games into games that are syntactically compatible with generic algorithms accessing group elements only via abstract handles.</p>

    <p class="text-gray-300">We say that winning algebraic game  <span class="math">G_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon, t)</span> -hard in the generic group model if for every generic algorithm  <span class="math">A_{\\mathsf{gen}}</span>  it holds that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}} \\leq t \\implies \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{gen}}}^{\\mathbf{G}} \\leq \\varepsilon.</span>$</p>

    <p class="text-gray-300">We remark that usually in the generic group model one considers group operations (i.e., oracle calls) instead of the running time. In our context it is more convenient to measure the running time instead, assuming every oracle call takes one unit time.</p>

    <p class="text-gray-300">As an important example, consider the algebraic Discrete Logarithm Game  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in Figure 2 which is  <span class="math">(t^2/p, t)</span> -hard in the generic group model [Sho97, Mau05].</p>

    <p class="text-gray-300">We assume that a generic algorithm  <span class="math">A_{gen}</span>  additionally provides the representation of  <span class="math">\\mathbf{Z}</span>  relative to all previously received group elements, for all group elements  <span class="math">\\mathbf{Z}</span>  that it outputs. This assumption is w.l.o.g. since a generic algorithm can only obtain new group elements by multiplying two known group elements; hence it always knows a valid representation. This way, every generic algorithm is also an algebraic algorithm.</p>

    <p class="text-gray-300">Furthermore, if  <span class="math">B_{gen}</span>  is a generic algorithm and  <span class="math">A_{alg}</span>  is an algebraic algorithm, then  <span class="math">B_{alg} := B_{gen}^{A_{alg}}</span>  is also is an algebraic algorithm. We refer to [Mau05] for more on generic algorithms.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Generic Reductions Between Algebraic Security Games</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  and  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  be two algebraic security games. We write  <span class="math">\\mathbf{H}_{\\mathcal{G}} \\overset{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow} \\mathsf{alg} \\mathbf{G}_{\\mathcal{G}}</span>  if there exists a generic algorithm  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  (called generic  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for every algebraic algorithm  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> , algorithm  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{gen}}</span>  satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span>$</p>

    <p class="text-gray-300">Note that we deliberately require reduction  <span class="math">R_{gen}</span>  to be generic. Hence, if  <span class="math">A_{alg}</span>  is algebraic, then  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is algebraic; if  <span class="math">A_{alg}</span>  is generic, then  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is generic. If one is only interested in algebraic adversaries, then it suffices to require reduction  <span class="math">R_{gen}</span>  to be algebraic. But in that case one can no longer infer that  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  is generic in case  <span class="math">A_{alg}</span>  is generic.</p>

    <p class="text-gray-300">Composing information-theoretic lower bounds with reductions in the AGM. The following lemma explains how statements in the AGM carry over to the GGM.</p>

    <p class="text-gray-300"><strong>Lemma 2.2</strong> Let  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  and  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  be algebraic security games such that  <span class="math">\\mathbf{H}_{\\mathcal{G}} \\stackrel{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{\\mathcal{G}}</span>  and winning  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon, t)</span> -hard in the GGM. Then,  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon \\cdot \\Delta_{\\varepsilon}, t/\\Delta_{t})</span> -hard in the GGM.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">A_{gen}</span>  be a generic algorithm playing in game  <span class="math">G_{\\mathcal{G}}</span> . Then by our premise there exists a generic algorithm  <span class="math">B_{alg} = R_{gen}^{A_{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span>$</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{dlog}}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\mathbf{lc}\\text{-}dh}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\mathbf{sq}\\text{-}\\mathbf{dh}}^{A}_{\\mathcal{G}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} \\coloneqq g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\mathbf{X},\\mathbf{Y}) \\coloneqq (g^x,g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} \\coloneqq g^x</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">z \\stackrel{\\</span>}{\\leftarrow} A(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oz <span class="math">(\\mathbf{Z}, u, v, w) \\stackrel{\\</span>}{\\leftarrow} A(\\mathbf{X}, \\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\mathbf{Z} \\overset{\\</span>}{\\leftarrow} A(\\mathbf{X})$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(z=x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{ux^2 + vxy + wy^2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(\\mathbf{Z} = g^{x^2})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\wedge \\ (u \\neq 0 \\lor v \\neq 0 \\lor w \\neq 0))</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 2: Discrete Logarithm Game <strong>dlog</strong>, Square Diffie-Hellman Game <strong>sq-dh</strong>, and Linear Combination Diffie-Hellman Game <strong>lc-dh</strong> relative to group  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|}\\hline \\mathbf{sq\\text{-}dh}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}} \\\\ \\hline \\mathbf{00} &amp; x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ \\mathtt{01} &amp; \\mathbf{X} := g^x \\ \\mathtt{02} &amp; [\\mathbf{Z}]</em>{(a,b)} \\overset{$}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}(\\mathbf{X}) \\ \\mathtt{03} &amp; \\mathrm{Return} &amp; (\\mathbf{Z} = g^{x^2}) \\end{array}$$</p>

    <p class="text-gray-300">Figure 3: Algebraic adversary  <span class="math">A_{alg}</span>  playing in  <span class="math">\\mathbf{sq}</span> - <span class="math">\\mathbf{dh}_{G}</span> .</p>

    <p class="text-gray-300">Assume  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}} \\leq t/\\Delta_t</span> ; then  <span class="math">\\mathbf{Time}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_t \\cdot \\mathbf{Time}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}} \\leq t</span> . Since winning  <span class="math">\\mathbf{H}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon,t)</span> -hard in the GGM, it follows that</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\geq \\mathbf{Adv}^{\\mathbf{H}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}^{\\mathbf{G}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}</span>$</p>

    <p class="text-gray-300">and thus  <span class="math">\\varepsilon \\cdot \\Delta_{\\varepsilon} \\geq \\mathbf{Adv}_{\\mathcal{G}, \\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span> , which proves that  <span class="math">\\mathbf{G}_{\\mathcal{G}}</span>  is  <span class="math">(\\varepsilon \\Delta_{\\varepsilon}, t/\\Delta_{t})</span> -hard in the GGM.</p>

    <p class="text-gray-300">In this section we consider some variants of the standard Diffie-Hellman assumption [DH76] and prove them to be equivalent to the discrete logarithm assumption (defined via algebraic game  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  of Figure 2) in the Algebraic Group Model.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Computational Diffie-Hellman</h3>

    <p class="text-gray-300">Consider the Square Diffie-Hellman Assumption [MW99] described in algebraic game  <span class="math">\\mathbf{sq}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span>  and the Linear Combination Diffie-Hellman Assumption described in algebraic game  <span class="math">\\mathbf{lc}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span>  (both in Figure 2), which will be convenient for the proof of Theorem 3.3.</p>

    <p class="text-gray-300">As a warm-up we now prove that the Discrete Logarithm assumption is tightly equivalent to the Diffie-Hellman, the Square Diffie-Hellman, and the Linear Combination Diffie-Hellman Assumption in the Algebraic Group Model. The equivalence of the Square Diffie-Hellman and Diffie-Hellman problems was previously proven in [MW99, BDZ03].</p>

    <p class="text-gray-300">
<span class="math">$\\textbf{Theorem 3.1 } \\textbf{dlog}_{\\mathcal{G}} \\overset{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\ \\left\\{ \\mathbf{cdh}_{\\mathcal{G}}, \\mathbf{sq\\text{-}dh}_{\\mathcal{G}} \\right\\} \\ \\textit{and} \\ \\mathbf{dlog}_{\\mathcal{G}} \\overset{(3,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\ \\mathbf{lc\\text{-}dh}_{\\mathcal{G}}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">A_{\\mathsf{alg}}</span>  be an algebraic adversary executed in game  <span class="math">\\mathbf{sq\\text{-}dh}_{\\mathcal{G}}</span> ; cf. Figure 3.</p>

    <p class="text-gray-300">As  <span class="math">A_{\\mathsf{alg}}</span>  is an algebraic adversary, it returns a solution  <span class="math">\\mathbf{Z}</span>  together with a representation  <span class="math">(a,b) \\in \\mathbb{Z}_p^2</span>  such that</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{Z} = g^{x^2} = g^a (g^x)^b. \\tag{1}</span>$</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\operatorname{\\underline{\\mathbf{sdh}}}^{A}_{\\mathcal{G}}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{O}(\\mathbf{Y}&#x27;,\\mathbf{Z}&#x27;)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ x, y \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(\\mathbf{Z}&#x27; = (\\mathbf{Y}&#x27;)^x)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">(\\mathbf{X},\\mathbf{Y}):=(g^x,g^y)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">o2 <span class="math">\\mathbf{Z} \\overset{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A^{O(\\cdot,\\cdot)}(\\mathbf{X},\\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return ( <span class="math">\\mathbf{Z} = g^{xy}</span> )</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 4: Strong Diffie-Hellman Game sdh relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now show how to construct a generic reduction  <span class="math">R_{gen}</span>  that calls  <span class="math">A_{alg}</span>  exactly once such that for  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Adv}^{\\mathbf{sq}\\text{-}\\mathbf{dh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}</span>$</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  works as follows. On input a discrete logarithm instance  <span class="math">\\mathbf{X}</span> , it runs  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  on  <span class="math">\\mathbf{X}</span> . Suppose  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is successful. Equation (1) is equivalent to the quadratic equation  <span class="math">x^2 - bx - a \\equiv_p 0</span>  with at most two solutions in x. (In general such equations are not guaranteed to have a solution but since the representation is valid and  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is assumed to be correct, there exists at least one solution for x.)  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  can test which one (out of the two) is the correct solution x by testing against  <span class="math">\\mathbf{X} = g^x</span> . Moreover, it is easy to see that  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  only performs generic group operations and is therefore generic. Hence,  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span>  is algebraic, which proves</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{dlog}_{\\mathcal{G}} \\overset{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{sq}\\text{-}\\mathbf{dh}_{\\mathcal{G}}.</span>$</p>

    <p class="text-gray-300">The statement  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(1,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{cdh}_{\\mathcal{G}}</span>  follows, since given an adversary against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  (see Figure 1), we can easily construct an adversary against  <span class="math">\\mathbf{sq}\\text{-}\\mathbf{dh}_{\\mathcal{G}}</span>  that runs in the same time and has the same probability of success (given  <span class="math">\\mathbf{X} = g^x</span> , sample  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$ , run the  <span class="math">\\mathbf{cdh}</span>  adversary on  <span class="math">(\\mathbf{X}, \\mathbf{X}^r)</span> , obtain  <span class="math">\\mathbf{Z}</span>  and return  <span class="math">\\mathbf{Z}_r^{\\frac{1}{r}}</span> ).</p>

    <p class="text-gray-300">It remains to show that  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}} \\stackrel{(3,1)}{\\Longrightarrow}_{\\operatorname{alg}} \\operatorname{lc-dh}_{\\mathcal{G}}</span> . Given an algebraic solver  <span class="math">\\mathsf{C}_{\\operatorname{alg}}</span>  executed in game  <span class="math">\\operatorname{lc-dh}_{\\mathcal{G}}</span> , we construct an adversary  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  against  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}}</span>  as follows: On input  <span class="math">\\mathbf{X} = g^x</span> ,  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  samples  <span class="math">r \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and computes either  <span class="math">(\\mathbf{X}, g^r)</span> ,  <span class="math">(g^r, \\mathbf{X})</span> , or  <span class="math">(\\mathbf{X}, \\mathbf{X}^r)</span>  each with probability 1/3. Note that this instance is correctly distributed. It then runs  $\\mathsf{C}</em>{\\operatorname{alg}}$  on the resulting tuple  <span class="math">(\\mathbf{X}_1, \\mathbf{X}_2)</span>  and receives  <span class="math">(\\mathbf{Z}, u, v, w)</span>  together with (a, b, c) s.t.  <span class="math">\\mathbf{Z} = g^a \\mathbf{X}_1^b \\mathbf{X}_2^c</span> . If  <span class="math">u \\neq 0</span> , then the choice  <span class="math">\\mathbf{X}_1 = \\mathbf{X}</span> ,  <span class="math">\\mathbf{X}_2 = g^r</span>  yields  <span class="math">\\mathbf{Z} = g^{ux^2 + vxr + wr^2}</span> , from which  <span class="math">g^{x^2}</span>  can be computed as  <span class="math">g^{x^2} = (\\mathbf{Z}\\mathbf{X}^{-vr}g^{-wr^2})^{\\frac{1}{u}}</span> . Clearly,  <span class="math">\\mathsf{A}_{\\operatorname{alg}}</span>  is able to compute an algebraic representation of  <span class="math">g^{x^2}</span>  from the values (a, b, c) and thus is algebraic itself. The cases  <span class="math">v \\neq 0</span> ,  <span class="math">w \\neq 0</span>  follow in a similar fashion.</p>

    <p class="text-gray-300">Corollary 3.2  <span class="math">\\operatorname{cdh}_{\\mathcal{G}}</span>  and  <span class="math">\\operatorname{sq-dh}_{\\mathcal{G}}</span>  are  <span class="math">(t^2/p,t)</span> -hard in the generic group model and  <span class="math">\\operatorname{lc-dh}_{\\mathcal{G}}</span>  is  <span class="math">(3t^2/p,t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">For the subsequent sections and proofs, we will not make explicit the reduction algorithm  <span class="math">R_{\\sf gen}</span>  every time (as done above).</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Strong Diffie-Hellman</h3>

    <p class="text-gray-300">Consider the Strong Diffie-Hellman Assumption [ABR01] described via game  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  in Figure 4. We now prove that the Discrete Logarithm Assumption (non-tightly) implies the Strong Diffie-Hellman Assumption in the Algebraic Group Model. We briefly present the main ideas of the proof. The full proof of Theorem 3.3 can be found in Appendix A.1. Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^z</span>  denote the Discrete Logarithm challenge. We show an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  that simulates  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> .  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  appropriately answers</p>

    <p class="text-gray-300"> <span class="math">A_{alg}</span> 's queries to the oracle  <span class="math">O(\\cdot, \\cdot)</span>  by using the algebraic representation of the queried elements provided by  <span class="math">A_{alg}</span> . Namely, when  <span class="math">(\\mathbf{Y}&#x27;, \\mathbf{Z}&#x27;)</span>  is asked to the oracle,  <span class="math">B_{alg}</span>  obtains vectors  <span class="math">\\vec{b}, \\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1} \\mathbf{X}^{b_2} \\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1} \\mathbf{X}^{c_2} \\mathbf{Y}^{c_3}</span> . As long as  <span class="math">b_2 = b_3 = 0</span> ,  <span class="math">B_{alg}</span>  can answer all of  <span class="math">A_{alg}</span> 's queries by checking whether  <span class="math">\\mathbf{X}^{b_1} = \\mathbf{Z}&#x27;</span> . On the other hand, if  <span class="math">b_2 \\neq 0</span>  or  <span class="math">b_3 \\neq 0</span> , then  <span class="math">B_{alg}</span>  simply returns 0. Informally, the simulation will be perfect unless  <span class="math">A_{alg}</span>  manages to compute a valid solution to  <span class="math">\\mathbf{lc}</span> - <span class="math">\\mathbf{dh}_{\\mathcal{G}}</span> . All of these games can be efficiently simulated by  <span class="math">B_{alg}</span> , as we have shown in the previous section.</p>

    <p class="text-gray-300"><strong>Theorem 3.3</strong>  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(4q,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{sdh}_{\\mathcal{G}}</span> , where q is the maximum number of queries to oracle  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  in  <span class="math">\\mathbf{sdh}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 3.4  <span class="math">\\operatorname{sdh}_{\\mathcal{G}}</span>  is  <span class="math">(\\frac{t^2}{4pq}, t)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The interactive LRSW assumption [LRSW99, CL04] is defined via the algebraic security game <strong>lrsw</strong> in Figure 5.</p>

    <pre><code class="language-text"> \\begin{array}{|c|c|c|}\\hline \\mathbf{lrsw}_{\\mathcal{G}}^{\\mathsf{A}} &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 00 &amp; Q := \\emptyset &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 01 &amp; x, y \\overset{\\$}{\\leftarrow} \\mathbb{Z}_p &amp; &amp; &amp; &amp; &amp; &amp; \\\\ 02 &amp; \\mathbf{X} := g^x, \\mathbf{Y} := g^y &amp; &amp; &amp; &amp; &amp; \\\\ 03 &amp; (m^*, \\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*) \\overset{\\$}{\\leftarrow} \\mathbf{A}^{\\mathsf{O}(\\cdot)}(\\mathbf{X}, \\mathbf{Y}) &amp; &amp; &amp; &amp; \\\\ 04 &amp; \\mathrm{Return} &amp; (m^* \\notin Q \\wedge m^* \\neq 0 \\wedge \\mathbf{A}^* \\neq 1 &amp; &amp; &amp; \\\\ &amp; &amp; \\wedge \\mathbf{B}^* = (\\mathbf{A}^*)^y \\wedge \\mathbf{C}^* = (\\mathbf{A}^*)^{m^*xy+x}) &amp; &amp; &amp; &amp; \\\\ \\end{array}
</code></pre>

    <p class="text-gray-300">Figure 5: Game lrsw relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">We now prove that the LRSW assumption is (non-tightly) implied by the Discrete Logarithm Assumption in the Algebraic Group Model. We give a high-level sketch of the main ideas here and defer the full proof of Theorem 4.1 to Appendix A.2. Let  <span class="math">A_{alg}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  and let  <span class="math">\\mathbf{Z} = g^z</span>  denote the Discrete Logarithm challenge. We construct an adversary  <span class="math">B_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span> , which simulate  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to  <span class="math">A_{alg}</span>  by embedding the value of z in one of three possible ways. Namely, it either sets  <span class="math">\\mathbf{X} := \\mathbf{Z}</span>  or  <span class="math">\\mathbf{Y} := \\mathbf{Z}</span> , or it chooses a random the query by  <span class="math">A_{alg}</span>  to the oracle  <span class="math">O(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span>  to embed the value of z. These behaviours correspond in our proof to the adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span> , and  <span class="math">E_{alg}</span> , respectively. After obtaining a solution  <span class="math">(m^*, [\\mathbf{A}^*]_{\\vec{c}}, [\\mathbf{B}^*]_{\\vec{b}}, [\\mathbf{C}^*]_{\\vec{c}})</span>  on a fresh value  <span class="math">m^* \\neq 0</span>  from  <span class="math">A_{alg}</span> , the adversaries use the algebraic representations  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  obtained from  <span class="math">A_{alg}</span>  to suitably rewrite the values of  <span class="math">\\mathbf{A}^*</span> ,  <span class="math">\\mathbf{C}^*</span>  (Lemma A.1). They then make use of the relation  <span class="math">(\\mathbf{A}^*)^{(xm^*y+x)} = \\mathbf{C}^*</span>  to obtain an equation mod p, which in turn gives z.</p>

    <p class="text-gray-300"><strong>Theorem 4.1</strong>  <span class="math">\\mathbf{dlog}_{\\mathcal{G}} \\stackrel{(6q,1)}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{lrsw}_{\\mathcal{G}}</span> , where  <span class="math">q \\geq 6</span>  is the maximum number of queries to  <span class="math">\\mathsf{O}(\\cdot)</span>  in  <span class="math">\\mathbf{lrsw}_{\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 4.2  <span class="math">\\operatorname{lrsw}_{\\mathcal{G}}</span>  is  <span class="math">(t, \\frac{t^2}{6pq})</span> -hard in the generic group model.</p>

    <p class="text-gray-300">In this section we prove that the IND-CCA1 (aka. lunchtime security) of the ElGamal encryption scheme (in its abstraction as a KEM) is implied by a parametrized (&quot;q-type&quot;) variant of the</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{ind\\text{-}cca1}}_{KEM,par,b}^{A}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Dec}(C)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Enc() // One time</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 \\ (pk, sk) \\stackrel{\\</span>}{\\leftarrow} Gen(par)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">//Before Enc is called</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">(K_0^*,C^*) \\stackrel{\\</span>}{\\leftarrow} Enc(pk)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">b&#x27; \\stackrel{\\</span>}{\\leftarrow} A^{Dec,Enc}(pk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 <span class="math">K \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} Dec(C,sk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">K_1^* \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} \\mathcal{K}$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return b'</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or Return <span class="math">(K_b^*, C^*)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 6: IND-CCA1 Game ind-cca1 relative to KEM KEM = (Gen, Enc, Dec), parameters par, and adversary A.</p>

    <p class="text-gray-300">Decision Diffie-Hellman Assumption in the Algebraic Group Model.</p>

    <p class="text-gray-300">ADVANTAGE FOR DECISIONAL ALGEBRAIC SECURITY GAMES. We parameterize a decisional algebraic game G (such as the game in Figure 7) with a parameter bit b. We define the advantage of adversary A in G as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{A}}^{\\mathbf{G}} := \\big| \\Pr \\left[ \\mathbf{G}_{par,0}^{\\mathsf{A}} = 1 \\right] - \\Pr \\left[ \\mathbf{G}_{par,1}^{\\mathsf{A}} = 1 \\right] \\big|.</span>$</p>

    <p class="text-gray-300">We define  <span class="math">\\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}</span>  independently of the parameter bit b, i.e., we consider only the worst-case running time of  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  in either game. In order to cover games that define the security of schemes (rather than assumptions), instead of  <span class="math">par = \\mathcal{G}</span> , we only require that  <span class="math">\\mathcal{G}</span>  be included in par. Let  <span class="math">\\mathbf{G}_{par}, \\mathbf{H}_{par}</span>  be decisional algebraic security games. As before, we write  <span class="math">\\mathbf{H}_{par} \\overset{(\\Delta_{\\varepsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{par}</span>  if there exists a generic algorithm  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  (called generic  <span class="math">(\\Delta_{\\varepsilon}, \\Delta_{t})</span> -reduction) such that for algebraic algorithm  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defined as  <span class="math">\\mathsf{B}_{\\mathsf{alg}} := \\mathsf{R}_{\\mathsf{gen}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G}}.</span>$</p>

    <p class="text-gray-300">KEY ENCAPSULATION MECHANISMS. A key encapsulation mechanism (KEM for short) KEM = (Gen, Enc, Dec) is a triple of algorithms together with a symmetric-key space  <span class="math">\\mathcal{K}</span> . The randomized key generation algorithm Gen takes as input a set of parameters, par, and outputs a public/secret key pair (pk, sk). The encapsulation algorithm Enc takes as input a public key pk and outputs a key/ciphertext pair (K, C) such that  <span class="math">K \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K}$ . The deterministic decapsulation algorithm Dec takes as input a secret key sk and a ciphertext C and outputs a key  <span class="math">K \\in \\mathcal{K}</span>  or a special symbol  <span class="math">\\bot</span>  if C is invalid. We require that KEM be correct: For all possible pairs (K, C) output by Enc(pk), we have Dec(sk, C) = K. We formalize IND-CCA1 security of a KEM via the games (for b = 0, 1) depicted in Figure 6.</p>

    <p class="text-gray-300">In the following, we consider the ElGamal KEM EG defined in Figure 8. We also consider a stronger variant of the well-known Decisional Diffie-Hellman (DDH) assumption that is parametrized by an integer q. In the q-DDH game, defined in Figure 7, the adversary receives, in addition to  <span class="math">(g^x, g^r)</span> , the values  <span class="math">g^{x^2}, \\ldots, g^{x^q}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.1</strong> [Che06] For  <span class="math">q &lt; p^{1/3}</span> ,  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G}}</span>  is  <span class="math">\\left(\\frac{t^2q}{p\\log p},t\\right)</span> -hard in the generic group model.</p>

    <p class="text-gray-300">The proof of the following theorem can be found in Appendix A.3.</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G},b}^{\\mathsf{A}}}{00 \\ x,r,z} \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_{p}$$
01  <span class="math">b&#x27; \\overset{\\</span>}{\\leftarrow} \\mathsf{A}(g^{x},g^{x^{2}},...,g^{x^{q}},g^{r},g^{xr+zb})$
02 Return  <span class="math">b&#x27;</span></p>

    <p class="text-gray-300">Figure 7: q-Decisional Diffie-Hellman Game  <span class="math">\\mathbf{q}</span> - <span class="math">\\mathbf{ddh}</span>  relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Gen}(\\mathcal{G})</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Enc}(pk)</span> :</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{Dec}(\\mathbf{C},sk)</span> :</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">r \\overset{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 If <span class="math">\\mathbf{C} \\not\\in \\mathbb{G}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">\\mathbf{C} := g^r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return &perp;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">(pk, sk) := (\\mathbf{X}, x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\mathbf{K} := \\mathbf{X}^r</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 <span class="math">\\tilde{\\mathbf{K}} := \\mathbf{C}^x</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of Return <span class="math">(\\mathbf{K}, \\mathbf{C})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 Return <span class="math">\\tilde{\\mathbf{K}}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 8: ElGamal KEM EG = (Gen, Enc, Dec)</p>

    <p class="text-gray-300"><strong>Theorem 5.2</strong> ind-cca1<sub>EG,G</sub>  <span class="math">\\stackrel{(1,1)}{\\Longleftrightarrow}_{\\mathsf{alg}}</span>  q-ddh<sub>G</sub>, where q-1 is the maximal number of queries to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  in ind-cca1<sub>EG,G</sub>.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">03 Return <span class="math">\\vec{b}&#x27;</span> 09 <span class="math">\\mathbf{K}^* \\stackrel{\\mathcal{L}}{\\leftarrow} \\mathcal{K}</span> 10 Return <span class="math">(\\mathbf{K}^*, \\mathbf{C}^*)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">--------------------------------------------------------------------------------------------------------------------------------</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 9: Games  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},0}^\\mathsf{A}</span>  and  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^\\mathsf{A}</span>  with algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . The boxed statement is only executed in  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^\\mathsf{A}</span> .</p>

    <p class="text-gray-300"><strong>Corollary 5.3</strong> For  <span class="math">q &lt; p^{1/3}</span> ,  <span class="math">\\operatorname{ind-cca1}_{\\mathsf{EG},\\mathcal{G}}</span>  is  <span class="math">(\\frac{t^2q}{p\\log p},t)</span> -hard in the generic group model, where q-1 is the maximal number of queries to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  in  <span class="math">\\operatorname{ind-cca1}_{\\mathsf{EG},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">For this section, we introduce the notion of groups  <span class="math">\\mathbb{G}</span>  equipped with a symmetric, (non-degenerate) bilinear map  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  denotes the so-called <em>target group</em>. We now set  <span class="math">\\mathcal{G} = (p, \\mathbb{G}_T, g, e)</span> .</p>

    <p class="text-gray-300">SIGNATURE SCHEMES. A signature scheme SIG = (SIGGen, SIGSig, SIGVer) is a triple of algorithms. The randomized key generation algorithm SIGGen takes as input a set of parameters, par, and outputs a public/secret key pair (pk, sk). The randomized signing algorithm SIGSig takes as input a secret key sk and a message m in the message space  <span class="math">\\mathcal{M}</span>  and outputs a signature  <span class="math">\\sigma</span>  in the signature space  <span class="math">\\mathcal{S}</span> . The deterministic signature verification algorithm SIGVer takes as input a public key pk, a message m, and a signature  <span class="math">\\sigma</span>  and outputs  <span class="math">b \\in \\{0,1\\}</span> . We require that SIG be correct: For all possible pairs (pk, sk) output by SIGGen and all messages  <span class="math">m \\in \\mathcal{M}</span> , we have  <span class="math">\\Pr[\\mathsf{SIGVer}(pk, m, \\mathsf{SIGSig}(m, sk)) = 1] = 1</span> . We formalize unforgeability under chosen message attacks for SIG via game  <span class="math">\\mathsf{uf\\text{-cma}}_{\\mathsf{SIG},par}</span>  depicted in Figure 10.</p>

    <p class="text-gray-300">In the following, we show how in the AGM with a random oracle, the security of the BLS signature scheme [BLS04], depicted in Figure 11, can be tightly reduced to the discrete logarithm problem. Boneh, Lynn and Shacham [BLS04] only prove a loose reduction to the CDH problem. In the AGM we can improve the quality of the reduction by leveraging the fact that a forgery comes with a representation in the basis of all previously answered random-oracle and signature queries. We embed a discrete logarithm challenge in either the secret key or inside the random oracle queries&mdash;a choice that remains hidden from the adversary. Depending on the adversary's behavior we always solve the discrete logarithm challenge in one of the cases.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">uf-cma <sup>A</sup> <sub>SIG,par</sub></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><u>O</u> (m)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">(pk,sk) \\stackrel{s}{\\leftarrow} SIGGen</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">Q \\mathrel{\\mathop:}= Q \\cup \\{m\\}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">Q:=\\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\sigma \\overset{\\</span>}{\\leftarrow} SIGSig(m,sk)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">(m^*,\\sigma^*) \\stackrel{\\</span>}{\\leftarrow} A^{O(\\cdot)}(pk)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">\\sigma</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Return <span class="math">(m^* \\not\\in Q \\land SIGVer(m^*, \\sigma^*))</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 10: Game <strong>uf-cma</strong> defining (existential) unforgeability under chosen-message attacks for signature scheme SIG, parameters par and adversary A.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLSGen(G)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">BLSSig(m)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\tt BLSVer(m, \\boldsymbol{\\Sigma})</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">oo <span class="math">x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\text{O5 } \\Sigma := H(m)^x}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or Return <span class="math">(e(H(m), \\mathbf{X}) = e(\\mathbf{\\Sigma}, g))</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">\\Sigma</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">or <span class="math">sk := x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">pk := \\mathbf{X}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(pk, sk)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 11: Boneh, Lynn and Shacham's signature scheme  <span class="math">\\mathsf{BLS}_{\\mathcal{G}}</span> . Here, H is a hash function that is modeled as a random oracle.</p>

    <p class="text-gray-300">Theorem 6.1  <span class="math">\\operatorname{dlog}_{\\mathcal{G}} \\stackrel{(4,1)}{\\Longrightarrow}_{\\operatorname{alg}} \\operatorname{uf-cma}_{\\operatorname{BLS},\\mathcal{G}} in the random oracle model.</span></p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G} := \\mathbf{uf\\text{-}cma}_{\\mathsf{BLS},\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> , depicted in Figure 12. As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is an algebraic adversary, at the end of  <span class="math">\\mathbf{G}</span>  it returns a forgery  <span class="math">\\mathbf{\\Sigma}^*</span>  on a message  <span class="math">m^* \\notin Q</span>  together with a representation  <span class="math">\\vec{a} = (\\hat{a}, a&#x27;, \\bar{a}_1, ..., \\bar{a}_a, \\tilde{a}_1, ..., \\tilde{a}_a)</span>  s.t.</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{\\Sigma}^* = H(m^*)^x = g^{\\hat{a}} \\mathbf{X}^{a&#x27;} \\prod_{i=1}^q \\mathbf{H}_i^{\\tilde{a}_i} \\prod_{i=1}^q \\mathbf{\\Sigma}_i^{\\tilde{a}_i}.</span>$
(2)</p>

    <p class="text-gray-300">Here, the representation is split (from left to right) into powers of the generator g, the public key  <span class="math">\\mathbf{X}</span> , all of the answers to hash queries  <span class="math">\\mathbf{H}_i, i \\in [q]</span> , and the signatures  <span class="math">\\mathbf{\\Sigma}_i, i \\in [q]</span> , returned by the signing oracle. In the following, we let  <span class="math">r^*</span>  and  <span class="math">r_i</span> , for  <span class="math">i \\in [q]</span> , be such that  <span class="math">H(m^*) = g^{r^*}</span>  and  <span class="math">H(m_i) = g^{r_i}</span> . Equation (2) is thus equivalent to</p>

    <p class="text-gray-300">
<span class="math">$xr^* \\equiv_p x(a&#x27; + \\Sigma_i r_i \\tilde{a}_i) + (\\hat{a} + \\Sigma_i r_i \\bar{a}_i). \\tag{3}</span>$</p>

    <p class="text-gray-300">We remark that since  <span class="math">A_{alg}</span>  wins G, the sum  <span class="math">\\Sigma_i r_i \\tilde{a}_i</span>  may not include a term of the form  <span class="math">r^* \\tilde{a}^*</span>  (since  <span class="math">A_{alg}</span>  may not query the signing oracle on  <span class="math">m^*</span> ). We will now describe the behavior of adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span>  (depicted in Figures 13 and 14, respectively) playing in the discrete logarithm game. Each of these adversaries simulates G to  <span class="math">A_{alg}</span>  in a different way.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">- &middot; A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">- /</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathbf{G}^{A_{alg}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{O}(m_i)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\underline{H}(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">00 x \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">Q := Q \\cup \\{m_i\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">\\mathbf{H}_i \\leftarrow H(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\mathbf{X} := g^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">\\mathbf{\\Sigma}_i \\leftarrow H(m_i)^x</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 Return <span class="math">\\mathbf{H}_i</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">Q := \\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 Return <span class="math">\\boldsymbol{\\Sigma}_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">(m^*, [\\mathbf{\\Sigma}^*]_{\\vec{a}}) \\overset{\\</span>}{\\leftarrow} A_{alg}^{O(\\cdot), H(\\cdot)}(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 Return <span class="math">(m^* \\not\\in Q \\land \\Sigma^* = H(m^*)^x)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 12: Game  <span class="math">\\mathbf{G} = \\mathbf{uf\\text{-}cma}_{\\mathsf{BLS},\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span>  relative to adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">C_{alg}(\\mathbf{Z} = g^z)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">O(m_i)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">H(m_i)</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{c} \\frac{2\\operatorname{dig}}{00} (\\mathbf{Z} + \\mathbf{S}) \\\\ \\end{array}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">04 \\text{ If } H(m_i) = \\bot</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">09 \\text{ If } H(m_i) \\neq \\bot</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(m^*, [\\mathbf{\\Sigma}^*]_{\\vec{a}}) \\overset{\\</span>}{\\leftarrow} A^{O(\\cdot), H(\\cdot)}(\\mathbf{X})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">r_i \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 Return <span class="math">H(m_i)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Compute <span class="math">z</span> (see description)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">H(m_i) \\leftarrow g^{r_i}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11 <span class="math">r_i \\stackrel{\\</span>}{\\leftarrow} \\mathbb{Z}_p$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 Return z</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">07 <span class="math">\\mathbf{\\Sigma}_i \\leftarrow \\mathbf{X}^{r_i}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12 <span class="math">H(m_i) \\leftarrow g^{r_i}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return <span class="math">\\Sigma_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13 Return <span class="math">H(m_i)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 13: Adversary  <span class="math">C_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300"><strong>Lemma 6.2</strong> Let <strong>G</strong> be as defined in Figure 12 and, with  <span class="math">a&#x27;, \\tilde{a}_i, r^*</span>  and  <span class="math">r_i</span>  defined as above, let F denote the event that  <span class="math">a&#x27; + \\sum_i r_i \\tilde{a}_i - r^* \\not\\equiv_p 0</span> . Then there exist  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}</span>  playing in the discrete logarithm game such that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{dlog}^{\\mathsf{C}_{\\mathsf{alg}}} = 1] = \\Pr[\\mathbf{G} = 1 \\mid F] \\tag{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{dlog}^{\\mathsf{D}_{\\mathsf{alg}}} = 1] \\geq \\frac{p-1}{p} \\Pr[\\mathbf{G} = 1 \\mid \\neg F]</span>$
(5)</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">{\\bf Z}</span>  denote the discrete logarithm instance.  <span class="math">{\\sf C}_{\\sf alg}</span>  and  <span class="math">{\\sf D}_{\\sf alg}</span>  simulate  <span class="math">{\\bf G}</span>  to  <span class="math">{\\sf A}_{\\sf alg}</span> .</p>

    <p class="text-gray-300">Adversary  <span class="math">C_{\\mathsf{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">C_{\\mathsf{alg}}</span>  is depicted in Figure 13 and works as follows. It sets  <span class="math">\\mathbf{X} := \\mathbf{Z}</span> , which implicitly sets x := z. To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">r_i \\stackrel{\\</span>}{=} \\mathbb{Z}<em>i$  and sets  <span class="math">H(m_i) := g^{r_i}</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first calls  <span class="math">\\mathsf{H}(m_i)</span>  which defines  <span class="math">H(m_i)</span>  (and thus  <span class="math">r_i</span> ). It then computes and returns  <span class="math">\\Sigma_i := \\mathbf{X}^{r_i}</span> . It is easy to see that  $\\mathsf{C}</em>{\\mathsf{alg}}$ 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 1 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^* \\not\\equiv_p 0</span> . If  <span class="math">r^*</span>  has not been defined at this point,  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  makes an additional query  <span class="math">\\mathsf{H}(m^*)</span>  which defines  <span class="math">r^*</span> . Now, by (3) we have:</p>

    <p class="text-gray-300">
<span class="math">$zr^* \\equiv_p z(a&#x27; + \\Sigma_i r_i \\tilde{a}_i) + (\\hat{a} + \\Sigma_i r_i \\bar{a}_i).</span>$
(6)</p>

    <p class="text-gray-300"><span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  efficiently computes z from (6) as  <span class="math">z = (\\hat{a} + \\Sigma_i r_i \\bar{a}_i)(r^* - a&#x27; - \\Sigma_i r_i \\tilde{a}_i)^{-1} \\bmod p</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{c} \\underline{D_{alg}(\\mathbf{Z} = g^z)} \\\\ \\hline 00 \\ x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ 01 \\ \\mathbf{X} := g^x \\ 02 \\ (m^*, [\\mathbf{\\Sigma}^*]</em>{\\vec{a}}) \\overset{$}{\\leftarrow} A^{O(\\cdot),H}(\\mathbf{X}) \\end{array}$</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\underline{O}}(m_i)</span> 05 <span class="math">\\Sigma_i := H(m_i)^x</span> 06 Return <span class="math">\\Sigma_i</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\frac{\\underline{H}(m_i)}{07 \\ b_i, \\hat{r}_i} \\stackrel{$}{\\sim} \\mathbb{Z}_p \\ 08 \\ \\text{Return} \\ g^{zb_i + \\hat{r}_i} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 Compute <span class="math">z</span> (see above)<br>04 Return <span class="math">z</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 14: Adversary  <span class="math">D_{alg}</span>  against  <span class="math">\\mathbf{dlog}_{\\mathcal{G}}</span>  in the proof of Theorem 6.1.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{D}_{\\mathsf{alg}}(\\mathbf{Z} = g^z)</span> : Adversary  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  is depicted in Figure 14 and works as follows. It samples its own secret key  <span class="math">x \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and sets  <span class="math">\\mathbf{X} := g^x</span> . To answer a query  <span class="math">\\mathsf{H}(m_i)</span> ,  $\\mathsf{D}</em>{\\mathsf{alg}}$  first checks whether  <span class="math">H(m_i) = \\bot</span> . If so, it samples  <span class="math">\\hat{r}_i \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p$  and  <span class="math">b_i \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and sets  <span class="math">H(m_i) = g^{r_i} := \\mathbf{Z}^{b_i} g^{\\hat{r}_i}</span> , which implicitly sets  <span class="math">r_i := \\hat{r}_i + zb_i</span> . It then returns  <span class="math">H(m_i)</span> . To answer a query  <span class="math">\\mathsf{O}(m_i)</span> , it first checks whether  <span class="math">\\mathsf{H}(m_i)</span>  has previously been queried. If not, it first queries  <span class="math">\\mathsf{H}(m_i)</span> , which defines  <span class="math">H(m_i)</span>  and the values  <span class="math">\\hat{r}_i \\in \\mathbb{Z}_p</span> ,  <span class="math">b_i \\in \\mathbb{Z}_p</span> , and  <span class="math">r_i = \\hat{r}_i + zb_i</span> . It then computes and returns  <span class="math">\\mathbf{\\Sigma}_i := H(m_i)^x</span> . Again, it is straight-forward to verify that  $\\mathsf{D}</em>{\\mathsf{alg}}$ 's simulation is perfect. Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathbf{G}</span>  given that  <span class="math">F = 0 \\Leftrightarrow a&#x27; + \\Sigma_i r_i \\tilde{a}_i - r^* \\equiv_p 0</span> . Now,</p>

    <p class="text-gray-300"><span class="math">$zb^* + \\hat{r}^* \\equiv_p r^* \\equiv_p a&#x27; + \\sum_i r_i \\tilde{a}_i \\equiv_p (a&#x27; + \\sum_i \\hat{r}_i \\tilde{a}_i) + z(\\sum_i b_i \\tilde{a}_i) \\equiv_p Az + B, \\tag{7}</span>$</p>

    <p class="text-gray-300">$$\\begin{array}{c|c}
q-\\mathbf{dlog} \\overset{\\mathsf{A}}{\\mathcal{G}} \\
00 &amp; x \\overset{$}{\\leftarrow} \\mathbb{Z}_p^* \\
01 &amp; z \\overset{$}{\\leftarrow} \\mathsf{A}(g^x, g^{x^2}, ..., g^{x^q}) \\
02 &amp; \\text{Return } (z = x)
\\end{array}$$</p>

    <p class="text-gray-300">Figure 15: q-Discrete Logarithm Game q-dlog relative to  <span class="math">\\mathcal{G}</span>  and adversary A.</p>

    <p class="text-gray-300">where  <span class="math">A := \\Sigma_i b_i \\tilde{a}_i</span>  and  <span class="math">B := (a&#x27; + \\Sigma_i \\hat{r}_i \\tilde{a}_i)</span> . Note that the value of  <span class="math">b^*</span>  is information-theoretically hidden from  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  and thus independent from the value of A. As we have argued, the sum  <span class="math">\\Sigma_i r_i \\tilde{a}_i</span>  may not contain a term of the form  <span class="math">a^* r^*</span> . This means in particular that  <span class="math">a&#x27; + \\Sigma_i r_i \\tilde{a}_i</span>  is not composed of the singleton term  <span class="math">r^* \\equiv_p zb^* + \\hat{r}^*</span> . Therefore, with probability  <span class="math">1 - \\frac{1}{p}</span> , we have  <span class="math">b^* - A \\not\\equiv_p 0</span>  and thus  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can compute z as  <span class="math">z := (B - \\hat{r}^*)(b^* - A)^{-1} \\bmod p</span> .</p>

    <p class="text-gray-300">Now, we can simply let an adversary  <span class="math">B_{alg}</span>  choose to emulate one of the described adversaries  <span class="math">C_{alg}</span>  or  <span class="math">D_{alg}</span>  with probability  <span class="math">\\frac{1}{2}</span>  each. All in all,  <span class="math">\\mathbf{Adv}_{\\mathbf{dlog}}^{\\mathsf{B}_{alg},\\mathcal{G}} \\geq \\frac{p-1}{2p} \\mathbf{Adv}_{\\mathbf{uf-cma}_{\\mathsf{BLS}}}^{\\mathsf{A}_{alg},\\mathcal{G}} \\geq \\frac{1}{4} \\mathbf{Adv}_{\\mathbf{uf-cma}_{\\mathsf{BLS}}}^{\\mathsf{A}_{alg},\\mathcal{G}}</span> .</p>

    <p class="text-gray-300">Corollary 6.3 uf-cma<sub>BLS,G</sub> is  <span class="math">(t, \\frac{t^2}{4p})</span> -hard in the generic group model with a random oracle.</p>

    <p class="text-gray-300">In order to cover notions such as knowledge soundness, which are defined via games for two algorithms, we generalize the notion of algebraic games and reductions between them. We write  <span class="math">\\mathbf{G}_{par}^{\\mathsf{A},\\mathsf{X}}</span>  to denote that A and X play in  <span class="math">\\mathbf{G}_{par}</span>  and define the advantage  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}} := \\Pr[\\mathbf{G}_{par}^{\\mathsf{A},\\mathsf{X}} = 1]</span>  and the running time  <span class="math">\\mathbf{Time}_{\\mathbf{par},\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  as before. To capture definitions that require that for every A there exists some X (which has black-box access to A) such that  <span class="math">\\mathbf{Adv}_{par,\\mathsf{A},\\mathsf{X}}^{\\mathbf{G}}</span>  is small, we define algebraic reductions for games  <span class="math">\\mathbf{G}_{par}</span>  of this type as follows.</p>

    <p class="text-gray-300">We write  <span class="math">\\mathbf{H}_{par} \\stackrel{(\\Delta_{\\epsilon}, \\Delta_{t})}{\\Longrightarrow}_{\\mathsf{alg}} \\mathbf{G}_{par}</span>  if there exist generic algorithms  <span class="math">\\mathsf{R}_{\\mathsf{gen}}</span>  and  <span class="math">\\mathsf{S}_{\\mathsf{gen}}</span>  such that for all algebraic algorithms  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\geq \\frac{1}{\\Delta_{\\varepsilon}} \\cdot \\mathbf{Adv}_{par,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{alg}}}^{\\mathbf{G}}, \\quad \\mathbf{Time}_{par,\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{H}} \\leq \\Delta_{t} \\cdot \\mathbf{Time}_{par,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{alg}}}^{\\mathbf{G}},</span>$</p>

    <p class="text-gray-300">with  <span class="math">B_{alg}</span>  defined as  <span class="math">B_{alg} := R_{gen}^{A_{alg}}</span>  and  <span class="math">X_{alg}</span>  defined as  <span class="math">X_{alg} := S_{gen}^{A_{alg}}.</span></p>

    <p class="text-gray-300">THE q-DISCRETE LOGARITHM ASSUMPTION. We define a parametrized (&quot;q-type&quot;) variant of the DLog assumption via the algebraic security game q-dlog in Figure 15. We will show that Groth's [Gro16] scheme, which is the most efficient SNARK system to date, is secure under q-DLog in the algebraic group model.</p>

    <p class="text-gray-300">Non-interactive zero-knowledge arguments of knowledge. Groth [Gro16] considers proof systems for satisfiability of arithmetic circuits, which consist of addition and multiplication gates over a finite field  <span class="math">\\mathbb{F}</span> . As a tool, Gennaro et al. [GGPR13] show how to efficiently convert any arithmetic circuit into a quadratic arithmetic program (QAP) R, which is described by  <span class="math">\\mathbb{F}</span> , integers  <span class="math">\\ell \\leq m</span>  and polynomials  <span class="math">u_i, v_i, w_i \\in \\mathbb{F}[X]</span> , for  <span class="math">0 \\leq i \\leq m</span> , and  <span class="math">t \\in \\mathbb{F}[X]</span> , where the degrees of  <span class="math">u_i, v_i, w_i</span>  are less than the degree n of t. (The relation R can also contain additional information aux.) A QAP R defines the following binary relation of statements  <span class="math">\\phi</span>  and witnesses  <span class="math">\\omega</span> , where we set  <span class="math">a_0 := 1</span> :</p>

    <p class="text-gray-300"><span class="math">$R = \\left\\{ (\\phi, \\omega) \\middle| \\begin{array}{l} \\phi = (a_1, \\dots, a_\\ell) \\in \\mathbb{F}^\\ell, \\ \\omega = (a_{\\ell+1}, \\dots, a_m) \\in \\mathbb{F}^{m-\\ell} \\\\ \\left( \\sum_{i=0}^m a_i u_i(X) \\right) \\cdot \\left( \\sum_{i=0}^m a_i v_i(X) \\right) \\equiv \\sum_{i=0}^m a_i w_i(X) \\pmod{t(X)} \\right\\}</span>$</p>

    <pre><code class="language-text">\\begin{array}{|c|c|c|}\\hline &amp; \\mathbf{knw\\text{-}\\mathbf{snd}} \\overset{\\mathsf{A},\\mathsf{X}_\\mathsf{A}}{\\mathsf{SNK},R} \\\\ &amp; \\texttt{00} &amp; \\mathit{crs} \\overset{\\$}{\\sim} \\mathsf{Setup}(R) \\\\ &amp; \\texttt{01} &amp; ((\\phi,\\pi);\\omega) \\overset{\\$}{\\sim} (\\mathsf{A} \\, \\| \\, \\mathsf{X}_\\mathsf{A})(R,\\mathit{crs}) \\\\ &amp; \\texttt{02} &amp; \\mathsf{Return} &amp; ((\\phi,\\omega) \\notin R \\\\ &amp; &amp; \\land \\mathsf{Vfy}(R,\\mathit{crs},\\phi,\\pi) = 1) \\\\ \\hline \\end{array} \\begin{array}{|c|c|c|c|}\\hline &amp; \\mathbf{k}\\text{-}\\mathbf{snd\\text{-}\\mathbf{aff}} \\overset{\\mathsf{X},\\mathsf{A}}{\\mathsf{NILP},R} \\\\ &amp; \\texttt{03} &amp; \\vec{\\sigma} \\overset{\\$}{\\sim} \\mathsf{LinSetup}(R) \\\\ &amp; \\texttt{04} &amp; (\\phi,P) \\overset{\\$}{\\sim} \\mathsf{A}(R) \\\\ &amp; \\texttt{05} &amp; \\omega \\overset{\\$}{\\sim} \\mathsf{X}(R,\\phi,P) \\\\ &amp; \\texttt{06} &amp; \\mathsf{Return} &amp; (P \\in \\mathbb{F}^{\\nu \\times \\mu} \\, \\land \\, (\\phi,\\omega) \\notin R \\\\ &amp; &amp; \\land \\; \\mathsf{LinVfy}(R,\\vec{\\sigma},\\phi,P\\vec{\\sigma}) = 1) \\\\ \\hline \\end{array}
</code></pre>

    <p class="text-gray-300">Figure 16: Left: Knowledge soundness game knw-snd relative to SNK = (Setup, Prv, Vfy), adversary A and extractor  <span class="math">X_A</span> . Right: Knowledge soundness game k-snd-aff relative to NILP = (LinSetup, PrfMtrx, Test), extractor X and affine adversary A (right).</p>

    <p class="text-gray-300">Relation R defines an NP language  <span class="math">L_R := \\{ \\phi \\in \\mathbb{F}^\\ell \\mid \\exists \\omega \\in \\mathbb{F}^{m-\\ell} : (\\phi, \\omega) \\in R \\}</span> .</p>

    <p class="text-gray-300">A non-interactive argument system for a class of relations  <span class="math">\\mathcal{R}</span>  is a tuple  <span class="math">\\mathsf{SNK} = (\\mathsf{Setup}, \\mathsf{Prv}, \\mathsf{Vfy})</span>  of algorithms. Setup on input a relation  <span class="math">R \\in \\mathcal{R}</span>  outputs a common reference string  <span class="math">\\mathit{crs}</span> ; prover algorithm  <span class="math">\\mathsf{Prv}</span>  on input  <span class="math">\\mathit{crs}</span>  and a statement/witness pair  <span class="math">(\\phi, \\omega) \\in R</span>  returns an argument  <span class="math">\\pi</span> ; Verification  <span class="math">\\mathsf{Vfy}</span>  on input  <span class="math">\\mathit{crs}</span> ,  <span class="math">\\phi</span>  and  <span class="math">\\pi</span>  returns either 0 (reject) or 1 (accept). We require  <span class="math">\\mathsf{SNK}</span>  to be  <span class="math">\\mathit{complete}</span> , i.e., for all  <span class="math">\\mathit{crs}</span>  output by  <span class="math">\\mathsf{Setup}</span> , all arguments for true statements produced by  <span class="math">\\mathsf{Prv}</span>  are accepted by  <span class="math">\\mathsf{Vfy}</span> .</p>

    <p class="text-gray-300">Knowledge soundness requires that for every adversary A there exists an extractor  <span class="math">X_A</span>  that extracts a witness from any valid argument output by A. We write  <span class="math">(y; z) \\stackrel{\\</span>}{\\leftarrow} (A \\parallel X_A)(x)$  when A on input x outputs y and  <span class="math">X_A</span>  on the same input (including A's coins) returns z. Knowledge soundness is defined via game  <span class="math">\\mathbf{knw\\text{-snd}}_{SNK,R}^{A,X_A}</span>  in Figure 16.</p>

    <p class="text-gray-300">Zero knowledge for SNK requires that arguments do not leak any information besides the truth of the statement. It is formalized by demanding the existence of a simulator which on input a trapdoor (which is an additional output of Setup) and a true statement  <span class="math">\\phi</span>  returns an argument that is indistinguishable from an argument for  <span class="math">\\phi</span>  output by Prv when given a witness for  <span class="math">\\phi</span>  (see [Gro16] for a formal definition).</p>

    <p class="text-gray-300">A (preprocessing) succinct argument of knowledge (SNARK) is a knowledge-sound non-interactive argument system whose arguments are of size polynomial in the security parameter and can be verified in polynomial time in the security parameter and the length of the statement.</p>

    <p class="text-gray-300">NON-INTERACTIVE LINEAR PROOFS OF DEGREE 2. NILPs (in Groth's [Gro16] terminology) are an abstraction of many SNARK constructions introduced by Bitansky et al. [BCI<sup>+</sup>13]. We only consider NILPs of degree 2 here. Such a system NILP is defined by three algorithms as follows. On input a quadratic arithmetic program R, LinSetup returns  <span class="math">\\vec{\\sigma} \\in \\mathbb{F}^{\\mu}</span>  for some  <span class="math">\\mu</span> . On input R,  <span class="math">\\phi</span>  and  <span class="math">\\omega</span> , algorithm PrfMtrx generates a matrix  <span class="math">P \\in \\mathbb{F}^{\\nu \\times \\mu}</span>  (where  <span class="math">\\nu</span>  is the (short) proof length). And on input R and  <span class="math">\\phi</span> , Test returns matrices  <span class="math">T_1, \\ldots, T_{\\eta} \\in \\mathbb{F}^{\\mu + \\nu}</span> . The last two algorithms implicitly define a prover and a verification algorithm as follows:</p>

    <pre><code class="language-text">\\circ \\ \\vec{\\pi} \\overset{\\$}{\\leftarrow} \\mathsf{LinPrv}(R, \\vec{\\sigma}, \\phi, \\omega) \\colon \\operatorname{run} \\ P \\overset{\\$}{\\leftarrow} \\mathsf{PrfMtrx}(R, \\phi, \\omega); \\ \\operatorname{return} \\ \\vec{\\pi} := P \\vec{\\sigma}.
\\circ \\ b \\overset{\\$}{\\leftarrow} \\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, \\vec{\\pi}) \\colon (T_1, \\dots, T_\\eta) \\overset{\\$}{\\leftarrow} \\mathsf{Test}(R, \\phi); \\ \\operatorname{return} \\ 1 \\ \\text{iff for all} \\ 1 \\le k \\le \\eta:
(\\vec{\\sigma}^\\top \\mid \\vec{\\pi}^\\top) \\ T_k \\ (\\vec{\\sigma}^\\top \\mid \\vec{\\pi}^\\top)^\\top = 0. \\tag{8}
</code></pre>

    <p class="text-gray-300">By symmetry of (8), for  <span class="math">T_k =: (t_{k,i,j})_{i,j=1}^{\\mu+\\nu}</span>  we can w.l.o.g. assume that  <span class="math">t_{k,i,j} = 0</span>  for all k, i and j &lt; i.</p>

    <p class="text-gray-300">We require a NILP to satisfy statistical knowledge soundness against affine prover strategies, which requires the existence of an (efficient) extractor X that works for all (unbounded) adversaries A. Whenever A returns a proof matrix P which leads to a valid proof  <span class="math">P\\vec{\\sigma}</span>  for a freshly</p>

    <pre><code class="language-text">\\mathsf{Setup}(R)
                                                                   Prv(R, \\vec{\\Sigma}, \\phi, \\omega)
                                                                                                                                                   Vfy(R, \\vec{\\Sigma}, \\phi, \\vec{\\Pi})
                                                                   03 P \\stackrel{\\$}{\\leftarrow} \\mathsf{PrfMtrx}(R, \\phi, \\omega)
                                                                                                                                                   og T_1, \\ldots, T_\\eta \\stackrel{\\$}{\\leftarrow} \\mathsf{Test}(R, \\phi)
oo q \\stackrel{\\$}{\\leftarrow} \\mathbb{G}
of \\vec{\\sigma} \\overset{\\$}{\\leftarrow} \\mathsf{LinSetup}(R)
                                                                   04 Parse P = (p_{i,i})_{i,j}
                                                                                                                                                   10 Parse T_k = (t_{k,i,j})_{i,j}
                                                                   of For i = 1 \\dots \\nu:
02 Return \\vec{\\Sigma} := \\langle \\vec{\\sigma} \\rangle
                                                                                                                                                   11 Return 1 iff for all 1 \\le k \\le \\eta:
                                                                  06 \\Pi_i \\coloneqq \\prod_{j=1}^{\\mu} \\Sigma_j^{p_{i,j}}07 \\pi \\coloneqq (\\Pi_1, \\dots, \\Pi_{\\nu})
                                                                                                                                                            0 = \\prod_{i=1}^{\\mu} \\prod_{j=i}^{\\mu} e(\\mathbf{\\Sigma}_{i}, \\mathbf{\\Sigma}_{j})^{t_{k,i,j}} \\cdot \\prod_{i=1}^{\\mu} \\prod_{j=\\mu+1}^{\\mu+\\nu} e(\\mathbf{\\Sigma}_{i}, \\mathbf{\\Pi}_{j})^{t_{k,i,j}} \\cdot \\prod_{i=\\mu+1}^{\\mu+\\nu} \\prod_{j=i}^{\\mu+\\nu} e(\\mathbf{\\Pi}_{i}, \\mathbf{\\Pi}_{j})^{t_{k,i,j}}
                                                                   08 Return \\pi
                                                                        // Note that \\pi := \\langle P\\vec{\\sigma} \\rangle
                                                                                                                                                         // This evaluates (8) in the exponent
</code></pre>

    <p class="text-gray-300">Figure 17: Argument system (Setup, Prv, Vfy) from a NILP (LinSetup, PrfMtrx, Test).</p>

    <pre><code class="language-text"> \\begin{array}{c} \\operatorname{LinSetup}(R) \\\\ \\text{00} \\ \\alpha, \\beta, \\gamma, \\delta, \\tau \\overset{\\$}{\\leftarrow} \\mathbb{F}^* \\\\ \\text{01} \\ \\vec{\\sigma} := \\left(\\alpha, \\beta, \\gamma, \\delta, \\{\\tau^i\\}_{i=0}^{n-1}, \\{\\frac{1}{\\gamma}(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=0}^{\\ell}, \\\\ \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad \\qquad
</code></pre>

    <p class="text-gray-300">Figure 18: Groth's NILP (LinSetup, PrfMtrx, Test).</p>

    <p class="text-gray-300">sampled  <span class="math">\\vec{\\sigma}</span> , X can extract a witness from P. The notion is defined via game <strong>k-snd-aff</strong><sub>NILP,R</sub> in Figure 16.</p>

    <p class="text-gray-300">NON-INTERACTIVE ARGUMENTS FROM NILPS. From a NILP for a quadratic arithmetic program over a finite field  <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>  for some prime p, one can construct an argument system over a bilinear group  <span class="math">\\mathcal{G} = (p, \\mathbb{G}, g, e)</span> . We thus consider QAP relations R of the form</p>

    <p class="text-gray-300">
<span class="math">$R = (\\mathcal{G}, \\mathbb{F} = \\mathbb{Z}_p, \\ell, \\{u_i(X), v_i(X), w_i(X)\\}_{i=0}^m, t(X)),</span>$
(9)</p>

    <p class="text-gray-300">and define the <em>degree</em> of R as the degree of n of t(X).</p>

    <p class="text-gray-300">The construction of SNK = (Setup, Prv, Vfy) from NILP = (LinSetup, PrfMtrx, Test) is given in Figure 17, where we write  <span class="math">\\langle \\vec{x} \\rangle</span>  for  <span class="math">(g^{x_1}, \\ldots, g^{x_{|\\vec{x}|}})</span> . Setup samples a random group generator g and embeds the NILP CRS &quot;in the exponent&quot;. Using group operations, Prv computes LinPrv in the exponent, and using the pairing, Vfy verifies LinVfy in the exponent.</p>

    <p class="text-gray-300">GROTH'S NEAR-OPTIMAL SNARK FOR QAPS. Groth [Gro16] obtains his SNARK system by constructing a NILP for QAPs and then applying the conversion in Figure 17. Recall that R, as in (9), defines a language of statements  <span class="math">\\phi = (a_1, \\ldots, a_\\ell) \\in \\mathbb{F}^\\ell</span>  with witnesses of the form</p>

    <p class="text-gray-300"> <span class="math">\\omega = (a_{\\ell+1}, \\dots, a_m) \\in \\mathbb{F}^{m-\\ell}</span>  such that (with  <span class="math">a_0 := 1</span> ):</p>

    <p class="text-gray-300">
<span class="math">$\\left(\\sum_{i=0}^{m} a_i u_i(X)\\right) \\cdot \\left(\\sum_{i=0}^{m} a_i v_i(X)\\right) = \\sum_{i=0}^{m} a_i w_i(X) + h(X)t(X) \\tag{10}</span>$</p>

    <p class="text-gray-300">for some  <span class="math">h(X) \\in \\mathbb{F}[X]</span>  of degree at most n-2. Groth's NILP is given in Figure 18.</p>

    <p class="text-gray-300"><strong>Theorem 7.1</strong> ([Gro16, Theorem 1]). The construction in Figure 18 is a NILP with perfect completeness, perfect zero knowledge and statistical knowledge soundness against affine prover strategies.</p>

    <p class="text-gray-300">Groth embeds his NILP in asymmetric bilinear groups, which yields a more efficient SNARK. He then shows that the scheme is knowledge-sound in the generic group model for symmetric bilinear groups (which is a stronger result, as the adversary is more powerful than in asymmetric groups). Since we aim at strengthening Groth's security statement, we also consider the symmetric-group variant (which is what the transformation in Figure 17 yields). We now show how from an algebraic adversary breaking knowledge soundness one can construct an adversary against the q-DLog assumption.</p>

    <p class="text-gray-300"><strong>Theorem 7.2</strong> Let SNK denote Groth's [Gro16] SNARK for degree-n QAPs defined over a (symmetric) bilinear group  <span class="math">\\mathcal{G}</span>  of order p with  <span class="math">n^2 \\leq (p-1)/8</span> . Then we have q-dlog  <span class="math">\\Longrightarrow_{\\mathsf{alg}}^{(3,1)}</span>  knw-snd<sub>SNK</sub> with q := 2n-1.</p>

    <p class="text-gray-300">Let us start with a proof overview. Consider an algebraic adversary  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  against knowledge soundness (as defined in Figure 16):  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  has input  <span class="math">(R, \\langle \\vec{\\sigma} \\rangle)</span>  and returns a statement  <span class="math">\\phi</span>  and a proof  <span class="math">\\vec{\\Pi}</span>  consisting of 3 group elements. Since  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is algebraic and its group-element inputs are  <span class="math">\\vec{\\Sigma} = \\langle \\vec{\\sigma} \\rangle</span> , the adversary returns  <span class="math">[\\mathbf{\\Pi}_i]_{\\vec{a}_i}</span>  for  <span class="math">1 \\leq i \\leq 3</span>  with  <span class="math">\\mathbf{\\Pi}_i = \\prod_{i=1}^{\\mu} \\mathbf{\\Sigma}_j^{a_{i,j}} = \\langle \\sum_{i=1}^{\\mu} \\sigma_j a_{i,j} \\rangle</span> . Letting  <span class="math">P := (a_{i,j})_{i,j} \\in \\mathbb{F}^{3 \\times \\mu}</span> , we have  <span class="math">\\vec{\\Pi} = \\langle P\\vec{\\sigma} \\rangle</span>  and we denote  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's group-element output as  <span class="math">[\\vec{\\Pi}]_P</span> .</p>

    <p class="text-gray-300">By definition,  <span class="math">\\vec{\\Pi}</span>  passes Vfy iff  <span class="math">P\\vec{\\sigma}</span>  satisfies LinVfy. In this case, by Groth's theorem (Theorem 7.1), there exists an extractor X, which on input P such that  <span class="math">P\\vec{\\sigma}</span>  satisfies LinVfy extracts a witness (see game <strong>k-snd-aff</strong><sub>NILP,R</sub> in Figure 16).</p>

    <p class="text-gray-300">So it seems this extractor X should also work for  <span class="math">A_{\\mathsf{alg}}</span>  (which returns P as required). However, X is only guaranteed to succeed if  <span class="math">P\\vec{\\sigma}</span>  verifies for a randomly sampled  <span class="math">\\vec{\\sigma}</span> , whereas for  <span class="math">A_{\\mathsf{alg}}</span>  in  <span class="math">\\mathbf{knw\\text{-snd}}_{\\mathsf{SNK},R}</span>  it suffices to return P so that  <span class="math">P\\vec{\\sigma}</span>  verifies for the specific  <span class="math">\\vec{\\sigma}</span>  for which it received  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> . To prove knowledge soundness, we must show that an adversary can only output P which works for all choices of  <span class="math">\\vec{\\sigma}</span>  (from which X will then extract a witness).</p>

    <p class="text-gray-300">In the generic group model this follows rather straight-forwardly, since the adversary has no information about the concrete  <span class="math">\\vec{\\sigma}</span> . In the AGM however,  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is given  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> , and if  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  could compute discrete logarithms, it could compute P which only verifies for the specific  <span class="math">\\vec{\\sigma}</span>  (in the same way as proofs are simulated to show zero knowledge of the scheme [Gro16]). Our proof strategy is to show that computing discrete logarithms is basically the only way to compute P which only works for the specific  <span class="math">\\vec{\\sigma}</span> .</p>

    <p class="text-gray-300">Examining the structure of a NILP CRS  <span class="math">\\vec{\\sigma}</span>  (Figure 18), we see that its components are defined as multivariate (Laurent) polynomials evaluated at a random point  <span class="math">\\vec{x} = (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> .</p>

    <p class="text-gray-300">Now what does it mean for  <span class="math">A_{alg}</span>  to output a valid P? By the definition of LinVfy via Test (cf. Equation (8) with  <span class="math">\\vec{\\pi} := P\\vec{\\sigma}</span> ), it means that  <span class="math">A_{alg}</span>  found P such that</p>

    <p class="text-gray-300">
<span class="math">$(\\vec{\\sigma}^{\\top} | (P\\vec{\\sigma}))^{\\top}) T (\\vec{\\sigma}^{\\top} | (P\\vec{\\sigma})^{\\top})^{\\top} = 0.</span>$</p>

    <p class="text-gray-300"><span class="math">$(11)</span>$</p>

    <p class="text-gray-300">If we interpret the components of  <span class="math">\\vec{\\sigma}</span>  as polynomials over  <span class="math">X_1, \\ldots, X_5</span>  (corresponding to  <span class="math">\\vec{x} = (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> ) then the left-hand side of (11) defines a polynomial  <span class="math">Q_P(\\vec{X})</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">X_A(R,\\langle \\vec{\\sigma} \\rangle)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{\\mathbf{knw\\text{-}snd}}{snk,R}^{A_{alg},X_{A}}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\bigcirc} (\\phi, [\\vec{\\mathbf{\\Pi}}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">03 <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\omega \\overset{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">(\\phi, [\\vec{\\Pi}]_P) \\stackrel{\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">\\omega</span> .</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">\\omega \\stackrel{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 Return <span class="math">((\\phi, \\omega) \\notin R \\land LinVfy(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 19: Extractor  <span class="math">X_A</span>  defined from X and  <span class="math">A_{alg}</span>  (left) and knowledge soundness game <strong>knw-snd</strong> for a SNARK built from NILP = (LinSetup, PrfMtrx, Test), algebraic adversary  <span class="math">A_{alg}</span>  and  <span class="math">X_A</span>  (right).</p>

    <p class="text-gray-300">On the other hand, what does it mean that  <span class="math">P\\vec{\\sigma}</span>  verifies for the specific  <span class="math">\\vec{\\sigma}</span>  from  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's input but not in general? It means that  <span class="math">Q_P(\\vec{x}) = 0</span> , but  <span class="math">Q_P \\not\\equiv 0</span> , that is,  <span class="math">Q_P</span>  is not the zero polynomial (since otherwise (11) would hold for any choice of  <span class="math">\\vec{x}</span> , that is,  <span class="math">P\\vec{\\sigma}&#x27;</span>  would verify for any  <span class="math">\\vec{\\sigma}&#x27;</span> ).</p>

    <p class="text-gray-300">We now bound the probability that  <span class="math">A_{alg}</span>  behaves &quot;badly&quot;, that is, it returns a proof that only holds with respect to its specific CRS. To do so, we bound the probability that given  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> ,  <span class="math">A_{alg}</span>  (implicitly) returns a nonzero polynomial  <span class="math">Q_P</span>  which vanishes at  <span class="math">\\vec{x}</span> , the point that defines  <span class="math">\\vec{\\sigma}</span> . By factoring  <span class="math">Q_P</span> , we can then extract information about  <span class="math">\\vec{x}</span> , which was only given as group elements  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> .</p>

    <p class="text-gray-300">Concretely, we embed a q-DLog instance simultaneously into  <span class="math">\\alpha, \\ldots, \\tau</span>  of a CRS  <span class="math">\\langle \\vec{\\sigma} \\rangle</span> , for which we thus need q to be at least the maximum of the total degrees of the polynomials defining  <span class="math">\\sigma</span> , which for Groth's NILP is 2n-1. The technical part of the proof is to show that the left-hand side of (11), when viewed as a <em>univariate</em> polynomial, one of whose roots is the DLog challenge, is non-zero. The reduction can then compute the DLog by factoring this polynomial to obtain its roots.</p>

    <p class="text-gray-300">Proof of Theorem 7.2. Let R be a QAP of degree n (cf. (9)). Let NILP = (LinSetup, PrfMtrx, Test) denote Groth's NILP (Figure 18). By Theorem 7.1 there exists an extractor X, which on input R, statement  <span class="math">\\phi \\in L_R</span> , and  <span class="math">P \\in \\mathbb{F}^{\\nu \\times \\mu}</span>  such that  <span class="math">\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1</span>  for  <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} \\mathsf{LinSetup}(R)$  returns a witness  <span class="math">\\omega</span>  with probability  <span class="math">\\mathbf{Adv}^{\\mathbf{k-snd-aff}}_{\\mathsf{NILP},R,\\mathsf{X},\\mathsf{F}}</span>  for any affine  <span class="math">\\mathsf{F}</span> .</p>

    <p class="text-gray-300">Let SNK denote Groth's SNARK obtained from NILP via the transformation in Figure 17 and let  <span class="math">A_{alg}</span>  be an algebraic adversary in the game <strong>knw-snd</strong>  <span class="math">_{SNK,R}</span> . From X we construct an extractor  <span class="math">X_A</span>  for  <span class="math">A_{alg}</span>  in Figure 19. Note that since  <span class="math">A_{alg}</span>  is algebraic, we have  <span class="math">\\vec{\\Pi} = \\langle P\\vec{\\sigma} \\rangle</span> , for which we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Vfy}(R, \\vec{\\Sigma}, \\phi, \\vec{\\Pi}) = \\mathsf{Vfy}(R, \\vec{\\Sigma}, \\phi, \\langle P\\vec{\\sigma} \\rangle) = \\mathsf{Lin}\\mathsf{Vfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) \\tag{12}</span>$</p>

    <p class="text-gray-300">by the definition of Vfy (Figure 17). Using this, we write out Game  <span class="math">\\mathbf{knw\\text{-}snd}^{\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}_{\\mathsf{SNK},R}</span>  in Figure 19. Our goal is to upperbound  <span class="math">\\mathbf{Adv}^{\\mathbf{knw\\text{-}snd}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}</span> .</p>

    <p class="text-gray-300">Consider the affine prover A' in Figure 20 and <strong>k-snd-aff</strong>  <span class="math">^{\\mathsf{X},\\mathsf{A&#x27;}}_{\\mathsf{NILP}}</span> , with the code of A' written out, also in Figure 20. Comparing the right-hand sides of Figures 19 and 20, we see that the outputs of the games only differ in the following: if LinVfy returns 0 for  <span class="math">P\\vec{\\rho}</span>  w.r.t.  <span class="math">\\vec{\\rho}</span> , but it returns 1 for  <span class="math">P\\vec{\\sigma}</span>  w.r.t.  <span class="math">\\vec{\\sigma}</span> , then <strong>knw-snd</strong> returns 1 whereas <strong>k-snd-aff</strong> returns 0. Let <strong>bad</strong> denote the event when this happens; formally defined as a flag in game <strong>k-snd-aff</strong> in Figure 20. By definition, we have</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{Adv_{SNK}^{knw\\text{-snd}}}_{NK,R,A_{alg},X_A} \\le \\mathbf{Adv_{NILP,R,X,A&#x27;}^{k\\text{-snd-aff}}} + \\Pr[\\mathbf{bad} = 1].</span>$
(13)</p>

    <p class="text-gray-300">In order to simplify our analysis, we first make a syntactical change to NILP by multiplying</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A'(R)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{\\mathbf{k}}</span> -snd-aff <span class="math">\\mathbf{n}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\circ} \\circ \\overrightarrow{\\sigma} \\stackrel{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os <span class="math">\\vec{\\rho} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">(\\phi, [\\vec{\\bm{\\Pi}}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">04 <span class="math">\\vec{\\sigma} \\overset{\\</span>}{\\leftarrow} LinSetup(R)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 Return <span class="math">(\\phi, P)</span> .</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">05 <span class="math">(\\phi, [\\vec{\\bf \\Pi}]_P) \\stackrel{\\hspace{0.1em}\\scriptscriptstyle\\</span>}{\\leftarrow} A_{alg}(R, \\langle \\vec{\\sigma} \\rangle)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 <span class="math">\\omega \\stackrel{\\</span>}{\\leftarrow} X(R,\\phi,P)$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of If <span class="math">((\\phi,\\omega)\\notin R \\wedge LinVfy(R,\\vec{\\sigma},\\phi,P\\vec{\\sigma})=1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\wedge \\; LinVfy(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">08  \\text{Then } \\mathbf{bad} := 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">09 Return <span class="math">((\\phi, \\omega) \\notin R \\land LinVfy(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 20: Affine prover A' defined from  <span class="math">A_{alg}</span>  (left) and game <strong>k-snd-aff</strong> for NILP, extractor X and A' (right).</p>

    <p class="text-gray-300">out all denominators, that is, we let LinSetup (cf. Figure 18) return</p>

    <p class="text-gray-300"><span class="math">$\\vec{\\sigma} := \\left(\\delta\\gamma, \\alpha\\delta\\gamma, \\beta\\delta\\gamma, \\delta\\gamma^2, \\delta^2\\gamma, \\{\\delta\\gamma\\tau^i\\}_{i=0}^{n-1}, \\{\\delta(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=0}^{\\ell}, \\{\\gamma(\\beta u_i(\\tau) + \\alpha v_i(\\tau) + w_i(\\tau))\\}_{i=\\ell+1}^{m}, \\{\\gamma\\tau^i t(\\tau)\\}_{i=0}^{n-2}\\right).</span>$
(14)</p>

    <p class="text-gray-300">Note that this does not affect the distribution of the SNARK CRS as running the modified LinSetup amounts to the same as choosing  <span class="math">g&#x27; \\stackrel{\\</span>}{\\leftarrow} \\mathbb{G}$  and running the original setup with  <span class="math">g := (g&#x27;)^{\\delta \\gamma}</span> , which again is a uniformly random generator.</p>

    <p class="text-gray-300">Observe that the components of LinSetup defined in (14) can be described via multivariate polynomials  <span class="math">S_i(\\vec{x})</span> ,  <span class="math">1 \\le i \\le \\mu</span> , of total degree at most 2n-1 with  <span class="math">\\vec{x} := (\\alpha, \\beta, \\gamma, \\delta, \\tau)</span> , and LinSetup can be defined as picking a random point  <span class="math">\\vec{x} \\stackrel{\\</span>}{\\leftarrow} (\\mathbb{F}^*)^5$  and returning the evaluations  <span class="math">\\sigma_i := S_i(\\vec{x})</span>  of these polynomials.</p>

    <p class="text-gray-300">Let T be as defined by Test in Figure 18. By (8) we have</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma}) = 1 \\iff \\vec{\\sigma}^\\top \\big( (Id \\,|\\, P^\\top) \\cdot T \\cdot (Id \\,|\\, P^\\top)^\\top \\big) \\, \\vec{\\sigma} = 0.</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\vec{S}</span>  be the vector of polynomials defined by LinSetup. For a matrix  <span class="math">P \\in \\mathbb{F}^{3 \\times \\mu}</span>  define the following multivariate polynomial</p>

    <p class="text-gray-300">
<span class="math">$Q_{P}(\\vec{X}) := (\\vec{S}(\\vec{X}))^{\\top} ((Id \\mid P^{\\top}) \\cdot T \\cdot (Id \\mid P^{\\top})^{\\top}) \\vec{S}(\\vec{X})</span>$
(15)</p>

    <p class="text-gray-300">of degree at most  <span class="math">(2n-1)^2</span> . Then for any  <span class="math">\\vec{x} \\in (\\mathbb{F}^*)^5</span>  and  <span class="math">\\vec{\\sigma} := \\vec{S}(\\vec{x})</span>  we have</p>

    <p class="text-gray-300">
<span class="math">$\\mathsf{LinVfy}(R, \\vec{\\sigma}, \\phi, P\\vec{\\sigma})) = 1 \\iff Q_P(\\vec{x}) = 0. \\tag{16}</span>$</p>

    <p class="text-gray-300">Groth [Gro16] proves Theorem 7.1 by showing that from a proof P with  <span class="math">Q_P \\equiv 0</span>  (that is, P verifies for any choice of  <span class="math">\\sigma</span> ), an extractor X can efficiently compute a witness. Thus in order to win game <strong>k-snd-aff</strong> NILP,R, the adversary must return P with  <span class="math">Q_P \\not\\equiv 0</span>  (thus the extractor fails), but which verifies for  <span class="math">\\sigma</span> , which by (16) means  <span class="math">Q_P(\\vec{x}) = 0</span> .</p>

    <p class="text-gray-300">The affine adversary has no information on  <span class="math">\\sigma</span>  and thus the polynomial  <span class="math">Q_P</span>  is independent of it. The Schwartz-Zippel lemma states that a non-zero multivariate polynomial over  <span class="math">\\mathbb{F}_p</span>  of total degree d evaluates to 0 on a uniformly random point with probability at most  <span class="math">\\frac{d}{p-1}</span> .</p>

    <p class="text-gray-300">Since the total degree of  <span class="math">Q_P</span>  is at most  <span class="math">d = (2n-1)^2</span>  (using the modified  <span class="math">\\vec{\\sigma}</span>  from (14)), the probability that  <span class="math">Q_P(\\vec{x}) = 0</span>  for a random  <span class="math">\\vec{x} \\stackrel{\\</span>}{\\leftarrow} (F^*)^5$  is thus bounded by  <span class="math">\\frac{d}{p-1}</span> . This yields</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{Adv}_{\\mathsf{NILP},R,\\mathsf{X},\\mathsf{A&#x27;}}^{\\mathsf{k-snd-aff}} \\le \\frac{(2n-1)^2}{p-1}. \\tag{17}</span>$</p>

    <p class="text-gray-300">In order to bound  <span class="math">\\mathbf{Adv_{SNK}^{knw-snd}}_{SNK,R,A_{alg},X_{A}}</span>  in (13), we will construct an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{bad} = 1\\right] \\le \\left(1 - \\frac{(2n-1)^2}{p-1}\\right) \\cdot \\mathbf{Adv}_{\\mathcal{G}, \\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}} \\quad \\text{with} \\quad q = 2n - 1.</span>$
(18)</p>

    <p class="text-gray-300">For <strong>bad</strong> to be set to 1,  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> 's output P must be such that  <span class="math">Q_P \\not\\equiv 0</span> : otherwise,  <span class="math">\\mathsf{LinVfy}</span>  returns 1 for  <span class="math">any \\ \\vec{x}</span>  and in particular  <span class="math">\\mathsf{LinVfy}(R, \\vec{\\rho}, \\phi, P\\vec{\\rho}) = 1</span> .</p>

    <p class="text-gray-300">Event  <span class="math">\\mathbf{bad} = 1</span>  implies thus that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  on input  <span class="math">\\langle \\vec{\\sigma} \\rangle = \\langle \\vec{S}(\\vec{x}) \\rangle</span>  returns P such that</p>

    <p class="text-gray-300">
<span class="math">$Q_P \\not\\equiv 0 \\quad \\text{and} \\quad Q_P(\\vec{x}) = 0.</span>$
(19)</p>

    <p class="text-gray-300">We now use such  <span class="math">A_{alg}</span>  to construct an adversary  <span class="math">B_{alg}</span>  that solves q-DLog with q := 2n - 1.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}(\\langle z \\rangle, \\langle z^2 \\rangle, ..., \\langle z^q \\rangle)</span> : On input a q-DLog instance,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  simulates  <span class="math">\\mathsf{k\\text{-snd-aff}}_{\\mathsf{NILP},R}^{\\mathsf{X},\\mathsf{A}&#x27;}</span>  for  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . It first picks a random values  <span class="math">\\vec{r} \\leftarrow (\\mathbb{F}^*)^5</span>  and  <span class="math">\\vec{s} \\leftarrow \\mathbb{F}^5</span>  and (implicitly) sets  <span class="math">x_i := r_i z + s_i</span> , that is:</p>

    <p class="text-gray-300"><span class="math">$\\alpha := r_1 z + s_1</span>$
<span class="math">\\beta := r_2 z + s_2</span>   <span class="math">\\gamma := r_3 z + s_3</span>   <span class="math">\\delta := r_4 z + s_4</span>   <span class="math">\\tau := r_5 z + s_5</span></p>

    <p class="text-gray-300">If  <span class="math">x_i=0</span>  for some i (which  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can check using  <span class="math">\\langle z \\rangle</span> ) then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  stops and outputs  <span class="math">z:=-s_i r_i^{-1} \\bmod p</span> .</p>

    <p class="text-gray-300">Otherwise,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  generates a CRS  <span class="math">\\langle \\vec{\\sigma} \\rangle := \\langle \\vec{S}(\\vec{x}) \\rangle = \\langle \\vec{S}(\\alpha, \\beta, \\gamma, \\delta, \\tau) \\rangle</span>  as defined in (14). Since the total degree of the polynomials  <span class="math">S_i</span>  defining  <span class="math">\\vec{\\sigma}</span>  is bounded by 2n-1=q (the degree of the last component of  <span class="math">\\vec{\\sigma}</span> ),  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can compute  <span class="math">\\langle \\vec{\\sigma} \\rangle</span>  from its q-DLog instance.</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  runs  <span class="math">(\\phi, [\\vec{\\mathbf{\\Pi}}]_P) \\overset{\\</span>}{\\leftarrow} \\mathsf{A}<em>{\\mathsf{alg}}(R, \\langle \\vec{\\sigma} \\rangle)$  and from P computes the multivariate polynomial  <span class="math">Q_P(\\vec{X})</span>  as defined in (15). If  <span class="math">Q_P \\equiv 0</span>  or  <span class="math">Q_P(\\vec{x}) \\neq 0</span>  (by (19) this means that event <strong>bad</strong> has not occurred) then  $\\mathsf{B}</em>{\\mathsf{alg}}$  aborts. (**)</p>

    <p class="text-gray-300">Otherwise  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  defines the univariate polynomial</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;_P(Z) := Q_P(r_1Z + s_1, \\dots, r_5Z + s_5).</span>$</p>

    <p class="text-gray-300">If
<span class="math">$Q_P&#x27; \\equiv 0</span>$
then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  aborts.  <span class="math">(***)</span></p>

    <p class="text-gray-300">Otherwise  <span class="math">B_{alg}</span>  factors  <span class="math">Q&#x27;_P</span>  to obtain its roots (of which by (15) there are at most  <span class="math">(2n-1)^2</span> ), checks them against its DLog instance to determine whether z is among them, and if so, returns z.</p>

    <p class="text-gray-300">In case  <span class="math">B_{alg}</span>  does not stop at (*), it perfectly simulates <strong>k-snd-aff</strong>  <span class="math">^{X,A&#x27;}_{NILP,R}</span>  for  <span class="math">A_{alg}</span> . We now analyze the probability that  <span class="math">B_{alg}</span>  finds the target z provided that bad = 1. As in this case  <span class="math">B_{alg}</span>  will not abort at (**), it remains to bound the probability of aborting at (***).</p>

    <p class="text-gray-300">Since  <span class="math">Q&#x27;_P(z) = Q_P(r_1z + s_1, \\dots, r_5z + s_5) = Q_P(\\vec{x})</span> , by (19) we have  <span class="math">Q&#x27;_P(z) = 0</span> . Thus if  <span class="math">Q&#x27;_P \\not\\equiv 0</span>  then  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  finds z by factoring  <span class="math">Q&#x27;_P</span> , and it remains to argue that  <span class="math">Q&#x27;_P \\not\\equiv 0</span> .</p>

    <p class="text-gray-300"><span class="math">Q_P</span>  is of the form  <span class="math">Q_P(\\vec{X}) = \\sum_{i_1,\\dots,i_5} c_{i_1,\\dots,i_5} \\prod_{j=1}^5 X_j^{i_j}</span>  for coefficients  <span class="math">c_{i_1,\\dots,i_5}</span>  and thus</p>

    <p class="text-gray-300"><span class="math">$Q&#x27;_{P}(Z) = \\sum_{i_{1},\\dots,i_{5}} c_{i_{1},\\dots,i_{5}} \\prod_{j=1}^{5} (r_{j}Z + s_{j})^{i_{j}} = \\sum_{\\vec{i}} c_{\\vec{i}} \\prod_{j=1}^{5} \\left( \\sum_{k=0}^{i_{j}} \\binom{i_{j}}{k} r_{j}^{k} Z^{k} s_{j}^{i_{j}-k} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{k_{1},\\dots,k_{5}}^{i_{1},\\dots,i_{5}} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} Z^{k_{j}} s_{j}^{i_{j}-k_{j}} = \\sum_{\\ell} \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{\\vec{k}: \\sum_{j}k_{j}=\\ell}^{5} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} Z^{k_{j}} s_{j}^{i_{j}-k_{j}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\ell} c&#x27;_{\\ell} Z^{\\ell} \\qquad \\text{with} \\quad c&#x27;_{\\ell} := \\sum_{\\vec{i}} c_{\\vec{i}} \\sum_{\\vec{k}: \\sum_{j}k_{j}=\\ell}^{5} \\prod_{j=1}^{5} \\binom{i_{j}}{k_{j}} r_{j}^{k_{j}} s_{j}^{i_{j}-k_{j}}.</span>$</p>

    <p class="text-gray-300">By (19) we have  <span class="math">Q_P \\not\\equiv 0</span> . Let  <span class="math">d^*</span>  be the total degree of  <span class="math">Q_P</span> , thus for some  <span class="math">i_1, \\ldots, i_5 \\geq 0</span>  with  <span class="math">\\sum_i i_j = d^*</span>  we have  <span class="math">c_{i_1, \\ldots, i_5} \\neq 0</span> , while  <span class="math">c_{i_1, \\ldots, i_5} = 0</span>  when  <span class="math">\\sum_i i_j &gt; d^*</span> . By the latter we have</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{d^*} \\ = \\ \\sum_{\\vec{i}: \\, \\Sigma_j i_j \\leq d^*} c_{\\vec{i}} \\, \\sum_{\\vec{k}: \\, \\Sigma_j k_j = d^*}^{\\vec{i}} \\, \\prod_{j=1}^5 \\binom{i_j}{k_j} \\, r_j^{k_j} \\, s_j^{i_j - k_j} \\ = \\ \\sum_{\\vec{i}: \\, \\Sigma_j i_j \\leq d^*} c_{\\vec{i}} \\, \\prod_{j=1}^5 r_j^{i_j},</span>$</p>

    <p class="text-gray-300">since  <span class="math">k_j \\leq i_j</span> , for all j, and  <span class="math">\\sum_i i_j \\leq d^*</span>  and  <span class="math">\\sum_i k_j = d^*</span>  implies  <span class="math">k_j = i_j</span>  for all j.</p>

    <p class="text-gray-300">We now lower-bound the probability that  <span class="math">c&#x27;_{d^*} \\neq 0</span>  and thus  <span class="math">Q&#x27;_P \\not\\equiv 0</span> . First note that from  <span class="math">\\langle \\vec{\\sigma} \\rangle = \\langle \\vec{S}(\\vec{x}) \\rangle</span>  the adversary obtains information on  <span class="math">\\vec{x}</span> , which might influence its choice of  <span class="math">Q_P</span> ; however, the values  <span class="math">s_1, \\ldots, s_5</span>  perfectly blind the values  <span class="math">r_1 z, \\ldots, r_5 z</span> , and  <span class="math">c&#x27;_{d^*}</span> , which is independent of  <span class="math">(s_1, \\ldots, s_5)</span>  is thus also independent of  <span class="math">(r_1, \\ldots, r_5)</span> . Consider  <span class="math">c&#x27;_{d^*}</span>  as a polynomial in variables  <span class="math">(R_1, \\ldots, R_n)</span>  of degree  <span class="math">d^*</span> , that is,  <span class="math">C&#x27;_{d^*}(\\vec{R}) := \\sum_{\\vec{i}} c_{\\vec{i}} \\prod_{j=1}^5 R_j^{i_j}</span> . By the Schwartz-Zippel lemma, the probability that for a random  <span class="math">\\vec{r} \\stackrel{\\</span>}{\\leftarrow} (\\mathbb{F}^<em>)^5$  we have  $C'_{d^</em>}(\\vec{r}) = 0$  is bounded by  <span class="math">\\frac{d^*}{p-1}</span>  where  <span class="math">d^*</span>  is upper-bounded by the total degree of  <span class="math">Q_P</span> , which is at most  <span class="math">(2n-1)^2</span> . We thus have  <span class="math">Q&#x27;_P \\not\\equiv 0</span>  with probability at least  <span class="math">1 - \\frac{(2n-1)^2}{p-1}</span> . Since, conditioned on <strong>bad</strong> = 1, the adversary returns the solution to the q-DLog instance, with q = 2n - 1, whenever  <span class="math">Q&#x27;_P \\not\\equiv 0</span> , we have:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}} \\geq \\left(1 - \\frac{(2n-1)^2}{p-1}\\right) \\cdot \\Pr\\left[\\mathbf{bad} = 1\\right] \\geq \\frac{1}{2} \\cdot \\Pr\\left[\\mathbf{bad} = 1\\right],</span>$</p>

    <p class="text-gray-300">where the last inequality comes from  <span class="math">n^2 \\leq (p-1)/8</span> . Putting this together with (13) and (17), we have shown that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv_{\\mathsf{SNK},R}^{\\mathbf{knw\\text{-}snd}}}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}} \\leq \\tfrac{q^2}{p-1} + 2 \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}}.</span>$</p>

    <p class="text-gray-300">Following the generic bound for Boneh and Boyen's SDH assumption [BB08] (see below), we may assume that  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q-\\mathsf{dlog}} \\geq \\frac{q^2}{p-1}</span> . The above equation thus implies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{SNK},R,\\mathsf{A}_{\\mathsf{alg}},\\mathsf{X}_{\\mathsf{A}}}^{\\mathbf{knw\\text{-}snd}} \\leq 3 \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{q\\text{-}\\mathbf{dlog}},</span>$</p>

    <p class="text-gray-300">which concludes the proof.</p>

    <p class="text-gray-300"><strong>Corollary 7.3</strong> In the generic group model breaking knowledge soundness of Groth's SNARK [Gro16] for a degree-n QAP is  <span class="math">(\\frac{3t^2q+3q^3}{p},t)</span> -hard for q=2n-1.</p>

    <p class="text-gray-300">The corollary follows from the generic  <span class="math">(\\frac{t^2q+q^3}{p},t)</span> -hardness of q-dlog, which is derived analogously to the bound for Boneh and Boyen's SDH assumption [BB08].</p>

    <p class="text-gray-300">We remark that the above result is not specific to Groth's SNARK; it applies to any SNARK built from a NILP whose setup evaluates multivariate polynomials on a random position. The maximal total degree of these polynomials determines the parameter q in the q-DLog instance.</p>

    <p class="text-gray-300">We thank Balthazar Bauer for pointing out a flaw and a fix in the proof of Theorem 7.2. We also thank Dan Brown for valuable comments, Pooya Farshim for discussions on polynomiels and Helger Lipmaa for sharing with us his independent security proof for Groth's SNARK. The first author is supported by the French ANR EfTrEC project (ANR-16-CE39-0002). The second author was supported in part by ERC Project ERCC (FP7/615074) and by DFG SPP 1736 Big Data. The third author was supported by ERC Project ERCC (FP7/615074).</p>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABM15] Michel Abdalla, Fabrice Benhamouda, and Philip MacKenzie. Security of the J-PAKE password-authenticated key exchange protocol. In <em>2015 IEEE Symposium on Security and Privacy</em>, pages 571&ndash;587. IEEE Computer Society Press, May 2015. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[ABR01] Michel Abdalla, Mihir Bellare, and Phillip Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In David Naccache, editor, <em>CT-RSA 2001</em>, volume 2020 of <em>LNCS</em>, pages 143&ndash;158. Springer, Heidelberg, April 2001. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-9-1">10.</a>)</p></li>
      <li><p class="text-gray-300">[ABS16] Miguel Ambrona, Gilles Barthe, and Benedikt Schmidt. Automated unbounded analysis of cryptographic constructions in the generic group model. In Marc Fischlin and Jean-S&eacute;bastien Coron, editors, <em>EUROCRYPT 2016, Part II</em>, volume 9666 of <em>LNCS</em>, pages 822&ndash;851. Springer, Heidelberg, May 2016. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[ACdM05] Giuseppe Ateniese, Jan Camenisch, and Breno de Medeiros. Untraceable RFID tags via insubvertible encryption. In Vijayalakshmi Atluri, Catherine Meadows, and Ari Juels, editors, <em>ACM CCS 05</em>, pages 92&ndash;101. ACM Press, November 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[ACHdM05] Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, and Breno de Medeiros. Practical group signatures without random oracles. Cryptology ePrint Archive, Report 2005/385, 2005. <a href="http://eprint.iacr.org/2005/385" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2005/385</a>. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[AGO11] Masayuki Abe, Jens Groth, and Miyako Ohkubo. Separating short structurepreserving signatures from non-interactive assumptions. In Dong Hoon Lee and Xiaoyun Wang, editors, <em>ASIACRYPT 2011</em>, volume 7073 of <em>LNCS</em>, pages 628&ndash;646. Springer, Heidelberg, December 2011. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[AM09] Divesh Aggarwal and Ueli Maurer. Breaking RSA generically is equivalent to factoring. In Antoine Joux, editor, <em>EUROCRYPT 2009</em>, volume 5479 of <em>LNCS</em>, pages 36&ndash;53. Springer, Heidelberg, April 2009. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">[BB08] Dan Boneh and Xavier Boyen. Short signatures without random oracles and the SDH assumption in bilinear groups. <em>Journal of Cryptology</em>, 21(2):149&ndash;177, April 2008. (Cited on page <a href="#page-22-0">23.</a>)</p></li>
      <li><p class="text-gray-300">[BCI+13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, <em>TCC 2013</em>, volume 7785 of <em>LNCS</em>, pages 315&ndash;333. Springer, Heidelberg, March 2013. (Cited on page <a href="#page-16-2">17.</a>)</p></li>
      <li><p class="text-gray-300">[BCL04] E. Bangerter, J. Camenisch, and A. Lysyanskaya. A cryptographic framework for the controlled release of certified data. In <em>Security Protocols Workshop</em>, pages 20&ndash;24, 2004. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[BCPR16] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. <em>SIAM Journal on Computing</em>, 2016. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[BCS05] M. Backes, J. Camenisch, and D. Sommer. Anonymous yet accountable access control. In <em>WPES</em>, pages 40&ndash;46, 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[BDZ03] Feng Bao, Robert H. Deng, and Huafei Zhu. Variations of Diffie-Hellman problem. In Sihan Qing, Dieter Gollmann, and Jianying Zhou, editors, <em>ICICS 03</em>, volume 2836 of <em>LNCS</em>, pages 301&ndash;312. Springer, Heidelberg, October 2003. (Cited on page <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">[BFF+14] Gilles Barthe, Edvard Fagerholm, Dario Fiore, John C. Mitchell, Andre Scedrov, and Benedikt Schmidt. Automated analysis of cryptographic assumptions in generic group models. In Juan A. Garay and Rosario Gennaro, editors, <em>CRYPTO 2014, Part I</em>, volume 8616 of <em>LNCS</em>, pages 95&ndash;112. Springer, Heidelberg, August 2014. (Cited on page <a href="#page-3-0">4,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[BFW16] David Bernhard, Marc Fischlin, and Bogdan Warinschi. On the hardness of proving CCA-security of signed ElGamal. In Chen-Mou Cheng, Kai-Min Chung, Giuseppe Persiano, and Bo-Yin Yang, editors, <em>PKC 2016, Part I</em>, volume 9614 of <em>LNCS</em>, pages 47&ndash;69. Springer, Heidelberg, March 2016. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[BG04] Daniel R. L. Brown and Robert P. Gallant. The static diffie-hellman problem. Cryptology ePrint Archive, Report 2004/306, 2004. <a href="http://eprint.iacr.org/2004/306" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a> <a href="http://eprint.iacr.org/2004/306" target="_blank" rel="noopener noreferrer">2004/306</a>. (Cited on page <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">[BL96] Dan Boneh and Richard J. Lipton. Algorithms for black-box fields and their application to cryptography (extended abstract). In Neal Koblitz, editor, <em>CRYPTO'96</em>, volume 1109 of <em>LNCS</em>, pages 283&ndash;297. Springer, Heidelberg, August 1996. (Cited on page <a href="#page-0-0">1.</a>)</p></li>
      <li><p class="text-gray-300">[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing. <em>Journal of Cryptology</em>, 17(4):297&ndash;319, September 2004. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-12-1">13.</a>)</p></li>
      <li><p class="text-gray-300">[BMV08] Emmanuel Bresson, Jean Monnerat, and Damien Vergnaud. Separation results on the &quot;one-more&quot; computational problems. In Tal Malkin, editor, <em>CT-RSA 2008</em>, volume 4964 of <em>LNCS</em>, pages 71&ndash;87. Springer, Heidelberg, April 2008. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[Boy08] Xavier Boyen. The uber-assumption family (invited talk). In Steven D. Galbraith and Kenneth G. Paterson, editors, <em>PAIRING 2008</em>, volume 5209 of <em>LNCS</em>, pages 39&ndash;56. Springer, Heidelberg, September 2008. (Cited on page <a href="#page-4-0">5,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In V. Ashby, editor, <em>ACM CCS 93</em>, pages 62&ndash;73. ACM Press, November 1993. (Cited on page <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">[BR04] Mihir Bellare and Phillip Rogaway. Code-based game-playing proofs and the security of triple encryption. Cryptology ePrint Archive, Report 2004/331, 2004. <a href="http://eprint.iacr.org/2004/331" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2004/331</a>. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[BV98] Dan Boneh and Ramarathnam Venkatesan. Breaking RSA may not be equivalent to factoring. In Kaisa Nyberg, editor, <em>EUROCRYPT'98</em>, volume 1403 of <em>LNCS</em>, pages 59&ndash;71. Springer, Heidelberg, May / June 1998. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">[CGH98] Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle methodology, revisited (preliminary version). In <em>30th ACM STOC</em>, pages 209&ndash;218. ACM Press, May 1998. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[Che06] Jung Hee Cheon. Security analysis of the strong Diffie-Hellman problem. In Serge Vaudenay, editor, <em>EUROCRYPT 2006</em>, volume 4004 of <em>LNCS</em>, pages 1&ndash;11. Springer, Heidelberg, May / June 2006. (Cited on page <a href="#page-3-0">4,</a> <a href="#page-11-2">12.</a>)</p></li>
      <li><p class="text-gray-300">[CHK+06] Jan Camenisch, Susan Hohenberger, Markulf Kohlweiss, Anna Lysyanskaya, and Mira Meyerovich. How to win the clonewars: Efficient periodic n-times anonymous authentication. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors, <em>ACM CCS 06</em>, pages 201&ndash;210. ACM Press, October / November 2006. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[CHL05] Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In Ronald Cramer, editor, <em>EUROCRYPT 2005</em>, volume 3494 of <em>LNCS</em>, pages 302&ndash;321. Springer, Heidelberg, May 2005. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[CHP07] Jan Camenisch, Susan Hohenberger, and Michael &Oslash;stergaard Pedersen. Batch verification of short signatures. In Moni Naor, editor, <em>EUROCRYPT 2007</em>, volume 4515 of <em>LNCS</em>, pages 246&ndash;263. Springer, Heidelberg, May 2007. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[CL04] Jan Camenisch and Anna Lysyanskaya. Signature schemes and anonymous credentials from bilinear maps. In Matthew Franklin, editor, <em>CRYPTO 2004</em>, volume 3152 of <em>LNCS</em>, pages 56&ndash;72. Springer, Heidelberg, August 2004. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-10-3">11.</a>)</p></li>
      <li><p class="text-gray-300">[CM14] Melissa Chase and Sarah Meiklejohn. D&eacute;j&agrave; Q: Using dual systems to revisit q-type assumptions. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>EURO-CRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 622&ndash;639. Springer, Heidelberg, May 2014. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[Cor02] Jean-S&eacute;bastien Coron. Optimal security proofs for PSS and other signature schemes. In Lars R. Knudsen, editor, <em>EUROCRYPT 2002</em>, volume 2332 of <em>LNCS</em>, pages 272&ndash;287. Springer, Heidelberg, April / May 2002. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[Dam92] Ivan Damg&aring;rd. Towards practical public key systems secure against chosen ciphertext attacks. In Joan Feigenbaum, editor, <em>CRYPTO'91</em>, volume 576 of <em>LNCS</em>, pages 445&ndash;456. Springer, Heidelberg, August 1992. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[Den02] Alexander W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In Yuliang Zheng, editor, <em>ASIACRYPT 2002</em>, volume 2501 of <em>LNCS</em>, pages 100&ndash;109. Springer, Heidelberg, December 2002. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[DH76] Whitfield Diffie and Martin E. Hellman. New directions in cryptography. <em>IEEE Transactions on Information Theory</em>, 22(6):644&ndash;654, 1976. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">[FKL17] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. <em>Cryptology ePrint Archive, Report 2017/620</em>, 2017. (Cited on page .)</p></li>
      <li><p class="text-gray-300">[GBL08] Sanjam Garg, Raghav Bhaskar, and Satyanarayana V. Lokam. Improved bounds on security reductions for discrete log based signatures. In David Wagner, editor, <em>CRYPTO 2008</em>, volume 5157 of <em>LNCS</em>, pages 93&ndash;107. Springer, Heidelberg, August 2008. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[GG17] Jens Groth and Essam Ghadafi. Towards a classification of non-interactive computational assumptions in cyclic groups. In Tsuyoshi Takagi and Thomas Peyrin,</p></li>
      <li><p class="text-gray-300">editors, <em>ASIACRYPT 2017</em>, volume 10625 of <em>LNCS</em>, pages 66&ndash;96, Hong Kong, December 2017. Springer. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, <em>EUROCRYPT 2013</em>, volume 7881 of <em>LNCS</em>, pages 626&ndash;645. Springer, Heidelberg, May 2013. (Cited on page <a href="#page-15-1">16.</a>)</p></li>
      <li><p class="text-gray-300">[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-S&eacute;bastien Coron, editors, <em>EUROCRYPT 2016, Part II</em>, volume 9666 of <em>LNCS</em>, pages 305&ndash;326. Springer, Heidelberg, May 2016. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-15-1">16,</a> <a href="#page-16-2">17,</a> <a href="#page-17-3">18,</a> <a href="#page-18-4">19,</a> <a href="#page-20-5">21,</a> <a href="#page-22-0">23.</a>)</p></li>
      <li><p class="text-gray-300">[HP78] M. E. Hellman and S. C. Pohlig. An improved algorithm for computing logarithms over <em>GF</em>(<em>p</em>) and its cryptographic significance. <em>IEEE Transactions on Information Theory</em>, 24(1):106&ndash;110, 1978. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[JR10] Tibor Jager and Andy Rupp. The semi-generic group model and applications to pairing-based cryptography. In Masayuki Abe, editor, <em>ASIACRYPT 2010</em>, volume 6477 of <em>LNCS</em>, pages 539&ndash;556. Springer, Heidelberg, December 2010. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[JR15] Antoine Joux and Antoine Rojat. Security ranking among assumptions within the <em>Uber Assumption</em> framework. In Yvo Desmedt, editor, <em>ISC 2013</em>, volume 7807 of <em>LNCS</em>, pages 391&ndash;406. Springer, Heidelberg, November 2015. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[JS09] Tibor Jager and J&ouml;rg Schwenk. On the analysis of cryptographic assumptions in the generic ring model. In Mitsuru Matsui, editor, <em>ASIACRYPT 2009</em>, volume 5912 of <em>LNCS</em>, pages 399&ndash;416. Springer, Heidelberg, December 2009. (Cited on page <a href="#page-3-0">4.</a>)</p></li>
      <li><p class="text-gray-300">[Kil01] Eike Kiltz. A tool box of cryptographic functions related to the Diffie-Hellman function. In C. Pandu Rangan and Cunsheng Ding, editors, <em>INDOCRYPT 2001</em>, volume 2247 of <em>LNCS</em>, pages 339&ndash;350. Springer, Heidelberg, December 2001. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[KK12] Saqib A. Kakvi and Eike Kiltz. Optimal security proofs for full domain hash, revisited. In David Pointcheval and Thomas Johansson, editors, <em>EUROCRYPT 2012</em>, volume 7237 of <em>LNCS</em>, pages 537&ndash;553. Springer, Heidelberg, April 2012. (Cited on page <a href="#page-2-1">3.</a>)</p></li>
      <li><p class="text-gray-300">[KMP16] Eike Kiltz, Daniel Masny, and Jiaxin Pan. Optimal security proofs for signatures from identification schemes. In Matthew Robshaw and Jonathan Katz, editors, <em>CRYPTO 2016, Part II</em>, volume 9815 of <em>LNCS</em>, pages 33&ndash;61. Springer, Heidelberg, August 2016. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In Nigel P. Smart, editor, <em>EUROCRYPT 2008</em>, volume 4965 of <em>LNCS</em>, pages 146&ndash;162. Springer, Heidelberg, April 2008. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[LR06] Gregor Leander and Andy Rupp. On the equivalence of RSA and factoring regarding generic ring algorithms. In Xuejia Lai and Kefei Chen, editors, <em>ASIACRYPT 2006</em>, volume 4284 of <em>LNCS</em>, pages 241&ndash;251. Springer, Heidelberg, December 2006. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[LRSW99] Anna Lysyanskaya, Ronald L. Rivest, Amit Sahai, and Stefan Wolf. Pseudonym systems. In Howard M. Heys and Carlisle M. Adams, editors, <em>SAC 1999</em>, volume 1758 of <em>LNCS</em>, pages 184&ndash;199. Springer, Heidelberg, August 1999. (Cited on page <a href="#page-2-1">3,</a> <a href="#page-3-0">4,</a> <a href="#page-10-3">11.</a>)</p></li>
      <li><p class="text-gray-300">[Mau05] Ueli M. Maurer. Abstract models of computation in cryptography (invited paper). In Nigel P. Smart, editor, <em>10th IMA International Conference on Cryptography and Coding</em>, volume 3796 of <em>LNCS</em>, pages 1&ndash;12. Springer, Heidelberg, December 2005. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-4-0">5,</a> <a href="#page-5-0">6,</a> <a href="#page-7-0">8.</a>)</p></li>
      <li><p class="text-gray-300">[MRV16] Paz Morillo, Carla R&agrave;fols, and Jorge Luis Villar. The kernel matrix Diffie-Hellman assumption. In Jung Hee Cheon and Tsuyoshi Takagi, editors, <em>ASIACRYPT 2016, Part I</em>, volume 10031 of <em>LNCS</em>, pages 729&ndash;758. Springer, Heidelberg, December 2016. (Cited on page <a href="#page-4-0">5.</a>)</p></li>
      <li><p class="text-gray-300">[MW98] Ueli M. Maurer and Stefan Wolf. Lower bounds on generic algorithms in groups. In Kaisa Nyberg, editor, <em>EUROCRYPT'98</em>, volume 1403 of <em>LNCS</em>, pages 72&ndash;84. Springer, Heidelberg, May / June 1998. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[MW99] Ueli Maurer and Stefan Wolf. The relationship between breaking the diffiehellman protocol and computing discrete logarithms. <em>SIAM Journal on Computing</em>, 28(5):1689&ndash;1721, 1999. (Cited on page <a href="#page-8-3">9.</a>)</p></li>
      <li><p class="text-gray-300">[Nec94] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. <em>Mathematical Notes</em>, 55(2):165&ndash;172, 1994. (Cited on page <a href="#page-0-0">1.</a>)</p></li>
      <li><p class="text-gray-300">[Pol78] J. M. Pollard. Monte Carlo methods for index computation mod <em>p</em>. <em>Mathematics of Computation</em>, 32:918&ndash;924, 1978. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[PV05] Pascal Paillier and Damien Vergnaud. Discrete-log-based signatures may not be equivalent to discrete log. In Bimal K. Roy, editor, <em>ASIACRYPT 2005</em>, volume 3788 of <em>LNCS</em>, pages 1&ndash;20. Springer, Heidelberg, December 2005. (Cited on page <a href="#page-1-0">2,</a> <a href="#page-6-1">7.</a>)</p></li>
      <li><p class="text-gray-300">[Riv04] Ronald L. Rivest. On the notion of pseudo-free groups. In Moni Naor, editor, <em>TCC 2004</em>, volume 2951 of <em>LNCS</em>, pages 505&ndash;521. Springer, Heidelberg, February 2004. (Cited on page <a href="#page-1-0">2.</a>)</p></li>
      <li><p class="text-gray-300">[RLB+08] Andy Rupp, Gregor Leander, Endre Bangerter, Alexander W. Dent, and Ahmad-Reza Sadeghi. Sufficient conditions for intractability over black-box groups: Generic lower bounds for generalized DL and DH problems. In Josef Pieprzyk, editor, <em>ASIACRYPT 2008</em>, volume 5350 of <em>LNCS</em>, pages 489&ndash;505. Springer, Heidelberg, December 2008. (Cited on page <a href="#page-5-0">6.</a>)</p></li>
      <li><p class="text-gray-300">[Sho97] Victor Shoup. Lower bounds for discrete logarithms and related problems. In Walter Fumy, editor, <em>EUROCRYPT'97</em>, volume 1233 of <em>LNCS</em>, pages 256&ndash;266. Springer, Heidelberg, May 1997. (Cited on page <a href="#page-0-0">1,</a> <a href="#page-4-0">5,</a> <a href="#page-5-0">6,</a> <a href="#page-7-0">8.</a>)</p></li>
      <li><p class="text-gray-300">[Sho04] Victor Shoup. Sequences of games: a tool for taming complexity in security proofs. Cryptology ePrint Archive, Report 2004/332, 2004. <a href="http://eprint.iacr.org/2004/332" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a> <a href="http://eprint.iacr.org/2004/332" target="_blank" rel="noopener noreferrer">2004/332</a>. (Cited on page <a href="#page-28-2">29.</a>)</p></li>
    </ul>

    <p class="text-gray-300">[SS01] Ahmad-Reza Sadeghi and Michael Steiner. Assumptions related to discrete logarithms: Why subtleties make a real difference. In Birgit Pfitzmann, editor, <em>EUROCRYPT 2001</em>, volume 2045 of <em>LNCS</em>, pages 244&ndash;261. Springer, Heidelberg, May 2001. (Cited on page 5.)</p>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Deferred Proofs</h2>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Proof of Theorem 3.3</h3>

    <p class="text-gray-300"><em>Proof.</em> We prove that</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathbf{cdh}} \\ge \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{sdh}} - q \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\cdot\\mathbf{dh}}.</span>$
(20)</p>

    <p class="text-gray-300">Applying Theorem 3.1 yields the theorem. We now prove (20) via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} := \\mathbf{sdh}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is an algebraic adversary, it returns a vector  <span class="math">\\vec{a}</span>  along with  <span class="math">\\mathbf{Z}</span>  at the end of the game such that  <span class="math">\\mathbf{Z} = g^{a_1}\\mathbf{X}^{a_2}\\mathbf{Y}^{a_3}</span> . Furthermore, for any query asked to  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span> , it includes vectors  <span class="math">\\vec{b},\\vec{c}</span>  such that  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}\\mathbf{X}^{b_2}\\mathbf{Y}^{b_3}</span>  and  <span class="math">\\mathbf{Z}&#x27; = g^{c_1}\\mathbf{X}^{c_2}\\mathbf{Y}^{c_3}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figure 21.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|c|}\\hline \\mathbf{G_0}, \\overline{\\mathbf{G_1}} &amp; \\underline{\\mathbf{O}}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}): \\\\ \\hline \\text{00 } x, y &amp; \\mathbb{Z}_p \\\\ \\hline \\text{01 } (\\mathbf{X}, \\mathbf{Y}) := (g^x, g^y) \\\\ \\hline \\text{02 } [\\mathbf{Z}]_{\\vec{a}} &amp; \\stackrel{\\</span>}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}(\\cdot, \\cdot)}(\\mathbf{X}, \\mathbf{Y}) \\ \\hline \\text{03 } \\text{Return } \\mathbf{Z} = g^{xy} \\ \\end{array} \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c$$</p>

    <p class="text-gray-300">Figure 21: Games  <span class="math">G_0</span>  and  <span class="math">G_1</span> . The boxed statements are only executed in  <span class="math">G_1</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : For game  <span class="math">\\mathbf{G_1}</span>  we alter the way that the oracle  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  answers queries. Namely, if  <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span> , it always returns 0. Game  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 21. The check performed by the oracle in  <span class="math">\\mathbf{G_1}</span>  amounts to checking whether  <span class="math">\\mathbf{Z}&#x27; = \\mathbf{X}^{b_1}</span> , since if  <span class="math">b_2 = b_3 = 0</span>  then  <span class="math">\\mathbf{Y}&#x27; = g^{b_1}</span> . Using this property of  <span class="math">\\mathbf{G_1}</span> , we show an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  against  <span class="math">\\mathbf{cdh}_{\\mathcal{G}}</span>  such that  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}^{\\mathsf{cdh}} = \\Pr[\\mathbf{G_1} = 1]</span> .  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  is depicted in Figure 22.</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{|c|c|} \\hline \\textbf{B}_{\\mathsf{alg}}(\\mathbf{X} = g^x, \\mathbf{Y} = g^y) &amp; \\underline{\\mathbf{O}}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}): \\\\ \\hline \\textbf{00} &amp; [\\mathbf{Z}]_{\\vec{a}} \\overset{\\</span>}{\\leftarrow} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}}(\\cdot, \\cdot)(\\mathbf{X}, \\mathbf{Y}) \\ \\hline \\textbf{01} &amp; \\mathrm{Return} \\ \\mathbf{Z} &amp; \\mathrm{03} \\quad \\mathrm{Return} \\ \\mathbf{0} \\ \\hline \\textbf{04} &amp; \\mathrm{Return} \\ \\mathbf{Z}' = \\mathbf{X}^{b_1} \\ \\hline \\end{array}$$</p>

    <p class="text-gray-300">Figure 22: Behavior of adversary Balg.</p>

    <p class="text-gray-300">We now show the existence of adversary  <span class="math">C_{alg}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\left|\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - \\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}\\right| \\leq q \\cdot \\mathbf{Adv}^{\\mathbf{lcdh}}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}.</span>$</p>

    <p class="text-gray-300">Let F denote the event that  <span class="math">\\mathbf{Z}&#x27; = (\\mathbf{Y}&#x27;)^x \\wedge (b_2 \\neq 0 \\vee b_3 \\neq 0)</span>  in at least one call to the oracle. Clearly, as long as F does not occur, the games behave identically. By the difference lemma [Sho04], we obtain</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathbf{G_0} = 1] - \\Pr[\\mathbf{G_1} = 1]| \\le \\Pr[F].</span>$</p>

    <p class="text-gray-300">We show the existence of  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F] \\leq q \\cdot \\mathbf{Adv^{lc\\text{-}dh}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}}</span>$</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">C_{alg}(\\mathbf{X} = g^x, \\mathbf{Y} = g^y)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\underline{O}([\\mathbf{Y}&#x27;]_{\\vec{b}}, [\\mathbf{Z}&#x27;]_{\\vec{c}}):</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\overline{\\circ\\circ Q} := \\emptyset</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os If <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">on <span class="math">[\\mathbf{Z}]_{\\vec{a}} \\overset{\\</span>}{\\leftarrow} A_{alg}^{O(\\cdot,\\cdot)}(\\mathbf{X},\\mathbf{Y})$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">06 If <span class="math">b_2 \\neq 0 \\land b_3 \\neq 0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">02 <span class="math">\\tilde{\\mathbf{Z}} \\overset{\\</span>}{\\leftarrow} Q$</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Q := Q \\cup \\{\\mathbf{Z}&#x27;\\}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">os Obtain <span class="math">b_1, b_2, b_3</span> as described</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">08 Return 0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">o4 Return <span class="math">(\\widetilde{\\mathbf{Z}}X^{-b_1},b_2,b_3,0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">og Return <span class="math">(\\mathbf{Z}&#x27; = \\mathbf{X}^{b_1})</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 23: Behavior of adversary  <span class="math">C_{\\mathsf{alg}}</span> .</p>

    <p class="text-gray-300"><span class="math">C_{alg}</span>  is depicted in Figure 23.</p>

    <p class="text-gray-300">We now analyze  <span class="math">C_{alg}</span> . Clearly,  <span class="math">E_{alg}</span>  runs in the same time as  <span class="math">A_{alg}</span> . Once  <span class="math">A_{alg}</span>  halts,  <span class="math">C_{alg}</span>  picks at random  <span class="math">\\hat{\\mathbf{Z}}</span>  that was input by  <span class="math">A_{\\mathsf{alg}}</span>  as one of at most q queries to  <span class="math">\\mathsf{O}(\\cdot,\\cdot)</span>  along with  <span class="math">\\hat{\\mathbf{Y}}</span>  and  <span class="math">\\hat{b},\\hat{c}</span> such that  <span class="math">b_2 \\neq 0 \\lor b_3 \\neq 0</span> , and</p>

    <p class="text-gray-300">$$\\tilde{\\mathbf{Y}} = g^{b_1} \\mathbf{X}^{b_2} \\mathbf{Y}^{b_3},
\\tilde{\\mathbf{Z}} = g^{c_1} \\mathbf{X}^{c_2} \\mathbf{Y}^{c_3}.$$</p>

    <p class="text-gray-300">Clearly, if  <span class="math">(\\tilde{\\mathbf{Y}})^x = \\tilde{\\mathbf{Z}}</span>  then  <span class="math">(\\tilde{\\mathbf{Z}}\\mathbf{X}^{-b_1}, b_2, b_3, 0)</span>  yields a winning solution for  <span class="math">\\mathbf{lc}\\text{-}\\mathbf{dh}_G^{\\mathsf{C}_{\\mathsf{alg}}}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\tilde{\\mathbf{Z}}\\mathbf{X}^{-b_1} = (\\tilde{\\mathbf{Y}})^x \\mathbf{X}^{-b_1} = g^{b_2 x^2 + b_3 xy}.</span>$</p>

    <p class="text-gray-300">As  <span class="math">C_{alg}</span>  picks  <span class="math">\\tilde{\\mathbf{Z}}</span>  at random from at most q elements in Q, it picks a correct solution with probability at least  <span class="math">\\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\text{-}\\mathbf{dh}} \\geq \\frac{\\Pr[F]}{q}</span> . This yields  <span class="math">\\Pr[F] \\leq q \\cdot \\mathbf{Adv}_{\\mathcal{G},\\mathsf{C}_{\\mathsf{alg}}}^{\\mathbf{lc}\\text{-}\\mathbf{dh}}</span> ). Thus, we now have</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}^{\\mathbf{cdh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} &amp;= &amp; \\Pr[\\mathbf{G_1} = 1] \\\\ &amp;\\geq &amp; \\Pr[\\mathbf{G_0} = 1] - |\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - \\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}| \\\\ &amp;\\geq &amp; \\mathbf{Adv}^{\\mathbf{sdh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} - q \\cdot \\mathbf{Adv}^{\\mathbf{lc\\text{-}dh}}_{\\mathcal{G},\\mathsf{Calg}}. \\end{split}</span>$</p>

    <p class="text-gray-300">It is straight forward to see that all the steps performed in the above simulations are generic. This proves (20).</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Proof of Theorem 4.1 A.2</h4>

    <p class="text-gray-300"><em>Proof.</em> We prove the statement via a sequence of games.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_0}</span> : Let  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  be an algebraic adversary playing in  <span class="math">\\mathbf{G_0} := \\mathbf{lrsw}_{\\mathcal{G}}^{\\mathsf{A}_{\\mathsf{alg}}}</span> . Game  <span class="math">\\mathbf{G_0}</span>  is depicted in Figures 24. As  <span class="math">A_{alg}</span>  is an algebraic adversary, at the end of the game, it outputs a winning tuple  <span class="math">(m^*, \\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*)</span>  along with vectors  <span class="math">\\vec{a}, \\vec{b}, \\vec{c}</span>  that provide the representation of  <span class="math">\\mathbf{A}^*, \\mathbf{B}^*, \\mathbf{C}^*</span>  relative to  <span class="math">g, \\mathbf{X}, \\mathbf{Y}</span>  and the answers  <span class="math">\\mathbf{A}_1, ..., \\mathbf{A}_q, \\mathbf{B}_1, ..., \\mathbf{B}_q, \\mathbf{C}_1, ..., \\mathbf{C}_q</span>  from previous oracle queries, where  <span class="math">\\mathbf{A}_{i} = g^{r_{i}}, \\ \\mathbf{B}_{i} = g^{r_{i}y}, \\ \\text{and} \\ \\mathbf{C}_{i} = g^{r_{i}(yxm_{i}+x)}.</span></p>

    <p class="text-gray-300">Concretely, the representations of  <span class="math">A^*</span> ,  <span class="math">B^*</span> , and  <span class="math">C^*</span>  are as follows:</p>

    <p class="text-gray-300">
<span class="math">$\\mathbf{A}^{*} = \\prod_{i=1}^{q} \\mathbf{A}_{i}^{a_{i}} g^{a_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{a_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{a_{i}} \\mathbf{X}^{a_{3q+2}} \\mathbf{Y}^{a_{3q+3}},</span>$
(21)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{B}^{*} = \\prod_{i=1}^{q} \\mathbf{A}_{i}^{b_{i}} g^{b_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{b_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{b_{i}} \\mathbf{X}^{b_{3q+2}} \\mathbf{Y}^{b_{3q+3}},</span>$
(22)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^{*} = \\prod_{i=1}^{q} \\mathbf{C}_{i}^{c_{i}} \\mathbf{X}^{c_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{A}_{i-q-1}^{c_{i}} \\prod_{i=2q+2}^{3q+1} \\mathbf{B}_{i-2q-1}^{c_{i}} g^{c_{3q+2}} \\mathbf{Y}^{c_{3q+3}}.</span>$
(23)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{B}^* = \\prod_{i=1}^{q} \\mathbf{A}_i^{b_i} g^{b_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{B}_{i-q-1}^{b_i} \\prod_{i=2q+2}^{3q+1} \\mathbf{C}_{i-2q-1}^{b_i} \\mathbf{X}^{b_{3q+2}} \\mathbf{Y}^{b_{3q+3}},</span>$
(22)</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^* = \\prod_{i=1}^{q} \\mathbf{C}_i^{c_i} \\mathbf{X}^{c_{q+1}} \\prod_{i=q+2}^{2q+1} \\mathbf{A}_{i-q-1}^{c_i} \\prod_{i=2q+2}^{3q+1} \\mathbf{B}_{i-2q-1}^{c_i} g^{c_{3q+2}} \\mathbf{Y}^{c_{3q+3}}.</span>$
(23)</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|c} \\mathbf{G_{0}}, \\boxed{\\mathbf{G_{1}}} \\\\ \\hline 00 &amp; \\ell^{*}, k^{*}, i^{*} \\overset{\\</span>}{\\leftarrow} {1, ..., q} \\ \\hline 01 &amp; \\mathbf{If } k^{<em>} = \\ell^{</em>} \\vee k^{<em>} = i^{</em>} \\vee \\ell^{<em>} = i^{</em>} \\ \\hline 02 &amp; \\mathbf{Abort} \\ \\hline 03 &amp; Q := \\emptyset \\ \\hline 04 &amp; x, y \\overset{$}{\\leftarrow} \\mathbb{Z}<em>{p} \\ \\hline 05 &amp; \\mathbf{X} := g^{x}, \\mathbf{Y} := g^{y} \\ \\hline 06 &amp; (m^{*}, [\\mathbf{A}^{*}]</em>{\\vec{a}}, [\\mathbf{B}^{<em>}]_{\\vec{b}}, [\\mathbf{C}^{</em>}]<em>{\\vec{c}}) \\overset{$}{\\leftarrow} \\mathbf{A}</em>{\\mathsf{alg}}^{\\mathsf{O}(\\cdot)}(\\mathbf{X}, \\mathbf{Y}) \\ \\hline 07 &amp; \\mathbf{Return } m^{<em>} \\notin Q \\wedge m^{</em>} \\neq 0 \\ &amp; \\wedge \\mathbf{A}^{<em>} \\neq 1 \\wedge \\mathbf{B}^{</em>} = (\\mathbf{A}^{<em>})^{y} \\wedge \\mathbf{C}^{</em>} = (\\mathbf{A}^{<em>})^{xm^{</em>}y + x} \\ \\hline \\end{array}$$</p>

    <p class="text-gray-300">Figure 24: Games  <span class="math">G_0</span>  and  <span class="math">G_1</span>  with algebraic adversary  <span class="math">A_{alg}</span> . The boxed statements are only executed in  <span class="math">G_1</span> .</p>

    <p class="text-gray-300">We assume that  <span class="math">A_{alg}</span>  never queries the oracle on the same message  <span class="math">m_i</span>  more than once. (Multiple queries can be simulated by rerandomization.)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G_1}</span> : In  <span class="math">\\mathbf{G_1}</span>  we consider a slightly altered game that is defined as follows. Before the first query is asked, the challenger in  <span class="math">\\mathbf{G_1}</span>  also chooses values  <span class="math">k^*, \\ell^*, i^* \\overset{\\</span>}{\\leftarrow} {1, ..., q}$ . If  <span class="math">k^* = \\ell^* \\vee k^* = i^* \\vee \\ell^* = i^*</span> , it aborts the game.  <span class="math">\\mathbf{G_1}</span>  is depicted in Figure 24. Clearly,  <span class="math">\\left(1-\\frac{3}{q}\\right)\\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G_0}} = \\mathbf{Adv}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}^{\\mathbf{G_1}}</span> . By defining  <span class="math">s_1, s_2, t_1, t_2, u_1, u_2, v_1, v_2 \\in \\mathbb{Z}_p</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} s_1 &amp;\\coloneqq a_{3q+2} + \\sum_{i=2q+3}^{3q+2} a_i r_{i-2q-2}, &amp; s_2 &amp;\\coloneqq c_{q+1} + \\sum_{i=1}^q c_i r_i, \\\\ t_1 &amp;\\coloneqq \\sum_{i=2q+3}^{3q+2} a_i m_i r_{i-2q-2}, &amp; t_2 &amp;\\coloneqq \\sum_{i=1}^q c_i m_i r_i, \\\\ u_1 &amp;\\coloneqq a_{3q+3} + \\sum_{i=q+2}^{2q+1} a_i r_{i-q-1}, &amp; u_2 &amp;\\coloneqq c_{3q+3} + \\sum_{i=2q+2}^{3q+1} c_i r_{i-q-1}, \\\\ v_1 &amp;\\coloneqq g^{a_{q+1}} + \\sum_{i=1}^q a_i r_i, &amp; v_2 &amp;\\coloneqq g^{c_{3q+2}} + \\sum_{i=q+2}^{2q+1} c_i r_{i-q-1}, \\end{split}</span>$</p>

    <p class="text-gray-300">equations (21) and (23) can be further simplified to</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{rcl} \\mathbf{A}^* &amp; = &amp; g^{s_1x + t_1xy + u_1y + v_1} \\\\ \\mathbf{C}^* &amp; = &amp; g^{s_2x + t_2xy + u_2y + v_2} \\end{array}</span>$</p>

    <p class="text-gray-300">We also define the parameters  <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span>  as</p>

    <p class="text-gray-300">
<span class="math">$\\Delta := m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1, \\tag{24}</span>$</p>

    <p class="text-gray-300">$$\\Delta := m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1,
\\Delta' := u_1 m^* y^2 + m^* y v_1 + u_1 y - t_2 y - s_2 + v_1,$$
(24)</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; := u_2 y + v_2, \\tag{26}</span>$</p>

    <p class="text-gray-300">and the boolean variable  <span class="math">F^*</span>  as</p>

    <p class="text-gray-300">
<span class="math">$F^* = 1 \\Leftrightarrow s_1 \\equiv_p t_1 \\equiv_p u_1 \\equiv_p u_2 \\equiv_p 0. \\tag{27}</span>$</p>

    <p class="text-gray-300">We prove the following lemma that allows us to rewrite  <span class="math">A^*</span>  and  <span class="math">C^*</span>  in a more convenient form.</p>

    <p class="text-gray-300"><strong>Lemma A.1</strong> <em>If F</em> <sup>&lowast;</sup> = 1<em>, then</em></p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = \\prod_{i=1}^q \\mathbf{A}_i^{\\varepsilon_i}, \\quad \\mathbf{C}^* = \\prod_{i=1}^q \\mathbf{C}_i^{\\delta_i}</span>$</p>

    <p class="text-gray-300"><em>holds for</em></p>

    <p class="text-gray-300"><span class="math">$\\delta_i := \\begin{cases} c_i &amp; i \\notin \\{k^*, \\ell^*\\} \\\\ c_{\\ell^*} - \\frac{r_{k^*} m_{k^*} c_{q+1}}{(r_{\\ell^*} m_{\\ell^*})(r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}})} &amp; i = \\ell^* \\\\ c_{k^*} + \\frac{c_{q+1}}{r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}}} &amp; i = k^* \\end{cases}</span>$</p>

    <p class="text-gray-300"><em>and</em></p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_i := \\begin{cases} a_i &amp; i \\neq k^* \\\\ a_{k^*} + \\frac{a_{q+1}}{r_{k^*}} &amp; i = k^* \\end{cases}.</span>$</p>

    <p class="text-gray-300">Using Lemma <a href="#page-31-0">A.1,</a> we can now formulate the following conditions whenever <strong>G<sup>1</sup></strong> does not abort. To further simplify the notation, we define the following Boolean variables:</p>

    <p class="text-gray-300"><span class="math">$G^* = 1 \\Leftrightarrow \\Delta \\not\\equiv_p 0 \\lor \\Delta&#x27; \\not\\equiv_p 0 \\lor \\Delta&#x27;&#x27; \\not\\equiv_p 0</span>$</p>

    <p class="text-gray-300"><span class="math">$H^* := 1 \\Leftrightarrow \\forall j \\not\\in \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">Note that <em>H</em><sup>&lowast;</sup> is only well defined (by Lemma <a href="#page-31-0">A.1)</a> if <em>F</em> <sup>&lowast;</sup> = 1.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Condition <em>F</em><sup>1</sup> : This condition holds iff <em>G</em><sup>&lowast;</sup> <em>.</em></li>
      <li>Condition <em>F</em><sup>2</sup> : This condition holds iff (&not;<em>G</em><sup>&lowast;</sup> &and; &not;<em>F</em> &lowast; ) &or; (<em>F</em> <sup>&lowast;</sup> &and; <em>H</em><sup>&lowast;</sup> )<em>.</em></li>
      <li>Condition <em>F</em><sup>3</sup> : This condition holds iff <em>F</em> <sup>&lowast;</sup> &and; &not;<em>H</em><sup>&lowast;</sup> <em>.</em></li>
    </ul>

    <p class="text-gray-300">It is easy to see that <em>F</em><sup>1</sup> &or; <em>F</em><sup>2</sup> &or; <em>F</em><sup>3</sup> = 1<em>.</em> We will now describe the behavior of adversaries Calg<em>,</em> Dalg<em>,</em> Ealg playing in the discrete logarithm game. Each of these adversaries simulates <strong>G<sup>1</sup></strong> to Aalg in a different way. Concretely, we prove the following Lemma.</p>

    <p class="text-gray-300"><strong>Lemma A.2</strong> <em>There exist</em> Calg<em>,</em> Dalg<em>,</em> Ealg <em>playing in the discrete logarithm game such that:</em></p>

    <p class="text-gray-300">
<span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{C}_{\\mathsf{alg}}} = 1\\right] = \\Pr\\left[\\mathbf{G_1} = 1 \\mid F_1\\right] \\tag{28}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{D}_{\\mathsf{alg}}} = 1\\right] \\geq (1 - \\frac{2}{q})\\Pr\\left[\\mathbf{G_1} = 1 \\mid F_2\\right]</span>$
(29)</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{dlog}^{\\mathsf{E}_{\\mathsf{alg}}} = 1\\right] \\geq \\frac{1}{q}\\Pr[\\mathbf{G}_1 = 1 \\mid F_3]. \\tag{30}</span>$</p>

    <p class="text-gray-300"><em>of Lemma <a href="#page-31-0">A.1.</a></em> We first note that <em>&delta;<sup>l</sup></em> <sup>&lowast;</sup> <em>, &delta;<sup>k</sup></em> <sup>&lowast;</sup> are well defined, because *<code>* &lt;sup&gt;&lowast;&lt;/sup&gt; =6 *k* &lt;sup&gt;&lowast;&lt;/sup&gt; and thus *m</code>* <sup>&lowast;</sup> 6= <em>m<sup>k</sup></em> &lowast; . Otherwise <strong>G<sup>1</sup></strong> aborts and there is nothing to prove (since nothing is returned by Aalg in this case). Observe that since <em>F</em> <sup>&lowast;</sup> = 1 &hArr; <em>s</em><sup>1</sup> &equiv;<em><sup>p</sup> t</em><sup>1</sup> &equiv;<em><sup>p</sup> u</em><sup>1</sup> &equiv;<em><sup>p</sup> u</em><sup>2</sup> &equiv;<em><sup>p</sup> v</em><sup>2</sup> &equiv;<em><sup>p</sup></em> 0<em>,</em> we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = g^{a_{q+1}} \\prod_{i=1}^q \\mathbf{A}_i^{a_i} \\quad \\text{and} \\quad \\mathbf{C}^* = \\mathbf{X}^{c_{q+1}} \\prod_{i=1}^q \\mathbf{C}_i^{c_i}.</span>$</p>

    <p class="text-gray-300">Now, the choices of <em>&delta;</em>1<em>, ..., &delta;q,</em> 1<em>, ..., <sup>q</sup></em> satisfy</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = \\prod_{i=1}^q \\mathbf{A}_i^{\\epsilon_i}</span>$
and  <span class="math">\\mathbf{C}^* = \\prod_{i=1}^q \\mathbf{C}_i^{\\delta_i}</span> .</p>

    <p class="text-gray-300">To see this, first observe that X can be written as</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X} = \\left(\\mathbf{X}^{r_{k}*(1-m_{k}*/m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\left(g^{r_{k}*(x+yxm_{k}*)}g^{-r_{\\ell}*(x+yxm_{\\ell}*)(r_{k}*m_{k}*)/(r_{\\ell}*m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\left(\\mathbf{C}_{k}^{*}\\mathbf{C}_{\\ell^{*}}^{-(r_{k}*m_{k}*)/(r_{\\ell}*m_{\\ell}*)}\\right)^{\\frac{1}{r_{k}*(1-m_{k}*/m_{\\ell}*)}}.</span>$</p>

    <p class="text-gray-300">Because of this, setting</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\delta_{k^*} &amp;:= c_{k^*} + \\frac{c_{q+1}}{r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}}}, \\\\ \\delta_{\\ell^*} &amp;:= c_{\\ell^*} - \\frac{r_{k^*} m_{k^*} c_{q+1}}{(r_{\\ell^*} m_{\\ell^*}) (r_{k^*} - r_{k^*} \\frac{m_{k^*}}{m_{\\ell^*}})}, \\end{split}</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\delta_i := c_i</span>  for  <span class="math">i \\notin \\{\\ell^*, k^*\\}</span>  we obtain</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}^{c_{q+1}}\\mathbf{C}_{k^*}^{c_{k^*}}\\mathbf{C}_{\\ell^*}^{c_{\\ell^*}} = \\mathbf{C}_{k^*}^{c_{k^*}}\\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}\\left(\\mathbf{C}_{k^*}\\mathbf{C}_{\\ell^*}^{-(r_{k^*}m_{k^*})/(r_{\\ell^*}m_{\\ell^*})}\\right)^{\\frac{c_{q+1}}{r_{k^*}(1-m_{k^*}/m_{\\ell^*})}} = \\mathbf{C}_{k^*}^{\\delta_{k^*}}\\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}}.</span>$</p>

    <p class="text-gray-300">This means that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X}^{c_{q+1}} \\prod_{i} \\mathbf{C}_{i}^{c_{i}} = (\\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^{*}}^{c_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{c_{\\ell^{*}}}) \\prod_{i \\neq k^{*} \\ell^{*}} \\mathbf{C}_{i}^{c_{i}} = \\mathbf{C}_{k^{*}}^{\\delta_{k^{*}}} \\mathbf{C}_{\\ell^{*}}^{\\delta_{\\ell^{*}}} \\prod_{i \\neq k^{*} \\ell^{*}} \\mathbf{C}_{i}^{\\delta_{i}} = \\prod_{i} \\mathbf{C}_{i}^{\\delta_{i}}.</span>$</p>

    <p class="text-gray-300">Also observe that  <span class="math">\\mathbf{A}_{k^*}^{\\epsilon_{k^*}} = \\mathbf{A}_{k^*}^{a_{k^*}} g^{a_{q+1}}</span>  and thus</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}^* = g^{a_{q+1}} \\prod_i \\mathbf{A}_i^{a_i} = \\prod_i \\mathbf{A}_i^{\\epsilon_i}.</span>$</p>

    <p class="text-gray-300">Using Lemma A.2 and the fact that  <span class="math">F_1 \\vee F_2 \\vee F_3 = 1</span> , it is now straightforward to construct an adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\Big[\\mathbf{dlog}^{\\mathsf{B}_{\\mathsf{alg}}} = 1\\Big] \\geq \\frac{1}{3q}\\Pr[\\mathbf{G_1} = 1]</span>$</p>

    <p class="text-gray-300">by letting  <span class="math">B_{alg}</span>  emulate one of the adversaries  <span class="math">C_{alg}</span> ,  <span class="math">D_{alg}</span> ,  <span class="math">E_{alg}</span>  (chosen uniformly at random).</p>

    <p class="text-gray-300">of Lemma A.2. Let  <span class="math">\\mathbf{Z}=g^z</span>  denote the discrete logarithm instance.  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}, \\mathsf{E}_{\\mathsf{alg}}</span>  simulate  <span class="math">\\mathbf{G_1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . They begin by sampling  <span class="math">k^*, \\ell^*, i^* \\overset{\\</span>}{\\leftarrow} {1, ..., q}$ . If  <span class="math">k^* = \\ell^* \\vee k^* = i^* \\vee \\ell^* = i^*</span> , they abort the simulation. Thus, assume throughout the proof that  <span class="math">k^* \\neq \\ell^*, k^* \\neq i^*, \\ell^* \\neq i^*</span></p>

    <p class="text-gray-300"><strong>Adversary</strong>  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span> . Adversary  <span class="math">\\mathsf{C}_{\\mathsf{alg}}</span>  samples  <span class="math">\\alpha \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (\\mathbf{Z}, g^{\\alpha})</span> . This implicitly sets x = z and  <span class="math">y = \\alpha</span> . Recall that</p>

    <p class="text-gray-300"><span class="math">$F_1 = 1 \\Leftrightarrow \\Delta \\not\\equiv_p 0 \\lor \\Delta&#x27; \\not\\equiv_p 0 \\lor \\Delta&#x27;&#x27; \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">We now analyze  <span class="math">C_{alg}</span> . Suppose  <span class="math">A_{alg}</span>  wins  <span class="math">G_1</span>  given that  <span class="math">F_1 = 1</span> . Then  <span class="math">C^* = (\\mathbf{A}^*)^{x+m^*xy}</span>  which is equivalent to</p>

    <p class="text-gray-300">
<span class="math">$x^2 \\Delta + x \\Delta&#x27; - \\Delta&#x27;&#x27; \\equiv_p 0 \\tag{31}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\Delta, \\Delta&#x27;, \\Delta&#x27;&#x27;</span>  are defined in (24)-(26). Quadratic equation (31) in indeterminate x has exactly two (possibly equal) solutions, say  <span class="math">x_1</span>  and  <span class="math">x_2</span> , that can be computed efficiently by  <span class="math">C_{alg}</span> . One of them has to be equal to z = x, which one can be tested by comparing  <span class="math">g^{x_i}</span>  to  <span class="math">\\mathbf{Z}</span> . This proves equation (28).</p>

    <pre><code class="language-text">\\begin{array}{ll}
</code></pre>

    <p class="text-gray-300">Figure 25: Behavior of adversary C<sub>alg</sub>.</p>

    <pre><code class="language-text">\\begin{array}{ll} \\mathsf{D}_{\\mathsf{alg}}(\\mathbf{Z} = g^z) &amp; \\mathsf{O}(m_j) : \\ //For \\ query \\ j \\\\ \\mathsf{00} \\ \\ Q := \\emptyset &amp; \\mathsf{05} \\ \\ r_j \\overset{\\$}{\\sim} \\mathbb{Z}_p; \\\\ \\mathsf{01} \\ \\ \\alpha \\overset{\\$}{\\sim} \\mathbb{Z}_p &amp; \\mathsf{06} \\ \\ \\mathbf{A}_j := g^{r_j} \\\\ \\mathsf{02} \\ \\ (m^*, [\\mathbf{A}^*]_{\\vec{a}}, [\\mathbf{B}^*]_{\\vec{b}}, [\\mathbf{C}^*]_{\\vec{c}}) \\overset{\\$}{\\sim} \\mathsf{A}_{\\mathsf{alg}}^{\\mathsf{O}(\\cdot)}(g^\\alpha, \\mathbf{Z}) \\\\ \\mathsf{03} \\ \\ \\mathsf{Compute} \\ \\ y \\ \\ \\mathsf{as} \\ \\ \\mathsf{described} \\ \\ \\mathsf{below} \\\\ \\mathsf{04} \\ \\ \\mathsf{Return} \\ \\ y &amp; \\mathsf{09} \\ \\ Q := \\mathbf{Q} \\cup \\{m_j\\} \\\\ \\mathsf{10} \\ \\ \\mathsf{Return} \\ \\ (\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{C}_j) \\end{array}
</code></pre>

    <p class="text-gray-300">Figure 26: Behaviour of Dalg.</p>

    <p class="text-gray-300">Adversary  <span class="math">D_{\\mathsf{alg}}</span> : Adversary  <span class="math">D_{\\mathsf{alg}}</span>  does the following. It samples  <span class="math">\\alpha \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}_p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, \\mathbf{Z})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and y = z. Recall that  <span class="math">F_2 = 1</span>  iff</p>

    <p class="text-gray-300"><span class="math">$\\neg F^* \\wedge \\neg (\\Delta \\not\\equiv_p 0 \\vee \\Delta&#x27; \\not\\equiv_p 0 \\vee \\Delta&#x27;&#x27; \\not\\equiv_p 0) \\vee F^* \\wedge \\forall j \\not\\in \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">where  <span class="math">F^*</span>  is defined in (27).</p>

    <p class="text-gray-300">We analyze and describe  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span> . Suppose that  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  wins  <span class="math">\\mathsf{G}_1</span>  given that  <span class="math">F_2=1</span> . As before, we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}^* = (\\mathbf{A}^*)^{x+m^*xy} \\Leftrightarrow x^2 \\Delta + x \\Delta&#x27; - \\Delta&#x27;&#x27; \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\Delta \\equiv_p \\Delta&#x27; \\equiv_p \\Delta&#x27;&#x27; \\equiv_p 0 \\land \\neg F^*</span>  then  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can efficiently solve one of the equations</p>

    <p class="text-gray-300"><span class="math">$\\Delta \\equiv_p 0,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27; \\equiv_p 0,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; \\equiv_p 0.</span>$</p>

    <p class="text-gray-300">in indeterminate y = z. This can be seen as follows.</p>

    <p class="text-gray-300">&bull; If  <span class="math">s_1 \\not\\equiv_p 0 \\lor t_1 \\not\\equiv_p 0</span> , it can solve the quadratic equation</p>

    <p class="text-gray-300"><span class="math">$\\Delta \\equiv_p m^* t_1 y^2 + t_1 y + s_1 m^* y + s_1 \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">because  <span class="math">m^* \\not\\equiv_p 0</span>  by assumption.</p>

    <p class="text-gray-300">&bull; If  <span class="math">u_1 \\not\\equiv_p 0</span> , it can solve the quadratic equation</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27; \\equiv_p u_1 m^* y^2 + m^* y v_1 - t_2 y + u_1 y + v_1 - s_2 \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">where again we use the fact that  <span class="math">m^* \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">&bull; If  <span class="math">v_2 \\not\\equiv_p 0</span> , then since</p>

    <p class="text-gray-300"><span class="math">$\\Delta&#x27;&#x27; \\equiv_p v_2 + u_2 y \\equiv_p 0,</span>$</p>

    <p class="text-gray-300">also  <span class="math">u_2 \\not\\equiv_p 0</span>  and so  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can solve for y the equation</p>

    <p class="text-gray-300"><span class="math">$v_2 + u_2 y \\equiv_p 0</span>$</p>

    <p class="text-gray-300">whenever  <span class="math">v_2 \\not\\equiv_p 0 \\lor u_2 \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">Given two possible solutions  <span class="math">y_1, y_2</span>  for a quadratic equation,  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can determine the correct one by comparing  <span class="math">g^{y_i}</span>  to  <span class="math">\\mathbf{Z}</span> .</p>

    <p class="text-gray-300">If  <span class="math">F^* = 1</span> , Lemma A.1 guarantees that  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  can efficiently compute parameters  <span class="math">\\delta_1, ..., \\delta_q, \\varepsilon_1, ..., \\varepsilon_q</span>  such that  <span class="math">\\mathbf{A}^* = \\prod_i \\mathbf{A}_i^{\\varepsilon_i}, \\mathbf{C}^* = \\prod_i \\mathbf{C}_i^{\\delta_i}</span> . We distinguish two cases.</p>

    <p class="text-gray-300">&bull; Case 1:  <span class="math">\\exists j \\notin \\{\\ell^*, k^*\\} : \\varepsilon_j \\not\\equiv_p 0 \\lor \\delta_j \\not\\equiv_p 0</span> . Without loss of generality, assume that  <span class="math">\\varepsilon_j \\not\\equiv_p 0</span> . Since</p>

    <p class="text-gray-300"><span class="math">$\\forall j \\notin \\{\\ell^*, k^*\\} : r_i \\varepsilon_j (1 + m^* y) - r_i \\delta_j (1 + y m_j) \\equiv_p 0, \\tag{32}</span>$</p>

    <p class="text-gray-300"><span class="math">D_{alg}</span>  solves the equation</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\delta_j}{\\varepsilon_j} - 1 \\equiv_p y \\left( m^* - m_j \\frac{\\delta_j}{\\varepsilon_j} \\right)</span>$</p>

    <p class="text-gray-300">for y, which is obtained from rearranging terms in (32). This equation has a unique solution for y, and its coefficient can not become zero; this would imply that  <span class="math">m^* \\equiv_p m_j</span> , a contradiction.</p>

    <p class="text-gray-300">&bull; Case 2:  <span class="math">\\forall j \\notin \\{\\ell^*, k^*\\} : \\varepsilon_j \\equiv_p \\delta_j \\equiv_p 0</span> . This means that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{A}^* &amp;= \\mathbf{A}_{\\ell^*}^{\\varepsilon_{\\ell^*}} \\mathbf{A}_{k^*}^{\\varepsilon_{k^*}} = g^{a_{q+1}} \\mathbf{A}_{k^*}^{a_{k^*}} \\mathbf{A}_{\\ell^*}^{a_{\\ell^*}}, \\\\ \\mathbf{C}^* &amp;= \\mathbf{C}_{k^*}^{\\delta_{k^*}} \\mathbf{C}_{\\ell^*}^{\\delta_{\\ell^*}} = \\mathbf{X}^{c_{q+1}} \\mathbf{C}_{k^*}^{c_{k^*}} \\mathbf{C}_{\\ell^*}^{c_{\\ell^*}}. \\end{split}</span>$</p>

    <p class="text-gray-300">If  <span class="math">a_{\\ell^*} \\equiv_p a_{k^*} \\equiv_p c_{k^*} \\equiv_p c_{\\ell^*} \\equiv_p 0</span> , then  <span class="math">\\mathbf{A}^* = g^{a_{q+1}}, \\mathbf{C}^* = \\mathbf{X}^{c_{q+1}}</span>  and therefore</p>

    <p class="text-gray-300"><span class="math">$c_{q+1} - a_{q+1} \\equiv_p ym^* a_{q+1}.</span>$</p>

    <p class="text-gray-300">Again, this equation has a unique solution for y and its coefficient can not become zero, because  <span class="math">a_{q+1} \\not\\equiv_p 0</span>  (recall that  <span class="math">\\mathbf{A}^* \\not\\equiv_p 1</span> ) and  <span class="math">m^* \\not\\equiv_p 0</span> .</p>

    <p class="text-gray-300">Finally, we note that with probability at most  <span class="math">\\frac{2}{q-1}</span> ,  <span class="math">A_{\\mathsf{alg}}</span>  succeeds in setting</p>

    <p class="text-gray-300"><span class="math">$(a_{\\ell^*} \\not\\equiv_p 0 \\lor a_{k^*} \\not\\equiv_p 0 \\lor c_{k^*} \\not\\equiv_p 0 \\lor c_{\\ell^*} \\not\\equiv_p 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\land (\\forall j \\not\\in \\{\\ell^*, k^*\\} : \\varepsilon_j \\equiv_p a_j \\equiv_p c_j \\equiv_p \\delta_j \\equiv_p 0).</span>$</p>

    <p class="text-gray-300">This argument is true, because the indices  <span class="math">\\ell^*</span> ,  <span class="math">k^*</span>  are information theoretically hidden from  <span class="math">\\mathsf{A}&#x27;_{\\mathsf{alg}}s</span>  view and so it guesses either of them with probability at most  <span class="math">\\frac{2}{q-1}</span> . All in all,  <span class="math">\\mathsf{D}_{\\mathsf{alg}}</span>  succeeds in computing y with probability at least  <span class="math">1-\\frac{2}{q-1}</span> . This proves equation (29).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{c} \\overline{E_{alg}(\\mathbf{Z}=g^z)} \\\\ \\hline 00 \\ Q := \\emptyset \\\\ 01 \\ \\alpha, \\beta \\overset{\\</span>}{\\leftarrow} \\mathbb{Z}<em>p \\ 02 \\ (m^*, [\\mathbf{A}^*]</em>{\\vec{a}}, [\\mathbf{B}^<em>]_{\\vec{b}}, [\\mathbf{C}^</em>]<em>{\\vec{c}}) \\overset{$}{\\leftarrow} A</em>{alg}^{O(\\cdot)}(g^\\alpha, g^\\beta) \\ 03 \\ Compute \\ z \\ as \\ described \\ below \\ 04 \\ Return \\ z \\end{array}$</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\underline{O}(m_{j}): //For \\ query \\ j $ $ 05 \\ b := (j = i^{*}) $ $ 06 \\ r'<em>{j} \\stackrel{$}{\\leftarrow} \\mathbb{Z}</em>{p}; $ $ 07 \\ \\mathbf{A}<em>{j} := g^{z^{b}r'</em>{j}} $ $ 08 \\ \\mathbf{B}<em>{j} := g^{z^{b}\\beta r'</em>{j}} $ $ 09 \\ \\mathbf{C}<em>{j} := g^{z^{b}r'</em>{j}m_{j}\\beta\\alpha}g^{z^{b}\\alpha r'_{j}} $</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 <span class="math">Q := g \\cup \\{m_j\\}</span><br>11 Return <span class="math">(\\mathbf{A}_j, \\mathbf{B}_j, \\mathbf{C}_j)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 27: Behaviour of E<sub>alg</sub>.</p>

    <p class="text-gray-300">Adversary  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span> : To simulate  <span class="math">\\mathbf{G_1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> , the adversary  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  does the following. It samples  <span class="math">\\alpha, \\beta \\overset{\\hspace{0.1em}\\mathsf{\\scriptscriptstyle\\</span>}}{\\leftarrow} \\mathbb{Z}<em>p$  and computes  <span class="math">(\\mathbf{X}, \\mathbf{Y}) = (g^{\\alpha}, g^{\\beta})</span> . This implicitly sets  <span class="math">x = \\alpha</span>  and  <span class="math">y = \\beta</span> . It embeds z into the answer to the  <span class="math">i^*</span> th oracle query as shown in Figure 27. We now analyze  $\\mathsf{E}</em>{\\mathsf{alg}}$ . If  <span class="math">F_3 = 1</span> , then</p>

    <p class="text-gray-300"><span class="math">$F^* \\wedge \\exists j \\notin \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">Lemma A.1 guarantees that  <span class="math">E_{alg}</span>  can efficiently compute the parameters</p>

    <p class="text-gray-300"><span class="math">$\\delta_1, ..., \\delta_q, \\varepsilon_1, ..., \\varepsilon_q</span>$</p>

    <p class="text-gray-300">such that  <span class="math">\\mathbf{A}^* = \\prod_i \\mathbf{A}_i^{\\varepsilon_i}, \\mathbf{C}^* = \\prod_i \\mathbf{C}_i^{\\delta_i}</span> . By assumption</p>

    <p class="text-gray-300"><span class="math">$\\exists j \\notin \\{\\ell^*, k^*\\} : r_j \\varepsilon_j (1 + m^* y) - r_j \\delta_j (1 + y m_j) \\not\\equiv_p 0.</span>$</p>

    <p class="text-gray-300">With probability  <span class="math">\\frac{1}{q}</span> ,  <span class="math">j = i^*</span> , because  <span class="math">i^*</span>  is information theoretically hidden from  <span class="math">A_{alg}</span>  and thus independent of its computation. This yields the equation</p>

    <p class="text-gray-300"><span class="math">$(\\prod_{i} g^{r_{i}\\varepsilon_{i}})^{x+m^{*}xy} = (\\prod_{i} \\mathbf{A}_{i}^{\\varepsilon_{i}})^{x+m^{*}xy} = (\\mathbf{A}^{*})^{(x+m^{*}xy)}</span>$
<span class="math">$= \\mathbf{C}^{*} = \\prod_{i} \\mathbf{C}_{i}^{\\delta_{i}} = \\prod_{i} g^{\\delta_{i}r_{i}(x+m_{i}yx)},</span>$</p>

    <p class="text-gray-300">which is equivalent to</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{i} r_{i} \\varepsilon_{i}\\right)(x + m^{*}xy) - \\sum_{i} r_{i} \\delta_{i}(x + m_{i}yx) \\equiv_{p} 0.</span>$</p>

    <p class="text-gray-300">Rearranging terms yields</p>

    <p class="text-gray-300"><span class="math">$z[r&#x27;_{i^*}\\varepsilon_{i^*}(1+m^*y)-r&#x27;_{i^*}\\delta_{i^*}(1+m_{i^*}y)] \\equiv_p \\sum_{i\\neq i^*} r_i\\delta_i(1+ym_i)-(\\sum_{i\\neq i^*} r_i\\varepsilon_i)(1+m^*y).</span>$</p>

    <p class="text-gray-300">By assumption, the coefficient of z in this expression is not zero. Therefore,  <span class="math">\\mathsf{E}_{\\mathsf{alg}}</span>  can efficiently solve the modular equation to obtain z. Putting things together, we obtain for the adversary  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  emulating one of  <span class="math">\\mathsf{C}_{\\mathsf{alg}}, \\mathsf{D}_{\\mathsf{alg}}, \\mathsf{E}_{\\mathsf{alg}}</span>  the following bound on the advantage  <span class="math">\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathsf{B}_{\\mathsf{alg}},\\mathcal{G}}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{dlog}}_{\\mathsf{B}_{\\mathsf{alg}},\\mathcal{G}} \\geq \\frac{1}{3q}\\mathbf{Adv}^{\\mathbf{G_1}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}} = \\frac{q-3}{3q^2}\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}} \\geq \\frac{1}{6q}\\mathbf{Adv}^{\\mathbf{G_0}}_{\\mathsf{A}_{\\mathsf{alg}},\\mathcal{G}},</span>$</p>

    <p class="text-gray-300">where the last inequality holds for  <span class="math">q \\geq 6</span> .</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Proof of Theroem 5.2</h3>

    <p class="text-gray-300"><em>Proof.</em> First note that given an adversary  <span class="math">A_{alg}</span>  against  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G}}</span>  one can easily construct an adversary  <span class="math">B_{alg}</span>  against  <span class="math">\\mathbf{ind}\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G}}</span> .  <span class="math">B_{alg}</span>  first calls  <span class="math">\\mathsf{Dec}(\\cdot)</span>  to compute the elements  <span class="math">(g^x,...,g^{x^q})</span> . When it is presented with a challenge  <span class="math">(\\mathbf{K}^*,\\mathbf{C}^*)</span> , it calls  <span class="math">A_{alg}</span>  on input  <span class="math">(g^x,...,g^{x^q},\\mathbf{C}^*,\\mathbf{K}^*)</span>  and then outputs  <span class="math">A_{alg}</span> 's output bit b'. Clearly,  <span class="math">(g^x,...,g^{x^q},\\mathbf{C}^*,\\mathbf{K}^*)</span>  is correctly distributed and therefore</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathbf{q\\text{-}ddh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} = \\mathbf{Adv}^{\\mathbf{ind\\text{-}cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}, \\quad \\mathbf{Time}^{\\mathbf{q\\text{-}ddh}}_{\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}} = \\mathbf{Time}^{\\mathbf{ind\\text{-}cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}}.</span>$</p>

    <p class="text-gray-300">For the converse, let  <span class="math">A_{alg}</span>  be an algebraic adversary playing in one of the games  <span class="math">ind\\text{-}cca1_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span>  ind- <span class="math">cca1_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span> . We construct an adversary  <span class="math">\\mathsf{B}_{alg}</span>  against  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}</span>  that interpolates between  <span class="math">ind\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},0}^{\\mathsf{A}_{alg}}</span>  and  <span class="math">ind\\text{-}\\mathbf{cca1}_{\\mathsf{EG},\\mathcal{G},1}^{\\mathsf{A}_{alg}}</span>  by simulating one of these games to  <span class="math">\\mathsf{A}_{alg}</span> .  <span class="math">\\mathsf{B}_{alg}</span>  is depicted in Figure 28.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\frac{B_{alg}(g, (\\mathbf{X}<em>i)</em>{i=1}^q, \\mathbf{R}, \\mathbf{Z})}{00 \\ \\mathbf{X} := g^x} \\ 01 \\ b' \\overset{$}{\\leftarrow} A_{alg}^{Dec(\\cdot), Enc}(\\mathbf{X}) \\ 02 \\ Return \\ b' $</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{\\text{Dec}([\\mathbf{C}]_{\\vec{c}})}{//\\text{Let this be the } i\\text{-th query}}</span> 03 Compute <span class="math">\\vec{a}</span> s.t. <span class="math">\\mathbf{C} = \\prod_{j=1}^{i} g^{a_j x^j}</span> 04 <span class="math">\\mathbf{K} := \\mathbf{C}^x = \\prod_{j=1}^{i} \\mathbf{X}_{j+1}^{a_j}</span> 05 Return <span class="math">\\mathbf{K}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\frac{Enc()}{o6} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ </span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">---------------------------------------------------------</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 28: Adversary B<sub>alg</sub> against <strong>q-ddh</strong>.</p>

    <p class="text-gray-300">Let  <span class="math">(g, \\mathbf{X}_1 = g^x, \\mathbf{X}_2 = g^{x^2}, \\dots, \\mathbf{X}_q = g^{x^q}, \\mathbf{R} = g^r, \\mathbf{Z} = g^{xr+zb})</span>  be the problem instance given to  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  in  <span class="math">\\mathbf{q}\\text{-}\\mathbf{ddh}_{\\mathcal{G},b}^{\\mathsf{B}_{\\mathsf{alg}}}</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  is algebraic, along with its  <span class="math">i\\text{-}\\mathsf{th}</span>  query  <span class="math">\\mathbf{C}</span>  to  <span class="math">\\mathsf{Dec}(\\cdot)</span>  it sends a vector  <span class="math">\\vec{c}</span>  such that  <span class="math">\\mathbf{C} = \\prod_i \\mathbf{L}_i^{c_i}</span>  where  <span class="math">\\vec{\\mathbf{L}}</span>  consists of group elements  <span class="math">g, \\mathbf{X}, \\mathbf{K}_1, \\dots, \\mathbf{K}_{i-1}</span> . Here,  <span class="math">\\mathbf{K}_1, \\dots, \\mathbf{K}_{i-1}</span>  denote the answers to the first i-1 queries asked to  <span class="math">\\mathsf{Dec}(\\cdot)</span> .</p>

    <p class="text-gray-300">Observe that given  <span class="math">\\vec{c}</span> ,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can express  <span class="math">\\mathbf{C}</span>  as  <span class="math">\\mathbf{C} = \\prod_{i \\geq j \\geq 0} g^{a_j x^j}</span> , for some known constants  <span class="math">a_j</span> . As  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  asks at most q-1 such queries,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  can answer them using the group elements  <span class="math">(g, g^x, g^{x^2}, ..., g^{x^q})</span>  from its instance. When  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  queries  <span class="math">\\mathsf{Enc}()</span> ,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  returns  <span class="math">(g^{xr+zb}, g^r)</span> . When  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span>  halts with output b',  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  returns b'. Clearly,  <span class="math">\\mathsf{B}_{\\mathsf{alg}}</span>  perfectly simulates either  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},0}</span>  or  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},1}</span>  to  <span class="math">\\mathsf{A}_{\\mathsf{alg}}</span> . Finally,  <span class="math">\\mathsf{ind}\\text{-}\\mathsf{cca1}^{\\mathsf{A}_{\\mathsf{alg}}}_{\\mathsf{EG},\\mathcal{G},b}</span>  returns 1 if and only if  <span class="math">\\mathsf{q}\\text{-}\\mathsf{ddh}^{\\mathsf{B}_{\\mathsf{alg}}}_{\\mathcal{G},b}</span>  returns 1. Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{q\\text{-}\\mathbf{ddh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Adv}^{ind\\text{-}\\mathbf{cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}, \\quad \\mathbf{Time}^{q\\text{-}\\mathbf{ddh}}_{\\mathcal{G},\\mathsf{B}_{\\mathsf{alg}}} = \\mathbf{Time}^{ind\\text{-}\\mathbf{cca1}}_{\\mathsf{EG},\\mathcal{G},\\mathsf{A}_{\\mathsf{alg}}}.</span>$</p>

    </section>
`;
---

<BaseLayout title="The Algebraic Group Model and its Applications (2017/620)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/620
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Algebraic Algorithms</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Algebraic Group Model</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Related Work and Open Questions</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Algebraic Algorithms</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Algebraic Security Games and Algorithms</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Generic Security Games and Algorithms</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Generic Reductions Between Algebraic Security Games</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">The Diffie-Hellman Assumption and Variants</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Computational Diffie-Hellman</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Strong Diffie-Hellman</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">The LRSW Assumption</a></li>
        <li><a href="#sec-5" class="hover:text-white">ElGamal Encryption</a></li>
        <li><a href="#sec-6" class="hover:text-white">Tight Reduction for the BLS Scheme</a></li>
        <li><a href="#sec-7" class="hover:text-white">Groth&#x27;s Near-Optimal zk-SNARK</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Deferred Proofs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Proof of Theorem 3.3</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Proof of Theroem 5.2</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-algebraic-group-model-and-its-applications-2017" />
  </article>
</BaseLayout>
