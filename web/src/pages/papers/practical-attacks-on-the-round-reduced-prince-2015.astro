---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/245';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Practical Attacks on the Round-reduced PRINCE';
const AUTHORS_HTML = 'Pawel Morawiecki';

const CONTENT = `    <p class="text-gray-300">Paweł Morawiecki [ Institute of Computer Science, Polish Academy of Sciences, Poland Section of Informatics, Kielce University of Commerce, Poland ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">The PRINCE cipher is the result of a cooperation between the Technical University of Denmark (DTU), NXP Semiconductors and the Ruhr University Bochum. The cipher was designed to reach an extremely low-latency encryption and instant response time. PRINCE has already gained a lot of attention from the academic community, however, most of the attacks are theoretical, usually with very high time or data complexity. Our work helps to fill the gap in more practically oriented attacks, with more realistic scenarios and complexities. We present new attacks, up to 7 rounds, relying on integral and higher-order differential cryptanalysis.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">PRINCE, lightweight cryptography, integral cryptanalysis, higher-order differential</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A need of low-cost cryptosystems for several fast-growing applications, such as RFID tags, sensor networks or Internet of Things, has drawn great attention to the area of lightweight cryptographic primitives over the last decade. It has been a vibrant research area, where a good trade-off between security and efficiency is a particularly challenging task. Some well established algorithms (e.g., AES<em>[5]</em>) may not meet the basic requirements of constrained devices — low cost hardware implementation, low power usage and latency.</p>

    <p class="text-gray-300">Recently, at Asiacrypt 2012 conference, a new lightweight block cipher called PRINCE has been proposed <em>[2]</em>. PRINCE is the result of a cooperation between the Technical University of Denmark (DTU), NXP Semiconductors and the Ruhr University Bochum. The cipher was designed to reach an extremely low-latency encryption and instant response time. These requirements are highly desirable for applications such as instant authentication or block-wise read/write access to memory devices, e.g., in solid-state hard disks.</p>

    <p class="text-gray-300">For PRINCE — a serious proposal with a clear motivation from industry — it is very important to estimate the security margin, particularly for practical settings, regarding a future deployment of the cipher. Too conservative design (e.g., too many rounds) might result in the algorithm below industry expectations. On the other hand, insufficient level of security will make the users and customers reluctant to deploy and use the algorithm.</p>

    <p class="text-gray-300">PRINCE has already gained a lot of attention from the academic community and some interesting cryptanalysis has been published <em>[3, 7, 10, 11]</em>. However, most of the attacks are theoretical, usually with very high time or data complexity. To spur on more practically oriented research, PRINCE designers launched ‘PRINCE challenge’ <em>[1]</em> — a competition where cryptanalysts are encouraged to find key recovery attacks with time complexity below <span class="math">2^{64}</span> and a number of plaintexts set to a more realistic scenario.</p>

    <p class="text-gray-300">Our contribution helps to fill the gap in the practical attacks on PRINCE, giving a better estimation of the security margin. Table 1 summarizes our results.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">Related work</h3>

    <p class="text-gray-300">As stated, most of published work on PRINCE are theoretical attacks. Though, there are a few attack with practical complexities. In <em>[7]</em>, the integral attack was described, up to 6 rounds.</p>

    <p class="text-gray-300">Table 1. Our key recovery attacks</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Technique</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">5·28</td>

            <td class="px-3 py-2 border-b border-gray-700">5·24</td>

            <td class="px-3 py-2 border-b border-gray-700">integral</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

            <td class="px-3 py-2 border-b border-gray-700">6·23</td>

            <td class="px-3 py-2 border-b border-gray-700">bit-pattern integral</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">229</td>

            <td class="px-3 py-2 border-b border-gray-700">6·24</td>

            <td class="px-3 py-2 border-b border-gray-700">integral</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">241</td>

            <td class="px-3 py-2 border-b border-gray-700">6·216</td>

            <td class="px-3 py-2 border-b border-gray-700">integral</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">6·257</td>

            <td class="px-3 py-2 border-b border-gray-700">higher-order differential</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, the authors conclude that practical attacks can only be mounted for PRINCE <span class="math">_{core}</span>  (an underlying primitive of the cipher) and applying the same technique to PRINCE results in an increase of time complexity to  <span class="math">2^{64}</span> . Our work clearly improves their findings. Very recently, two other approaches (meet-in-the-middle attack and SAT-based cryptanalysis) led to practical (or arguably close to practical) attacks, up to 10 rounds [6].</p>

    <p class="text-gray-300">In this section we give a description of the PRINCE cipher with all the details needed to follow our attacks. For a complete specification and design rationale of the cipher, we refer a reader to [2].</p>

    <p class="text-gray-300">PRINCE is the 64-bit block cipher which uses 128-bit key  <span class="math">k</span> . First,  <span class="math">k</span>  is divided into two subkeys  <span class="math">k_0 \\parallel k_1</span>  and then is expanded into 192 bits with a simple linear transformation  <span class="math">L</span> .</p>

    <p class="text-gray-300"><span class="math">k = (k_{0}\\parallel k_{1})\\to (k_{0}\\parallel k_{0}^{\\prime}\\parallel k_{1})</span>  , where  <span class="math">k_0^{\\prime} = L(k_0) = (k_0\\gg 1)\\oplus (k_0\\gg 63)</span></p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. A scheme of the PRINCE cipher</p>

    <p class="text-gray-300">The 64-bit subkeys  <span class="math">k_{0}</span>  and  <span class="math">k_{0}^{\\prime}</span>  can be treated as the input and output whitening keys to the underlying block cipher named PRINCE <span class="math">_{core}</span>  with its internal 64-bit key  <span class="math">k_{1}</span> . Figure 1 shows the complete scheme.</p>

    <p class="text-gray-300">PRINCE is the substitution-permutation network composed of 12 rounds. The 64-bit state can be organized as the  <span class="math">4 \\times 4</span>  array of nibbles and we use this convention throughout the paper. To specify a given nibble we use a notation  <span class="math">[\\mathrm{x},\\mathrm{y}]</span> . Four nibbles sharing the same  <span class="math">x</span>  coordinate are called a column.</p>

    <p class="text-gray-300">The 4-bit Sbox  <span class="math">S</span>  can be specified in the hexadecimal notation  <span class="math">S = [B, F, 3, 2, A, C, 9, 1, 6, 7, 8, 0, E, 5, D, 4]</span> . In each round the Sbox  <span class="math">S</span>  (or its inverse  <span class="math">S^{-1}</span> ) is applied to all 16 nibbles. For one</p>

    <p class="text-gray-300">of our attacks, we need an explicit form of the Sbox equations given in the Algebraic Normal Form. Four Sbox outputs <span class="math">y_{0}\\dots y_{3}</span> are described as follows:</p>

    <p class="text-gray-300"><span class="math">y_{3}</span> <span class="math">=x_{1}\\oplus x_{0}\\oplus x_{3}x_{2}\\oplus x_{3}x_{0}\\oplus x_{2}x_{1}\\oplus x_{1}x_{0}\\oplus x_{3}x_{2}x_{1}\\oplus 1</span> <span class="math">y_{2}</span> <span class="math">=x_{3}x_{1}\\oplus x_{2}x_{1}\\oplus x_{2}x_{0}\\oplus x_{3}x_{2}x_{1}\\oplus x_{2}x_{1}x_{0}\\oplus 1</span> <span class="math">y_{1}</span> <span class="math">=x_{3}x_{2}\\oplus x_{3}x_{0}\\oplus x_{2}x_{0}\\oplus x_{3}x_{2}x_{0}\\oplus x_{2}x_{1}x_{0}\\oplus x_{3}\\oplus x_{0}</span> <span class="math">y_{0}</span> <span class="math">=x_{2}x_{1}\\oplus x_{1}x_{0}\\oplus x_{3}x_{2}x_{1}\\oplus x_{3}x_{2}x_{0}\\oplus x_{3}x_{1}x_{0}\\oplus x_{2}\\oplus x_{0}\\oplus 1</span></p>

    <p class="text-gray-300">The linear step <span class="math">M</span> consists of the linear matrix <span class="math">M^{{}^{\\prime}}</span> and the nibble shifting <span class="math">SR</span> (similar to ShiftRows in AES); <span class="math">M=SR\\circ M^{{}^{\\prime}}</span>. The <span class="math">M^{{}^{\\prime}}</span> is an involutive, linear transformation, a kind of equivalent of MixColumns in AES. We give the bitwise equations of <span class="math">M^{{}^{\\prime}}</span> in Appendix. For a detailed algebraic description and design rationale of <span class="math">M</span>, we refer to <em>[2]</em>.</p>

    <p class="text-gray-300">In the first 5 rounds, an order of steps is as follows. First, the subkey <span class="math">k_{1}</span> and the round constant <span class="math">RC_{i}</span> are added to the state. Then, the Sbox layer is applied, followed by the linear transformation <span class="math">M</span>. In the last 5 rounds, the inverse transformations <span class="math">S^{-1}</span> and <span class="math">M^{-1}</span> are used, also the order of them is reversed, as shown in Figure 1. The middle rounds consist of only <span class="math">S</span>, <span class="math">M^{-1}</span>, and <span class="math">S^{-1}</span>.</p>

    <p class="text-gray-300">We attack the round-reduced variants of PRINCE. In case of an even number of rounds, we keep the symmetry of the cipher, that is the same number of rounds are before and after the middle rounds. In case of an odd number of rounds, one extra round is added at the beginning of the cipher. (If an extra round would be added at the end, all the reported attacks still work.)</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Integral Attacks</h2>

    <p class="text-gray-300">Integral cryptanalysis was originally designed as a dedicated attack against the Square cipher <em>[4]</em>. This cryptanalytic attack is particularly applicable to block ciphers based on substitution-permutation networks and PRINCE falls into this category.</p>

    <p class="text-gray-300">Unlike differential cryptanalysis, where we usually trace the XOR difference between a pair of plaintexts, integral cryptanalysis uses bigger sets, e.g., 256 chosen plaintexts. Typically, most part of plaintexts is set to a constant and some words vary through all possibilities. (These words are called active.) Then, we study how the XOR sum in given words changes through the subsequent steps of a cipher. We hope that after a few steps/rounds, some words still sum up to zero. Such the property would distinguish a given cipher from a random permutation and often leads to a key recovery attack.</p>

    <p class="text-gray-300">The base for all our integral attacks is the 3.5-round integral distinguisher. We start from one active nibble (the position of the nibble is arbitrary) and after 3.5 rounds, all nibbles are still balanced, that is, their XOR sum is zero. A subsequent Sbox layer destroys the property. An integral distinguisher is very similar to the one presented originally for the Square cipher and AES. Figure 2 shows the 3.5-round integral distinguisher.</p>

    <p class="text-gray-300">What is interesting is how the linear <span class="math">M^{{}^{\\prime}}</span> affects a single column when one nibble is active and the rest are constant. In the classic Square attack (also applied to AES) if a byte is active and other three bytes are constant, then applying MixColumn operation gives you 4 active bytes (in that column). However, in PRINCE, the <span class="math">M^{{}^{\\prime}}</span> step transforms such column in a way that each nibble (in that column) takes exactly 8 distinct values (rather than 16, as one might expect). Each of these 8 values is present two times, so they balance each other and a nibble is still balanced (sums up to zero) and behaves as it were an active nibble. This property of <span class="math">M^{{}^{\\prime}}</span> becomes clear when one studies its bitwise equations. We give such analysis in Appendix.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. 3.5-round integral distinguisher for PRINCE</p>

    <p class="text-gray-300">First, we encrypt a set of  <span class="math">2^{4}</span>  plaintexts, with one active nibble. We guess a value of  <span class="math">k_{1} \\oplus k_{0}&#x27;</span> , partially decrypt ciphertexts through the last Sbox and check whether the given nibble is balanced or not. With a correct guess, a nibble must be balanced. This is repeated for all 16 nibbles. Our implementation shows that there are many false positives and it is better to use more sets, making the filter stronger. (5 sets are sufficient to eliminate all false positives.)</p>

    <p class="text-gray-300">Then, the standard procedure would be to peel off the 4th round (as  <span class="math">k_{1} \\oplus k_{0}&#x27;</span>  is already known) and next recover  <span class="math">k_{1}</span> , nibble by nibble. However, this is not possible since at the end of the 3rd round all nibbles are still balanced, then any  <span class="math">k_{1}</span>  guess would be 'correct', so there is no filter. To deal with that, the attacker may exhaustively search  <span class="math">k_{1}</span>  (or  <span class="math">k_{0}</span> ) and recover the whole key with time complexity  <span class="math">2^{64}</span>  (as it was done in [8]). However, we can do better by using an extra set of plaintexts.</p>

    <p class="text-gray-300">Instead of using the 3.5-round distinguisher, we now use the 2.5-round one, starting from four active nibbles (placed as in the second diagram in Figure 2). We peel off the 4th round and then recover  <span class="math">k_{1}</span>  key, on nibble by nibble basis. Now a filter works as at the end of the 3rd round a nibble is not guaranteed to be balanced.</p>

    <p class="text-gray-300">Once we know  <span class="math">k_{1}</span>  and  <span class="math">(k_{1} \\oplus k_{0}^{\\prime})</span> ,  <span class="math">k_{0}^{\\prime}</span>  is also known. Therefore, we can easily calculate  <span class="math">k_{0}</span>  from a set of linear equations  <span class="math">L(k_{0}) = k_{0}^{\\prime}</span> . The complete scheme of the attack is as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt 5 sets of  <span class="math">2^{4}</span>  plaintexts with one active nibble</li>

      <li>for all 16 nibbles</li>

    </ol>

    <p class="text-gray-300">(a) for all values of  <span class="math">k_{1} \\oplus k_{0}^{\\prime}</span>  nibble</p>

    <p class="text-gray-300">i. for all 5 sets of plaintexts</p>

    <p class="text-gray-300">A. Decrypt all ciphertexts for a given set through the Sbox B. Sum the nibbles calculated in Step A. If the sum is zero, then the guess is a candidate for correct  <span class="math">k_{1} \\oplus k_{0}^{\\prime}</span></p>

    <p class="text-gray-300">(b) Identify a candidate of  <span class="math">k_{1} \\oplus k_{0}^{\\prime}</span>  which appears in all 5 sets for a given nibble</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt another 5 sets of  <span class="math">2^{4}</span>  plaintexts with four active nibbles (placed as in the second diagram in Figure 2)</li>

      <li>Peel off the 4th round with the recovered  <span class="math">k_{1} \\oplus k_{0}^{\\prime}</span></li>

      <li>for all 16 nibbles</li>

    </ol>

    <p class="text-gray-300">(a) for all values of  <span class="math">k_{1}</span>  nibble</p>

    <p class="text-gray-300">i. for all 5 sets of plaintexts</p>

    <p class="text-gray-300">A. Decrypt all ciphertexts for a given set through the Sbox B. Sum the nibbles calculated in Step A. If the sum is zero, then the guess is a candidate for correct <span class="math">k_{1}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Identify a candidate of <span class="math">k_{1}</span> which appears in all 5 sets for a given nibble</li>

      <li>Recover 64 bits of <span class="math">k_{0}</span> by solving a set of linear equations of the form <span class="math">L(k_{0})=k_{0}^{{}^{\\prime}}</span></li>

    </ol>

    <p class="text-gray-300">Data complexity of the attack is <span class="math">5\\cdot 2^{4}</span> + <span class="math">5\\cdot 2^{4}\\cong 2^{7}</span> chosen plaintexts. Time complexity is dominated by the Sbox calls and is equal to <span class="math">16(\\text{nibbles})\\cdot 5(\\text{sets})\\cdot 2^{4}</span> + <span class="math">16\\cdot 5\\cdot 2^{4}\\cong 2^{11}</span>. We implemented the attack on a desktop PC and the full key recovery takes a fraction of a second.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.2 5-round Attack</h3>

    <p class="text-gray-300">An extension of the attack to 5 rounds is done by guessing a complete column (4 nibbles) of <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span>, rather than a single nibble. Consequently, we can partially decrypt a column of ciphertexts through the Sbox layer and M-layer. Then, we can guess a single nibble of <span class="math">k_{1}[0,0]</span> to pass through the subsequent Sbox. If the guesses are correct, the balance property should hold (according to our 3.5-round distinguisher). The pseudo-code of the attack is given below.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt 6 sets of <span class="math">2^{4}</span> plaintexts with one active nibble</li>

      <li>for all 4 columns of nibbles</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all values of <span class="math">(k_{1}\\oplus k_{0}^{{}^{\\prime}})</span> column and <span class="math">k_{1}[0,0]</span> nibble</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all 6 sets of plaintexts</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt the column through S-Layer and M-Layer</li>

      <li>Decrypt a nibble <span class="math">[0,0]</span> through the Sbox</li>

      <li>Sum the nibbles calculated in Step B. If the sum is zero, then the guess is a candidate for correct <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span> column</li>

      <li>Identify a candidate of <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span> which appears in all 6 sets for a given column</li>

      <li>Peel off the 5th round with the recovered <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span></li>

      <li>for all 16 nibbles</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all values of <span class="math">k_{1}</span> nibble</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all 6 sets of plaintexts</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt all ciphertexts for a given set through the Sbox</li>

      <li>Sum the nibbles calculated in Step A. If the sum is zero, then the guess is a candidate for correct <span class="math">k_{1}</span></li>

      <li>Identify a candidate of <span class="math">k_{1}</span> which appears in all 6 sets for a given nibble</li>

      <li>Recover 64 bits of <span class="math">k_{0}</span> by solving a set of linear equations of the form <span class="math">L(k_{0})=k_{0}^{{}^{\\prime}}</span></li>

    </ol>

    <p class="text-gray-300">Our implementation indicates that 6 sets of plaintexts make the filter strong enough. Thus, data complexity is <span class="math">6\\cdot 2^{4}</span> chosen plaintexts. Time complexity is dominated by the Sbox calls (the most inner loop in the pseudo-code) and is equal to <span class="math">6\\cdot 2^{4}</span> (plaintexts) <span class="math">\\cdot 4(\\text{columns})\\cdot 2^{16+4}\\cong 2^{29}</span>. We implemented the attack and the secret key is recovered in about 3 minutes on a desktop PC.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.3 6-round Attack</h3>

    <p class="text-gray-300">The 6-round attack is exactly the same as the 5-round variant except that we start with a larger structure of <span class="math">2^{16}</span> plaintexts. We use the same idea which allows to add one more round (at the beginning) for the integral attack against Square or AES. Four nibbles from the same column takes all possible <span class="math">2^{16}</span> values and the remaining nibbles are set to some arbitrary constant. After the first round, we have, in fact, <span class="math">2^{12}</span> sets of <span class="math">2^{4}</span> plaintexts ready for the 5-round attack. So, data and time complexity have to be multiplied by a factor of <span class="math">2^{12}</span> (in comparison to the 5-round attack). Thus, required data is <span class="math">6\\cdot 2^{16}</span> chosen plaintexts and time is <span class="math">2^{41}</span>. The 6-round attack</p>

    <p class="text-gray-300">would take a couple of days on a single PC, but it can be easily parallelized and <span class="math">2^{41}</span> complexity is not an obstacle to get the very practical time. We experimented with the limited pool of keys (including the correct key) to confirm that indeed the correct key is recovered and false ones are discarded.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 Bit-Pattern Based Integral Attack</h2>

    <p class="text-gray-300">The integral attack naturally fits to the primitives with the word-oriented structure such as Square, AES and also PRINCE. However, it has been shown <em>[12]</em>, that a modified variant of the technique (called bit-pattern based integral attack) can be applied to the bit-oriented algorithms. The classic integral attack starts with (at least) one active <span class="math">s</span>-bit word, so a number of chosen plaintexts (data complexity) has a lower bound <span class="math">2^{s}</span>. The bit-pattern variant of the integral attack allows to work with fewer chosen plaintexts. For practical attacks, where the adversary might have very limited power to harvest chosen plaintexts, we believe it is important to push data complexity to the lowest possible value. Hence our motivation to mount the bit-pattern based integral attack against PRINCE.</p>

    <p class="text-gray-300">Let us first briefly describe how the technique works. There are two features which differ the bit-pattern based attack from the classic integral attack. First, we trace single bits (their patterns) rather than the whole words (such as nibbles in PRINCE or bytes in AES). Second, we care about the order of plaintexts. It will becomes clearer as we take a closer look at the bit patterns. In a given structure (e.g., 8 plaintexts), each bit position holds a specific sequence of 0’s and/or 1’s. For example, ‘00000000’ (8 zeros) is called the constant pattern, while ‘11110000’ is the active pattern denoted by <span class="math">a_{2}</span>. According to the notation introduced in <em>[12]</em>, we have the following patters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>constant pattern <span class="math">c</span>: bits within the structure consists of either all 0’s or all 1’s.</li>

      <li>active pattern <span class="math">a_{i}</span>: alternating values of bits in <span class="math">2^{i}</span>-bit blocks is repeated throughout the structure.</li>

      <li>pattern <span class="math">b_{i}</span>: consecutive bits in <span class="math">2^{i}</span>-bit blocks, but the values of the blocks are not necessarily repeated in an alternating manner.</li>

      <li>dual pattern <span class="math">d_{i}</span>: bits hold either the <span class="math">c</span> (constant) or the <span class="math">a_{i}</span> (active) pattern.</li>

    </ul>

    <p class="text-gray-300">If the XOR sum of all bits in one pattern equals 0, the pattern is balanced. All the above patterns are balanced except for <span class="math">b_{0}</span> which may or may not be balanced. In this paper we use the following convention: <span class="math">b_{0}</span> is treated as balanced and when it is unknown whether <span class="math">b_{0}</span> is balanced or not, the new symbol ‘?’ is introduced.</p>

    <p class="text-gray-300">A key recovery attack with the bit-pattern variant of the integral attack works the same as for the classic integral attack. Once we have the bit-pattern integral distinguisher, we guess a part of the key from the last round, partially decrypt ciphertexts through the Sbox layer and check the balance property of certain bits. If the property holds (according to a distinguisher), then our key guess, most likely, is correct.</p>

    <p class="text-gray-300">To trace how bit patters change through the subsequent rounds in PRINCE, first we need the bitwise description of the cipher. The linear <span class="math">M/M^{{}^{\\prime}}</span>-layer involves only XORs of nibbles, so the bit-level description is straightforward. (The bitwise equations are given in Appendix.) For the Sbox layer we use four ANF equations given in Section 2). Therefore, the whole cipher can be expressed with only the bitwise AND and XOR. Now we have to figure out how to operate on patterns with these two operators. Some operations are pretty obvious, for example, the constant pattern <span class="math">c</span> XORed with any other pattern <span class="math">p</span> gives <span class="math">p</span>. A detailed list of operations on the patterns is given in Appendix.</p>

    <p class="text-gray-300">Figure 3 shows an evolution of patterns through the first 3 rounds. We start with three active bits, so  <span class="math">2^{3}</span>  chosen plaintexts are needed. Please note that three active bits are placed in separate nibbles. This way they do not interact in the first round and the  <span class="math">b_{0}</span>  pattern does not appear right after the first S-Layer. Addition of secret key and round constants can be omitted as these operations do know bring any changes to patterns of bits (XORing with the the constant pattern  <span class="math">c</span> ). The balance property holds up to 2.5 rounds and the third layer of the Sboxes destroys the property.</p>

    <p class="text-gray-300">We experimented with other placement of active bits (e.g., all three active bits in a single nibble) but it did not lead to better results than 3 rounds.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. Evolution of patterns through the first 3 rounds. After the third Sbox layer the balance property does not hold any more for any of bits.</p>

    <p class="text-gray-300">One may ask why, instead of three active bits  <span class="math">(a_0, a_1, a_2)</span> , we do not take only two active bits and limit a number of chosen plaintexts even further. The problem is that with two active</p>

    <p class="text-gray-300">bits (structure of four plaintexts) the symbolic operations do not work in the same way as for bigger structures. For example, (<span class="math">a_{1}</span> XOR <span class="math">a_{0}</span>) AND <span class="math">c</span> is no longer guaranteed to be balanced, while for bigger structures the outcome is balanced, namely <span class="math">b_{0}</span>. Consequently, the ‘?’ symbol would appear earlier. (It becomes even more clear with a trivial structure of two plaintexts, with only <span class="math">a_{0}</span> bit.)</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">4.1 4-round Attack</h3>

    <p class="text-gray-300">The scheme of the attack is very similar to the 5-round classic integral attack shown earlier.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encrypt 6 sets of <span class="math">2^{3}</span> plaintexts where active bits <span class="math">a_{0}</span>, <span class="math">a_{1}</span> and <span class="math">a_{2}</span> are placed in separate columns (an example placement shown in Figure 3).</li>

      <li>for all 4 columns of nibbles</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all values of <span class="math">(k_{1}\\oplus k_{0}^{{}^{\\prime}})</span> column and <span class="math">k_{1}[0,0]</span> nibble</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all 6 sets of plaintexts</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt the column through S-Layer and M-Layer</li>

      <li>Decrypt a nibble [0,0] through the Sbox</li>

      <li>Sum the nibbles calculated in Step B. If the sum is zero, then the guess is a candidate for correct <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span> column</li>

      <li>Identify a candidate of <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span> which appears in all 6 sets for a given column</li>

      <li>Peel off the 4th round with the recovered <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span></li>

      <li>for all 16 nibbles</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all values of <span class="math">k_{1}</span> nibble</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all 6 sets of plaintexts</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decrypt all ciphertexts for a given set through the Sbox</li>

      <li>Sum the nibbles calculated in Step A. If the sum is zero, then the guess is a candidate for correct <span class="math">k_{1}</span></li>

      <li>Identify a candidate of <span class="math">k_{1}</span> which appears in all 6 sets for a given nibble</li>

      <li>Recover 64 bits of <span class="math">k_{0}</span> by solving a set of linear equations of the form <span class="math">L(k_{0})=k_{0}^{{}^{\\prime}}</span></li>

    </ol>

    <p class="text-gray-300">Six sets of plaintexts are enough to identify the correct guess of a column of <span class="math">k_{1}\\oplus k_{0}^{{}^{\\prime}}</span> and eliminate all false positives. Then, the same sets of plaintexts are used to recover <span class="math">k_{1}</span>, on a nibble by nibble basis. Thus, data complexity is <span class="math">6\\cdot 2^{3}</span> chosen plaintexts, fewer than <span class="math">10\\cdot 2^{4}</span> needed for the classic integral attack from Section 3.1. Time complexity is dominated by the Sbox calls in Step 2. So, <span class="math">6\\cdot 2^{3}</span> (plaintexts) <span class="math">\\cdot 4</span> (columns) <span class="math">\\cdot 2^{16+4}\\cong 2^{28}</span> operations. We implemented the attack on a desktop PC (2.2 GHz, single core) and it takes a minute to recover the key. In Step 5, we observe that for some nibbles there are more than one suggestion of <span class="math">k_{1}</span>. To identify the correct 64-bit <span class="math">k_{1}</span>, we run trial encryptions with all suggested combinations of <span class="math">k_{1}</span> nibbles and then compare the obtained ciphertexts to the real ciphertexts from our data set. We mounted the attack for 100 randomly chosen keys and every time a number of those extra cipher calls was negligible and did not affect time complexity.</p>

    <h2 id="sec-13" class="text-2xl font-bold">5 7-round Higher-order Differential Attack</h2>

    <p class="text-gray-300">Higher order differential attack is applicable to ciphers which can be represented as Boolean polynomials of a low algebraic degree <em>[9]</em>. In PRINCE the only non-linear step is the Sbox layer, so an algebraic degree of a single round is the same as the degree of the SBox, which is 3. We can take advantage of this relatively small degree to reach 7 rounds.</p>

    <p class="text-gray-300">For the standard differential cryptanalysis we operate on differences between a pair of plaintexts. Higher-order differential cryptanalysis is a natural extension, where we trace differences</p>

    <p class="text-gray-300">between a larger set of plaintexts. In our attack, we are interested in calculating <span class="math">i</span>-th derivative at some selected points. To do so, we need to form a set of <span class="math">2^{i}</span> plaintexts, where <span class="math">i</span> plaintext variables change through all possible values, while the rest of the state is set to an arbitrary constant.</p>

    <p class="text-gray-300">A ciphertext variable (expressed as a polynomial in plaintext and key variables) of the 3-round PRINCE has an algebraic degree (at most) <span class="math">3^{3}=27</span>. Therefore, any 28-th order derivative (or higher) must be 0, regardless of the actual key values. This simple observation could lead us to the 5-round attack (similar to the integral attack), but we would have to use <span class="math">2^{28}</span> chosen plaintexts (to calculate a derivative), so it would not bring a better result than that obtained with the integral attack. However, we can get the first few steps for ‘free’ and start the actual attack after the second S-Layer.</p>

    <p class="text-gray-300">We form a structure of <span class="math">2^{32}</span> chosen plaintexts, where two columns (8 nibbles) take all possible values. As the PRINCE Sbox is a bijection, the first Sbox layer preserves the property, that is, two selected columns still take all possible values. The next step <span class="math">M^{{}^{\\prime}}</span> works on columns independently (see Appendix), thus we still have 32 state bits taking all possible combinations. Then, the <span class="math">SR</span> step only shifts nibbles in the state. The second Sbox layer keeps the desired state property and eventually <span class="math">M^{{}^{\\prime}}</span> in the second round destroys the property.</p>

    <p class="text-gray-300">Therefore, we get first 1.5 rounds (two S-Layers) for free and then we can launch the attack which covers another three S-Layers. (It is not possible to cover four S-Layers as the algebraic degree <span class="math">3^{4}=81</span> would be greater than 32 and hence the 32-th derivative is not guaranteed to be 0.)</p>

    <p class="text-gray-300">The scheme of the attack (taking the attack ‘interface’ point of view) is basically the same as the one given for the 5-round integral attack in Section 3.2. The only difference is that we start with a larger structure of <span class="math">2^{32}</span> plaintexts, so time and data complexities are higher. Time complexity is <span class="math">6\\,\\cdot\\,2^{32}</span> (plaintexts) <span class="math">\\cdot\\,4(\\mbox{columns})\\,\\cdot\\,2^{16+4}\\cong 2^{57}</span> operations. (We assume, that as in the previous attacks, 6 sets of plaintexts make the filter strong enough.)</p>

    <h2 id="sec-14" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">We presented a few new attacks on the round-reduced (up to 7 rounds) variants of PRINCE. We focused on the practical attacks, most of them implemented and verified on a single desktop PC. Such analysis should help to evaluate the security margin of the cipher, especially regarding real-life scenarios and potential deployment of the algorithm. Using integral cryptanalysis we managed to reach 6 rounds with low data complexity. We also mounted the 7-round attack with an aid of higher-order differential cryptanalysis. We conclude that the full, 12-round PRINCE has sufficient security margin against the attacks which exploit a low algebraic degree in a cryptosystem.</p>

    <h2 id="sec-15" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] PRINCE Challenge: https://www.emsec.rub.de/research/research_startseite/prince-challenge</li>

      <li>[2] Borghoff, J., Canteaut, A., Güneysu, T., Kavun, E.B., Knezevic, M., Knudsen, L.R., Leander, G., Nikov, V., Paar, C., Rechberger, C., Rombouts, P., Thomsen, S.S., Yalçin, T.: PRINCE - A Low-Latency Block Cipher for Pervasive Computing Applications - Extended Abstract. In: Advances in Cryptology - ASIACRYPT 2012 - 18th International Conference on the Theory and Application of Cryptology and Information Security, Beijing, China, December 2-6, 2012. Proceedings. pp. 208–225 (2012)</li>

      <li>[3] Canteaut, A., Fuhr, T., Gilbert, H., Naya-Plasencia, M., Reinhard, J.: Multiple Differential Cryptanalysis of Round-Reduced PRINCE (Full version). IACR Cryptology ePrint Archive 2014, 89 (2014), http://eprint.iacr.org/2014/089</li>

      <li>[4] Daemen, J., Knudsen, L.R., Rijmen, V.: The block cipher square. In: FSE. pp. 149–165 (1997)</li>

      <li>[5] Daemen, J., Rijmen, V.: The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography, Springer (2002)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derbez, P., Perrin, L.: Meet-in-the-Middle Attacks and Structural Analysis of Round-Reduced PRINCE. In: Fast Software Encryption Conference (2015)</li>

      <li>Jean, J., Nikolic, I., Peyrin, T., Wang, L., Wu, S.: Security Analysis of PRINCE. In: Fast Software Encryption - 20th International Workshop, FSE 2013, Singapore, March 11-13, 2013. Revised Selected Papers. pp. 92-111 (2013)</li>

      <li>Jean, J., Nikolic, I., Peyrin, T., Wang, L., Wu, S.: Security analysis of prince. In: FSE. pp. 92-111 (2013)</li>

      <li>Lai, X.: Higher Order Derivatives and Differential Cryptanalysis. In: Blahut, R., Costello, DanielJ., J., Maurer, U., Mittelholzer, T. (eds.) Communications and Cryptography, The Springer International Series in Engineering and Computer Science, vol. 276, pp. 227-233. Springer US (1994)</li>

      <li>Li, L., Jia, K., Wang, X.: Improved Meet-in-the-Middle Attacks on AES-192 and PRINCE. Cryptology ePrint Archive, Report 2013/573 (2013)</li>

      <li>Soleimany, H., Blondeau, C., Yu, X., Wu, W., Nyberg, K., Zhang, H., Zhang, L., Wang, Y.: Reflection Cryptanalysis of PRINCE-Like Ciphers. In: Fast Software Encryption - 20th International Workshop, FSE 2013, Singapore, March 11-13, 2013. Revised Selected Papers. pp. 71-91 (2013)</li>

      <li>Z'aba, M.R., Raddum, H., Henricksen, M., Dawson, E.: Bit-Pattern Based Integral Attack. In: FSE. Lecture Notes in Computer Science, vol. 5086, pp. 363-381. Springer (2008)</li>

    </ol>

    <p class="text-gray-300"><span class="math">M^{\\prime}</span>  can be expressed as the parallel application of two independent transformations:  <span class="math">\\hat{M}^{(0)}</span>  and  <span class="math">\\hat{M}^{(1)}</span> .  <span class="math">\\hat{M}^{(0)}</span>  is applied to columns 0 and 3, whereas  <span class="math">\\hat{M}^{(1)}</span>  is applied to columns 1 and 2. So, four nibbles  <span class="math">(x_{3}\\ldots x_{0})</span>  are transformed into other four nibbles  <span class="math">(y_{3}\\ldots y_{0})</span>  by these transformations. Bitwise equations behind  <span class="math">\\hat{M}^{(0)}</span>  and  <span class="math">\\hat{M}^{(1)}</span>  are as follows. (A nibble in a column and a particular bit in a nibble are denoted by a lower and an upper index, respectively.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y00=x00⊕x00⊕x30</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y10=x00⊕x10⊕x20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y20=x00⊕x10⊕x30</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y30=x00⊕x20⊕x30</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y01=x00⊕x11⊕x21</td>

            <td class="px-3 py-2 border-b border-gray-700">y11=x11⊕x11⊕x11</td>

            <td class="px-3 py-2 border-b border-gray-700">y11=x01⊕x11⊕x11</td>

            <td class="px-3 py-2 border-b border-gray-700">y11=x01⊕x11⊕x11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y02=x00⊕x11⊕x21</td>

            <td class="px-3 py-2 border-b border-gray-700">y12=x00⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y21=x12⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y21=x02⊕x11⊕x21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y03=x00⊕x11⊕x21</td>

            <td class="px-3 py-2 border-b border-gray-700">y13=x03⊕x11⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y22=x03⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y31=x13⊕x21⊕x31</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y10=x10⊕x20⊕x30</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y00=x00⊕x10⊕x20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y10=x00⊕x10⊕x30</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y20=x00⊕x20⊕x30</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y11=x11⊕x11⊕x11</td>

            <td class="px-3 py-2 border-b border-gray-700">y01=x11⊕x11⊕x11</td>

            <td class="px-3 py-2 border-b border-gray-700">y11=x01⊕x11⊕x11</td>

            <td class="px-3 py-2 border-b border-gray-700">y21=x01⊕x11⊕x11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y12=x02⊕x11⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y02=x02⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y12=x12⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y22=x02⊕x11⊕x21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">y13=x03⊕x13⊕x21</td>

            <td class="px-3 py-2 border-b border-gray-700">y03=x03⊕x13⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y13=x03⊕x21⊕x31</td>

            <td class="px-3 py-2 border-b border-gray-700">y23=x13⊕x21⊕x31</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These equations are helpful to analyse how  <span class="math">M&#x27;</span>  affects the column with one active nibble and other three constant. We stated that  <span class="math">M&#x27;</span>  step transforms such a column in a way that each nibble (in that column) takes exactly 8 distinct values (rather than 16, as one might expect). For example, let us assume that  <span class="math">\\hat{M}^{(0)}</span>  is applied to a column and the nibble  <span class="math">x_0</span>  is active;  <span class="math">x_0</span>  consists of four bits  <span class="math">(x_0^0, x_0^1, x_0^2, x_0^3)</span> . Now, if we look carefully, for all four output nibbles  <span class="math">(y_3, y_2, y_1, y_0)</span> , there is one output bit  <span class="math">(y_3^3, y_2^2, y_1^1, y_0^0</span> , respectively) which does not depend on any of these active bits  <span class="math">(x_0^0, x_0^1, x_0^2, x_0^3)</span> . Hence, such a bit has to be constant. Consequently, a nibble can not take all 16 values (but takes 8), as one bit is constant. Reasoning for other situations (e.g., three constant nibbles and one quasi-active  <span class="math">A^8</span> ) can be done in a similar way.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">symbol 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">symbol 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">operator</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">result</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">?</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">?</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ai</td>

            <td class="px-3 py-2 border-b border-gray-700">aj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ai</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">aj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">dj</td>

            <td class="px-3 py-2 border-b border-gray-700">⊕</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">b0</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">?</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">?</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">?</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ai</td>

            <td class="px-3 py-2 border-b border-gray-700">aj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ai</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">aj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">bj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">dj</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ai</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">di</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">&</td>

            <td class="px-3 py-2 border-b border-gray-700">bi</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">All symbols and their meaning were introduced in Section 4. We assume that  <span class="math">i \\leqslant j</span> . Both bitwise operators are commutative.</p>`;
---

<BaseLayout title="Practical Attacks on the Round-reduced PRINCE (2015/245)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/245
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
