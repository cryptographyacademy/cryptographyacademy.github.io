---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/130';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis';
const AUTHORS_HTML = 'Joppe W.  Bos, Craig Costello, Patrick Longa, Michael Naehrig';

const CONTENT = `    <p class="text-gray-300">Noname manuscript No. (will be inserted by the editor)</p>

    <p class="text-gray-300">Joppe W. Bos · Craig Costello · Patrick Longa · Michael Naehrig</p>

    <p class="text-gray-300">Received: date / Accepted: date</p>

    <p class="text-gray-300">Abstract We select a set of elliptic curves for cryptography and analyze our selection from a performance and security perspective. This analysis complements recent curve proposals that suggest (twisted) Edwards curves by also considering the Weierstrass model. Working with both Montgomery-friendly and pseudo-Mersenne primes allows us to consider more possibilities which help to improve the overall efficiency of base field arithmetic. Our Weierstrass curves are backwards compatible with current implementations of prime order NIST curves, while providing improved efficiency and stronger security properties. We choose algorithms and explicit formulas to demonstrate that our curves support constant-time, exception-free scalar multiplications, thereby offering high practical security in cryptographic applications. Our implementation shows that variable-base scalar multiplication on the new Weierstrass curves at the 128-bit security level is about 1.4 times faster than the recent implementation record on the corresponding NIST curve. For practitioners who are willing to use a different curve model and sacrifice a few bits of security, we present a collection of twisted Edwards curves with particularly efficient arithmetic that are up to 1.42, 1.26</p>

    <p class="text-gray-300">and 1.24 times faster than the new Weierstrass curves at the 128-, 192- and 256-bit security levels, respectively. Finally, we discuss how these curves behave in a real-world protocol by considering different scalar multiplication scenarios in the transport layer security (TLS) protocol. The proposed curves and the results of the analysis are intended to contribute to the recent efforts towards recommending new elliptic curves for Internet standards.</p>

    <p class="text-gray-300">Keywords Elliptic curves, Weierstrass form, twisted Edwards form, secure scalar multiplication, constant-time execution, transport layer security (TLS) protocol.</p>

    <p class="text-gray-300">The first release of a cryptographic standard specifying elliptic curves for use in practice dates back to 2000 [21]. Nowadays, roughly one out of ten systems on the publicly observable Internet offers cipher suites in the Secure Shell (SSH) and Transport Layer Security (TLS) protocols that contain elliptic-curve-based cryptographic algorithms [16]. Most elliptic curve standards recommend curves for different perceived security levels that are either defined over prime fields or binary extension fields; on the Internet, however, the deployed curves are mostly defined over prime fields [16]. This can be partially explained by the increasing skepticism towards the security of elliptic curves defined over binary extension fields (justified by recent progress on solving the discrete logarithm problem on such curves [26]). Therefore, in this work, we only consider elliptic curves defined over prime fields.</p>

    <p class="text-gray-300">Recently, part of the cryptographic community has been looking for alternatives to the currently deployed elliptic curves that may offer better performance and provide stronger overall security (see for example an evaluation of recent curve candidates in [12]). Most notably, the TLS working group has issued a formal request to the Crypto Forum Research Group (CFRG) asking for recommendations for new elliptic curves. The urge to change curves has been fueled by the recently leaked NSA documents, which suggest the existence of a back door in the Dual Elliptic Curve Deterministic Random Bit Generator [56]. Although cryptographers have suspected this at least as early as in 2007 [53], these recent revelations have accelerated a controversy on whether the widely deployed NIST curves [58] should be replaced by curves with a verifiably deterministic generation. Besides such security concerns, there has been significant progress related to both efficiency and security since the initial standardization of elliptic curve</p>

    <p class="text-gray-300">cryptography. Notable examples are algorithms protected against certain side-channel attacks, different “special” prime shapes which allow faster modular arithmetic, and a larger set of curve models from which to choose. For example, in 2007, Edwards [25] discovered an interesting normal form for elliptic curves, now called the Edwards model, which was introduced to cryptographic applications by Bernstein and Lange [11]. A generalization of this curve model, known as the twisted Edwards model [7], facilitates the most efficient curve arithmetic [35]. Such (twisted) Edwards curves also have other attractive properties: they may be selected to support a complete addition law and are compatible with the Montgomery model, which supports efficient Montgomery ladder computations [47]. However, twisted Edwards curves cannot have a prime number of rational points over the base field, and they are therefore incompatible with the <em>prime-order</em> Weierstrass curves used in all of the current cryptographic standards [21; 48; 58].</p>

    <p class="text-gray-300">Related Work. The NIST curves [58] have been included in numerous standards (e.g. [21; 48]) and are deployed in many security protocols. The most recent speed record on the NIST curve which aims to provide 128-bit security is due to Gueron and Krasnov [31]. Alternatives to the NIST curves have been suggested by the German working group Brainpool [24]; their curve choices followed additional security requirements, one of which demands verifiably pseudo-random curve generation. Another alternative curve has been proposed by Bernstein [5]; this is a Montgomery curve, called Curve25519, which allows efficient computation of ECDH using the Montgomery ladder at the 128-bit security level. It was later shown by Bernstein et al. [9] that a twisted Edwards curve, birationally equivalent to Curve25519, can be used for efficient elliptic curve signature generation and verification. Recently, Bernstein and Lange started a project to select and analyze secure elliptic curves for use in cryptography: see [12] for a list of the security assessments the project performs and the requirements it imposes. A range of curves, targeting different security levels, is also presented in [12]. Following this, several new curves satisfying the requirements from [12], which facilitate both the twisted Edwards and Montgomery form, were proposed by Aranha et al. [3].</p>

    <p class="text-gray-300">Motivation and Rationale. The new curves presented in [12; 3] are all efficient and secure elliptic curves ready to be used in cryptography. This prompts the question as to why we should perform an efficiency and security analysis for a set of new curves. It is our opinion that not all options for prime fields and elliptic curve models have been considered in the recent curve proposal projects (either because they are overlooked or do not fit the requirements set by the project). Our goal is to rigorously analyze all of these different aspects from both a security and efficiency perspective, in hope that this paper helps practitioners better understand (and correctly implement) the choices that lie in front of them. Abandoning a set of standard curves demands a judicious selection of new curves, since this cannot be done too frequently if widespread adoption is desired. In that light, it is our opinion that one should consider all of the options available. For example, in contrast to [12; 3], our selection includes prime order Weierstrass curves. Just as the almost-prime order twisted Edwards curves have their practical advantages, we argue that there are also benefits to choosing prime order Weierstrass curves: the absence of small torsion simplifies the point/input validation process, and (over a prime field of fixed length) does not sacrifice any bits of security with respect to attacks on the underlying elliptic curve discrete logarithm problem (ECDLP). In addition, such curves are backwards compatible with current implementations supporting NIST curves over prime fields (i.e., no changes are required in protocols), and could be integrated into existing implementations by simply changing the curve constant and (in some cases) field arithmetic.</p>

    <p class="text-gray-300">We investigate the selection of prime moduli that allow efficient modular arithmetic. As in [5; 35; 42; 15; 12; 3], we study pseudo-Mersenne primes of the form <span class="math">2^{\\alpha}-\\gamma</span>, but also primes of the form <span class="math">2^{\\alpha}(2^{\\beta}-\\gamma)-1</span> that can be used to accelerate Montgomery arithmetic [46] as used in [32; 15]. Following the deterministic selection requirement from [12], we pick two primes of each shape for a given targeted security level: one prime is selected to be slightly smaller than the other, which sacrifices a small amount of ECDLP security in favor of enhanced performance. Note that, as explained in Section 2, for practical considerations we require all primes to be congruent to 3 modulo 4. These primes are used to construct cryptographically suitable curves focusing on (arguably) the two most relevant curve models: short Weierstrass curves with the curve parameter <span class="math">a</span> set to <span class="math">-3</span> and twisted Edwards curves with the curve parameter <span class="math">a</span> set to <span class="math">-1</span>. The prime order Weierstrass curves give full ECDLP security over prime fields of a fixed bitlength, while offering good practical performance. On the other hand, the twisted Edwards curves sacrifice a small amount of ECDLP security but facilitate the fastest realization of curve arithmetic [35]. Both types of curves are selected in a deterministic fashion (see Sec</p>

    <p class="text-gray-300">tion 3 for the full details) and offer twist-security [5], a property which is useful in certain scenarios. We note that our prime and curve selection is meant to cover a wide range of options exhibiting attractive features. Nevertheless, there are other design alternatives that might offer different trade-offs between security, rigidity and performance on different platforms. We leave the investigation of other options as future work.</p>

    <p class="text-gray-300">An important requirement for implementations of modern cryptographic algorithms is a constant runtime when the algorithm computes on secret data to guard against timing attacks [39]. In particular, this potential threat exists for two basic elliptic curve operations: variable-base and fixed-base scalar multiplication. One solution is to use a complete addition law. However, a complete addition law is typically less efficient compared to the dedicated formulas which can fail for certain inputs. In Section 4 we outline another solution to this problem for the variable-base case. We show that our algorithms which compute on secret data, can never run into any exceptional cases (i. e. produce incorrect results) while using the faster dedicated formulas and ensuring a constant runtime (with the exception of the very last addition; see Section 4.1 for the details). Hence, this solution results in faster implementations compared to the complete solution. In the fixed-base case the situation is more complicated: most efficient algorithms in the literature may potentially run into exceptions. While the use of a complete addition formula suffices to solve the problem on twisted Edwards curves, the high cost of complete additions on Weierstrass curves would degrade performance significantly [18] (see Appendix C.1). To solve this problem, we propose a new formula that works for all possible inputs by exploiting masking techniques. This pseudo-complete addition requires the same number of multiplications and squarings as the unprotected dedicated addition formula and drastically reduces the overhead of protecting scalar multiplication. We comment that the formula is also useful in the context of secure, exception-free multi-scalar multiplications. The reader is referred to Appendix C.1 for more details on the new formula.</p>

    <p class="text-gray-300">We do not claim full security against other attacks such as simple power analysis (SPA); this is left for future work. Nevertheless, we remark that all the selected algorithms have a regular structure as required when implementing countermeasures against certain simple side-channel attacks.</p>

    <p class="text-gray-300">Summary of contributions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Analysis of a new set of deterministically selected prime-order Weierstrass curves (see Table 1) which are defined over pseudo-Mersenne and Montgomery-friendly primes whose bitlengths match those of the NIST primes. See Sections 2 and 3.</li>

      <li>Analysis of a new set of deterministically selected composite-order twisted Edwards curves (see Table 2 and Section 3). In contrast to existing curve proposals, the selected curves present (simultaneously) minimal parameter <span class="math">d</span> in the twisted Edwards form and minimal parameter <span class="math">A</span> in isogenous Montgomery form (minimal in absolute value). See Section 3.3.</li>

      <li>A new, (pseudo-)complete addition algorithm for general curves in short Weierstrass form. This algorithm works for all pairs of inputs and its execution incurs only a small overhead compared to the dedicated addition law. See Section C.1.</li>

      <li>We demonstrate how to use the scalar multiplication algorithms and prove that they become exception-free and facilitate constant-time implementations when used this way. This allows one to use the more efficient dedicated formulas whenever possible, resulting in an efficient and secure solution for elliptic curve scalar multiplication. See Section 4.</li>

      <li>A comprehensive software implementation providing timings for various scenarios; this includes performance estimates for the above curves when used in the context of the TLS protocol. See Sections 5 and 6.</li>

    </ul>

    <p class="text-gray-300">Proposed Curves. Tables 1 and 2 show the curves that we have chosen deterministically according to our security and efficiency criteria. The tables show the target security level, which gives a rough estimate for the desired security in each case. Curve names indicate the curve model (w for the Weierstrass model and ed for the (twisted) Edwards model), the bitlength of the underlying base field prime and the type of prime (mont for Montgomery-friendly and mers for pseudo-Mersenne primes). In Appendix D, we provide the trace of Frobenius <span class="math">t</span> for each curve, so the number of <span class="math">\\mathbf{F}_{p}</span>-rational points for the curve <span class="math">E</span> and its quadratic twist <span class="math">E^{\\prime}</span> can be computed as <span class="math">\\#E(\\mathbf{F}_{p})=p+1-t</span> and <span class="math">\\#E^{\\prime}(\\mathbf{F}_{p})=p+1+t</span>. More details on the curve choices and their properties are given in Section 3.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Modular Arithmetic - Choosing Primes</h2>

    <p class="text-gray-300">Over a prime field <span class="math">\\mathbf{F}_{p}</span> (with <span class="math">p&gt;3</span> prime), the computation of the elliptic curve group operation boils down to numerous computations modulo <span class="math">p</span>. In this section we outline the types of primes that we prefer for efficiency and security considerations, and discuss how the primes are uniquely determined from a fixed security level. We</p>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">Table 1 Summary of our chosen Weierstrass curves of the form  <span class="math">E_{b} / \\mathbf{F}_{p}:y^{2} = x^{3} - 3x + b</span>  defined over  <span class="math">\\mathbf{F}_p</span>  with quadratic twist  <span class="math">E_b^\\prime /\\mathbf{F}_p:y^2 = x^3 -3x - b</span>  and target security level  <span class="math">\\lambda</span> . The group orders  <span class="math">r = \\# E_b(\\mathbf{F}_p)</span>  and  <span class="math">r^{\\prime} = \\# E_{b}^{\\prime}(\\mathbf{F}_{p})</span>  are both prime, and  <span class="math">r &amp;lt; p</span>  for all curves. The value under  <span class="math">\\rho</span>  complexity is an estimate for the actual security of the ECDLP against Pollard's  <span class="math">\\rho</span>  method, it is  <span class="math">\\log_2(\\sqrt{\\pi / 4}\\cdot \\sqrt{r})</span>  rounded to one decimal.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">target security λ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2240(216 - 88) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">85610</td>

            <td class="px-3 py-2 border-b border-gray-700">127.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2240(214 - 127) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-12146</td>

            <td class="px-3 py-2 border-b border-gray-700">126.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2256 - 189</td>

            <td class="px-3 py-2 border-b border-gray-700">152961</td>

            <td class="px-3 py-2 border-b border-gray-700">127.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2255 - 765</td>

            <td class="px-3 py-2 border-b border-gray-700">-20925</td>

            <td class="px-3 py-2 border-b border-gray-700">127.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2376(28 - 79) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">27798</td>

            <td class="px-3 py-2 border-b border-gray-700">191.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2368(214 - 5) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-133746</td>

            <td class="px-3 py-2 border-b border-gray-700">190.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2384 - 317</td>

            <td class="px-3 py-2 border-b border-gray-700">-34568</td>

            <td class="px-3 py-2 border-b border-gray-700">191.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2383 - 421</td>

            <td class="px-3 py-2 border-b border-gray-700">97724</td>

            <td class="px-3 py-2 border-b border-gray-700">191.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2496(216 - 491) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">99821</td>

            <td class="px-3 py-2 border-b border-gray-700">255.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2496(214 - 290) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">39053</td>

            <td class="px-3 py-2 border-b border-gray-700">254.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2512 - 569</td>

            <td class="px-3 py-2 border-b border-gray-700">121243</td>

            <td class="px-3 py-2 border-b border-gray-700">255.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2511 - 481</td>

            <td class="px-3 py-2 border-b border-gray-700">555482</td>

            <td class="px-3 py-2 border-b border-gray-700">255.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2 Summary of our chosen twisted Edwards curves of the form  <span class="math">\\mathcal{E}_d / \\mathbf{F}_p: -x^2 + y^2 = 1 + dx^2y^2</span>  defined over  <span class="math">\\mathbf{F}_p</span> , where  <span class="math">d = -(A - 2) / (A + 2)</span> , and the target security level is  <span class="math">\\lambda</span> . A model for the quadratic twist is  <span class="math">\\mathcal{E}_d&#x27; / \\mathbf{F}_p: -x^2 + y^2 = 1 + (1/d)x^2y^2</span> . The curve  <span class="math">\\mathcal{E}_d</span>  is birationally equivalent to the Montgomery curve  <span class="math">E_A / \\mathbf{F}_p: y^2 = x^3 + Ax^2 + x</span>  with quadratic twist  <span class="math">E_{-A} / \\mathbf{F}_p: y^2 = x^3 - Ax^2 + x</span> . The group orders are  <span class="math">\\# \\mathcal{E}_d(\\mathbf{F}_p) = 4r</span>  and  <span class="math">\\# \\mathcal{E}_d&#x27;(\\mathbf{F}_p) = 4r&#x27;</span> , where  <span class="math">r</span>  and  <span class="math">r&#x27;</span>  are both prime, and  <span class="math">4r &amp;lt; p</span>  for all curves. The value  <span class="math">d_0 = -(A + 2)/4 = -1/(d + 1)</span>  defines a curve with the same group order as that given by  <span class="math">d</span> , i.e.  <span class="math">\\# \\mathcal{E}_{d_0}(\\mathbf{F}_p) = 4r</span>  and  <span class="math">\\# \\mathcal{E}_{d_0}&#x27;(\\mathbf{F}_p) = 4r&#x27; = \\# \\mathcal{E}_{-(d_0 + 1)}</span> . The  <span class="math">\\rho</span>  complexity is an estimate for the actual security of the ECDLP against Pollard's  <span class="math">\\rho</span>  method, it is  <span class="math">\\log_2(\\sqrt{\\pi/4} \\cdot \\sqrt{r})</span>  rounded to one decimal.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">target security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2240(216 - 88) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-54314</td>

            <td class="px-3 py-2 border-b border-gray-700">13578</td>

            <td class="px-3 py-2 border-b border-gray-700">126.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2240(214 - 127) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-55790</td>

            <td class="px-3 py-2 border-b border-gray-700">13947</td>

            <td class="px-3 py-2 border-b border-gray-700">125.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2256 - 189</td>

            <td class="px-3 py-2 border-b border-gray-700">-61370</td>

            <td class="px-3 py-2 border-b border-gray-700">15342</td>

            <td class="px-3 py-2 border-b border-gray-700">126.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2255 - 765</td>

            <td class="px-3 py-2 border-b border-gray-700">-240222</td>

            <td class="px-3 py-2 border-b border-gray-700">60055</td>

            <td class="px-3 py-2 border-b border-gray-700">126.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2376(28 - 79) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-113758</td>

            <td class="px-3 py-2 border-b border-gray-700">28439</td>

            <td class="px-3 py-2 border-b border-gray-700">190.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2368(214 - 5) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-2870790</td>

            <td class="px-3 py-2 border-b border-gray-700">717698</td>

            <td class="px-3 py-2 border-b border-gray-700">189.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2384 - 317</td>

            <td class="px-3 py-2 border-b border-gray-700">-1332778</td>

            <td class="px-3 py-2 border-b border-gray-700">333194</td>

            <td class="px-3 py-2 border-b border-gray-700">190.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2383 - 421</td>

            <td class="px-3 py-2 border-b border-gray-700">-2095962</td>

            <td class="px-3 py-2 border-b border-gray-700">523990</td>

            <td class="px-3 py-2 border-b border-gray-700">190.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2496(216 - 491) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-305778</td>

            <td class="px-3 py-2 border-b border-gray-700">76444</td>

            <td class="px-3 py-2 border-b border-gray-700">254.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">2496(214 - 290) - 1</td>

            <td class="px-3 py-2 border-b border-gray-700">-2320506</td>

            <td class="px-3 py-2 border-b border-gray-700">580126</td>

            <td class="px-3 py-2 border-b border-gray-700">253.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2512 - 569</td>

            <td class="px-3 py-2 border-b border-gray-700">-2550434</td>

            <td class="px-3 py-2 border-b border-gray-700">637608</td>

            <td class="px-3 py-2 border-b border-gray-700">254.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">2511 - 481</td>

            <td class="px-3 py-2 border-b border-gray-700">-4390390</td>

            <td class="px-3 py-2 border-b border-gray-700">1097597</td>

            <td class="px-3 py-2 border-b border-gray-700">254.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">have not experimented with using a smaller radix system to accumulate the intermediate carries, at the cost of increasing the number of multiplications. We leave the investigation of such approaches as future work.</p>

    <p class="text-gray-300">Primes of the form  <span class="math">2^{\\alpha} - \\gamma</span> . Selecting primes of a special form to enhance the performance of the modular reduction is not new. The primes standardized in the digital signature standard [58] have a special form allowing fast reduction based on the work by Solinas [54]. Even faster modular reduction can be achieved by selecting primes of the form  <span class="math">p = 2^{\\alpha} - \\gamma</span> , known as pseudo-Mersenne primes. In this case, the value  <span class="math">\\alpha</span>  is determined by the security parameter and is typically a multiple of 64 (or slightly smaller). The integer  <span class="math">\\gamma</span>  is chosen to be a small positive integer, i.e. significantly smaller than  <span class="math">2^{32}</span> . Given two integers  <span class="math">x</span>  and  <span class="math">y</span>  such that  <span class="math">0 \\leq x, y &amp;lt; 2^{\\alpha} - \\gamma</span> ,</p>

    <p class="text-gray-300">one can compute  <span class="math">x \\cdot y \\mod (2^{\\alpha} - \\gamma)</span>  by first computing the product and writing this in a radix-  <span class="math">2^{\\alpha}</span>  system as  <span class="math">x \\cdot y = z_h \\cdot 2^{\\alpha} + z_\\ell</span> . A first reduction step, based on the shape of the modulus, is  <span class="math">z_h \\cdot 2^{\\alpha} + z_\\ell \\equiv z_\\ell + z_h \\cdot \\gamma</span>  (mod  <span class="math">2^{\\alpha} - \\gamma</span> ) =  <span class="math">z</span> , where  <span class="math">0 \\leq z &amp;lt; (\\gamma + 1)2^{\\alpha}</span> . If this step is repeated, the result is such that  <span class="math">0 \\leq z &amp;lt; 2^{\\alpha} + \\gamma^{2}</span> , which can finally be brought into the desired range by applying an additional correction modulo  <span class="math">p</span>  using subtractions. A standard way of enhancing the performance is to use a redundant representation: instead of reducing  <span class="math">z</span>  to the range  <span class="math">[0, 2^{\\alpha} - \\gamma)</span> , one can often more efficiently reduce  <span class="math">z</span>  to the range  <span class="math">[0, 2^{\\alpha})</span> , or to the range  <span class="math">[0, 2^{2s})</span>  if  <span class="math">\\alpha</span>  is a few bits smaller than  <span class="math">2s</span>  (at a target security level of  <span class="math">s</span>  bits). The latter case can be optimized further by computing exclusively in such a redundant form and</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">performing a sole correction at the end of the scalar multiplication.</p>

    <p class="text-gray-300">Given a security level of <span class="math">s</span> bits, we consider the parameter <span class="math">\\alpha\\in\\{2s,2s-1\\}</span>. Taking <span class="math">\\alpha=2s</span> makes the prime as large as possible, matching one of the requirements to achieve maximal ECDLP security at the <span class="math">s</span>-bit security level. Taking <span class="math">\\alpha=2s-1</span> sacrifices half a bit of ECDLP security in favor of potential enhancements in efficiency, as described above. Thus, fixing <span class="math">s</span> results in two possible values for <span class="math">\\alpha</span> and subsequently two primes of the form <span class="math">2^{\\alpha}-\\gamma</span>: for a fixed <span class="math">\\alpha</span>, we choose the smallest <span class="math">\\gamma</span> such that <span class="math">2^{\\alpha}-\\gamma</span> is both prime and congruent to 3 modulo 4 (the rational behind this congruence condition is discussed below). Following our curve selection criteria, the values <span class="math">\\gamma</span> for the curves under analysis are always smaller than <span class="math">2^{10}</span>, which makes them attractive for efficient implementation on 16, 32 and 64-bit platforms.</p>

    <p class="text-gray-300">Primes of the form <span class="math">\\mathbf{2}^{\\alpha}(\\mathbf{2}^{\\beta}-\\gamma)-1</span>. Another approach to select primes is inspired by Montgomery arithmetic [46]. The idea behind Montgomery multiplication is to replace the relatively expensive divisions by computationally inexpensive logical shifts when computing the modular reduction. Some computations (and storage) can be avoided when primes of the form <span class="math">p=2^{\\alpha}(2^{\\beta}-\\gamma)-1</span> are used for positive integers <span class="math">\\alpha</span>, <span class="math">\\beta</span> and <span class="math">\\gamma</span> (cf. [40; 38; 1; 32; 15]). When the prime <span class="math">p</span> is two bits short of a multiple of the word size <span class="math">w</span> (i.e. <span class="math">w\\mid\\alpha+\\beta+2</span>), one can avoid a conditional subtraction in every multiplication [59].</p>

    <p class="text-gray-300">There are different ways to construct Montgomery-friendly primes: for example, [32] prefers <span class="math">\\gamma</span> to be a power of two, while [15] sets <span class="math">\\beta=64</span> and <span class="math">\\gamma</span> as small as possible to specifically target 64-bit platforms. We make choices of <span class="math">\\alpha</span>, <span class="math">\\beta</span> and <span class="math">\\gamma</span> such that the modular arithmetic can be implemented efficiently on a wide range of platforms. Given a security level of <span class="math">s</span> bits, we consider <span class="math">\\alpha=8\\delta</span> and <span class="math">\\beta\\in\\{2s-\\alpha,2s-2-\\alpha\\}</span>, and choose <span class="math">\\gamma</span> and <span class="math">\\delta</span> as the smallest positive integers such that <span class="math">p=2^{\\alpha}(2^{\\beta}-\\gamma)-1</span> is prime and <span class="math">\\lceil\\log_{2}(p)\\rceil=2s</span> (resp. <span class="math">\\lceil\\log_{2}(p)\\rceil=2s-2</span>) in the setting of <span class="math">\\beta=2s-\\alpha</span> (resp. <span class="math">\\beta=2s-2-\\alpha</span>). We start with <span class="math">\\delta=1</span> and increment it by 1 (if necessary) until <span class="math">\\gamma</span> is found. For instance, for <span class="math">s=192</span> and <span class="math">\\beta=2s-\\alpha</span>, we observe that <span class="math">(\\delta,\\gamma)=(1,79)</span> results in a prime which can be written as</p>

    <p class="text-gray-300"><span class="math">2^{376}(2^{8}-79)-1</span> <span class="math">=2^{352}(2^{32}-2^{24}\\cdot 79)-1</span> <span class="math">=2^{320}(2^{64}-2^{56}\\cdot 79)-1,</span></p>

    <p class="text-gray-300">for usage on 8-, 32- and 64-bit platforms, respectively. This has the advantage that the reduction step, which has to be computed at every iteration inside the interleaved Montgomery algorithm, can be computed using only a multiply-and-add and an addition instruction. Note that, by construction, primes of this form are always congruent to 3 modulo 4.</p>

    <p class="text-gray-300">Constant-time modular arithmetic. One of the measures to guard software implementations against various types of side-channel analysis such as timing attacks [39] is to ensure a constant running time. In practice, this often means writing code which does not contain branches depending on secret data. For instance, the interleaved Montgomery multiplication algorithm requires a conditional subtraction at the end. To remove this, we always compute the subtractions and select (mask) the correct value depending on the conditional flag. In the setting of primes of the shape <span class="math">2^{\\alpha}-\\gamma</span>, one must always compute the worst-case number of reduction rounds in order to ensure constant runtime.</p>

    <p class="text-gray-300">Besides the “standard” modular operations, there is also the need for constant-time methods to compute the modular inversion and the modular square roots. In order to compute the inversion modulo a prime <span class="math">p</span>, one can use Fermat’s little theorem: i.e. compute <span class="math">a^{p-2}\\equiv a^{-1}</span> (mod <span class="math">p</span>). Since our chosen primes all have a special shape, finding efficient addition chains for this exponentiation is not difficult. For the <span class="math">n</span>-bit primes considered in this work, we found that we can always compute the modular inversion using at most <span class="math">1.11\\lceil\\log_{2}(p)\\rceil</span> modular multiplications and modular squarings. If <span class="math">p\\equiv 3</span> (mod 4), then one can compute a modular square root <span class="math">x</span> (if it exists) of an element <span class="math">a</span> using <span class="math">x\\equiv a^{\\frac{p+1}{4}}\\pmod{p}</span>. Since this can be performed efficiently, and in constant-time, we require all of our primes to be congruent to 3 modulo 4.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Curve Selection</h2>

    <p class="text-gray-300">In this section we explain how the curves in Tables 1 and 2 were chosen based on the selection of primes that is outlined in Section 2. For each chosen prime <span class="math">p\\equiv 3</span> (mod 4), we provide two curves: one is a prime order short Weierstrass curve, while the other is an almost-prime order twisted Edwards curve.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">3.1 Curve selection for Weierstrass curves</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a fixed prime <span class="math">p</span>, a specific curve <span class="math">E_{b}:y^{2}=x^{3}-3x+b</span> is uniquely determined by the curve parameter <span class="math">b\\in\\mathbf{F}_{p}\\backslash\\{\\pm 2,0\\}</span>. Note that, since <span class="math">p\\equiv 3\\bmod 4</span>, its non-trivial quadratic twist <span class="math">E_{b}^{\\prime}</span> has the curve equation <span class="math">E_{b}^{\\prime}:y^{2}=x^{3}-3x-b</span>. In order to guarantee twist-security [5], we require both the group orders <span class="math">r=\\#E_{b}(\\mathbf{F}_{p})</span> and <span class="math">r^{\\prime}=\\#E_{b}^{\\prime}(\\mathbf{F}_{p})</span> to be prime. We have <span class="math">r=p+1-t</span> and <span class="math">r^{\\prime}=p+1+t</span> for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\sqrt{p}<span class="math"> and demand </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;1$ because</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">curves with <span class="math">t \\in \\{0,1\\}</span> are weak. Thus, depending on the sign of the trace <span class="math">t</span>, either <span class="math">r &amp;gt; p, r&#x27; &amp;lt; p</span> or <span class="math">r &amp;lt; p, r&#x27; &amp;gt; p</span>. To ease implementation, we demand that <span class="math">r &amp;lt; p</span> for all curves, i.e. we choose the curve with positive trace. To leave no room for manipulating the curve choice, we select all curve parameters deterministically, namely by choosing the integer <span class="math">b</span> with the smallest absolute value that yields a curve with the above properties. Based on these considerations, the selection process is completely explained in accordance with the rigidity condition of [12]. Specifically, we search for a suitable coefficient <span class="math">b</span> by starting with <span class="math">b = 1</span> and incrementing <span class="math">b</span> by one until both <span class="math">r</span> and <span class="math">r&#x27;</span> are prime. For each value of <span class="math">b</span>, we use the Schoof-Elkies-Atkin (SEA) point counting algorithm [52] in Magma [17] to compute the trace <span class="math">t</span> of <span class="math">E_b</span>, such that <span class="math">r = p + 1 - t</span> and <span class="math">r&#x27; = p + 1 + t</span>. We use the implementation's 'early abort' feature that abandons the computation when small factors are found either in the curve's or the twist's group order. Because of the curve model for <span class="math">E_b&#x27;</span>, the search only considers positive values of <span class="math">b</span> and we select the sign of <span class="math">b</span> to ensure that <span class="math">r &amp;lt; p</span>. The resulting curves are summarized in Table 1.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3.2 Curve selection for twisted Edwards (and Montgomery) curves</h2>

    <p class="text-gray-300">For a fixed prime <span class="math">p</span>, a specific twisted Edwards curve <span class="math">\\mathcal{E}_d: -x^2 + y^2 = 1 + dx^2y^2</span> is uniquely determined by the curve parameter <span class="math">d \\in \\mathbf{F}_p \\backslash \\{0, -1\\}</span>. Let <span class="math">A = 2\\frac{1 - d}{d + 1}</span>, and <span class="math">B = -(A + 2)</span>. Theorem 3.2 of [7] shows that the twisted Edwards curve <span class="math">\\mathcal{E}</span> and the Montgomery curve <span class="math">By^2 = x^3 + Ax^2 + x</span> are birationally equivalent. If <span class="math">B</span> is a square in <span class="math">\\mathbf{F}_p</span> (which it is for all our curves), then <span class="math">\\mathcal{E}_d</span> is birationally equivalent to <span class="math">E_A: y^2 = x^3 + Ax^2 + x</span>. As for the Weierstrass curves, we demand <span class="math">t &amp;gt; 1</span> to exclude the weak curves with <span class="math">t \\in \\{0,1\\}</span> and to ensure that <span class="math">4r &amp;lt; p</span>.</p>

    <p class="text-gray-300">Ideally, it would be desirable to have a curve with minimal parameter <span class="math">d</span> in the twisted Edwards form and minimal parameter <span class="math">A</span> in the Montgomery form. Unfortunately, existing curve proposals have been forced to pick one form and optimize it at the expense of the other one. We show in Section 3.3 below, that a search minimizing the absolute value of the parameter <span class="math">d</span> would find curves with the same group orders for curve and twist, where the latter corresponds to <span class="math">-(d + 1)</span>. This means that a search for minimal absolute value of <span class="math">d</span> will always find positive <span class="math">d</span> first, which corresponds to negative <span class="math">A</span>. Our search thus minimizes the absolute values of <span class="math">A</span> and <span class="math">d</span> at the same time.</p>

    <p class="text-gray-300">For each fixed <span class="math">p</span>, we start with <span class="math">A = -6</span> and search for <span class="math">A \\in 2 + 4\\mathbf{Z}</span> (subtracting 4 each time) until <span class="math">\\# E_A = 4r</span> and <span class="math">\\# E_A&#x27; = 4r&#x27;</span>, where <span class="math">r</span> and <span class="math">r&#x27;</span> are both prime. Note that the discussion in Section 3.3 also shows that <span class="math">B = -(A + 2)</span> is always a square in <span class="math">\\mathbf{F}_p</span>, which means that <span class="math">E_A&#x27;: y^2 = x^3 - Ax^2 + x</span> is a model for the non-trivial quadratic twist of <span class="math">E_A</span>. Again, for each <span class="math">A</span>, we use the SEA algorithm [52] in Magma [17] to compute the trace <span class="math">t</span> of <span class="math">E</span>, which determines <span class="math">\\# E_A = p + 1 - t</span> and <span class="math">\\# E_A&#x27; = p + 1 + t</span>. Section 3.3 also shows that <span class="math">A^2 - 4</span> is non-square in <span class="math">\\mathbf{F}_p</span>, which simplifies notions of completeness on <span class="math">E</span> (see [5]). Furthermore, we check that the curve satisfies all conditions posed by [12], if one of them is not met², we continue with the next value for <span class="math">A</span>. We note that the cofactors of 4 are minimal when insisting on an <span class="math">\\mathbf{F}_p</span>-rational twisted Edwards and/or Montgomery form. The resulting curves are summarized in Table 2.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3.3 Correspondence between minimal <span class="math">A</span> and <span class="math">d</span> for twisted Edwards curves</h2>

    <p class="text-gray-300">Table 2 contains a column with values for the parameter <span class="math">d_0 = -(A + 2) / 4</span>, which can be used for implementing twisted Edwards curves defined over our prime fields. The curve <span class="math">\\mathcal{E}_{d_0} / \\mathbf{F}_p: -x^2 + y^2 = 1 + d_0 x^2 y^2</span> has the same number of <span class="math">\\mathbf{F}_p</span>-rational points as the curve <span class="math">\\mathcal{E}_d / \\mathbf{F}_p: -x^2 + y^2 = 1 + dx^2 y^2</span> with <span class="math">d = -(A - 2) / (A + 2)</span> and the Montgomery curve <span class="math">E_A / \\mathbf{F}_p: y^2 = x^3 + Ax^2 + x</span>. Furthermore, the curve <span class="math">\\mathcal{E}_{-(d_0 + 1)} / \\mathbf{F}_p: -x^2 + y^2 = 1 - (d_0 + 1) x^2 y^2</span> has the same number of <span class="math">\\mathbf{F}_p</span>-rational points as the quadratic twist <span class="math">\\mathcal{E}_d&#x27;</span> and the quadratic twist <span class="math">E_{-A}</span>. In this section, we show that this is true in general, and that therefore, the relation between <span class="math">d_0</span> and <span class="math">A</span> shows that the value <span class="math">d_0</span> is the minimal value for <span class="math">d</span> defining <span class="math">\\mathcal{E}_d</span> such that all the criteria in our curve selection are satisfied if and only if <span class="math">A</span> is the minimal such value for the Montgomery form. This shows that it is not necessary to search for a new set of twisted Edwards curves if one wants to minimize the parameter <span class="math">d</span> instead of the Montgomery parameter <span class="math">A</span>. One can simply use the curve defined by <span class="math">d_0</span>.</p>

    <p class="text-gray-300">The following lemma connects the two twisted Edwards curves <span class="math">\\mathcal{E}_d</span> and <span class="math">\\mathcal{E}_{d_0}</span> via an isogeny whenever <span class="math">d_0 = -1 / (d + 1)</span>. It also gives a condition on <span class="math">d_0</span> which determines whether the map is defined over <span class="math">\\mathbf{F}_p</span>. If this is the case, both curves have the same number of <span class="math">\\mathbf{F}_p</span>-rational points.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> Let <span class="math">\\mathcal{E}_d: -x^2 + y^2 = 1 + dx^2y^2</span> be a twisted Edwards curve defined over a prime field <span class="math">\\mathbf{F}_p</span> and let <span class="math">d_0 = -1/(d+1) \\in \\mathbf{F}_p</span>. Then there exists a 4-isogeny</p>

    <p class="text-gray-300">² The only instance where the first twisted Edwards curve we found did not fulfill all of the SafeCurves requirements was in the search for ed-383-mers: the constant <span class="math">A = 1629146</span> corresponds to a curve-twist pair with <span class="math">\\#E_A = 4r</span> and <span class="math">E_A&#x27; = 4r&#x27;</span>, where <span class="math">r</span> and <span class="math">r&#x27;</span> are both prime, but the embedding degree of <span class="math">E_A</span> with respect to <span class="math">r</span> is <span class="math">(r - 1)/188</span>, which fails to meet the minimum requirement of <span class="math">(r - 1)/100</span> imposed in [12].</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300"><span class="math">\\phi:\\mathcal{E}_{d}\\to\\mathcal{E}_{d_{0}}</span>. If <span class="math">d_{0}</span> is a square in <span class="math">\\mathbf{F}_{p}</span>, the isogeny is defined over <span class="math">\\mathbf{F}_{p}</span>, in particular <span class="math">\\#\\mathcal{E}_{d}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{d_{0}}(\\mathbf{F}_{p})</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The isogeny <span class="math">\\phi</span> is one of the isogenies described in Section 3 of [2]. This means, it is the composition of maps</p>

    <p class="text-gray-300"><span class="math">\\phi=\\hat{\\psi}_{-1,-1/(d+1)}\\circ\\sigma\\circ\\psi_{-1,d}.</span></p>

    <p class="text-gray-300">The map <span class="math">\\psi_{-1,d}</span> is the 2-isogeny <span class="math">\\psi_{-1,d}:\\mathcal{E}_{d}\\to L_{-d}</span> to the Legendre form curve <span class="math">L_{-d}:y^{2}=x(x-1)(x+d)</span> given in <em>(2, Theorem 3.2)</em>, and <span class="math">\\hat{\\psi}_{-1,-1/(d+1)}:L_{1/(d+1)}\\to\\mathcal{E}_{-1/(d+1)}</span> is the dual of the corresponding isogeny for <span class="math">1/(d+1)</span>. The map <span class="math">\\sigma</span> is equal to the isomorphism <span class="math">\\sigma_{2}\\sigma_{1}:L_{-d}\\to L_{1/(d+1)}</span> given in <em>(2, Section 3.2)</em>. The composition <span class="math">\\phi</span> is defined over <span class="math">\\mathbf{F}_{p}</span> if <span class="math">d_{0}</span> and thus <span class="math">-(d+1)</span> is a square in <span class="math">\\mathbf{F}_{p}</span>. This proves the lemma. ∎</p>

    <p class="text-gray-300">The next result uses the previous isogeny to show that the original curve <span class="math">\\mathcal{E}_{d}</span> and its twist <span class="math">\\mathcal{E}_{d}^{\\prime}</span> each have corresponding curves with small parameters <span class="math">d_{0}</span> and <span class="math">-(d_{0}+1)</span>, respectively, which have the same number of <span class="math">\\mathbf{F}_{p}</span>-rational points, provided that both these small parameters are squares in <span class="math">\\mathbf{F}_{p}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">A\\in\\mathbf{F}_{p}\\setminus\\{-2,2\\}</span>, <span class="math">d=-(A-2)/(A+2)</span> and <span class="math">d_{0}=-(A+2)/4</span> such that both <span class="math">d_{0}</span> and <span class="math">-(d_{0}+1)</span> are squares in <span class="math">\\mathbf{F}_{p}</span>. Then <span class="math">\\#\\mathcal{E}_{d}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{d_{0}}(\\mathbf{F}_{p})</span>. Moreover, <span class="math">\\#\\mathcal{E}_{d}^{\\prime}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{-(d_{0}+1)}(\\mathbf{F}_{p})</span>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The first part follows from Lemma 1 because <span class="math">d_{0}=-1/(d+1)</span>. Since the twist <span class="math">\\mathcal{E}_{d}^{\\prime}=\\mathcal{E}_{1/d}</span>, the second part follows from Lemma 1 with <span class="math">d</span> replaced by <span class="math">1/d</span>, which means that <span class="math">d_{0}</span> is replaced by <span class="math">-(d_{0}+1)</span>. ∎</p>

    <p class="text-gray-300">Finally, we show that indeed our search criteria, in particular the facts that <span class="math">p\\equiv 3\\pmod{4}</span> and that both group orders are not divisible by 8, imply that <span class="math">d_{0}</span> and <span class="math">-(d_{0}+1)</span> as given in our setting are squares in <span class="math">\\mathbf{F}_{p}</span>, which shows that the correspondence above holds.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">p\\equiv 3\\pmod{4}</span>, <span class="math">d_{0}\\in\\mathbf{F}_{p}</span> and let <span class="math">\\mathcal{E}_{d_{0}}:-x^{2}+y^{2}=1+d_{0}x^{2}y^{2}</span> be a twisted Edwards curve such that <span class="math">\\#\\mathcal{E}_{d_{0}}(\\mathbf{F}_{p})=4r</span> and <span class="math">\\#\\mathcal{E}_{d_{0}}^{\\prime}(\\mathbf{F}_{p})=4r^{\\prime}</span> for primes <span class="math">r</span> and <span class="math">r^{\\prime}</span>. Then <span class="math">d_{0}</span> and <span class="math">-(d_{0}+1)</span> are both squares in <span class="math">\\mathbf{F}_{p}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first prove that <span class="math">d_{0}</span> is a square in <span class="math">\\mathbf{F}_{p}</span>. Assume that it is not a square. Section 3 in [8] provides an exhaustive description of all points of order 2 and 4 on a twisted Edwards curve. If <span class="math">d_{0}</span> is not a square, then <span class="math">-1/d_{0}</span> is a square because <span class="math">p\\equiv 3\\pmod{4}</span>. Then the full 2-torsion is defined over <span class="math">\\mathbf{F}_{p}</span>, it consists of the affine point <span class="math">(0,-1)</span> and two points at infinity <span class="math">((1:0),(\\pm\\sqrt{-1/d_{0}}))</span> (written as completed points in projective space <span class="math">\\mathbb{P}^{1}\\times\\mathbb{P}^{1}</span>, see <em>(8, Section 2.7)</em>). Let <span class="math">s\\in\\mathbf{F}_{p}</span> with <span class="math">s^{2}=-1/d_{0}</span>, then exactly one of <span class="math">\\pm s</span> is a square, assume without loss of generality that it is <span class="math">s</span>. Then this value gives 4 affine points <span class="math">(\\pm\\sqrt{s},\\pm\\sqrt{s})</span> (signs chosen independently) of order 4 defined over <span class="math">\\mathbf{F}_{p}</span>. The group structure of the 4-torsion on <span class="math">\\mathcal{E}_{d_{0}}</span> that is defined over <span class="math">\\mathbf{F}_{p}</span> is thus <span class="math">\\mathbf{Z}_{2}\\times\\mathbf{Z}_{4}</span> and has order 8. Therefore 8 must divide <span class="math">\\#\\mathcal{E}_{d_{0}}(\\mathbf{F}_{p})</span>, which contradicts our assumption that the group order is <span class="math">4r</span> for <span class="math">r</span> prime. Hence, <span class="math">d_{0}</span> is a square.</p>

    <p class="text-gray-300">We know that the twist <span class="math">\\mathcal{E}_{d_{0}}^{\\prime}</span> is birationally equivalent to <span class="math">\\mathcal{E}_{1/d_{0}}</span>, and we have already shown that <span class="math">d_{0}</span> is a square, so <span class="math">1/d_{0}</span> is a square. We can apply Lemma 1 with <span class="math">d_{0}</span> replaced by <span class="math">1/d_{0}</span>, which means that <span class="math">d=-(d_{0}+1)</span>, and obtain that <span class="math">\\#\\mathcal{E}_{-(d_{0}+1)}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{1/d_{0}}(\\mathbf{F}_{p})=4r^{\\prime}</span>. Now looking at the 4-torsion defined over <span class="math">\\mathbf{F}_{p}</span> as above yields that <span class="math">-(d_{0}+1)</span> is a square in <span class="math">\\mathbf{F}_{p}</span>. ∎</p>

    <p class="text-gray-300">The minimality of <span class="math">d_{0}</span>. All our selected twisted Edwards curves satisfy the conditions of the previous two lemmas. Therefore, one can choose to work with the isogenous curves defined by <span class="math">d_{0}</span> or <span class="math">-(d_{0}+1)</span>, whichever is more convenient. The isogenous curves and their twists have the same orders as the original curves and their twists. Therefore all conditions required in the curve selection are satisfied with the added benefit of a small <span class="math">d</span>-value.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We argue that <span class="math">d_{0}</span> is of minimal absolute value defining a curve that satisfies the search criteria. Assume that <span class="math">A</span> is a coefficient with minimal absolute value that yields a desired curve when minimizing for the Montgomery parameter (like the values for <span class="math">A</span> in our examples). A search that minimizes the absolute value of the parameter <span class="math">d</span> in the twisted Edwards model <span class="math">\\mathcal{E}_{d}</span>, must find the value <span class="math">d_{0}</span> (or <span class="math">-(d_{0}+1)</span>) first since <span class="math">A=-(4d_{0}+2)</span>. Without loss of generality, let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{0}+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, i.e. </span>d_{0}&gt;0<span class="math">, otherwise interchange </span>d_{0}<span class="math"> and </span>-(d_{0}+1)<span class="math">. Indeed, assume that a </span>d_{1}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> leads to a curve that satisfies all criteria. Let </span>A_{1}=-(4d_{1}+2)<span class="math">. By Lemma 3, </span>d_{1}<span class="math"> and </span>-(d_{1}+1)<span class="math"> are squares, then by Lemma 2, </span>\\#\\mathcal{E}_{d_{1}}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{\\hat{d}_{1}}(\\mathbf{F}_{p})=\\#E_{A_{1}}(\\mathbf{F}_{p})<span class="math">, where </span>\\hat{d}_{1}=-(A_{1}-2)/(A_{1}+2)<span class="math"> and </span>\\#\\mathcal{E}_{d_{1}}^{\\prime}(\\mathbf{F}_{p})=\\mathcal{E}_{-(d_{1}+1)}(\\mathbf{F}_{p})=\\#\\mathcal{E}_{1/\\hat{d}_{1}}(\\mathbf{F}_{p})=\\#E_{-A_{1}}(\\mathbf{F}_{p})<span class="math">. This means that the curve </span>E_{A_{1}}$ satisfies the search criteria.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since we fixed <span class="math">d_{0}&amp;gt;0</span>, we have <span class="math">A&amp;lt;0</span>. By assumption, we have $-A=4d_{0}+2=4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2&gt;4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2<span class="math">. Now consider the two cases </span>d_{1}&gt;0<span class="math"> and </span>d_{1}&lt;0<span class="math">. If </span>d_{1}&gt;0<span class="math">, then </span>A_{1}=-(4d_{1}+2)&lt;0<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=-A&gt;4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2=4d_{1}+2=-A_{1}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, contradicting the minimality of </span>A<span class="math">. Similarly, if </span>d_{1}&lt;0<span class="math">, then </span>A_{1}&gt;0<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=-A&gt;4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2&gt;4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d_{1}+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2=-4(d_{1}+1)+2=-(4d_{1}+2)=A_{1}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, again a contradiction. Overall, this means that </span>d_{0}$ must be the coefficient with minimal absolute value.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.4 Curve properties</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In both families of curves, note that for primes of the form <span class="math">2^{\\alpha}-\\gamma</span>, the bitlengths of <span class="math">r</span> and <span class="math">r^{\\prime}</span> differ by 1, since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gg\\gamma<span class="math"> in general; for primes of the form </span>2^{\\alpha}(2^{\\beta}-\\gamma)-1<span class="math">, the bitlengths of </span>r<span class="math"> and </span>r^{\\prime}<span class="math"> are always equal when </span>\\gamma\\neq 0<span class="math">. The curves in Table 2 can be used in different curve models: in the twisted Edwards model, in the Montgomery model for implementing Montgomery ladders, and also in the original Edwards model allowing complete addition formulas [11]. The latter can be seen as follows. Since </span>p\\equiv 3\\pmod{4}<span class="math">, </span>E_{A}<span class="math"> is birationally equivalent to an Edwards curve by [7, Theorem 3.4]. Using the maps discussed in <em>(7, Section 3)</em>, one can show that </span>E_{A}:y^{2}=x^{3}+Ax^{2}+x<span class="math"> is birationally equivalent to </span>\\mathcal{E}_{-1/d}:x^{2}+y^{2}=1-(1/d)x^{2}y^{2}<span class="math">. For all of our curves, </span>d<span class="math"> is a square in </span>\\mathbf{F}_{p}<span class="math">, so </span>-1/d<span class="math"> is not a square, which means that the addition law on </span>\\mathcal{E}_{-1/d}<span class="math"> is complete. All of the curves in Table 2 allow for an efficient map from a subset of their </span>\\mathbf{F}_{p}<span class="math">-rational points to bit strings of a certain length, such that they are indistinguishable from uniform random bitstrings of the same length (see [10], which is based on [29]). However, note that curves defined over pseudo-Mersenne primes are more suitable for achieving indistinguishability than those over Montgomery-friendly primes because for the latter primes </span>p<span class="math">, the value </span>(p+1)/2<span class="math"> is further away from a power of 2 (see <em>(10, §2.6)</em>). The prime-order Weierstrass curves presented in Table 1 are similar in their basic properties to the NIST curves, as they have the same curve model, share the parameter </span>a=-3<span class="math">, and include prime fields of the same bit lengths as the ones for the NIST curves [58]. However, we stress that the curves in Table 1 do not allow any room for manipulations, which can be the case when the curve parameter </span>b$ is allowed to be chosen “randomly”. Our curves are <em>twist-secure</em>, do not allow <em>transfers</em>, and have large <em>discriminants</em> (notions used to guard against certain attacks; e.g., see [12]). The work in [57] shows that indistinguishability can also be achieved for our prime-order Weierstrass curves in Table 1, however the resulting bit strings are twice as large as those that result from applying [10; 29] to the twisted Edwards curves in Table 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-14" class="text-2xl font-bold">4 Efficient, Constant-time, and Exceptionless Scalar Multiplications</h2>

    <p class="text-gray-300">To protect against certain types of side-channel attacks [39], it is essential that scalar multiplications are computed in <em>constant-time</em>. This means that the running time of the algorithm for computing a scalar multiplication <span class="math">kP</span> must be independent of the scalar <span class="math">k</span> and the point <span class="math">P</span>. Classical curve arithmetic formulas have exceptional cases, i.e. they do not work for all points. Having conditional statements in the code that check for these cases means the algorithms have a variable running time depending on different input cases, but simply leaving them out might lead to exceptional point attacks that produce wrong results or cause other implementation errors. In this section we outline how constant-time algorithms can be achieved efficiently for our chosen Weierstrass and twisted Edwards curves in two different settings: the variable- and fixed-base scenarios. The variable-base scenario refers to the case in which the base point <span class="math">P</span> can be different for each execution of the algorithm. In the fixed-base case, multiples of a public constant point can be precomputed, which allows different optimization possibilities. In Appendix A we present an algorithm for the double-scalar scenario, which carries out a computation of the form <span class="math">k_{1}P_{1}+k_{2}P_{2}</span> (see Algorithm 9). This occurs for example in the verification of ECDSA signatures. In this setting the verification algorithm operates on public inputs only, and one can profit from more efficient variable-time algorithms since the implementation does not require side-channel protection or constant-time execution.</p>

    <p class="text-gray-300">We discuss the various cases for implementing scalar multiplication for the different curve models and algorithm choices. We list all algorithms as pseudo-code in Appendix A (scalar multiplication, point validation, precomputation and recoding) and in Appendix B (point operations). The reader is referred to Appendix C for complete details on the selection of explicit formulas. Note that several of these algorithms contain if-statements, which are marked in the pseudo-code according to their nature. For example, some of these statements occur in algorithms that are only run on public inputs and do not need to run in constant time; some of them are implemented in constant time via masking techniques; and some of them are there merely to allow us to represent several algorithms in one pseudo-code algorithm environment and to re-use the different variants in different scenarios. As soon as a specific scenario is chosen, these statements are always executed under the same condition. The remaining if-statements are the ones that when implemented introduce data-dependent branches into the algorithms. They occur only in algorithms for point doubling, point addition and merged point doubling/addition, where they correspond to exceptions, i.e. the exceptional cases for which the given formulas are not valid. But, whenever the implementation needs to be constant-time, the conditions for entering these if-statements are always false such that they are never executed (and can be removed in the code). Below, we argue that indeed no exceptional cases occur</p>

    <p class="text-gray-300">and that the proposed algorithms can be implemented to run in constant time (when used as described in the algorithms in Appendix A). Note that the neutral element on Weierstrass curves is the point at infinity, i.e. the point <span class="math">(0\\colon 1\\colon 0)</span> in projective coordinates, while on twisted Edwards curves the neutral element is the rational point <span class="math">(0,1)</span>, and in the Montgomery ladder the neutral element is <span class="math">(X\\colon Z)=(0\\colon 0)</span>. In this paper, they are all denoted by <span class="math">\\mathcal{O}</span>.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.1 Weierstrass Scalar Multiplications</h3>

    <p class="text-gray-300">Let <span class="math">E_{b}/F_{p}</span> be any of the Weierstrass curves in Table 1, with <span class="math">r=\\#E_{b}(\\mathbf{F}_{p})</span> prime. Let <span class="math">k</span> be an integer scalar and <span class="math">P=(x_{1},y_{1})\\in\\mathbf{F}_{p}\\times\\mathbf{F}_{p}</span>. We consider the computation of efficient, constant-time and exception-free scalar multiplications in two scenarios.</p>

    <p class="text-gray-300">The variable-base scenario. On input of the scalar <span class="math">k</span> and variable point <span class="math">P=(x_{1},y_{1})</span>, perform the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validation: Validate that <span class="math">k\\in[1,r)</span> and that <span class="math">P=(x_{1},y_{1})\\in E_{b}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}</span> by checking that <span class="math">y_{1}^{2}=x_{1}^{3}-3x_{1}+b</span>. Otherwise, return false (see Algorithm 2).</li>

      <li>Precomputation: For a fixed window size <span class="math">2\\leq w&lt;10</span>, compute the <span class="math">2^{w-2}</span> multiples <span class="math">\\{P,3P,\\ldots,(2^{w-1}-1)P\\}</span> of <span class="math">P</span>, and store them in a lookup table. This precomputation can be achieved using one point doubling and <span class="math">2^{w-2}-1</span> point additions (see Algorithm 4).</li>

      <li>Scalar recoding: Convert the scalar <span class="math">k</span> to odd by replacing <span class="math">k</span> with <span class="math">r-k</span> (if even) and recode it into exactly <span class="math">\\lceil\\log_{2}(r)/(w-1)\\rceil+1</span> odd, signed, non-zero digits in <span class="math">\\{\\pm 1,\\pm 3,\\ldots,\\pm(2^{w-1}-1)\\}</span> (see Algorithm 6).</li>

      <li>Evaluation: Compute <span class="math">kP</span> using a fixed window with the precomputed values from the previous step. This requires exactly <span class="math">(w-1)\\lceil\\log_{2}(r)/(w-1)\\rceil</span> point doublings and <span class="math">\\lceil\\log_{2}(r)/(w-1)\\rceil</span> point additions, or <span class="math">(w-2)\\lceil\\log_{2}(r)/(w-1)\\rceil+1</span> point doublings, <span class="math">\\lceil\\log_{2}(r)/(w-1)\\rceil-1</span> point doubling-additions and one addition when <span class="math">w&gt;2</span>. Note that every time an addition is performed, we also negate the selected point in the look-up table, and choose the correct one according to the sign of the digit in the recoded scalar. This is repeated until the last iteration, when crucially, the final addition is performed via a “complete masked” addition (see Appendix C.1). The final result is negated if the original value of <span class="math">k</span> was even.</li>

    </ol>

    <p class="text-gray-300">This can be computed as outlined in Algorithm 1 in Appendix A.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 1</h6>

    <p class="text-gray-300">When computing variable-base scalar multiplications on any of the Weierstrass curves in Table 1 using Algorithm 1 to implement the steps above, no exceptions occur.</p>

    <p class="text-gray-300">Before proving the proposition, we fix notation to partition the non-zero points in a prime order subgroup of the group <span class="math">E_{b}(\\mathbf{F}_{p})</span>. For a fixed point <span class="math">P\\in E_{b}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}</span>, the map <span class="math">[1,r)\\to E_{b}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\},\\ k\\mapsto kP</span> is a bijection. It induces a partition of <span class="math">E_{b}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}=S_{\\mathrm{odd}}\\cup S_{\\mathrm{even}}</span> into two equally sized sets, where <span class="math">S_{\\mathrm{odd}}=\\{kP\\mid k\\in[1,r)\\;\\mathrm{odd}\\}</span> and <span class="math">S_{\\mathrm{even}}=\\{kP\\mid k\\in[1,r)\\;\\mathrm{even}\\}</span>. Let <span class="math">T=\\{P,3P,\\ldots,(2^{w-1}-1)P\\}\\subset S_{\\mathrm{odd}}</span> and <span class="math">T^{-1}=\\{(r-1)P,(r-3)P,\\ldots,(r-(2^{w-1}-1))P\\}\\subset S_{\\mathrm{even}}</span>. The set <span class="math">T^{-1}</span> contains the inverses of the points in the set <span class="math">T</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">To exclude any exceptions in the course of Algorithm 1, we consider all of its doubling, addition and merged doubling/addition operations. First of all, it is easy to see that all doubling and addition steps for building the look-up table are exception-free. Note that the look-up table consists exactly of the points in the set <span class="math">T</span> defined above. The precomputation as shown in Algorithm 4 starts by doubling <span class="math">P</span> with Algorithm 10. The algorithm works for the point at infinity <span class="math">\\mathcal{O}</span> when defined as <span class="math">(0:Y_{1}:0)</span> with <span class="math">Y_{1}\\neq 0</span>, but the case <span class="math">P=\\mathcal{O}</span> is excluded by point validation, and it does not have any exceptions since there are no points of order <span class="math">2</span> in the group <span class="math">E(\\mathbf{F}_{p})</span>. The points for the look-up table are then computed by adding <span class="math">2P\\in S_{\\mathrm{even}}</span> to points from <span class="math">T\\subset S_{\\mathrm{odd}}</span> only, i.e. the input points to the additions are always different and do not include <span class="math">\\mathcal{O}</span>. Also <span class="math">-2P=(r-2)P</span> is not among these points because <span class="math">2^{w-1}-1&lt;r-2</span> (note <span class="math">2\\leq w&lt;10</span>).</p>

    <p class="text-gray-300">The operations in the evaluation stage depend on the recoding of the scalar <span class="math">k</span>, which at this point in the algorithm satisfies <span class="math">0&lt;k&lt;r</span>. Let <span class="math">t=\\lceil\\log_{2}(r)/(w-1)\\rceil</span>, then with notation as in Algorithm 1, the scalar can be written as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$k=\\sum_{i=0}^{t}s_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2^{(w-1)i},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">s_{i}\\in\\{-1,1\\}</span> and <span class="math">k_{i}\\in\\mathbf{Z}</span> with $0<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><2^{w-1}<span class="math">. The recoding used here guarantees </span>k_{t}>0<span class="math"> such that </span>s_{t}=1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k_{t}<span class="math">. Throughout the evaluation stage, the variable </span>Q<span class="math"> is used to denote the running value during the algorithm. At any stage, there is some </span>z\\in[0,r)<span class="math"> such that </span>Q=zP<span class="math">. Let </span>z_{1}>0<span class="math"> and </span>z_{2}=2^{w-1}z_{1}\\pm z_{0}<span class="math"> with </span>z_{0}\\in\\{1,3,\\ldots,2^{w-1}-1\\}<span class="math">, then </span>z_{2}\\geq z_{1}<span class="math">. If </span>z_{1}>1<span class="math">, we even have </span>z_{2}>z_{1}<span class="math">. This means that whenever a positive integer is doubled </span>w-1$ times and then an integer corresponding to one of the elements in the look-up table is either added or subtracted, the result cannot be smaller</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">than the original integer. Thus, in the evaluation stage of Algorithm 1, after each sequence of <span class="math">w-1</span> doublings and one addition step, the value <span class="math">z</span> of the running point <span class="math">Q</span> cannot decrease.</p>

    <p class="text-gray-300">The evaluation stage begins with choosing an element from the lookup table <span class="math">T</span> and assigning it to <span class="math">Q</span>. After the first assignment, we have <span class="math">z\\in\\{1,3,\\ldots,2^{w-1}-1\\}</span>. All the doubling operations in Lines 11, 14 and 18 of Algorithm 1 are done using Algorithm 10. Therefore, for the same reasons as explained above there are no exceptions possible in these steps. The last addition in Line 19 is done with a complete addition formula and hence also does not have any exceptional cases. It now suffices to ensure that all remaining addition steps (i.e. in Lines 12 and 15) do not run into exceptions.</p>

    <p class="text-gray-300">First, assume that an exceptional case occurs in one of the additions in Step 15, which computes <span class="math">Q+R</span> for <span class="math">R\\in T\\cup T^{-1}</span> using Algorithm 12. Note that none of the doubling steps can ever output <span class="math">\\mathcal{O}</span> because there are no points of order 2 and <span class="math">\\mathcal{O}</span> is never input to any of them since the running value <span class="math">Q</span> always has <span class="math">1&lt;z&lt;r</span> for all points input to doubling steps prior to any of the additions in Step 15. Thus the only exceptional cases that could occur in this algorithm, are the cases where <span class="math">Q=\\pm R</span>. This means that either <span class="math">Q\\in T</span> or <span class="math">Q\\in T^{-1}</span>. Since <span class="math">Q</span> is the output of a non-trivial doubling operation, we have <span class="math">Q\\in S_{\\mathrm{even}}</span> which excludes <span class="math">Q\\in T</span> and means that <span class="math">Q\\in T^{-1}</span>. Therefore, <span class="math">Q=zP</span> with <span class="math">z\\geq r-(2^{w-1}-1)</span>. After each addition in Step 15 there are always <span class="math">w-1</span> doublings that follow. Hence, the minimal value for <span class="math">z</span> that can occur after the exceptional addition and the following doublings is <span class="math">2^{w-1}(r-2(2^{w-1}-1))</span>. The addition of a table element immediately after these doublings, can bring down this value to the minimal <span class="math">z_{\\mathrm{min}}=2^{w-1}(r-2(2^{w-1}-1))-(2^{w-1}-1)=2^{w-1}r-(2^{w}+1)(2^{w-1}-1)</span>. This value is larger than <span class="math">r</span>, because otherwise, it follows that <span class="math">r\\leq 2^{w}+1</span>, which is not true for any of our curves. Given the observation that a positive integer does not decrease after any sequence of <span class="math">w-1</span> doublings and a following addition of an integer corresponding to a look-up table element, the scalar <span class="math">k</span> cannot be reached any more as the final value for <span class="math">z</span> after the exceptional addition. This contradicts any exceptions in the additions of Step 15.</p>

    <p class="text-gray-300">Next, assume that an exception occurs in one of the steps in Line 12 of Algorithm 1. This step is a merged doubling and addition step and is computed via Algorithm 11. The algorithm computes <span class="math">2Q+R</span> for <span class="math">R\\in T\\cup T^{-1}</span> as <span class="math">(Q+R)+Q</span>. For the same reasons as above, the input point <span class="math">Q</span> cannot be equal to <span class="math">\\mathcal{O}</span>. Since <span class="math">R\\in T\\cup T^{-1}</span>, we have <span class="math">R\\neq\\mathcal{O}</span>. The first addition <span class="math">Q+R</span> could have the same exceptions as the additions in Step 15 treated in the previous paragraph. This means that an exception can only be <span class="math">Q\\in T^{-1}</span> as above and again we look at the minimal value <span class="math">z_{\\mathrm{min}}</span> after carrying out the exceptional addition, the addition of <span class="math">Q</span> and the following <span class="math">w-1</span> doublings and subsequent addition (also the steps including the merged doubling and addition algorithm can be treated as such). This value is <span class="math">z_{\\mathrm{min}}\\geq 2^{w-1}\\cdot(2r-3(2^{w-1}-1))-(2^{w-1}-1)=2^{w}r-(3\\cdot 2^{w-1}+1)(2^{w-1}-1)</span>. Again, this value is larger than <span class="math">r</span>, because otherwise we would have <span class="math">r\\leq 3\\cdot 2^{w-1}+1</span>, which does not hold for our curve parameters. As above this means that the scalar <span class="math">k&lt;r</span> cannot be reached as the final value of <span class="math">z</span>, contradicting any exception in the first addition in <span class="math">(Q+R)+Q</span>. Finally, we assume that there is an exception in the second addition. We have already excluded <span class="math">Q=\\mathcal{O}</span> and <span class="math">Q+R=\\mathcal{O}</span>. Hence, the only two possibilities for an exception are <span class="math">Q+R=Q</span> or <span class="math">Q+R=-Q</span>. The first condition means that <span class="math">R=\\mathcal{O}</span> which is not possible since <span class="math">R\\in T\\cup T^{-1}</span>. We are thus left with the condition <span class="math">2Q=-R</span> and hence either <span class="math">2Q\\in T</span> or <span class="math">2Q\\in T^{-1}</span>. Since <span class="math">2Q\\in S_{\\mathrm{even}}</span>, it cannot be in <span class="math">T</span>, which leaves <span class="math">2Q\\in T^{-1}</span>. This means that <span class="math">2z\\geq r-(2^{w-1}-1)</span>. The minimal value <span class="math">z_{\\mathrm{min}}</span> after the computation <span class="math">(Q+R)+Q</span> and the following <span class="math">w-1</span> doublings and another addition is <span class="math">z_{\\mathrm{min}}\\geq 2^{w-1}(r-2(2^{w-1}-1))-(2^{w-1}-1)=2^{w-1}r-(2^{w}+1)(2^{w-1}-1)</span>. Again, this value is larger than <span class="math">r</span>, leaving no way to achieve the scalar <span class="math">k</span> during the remaining computation. This excludes all exceptions in Line 12 and therefore all exceptions in Algorithm 1. ∎</p>

    <p class="text-gray-300">Given that the recoding always produces a fixed length for the scalar, this means that after a successful validation step, we do not execute any conditional statements.</p>

    <p class="text-gray-300">The fixed-base scenario. In this setting, the point <span class="math">P</span> is fixed (e.g., as a public parameter of the system), so multiples of <span class="math">P</span> can be precomputed offline and used to speedup the online computation of <span class="math">kP</span>. In terms of performance, it might be difficult to select the “optimal” size of the precomputed table. A larger table with more multiples of <span class="math">P</span> typically means a reduced number of elliptic curve operations at runtime, but such tables might result in cache-misses which can result in a performance penalty. Moreover, when one wants to extract elements from this table in a cache-attack resistant manner, one should access <em>every</em> element and mask out the correct value to avoid leaking access patterns. Hence, using a larger table implies an increased access cost for every table-lookup.</p>

    <p class="text-gray-300">This is not the only problem with large precomputed tables. As far as we know, one cannot show (for all inputs) that a current active point in the fixed-base scalar multiplication will not be the same (or have an opposite sign) as one of the many precomputed val</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">ues. Although this might happen only with extremely low probability, such that honest parties may never encounter this by accident, active adversaries could manipulate such scalar/point combinations to force exceptions. This means that, unlike the variable-base multiplication, the implementation of the group law must cover exceptional cases. One solution is to use complete formulas (which have no exceptional cases). Unfortunately, the complete Weierstrass formulas from [18] (see Appendix C.1) are expensive compared to their incomplete counterparts, and using these would incur a much larger relative penalty than the complete formulas on (twisted) Edwards curves do. Another possible solution is to always compute two candidates for the addition, <span class="math">C_{1}=2P</span> and <span class="math">C_{2}=P+L</span>, and select (in a constant time manner) <span class="math">C_{1}</span> if <span class="math">P=L</span>, <span class="math">\\mathcal{O}</span> if <span class="math">P=-L</span>, <span class="math">L</span> if <span class="math">P=\\mathcal{O}</span>, <span class="math">P</span> if <span class="math">L=\\mathcal{O}</span>, and <span class="math">C_{2}</span> otherwise. At a first glance this approach seemingly increases the cost of an addition to be at least that of computing both an addition and a doubling. However, as noted by Chevallier-Mames et al. [22] for the case of binary affine operations, doubling and addition share several similarities in their formulas. By observing that these similarities naturally reflect to the projective formulas, we present a solution that achieves the required behavior explained above <em>without</em> increasing the number of modular multiplications or squarings required in a dedicated point addition (see Algorithms 18 and 19). The idea is to exploit the similarities in the doubling and addition routines by masking out the correct operands first, and using these as inputs to the arithmetic operations. Hence, Algorithms 18 and 19 work for <em>any</em> input points, do not have any exceptional cases and have roughly the same run-time as their corresponding dedicated point additions. We note that Chevallier-Mames et al.’s approach tries to address a different problem and hence produces different formulas. In particular, they exploit similarities in the affine formulas to build (separate) routines for doubling and addition with the same pattern of field operations. This is done in order to eliminate differences in the power traces of the doubling and addition executions. In projective coordinates, however, the same approach would not work because of the extra operations required by addition in comparison to doubling (in this case, point operations are partitioned into smaller atomic units, each with the same pattern of field operations. Thus, this technique does not exploit similarities between doubling and addition).</p>

    <p class="text-gray-300">For a scalar <span class="math">k</span> and the fixed point <span class="math">P=(x_{1},y_{1})</span>, we make use of these formulas to perform the following steps.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Offline computation.</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Point validation: Validate that <span class="math">P=(x_{1},y_{1})\\in E_{b}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}</span> by checking that <span class="math">y_{1}^{2}=x_{1}^{3}-3x_{1}+b</span>. Otherwise, return false (see Algorithm 2).</li>

      <li>Precomputation: For a fixed window size <span class="math">2\\leq w&amp;lt;10</span>, compute <span class="math">v&amp;gt;0</span> tables of <span class="math">2^{w-1}</span> points (each) for the mLSB-set comb method (see Line 2 of Algorithm 7). Convert all points in the lookup table to affine form.</li>

    </ol>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Online computation.</h4>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Scalar validation: Validate that the scalar <span class="math">k\\in[1,r)</span>. Let the maximum bit-length of all valid scalars be <span class="math">t=\\lceil\\log_{2}(r)\\rceil</span>.</li>

      <li>Recoding: Convert the scalar <span class="math">k</span> to odd by replacing it with <span class="math">r-k</span> (if even) and recode it into the mLSB-set representation (see Algorithm 8).</li>

      <li>Evaluation: Using the precomputed values from the offline precomputation, compute <span class="math">kP</span> with exactly <span class="math">\\lceil\\frac{t}{w\\cdot v}\\rceil-1</span> point doublings and <span class="math">v\\lceil\\frac{t}{w\\cdot v}\\rceil-1</span> point additions. All point additions are computed using the “complete masked” approach in Algorithm 18 in Appendix C.1. The final result is negated if the original value of <span class="math">k</span> was even.</li>

    </ol>

    <p class="text-gray-300">This approach is outlined in Algorithm 7 in Appendix A.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proposition 2</h6>

    <p class="text-gray-300">When computing fixed-base scalar multiplications on any of the Weierstrass curves in Table 1 using Algorithm 7 to implement the steps above, no exceptions occur.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Following the proof of Proposition 1, point doublings computed via Algorithm 10 do not fail for any rational points in <span class="math">E_{b}(\\mathbf{F}_{p})</span> for any of the curves <span class="math">E_{b}</span> in Table 1. Furthermore, Algorithm 10 also correctly computes doublings at the point at infinity, <span class="math">\\mathcal{O}</span>. Thus, no exceptions can arise in point doublings; and, since all online additions are implemented using the “complete” masking technique described in Appendix C.1, it follows that no exceptions can arise at any stage of the online computation (offline computations can also make use of this technique if necessary). ∎</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.2 Twisted Edwards Scalar Multiplications</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}_{d}/\\mathbf{F}_{p}</span>: <span class="math">-x^{2}+y^{2}=1+dx^{2}y^{2}</span> be any of the twisted Edwards curves in Table 2, with <span class="math">\\#E(\\mathbf{F}_{p})=4r</span> for <span class="math">r</span> prime. In a similar vein to [34; 5], we avoid small subgroup attacks by requiring all scalar multiplications to include a cofactor 4. Thus, let the integer <span class="math">\\tilde{k}</span> be defined as <span class="math">\\tilde{k}:=4k</span> with <span class="math">k\\in[1,r)</span>, and let <span class="math">P=(x_{1},y_{1})</span> be in <span class="math">\\mathbf{F}_{p}\\times\\mathbf{F}_{p}</span>.</p>

    <p class="text-gray-300">The variable-base scenario. On input of <span class="math">\\hat{k}</span> and (variable) <span class="math">P=(x_{1},y_{1})\\in\\mathbf{F}_{p}\\times\\mathbf{F}_{p}</span>, we perform the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validation: Validate that <span class="math">\\hat{k}\\in[4\\cdot 1,4\\cdot 2,\\ldots,4(r-1)]</span>. Validate that <span class="math">P=(x_{1},y_{1})\\in\\mathcal{E}_{d}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}</span> by checking that <span class="math">-x_{1}^{2}+y_{1}^{2}=1+dx_{1}^{2}y_{1}^{2}</span> and that <span class="math">P\\neq(0,1)=\\mathcal{O}</span> (see Algorithm 3). Otherwise, return false.</li>

      <li>Clear torsion: Compute <span class="math">Q\\leftarrow[4]P</span> using two consecutive doublings (as in Algorithm 3).</li>

      <li>Revalidation: Validate that (the projective point) <span class="math">Q\\neq\\mathcal{O}</span>. If not, reject.</li>

      <li>Precomputation: Compute the <span class="math">2^{w-2}</span> odd, positive multiples <span class="math">\\{Q,3Q,\\ldots,(2^{w-1}-1)Q\\}</span> of <span class="math">Q</span>, and store them in a lookup table. This precomputation can be achieved using one point doubling and <span class="math">2^{w-2}-1</span> point additions (see Algorithm 4).</li>

      <li>Scalar recoding: Using a window size of <span class="math">2\\leq w&lt;10</span>, convert the updated scalar <span class="math">k:=\\hat{k}/4\\in[1,r-1]</span> to odd by setting <span class="math">k</span> to <span class="math">r-k</span> (if even) and recode it into exactly <span class="math">\\lceil\\log_{2}(r)/(w-1)\\rceil+1</span> odd, signed, non-zero digits in <span class="math">\\{\\pm 1,\\pm 3,\\ldots,\\pm(2^{w-1}-1)\\}</span> (see Algorithm 6).</li>

      <li>Evaluation: Compute <span class="math">\\hat{k}P</span> as <span class="math">kQ</span>, using exactly <span class="math">(w-1)\\lceil\\log_{2}(r)/(w-1)\\rceil</span> point doublings and <span class="math">\\lceil\\log_{2}(r)/(w-1)\\rceil</span> point additions. Note that every time an addition is performed, we also negate the selected point in the look-up table, and choose the correct one according to the sign of the digit in the recoded scalar. This is repeated until the last iteration, when crucially, the final addition is performed using the unified formula in <em>(35, Eq. (5))</em>. The final result is negated if the original value of <span class="math">k</span> was even.</li>

    </ol>

    <p class="text-gray-300">This computation is given in Algorithm 1 in Appendix A.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proposition 3</h6>

    <p class="text-gray-300">When computing variable-base scalar multiplications on any of the twisted Edwards curves in Table 2 using Algorithm 1 to implement the steps above, no exceptions occur.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">The first 3 steps (validation, clear torsion, and revalidation) detailed in Section 4.2 ensure that the point <span class="math">Q</span> has large prime order <span class="math">r</span>. Furthermore, only elements of <span class="math">\\langle Q\\rangle</span> are encountered after the revalidation stage, meaning that Corollary 1 from [35] can be invoked to say that the additions in Algorithm 15 (from [35], but extended according to the representation suggested in [32]) will never fail to add points <span class="math">P</span> and <span class="math">Q</span> of odd order, except when <span class="math">P=Q</span>. This corollary also tells us that the formulas for point doubling in Algorithm 14 never fail for points of odd order. Similar to the addition formulas, these doubling formulas, which are from [7], are extended according to [32]. Thus, the proof from this point is identical to the proof of Proposition 1: we partition the elements in <span class="math">\\langle Q\\rangle\\setminus\\{\\mathcal{O}\\}</span> into <span class="math">S_{\\mathrm{odd}}</span> and <span class="math">S_{\\mathrm{even}}</span> to categorize the elements in the look-up table, and use this to show that the running value that is input into point additions can never be equal to an element in the look-up table, except possibly in the final addition, where we use the formula in <em>(35, Eq. (5))</em>, which is slightly slower, but is exception-free in <span class="math">\\langle Q\\rangle</span>. ∎</p>

    <p class="text-gray-300">The fixed-base scenario. Let <span class="math">P=(x_{1},y_{1})\\in\\mathbf{F}_{p}\\times\\mathbf{F}_{p}</span> be a fixed point and let <span class="math">\\hat{k}=4k</span> be an integer scalar, which is a multiple of the cofactor 4. Then perform the following steps.</p>

    <p class="text-gray-300">Offline computation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Validation: Validate that <span class="math">\\hat{k}\\in[4\\cdot 1,4\\cdot 2,\\ldots,4(r-1)]</span>. Validate that <span class="math">P=(x_{1},y_{1})\\in\\mathcal{E}_{d}(\\mathbf{F}_{p})\\setminus\\{\\mathcal{O}\\}</span> by checking that <span class="math">-x_{1}^{2}+y_{1}^{2}=1+dx_{1}^{2}y_{1}^{2}</span> and that <span class="math">P\\neq(0,1)=\\mathcal{O}</span> (see Algorithm 3). Otherwise, return false.</li>

      <li>Clear torsion: Compute <span class="math">Q\\leftarrow[4]P</span> using two consecutive doublings (see Algorithm 3).</li>

      <li>Revalidation: Validate that <span class="math">Q\\neq\\mathcal{O}</span>. If not, reject.</li>

      <li>Precomputation: For a fixed window size <span class="math">2\\leq w&lt;10</span>, compute <span class="math">v&gt;0</span> tables of <span class="math">2^{w-1}</span> points (each) for the mLSB-set comb method (see Line 2 of Algorithm 7) – convert all points in the lookup table to affine form.</li>

    </ol>

    <p class="text-gray-300">Online computation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recoding: Convert the updated scalar <span class="math">k:=\\hat{k}/4</span> to odd by setting <span class="math">k</span> to <span class="math">r-k</span> (if even) and recode it into the mLSB-set representation (see Algorithm 8).</li>

      <li>Evaluation: Using the precomputed values from the offline precomputation, compute <span class="math">\\hat{k}P</span> as <span class="math">kQ</span> with exactly <span class="math">\\lceil\\frac{t}{w\\cdot v}\\rceil-1</span> point doublings and <span class="math">v\\lceil\\frac{t}{w\\cdot v}\\rceil-1</span> point additions. Every one of these additions is computed using the unified formulas from <em>(35, Eq. (5))</em>. The final result is negated if the original value of <span class="math">k</span> was even.</li>

    </ol>

    <p class="text-gray-300">Algorithm 7 in Appendix A outlines this computation.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proposition 4</h6>

    <p class="text-gray-300">When computing fixed-base scalar multiplications on any of the twisted Edwards curves in Table 2 using Algorithm 7 to implement the steps above, no exceptions occur.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">As in the proof of Proposition 3, we start by noting that the (updated) point <span class="math">Q</span> has odd order <span class="math">r</span>, and that we only compute on elements in <span class="math">\\langle Q\\rangle</span>. The only algorithm we use for online additions corresponds to the formulas in <em>(35, Eq. (5))</em>, which do not fail for any pair</p>

    <p class="text-gray-300">of inputs in <span class="math">\\langle Q\\rangle</span>. Additionally, the only algorithm we use for doublings is Algorithm 14 (from [7]), which is also exception-free on all inputs from <span class="math">\\langle Q\\rangle</span>. <span class="math">\\Box</span></p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 The Montgomery Ladder</h3>

    <p class="text-gray-300">Let <span class="math">E_{A}/\\mathbf{F}_{p}\\colon y^{2}=x^{3}+Ax^{2}+x</span> be the Montgomery form of any of the curves in Table 2, with <span class="math">\\#E_{A}(\\mathbf{F}_{p})=4r</span>, for <span class="math">r</span> a large prime. Since the Montgomery ladder is not compatible with the recoding techniques discussed in Section 4, we take the following route to guarantee a fixed length scalar. For all <span class="math">k\\in[1,r-1]</span>, we use the updated scalar <span class="math">\\hat{k}=4(\\alpha r+k)</span>, where <span class="math">\\alpha</span> is the smallest positive integer such that <span class="math">\\alpha r+1</span> and <span class="math">(\\alpha+1)r-1</span> have the same bitlength; <span class="math">\\alpha</span> is specific to <span class="math">r</span>, but for each of the curves in Table 2 we have <span class="math">\\alpha\\in\\{1,2,3\\}</span>. Note that scalar multiplication by <span class="math">\\hat{k}</span> corresponds to scalar multiplication by <span class="math">4k</span> on <span class="math">E_{A}</span>, which thwarts small subgroup attacks in the same way as the twisted Edwards scalar multiplications in Section 4.2.</p>

    <p class="text-gray-300">On input of <span class="math">\\hat{k}</span> and <span class="math">x_{1}\\in\\mathbf{F}_{p}</span>, we perform the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Scalar validation: First validate that <span class="math">\\hat{k}\\in 4\\mathbb{Z}</span>, and then that the integer <span class="math">\\hat{k}/4\\in[\\alpha r+1,(\\alpha+1)r-1]</span>. Otherwise, reject.</li>

      <li>Evaluation: Process the scalar by inputting <span class="math">\\hat{k}</span> and <span class="math">(x_{1}\\colon 1)</span> into the standard <span class="math">(X\\colon Z)</span>-only Montgomery ladder routine [47, §10], with constant <span class="math">(A+2)/4</span> in the addition formula. Since <span class="math">\\hat{k}=4(\\alpha r+k)</span>, this can be done by inputting the fixed-length scalar <span class="math">\\hat{k}/4=\\alpha r+k</span> and <span class="math">(x_{1}\\colon 1)</span> into the Montgomery ladder to give <span class="math">(X_{1}\\colon Z_{1})</span>, before finishing with two repeated, standalone Montgomery doublings of <span class="math">(X_{1}\\colon Z_{1})</span> to give <span class="math">(\\hat{X}\\colon\\hat{Z})=4(X_{1}\\colon Z_{1})</span></li>

      <li>Normalize: If <span class="math">\\hat{Z}=0</span>, return <span class="math">\\mathcal{O}</span>, otherwise return <span class="math">\\hat{x}_{1}=\\hat{X}/\\hat{Z}</span>.</li>

    </ol>

    <p class="text-gray-300">Notice that there is no validation of the input coordinate <span class="math">x_{1}\\in\\mathbf{F}_{p}</span>, i.e. that we do not check whether <span class="math">x_{1}^{3}+Ax_{1}^{2}+x_{1}</span> is a square in <span class="math">\\mathbf{F}_{p}</span>, so that <span class="math">x_{1}</span> corresponds to a point (or points) on <span class="math">E_{A}</span>. Avoiding this check in the presence of twist-security is due to Bernstein (cf. [5]), since even if <span class="math">x_{1}</span> corresponds to a point on the quadratic twist <span class="math">E_{A}^{\\prime}</span>, the output of the Montgomery ladder corresponds to a scalar multiplication on <span class="math">E_{A}^{\\prime}</span>, because scalar multiplications on both curves use the same constant <span class="math">(A+2)/4</span>. In this case, multiplication by <span class="math">\\hat{k}=4(\\alpha r+k)</span> on <span class="math">E_{A}^{\\prime}</span> no longer corresponds to the scalar <span class="math">4k</span>, but rather to the scalar <span class="math">4k^{\\prime}</span>, where <span class="math">k^{\\prime}\\equiv(\\alpha r+k)\\bmod r^{\\prime}</span> for <span class="math">\\#E_{A}^{\\prime}(\\mathbf{F}_{p})=4r^{\\prime}</span>. This is not a problem in practice since the cofactor of 4 still clears torsion on the twist, and the twist-security ensures that the discrete logarithm problem has a similar difficulty in <span class="math">E_{A}^{\\prime}(\\mathbf{F}_{p})</span> as it does in <span class="math">E_{A}(\\mathbf{F}_{p})</span>. Following the arguments developed in [4] (see also <em>(5, App. A-B)</em>), it could be possible to prove that no exceptions can occur in Montgomery ladder implementations of the curves in Table 2 that follow Steps 1-3 above, subject to addressing the issues below.</p>

    <p class="text-gray-300">It should first be pointed out that the lack of validation means that there are some scalar/point combinations which could produce exceptions. For example, suppose <span class="math">k</span> is chosen as the unique integer less than <span class="math">r^{\\prime}</span> such that <span class="math">k\\equiv-\\alpha r\\bmod r^{\\prime}</span>. If <span class="math">k</span> is also less than <span class="math">r</span>, then <span class="math">\\hat{k}:=4(\\alpha r+k)</span> is a valid scalar according to Step 1 above. But, if an unvalidated <span class="math">x</span>-coordinate, say <span class="math">x_{1}^{\\prime}</span>, corresponds to a point <span class="math">P_{1}^{\\prime}</span> on <span class="math">E_{A}^{\\prime}</span>, then <span class="math">\\hat{k}P_{1}=\\mathcal{O}</span>, because <span class="math">(\\alpha r+k)\\equiv 0\\bmod r^{\\prime}</span>; note that outputting <span class="math">\\mathcal{O}</span> in Step 3 above could leak information to an attacker. Furthermore, in practice these ladder implementations are often used in conjunction with non-ladder implementations on (most likely a twisted Edwards model of) the same curve – see Section 6. In such a scenario, the refined forms of the scalars in this section do not match the forms of the scalars in Section 4.2, so if the scalars above were to be used on the twisted Edwards form of <span class="math">E_{A}</span>, then Proposition 3 and Proposition 4 no longer provide any guarantees. More specifically, if an implementation synchronizes the inherently larger Montgomery ladder scalars above to also be used on the twisted Edwards curve, then the argument of <span class="math">\\hat{k}\\in[4,8,\\ldots,4(r-1)]</span> that was used in the proof of Proposition 3 no longer holds when <span class="math">\\alpha&gt;0</span>. Roughly speaking, the fact that <span class="math">\\hat{k}/4</span> is now outside the range <span class="math">[1,r-1]</span> means that the running multiple of an input point can now reach the dangerous stage of a scalar multiplication (which we handle by using complete additions) before the final addition.</p>

    <p class="text-gray-300">In Curve25519’s Montgomery ladder implementation [5], and in the complementary Edwards “Ed25519” implementation [9], it seems that the above problems are overcome by restricting the set of permissible scalars to be of a lesser cardinality than the prime subgroup order. Namely, Curve25519 has <span class="math">r,r^{\\prime}&gt;2^{252}</span>, with all scalars being of the form <span class="math">\\hat{k}=8\\cdot(2^{251}+k)</span> for <span class="math">k\\in[0,2^{251}-1]</span>. As well as guaranteeing that all of the possible scalars <span class="math">\\hat{k}</span> have the same bitlength, this prevents the existence of a <span class="math">\\hat{k}</span> such that <span class="math">\\hat{k}\\equiv 0\\bmod r</span> or <span class="math">\\hat{k}\\equiv 0\\bmod r^{\\prime}</span>. On the other hand, it also means that for a fixed base point <span class="math">P</span> of order <span class="math">r</span> on Ed25519, less than half of the elements in <span class="math">\\langle P\\rangle</span> are possible outputs when computing scalar multiplications of <span class="math">P</span>.</p>

    <p class="text-gray-300">As one potential alternative, we remark that a hybrid solution which uses both Montgomery and twisted Edwards scalar multiplications could parse scalars differently: <span class="math">k\\in[0,r-1]</span> could be modified to <span class="math">\\hat{k}:=4(\\alpha r+k)</span> in the Montgomery implementation, but modified to</p>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300"><span class="math">\\hat{k} := 4k</span> in the twisted Edwards implementation. If, in addition, all <span class="math">x</span>-coordinates were validated in Step 1 of the Montgomery ladder routine, then this may well be enough to prove that all scalar multiplications compute correctly and without exception: Proposition 3 would then apply directly to the twisted Edwards part, while the techniques in [5; 4] could be used to prove the Montgomery ladder part.</p>

    <h2 id="sec-28" class="text-2xl font-bold">5 Implementation Results</h2>

    <p class="text-gray-300">To evaluate the performance of the selected curves, we developed a software library that includes support for three scenarios: variable-base, fixed-base and double-scalar multiplication. The library can perform arithmetic on <span class="math">a = -1</span> twisted Edwards, <span class="math">a = -3</span> Weierstrass and Montgomery curves, and supports all of the new curves from Section 3, with exception of the Weierstrass curves with reduced bitlength (see Tables 1 and 2). The implementation of the library is largely in the C-programming language with the modular arithmetic implemented in x64 assembly for Windows.</p>

    <p class="text-gray-300">Taking the above into account, we remark that the purpose of the library is to allow the comparison and evaluation of a large number of curve options, using a generic design that is flexible, reduces code size, and eases maintenance effort. Nevertheless, the library achieves good performance in comparison with standalone implementations that are tailored towards speed records.</p>

    <p class="text-gray-300">It is well known that it is non-trivial to create an efficient and secure implementation of cryptographic primitives (for use in elliptic curve cryptography). Complete formulas might avoid certain pitfalls to the programmer, but this can come at a performance cost. As illustrated in Section 4, and by our software library, it is possible to have efficient, constant-time, and exceptionless scalar multiplications with a reasonable easy implementation strategy.</p>

    <p class="text-gray-300">Table 3 shows the performance details of scalar multiplication in the three scenarios of interest. Variable-base scalar multiplication is computed with the fixed-window method (see Algorithm 1 in Appendix A) using window width <span class="math">w = 6</span>. Fixed-base scalar multiplication was computed using the mLSB-set method (see Algorithm 7 in Appendix A) using parameters <span class="math">w = 5</span></p>

    <p class="text-gray-300">and <span class="math">v = 4</span> for the twisted Edwards curves at the 128-bit security level; all other cases use <span class="math">w = 6</span> and <span class="math">v = 3</span>. These values correspond to precomputed tables of sizes: 6KB, 9KB and 12KB for Weierstrass curves at the 128-, 192- and 256-bit security levels, respectively, and 6KB, 13.5KB and 18KB for twisted Edwards curves at the 128-, 192- and 256-bit security levels, respectively. Double scalar multiplication was computed using the <span class="math">w</span>NAF method with interleaving (see Algorithm 9 in Appendix A) using window width <span class="math">w_{1} = 6</span> for the variable base and <span class="math">w_{2} = 7</span> for the fixed base. The latter corresponds to precomputed tables with sizes: 2KB, 3KB and 4KB for Weierstrass curves at the 128-, 192- and 256-bit security levels, respectively, and 3KB, 4.5KB and 6KB for twisted Edwards curves at the 128-, 192- and 256-bit security levels, respectively. The results (expressed in terms of computer cycles) were obtained by running and averaging <span class="math">10^{4}</span> iterations of each computation on an Intel Core i7-2600 (Sandy Bridge) processor with Intel's Turbo Boost and Hyper-Threading disabled. The variable- and fixed-base scalar multiplication routines have a constant running time which guards against various types of timing attacks [39; 20], including cache attacks [50] (e.g., see [19] in the asymmetric setting). This means that no conditional branches on secret data or secret indexes for table lookups are allowed in the implementations.</p>

    <p class="text-gray-300">Our results suggest that reducing the size of the pseudo-Mersenne primes does not have a significant effect on the performance: below a factor 1.04 reduction of the running time at the expense of roughly half a bit of ECDLP security. However, using slightly smaller moduli in the setting of the Montgomery-friendly primes does pay off: a reduction of the running time by a factor 1.20, 1.11, and 1.09 at the 128-, 192-, and 256-bit security level, respectively. This performance difference between pseudo-Mersenne and Montgomery-friendly primes can be explained by the fact that the final constant-time conditional subtraction in Montgomery multiplication can be omitted when reducing the modulus size appropriately. The size-reduced Montgomery-friendly primes are the best choice (with respect to performance) at the 128- and 192-bit security levels while the size-reduced pseudo-Mersenne prime is faster for the 256-bit security level. For full-word length moduli, Montgomery-friendly and pseudo-Mersenne primes achieve similar performance at the 128-bit security level, whereas full-word length pseudo-Mersenne moduli are the best option for the 192- and 256-bit security levels. The better performance of pseudo-Mersenne primes at high security levels can be explained by the inherent higher register pressure in our Montgomery-friendly implementations which results in more load and store operations</p>

    <p class="text-gray-300">7 Validating that <span class="math">x_{1} \\in \\mathbf{F}_{p}</span> corresponds to <span class="math">E_{A}</span> would incur the small relative cost of an exponentiation and a few multiplications: namely, we reject <span class="math">x_{1}</span> if <span class="math">(x_{1}^{3} + Ax_{1}^{2} + x_{1})^{(p - 1) / 2} = -1</span>.</p>

    <p class="text-gray-300">8 A version of the library (known as MSR ECCLib [51]) which supports a subset of the curves presented in this work is publicly available at http://research.microsoft.com/en-us/downloads/149804d4-b5f5-496f-9a17-a013b242c02d/.</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Table 3 Experimental results for variable-base, fixed-base and double-scalar multiplication. The results (rounded to thousand cycles) are the average of  <span class="math">10^{4}</span>  runs of the scalar multiplication including the final modular inversion to convert the result to its affine form. These results have been obtained on a 3.4GHz Intel Core i7-2600 Sandy Bridge processor with Intel's Turbo Boost and Hyper-Threading disabled. The library was compiled with Visual Studio 2012 on Windows 8 OS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">variable-base</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fixed-base</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">double scalar</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">280,000</td>

            <td class="px-3 py-2 border-b border-gray-700">110,000</td>

            <td class="px-3 py-2 border-b border-gray-700">287,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">278,000</td>

            <td class="px-3 py-2 border-b border-gray-700">113,000</td>

            <td class="px-3 py-2 border-b border-gray-700">288,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">233,000</td>

            <td class="px-3 py-2 border-b border-gray-700">87,000</td>

            <td class="px-3 py-2 border-b border-gray-700">237,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">194,000</td>

            <td class="px-3 py-2 border-b border-gray-700">73,000</td>

            <td class="px-3 py-2 border-b border-gray-700">198,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">228,000</td>

            <td class="px-3 py-2 border-b border-gray-700">89,000</td>

            <td class="px-3 py-2 border-b border-gray-700">236,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">223,000</td>

            <td class="px-3 py-2 border-b border-gray-700">88,000</td>

            <td class="px-3 py-2 border-b border-gray-700">228,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">196,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">219,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">795,000</td>

            <td class="px-3 py-2 border-b border-gray-700">279,000</td>

            <td class="px-3 py-2 border-b border-gray-700">812,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">744,000</td>

            <td class="px-3 py-2 border-b border-gray-700">271,000</td>

            <td class="px-3 py-2 border-b border-gray-700">761,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">657,000</td>

            <td class="px-3 py-2 border-b border-gray-700">228,000</td>

            <td class="px-3 py-2 border-b border-gray-700">672,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">590,000</td>

            <td class="px-3 py-2 border-b border-gray-700">211,000</td>

            <td class="px-3 py-2 border-b border-gray-700">605,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">610,000</td>

            <td class="px-3 py-2 border-b border-gray-700">220,000</td>

            <td class="px-3 py-2 border-b border-gray-700">624,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">596,000</td>

            <td class="px-3 py-2 border-b border-gray-700">213,000</td>

            <td class="px-3 py-2 border-b border-gray-700">607,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">632,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">580,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">1,762,000</td>

            <td class="px-3 py-2 border-b border-gray-700">573,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,821,00</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">1,538,000</td>

            <td class="px-3 py-2 border-b border-gray-700">513,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,592,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">1,461,000</td>

            <td class="px-3 py-2 border-b border-gray-700">467,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,507,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">1,335,000</td>

            <td class="px-3 py-2 border-b border-gray-700">432,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,369,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">1,282,000</td>

            <td class="px-3 py-2 border-b border-gray-700">420,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,320,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">1,240,000</td>

            <td class="px-3 py-2 border-b border-gray-700">411,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,274,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">1,437,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">m-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">1,299,000</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

            <td class="px-3 py-2 border-b border-gray-700">N/A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for large moduli sizes. The faster arithmetic operations in the base field translate directly to optimizations in the different scenarios for the scalar multiplication.</p>

    <p class="text-gray-300">In the setting of variable-base scalar multiplication the twisted Edwards implementation and the Montgomery ladder achieve similar performance at the 128 and 192-bit security levels. At the 256-bit security level the gap increases in favor of twisted Edwards which outperforms the Montgomery ladder by a factor 1.05.</p>

    <p class="text-gray-300">Note that our best results using the twisted Edwards and Montgomery forms at the 128-bit security level are virtually equivalent to the state-of-the-art Montgomery ladder implementation of Curve25519 [5] (194,000 cycles on the benchmark machine "sandy0" [13]). Given the significant level of code optimization applied on the Curve25519 implementation which includes full use of assembly for the curve and field arithmetic, this comparison demonstrates the high efficiency of the chosen 254-bit Montgomery-friendly prime.</p>

    <p class="text-gray-300">The state-of-the-art implementation of the NIST P-256 curve [31] can compute a variable-base scalar multiplication in 400,000 cycles on a Sandy Bridge CPU. Our curve w-256-mont offers better security properties and results in a 1.43 times reduction of the running time compared to [31]. When switching from prime or</p>

    <p class="text-gray-300">der Weierstrass curves using full size moduli to composite order twisted Edwards curves with size-reduced moduli one can expect a reduction in the running time by a factor between 1.25 and 1.44 at the price of a slight decrease in ECDLP security.</p>

    <p class="text-gray-300">Although significant research has been devoted to optimize the most popular ECC operation (the variable-base scalar multiplication), in real-world cryptographic solutions it is often not as simple as computing just a single scalar multiplication with an unknown base. Cryptographic protocols typically require a combination of different types of scalar multiplications including fixed-, variable-base and multiple-scalar operations. In this section we study the TLS protocol, more specifically the computation of the TLS handshake using the ECDHE-ECDSA cipher suite. We outline the impact of using different curve and coordinate systems in practice.</p>

    <p class="text-gray-300">TLS with perfect forward secrecy. Support for using elliptic curves in the TLS protocol is specified in RFC 4492 [14]. The cipher suites specified in this RFC</p>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">Table 4 Cost estimates for the TLS handshake using the ECDHE-ECDSA cipher suite for different security levels where we consider the elliptic curve scalar multiplications. Costs in cycles are estimated using the performance numbers from Table 3. These estimates do not include the modular inversion required outside scalar multiplication during ECDSA signing and verification. Estimates for the total cost correspond to the full handshake ECDHE-ECDSA involving authentication in both the server and client side. We assume the use of precomputed tables with 96 points to accelerate fixed-base scalar multiplication (64 points for twisted Edwards curves at the 128-bit security level). Similarly, we assume the use of precomputed tables with 32 points to accelerate double scalar multiplication (where one base is fixed). For comparison we state performance numbers for NIST P-256 [31] which uses 150KB of storage, and performance numbers when using the Ed25519 signature scheme [9] (obtained from the benchmark machine "sandy0" [13]). We consider that point transmission (T) in the key-exchange can be performed in uncompressed (U) or compressed (C) form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">security level</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve names</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">estimated cost (in cycles)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ECDHE</td>

            <td class="px-3 py-2 border-b border-gray-700">ECDSA sign</td>

            <td class="px-3 py-2 border-b border-gray-700">ECDSA ver</td>

            <td class="px-3 py-2 border-b border-gray-700">total cost</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">390,000</td>

            <td class="px-3 py-2 border-b border-gray-700">110,000</td>

            <td class="px-3 py-2 border-b border-gray-700">287,000</td>

            <td class="px-3 py-2 border-b border-gray-700">787,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">412,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">809,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">267,000</td>

            <td class="px-3 py-2 border-b border-gray-700">73,000</td>

            <td class="px-3 py-2 border-b border-gray-700">198,000</td>

            <td class="px-3 py-2 border-b border-gray-700">538,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">283,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">554,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">hybrid ed-254-mont + m-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">269,000</td>

            <td class="px-3 py-2 border-b border-gray-700">73,000</td>

            <td class="px-3 py-2 border-b border-gray-700">198,000</td>

            <td class="px-3 py-2 border-b border-gray-700">540,000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  C  |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">NIST P-256 [31]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">490,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">90,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">530,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,110,000</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">1,015,000</td>

            <td class="px-3 py-2 border-b border-gray-700">271,000</td>

            <td class="px-3 py-2 border-b border-gray-700">761,000</td>

            <td class="px-3 py-2 border-b border-gray-700">2,047,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">1,072,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2,104,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">801,000</td>

            <td class="px-3 py-2 border-b border-gray-700">211,000</td>

            <td class="px-3 py-2 border-b border-gray-700">605,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,617,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">854,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1,670,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">hybrid ed-382-mers + m-382-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">793,000</td>

            <td class="px-3 py-2 border-b border-gray-700">213,000</td>

            <td class="px-3 py-2 border-b border-gray-700">607,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,613,000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  C  |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w-512-mers</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,051,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">513,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1,592,000</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4,156,000</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ed-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">1,651,000</td>

            <td class="px-3 py-2 border-b border-gray-700">411,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,274,000</td>

            <td class="px-3 py-2 border-b border-gray-700">3,336,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">1,753,000</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3,438,000</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">hybrid ed-511-mers + m-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">U</td>

            <td class="px-3 py-2 border-b border-gray-700">1,710,000</td>

            <td class="px-3 py-2 border-b border-gray-700">411,000</td>

            <td class="px-3 py-2 border-b border-gray-700">1,274,000</td>

            <td class="px-3 py-2 border-b border-gray-700">3,395,000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  C  |   |   |   |   |</p>

    <p class="text-gray-300">use the elliptic curve Diffie-Hellman (ECDH) key exchange, whose keys may either be long-term or ephemeral. We focus our analysis on the latter case (denoted by ECDHE) since it offers perfect forward secrecy. Besides the usage of elliptic curves in the DH key exchange, TLS certificates contain a public key that the server uses to authenticate itself: this is an ECDSA public key for the case of the ECDHE-ECDSA cipher suite. The TLS handshake, using the ECDHE-ECDSA cipher suite, consists of three main components. The ECDSA signature generation (fixed-base scalar multiplication), ECDSA signature verification (double scalar multiplication), and ECDHE (one fixed- and one variable-base scalar multiplication <span class="math">^9</span> ). We consider Weierstrass and twisted Edwards curves separately, with and without point compression. The cost of decompressing a point in Weierstrass and twisted Edwards form is stated in Table 7 (where we follow the approach described in [9] to decompress points on twisted Edwards curves).</p>

    <p class="text-gray-300">When using Weierstrass curves the situation is not complicated: transmitting compressed points costs a single conversion while no additional cost is needed when transmitting uncompressed points. In the setting of twisted Edwards curves there are more possibilities. The simplest approach is to only use the Montgomery form; however, this is expensive since the Montgomery ladder cannot take advantage of the fixed-base setting. One might consider a hybrid solution: computing the fixed-base scalar multiplication using the birationally equivalent twisted Edwards curve while computing the variable-base scalar multiplication using the Montgomery ladder. In such a hybrid solution the protocol should specify if the coordinates are transmitted in (compressed) twisted Edwards or Montgomery coordinates (which are already in compressed form). When using such a hybrid solution in the setting of ECDHE, transmitting the points in Montgomery form is best (see Table 7). The cost for the conversion (between Montgomery and twisted Edwards) is roughly the same as when only using twisted Edwards curves and transmitting compressed points.</p>

    <p class="text-gray-300">Table 4 gives the cost estimates for the separate components and total cost of the TLS handshake using the ECDHE-ECDSA cipher suite for different security levels. It includes the options with the best results for the cases of Weierstrass curves, twisted Edwards curves and the hybrid approach combining the use of the Montgomery ladder and twisted Edwards. The results suggest that the approach using only twisted Edwards achieves similar performance to the hybrid approach using the Montgomery ladder, while it avoids conversions between coordinate systems (the performance gap between both approaches is below 4% in all the cases, compressed or uncompressed form). Furthermore, our Montgomery ladder implementations do not include the extra validation step discussed at the end of Section 4.3; if incorporated, this would incur additional overhead.</p>

    <p class="text-gray-300">The results in Table 4 also show that the use of twisted Edwards for the ECDHE and ECDHE-ECDSA computations are approximately a factor 1.46, 1.26 and 1.24 faster in comparison to the Weierstrass curves at the 128-, 192- and 256-bit security levels, respectively. We also include the results from [31] when using NIST P-256. In [31] the fixed-base scalar multiplication is implemented using a relatively large (slightly over 150KB) lookup table for the fixed-base scalar multiplication. It is unclear if this implementation accesses the table-lookup elements in a cache-attack resistant manner and if the dedicated addition formula used takes care of exceptions, and if so if this is done in constant time. This might explain the faster implementation results. As a reference we also include the results for Ed25519 [9] (obtained from the “sandy0” benchmark machine [13]), which is a Schnorr-like signature scheme based on a twisted Edwards curve that is isomorphic to Curve25519. Note that [9] only computes signatures; when computing ECDH one could use the approach as described in [5] which uses the Montgomery ladder. In order to achieve perfect forward secrecy (ECDHE), the implementation can compute the fixed-base scalar multiplication using the Montgomery ladder (which is slow) or convert the point and compute the fixed-base scalar multiplication using the corresponding twisted Edwards curve (using a hybrid approach).</p>

    <h2 id="sec-30" class="text-2xl font-bold">7 Conclusions</h2>

    <p class="text-gray-300">In this paper we have presented new elliptic curves for cryptography targeting the 128-, 192-, and 256-bit security levels. By considering different choices for the base field arithmetic, pseudo-Mersenne and Montgomery-friendly primes, we deterministically selected efficient twisted Edwards curves as well as traditional Weierstrass curves. Instead of resorting to the slower complete formulas, we show how to compute efficient scalar multiplications by using constant-time, exceptionless, dedicated group operations. For the cases in which they are not guaranteed to be exceptionless, we have proposed an efficient “complete” addition formula based on masking techniques for Weierstrass curves. Our implementation of the scalar multiplication in the three most-widely deployed scenarios show that our new backwards compatible Weierstrass curves offer enhanced security properties while improving the performance compared to the standard NIST Weierstrass curves. At the expense of at most a few bits of ECDLP security, our new twisted Edwards curves offer a performance increase of a factor 1.2 to 1.4 compared to our new Weierstrass curves. We demonstrated the potential cryptographic impact by showing cost estimates for these curves inside the TLS handshake protocol.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Acknowledgements.</h6>

    <p class="text-gray-300">We would like to thank Niels Ferguson, Thorsten Kleinjung, Dan Shumow and Greg Zaverucha for their valuable feedback, comments, and help. We also would like to thank the anonymous reviewers of JCEN which helped to improve the quality of the paper.</p>

    <h2 id="sec-32" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(1) T. Acar and D. Shumow. Modular reduction without pre-computation for special moduli. Technical report, Microsoft Research, 2010.</li>

      <li>(2) O. Ahmadi and R. Granger. On isogeny classes of edwards curves over finite fields. Journal of Number Theory, 132(6):1337 – 1358, 2012.</li>

      <li>(3) D. F. Aranha, P. S. L. M. Barreto, G. C. C. F. Pereira, and J. E. Ricardini. A note on high-security general-purpose elliptic curves. Cryptology ePrint Archive, Report 2013/647, 2013. http://eprint.iacr.org/.</li>

      <li>(4) D. J. Bernstein. Can we avoid tests for zero in fast elliptic-curve arithmetic?, 2006. http://cr.yp.to/papers.html#curvezero.</li>

      <li>(5) D. J. Bernstein. Curve25519: New Diffie-Hellman speed records. In M. Yung, Y. Dodis, A. Kiayias, and T. Malkin, editors, Public Key Cryptography – PKC 2006, volume 3958 of LNCS, pages 207–228. Springer, Heidelberg, 2006.</li>

      <li>(6) D. J. Bernstein. Counting points as a video game, 2010. Slides of a talk given at Counting Points: Theory, Algorithms and Practice, April 19, University of Montreal: http://cr.yp.to/talks/2010.04.19/slides.pdf.</li>

      <li>(7) D. J. Bernstein, P. Birkner, M. Joye, T. Lange, and C. Peters. Twisted Edwards curves. In S. Vaudenay, editor, AFRICACRYPT, volume 5023 of LNCS, pages 389–405. Springer, 2008.</li>

      <li>(8) D. J. Bernstein, P. Birkner, T. Lange, and C. Peters. ECM using edwards curves. Math. Comput., 82(282), 2013.</li>

      <li>(9) D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B.-Y. Yang. High-speed high-security signatures. Journal of Cryptographic Engineering, 2(2):77–89, 2012.</li>

      <li>(</li>

    </ul>

    <p class="text-gray-300">10] D. J. Bernstein, M. Hamburg, A. Krasnova, and T. Lange. Elligator: Elliptic-curve points indistinguishable from uniform random strings. In ACM Conference on Computer and Communications Security, 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[11] D. J. Bernstein and T. Lange. Faster addition and doubling on elliptic curves. In K. Kurosawa, editor, ASIACRYPT, volume 4833 of LNCS, pages 29–50. Springer, 2007.</li>

      <li>[12] D. J. Bernstein and T. Lange. SafeCurves: choosing safe curves for elliptic-curve cryptography. http://safecurves.cr.yp.to, accessed 16 October 2013.</li>

      <li>[13] D. J. Bernstein and T. Lange (editors). eBACS: ECRYPT Benchmarking of Cryptographic Systems. http://bench.cr.yp.to, accessed February 3rd 2014.</li>

      <li>[14] S. Blake-Wilson, N. Bolyard, V. Gupta, C. Hawk, and B. Moeller. Elliptic curve cryptography (ECC) cipher suites for transport layer security (TLS). RFC 4492, 2006.</li>

      <li>[15] J. W. Bos, C. Costello, H. Hisil, and K. Lauter. Fast cryptography in genus 2. In T. Johansson and P. Q. Nguyen, editors, EUROCRYPT, volume 7881 of LNCS, pages 194–210. Springer, 2013.</li>

      <li>[16] J. W. Bos, J. A. Halderman, N. Heninger, J. Moore, M. Naehrig, and E. Wustrow. Elliptic curve cryptography in practice (to appear). In Financial Cryptography and Data Security, LNCS. Springer, 2014.</li>

      <li>[17] W. Bosma, J. Cannon, and C. Playoust. The Magma algebra system. I. The user language. J. Symbolic Comput., 24(3-4):235–265, 1997. Computational algebra and number theory (London, 1993).</li>

      <li>[18] W. Bosma and H. W. Lenstra. Complete systems of two addition laws for elliptic curves. Journal of Number Theory, 53(2):229–240, 1995.</li>

      <li>[19] B. B. Brumley and R. M. Hakala. Cache-timing template attacks. In M. Matsui, editor, ASIACRYPT, volume 5912 of LNCS, pages 667–684. Springer, 2009.</li>

      <li>[20] D. Brumley and D. Boneh. Remote timing attacks are practical. In S. Mangard and F.-X. Standaert, editors, Proceedings of the 12th USENIX Security Symposium, volume 6225 of LNCS, pages 80–94. Springer, 2003.</li>

      <li>[21] Certicom Research. Standards for efficient cryptography 2: Recommended elliptic curve domain parameters. Standard SEC2, Certicom, 2000.</li>

      <li>[22] B. Chevallier-Mames, M. Ciet, and M. Joye. Low-cost solutions for preventing simple side-channel analysis: Side-channel atomicity. IEEE Transactions on Computers, 53(6):760–768, 2004.</li>

      <li>[23] D. Chudnovsky and G. Chudnovsky. Sequences of numbers generated by addition in formal groups and new primality and factorization tests. Advances in Applied Mathematics, 7(4):385–434, 1986.</li>

      <li>[24] ECC Brainpool. ECC Brainpool Standard Curves and Curve Generation. http://www.ecc-brainpool.org/download/Domain-parameters.pdf, 2005.</li>

      <li>[25] H. M. Edwards. A normal form for elliptic curves. Bulletin of the American Mathematical Society, 44:393–422, July 2007.</li>

      <li>[26] J.-C. Faugère, L. Perret, C. Petit, and G. Renault. Improving the complexity of index calculus algorithms in elliptic curves over binary fields. In D. Pointcheval and T. Johansson, editors, EUROCRYPT, volume 7237 of LNCS, pages 27–44. Springer, 2012.</li>

      <li>[27] A. Faz-Hernández, P. Longa, and A. Sánchez. Efficient and secure algorithms for GLV-based scalar multiplication and their implementation on GLV-GLS curves (extended version). Journal of Cryptographic Engineering (to appear), 2014. Available at: http://eprint.iacr.org/2013/158.</li>

      <li>[28] M. Feng, B. Zhu, M. Xu, and S. Li. Efficient comb elliptic curve multiplication methods resistant to power analysis. In Cryptology ePrint Archive, Report 2005/222, 2005. Available at: http://eprint.iacr.org/2005/222.</li>

      <li>[29] P.-A. Fouque, A. Joux, and M. Tibouchi. Injective encodings to elliptic curves. In C. Boyd and L. Simpson, editors, ACISP, volume 7959 of LNCS, pages 203–218. Springer, 2013.</li>

      <li>[30] R. P. Gallant, R. J. Lambert, and S. A. Vanstone. Faster point multiplication on elliptic curves with efficient endomorphisms. In J. Kilian, editor, CRYPTO, volume 2139 of LNCS, pages 190–200. Springer, 2001.</li>

      <li>[31] S. Gueron and V. Krasnov. Fast prime field elliptic curve cryptography with 256 bit primes. Cryptology ePrint Archive, Report 2013/816, 2013. http://eprint.iacr.org/.</li>

      <li>[32] M. Hamburg. Fast and compact elliptic-curve cryptography. Cryptology ePrint Archive, Report 2012/309, 2012. http://eprint.iacr.org/.</li>

      <li>[33] M. Hamburg. Twisting edwards curves with isogenies. Cryptology ePrint Archive, Report 2014/027, 2014. http://eprint.iacr.org/.</li>

      <li>[34] D. Hankerson, A. Menezes, and S. Vanstone. Guide to elliptic curve cryptography. Springer Verlag, 2004.</li>

      <li>[35] H. Hisil, K. K.-H. Wong, G. Carter, and E. Dawson. Twisted Edwards curves revisited. In J. Pieprzyk, editor, Asiacrypt 2008, volume 5350 of LNCS, pages 326–343. Springer, Heidelberg, 2008.</li>

      <li>[36] M. Joye and M. Tunstall. Exponent recoding and regular exponentiation algorithms. In M. Joye, editor, Proceedings of Africacrypt 2003, volume 5580 of LNCS, pages 334–349. Springer, 2009.</li>

      <li>[37] A. Karatsuba and Y. Ofman. Multiplication of multidigit numbers on automata. In Soviet physics doklady, volume 7, page 595, 1963.</li>

      <li>[38] M. Knežević, F. Vercauteren, and I. Verbauwhede. Speeding up bipartite modular multiplication. In M. Hasan and T. Helleseth, editors, Arithmetic of Finite Fields – WAIFI 2010, volume 6087 of LNCS, pages 166–179. Springer Berlin / Heidelberg, 2010.</li>

      <li>[39] P. C. Kocher. Timing attacks on implementations of Diffie-Hellman, RSA, DSS, and other systems. In N. Koblitz, editor, Crypto 1996, volume 1109 of LNCS, pages 104–113. Springer, Heidelberg, 1996.</li>

      <li>[40] A. K. Lenstra. Generating RSA moduli with a predetermined portion. In K. Ohta and D. Pei, editors, Asiacrypt’98, volume 1514 of LNCS, pages 1–10. Springer Berlin / Heidelberg, 1998.</li>

      <li>[41] C. H. Lim and P. J. Lee. More flexible exponentiation with precomputation. In Y. Desmedt, editor, CRYPTO, volume 839 of LNCS, pages 95–107. Springer, 1994.</li>

      <li>[42] P. Longa and C. Gebotys. Efficient techniques for high-speed elliptic curve cryptography. In S. Mangard and F.-X. Standaert, editors, Proceedings of CHES 2010, volume 6225 of LNCS, pages 80–94. Springer, 2010.</li>

      <li>[43] P. Longa and A. Miri. New composite operations and precomputation scheme for elliptic curve cryptosystems over prime fields. In R. Cramer, editor, Proceedings of PKC 2008, volume 4939 of LNCS, pages 229–247. Springer, 2008.</li>

      <li>[44] N. Meloni. New point addition formulae for ECC applications. In C. Carlet and B. Sunar, editors, Workshop on Arithmetic of Finite Fields (WAIFI), volume 4547 of LNCS, pages 189–201. Springer, 2007.</li>

      <li>[45] B. Möller. Algorithms for multi-exponentiation. In S. Vaudenay and A. M. Youssef, editors, Selected Areas</li>

    </ul>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">in Cryptography, volume 2259 of LNCS, pages 165–180. Springer, 2001.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(46) P. L. Montgomery. Modular multiplication without trial division. Mathematics of Computation, 44(170):519–521, April 1985.</li>

      <li>(47) P. L. Montgomery. Speeding the Pollard and elliptic curve methods of factorization. Mathematics of Computation, 48(177):243–264, 1987.</li>

      <li>(48) National Security Agency. Fact sheet NSA Suite B Cryptography. http://www.nsa.gov/ia/programs/suiteb_cryptography/index.s, 2009.</li>

      <li>(49) K. Okeya and T. Takagi. The width- <span class="math">w</span> NAF method provides small memory and fast elliptic curve scalars multiplications against side-channel attacks. In M. Joye, editor, Proceedings of CT-RSA 2003, volume 2612 of LNCS, pages 328–342. Springer, 2003.</li>

      <li>(50) D. A. Osvik, A. Shamir, and E. Tromer. Cache attacks and countermeasures: The case of AES. In D. Pointcheval, editor, CT-RSA, volume 3860 of LNCS, pages 1–20. Springer, 2006.</li>

      <li>(51) M. Research. MSR Elliptic Curve Cryptography Library (MSR ECCLib), 2014. Available at: http://research.microsoft.com/en-us/projects/nsms.</li>

      <li>(52) R. Schoof. Counting points on elliptic curves over finite fields. Journal de théorie des nombres de Bordeaux, 7(1):219–254, 1995.</li>

      <li>(53) D. Shumow and N. Ferguson. On the possibility of a back door in the NIST SP800-90 dual ec prng. http://rump2007.cr.yp.to/15-shumow.pdf, 2007.</li>

      <li>(54) J. A. Solinas. Generalized Mersenne numbers. Technical Report CORR 99–39, Centre for Applied Cryptographic Research, University of Waterloo, 1999.</li>

      <li>(55) J. A. Solinas. Efficient arithmetic on Koblitz curves. Designs, Codes and Cryptography, 19(195–249), 2000.</li>

      <li>(56) The New York Times. Government announces steps to restore confidence on encryption standards. http://bits.blogs.nytimes.com/2013/09/10/government-announces-steps-to-restore-confidence-on-encryption-standards, 2013.</li>

      <li>(57) M. Tibouchi. Elligator squared: Uniform points on elliptic curves of prime order as uniform random strings. Cryptology ePrint Archive, Report 2014/043, 2014. http://eprint.iacr.org/.</li>

      <li>(58) U.S. Department of Commerce/National Institute of Standards and Technology. Digital Signature Standard (DSS). FIPS-186-4, 2013. http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf.</li>

      <li>(59) C. D. Walter. Montgomery exponentiation needs no final subtractions. Electronics Letters, 35(21):1831–1832, 1999.</li>

    </ul>

    <h2 id="sec-33" class="text-2xl font-bold">Appendix A Algorithms for Scalar Multiplication</h2>

    <p class="text-gray-300">Algorithms for variable-base scalar multiplication. Algorithm 1 computes scalar multiplication for the variable-base scenario using the fixed-window method from [49]. We refer to Sections 4.1 and 4.2 for details on its usage with Weierstrass and twisted Edwards curves, respectively. The computation of this operation mainly consists of four different stages: input and point validation, precomputation, recoding and evaluation. Input and point validation are computed at the very beginning of the execution using Algorithm 2 for Weierstrass curves and Algorithm 3 for twisted Edwards curves. In particular, Algorithm 3 performs two doublings over the input point in twisted Edwards to ensure that subsequent computations are performed in the large prime order subgroup (avoiding small subgroup attacks). We remark that it is the protocol implementer’s responsibility to ensure that timing differences during the detection of errors do not leak sensitive information to an attacker. In the precomputation stage, the implementer should first select a window width <span class="math">2\\leq w&amp;lt;10</span> according to efficiency and/or memory considerations. For example, selecting <span class="math">w=6</span> for 256-, 384- and 512-bit scalar multiplication was found to achieve optimal performance in our implementations of Weierstrass curves. Precomputation is then computed by successively executing <span class="math">P+2P+2P+\\ldots+2P</span> with <span class="math">2^{w-2}-1</span> point additions and storing the intermediate results. Explicit schemes are given in Algorithms 4 and 5 for <span class="math">a=-3</span> Weierstrass and <span class="math">a=-1</span> twisted Edwards curves, respectively. In the recoding stage, we use a variant of the regular recoding by [36] that ensures fixed length (see Algorithm 6). Since Algorithm 6 only recodes odd integers, we include a conversion step at Step 6 to deal with even values. The corresponding correction is performed at Step 20. These computations should be executed in constant time to protect against timing attacks. For example, a constant time execution of Step 6 could be implemented as follows (assuming a two’s complement representation in which <span class="math">-1\\equiv 0</span>xFF<span class="math">\\ldots</span>FF, and bitlength(<span class="math">odd</span>) = bitlength(<span class="math">k</span>)):</p>

    <p class="text-gray-300"><span class="math">odd</span> <span class="math">=</span> <span class="math">-(k\\text{ AND }1)</span> <span class="math">\\{</span>If <span class="math">k</span> is even then <span class="math">odd=</span>0xFF<span class="math">\\ldots</span>FF else <span class="math">odd=0\\}</span></p>

    <p class="text-gray-300"><span class="math">k^{\\prime}</span> <span class="math">=</span> <span class="math">k-r</span></p>

    <p class="text-gray-300"><span class="math">k</span> <span class="math">=</span> <span class="math">(odd\\text{ AND }(k\\text{ XOR }k^{\\prime}))\\text{ XOR }k^{\\prime}</span> <span class="math">\\{</span>If <span class="math">odd=0</span> then <span class="math">k</span> = <span class="math">k-r\\}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The main computation in the evaluation stage consists of <span class="math">t=[\\log_{2}(r)/(w-1)]</span> iterations each computing <span class="math">(w-1)</span> doublings and one addition with a value from the precomputed table. For <span class="math">a=-3</span> Weierstrass curves, the use of Jacobian coordinates is a popular choice for efficiency reasons. If this is used, then Algorithm 1 can use an efficient merged doubling-addition formula [43] when <span class="math">w&amp;gt;2</span> by setting DBLADD = <span class="math">true</span>. Other cases, including Weierstrass curves with <span class="math">w=2</span> or twisted Edwards curves, should use DBLADD = <span class="math">false</span>. Note that the evaluation of DBLADD is used to simplify the description of the algorithm. An implementation might choose for having separate functions for twisted Edwards and Weierstrass curves. Following the recommendations from Section 4, the last addition should be performed with a unified formula (denoted by <span class="math">\\oplus</span>) in order to avoid exceptions and it has been separated from the main loop; see Steps 18 and 19. To achieve constant-time execution, the points from the precomputed table should be extracted by doing a full pass over all the points in the lookup table and masking the correct value with the index $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)/2$. Finally, a suitable conversion to affine coordinates may be computed at Step 21 (if required).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 7 computes scalar multiplication for the fixed-base scenario using the modified LSB-set method [27] (denoted by mLSB-set), which combines the comb method [41] and LSB-set recoding [28]. Refer to Sections 4.1 and 4.2 for details on the use of the method with Weierstrass and twisted Edwards curves, respectively. This operation consists of computations executed offline, which involve point validation and precomputing multiples of the known input point, and computations executed online, which involve scalar validation, recoding and evaluation stages. As before, point validation for twisted Edwards using Algorithm 3 during the offline phase performs two doublings over the input point to ensure that</p>

    <p class="text-gray-300">Algorithm 6 Protected odd-only recoding algorithm for the fixed-window representation.</p>

    <p class="text-gray-300">⬇ Input: odd integer <span class="math">k\\in[1,r)</span> and window width <span class="math">w\\geq 2</span>, where <span class="math">r</span> is the prime order of the targeted elliptic curve (sub)group. Output: <span class="math">(k_{t},\\ldots,k_{0})</span>, where <span class="math">k_{i}\\in\\{\\pm 1,\\pm 3,\\cdots,\\pm(2^{w-1}-1)\\}</span> and <span class="math">t=[\\log_{2}(r)/(w-1)]</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t=[\\log_{2}(r)/(w-1)]</span></li>

      <li>for <span class="math">i=0</span> to <span class="math">(t-1)</span> do</li>

      <li><span class="math">k_{i}=(k\\mod 2^{w})-2^{w-1}</span></li>

      <li><span class="math">k=(k-k_{i})/2^{w-1}</span></li>

      <li><span class="math">k_{t}=k</span></li>

      <li>return <span class="math">(k_{t},\\ldots,k_{0})</span>.</li>

    </ol>

    <p class="text-gray-300">The following is the main result of the main results of the computation:</p>

    <p class="text-gray-300">the computation takes place in the large prime order subgroup. Again, it is the protocol implementer’s responsibility to ensure that timing differences during the detection of errors do not leak sensitive information to an attacker. The implementer should choose a window width <span class="math">2\\leq w&lt;10</span> and a table parameter <span class="math">v\\geq 1</span> according to efficiency and/or memory constraints, taking into account that the mLSB-set method requires <span class="math">v\\cdot 2^{w-1}</span> precomputed points. For example, selecting <span class="math">w=6</span> and <span class="math">v=3</span> for 256-bit scalar multiplication was found to achieve optimal performance in our implementations of Weierstrass curves when storage is constrained to 6KB. During the online computation, the recoded scalar obtained from Algorithm 8 has a fixed length, which enables a fully regular execution when the representation is set up as described at Step 7. Since Algorithm 8 only recodes odd integers, we include a conversion step at Step 6 to deal with even values. The corresponding correction is performed at Step 13. In the evaluation stage, the main computation consists of <span class="math">e-1=\\lceil\\lceil\\log_{2}(r)\\rceil/(wv)\\rceil-1</span> iterations each computing one doubling and <span class="math">v</span> additions with a value from the precomputed table. Following Section 4, the additions should be performed with a unified formula (denoted by <span class="math">\\oplus</span>) to avoid exceptions. Note that, as described in the variable-base case, all the conditional computations using “if” statements as well as the extraction of points from the precomputed table should be executed in constant time in order to protect against timing attacks (with the exception of Step 3, which depends on public parameters; any potential leak through the detection of errors at Step 4 should be assessed by the protocol’s implementer). Finally, a suitable conversion to affine coordinates may be computed at Step 14 (if required).</p>

    <p class="text-gray-300">Algorithm 9 computes double-scalar multiplication, which is typically found in signature verification schemes, and uses the width-<span class="math">w</span> non-adjacent form [55] with interleaving [30; 45]. We assume that one of the input points is known in advance (<span class="math">P_{2}</span>) whereas the other one is a variable base (<span class="math">P_{1}</span>). Hence, we distinguish two phases: <em>offline</em>, which involves validation of <span class="math">P_{2}</span> and a precomputation stage using the value <span class="math">w_{2}</span>; and <em>online</em>, which involves scalar validation, point validation of <span class="math">P_{1}</span> and precomputation (using <span class="math">w_{1}</span>), recoding and evaluation stages. Again, point validation for twisted Edwards curves with Algorithm 3 performs two doublings over the input points to ensure computation in the large prime order subgroup. The precomputation for both input points are performed as in the variable-base scenario using Algorithms 4 and 5 for <span class="math">a=-3</span> Weierstrass and <span class="math">a=-1</span> twisted Edwards curves, respectively. However, the implementer has additional freedom in the selection of <span class="math">w_{2}</span> since the precomputation for the fixed-base is done offline. For example, we found that using <span class="math">w_{1}=6</span> and <span class="math">w_{2}=7</span> results in optimal performance in our implementa.</p>

    <p class="text-gray-300">Algorithm 7 Protected fixed-base scalar multiplication using the modified LSB-set comb method.</p>

    <p class="text-gray-300">⬇ Input: A point <span class="math">P=(x,y)\\in E(\\mathbf{F}_{p})</span>, where <span class="math">\\#E=h.r</span> with co-factor <span class="math">h\\in\\mathbf{Z}^{n}</span> and <span class="math">r</span> prime, a scalar <span class="math">k=(k_{t-1},\\ldots,k_{0})_{2}\\in[0,r)</span>, where <span class="math">t=\\lceil\\log_{2}(r)\\rceil</span>, window width <span class="math">w\\geq 2</span>, and table parameter <span class="math">v\\geq 1</span>, such that <span class="math">e=\\lceil t/(wv)\\rceil</span>, <span class="math">d=ev</span> and <span class="math">t=dw</span>. Output: <span class="math">kP</span>.</p>

    <p class="text-gray-300"><em>Offline computation</em>:</p>

    <p class="text-gray-300">Precomputation stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run point validation and compute <span class="math">T=4P</span> (for <span class="math">\\mathcal{E}_{d}</span>) using Algorithm 2 for <span class="math">E_{b}</span> and Algorithm 3 for <span class="math">\\mathcal{E}_{d}</span>. If “invalid” return (“error: invalid point”), else set <span class="math">P=T</span> (for <span class="math">\\mathcal{E}_{d}</span>).</li>

    </ol>

    <p class="text-gray-300">[if: validation]</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">P[i][j]=2^{ej}(1+i_{0}2^{d}+\\ldots+i_{w-2}2^{(w-1)d})P</span> for all <span class="math">0\\leq i&lt;2^{w-1}</span> and <span class="math">0\\leq j&lt;v</span>, where <span class="math">i=(i_{w-2},\\ldots,i_{0})_{2}</span>.</li>

      <li>if <span class="math">wv\\mid t</span> then compute <span class="math">2^{wd}P</span>.</li>

    </ol>

    <p class="text-gray-300">[if: algorithm variant]</p>

    <p class="text-gray-300"><em>Online computation</em>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">k=0\\vee k\\geq r</span> then return (“error: invalid scalar”) [if: validation]</li>

    </ol>

    <p class="text-gray-300">Recoding stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>odd <span class="math">=k</span> mod 2</li>

      <li>if odd <span class="math">=0</span> then <span class="math">k=r-k</span> [if: masked constant time]</li>

      <li>Pad <span class="math">k</span> with <span class="math">dw-t</span> zeros to the left and convert it to the <span class="math">m</span>LSB-set representation using Algorithm 8 such that <span class="math">k=(c,b_{l-1},\\ldots,b_{0})_{m\\text{LSB-set}}</span>. Set the digit columns <span class="math">\\mathbf{T}_{i,j}=\\lceil\\sum_{m=0}^{w-2}b_{(m+1)d+ei+j}2^{m}\\rceil</span> with signs <span class="math">s_{i,j}=b_{ei+j}</span> for all <span class="math">0\\leq i&lt;v</span> and <span class="math">0\\leq j&lt;e</span>.</li>

    </ol>

    <p class="text-gray-300">Evaluation stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q=\\sum_{i=0}^{v-1}s_{i,e-1}P[\\mathbf{T}_{i,e-1}][i]</span></li>

      <li>for <span class="math">i=e-2</span> to <span class="math">0</span> do</li>

      <li><span class="math">Q=2Q</span> (Use Alg.10 for <span class="math">E_{b}</span> and Alg.14 for <span class="math">\\mathcal{E}_{d}</span>)</li>

      <li><span class="math">Q=Q\\oplus\\sum_{j=0}^{v-1}s_{j,i}P[\\mathbf{T}_{j,i}][j]</span> (Use Alg.18 for <span class="math">E_{b}</span> and Alg.17 for <span class="math">\\mathcal{E}_{d}</span>)</li>

      <li>if <span class="math">wv\\mid t\\land c=1</span> then <span class="math">Q=Q+2^{wd}P</span> [if: masked constant time]</li>

      <li>if odd <span class="math">=0</span> then <span class="math">Q=-Q</span> [if: masked constant time]</li>

      <li>Convert <span class="math">Q</span> to affine coordinates <span class="math">(x,y)</span>.</li>

      <li>return <span class="math">Q</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 8</p>

    <p class="text-gray-300">This is the main result of the main results of the computation.</p>

    <p class="text-gray-300">This is the main result of the main results of the computation.</p>

    <h2 id="sec-34" class="text-2xl font-bold">Appendix B Algorithms for Point Operations</h2>

    <p class="text-gray-300">Refer to Algorithms 10-17.</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Algorithm 8 Protected odd-only recoding algorithm for the modified LSB-set representation. Input: An odd  <span class="math">\\ell</span> -bit integer  <span class="math">k = (k_{\\ell -1},\\ldots ,k_0)_2\\in [1,r)</span>  window width  <span class="math">w\\geq 2</span>  and table parameter  <span class="math">v\\geq 1</span>  where  <span class="math">r</span>  is the prime order of the targeted elliptic curve group such that  <span class="math">e = \\lceil t / (wv)\\rceil</span> <span class="math">d = ev</span>  and  <span class="math">\\ell = dw</span>  where  <span class="math">t = \\lceil \\log_2(r)\\rceil</span> Output:  <span class="math">(c,b_{\\ell -1},\\dots ,b_0)_{mLSB - set}</span>  where  <span class="math">\\left\\{b_i\\in \\{1, - 1\\} \\quad \\text{if} 0\\leq i &amp;lt;   d\\right.</span>  if  <span class="math">wv\\mid t</span>  then  <span class="math">c\\in \\{0,1\\}</span>  otherwise,  <span class="math">c = 0</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b_{d - 1} = 1</span></li>

      <li>for  <span class="math">i = 0</span>  to  <span class="math">(d - 2)</span>  do</li>

      <li><span class="math">b_{i} = 2k_{i + 1} - 1</span></li>

      <li><span class="math">c = \\lfloor k / 2^d\\rfloor</span></li>

      <li>for  <span class="math">i = d</span>  to  <span class="math">(\\ell -1)</span>  do</li>

      <li><span class="math">b_{i} = b_{i\\bmod d}\\cdot c_{0}</span></li>

      <li><span class="math">c = \\lfloor c / 2\\rfloor -\\lfloor b_i / 2\\rfloor</span></li>

      <li>return  <span class="math">(c,b_{l - 1},\\dots ,b_0)_{mLSB - set}</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 10 Point doubling using Jacobian coordinates on Weierstrass curves  <span class="math">(E_b)</span> . Input:  <span class="math">P = (X_1, Y_1, Z_1) \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates. Output:  <span class="math">2P = (X_2, Y_2, Z_2) \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_1 = Z_1^2</span>  10.  <span class="math">t_4 = t_4 - t_3</span></li>

      <li><span class="math">t_2 = X_1 + t_1</span>  11.  <span class="math">X_2 = t_4 - t_3</span></li>

      <li><span class="math">t_1 = X_1 - t_1</span>  12.  <span class="math">Z_2 = Y_1 \\times Z_1</span></li>

      <li><span class="math">t_1 = t_1 \\times t_2</span>  13.  <span class="math">t_2 = t_2^2</span></li>

      <li><span class="math">t_2 = t_1 / 2</span>  14.  <span class="math">t_4 = t_3 - X_2</span></li>

      <li><span class="math">t_1 = t_1 + t_2</span>  15.  <span class="math">t_1 = t_1 \\times t_4</span></li>

      <li><span class="math">t_2 = Y_1^2</span>  16.  <span class="math">Y_2 = t_1 - t_2</span></li>

      <li><span class="math">t_3 = X_1 \\times t_2</span>  17. return 2P = (X2, Y2, Z2).</li>

    </ol>

    <p class="text-gray-300">Weierstrass curves. It is standard to represent points on  <span class="math">E_{b} \\colon y^{2} = x^{3} - 3x + b</span>  using Jacobian coordinates [21,48,58]: for non-zero  <span class="math">Z \\in \\mathbf{F}_{p}</span> , the tuple  <span class="math">(X \\colon Y \\colon Z)</span>  is used to represent the affine point  <span class="math">(X / Z^2, Y / Z^3)</span>  on  <span class="math">E_{b}</span> . There are many different variants of the Jacobian formulas originally proposed in [23]. In our implementation we use the doubling formula from [42] (see Algorithm 10). Point additions are usually performed between a running point and a point from a (precomputed) 'look-up' table. Typically, it is advantageous to leave the precomputed points in projective form for variable-base computations, and to convert them (offline) to their affine form for fixed-base computations. When elements in the table are stored in affine coordinates, point addition is performed using mixed Jacobian/affine coordinates using, for example, the formula presented in [34] (see Algorithm 13). There are cases in which exceptions in the formulas might arise. This is the case, for example, for fixed-base scalar multiplication. To achieve constant-time execution, we devised a complete formula based on masking that works for point addition, doubling, inverses and the point at infinity (see Algorithm 18). If points from the precomputed table are stored in projective coordinates, we use Chudnovsky coordinates to represent the affine point  <span class="math">(X / Z^2, Y / Z^3) \\in E_{b}</span>  by the projective tuple  <span class="math">(X : Y : Z : Z^2 : Z^3)</span> . The corresponding addition formula is given as Algorithm 12. More efficiently, whenever a dou</p>

    <p class="text-gray-300">Algorithm 11 Merged point doubling-addition using Jacobian/Chudnovsky coordinates on Weierstrass curves  <span class="math">(E_b)</span> . Input:  <span class="math">P, Q \\in E_b(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1)</span>  is in Jacobian coordinates and  <span class="math">Q = (X_2, Y_2, Z_2, Z_2^2, Z_2^3)</span>  is in Chudnovsky coordinates. Output:  <span class="math">2P + Q = (X_4, Y_4, Z_4) \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">P = \\mathcal{O}</span>  then return  <span class="math">Q</span>  20.  <span class="math">X_4 = t_4 \\times t_5</span>  [if: exception] 21.  <span class="math">t_4 = t_2^2</span></li>

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then use Algo- 22.  <span class="math">t_4 = t_4 - t_1</span>  rithm 10 to compute and 23.  <span class="math">t_4 = t_4 - X_4</span>  return 2P [if: exception] 24.  <span class="math">t_4 = t_4 - X_4</span>  25.  <span class="math">t_4 = t_4 - X_4</span></li>

      <li><span class="math">t_1 = Z_1^2</span>  26. if  <span class="math">t_4 = 0</span>  then return (O)</li>

      <li><span class="math">t_2 = Z_1 \\times t_1</span>  [if: exception]</li>

      <li><span class="math">t_3 = Z_2^2 \\times Y_1</span>  27.  <span class="math">Y_4 = t_1 \\times t_3</span></li>

      <li><span class="math">t_2 = Y_2 \\times t_2</span>  28.  <span class="math">t_1 = t_2 \\times t_4</span></li>

      <li><span class="math">t_2 = t_2 - t_3</span>  29.  <span class="math">t_1 = t_1 + Y_4</span></li>

      <li><span class="math">t_4 = Z_2^2 \\times X_1</span>  30.  <span class="math">t_1 = t_1 + Y_4</span></li>

      <li><span class="math">t_1 = t_1 \\times X_2</span>  31.  <span class="math">Z_4 = Z_4 \\times t_4</span></li>

      <li><span class="math">t_1 = t_1 - t_4</span>  32.  <span class="math">t_2 = t_4^2</span></li>

      <li>if  <span class="math">t_1 = 0</span>  then [if: exception] 33.  <span class="math">t_4 = t_2 \\times t_4</span>  34.  <span class="math">t_2 = t_2 \\times X_4</span></li>

      <li>if  <span class="math">t_2 = 0</span>  then [if: exception] 35.  <span class="math">t_3 = t_1^2</span>  36.  <span class="math">t_3 = t_3 - t_4</span></li>

      <li>Use Alg. 10 to 37.  <span class="math">t_3 = t_3 - t_2</span>  compute  <span class="math">R = 2P</span>  38.  <span class="math">X_4 = t_3 - t_2</span></li>

      <li>Use Alg. 12 to 39.  <span class="math">t_3 = X_4 - t_2</span>  compute and return  <span class="math">R + Q</span>  40.  <span class="math">t_4 = t_4 \\times Y_4</span></li>

      <li>else return  <span class="math">P</span>  41.  <span class="math">t_1 = t_1 \\times t_3</span></li>

      <li><span class="math">Z_4 = Z_1 \\times Z_2</span>  42.  <span class="math">Y_4 = t_1 - t_4</span></li>

      <li><span class="math">Z_4 = t_1 \\times Z_4</span>  43. return 2P + Q = (X4, Y4, Z4).</li>

      <li><span class="math">t_5 = t_1^2</span></li>

      <li><span class="math">t_1 = t_1 \\times t_5</span></li>

    </ol>

    <p class="text-gray-300">bling is followed by an addition (as in the main loop of the variable-base scalar multiplication; see Algorithm 1) one can use a merged doubling-addition formula [43] that is based on the special addition with the same  <span class="math">Z</span> -coordinate from [44] (see Algorithm 11). The different costs of the point formulas used in our implementation can be found in Table 5. Finally, the exact routine to perform the precomputation for the variable-base scenario is outlined in Algorithm 4. The scheme uses a straightforward variant of the general formulas, including the special addition from [44].</p>

    <p class="text-gray-300">Twisted Edwards curves. Hisil et al. [35] derive efficient formulas for additions on (special) twisted Edwards curves [7] by representing affine points  <span class="math">(X / Z, Y / Z)</span>  on  <span class="math">\\mathcal{E}_d</span> :  <span class="math">-x^2 + y^2 = 1 + dx^2y^2</span>  by the projective tuple  <span class="math">(X:Y:Z:T)</span> , where  <span class="math">T = XY / Z</span> . Hamburg [32] proposes to represent such a projective point using five elements:  <span class="math">(X:Y:Z:T_1:T_2)</span> , where  <span class="math">T = T_1T_2</span> . This has the advantage of avoiding a required lookahead when computing the elliptic curve scalar multiplication using the techniques from [35]. If the addition formulas are "dedicated" they do not work for doubling but are usually more efficient. The details of the dedicated additions used in our implementation are outlined in Algorithm 15 and 16. For settings that might trigger exceptions in the formulas (e.g., fixed-based scalar multiplication), one can use the unified addition formula proposed by [35] (see Algorithm 17). The algorithm for point doubling on  <span class="math">\\mathcal{E}_d</span>  is given in Algorithm 14:</p>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">Algorithm 12 Point addition using Jacobian/Chudnovsky coordinates on Weierstrass curves  <span class="math">(E_b)</span> . Input:  <span class="math">P, Q \\in E_b(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1)</span>  is in Jacobian coordinates and  <span class="math">Q = (X_2, Y_2, Z_2, Z_2^2, Z_2^3)</span>  is in Chudnovsky coordinates. Output:  <span class="math">P + Q = (X_3, Y_3, Z_3) \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">P = \\mathcal{O}</span>  then return 14. else return  <span class="math">(\\mathcal{O})</span> <span class="math">Q</span>  [if: exception] 15.  <span class="math">Z_3 = Z_1 \\times Z_2</span></li>

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then return 16.  <span class="math">Z_3 = t_1 \\times Z_3</span> <span class="math">P</span>  [if: exception] 17.  <span class="math">t_5 = t_1^2</span></li>

      <li><span class="math">t_1 = Z_1^2</span>  18.  <span class="math">t_1 = t_1 \\times t_5</span></li>

      <li><span class="math">t_2 = Z_1 \\times t_1</span>  19.  <span class="math">t_4 = t_4 \\times t_5</span></li>

      <li><span class="math">t_3 = Z_2^3 \\times Y_1</span>  20.  <span class="math">t_5 = t_2^2</span></li>

      <li><span class="math">t_2 = Y_2 \\times t_2</span>  21.  <span class="math">t_5 = t_5 - t_1</span></li>

      <li><span class="math">t_2 = t_2 - t_3</span>  22.  <span class="math">t_5 = t_5 - t_4</span></li>

      <li><span class="math">t_4 = Z_2^2 \\times X_1</span>  23.  <span class="math">X_3 = t_5 - t_4</span></li>

      <li><span class="math">t_1 = t_1 \\times X_2</span>  24.  <span class="math">t_4 = t_4 - X_3</span></li>

      <li><span class="math">t_1 = t_1 - t_4</span>  25.  <span class="math">t_4 = t_2 \\times t_4</span></li>

      <li>if  <span class="math">t_1 = 0</span>  then [if: exception] 26.  <span class="math">t_1 = t_1 \\times t_3</span></li>

      <li>if  <span class="math">t_2 = 0</span>  then [if: exception] 27.  <span class="math">Y_3 = t_4 - t_1</span></li>

      <li>Use Alg. 10 to compute and return 2P.</li>

    </ol>

    <p class="text-gray-300">Algorithm 13 Point addition using Jacobian/affine coordinates on Weierstrass curves  <span class="math">(E_b)</span> . Input:  <span class="math">P, Q \\in E_b(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1)</span>  is in Jacobian coordinates and  <span class="math">Q = (x_2, y_2)</span>  is in affine coordinates. Output:  <span class="math">P + Q = (X_3, Y_3, Z_3) \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">P = \\mathcal{O}</span>  then return 12. else return  <span class="math">(\\mathcal{O})</span> <span class="math">Q</span>  [if: exception] 13.  <span class="math">Z_3 = Z_1 \\times t_1</span></li>

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then return 14.  <span class="math">t_3 = t_1^2</span> <span class="math">P</span>  [if: exception] 15.  <span class="math">t_4 = t_1 \\times t_3</span></li>

      <li><span class="math">t_1 = Z_1^2</span>  16.  <span class="math">t_3 = X_1 \\times t_3</span></li>

      <li><span class="math">t_2 = Z_1 \\times t_1</span>  17.  <span class="math">t_1 = t_3 + t_3</span></li>

      <li><span class="math">t_1 = t_1 \\times x_2</span>  18.  <span class="math">X_3 = t_2^2</span></li>

      <li><span class="math">t_2 = t_2 \\times y_2</span>  19.  <span class="math">X_3 = X_3 - t_1</span></li>

      <li><span class="math">t_1 = t_1 - X_1</span>  20.  <span class="math">X_3 = X_3 - t_4</span></li>

      <li><span class="math">t_2 = t_2 - Y_1</span>  21.  <span class="math">t_3 = t_3 - X_3</span></li>

      <li>if  <span class="math">t_1 = 0</span>  then [if: exception] 22.  <span class="math">t_3 = t_2 \\times t_3</span></li>

      <li>if  <span class="math">t_2 = 0</span>  then [if: exception] 23.  <span class="math">t_4 = t_4 \\times Y_1</span></li>

      <li>Use Alg. 10 to compute and return 2P. 24.  <span class="math">Y_3 = t_3 - t_4</span></li>

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then return 25. return  <span class="math">P + Q = (X_3, Y_3, Z_3)</span> .</li>

    </ol>

    <p class="text-gray-300">this extends the formula from [7] by using the five element representation as suggested in [32].</p>

    <p class="text-gray-300">When storing precomputed points, we follow the caching techniques described in [35]: we store affine points as  <span class="math">(x + y, y - x, 2t)</span>  with  <span class="math">t = xy</span> , or projective points as  <span class="math">(X + Y:Y - X:2Z:2T)</span>  with  <span class="math">T = XY / Z</span> , both of which can speed up the scalar multiplication computation. Just as in the case of the Weierstrass curves above, it is usually advantageous to leave the precomputed points in projective form for variable-base</p>

    <p class="text-gray-300">Algorithm 14 Point doubling using homogeneous/extended homogeneous coordinates on Edwards curves  <span class="math">(\\mathcal{E}_d)</span> . Input:  <span class="math">P = (X_{1},Y_{1},Z_{1})\\in \\mathcal{E}_{d}(\\mathbf{F}_{p})</span> Output:  <span class="math">2P = (X_{2},Y_{2},Z_{2},T_{2,a},T_{2,b})\\in \\mathcal{E}_{d}(\\mathbf{F}_{p}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">t_1 = X_1^2</span>  8.  <span class="math">t_2 = Z_1^2</span></li>

      <li><span class="math">t_2 = Y_1^2</span>  9.  <span class="math">t_2 = t_2 + t_2</span></li>

      <li><span class="math">T_{3,b} = t_1 + t_2</span>  10.  <span class="math">t_2 = t_2 - t_1</span></li>

      <li><span class="math">t_1 = t_2 - t_1</span>  11.  <span class="math">Z_{2} = t_{1}\\times t_{2}</span></li>

      <li><span class="math">t_2 = Y_1 + Y_1</span>  12.  <span class="math">X_{2} = t_{2}\\times T_{2,a}</span></li>

      <li><span class="math">T_{2,a} = X_1\\times t_2</span>  13. return 2P = 7.  <span class="math">Y_{2} = t_{1}\\times T_{2,b}</span> <span class="math">(X_{2},Y_{2},Z_{2},T_{2,a},T_{2,b})</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 15 Point addition using extended homogeneous coordinates on Edwards curves  <span class="math">(\\mathcal{E}_d)</span> . Input:  <span class="math">P, Q \\in \\mathcal{E}_d(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1, T_{1,a}, T_{1,b})</span>  and  <span class="math">Q = (X_2 + Y_2, Y_2 - X_2, 2Z_2, 2T_2)</span> . Output:  <span class="math">P + Q = (X_3, Y_3, Z_3, T_{3,a}, T_{3,b}) \\in \\mathcal{E}_d(\\mathbf{F}_p)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then return 12.  <span class="math">t_2 = T_{3,a} \\times (2Z_2)</span> <span class="math">P</span>  [if: exception] 13.  <span class="math">T_{3,a} = t_2 - t_1</span></li>

      <li>if  <span class="math">P = \\mathcal{O}</span>  then [if: exception] 14.  <span class="math">T_{3,b} = t_1 + t_2</span>  15.  <span class="math">t_2 = X_1 + Y_1</span></li>

      <li><span class="math">t_1 = (X_2 + Y_2) - (Y_2 - X_2)</span>  16.  <span class="math">t_1 = (Y_2 - X_2) \\times t_2</span>  17.  <span class="math">t_2 = Y_1 - X_1</span></li>

      <li><span class="math">t_1 = t_1 / 2</span>  18.  <span class="math">t_2 = (X_2 + Y_2) \\times t_2</span></li>

      <li><span class="math">Y_3 = (Y_2 - X_2) + t_1</span>  19.  <span class="math">Z_3 = t_1 - t_2</span></li>

      <li><span class="math">X_3 = t_1</span>  20.  <span class="math">t_1 = t_1 + t_2</span></li>

      <li><span class="math">Z_3 = (2Z_2) / 2</span>  21.  <span class="math">X_3 = T_{3,b} \\times Z_3</span></li>

      <li><span class="math">T_{3,a} = (2T_2) / 2</span>  22.  <span class="math">Z_3 = Z_3 \\times t_1</span></li>

      <li><span class="math">T_{3,b} = 1</span>  23.  <span class="math">Y_3 = T_{3,a} \\times t_1</span></li>

      <li><span class="math">T_{3,a} = T_{1,a} \\times T_{1,b}</span>  24. return  <span class="math">P + Q = (X_3, Y_3, Z_3, T_{3,a}, T_{3,b})</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 16 Point addition using extended homogeneous/extended affine coordinates on Edwards curves  <span class="math">(\\mathcal{E}_d)</span> . Input:  <span class="math">P, Q \\in \\mathcal{E}_d(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1, T_{1,a}, T_{1,b})</span>  and  <span class="math">Q = (x_2 + y_2, y_2 - x_2, 2t_2)</span> . Output:  <span class="math">P + Q = (X_3, Y_3, Z_3, T_{3,a}, T_{3,b}) \\in \\mathcal{E}_d(\\mathbf{F}_p)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then return 12.  <span class="math">t_2 = T_{3,a} + T_{3,a}</span> <span class="math">P</span>  [if: exception] 13.  <span class="math">T_{3,a} = t_2 - t_1</span></li>

      <li>if  <span class="math">P = \\mathcal{O}</span>  then [if: exception] 14.  <span class="math">T_{3,b} = t_1 + t_2</span>  15.  <span class="math">t_2 = X_1 + Y_1</span></li>

      <li><span class="math">t_1 = (x_2 + y_2) - (y_2 - x_2)</span>  16.  <span class="math">t_1 = (Y_2 - X_2) \\times t_2</span>  17.  <span class="math">t_2 = Y_1 - X_1</span></li>

      <li><span class="math">t_1 = t_1 / 2</span>  18.  <span class="math">t_2 = (X_2 + Y_2) \\times t_2</span></li>

      <li><span class="math">Y_3 = (y_2 - x_2) + t_1</span>  19.  <span class="math">Z_3 = t_1 - t_2</span></li>

      <li><span class="math">X_3 = t_1</span>  20.  <span class="math">t_1 = t_1 + t_2</span></li>

      <li><span class="math">Z_3 = 1</span>  21.  <span class="math">X_3 = T_{3,b} \\times Z_3</span></li>

      <li><span class="math">T_{3,a} = (2t_2) / 2</span>  22.  <span class="math">Z_3 = Z_3 \\times t_1</span></li>

      <li><span class="math">T_{3,b} = 1</span>  23.  <span class="math">Y_3 = T_{3,a} \\times t_1</span></li>

      <li><span class="math">T_{3,a} = T_{1,a} \\times T_{1,b}</span>  24. return  <span class="math">P + Q = (X_3, Y_3, Z_3, T_{3,a}, T_{3,b})</span> .</li>

    </ol>

    <p class="text-gray-300">computations, and to convert them (offline) to their affine form for fixed-base computations. The explicit routine that performs the precomputation for the variable-base scenario is outlined in Algorithm 5. The costs of the different formulas used in our implementation are displayed in Table 5.</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Table 5 An overview of the number of modular operations required to implement the group law for  <span class="math">a = -3</span>  Weierstrass,  <span class="math">a = -1</span>  twisted Edwards and Montgomery curves using different coordinate systems. The Weierstrass point doubling works on Jacobian coordinates while the point addition formula takes as input one Jacobian (Jac) coordinate and the other in either affine (aff) or (projective) Chudnovsky coordinates. We also show a merged double-and-add approach which computes  <span class="math">R = 2P + Q</span>  where  <span class="math">R</span>  and  <span class="math">P</span>  are in Jacobian and  <span class="math">Q</span>  in Chudnovsky coordinates. The complete addition formulas also include the number of table look-ups (denoted by #lut) that are required for their realization. The Edwards doubling uses the five-element projective coordinates  <span class="math">(X:Y:Z:T_1:T_2)</span> . The Edwards addition adds a five-element projective coordinate  <span class="math">(X:Y:Z:T_1:T_2)</span>  to a four-element projective coordinate  <span class="math">(X + Y:Y - X:2Z:2T)</span>  (proj.) or a three-element extended affine coordinate  <span class="math">(x + y,y - x,2t)</span>  (aff.) resulting in a five-element coordinate as a result. The performance of a single step of the Montgomery ladder (which computes a doubling and a differential addition) is stated as well.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ref</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#mul</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#sqr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#mulc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#sub</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#div2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#lut</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">see</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Weierstrass double</td>

            <td class="px-3 py-2 border-b border-gray-700">[42]</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 10</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Weierstrass add: |  |  |  |  |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Jac + Chud → Jac</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[23]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 12</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Weierstrass dbl-add</td>

            <td class="px-3 py-2 border-b border-gray-700">[43]</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Complete) Jac + aff → Jac</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Complete) Jac + Jac → Jac</td>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Edwards doubling</td>

            <td class="px-3 py-2 border-b border-gray-700">[7]</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Edwards addition proj.</td>

            <td class="px-3 py-2 border-b border-gray-700">[35]</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Edwards addition aff.</td>

            <td class="px-3 py-2 border-b border-gray-700">[35]</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Unified) Edwards addition proj.</td>

            <td class="px-3 py-2 border-b border-gray-700">[35]</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Unified) Edwards addition aff.</td>

            <td class="px-3 py-2 border-b border-gray-700">[35]</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm 17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Montgomery ladder step double-and-add</td>

            <td class="px-3 py-2 border-b border-gray-700">[47]</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithm 17 Unified point addition using extended homogeneous coordinates on Edwards curves  <span class="math">(\\mathcal{E}_d)</span> . Input:  <span class="math">P, Q \\in \\mathcal{E}_d(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1, T_{1,a}, T_{1,b})</span>  and  <span class="math">Q = (X_2 + Y_2, Y_2 - X_2, 2Z_2, 2T_2)</span> . Output:  <span class="math">P + Q = (X_3, Y_3, Z_3, T_{3,a}, T_{3,b}) \\in \\mathcal{E}_d(\\mathbf{F}_p)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T_{3,a} = T_{1,a} \\times T_{1,b}</span></li>

      <li>if  <span class="math">2Z_2 = 2</span>  then [if: exception]</li>

      <li><span class="math">t_1 = Z_1 + Z_1</span>  {Q is in affine coordinates}</li>

      <li>else</li>

      <li><span class="math">t_1 = (2Z_2) \\times Z_1</span></li>

      <li><span class="math">t_2 = T_{3,a} \\times (2T_2)</span></li>

      <li><span class="math">T_{3,a} = t_2 \\times d</span></li>

      <li><span class="math">t_3 = t_1 - T_{3,a}</span></li>

      <li><span class="math">t_1 = t_1 + T_{3,a}</span></li>

    </ol>

    <p class="text-gray-300">curve [35]. But even when working on an Edwards curve with complete formulas, an implementation of the scalar multiplication could still be sped up by mapping to a different curve, while remaining with the complete formulas for all other operations. One could for example follow the approach suggested in [33], and use an isogeny to the twisted Edwards curve  <span class="math">\\mathcal{E}_{-1 / d - 1}:x^2 +y^2 = 1 - (1 / d + 1)x^2 y^2</span> ; or use the birational equivalence to  <span class="math">\\mathcal{E}: - x^{2} + y^{2} = 1 + dx^{2}y^{2}</span></p>

    <p class="text-gray-300">The situation for the prime order Weierstrass curves in this paper is more complicated. As pointed out by Bosma and Lenstra [18], the best that we can do for general elliptic curves is as follows: on input of two points  <span class="math">P_{1}</span>  and  <span class="math">P_{2}</span> , we must compute two candidate sums,  <span class="math">P_{3}</span>  and  <span class="math">P_{3}^{\\prime}</span> , for which we can only be guaranteed that at least one of them is a correct projective representation for  <span class="math">P_{1} + P_{2}</span> . In the case that precisely one of  <span class="math">P_{3}</span>  and  <span class="math">P_{3}^{\\prime}</span>  correctly corresponds to  <span class="math">P_{1} + P_{2}</span> , the other candidate has all of its coordinates as zero; although this makes it straightforward to write a constant-time routine for complete additions, it also means that computing complete additions in this way is much more costly than computing incomplete additions.</p>

    <p class="text-gray-300">For the sake of comparison, we present the simplified version of the complete formulas <span class="math">^{10}</span>  from [18], which are specialized to short Weierstrass curves of the form  <span class="math">E \\colon y^2 = x^3 + ax + b</span> . For two input points  <span class="math">P_1 = (X_1 \\colon Y_1 \\colon Z_1)</span>  and  <span class="math">P_2 = (X_2 \\colon Y_2 \\colon Z_2)</span>  in homogeneous projective space, the two candidate sums  <span class="math">P_3 = (X_3 \\colon Y_3 \\colon Z_3)</span>  and  <span class="math">P_3&#x27; = (X_3&#x27; \\colon Y_3&#x27; \\colon Z_3&#x27;)</span></p>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">are computed as</p>

    <p class="text-gray-300">|  X3=(X1Y2-X2Y1)(Y1Z2+Y2Z1)-  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (X1Z2-X2Z1)(a(X1Z2+X2Z1)+3bZ1Z2-Y1Y2);  |   |</p>

    <p class="text-gray-300">|  Y3=- (3X1X2+aZ1Z2)(X1Y2-X2Y1)+  |   |</p>

    <p class="text-gray-300">|  (Y1Z2-Y2Z1)(a(X1Z2+X2Z1)+3bZ1Z2-Y1Y2);  |   |</p>

    <p class="text-gray-300">|  Z3=(3X1X2+aZ1Z2)(X1Z2-X2Z1)-  |   |</p>

    <p class="text-gray-300">|  (Y1Z2+Y2Z1)(Y1Z2-Y2Z1);  |   |</p>

    <p class="text-gray-300">|  X'3=- (X1Y2+X2Y1)(a(X1Z2+X2Z1)+  |   |</p>

    <p class="text-gray-300">|  3bZ1Z2-Y1Y2)-(Y1Z2+Y2Z1)(3b(X1Z2+X2Z1)+  |   |</p>

    <p class="text-gray-300">|  a(X1X2-aZ1Z2));  |   |</p>

    <p class="text-gray-300">|  Y'3=Y12Y22+3aX12X22-2a2X1X2Z1Z2-(a3+9b2)Z1Z22+  |   |</p>

    <p class="text-gray-300">|  (X1Z2+X2Z1)(3b(3X1X2-aZ1Z2)-  |   |</p>

    <p class="text-gray-300">|  a2(X2Z1+X1Z2));  |   |</p>

    <p class="text-gray-300">|  Z'3=(3X1X2+aZ1Z2)(X1Y2+X2Y1)+  |   |</p>

    <p class="text-gray-300">|  (Y1Z2+Y2Z1)(Y1Y2+3bZ1Z2+a(X1Z2+X2Z1)).  |   |</p>

    <p class="text-gray-300">In the case of  <span class="math">a = -3</span>  short Weierstrass curves, like the prime order curves in this paper, we found that the computations in (1) require at most  <span class="math">^{11}22</span>  multiplications, 3 multiplications by  <span class="math">b</span> , and one multiplication by  <span class="math">b^2 - 3</span> . The adaptation of the formulas to points in Jacobian coordinates can be achieved in the obvious way at an additional cost of 6 multiplications and 3 squarings: preceding (1), we can transform from Jacobian coordinates to homogeneous coordinates by taking  <span class="math">X_i \\gets X_i \\cdot Z_i</span>  and then  <span class="math">Z_i \\gets Z_i^3</span>  for  <span class="math">i = 1, 2</span> ; and, following the correct choosing of  <span class="math">P_3 = (X_3 : Y_3 : Z_3)</span> , we can move back to Jacobian coordinates by taking  <span class="math">X_3 \\gets X_3 \\cdot Z_3</span>  and then  <span class="math">Y_3 \\gets Y_3 \\cdot Z_3^2</span> .</p>

    <p class="text-gray-300">Although the formulas in (1) are mathematically satisfactory, their computation costs around twice as much as an incomplete addition (see Table 5), which renders them far from satisfactory in cryptographic applications. On the other hand, the work-around we present in Algorithm 19 and Algorithm 18, while perhaps not as mathematically elegant, is equivalent for all practical purposes and incurs a much smaller overhead over the incomplete formulas. In particular, there are no additional multiplications or squarings (on top of those incurred during an incomplete addition) required when performing a complete addition via this masking approach.</p>

    <p class="text-gray-300">As briefly discussed in Section 4.1, the idea is to exploit the similarity between the sequences of operations computed in a doubling and an addition. On input of  <span class="math">P</span>  and  <span class="math">Q</span> , one would ordinarily compute the doubling  <span class="math">2P</span>  and the (non-unified) addition  <span class="math">P + Q</span>  and mask out the correct result at the end, depending on whether  <span class="math">P = Q</span> . However, the detection of  <span class="math">P = Q</span>  (or not) can be achieved much earlier in projective space using only a few operations that are common to both doublings and non-unified additions - see Line 17 (resp. Line 12) in Algorithm 19 (resp. Algorithm 18). After this detection, the required operation (doubling or addition) is achieved by masking the correct inputs and outputs through a sequence of subsequent computations, those which overlap in the explicit formulas for point doublings and additions. Of course, in the case that one or both of  <span class="math">P</span>  or  <span class="math">Q</span>  is  <span class="math">\\mathcal{O}</span> , or that  <span class="math">P = -Q</span> , these superfluous computations are still computed in constant-time such that the correct result is masked out in a cache-attack resistant manner.</p>

    <p class="text-gray-300">Algorithm 18 Complete (mixed) addition using masking and Jacobian/affine coordinates on prime-order Weierstrass curves  <span class="math">E_{b}</span> . Input:  <span class="math">P, Q \\in E_b(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1)</span>  is in Jacobian coordinates and  <span class="math">Q = (x_2, y_2)</span>  is in affine coordinates. Output:  <span class="math">R = P + Q \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates. Computations marked with  <span class="math">[\\star]</span>  are implemented in constant time using masking.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T[0] = \\mathcal{O}\\{T[i] = 21.\\hat{Z}_2 = Z_1 \\times t_2</span> <span class="math">(\\hat{X}_i, \\hat{Y}_i, \\hat{Z}_i)</span>  for  <span class="math">0 \\leq i &amp;lt; 4\\}</span></li>

      <li><span class="math">T[1] = Q</span>  [★]</li>

      <li><span class="math">t_2 = Z_1^2</span></li>

      <li><span class="math">t_3 = Z_1 \\times t_2</span></li>

      <li><span class="math">t_1 = x_2 \\times t_2</span></li>

      <li><span class="math">t_4 = y_2 \\times t_3</span></li>

      <li><span class="math">t_1 = t_1 - X_1</span></li>

      <li><span class="math">t_4 = t_4 - Y_1</span></li>

      <li>index = 3</li>

      <li>if  <span class="math">t_1 = 0</span>  then [★]</li>

      <li>index = 0</li>

      <li>if  <span class="math">t_4 = 0</span>  then</li>

      <li>if  <span class="math">P = \\mathcal{O}</span>  then index = 1</li>

      <li>mask = 0</li>

      <li>if index = 3 then</li>

      <li><span class="math">t_3 = X_1 + t_2</span></li>

      <li><span class="math">t_6 = X_1 - t_2</span></li>

      <li>if mask = 0 then  <span class="math">t_2 = Y_1</span>  else  <span class="math">t_2 = t_1</span>  [★]</li>

      <li><span class="math">t_5 = t_2^2</span></li>

      <li><span class="math">t_1 = X_1 \\times t_5</span></li>

    </ol>

    <p class="text-gray-300">Refer to Table 6.</p>

    <p class="text-gray-300">Refer to Table 7.</p>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Algorithm 19 Complete (projective) addition using masking and Jacobian coordinates on prime-order Weierstrass curves  <span class="math">E_{b}</span> .</p>

    <p class="text-gray-300">Input:  <span class="math">P, Q \\in E_b(\\mathbf{F}_p)</span>  such that  <span class="math">P = (X_1, Y_1, Z_1)</span>  and  <span class="math">Q = (X_2, Y_2, Z_2)</span>  are in Jacobian coordinates.</p>

    <p class="text-gray-300">Output:  <span class="math">R = P + Q \\in E_b(\\mathbf{F}_p)</span>  in Jacobian coordinates. Computations marked with  <span class="math">[\\star]</span>  are implemented in constant time using masking.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">T[0] = \\mathcal{O}</span> <span class="math">\\{T[i] = 25.</span> <span class="math">t_5 = t_2^2</span> <span class="math">(\\tilde{X}_i,\\tilde{Y}_i,\\tilde{Z}_i)</span>  for  <span class="math">0\\leq i &amp;lt;   5\\}</span></li>

      <li><span class="math">T[1] = Q</span>  27.  <span class="math">t_1 = t_5\\times t_7</span></li>

      <li><span class="math">T[4] = P</span>  28.  <span class="math">\\tilde{Z}_2 = Z_1\\times t_2</span></li>

      <li><span class="math">t_2 = Z_1^2</span>  29.  <span class="math">\\tilde{Z}_3 = Z_3\\times \\tilde{Z}_2</span></li>

      <li><span class="math">t_3 = Z_1\\times t_2</span>  30. if mask  <span class="math">\\neq 0</span>  then  <span class="math">t_3 = t_2</span></li>

      <li><span class="math">t_1 = X_2\\times t_2</span>  [\\*</li>

      <li><span class="math">t_4 = Y_2\\times t_3</span>  31. if mask  <span class="math">\\neq 0</span>  then  <span class="math">t_6 = t_5</span>  [\\]</li>

      <li><span class="math">t_3 = Z_2^2</span>  [\\]</li>

      <li><span class="math">t_5 = Z_2\\times t_3</span>  32.  <span class="math">t_2 = t_3\\times t_6</span></li>

      <li><span class="math">t_7 = X_1\\times t_3</span>  33.  <span class="math">t_3 = t_2 / 2</span></li>

      <li><span class="math">t_8 = Y_1\\times t_5</span>  34.  <span class="math">t_3 = t_2 + t_3</span></li>

      <li><span class="math">t_1 = t_1 - t_7</span>  35. if mask  <span class="math">\\neq 0</span>  then  <span class="math">t_3 = t_4</span></li>

      <li><span class="math">t_4 = t_4 - t_8</span>  [\\]</li>

      <li>index  <span class="math">= 3</span>  36.  <span class="math">t_4 = t_3^2</span></li>

      <li>if  <span class="math">t_1 = 0</span>  then [★] 37.  <span class="math">t_4 = t_4 - t_1</span></li>

      <li>index  <span class="math">= 0</span>  38.  <span class="math">\\tilde{X}_2 = t_4 - t_1</span> <span class="math">\\{R = \\mathcal{O}\\}</span>  39.  <span class="math">\\tilde{X}_3 = \\tilde{X}_2 - t_2</span></li>

      <li>if  <span class="math">t_4 = 0</span>  then 40. if mask  <span class="math">= 0</span>  then  <span class="math">t_4 =</span>  index  <span class="math">= 2</span> <span class="math">\\{R = 2P\\}</span> <span class="math">\\tilde{X}_2</span>  else  <span class="math">t_4 = \\tilde{X}_3</span>  [★]</li>

    </ol>

    <p class="text-gray-300">[★] 41.  <span class="math">t_1 = t_1 - t_4</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">P = \\mathcal{O}</span>  then index  <span class="math">= 1</span>  42.  <span class="math">t_4 = t_3\\times t_1</span> <span class="math">\\{R = Q\\}</span>  [★] 43. if mask  <span class="math">= 0</span>  then  <span class="math">t_1 = t_5</span></li>

      <li>if  <span class="math">Q = \\mathcal{O}</span>  then index  <span class="math">= 4</span>  else  <span class="math">t_1 = t_8</span>  [★]</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\{R = P\\}</span>  [★] 44. if mask  <span class="math">= 0</span>  then  <span class="math">t_2 = t_5</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>mask  <span class="math">= 0</span>  [★]</li>

      <li>if index  <span class="math">= 3</span>  then 45.  <span class="math">t_3 = t_1\\times t_2</span>  mask  <span class="math">= 1</span>  46.  <span class="math">\\tilde{Y}_2 = t_4 - t_3</span>  {case  <span class="math">P + Q</span>  , else any 47.  <span class="math">\\tilde{Y}_3 = \\tilde{Y}_2</span>  other case} [★] 48.  <span class="math">R = T[\\mathrm{index}]</span>  (=  <span class="math">(\\tilde{X}_{\\mathrm{index}},\\tilde{Y}_{\\mathrm{index}},\\tilde{Z}_{\\mathrm{index}})</span></li>

      <li><span class="math">t_3 = X_1 + t_2</span>  [★]</li>

      <li><span class="math">t_6 = X_1 - t_2</span></li>

      <li>if mask  <span class="math">= 0</span>  then  <span class="math">t_2 = Y_1</span>  49. return  <span class="math">R</span>  else  <span class="math">t_2 = t_1</span>  [★]</li>

    </ol>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">Algorithm 1 Variable-base scalar multiplication using the fixed-window method. Input: Scalar  <span class="math">k\\in [0,r\\rangle</span>  and point  <span class="math">P = (x,y)\\in E(\\mathbf{F}_p)</span>  , where  <span class="math">\\# E(\\mathbf{F}_p) = h.r</span>  with co-factor  <span class="math">h\\in \\mathbf{Z}^+</span>  and  <span class="math">r</span>  prime. Output:  <span class="math">kP</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">k = 0\\lor k\\geq r</span>  then return ("error: invalid scalar") [if: validation]</li>

      <li>Run point validation and compute  <span class="math">T = 4P</span>  (for  <span class="math">\\mathcal{E}_d</span>  ) using Algorithm 2 for  <span class="math">E_{b}</span>  and Algorithm 3 for  <span class="math">\\mathcal{E}_d</span>  . If "invalid" return ("error: invalid point"), else set  <span class="math">P = T</span>  (for  <span class="math">\\mathcal{E}_d</span>  ). [if: validation]</li>

    </ol>

    <p class="text-gray-300">Precomputation Stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix the window width  <span class="math">2\\leq w &amp;lt;   10\\in \\mathbf{Z}^{+}</span></li>

      <li>Compute  <span class="math">P[i] = (2i + 1)P</span>  for  <span class="math">0\\leq i &amp;lt;   2^{w - 2}</span>  using Algorithm 4 for  <span class="math">E_{b}</span>  and Algorithm 5 for  <span class="math">\\mathcal{E}_d</span>  . Recoding Stage:</li>

      <li>odd  <span class="math">= k</span>  mod 2</li>

      <li>if odd  <span class="math">= 0</span>  then  <span class="math">k = r - k</span>  [if: masked constant time]</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. Recode  <span class="math">k</span>  to  $(k_{t},\\dots ,k_{0}) = (s_{t}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\dots ,s_{0}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  using Algorithm 6, where  </span>t = \\lceil \\log_2(r) / (w - 1)\\rceil<span class="math">  and  </span>s_j$  are the signs of the recoded digits. Evaluation Stage:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for  <span class="math">i = (t - 1)</span>  to 1</li>

      <li>if DBLADD  <span class="math">=</span>  true  <span class="math">\\wedge w\\neq 2</span>  then [if: algorithm variant]</li>

      <li><span class="math">Q = 2^{(w - 2)}Q</span>  (Use Alg.10)</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12.  $Q = 2Q + s_iP[(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / 2]$  (Use Alg.11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>else</li>

      <li><span class="math">Q = 2^{(w - 1)}Q</span>  (Use Alg.10 for  <span class="math">E_{b}</span>  and Alg.14 for  <span class="math">\\mathcal{E}_d</span>  )</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">15.  $Q = Q + s_iP[(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / 2]<span class="math">  (Use Alg.12 for  </span>E_{b}<span class="math">  and Alg.15 for  </span>\\mathcal{E}_d$  )</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>end if</li>

      <li>end for</li>

      <li><span class="math">Q = 2^{(w - 1)}Q</span>  (Use Alg.10 for  <span class="math">E_{b}</span>  and Alg.14 for  <span class="math">\\mathcal{E}_d</span>  )</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19.  $Q = Q\\oplus s_0P[(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1) / 2]<span class="math">  (Use Alg.19 for  </span>E_{b}<span class="math">  and Alg.17 for  </span>\\mathcal{E}_d$  )</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if odd  <span class="math">= 0</span>  then  <span class="math">Q = -Q</span>  [if: masked constant time]</li>

      <li>Convert  <span class="math">Q</span>  to affine coordinates  <span class="math">(x,y)</span></li>

      <li>return  <span class="math">Q</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 2 Point validation for the Weierstrass curves  <span class="math">E_{b} / \\mathbf{F}_{p}:y^{2} = x^{3} - 3x + b</span>  in Table 1. Input: Point  <span class="math">P = (x_{1},y_{1})</span> Output: "Valid" or "invalid" point. 1. if  <span class="math">P = \\mathcal{O}</span>  then return ("invalid") [if: validation]</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">x_{1} \\notin [0,p - 1] \\lor y_{1} \\notin [0,p - 1]</span>  then return ("invalid") [if: validation]</li>

      <li>if  <span class="math">y_{1}^{2} \\neq x_{1}^{2} - 3x_{1} + b</span>  (mod  <span class="math">p</span> ) then return ("invalid") [if: validation]</li>

      <li>return ("valid").</li>

    </ol>

    <p class="text-gray-300">Algorithm 3 Combined point validation and torsion clearing for the twisted Edwards curves  <span class="math">\\mathcal{E}_d</span> :  <span class="math">-x^2 + y^2 = 1 + dx^2y^2</span>  in Table 2. Input: Point  <span class="math">P = (x_{1},y_{1})</span> Output: "Invalid", or "valid" and a point  <span class="math">T</span>  of prime order  <span class="math">r</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">x_{1} \\notin [0,p - 1] \\lor y_{1} \\notin [0,p - 1]</span>  then return ("invalid") [if: validation]</li>

      <li>if  <span class="math">-x_{1}^{2} + y_{1}^{2} \\neq 1 + dx_{1}^{2}y_{1}^{2}</span>  (mod  <span class="math">p</span> ) then return ("invalid") [if: validation]</li>

      <li>if  <span class="math">(x_{1},y_{1}) = (0,1)</span>  then return ("invalid") [if: validation]</li>

      <li>Compute  <span class="math">T = 4P</span></li>

      <li>if  <span class="math">T = \\mathcal{O}</span>  then return ("invalid") [if: validation]</li>

      <li>return ("valid") and  <span class="math">T</span> .</li>

    </ol>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Algorithm 4 Precomputation scheme for the Weierstrass curves  <span class="math">E_{b} / \\mathbf{F}_{p}:y^{2} = x^{3} - 3x + b</span>  in Table 1. Input: Point  <span class="math">P = (x_{1},y_{1})\\in E_{b}(\\mathbf{F}_{p})\\setminus \\{\\mathcal{O}\\}</span>  of prime order  <span class="math">r</span>  and window width  <span class="math">2\\leq w &amp;lt; 10</span> Output:  <span class="math">P[i] = (2i + 1)P</span>  for  <span class="math">0\\leq i &amp;lt;   2^{w - 2}</span>  , in Chudnovsky coordinates.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given  <span class="math">P = (x_{1},y_{1})</span>  , compute  <span class="math">Q = 2P</span>  in Jacobian coordinates  <span class="math">(Q = (\\mathbf{X}_2,\\mathbf{Y}_2,\\mathbf{Z}_2))</span>  and convert  <span class="math">P</span>  to Chudnovsky coordinates  <span class="math">(P = (X,Y,Z_1,Z_2,Z_3))</span>  such that the new  <span class="math">P</span>  and  <span class="math">Q</span>  have the same  <span class="math">Z</span>  -coordinate (read from left to right, top to bottom):  <span class="math">t_2 = 1,</span> <span class="math">t_1 = x_1^2,</span> <span class="math">t_1 = t_1 - t_2,</span> <span class="math">t_2 = t_1 / 2,</span> <span class="math">t_1 = t_1 + t_2,</span> <span class="math">Z_{2} = y_{1}^{2},</span> <span class="math">X = x_{1}\\cdot Z_{2},</span> <span class="math">Z_{3} = Z_{2}\\cdot y_{1},</span> <span class="math">t_2 = t_1^2,</span> <span class="math">t_2 = t_2 - X,</span> <span class="math">\\mathbf{X}_2 = t_2 - X,</span> <span class="math">\\mathbf{Z}_2 = y_1,</span> <span class="math">Z_{1} = y_{1},</span> <span class="math">Y = Z_2^2,</span> <span class="math">t_2 = X - X_2,</span> <span class="math">t_3 = t_1\\cdot t_2,</span> <span class="math">\\mathbf{Y}_2 = t_3 - Y.</span></li>

      <li><span class="math">P[0] = P</span></li>

      <li>for  <span class="math">i = 1</span>  to  <span class="math">2^{w - 2} - 1</span>  do</li>

      <li>Given  <span class="math">Q = (X_{1},Y_{1},Z)</span>  and  <span class="math">P[i - 1] = (X_{2},Y_{2},Z,Z^{2},Z^{3})</span>  compute  <span class="math">P[i] = Q + P[i - 1] = (X_{3},Y_{3},Z_{3,1},Z_{3,2},Z_{3,3})</span>  and update the representation of  <span class="math">Q = (\\mathbf{X},\\mathbf{Y},\\mathbf{Z})</span>  such that  <span class="math">\\mathbf{Z} = Z_{3,1}</span>  (read from left to right, top to bottom):  <span class="math">t_1 = X_2 - X_1,</span> <span class="math">Z_{3,1} = Z\\cdot t_1,</span> <span class="math">\\mathbf{Z} = Z_{3,1},</span> <span class="math">t_2 = t_1^2,</span> <span class="math">Z_{3,2} = Z_{3,1}^2,</span> <span class="math">t_3 = t_1\\cdot t_2,</span> <span class="math">\\mathbf{X} = X_1\\cdot t_2,</span> <span class="math">t_1 = Y_2 - Y_1,</span> <span class="math">X_{3} = t_{1}^{2},</span> <span class="math">Z_{3,3} = Z_{3}\\cdot Z_{3,2},</span> <span class="math">X_{3} = X_{3} - t_{3},</span> <span class="math">X_{3} = X_{3} - \\mathbf{X},</span> <span class="math">X_{3} = X_{3} - \\mathbf{X},</span> <span class="math">t_2 = \\mathbf{X} - X_3,</span> <span class="math">t_1 = t_1\\cdot t_2,</span> <span class="math">\\mathbf{Y} = Y_1\\cdot t_3,</span> <span class="math">Y_{3} = t_{1} - \\mathbf{Y}.</span></li>

      <li>return  <span class="math">P[i]</span> <span class="math">(= (2i + 1)P</span>  for  <span class="math">0\\leq i &amp;lt;   2^{w - 2})</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 5 Precomputation scheme for twisted Edwards curves  <span class="math">(\\mathcal{E}_d)</span> Input: Point  <span class="math">P = (x_{1},y_{1})\\in \\mathcal{E}_{d}(\\mathbf{F}_{p})</span>  of prime order  <span class="math">r</span>  and window width  <span class="math">w\\geq 2\\in \\mathbf{Z}^{+}</span> Output:  <span class="math">P[i] = (2i + 1)P</span>  , for  <span class="math">0\\leq i &amp;lt;   2^{w - 2}</span>  , in extended homogeneous coordinates  <span class="math">(X + Y,Y - X,2Z,2T)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given  <span class="math">P = (x_{1},y_{1})</span>  , compute  <span class="math">Q = 2P = (X_{2},Y_{2},Z_{2},T_{2})</span>  (where  <span class="math">Q</span>  is represented using  <span class="math">(X + Y,Y - X,Z,T))</span>  , and update  <span class="math">P = (\\mathbf{X},\\mathbf{Y},\\mathbf{Z},\\mathbf{T})</span>  in the representation  <span class="math">(X + Y,Y - X,2Z,2T)</span>  (read from left to right, top to bottom):  <span class="math">\\mathbf{X} = x_1^2</span> <span class="math">t_1 = y_1^2</span> <span class="math">t_2 = \\mathbf{X} + t_1</span> <span class="math">t_1 = t_1 - \\mathbf{X}</span> <span class="math">\\mathbf{Y} = x_{1}\\cdot y_{1}</span> <span class="math">t_3 = \\mathbf{Y} + \\mathbf{Y}</span> <span class="math">Y_{2} = t_{1}\\cdot t_{2}</span> <span class="math">T_{2} = t_{2}\\cdot t_{3}</span> <span class="math">t_2 = 2</span> <span class="math">t_2 = t_2 - t_1</span> <span class="math">Z_{2} = t1\\cdot t_{2}</span> <span class="math">t_1 = t2\\cdot t_3</span> <span class="math">\\mathbf{Z} = x_{1}</span> <span class="math">\\mathbf{T} = x_{1}\\cdot \\mathbf{Y}</span> <span class="math">X_{2} = t_{1} + Y_{2}</span> <span class="math">Y_{2} = Y_{2} - t_{1}</span> <span class="math">t_1 = \\mathbf{X} + \\mathbf{Y}</span> <span class="math">\\mathbf{Y} = \\mathbf{Y} - \\mathbf{X}</span> <span class="math">\\mathbf{X} = t_{1}</span> <span class="math">\\mathbf{Z} = \\mathbf{Z} + \\mathbf{Z}</span> <span class="math">\\mathbf{T} = \\mathbf{T} + \\mathbf{T}</span></li>

      <li><span class="math">P[0] = P</span></li>

      <li>for  <span class="math">i = 1</span>  to  <span class="math">2^{(w - 2)} - 1</span>  do</li>

      <li>Given  <span class="math">P[i - 1] = (X_2,Y_2,Z_2,T_2)</span>  (represented using  <span class="math">(X + Y,Y - X,2Z,2T)</span> ) and  <span class="math">Q = (X_{1},Y_{1},Z_{1},T_{1})</span>  (represented using  <span class="math">(X + Y,Y - X,Z,T)</span> ) compute  <span class="math">P[i] = Q + P[i - 1]</span> , where  <span class="math">P[i] = (X_3,Y_3,Z_3,T_3)</span>  is represented as  <span class="math">(X + Y,Y - X,2Z,2T)</span>  (read from left to right, top to bottom):  <span class="math">t_1 = T_2\\cdot Z_1</span> <span class="math">t_2 = T_1\\cdot Z_2</span> <span class="math">t_3 = t_2 - t_1</span> <span class="math">t_1 = t_1 + t_2</span> <span class="math">t_2 = t_1\\cdot t_3</span> <span class="math">T_{3} = t_{2} + t_{2}</span> <span class="math">t_2 = X_1\\cdot Y_2</span> <span class="math">X_{3} = Y_{1}\\cdot X_{2}</span> <span class="math">Y_{3} = t_{2} - X_{3}</span> <span class="math">t_2 = X_3 + t_2</span> <span class="math">X_{3} = Y_{3}\\cdot t_{1}</span> <span class="math">Z_{3} = Y_{3}\\cdot t_{2}</span> <span class="math">t_1 = t_3\\cdot t_2</span> <span class="math">Y_{3} = t_{1} - X_{3}</span> <span class="math">X_{3} = X_{3} + t_{1}</span> <span class="math">Z_{3} = Z_{3} + Z_{3}</span></li>

      <li>return  <span class="math">P[i]</span> <span class="math">(= (2i + 1)P</span>  for  <span class="math">0\\leq i &amp;lt;   2^{w - 2})</span></li>

    </ol>

    <p class="text-gray-300">Joppe W. Bos et al.</p>

    <p class="text-gray-300">Algorithm 9 Double-scalar multiplication using the width-  <span class="math">w</span>  NAF with interleaving. (If-statements are not marked because this algorithm is not assumed to be constant-time.)</p>

    <p class="text-gray-300">Input: Scalars  <span class="math">k_{1}</span>  and  <span class="math">k_{2} \\in [0, r)</span>  and points  <span class="math">P_{1}</span>  and  <span class="math">P_{2} \\in E(\\mathbf{F}_{p})</span> , where  <span class="math">\\# E = h.r</span>  with co-factor  <span class="math">h \\in \\mathbf{Z}^{+}</span>  and  <span class="math">r</span>  prime.</p>

    <p class="text-gray-300">Output:  <span class="math">k_{1}P_{1} + k_{2}P_{2}</span> .</p>

    <p class="text-gray-300">Offline computation:</p>

    <p class="text-gray-300">Precomputation stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run point validation over  <span class="math">P_{2}</span>  and compute  <span class="math">T = 4P_{2}</span>  (for  <span class="math">\\mathcal{E}_d</span> ) using Algorithm 2 for  <span class="math">E_{b}</span>  and Algorithm 3 for  <span class="math">\\mathcal{E}_d</span> . If "invalid" return ("error: invalid point"), else set  <span class="math">P_{2} = T</span>  (for  <span class="math">\\mathcal{E}_d</span> ).</li>

      <li>Fix the window width  <span class="math">w_{2} \\geq 2 \\in \\mathbf{Z}^{+}</span> .</li>

      <li>Compute  <span class="math">P_{2}[i] = (2i + 1)P_{2}</span>  for  <span class="math">0 \\leq i &amp;lt; 2^{w_{2} - 2}</span>  using Algorithm 4 for  <span class="math">E_{b}</span>  and Algorithm 5 for  <span class="math">\\mathcal{E}_d</span> .</li>

    </ol>

    <p class="text-gray-300">Online computation:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">(k_{1} = 0\\lor k_{1}\\geq r)\\lor (k_{2} = 0\\lor k_{2}\\geq r)</span>  then return ("error: invalid scalar")</li>

      <li>Run point validation over  <span class="math">P_{1}</span>  and compute  <span class="math">T = 4P_{1}</span>  (for  <span class="math">\\mathcal{E}_d</span> ) using Algorithm 2 for  <span class="math">E_{b}</span>  and Algorithm 3 for  <span class="math">\\mathcal{E}_d</span> . If "invalid" return ("error: invalid point"), else set  <span class="math">P_{1} = T</span>  (for  <span class="math">\\mathcal{E}_d</span> ).</li>

    </ol>

    <p class="text-gray-300">Precomputation Stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fix the window width  <span class="math">w_{1} \\geq 2 \\in \\mathbf{Z}^{+}</span> .</li>

      <li>Compute  <span class="math">P_{1}[i] = (2i + 1)P_{1}</span>  for  <span class="math">0 \\leq i &amp;lt; 2^{w_{i} - 2}</span>  using Algorithm 4 for  <span class="math">E_{b}</span>  and Algorithm 5 for  <span class="math">\\mathcal{E}_d</span> .</li>

    </ol>

    <p class="text-gray-300">Recoding Stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recode  <span class="math">k_{1}</span>  to  <span class="math">(k_{1,i-1}, k_{1,i-2}, \\ldots, k_{1,0})_{w\\mathrm{NAF}}</span>  using [34, Algorithm 3.35] and pad it with  <span class="math">\\lceil \\log_2(r) \\rceil - i + 1</span>  zeros to the left.</li>

      <li>Recode  <span class="math">k_{2}</span>  to  <span class="math">(k_{2,j-1}, k_{2,j-2}, \\ldots, k_{2,0})_{w\\mathrm{NAF}}</span>  using [34, Algorithm 3.35] and pad it with  <span class="math">\\lceil \\log_2(r) \\rceil - j + 1</span>  zeros to the left.</li>

    </ol>

    <p class="text-gray-300">Evaluation Stage:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for  <span class="math">i = \\lceil \\log_2(r) \\rceil</span>  to 0</li>

      <li>if DBLADD = true then</li>

      <li>if  <span class="math">k_{1,i} = 0</span>  then</li>

      <li><span class="math">Q = 2Q</span>  (Use Algorithm 10)</li>

      <li>else if  <span class="math">k_{1,i} &amp;gt; 0</span>  then</li>

      <li><span class="math">Q = 2Q + P_{1}[k_{1,i} / 2]</span>  (Use Algorithm 11)</li>

      <li>else if  <span class="math">k_{1,i} &amp;lt; 0</span>  then</li>

      <li><span class="math">Q = 2Q - P_{1}[(-k_{1,i}) / 2]</span>  (Use Algorithm 11)</li>

      <li>end if</li>

      <li>if  <span class="math">k_{2,i} &amp;gt; 0</span>  then</li>

      <li><span class="math">Q = Q + P_{2}[k_{2,i} / 2]</span>  (Use Algorithm 13)</li>

      <li>else if  <span class="math">k_{2,i} &amp;lt; 0</span>  then</li>

      <li><span class="math">Q = Q - P_{2}[(-k_{2,i}) / 2]</span>  (Use Algorithm 13)</li>

      <li>end if</li>

      <li>else</li>

      <li><span class="math">Q = 2Q</span>  (Use Algorithm 14)</li>

      <li>else if  <span class="math">k_{1,i} &amp;gt; 0</span>  then</li>

      <li><span class="math">Q = Q + P_{1}[k_{1,i} / 2]</span>  (Use Algorithm 15)</li>

      <li>else if  <span class="math">k_{1,i} &amp;lt; 0</span>  then</li>

      <li><span class="math">Q = Q - P_{1}[(-k_{1,i}) / 2]</span>  (Use Algorithm 15)</li>

      <li>end if</li>

      <li>if  <span class="math">k_{2,i} &amp;gt; 0</span>  then</li>

      <li><span class="math">Q = Q + P_{2}[k_{2,i} / 2]</span>  (Use Algorithm 16)</li>

      <li>else if  <span class="math">k_{2,i} &amp;lt; 0</span>  then</li>

      <li><span class="math">Q = Q - P_{2}[(-k_{2,i}) / 2]</span>  (Use Algorithm 16)</li>

      <li>end if</li>

      <li>end if</li>

      <li>end for</li>

      <li>Convert  <span class="math">Q</span>  to affine coordinates  <span class="math">(x,y)</span></li>

      <li>return  <span class="math">Q</span> .</li>

    </ol>

    <p class="text-gray-300">Selecting Elliptic Curves for Cryptography: An Efficiency and Security Analysis</p>

    <p class="text-gray-300">Table 6 The traces of Frobenius  <span class="math">t</span>  for the curves in Tables 1 and 2. Compute group orders as  <span class="math">\\# E(\\mathbf{F}_p) = p + 1 - t</span>  and  <span class="math">\\# E^{\\prime}(\\mathbf{F}_p) = p + 1 + t</span>  for  <span class="math">E\\in \\{E_b,\\mathcal{E}_d\\}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">curve Eb</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">trace</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x3AE8AEC191AF8B462EF3A1E5867A815</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x147E7415F25C8A3F905BE63B507207C1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x1BC37D8A15D9A39FDF54DFD6B8AE571F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x79B5C7D7C52D4C2054705367C3A6B219</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x456480EB358AEDAC85B1232C7583BE25D641B76B4D671145</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x5914E300B421DEB28C4CDE002717D32E9F54797FC144CFE3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x29E150E114A2977E412562C2B3C81D859FB27E0984F19D0B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x563507EB575EE952604F4BFCABE8550CE6D6803F4485BABD</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x9C757286D118AFD67F9B550F47B6719E20C2C66AF9B128C46C69D70E81670237</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x46EB93321EAF10CC8B854D62E19A8C272DD216A1CDDCFC0C5FF4DFF6790565D3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0xA4C35B046B187CE4B03DA712682F4239C4A974C99F832DBC31EAC0C6FBCCA86B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x724105C0A12627C65D2B01900AE91780572C19A95F06605E0FEFA08C4C462C81</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">curve Ed</td>

            <td class="px-3 py-2 border-b border-gray-700">trace</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x13AAD11411E6330DA649B44849C4E1154</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-254-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x51AB3E4DD0A7413C5430B004EE459CE4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-256-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x106556A94BD650E6C691EC643BB752C90</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-255-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x8C3961E84965F3454ED8B84BEF244F30</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0x2A4BE076C762D8C9825225944DFC2407E406C7167336DD94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-382-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0xB394157AB7C8FA209CFA7E8EDF87E5F659DFF2586830167C</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-384-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x4CA0BB84A976997697B17EE9C7182C6EB8A4A3823EF64630</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-383-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x3BBA3EC630981110CAA5E0D854D777E40050C4F9160DDE8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0xCCC0A98C8F32E3CBBF3E7EBB024842CB2099437935363F81733ADE04D1C927EC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-510-mont</td>

            <td class="px-3 py-2 border-b border-gray-700">0xA0C4BB860F4395023A482F564F6E7DFD280CF7DBA06996F4DE9F78C8324AB93C</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-512-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x1606BDFD840951119676E1EC2EDAAE83C8C56803CD1FFC1DAC61CB8D3D283F7A4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ed-511-mers</td>

            <td class="px-3 py-2 border-b border-gray-700">0x560F2F9F46F87459155B3C6E1CEDD9236AF63E504E83379AC20F45C1CBAF41DC</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 7 The cost of converting points when using the curves from Tables 1 and 2. This is used for point decompressing and converting between twisted Edwards and Montgomery (and vice versa). The cost is expressed in the number of exponentiations (exp), multiplications (mul), multiplication by constants (mulc) and squarings (squ). Let  <span class="math">E_A / \\mathbf{F}_p : v^2 = u^3 + Au^2 + u</span>  and  <span class="math">\\mathcal{E}_d / \\mathbf{F}_p : -x^2 + y^2 = 1 + dx^2y^2</span>  with  <span class="math">B = -(A + 2)</span>  a square in  <span class="math">\\mathbf{F}_p</span>  and  <span class="math">d = -(A - 2) / (A + 2)</span> . Let  <span class="math">(X : Y : Z)</span>  be the projective coordinates for  <span class="math">\\mathcal{E}</span> . We follow the approach described in [9] to decompress twisted Edwards points.</p>

    <p class="text-gray-300">|  Edwards to Montgomery  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(x,y) to (u)</td>

            <td class="px-3 py-2 border-b border-gray-700">u = (1 + y)(1 - y)p-2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 exp, 1 mul</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(y) to (u)</td>

            <td class="px-3 py-2 border-b border-gray-700">u = (1 + y)(1 - y)p-2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 exp, 1 mul</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(X:Y:Z) to (u)</td>

            <td class="px-3 py-2 border-b border-gray-700">u = (Z + Y)(Z - Y)p-2</td>

            <td class="px-3 py-2 border-b border-gray-700">1 exp, 1 mul</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Edwards to Edwards  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conversion</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">formula</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | b = dy2 + 1 |   |</p>

    <p class="text-gray-300">|   | x = ab(ab3)(p-3)/4 |   |</p>

    <p class="text-gray-300">|  Montgomery to Edwards  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conversion</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">formula</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(u) to (x,y)</td>

            <td class="px-3 py-2 border-b border-gray-700">x = u√B(u3 + Au2 + u)(3p-5)/4</td>

            <td class="px-3 py-2 border-b border-gray-700">2 exp, 2 mul, 1 mulc, 1 squ</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | y = (u - 1)(u + 1)p-2 |   |</p>

    <p class="text-gray-300">|  Weierstrass to Weierstrass  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">conversion</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">formula</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Selecting Elliptic Curves for Cryptography: An Efficiency an... (2014/130)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/130
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
