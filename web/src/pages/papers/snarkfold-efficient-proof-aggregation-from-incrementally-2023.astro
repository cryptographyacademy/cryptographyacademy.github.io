---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1946';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SnarkFold: Efficient Proof Aggregation from Incrementally Verifiable Computation and Applications';
const AUTHORS_HTML = 'Xun Liu, Shang Gao, Tianyu Zheng, Yu Guo, Bin Xiao';

const CONTENT = `    <p class="text-gray-300">SnarkFold: Efficient Proof Aggregation from Incrementally Verifiable Computation and Applications</p>

    <p class="text-gray-300">Xun Liu^{1}, Shang Gao^{1} , Tianyu Zheng^{1}, Yu Guo^{2}, and Bin Xiao^{1}</p>

    <p class="text-gray-300">^{1} Department of Computing, The Hong Kong Polytechnic University</p>

    <p class="text-gray-300">^{2} SECBIT Labs</p>

    <p class="text-gray-300">compxun.liu@connect.polyu.hk</p>

    <p class="text-gray-300">shanggao@polyu.edu.hk</p>

    <p class="text-gray-300">tian-yu.zheng@connect.polyu.hk</p>

    <p class="text-gray-300">yu.guo@secbit.io</p>

    <p class="text-gray-300">csbxiao@polyu.edu.hk</p>

    <p class="text-gray-300">Abstract. The succinct non-interactive argument of knowledge (SNARK) technique has been extensively utilized in blockchain systems to replace the costly on-chain computation with the verification of a succinct proof. However, most existing applications verify each proof independently, resulting in a heavy load on nodes and high transaction fees for users. Currently, the mainstream proof aggregation schemes are based on generalized inner product argument, which has a logarithmic proof size and verification cost. To improve the efficiency of verifying multiple proofs, we introduce SnarkFold, a novel SNARK-proof aggregation scheme with constant verification time and proof size. SnarkFold is derived from incrementally verifiable computation (IVC) and is optimized further through the folding scheme. By folding multiple instance-proof pairs, SnarkFold defers the expensive SNARK verification (e.g., elliptic curve pairing) to the final step. Additionally, we propose a generic technique to enhance the verifier’s efficiency by delegating instance aggregation tasks to the prover. The verifier only needs a simple preprocessing to check the validity of the delegation. We further introduce folding schemes for Groth16 and Plonk proofs. Experimental results demonstrate that SnarkFold offers significant advantages, with an aggregated Plonk proof size of just 0.5 KB and the verification time of only 4.5 ms for aggregating 4096 Plonk proofs.</p>

    <p class="text-gray-300">Keywords: Succinct Non-interactive Argument of Knowledge, Incrementally Verifiable Computation, Proof Aggregation.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The succinct non-interactive argument of knowledge (SNARK) is a crucial cryptographic technique that allows a prover to convince a verifier of the correctness</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Shang Gao is the corresponding author of this paper.</li>

    </ul>

    <p class="text-gray-300">Table 1: Complexity comparison of proof aggregations.  <span class="math">\\mathbb{G}_1</span>  indicates the scalar multiplication in the group  <span class="math">\\mathbb{G}_1</span> .  <span class="math">\\mathbb{Z}_p</span>  indicates the field operation.  <span class="math">\\mathsf{H}</span>  indicates hash operation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Veri.</td>

            <td class="px-3 py-2 border-b border-gray-700">Instance Agg.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TIPP [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkPack [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">aPlonk [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkFold (this)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) H (prep.) O(1) (online veri.)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">of a specific statement in a non-interactive way. This is achieved by the prover constructing a succinct proof that the verifier can efficiently verify. The zero-knowledge version of SNARK, zk-SNARK, further guarantees that the proofs reveal no additional information beyond the validity of the statement.</p>

    <p class="text-gray-300">In recent years, (zk-)SNARKs have gained great attention in real-world applications, leading to the development of many new constructions and implementations [17] [13] [24] [34] [6] [3] [28] [11] [35] [15]. For example, in zero-knowledge rollups (zk-Rollups), a layer-2 network must provide a SNARK proof to the underlying layer-1 blockchain to show the validity of off-chain transactions [31]. The more general version, zero-knowledge Ethereum virtual machine (zk-EVM), further employs SNARK to demonstrate the correct execution of smart contracts [25]. Additionally, zk-SNARK has been extensively used in private scenarios such as anonymous cryptocurrencies [26] [18]. They can enhance blockchain privacy by allowing users to prove the validity of a transaction without disclosing sensitive information such as account address and account balance.</p>

    <p class="text-gray-300">Although (zk-)SNARKs are promising for enhancing scalability and privacy, SNARK-based applications pose significant challenges for both the prover and the verifier, as verifying individual proofs can be time-consuming, thereby reducing the system's throughput. This issue is more pronounced in blockchain systems like Ethereum [33], where users (provers) are required to pay transaction fees to the blockchain miners (verifiers) based on the computational and storage resource usage of operations (the cost of proof verification). For instance, in Sept. 2024, a deposit operation in TornadoCash (a smart contract for anonymous transactions on Ethereum) required nearly 40 USD of transaction fees.</p>

    <p class="text-gray-300">Proof aggregation. A SNARK-proof aggregation scheme (hereafter referred to as proof aggregation) can be utilized to mitigate these challenges. Informally, the aggregation prover compacts  <span class="math">n</span>  SNARK proofs  <span class="math">(\\pi_i)_{i=1}^n</span>  into a single aggregated proof  <span class="math">\\pi^<em></span>  and generates an aggregation proof  <span class="math">\\pi_{\\mathsf{AGG}}</span>  to show the validity the aggregation process. The aggregation verifier computes an aggregated instance (i.e., the public input)  <span class="math">u^</em></span>  based on the corresponding instances  <span class="math">(u_i)_{i=1}^n</span> . The validity of  <span class="math">\\pi^*</span>  and  <span class="math">\\pi_{\\mathsf{AGG}}</span>  implies the validity of all individual proofs. The aggregation time (proving time), verification time, and proof size are important metrics for</p>

    <p class="text-gray-300">evaluating a proof aggregation scheme. Normally, we require the verification of <span class="math">\\pi^{<em>}</span> and <span class="math">\\pi_{\\textsf{AGG}}</span> to be much simpler than checking <span class="math">(\\pi_{i})_{i=1}^{n}</span> individually. Proof aggregation schemes have been applied in many applications, such as Zcash </em>[18]<em>, and Filecoin </em>[23]<em>. Currently, the mainstream of proof aggregation schemes is derived from generalized inner product argument (GIPA) </em>[10]<em> </em>[14]<em>, which transforms the verification of <span class="math">n</span> SNARK proofs into an inner product form. These schemes further employ Bulletproofs-like compression </em>[6]<em> and a KZG commitment </em>[19]* to reduce the proof size and verification cost to <span class="math">O(\\log n)</span>. However, the verification cost remains substantial for real-world applications. Additionally, these GIPA-based schemes require a trusted setup.</p>

    <p class="text-gray-300">Motivation. One major objective of this paper is to reduce the proof size and the verification cost of proof aggregation. To achieve this, we resort to a cryptographic primitive known as the incrementally verifiable computation (IVC) <em>[32]</em>, which provides an efficient framework to generate a proof for a “long-repeated” computation. IVC is a verification-friendly scheme as the verifier only needs to validate the proof of the final step in the incremental computation, thereby achieving constant verification time and proof size. Moreover, it does not require a trusted setup. These inspire us to incorporate IVC in proof aggregation, regarding the aggregation of each proof as a repeated computation in IVC.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We summarize the contributions of our paper as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A novel proof aggregation scheme. We propose SnarkFold, the first proof aggregation scheme based on IVC. Additionally, we introduce a general two-folding IVC structure for SNARK proof aggregation, which can completely remove the complex SNARK verification logic from the recursive circuit. Compared with existing GIPA-based approaches, SnarkFold has notable advantages that achieve constant-size aggregated proof and constant verification time without the trusted setup (see Table 1).</li>

      <li>Instance delegation. In existing schemes, the verifier must aggregate instances <span class="math">(u_{i})_{i=1}^{n}</span> after receiving <span class="math">\\pi_{\\textsf{AGG}}</span> and <span class="math">\\pi^{*}</span> by itself, which may lead to an inefficient verifier. We propose a generic instance delegation technique, which allows the verifier to delegate the instance aggregation of all kinds of SNARKs to the prover with a simple preprocessing. By doing so, the verifier can complete the verification at a small cost.</li>

      <li>Folding schemes for Groth16 and Plonk proofs. To demonstrate the application of SnarkFold, we provide two detailed proof aggregation constructions for Groth16 <em>[17]</em> and Plonk <em>[13]</em>, respectively. For Groth16, we introduce a new “relaxed Groth16 proof relation” and further improve the prover’s efficiency with some variants. For Plonk, we present two constructions: one transforms a Plonk proof into a linear relation with a larger recursive circuit, and the other transforms into a quadratic relation but with a smaller circuit for a more efficient prover.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Experimental results. We conduct a performance comparison of SnarkFold and other state-of-the-art aggregation schemes. SnarkFold has notable advantages in terms of proof size and verification time. Our proof size for aggregating Plonk proofs remains constant (0.5 KB for the linear version and 1.74 KB for the quadratic version) while aPlonk increases logarithmically with the number of proofs (13 KB for aggregating 4096 proofs). In terms of the verification time, SnarkFold’s verifier only takes 4.5 ms for aggregating 4096 proofs, which outperforms the 38 ms of aPlonk.</li>

    </ul>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.2 Technique Overview</h3>

    <p class="text-gray-300">In this section, we briefly provide some core techniques included in SnarkFold.</p>

    <p class="text-gray-300">Lightweight verifier from IVC. The verification cost in proof aggregation is crucial for blockchain applications. However, the existing solutions’ verification overhead is substantial. For example, in GIPA-based schemes <em>[10]</em> <em>[14]</em> <em>[1]</em>, the verifier needs to perform <span class="math">O(\\log n)</span> <span class="math">\\mathbb{G}_{T}</span> (the pairing group of elliptic curves) operations to aggregate <span class="math">n</span> Groth16 proofs. Since elements in <span class="math">\\mathbb{G}_{T}</span> are 12 times larger and operations are 5 times slower than those in <span class="math">\\mathbb{G}_{1}</span> (the elliptic curve group), blockchain users face high transaction fees for verifying the aggregation process, which limits its applications in real-world scenarios. Unfortunately, there is no solution to reduce the costly <span class="math">\\mathbb{G}_{T}</span> operations in GIPA-based Groth16 aggregation. To ease the verifier’s cost, we construct proof aggregation system based on IVC. The IVC verifier maintains a constant cost because it only needs to check the IVC proof of the final step. For example, at each step <span class="math">i</span>, a straightforward design is to view the verification of each SNARK proof <span class="math">\\mathsf{SNARK.V}(u_{i},\\pi_{i})</span> as a repeated computation. The correctness of the IVC proof <span class="math">\\Pi_{i}</span> demonstrates the validity of all SNARK proofs for the first <span class="math">i</span> steps. Therefore, suppose we have <span class="math">n</span> proofs that need to be aggregated; the prover performs <span class="math">n</span> repeated computations to generate the final IVC proof <span class="math">\\Pi_{n}</span>. The verifier only needs to check <span class="math">\\Pi_{n}</span> to confirm the validity of all <span class="math">n</span> SNARK proofs. The detailed descriptions are provided in Section 3.1 and the formal constructions are provided in Figure 3.</p>

    <p class="text-gray-300">Instance delegation with preprocessing. In proof aggregation scenarios, the aggregation verifier conducts three key operations: ❶ receives an aggregation proof <span class="math">\\pi_{\\mathsf{AGG}}</span> and <span class="math">\\pi^{<em>}</span> from the prover, ❷ computes an aggregated instance <span class="math">u^{</em>}</span> based on <span class="math">u_{1},...,u_{n}</span>, and ❸ verifies the validity of <span class="math">\\pi_{\\mathsf{AGG}}</span> and <span class="math">\\pi^{<em>}</span>. In existing schemes, these steps are sequential, i.e., the verifier cannot precompute <span class="math">u^{</em>}</span> before receiving <span class="math">\\pi_{\\mathsf{AGG}}</span> and <span class="math">\\pi^{<em>}</span> from the prover. For example, in a Groth16 proof aggregation scheme proposed by Bünz et al. </em>[10]<em>, the verifier computes <span class="math">u^{</em>}</span> using some commitments provided in <span class="math">\\pi_{\\mathsf{AGG}}</span>, which involves <span class="math">O(n)</span> scalar-exponentiation in <span class="math">\\mathbb{G}_{1}</span>. Similarly, SnarkPack’s verifier also relies on <span class="math">\\pi_{\\mathsf{AGG}}</span> to aggregate instances with <span class="math">O(n)</span> <span class="math">\\mathbb{Z}_{p}</span> operations <em>[14]</em>. This leaves us a space for reducing the verifier’s cost by further <em>delegating</em> the computation of <span class="math">u^{<em>}</span> to the prover. However, directly accepting an aggregated instance <span class="math">u^{</em>}</span> from the prover incurs some security issues, even when the aggregation is done correctly. For instance, a malicious prover can replace <span class="math">(u_{i},\\pi_{i})</span> with a valid trivial instance-proof pair <span class="math">(u^{\\prime}_{i},\\pi^{\\prime}_{i})</span>. Thus, the verifier</p>

    <p class="text-gray-300">needs to ensure that <span class="math">u^{<em>}</span> is aggregated using the </em>expected<em> instances. To achieve this, we adopt a generic preprocessing process to allow the verifier to efficiently precompute a </em>binding claim<em> using all <span class="math">u_{i}</span> locally with <span class="math">O(n)</span> hash operations, which is much more efficient than the <span class="math">O(n)</span> <span class="math">\\mathbb{G}_{1}</span> operations required by Bünz’s scheme </em>[10]<em>. Specifically, performing 4096 <span class="math">\\mathbb{G}_{1}</span> operations takes 100 ms, while the cost of 4096 hash operations is less than 5 ms. Note that our preprocessing process is applicable for all kinds of SNARKs and can be independently completed by the verifier in advance without relying on the <span class="math">\\pi_{\\sf AGG}</span> and <span class="math">\\pi^{</em>}</span> from the prover. Meanwhile, the prover is required to integrate the precomputation logic into the recursive circuit, outputting the binding claim at the final step as a part of <span class="math">\\pi_{\\sf AGG}</span>. By comparing the binding claim from the prover with the local one, the verifier can efficiently ensure <span class="math">u^{<em>}</span> is aggregated from those expected <span class="math">u_{i}</span>’s. We refer to this constant-cost comparison and the process of checking <span class="math">\\pi_{\\sf AGG}</span> and <span class="math">\\pi^{</em>}</span> as <em>online verification</em>. The detailed descriptions are provided in Section 3.1.</p>

    <p class="text-gray-300">Lightweight prover from the folding scheme. We further enhance the efficiency of the aggregation prover when using IVC for proof aggregation. In the straightforward design discussed in “lightweight verifier from IVC”, at step <span class="math">i</span>, the prover inputs a new SNARK instance-proof pair <span class="math">(u_{i},\\pi_{i})</span> and the previous IVC proof <span class="math">\\Pi_{i-1}</span>. The recursive circuit is required to show the validity of both the IVC proof <span class="math">\\Pi_{i-1}</span> and the SNARK proof <span class="math">\\pi_{i}</span>. Then, the prover generates a new IVC proof <span class="math">\\Pi_{i}</span> and feeds it into the next recursion step. However, there are certain limitations in the straightforward design since integrating complex verification algorithms such as elliptic curve pairing into recursive circuits incurs a significant cost. For instance, a single pairing operation requires up to 25 million gates, and the circuit compilation time for a single pairing operation can take up to 4.2 hours <em>[30]</em>. Recently, IVC has been developed from the folding schemes <em>[9]</em> <em>[8]</em> <em>[22]</em> <em>[21]</em> <em>[7]</em> <em>[12]</em> <em>[36]</em> <em>[20]</em> for a simpler recursion, which moves the verification of the previous step <span class="math">\\Pi_{i-1}</span> from the recursive circuit (replacing it with folding <em>relaxed R1CS</em> instances in Nova <em>[22]</em>). Unfortunately, the circuit still requires verifying the current SNARK proof <span class="math">\\pi_{i}</span>, which remains to be a large overhead. To improve the prover’s efficiency, we propose a novel construction with <em>two</em> folding operations in the recursive circuit: one <em>algebraic instance</em> for folding SNARK proofs and one <em>circuit instance</em> for folding relaxed R1CS instances. In other words, we regard “folding each proof” as repeated computation (actually, we only fold each instance in the recursive circuit) rather than “verifying each proof”. This can completely remove the pairing operations from the circuit. The detailed descriptions of the recursive circuit are provided in Section 3.2.</p>

    <p class="text-gray-300">Folding schemes for Groth16 proofs. To implement our proof aggregation architecture, we require a folding scheme for the SNARK proof. We first consider the Groth16 proof, which consists of three group elements <span class="math">\\pi_{\\sf Gro}=(A,B,C)</span>, with <span class="math">A,C\\in\\mathbb{G}_{1}</span> and <span class="math">B\\in\\mathbb{G}_{2}</span>. A straightforward way to obtain a folded proof <span class="math">(A^{<em>},B^{</em>},C^{<em>})</span> is to use a random combination between two proofs <span class="math">(A_{1},B_{1},C_{1})</span> and <span class="math">(A_{2},B_{2},C_{2})</span>, such as <span class="math">A^{</em>}=A_{1}\\cdot(A_{2})^{r}</span>. However, the folded proof can not pass the verifier’s pairing check due to the cross-terms generated by the random combination. To solve this, we propose a “relaxed Groth16 proof relation” by</p>

    <p class="text-gray-300">introducing two additional factors to absorb the cross terms generated by folding, and further enhance the prover’s efficiency with some variants. The detailed descriptions are provided in Section 4.1.</p>

    <p class="text-gray-300">Folding schemes for Plonk proofs. Unlike Groth16, Plonk is built from polynomial interactive oracle proofs (PIOPs), which require multiple rounds of interaction. The corresponding non-interactive version requires Fiat-Shamir transformations, which must be verified in the recursive circuit since they are not homomorphic. To address this problem, we introduce a preprocessing step in the recursive circuit that performs some simple hash checks and transforms the Plonk proof into a folding-friendly form. Note that all inputs of the preprocessing should be regarded as a part of the instance of the new relation, as the folding verifier also needs to run the preprocessing to ensure its correct execution. Specifically, we outline two methods: the first preprocesses a Plonk proof into a linear relation, supporting multi-folding without error terms but resulting in a larger recursive circuit due to the preprocessing process (similar to <em>[9]</em>); the second employs a simpler preprocessing process (i.e., a smaller recursive circuit) to transform a Plonk proof into a quadratic relation, but only supports two-folding. The details are provided in Section 4.2.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <p class="text-gray-300">Proof aggregation. Some work focuses on designing cryptography accumulators for aggregating specific proofs, such as (non-)membership proofs. Srinivasan et al. <em>[29]</em> propose a zero-knowledge (non-)membership proof aggregation in the bilinear pairing group settings. However, it is not suitable for aggregating general-purpose SNARK proofs such as Groth16 and Plonk. Bünz et al. <em>[10]</em> adopt GIPA for Groth16 proof aggregation. This approach converts the verification of <span class="math">n</span> individual Groth16 proofs into the verification of a generalized inner product argument, which can utilize Bulletproofs folding to reduce the proof size to a logarithmic scale. Furthermore, they introduce an inner pairing product (TIPP) relation to regard the compressed argument as a polynomial and utilize the KZG commitment to reduce the verification cost further. Bünz et al.’s scheme requires the verifier to conduct <span class="math">O(n)</span> field operations and <span class="math">O(\\log n)</span> cryptographic operations. SnarkPack <em>[14]</em>, an optimization of Bünz et al.’s scheme, is designed to aggregate Groth16 proofs and reuses the public parameters from the trusted setup. Both Bünz et al.’s scheme and SnarkPack achieve <span class="math">O(\\log n)</span> proof size. aPlonk <em>[1]</em> extends the techniques of SnarkPack to Plonk aggregation with a logarithmic proof size and verification time. Other approach for Groth16 proof aggregation rely on recursive composition. Bowe et al. <em>[5]</em> construct an additional SNARK for <span class="math">n</span> copies of the Groth16 verifier circuit. However, this scheme integrates pairing into the circuit and incurs a significant cost. For instance, calculating a pairing on the BLS12-377 curve requires approximately 15,000 constraints <em>[10]</em>.</p>

    <p class="text-gray-300">Folding scheme. Traditionally, recursive SNARK required embedding a SNARK verifier in the circuit and implementing a full verification logic at every step,</p>

    <p class="text-gray-300">which introduces a huge overhead. The folding scheme is an advanced technique for constructing efficient recursive SNARKs. Several folding protocols, such as Nova <em>[22]</em>, Kilonova <em>[36]</em>, and others, have been proposed recently. The folding scheme allows multiple instances to be folded into a single one. The validity of the folded instance implies the correctness of all instances. This eliminates the need for costly verification from the recursive circuit: the recursive circuit simply folds multiple instances into a folded “running instance” and outputs a “circuit instance” to demonstrate that the recursion function and folding are executed correctly. By verifying the correctness of the running instance and the circuit instance in the final step, the verifier can ensure the accuracy of all iterations.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">This work considers the security parameter as <span class="math">\\lambda</span>. <span class="math">\\mathsf{negl}(\\lambda)</span> denotes a negligible function in <span class="math">\\lambda</span>. Let <span class="math">\\mathbb{Z}_{p}</span> denote the prime field for a large prime <span class="math">p</span>, and <span class="math">\\mathbb{Z}_{p}^{&lt;d}[X]</span> (or <span class="math">\\mathbb{Z}_{p}^{d}[X]</span>) denote the set of univariate polynomials over <span class="math">\\mathbb{Z}_{p}</span> with a degree smaller than (or equals to) <span class="math">d</span>. We use <span class="math">r\\leftrightarrows\\mathbb{Z}_{p}</span> to denote sampling <span class="math">r</span> from <span class="math">\\mathbb{Z}_{p}</span> uniformly at random and <span class="math">x\\leftarrow a</span> to denote variable assignment of <span class="math">a</span> to <span class="math">x</span>. For simplicity, <span class="math">(a_{1},...,a_{n})</span> is denoted as <span class="math">(a_{i})_{i=1}^{n}</span>.</p>

    <p class="text-gray-300">Relations. For a nondeterministic polynomial time (<span class="math">\\mathsf{NP}</span>) relation <span class="math">\\mathcal{R}</span>, we define it over <em>public parameters</em> <span class="math">\\mathsf{pp}</span> (e.g., the groups and fields), <em>structure</em> <span class="math">\\mathsf{s}</span> (e.g., R1CS coefficient matrices), <em>instance</em> <span class="math">u</span> (i.e., the public inputs), and <em>witness</em> <span class="math">w</span> (i.e., the secret) tuples, <span class="math">(\\mathsf{pp},\\mathsf{s},u,w)\\in\\mathcal{R}</span>.</p>

    <p class="text-gray-300">Bilinear groups. Let <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},p,e)</span> be a type II bilinear group of prime order <span class="math">p</span> where <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is the bilinear map. Let <span class="math">g\\in\\mathbb{G}_{1}</span> and <span class="math">h\\in\\mathbb{G}_{2}</span> be the generators of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> respectively. We define group elements <span class="math">[x]_{1}</span> as <span class="math">g^{x}\\in\\mathbb{G}_{1}</span>, <span class="math">[x]_{2}</span> as <span class="math">h^{x}\\in\\mathbb{G}_{2}</span>, and <span class="math">[x]_{T}</span> as <span class="math">e(g,h)^{x}\\in\\mathbb{G}_{T}</span>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 (zk-)SNARK and Proof Aggregation</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a <span class="math">\\mathsf{NP}</span> relation. A SNARK is described by four algorithms (<span class="math">\\mathsf{SNARK.G}</span> for public parameter generator, <span class="math">\\mathsf{SNARK.K}</span> for key generator, <span class="math">\\mathsf{SNARK.P}</span> for prover, <span class="math">\\mathsf{SNARK.V}</span> for verifier), that work in a non-interactive way:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{SNARK.G}(1^{\\lambda})</span>: On input security parameter <span class="math">\\lambda</span>, sample public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathsf{SNARK.K}(\\mathsf{pp},\\mathsf{s})</span>: Taking the public parameters <span class="math">\\mathsf{pp}</span> and a structure <span class="math">\\mathsf{s}</span>, generate the prover’s proving key <span class="math">\\mathsf{pk}</span> and the verifier’s verification key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\mathsf{SNARK.P}(\\mathsf{pk},u,w)</span>: Given an instance-witness pair <span class="math">(u,w)</span>, output a succinct proof <span class="math">\\pi</span> with <span class="math">\\mathsf{pk}</span> proving that <span class="math">(\\mathsf{pp},\\mathsf{s},u,w)\\in\\mathcal{R}</span>.</li>

      <li><span class="math">0/1\\leftarrow\\mathsf{SNARK.V}(\\mathsf{vk},u,\\pi)</span>: Given an instance <span class="math">u</span> and the corresponding proof <span class="math">\\pi</span>, output either <span class="math">1</span> by accepting the proof or <span class="math">0</span> by rejecting it.</li>

    </ul>

    <p class="text-gray-300">A SNARK satisfies completeness, knowledge soundness, and succinctness properties. Zk-SNARK is a variant of SNARK with zero-knowledge property: the proof <span class="math">\\pi</span> reveals nothing about <span class="math">w</span> (formally defined in the Appendix A.1).</p>

    <p class="text-gray-300">Given a SNARK system and <span class="math">n</span> proofs <span class="math">\\pi_1, \\ldots, \\pi_n</span>, we call AGG a proof aggregation scheme, which includes four algorithms (AGG.G, AGG.K, AGG.P, AGG.V):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{AGG.G}(1^{\\lambda})</span>: On input of the security parameter <span class="math">\\lambda</span>, sample public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathsf{AGG.K}(\\mathsf{pp})</span>: Taking the public parameters <span class="math">\\mathsf{pp}</span>, generate the prover's proving key <span class="math">\\mathsf{pk}</span> and the verifier's verification key <span class="math">\\mathsf{vk}</span> for the aggregation scheme.</li>

      <li><span class="math">(\\pi^{<em>}, \\pi_{\\mathsf{AGG}}) \\gets \\mathsf{AGG.P}(\\mathsf{pk}, (u_i, \\pi_i)_{i=1}^n)</span>: Given <span class="math">n</span> instance-proof pairs <span class="math">(u_i, \\pi_i)_{i=1}^n</span>, output an aggregated proof <span class="math">\\pi^{</em>}</span> and an aggregation proof <span class="math">\\pi_{\\mathsf{AGG}}</span> that shows the correctness of the aggregation process.</li>

      <li><span class="math">0/1 \\gets \\mathsf{AGG.V}(\\mathsf{vk}, n, (u_i)_{i=1}^n, \\pi^<em>, \\pi_{\\mathsf{AGG}})</span>: Given <span class="math">n</span> instances <span class="math">(u_i)_{i=1}^n</span>, an aggregated proof <span class="math">\\pi^</em></span> and an aggregation proof <span class="math">\\pi_{\\mathsf{AGG}}</span>, output either 1 by accepting the aggregation or 0 by rejecting.</li>

    </ul>

    <p class="text-gray-300">A proof aggregation scheme satisfies perfect completeness and knowledge soundness, which are formally defined in Appendix A.2.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.3 IVC and Folding Scheme</h2>

    <p class="text-gray-300">IVC allows efficient verification on repeated computation of <span class="math">F</span>, i.e., <span class="math">F(z_{i-1}, \\omega_{i-1}) = z_i</span> at step <span class="math">i</span>, where <span class="math">\\omega_{i-1}</span> is an auxiliary input and <span class="math">z_{i-1}</span> is the output in step <span class="math">i-1</span>. IVC is constructed by a tuple of PPT algorithms (IVC.G, IVC.K, IVC.P, IVC.V) with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{IVC.G}(1^{\\lambda})</span>: Given a security parameter <span class="math">\\lambda</span>, sample public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathsf{IVC.K}(\\mathsf{pp}, F)</span>: Given the public parameter <span class="math">\\mathsf{pp}</span> and the function <span class="math">F</span>, generate a proving key <span class="math">\\mathsf{pk}</span> and a verification key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\Pi_i \\gets \\mathsf{IVC.P}(\\mathsf{pk}, i, z_0, z_i, z_{i-1}, \\omega_{i-1}, \\Pi_{i-1})</span>: Taking a counter of current step <span class="math">i</span>, an initial input <span class="math">z_0</span>, two claimed outputs of the previous and current steps <span class="math">z_{i-1}</span> and <span class="math">z_i</span>, an auxiliary input <span class="math">\\omega_{i-1}</span>, and a proof <span class="math">\\Pi_{i-1}</span> attesting to the correctness of <span class="math">z_{i-1}</span>, output a proof <span class="math">\\Pi_i</span> for <span class="math">z_i = F(z_{i-1}, \\omega_{i-1})</span> with <span class="math">\\mathsf{pk}</span>.</li>

      <li><span class="math">0/1 \\gets \\mathsf{IVC.V}(\\mathsf{vk}, i, z_0, z_i, \\Pi_i)</span>: On the input of a counter of current step <span class="math">i</span>, an initial input <span class="math">z_0</span>, a claimed output of the <span class="math">i</span>-th iteration <span class="math">z_i</span>, and a proof <span class="math">\\Pi_i</span> attesting to <span class="math">z_i</span>, output 1 if <span class="math">\\Pi_i</span> is a valid proof and 0 otherwise with <span class="math">\\mathsf{vk}</span>.</li>

    </ul>

    <p class="text-gray-300">An IVC scheme satisfies perfect completeness, knowledge soundness, and succinctness, which are formally defined in Appendix A.3.</p>

    <p class="text-gray-300">One approach to achieve IVC is from a folding scheme that allows the prover and verifier to transform the task of verifying two (or more) instances of relation <span class="math">\\mathcal{R}</span> into the task of verifying a single instance in <span class="math">\\mathcal{R}</span>. The folding scheme consists of four algorithms (Fold.G, Fold.K, Fold.P, Fold.V) with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{Fold.G}(1^{\\lambda})</span>: Given a security parameter <span class="math">\\lambda</span>, sample public parameters <span class="math">\\mathsf{pp}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathsf{Fold}.\\mathsf{K}(\\mathsf{pp},\\mathsf{s})</span>: Given the public input <span class="math">\\mathsf{pp}</span> and a common structure <span class="math">\\mathsf{s}</span> between instances to be folded, output a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">(u, w) \\gets \\text{Fold.P}(\\mathsf{pk}, (u_1, w_1), (u_2, w_2))</span>: Given two instance-witness pairs <span class="math">(u_1, w_1)</span> and <span class="math">(u_2, w_2)</span>, generate a new folded instance-witness pair <span class="math">(u, w)</span> of the same size.</li>

      <li><span class="math">u \\gets \\text{Fold.V}(\\mathsf{vk}, u_1, u_2)</span>: Given the instance <span class="math">u_1</span> and <span class="math">u_2</span>, output a new folded instance <span class="math">u</span>.</li>

    </ul>

    <p class="text-gray-300">The above algorithms can also be generalized to multiple folding (e.g., <span class="math">(\\mathsf{u},\\mathsf{w})\\gets \\mathsf{Fold.P}(\\mathsf{pk},(\\mathsf{u_i},\\mathsf{w_i})_{i = 1}^n)</span>). A folding scheme satisfies perfect completeness and knowledge soundness, which are formally defined in Appendix A.4. Given that our application is proof aggregation, where the instances are derived from zk-SNARK proofs, we do not require the folding schemes to have a zero-knowledge property.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.4 Groth16 Background</h2>

    <p class="text-gray-300">Groth16 is a pairing-based efficient zkSNARK [17]. We briefly present the algorithms of Groth16 (the details of each parameter are shown in Appendix B.1).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{Groth16.G}(1^{\\lambda})</span>: Based on <span class="math">\\lambda</span>, sample a type III bilinear group <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e)</span> with <span class="math">g \\in \\mathbb{G}_1</span> and <span class="math">h \\in \\mathbb{G}_2</span> as generators. Output <span class="math">\\mathsf{pp} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e, g, h)</span>.</li>

      <li><span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathsf{Groth16.K}(\\mathsf{pp},\\mathsf{s})</span>: Generate a common reference string crs which contains the necessary group elements for the prover and the verifier. Output <span class="math">\\mathsf{pk} = \\mathsf{crs}</span> and <span class="math">\\mathsf{vk} = \\mathsf{crs}</span>.</li>

      <li><span class="math">\\pi \\gets \\mathsf{Groth16.P}(\\mathsf{pk}, u, w)</span>: Let <span class="math">(u, w)</span> be a R1CS instance-proof pair with <span class="math">u := (a_1, \\dots, a_\\ell) \\in \\mathbb{Z}_p^\\ell</span>. The algorithm outputs a Groth16 proof <span class="math">\\pi = (A, B, C)</span> consisting of three group elements <span class="math">A, C \\in \\mathbb{G}_1</span> and <span class="math">B \\in \\mathbb{G}_2</span> (more details in Appendix B.1).</li>

      <li><span class="math">0/1 \\gets \\mathsf{Groth16.V}(\\mathsf{vk}, u, \\pi)</span>: Parse <span class="math">u</span> as <span class="math">(a_1, \\dots, a_\\ell)</span> and obtain <span class="math">(S_i)_{i=0}^\\ell = \\left(\\left[\\frac{\\beta u_i(x) + \\alpha v_i(x) + w_i(x)}{\\gamma}\\right]_1\\right)_{i=0}^\\ell</span> from crs. Compute <span class="math">D = e([\\alpha]_1, [\\beta]_2)</span> and check</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e (A, B) = e (C, [ \\delta ] _ {2}) \\cdot e (\\prod_ {i = 0} ^ {\\ell} S _ {i} ^ {a _ {i}}, [ \\gamma ] _ {2}) \\cdot D,</span></div>

    <p class="text-gray-300">where <span class="math">u_{i}(X), v_{i}(X), w_{i}(X)</span> are polynomials defined in circuit structure <span class="math">\\mathsf{s}</span> and <span class="math">[\\alpha]_{1}, [\\beta]_{2}, [\\gamma]_{2}, [\\delta]_{2}, x</span> are parameters defined in <span class="math">\\mathsf{crs}</span> (details in Appendix B.1).</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.5 Plonk Background</h2>

    <p class="text-gray-300">Plonk is an efficient zk-SNARK with a universal trusted setup. The verification only requires checking a KZG pairing equation. We briefly present the algorithms of Plonk (the details of each building block are provided in the Appendix B.2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{Plonk.G}(1^{\\lambda})</span>: Given the parameter <span class="math">\\lambda</span>, select a bilinear group <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e)</span> with generators <span class="math">g \\in \\mathbb{G}_1</span> and <span class="math">h \\in \\mathbb{G}_2</span>. Output <span class="math">\\mathsf{pp} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e, g, h)</span>.</li>

    </ul>

    <p class="text-gray-300">9</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(pk, vk) <span class="math">\\leftarrow</span> Plonk.K(pp, s): Generate a structured reference string srs that includes the required group elements for the prover and verifier. Compute and output pk and vk based on srs.</li>

      <li><span class="math">\\pi \\leftarrow</span> Plonk.P(pk, u, w): Given a Plonkish instance-witness pair <span class="math">(u, w)</span>, output a Plonk proof</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left( \\begin{array}{c} A, B, C, Z, T_{l}, T_{mi}, T_{h}, W, V, \\\\ \\bar{a}, \\bar{b}, \\bar{c}, \\bar{s}_{\\sigma_{1}}, \\bar{s}_{\\sigma_{2}}, \\bar{z}_{\\omega} \\end{array} \\right),</span></div>

    <p class="text-gray-300">where the first line consists of <span class="math">\\mathbb{G}_1</span> elements and the second line consists of <span class="math">\\mathbb{Z}_p</span> elements (more details in Appendix B.2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">0/1 \\leftarrow \\text{Plonk.V}(\\text{vk}, u, \\pi)</span>: The verifier checks the pairing relation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(W \\cdot V^{\\gamma}, [x]_{2}) = e(W^{\\lambda} \\cdot V^{\\gamma \\lambda \\omega} \\cdot M \\cdot N \\cdot F^{-1}, [1]_{2}),</span></div>

    <p class="text-gray-300">where <span class="math">x</span> is the trapdoor element from the srs, <span class="math">\\lambda, \\gamma</span> are challenge points used in KZG evaluation and KZG batching, <span class="math">\\omega \\in \\mathbb{F}</span> is <span class="math">m</span>-th root of unity of the subgroup <span class="math">\\mathbb{H}</span>, and <span class="math">M, N, F \\in \\mathbb{G}_1</span> are commitments calculated from the Plonk proof <span class="math">\\pi</span> (more details in Appendix B.2).</p>

    <p class="text-gray-300">We present our proof aggregation scheme, SnarkFold, which is built from folding-based IVC. We also construct two folding schemes for Groth16 and Plonk for real-world applications.</p>

    <p class="text-gray-300">In IVC, the recursive function <span class="math">F</span> is performed sequentially with each step built upon the previous one, whereas the relationship among each SNARK proof is independent in proof aggregation, and there is no strict requirement to follow a step-by-step order. Thus, we first propose a straightforward construction shown in Figure 1a, which models the aggregation process as a <span class="math">n</span>-step IVC (the witness part is omitted here for simplicity). The IVC prover iterates <span class="math">n</span> steps, with each step receiving a new SNARK instance-proof pair <span class="math">(u_i, \\pi_i)</span> as input. The IVC proof of step <span class="math">i</span> validates the SNARK proofs <span class="math">\\pi_1, \\ldots, \\pi_i</span>, and the final IVC proof validates all <span class="math">n</span> SNARK proofs. Specifically, this design sets <span class="math">F</span> to checking SNARK.V <span class="math">(u_i, \\pi_i) = 1</span>. The recursive circuit is required to verify the correctness of <span class="math">F</span> and FoldCircuit.V, transforming them into a circuit instance <span class="math">u_{\\mathsf{C},i}</span> (e.g., relaxed R1CS). Here, FoldCircuit.V folds the previous circuit instance <span class="math">u_{\\mathsf{C},i-1}</span> with the running instance <span class="math">u_{\\mathsf{C},i-1}^{<em>}</span> into a new running instance <span class="math">u_{\\mathsf{C},i}^{</em>}</span>, which serves as the input for the next step. The final verifier only needs to check <span class="math">u_{\\mathsf{C},n}</span> and <span class="math">u_{\\mathsf{C},n}^{*}</span> to accept all proofs. This design can enhance the verifier's efficiency. However, a major drawback is that SNARK.V may involve expensive non-native computations like elliptic curve pairings, which incur substantial overhead.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) A straightforward design. Fig. 1: Comparison of the straightforward design and the SnarkFold scheme.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) SnarkFold from two-folding.</p>

    <p class="text-gray-300">SnarkFold: proof aggregation from two-folding. Different from the straightforward construction, which includes a full SNARK verification logic in the recursive circuit, we remove the verification (i.e., SNARK.V) from the circuit and replace it with folding SNARK proofs (i.e., FoldsNARK.V). This defers the costly verification such as pairing operations to the final step. As depicted in Figure 1b, we employ two running instances of different types in the recursive circuit:  <span class="math">u_{i}^{<em>}</span>  for the SNARK and  <span class="math">u_{\\mathsf{C},i}^{</em>}</span>  for the circuit. One core idea of our construction is to view each  <span class="math">\\pi_{i}</span>  as a witness, folded locally rather than in the recursive circuit. The prover adopts a folding scheme FoldsNARK.V to fold the input SNARK instances to  <span class="math">u_{i}^{<em>}</span>  and another folding scheme FoldsCircuit.V to fold the circuit instance to  <span class="math">u_{\\mathsf{C},i}^{</em>}</span> . The recursive circuit shows the correct execution of the two foldings by outputting a claim as a new circuit instance  <span class="math">u_{\\mathsf{C},i}</span> . For example, assume  <span class="math">(u_{i},\\pi_{i}) = (P_{i},Q_{i})\\in \\mathbb{G}_{1}\\times \\mathbb{G}_{1}</span> , with the verification relation  <span class="math">e(P_i,[\\alpha ]_2) = e(Q_i,[\\beta ]_2)</span> . The FoldsNARK.V simply computes  <span class="math">P_{i}^{<em>} = P_{i - 1}^{</em>}\\cdot (P_{i})^{r}</span>  ( <span class="math">r</span>  donates a random challenge from  <span class="math">\\mathbb{Z}_p</span> ). The proof  <span class="math">Q_{i}</span>  is folded locally as  <span class="math">Q_{i}^{<em>} = Q_{i - 1}^{</em>}\\cdot (Q_{i})^{r}</span>  since we regard it as witness. Consequently, the recursive circuit only needs to transfer the correct execution of one  <span class="math">\\mathbb{G}_1</span>  operations (and FoldsCircuit.V) into a circuit instance  <span class="math">u_{\\mathsf{C},i}</span> , without the need for the costly transformation of pairing. We provide the formal design in Section 3.2.</p>

    <p class="text-gray-300">Instance delegation. In existing schemes, the verifier must combine instances  <span class="math">(u_{i})_{i = 1}^{n}</span>  into an aggregated instance  <span class="math">u^{<em>}</span> , typically requiring at least  <span class="math">O(n)</span>  operations. Furthermore, this step cannot be precomputed before receiving  <span class="math">\\pi^{</em>}</span>  and  <span class="math">\\pi_{\\mathrm{AGG}}</span>  from the prover. To reduce the verifier's online workload, we delegate the instance aggregation into the prover's recursive function  <span class="math">F</span> . As shown in Figure 1b, the running instance at step  <span class="math">n</span> ,  <span class="math">u_{n}^{<em>}</span> , can be considered as  <span class="math">u^{</em>}</span> . However, there is a subtle issue if the verifier does not read all  <span class="math">(u_{i})_{i = 1}^{n}</span>  as it can not ensure  <span class="math">u^{*}</span>  is derived from the expected instances. For instance, a malicious prover can replace  <span class="math">(u_{i},\\pi_{i})</span>  with a valid trivial proof  <span class="math">(u_i&#x27;,\\pi_i&#x27;)</span> . To address this issue, we</p>

    <p class="text-gray-300">require the verifier to recursively precompute a binding claim <span class="math">h</span> using <span class="math">(u_{i})_{i=1}^{n}</span> (i.e., <span class="math">h_{i}=\\text{Hash}(u_{i},h_{i-1})</span> and <span class="math">h=h_{n}</span>). Similarly, the prover performs the Hash operations as a part of recursive function (shown in the grey part in Figure 1(b)). <span class="math">h_{n}</span> is the IVC output from the <span class="math">n</span>-th step, which is included in the final IVC proof and sent to the verifier. By comparing the received claim with the local one, the verifier can ensure <span class="math">u^{*}</span> is derived from those expected <span class="math">u_{i}</span>’s.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 IVC Design</h3>

    <p class="text-gray-300">To describe our techniques more precisely, we include the witness parts of our design in Figure 1(b). As we described above, the recursive circuit only needs to show that “<span class="math">u_{i}</span> part is folded correctly”, avoiding the cost of showing “<span class="math">\\pi_{i}</span> part is folded correctly”. Specifically, the recursive circuit takes two SNARK instances <span class="math">u_{i}</span> and <span class="math">u_{i-1}^{<em>}</span> and two circuit instances <span class="math">u_{\\mathsf{C},i-1}</span> and <span class="math">u_{\\mathsf{C},i-1}^{</em>}</span>, and derives two running instances <span class="math">u_{i}^{<em>}</span> and <span class="math">u_{\\mathsf{C},i}^{</em>}</span>. Additionally, to compute the binding claim for the instance aggregation, the recursive circuit hashes <span class="math">u_{i}</span> and <span class="math">h_{i-1}</span> to generate a new binding claim <span class="math">h_{i}</span>.</p>

    <p class="text-gray-300"><span class="math">h_{i}</span> <span class="math">\\leftarrow\\text{Hash}(u_{i},h_{i-1}),</span> (1) <span class="math">u_{i}^{<em>}</span> <span class="math">\\leftarrow\\textsf{Fold}_{\\mathsf{SNARK}}.\\mathsf{V}(\\mathsf{vk}_{\\mathsf{FS}},u_{i},u_{i-1}^{</em>}),</span> <span class="math">u_{\\mathsf{C},i}^{<em>}</span> <span class="math">\\leftarrow\\textsf{Fold}_{\\mathsf{Circuit}}.\\mathsf{V}(\\mathsf{vk}_{\\mathsf{FC}},u_{\\mathsf{C},i-1},u_{\\mathsf{C},i-1}^{</em>}).</span></p>

    <p class="text-gray-300">The recursive circuit will generate an instance-witness pair <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span> to show the correct execution of Equation (1). The prover folds instance-proof and instance-witness pairs and computes <span class="math">h_{i}</span> locally:</p>

    <p class="text-gray-300"><span class="math">h_{i}</span> <span class="math">\\leftarrow\\text{Hash}(u_{i},h_{i-1}),</span> (2) <span class="math">(u_{i}^{<em>},\\pi_{i}^{</em>})</span> <span class="math">\\leftarrow\\textsf{Fold}_{\\mathsf{SNARK}}.\\mathsf{P}\\big{(}\\mathsf{pk}_{\\mathsf{FS}},(u_{i},\\pi_{i}),(u_{i-1}^{<em>},\\pi_{i-1}^{</em>})\\big{)},</span> <span class="math">(u_{\\mathsf{C},i}^{<em>},w_{\\mathsf{C},i}^{</em>})</span> <span class="math">\\leftarrow\\textsf{Fold}_{\\mathsf{Circuit}}.\\mathsf{P}\\big{(}\\mathsf{pk}_{\\mathsf{FC}},(u_{\\mathsf{C},i-1},w_{\\mathsf{C},i-1}),(u_{\\mathsf{C},i-1}^{<em>},w_{\\mathsf{C},i-1}^{</em>})\\big{)}.</span></p>

    <p class="text-gray-300">The above construction has a subtle issue: since <span class="math">h_{i}</span>, <span class="math">u_{i}^{<em>}</span> and <span class="math">u_{\\mathsf{C},i}^{</em>}</span> are outputs of the recursive circuit, they must be included in <span class="math">u_{\\mathsf{C},i}</span>’s public input (i.e., <span class="math">u_{\\mathsf{C},i}.x</span>). In other words, <span class="math">(h_{i}</span>, <span class="math">u_{i}^{<em>},u_{\\mathsf{C},i}^{</em>})\\in u_{\\mathsf{C},i}.x</span>. This implies that the structures of <span class="math">u_{\\mathsf{C},i}^{<em>}</span> and <span class="math">u_{\\mathsf{C},i}</span> are different and cannot be folded in the next iteration. To address this inconsistency, we adopt the same idea as Nova </em>[22]<em>, modifying the recursive circuit to output a collision-resistant hash of its inputs and outputs </em>[22]<em>, i.e., <span class="math">u_{\\mathsf{C},i}.x\\leftarrow\\text{Hash}(\\mathsf{vk},i,h_{i},u_{i}^{</em>},u_{\\mathsf{C},i}^{*})</span>. The detail design of the recursive circuit <span class="math">\\mathsf{RC}</span> and IVC are shown in Figure 2 and Figure 3, respectively.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 SnarkFold Construction</h3>

    <p class="text-gray-300">Proof aggregation with instance delegation. We formally define the SnarkFold scheme <span class="math">\\mathsf{SF}</span>, which consists of a set of algorithms: <span class="math">\\mathsf{SF}.{\\mathsf{G}}</span>, <span class="math">\\mathsf{SF}.{\\mathsf{K}}</span>, <span class="math">\\mathsf{SF}.{\\mathsf{P}}</span>, <span class="math">\\mathsf{SF}.{\\mathsf{VeriPrep}}</span>, and <span class="math">\\mathsf{SF}.{\\mathsf{V}}</span>. Compared to the existing aggregation algorithm in Section 2.2, <span class="math">\\mathsf{SF}</span> introduces a verifier preprocessing algorithm <span class="math">\\mathsf{SF}.{\\mathsf{VeriPrep}}</span> for delegation. Additionally, <span class="math">\\mathsf{SF}.{\\mathsf{P}}</span> and <span class="math">\\mathsf{SF}.{\\mathsf{V}}</span> have been correspondingly adjusted.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2: The logic of recursive circuit in SnarkFold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp} \\gets \\mathsf{SF}. \\mathsf{G}(1^{\\lambda})</span> : Given security parameter  <span class="math">\\lambda</span> , sample public parameters  <span class="math">\\mathsf{pp}</span> .</li>

      <li><span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathsf{SF}.K(\\mathsf{pp})</span>  : Taking the public parameters  <span class="math">\\mathsf{pp}</span> , generate the prover's proving key  <span class="math">\\mathsf{pk}</span>  and the verifier's verification key  <span class="math">\\mathsf{vk}</span>  for the aggregation scheme.</li>

      <li><span class="math">((u^{<em>},\\pi^{</em>}),\\pi_{\\mathsf{AGG}})\\gets \\mathsf{SF}.P(\\mathsf{pk},(u_i,\\pi_i)_{i = 1}^n)</span> : Given  <span class="math">n</span>  instance-proof pairs, output an aggregated instance-proof pair  <span class="math">(u^{<em>},\\pi^{</em>})</span>  and an aggregated proof  <span class="math">\\pi_{\\mathsf{AGG}}</span>  that shows the correctness of the aggregation process.</li>

      <li><span class="math">h \\gets \\mathsf{SF}. \\mathsf{VeriPrep}(\\mathsf{vk}, (u_i)_{i=1}^n)</span> : Given  <span class="math">n</span>  instances  <span class="math">u_1, \\ldots, u_n</span> , output a binding claim  <span class="math">h</span>  of all instances  <span class="math">u_1, \\ldots, u_n</span> .</li>

      <li><span class="math">0/1 \\gets \\mathsf{SF}.V(\\mathsf{vk}, n, h, (u^<em>, \\pi^</em>), \\pi_{\\mathsf{AGG}})</span> : Given an aggregated instance-proof  <span class="math">(u^<em>, \\pi^</em>)</span> , a binding claim  <span class="math">h</span>  and the corresponding aggregation proof  <span class="math">\\pi_{\\mathsf{AGG}}</span> , output either 1 to accept the aggregation or 0 to reject it.</li>

    </ul>

    <p class="text-gray-300">Definition 1 (Perfect Completeness). SnarkFold proof aggregation scheme SF for SNARK (with proving key  <span class="math">\\mathsf{pk}_{\\mathsf{SNARK}}</span>  and verification key  <span class="math">\\mathsf{vk}_{\\mathsf{SNARK}}</span> ) satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">Definition 2 (Knowledge Soundness). SnarkFold scheme satisfies knowledge soundness if for all PPT adversaries  <span class="math">\\mathcal{A}</span>  and any randomness  <span class="math">\\rho</span></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">|  pp← IVC.G(1λ)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  1: ppFS← FoldSNARK.G(1λ), ppFC← FoldCircuit.G(1λ),  |</p>

    <p class="text-gray-300">|  2: output pp← (ppFS, ppFC).  |</p>

    <p class="text-gray-300">|  (pk, vk)← IVC.K(pp, V)  |</p>

    <p class="text-gray-300">|  1: (pkFS, vkFS)← FoldSNARK.K(ppFS, ss), (pkFC, vkFC)← FoldCircuit.K(ppFC, sc),  |</p>

    <p class="text-gray-300">|  2: output (pk, vk)← ((V, pkFS, pkFC), (V, vkFS, vkFC)).  |</p>

    <p class="text-gray-300">|  Πi← IVC.P(pk, i, (ui, πi), Πi-1)  |</p>

    <p class="text-gray-300">|  1: if i = 1  |</p>

    <p class="text-gray-300">|  2: (u0<em>, π0</em>) ← (u⊥*, π⊥), (uC,0, wC,0) ← (uC,⊥, wC,⊥);  |</p>

    <p class="text-gray-300">|  3: else  |</p>

    <p class="text-gray-300">|  4: parse Πi-1 as (hi-1, (ui-1, πi-1), (uC,i-1, wC,i-1), (uC,i-1, wC,i-1)),  |</p>

    <p class="text-gray-300">|  5: compute hi, (ui<em>, πi</em>), (uC,i, wC,i) based on Equation (2),  |</p>

    <p class="text-gray-300">|  6: (uC,i, wC,i) ← tr(RC(vk, i, hi-1, ui, ui-1, uC,i-1, uC,i-1)),  |</p>

    <p class="text-gray-300">|  7: output Πi ← (hi, (ui<em>, πi</em>), (uC,i, wC,i), (uC,i, wC,i)).  |</p>

    <p class="text-gray-300">|  0/1← IVC.V(vk, i, Πi)  |</p>

    <p class="text-gray-300">|  1: parse Πi as (hi, (ui<em>, πi</em>), (uC,i, wC,i), (uC,i, wC,i)),  |</p>

    <p class="text-gray-300">|  2: check uC,i.x = Hash(vk, i, hi, ui*, uC,i),  |</p>

    <p class="text-gray-300">|  3: check πi<em> is a satisfying proof to ui</em>,  |</p>

    <p class="text-gray-300">|  4: check wC,i, wC,i are satisfying witnesses to uC,i, uC,i,  |</p>

    <p class="text-gray-300">|  5: check uC,i is a non-relaxed instance.  |</p>

    <p class="text-gray-300">Fig. 3: The logic of the IVC in SnarkFold.  <span class="math">(u, w) \\gets \\operatorname{tr}(\\mathsf{RC}(\\mathsf{input}))</span>  represents the trace of the recursive circuit. i.e., converting the recursive circuit RC(input) to an instance-witness pair  <span class="math">(u, w)</span> .</p>

    <p class="text-gray-300">Construction. Let  <span class="math">(u_{\\perp}^{<em>},\\pi_{\\perp}^{</em>})</span>  be a trivial satisfying instance-proof pair and  <span class="math">(u_{\\mathsf{C},\\perp}^{<em>},w_{\\mathsf{C},\\perp}^{</em>})</span>  be a trivially satisfying instances-witness pair. We describe the construction of SnarkFold in Figure 4. The aggregation prover calls  <span class="math">n</span>  times IVC.P to generate a final IVC proof  <span class="math">\\varPi_{n}</span> , which includes the binding claim  <span class="math">h_n</span> , the aggregated SNARK instance-proof pair  <span class="math">(u_{n}^{<em>},\\pi_{n}^{</em>})</span> , the circuit instance-witness pair  <span class="math">(u_{\\mathsf{C},n},w_{\\mathsf{C},n})</span> , and the running circuit instance-witness pair  <span class="math">(u_{\\mathsf{C},n}^{<em>},w_{\\mathsf{C},n}^{</em>})</span> . The resulting aggregated SNARK instance-proof pair is  <span class="math">(u^{<em>},\\pi^{</em>}) = (u_{n}^{<em>},\\pi_{n}^{</em>})</span>  and the binding claim is  <span class="math">h = h_n</span> . To further improve efficiency, the prover can fold  <span class="math">(u_{\\mathsf{C},n},w_{\\mathsf{C},n})</span>  and  <span class="math">(u_{\\mathsf{C},n}^{<em>},w_{\\mathsf{C},n}^{</em>})</span>  into  <span class="math">(u^{\\prime},w^{\\prime})</span>  and employ another SNARK for the recursive circuit (denoted as SNARK', which can be different from the SNARK to</p>

    <p class="text-gray-300">be aggregated) to produce a proof  <span class="math">\\pi&#x27;</span>  showing the knowledge of  <span class="math">w&#x27;</span> . Accordingly, the aggregation proof  <span class="math">\\pi_{\\mathsf{AGG}}</span>  is  <span class="math">(h_n, u_{\\mathsf{C}, n}, u_{\\mathsf{C}, n}^*, \\pi&#x27;)</span> .</p>

    <p class="text-gray-300">Theorem 1. The construction of the SnarkFold scheme in Figure 4 satisfies perfect completeness and knowledge soundness if IVC and SNARK' has perfect completeness and knowledge soundness.</p>

    <p class="text-gray-300">Proof Sketch. The perfect completeness of SnarkFold is directly inferred from the perfect completeness of IVC and SNARK'. The knowledge soundness of SnarkFold is also implied by the knowledge soundness of IVC and SNARK'. Guaranteed by the binding property of SF.VeriPrep (elaborated in Lemma 2), the  <span class="math">(u_i)_{i=1}^n</span>  are expected instances with an overwhelming probability. (Appendix C.2)</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 4: The SnarkFold scheme.</p>

    <p class="text-gray-300">4 SNARK Folding Schemes</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.1 Folding Scheme for Groth16</h3>

    <p class="text-gray-300">To adopt SnarkFold in Groth16 aggregation, we need a folding scheme for Groth16. A straightforward approach is to perform a random exponential combination (e.g., <span class="math">A^{<em>}=A_{1}\\cdot A_{2}^{r}</span>), but this leads to inconsistencies in folded verification due to cross-terms (i.e., <span class="math">e(A^{</em>},B^{<em>})\\neq e(C^{</em>},[\\delta]_{2})\\cdot e(\\prod_{i=0}^{\\ell}S_{i}^{a_{i}^{*}},[\\gamma]_{2})\\cdot D</span>).</p>

    <p class="text-gray-300">First attempt: relaxed Groth16. We introduce our initial attempt at the folding scheme for Groth16. Specifically, we propose a variant of the Groth16 relation, called “relaxed” Groth16, which introduces some additional elements to ensure that the folded instance-proof pair is satisfiable.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 3 (Relaxed Groth16 Proof Relation)</h6>

    <p class="text-gray-300">Given the structure with <span class="math">([\\delta]_{2}</span>, <span class="math">[\\gamma]_{2}</span>, <span class="math">(S_{i})_{i=0}^{\\ell}</span>, <span class="math">D</span>) <span class="math">\\in</span> <span class="math">(\\mathbb{G}_{2}</span>, <span class="math">\\mathbb{G}_{2}</span>, <span class="math">\\mathbb{G}_{1}^{\\ell+1}</span>, <span class="math">\\mathbb{G}_{T})</span>, a relaxed Groth16 proof relation consists of an instance <span class="math">(\\vec{a},\\mu,E)\\in(\\mathbb{Z}_{p}^{\\ell+1},\\mathbb{Z}_{p},\\mathbb{G}_{T})</span> and a proof <span class="math">(A,B,C)\\in(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{1})</span>, such that</p>

    <p class="text-gray-300"><span class="math">e(A,B)\\cdot e(C,[\\delta]_{2})^{-\\mu}\\cdot e(\\prod_{i=0}^{\\ell}S_{i}^{a_{i}},[\\gamma]_{2})^{-\\mu}\\cdot D^{-\\mu^{2}}=E,</span></p>

    <p class="text-gray-300">where <span class="math">\\vec{a}=(a_{0},...,a_{\\ell})</span>.</p>

    <p class="text-gray-300">The relaxed relation introduces two additional elements, <span class="math">E</span> and <span class="math">\\mu</span>. Specifically, <span class="math">E</span> is used to absorb the cross-term generated by folding, and <span class="math">\\mu</span> is used to absorb additional factors. For traditional (non-relaxed) Groth16 proof relations, <span class="math">\\mu=1</span> and <span class="math">E=[0]_{T}</span>.</p>

    <p class="text-gray-300">We describe the folding scheme for relaxed Groth16 in more detail. Given two instance-proof pairs, <span class="math">(u_{1},\\pi_{1})=\\left((\\vec{a}_{1},\\mu_{1},E_{1}),(A_{1},B_{1},C_{1})\\right)</span> and <span class="math">(u_{2},\\pi_{2})=\\left((\\vec{a}_{2},\\mu_{2},E_{2}),\\,(A_{2},B_{2},C_{2})\\right)</span> where <span class="math">\\vec{a}_{1}=(a_{1,i})_{i=0}^{\\ell}</span> and <span class="math">\\vec{a}_{2}=(a_{2,i})_{i=0}^{\\ell}</span>, the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> engage in the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: Compute and send the cross-item <span class="math">T</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">T</span> <span class="math">\\leftarrow</span> <span class="math">e(A_{1},B_{2})\\cdot e(A_{2},B_{1})\\cdot e(C_{1}^{-\\mu_{2}}C_{2}^{-\\mu_{1}},[\\delta]_{2})</span> <span class="math">\\cdot</span> <span class="math">e(\\prod_{i=0}^{\\ell}S_{i}^{-\\mu_{2}a_{1,i}-\\mu_{1}a_{2,i}},[\\gamma]_{2})\\cdot D^{-2\\mu_{1}\\mu_{2}}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: Sample and send a challenge <span class="math">r\\leftarrow\\</span> <span class="math">\\mathbb{Z}_{p}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> Compute the folded relaxed Groth16 instance <span class="math">(\\vec{a}^{<em>},\\mu^{</em>},E^{*})</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\vec{a}^{<em>}\\leftarrow\\vec{a}_{1}+r\\cdot\\vec{a}_{2},\\quad\\mu^{</em>}\\leftarrow\\mu_{1}+r\\cdot\\mu_{2},\\quad E^{*}\\leftarrow E_{1}\\cdot T^{r}\\cdot{E_{2}^{x^{2}}}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute the folded relaxed Groth16 proof <span class="math">(A^{<em>}</span>,<span class="math">B^{</em>}</span>,<span class="math">C^{*})</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">A^{<em>}\\leftarrow A_{1}\\cdot A_{2}^{r},\\quad B^{</em>}\\leftarrow B_{1}\\cdot B_{2}^{r},\\quad C^{*}\\leftarrow C_{1}\\cdot C_{2}^{r}.</span></p>

    <p class="text-gray-300">Reducing pairings: augmented relaxed Groth16. In the above construction, <span class="math">\\mathcal{P}</span> is required to compute four pairings for <span class="math">T</span> at step 1 in each iteration. Although the pairing is performed locally (not in the recursive circuit), it introduces a non-negligible cost. To improve efficiency, <span class="math">\\mathcal{P}</span> can compute and send <span class="math">T&#x27; = e(A_1, B_2) \\cdot e(A_2, B_1)</span>, <span class="math">R = C_1^{-\\mu_2} C_2^{-\\mu_1}</span>, <span class="math">\\vec{t} = \\mu_2 \\vec{a}_1 + \\mu_1 \\vec{a}_2</span>, and <span class="math">\\kappa = -2\\mu_1 \\mu_2</span> with two pairings in step 1. Consequently, the <span class="math">E^<em></span> in step 3 becomes <span class="math">E^</em> = E_1 \\cdot (T&#x27; \\cdot e(R, [\\delta]_2) \\cdot e(\\prod_{i=0}^{\\ell} S_i^{t_i}, [\\gamma]_2) \\cdot D^\\kappa)^r \\cdot E_2^{r^2}</span>. This may not seem helpful since computing <span class="math">E^*</span> requires two additional pairings, but we observe that <span class="math">R</span> and <span class="math">\\prod S_i^{t_i}</span> (and <span class="math">\\kappa</span>) parts can further be folded in each iteration, and the pairing operation (and <span class="math">\\mathbb{G}_T</span> operation) can be deferred to the final step. This indicates we only need <span class="math">2n + 2</span> pairings for folding <span class="math">n</span> proofs instead of <span class="math">4n</span> pairings. To achieve this optimization, we formally introduce the concept of an "augmented relaxed Groth16 proof relation".</p>

    <p class="text-gray-300"><strong>Definition 4 (Augmented Relaxed Groth16 Proof Relation).</strong> Given the structure with <span class="math">([\\delta]_2, [\\gamma]_2, (S_i)_{i=0}^\\ell, D) \\in (\\mathbb{G}_2, \\mathbb{G}_2, \\mathbb{G}_1^{\\ell+1}, \\mathbb{G}_T)</span>, an augmented relaxed Groth16 proof relation consists of an instance <span class="math">(\\vec{a}, \\mu, E, R, \\vec{t}, \\kappa) \\in (\\mathbb{Z}_p^{\\ell+1}, \\mathbb{Z}_p, \\mathbb{G}_T, \\mathbb{G}_1, \\mathbb{Z}_p^{\\ell+1}, \\mathbb{Z}_p)</span> and a proof <span class="math">(A, B, C) \\in (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_1)</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e (A, B) \\cdot e (C, [ \\delta ] _ {2}) ^ {- \\mu} \\cdot e \\left(\\prod_ {i = 0} ^ {\\ell} S _ {i} ^ {a _ {i}}, [ \\gamma ] _ {2}\\right) ^ {- \\mu} \\cdot D ^ {- \\mu^ {2}} \\\\ = E \\cdot e (R, [ \\delta ] _ {2}) \\cdot e \\left(\\prod_ {i = 0} ^ {\\ell} S _ {i} ^ {t _ {i}}, [ \\gamma ] _ {2}\\right) \\cdot D ^ {\\kappa}. \\end{array}</span></div>

    <p class="text-gray-300">For traditional Groth16 proof relations, we can simply set <span class="math">\\mu = 1</span>, <span class="math">E = [0]_T</span>, <span class="math">R = [0]_1</span>, <span class="math">\\vec{t} = \\vec{0}</span>, and <span class="math">\\kappa = 0</span>. Given two instance-proof pairs <span class="math">(u_{1},\\pi_{1}) = ((\\vec{a}_{1},\\mu_{1},E_{1},R_{1},\\vec{t}_{1},\\kappa_{1}),(A_{1},B_{1},C_{1}))</span> and <span class="math">(u_{2},\\pi_{2}) = ((\\vec{a}_{2},\\mu_{2},E_{2},R_{2},\\vec{t}_{2},\\kappa_{2}),(A_{2},B_{2},C_{2}))</span>, we describe the construction for augmented relaxed Groth16 in the following protocol. The non-interactive version can be implemented by the Fiat-Shamir transformation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: Compute <span class="math">T&#x27;, R, \\vec{t}, \\kappa</span>. Set and send the cross-item <span class="math">T</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T ^ {\\prime} \\leftarrow e \\left(A _ {1}, B _ {2}\\right) \\cdot e \\left(A _ {2}, B _ {1}\\right), \\quad R \\leftarrow C _ {1} ^ {- \\mu_ {2}} C _ {2} ^ {- \\mu_ {1}}, \\\\ \\vec {t} \\leftarrow \\mu_ {2} \\vec {a} _ {1} + \\mu_ {2} \\vec {a} _ {2}, \\quad \\kappa \\leftarrow - 2 \\mu_ {1} \\mu_ {2}, \\tag {3} \\\\ T \\leftarrow \\left(T ^ {\\prime}, R, \\vec {t}, \\kappa\\right). \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: Sample and send a challenge <span class="math">r \\gets \\mathbb{S} \\mathbb{Z}_p</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>: Compute the folded augmented relaxed Groth16 instance <span class="math">(\\vec{a}^<em>, \\mu^</em>, E^<em>, R^</em>, \\vec{t}^<em>, \\kappa^</em>)</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\vec {a} ^ {*} \\leftarrow \\vec {a} _ {1} + r \\cdot \\vec {a} _ {2}, \\quad \\mu^ {*} \\leftarrow \\mu_ {1} + r \\cdot \\mu_ {2}, \\\\ E ^ {*} \\leftarrow E _ {1} \\cdot \\left(T ^ {\\prime}\\right) ^ {r} \\cdot \\left(E _ {2}\\right) ^ {r ^ {2}}, \\quad R ^ {*} \\leftarrow R _ {1} \\cdot R ^ {r} \\cdot \\left(R _ {2}\\right) ^ {r ^ {2}}, \\tag {4} \\\\ \\vec {t} ^ {*} \\leftarrow \\vec {t} _ {1} + r \\cdot \\vec {t} + r ^ {2} \\cdot \\vec {t} _ {2}, \\quad \\kappa^ {*} \\leftarrow \\kappa_ {1} + r \\cdot \\kappa + r ^ {2} \\cdot \\kappa_ {2}. \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute the folded augmented relaxed Groth16 proof <span class="math">(A^{<em>},\\,B^{</em>},\\,C^{*})</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">A^{<em>}\\leftarrow A_{1}\\cdot A_{2}^{r},\\quad B^{</em>}\\leftarrow B_{1}\\cdot B_{2}^{r},\\quad C^{*}\\leftarrow C_{1}\\cdot C_{2}^{r}.</span></p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">The construction of the folding scheme for augmented relaxed Groth16 satisfies perfect completeness and knowledge soundness under the random oracle model.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof Sketch.</h6>

    <p class="text-gray-300">The perfect soundness holds trivially. For the knowledge soundness, we prove this interactive version of the protocol via the forking lemma in Lemma 1, which implies the knowledge soundness of the non-interactive construction under the Fiat-Shamir heuristic in the random oracle model. We present a formal proof in Appendix C.3.</p>

    <p class="text-gray-300">Remark: soundness of augmented relaxed Groth16 proof relation. Since a folded Groth16 proof cannot pass the original Groth16 verification due to the cross-items, we propose the augmented relaxed Groth16 proof relation to absorb cross-items by introducing some extra factors. It is a relation specifically for folding and only needs to satisfy the knowledge soundness (and the perfect completeness) of the <em>folding scheme</em> (detailed proof provided in Appendix C.3), i.e., the validity of the folded relation implies the validity of the original relations. Note that we ensure <span class="math">\\mu=1</span>, <span class="math">E=[0]_{T}</span>, <span class="math">R=[0]_{1}</span>, <span class="math">\\vec{t}=\\vec{0}</span>, and <span class="math">\\kappa=0</span> for the input Groth16 instance-proof pair in the recursive circuit. Since we have not made any changes to the Groth16 zk-SNARK proof system, the knowledge soundness of each single Groth16 instance-proof pair <span class="math">(u_{i},\\pi_{i})</span> is ensured by the <em>original</em> Groth16 zk-SNARK proof system.</p>

    <p class="text-gray-300">Large <span class="math">\\ell</span> case: committed augmented relaxed Groth16. The above construction requires <span class="math">O(\\ell)</span> <span class="math">\\mathbb{Z}_{p}</span> operations within the recursive circuit. When <span class="math">\\ell</span> is significantly large, this cost can be further reduced. This is achieved by redefining Definition 4 as a committed version, where <span class="math">\\vec{a}</span> is incorporated as part of the proof and <span class="math">\\prod S_{i}^{a_{i}}</span> is integrated as part of the instance. Specifically, a committed Groth16 relation consists of an instance <span class="math">(H,\\mu,E,R,S,\\kappa)\\in(\\mathbb{G}_{1},\\mathbb{Z}_{p},\\mathbb{G}_{T},\\mathbb{G}_{1},\\mathbb{G}_{1},\\mathbb{Z}_{p})</span> and a proof <span class="math">(\\vec{a},A,B,C)\\in(\\mathbb{Z}_{p}^{\\ell+1},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{1})</span>, such that</p>

    <p class="text-gray-300"><span class="math">e(A,B)\\cdot e(C,[\\delta]_{2})^{-\\mu}\\cdot e(H,[\\gamma]_{2})^{-\\mu}\\cdot D^{-\\mu^{2}}</span> <span class="math">=E\\cdot e(R,[\\delta]_{2})\\cdot e(S,[\\gamma]_{2})\\cdot D^{\\kappa},\\quad\\wedge\\quad H=\\prod_{i=0}^{\\ell}S_{i}^{a_{i}}.</span></p>

    <p class="text-gray-300">We briefly describe the interactive version of the folding scheme. Given two committed augmented relaxed Groth16 instance-proof pairs <span class="math">\\big{(}(H_{1},\\mu_{1},E_{1},R_{1},S_{1},\\kappa_{1}),</span> <span class="math">(\\vec{a}_{1},A_{1},B_{1},C_{1})\\big{)}</span> and <span class="math">\\big{(}(H_{2},\\mu_{2},E_{2},R_{2},S_{2},\\kappa_{2}),</span> <span class="math">(\\vec{a}_{2},A_{2},B_{2},C_{2})\\big{)}</span>, the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> engage in the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: Compute <span class="math">T^{\\prime},R,\\kappa</span> as in Equation (3). Compute <span class="math">S\\leftarrow H_{1}^{-\\mu_{2}}H_{2}^{-\\mu_{1}}</span>. Set and send the cross items <span class="math">T\\leftarrow(T^{\\prime},R,S,\\kappa)</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: Sample and send a challenge <span class="math">r\\leftarrow\\;\\mathbb{Z}_{p}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>: Compute <span class="math">\\mu^{<em>}, E^{</em>}, R^{<em>}, \\kappa^{</em>}</span> as in Equation (4). Compute <span class="math">H^{<em>}</span> and <span class="math">S^{</em>}</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">H^{*} \\leftarrow H_{1} \\cdot H_{2}^{r}, \\quad S^{*} \\leftarrow S_{1} \\cdot S^{r} \\cdot S_{2}^{r^{2}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute the folded proof <span class="math">(\\vec{a}^{<em>}, A^{</em>}, B^{<em>}, C^{</em>})</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\vec{a}^{*} \\leftarrow \\vec{a}_{1} + r \\cdot \\vec{a}_{2}, \\quad A^{*} \\leftarrow A_{1} \\cdot A_{2}^{r}, \\quad B^{*} \\leftarrow B_{1} \\cdot B_{2}^{r}, \\quad C^{*} \\leftarrow C_{1} \\cdot C_{2}^{r}.</span></div>

    <p class="text-gray-300">Theorem 3. The construction of the above folding scheme for committed Groth16 satisfies perfect completeness and knowledge soundness under the random oracle model.</p>

    <p class="text-gray-300">Proof Sketch. For the perfect completeness, <span class="math">H^{<em>} = \\prod S_{i}^{a_{i}^{r}}</span> holds since <span class="math">H^{</em>} = H_{1} \\cdot H_{2}^{r} = \\left( \\prod_{i=0}^{\\ell} S_{i}^{a_{1,i}} \\right) \\cdot \\left( \\prod_{i=0}^{\\ell} S_{i}^{a_{1,i}} \\right)^{r} = \\prod_{i=0}^{\\ell} S_{i}^{a_{i}^{r}}</span>. The remaining parts are identical to the proof of Theorem 2. As for knowledge soundness, the extractor extracts <span class="math">\\widetilde{a}_{1}</span> and <span class="math">\\widetilde{a}_{2}</span> with two accepting <span class="math">\\vec{a}_{1}^{<em>}</span> and <span class="math">\\vec{a}_{2}^{</em>}</span> under different challenges through interpolation. Other parts are almost identical to that of Theorem 2.</p>

    <p class="text-gray-300">Non-uniform structure for Groth16. The constructions we have presented so far are only applicable in cases of uniform structure, where different instance-proof pairs share the same structure <span class="math">([\\delta]_2, [\\gamma]_2, (S_i)_{i=0}^\\ell, D)</span>. For non-uniform pairs with different structures, we can also construct a similar folding scheme at the cost of some additional pairing operations.</p>

    <p class="text-gray-300">Definition 5 (Non-uniform Committed Relaxed Groth16). A non-uniform committed relaxed Groth16 proof consists of a structure <span class="math">([\\delta]_2, [\\gamma]_2, (S_i)_{i=0}^\\ell, D) \\in (\\mathbb{G}_2, \\mathbb{G}_2, \\mathbb{G}_1^{\\ell+1}, \\mathbb{G}_T)</span>, an instance <span class="math">(H, \\mu, E, F) \\in (\\mathbb{G}_1, \\mathbb{Z}_p, \\mathbb{G}_T, \\mathbb{G}_1)</span>, and a proof <span class="math">(\\vec{a}, A, B, C) \\in (\\mathbb{Z}_p^{\\ell+1}, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_1)</span>, such that</p>

    <div class="my-4 text-center"><span class="math-block">e(A, B) \\cdot e(C, [\\delta]_2)^{-1} \\cdot e(H, [\\gamma]_2)^{-1} \\cdot D^{-\\mu} = E, \\quad \\wedge \\quad H^{-\\mu} \\cdot \\prod_{i=0}^{\\ell} S_{i}^{a_{i}} = F.</span></div>

    <p class="text-gray-300">Given two non-uniform structure-instance-proof tuples <span class="math">\\big(([\\delta_1]_2, [\\gamma_1]_2, (S_{1,i})_{i=0}^\\ell, D_1), (H_1, \\mu_1, E_1, F_1), (\\vec{a}_1, A_1, B_1, C_1)\\big)</span> and <span class="math">\\big(([\\delta_2]_2, [\\gamma_2]_2, (S_{2,i})_{i=0}^\\ell, D_2), (H_2, \\mu_2, E_2, F_2), (\\vec{a}_2, A_2, B_2, C_2)\\big)</span>, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> engage in the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: Compute and send the cross-items <span class="math">T_{1}</span> and <span class="math">T_{2}</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T_{1} \\leftarrow e(A_{1}, B_{2}) \\cdot e(A_{2}, B_{1}) \\cdot e(C_{1}, [\\delta_{2}]_{2}) \\cdot e(C_{2}, [\\delta_{1}]_{2}) \\\\ \\cdot e(H_{1}, [\\gamma]_{2}) \\cdot e(H_{2}, [\\gamma]_{1}) \\cdot D_{1}^{\\mu_{2}} \\cdot D_{2}^{\\mu_{1}}, \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">T_{2} \\leftarrow H_{1}^{\\mu_{2}} \\cdot H_{2}^{\\mu_{1}} \\cdot \\prod_{i=0}^{\\ell} \\left(S_{1,i}^{a_{2,i}} \\cdot S_{2,i}^{a_{1,i}}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: Sample and send a challenge <span class="math">r \\leftrightarrows \\mathbb{Z}_p</span>.</li>

    </ol>

    <p class="text-gray-300">19</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>: Compute the folded committed Groth16 structure-instance pair <span class="math">\\big{(}([\\delta^{<em>}]_{2},[\\gamma^{</em>}]_{2},(S^{<em>}_{i})_{i=0}^{\\ell},D^{</em>}),(H^{<em>},\\mu^{</em>},E^{<em>},F^{</em>})\\big{)}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">[\\delta^{<em>}]_{2}\\leftarrow[\\delta_{1}]_{2}\\cdot[\\delta_{2}]_{2}^{r},\\quad[\\gamma^{</em>}]_{2}\\leftarrow[\\gamma]_{2}\\cdot[\\gamma]_{2}^{r},</span> <span class="math">S^{<em>}_{i}\\leftarrow S_{1,i}\\cdot S_{2,i}^{r},\\quad D^{</em>}\\leftarrow D_{1}\\cdot D_{2}^{r},</span> <span class="math">H^{<em>}\\leftarrow H_{1}\\cdot H_{2}^{r},\\quad\\mu^{</em>}\\leftarrow\\mu_{1}+r\\cdot\\mu_{2},</span> <span class="math">E^{<em>}=E_{1}\\cdot T_{1}^{r}\\cdot E_{2}^{r^{2}},\\quad F^{</em>}=F_{1}\\cdot T_{2}^{r}\\cdot F_{2}^{r^{2}}.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Compute the folded relaxed Groth16 proof <span class="math">(\\vec{a}^{<em>},A^{</em>},B^{<em>},C^{</em>})</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\vec{a}^{<em>}\\leftarrow\\vec{a}_{1}+r\\cdot\\vec{a}_{2},\\ \\ A^{</em>}\\leftarrow A_{1}\\cdot A_{2}^{r},\\ \\ B^{<em>}\\leftarrow B_{1}\\cdot B_{2}^{r},\\ \\ C^{</em>}\\leftarrow C_{1}\\cdot C_{2}^{r}.</span></p>

    <p class="text-gray-300">The <em>perfect completeness</em> and <em>knowledge soundness</em> of the protocol can be proved with an approach similar to the proof of Theorem 2. We omit the details here due to space constraints.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.2 Folding Scheme for Plonk</h3>

    <p class="text-gray-300">Unlike Groth16, the Plonk protocol is constructed from PIOPs, which require conversion into a non-interactive protocol using Fiat-Shamir transformations. The challenges of Fiat-Shamir are non-homomorphic and need to be verified within the circuit. To tackle this issue, we introduce a preprocessing step in the recursive circuit that conducts basic hash checks and converts the Plonk proof into a folding-friendly form. We outline two relations: linear relation and quadratic relation.</p>

    <p class="text-gray-300">Linear relation. Observe that the final verification of Plonk is in a linear form of <span class="math">e(P,[x]_{2})\\stackrel{{\\scriptstyle!}}{{=}}e(Q,[1]_{2})</span>. We can preprocess the proof to <span class="math">P,Q\\in\\mathbb{G}_{1}</span> and construct (multiple) folding without incurring any cross item. Specifically, the preprocessing procedure includes a Plonk verification except for the pairing check part, which is described in Figure 5.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 6 (Preprocessed Linear Plonk Relation).</h6>

    <p class="text-gray-300">Given a structure <span class="math">([x]_{2},\\mathsf{vk}_{\\mathsf{Plonk}})</span>, a preprocessed linear Plonk proof relation consists of an instance <span class="math">(P,Q,u_{\\mathsf{Plonk}},\\pi_{\\mathsf{Plonk}})</span> and an empty witness <span class="math">\\perp</span> such that</p>

    <p class="text-gray-300"><span class="math">e(P,[x]_{2})=e(Q,[1]_{2}).</span></p>

    <p class="text-gray-300">For non-folded instances, the verifier also needs to check <span class="math">(P,Q)=\\mathsf{Preprocess}_{\\mathsf{L}}</span> <span class="math">(\\mathsf{vk}_{\\mathsf{Plonk}},u_{\\mathsf{Plonk}},\\pi_{\\mathsf{Plonk}})</span> to ensure <span class="math">P</span> and <span class="math">Q</span> are correctly generated. This is the reason to include <span class="math">\\mathsf{vk}_{\\mathsf{Plonk}}</span>, <span class="math">u_{\\mathsf{Plonk}}</span>, and <span class="math">\\pi_{\\mathsf{Plonk}}</span> in the relation. However, they can be omitted in the folding scheme since all related parts are in <span class="math">\\mathsf{Preprocess}_{\\mathsf{L}}</span>, whose validity is implied by the recursive circuit. Specifically, given two instances with <span class="math">(P_{1},Q_{1})</span> and <span class="math">(P_{2},Q_{2})</span>, we can fold them into <span class="math">P^{<em>}=P_{1}\\cdot P_{2}^{r}</span> and <span class="math">Q^{</em>}=Q_{1}\\cdot Q_{2}^{r}</span></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 5: Preprocess a Plonk proof into a linear relation.</p>

    <p class="text-gray-300">using a challenge  <span class="math">r</span>  (the  <span class="math">u_{\\mathsf{Plonk}}^<em></span>  and  <span class="math">\\pi_{\\mathsf{Plonk}}^</em></span>  parts can be set to  <span class="math">\\bot</span> ). It is clear that  <span class="math">e(P^{<em>},[x]_{2}) = e(Q^{</em>},[1]_{2})</span>  still holds. This folding scheme also supports multiple folding, which allows for the folding of  <span class="math">k</span>  instances within a single incremental step. Given  <span class="math">k</span>  instances  <span class="math">(P_{i},Q_{i},u_{\\mathsf{Plonk},i},\\pi_{\\mathsf{Plonk},i})_{i = 1}^{k}</span> , the detailed  <span class="math">k</span> -folding construction is shown as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>  : Sample and send a challenge  <span class="math">r\\gets \\S \\mathbb{Z}_p</span></li>

      <li><span class="math">\\mathcal{P}</span> : Compute  <span class="math">P^{<em>}</span>  and  <span class="math">Q^{</em>}</span>  and return the folded instance-proof  <span class="math">\\left((P^{<em>},Q^{</em>},\\bot ,\\bot),\\bot\\right)</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">P ^ {*} \\leftarrow \\prod_ {i = 1} ^ {k} P _ {i} ^ {r ^ {i - 1}}, \\qquad Q ^ {*} \\leftarrow \\prod_ {i = 1} ^ {k} Q _ {i} ^ {r ^ {i - 1}}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> : For  <span class="math">i = 1</span>  to  <span class="math">k</span> , check</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(P _ {i}, Q _ {i}\\right) = \\operatorname {P r e p r o c e s s} _ {\\mathrm {L}} \\left(\\mathrm {v k} _ {\\text {P l o n k}}, u _ {\\text {P l o n k}, i}, \\pi_ {\\text {P l o n k}, i}\\right)</span></div>

    <p class="text-gray-300">and compute the folded instance  <span class="math">(P^{<em>},Q^{</em>},\\bot ,\\bot)</span></p>

    <div class="my-4 text-center"><span class="math-block">P ^ {*} \\leftarrow \\prod_ {i = 1} ^ {k} P _ {i} ^ {r ^ {i - 1}}, \\qquad Q ^ {*} \\leftarrow \\prod_ {i = 1} ^ {k} Q _ {i} ^ {r ^ {i - 1}}.</span></div>

    <p class="text-gray-300">The non-interactive version can be implemented by Fiat-Shamir transformation.</p>

    <p class="text-gray-300">Theorem 4. The construction of the multiple folding scheme for Plonk in the linear Plonk relation satisfies perfect completeness and knowledge soundness under the random oracle model.</p>

    <p class="text-gray-300">Proof Sketch. For each non-folded satisfying preprocessed linear Plonk instance, we have  <span class="math">(P_{i},Q_{i}) = \\mathsf{Preprocess}_{\\mathsf{L}}(\\mathsf{vk}_{\\mathsf{Plonk}},u_{\\mathsf{Plonk},i},\\pi_{\\mathsf{Plonk},i})</span> . Furthermore,  <span class="math">e(P^{<em>},[x]_{2}) = \\prod_{i = 1}^{k}e(P_{i},[x]_{2}) = \\prod_{i = 1}^{k}e(Q_{i},[1]_{2}) = e(Q^{</em>},[1]_{2})</span> . For the knowledge soundness, the extractor can trivially set the extracted witnesses to  <span class="math">\\perp</span> . As  <span class="math">e(P^{<em>},[x]_{2}) = e(Q^{</em>},[1]_{2})</span> ,  <span class="math">e(P_{i},[x]_{2}) = e(Q_{i},[1]_{2})</span>  holds for  <span class="math">i = \\{1,\\dots,k\\}</span>  by construction, which implies  <span class="math">\\left((P_i,Q_i,u_{\\mathsf{Plonk},i},\\pi_{\\mathsf{Plonk},i}),\\perp\\right)_{i = 1}^k</span>  are satisfying instance-witness pairs for the preprocessed linear Plonk relation.</p>

    <p class="text-gray-300">Quadratic relation. PreprocessL requires the prover to conduct many group operations in the recursive circuit. Alternatively, the preprocessing process can only conduct field operations and convert the proof into a quadratic relation with the cost of a single cross item in 2-folding cases, as depicted in Figure 6.</p>

    <p class="text-gray-300">Definition 7 (Relaxed Preprocessed Quadratic Plonk Relation). Given a Plonk proof  <span class="math">\\pi_{\\mathrm{Plonk}}</span>  to the corresponding instance  <span class="math">u_{\\mathrm{Plonk}}</span>  and verification key  <span class="math">\\mathsf{vk}_{\\mathrm{Plonk}}</span> , a relaxed preprocessed quadratic Plonk proof relation consists of a structure  <span class="math">([x]_2, \\mathsf{vk}_{\\mathrm{Plonk}})</span> , an instance  <span class="math">(\\lambda, \\gamma, v, \\bar{a}, \\bar{b}, \\bar{c}, \\bar{t}, u_{\\mathrm{Plonk}}, \\pi_{\\mathrm{Plonk}}, \\mu, E_P, E_Q)</span> , and an empty witness  <span class="math">\\perp</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">M \\leftarrow A ^ {v} \\cdot B ^ {t _ {1}} \\cdot C ^ {t _ {2}} \\cdot S _ {\\sigma_ {1}} ^ {t _ {3}} \\cdot S _ {\\sigma_ {2}} ^ {t _ {4}},</span></div>

    <div class="my-4 text-center"><span class="math-block">N \\leftarrow Q _ {M} ^ {\\bar {a} \\bar {b}} \\cdot Q _ {L} ^ {\\mu \\bar {a}} \\cdot Q _ {R} ^ {\\mu \\bar {b}} \\cdot Q _ {O} ^ {\\mu \\bar {c}} \\cdot Q _ {C} ^ {\\mu^ {3}} \\cdot Z ^ {t _ {5}} \\cdot S _ {\\sigma_ {3}} ^ {t _ {6}} \\cdot T _ {l} ^ {t _ {7}} \\cdot T _ {m i} ^ {t _ {8}} \\cdot T _ {h} ^ {t _ {9}},</span></div>

    <div class="my-4 text-center"><span class="math-block">P \\leftarrow W ^ {\\mu} \\cdot V ^ {\\gamma}, \\quad Q \\leftarrow W ^ {\\gamma} \\cdot V ^ {t _ {1 1}} \\cdot M \\cdot N \\cdot [ - \\mu t _ {1 0} ] _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">e (P, [ x ] _ {2}) \\cdot e (Q, [ 1 ] _ {2}) ^ {- 1} = e (E _ {P}, [ x ] _ {2}) \\cdot e (E _ {Q}, [ 1 ] _ {2}) ^ {- 1}.</span></div>

    <p class="text-gray-300">Note that the last verification can be checked with two pairings. Similar to the preprocessed linear Plonk relation, the verifier also needs to check  <span class="math">(\\lambda, \\gamma, v, \\bar{a}, \\bar{b}, \\bar{c}, \\bar{t}) = \\mathsf{Preprocess}_{\\mathsf{Q}}(\\mathsf{vk}_{\\mathsf{Plonk}}, u_{\\mathsf{Plonk}}, \\pi_{\\mathsf{Plonk}})</span>  for non-folded instances. However, for the folding scheme, the prover and verifier also need to fold  <span class="math">u_{\\mathsf{Plonk}}</span>  and  <span class="math">\\pi_{\\mathsf{Plonk}}</span>  parts as they are involved in the verification of the relaxed preprocessed quadratic Plonk proof relation.</p>

    <p class="text-gray-300">We describe the interactive version of the folding scheme. Given two preprocessed quadratic Plonk instances,  <span class="math">(\\lambda_1,\\gamma_1,v_1,\\bar{a}_1,\\bar{b}_1,\\bar{c}_1,\\bar{t}_1,u_{\\mathsf{Plonk},1},\\pi_{\\mathsf{Plonk},1})</span>  and  <span class="math">(\\lambda_{2},\\gamma_{2},v_{2},\\bar{a}_{2},\\bar{b}_{2},\\bar{c}_{2},\\bar{t}_{2},u_{\\mathsf{Plonk},2},\\pi_{\\mathsf{Plonk},2})</span>  where  <span class="math">\\bar{t}_i = (t_{1,i},\\dots,t_{11,i})</span>  for  <span class="math">i\\in \\{1,2\\}</span> , the prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  engage in the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> : Compute and send the cross-items  <span class="math">T_P</span>  and  <span class="math">T_Q</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">T _ {M} \\leftarrow A _ {1} ^ {v _ {2}} A _ {2} ^ {v _ {1}} \\cdot B _ {1} ^ {t _ {1, 2}} B _ {2} ^ {t _ {1, 1}} \\cdot C _ {1} ^ {t _ {2, 2}} C _ {2} ^ {t _ {2, 1}} \\cdot S _ {\\sigma_ {1}, 1} ^ {t _ {3, 2}} S _ {\\sigma_ {1}, 2} ^ {t _ {3, 1}} \\cdot S _ {\\sigma_ {2}, 1} ^ {t _ {4, 2}} S _ {\\sigma_ {2}, 2} ^ {t _ {4, 1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {N} \\leftarrow Q _ {M} ^ {\\bar {a} _ {1} \\bar {b} _ {2} + \\bar {a} _ {2} \\bar {b} _ {1}} \\cdot Q _ {L} ^ {\\mu_ {1} \\bar {a} _ {2} + \\mu_ {2} \\bar {a} _ {1}} \\cdot Q _ {R} ^ {\\mu_ {1} \\bar {b} _ {2} + \\mu_ {2} \\bar {b} _ {1}} \\cdot Q _ {O} ^ {\\mu_ {1} \\bar {c} _ {2} + \\mu_ {2} \\bar {c} _ {1}} \\cdot Q _ {C} ^ {2 \\mu_ {1} \\mu_ {2}} \\cdot Z _ {1} ^ {t _ {5, 2}} Z _ {2} ^ {t _ {5, 1}} \\cdot S _ {\\sigma_ {3}, 1} ^ {t _ {6, 2}} S _ {\\sigma_ {3}, 2} ^ {t _ {6, 1}} \\cdot T _ {l, 1} ^ {t _ {7, 2}} T _ {l, 2} ^ {t _ {7, 1}} \\cdot T _ {m i, 1} ^ {t _ {8, 2}} T _ {m i, 2} ^ {t _ {8, 1}} \\cdot T _ {h, 1} ^ {t _ {9, 2}} T _ {h, 2} ^ {t _ {9, 1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {P} \\leftarrow W _ {1} ^ {\\mu_ {2}} W _ {2} ^ {\\mu_ {1}} \\cdot V _ {1} ^ {\\gamma_ {2}} V _ {2} ^ {\\gamma_ {1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {Q} \\leftarrow W _ {1} ^ {\\gamma_ {2}} W _ {2} ^ {\\gamma_ {1}} \\cdot V _ {1} ^ {t _ {1 1, 2}} V _ {2} ^ {t _ {1 1, 1}} \\cdot T _ {M} \\cdot T _ {N} \\cdot [ - \\mu_ {1} t _ {1 0, 2} - \\mu_ {2} t _ {1 0, 1} ] _ {1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\rightarrow \\mathcal{P}</span>  : Sample and send a challenge  <span class="math">r\\gets \\S \\mathbb{Z}_p</span></li>

    </ol>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 6: Preprocess a Plonk proof into a quadratic relation.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  Compute the folded relaxed quadratic Plonk instance  <span class="math">(\\lambda^{<em>},\\gamma^{</em>},v^{<em>},</span> <span class="math">\\bar{a}^</em>,\\bar{b}^<em>,\\bar{c}^</em>,\\vec{t}^<em>,u_{\\mathrm{Plonk}}^</em>,\\pi_{\\mathrm{Plonk}}^<em>,\\mu^</em>,E_P^<em>,E_Q^</em>)</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\lambda^ {*} \\leftarrow \\lambda_ {1} + r \\cdot \\lambda_ {2}, \\quad \\gamma^ {*} \\leftarrow \\gamma_ {1} + r \\cdot \\gamma_ {2}, \\quad v ^ {*} \\leftarrow v _ {1} + r \\cdot v _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bar {a} ^ {*} \\leftarrow \\bar {a} _ {1} + r \\cdot \\bar {a} _ {2}, \\quad \\bar {b} ^ {*} \\leftarrow \\bar {b} _ {1} + r \\cdot \\bar {b} _ {2}, \\quad \\bar {c} ^ {*} \\leftarrow \\bar {c} _ {1} + r \\cdot \\bar {c} _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(u _ {\\text {P l o n k}} ^ {*}, \\pi_ {\\text {P l o n k}} ^ {*}\\right) \\leftarrow \\operatorname {L i n} \\left(\\left(u _ {\\text {P l o n k}, 1}, \\pi_ {\\text {P l o n k}, 1}\\right), \\left(u _ {\\text {P l o n k}, 2}, \\pi_ {\\text {P l o n k}, 2}\\right)\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vec {t} ^ {*} \\leftarrow \\vec {t} _ {1} + r \\cdot \\vec {t} _ {2}, \\quad \\mu^ {*} \\leftarrow \\mu_ {1} + r \\cdot \\mu_ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">E _ {P} ^ {*} \\leftarrow E _ {P, 1} \\cdot T _ {P} ^ {r} \\cdot E _ {P, 2} ^ {r ^ {2}}, \\quad E _ {Q} ^ {*} \\leftarrow E _ {Q, 1} \\cdot T _ {Q} ^ {r} \\cdot E _ {Q, 2} ^ {r ^ {2}},</span></div>

    <p class="text-gray-300">where  <span class="math">\\operatorname{Lin}</span>  is a function by conducting a scalar multiplication for each  <span class="math">\\mathbb{G}_1</span>  element and a linear combination for each  <span class="math">\\mathbb{Z}_p</span>  element (e.g.,  <span class="math">A^<em> = A_1 \\cdot A_2^r</span>  and  <span class="math">\\bar{z}_{\\omega}^{</em>} = \\bar{z}_{\\omega,1} + r \\cdot \\bar{z}_{\\omega,2}</span> ).</p>

    <p class="text-gray-300">Theorem 5. The construction of the 2-folding scheme for Plonk satisfies perfect completeness and knowledge soundness under the random oracle model.</p>

    <p class="text-gray-300">Proof Sketch. The perfect completeness and knowledge soundness of the protocol can be proved with an approach similar to the proof of Theorem 4. We present a formal proof in Appendix C.4.</p>

    <p class="text-gray-300">Non-uniform structure for Plonk. The folding scheme for quadratic Plonk relations can be extended to support non-uniform Plonk proofs of different structures. To achieve this, we introduce an additional step in  <span class="math">\\mathsf{Preprocess}_{\\mathbb{Q}}</span>  to compute  <span class="math">t_{12} \\gets \\bar{a} \\cdot \\bar{b}</span>  and return  <span class="math">t_{12}</span>  in  <span class="math">\\vec{t}</span> . The new relation is as follows:</p>

    <p class="text-gray-300">Definition 8 (Non-uniform Preprocessed Quadratic Plonk Relation).</p>

    <p class="text-gray-300">A non-uniform preprocessed quadratic Plonk proof relation consists of a structure <span class="math">([x]_2,\\mathsf{vk}_{\\mathsf{Plonk}})</span>, an instance <span class="math">(\\lambda ,\\gamma ,v,\\bar{a},\\bar{b},\\bar{c},\\bar{t},P,u_{\\mathsf{Plonk}},\\pi_{\\mathsf{Plonk}},\\mu ,E_P,E)</span>, and an empty witness <span class="math">\\perp</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">M \\leftarrow A ^ {v} \\cdot B ^ {t _ {1}} \\cdot C ^ {t _ {2}} \\cdot S _ {\\sigma_ {1}} ^ {t _ {3}} \\cdot S _ {\\sigma_ {2}} ^ {t _ {4}},</span></div>

    <div class="my-4 text-center"><span class="math-block">N \\leftarrow Q _ {M} ^ {t _ {1 2}} \\cdot Q _ {L} ^ {\\bar {a}} \\cdot Q _ {R} ^ {\\bar {b}} \\cdot Q _ {O} ^ {\\bar {c}} \\cdot Q _ {C} ^ {\\mu} \\cdot Z ^ {t _ {5}} \\cdot S _ {\\sigma_ {3}} ^ {t _ {6}} \\cdot T _ {l} ^ {t _ {7}} \\cdot T _ {m i} ^ {t _ {8}} \\cdot T _ {h} ^ {t _ {9}},</span></div>

    <div class="my-4 text-center"><span class="math-block">Q \\leftarrow W ^ {\\gamma} \\cdot V ^ {t _ {1 1}} \\cdot M \\cdot N \\cdot [ - \\mu t _ {1 0} ] _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">P ^ {- \\mu} \\cdot W ^ {\\mu} \\cdot V ^ {\\gamma} = E _ {P},</span></div>

    <div class="my-4 text-center"><span class="math-block">e (P, [ x ] _ {2}) \\cdot e (Q, [ 1 ] _ {2}) ^ {- 1} = E.</span></div>

    <p class="text-gray-300">We briefly describe the interactive version of the folding scheme for non-uniform Plonk proofs. Given two non-uniform preprocessed quadratic Plonk structure-instance-witness tuples <span class="math">\\left(([x_1]_2,\\mathsf{vk}_{\\mathsf{Plonk},1}),(\\lambda_1,\\gamma_1,v_1,\\bar{a}_1,\\bar{b}_1,\\bar{c}_1,\\bar{t}_1,P_1,u_{\\mathsf{Plonk},1},\\pi_{\\mathsf{Plonk},1},E_{P,1},E_1),\\perp\\right)</span> and <span class="math">\\left(([x_2]_2,\\mathsf{vk}_{\\mathsf{Plonk},2}),(\\lambda_2,\\gamma_2,v_2,\\bar{a}_2,\\bar{b}_2,\\bar{c}_2,\\bar{t}_2,P_2,u_{\\mathsf{Plonk},2},\\pi_{\\mathsf{Plonk},2},E_{P,2},E_2),\\perp\\right)</span>, the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> engage in the following protocol:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to \\mathcal{V}</span>: Compute and send the cross-items <span class="math">T_{P}</span> and <span class="math">T</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">T _ {M} \\leftarrow A _ {1} ^ {v _ {2}} A _ {2} ^ {v _ {1}} \\cdot B _ {1} ^ {t _ {1, 2}} B _ {2} ^ {t _ {1, 1}} \\cdot C _ {1} ^ {t _ {2, 2}} C _ {2} ^ {t _ {2, 1}} \\cdot S _ {\\sigma_ {1}, 1} ^ {t _ {3, 2}} S _ {\\sigma_ {1}, 2} ^ {t _ {3, 1}} \\cdot S _ {\\sigma_ {2}, 1} ^ {t _ {4, 2}} S _ {\\sigma_ {2}, 2} ^ {t _ {4, 1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {N} \\leftarrow Q _ {M, 1} ^ {t _ {1 2, 2}} Q _ {M, 2} ^ {t _ {1 2, 1}} \\cdot Q _ {L, 1} ^ {\\bar {a} _ {2}} Q _ {L, 2} ^ {\\bar {a} _ {1}} \\cdot Q _ {R, 1} ^ {\\bar {b} _ {2}} Q _ {R, 2} ^ {\\bar {b} _ {1}} \\cdot Q _ {O, 1} ^ {\\bar {c} _ {2}} Q _ {O, 2} ^ {\\bar {c} _ {1}} \\cdot Q _ {C, 1} ^ {\\mu_ {2}} Q _ {C, 2} ^ {\\mu_ {1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {Q} \\leftarrow W _ {1} ^ {\\gamma_ {2}} W _ {2} ^ {\\gamma_ {1}} \\cdot V _ {1} ^ {t _ {1 1, 2}} V _ {2} ^ {t _ {1 1, 1}} \\cdot T _ {M} \\cdot T _ {N} \\cdot [ - \\mu_ {1} t _ {1 0, 2} - \\mu_ {2} t _ {1 0, 1} ] _ {1},</span></div>

    <div class="my-4 text-center"><span class="math-block">T _ {P} \\leftarrow P _ {1} ^ {- \\mu_ {2}} P _ {2} ^ {- \\mu_ {1}} \\cdot W _ {1} ^ {\\mu_ {2}} W _ {2} ^ {\\mu_ {1}} \\cdot V _ {1} ^ {\\gamma_ {2}} V _ {2} ^ {\\gamma_ {1}},</span></div>

    <div class="my-4 text-center"><span class="math-block">T \\leftarrow e \\left(P _ {1}, [ x _ {2} ] _ {2}\\right) \\cdot e \\left(P _ {2}, [ x _ {2} ] _ {1}\\right) \\cdot e \\left(T _ {Q}, [ 1 ] _ {2}\\right) ^ {- 1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>: Sample and send a challenge <span class="math">r\\gets \\S \\mathbb{Z}_p</span></li>

      <li><span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>: Compute <span class="math">(\\lambda^{<em>},\\gamma^{</em>},v^{<em>},\\bar{a}^{</em>},\\bar{b}^{<em>},\\bar{c}^{</em>},\\bar{t}^{<em>},u_{\\mathrm{Plonk}}^{</em>},\\pi_{\\mathrm{Plonk}}^{<em>},\\mu^{</em>})</span> part using the same method as in the folding scheme for quadratic relations, and <span class="math">(P^{<em>},E_{P}^{</em>},E^{*})</span> part as</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">P ^ {*} \\leftarrow P _ {1} \\cdot P _ {2} ^ {r}, \\quad E _ {P} ^ {*} \\leftarrow E _ {P, 1} \\cdot T _ {P} ^ {r} \\cdot E _ {P, 2} ^ {r ^ {2}}, \\quad E ^ {*} \\leftarrow E _ {1} \\cdot T ^ {r} \\cdot E _ {2} ^ {r ^ {2}}.</span></div>

    <p class="text-gray-300">The perfect completeness and knowledge soundness of the non-uniform preprocessed quadratic plonk relation can be proved with an approach similar to the proof of Theorem 5. Therefore, we omit the detailed proof here due to the space constraints.</p>

    <p class="text-gray-300">5 Performance Evaluation</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.1 Theoretical Analysis</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first compare the performance of SnarkFold, TIPP <em>[10]</em>, and SnarkPack <em>[14]</em> in folding Groth16 proofs, as shown in Table 2. Group operations <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> indicate the scalar multiplication in the group. P indicates pairing operation, H indicates hash function, and RO indicates oracle query. The blue parts in this table represent the preprocessing (SF.VeriPrep) cost of SnarkFold and the instance aggregation cost of other methods. SNARK^{′}.P, SNARK^{′}.V and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\textsf{SNARK}^{{}^{\\prime}}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> stand for the proving time, verification time, and proof size of SNARK^{′}, respectively. SNARK^{′} is generated in the final step of IVC. </span>\\ell<span class="math"> represents the size of a Groth16 instance, which is a fixed value for a given circuit. In terms of proving/verification time, we ignore the cost of </span>\\mathbb{Z}_{p}<span class="math"> operations for simplicity as it only constitutes a minor overhead (except for the instance aggregation part). Notably, “RC” does not refer to the logic of the recursive circuit itself (the logic of the recursive circuit should be divided by </span>n<span class="math">). Among the three methods, our solution achieves a constant proof size, while the others are only logarithmic. Regarding proving cost, SnarkFold has the lowest local computation cost with only </span>2n<span class="math"> pairing operations, while TIPP and SnarkPack require </span>17n<span class="math"> and </span>21n<span class="math"> pairings, respectively. However, a SnarkFold prover necessitates additional steps to demonstrate that the computation has been correctly executed with a recursive circuit. In terms of verification time, the SnarkFold verifier is the most efficient. It verifies the delegation process by preprocessing with a cost of </span>n<span class="math"> H. However, TIPP requires </span>n\\ell<span class="math"> </span>\\mathbb{G}_{1}<span class="math"> operations for instance aggregation. SnarkPack needs </span>n\\ell<span class="math"> </span>\\mathbb{Z}_{p}<span class="math"> and </span>\\ell<span class="math"> </span>\\mathbb{G}_{1}<span class="math"> operations. Neither TIPP nor SnarkPack supports preprocessing. Besides, SnarkFold requires a constant online verification time, while TIPP and SnarkFold are logarithmic. Additionally, our committed version is expected to exhibit superior efficiency with large </span>\\ell$ values.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We further compare the performance of SnarkFold and aPlonk in folding Plonk proofs, as illustrated in Table 3. aPlonk employs additional parameters, <span class="math">\\zeta</span>, and <span class="math">\\eta</span>, to denote the sizes of the circuit and meta-verification circuit, respectively (for more details, refer to <em>[1]</em>). SnarkFold maintains a constant proof size, while aPlonk’s size is logarithmic. Snarkfold has a significant advantage in proof size, especially when the number of aggregated proofs is large. Regarding the proving time, both SnarkFold and aPlonk exhibit linear behavior. Specifically, SnarkFold does not require pairing operations but incurs the additional cost of the recursive circuit. We can employ quadratic preprocessing to reduce the number of <span class="math">\\mathbb{G}_{1}</span> operations from <span class="math">22n</span> to <span class="math">13n</span>. Moreover, if the proof is conducted over a cycle of elliptic curves, we can delegate <span class="math">\\mathbb{G}_{1}</span> operations to the other curve for enhanced efficiency, as demonstrated in Nova <em>[22]</em>. In terms of verification time, our scheme incurs a constant cost, while aPlonk’s time is logarithmic. Our SnarkFold can greatly reduce the verifier’s overhead in real-world applications. Moreover, our method supports instance preprocessing, while aPlonk does not support it and incurs an <span class="math">n\\ell\\log\\ell</span> complexity in <span class="math">\\mathbb{Z}_{p}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Table 2: Efficiency comparisons for Groth16 proof aggregation schemes. "LC" and "RC" are the total cost of local computation and recursive circuit when aggregating  <span class="math">n</span>  proofs. Group operations  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  in time columns) indicate the scalar multiplication in the group. P indicates pairing operation, H indicates hash function, and RO indicates oracle query. The blue parts represent SF.VeriPrep time of SnarkFold and the instance aggregation time of TIPP and SnarkPack.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">TIPP [10]</td>

            <td class="px-3 py-2 border-b border-gray-700">6 G1, 6 G2, (12 log n + 5) G_T</td>

            <td class="px-3 py-2 border-b border-gray-700">(2l + 10n) G1, 8n G2, (5n - 5) G_T, 1 H, 17n P</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">l G1, 12 log n G_T, 1 H, 18 P, n l G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkPack [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">7 G1, 6 G2, (12 log n + 5) G_T</td>

            <td class="px-3 py-2 border-b border-gray-700">(2n + 4 log n + 10) G1, 7n G2, (log n + 3) RO, 2 H, 21n P</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(l + 5) G1, 5 G2, 12 log n G_T, (log n + 3) RO, 2 H, 18 P, n l Zp, l G1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkFold (augmented)</td>

            <td class="px-3 py-2 border-b border-gray-700">(2l + 8) Zp, 7 G1, 1 G2, 1 G_T,</td>

            <td class="px-3 py-2 border-b border-gray-700">πSNARK'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LC</td>

            <td class="px-3 py-2 border-b border-gray-700">7n G1, n G2, n G_T, n RO, 2n P, SNARK'.P</td>

            <td class="px-3 py-2 border-b border-gray-700">(2l + 2) G1, 1 RO, 1 H, 5 P, SNARK'.V, n H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">RC</td>

            <td class="px-3 py-2 border-b border-gray-700">3n G1, n G_T, n RO, 2n H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkFold (committed)</td>

            <td class="px-3 py-2 border-b border-gray-700">9 G1, 1 G2, 1 G_T,</td>

            <td class="px-3 py-2 border-b border-gray-700">πSNARK'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LC</td>

            <td class="px-3 py-2 border-b border-gray-700">11n G1, n G2, n G_T, n RO, 2n P, SNARK'.P</td>

            <td class="px-3 py-2 border-b border-gray-700">(l + 2) G1, 1 RO, 1 H, 5 P, SNARK'.V, n H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">RC</td>

            <td class="px-3 py-2 border-b border-gray-700">6n G1, n G_T, n RO, 2n H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Efficiency comparisons for Plonk proof aggregation schemes. In aPlonk,  <span class="math">\\zeta</span>  represents the circuit size, and  <span class="math">\\eta = O(n + \\ell)</span>  denotes the size of the meta-verification circuit. The blue parts represent SF.VeriPrep time of SnarkFold and the instance aggregation time of aPlonk.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">aPlonk [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">19 Zp, 2 G2, (2 log2 3n + 10) G1, (2 log2 3n + 3) G_T</td>

            <td class="px-3 py-2 border-b border-gray-700">(3ζn + 6ζ + 3n + 9η + 20) G1, (3 log2 3n - 2) G2, (5 log2 3n + 2) P, (log2 3n + 10) H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">(2 log2 3n + 13) G1, (2 log2 3n) G_T, (log2 3n + 10) H, 4 P, n l log l Zp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkFold (linear)</td>

            <td class="px-3 py-2 border-b border-gray-700">4 Zp, 6 G1,</td>

            <td class="px-3 py-2 border-b border-gray-700">πSNARK'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LC</td>

            <td class="px-3 py-2 border-b border-gray-700">22n G1, 7n RO, SNARK'.P</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G1, 1 RO, 1 H, 2 P, SNARK'.V, n H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">RC</td>

            <td class="px-3 py-2 border-b border-gray-700">22n G1, 7n RO, 2n H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SnarkFold (quadratic)</td>

            <td class="px-3 py-2 border-b border-gray-700">(l + 25) Zp, 15 G1,</td>

            <td class="px-3 py-2 border-b border-gray-700">πSNARK'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">LC</td>

            <td class="px-3 py-2 border-b border-gray-700">50n G1, 7n RO, SNARK'.P</td>

            <td class="px-3 py-2 border-b border-gray-700">22 G1, 1 RO, 1 H, 2 P, SNARK'.V, n H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">RC</td>

            <td class="px-3 py-2 border-b border-gray-700">13n G1, 7n RO, 2n H</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 7: Efficiency comparisons for aPlonk and SnarkFold.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a></p>

    <p class="text-gray-300">We have implemented SnarkFold for Plonk in Rust based on Nova [27]. for Plonk in Rust based on Nova [27]. We adopt the BN254/Grumpkin [2], a half-pairing cycle of elliptic curves. For both random oracle and hash queries, we use Poseidon with 128-bit security [16], a hash function that is friendly to zero-knowledge proofs. The SNARK' in the final step is Spartan [28].</p>

    <p class="text-gray-300">We evaluate the performance of SnarkFold and aPlonk when folding  <span class="math">n</span>  Plonk proofs based on the BN254 curve. The experiments are conducted on a personal computer equipped with an Intel i7-12700KF CPU (3.6 GHz) and 32 GB of memory. The results are depicted in Figure 7. Our proof size remains constant (0.5 KB for the linear version and 1.74 KB for the quadratic version) while aPlonk increases logarithmically with the number of proofs. For the proving time, both SnarkFold and aPlonk scale linearly with the number of proofs, but SnarkFold performs about  <span class="math">10\\%</span>  to  <span class="math">20\\%</span>  better than aPlonk. Furthermore, our quadratic version performs about  <span class="math">10\\%</span>  better than the linear version, as we introduce fewer  <span class="math">\\mathbb{G}_1</span>  operations in the recursive circuit. However, this optimization is less significant as we use a cycle of elliptic curves in our implementation. If Plonk uses a curve that is different from our cycle curves, the optimization could reduce around  <span class="math">45\\%</span>  of the prover's cost. For the verification time, our solutions remain constant (around 2ms and 5ms, respectively), while aPlonk increases logarithmically. Besides, in aPlonk, the instance aggregation time becomes significant as the number of aggregations grows (e.g., 16ms for aggregating 4096 proofs). Our SnarkFold has more efficient pre-processing (2.9ms for aggregating 4096 instances), and the verifier only needs to perform one online verification. Therefore, both variants of SnarkFold consistently outperform aPlonk.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ambrona, M., Beunardeau, M., Schmitt, A.L., Toledo, R.R.: aPlonK: Aggregated PlonK from Multi-polynomial Commitment Schemes. IACR Cryptology ePrint Archive (2023), https://eprint.iacr.org/2022/1352</li>

      <li>[2] Aztec: Aztec Yellow Paper (2022), https://hackmd.io/@aztec-network/ByzgNxBfd</li>

      <li>[3] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent Succinct Arguments for R1CS. In: Proc. of the Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT). pp. 103–128. Springer (2019), https://doi.org/10.1007/978-3-030-17653-2_4</li>

      <li>[4] Boneh, D., Shoup, V.: A graduate course in applied cryptography. Draft 0.5 (2020)</li>

      <li>[5] Bowe, S., Chiesa, A., Green, M., Miers, I., Mishra, P., Wu, H.: Zexe: Enabling decentralized private computation. In: 2020 IEEE Symposium on Security and Privacy (S&P). pp. 947–964. IEEE (2020), https://doi.org/10.1109/SP40000.2020.00050</li>

      <li>[6] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short Proofs for Confidential Transactions and More. In: Proc. of the IEEE Symposium on Security and Privacy (S&P). pp. 315–334. IEEE (2018), https://doi.org/10.1109/SP.2018.00020</li>

      <li>[7] Bünz, B., Chen, B.: Protostar: Generic Efficient Accumulation/Folding for Special Sound Protocols. Proc. of the Annual International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT) (2023), https://doi.org/10.1007/978-981-99-8724-5_3</li>

      <li>[8] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-Carrying Data without Succinct Arguments. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 681–710. Springer (2021), https://doi.org/10.1007/978-3-030-84242-0_24</li>

      <li>[9] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Recursive Proof Composition from Accumulation Schemes. In: Proc. of the Theory of Cryptography Conference (TCC) (2020), https://doi.org/10.1007/978-3-030-64378-2_1</li>

      <li>[10] Bünz, B., Maller, M., Mishra, P., Tyagi, N., Vesely, P.: Proofs for Inner Pairing Products and Applications. In: Proc. of the Annual International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT). pp. 65–97. Springer (2021), https://doi.org/10.1007/978-3-030-92078-4_3</li>

      <li>[11] Chen, B., Bünz, B., Boneh, D., Zhang, Z.: Hyperplonk: Plonk with linear-time prover and high-degree custom gates. In: Proc. of the Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT). pp. 499–530. Springer (2023), https://doi.org/10.1007/978-3-031-30617-4_17</li>

      <li>[12] Eagen, L., Gabizon, A.: ProtoGalaxy: Efficient ProtoStar-style Folding of Multiple Instances. IACR Cryptology ePrint Archive (2023), https://eprint.iacr.org/2023/1106</li>

      <li>[13] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over Lagrange-bases for Oecumenical Noninteractive Arguments of Knowledge. IACR Cryptology ePrint Archive (2019), https://eprint.iacr.org/2019/953</li>

      <li>[14] Gailly, N., Maller, M., Nitulescu, A.: SnarkPack: Practical SNARK Aggregation. In: Proc. of the Financial Cryptography and Data Security (FC). pp. 203–229. Springer (2022), https://doi.org/10.1007/978-3-031-18283-9_10</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Golovnev, A., Lee, J., Setty, S., Thaler, J., Wahby, R.S.: Brakedown: Linear-time and field-agnostic snarks for r1cs. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 193–226. Springer (2023), https://doi.org/10.1007/978-3-031-38545-2_7</li>

      <li>[16] Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In: Proc. of the USENIX Security Symposium (Security). pp. 519–535 (2021)</li>

      <li>[17] Groth, J.: On the Size of Pairing-based Non-interactive Arguments. In: Proc. of the Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT). pp. 305–326. Springer (2016), https://doi.org/10.1007/978-3-662-49896-5_11</li>

      <li>[18] Hopwood, D., Bowe, S., Hornby, T., Wilcox, N., et al.: Zcash Protocol Specification. GitHub: San Francisco, CA, USA 4(220), 32 (2016)</li>

      <li>[19] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size Commitments to Polynomials and their Applications. In: Proc. of the Annual International Conference on the Theory and Application of Cryptology and Information Security (ASIACRYPT). pp. 177–194. Springer (2010), https://doi.org/10.1007/978-3-642-17373-8_11</li>

      <li>[20] Kothapalli, A., Setty, S.: SuperNova: Proving Universal Machine Executions without Universal Circuits. IACR Cryptology ePrint Archive (2022), https://eprint.iacr.org/2022/1758</li>

      <li>[21] Kothapalli, A., Setty, S.: Hypernova: Recursive arguments for customizable constraint systems. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 345–379. Springer (2024), https://doi.org/10.1007/978-3-031-68403-6_11</li>

      <li>[22] Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive Zero-knowledge Arguments from Folding Schemes. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 359–388. Springer (2022), https://doi.org/10.1007/978-3-031-15985-5_13</li>

      <li>[23] Labs, P.: Filecoin (2018), https://filecoin.io/filecoin.pdf</li>

      <li>[24] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly Practical Verifiable Computation. Communications of the ACM 59(2), 103–112 (2016), https://doi.org/10.1109/SP.2013.47</li>

      <li>[25] Polygon: Polygon zkEVM, https://github.com/0xpolygonhermez</li>

      <li>[26] Sasson, E.B., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized Anonymous Payments from Bitcoin. In: Proc. of the IEEE Symposium on Security and Privacy (S&P). pp. 459–474. IEEE (2014), https://doi.org/10.1109/SP.2014.36</li>

      <li>[27] Setty, S.: Nova project, https://github.com/microsoft/Nova</li>

      <li>[28] Setty, S.: Spartan: Efficient and General-purpose zkSNARKs without Trusted Setup. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 704–737. Springer (2020), https://doi.org/10.1007/978-3-030-56877-1_25</li>

      <li>[29] Srinivasan, S., Karantaidou, I., Baldimtsi, F., Papamanthou, C.: Batching, Aggregation, and Zero-Knowledge Proofs in Bilinear Accumulators. In: Proc. of the ACM Conference on Computer & Communications Security (CCS). pp. 2719–2733 (2022), https://doi.org/10.1145/3548606.3560676</li>

      <li>[30] Sun, Y.: zkPairing (2023), https://github.com/yi-sun/circom-pairing#benchmarks</li>

      <li>[31] Tech., S.: Scroll (2023), https://github.com/scroll-tech</li>

      <li>[32] Valiant, P.: Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency. In: Proc. of the Theory of Cryptography Conference (TCC). pp. 1–18. Springer (2008), https://doi.org/10.1007/978-3-540-78524-8_1</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wood, G.: Ethereum: A Secure Decentralised Generalised Transaction Ledger. Ethereum project yellow paper 151(2014), 1–32 (2014)</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>34. Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct Zero-knowledge Proofs with Optimal Prover Computation. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 733–764. Springer (2019), https://doi.org/10.1007/978-3-030-26954-8_24</li>

      <li>35. Xie, T., Zhang, Y., Song, D.: Orion: Zero knowledge proof with linear prover time. In: Proc. of the Annual International Cryptology Conference (CRYPTO). pp. 299–328. Springer (2022), https://doi.org/10.1007/978-3-031-15985-5_11</li>

      <li>36. Zheng, T., Gao, S., Guo, Y., Xiao, B.: KiloNova: Non-Uniform PCD with Zero-Knowledge Property from Generic Folding Schemes. IACR Cryptology ePrint Archive (2023), https://eprint.iacr.org/2023/1579</li>

    </ul>

    <p class="text-gray-300">Definition 9 (Perfect Completeness). A SNARK satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\text {S N A R K . V} (\\mathsf {v k}, u, \\pi) = 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\text {S N A R K . G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\text {S N A R K . K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\text {S N A R K . P} (\\mathsf {p k}, u, w) \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 10 (Knowledge Soundness). A SNARK satisfies knowledge soundness if for all PPT adversaries  <span class="math">\\mathcal{A}</span>  there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  such that for any randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\text {S N A R K . V} (\\mathsf {v k}, u, \\pi) = 1, \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\notin \\mathcal {R} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\text {S N A R K . G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}; \\rho), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\text {S N A R K . K} (\\mathsf {p p}, \\mathsf {s}), \\\\ w \\leftarrow \\mathcal {E} (\\mathsf {p p}; \\rho) \\end{array} \\right. \\right] = \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 11 (Succinctness). A SNARK system is succinct if the size of the SNARK proof  <span class="math">\\pi</span>  is poly-logarithmic in the size of the witness  <span class="math">w</span> .</p>

    <p class="text-gray-300">Definition 12 (Zero-Knowledge). A  <span class="math">zk</span> -SNARK satisfies zero-knowledge if there exists PPT simulator  <span class="math">\\mathcal{S}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s}, u, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {S N A R K . G} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {S N A R K . K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\mathsf {S N A R K . P} (\\mathsf {p k}, u, w) \\end{array} \\right. \\end{array} \\right. \\approx \\right. \\\\ \\left\\{ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s}, u, \\pi) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {p p}, \\tau) \\leftarrow \\mathcal {S} (1 ^ {\\lambda}), \\\\ (\\mathsf {s}, (u, w)) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p p}, \\mathsf {s}, u, w) \\in \\mathcal {R}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {S N A R K . K} (\\mathsf {p p}, \\mathsf {s}), \\\\ \\pi \\leftarrow \\mathcal {S} (\\mathsf {p p}, u, \\tau) \\end{array} \\right. \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 13 (Perfect Completeness). A proof aggregation scheme for SNARK (with proving key  <span class="math">\\mathsf{pk}_{\\mathsf{SNARK}}</span>  and verification key  <span class="math">\\mathsf{pk}_{\\mathsf{SNARK}}</span> ) satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\mathsf {A G G . V} (\\mathsf {v k}, n, (u _ {i}) _ {i = 1} ^ {n}, \\pi^ {*}, \\pi_ {\\mathsf {A G G}}) = 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {A G G . G} (1 ^ {\\lambda}), \\\\ (u _ {i}, \\pi_ {i}) _ {i = 1} ^ {n} \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ \\mathsf {S N A R K . V} (\\mathsf {v k} _ {\\mathsf {S N A R K}}, u _ {i}, \\pi_ {i}) = 1, \\\\ \\forall i \\in \\{1, \\dots , n \\}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {A G G . K} (\\mathsf {p p}), \\\\ (\\pi^ {*}, \\pi_ {\\mathsf {A G G}}) \\leftarrow \\mathsf {A G G . P} \\big (\\mathsf {p k}, (u _ {i}, \\pi_ {i}) _ {i = 1} ^ {n} \\big) \\end{array} \\right] = 1, \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 14 (Knowledge Soundness). A proof aggregation satisfies knowledge soundness if for all PPT adversaries  <span class="math">\\mathcal{A}</span>  and any randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\mathsf {A G G . V} (\\mathsf {v k}, n, (u _ {i}) _ {i = 1} ^ {n}, \\pi^ {*}, \\pi_ {\\mathsf {A G G}}) = 1, \\\\ \\exists i s. t \\mathsf {S N A R K . V} (\\mathsf {v k} _ {\\mathsf {S N A R K}}, u _ {i}, \\pi_ {i}) = 0 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {A G G . G} (1 ^ {\\lambda}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {A G G . K} (\\mathsf {p p}), \\\\ ((u _ {i}) _ {i = 1} ^ {n}, \\pi^ {*}, \\pi_ {\\mathsf {A G G}}) \\leftarrow \\mathcal {A} (\\mathsf {p p}, \\mathsf {p k}; \\rho), \\\\ (\\pi_ {i}) _ {i = 1} ^ {n} \\leftarrow \\mathcal {E} (\\mathsf {p p}, u; \\rho) \\end{array} \\right. \\right] = \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 15 (Perfect Completeness). An IVC satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\mathsf {I V C . V} (\\mathsf {v k}, i, \\\\ z _ {0}, z _ {i}, \\pi_ {i}) = 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {I V C . G} (1 ^ {\\lambda}), \\\\ (F, (i, z _ {0}, z _ {i}, z _ {i - 1}, \\omega_ {i - 1}, \\pi_ {i - 1})) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {I V C . K} (\\mathsf {p p}, F), \\\\ z _ {i} = F (z _ {i - 1}, \\omega_ {i - 1}), \\\\ \\mathsf {I V C . V} (\\mathsf {v k}, i - 1, z _ {0}, z _ {i - 1}, \\pi_ {i - 1}) = 1, \\\\ \\pi_ {i} \\leftarrow \\mathsf {I V C . P} (\\mathsf {p k}, i, z _ {0}, z _ {i}, z _ {i - 1}, \\omega_ {i - 1}, \\pi_ {i - 1}) \\end{array} \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 16 (Knowledge Soundness). An IVC satisfies knowledge soundness if for any constant  <span class="math">n \\in \\mathbb{N}</span>  and all expected PPT adversaries  <span class="math">\\mathcal{A}</span>  there exists an expected PPT extractor  <span class="math">\\mathcal{E}</span>  such that for any randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} z _ {n} \\neq z, \\\\ \\mathsf {I V C . V} (\\mathsf {v k}, n, \\\\ z _ {0}, z, \\pi) = 1 \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {I V C . G} (1 ^ {\\lambda}), \\\\ (F, (z _ {0}, z, \\pi)) \\leftarrow \\mathcal {A} (\\mathsf {p p}; \\rho), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {I V C . K} (\\mathsf {p p}, F), \\\\ (\\omega_ {0}, \\dots , \\omega_ {n - 1}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, z _ {0}, z; \\rho), \\\\ z _ {i} = F (z _ {i - 1}, \\omega_ {i - 1}) \\quad \\forall i \\in \\{1, \\dots , n \\} \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 17 (Succinctness). An IVC is succinct if the size of the IVC proof  <span class="math">\\pi_{n}</span>  does not grow with the number of iterations  <span class="math">n</span> .</p>

    <p class="text-gray-300">Consider a folding scheme between the prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span> . Let  <span class="math">(u, w) \\gets \\langle \\mathcal{P}(\\mathsf{pk}, w_1, w_2), \\mathcal{V}(\\mathsf{vk}) \\rangle (u_1, u_2)</span>  denote the verifier's output instance  <span class="math">u</span>  and the prover's output witness  <span class="math">w</span>  from the interaction of the folding scheme on instance-witnesses pairs  <span class="math">(w_1, u_1)</span>  and  <span class="math">(w_2, u_2)</span> , prover key  <span class="math">\\mathsf{pk}</span> , and verifier key  <span class="math">\\mathsf{vk}</span> . The following definitions can also be generalized to multiple folding.</p>

    <p class="text-gray-300">Definition 18 (Perfect Completeness). A folding scheme satisfies perfect completeness if for any PPT adversary  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\begin{array}{l} \\text {(p p , s , u , w) \\in \\mathcal {R}} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\text {p p} \\leftarrow \\text {F o l d . G (1 ^ {\\lambda}),} \\\\ \\text {(s , (u _ {1} , w _ {1}), (u _ {2} , w _ {2})) \\leftarrow \\mathcal {A} (\\text {p p}),} \\\\ \\text {(p p , s , u _ {1} , w _ {1}), (p p , s , u _ {2} , w _ {2}) \\in \\mathcal {R},} \\\\ \\text {(p k , v k) \\leftarrow F o l d . K (p p , s),} \\\\ \\text {(u , w) \\leftarrow \\langle \\mathcal {P} (\\text {p k} , w _ {1} , w _ {2}), \\mathcal {V} (\\text {v k}) \\rangle (u _ {1} , u _ {2})} \\end{array} \\right. \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Definition 19 (Knowledge Soundness). A folding scheme satisfies knowledge soundness if for all expected PPT adversaries  <span class="math">\\mathcal{A}</span> , there exists an expected PPT extractor  <span class="math">\\mathcal{E}</span>  such that for any randomness  <span class="math">\\rho</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr \\left[ \\begin{array}{l} \\text {(p p , s , u , w) \\in \\mathcal {R}} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\text {p p} \\leftarrow \\text {F o l d . G (1 ^ {\\lambda}),} \\\\ \\text {(s , (u _ {1} , u _ {2})) \\leftarrow \\mathcal {A} (\\text {p p ;} \\rho),} \\\\ \\text {(p k , v k) \\leftarrow F o l d . K (p p , s),} \\\\ \\text {(u , w) \\leftarrow \\langle \\mathcal {A} (\\text {p k ;} \\rho), \\mathcal {V} (\\text {v k}) \\rangle (u _ {1} , u _ {2})} \\end{array} \\right. \\right] - \\right. \\\\ \\Pr \\left[ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s}, u _ {1}, w _ {1}) \\in \\mathcal {R}, \\\\ (\\mathsf {p p}, \\mathsf {s}, u _ {2}, w _ {2}) \\in \\mathcal {R} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathsf {F o l d . G (1 ^ {\\lambda}),} \\\\ (\\mathsf {s}, (u _ {1}, u _ {2})) \\leftarrow \\mathcal {A} (\\mathsf {p p}; \\rho), \\\\ (w _ {1}, w _ {2}) \\leftarrow \\mathcal {E} (\\mathsf {p p}; \\rho) \\end{array} \\right. \\right] \\leq \\mathsf {n e g l} (\\lambda). \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Groth16 describes the circuit constraints as  <span class="math">\\mathcal{R}</span> , which is defined over the public parameters  <span class="math">\\mathsf{pp} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e, g, h)</span> , structure  <span class="math">\\mathsf{s} = \\big(\\ell, (u_i(X), v_i(X), w_i(X))_{i=1}^m, t(X)\\big)</span> , instance  <span class="math">u = (a_1, \\dots, a_\\ell) \\in \\mathbb{Z}_p^\\ell</span>  and witness  <span class="math">w = (a_{\\ell+1}, \\dots, a_m) \\in \\mathbb{Z}_p^{m-\\ell}</span>  with  <span class="math">a_0 = 1</span> , such that  <span class="math">\\sum_{i=0}^m a_i u_i(X) \\cdot \\sum_{i=0}^m a_i v_i(X) = \\sum_{i=0}^m a_i w_i(X) + h(X)t(X)</span>  for some  <span class="math">(n-2)</span> -degree quotient polynomial  <span class="math">h(X)</span> , where  <span class="math">n</span>  is the degree of  <span class="math">t(X)</span> .</p>

    <p class="text-gray-300">In Groth16.K, crs is set as follows with randomly sampled  <span class="math">\\alpha, \\beta, \\gamma, \\delta, x \\gets \\mathbb{Z}_p^*</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left([ \\alpha ] _ {1}, [ \\beta ] _ {1}, [ \\beta ] _ {2}, [ \\gamma ] _ {2}, [ \\delta ] _ {1}, [ \\delta ] _ {2}, \\left([ x ^ {i} ] _ {1}, [ x ^ {i} ] _ {2}\\right) _ {i = 0} ^ {n - 1}, \\left(\\left[ \\frac {x ^ {i} t (x)}{\\delta} \\right] _ {1}\\right) _ {i = 0} ^ {n - 1}, \\right. \\\\ \\left(\\left[ \\frac {\\beta u _ {i} (x) + \\alpha v _ {i} (x) + w _ {i} (x)}{\\gamma} \\right] _ {1}\\right) _ {i = 0} ^ {\\ell}, \\left(\\left[ \\frac {\\beta u _ {i} (x) + \\alpha v _ {i} (x) + w _ {i} (x)}{\\delta} \\right] _ {1}\\right) _ {i = \\ell + 1} ^ {m}\\left. \\right). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In Groth16.P, <span class="math">A, B, C</span> is computed as follows with randomly sampled <span class="math">r, s \\gets \\mathbb{Z}_p</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A = \\left[ \\alpha + \\sum_{i = 0}^{m} a_{i} u_{i}(x) + r \\delta \\right]_{1}, \\quad B = \\left[ \\beta + \\sum_{i = 0}^{m} a_{i} v_{i}(x) + s \\delta \\right]_{2}, \\\\ C = \\left[ \\frac{\\sum_{i = \\ell + 1}^{m} a_{i} \\left(\\beta u_{i}(x) + \\alpha v_{i}(x) + w_{i}(x)\\right) + h(x) t(x)}{\\delta} + s \\left(\\alpha + \\sum_{i = 0}^{m} a_{i} u_{i}(x)\\right) + r \\left(\\beta + \\sum_{i = 0}^{m} a_{i} v_{i}(x)\\right) + r s \\delta \\right]_{1}. \\end{array}</span></div>

    <p class="text-gray-300">In Groth16.V, <span class="math">D</span> is computed as <span class="math">D = e([\\alpha]_1, [\\beta]_2)</span>. The verifier checks</p>

    <div class="my-4 text-center"><span class="math-block">e(A, B) \\stackrel{?}{=} e(C, [\\delta]_2) \\cdot e\\left(\\prod_{i = 0}^{\\ell} S_{i}^{a_{i}}, [\\gamma]_{2}\\right) \\cdot D.</span></div>

    <h2 id="sec-32" class="text-2xl font-bold">B.2 Plonk</h2>

    <p class="text-gray-300">Plonk describes the circuit as a Plonkish relation <span class="math">\\mathcal{R}</span>, which is defined over the public parameters <span class="math">\\mathsf{pp} = (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, p, e, g, h)</span>, structure <span class="math">\\mathsf{s} = (\\ell, \\mathbb{H}, \\omega, q_L(X), q_R(X), q_M(X), q_O(X), q_C(X), \\sigma(X))</span>, instance <span class="math">(u_i)_{i=1}^{\\ell} \\in \\mathbb{Z}_p^\\ell</span>, and witness <span class="math">(a_i)_{i=1}^m</span>, <span class="math">(b_i)_{i=1}^m</span>, <span class="math">(c_i)_{i=1}^m \\in \\mathbb{Z}_p^m</span> such that</p>

    <p class="text-gray-300">$$ \\begin{array}{l} f_{a}(X) f_{b}(X) q_{M}(X) + f_{a}(X) q_{L}(X) + f_{b}(X) q_{R}(X) + f_{c}(X) q_{O}(X) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(u(X) + q_{C}(X)) = z_{H}(X) h(X); \\quad \\text{and} \\quad f(X) = f(\\sigma(X)),</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">f_{a}(X), f_{b}(X), f_{c}(X), u(X)</span> are polynomials derived by Lagrange interpolations on <span class="math">(a_{i})_{i=1}^{m}</span>, <span class="math">(b_{i})_{i=1}^{m}</span>, <span class="math">(c_{i})_{i=1}^{m}</span>, and <span class="math">(u_{i})_{i=1}^{\\ell}</span> respectively, <span class="math">f(X)</span> is a polynomial derived by a Lagrange interpolation on <span class="math">(a_{1}, \\dots, a_{m}, b_{1}, \\dots, b_{m}, c_{1}, \\dots, c_{m})</span>, <span class="math">z_{H}(X) = X^{m} - 1</span>, and <span class="math">h(X)</span> is a quotient polynomial.</p>

    <p class="text-gray-300"><strong>Setup.</strong> In Plonk.K, the common input <span class="math">\\mathsf{srs}</span> is set to <span class="math">([1]_1, [x]_1, [x^2]_1, \\dots, [x^{m+5}]_1, [1]_2, [x]_2)</span>. Define <span class="math">\\mathbb{H}&#x27; = \\mathbb{H} \\cup k_1 \\mathbb{H} \\cup k_2 \\mathbb{H}</span> and a permutation <span class="math">\\sigma^*</span> from <span class="math">\\{1, \\dots, 3m\\}</span> to <span class="math">\\mathbb{H}&#x27;</span> derived from applying <span class="math">\\sigma</span> and an injective mapping <span class="math">i \\to \\omega^i, n + i \\to k_1 \\omega^i, 2n + i \\to k_2 \\omega^i</span>. The proving key <span class="math">\\mathsf{pk}</span> and the verification key <span class="math">\\mathsf{vk}</span> are set to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{pk} = \\left(q_{L}(X), q_{R}(X), q_{M}(X), q_{O}(X), q_{C}(X), s_{\\sigma_{1}}(X), s_{\\sigma_{2}}(X), s_{\\sigma_{3}}(X)\\right), \\\\ \\mathsf{vk} = \\left(Q_{L}, Q_{R}, Q_{M}, Q_{O}, Q_{C}, S_{\\sigma_{1}}, S_{\\sigma_{2}}, S_{\\sigma_{3}}, m\\right), \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">s_{\\sigma_1}(X), s_{\\sigma_2}(X), s_{\\sigma_3}(X)</span> are derived by Lagrange interpolation. <span class="math">Q_L = [q_L(x)]_1</span>, <span class="math">Q_R = [q_R(x)]_1</span>, <span class="math">Q_M = [q_M(x)]_1</span>, <span class="math">Q_O = [q_O(x)]_1</span>, <span class="math">Q_C = [q_C(x)]_1</span>, <span class="math">S_{\\sigma_1} = [s_{\\sigma_1}(x)]_1</span>, <span class="math">S_{\\sigma_2} = [s_{\\sigma_2}(x)]_1</span>, <span class="math">S_{\\sigma_3} = [s_{\\sigma_3}(x)]_1</span>.</p>

    <p class="text-gray-300"><strong>Proving.</strong> The prover conducts the following computations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute wire polynomials <span class="math">a(X), b(X), c(X)</span> and commitments <span class="math">A, B, C</span>. Compute challenges <span class="math">\\beta, \\theta</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a quadratic polynomial <span class="math">r_p(X) \\gets \\mathbb{Z}_p^2[X]</span> and compute the permutation polynomial <span class="math">z(X) = r_p(X) \\cdot z_H(X) + p(X)</span> to prove the copy constraints, where <span class="math">p(X)</span> is a polynomial derived by a Lagrange interpolation on <span class="math">(1, p_1, \\dots, p_{m-1})</span> and <span class="math">p_i =</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\prod_{j=1}^{i} \\frac{(a_j + \\beta \\omega^j + \\theta)(b_j + \\beta k_1 \\omega^j + \\theta)(c_j + \\beta k_2 \\omega^j + \\theta)}{(a_j + \\beta s_{\\sigma_1}(\\omega^j) + \\theta)(b_j + \\beta s_{\\sigma_2}(\\omega^j) + \\theta)(c_j + \\beta s_{\\sigma_3}(\\omega^j) + \\theta)}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the commitment <span class="math">Z = [z(x)]_1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenge <span class="math">\\alpha</span> and polynomial <span class="math">t(X)</span>:</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} t(X) z_H(X) = \\\\ a(X) b(X) q_M(X) + a(X) q_L(X) + b(X) q_R(X) + c(X) q_O(X) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>u(X) + q_C(X) + \\alpha \\left[ (a(X) + \\beta X + \\theta)(b(X) + \\beta k_1 X + \\theta) \\right. \\\\</li>

    </ul>

    <p class="text-gray-300">\\left. (c(X) + \\beta k_2 X + \\theta) \\right] z(X) - \\alpha \\left[ (a(X) + \\beta s_{\\sigma 1}(X) + \\theta) \\right. \\\\ \\left. (b(X) + \\beta s_{\\sigma 2}(X) + \\theta)(c(X) + \\beta s_{\\sigma 3}(X) + \\theta) \\right] z(X \\omega) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\alpha^2 (z(X) - 1) L_1(X).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Split <span class="math">t(X)</span> into <span class="math">t_l(X), t_{mi}(X), t_h(X)</span>, where each polynomial has a degree less than <span class="math">n</span> such that <span class="math">t(X) = t_l(X) + X^m \\cdot t_{mi}(X) + X^{2m} \\cdot t_h(X)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute commitments <span class="math">T_l = [t_l(x)]_1</span>, <span class="math">T_{mi} = [t_{mi}(x)]_1</span> and <span class="math">T_h = [t_h(x)]_1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenge <span class="math">\\lambda = \\mathrm{Hash}(\\alpha, T_l, T_{mi}, T_h)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening evaluations <span class="math">\\bar{a} = a(\\lambda)</span>, <span class="math">\\bar{b} = b(\\lambda)</span>, <span class="math">\\bar{c} = c(\\lambda)</span>, <span class="math">\\bar{s}_{\\sigma_1} = s_{\\sigma_1}(\\lambda)</span>, <span class="math">\\bar{s}_{\\sigma_2} = s_{\\sigma_2}(\\lambda)</span> and <span class="math">\\bar{z}_{\\omega} = z(\\lambda \\omega)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenge <span class="math">v = \\mathrm{Hash}(\\lambda, \\bar{a}, \\bar{b}, \\bar{c}, \\bar{s}_{\\sigma_1}, \\bar{s}_{\\sigma_2}, \\bar{z}_{\\omega})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute linearisation polynomial:</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} r(X) = \\bar{a} \\bar{b} \\cdot q_M(X) + \\bar{a} \\cdot q_L(X) + \\bar{b} \\cdot q_R(X) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\bar{c} \\cdot q_O(X) + u(\\lambda) + q_C(X) \\\\</li>

      <li>\\alpha \\left[ (\\bar{a} + \\beta \\lambda + \\theta)(\\bar{b} + \\beta k_1 \\lambda + \\theta)(\\bar{c} + \\beta k_2 \\lambda + \\theta) \\right] z(X) \\\\</li>

      <li>\\alpha \\left[ (\\bar{a} + \\beta \\bar{s}_{\\sigma_1} + \\theta)(\\bar{b} + \\beta \\bar{s}_{\\sigma_2} + \\theta)(\\bar{c} + \\beta s_{\\sigma_3}(X) + \\theta) \\right] \\bar{z}_{\\omega} \\\\</li>

      <li>\\alpha^2 (z(X) - 1) L_1(\\lambda) - z_H(\\lambda) \\left( t_l(X) + \\lambda^m t_{mi}(X) + \\lambda^{2m} t_h(X) \\right).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening proof polynomial <span class="math">w(X)</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">w(X) = \\frac{1}{X - \\lambda} \\begin{pmatrix} r(X) + v(a(X) - \\bar{a}) \\\\ + v^2(b(X) - \\bar{b}) + v^3(c(X) - \\bar{c}) \\\\ + v^4(s_{\\sigma_1}(X) - \\bar{s}_{\\sigma_1}) + v^5(s_{\\sigma_2}(X) - \\bar{s}_{\\sigma_2}) \\end{pmatrix}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute opening proof polynomial <span class="math">v(X) = \\frac{v(X) - \\bar{z}_{\\omega}}{X - \\lambda \\omega}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute commitments <span class="math">W = [w(x)]_1</span>, <span class="math">V = [v(x)]_1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return Plonk proof <span class="math">\\pi = (A, B, C, Z, T_l, T_{mi}, T_h, W, V, \\bar{a}, \\bar{b}, \\bar{c}, \\bar{s}_{\\sigma_1}, \\bar{s}_{\\sigma_2}, \\bar{z}_{\\omega})</span>.</li>

    </ol>

    <p class="text-gray-300">Verification The verifier performs as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute challenges <span class="math">\\beta, \\theta, \\alpha, \\lambda, v, \\gamma \\in \\mathbb{Z}_p</span>, and evaluations <span class="math">u(\\lambda), z_H(\\lambda), L_1(\\lambda)</span>.</li>

      <li>Compute polynomial <span class="math">r(X)</span>'s constant term <span class="math">r_0 = u(\\lambda) - \\alpha (\\bar{a} + \\beta \\bar{s}_{\\sigma_1} + \\theta)(\\bar{b} + \\beta \\bar{s}_{\\sigma_2} + \\theta)(\\bar{c} + \\theta)\\bar{z}_\\omega - \\alpha^2 L_1(\\lambda)</span>.</li>

      <li>Compute batched commitment <span class="math">M, N, F \\in \\mathbb{G}_1</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">M = A^v \\cdot B^{v^2} \\cdot C^{v^3} \\cdot (S_{\\sigma_1})^{v^4} \\cdot (S_{\\sigma_2})^{v^5},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} N &amp;amp;= (Q_M)^{\\bar{a}\\bar{b}} \\cdot (Q_L)^{\\bar{a}} \\cdot (Q_R)^{\\bar{b}} \\cdot (Q_O)^{\\bar{c}} \\cdot Q_C \\\\ &amp;amp;\\quad \\cdot (Z)^{\\alpha (\\bar{a} + \\beta \\lambda + \\theta) (\\bar{b} + \\beta k_1 \\lambda + \\theta) (\\bar{c} + \\beta k_2 \\lambda + \\theta) + \\alpha^2 L_1 (\\lambda) + \\gamma} \\\\ &amp;amp;\\quad \\cdot (S_{\\sigma 3})^{-\\alpha (\\bar{a} + \\beta \\bar{s}_{\\sigma 1} + \\theta) (\\bar{b} + \\beta \\bar{s}_{\\sigma 2} + \\theta) \\beta \\bar{z}_\\omega} \\\\ &amp;amp;\\quad \\cdot (T_l)^{-Z_H(\\lambda)} \\cdot (T_{mi})^{-z_H(\\lambda) \\cdot \\lambda^m} \\cdot (T_h)^{-z_H(\\lambda) \\cdot \\lambda^{2m}}, \\end{aligned}</span></div>

    <div class="my-4 text-center"><span class="math-block">F = \\left[ -r_0 + v \\cdot \\bar{a} + v^2 \\cdot \\bar{b} + v^3 \\cdot \\bar{c} + v^4 \\cdot \\bar{s}_{\\sigma_1} + v^5 \\cdot \\bar{s}_{\\sigma_2} + \\gamma \\cdot \\bar{z}_\\omega \\right]_1.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">e \\left(W \\cdot V^\\gamma, [x]_2\\right) \\stackrel{?}{=} e \\left(W^\\lambda \\cdot V^{\\gamma \\lambda \\omega} \\cdot M \\cdot N \\cdot F^{-1}, [1]_2\\right).</span></div>

    <h2 id="sec-33" class="text-2xl font-bold">C Formal Proofs</h2>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">C.1 Lemmas</h3>

    <p class="text-gray-300"><strong>Lemma 1 (Forking Lemma for Folding Schemes [22]).</strong> Consider a <span class="math">(2k + 1)</span>-move folding scheme <span class="math">\\mathsf{Fold} = (\\mathsf{G};\\mathsf{K};\\mathsf{P};\\mathsf{V})</span>. Fold satisfies knowledge soundness if there exists a PPT <span class="math">\\mathcal{E}</span> such that for all input instance pairs <span class="math">(u_1;u_2)</span>, outputs satisfying witnesses <span class="math">(w_{1};w_{2})</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, given public parameters <span class="math">\\mathsf{pp}</span>, a structure <span class="math">\\mathsf{s}</span>, and an <span class="math">(n_{1},\\dots,n_{k})</span>-tree of accepting transcripts and the corresponding folded instance-witness pairs <span class="math">(u;w)</span>. This tree comprises <span class="math">n_1</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in the verifier's first message, and for each such transcript, <span class="math">n_2</span> transcripts (and the corresponding instance-witness pairs) with fresh randomness in the verifier's second message; etc., for a total of <span class="math">\\prod_{i=1}^{k} n_i</span> leaves bounded by <span class="math">\\mathsf{poly}(\\lambda)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Binding property of SF.VeriPrep.).</strong> The preprocessing algorithm SF.VeriPrep satisfies the binding property. Concretely, for all probabilistic polynomial time adversary <span class="math">\\mathcal{A}</span>, the following probability is negligible assuming that Hash is a collision-resistant hash function,</p>

    <p class="text-gray-300">$$ \\Pr \\left[ \\begin{array}{l} h = h', \\\\ \\exists j, \\text{s.t., } u_j \\neq u_j'</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array} \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{pp} \\leftarrow \\mathsf{SF}. \\mathsf{G}(1^\\lambda), \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathsf{SF}. \\mathsf{K}(\\mathsf{pp}, s'), \\\\ (u_i)_{i=1}^n, (u_i')_{i=1}^n \\leftarrow \\mathcal{A}(\\mathsf{pk}, \\mathsf{vk}) \\\\ h \\leftarrow \\mathsf{SF}. \\mathsf{VeriPrep}(\\mathsf{vk}, (u_i)_{i=1}^n) \\\\ h' \\leftarrow \\mathsf{SF}. \\mathsf{VeriPrep}(\\mathsf{vk}, (u_i')_{i=1}^n) \\end{array} \\right] = \\mathsf{negl}(\\lambda). $$</p>

    <p class="text-gray-300">Proof. We show that if there exists such <span class="math">\\mathcal{A}</span> who can break the binding property, i.e., outputs required two sets of instances with non-negligible probability, then it is efficient to construct a collision finder <span class="math">\\mathcal{B}</span> against the hash function Hash. Specifically, <span class="math">\\mathcal{B}</span> first runs <span class="math">\\mathcal{A}</span> to obtain two different instances sets <span class="math">(u_i)_{i=1}^n</span>, <span class="math">(u_i&#x27;)_{i=1}^n</span>, then <span class="math">\\mathcal{B}</span> can use these two sets to find collision in Hash. Since there must exist one pair of different instances <span class="math">(u_j, u_j&#x27;), j \\in [1, n]</span>, <span class="math">\\mathcal{B}</span> can output <span class="math">(u_j, h_{j-1})</span> and <span class="math">(u_j&#x27;, h_{j-1})</span> as the breaking case, where <span class="math">\\mathrm{Hash}((u_j, h_{j-1})) = \\mathrm{Hash}((u_j&#x27;, h_{j-1}))</span>, <span class="math">h_{j-1}</span> is computed with previous <span class="math">(u_i)_{i=1}^{j-1}</span>. More detailed discussions can be referred to the security proofs for the Merkle-Damgård paradigm [4].</p>

    <h2 id="sec-35" class="text-2xl font-bold">C.2 Proof of IVC for proof aggregation</h2>

    <p class="text-gray-300"><strong>Perfect completeness.</strong> Consider a satisfying SNARK instance-proof pair <span class="math">(u_i, \\pi_i)</span> such that <span class="math">V(u_i, \\pi_i) = 1</span>, where <span class="math">V</span> is derived from SNARK.V (since we adopt preprocessing to handle the non-homomorphic parts of SNARK.V, <span class="math">V</span> may not equal to SNARK.V). Consider the IVC algorithm defined in Figure 3. Let <span class="math">\\mathsf{pp} \\gets \\mathsf{IVC.G}(1^{\\lambda})</span> and <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathsf{IVC.K}(\\mathsf{pp}, V)</span>. Given a proof <span class="math">\\Pi_{i-1}</span> such that <span class="math">\\mathsf{IVC.V}(\\mathsf{vk}, i-1, \\Pi_{i-1}) = 1</span>, we prove <span class="math">\\Pi_i \\gets \\mathsf{IVC.P}(\\mathsf{pk}, i, (u_i, \\pi_i), \\Pi_{i-1})</span> such that <span class="math">\\mathsf{IV.V}(\\mathsf{vk}, i, \\Pi_i) = 1</span> by induction on <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Base Case <span class="math">(i = 1)</span>:</strong> Consider a satisfying instance-proof pair <span class="math">(u_1, \\pi_1)</span> such that <span class="math">V(u_1, \\pi_1) = 1</span>. Suppose the prover is provided <span class="math">\\Pi_0</span> such that <span class="math">\\mathsf{IV.V}(\\mathsf{vk}, 0, \\Pi_0) = 1</span>. By the base case of IVC.P, we have <span class="math">\\Pi_1 = (h_1, (u_1^<em>, \\pi_1^</em>), (u_{\\mathsf{C},1}, w_{\\mathsf{C},1}), (u_{\\mathsf{C},1}^<em>, w_{\\mathsf{C},1}^</em>))</span>. By the construction of IVC.P, we have <span class="math">(u_1^<em>, \\pi_1^</em>) = \\mathsf{Fold}_{\\mathsf{SNARK}}.P(\\mathsf{pk}_{\\mathsf{FS}}, (u_1, \\pi_1), (u_\\perp^<em>, \\pi_\\perp^</em>))</span>. Since <span class="math">(u_\\perp^<em>, \\pi_\\perp^</em>)</span> is a trivially satisfying instance-proof pair, we have <span class="math">(u_1^<em>, \\pi_1^</em>)</span> is a satisfying instance-proof pair (by the perfect completeness of <span class="math">\\mathsf{Fold}_{\\mathsf{SNARK}}</span>). Similarly, we can prove that <span class="math">(u_{\\mathsf{C},1}^<em>, w_{\\mathsf{C},1}^</em>)</span> is a satisfying instance-witness pair. Moreover, by construction of the recursive circuit RC, <span class="math">(u_{\\mathsf{C},1}, w_{\\mathsf{C},1})</span> must be satisfying and <span class="math">u_{\\mathsf{C},1}</span> is a non-relaxed instance. Additionally, <span class="math">u_{\\mathsf{C},1}.x = \\mathrm{Hash}(\\mathsf{vk}, 1, h_1, u_1^<em>, u_{\\mathsf{C},1}^</em>)</span>. Therefore, we have <span class="math">\\mathsf{IV.V}(\\mathsf{vk}, 1, \\Pi_1) = 1</span>.</p>

    <p class="text-gray-300"><strong>Inductive Step <span class="math">(i = 2</span> to <span class="math">n)</span>:</strong> Consider a satisfying instance-proof pair <span class="math">(u_i, \\pi_i)</span> such that <span class="math">V(u_i, \\pi_i) = 1</span>. Suppose <span class="math">\\Pi_{i-1}</span> is a satisfying IVC proof such that <span class="math">\\mathsf{IVC.V}(\\mathsf{vk}, i - 1, \\Pi_{i-1}) = 1</span>. Given <span class="math">\\Pi_i = (h_i, (u_i^<em>, \\pi_i^</em>), (u_{\\mathsf{C},i}, w_{\\mathsf{C},i}), (u_{\\mathsf{C},i}^<em>, w_{\\mathsf{C},i}^</em>))</span>, by the construction of IVC.P, we have</p>

    <div class="my-4 text-center"><span class="math-block">(u_i^*, w_i^*) \\leftarrow \\mathsf{Fold}_{\\mathsf{SNARK}}.P\\big(\\mathsf{pk}_{\\mathsf{FS}}, (u_i, \\pi_i), (u_{i-1}^*, \\pi_{i-1}^*)\\big), $$ $$ (u_{\\mathsf{C},i}^*, w_{\\mathsf{C},i}^*) \\leftarrow \\mathsf{Fold}_{\\mathsf{Circuit}}\\big(\\mathsf{pk}_{\\mathsf{FC}}, (u_{\\mathsf{C},i-1}, w_{\\mathsf{C},i-1}), (u_{\\mathsf{C},i-1}^*, w_{\\mathsf{C},i-1}^*)\\big).</span></div>

    <p class="text-gray-300">Since <span class="math">(u_{i-1}^<em>, \\pi_{i-1}^</em>)</span>, <span class="math">(u_{\\mathsf{C},i-1}, w_{\\mathsf{C},i-1})</span>, and <span class="math">(u_{\\mathsf{C},i-1}^<em>, w_{\\mathsf{C},i-1}^</em>)</span> are satisfying pairs, and <span class="math">(u_i, \\pi_i)</span> is also a satisfying instance-proof pair, we have that <span class="math">(u_i^<em>, \\pi_i^</em>)</span> and <span class="math">(u_{\\mathsf{C},i}^<em>, w_{\\mathsf{C},i}^</em>)</span> are satisfying pairs based on the perfect completeness of <span class="math">\\mathsf{Fold}_{\\mathsf{SNARK}}</span> and <span class="math">\\mathsf{Fold}_{\\mathsf{Circuit}}</span>. Moreover, since <span class="math">u_{\\mathsf{C},i-1}.x = \\mathrm{Hash}(\\mathsf{vk}, i - 1, h_{i-1}, u_{i-1}^<em>, u_{\\mathsf{C},i-1}^</em>)</span> and</p>

    <p class="text-gray-300"><span class="math">u_{\\mathsf{C},i - 1}</span>  is a non-relaxed instance (implied by the correctness of IVC.V in the previous round), the  <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span>  constructed by a claim of the recursive circuit  <span class="math">\\mathsf{tr}\\big(\\mathsf{RC}(\\mathsf{vk},i,h_{i - 1},u_i,u_{i - 1}^<em>,u_{\\mathsf{C},i - 1},u_{\\mathsf{C},i - 1}^</em>)\\big)</span>  is a satisfying pair and  <span class="math">u_{\\mathsf{C},i}</span>  nonrelaxed, by the perfect correctness of the underlying folding schemes. Thus, we have IVC.V(vk,  <span class="math">i,\\varPi_{i}) = 1</span></p>

    <p class="text-gray-300">Knowledge soundness. Let  <span class="math">\\mathsf{pp} \\gets \\mathsf{IVC}. \\mathsf{G}(1^{\\lambda})</span> . Given adversarially chosen  <span class="math">(V, (u_i)_{i=1}^n)</span>  by an expected PPT adversary  <span class="math">\\mathcal{A}</span> , generate the keys with  <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathsf{IVC}. \\mathsf{K}(\\mathsf{pp}, V)</span> .  <span class="math">\\mathcal{A}</span>  additionally outputs  <span class="math">\\Pi_n</span>  such that  <span class="math">\\mathsf{IVC}. \\mathsf{V}(\\mathsf{vk}, n, \\Pi_n) = 1</span>  for a constant  <span class="math">n</span>  with probability  <span class="math">\\epsilon</span> . We construct an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  that takes  <span class="math">(\\mathsf{pp}, (u_i)_{i=1}^n, \\Pi_n)</span>  and outputs  <span class="math">(\\pi_i)_{i=1}^n</span>  such that  <span class="math">V(u_i, \\pi_i) = 1</span>  for all  <span class="math">i = 1, \\dots, n</span>  with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span> . Specifically, we show  <span class="math">\\mathcal{E}</span>  can be constructed inductively by an expected polynomial-time extractor  <span class="math">\\mathcal{E}_i(\\mathsf{pp}; \\rho)</span>  that with probability  <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>  outputs  <span class="math">\\left((u_j, \\pi_j)_{j=i+1}^n, \\Pi_i\\right)</span>  such that  <span class="math">V(u_j, \\pi_j) = 1</span>  for all  <span class="math">j \\in \\{i+1, \\dots, n\\}</span>  and  <span class="math">\\mathsf{IVC}. \\mathsf{V}(\\mathsf{vk}, i, \\Pi_i) = 1</span> . This implies  <span class="math">(u_i, \\pi_i)_{i=1}^n</span>  since  <span class="math">(\\pi_i)_{i=1}^n</span>  extracted by  <span class="math">\\mathcal{E}_0</span>  are satisfying proofs for the corresponding instances  <span class="math">(u_i)_{i=1}^n</span> .</p>

    <p class="text-gray-300">To construct  <span class="math">\\mathcal{E}_{i-1}</span> , we assume there exists an  <span class="math">\\mathcal{E}_i</span>  that satisfies the inductive hypothesis. Then we use  <span class="math">\\mathcal{E}_i</span>  to construct an adversary  <span class="math">\\mathcal{A}_{i-1}</span>  for the folding schemes. By further invoking two extractors for folding schemes, we can construct  <span class="math">\\mathcal{E}_{i-1}</span>  that satisfies the inductive hypothesis. The detailed construction is as follows. Base Case  <span class="math">(i = n)</span> :  <span class="math">\\mathcal{E}_n</span>  outputs  <span class="math">(\\perp, \\perp, \\Pi_n)</span>  where  <span class="math">\\Pi_n = \\Pi</span>  is the output of  <span class="math">\\mathcal{A}</span> . By the premise,  <span class="math">\\mathcal{E}_n</span>  succeeds with probability  <span class="math">\\epsilon</span>  in expected polynomial-time. Inductive Step  <span class="math">(i = n - 1</span>  to 1): Suppose we have constructed  <span class="math">\\mathcal{E}_i</span>  that outputs  <span class="math">(\\pi_j)_{j=i+1}^n</span>  and a  <span class="math">\\Pi_i</span>  satisfies the inductive hypothesis. We first construct an adversary  <span class="math">\\mathcal{A}_{i-1}</span>  for the folding schemes as follows:</p>

    <p class="text-gray-300">|  A i-1(pp; ρ)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2:</td>

            <td class="px-3 py-2 border-b border-gray-700">parse Πi as (hi,(u1<em>,πi</em>), (uC,i,WC,i), (uC,i,WC,i)),</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3:</td>

            <td class="px-3 py-2 border-b border-gray-700">parse WC,i to retrieve (hi-1,ui,ui-1,uc-1,uc-1,uc-1),</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4:</td>

            <td class="px-3 py-2 border-b border-gray-700">output ((hi-1,ui,ui-1,uc-1,uc-1,uc-1), (u1<em>,πi</em>), (uC,i,WC,i)).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The third step is correct since  <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span>  is derived from  <span class="math">\\mathsf{tr}(\\mathsf{RC}(<em>))</span> . By the inductive hypothesis, we have IVC.V(vk,  <span class="math">i,\\varPi_{i})=1</span> . This implies  <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span>  is a non-relaxed satisfying pair for RC relation. Therefore,  <span class="math">w_{\\mathsf{C},i}</span>  must include  <span class="math">u_{i}</span> ,  <span class="math">u_{i-1}^{</em>}</span> ,  <span class="math">u_{\\mathsf{C},i-1}</span> , and  <span class="math">u_{\\mathsf{C},i-1}^{*}</span> . Based on the construction of RC and the binding property of the hash function, we have</p>

    <p class="text-gray-300"><span class="math">u_{i}^{<em>}\\gets \\mathsf{Fold}_{\\mathsf{SNARK}}.\\mathsf{V}(\\mathsf{vk}_{\\mathsf{FS}},u_{i},u_{i - 1}^{</em>}),</span> <span class="math">u_{\\mathsf{C},i}^{<em>}\\gets \\mathsf{Fold}_{\\mathsf{Circuit}}.\\mathsf{V}(\\mathsf{vk}_{\\mathsf{FC}},u_{\\mathsf{C},i - 1},u_{\\mathsf{C},i - 1}^{</em>}).</span></p>

    <p class="text-gray-300">Therefore,  <span class="math">\\mathcal{A}_{i-1}</span>  succeeds in producing satisfying folded pairs  <span class="math">(u_i^<em>, \\pi_i^</em>)</span>  and  <span class="math">(u_{\\mathsf{C},i}^<em>, w_{\\mathsf{C},i}^</em>)</span>  for instances  <span class="math">(u_i, u_{i-1}^<em>)</span>  and  <span class="math">(u_{\\mathsf{C},i-1}, u_{\\mathsf{C},i-1}^</em>)</span> , respectively.</p>

    <p class="text-gray-300">Based on the knowledge soundness of the folding schemes  <span class="math">\\mathsf{Fold}_{\\mathsf{SNARK}}</span>  and  <span class="math">\\mathsf{Fold}_{\\mathsf{Circuit}}</span> , we can further invoke the extractors of them,  <span class="math">\\mathcal{E}_S</span>  and  <span class="math">\\mathcal{E}_C</span> , which will</p>

    <p class="text-gray-300">output satisfying proofs <span class="math">(\\pi_i,\\pi_{i - 1}^<em>)</span> and witness <span class="math">(w_{\\mathsf{C},i - 1},w_{\\mathsf{C},i - 1}^{</em>})</span> for RC respectively in <span class="math">(i - 1)</span>-th round. The detailed construction of <span class="math">\\mathcal{E}_{i - 1}</span> is as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {E} _ {i - 1} (\\mathfrak {p p}; \\rho)</span></div>

    <p class="text-gray-300">1: <span class="math">\\left((u_{i},u_{i - 1}^{<em>},u_{\\mathsf{C},i - 1},u_{\\mathsf{C},i - 1}^{</em>}),\\right.</span> 2: <span class="math">(u_{i}^{<em>},w_{i}^{</em>}),(u_{\\mathsf{C},i}^{<em>},w_{\\mathsf{C},i}^{</em>}))\\leftarrow \\mathcal{A}_{i - 1}(\\mathsf{pp};\\rho),</span> 3: retrieve <span class="math">\\left((\\pi_j)_{j = i + 1}^n,\\pi_i\\right)</span> from <span class="math">\\mathcal{A}_{i - 1}</span>'s internal states, 4: <span class="math">(\\pi_i,\\pi_{i - 1}^<em>)\\gets \\mathcal{E}_5(\\mathsf{pp};\\rho),\\quad (w_{\\mathsf{C},i - 1},w_{\\mathsf{C},i - 1}^</em>)\\gets \\mathcal{E}_{\\mathsf{C}}(\\mathsf{pp};\\rho),</span> 5: <span class="math">\\Pi_{i - 1}\\gets \\bigl ((u_{i - 1}^<em>,\\pi_{i - 1}^</em>),(u_{\\mathsf{C},i - 1},w_{\\mathsf{C},i - 1}),(u_{\\mathsf{C},i - 1}^<em>,w_{\\mathsf{C},i - 1}^</em>)\\bigr),</span> 6: output <span class="math">\\left((\\pi_j)_{j = i}^n,\\Pi_{i - 1}\\right)</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{E}_5</span> and <span class="math">\\mathcal{E}_{\\mathbb{C}}</span> only incur a negligible soundness error, <span class="math">\\mathcal{E}_{i - 1}</span> succeeds with probability <span class="math">\\epsilon -\\mathrm{negl}(\\lambda)</span>. Now, we argue the validity of the outputs. First, <span class="math">(\\pi_j)_j^n = i + 1</span> are valid by hypothesis, <span class="math">\\pi_{i}</span> is also a satisfying proof to <span class="math">u_{i}</span> based on the knowledge soundness of <span class="math">\\mathcal{E}_5</span>. Besides, <span class="math">(u_{i},\\pi_{i})</span> is a non-relaxed pair implied by the validity of <span class="math">(u_{\\mathbb{C},i},w_{\\mathbb{C},i})</span>. Therefore, <span class="math">(\\pi_j)_j^n = i</span> are valid proofs.</p>

    <p class="text-gray-300">Next, we argue <span class="math">\\varPi_{i-1}</span> is valid. Since <span class="math">(u_{\\mathsf{C},i}, w_{\\mathsf{C},i})</span> satisfies RC in <span class="math">i</span>-th round and <span class="math">u_{\\mathsf{C},i-1}</span> is retrieved from <span class="math">w_{\\mathsf{C},i}</span>, we have <span class="math">u_{\\mathsf{C},i-1}.h = \\mathrm{Hash}(\\mathsf{vk}, i-1, u_{i-1}^<em>, u_{\\mathsf{C},i-1}^</em>)</span> and <span class="math">u_{\\mathsf{C},i-1}</span> are non-relaxed instances. Since <span class="math">\\mathcal{E}_{i-1}</span> succeeds with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>, we have IVC.V(vk, <span class="math">i-1, \\Pi_{i-1}</span>) = 1 with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Succinctness. The proof <span class="math">\\varPi_{i}</span> contains: <span class="math">h_i</span> <span class="math">(u_i^<em>,\\pi_i^</em>)</span> <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span>  and <span class="math">(u_{\\mathsf{C},i}^{<em>},w_{\\mathsf{C},i}^{</em>})</span>. By the definition of IVC.P, <span class="math">h_i</span> is a hash value of fixed size. The folding schemes ensure <span class="math">(u_{i}^{<em>},\\pi_{i}^{</em>})</span> and <span class="math">(u_{\\mathsf{C},i}^{<em>},w_{\\mathsf{C},i}^{</em>})</span> are of the size of one pair, which are independent of <span class="math">i</span>. <span class="math">(u_{\\mathsf{C},i},w_{\\mathsf{C},i})</span> is also independent from <span class="math">i</span> since it is a non-relaxed instance-witness pair. Therefore, the size of <span class="math">\\varPi_{i}</span> does not increase with <span class="math">i</span>.</p>

    <h2 id="sec-36" class="text-2xl font-bold">C.3 Proof of Theorem 2</h2>

    <p class="text-gray-300">Perfect completeness. Given two augmented relaxed Groth16 instance-proof pairs, <span class="math">\\left((\\mu_1,H_1,E_1,R_1,S_1),(A_1,B_1,C_1)\\right)</span> and <span class="math">\\left((\\mu_2,H_2,E_2,R_2,S_2),(A_2,B_2,C_2)\\right)</span>, the folded pair <span class="math">\\left((\\mu^{<em>},H^{</em>},E^{<em>},R^{</em>},S^{<em>}),(A^{</em>},B^{<em>},C^{</em>})\\right)</span> is a satisfying pair.</p>

    <p class="text-gray-300">Knowledge soundness. Consider public parameters <span class="math">\\mathsf{pp}</span> for <span class="math">\\mathsf{Fold}_{\\mathsf{Gro16}}</span>, an adversarially chosen augmented relaxed Groth16 proof structure <span class="math">([\\delta]_2, [\\gamma]_2, D) \\in (\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span>, and two adversarially chosen instances <span class="math">(\\mu_1, H_1, E_1, R_1, S_1, \\kappa_1)</span> and <span class="math">(\\mu_2, H_2, E_2, R_2, S_2, \\kappa_2)</span>. We prove knowledge soundness of the interactive version of the protocol via the forking lemma in Lemma 1 (the corresponding non-interactive version can be proved under the Fiat-Shamir heuristic in the random oracle model): there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that when given <span class="math">\\mathsf{pp}</span>, <span class="math">([\\delta]_2, [\\gamma]_2, D)</span>, and a tree of accepting transcripts and the corresponding folded instance-proof pair, outputs two satisfying proofs with probability <span class="math">1 - \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Specifically, when given 2 accepting transcripts with the same <span class="math">T</span>, <span class="math">\\left(T,r_i,(A_i^<em>,B_i^</em>,C_i^*)\\right)_{i = 1}^2</span> interpolate points <span class="math">(\\hat{A}_1,\\hat{B}_1,\\hat{C}_1)</span> and <span class="math">(\\hat{A}_2,\\hat{B}_2,\\hat{C}_2)</span> such that for all <span class="math">i\\in \\{1,2\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\hat{A}_1 \\cdot \\hat{A}_2^{r_i} = A_i^*, \\quad \\hat{B}_1 \\cdot \\hat{B}_2^{r_i} = B_i^*, \\quad \\hat{C}_1 \\cdot \\hat{C}_2^{r_i} = C_i^*.</span></div>

    <p class="text-gray-300">Now we show that the extracted proofs <span class="math">(\\hat{A}_1, \\hat{B}_1, \\hat{C}_1)</span> and <span class="math">(\\hat{A}_2, \\hat{B}_2, \\hat{C}_2)</span> are valid proofs to the corresponding instances. Since <span class="math">(A_i^<em>, B_i^</em>, C_i^*)</span> are satisfying proofs for <span class="math">i \\in \\{1, 2\\}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e(A_i^*, B_i^*) \\cdot e(C_i^*, [\\delta]_2)^{-\\mu_i^*} \\cdot e(H_i^*, [\\gamma]_2)^{-\\mu_i^*} \\cdot D^{-(\\mu_i^*)^2} \\tag{5} \\\\ = E_i^* \\cdot e(R_i^*, [\\delta]_2) \\cdot e(S_i^*, [\\gamma]_2) \\cdot D^{\\kappa_i^*}, \\quad \\forall i \\in \\{1, 2\\}, \\end{aligned}</span></div>

    <p class="text-gray-300">where <span class="math">(\\mu_i^<em>, H_i^</em>, E_i^<em>, R_i^</em>, S_i^<em>, \\kappa_i^</em>)_{i=1}^2</span> are computed based on <span class="math">\\mathsf{Fold}_{\\mathsf{Gro16}} \\cdot \\mathsf{V}</span> by <span class="math">\\mathcal{E}</span>. The left-hand side of Equation (5) equals</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e(A_i^*, B_i^*) \\cdot e(C_i^*, [\\delta]_2)^{-\\mu_i^*} \\cdot e(H_i^*, [\\gamma]_2)^{-\\mu_i^*} \\cdot D^{-(\\mu_i^*)^2} \\\\ = e(\\hat{A}_1 \\hat{A}_2^{r_i}, \\hat{B}_1 \\hat{B}_2^{r_i}) \\cdot e(\\hat{C}_1 \\hat{C}_2^{r_i}, [\\delta]_2)^{-(\\mu_1 + r_i \\mu_2)} \\cdot e(H_1 H_2^{r_i}, [\\gamma]_2)^{-(\\mu_1 + r_i \\mu_2)} \\cdot D^{-(\\mu_1 + r_i \\mu_2)^2} \\\\ = e(\\hat{A}_1, \\hat{B}_1) \\cdot e(\\hat{C}_1, [\\delta]_2)^{-\\mu_1} \\cdot e(H_1, [\\gamma]_2)^{-\\mu_1} \\cdot D^{-\\mu_1^2} \\cdot \\left(T&#x27; \\cdot e(R, [\\delta]_2) \\cdot e(S, [\\gamma]_2) \\cdot D^{\\kappa}\\right)^{r_i} \\\\ \\cdot \\left(e(\\hat{A}_2, \\hat{B}_2) \\cdot e(\\hat{C}_2, [\\delta]_2)^{-\\mu_2} \\cdot e(H_2, [\\gamma]_2)^{-\\mu_2} \\cdot D^{-\\mu_2^2}\\right)^{r_i^2}. \\end{aligned}</span></div>

    <p class="text-gray-300">The right-hand side of Equation (5) equals</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} E_i^* \\cdot e(R_i^*, [\\delta]_2) \\cdot e(S_i^*, [\\gamma]_2) \\cdot D^{\\kappa_i^*} \\\\ = \\left(E_1 (T&#x27;)^{r_i} E_2^{r_i^2}\\right) \\cdot e\\left(R_1 R^{r_i} R_2^{r_i^2}, [\\delta]_2\\right) \\cdot e\\left(S_1 S^{r_i} S_2^{r_i^2}, [\\gamma]_2\\right) \\cdot D^{\\kappa_1 + r_i \\kappa + r_i^2 \\kappa_2} \\\\ = E_1 \\cdot e(R_1, [\\delta]_2) \\cdot e(S_1, [\\gamma]_2) \\cdot D^{\\kappa_1} \\cdot \\left(T&#x27; \\cdot e(R, [\\delta]_2) \\cdot e(S, [\\gamma]_2) \\cdot D^{\\kappa}\\right)^{r_i} \\\\ \\cdot \\left(E_2 \\cdot e(R_2, [\\delta]_2) \\cdot e(S_2, [\\gamma]_2) \\cdot D^{\\kappa_2}\\right)^{r_i^2}. \\end{aligned}</span></div>

    <p class="text-gray-300">Since Equation (5) holds for <span class="math">i \\in \\{1, 2\\}</span>, by expanding and interpolating, we have the following relations hold with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e(\\hat{A}_i, \\hat{B}_i) \\cdot e(\\hat{C}_i, [\\delta]_2)^{-\\mu_i} \\cdot e(H_i, [\\gamma]_2)^{-\\mu_i} \\cdot D^{-\\mu_i^2} \\\\ = E_i \\cdot e(R_i, [\\delta]_2) \\cdot e(S_i, [\\gamma]_2), \\quad \\forall i \\in \\{1, 2\\}, \\end{aligned}</span></div>

    <p class="text-gray-300">which implies the extracted proofs <span class="math">(\\hat{A}_1, \\hat{B}_1, \\hat{C}_1)</span> and <span class="math">(\\hat{A}_2, \\hat{B}_2, \\hat{C}_2)</span> are valid proofs to the corresponding instances.</p>

    <h2 id="sec-37" class="text-2xl font-bold">C.4 Proof of Theorem 5</h2>

    <p class="text-gray-300"><strong>Perfect completeness.</strong> Given two relaxed quadratic Plonk instance-proof pairs <span class="math">\\left((\\lambda_i, \\gamma_i, v_i, \\bar{a}_i, \\bar{b}_i, \\bar{c}_i, \\vec{t}_i, u_{\\mathsf{Plonk},i}, \\pi_{\\mathsf{Plonk},i}), \\bot\\right)_{i=1}^2</span>, the folded pair <span class="math">\\left((\\lambda^<em>, \\gamma^</em>, v^<em>, \\bar{a}^</em>, \\bar{b}^<em>, \\bar{c}^</em>, \\vec{t}^<em>, u_{\\mathsf{Plonk}}^</em>, \\pi_{\\mathsf{Plonk}}^*, \\bot\\right)</span> satisfies one for the quadratic relation.</p>

    <p class="text-gray-300">Knowledge soundness. Consider public parameters <span class="math">\\mathsf{pp}</span> for <span class="math">\\mathsf{Fold}_{\\mathsf{Plonk}}</span>, an adversarially chosen relaxed preprocessed quadratic Plonk proof structure <span class="math">([1]_2, [x]_2) \\in (\\mathbb{G}_2, \\mathbb{G}_2)</span>, and two adversarially chosen instances <span class="math">(\\lambda_i, \\gamma_i, v_i, \\bar{a}_i, \\bar{b}_i, \\bar{c}_i, \\bar{t}_i, u_{\\mathsf{Plonk},i}, \\pi_{\\mathsf{Plonk},i})_{i=1}^2</span>. We prove knowledge soundness of the interactive version of the protocol via the forking lemma in Lemma 1. The extractor <span class="math">\\mathcal{E}</span> outputs empty witness <span class="math">\\perp</span> for both instances. We further argue the input instances must be valid if the folded instance is valid. When given 2 accepting transcripts with the same <span class="math">T_P</span> and <span class="math">T_Q</span>, we have two satisfying folded instances <span class="math">(\\lambda_i^<em>, \\gamma_i^</em>, v_i^<em>, \\bar{a}_i^</em>, \\bar{b}_i^<em>, \\bar{c}_i^</em>, \\bar{t}_i^<em>, u_{\\mathsf{Plonk},i}^</em>, \\pi_{\\mathsf{Plonk},i}^*)_{i=1}^2</span> under two distinct challenges <span class="math">r_1</span> and <span class="math">r_2</span>, such that for <span class="math">i \\in \\{1, 2\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(P _ {i} ^ {*}, [ x ] _ {2}\\right) \\cdot e \\left(Q _ {i} ^ {*}, [ 1 ] _ {2}\\right) ^ {- 1} = e \\left(E _ {P, i} ^ {*}, [ x ] _ {2}\\right) \\cdot e \\left(E _ {Q, i} ^ {*}, [ 1 ] _ {2}\\right) ^ {- 1}, \\tag {6}</span></div>

    <p class="text-gray-300">where <span class="math">P_{i}^{<em>}</span> and <span class="math">Q_{i}^{</em>}</span> are derived from the folded instance as with Definition 7. Since the folded instance is computed based on the logic of <span class="math">\\mathcal{V}</span>, we have the left-hand side of Equation (6) equals</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(P _ {i} ^ {*}, [ x ] _ {2}\\right) \\cdot e \\left(Q _ {i} ^ {*}, [ 1 ] _ {2}\\right) ^ {- 1} \\\\ = e \\left(\\left(W _ {i} ^ {*}\\right) ^ {\\mu_ {i} ^ {*}} \\left(V _ {i} ^ {*}\\right) ^ {\\gamma_ {i} ^ {*}}, [ x ] _ {2}\\right) \\cdot e \\left(\\left(W _ {i} ^ {*}\\right) ^ {\\gamma_ {i} ^ {*}} \\left(V _ {i} ^ {*}\\right) ^ {t _ {1 1, i} ^ {*}} M _ {i} ^ {*} N _ {i} ^ {*} \\left[ - \\mu_ {i} ^ {*} t _ {1 0, i} ^ {*} \\right] _ {1}, [ 1 ] _ {2}\\right) ^ {- 1} \\\\ = e \\left(W _ {1} ^ {\\mu_ {1}} V _ {1} ^ {\\gamma_ {1}}, [ x ] _ {2}\\right) \\cdot e \\left(W _ {1} ^ {\\gamma_ {1}} V _ {1} ^ {t _ {1 1, 1}} M _ {1} N _ {1} \\left[ - \\mu_ {1} t _ {1 0, 1} \\right] _ {1}, [ 1 ] _ {2}\\right) ^ {- 1} \\\\ \\cdot \\left(e \\left(T _ {P}, [ x ] _ {2} \\cdot e \\left(T _ {Q}, [ x ] _ {2}\\right) ^ {- 1}\\right)\\right) ^ {r _ {i}} \\\\ \\cdot \\left(e \\left(W _ {2} ^ {\\mu_ {2}} V _ {2} ^ {\\gamma_ {2}}, [ x ] _ {2}\\right) \\cdot e \\left(W _ {2} ^ {\\gamma_ {2}} V _ {2} ^ {t _ {1 1, 2}} M _ {2} N _ {2} \\left[ - \\mu_ {2} t _ {1 0, 2} \\right] _ {1}, [ 1 ] _ {2}\\right) ^ {- 1}\\right) ^ {r _ {i} ^ {2}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The right-hand side of Equation (6) equals</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(E _ {P, i} ^ {*}, [ x ] _ {2}\\right) \\cdot e \\left(E _ {Q, i} ^ {*}, [ 1 ] _ {2}\\right) ^ {- 1} \\\\ = e \\left(E _ {P, 1}, [ x ] _ {2}\\right) \\cdot e \\left(E _ {Q, 1}, [ 1 ] _ {2}\\right) ^ {- 1} \\cdot \\left(e \\left(T _ {P}, [ x ] _ {2}\\right) \\cdot e \\left(T _ {Q}, [ 1 ] _ {2}\\right) ^ {- 1}\\right) ^ {r _ {i}} \\\\ \\cdot \\left(e \\left(E _ {P, 2}, [ x ] _ {2}\\right) \\cdot e \\left(E _ {Q, 2}, [ 1 ] _ {2}\\right) ^ {- 1}\\right) ^ {r _ {i} ^ {2}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since Equation (6) holds for both <span class="math">r_1</span> and <span class="math">r_2</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(W _ {i} ^ {\\mu_ {i}} V _ {i} ^ {\\gamma_ {i}}, [ x ] _ {2}\\right) \\cdot e \\left(W _ {i} ^ {\\gamma_ {i}} V _ {i} ^ {t _ {1 1, i}} M _ {i} N _ {i} \\left[ - \\mu_ {i} t _ {1 0, i} \\right] _ {1}, [ 1 ] _ {2}\\right) ^ {- 1} \\\\ = e \\left(E _ {P, i}, [ x ] _ {2}\\right) \\cdot e \\left(E _ {Q, i}, [ 1 ] _ {2}\\right) ^ {- 1}, \\quad \\forall i \\in \\{1, 2 \\}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which implies the input instances are satisfying ones.</p>

    <p class="text-gray-300">41</p>`;
---

<BaseLayout title="SnarkFold: Efficient Proof Aggregation from Incrementally Ve... (2023/1946)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1946
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
