---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/323';
---

<BaseLayout title="Poseidon2 (2023/323)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Poseidon2: A Faster Version of the Poseidon Hash Function
      </h1>
      <p class="text-gray-400 mb-2">
        Lorenzo Grassi, Dmitry Khovratovich, Markus Schofnegger
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; Full Version &middot; eprint 2023/323
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">Our Goals</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Our Contributions and Results</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            Preliminaries: Modern Arithmetization Techniques</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Preliminaries: ZK-Friendly Symmetric Primitives</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">Modes of Operation</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                The Poseidon&sup1; Permutation</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Security: Initial and Final Matrix Multiplications</a>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">More Efficient Linear Layers</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Matrix for the External Round</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Matrix for the Internal Round</a>
            </li>
            <li>
              <a href="#sec-5.3"
                class="hover:text-white">
                Preventing Arbitrarily Long Subspace Trails</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Poseidon2&sup1; Specification</a>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">Security Analysis</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1"
                class="hover:text-white">Statistical Attacks</a>
            </li>
            <li>
              <a href="#sec-7.2"
                class="hover:text-white">Algebraic Attacks</a>
            </li>
            <li>
              <a href="#sec-7.3"
                class="hover:text-white">
                Attack from Bariant et al.</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">Performance Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-8.1"
                class="hover:text-white">
                Theoretical Comparison</a>
            </li>
            <li>
              <a href="#sec-8.2"
                class="hover:text-white">
                Implementation and Benchmarks</a>
            </li>
            <li>
              <a href="#sec-8.3"
                class="hover:text-white">
                Efficient Plonkish Version</a>
            </li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a"
            class="hover:text-white">
            Efficient Circulant MDS Matrices</a>
        </li>
        <li>
          <a href="#app-b"
            class="hover:text-white">
            Efficient Computation of
            <span class="math">M_&#123;\mathcal&#123;E&#125;&#125;</span></a>
        </li>
        <li>
          <a href="#app-c"
            class="hover:text-white">
            Optimized Feistel-ERF Implementation</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        Zero-knowledge proof systems for computational integrity have
        seen a rise in popularity in the last couple of years. One of
        the results of this development is the ongoing effort in
        designing so-called arithmetization-friendly hash functions in
        order to make these proofs more efficient. One of these new
        hash functions, Poseidon, is extensively used in this context,
        also thanks to being one of the first constructions tailored
        towards this use case. Many of the design principles of
        Poseidon have proven to be efficient and were later used in
        other primitives, yet parts of the construction have shown to
        be expensive in real-world scenarios.
      </p>
      <p class="text-gray-300">
        In this paper, we propose an optimized version of Poseidon,
        called Poseidon2. The two versions differ in two crucial
        points. First, Poseidon is a sponge hash function, while
        Poseidon2 can be either a sponge or a compression function
        depending on the use case. Secondly, Poseidon2 is instantiated
        by new and more efficient linear layers with respect to
        Poseidon. These changes allow to decrease the number of
        multiplications in the linear layer by up to 90% and the
        number of constraints in Plonk circuits by up to 70%. This
        makes Poseidon2 the currently fastest arithmetization-oriented
        hash function without lookups.
      </p>
      <p class="text-gray-300">
        Besides that, we address a recently proposed algebraic attack
        and propose a simple modification that makes both Poseidon and
        Poseidon2 secure against this approach.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Poseidon &ndash; Poseidon2 &ndash;
        ZK Application &ndash; Sponge/Compression Mode
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        The area of zero-knowledge proof systems has seen a rise in
        popularity during the last couple of years. Arithmetization
        techniques such as R1CS used in Groth16 [Gro16], AIR used for
        FRI-based commitments [BS+18a, BS+18b], and Plonk [GWC19] and Plonk-style
        arithmetizations (e.g., [GW22] used in halo2 [Zca22]) make it
        possible to efficiently verify the correctness of a
        computation.
      </p>
      <p class="text-gray-300">
        Most of these proof systems internally use hash functions for
        the purpose of polynomial (Merkle tree) commitments. These hash
        functions are rather different compared to more traditional
        primitives. Indeed, while the latter are often optimized for
        plain performance in software or hardware implementations,
        constructions for proof systems mostly focus on minimizing the
        number of <em>constraints</em> (similar to gates) when writing
        them down in a specific circuit language. This fact has led to
        new symmetric designs, exhibiting sometimes unusual symmetric
        building blocks (e.g., sacrificing plain performance in order
        to obtain a simpler description in a certain proof system).
      </p>
      <p class="text-gray-300">
        In the literature, hash functions fulfilling these properties
        are often described as being arithmetization-oriented or
        circuit-friendly, which refers to their focus towards use cases
        of computational integrity. Besides Poseidon [GKR+21], examples of
        such constructions include MiMC/GMiMC [AGR+16, AGP+19], Friday [AD18],
        <em>Rescue</em> [AAB+20], Neptune [GOPS22], Anemoi [BBP+22], Griffin [GHR+23],
        and lookup-based primitives such as Reinforced Concrete [GKL+22]
        and Monolith [G+23]. In the last years, the knowledge of
        designing arithmetization-oriented hash functions has evolved,
        and more specific design goals are known today.
      </p>
      <p class="text-gray-300">
        <strong>The Origin of Poseidon.</strong> In this paper, we
        mostly focus on the Poseidon hash function. First described in
        2019 [GKR+19], it is heavily based on the HadesMiMC family of block
        ciphers [GLR+20]. The key property of HadesMiMC is that it uses
        two different round functions, one containing a full nonlinear
        layer with S-boxes applied to the entire state, and one
        containing a partial nonlinear layer with the S-boxes only
        affecting part of the state. This approach was chosen in order
        to provide convincing security arguments against statistical
        attacks using the full rounds while at the same time increasing
        the degree efficiently (i.e., by using a smaller number of
        S-boxes) using the partial rounds. However, HadesMiMC was
        designed with MPC use cases in mind, which has very different
        properties and optimization goals compared to modern proof
        systems. Most importantly, all linear operations can be
        computed locally by every party in an MPC protocol. Since the
        final efficiency of such a protocol depends on the number of
        communication rounds and no communication is needed for linear
        operations, the main optimization goal of HadesMiMC was to
        minimize the number of nonlinear operations. As a result, the
        final number of linear operations turned out to be
        comparatively high, mainly due to many multiplications with
        matrices of large sizes. In particular, each round of
        HadesMiMC contains a multiplication of a
        <span class="math">t</span>-element state with a dense and
        unstructured
        <span class="math">t \times t</span> matrix over
        <span class="math">\mathbb&#123;F&#125;_p</span>, where
        <span class="math">p</span> is a comparatively large prime.
        Hence, this operation results in a number of multiplications
        in
        <span class="math">\mathcal&#123;O&#125;(t^2)</span> over
        <span class="math">\mathbb&#123;F&#125;_p</span>.
      </p>
      <p class="text-gray-300">
        Similar to MPC use cases, in some arithmetization techniques
        (e.g., R1CS used in Groth16 [Gro16]), the number of nonlinear
        operations is also the main bottleneck. Hence, building a hash
        function based on the HadesMiMC permutation seemed like an
        efficient approach. This idea led to the specification of
        Poseidon, which is essentially a sponge hash function using an
        internal permutation similar to the one used in HadesMiMC
        (with minor differences such as the omission of a key
        addition). Poseidon has since been implemented and used in many
        different proving frameworks, including e.g. Ginger-lib [HL22]
        and Plonky2 [Pol22].
      </p>
      <p class="text-gray-300">
        <strong>Plain Performance and the Plonk
        Arithmetization.</strong> Since the design of Poseidon, various
        new optimization goals emerged. For example, it became clear
        that plain performance must not be neglected, since among other
        things it plays a crucial role when building the commitments
        outside of the respective circuits. Recent hash function
        designs in this area acknowledge this fact and try to also
        optimize for plain performance.
      </p>
      <p class="text-gray-300">
        Moreover, the variety of different arithmetization techniques
        has increased in the last couple of years. While R1CS was the
        main target for the original Poseidon, nowadays also the
        so-called algebraic intermediate representation (AIR) [BS+19] for
        FRI-based proof systems [BS+18a] or Plonk [GWC19] and "Plonkish"
        representations are popular approaches. Particularly, in Plonk
        linear operations also contribute to the final cost. Note that
        this is a clear distinction between Plonk and R1CS.
      </p>
      <p class="text-gray-300">
        The Poseidon hash function, while widely used and arguably
        efficient in some use cases, exhibits a large number of linear
        operations. This makes it expensive in terms of plain
        performance and when considering a Plonk-style arithmetization.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Our Goals
      </h3>
      <p class="text-gray-300">
        Our first goal for
        Poseidon2<span class="math">^\pi</span> is to achieve a
        simpler and more efficient version of
        Poseidon<span class="math">^\pi</span>. At the same time, we
        want to stay close to the original description, which allows
        us to benefit from years of third-party cryptanalysis applied
        to Poseidon<span class="math">^\pi</span>. In particular, our
        modifications allow us to achieve significant performance
        improvements while keeping the same round numbers, i.e., the
        same number of nonlinear operations. This is beneficial in
        concrete use cases in computational integrity. Indeed, the
        number of constraints does not increase when choosing
        Poseidon2<span class="math">^\pi</span> instead of
        Poseidon<span class="math">^\pi</span>, while at the same time
        the plain performance is better. For example, Merkle trees, a
        prominent building block in many proof systems, can be computed
        significantly faster.
      </p>
      <p class="text-gray-300">
        The updated Poseidon2<span class="math">^\pi</span> will show
        similarities to other primitives, for example Neptune. Still,
        the algorithmic description is much closer to
        Poseidon<span class="math">^\pi</span>. We chose this approach
        since Poseidon<span class="math">^\pi</span> is widely used in
        practice, and reusing components from the original design
        reduces implementation efforts.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Remark 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            We emphasize that we do not propose changes to the original
            permutation, and we do not propose a new security analysis
            for it either. Instead, our modification
            Poseidon2<span class="math">^\pi</span> can be thought of
            as a new and optimized version of
            Poseidon<span class="math">^\pi</span>.
          </p>
        </div>
      </div>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Our Contributions and Results
      </h3>
      <p class="text-gray-300">
        <strong>Security Issue for
        Poseidon<span class="math">^\pi</span>.</strong> We address a
        security problem with the original
        Poseidon<span class="math">^\pi</span> permutation. Indeed, as
        has been observed in [BBLP22], the first two nonlinear layers can
        be skipped when mounting an algebraic attack on
        Poseidon<span class="math">^\pi</span>. This results in
        equation systems of lower degrees and a more efficient attack.
        This approach can be mitigated by adding an additional linear
        layer to the beginning of the permutation. We discuss this
        issue in Section 7.3.
      </p>
      <p class="text-gray-300">
        <strong>Poseidon2<span class="math">^\pi</span>.</strong> As
        the main contribution, we consider various optimizations in
        order to make Poseidon faster and more efficient in recent
        proof systems. In particular, compared to the original
        Poseidon<span class="math">^\pi</span> permutation, our
        modification called
        Poseidon2<span class="math">^\pi</span> has
      </p>
      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-1">
        <li>an additional linear layer at the beginning of the
          permutation,</li>
        <li>different linear layer matrices,</li>
        <li>round constants only applied to the first word in the
          internal rounds, and</li>
        <li>the same number of rounds for many instantiations used
          in practice.</li>
      </ol>
      <p class="text-gray-300">
        Regarding the last point, we compare the statistical and the
        algebraic security of
        Poseidon2<span class="math">^\pi</span> with that of
        Poseidon<span class="math">^\pi</span>. We also emphasize that
        our new modified permutation is very similar in nature to the
        original one, and thus inherits the trust gained from the
        third-party cryptanalysis of Poseidon. A full specification of
        the new linear layers and of
        Poseidon2<span class="math">^\pi</span> is given in Section 5
        and Section 6.
      </p>
      <p class="text-gray-300">
        <strong>Modes of Operation.</strong> In many computational
        integrity proof systems, the construction of Merkle trees is a
        crucial part. For example, it is used to compute commitments to
        polynomials or to prove membership. When building a Merkle
        tree, the next hash is computed using a fixed number of
        previous (hash) outputs. For this purpose, the sponge function
        has often been used in the past, albeit with only one
        permutation call. In this paper, depending on the use case, we
        suggest to use either the classical sponge hash function or a
        generic compression function which computes a single new output
        using an arbitrary number of inputs and only one permutation
        call. In our practical use case, its main advantage regards the
        fact that it operates on a smaller size. For example, the inner
        part (capacity elements) of a sponge is not necessary, and
        thus the permutation can become smaller, with concrete
        advantages. We discuss both modes of operation specified for
        Poseidon2<span class="math">^\pi</span> in Section 3.1.
      </p>
      <p class="text-gray-300">
        <strong>Performance Comparison.</strong> Following the
        description of our new permutation
        Poseidon2<span class="math">^\pi</span>, we discuss its
        performance characteristics in Section 8. We focus on the plain
        performance and on the number of Plonk constraints, and provide
        benchmarks from a Rust implementation for various state sizes.
        We also compare Poseidon2<span class="math">^\pi</span> to the
        original version and to other similar primitives, and we
        provide a new Plonkish arithmetization technique which is
        compatible with both
        Poseidon<span class="math">^\pi</span> and
        Poseidon2<span class="math">^\pi</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES: MODERN ARITHMETIZATION TECHNIQUES          -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">
        2. Preliminaries: Modern Arithmetization Techniques
      </h2>
      <p class="text-gray-300">
        Our focus in this paper is on use cases in the area of
        computational integrity proof systems. In such a scenario, a
        prover wants to convince a verifier to have correctly run an
        arbitrary computation, without making the verifier recompute
        the result. Many such proof systems exist in practice
        [37, 13, 26], and they also allow for zero-knowledge versions
        where the verifier does not learn any private details of the
        provided proof.
      </p>
      <p class="text-gray-300">
        In general, a proof can be split into two steps. First, the
        computation has to be represented as a number of polynomials,
        which is usually called arithmetization. Then, a polynomial
        commitment scheme is used in order to finalize the proof. In
        this paper, we focus on the arithmetization step, and for this
        purpose we briefly describe popular techniques. The aim when
        applying these is to keep the number of constraints as low as
        possible.
      </p>
      <p class="text-gray-300">
        <strong>R1CS.</strong> A rank-1 constraint satisfaction system
        (R1CS) consists of
        <span class="math">n</span> equations in the variables
        <span class="math">v_0, v_1, \ldots, v_m</span> defined by
      </p>
      <div class="math-block">
        \sum_&#123;i=0&#125;^&#123;m&#125; a_i^&#123;(n)&#125; v_i
        \cdot
        \sum_&#123;i=0&#125;^&#123;m&#125; b_i^&#123;(n)&#125; v_i
        =
        \sum_&#123;i=0&#125;^&#123;m&#125; c_i^&#123;(n)&#125; v_i
      </div>
      <p class="text-gray-300">
        where
        <span class="math">v_i</span> are elements from a finite
        field
        <span class="math">\mathbb&#123;F&#125;</span>,
        <span class="math">v_0 \in \&#123;0, 1\&#125;</span>, and
        <span class="math">a_i^&#123;(n)&#125;, b_i^&#123;(n)&#125;, c_i^&#123;(n)&#125;</span>
        are field elements describing the
        <span class="math">n</span>-th constraint.
      </p>
      <p class="text-gray-300">
        Note that these equations are of degree 2 in
        <span class="math">\&#123;v_i\&#125;_&#123;i=0&#125;^m</span>.
        They are derived from the statement to prove, which in many
        cases is a hash function evaluation. Then, minimizing the
        number of constraints generally leads to more efficient proofs.
        As an example, using high-degree functions in the hash
        specification results in a larger number of constraints, which
        is why many recent arithmetization-oriented designs rely on
        low-degree components.
      </p>
      <p class="text-gray-300">
        <strong>Plonk and Variants.</strong> The Plonk [GWC19]
        arithmetization results in a table-like representation for the
        execution trace. However, the constraints are not restricted to
        describe entire state transitions, and in general more freedom
        is offered to the designer. In particular, every constraint is
        of the form
      </p>
      <div class="math-block">
        q_&#123;L_i&#125; \cdot a_&#123;L_i&#125;
        + q_&#123;R_i&#125; \cdot a_&#123;R_i&#125;
        + q_&#123;O_i&#125; \cdot a_&#123;O_i&#125;
        + q_&#123;M_i&#125; \cdot (a_&#123;L_i&#125; a_&#123;R_i&#125;)
        + q_&#123;C_i&#125; = 0
      </div>
      <p class="text-gray-300">
        where
        <span class="math">a_&#123;L_i&#125;, a_&#123;R_i&#125;, a_&#123;O_i&#125;</span>
        are witness variables describing two inputs and an output of a
        gate, and
        <span class="math">q_&#123;L_i&#125;, q_&#123;R_i&#125;, q_&#123;O_i&#125;, q_&#123;M_i&#125;, q_&#123;C_i&#125;</span>
        are set such that a specific gate constraint (e.g., an addition
        or a multiplication) is enforced. Note that this is only a
        basic description of Plonk, and subsequent variants such as
        [GW22] make it possible to increase the "width" of the gate
        (e.g., the number of inputs).
      </p>
      <p class="text-gray-300">
        A notable difference in Plonk when compared to R1CS is that
        linear gates (e.g., additions) also require constraints of
        their own. Hence, linear operations are not "for free" anymore.
        This can make expensive linear operations, such as matrix
        multiplications, not only inefficient in a plain evaluation,
        but also with regards to the arithmetization.
      </p>
      <p class="text-gray-300">
        <strong>Plonkish and AIR.</strong> Both Plonkish [Zca22] and AIR
        [BS+19] are more powerful representations compared to R1CS and
        regular Plonk. Like Plonk, both Plonkish and AIR describe a
        computation trace as a matrix, but allow high-degree polynomial
        relations to represent the state transformation.
      </p>
      <p class="text-gray-300">
        The set of states is a
        <span class="math">T \times w</span> matrix, where
        <span class="math">T</span> is the number of states and
        <span class="math">w</span> is the width (or the number of
        registers). Focusing on a hash function evaluation, for
        example
        <span class="math">w</span> is set to the state size of the
        hash primitive and each new state describes the values obtained
        after applying a round function to the previous state. In
        contrast to R1CS, the constraint polynomials are not required
        to be of degree 2, but the efficiency of the arithmetization
        still depends on the maximum degree
        <span class="math">d</span> in the constraint polynomials. The
        prover time is proportional to
        <span class="math">T \cdot w \cdot d</span>, whereas the proof
        size is an affine function of the maximal number of variables
        <span class="math">q</span> in the constraints. Hence, more
        efficient Plonkish/AIR proofs are delivered by smaller degrees
        and/or fewer variables in the constraints.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. PRELIMINARIES: ZK-FRIENDLY SYMMETRIC PRIMITIVES           -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Preliminaries: ZK-Friendly Symmetric Primitives
      </h2>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Modes of Operation
      </h3>
      <p class="text-gray-300">
        Hash functions are crucial in the context of zero-knowledge
        protocols. Given a hash function
        <span class="math">\mathcal&#123;H&#125; : \mathbb&#123;F&#125;_p^&#123;\star&#125; \to \mathbb&#123;F&#125;_p^&#123;\infty&#125;</span>
        for a prime
        <span class="math">p \geq 2</span>, it must be computationally
        hard to find collisions, preimages, and second preimages.
      </p>
      <p class="text-gray-300">
        In this paper, we mainly focus on the sponge mode. However,
        when building a Merkle tree with small fixed-size input
        lengths, we often only need a single permutation call. In this
        case, we use a compression function rather than a full hash.
      </p>
      <p class="text-gray-300">
        <strong>Sponge Hash Functions.</strong> A sponge hash function
        [14, 15] is built using an internal permutation
        <span class="math">\mathcal&#123;P&#125;</span> over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> with
        <span class="math">t = r + c</span> (rate + capacity). As
        proven in [BDPVA08], the sponge is indifferentiable from a random
        oracle up to
        <span class="math">p^&#123;c/2&#125;</span> queries.
      </p>
      <p class="text-gray-300">
        <strong>Compression Functions.</strong> We focus on
      </p>
      <div class="math-block">
        x \in \mathbb&#123;F&#125;_p^t \mapsto
        \mathcal&#123;C&#125;(x) :=
        \mathrm&#123;Tr&#125;_n(\mathcal&#123;P&#125;(x) + x)
        \in \mathbb&#123;F&#125;_p^n
      </div>
      <p class="text-gray-300">
        This is secure if
        <span class="math">p^n \geq 2^&#123;2\kappa&#125;</span> and
        <span class="math">p^&#123;t-n&#125; \geq 2^&#123;\kappa&#125;</span>.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 The Poseidon<span class="math">^\pi</span> Permutation
      </h3>
      <p class="text-gray-300">
        Let
        <span class="math">p &gt; 2^&#123;30&#125;</span> and
        <span class="math">t \geq 2</span>. The permutation
        <span class="math">\mathcal&#123;P&#125;</span> over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> is
      </p>
      <div class="math-block">
        \mathcal&#123;P&#125;(x) =
        \mathcal&#123;E&#125;_&#123;R_F-1&#125; \circ \cdots \circ
        \mathcal&#123;E&#125;_&#123;R_F/2&#125; \circ
        \mathcal&#123;I&#125;_&#123;R_P-1&#125; \circ \cdots \circ
        \mathcal&#123;I&#125;_0 \circ
        \mathcal&#123;E&#125;_&#123;R_F/2-1&#125; \circ \cdots \circ
        \mathcal&#123;E&#125;_0(x)
      </div>
      <p class="text-gray-300">
        with
        <span class="math">R_F = 8</span> external rounds and
        <span class="math">R_P</span> internal rounds. The external
        round applies S-boxes to the entire state; the internal round
        applies a single S-box to the first element. Both use a
        <span class="math">t \times t</span> MDS matrix
        <span class="math">M</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (MDS Matrix)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A matrix
            <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;t \times t&#125;</span>
            is MDS if and only if its branch number
            <span class="math">B(M) = t + 1</span>, equivalently if
            every submatrix is invertible.
          </p>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. SECURITY: INITIAL AND FINAL MATRIX MULTIPLICATIONS        -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Security: Initial and Final Matrix Multiplications
      </h2>
      <p class="text-gray-300">
        For block ciphers, initial/final affine layers do not affect
        security. For sponge functions, the situation differs. The
        first nonlinear layer can be skipped by adjusting
        <span class="math">IV</span> [BBLP22]. Similarly, omitting the
        final linear layer removes diffusion. Hence, an SPN for sponge
        use <strong>must</strong> start and end with a linear layer.
        For compression functions, these layers do not decrease
        security either.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. MORE EFFICIENT LINEAR LAYERS                              -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. More Efficient Linear Layers
      </h2>
      <p class="text-gray-300">
        We propose new linear layers that maintain the same security
        level while reducing operations. Goals: (1) minimize constant
        multiplications for plain performance, and (2) use small
        matrix entries replaceable by addition chains.
      </p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Matrix for the External Round
      </h3>
      <p class="text-gray-300">
        For
        <span class="math">t = 4t'</span>, we use
      </p>
      <div class="math-block">
        M_&#123;\mathcal&#123;E&#125;&#125; =
        \begin&#123;cases&#125;
        M_4 &amp; \text&#123;if &#125; t = 4, \\
        \mathrm&#123;circ&#125;(2 \cdot M_4, M_4, \ldots, M_4)
        &amp; \text&#123;if &#125; t \geq 8,
        \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">M_4</span> is the MDS matrix
      </p>
      <div class="math-block">
        M_4 = \begin&#123;pmatrix&#125;
        5 &amp; 7 &amp; 1 &amp; 3 \\
        4 &amp; 6 &amp; 1 &amp; 1 \\
        1 &amp; 3 &amp; 5 &amp; 7 \\
        1 &amp; 1 &amp; 4 &amp; 6
        \end&#123;pmatrix&#125;
      </div>
      <p class="text-gray-300">
        needing 8 additions and 4 constant multiplications per
        4-element block, totaling
        <span class="math">3t</span> Plonk constraints.
      </p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Matrix for the Internal Round
      </h3>
      <p class="text-gray-300">
        For partial rounds, MDS is not required. We use
      </p>
      <div class="math-block">
        M_&#123;\mathcal&#123;I&#125;&#125; =
        \begin&#123;pmatrix&#125;
        \mu_0 &amp; 1 &amp; \cdots &amp; 1 \\
        1 &amp; \mu_1 &amp; \cdots &amp; 1 \\
        \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
        1 &amp; 1 &amp; \cdots &amp; \mu_&#123;t-1&#125;
        \end&#123;pmatrix&#125;
      </div>
      <p class="text-gray-300">
        with
        <span class="math">\mu_i \in \mathbb&#123;F&#125;_p \setminus \&#123;0,1\&#125;</span>.
        This needs
        <span class="math">2t-1</span> additions and
        <span class="math">t</span> multiplications.
      </p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8 mb-3">
        5.3 Preventing Arbitrarily Long Subspace Trails
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (Subspace Trail)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A sequence of subspaces
            <span class="math">(\mathfrak&#123;U&#125;_0, \ldots, \mathfrak&#123;U&#125;_r)</span>
            is a subspace trail of length
            <span class="math">r</span> for
            <span class="math">\mathcal&#123;F&#125;</span> if
            <span class="math">\mathcal&#123;F&#125;(\mathfrak&#123;U&#125;_i + \varphi_i) \subseteq \mathfrak&#123;U&#125;_&#123;i+1&#125; + \varphi_&#123;i+1&#125;</span>
            for appropriate cosets. It is invariant if all subspaces
            are equal.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        If the minimal polynomials of
        <span class="math">M_&#123;\mathcal&#123;I&#125;&#125;, M_&#123;\mathcal&#123;I&#125;&#125;^2, \ldots</span>
        are irreducible and of maximum degree, no arbitrarily long
        subspace trail exists [GRS21].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. POSEIDON2 SPECIFICATION                                   -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Poseidon2<span class="math">^\pi</span> Specification
      </h2>
      <p class="text-gray-300">
        The permutation
        <span class="math">\mathcal&#123;P&#125;_2</span> over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> is
      </p>
      <div class="math-block">
        \mathcal&#123;P&#125;_2(x) =
        \mathcal&#123;E&#125;_&#123;R_F-1&#125; \circ \cdots \circ
        \mathcal&#123;E&#125;_&#123;R_F/2&#125; \circ
        \mathcal&#123;I&#125;_&#123;R_P-1&#125; \circ \cdots \circ
        \mathcal&#123;I&#125;_0 \circ
        \mathcal&#123;E&#125;_&#123;R_F/2-1&#125; \circ \cdots \circ
        \mathcal&#123;E&#125;_0(M_&#123;\mathcal&#123;E&#125;&#125;
        \cdot x)
      </div>
      <p class="text-gray-300">
        External rounds use
        <span class="math">M_&#123;\mathcal&#123;E&#125;&#125;</span>;
        internal rounds use
        <span class="math">M_&#123;\mathcal&#123;I&#125;&#125;</span>
        with a single round constant
        <span class="math">\hat&#123;c&#125;_0^&#123;(i)&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>Differences from
        Poseidon<span class="math">^\pi</span>:</strong> (1) initial
        linear layer
        <span class="math">M_&#123;\mathcal&#123;E&#125;&#125;</span>,
        (2) two different linear layers for
        <span class="math">t \geq 4</span>, (3) one round constant per
        internal round.
      </p>
      <p class="text-gray-300">
        <strong>Instances</strong> (some examples for 2-to-1
        compressions):
      </p>
      <table class="w-full text-sm">
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">(n, t, d)</span></th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">R_F</span></th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">R_P</span></th>
          </tr>
        </thead>
        <tbody class="text-gray-300">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(31, 16, 5)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">14</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(31, 24, 5)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">22</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(64, 8, 7)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">22</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(64, 12, 7)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">22</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(256, 2, 5)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">56</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">(256, 3, 5)</td>
            <td class="py-2 px-3">8</td>
            <td class="py-2 px-3">56</td>
          </tr>
        </tbody>
      </table>
    </section>

    <!-- ============================================================ -->
    <!-- 7. SECURITY ANALYSIS                                         -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7. Security Analysis</h2>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 Statistical Attacks
      </h3>
      <p class="text-gray-300">
        <strong>Differential Attacks.</strong> The branch number of
        <span class="math">M_&#123;\mathcal&#123;E&#125;&#125;</span>
        is
        <span class="math">b = t/4 + 4 \geq 5</span>. Six external
        rounds suffice for security, as in
        Poseidon<span class="math">^\pi</span>. Other statistical
        attacks (linear [Mat93], truncated differential [Knu94], rebound
        [M+09]) are similarly covered.
      </p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8 mb-3">
        7.2 Algebraic Attacks
      </h3>
      <p class="text-gray-300">
        <strong>Interpolation Attack.</strong> Maximum degrees and
        monomial counts match for both schemes.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3 (CICO Problem)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            <span class="math">\mathcal&#123;P&#125;</span> is
            <span class="math">(\lambda, x_2, y_1)</span>-secure
            w.r.t. CICO if no algorithm with complexity
            <span class="math">&lt; \lambda</span> finds
            <span class="math">x_1, y_2</span> such that
            <span class="math">\mathcal&#123;P&#125;(x_1 \| x_2) = y_1 \| y_2</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Grobner Basis Attacks.</strong> No significant
        difference between
        Poseidon<span class="math">^\pi</span> and
        Poseidon2<span class="math">^\pi</span> was observed.
      </p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8 mb-3">
        7.3 Attack from Bariant et al. [BBLP22]
      </h3>
      <p class="text-gray-300">
        This attack skips the first round when solving CICO, requiring
        <span class="math">S(xy) = S(x)S(y)</span> (true for power
        maps). The initial linear layer in
        Poseidon2<span class="math">^\pi</span> reduces the advantage
        to 1 round. Combined with the 12.5% internal round margin, the
        scheme remains secure.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 8. PERFORMANCE EVALUATION                                    -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">8. Performance Evaluation</h2>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8 mb-3">
        8.1 Theoretical Comparison
      </h3>
      <p class="text-gray-300">
        For
        <span class="math">\log_2(p) \approx 64</span>, the number of
        linear-layer operations is reduced significantly, especially
        for the external rounds.
      </p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8 mb-3">
        8.2 Implementation and Benchmarks
      </h3>
      <p class="text-gray-300">
        Rust benchmarks on Intel i7-6700K for three primes (BLS12
        255-bit, Goldilocks 64-bit, Babybear 31-bit). Performance in
        <span class="math">\mu s</span>:
      </p>
      <table class="w-full text-sm">
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-400">
              Permutation</th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">t=2</span></th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">t=3</span></th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">t=4</span></th>
            <th class="text-left py-2 px-3 text-gray-400">
              <span class="math">t=8</span></th>
          </tr>
        </thead>
        <tbody class="text-gray-300">
          <tr>
            <td class="py-1 px-3" colspan="5">
              <em class="text-gray-500">
                <span class="math">p_&#123;\text&#123;BLS12&#125;&#125;</span>,
                255-bit
              </em>
            </td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Poseidon<span class="math">^\pi</span></td>
            <td class="py-2 px-3">11.78</td>
            <td class="py-2 px-3">16.99</td>
            <td class="py-2 px-3">22.26</td>
            <td class="py-2 px-3">53.46</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Neptune</td>
            <td class="py-2 px-3">&ndash;</td>
            <td class="py-2 px-3">&ndash;</td>
            <td class="py-2 px-3">17.45</td>
            <td class="py-2 px-3">30.05</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">GMiMC</td>
            <td class="py-2 px-3">20.63</td>
            <td class="py-2 px-3">21.86</td>
            <td class="py-2 px-3">22.96</td>
            <td class="py-2 px-3">26.97</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">
              Poseidon2<span class="math">^\pi</span></td>
            <td class="py-2 px-3">6.49</td>
            <td class="py-2 px-3">7.30</td>
            <td class="py-2 px-3">13.30</td>
            <td class="py-2 px-3">22.12</td>
          </tr>
        </tbody>
      </table>
      <p class="text-gray-300">
        Poseidon2<span class="math">^\pi</span> achieves up to 4x
        speedup for 24-word instances and &gt;2x even for 3-word.
      </p>

      <h3 id="sec-8.3" class="text-xl font-semibold mt-8 mb-3">
        8.3 Efficient Plonkish Version
      </h3>
      <p class="text-gray-300">
        We show that
        <span class="math">(t-1)</span> polynomial equations suffice
        (vs. <span class="math">t</span> in [32, App. E]).
      </p>

      <div class="formal-block formal-block-proposition">
        <div class="formal-block-title text-violet-400">
          Proposition 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            If
            <span class="math">\mathcal&#123;M&#125;</span> has no
            invariant subspace trail, the state is uniquely determined
            by S-box inputs in
            <span class="math">t</span> preceding rounds.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        Total: about
        <span class="math">t \cdot R_F + R_P - t + 1</span>
        constraints of degree <span class="math">d</span>.
      </p>
      <p class="text-gray-300">
        <strong>Acknowledgements.</strong> We thank Nicholas Mainardi
        and the anonymous reviewers for their contributions.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A. Efficient Circulant MDS Matrices
      </h2>
      <p class="text-gray-300">
        Circulant matrix&ndash;vector products can be computed via FFT
        in
        <span class="math">\mathcal&#123;O&#125;(t \log_2(t))</span>
        using the isomorphism with
        <span class="math">\mathbb&#123;F&#125;_p[X]/(X^t - 1)</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B                                                   -->
    <!-- ============================================================ -->

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B. Efficient Computation of
        <span class="math">M_&#123;\mathcal&#123;E&#125;&#125;</span>
      </h2>
      <p class="text-gray-300">
        <span class="math">M_4 \cdot x</span> requires 8 additions
        and 4 multiplications (by 2 and 4). For state size
        <span class="math">t</span>, repeat
        <span class="math">t/4</span> times plus
        <span class="math">2t</span> finalization additions.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX C                                                   -->
    <!-- ============================================================ -->

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix C. Optimized Feistel-ERF Implementation
      </h2>
      <p class="text-gray-300">
        An accumulator-based approach reduces <span class="math">\text&#123;GMiMC&#125;_&#123;\text&#123;erf&#125;&#125;</span> [AGP+19]
        per-round operations to a constant, independent of
        <span class="math">t</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ul class="text-sm text-gray-400 space-y-2 mt-4 list-none">
        <li>
          <span class="text-gray-500">[AAB+20]</span>
          A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and
          A. Szepieniec. "Design of Symmetric-Key Primitives for
          Advanced Cryptographic Protocols". IACR Trans. Symmetric
          Cryptol. 2020(3).
        </li>
        <li>
          <span class="text-gray-500">[ABM23]</span>
          T. Ashur, T. Buschman, and M. Mahzoun. "Algebraic
          cryptanalysis of POSEIDON". ePrint 2023/537.
        </li>
        <li>
          <span class="text-gray-500">[ACG+19]</span>
          M. R. Albrecht et al. "Algebraic Cryptanalysis of
          STARK-Friendly Designs". ASIACRYPT 2019.
        </li>
        <li>
          <span class="text-gray-500">[AD18]</span>
          T. Ashur and S. Dhooghe. "Marvellous: a STARK-friendly
          family of cryptographic primitives". ePrint 2018/1098.
        </li>
        <li>
          <span class="text-gray-500">[AGP+19]</span>
          M. R. Albrecht et al. "Feistel Structures for MPC, and
          More". ESORICS 2019.
          <a href="/papers/feistel-structures-mpc-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[AGR+16]</span>
          M. R. Albrecht et al. "MiMC: Efficient Encryption and
          Cryptographic Hashing with Minimal Multiplicative
          Complexity". ASIACRYPT 2016.
        </li>
        <li>
          <span class="text-gray-500">[AKMQ22]</span>
          J.-P. Aumasson, D. Khovratovich, B. Mennink, and
          P. Quine. "SAFE (Sponge API for Field Elements)". 2022.
          <a href="/papers/safe-sponge-api-2023"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[ASTW22]</span>
          M. Ambrona, A. Schmitt, R. R. Toledo, and D. Willems.
          "New optimization techniques for PlonK's arithmetization".
          ePrint 2022/462.
          <a href="/papers/plonk-optimization-2022"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[BBLP22]</span>
          A. Bariant, C. Bouvier, G. Leurent, and L. Perrin.
          "Algebraic Attacks Against Some Arithmetization-Oriented
          Primitives". IACR Trans. Symmetric Cryptol. 2022(3).
        </li>
        <li>
          <span class="text-gray-500">[BBP+22]</span>
          C. Bouvier et al. "Anemoi Permutations and Jive
          Compression Mode". ePrint 2022/840.
          <a href="/papers/anemoi-2022"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[BCD+20]</span>
          T. Beyne et al. "Out of Oddity &ndash; New Cryptanalytic
          Techniques Against Symmetric Primitives Optimized for
          Integrity Proof Systems". CRYPTO 2020.
          <a href="/papers/out-of-oddity-2020"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[BDPVA07]</span>
          G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche.
          "Sponge functions". Ecrypt Hash Workshop 2007.
        </li>
        <li>
          <span class="text-gray-500">[BDPVA08]</span>
          G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche.
          "On the Indifferentiability of the Sponge Construction".
          EUROCRYPT 2008.
        </li>
        <li>
          <span class="text-gray-500">[BRS02]</span>
          J. Black, P. Rogaway, and T. Shrimpton. "Black-Box
          Analysis of the Block-Cipher-Based Hash-Function
          Constructions from PGV". CRYPTO 2002.
        </li>
        <li>
          <span class="text-gray-500">[BS+18a]</span>
          E. Ben-Sasson et al. "Fast Reed-Solomon Interactive Oracle
          Proofs of Proximity". ICALP 2018.
        </li>
        <li>
          <span class="text-gray-500">[BS+18b]</span>
          E. Ben-Sasson et al. "Scalable, transparent, and
          post-quantum secure computational integrity".
          ePrint 2018/46.
        </li>
        <li>
          <span class="text-gray-500">[BS+19]</span>
          E. Ben-Sasson et al. "Scalable Zero Knowledge with No
          Trusted Setup". CRYPTO 2019.
        </li>
        <li>
          <span class="text-gray-500">[BS90]</span>
          E. Biham and A. Shamir. "Differential Cryptanalysis of
          DES-like Cryptosystems". CRYPTO 1990.
        </li>
        <li>
          <span class="text-gray-500">[Dam89]</span>
          I. Damgard. "A Design Principle for Hash Functions".
          CRYPTO 1989.
        </li>
        <li>
          <span class="text-gray-500">[DK10]</span>
          O. Dunkelman and N. Keller. "The effects of the omission
          of last round's MixColumns on AES". Inf. Process. Lett.
          2010.
        </li>
        <li>
          <span class="text-gray-500">[DL18]</span>
          S. Duval and G. Leurent. "MDS Matrices with Lightweight
          Circuits". IACR Trans. Symmetric Cryptol. 2018(2).
        </li>
        <li>
          <span class="text-gray-500">[DR01]</span>
          J. Daemen and V. Rijmen. "The Wide Trail Design Strategy".
          IMA 2001.
        </li>
        <li>
          <span class="text-gray-500">[F+93]</span>
          J.-C. Faugere et al. "Efficient Computation of
          Zero-Dimensional Grobner Bases by Change of Ordering".
          J. Symb. Comput. 1993.
        </li>
        <li>
          <span class="text-gray-500">[G+23]</span>
          L. Grassi et al. "Monolith: Circuit-Friendly Hash
          Functions with New Nonlinear Layers". ePrint 2023/1025.
        </li>
        <li>
          <span class="text-gray-500">[GHR+23]</span>
          L. Grassi et al. "Horst Meets Fluid-SPN: Griffin for
          Zero-Knowledge Applications". CRYPTO 2023.
          <a href="/papers/griffin-2022"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKL+22]</span>
          L. Grassi et al. "Reinforced Concrete: A Fast Hash
          Function for Verifiable Computation". CCS 2022.
          <a href="/papers/reinforced-concrete-2021"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKR+19]</span>
          L. Grassi, D. Khovratovich, A. Roy, C. Rechberger, and
          M. Schofnegger. "Poseidon: A New Hash Function for
          Zero-Knowledge Proof Systems". ePrint 2019/458.
          <a href="/papers/poseidon-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKR+21]</span>
          L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and
          M. Schofnegger. "Poseidon: A New Hash Function for
          Zero-Knowledge Proof Systems". USENIX Security 2021.
          <a href="/papers/poseidon-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GKRS22]</span>
          L. Grassi, D. Khovratovich, S. Ronjom, and
          M. Schofnegger. "The Legendre Symbol and the Modulo-2
          Operator in Symmetric Schemes". IACR Trans. Symmetric
          Cryptol. 2022(1).
        </li>
        <li>
          <span class="text-gray-500">[GLR+20]</span>
          L. Grassi et al. "On a Generalization of
          Substitution-Permutation Networks: The HADES Design
          Strategy". EUROCRYPT 2020.
          <a href="/papers/hades-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[GOPS22]</span>
          L. Grassi, S. Onofri, M. Pedicini, and L. Sozzi.
          "Invertible Quadratic Non-Linear Layers for
          MPC-/FHE-/ZK-Friendly Schemes". IACR Trans. Symmetric
          Cryptol. 2022(3).
        </li>
        <li>
          <span class="text-gray-500">[Gro16]</span>
          J. Groth. "On the Size of Pairing-Based Non-interactive
          Arguments". EUROCRYPT 2016.
        </li>
        <li>
          <span class="text-gray-500">[GRR16]</span>
          L. Grassi, C. Rechberger, and S. Ronjom. "Subspace Trail
          Cryptanalysis and its Applications to AES". IACR Trans.
          Symmetric Cryptol. 2016(2).
        </li>
        <li>
          <span class="text-gray-500">[GRS21]</span>
          L. Grassi, C. Rechberger, and M. Schofnegger. "Proving
          Resistance Against Infinitely Long Subspace Trails".
          IACR Trans. Symmetric Cryptol. 2021(2).
        </li>
        <li>
          <span class="text-gray-500">[GW22]</span>
          A. Gabizon and Z. J. Williamson. "Turbo-PLONK". 2022.
        </li>
        <li>
          <span class="text-gray-500">[GWC19]</span>
          A. Gabizon, Z. J. Williamson, and O. Ciobotaru. "PLONK".
          ePrint 2019/953.
          <a href="/papers/plonk-2019"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[HL22]</span>
          Horizen Labs. "ginger-lib". 2022.
        </li>
        <li>
          <span class="text-gray-500">[IAIK21]</span>
          IAIK. "Hash functions for Zero-Knowledge applications
          Zoo". Graz University of Technology, 2021.
        </li>
        <li>
          <span class="text-gray-500">[JK97]</span>
          T. Jakobsen and L. R. Knudsen. "The Interpolation Attack
          on Block Ciphers". FSE 1997.
        </li>
        <li>
          <span class="text-gray-500">[K+16]</span>
          S. Kolbl et al. "Haraka v2". IACR Trans. Symmetric
          Cryptol. 2016(2).
        </li>
        <li>
          <span class="text-gray-500">[Knu94]</span>
          L. R. Knudsen. "Truncated and Higher Order Differentials".
          FSE 1994.
        </li>
        <li>
          <span class="text-gray-500">[KR21]</span>
          N. Keller and A. Rosemarin. "Mind the Middle Layer: The
          HADES Design Strategy Revisited". EUROCRYPT 2021.
          <a href="/papers/hades-revisited-2020"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[LAAZ11]</span>
          G. Leander et al. "A Cryptanalysis of PRINTcipher: The
          Invariant Subspace Attack". CRYPTO 2011.
        </li>
        <li>
          <span class="text-gray-500">[LMR15]</span>
          G. Leander, B. Minaud, and S. Ronjom. "A Generic Approach
          to Invariant Subspace Attacks". EUROCRYPT 2015.
        </li>
        <li>
          <span class="text-gray-500">[M+09]</span>
          F. Mendel et al. "The Rebound Attack: Cryptanalysis of
          Reduced Whirlpool and Grostl". FSE 2009.
        </li>
        <li>
          <span class="text-gray-500">[Mat93]</span>
          M. Matsui. "Linear Cryptanalysis Method for DES Cipher".
          EUROCRYPT 1993.
        </li>
        <li>
          <span class="text-gray-500">[Mer89]</span>
          R. C. Merkle. "A Certified Digital Signature".
          CRYPTO 1989.
        </li>
        <li>
          <span class="text-gray-500">[PGV93]</span>
          B. Preneel, R. Govaerts, and J. Vandewalle. "Hash
          Functions Based on Block Ciphers". CRYPTO 1993.
        </li>
        <li>
          <span class="text-gray-500">[Pol22]</span>
          Polygon. "Introducing Plonky2". 2022.
        </li>
        <li>
          <span class="text-gray-500">[RPO22]</span>
          T. Ashur et al. "Rescue-Prime Optimized".
          ePrint 2022/1577.
          <a href="/papers/rescue-prime-optimized-2022"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[RZ23]</span>
          RISC Zero. "RISC Zero: General-Purpose Verifiable
          Computing". 2023.
        </li>
        <li>
          <span class="text-gray-500">[S+23]</span>
          A. Szepieniec et al. "The Tip5 Hash Function for Recursive
          STARKs". ePrint 2023/107.
          <a href="/papers/tip5-2023"
            class="text-blue-400 hover:text-blue-300"
          >[page on this site]</a>
        </li>
        <li>
          <span class="text-gray-500">[SK96]</span>
          B. Schneier and J. Kelsey. "Unbalanced Feistel Networks
          and Block Cipher Design". FSE 1996.
        </li>
        <li>
          <span class="text-gray-500">[SS21]</span>
          J. F. Sauer and A. Szepieniec. "SoK: Grobner Basis
          Algorithms for Arithmetization Oriented Ciphers".
          ePrint 2021/870.
        </li>
        <li>
          <span class="text-gray-500">[Sze21]</span>
          A. Szepieniec. "On the Use of the Legendre Symbol in
          Symmetric Cipher Design". ePrint 2021/984.
        </li>
        <li>
          <span class="text-gray-500">[Zca22]</span>
          Zcash. "halo2". 2022.
        </li>
      </ul>
    </section>
  </article>
</BaseLayout>
