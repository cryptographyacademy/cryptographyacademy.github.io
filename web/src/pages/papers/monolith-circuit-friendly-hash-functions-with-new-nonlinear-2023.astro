---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1025';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Monolith: Circuit-Friendly Hash Functions with New Nonlinear Layers for Fast and Constant-Time Implementations';
const AUTHORS_HTML = 'Lorenzo Grassi, Dmitry Khovratovich, Reinhard L&uuml;ftenegger, Christian Rechberger, Markus Schofnegger, Roman Walch';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Hash functions are a crucial component in incrementally verifiable computation (IVC) protocols and applications. Among those, recursive SNARKs and folding schemes require hash functions to be both fast in native CPU computations and compact in algebraic descriptions (constraints). However, neither SHA-2/3 nor newer algebraic constructions, such as Poseidon, achieve both requirements.
In this work we overcome this problem in several steps. First, for certain prime field domains we propose a new design strategy called Kintsugi, which explains how to construct nonlinear layers of high algebraic degree which allow fast native implementations and at the same time also an efficient circuit description for zero-knowledge applications. Then we suggest another layer, based on the Feistel Type-3 scheme, and prove wide trail bounds for its combination with an MDS matrix.
We propose a new permutation design named Monolith to be used as a sponge or compression function. It is the first arithmetization-oriented function with a native performance comparable to SHA3-256. At the same time, it outperforms Poseidon in a circuit using the Merkle tree prover in the Plonky2 framework. Contrary to previously proposed designs, Monolith also allows for efficient constant-time native implementations which mitigates the risk of side-channel attacks</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Hash Functions &middot; Monolith &middot; Zero Knowledge</p>
    </section>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Well-Definition and Bijectivity</h3>

    <p class="text-gray-300">Here we prove that our  <span class="math">\\mathcal{C} \\circ \\mathcal{S} \\circ \\mathcal{D}(\\cdot)</span>  defined in Eq. (2) and in particular its  <span class="math">\\mathcal{S}</span>  components are invertible and well-defined.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let p be a prime and  <span class="math">\\{\\tau_i\\}</span>  the bucket decomposition aligned with p'. Then Kintsugi (Eq. (2)) with the S-boxes satisfying Eq. (4) is bijective over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We consider the natural extension of the transformation  <span class="math">C \\circ S \\circ D(\\cdot)</span>  to the domain  <span class="math">\\mathbb{Z}_{2^{\\rho}}</span>  and denote it by  <span class="math">\\mathcal{T}</span> . Then we proceed in two steps. First we prove that  <span class="math">\\mathcal{T}</span>  is bijective over  <span class="math">\\mathbb{Z}_{2^{\\rho}}</span> . Then we prove that for any x &lt; p we have  <span class="math">\\mathcal{T}(x) &lt; p</span> . These two facts imply the result.</p>

    <p class="text-gray-300">Transformation  <span class="math">\\mathcal{T}</span> . We define  <span class="math">\\mathcal{T}: \\mathbb{Z}_{2^p} \\to \\mathbb{Z}_{2^p}</span>  as  <span class="math">\\mathcal{T}:=\\mathcal{C}&#x27; \\circ \\mathcal{S} \\circ \\mathcal{D}&#x27;(\\cdot)</span> , where  <span class="math">\\mathcal{D}&#x27;</span>  is a generalization of  <span class="math">\\mathcal{D}</span>  that takes inputs from  <span class="math">\\mathbb{Z}_{2^p}</span>  instead of  <span class="math">\\mathbb{Z}_p</span> , i.e.,</p>

    <p class="text-gray-300"><span class="math">$x \\in \\mathbb{Z}_{2^{\\rho}} \\mapsto (x&#x27;_1, x&#x27;_2, \\dots, x&#x27;_s) \\in \\mathbb{Z}_{2^{\\tau_1}} \\times \\mathbb{Z}_{2^{\\tau_2}} \\times \\dots \\times \\mathbb{Z}_{2^{\\tau_s}},</span>$</p>

    <p class="text-gray-300">where  <span class="math">x = \\sum_{i=1}^{s} 2^{\\rho_i} \\cdot x_i&#x27;</span>  as before. Further,  <span class="math">\\mathcal{S}</span>  is defined as before and  <span class="math">\\mathcal{C}&#x27;</span>  is the inverse of  <span class="math">\\mathcal{D}&#x27;</span>  (basically, it corresponds to  <span class="math">\\mathcal{C}</span>  without the modular reduction).</p>

    <p class="text-gray-300">Bijectivity of  <span class="math">\\mathcal{T}</span> . This follows from the fact that  <span class="math">\\mathcal{D}&#x27;</span> ,  <span class="math">\\mathcal{S}</span> , and  <span class="math">\\mathcal{C}&#x27;</span>  are bijective.</p>

    <p class="text-gray-300">Finally, we have to prove that  <span class="math">\\forall x \\in \\{0, \\dots, p-1\\} : \\mathcal{T}(x) \\in \\{0, \\dots, p-1\\}</span> . Let us start by analyzing the case x = p-1. If p-1 = p' (i.e.,  <span class="math">p \\neq 1 \\mod 4</span> ), then all S-boxes act as identity functions (due to Eq. (4)), and thus  <span class="math">\\mathcal{T}(x) = x &lt; p</span> . Instead, if  <span class="math">x = p-1 \\neq p&#x27;</span> , then  <span class="math">\\mathcal{D}(x)</span>  differs from  <span class="math">\\mathcal{D}(p&#x27;)</span>  in the first bucket: the former ends with 10 and the latter with 11. As  <span class="math">2^{\\tau_s} - 1</span>  is a fixed point of the S-box  <span class="math">\\mathcal{S}_s</span> , we get that  <span class="math">\\mathcal{S}_s(x_s&#x27;) &lt; 2^{\\tau_s} - 1 = z_s</span>  and so  <span class="math">\\mathcal{T}(x) &lt; p&#x27; \\leq p</span> .</p>

    <p class="text-gray-300">Next, let us consider the case x . Consider the binary form of <math>x, and let b be the most significant bit in which it differs from p'. Clearly, b is in a 1-bucket of p' with some index i. Note that for each j &lt; i all S-boxes  <span class="math">S_j</span>  act as identity functions, that is,  <span class="math">S_i(x_i) = S(z_i) = z_i</span> . For  <span class="math">x_i&#x27; &lt; 2^{\\tau_i} - 1 = z_i</span> , we have  <span class="math">S_i(x_i&#x27;) &lt; 2^{\\tau_i} - 1 = z_i</span>  as  <span class="math">2^{\\tau_i} - 1</span>  is a fixed point of the S-box  <span class="math">S_i</span> . This implies that if x , then <math>T(x) .</p>

    <p class="text-gray-300">The two previous facts together with  <span class="math">\\mathcal{T}</span>  being bijective imply that  <span class="math">\\mathcal{T}(x) &gt; p-1</span>  for each x &gt; p-1. It follows that  <span class="math">\\mathcal{C} \\circ \\mathcal{S} \\circ \\mathcal{D}(x) \\in \\mathbb{F}_p</span>  for each  <span class="math">x \\in \\mathbb{F}_p</span> .</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Considerations about the Kintsugi Strategy</h3>

    <p class="text-gray-300">Due to the isomorphism between  <span class="math">\\mathbb{F}_2^{\\tau_i}</span>  and  <span class="math">\\mathbb{F}_{2^{\\tau_i}}</span> , almost any invertible AndRX transformation works well for  <span class="math">\\mathcal{S}</span>  and can be implemented in constant time as its components are basic x86 operations. Here we give some examples for  <span class="math">p = 2^n - 1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Bit Shuffle. Clearly, both  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  are fixed points under the bit shuffling operation for any  <span class="math">\\tau</span> . Moreover, it is essentially for free in hardware.</li>
    </ul>

    <p class="text-gray-300">- Efficient Linear Operations. Linear operations over  <span class="math">\\mathbb{F}_2^{\\tau}</span>  of the form</p>

    <p class="text-gray-300"><span class="math">$x \\mapsto x \\oplus (x \\lll i) \\oplus (x \\lll j)</span>$</p>

    <p class="text-gray-300">with nonzero  <span class="math">i \\neq j</span> , and where  <span class="math">\\ll</span>  denotes the circular shift operation, are (i) invertible for odd  <span class="math">\\tau</span>  and (ii) result in  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  being fixed points.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Efficient Nonlinear Operations. Nonlinear operations over  <span class="math">\\mathbb{F}_2^{\\tau}</span>  such as</li>
    </ul>

    <p class="text-gray-300"><span class="math">$x \\mapsto x \\oplus (\\bar{x} \\lll 1) \\odot (x \\lll 2)</span>$</p>

    <p class="text-gray-300">for odd  <span class="math">\\tau</span> , where  <span class="math">\\bar{x} := x \\oplus \\mathbf{1}^{\\tau}</span> , are also possible. This corresponds to the  <span class="math">\\chi</span> -function [Dae95, Table A.1] already used in Keccak/SHA-3, which is known to be invertible for  <span class="math">\\gcd(\\tau, 2) = 1</span> . Moreover,  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  are fixed points.</p>

    <p class="text-gray-300">An additional bit rotation may be needed to reduce the number of fixed points.</p>

    <p class="text-gray-300">Bars in Kintsugi and Reinforced Concrete. There are various differences between the Kintsugi strategy just described and the Bars functions proposed in Reinforced Concrete (and later used in Tip5). In Reinforced Concrete an element of  <span class="math">\\mathbb{F}_p</span>  is represented as a vector from  <span class="math">\\mathbb{Z}_{p_1} \\times \\cdots \\times \\mathbb{Z}_{p_l}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We rely on the structure of the prime p. Thanks to its composition of a few powers of two, the decomposition now is simply a bit extraction rather than a chain of modular reductions, which is expensive both natively and inside the proof system. The bijectivity of Kintsugi is guaranteed under the minor and easily satisfied condition that some specific inputs are fixed points.</li>
      <li>The S-boxes of Reinforced Concrete or Tip5 do not have a simple representation and must be implemented as tables both for native and circuit computations. The Kintsugi strategy instantiates the S-boxes with AndRX transformations, which are fast and constant-time in native x86 implementations but can easily be transformed to table lookups for circuits.</li>
    </ul>

    <p class="text-gray-300">Side-Channel Leakage and Countermeasures. Lookup tables in symmetric primitives are a well-known source of side channel leakage. When confidential information is processed (e.g., committing to coin secrets with ZK hash functions in privacy-preserving payment systems), an adversary may recover a large portion of it from timing differences of lookups into memory or caches. These techniques are well-known since at least two decades in the context of encryption [Pag02; Ber05; OST06], and the high-level ideas have found first applications in zero-knowledge proof systems [TBP20]. The lookup-oriented designs Reinforced Concrete and Tip5 use specific tables for which a constant-time implementation with reasonable overhead is nontrivial. It is thus of utmost importance to have a design where lookups can be replaced with constant-time operations.</p>

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8">2.5 Statistical and Algebraic Properties</h3>

    <p class="text-gray-300">Here we prove a generic statement that links algebraic and statistical properties of mappings over  <span class="math">\\mathbb{F}_p</span> , which we will use in the security analysis of Monolith.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">p \\geq 3</span>  be a prime number, and let  <span class="math">\\mathcal{F}_{sq}</span>  denote the squaring function  <span class="math">x \\to x^2</span>  over  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">\\mathsf{F}_{sq}</span>  be any interpolant of  <span class="math">\\mathcal{F}_{sq}</span>  over  <span class="math">\\mathbb{F}_2^{\\lceil \\log_2 p \\rceil}</span> , i.e., for any a &lt; p and its bit representation  <span class="math">\\mathsf{a}</span>  we have that  <span class="math">\\mathsf{F}_{sq}(\\mathsf{a})</span>  is the bit representation of  <span class="math">\\mathcal{F}_{sq}(\\mathsf{a})</span> . Then  <span class="math">\\mathsf{F}_{sq}</span>  has (multivariate) degree at least d, where d is the maximum positive integer such that  <span class="math">d &lt; \\log_2 \\sqrt{p}</span>  and  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd.<sup>5</sup></p>

    <p class="text-gray-300"><em>Proof.</em> We prove this result by contradiction. Suppose that the degree of  <span class="math">\\mathsf{F}_{sq}</span>  is smaller than d. Then the XOR sum of its outputs over any hypercube of dimension d is equal to zero [Lai94], including the hypercube</p>

    <p class="text-gray-300"><span class="math">$\\mathfrak{H} := \\{ \\mathsf{a}_0 = (0,0,\\dots,0), \\dots, \\mathsf{a}_{2^d-1} = (0,\\dots,0,\\underbrace{1,\\dots,1}_{d \\text{ ones}}) \\}.</span>$</p>

    <p class="text-gray-300">Note that  <span class="math">\\mathcal{F}(a_i) = i^2 &lt; p</span>  by the definition of d. Now consider  <span class="math">\\mathfrak{B} = \\{\\mathsf{a}_i \\in \\mathfrak{H} \\mid i &gt; 2^{d-0.5}\\}</span> , so that (i)  <span class="math">2^{2d} &gt; \\mathcal{F}(b \\in \\mathfrak{B}) &gt; 2^{2d-1}</span>  and (ii) the 2d-th least significant bit is set. By simple computation, the size of  <span class="math">\\mathfrak{B}</span>  is  <span class="math">2^d - \\lceil 2^{d-0.5} \\rceil</span> . Whenever this number is odd,  <span class="math">\\mathsf{F}</span>  does not XOR to 0 at the 2d-th least significant bit, which contradicts the previous fact. As a result, the squaring has at least degree d if  <span class="math">\\lfloor 2^{d-0.5} \\rfloor</span>  is odd and  <span class="math">d &lt; \\log_2 \\sqrt{p}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 3 (Differential).</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself with a differential  <span class="math">\\Delta_I \\to \\Delta_O</span>  holding with probability  <span class="math">0 &lt; \\alpha &lt; 1</span> , i.e.,  <span class="math">|\\{x \\in \\mathbb{F}_p \\mid \\mathcal{F}(x + \\Delta_I) = \\mathcal{F}(x) + \\Delta_O\\}| = p \\cdot \\alpha</span> . Then we have  <span class="math">\\deg(\\mathcal{F}) &gt; \\alpha \\cdot p</span> , where  <span class="math">\\deg(\\mathcal{F})</span>  is the degree of  <span class="math">\\mathcal{F}</span>  as a polynomial over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By definition,  <span class="math">\\mathcal{F}(x + \\delta_{in}) = \\mathcal{F}(x) + \\delta_{out}</span>  has at least  <span class="math">\\alpha \\cdot p</span>  solutions  <span class="math">x_1, x_2, \\ldots, x_{\\alpha p}</span> . Therefore, the polynomial  <span class="math">\\mathcal{G}(x) := \\mathcal{F}(x + \\delta_{in}) - \\mathcal{F}(x) - \\delta_{out}</span>  is divisible by the polynomial  <span class="math">(x - x_1) \\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_{\\alpha \\cdot p})</span>  of degree  <span class="math">\\alpha \\cdot p</span> , and so it has a degree of at least  <span class="math">\\alpha \\cdot p</span> . As the degree of the polynomial  <span class="math">\\mathcal{G}</span>  is smaller than the degree of  <span class="math">\\mathcal{F}</span>  by 1, we obtain that  <span class="math">\\deg(\\mathcal{F}) &gt; \\alpha \\cdot p</span> .</p>

    <p class="text-gray-300"><strong>Lemma 4 (Linear Approximation).</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself such that there exists a linear approximation (a,b) with probability  <span class="math">0 &lt; \\beta &lt; 1</span> , that is,  <span class="math">\\frac{|\\{x \\in \\mathbb{F}_p | \\mathcal{F}(x) = a \\cdot x + b\\}|}{p} = \\beta</span> . Then we have  <span class="math">\\deg(\\mathcal{F}) \\geq \\beta \\cdot p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By definition, the equation  <span class="math">\\mathcal{F}(x) = A \\cdot x + B</span>  has at least  <span class="math">\\beta \\cdot p</span>  solutions  <span class="math">x_1, x_2, \\ldots, x_{\\beta \\cdot p}</span> . Therefore, the polynomial  <span class="math">\\mathcal{G}(x) := \\mathcal{F}(x) - (a \\cdot x + b)</span>  is divisible by the polynomial  <span class="math">(x - x_1) \\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_{\\beta p})</span>  of degree  <span class="math">\\beta \\cdot p</span> . Similar to before, we conclude that F has degree at least equal to  <span class="math">\\beta \\cdot p</span> .</p>

    <p class="text-gray-300">Based on the previous result, we can immediately conclude the following.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself with b &lt; p fixed points, that is,  <span class="math">|\\{x \\in \\mathbb{F}_p : F(x) = x\\}| = b</span> . It follows that  <span class="math">\\deg(\\mathcal{F}) \\geq b</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup> For example,  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd for  <span class="math">d \\in \\{2, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 21, \\dots \\}</span> .</p>

    <p class="text-gray-300">The Kintsugi Bar is nonlinear but we will see in Section <a href="#page-19-0">6.1</a> that its high algebraic degree comes at the cost of weak differential properties. Thus if being used in an SPN construction, it would make it vulnerable to statistical (e.g., differential) cryptanalysis. For this reason, we introduce another nonlinear component defined as a Feistel Type-3 network <a href="#page-37-8">[ZMI89]</a> that complements Kintsugi Bars. By instantiating it via low-degree functions, it will allow us to provide strong argument for guaranteeing resistance against differential and statistical attacks in general. We follow the naming convention of Reinforced Concrete (the first lookup-based ZK-friendly hash function) where the nonlinear layer providing protection against statistical attacks is called Bricks, and use the same name for uniformity.</p>

    <p class="text-gray-300">Feistel Type-3. The Feistel Type-3 network is a member of a larger Feistel family <a href="#page-34-6">[HR10]</a>, which has been largely neglected in favour of SPN schemes in block cipher and hash function design, primarily for its complexity and worse diffusion properties. As already recalled in the introduction, a potential drawback of SPN schemes regards the fact that their invertibility depends on the fact that all their internal components are invertible as well. As it is well known, this is not the case of Feistel networks, which remain invertible independently of the details of their internal functions. For many prime order groups used in SNARKs, the smallest invertible power mapping is x 5 . As a result, we have found the Feistel Type-3 newtork instantiated with square maps x 7&rarr; x 2 to be particularly attractive as it is cheaper in circuits and, most importantly, its blend with an MDS layer yields statistical properties similar to those in regular SPNs.</p>

    <p class="text-gray-300">With nonlinear F<sup>i</sup> , Bricks<sup>F</sup> for t elements x1, . . . , x<sup>t</sup> is defined as</p>

    <p class="text-gray-300">Bricks<sup>F</sup>
<span class="math">$(x_1, ..., x_t) := (x_1, x_2 + \\mathcal{F}_1(x_1), x_3 + \\mathcal{F}_2(x_2), ..., x_t + \\mathcal{F}_{t-1}(x_{t-1})).</span>$
(5)</p>

    <p class="text-gray-300">Diffusion Layer. While Bricks<sup>F</sup> alone does not provide fast diffusion, a combination with a matrix layer increases the diffusion properties <a href="#page-32-4">[BMT13;</a> <a href="#page-32-5">BFM+16]</a>. This approach is well-known in the SPN design as the wide trail strategy <a href="#page-33-6">[DR01]</a>, where a lower bound for the number of &quot;active&quot; nonlinear components in any differential trail is proven, leading to strong arguments against differential attacks.</p>

    <p class="text-gray-300">Here we follow this line of research, and for the first time we derive bounds for the SPN structure where the nonlinear layer is a Feistel Type-3 function. For this, we work with matrices of Maximum Distance Separable (MDS) Codes for maximizing the number of active Fp-words over two consecutive rounds.</p>

    <p class="text-gray-300">Our New Bound. Now we obtain our main result on the differential properties of the Feistel-Type3-MDS combination. Our new bound improves the ones recently proposed in <a href="#page-34-5">[Gra23]</a> for an analogous (but different) scheme.</p>

    <p class="text-gray-300">Proposition 1. Consider an R-round construction, where each round consists of the application of Bricks<sup>F</sup> over F t <sup>q</sup> as in Eq. <a href="#page-11-0">(5)</a> followed by the multiplication with a  <span class="math">t \\times t</span>  MDS matrix. The minimum number  <span class="math">\\hat{c}</span>  of active functions  <span class="math">\\mathcal{F}_i</span>  in any differential trail satisfies</p>

    <p class="text-gray-300"><span class="math">$\\hat{c} \\geq (t-1) \\cdot \\left(\\frac{3R-2-(-2)^{1-R}}{9}\\right) \\geq (t-1) \\cdot \\left(\\frac{3R-2.5}{9}\\right) \\, .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Denote the number of active words in the input and the output of the i-th Bricks<sup>F</sup> layer by  <span class="math">a_i</span>  and  <span class="math">b_i</span> , respectively. Then we exploit two properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Each active input word  <span class="math">x_i</span>  to  <span class="math">Bricks^F</span>  activates  <span class="math">\\mathcal{F}_i</span>  if i &lt; t, hence a words activate at least a 1 functions  <span class="math">\\mathcal{F}_i</span> .</li>
      <li>Each active output word  <span class="math">y_i</span>  of  <span class="math">\\operatorname{Bricks}^F</span>  implies that  <span class="math">\\mathcal{F}_{i-1}</span>  or  <span class="math">\\mathcal{F}_{i-2}</span>  is active if i &gt; 1. Hence b words activate at least  <span class="math">\\frac{b-1}{2}</span>  functions.</li>
    </ul>

    <p class="text-gray-300">With the MDS property, which states that  <span class="math">b_k + a_{k+1} \\ge t + 1</span>  for each  <span class="math">k \\ge 1</span> , we obtain the following for the number  <span class="math">c_k</span>  of active functions  <span class="math">\\mathcal{F}_i</span>  in round k:</p>

    <p class="text-gray-300"><span class="math">$c_{1} \\geq \\max \\left\\{ a_{1} - 1, \\frac{b_{1} - 1}{2} \\right\\}, \\quad b_{1} + a_{2} \\geq t + 1,</span>$</p>

    <p class="text-gray-300"><span class="math">$c_{2} \\geq \\max \\left\\{ a_{2} - 1, \\frac{b_{2} - 1}{2} \\right\\}, \\quad b_{2} + a_{3} \\geq t + 1,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\vdots</span>$</p>

    <p class="text-gray-300"><span class="math">$c_{r-1} \\geq \\max \\left\\{ a_{r-1} - 1, \\frac{b_{r-1} - 1}{2} \\right\\}, \\quad b_{r-1} + a_{r} \\geq t + 1,</span>$</p>

    <p class="text-gray-300"><span class="math">$c_{r} \\geq \\max \\left\\{ a_{r} - 1, \\frac{b_{r-1} - 1}{2} \\right\\},</span>$</p>

    <p class="text-gray-300">for r rounds. Summing each two consecutive inequalities for  <span class="math">c_i</span> , we obtain</p>

    <p class="text-gray-300">
<span class="math">$2c_i + c_{i+1} \\ge 2\\frac{b_{i-1}}{2} + (a_{i+1} - 1) = b_i + a_{i+1} - 2 \\ge t - 1</span>$
(6)</p>

    <p class="text-gray-300">with the last inequality being the MDS property.</p>

    <p class="text-gray-300">W.l.o.g., let us find a bound for  <span class="math">\\hat{c}:=c_1+\\cdots+c_R</span>  where all  <span class="math">c_i</span>  are non-negative real values satisfying Eq. (6). First, the optimal  <span class="math">\\{c_i\\}</span>  make all inequalities equal. Indeed, suppose that  <span class="math">2c_j+c_{j+1}&gt;t-1</span>  but for all k&gt;j we have  <span class="math">2c_k+c_{k+1}=t-1</span> . Then by using  <span class="math">c&#x27;_j=c_j-\\epsilon</span> ,  <span class="math">c&#x27;_{j-1}=c_{j-1}+\\epsilon/2</span> ,  <span class="math">c&#x27;_{j-2}=c_{j-2}-\\epsilon/4</span>  for a small  <span class="math">\\epsilon</span>  Eq. (6) is still satisfied but  <span class="math">c_{min}</span>  decreases by  <span class="math">\\epsilon\\cdot(1-1/2+1/4-1/8+\\cdots)&gt;0</span> . Thus all inequalities are equations, i.e.,</p>

    <p class="text-gray-300"><span class="math">$2c_i + c_{i+1} = t - 1</span>$
.</p>

    <p class="text-gray-300">Then we observe that in the optimal  <span class="math">\\{c_i\\}</span>  it should hold that  <span class="math">c_R = 0</span> . Indeed otherwise we apply the same trick by setting  <span class="math">c_R&#x27; = c_R - \\epsilon</span> ,  <span class="math">c_{R-1}&#x27; = c_{R-1} + \\epsilon/2</span>  etc., again decreasing  <span class="math">c_{min}</span> . Thus, the minimum is achieved by  <span class="math">c_R = 0</span>  and</p>

    <p class="text-gray-300"><span class="math">$c_{R-1} = \\frac{t-1}{2}, \\quad c_{R-2} = \\frac{t-1}{4}, \\quad c_{R-3} = \\frac{3(t-1)}{8}, \\quad \\dots, \\quad c_{R-i} = \\frac{t-1}{3} \\cdot \\left(1 + \\frac{(-1)^{i+1}}{2^i}\\right).</span>$</p>

    <p class="text-gray-300">Substituting these values into the formula for  <span class="math">\\hat{c}</span> , we obtain</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\hat{c} &amp;= \\sum_{i=0}^{R-1} \\frac{t-1}{3} \\left( 1 + \\frac{(-1)^{i+1}}{2^i} \\right) = \\frac{t-1}{3} \\sum_{i=0}^{R-1} \\left( 1 + \\frac{(-1)^{i+1}}{2^i} \\right) = \\frac{t-1}{3} \\left( R - \\sum_{i=0}^{R-1} (-2)^{-i} \\right) \\\\ &amp;= \\frac{t-1}{3} \\left( R - \\frac{2(1-(-2)^{-R})}{3} \\right) = (t-1) \\left( \\frac{3R-2-(-2)^{1-R}}{9} \\right). \\end{split}</span>$</p>

    <p class="text-gray-300">Remark 1 (On the Design Rationale). Our choice of Feistel versus SPN is purely performance-driven: fewer non-constant field multiplications in the former when using  <span class="math">x \\mapsto x^2</span> . However, neither Feistel Type-3 nor Type-2<sup>6</sup> alone would provide good statistical properties [HR10]. Notably, the combination of Type-2 with an MDS layer would not allow us to derive optimal bounds regarding the number of active nonlinear functions in such a simple and elegant way either.</p>

    <p class="text-gray-300">Monolith is a family of permutations which can be used within hash functions and other constructions. They use prime fields  <span class="math">\\mathbb{F}_p</span>  with two options for p, namely</p>

    <p class="text-gray-300">
<span class="math">$p_{\\text{Goldilocks}} = 2^{64} - 2^{32} + 1</span>$
and  <span class="math">p_{\\text{Mersenne}} = 2^{31} - 1.</span>  (7)</p>

    <p class="text-gray-300">The permutation Monolith-64 is defined over  <span class="math">p_{\\texttt{Goldilocks}}</span>  with the state consisting of t=8 or t=12 elements. The permutation Monolith-31 is defined over  <span class="math">p_{\\texttt{Mersenne}}</span>  with the state consisting of t=16 or t=24 elements.</p>

    <p class="text-gray-300">Monolith supports sponge modes and a 2-to-1 compression function.</p>

    <p class="text-gray-300"><strong>Sponge-Based Schemes.</strong> First, Monolith can instantiate a sponge [BDP+07; BDP+08] and thus various symmetric constructions such as variable-length hash functions, commitment schemes, authenticated encryption, and stream ciphers. The recently proposed SAFE framework [AKM+22; KBM23] instructs how to handle domain separation and padding in these constructions. In a sponge, the permutation state is split into an outer part with a rate of r elements and an inner part with a capacity of c elements. As we uniformly suggest a security level close to 128 bits, we set  <span class="math">c = \\left\\lfloor \\frac{256}{\\rho} \\right\\rfloor</span>  and r = 2c.</p>

    <p class="text-gray-300"><strong>2-to-1 Compression Function.</strong> We also suggest a fixed-length 2-to-1 compression function. Concretely, it takes  <span class="math">t \\ \\mathbb{F}_p</span>  elements as input and produces  <span class="math">t/2 \\ \\mathbb{F}_p</span>  elements as output. It is defined as  <span class="math">x \\in \\mathbb{F}_p^t \\mapsto \\mathrm{Tr}_{t/2}(\\mathcal{P}(x)+x) \\in \\mathbb{F}_p^t</span> , where  <span class="math">\\mathrm{Tr}_{t/2}</span>  yields the first t/2 elements of the inputs. This compression function can be used in Merkle trees and has recently also been applied in similar constructions, including Anemoi [BBC+23], GRIFFIN [GHR+23], and POSEIDON2 [GKS23]. For a security level of close to 128 bits, we set  <span class="math">t = \\left\\lfloor \\frac{512}{\\rho} \\right\\rfloor</span> , i.e., t = 8 for the 64-bit field and t = 16 for the 31-bit field (factually yielding slightly less than 128 bits).</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;6</sup> Type-2 Feistel turns state  <span class="math">\\{x_i\\}</span>  into  <span class="math">\\{y_i\\}</span>  where odd elements remain untouched and  <span class="math">y_{2i} = x_{2i+1} + \\mathcal{F}_i(x_{2i})</span> .</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4. One round of the Monolith construction, where  <span class="math">x_i, y_i \\in \\mathbb{F}_p</span> .</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Permutation Structure</h3>

    <p class="text-gray-300">The Monolith permutation is defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathtt{Monolith}(\\cdot) = \\mathcal{R}_R \\circ \\cdots \\circ \\mathcal{R}_2 \\circ \\mathcal{R}_1 \\circ \\mathtt{Concrete}(\\cdot),</span>$</p>

    <p class="text-gray-300">where R is the number of rounds and  <span class="math">\\mathcal{R}_i</span>  over  <span class="math">\\mathbb{F}_p^t</span>  are defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{R}_i(\\cdot) = c^{(i)} + \\mathtt{Concrete} \\circ \\mathtt{Bricks} \\circ \\mathtt{Bars}(\\cdot), \\qquad \\forall i \\in \\{1, 2, \\dots, R\\},</span>$</p>

    <p class="text-gray-300">where Concrete is a linear operation, Bars and Bricks are nonlinear operations over  <span class="math">\\mathbb{F}_p^t</span> ,  <span class="math">c^{(1)}, \\ldots, c^{(r-1)} \\in \\mathbb{F}_p^t</span>  are pseudo-random round constants, and  <span class="math">c^{(r)} = \\mathbf{0}</span> . Note that a single Concrete operation is applied before the first round. A graphical overview of one round of the construction is shown in Fig. 4.</p>

    <p class="text-gray-300">Round Constant Generation. The actual values of pseudo-randomly chosen round constants have no impact on the security. For completeness we provide a generation method in Appendix A.3.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8"><strong>4.3</strong> Bars</h3>

    <p class="text-gray-300">The Bars layer is defined as</p>

    <p class="text-gray-300">
<span class="math">$Bars(x_1, x_2, \\dots, x_t) := Bar(x_1) \\| \\dots \\| Bar(x_u) \\| x_{u+1} \\| \\dots \\| x_t</span>$
(8)</p>

    <p class="text-gray-300">for a t-element state, where  <span class="math">\\mathbf{u} \\in \\{1,\\ldots,t\\}</span>  denotes the number of Bar applications in a single round. We select  <span class="math">\\mathbf{u}</span>  such that  <span class="math">\\mathbf{u} \\cdot \\log_2 p \\approx 256</span> , i.e., the nonlinear part occupies around 256 bits of the state. Each Bar application is defined as</p>

    <p class="text-gray-300"><span class="math">$Bar(x) = C \\circ S \\circ D(x),</span>$</p>

    <p class="text-gray-300">where C, S and D are the operations defined in Section 2. In the following, we describe them individually for Monolith-64 and Monolith-31.</p>

    <p class="text-gray-300">Bars for Monolith-64. In Eq. (8) we set  <span class="math">t \\in \\{8, 12\\}</span>  (compression or sponge, resp.) and we set u = 4 (i.e., 4 Bar operations are applied in each round).</p>

    <p class="text-gray-300">Operations  <span class="math">\\mathcal{D}</span>  and  <span class="math">\\mathcal{C}</span> . We use a decomposition into 8-bit values such that</p>

    <p class="text-gray-300"><span class="math">$x = 2^{56}x_8&#x27; + 2^{48}x_7&#x27; + 2^{40}x_6&#x27; + 2^{32}x_5&#x27; + 2^{24}x_4&#x27; + 2^{16}x_3&#x27; + 2^8x_2&#x27; + x_1&#x27;.</span>$</p>

    <p class="text-gray-300">The composition  <span class="math">\\mathcal{C}</span>  is the inverse operation of the decomposition  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">S-Boxes S. In Eq. (3) we set s = 8. Then all  <span class="math">S_i</span>  over  <span class="math">\\mathbb{F}_2^8</span>  are defined as</p>

    <p class="text-gray-300">
<span class="math">$S_i(y) = (y \\oplus ((\\overline{y} \\ll 1) \\odot (y \\ll 2) \\odot (y \\ll 3))) \\ll 1, \\tag{9}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\ll</span>  is a circular shift (here we interpret an integer as a big-endian 8-bit string) and  <span class="math">\\overline{y}</span>  is the bitwise negation (see [Dae95, Table A.1]).</p>

    <p class="text-gray-300">Bars for Monolith-31. In Eq. (8) we set  <span class="math">t \\in \\{16, 24\\}</span>  (compression or sponge, resp.) and we set u = 8 (i.e., 8 Bar operations are applied in each round).</p>

    <p class="text-gray-300">Operations  <span class="math">\\mathcal{D}</span>  and  <span class="math">\\mathcal{C}</span> . The decomposition  <span class="math">\\mathcal{D}</span>  is given by</p>

    <p class="text-gray-300"><span class="math">$x = 2^{24}x_4&#x27; + 2^{16}x_3&#x27; + 2^8x_2&#x27; + x_1&#x27;,</span>$</p>

    <p class="text-gray-300">where  <span class="math">x_4&#x27; \\in \\mathbb{Z}_2^7</span>  and  <span class="math">x_3&#x27;, x_2&#x27;, x_1&#x27; \\in \\mathbb{Z}_2^8</span> . The composition  <span class="math">\\mathcal{C}</span>  is the inverse of  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">S-Boxes S. In Eq. (3) we set s=4 using  <span class="math">\\{8,7\\}</span> -bit lookup tables. Then, for  <span class="math">y\\in\\mathbb{F}_2^8</span>  and  <span class="math">y&#x27;\\in\\mathbb{F}_2^7</span> , the S-boxes are defined as (see [Dae95, Table A.1])</p>

    <p class="text-gray-300">
<span class="math">$\\forall i \\in \\{1, 2, \\dots, s-1\\}: \\quad \\mathcal{S}_i(y) = \\left(y \\oplus \\left((\\overline{y} \\ll 1) \\odot (y \\ll 2) \\odot (y \\ll 3)\\right)\\right) \\ll 1,</span>$
<span class="math">$\\mathcal{S}_s(y&#x27;) = \\left(y&#x27; \\oplus \\left((\\overline{y&#x27;} \\ll 1) \\odot (y&#x27; \\ll 2)\\right)\\right) \\ll 1.</span>$
(10)</p>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Bricks</h3>

    <p class="text-gray-300">The component Bricks over  <span class="math">\\mathbb{F}_p^t</span>  is defined as a Feistel Type-3 Bricks<sup>F</sup> (Eq. (5)) with  <span class="math">x \\mapsto x^2</span> , i.e., Bricks <span class="math">(x_1, \\dots, x_t) := (x_1, x_2 + x_1^2, x_3 + x_2^2, \\dots, x_t + x_{t-1}^2)</span> .</p>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">4.5 Concrete</h3>

    <p class="text-gray-300">The Concrete layer is defined as  <span class="math">\\operatorname{Concrete}(x_1,\\ldots,x_t) := M \\times (x_1,\\ldots,x_t)^T</span> , where  <span class="math">M \\in \\mathbb{F}_n^{t \\times t}</span>  is an MDS matrix.</p>

    <p class="text-gray-300">If  <span class="math">p = 2^{64} - 2^{32} + 1</span> , then M = circ(23, 8, 13, 10, 7, 6, 21, 8) for t = 8 and M = circ(7, 23, 8, 26, 13, 10, 9, 7, 6, 22, 21, 8) for t = 12. These two circulant matrices defined for the Goldilocks prime  <span class="math">p_{\\text{Goldilocks}}</span>  correspond to the ones found and implemented by the Winterfell STARK library. These matrices have the unique</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup> https://github.com/facebook/winterfell/tree/main/crypto/src/hash/mds</p>

    <p class="text-gray-300">Table 1. Parameters for Monolith.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Name</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds <span class="math">R</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Wie 2-to-1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\begin{array}{c} \\text{dth } t \\\\ \\text{Sponge} \\end{array}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># Bar <span class="math">u</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-64 Monolith-31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\begin{array}{ c c c c c c c c c c c c c c c c c c c</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128<br>124</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8<br>16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12<br>24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 8</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">advantage of having small elements in the time and frequency domain (i.e., before and after DFT application), allowing for especially fast native performance.</p>

    <p class="text-gray-300">If  <span class="math">p = 2^{31} - 1</span>  and t = 16, M is the  <span class="math">16 \\times 16</span>  matrix from Tip5 [SLS+23]<sup>8</sup>, i.e.,</p>

    <p class="text-gray-300"><span class="math">M = \\text{circ}(61402, 1108, 28750, 33823, 7454, 43244, 53865, 12034, \\\\ 56951, 27521, 41351, 40901, 12021, 59689, 26798, 17845).</span></p>

    <p class="text-gray-300">If  <span class="math">p=2^{31}-1</span>  and t=24, M is a  <span class="math">24\\times 24</span>  submatrix of the  <span class="math">32\\times 32</span>  circulant MDS matrix constructed from [HS24]. This particular design choice is explained in Section 7.1. The  <span class="math">32\\times 32</span>  circulant MDS matrix is defined as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} M &amp;= \\mathrm{circ}(0\\texttt{x}536\\texttt{C}316, 0\\texttt{x}1\\texttt{D}\\texttt{D}20\\texttt{A}84, 0\\texttt{x}43\\texttt{E}26541, 0\\texttt{x}52\\texttt{B}22\\texttt{B}8\\mathsf{D}, 0\\texttt{x}37\\texttt{D}\\texttt{A}\\texttt{B}\\texttt{D}\\mathsf{F}0, 0\\texttt{x}54\\texttt{O}\\texttt{E}\\texttt{C}066, \\\\ 0\\texttt{x}3015718\\texttt{D}, 0\\texttt{x}5\\texttt{A}99\\texttt{E}14\\texttt{C}, 0\\texttt{x}23637285, 0\\texttt{x}4\\texttt{C}8\\texttt{A}2\\texttt{F}76, 0\\texttt{x}5\\texttt{D}\\texttt{E}\\texttt{C}4\\texttt{E}6\\texttt{E}, 0\\texttt{x}374\\texttt{E}\\texttt{E}8\\texttt{D}6, \\\\ 0\\texttt{x}27\\texttt{E}\\texttt{D}\\texttt{A}4\\texttt{D}8, 0\\texttt{x}665\\texttt{D}30\\texttt{D}3, 0\\texttt{x}32\\texttt{E}44597, 0\\texttt{x}43\\texttt{C}7\\texttt{E}2\\texttt{B}3, 0\\texttt{x}67\\texttt{C}4\\texttt{C}603, 0\\texttt{x}78\\texttt{A}8631\\texttt{F}, \\\\ 0\\texttt{x}452\\texttt{F}77\\texttt{E}3, 0\\texttt{x}39\\texttt{F}03\\texttt{D}\\texttt{F}, 0\\texttt{x}743\\texttt{D}\\texttt{B}\\texttt{F}\\texttt{E}0, 0\\texttt{x}4\\texttt{D}\\texttt{A}05\\texttt{A}48, 0\\texttt{x}5\\texttt{F}027940, 0\\texttt{x}8293632, \\\\ 0\\texttt{x}50\\texttt{F}2\\texttt{C}76\\texttt{A}, 0\\texttt{x}7\\texttt{B}773729, 0\\texttt{x}577\\texttt{D}\\texttt{E}8\\texttt{B}0, 0\\texttt{x}73\\texttt{B}1\\texttt{E}\\texttt{A}\\texttt{C}6, 0\\texttt{x}5\\texttt{B}\\texttt{D}\\texttt{A}7\\texttt{D}29, 0\\texttt{x}67\\texttt{A}\\texttt{A}4375, \\\\ 0\\texttt{x}\\texttt{D}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{E}33, 0\\texttt{x}2655\\texttt{E}5\\texttt{A}1). \\end{split}</span>$</p>

      <h3 id="sec-4.6" class="text-xl font-semibold mt-8">4.6 Number of Rounds and Security Claims</h3>

    <p class="text-gray-300">We suggest to use R=6 rounds for Monolith-64 and Monolith-31 (see Table 1) and claim  <span class="math">2\\log_2(p_{\\texttt{Goldilocks}})\\approx 128</span>  bits and  <span class="math">4\\log_2(p_{\\texttt{Mersenne}})\\approx 124</span>  bits of security for Monolith-64 and Monolith-31, respectively.</p>

    <p class="text-gray-300">Remark 2. We do not claim that the Monolith permutation does not have any non-generic property (or &quot;indifferentiable from random&quot;). In particular, we do not consider certain permutation distinguishers &ndash; such as the integral one [DKR97] or the zero-sum partitions [KR07; BCC11] &ndash; that have not ever resulted in collision or preimage attacks for similar designs. We refer to Appendix B.3 for more details.</p>

      <h3 id="sec-4.7" class="text-xl font-semibold mt-8">4.7 Security Analysis</h3>

    <p class="text-gray-300">The numbers of rounds are conservatively chosen based on the security analysis proposed in Section 5 and Section 6. As some of the components or combinations</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span>  It is also MDS for  <span class="math">p_{\\tt Mersenne}</span>  as proved in <code>https://github.com/Neptune-Crypto/twenty-first/blob/master/twenty-first/src/shared_math/tip5.rs</code></p>

    <p class="text-gray-300">are new, our analysis contains several nontrivial ideas and may be of separate interest to cryptanalysts and designers.</p>

    <p class="text-gray-300">First, in the spirit of the wide trail strategy, <a href="#page-33-5">[DR02]</a>, we prove tight bounds for the number of active squarings in differential characteristics for the Type-3 Feistel-MDS combination in Section <a href="#page-17-1">5.1.</a> We also study rebound attacks in Section <a href="#page-18-0">5.3,</a> a research direction that is often missed in the ZK hash function design. We demonstrate practical attacks on a reduced version of Monolith and argue the security of the full version.</p>

    <p class="text-gray-300">Using differential and linear properties of Bar, we prove lower bounds on its algebraic degree in Section <a href="#page-19-0">6.1,</a> which implies resistance against algebraic attacks after a few rounds. In this regard, we additionally study the complexity of Gr&ouml;bner basis attacks on toy versions of Monolith with smaller primes but still realistic Bars layers in Section <a href="#page-22-0">6.3.</a></p>

    <p class="text-gray-300">To summarize, we are not able to even break 5 rounds of the proposed scheme with any basic attacks proposed in the literature. As future work, we encourage to study reduced-round and/or toy variants of our design.</p>

    <p class="text-gray-300">Given pairs of inputs with some fixed input differences, differential cryptanalysis <a href="#page-32-7">[BS90]</a> considers the probability distribution of the corresponding output differences produced by the cryptographic primitive. Since the Bars layer is not supposed to have good statistical properties, we simply assume that the attacker can skip it with probability 1.</p>

    <p class="text-gray-300">As the maximum differential probability of the square map is 1/p, Proposition <a href="#page-11-1">1</a> immediately implies the following bound.</p>

    <p class="text-gray-300">Corollary 2. Any 4-round differential characteristic for Monolith has a probability of at most p &minus;9(t&minus;1) <sup>8</sup> .</p>

    <p class="text-gray-300">As a result, any characteristic that spans over 5 rounds and more would cover more squarings than the number of state elements, and thus a solution to it cannot be found by standard means. Therefore, a differential-based collision attack on 5 rounds looks infeasible.</p>

    <p class="text-gray-300">Linear Attacks. Linear cryptanalysis <a href="#page-36-8">[Mat93]</a> exploits the existence of linear approximations. For primitives over binary fields, the attack makes use of the high correlations <a href="#page-33-8">[DGV94]</a> between sums of input bits and sums of output bits. The generalization of this attack over prime fields has been proposed in <a href="#page-32-8">[BSV07;</a> <a href="#page-32-9">DGG+21]</a>. We claim that our scheme is secure against this approach, due to the low correlation of the map x 7&rarr; x 2 (as for the case of differential attacks).</p>

    <p class="text-gray-300">Truncated Differentials. Truncated differential attacks [Knu94] are used mostly against primitives that have incomplete diffusion over a few rounds. This is not the case here since (i) Bricks is a full nonlinear layer, and (ii) the Concrete matrix is MDS. We have not found any other attacks where a truncated differential can be used as a subroutine either.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Rebound Attacks</h3>

    <p class="text-gray-300">Rebound attacks [MRS+09] have been widely used to analyze the security of various types of hash functions against shortcut collision attacks since the beginning of the SHA-3 competition. It starts by choosing internal state values in the middle of the computation, and then computing in the forward and backward directions to arrive at the inputs and outputs. It is useful to think of it as having central (often called &quot;inbound&quot;) and the above mentioned &quot;outbound&quot; parts. In the attack, solutions to the inbound phase are first found, and then are filtered in the outbound phase.</p>

    <p class="text-gray-300">Whereas it is not possible to prove the resistance to the rebound attacks rigorously, we can provide some meaningful arguments to demonstrate that they are not feasible. The inbound phase deals with truncated and regular differentials. By Corollary 2 we see that a solution for a 5-round differential cannot be found, and so the inbound phase cannot cover more than 4 Bricks layers. In the outbound phase, the Concrete layers that surround these Bricks layers make all differentials diffuse to the entire state, so that the next Bricks layers destroy all of those. We hence conclude that 6 rounds of Monolith are sufficient to prevent rebound attacks. We refer to Appendix B.1 for more details.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Other Statistical Attacks</h3>

    <p class="text-gray-300">We claim that 6 rounds are sufficient for preventing other statistical attacks as well. Here we provide argument to support such conclusion for one of the most powerful statistical attacks against a hash function, that is, the rebound attack. For that goal, we propose an analysis of the number of the fixed points and of the truncated differential characteristics.</p>

    <p class="text-gray-300">Fixed Points. Contrary to Reinforced Concrete, the Bars layer of Monolith has very few fixed points. Both local maps  <span class="math">x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2) \\odot (x \\ll 3))</span>  and  <span class="math">x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2))</span>  have about  <span class="math">(7/4)^n</span>  fixed points (for even and odd n, respectively) when considered over  <span class="math">\\mathbb{F}_2^n</span>  (a bit value is preserved if the product of nearby bits is 0). However, all of them except  <span class="math">\\mathbf{0}</span>  and  <span class="math">\\mathbf{1} = 2^n - 1</span>  are destroyed by the circular shift (verified experimentally).</p>

    <p class="text-gray-300">A Bar of Monolith-64, consisting of 8 such S-boxes, admits  <span class="math">2^8-2^4+1=241</span>  fixed points out of  <span class="math">2^{64}-2^{32}+1</span> . This implies that the probability that a point is fixed is approximately  <span class="math">2^{-56}</span>  for Bar and less than  <span class="math">2^{-56\\cdot 4}=2^{-224}</span>  for Bars. Similarly, a Bar of Monolith-31 admits  <span class="math">2^4-1=15</span>  fixed points out of  <span class="math">2^{31}-1</span> .</p>

    <p class="text-gray-300">This implies that the probability that a point is fixed is approximately  <span class="math">2^{-27}</span>  for Bar and less than  <span class="math">2^{-27\\cdot 8}=2^{-216}</span>  for Bars.</p>

    <p class="text-gray-300">For comparison, we recall that a Bar of Reinforced Concrete has  <span class="math">2^{134.5}</span>  fixed points out of  <span class="math">2^{254}</span>  possibilities. Hence, the probability of encountering a fixed point is approximately  <span class="math">2^{-119.5\\cdot 3}=2^{-358.5}</span>  for Bars. At the current state of the art, we are not aware of any attack that exploits these fixed points.</p>

    <p class="text-gray-300">Invariant Subspace Attacks. An invariant subspace attack exploits the existence of a subspace  <span class="math">\\mathfrak{X} \\subseteq \\mathbb{F}_p^t</span>  that remains invariant under the round function. (Note that we do not require that the coset of such subspace does not change as well.) Such attack is particular effective either in the case of keyed ciphers instantiated with weak keys [LAA+11; LMR15], or/and in the case of partial SPN schemes, in which part of the state remains unchanged after the application of the nonlinear layer. In this second case, the linear layer and the round constants can be carefully chosen in order to break such invariant subspaces, as shown in [GRS21; GSW+21].</p>

    <p class="text-gray-300">In our design, Bars layer is a partial nonlinear layer. However, such layer is combined with another nonlinear layer instantiated with Feistel Type-3 Bricks<sup>F</sup>. Even considering a weaker version of the scheme instantiated by a single nonlinear layer of the form  <span class="math">\\text{Bar}(x_1) \\mid\\mid \\cdots \\mid\\mid \\text{Bar}(x_u) \\mid\\mid x_u^2 + x_{u+1} \\mid\\mid x_{u+1}^2 + x_{u+2} \\cdots \\mid\\mid x_{t-1}^2 + x_t</span> , and due to the fact that the linear layer is instantiated with an MDS matrix, we have not found any non-trivial invariant subspace that covers more than a single round of Monolith.</p>

    <p class="text-gray-300">Cryptanalytic successes such as Gr&ouml;bner basis attacks on Friday and Jarvis [ACG+19], attacks on MiMC combining higher-order differential distinguishers with polynomial factorization [EGL+20; BCP23; LP19; RAS20], or an attack on Grendel [GKR+22] leveraging polynomial factorization are a stark warning that through analysis of such attack vectors is important. While the use of Bars is intuitively expected to frustrate such attacks, it is nevertheless essential to establish a sound basis for arguments against such attacks.</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> Let n &gt; 4 be such that  <span class="math">\\gcd(n,3) = 1</span> . Let S be the invertible map over  <span class="math">\\mathbb{F}_2^n</span>  given Eq. (9), that is,  <span class="math">x \\mapsto (x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2) \\odot (x \\ll 3))) \\ll 1</span> . Let  <span class="math">\\overline{S}</span>  be the corresponding mapping but over  <span class="math">\\mathbb{Z}_{2^n}</span> , where the elements of  <span class="math">\\mathbb{F}_2^n</span>  are viewed as the big-endian counterparts of elements from  <span class="math">\\mathbb{Z}_{2^n}</span> .</p>

    <p class="text-gray-300">The map  <span class="math">\\overline{S}</span>  has differential probability at least 13/64 over  <span class="math">\\mathbb{Z}_{2^n}</span> . Particularly the pair (x, x+1) for even x is mapped into (y, y+2) for some  <span class="math">y \\equiv 0, 1 \\pmod{4}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Consider two input states x, x' with a single bit difference in the <em>i</em>-th bit, that is,  <span class="math">x_i = 1 \\oplus x&#x27;_i = 0</span>  and  <span class="math">x_j = x&#x27;_j</span>  for  <span class="math">j \\neq i</span> . Let us derive sufficient conditions</p>

    <p class="text-gray-300">for which the output states y, y' via S differ in the (i-1)-th bit only (note the final shift  <span class="math">\\ll</span>  1). By simple computation, this occurs if the product in the S-box bit mapping is 0 whenever the i-th bit is XORed or is part of the product, i.e.,</p>

    <p class="text-gray-300"><span class="math">$\\overline{x_{i+1}} \\odot x_{i+2} \\odot x_{i+3} = 0, \\quad x_{i+1} \\odot x_{i+2} = 0, \\quad \\overline{x_{i-1}} \\odot x_{i+1} = 0, \\quad \\overline{x_{i-2}} \\odot x_{i-1} = 0.</span>$</p>

    <p class="text-gray-300">The number of 5-tuples satisfying this system is 13 out of 32 possible. Therefore, a differential for S over  <span class="math">\\mathbb{F}_2^n</span>  holds with probability 13/32.</p>

    <p class="text-gray-300">For i = n, we have</p>

    <p class="text-gray-300"><span class="math">$\\{(x_1,\\ldots,x_{n-1},0),(x_1,\\ldots,x_{n-1},1)\\} \\xrightarrow{S} \\{(y_1,\\ldots,y_{n-2},0,y_n),(y_1,\\ldots,y_{n-2},1,y_n)\\}.</span>$</p>

    <p class="text-gray-300">By simple computation, the same result holds for  <span class="math">\\overline{S}</span> , i.e.,  <span class="math">\\{x=2\\cdot x&#x27; \\text{ (even)}, x+1\\} \\xrightarrow{\\overline{S}} \\{y,y+2\\}</span> . The result follows immediately.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> The Bar function for  <span class="math">p = 2^{64} - 2^{32} + 1</span>  (Section 4.3) has differential probability at least 13/64 over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For every even x &lt; p-1 we have that x+1 &lt; p. Let  <span class="math">\\mathcal{D}</span>  of Bar decompose x to  <span class="math">x_1, x_2, \\ldots, x_s</span> . Then we have that  <span class="math">\\mathcal{D}(x+1)</span>  differs from  <span class="math">\\mathcal{D}(x)</span>  in the last bucket only, and we have  <span class="math">S(x_s+1)=S(x)+2</span>  from Lemma 5 with probability 13/32. Therefore for the full Bar function we have Bar(x+1)=Bar(x)+2 for at least  <span class="math">13(2^{64}-2^{32})/64</span>  values of x, which gives the lemma statement.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let n &gt; 4 be such that gcd(n, 2) = 1. Let S' be the invertible map over  <span class="math">\\mathbb{F}_2^n</span>  given Eq. (10), that is,  <span class="math">x \\mapsto (x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2))) \\ll 1</span> . Let  <span class="math">\\overline{S}&#x27;</span>  be the corresponding mapping but over  <span class="math">\\mathbb{Z}_{2^n}</span> , where the elements of  <span class="math">\\mathbb{F}_2^n</span>  are viewed as the big-endian counterparts of elements from  <span class="math">\\mathbb{Z}_{2^n}</span> .</p>

    <p class="text-gray-300">The map  <span class="math">\\overline{S}&#x27;</span>  has differential probability at least 1/8 over  <span class="math">\\mathbb{Z}_{2^n}</span> . Particularly, the pair (x, x+1) for even x is mapped into (y, y+2) for some  <span class="math">y \\equiv 0, 1 \\pmod{4}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof repeats that of Lemma 5 with the system of equations for  <span class="math">x_i</span>  appearing as  <span class="math">\\overline{x_{i+1}} \\odot x_{i+2} = 0</span> ,  <span class="math">x_{i+1} = 0</span> , and  <span class="math">\\overline{x_{i-1}} = 0</span> . The number of 3-tuples satisfying this system is 1 out of 8 possible. Thus, for i = n we have a differential for S' with probability 1/8:</p>

    <p class="text-gray-300"><span class="math">$\\{(x_1,\\ldots,x_{n-1},0),(x_1,\\ldots,x_{n-1},1)\\} \\xrightarrow{S&#x27;} \\{(y_1,\\ldots,y_{n-2},0,y_n),(y_1,\\ldots,y_{n-2},1,y_n)\\}.</span>$</p>

    <p class="text-gray-300">Simultaneously, for  <span class="math">\\overline{S}&#x27;</span> , we have that  <span class="math">\\{x = 2x&#x27; \\text{ (even)}, x+1\\} \\xrightarrow{\\overline{S}&#x27;} \\{y, y+2\\}</span> . The result follows immediately.</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> The Bar function for  <span class="math">p = 2^{31} - 1</span>  (Section 4.3) has differential probability at least 1/16 over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">The proof is identical to that of Lemma 6. With Lemma 3, we obtain the following bound on the degree of Bar.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> The Bar operation (and its inverse) has degree at least (i)  <span class="math">2^{59}</span>  for  <span class="math">p = 2^{64} - 2^{32} + 1</span> , and (ii)  <span class="math">2^{27}</span>  for  <span class="math">p = 2^{31} - 1</span> .</p>

    <p class="text-gray-300">Additional data about the degree of Bars for various p as well as density estimates are presented in Appendix B.2. Our practical tests on toy-Bars functions defined on smaller prime fields showed that the corresponding interpolation polynomial is dense and of high (usually, maximum or close to maximum) degree.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Security against Algebraic Attacks via Bars</h3>

    <p class="text-gray-300">Here we consider attacks that exploit the fact that several rounds of the permutation do not have maximum possible algebraic degree. For this, we interpret the output elements as polynomials of the input elements. Then we formulate a collision or a preimage attack as a system of equations and try to solve it.</p>

    <p class="text-gray-300">Interpolation Attacks. Interpolation attacks [JK97] exploit the degree of a component to reconstruct its polynomial and solve a system of equations. However, we have demonstrated that the degree of the Bar component is close to p. Therefore, after at most 2 rounds of Monolith, the degree in each variable becomes almost p, which implies that mounting the attack is infeasible.</p>

    <p class="text-gray-300">Note that the Bars layer is partial, using only u Bar components. Thus, excluding the Type-3 Feistel layer, it may be possible to pass r rounds by guessing  <span class="math">r \\cdot u</span>  intermediate variables. However, as  <span class="math">u \\ge t/3</span> , this is possible for at most 2 rounds (without exhausting the degrees of freedom). We conclude that it is not feasible to apply simple algebraic attacks on 4 or more rounds of Monolith.</p>

    <p class="text-gray-300">Solving a CICO Problem with Univariate polynomials. In the CICO problem, the goal is to find a solution to the system of v polynomial equations of t-v input variables (as the remaining v ones are set to zero). More formally:</p>

    <p class="text-gray-300"><strong>Definition 4 (CICO Security).</strong> A permutation  <span class="math">\\mathcal{P}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is v-CICO secure if no algorithm with expected complexity smaller than  <span class="math">p^v</span>  finds  <span class="math">I_1 \\in \\mathbb{F}_p^{t-v}</span>  and  <span class="math">O_2 \\in \\mathbb{F}_p^{t-v}</span>  such that  <span class="math">\\mathcal{P}(\\mathbf{0}^v \\mid\\mid I_1) = \\mathbf{0}^v \\mid\\mid O_2</span> .</p>

    <p class="text-gray-300">The univariate system appears if v=t-1 or we guess t-v-1 variables. Note that our guess may be invalid if the number of equations exceeds the number of variables, so we have to repeat the guess  <span class="math">p^{v-1}</span>  times. Note also that p is smaller than  <span class="math">2^{128}</span>  so  <span class="math">p^{v-1}</span>  may still be feasible.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If v=1 and we have guessed t-2 variables, then we have to solve a single polynomial equation faster than in time p. The degree of the polynomial reaches p after 2 applications of the Bars layer, i.e., after 2 rounds. Therefore, solving the equation will require time  <span class="math">\\approx p</span> .</li>
      <li>If v &gt; 1, and we have guessed t v 1 variables, then the probability that a CICO solution exists for a particular guess is  <span class="math">p^{-(v-1)}</span> , since we only solve one equation and hope for other v 1 to hold. A system of polynomial equations has degree close to p, so solving it would cost at least p time for any guess. Multiplying by the number of guesses, we obtain that the total complexity still exceeds  <span class="math">p \\cdot p^{v-1} = p^v</span> .</li>
    </ul>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8">6.3 Solving the Multivariate CICO Problem with Gr&ouml;bner Bases</h3>

    <p class="text-gray-300">In a general case, we model the CICO problem as a system of multivariate polynomial equations generating a zero-dimensional ideal. The main technique for solving these systems is to use Gr&ouml;bner bases and apply the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. Compute a Gr&ouml;bner basis for the zero-dimensional ideal of the system of polynomial equations with respect to the <em>degrevlex</em> term order.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Convert the degrevlex Gr&ouml;bner basis into a lex Gr&ouml;bner basis using the FGLM algorithm [FGL+93].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Factor the univariate polynomial in the <em>lex</em> Gr&ouml;bner basis and determine the solutions for the corresponding variable. Back-substitute those solutions, if needed, to determine solutions for the other variables.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The total complexity of a Gr&ouml;bner basis attack is hence the sum of the respective complexities of the above steps. We argue that even step 1. is prohibitively expensive for Monolith.</p>

    <p class="text-gray-300">The complexity of computing a Gr&ouml;bner basis with (matrix-based) algorithms such as Lazard [Laz79; Laz83], F4 [Fau99], or Matrix-F5 [BFS15] for an equation system with  <span class="math">n_e</span>  equations in  <span class="math">n_v</span>  variables over a field  <span class="math">\\mathbb F</span>  can be bounded by</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{O}\\left(n_e \\cdot \\binom{n_v + d_{\\text{solv}}}{n_v}^{\\omega}\\right) \\tag{11}</span>$</p>

    <p class="text-gray-300">operations in  <span class="math">\\mathbb{F}</span> . Here,  <span class="math">d_{\\rm solv}</span>  denotes the solving degree and  <span class="math">\\omega</span>  denotes the linear algebra exponent. Intuitively,  <span class="math">d_{\\rm solv}</span>  corresponds to the maximum degree attained during a Gr&ouml;bner basis computation. Thus, the overall complexity of computing a Gr&ouml;bner basis can be understood as bounded by row-reducing (full-rank) matrices of size  <span class="math">n_e \\cdot \\binom{n_v+i-1}{i} \\times \\binom{n_v+i-1}{i}</span> , for  <span class="math">i=0,1,\\ldots,d_{\\rm solv}</span> , eventually, leading to the bound in Eq. (11). In practice, the Macaulay matrices built during a Gr&ouml;bner basis computation might be sparse and have a substantial rank defect, and Eq. (11) does not account for this particular structure in the Macaulay matrices.</p>

    <p class="text-gray-300">Rationale for our Security Arguments. As a conservative choice and to account for the structured Macaulay matrices in the algebraic model for Monolith, in Eq. (11) we drop any factors from the asymptotic  <span class="math">\\mathcal{O}(\\cdot)</span>  notation and set  <span class="math">n_e = \\omega = 1</span> , and, hence, use  <span class="math">\\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{solv}}) = \\binom{n_v + d_{\\text{solv}}}{n_v}</span>  as a guideline for estimating the complexity of actual Gr&ouml;bner basis computations. We stress that setting  <span class="math">\\omega = 1</span>  is a highly optimistic scenario from an attacker's viewpoint.</p>

    <p class="text-gray-300">Establishing concrete estimates for  <span class="math">\\mathcal{C}_{\\mathrm{GB}}</span> , hence, boils down to bounding the solving degree  <span class="math">d_{\\mathrm{solv}}</span> . This task is in general a difficult problem in its own regard, often as hard as actually computing a Gr&ouml;bner basis. However, for the special case of (semi-)regular sequences, there exist bounds on  <span class="math">d_{\\mathrm{solv}}</span> . In particular, for regular sequences  <span class="math">d_{\\mathrm{solv}}</span>  is upper-bounded by the <em>Macaulay bound</em> [BFS15]</p>

    <p class="text-gray-300"><span class="math">$d_{\\text{Mac}} := 1 + \\sum_{i=1}^{n_e} (d_i - 1). \\tag{12}</span>$</p>

    <p class="text-gray-300">Informally, the case of regular sequences can be regarded as a generic case, formalizing the notion of &quot;random polynomial systems&quot;. Although the assumption of regular sequences often fails for algebraic models of circuit-friendly primitives, comparing a given algebraic model with this generic case can still be an informative approach and help to establish heuristic estimates for the complexity of Gr&ouml;bner basis computations when practical experiments are infeasible. In our analysis, we compare the actual solving degree dsolv from our practical experiments with dMac. This allows us to extrapolate trends from the aquired data points to large-scale instances, which are computationally intractable.</p>

    <p class="text-gray-300">When analyzing a given algebraic model, another problem is scalability: it is nontrivial to properly scale down the original system of equations to some smallscale variant that is solvable on a standard machine. We tackle this problem and estimate the complexity of a Gr&ouml;bner basis attack on the CICO problem for full-scale Monolith as described below. We point out that we only focus on step <a href="#page-22-1">1.</a> of a Gr&ouml;bner basis attack and show that already the complexity of this step exceeds the generic CICO security level.</p>

    <p class="text-gray-300">&ndash; We consider a small-scale, weakened version of one round of Monolith, denoted SmallWeak1R, with a small state of only t = 4 elements, and u=2 Bar functions in the Bars layer. We have</p>

    <p class="text-gray-300"><span class="math">\${\\tt SmallWeak1R} := {\\tt Concrete&#x27;} \\circ {\\tt Bricks} \\circ {\\tt Bars} \\circ {\\tt Concrete&#x27;},</span>$</p>

    <p class="text-gray-300">where for Concrete&prime; we use the circulant matrix M = circ(2, 1, 1, 1), which is not MDS and thus weaker than the MDS matrix used in Monolith. For Bricks, we use the same Bricks as described in Section <a href="#page-15-0">4.4,</a> with t = 4. The Bars function is the same function described in Section <a href="#page-14-0">4.3,</a> with t = 4 and a decomposition into m = 2 buckets for all small primes for which we run actual computations, see also Table <a href="#page-24-0">2.</a> For the S-Box functions inside Bar, we use suitable functions from <a href="#page-32-3">[Dae95,</a> Table A.1].</p>

    <p class="text-gray-300">&ndash; We use the following CICO problem, called SmallWeak1R-CICO, in our analysis: find i2, i3, i4, o2, o3, o<sup>4</sup> &isin; F<sup>p</sup> such that</p>

    <p class="text-gray-300">
<span class="math">$\\mathtt{SmallWeak1R}(0, i_2, i_3, i_4) = (0, o_2, o_3, o_4). \\tag{13}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We suggest an arguably optimal model for SmallWeak1R-CICO, denoted by the same name, as a system of polynomial equations (see Appendix <a href="#page-42-0">B.3)</a>.</li>
      <li>For various small primes, we run actual GB computations on the model SmallWeak1R-CICO and observe that for these small-scale instances</li>
    </ul>

    <p class="text-gray-300"><span class="math">$d_{\\text{solv}} \\ge d_{\\text{Mac}}/4</span>$
.</p>

    <p class="text-gray-300">&ndash; Extrapolating heuristically, we argue that the complexity of computing a Gr&ouml;bner basis for SmallWeak1R-CICO, also for larger primes, is around</p>

    <p class="text-gray-300">
<span class="math">$C_{\\rm GB}(n_v, d_{\\rm Mac}/4) = \\binom{n_v + d_{\\rm Mac}/4}{n_v}.</span>$
(14)</p>

    <p class="text-gray-300">Table 2. Results of Gr&ouml;bner basis computations on several instances of SmallWeak1R-CICO, described in Eq. (13), for various small primes p, decomposition into m=2 buckets with bucket sizes  <span class="math">2^{s_1}</span> ,  <span class="math">2^{s_2}</span> , and extrapolation to 1R-CICO. Here,  <span class="math">n_e</span>  and  <span class="math">n_v</span>  denotes the number of equations and variables, respectively. The degree  <span class="math">d_{\\text{solv}}</span>  denotes the maximum degree reached during a GB computation with Magma. T is the runtime in microseconds  <span class="math">(10^{-6})</span> . For the complexity  <span class="math">\\mathcal{C}</span>  we use the estimate  <span class="math">\\mathcal{C} = \\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{Mac}}/4)</span> . Extrapolated estimates are in italic.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">SmallWeak1R-CICO</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1R-CICO</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">113</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p_{\\rm Mers.}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p_{\\mathrm{Goldil.}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p_{\\rm Mers.}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p_{\\mathrm{Goldil.}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n_e, n_v</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10, 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10, 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10, 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10, 10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14, 14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22, 22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64,64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48, 48</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_i</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2, 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4, 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8,8,8,7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8,,8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8,8,8,7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8,,8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">u</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\rm Mac}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">66</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">74</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2294</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4590</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9177</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9181</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\rm solv}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">573</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1147</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2295</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2296</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">d_{\\mathrm{Mac}}:d_{\\mathrm{solv}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.62</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.08</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\log_2 T</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><u>-</u></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\log_2 \\mathcal{C}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">92.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">154</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">419.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">333.7</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">For the original, full-sized primes  <span class="math">p_{\\texttt{Goldilocks}}</span>  and  <span class="math">p_{\\texttt{Mersenne}}</span> , this yields a complexity estimate for solving SmallWeak1R-CICO via Gr&ouml;bner basis techniques of  <span class="math">2^{154}</span>  operations in  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p=p_{\\texttt{Goldilocks}}</span> , and  <span class="math">2^{93}</span>  operations for  <span class="math">p=p_{\\texttt{Mersenne}}</span> . Compared to the generic CICO-security level of  <span class="math">2^{64}</span>  and  <span class="math">2^{31}</span>  function calls for  <span class="math">p_{\\texttt{Goldilocks}}</span>  and  <span class="math">p_{\\texttt{Mersenne}}</span> , respectively, our analysis suggests ample security margin against Gr&ouml;bner basis attacks on SmallWeak1R-CICO.</p>

    <p class="text-gray-300">Based on the (heuristic) estimate presented in Eq. (14), we argue that one round of full Monolith given by 1R := Concrete  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete provides ample security against Gr&ouml;bner basis attacks as well. Intuitively, it is reasonable to assume that an increased state size and/or an increased field size do not make the attacks more efficient (given the same ratio of CICO constraints and Bar applications).</p>

    <p class="text-gray-300">In more detail, let 1R-CICO denote the following CICO-problem for 1R: find  <span class="math">I_1,O_2\\in\\mathbb{F}_p^{t-v}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$1R(\\mathbf{0}^v, I_1) = (\\mathbf{0}^v, O_2),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{0}^v</span>  denotes a v-tuple with all entries being zero. For  <span class="math">p_{\\texttt{Goldilocks}}</span> , we have t=12, v=4, and for  <span class="math">p_{\\texttt{Mersenne}}</span>  we have t=24, v=8. This amounts to a generic CICO-security level of  <span class="math">2^{256}</span>  and  <span class="math">2^{248}</span>  function calls, respectively. Extrapolating Eq. (14), we arrive at an estimated Gr&ouml;bner basis complexity for 1R-CICO of  <span class="math">2^{334}</span>  operations in  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p=p_{\\texttt{Goldilocks}}</span> , and  <span class="math">2^{420}</span>  operations for  <span class="math">p=p_{\\texttt{Mersenne}}</span> . We summarize the results of our Gr&ouml;bner basis analysis in Table 2.</p>

    <p class="text-gray-300"><strong>Discussion of Gr&ouml;bner Basis Experiments.</strong> The results of our Gr&ouml;bner basis experiments on small-scale instances of SmallWeak1R-CICO, described in Eq. (13), are depicted in Table 2. We conducted our experiments on a machine</p>

    <p class="text-gray-300">with an Intel Xeon E5-2630 v3 @ 2.40 GHz (32 cores) and 378 GB RAM under Debian 11 using Magma V2.26-2.</p>

    <p class="text-gray-300">For the maximum degree  <span class="math">d_{\\text{solv}}</span>  reached during a Gr&ouml;bner basis computation, we see that the ratio  <span class="math">d_{\\text{Mac}}</span> :  <span class="math">d_{\\text{solv}}</span>  is higher than 4. Moreover,  <span class="math">\\mathcal{C} = \\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{Mac}}/4)</span>  can be seen as a lower bound for the actual computation time T.</p>

    <p class="text-gray-300">We also consider algebraic attacks working over the binary field  <span class="math">\\mathbb{F}_2</span> , due to the low degree of Bars in this setting. Here we demonstrate that the squaring operation of Bricks has a high degree as a multivariate polynomial over  <span class="math">\\mathbb{F}_2</span> .</p>

    <p class="text-gray-300">Since  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd for d=15 and d=30, Lemma 2 implies the following bound on the degree of the squaring function over  <span class="math">\\mathbb{F}_2</span> .</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let  <span class="math">p \\in \\{p_{Mersenne}, p_{Goldilocks}\\}</span>  (7). Let  <span class="math">\\mathsf{F}_{sq}</span>  be an interpolant over  <span class="math">\\mathbb{F}_2^{\\lceil \\log_2 p \\rceil}</span>  of the squaring operation  <span class="math">\\mathcal{F}(x) = x^2</span>  over  <span class="math">\\mathbb{F}_p</span> . Then  <span class="math">\\mathsf{F}_{sq}</span>  has degree (multivariate over  <span class="math">\\mathbb{F}_2</span> ) at least d, where (i) d = 30 for  <span class="math">p = 2^{64} - 2^{32} + 1</span> , and (ii) d = 15 for  <span class="math">p = 2^{31} - 1</span> .</p>

    <p class="text-gray-300">Since Bars is of degree 2 over  <span class="math">\\mathbb{F}_2</span> , and since Concrete is a nonlinear function over a binary field, we claim that Monolith is secure against algebraic attacks instantiated over the binary field.</p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8">7.1 Native Performance</h3>

    <p class="text-gray-300">We compare the performance of Monolith and competitors in Table 3. All benchmarks were taken on an AMD Ryzen 9 7900X CPU (singlethreaded, 4.7 GHz).</p>

    <p class="text-gray-300">We included implementations of Monolith into the framework in [IAI21], and also added instantiations of widely popular Poseidon [GKR+21], its modification Poseidon2 [GKS23], and also Griffin [GHR+23] with  <span class="math">p=2^{64}-2^{32}+1</span>  following their original instance generation scripts. We benchmark these hash functions with a state size of t=8 for the compression mode and of t=12 for the sponge mode in order to have a fair comparison. We also compare against Tip5 with its fixed state size of t=16 using the implementation from [SLS+23], and against Tip4', a faster instance of Tip5 with a fixed state size t=12, using the implementation from [Sal23]. We also compare against Reinforced Concrete instantiated with the scalar field of the BN254 curve, and against SHA3-256/SHA-256 as implemented in RustCrypto. The constant-time versions of Tip5 and Reinforced Concrete is our modification of the original code, which may not be optimized, thus it is given as an estimate.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;9</sup> The source code is available at https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo/-/tree/master/plain_impls.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{10}&lt;/sup&gt;</span>  https://github.com/Neptune-Crypto/twenty-first</p>

    <p class="text-gray-300"><sup>11</sup> https://github.com/Nashtare/winterfell</p>

    <p class="text-gray-300"><sup>12</sup> https://github.com/RustCrypto/hashes</p>

    <p class="text-gray-300">Table 3. Native performance in nano seconds (ns) of different hash functions for variable and constant time implementations. Benchmarks are given for one permutation call, i.e., hashing &asymp; 500 bits for all but SHA functions. Estimates are in italic.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hashing algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time (ns)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Const. Time (ns)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2-to-1 sponge 2-to-1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">sponge</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p = 264 &minus;<br>32 + 1:<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">210.5 148.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">230.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1897.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3288.7 2347.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4059.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">944.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1291.5 1149.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1617.9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue-Prime</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12128.0 19095.0 12128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19095</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Griffin</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1815.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1988.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tip5 (t = 16)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">463.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">500</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tip4&prime;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">247.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p = 231 &minus;<br>1:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 24 t = 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 24</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">210.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">924.2 237.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">946.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4478.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8539.7 4372.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8538.0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">792.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1257.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">840.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1355.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Other:</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Reinforced Concrete (BN254)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1467.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA3-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">189.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SHA-256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Finally, we compare Monolith-31 with Poseidon and Poseidon2 over the pMersenne prime field and state sizes of t = 16 and t = 24 (again for sponge and compression mode), as well as for a constant time implementation (constant time F<sup>p</sup> operations and no lookup tables). We see that Monolith-64 is significantly faster than any other arithmetization-oriented hash function. For example, the fastest one, i.e., Poseidon2, is slower by a factor 7.3 for t = 8. Tip4&prime; , the fastest lookup table based design, is also slower by a factor of 1.9 when using Monolith with the compression mode, and also slower by 36 ns compared to Monolith with the same state size t = 12.</p>

    <p class="text-gray-300">Most interestingly, the performance gap between arithmetization-friendly hash functions and traditional ones is now closed, with SHA3-256 being slower than Monolith-64 with t = 8 and only faster by 21 ns than Monolith-64 in the sponge mode with t = 12.</p>

    <p class="text-gray-300">Regarding Monolith-31 for the 31 bit Mersenne prime field we observe that we still get a fast native performance with 210 ns for t = 16. This is significantly faster than Tip5 which has the same state size, but is implemented with the larger 64 bit prime field. Only for t = 24 we observe a slower native performance which is due to the usage of a 32&times;32 circular MDS matrix in the Concrete layer, which we use to be able to implement it via a radix-2 FFT (see Note on MDS Matrices below). However, competing designs, such as Tip5 also rely on MDS matrices and thus will either suffer from the same performance loss, or if they come up with better matrices/implementations, these can be used in Monolith-31 as well. Nonetheless, one can observe that Monolith-31 is still faster than the closest competitor for the same field and state size, i.e., Poseidon2, by 300 ns.</p>

    <p class="text-gray-300">Unlike other lookup-based designs, Monolith does not rely on lookup tables and its structure allows for constant-time implementations without significant performance loss. The binary  <span class="math">\\chi</span> -like layer can be efficiently implemented using a vectorized implementation that does not require an explicit (de-)composition, while unrolling the lookup-tables containing repeated power maps in Reinforced Concrete, Tip5, and Tip4' adds considerable workload to the computation. Thus, the overhead of going to a constant-time implementation only consists of supporting constant-time prime field arithmetic for Monolith, which can help in efficiently preventing side-channel attacks such as the ones proposed in [TBP20].</p>

    <p class="text-gray-300">Using a constant-time reduction leads to a slight slowdown in our comparison. However, the resulting runtimes are still significantly faster than the nonconstant-time runtimes of other circuit-friendly hash functions, such as Poseidon and Griffin, and Tip4' for t=8 and t=12. Moreover, a constant-time Monolith-64 in compression mode is still faster than SHA3-256 for t=8 (although we acknowledge the different security margin of the two constructions).</p>

    <p class="text-gray-300">Finally, for completeness, we give the runtime of each part of the Monolith permutation for both a constant- and variable-time version in Appendix C.</p>

    <p class="text-gray-300">Note on MDS Matrices. We use matrix multiplications based on fast Fourier transforms and circulant matrices for the linear layer of Monolith. For  <span class="math">t \\in \\{8, 12, 16\\}</span>  we use matrices whose dimensions correspond to the state size. However, for t = 24, we use a circulant matrix of dimension  <span class="math">32 \\times 32</span>  [HS24].<sup>13</sup> This allows us to efficiently employ a radix-2 algorithm. In more detail, if the input to the linear layer is  <span class="math">(x_1, \\ldots, x_{24})</span> , the output is defined by</p>

    <p class="text-gray-300"><span class="math">$(y_1, \\dots, y_{24})^T = \\text{Tr}_{24}(M \\times (x_1, \\dots, x_{24}, \\underbrace{0, \\dots, 0}_{\\text{8 zeroes}})^T),</span>$</p>

    <p class="text-gray-300">where  <span class="math">M \\in \\mathbb{F}^{32 \\times 32}</span>  and  <span class="math">\\operatorname{Tr}(\\cdot)_n</span>  yields the first n elements of the input. While the multiplication uses a  <span class="math">32 \\times 32</span>  MDS matrix, the final output will be the result of the multiplication by a  <span class="math">24 \\times 24</span>  (non-circulant) MDS matrix, since every submatrix of an MDS matrix is also MDS. This approach leads to an advantage of around 15% compared to the naive multiplication with a generic  <span class="math">24 \\times 24</span>  matrix.</p>

    <p class="text-gray-300">A modern zero-knowledge proof system defines arithmetization rules for the circuit it attempts to prove. Most new proof systems support the <em>Plonkish</em> arithmetization, where all input, output, and intermediate variables are put into a</p>

    <p class="text-gray-300">We emphasize that it is unknown how to efficiently construct a  <span class="math">24 \\times 24</span>  circulant MDS matrix over  <span class="math">\\mathbb{F}_p</span>  for large p.</p>

    <p class="text-gray-300"><strong>Table 4.</strong> Plonkish arithmetization comparison for various 64-bit schemes. The numbers are for a single permutation.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Primitive</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Lookups</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Nonlinear constraints</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Degree</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Witness size</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Area-degree<br>product</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-64-compression</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">460</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">920</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-64-sponge</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">480</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">960</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tip5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">380</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2660</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tip4'</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">360</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2520</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon/Poseidon2 (sponge)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">826</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rescue-Prime (sponge)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">672</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">witness matrix W with a fixed number of rows and columns. The data in each row is restricted by polynomial equations determining the values and computations used. One of these generic equations of degree 2 is  <span class="math">a_ix_1x_2 + b_ix_3 + c_ix_4 + d_i = 0</span> , where  <span class="math">a_i, b_i, c_i, d_i</span>  are public constants for the i-th row [GWC19]. The Plonkish arithmetization allows for different tradeoffs w.r.t. the number of columns, variables being used, and the final degrees. Additionally, various tuples within a row may be constrained to a set of values in a predefined table  <span class="math">\\mathfrak{T}</span> .</p>

    <p class="text-gray-300">A precise comparison of different arithmetizations is hard without implementing and testing. However, a significant part of the work is to construct s degree- <span class="math">\\rho</span>  polynomials for the witness columns and to prove that they satisfy the polynomial equations. The total work is then estimated as an element in  <span class="math">\\mathcal{O}(d \\cdot \\rho \\cdot s)</span> , where d is the maximum degree of a row polynomial. The cost of using table lookups for FRI-based schemes is currently equivalent to the use of a single polynomial of degree  <span class="math">t = \\max\\{\\rho, |\\mathfrak{T}|\\}</span> .</p>

    <p class="text-gray-300">In this section we give possible arithmetizations for translating Monolith into a set of Plonkish constraints and refer to Appendix D.1 for R1CS constraints. Our Plonkish arithmetization is designed to accommodate lookup constraints capable of efficiently looking up 8-bit values. If the proof system is able to use larger tables (e.g., 16-bit ones), then multiple lookup constraints can be combined into just one larger constraint, reducing the total number of constraints.</p>

    <p class="text-gray-300"><strong>Plonkish Arithmetization.</strong> Each composition Concrete  <span class="math">\\circ</span>  Bricks is described with t polynomial equations of degree 2. Then, for each Bar in the Bars layer, we enforce the correct relations with  <span class="math">x = \\sum_{i=1}^m 2^{\\sum_{j=1}^i s_j} x_i&#x27;</span>  and  <span class="math">y = \\sum_{i=1}^m 2^{\\sum_{j=1}^i s_j} y_i&#x27;</span> , while also making sure that the limbs in the decomposition correspond to field elements. For  <span class="math">p_{\\text{Goldilocks}}</span> , this means enforcing that either the least significant 32 bits of Bar's input are 0 or the most significant bits are not all 1, i.e.,</p>

    <p class="text-gray-300"><span class="math">$(x_4 2^{24} + x_3 2^{16} + x_2 2^8 + x_1)(x_8 2^{24} + x_7 2^{16} + x_6 2^8 + x_5 - z) = 0, \\quad z&#x27;(z - 2^{32} + 1) = 1.</span>$</p>

    <p class="text-gray-300">For  <span class="math">p_{\\texttt{Mersenne}} = \\texttt{Ox7ffffffff}</span>  we need to make sure that the combined values are  <span class="math">\\neq p</span> , which is equivalent to them not being  <span class="math">2^8 - 1</span>  (three) or  <span class="math">2^7 - 1</span>  (one), i.e.,</p>

    <p class="text-gray-300"><span class="math">$(x_4 + x_3 + x_2 + x_1 - 2^7 - 3 \\cdot 2^8 + 4) \\cdot z&#x27; = 1.</span>$</p>

    <p class="text-gray-300">Table 5. Proving performance in Plonky2 using pGoldilocks and sponge mode.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Permutation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Prove (ms)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Verify (ms)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Size (kB)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Monolith-64-sponge</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">113</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">We describe the application of s individual S-boxes with s lookup constraints (x1, y1), (x2, y2), . . . ,(xs, ys). These also include the range checks for each input which are also necessary for the correctness of the constraints above.</p>

    <p class="text-gray-300">Apart from 2s lookup variables per Bar, we define u variables at the output of the first Concrete layer (these are the inputs to the Bars layer) and t variables at the output of each of the following Concrete layers (except for the last one). The reason is that the variables after the first Concrete layer store linear relations in the input, and only the u variables entering the Bars layer are needed. For the last layer, the output variables can be used directly. In total, we have 6 &middot; (2us + u) + 5t + u variables, where {u = 4, s = 8} for the pGoldilocks case and {u = 8, s = 4} for the pMersenne case (considering S-boxes of &asymp; 8 bits).</p>

    <p class="text-gray-300">In Table <a href="#page-28-0">4</a> we compare the (non-optimized) arithmetization of Monolith with the ones of other 64-bit designs (see Appendix <a href="#page-45-0">D.2</a> for details). To achieve a fair comparison, we do not apply any constraint or witness optimization but try to follow the same approach. We see that both the number of lookups and constraints in Monolith is slightly larger than in Tip5 and Tip4', but the constraint degree is smaller by the factor of 3.5, which should result in an overall decrease of the prover time by a factor of at least 2 (estimated as area-degree product). This is reasonable since Tip5 and Tip4' are able to process more field elements with a permutation call. Poseidon, Poseidon2, and Rescue-Prime due to their comparably small witness size and no lookup tables are estimated to still provide faster proving performance, closely followed by Monolith-64 with its low-degree nonlinear layers. Again, we stress that these numbers are derived from non-optimized arithmetizations and are subject to change. For example, one can leverage the low degree of Monolith to reduce witness size by trading with a larger degree round function. We refer to Appendix <a href="#page-45-1">D.3</a> for details. Furthermore, these estimates are based on a simplified performance metric (areadegree-product) which does not consider every aspect of prover performance, and benchmarks in real proof systems might differ.</p>

    <p class="text-gray-300">Benchmarks in Plonky2. We implemented Monolith-64 in the Plonky2<a href="#page-29-1">14</a> proof system to verify the estimations of Table <a href="#page-28-0">4.</a> <a href="#page-29-2">15</a> Plonky2 uses FRI commitments and hence works well with small prime fields. Since it already comes with a custom gate of Poseidon in sponge mode (t = 12) where the entire gate is put into just one row of the trace, we implement Monolith-64-sponge with the same parameters. To highlight the main advantage of Monolith-64, namely its fast</p>

    <p class="text-gray-300"><sup>14</sup> <a href="https://github.com/mir-protocol/plonky2" target="_blank" rel="noopener noreferrer">https://github.com/mir-protocol/plonky2</a></p>

    <p class="text-gray-300"><sup>15</sup> Our implementation is available at <a href="https://github.com/HorizenLabs/monolith" target="_blank" rel="noopener noreferrer">https://github.com/HorizenLabs/monolith</a>.</p>

    <p class="text-gray-300">native performance, we benchmark proving a Monolith-64 permutation while using Monolith-64 as the hash function to build the Merkle trees. Similarly, we benchmark Poseidon when using Poseidon as the hash function (which is the default setting in Plonky2). The results can be seen in Table <a href="#page-29-0">5.</a> One can observe that since Monolith requires more witnesses than Poseidon and both gates use just one row in the trace, the resulting proof is larger. However, the combination of proving Monolith-64 while using it at as the Plonky2 hash function leads to half the prover and verifier runtime compared to Poseidon.</p>

    <p class="text-gray-300">This work was partially supported by a gift from the Ethereum foundation. Lorenzo Grassi is partially supported by the German Research foundation (DFG) within the framework of the Excellence Strategy of the Federal Government and the States &ndash; EXC 2092 CaSa &ndash; 39078197. Roman Walch was supported by the &quot;DDAI&quot; COMET Module within the COMET &ndash; Competence Centers for Excellent Technologies Programme, funded by the Austrian Federal Ministry for Transport, Innovation and Technology (bmvit), the Austrian Federal Ministry for Digital and Economic Affairs (bmdw), the Austrian Research Promotion Agency (FFG), the province of Styria (SFG) and partners from industry and academia. The COMET Programme is managed by FFG.</p>

    <p class="text-gray-300">Finally, we thank Nicholas Mainardi for helping with the implementation of Monolith in Plonky2 and for improving the efficiency of the gate. We also thank the anonymous Eurocrypt'24 Reviewers for their comments, especially for the observation regarding Eq. <a href="#page-12-0">(6)</a> which allows us to reduce the (longer) original proof of Proposition <a href="#page-11-1">1.</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[AAE+20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. &quot;Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols&quot;. In: IACR Trans. Symmetric Cryptol. 2020.3 (2020), pp. 1&ndash;45 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[ACG+19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard L&uuml;ftenegger, Christian Rechberger, et al. &quot;Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC&quot;. In: ASIACRYPT 2019. Vol. 11923. LNCS. 2019, pp. 371&ndash;397 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[AGR+16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. &quot;MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity&quot;. In: ASIACRYPT 2016. Vol. 10031. LNCS. 2016, pp. 191&ndash;219 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[AJN14] Jean-Philippe Aumasson, Philipp Jovanovic, and Samuel Neves. &quot;NORX: Parallel and Scalable AEAD&quot;. In: ESORICS 2014. Vol. 8713. LNCS. 2014, pp. 19&ndash;36 (cit. on p. <a href="#page-5-2">6)</a>.</p></li>
      <li><p class="text-gray-300">[AKM+22] Jean-Philippe Aumasson, Dmitry Khovratovich, Bart Mennink, and Por&ccedil;u Quine. SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications. <a href="https://eprint.iacr.org/2023/522" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/522</a>. 2022 (cit. on p. <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[Bal23] Balazs Komuves. hash-circuits. 2023. url: <a href="https://github.com/bkomuves/hash-circuits" target="_blank" rel="noopener noreferrer">https://github.com/</a> <a href="https://github.com/bkomuves/hash-circuits" target="_blank" rel="noopener noreferrer">bkomuves/hash-circuits</a> (visited on 10/06/2023) (cit. on p. <a href="#page-4-2">5)</a>.</p></li>
      <li><p class="text-gray-300">[BBC+23] Cl&eacute;mence Bouvier, Pierre Briaud, Pyrros Chaidos, L&eacute;o Perrin, Robin Salen, Vesselin Velichkov, et al. &quot;New Design Techniques for Efficient Arithmetization-Oriented Hash Functions: Anemoi Permutations and Jive Compression Mode&quot;. In: CRYPTO 2023. Vol. 14083. LNCS. 2023, pp. 507&ndash;539 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[BBH+19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. &quot;Scalable Zero Knowledge with No Trusted Setup&quot;. In: CRYPTO 2019. Vol. 11694. LNCS. 2019, pp. 701&ndash;732 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[BC23] Benedikt B&uuml;nz and Binyi Chen. &quot;ProtoStar: Generic Efficient Accumulation/Folding for Special Sound Protocols&quot;. In: IACR Cryptol. ePrint Arch. (2023). <a href="https://eprint.iacr.org/2023/620" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/620</a>, p. 620 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[BCC11] Christina Boura, Anne Canteaut, and Christophe De Canni&egrave;re. &quot;Higher-Order Differential Properties of Keccak and Luffa&quot;. In: FSE 2011. Vol. 6733. LNCS. 2011, pp. 252&ndash;269 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[BCD+20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Ga&euml;tan Leurent, et al. &quot;Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems&quot;. In: CRYPTO 2020. Vol. 12172. LNCS. 2020, pp. 299&ndash;328 (cit. on p. <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[BCP23] Cl&eacute;mence Bouvier, Anne Canteaut, and L&eacute;o Perrin. &quot;On the algebraic degree of iterated power functions&quot;. In: Des. Codes Cryptogr. 91.3 (2023), pp. 997&ndash;1033. doi: <a href="https://doi.org/10.1007/S10623-022-01136-X" target="_blank" rel="noopener noreferrer">10.1007/S10623- 022- 01136- X</a> (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[BDP+07] G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche. Sponge functions. In: Ecrypt Hash Workshop 2007, [http://www.csrc.](http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html) [nist.gov/pki/HashWorkshop/PublicComments/2007\\_May.html](http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html). 2007 (cit. on p. <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[BDP+08] Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, and Gilles Van Assche. &quot;On the Indifferentiability of the Sponge Construction&quot;. In: EUROCRYPT 2008. Vol. 4965. LNCS. 2008, pp. 181&ndash;197 (cit. on p. <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[BDP+11] Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, and Gilles Van Assche. Note on zero-sum distinguishers of Keccak-f. Available at</p></li>
      <li><p class="text-gray-300"><a href="https://keccak.team/files/NoteZeroSum.pdf" target="_blank" rel="noopener noreferrer">https://keccak.team/files/NoteZeroSum.pdf</a>. 2011 (cit. on p. <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[BDP+18] Guido Bertoni, Joan Daemen, Micha&euml;l Peeters, Gilles Van Assche, Ronny Van Keer, and Beno&icirc;t Viguier. &quot;KangarooTwelve: Fast Hashing Based on Keccak-p&quot;. In: ACNS 2018. Vol. 10892. LNCS. 2018, pp. 400&ndash;418 (cit. on p. <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[Ber05] Daniel J. Bernstein. Cache-timing attacks on AES. Avaiable at <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf" target="_blank" rel="noopener noreferrer">http://cr.yp.to/antiforgery/cachetiming- 20050414.pdf</a>. 2005 (cit. on p. <a href="#page-9-1">10)</a>.</p></li>
      <li><p class="text-gray-300">[BFM+16] Thierry P. Berger, Julien Francq, Marine Minier, and Ga&euml;l Thomas. &quot;Extended Generalized Feistel Networks Using Matrix Representation to Propose a New Lightweight Block Cipher: Lilliput&quot;. In: IEEE Trans. Computers 65.7 (2016), pp. 2074&ndash;2089 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12)</a>.</p></li>
      <li><p class="text-gray-300">[BFS15] Magali Bardet, Jean-Charles Faug&egrave;re, and Bruno Salvy. &quot;On the Complexity of the F5 Gr&ouml;bner Basis Algorithm&quot;. In: Journal of Symbolic Computation 70 (2015), pp. 49&ndash;70 (cit. on p. <a href="#page-22-3">23)</a>.</p></li>
      <li><p class="text-gray-300">[BMT13] Thierry P. Berger, Marine Minier, and Ga&euml;l Thomas. &quot;Extended Generalized Feistel Networks Using Matrix Representation&quot;. In: SAC 2013. Vol. 8282. LNCS. 2013, pp. 289&ndash;305 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12)</a>.</p></li>
      <li><p class="text-gray-300">[BS90] Eli Biham and Adi Shamir. &quot;Differential Cryptanalysis of DES-like Cryptosystems&quot;. In: CRYPTO 1990. Vol. 537. LNCS. 1990, pp. 2&ndash; 21 (cit. on p. <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[BSV07] Thomas Baign&egrave;res, Jacques Stern, and Serge Vaudenay. &quot;Linear Cryptanalysis of Non Binary Ciphers&quot;. In: Selected Areas in Cryptography &ndash; SAC 2007. Vol. 4876. LNCS. 2007, pp. 184&ndash;211 (cit. on p. <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[But22] Vitalik Buterin. What we want out of STARK signature aggregation. available at <a href="https://t.ly/UZMKw" target="_blank" rel="noopener noreferrer">https://t.ly/UZMKw</a>. 2022 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[CFG+22] Shumo Chu, Boyuan Feng, Brandon H. Gomes, Francisco Hern&aacute;ndez Iglesias, and Todd Norton. MantaPay Protocol Specification. available at <a href="https://github.com/Manta-Network/spec/blob/main/manta-pay/spec.pdf" target="_blank" rel="noopener noreferrer">https://github.com/Manta- Network/spec/blob/</a> <a href="https://github.com/Manta-Network/spec/blob/main/manta-pay/spec.pdf" target="_blank" rel="noopener noreferrer">main/manta-pay/spec.pdf</a>. 2022 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. &quot;Fractal: Postquantum and Transparent Recursive Proofs from Holography&quot;. In: EUROCRYPT 2020. Vol. 12105. LNCS. 2020, pp. 769&ndash;793 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[Dae95] Joan Daemen. Cipher and hash function design strategies based on linear and differential cryptanalysis. Doctoral Dissertation. Available at <a href="https://cs.ru.nl/~joan/papers/JDA_Thesis_1995.pdf" target="_blank" rel="noopener noreferrer">https://cs.ru.nl/~joan/papers/JDA\\_Thesis\\_1995.</a> <a href="https://cs.ru.nl/~joan/papers/JDA_Thesis_1995.pdf" target="_blank" rel="noopener noreferrer">pdf</a>. 1995 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-9-1">10,</a> <a href="#page-15-5">16,</a> <a href="#page-23-2">24)</a>.</p></li>
      <li><p class="text-gray-300">[DGG+21] Christoph Dobraunig, Lorenzo Grassi, Anna Guinet, and Dani&euml;l Kuijsters. &quot;Ciminion: Symmetric Encryption Based on Toffoli-Gates over Large Finite Fields&quot;. In: Advances in Cryptology - EURO-CRYPT 2021. Vol. 12697. LNCS. 2021, pp. 3&ndash;34 (cit. on p. <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[DGV94] Joan Daemen, Ren&eacute; Govaerts, and Joos Vandewalle. &quot;Correlation Matrices&quot;. In: FSE 1994. Vol. 1008. LNCS. 1994, pp. 275&ndash;285 (cit. on p. <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[DKR97] Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. &quot;The Block Cipher Square&quot;. In: FSE 1997. Vol. 1267. LNCS. 1997, pp. 149&ndash;165 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[DR01] Joan Daemen and Vincent Rijmen. &quot;The Wide Trail Design Strategy&quot;. In: Cryptography and Coding - IMA International Conference 2001. Vol. 2260. LNCS. 2001, pp. 222&ndash;238 (cit. on p. <a href="#page-11-2">12)</a>.</p></li>
      <li><p class="text-gray-300">[DR02] Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography. Available at <a href="https://cs.ru.nl/~joan/papers/JDA_VRI_Rijndael_2002.pdf" target="_blank" rel="noopener noreferrer">https://cs.ru.nl/~joan/papers/</a> <a href="https://cs.ru.nl/~joan/papers/JDA_VRI_Rijndael_2002.pdf" target="_blank" rel="noopener noreferrer">JDA\\_VRI\\_Rijndael\\_2002.pdf</a>. Springer, 2002 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. &quot;cq: Cached quotients for fast lookups&quot;. In: IACR Cryptol. ePrint Arch. (2022). <a href="https://eprint.iacr.org/2022/1763" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2022/1763" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2022/1763</a> (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[EGL+20] Maria Eichlseder, Lorenzo Grassi, Reinhard L&uuml;ftenegger, Morten &Oslash;ygarden, Christian Rechberger, Markus Schofnegger, et al. &quot;An Algebraic Attack on Ciphers with Low-Degree Round Functions: Application to Full MiMC&quot;. In: IACR Cryptol. ePrint Arch. (2020), p. 182 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[Fau99] Jean-Charles Faug&egrave;re. &quot;A New Efficient Algorithm for Computing Gr&ouml;bner Bases (F4)&quot;. In: Journal of Pure and Applied Algebra 139 (1999), pp. 61&ndash;88. doi: <a href="https://doi.org/10.1016/S0022-4049(99" target="_blank" rel="noopener noreferrer">10.1016/S0022-4049(99)00005-5</a>00005-5) (cit. on p. <a href="#page-22-3">23)</a>.</p></li>
      <li><p class="text-gray-300">[FGL+93] Jean-Charles Faug&egrave;re, Patrizia M. Gianni, Daniel Lazard, and Teo Mora. &quot;Efficient Computation of Zero-Dimensional Gr&ouml;bner Bases by Change of Ordering&quot;. In: J. Symb. Comput. 16.4 (1993), pp. 329&ndash; 344 (cit. on p. <a href="#page-22-3">23)</a>.</p></li>
      <li><p class="text-gray-300">[Fou22] Ethereum Foundation. ZKEVM Introduction. <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md" target="_blank" rel="noopener noreferrer">https://github.</a> <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md" target="_blank" rel="noopener noreferrer">com / privacy - scaling - explorations / zkevm - specs / blob /</a> <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md" target="_blank" rel="noopener noreferrer">master/specs/introduction.md</a>. 2022 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[GHR+23] Lorenzo Grassi, Yonglin Hao, Christian Rechberger, Markus Schofnegger, Roman Walch, and Qingju Wang. &quot;Horst Meets Fluid-SPN: Griffin for Zero-Knowledge Applications&quot;. In: CRYPTO 2023. Vol. 14083. LNCS. 2023, pp. 573&ndash;606 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-13-2">14,</a> <a href="#page-25-6">26,</a> <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[GKL+22] Lorenzo Grassi, Dmitry Khovratovich, Reinhard L&uuml;ftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. &quot;Reinforced Concrete: A Fast Hash Function for Verifiable Computation&quot;. In: ACM CCS. 2022, pp. 1323&ndash;1335 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5)</a>.</p></li>
      <li><p class="text-gray-300">[GKR+21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. &quot;Poseidon: A New Hash Function for Zero-Knowledge Proof Systems&quot;. In: USENIX Security Symposium. USENIX Association, 2021, pp. 519&ndash;535 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2,</a> <a href="#page-3-1">4,</a> <a href="#page-25-6">26,</a> <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[GKR+22] Lorenzo Grassi, Dmitry Khovratovich, Sondre R&oslash;njom, and Markus Schofnegger. &quot;The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over Fnp Preimage Attack on Full Grendel&quot;. In: IACR Trans. Symmetric Cryptol. 2022.1 (2022), pp. 5&ndash;37 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[GKS23] Lorenzo Grassi, Dmitry Khovratovich, and Markus Schofnegger. &quot;Poseidon2: A Faster Version of the Poseidon Hash Function&quot;. In: AFRICACRYPT 2023. Vol. 14064. LNCS. 2023, pp. 177&ndash;203 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-13-2">14,</a> <a href="#page-25-6">26)</a>.</p></li>
      <li><p class="text-gray-300">[GLL+20] Jian Guo, Guohong Liao, Guozhen Liu, Meicheng Liu, Kexin Qiao, and Ling Song. &quot;Practical Collision Attacks against Round-Reduced SHA-3&quot;. In: J. Cryptol. 33.1 (2020), pp. 228&ndash;270 (cit. on p. <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[Gra23] Lorenzo Grassi. &quot;Bounded Surjective Quadratic Functions over F n p for MPC-/ZK-/FHE-Friendly Symmetric Primitives&quot;. In: IACR Trans. Symmetric Cryptol. 2023.2 (2023), pp. 94&ndash;131 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12)</a>.</p></li>
      <li><p class="text-gray-300">[GRS21] Lorenzo Grassi, Christian Rechberger, and Markus Schofnegger. &quot;Proving Resistance Against Infinitely Long Subspace Trails: How to Choose the Linear Layer&quot;. In: IACR Trans. Symmetric Cryptol. 2021.2 (2021), pp. 314&ndash;352 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[GSW+21] Chun Guo, Fran&ccedil;ois-Xavier Standaert, Weijia Wang, Xiao Wang, and Yu Yu. &quot;Provable Security of SP Networks with Partial Non-Linear Layers&quot;. In: IACR Trans. Symmetric Cryptol. 2021.2 (2021), pp. 353&ndash;388 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[GW20] Ariel Gabizon and Zachary J. Williamson. &quot;plookup: A simplified polynomial protocol for lookup tables&quot;. In: IACR Cryptol. ePrint Arch. (2020) (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-28-1">29)</a>.</p></li>
      <li><p class="text-gray-300">[Hab23] Ulrich Hab&ouml;ck. Brakedown's expander code. Cryptology ePrint Archive, Paper 2023/769. <a href="https://eprint.iacr.org/2023/769" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/769</a>. 2023 (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[HLN23] Ulrich Hab&ouml;ck, Daniel Lubarov, and Jacqueline Nabaglo. Reed-Solomon Codes over the Circle Group. Cryptology ePrint Archive, Paper 2023/824. <a href="https://eprint.iacr.org/2023/824" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/824</a>. 2023 (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[HR10] Viet Tung Hoang and Phillip Rogaway. &quot;On generalized Feistel networks&quot;. In: Annual Cryptology Conference. Springer. 2010, pp. 613&ndash; 630 (cit. on pp. <a href="#page-11-2">12,</a> <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[HS24] Ulrich Hab&ouml;ck and Markus Schofnegger. &quot;Efficient MDS Matrices from Linear Codes&quot;. In preparation. 2024 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-27-1">28)</a>.</p></li>
      <li><p class="text-gray-300">[IAI21] IAIK. Hash functions for Zero-Knowledge applications Zoo. <a href="https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo" target="_blank" rel="noopener noreferrer">//extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo</a>. IAIK, Graz University of Technology. Aug. 2021 (cit. on p. <a href="#page-25-6">26)</a>.</p></li>
      <li><p class="text-gray-300">[JK97] Thomas Jakobsen and Lars R. Knudsen. &quot;The Interpolation Attack on Block Ciphers&quot;. In: FSE 1997. Vol. 1267. LNCS. 1997, pp. 28&ndash;40 (cit. on p. <a href="#page-21-0">22)</a>.</p></li>
      <li><p class="text-gray-300">[KBM23] Dmitry Khovratovich, Mario Marhuenda Beltr&aacute;n, and Bart Mennink. &quot;Generic Security of the SAFE API and Its Applications&quot;. In: IACR Cryptol. ePrint Arch. (2023). to appear at ASIACRYPT'23, p. 520 (cit. on p. <a href="#page-13-2">14)</a>.</p></li>
      <li><p class="text-gray-300">[KMT22] Dmitry Khovratovich, Mary Maller, and Pratyush Ranjan Tiwari. &quot;MinRoot: Candidate Sequential Function for Ethereum VDF&quot;. In: IACR Cryptol. ePrint Arch. (2022) (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[Knu94] Lars R. Knudsen. &quot;Truncated and Higher Order Differentials&quot;. In: FSE 1994. Vol. 1008. LNCS. 1994, pp. 196&ndash;211 (cit. on pp. <a href="#page-18-1">19,</a> <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[KR07] Lars R. Knudsen and Vincent Rijmen. &quot;Known-Key Distinguishers for Some Block Ciphers&quot;. In: Advances in Cryptology - ASI-ACRYPT 2007. Vol. 4833. LNCS. 2007, pp. 315&ndash;324 (cit. on p. <a href="#page-16-2">17)</a>.</p></li>
      <li><p class="text-gray-300">[KS23] Abhiram Kothapalli and Srinath T. V. Setty. &quot;HyperNova: Recursive arguments for customizable constraint systems&quot;. In: IACR Cryptol. ePrint Arch. (2023). <a href="https://eprint.iacr.org/2023/573" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/</a> <a href="https://eprint.iacr.org/2023/573" target="_blank" rel="noopener noreferrer">573</a>, p. 573 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[KST22] Abhiram Kothapalli, Srinath T. V. Setty, and Ioanna Tzialla. &quot;Nova: Recursive Zero-Knowledge Arguments from Folding Schemes&quot;. In: CRYPTO 2022. Vol. 13510. LNCS. 2022, pp. 359&ndash;388 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[LAA+11] Gregor Leander, Mohamed Ahmed Abdelraheem, Hoda AlKhzaimi, and Erik Zenner. &quot;A Cryptanalysis of PRINTcipher: The Invariant Subspace Attack&quot;. In: CRYPTO 2011. Vol. 6841. LNCS. 2011, pp. 206&ndash;221 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[Lai94] Xuejia Lai. &quot;Higher Order Derivatives and Differential Cryptanalysis&quot;. In: Communications and Cryptography: Two Sides of One Tapestry. Springer US, 1994, pp. 227&ndash;233 (cit. on p. <a href="#page-10-2">11)</a>.</p></li>
      <li><p class="text-gray-300">[Laz79] Daniel Lazard. &quot;Systems of Algebraic Equations&quot;. In: International Symposium on Symbolic and Algebraic Computation - EUROSAM 1979. Ed. by Edward W. Ng. Vol. 72. Lecture Notes in Computer Science. Springer, 1979, pp. 88&ndash;94 (cit. on p. <a href="#page-22-3">23)</a>.</p></li>
      <li><p class="text-gray-300">[Laz83] Daniel Lazard. &quot;Gr&ouml;bner Bases, Gaussian Elimination and Resolution of Systems of Algebraic Equations&quot;. In: European Conference on Computer Algebra - EUROCAL 1983. Ed. by J. A. van Hulzen. Vol. 162. Lecture Notes in Computer Science. Springer, 1983, pp. 146&ndash;156 (cit. on p. <a href="#page-22-3">23)</a>.</p></li>
      <li><p class="text-gray-300">[LMR15] Gregor Leander, Brice Minaud, and Sondre R&oslash;njom. &quot;A Generic Approach to Invariant Subspace Attacks: Cryptanalysis of Robin, iSCREAM and Zorro&quot;. In: EUROCRYPT 2015. Vol. 9056. LNCS. 2015, pp. 254&ndash;283 (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[LP19] Chaoyun Li and Bart Preneel. &quot;Improved Interpolation Attacks on Cryptographic Primitives of Low Algebraic Degree&quot;. In: Selected</p></li>
      <li><p class="text-gray-300">Areas in Cryptography SAC 2019 26th International Conference, Waterloo, ON, Canada, August 12-16, 2019, Revised Selected Papers. Ed. by Kenneth G. Paterson and Douglas Stebila. Vol. 11959. Lecture Notes in Computer Science. Springer, 2019, pp. 171&ndash;193. doi: <a href="https://doi.org/10.1007/978-3-030-38471-5_8" target="_blank" rel="noopener noreferrer">10.1007/978-3-030-38471-5\\_8</a> (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[Mat93] Mitsuru Matsui. &quot;Linear Cryptanalysis Method for DES Cipher&quot;. In: EUROCRYPT 1993. Vol. 765. LNCS. 1993, pp. 386&ndash;397 (cit. on p. <a href="#page-17-3">18)</a>.</p></li>
      <li><p class="text-gray-300">[MRS+09] Florian Mendel, Christian Rechberger, Martin Schl&auml;ffer, and S&oslash;ren S. Thomsen. &quot;The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Gr&oslash;stl&quot;. In: FSE 2009. Vol. 5665. LNCS. 2009, pp. 260&ndash;276 (cit. on p. <a href="#page-18-1">19)</a>.</p></li>
      <li><p class="text-gray-300">[Nat15] National Institute of Standards and Technology. &quot;SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions&quot;. In: Federal Information Processing Standards Publication (FIPS) (202 2015) (cit. on p. <a href="#page-44-2">45)</a>.</p></li>
      <li><p class="text-gray-300">[OST06] Dag Arne Osvik, Adi Shamir, and Eran Tromer. &quot;Cache Attacks and Countermeasures: The Case of AES&quot;. In: CT-RSA 2006. Vol. 3860. LNCS. 2006, pp. 1&ndash;20 (cit. on p. <a href="#page-9-1">10)</a>.</p></li>
      <li><p class="text-gray-300">[Pag02] D. Page. Theoretical Use of Cache Memory as a Cryptanalytic Side-Channel. Cryptology ePrint Archive. <a href="https://eprint.iacr.org/2002/169" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2002/169" target="_blank" rel="noopener noreferrer">2002/169</a>. 2002 (cit. on p. <a href="#page-9-1">10)</a>.</p></li>
      <li><p class="text-gray-300">[PH23] Shahar Papini and Ulrich Hab&ouml;ck. &quot;Improving logarithmic derivative lookups using GKR&quot;. In: IACR Cryptol. ePrint Arch. (2023). <a href="https://eprint.iacr.org/2023/1284" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/1284</a> (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[Pol22a] Polygon. Introducing Plonky2. 2022 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5)</a>.</p></li>
      <li><p class="text-gray-300">[Pol22b] Polygon. zkEVM Documentation. <a href="https://docs.hermez.io/zkEVM/Overview/Overview/" target="_blank" rel="noopener noreferrer">https : / / docs . hermez . io /</a> <a href="https://docs.hermez.io/zkEVM/Overview/Overview/" target="_blank" rel="noopener noreferrer">zkEVM/Overview/Overview/</a>. 2022 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[Pol23] Polygon. Plonky3. 2023. url: <a href="https://github.com/Plonky3/Plonky3" target="_blank" rel="noopener noreferrer">https : / / github . com / Plonky3 /</a> <a href="https://github.com/Plonky3/Plonky3" target="_blank" rel="noopener noreferrer">Plonky3</a> (visited on 06/12/2023) (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[PSS19] Alexey Pertsev, Roman Semenov, and Roman Storm. Tornado Cash Privacy Solution Version 1.4. available at <a href="https://t.ly/ys_pW" target="_blank" rel="noopener noreferrer">https://t.ly/ys\\_pW</a>. 2019 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[RAS20] Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer. &quot;Interpolation Cryptanalysis of Unbalanced Feistel Networks with Low Degree Round Functions&quot;. In: Selected Areas in Cryptography - SAC 2020 - 27th International Conference, Halifax, NS, Canada (Virtual Event), October 21-23, 2020, Revised Selected Papers. Ed. by Orr Dunkelman, Michael J. Jacobson Jr., and Colin O'Flynn. Vol. 12804. Lecture Notes in Computer Science. Springer, 2020, pp. 273&ndash;300. doi: <a href="https://doi.org/10.1007/978-3-030-81652-0_11" target="_blank" rel="noopener noreferrer">10 . 1007 / 978 - 3 - 030 - 81652 - 0 \\ \\_11</a> (cit. on p. <a href="#page-19-3">20)</a>.</p></li>
      <li><p class="text-gray-300">[RIS23a] Jeremy Bruestle (RISC0). private communication. 2023 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[RIS23b] RISC Zero. RISC Zero : General-Purpose Verifiable Computing. 2023 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5)</a>.</p></li>
      <li><p class="text-gray-300">[SAD20] Alan Szepieniec, Tomer Ashur, and Siemen Dhooghe. Rescue-Prime: a Standard Specification (SoK). Cryptology ePrint Archive, Report 2020/1143. 2020 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[Sal23] Robin Salen. Two additional instantiations from the Tip5 hash function construction. <a href="https://toposware.com/paper_tip5.pdf" target="_blank" rel="noopener noreferrer">https://toposware.com/paper\\_tip5.pdf</a>. 2023 (cit. on p. <a href="#page-25-6">26)</a>.</p></li>
      <li><p class="text-gray-300">[SLS+23] Alan Szepieniec, Alexander Lemmens, Jan Ferdinand Sauer, Bobbin Threadbare, and Al-Kindi. The Tip5 Hash Function for Recursive STARKs. Cryptology ePrint Archive, Paper 2023/107. <a href="https://eprint.iacr.org/2023/107" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://eprint.iacr.org/2023/107" target="_blank" rel="noopener noreferrer">//eprint.iacr.org/2023/107</a>. 2023 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5,</a> <a href="#page-16-2">17,</a> <a href="#page-25-6">26)</a>.</p></li>
      <li><p class="text-gray-300">[STW23] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. &quot;Unlocking the lookup singularity with Lasso&quot;. In: IACR Cryptol. ePrint Arch. (2023). <a href="https://eprint.iacr.org/2023/1216" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2023/1216</a> (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[TBP20] Florian Tram&egrave;r, Dan Boneh, and Kenny Paterson. &quot;Remote Side-Channel Attacks on Anonymous Transactions&quot;. In: USENIX Security Symposium. USENIX Association, 2020, pp. 2739&ndash;2756 (cit. on pp. <a href="#page-9-1">10,</a> <a href="#page-27-1">28)</a>.</p></li>
      <li><p class="text-gray-300">[Val08] Paul Valiant. &quot;Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency&quot;. In: TCC 2008. Vol. 4948. LNCS. 2008, pp. 1&ndash;18 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[ZBK+22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. &quot;Caulk: Lookup Arguments in Sublinear Time&quot;. In: CCS. ACM, 2022, pp. 3121&ndash;3134 (cit. on p. <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[ZGK+22] Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla R&agrave;fols. Baloo: Nearly Optimal Lookup Arguments. Cryptology ePrint Archive. <a href="https://eprint.iacr.org/2022/1565" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2022/1565</a>. 2022 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-2-1">3)</a>.</p></li>
      <li><p class="text-gray-300">[Zha22] Ye Zhang. Introducing zkEVM. <a href="https://scroll.io/blog/zkEVM" target="_blank" rel="noopener noreferrer">https://scroll.io/blog/zkEVM</a>. 2022 (cit. on p. <a href="#page-1-1">2)</a>.</p></li>
      <li><p class="text-gray-300">[ZMI89] Yuliang Zheng, Tsutomu Matsumoto, and Hideki Imai. &quot;On the Construction of Block Ciphers Provably Secure and Not Relying on Any Unproved Hypotheses&quot;. In: CRYPTO 1989. Vol. 435. LNCS. 1989, pp. 461&ndash;480 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-11-2">12)</a>.</p></li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1<br>Hash Functions in Zero-Knowledge Frameworks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2<br>Our Contributions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fast and Circuit-Friendly Functions over Fp<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.1<br>Chunks and Buckets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2<br>The Kintsugi Bar</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3<br>Well-Definition and Bijectivity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.4<br>Considerations about the Kintsugi Strategy</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5<br>Statistical and Algebraic Properties</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Feistel Type-3 Layer and the Wide Trail Strategy</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Specification of Monolith</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1<br>Modes of Operation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2<br>Permutation Structure</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3<br>Bars</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.4<br>Bricks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5<br><br>Concrete</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.6<br>Number of Rounds and Security Claims</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.7<br>Security Analysis</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Security Analysis: Statistical Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.1<br>(Truncated) Differential and Linear Cryptanalysis</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.2<br>Rebound Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.3<br>Other Statistical Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Security Analysis: Algebraic Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1<br>Degree of the Bars Polynomials</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.2<br>Security against Algebraic Attacks via Bars</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.3<br>Solving the Multivariate CICO Problem with Gr&ouml;bner Bases</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algebraic Attacks over F2<br>6.4<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Performance Evaluation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.1<br>Native Performance</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7.2<br>Performance in Proof Systems</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Fast Reduction for Special Primes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 &minus;<br>A.1<br>Fast Reduction for Primes of the Form &#981;<br>&#981; + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&rho; &minus;<br>A.2<br>Fast Reduction for Primes of the Form 2<br>1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A.3<br>Generation of Round Constants</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Security Analysis &ndash; Additional Material</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B.1<br>Rebound Collision Attack on the 3-Round (Weakened) Monolith</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B.2<br>Degree and Density: Practical Results</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B.3<br>Details about GB Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B.4<br>Non-Applicable Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Benchmarks of Different Round Functions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Arithmetization Details</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">D.1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">R1CS</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">45</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Circuits for Other Hash Functions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Multiround Constraints for Monolith</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Fast Reduction for Primes of the Form &#981; <sup>2</sup> &minus; &#981; + 1</h3>

    <p class="text-gray-300">Here we describe the fast reduction modulo a prime number of the form &#981; <sup>2</sup>&minus;&#981;+1. Note that this includes p = 2<sup>64</sup> &minus;2 <sup>32</sup> + 1, where &#981; = 232. We focus on the case of a multiplication, where two n-bit inputs result in an output of at most 2n bits.</p>

    <p class="text-gray-300">Given F<sup>p</sup> for p = &#981; <sup>2</sup> &minus; &#981; + 1, it follows that</p>

    <p class="text-gray-300"><span class="math">$\\phi^2 = \\phi - 1 \\implies \\phi^3 = \\phi^2 - \\phi = -1.</span>$</p>

    <p class="text-gray-300">Now, let us write a value x to be reduced as</p>

    <p class="text-gray-300"><span class="math">$x = x_0 + \\phi^2 x_1 + \\phi^3 x_2,</span>$</p>

    <p class="text-gray-300">where x<sup>0</sup> &isin; Z2<sup>n</sup> and x1, x<sup>2</sup> &isin; Z2n/<sup>2</sup> . Then</p>

    <p class="text-gray-300"><span class="math">$x = x_0 + (\\phi - 1)x_1 - x_2 \\pmod{p},</span>$</p>

    <p class="text-gray-300">where note that log<sup>2</sup> (x<sup>0</sup> + (&#981; &minus; 1)x<sup>1</sup> &minus; x2) &asymp; log<sup>2</sup> (p). This reduction can be computed using only a small number of additions and subtractions.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Fast Reduction for Primes of the Form 2 <sup>&rho;</sup> &minus; 1</h3>

    <p class="text-gray-300">Here we describe the fast reduction modulo a prime number of the form 2 <sup>&rho;</sup> &minus; 1 which includes p = 2<sup>31</sup> &minus; 1. We focus on the case of a multiplication, where two &rho;-bit inputs result in an output of at most 2&rho; bits.</p>

    <p class="text-gray-300">Given F<sup>p</sup> for p = 2<sup>&rho;</sup> &minus; 1, it follows that 2 <sup>&rho;</sup> = 1 + p. Now, let us write a value x to be reduced as</p>

    <p class="text-gray-300"><span class="math">$x = x_0 + 2^{\\rho} x_1,</span>$</p>

    <p class="text-gray-300">where x<sup>0</sup> &isin; Z<sup>2</sup> <sup>&rho;</sup> and x<sup>1</sup> &isin; Fp. Then</p>

    <p class="text-gray-300"><span class="math">$x = x_0 + x_1 + \\underbrace{(2^{\\rho} - 1) \\cdot x_1}_{=0 \\pmod{p}} = x_0 + x_1 \\pmod{p}.</span>$</p>

    <p class="text-gray-300">This reduction can be computed using only a small number of additions and binary shifts.</p>

      <h3 id="app-a.3" class="text-xl font-semibold mt-8">A.3 Generation of Round Constants</h3>

    <p class="text-gray-300">The round constants  <span class="math">c_1^{(i)}, c_2^{(i)}, \\ldots, c_t^{(i)}</span>  for the i-th round are generated using the well-known approach of seeding a pseudo-random number generator and reading its output stream. In particular, we use SHAKE-128 with rejection sampling, i.e., we discard elements which are not in  <span class="math">\\mathbb{F}_p</span> . SHAKE-128, thereby, is seeded with the initial seed &quot;Monolith&quot; followed by the state size t and number of rounds R, each represented as one byte, the prime p represented by  <span class="math">\\lceil \\log_2(p)/8 \\rceil</span>  bytes in little endian representation, and the decomposition sizes in the bar layer, where each  <span class="math">s_i</span>  is represented as one byte. As concrete examples, the seed is</p>

    <p class="text-gray-300">b'Monolith\\x08\\x06\\x01\\x00\\x00\\x0f\\xff\\xff\\xff\\xff\\xff\\xff\\xff</p>

    <p class="text-gray-300">for Monolith-64 with t = 8 and R = 6, and</p>

    <p class="text-gray-300"><span class="math">b&#x27;Monolith\\\\x10\\\\x06\\\\xff\\\\xff\\\\xff\\\\x7f\\\\x08\\\\x08\\\\x08\\\\x07&#x27;</span></p>

    <p class="text-gray-300">for Monolith-31 with t = 16 and R = 6.</p>

    <p class="text-gray-300">The best rebound attack that we have found is a near-collision attack on the reduced 3-round permutation without the Bars layer. We show how to find a state that satisfies a differential  <span class="math">\\Delta_1 \\to \\Delta_8</span>  for certain  <span class="math">\\Delta_1, \\Delta_8</span>  which are equal in the last  <span class="math">\\mathbb{F}_p</span>  word, i.e.,  <span class="math">\\Delta_{1,t} = \\Delta_{8,t}</span> . As a concrete application, this yields a zero difference in this word for the compression function  <span class="math">x \\mapsto \\operatorname{Tr}_{t/2}(\\mathcal{P}(x) + x)</span> , which is a near-collision.</p>

    <p class="text-gray-300">The inbound phase covers 3 layers of Bricks separated by 2 Concrete layers:</p>

    <p class="text-gray-300"><span class="math">$\\Delta_1 \\xleftarrow{\\mathsf{Concrete}}_{t \\to 1} \\Delta_2 \\xleftarrow{\\mathsf{Bricks}}_{1} \\underbrace{\\Delta_3 \\xrightarrow{\\mathsf{Concrete}}_{1 \\to t} \\Delta_4 \\xleftarrow{\\mathsf{Bricks}}_{t \\to 1} \\Delta_5 \\xrightarrow{\\mathsf{Concrete}}_{t \\leftarrow 2} \\Delta_6 \\xrightarrow{\\mathsf{Bricks}}_{2} \\Delta_7}_{\\text{inbound phase}} \\xrightarrow{\\mathsf{Concrete}}_{2 \\to t} \\Delta_8.</span>$</p>

    <p class="text-gray-300">To find such a state pair, we apply the following approach.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the inbound phase we arbitrarily choose  <span class="math">\\delta</span>  and set  <span class="math">\\Delta_3 = [0, 0, \\dots, 0, \\delta]</span>  such that its nonzero difference is in the last word only and propagates through  <span class="math">\\mathtt{Bricks}^{-1}</span>  untouched. That is,  <span class="math">\\Delta_2 = \\Delta_3</span> . Let  <span class="math">\\Delta_1</span>  be  <span class="math">\\mathtt{Concrete}^{-1}(\\Delta_2)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The inbound phase covers the expansion of  <span class="math">\\Delta_2</span>  to t words and back to the 2-word difference  <span class="math">\\Delta_7 = [0,0,\\ldots,0,\\delta_2,\\delta_3]</span> . Note that we have  <span class="math">\\Delta_6 = [0,0,\\ldots,0,\\delta_2,\\delta_4]</span> . We arbitrarily set  <span class="math">\\delta_2,\\delta_3</span>  such that  <span class="math">\\Delta_{8,t} = \\Delta_{1,t}</span>  and then choose  <span class="math">\\delta_4</span>  such that</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathtt{Concrete}(\\Delta_2) = \\Delta_{4,1} = \\Delta_{5,1} = \\mathtt{Concrete}^{-1}(\\Delta_6).</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>As a result, the differential path for the full 3-round scheme is established, and we determine the state. The  <span class="math">(\\delta_3, \\delta_4)</span>  differential determines the input word  <span class="math">x_{t-1}</span>  of the third Bricks layer, and the equation</li>
    </ol>

    <p class="text-gray-300"><span class="math">$Bricks(\\mathbf{X} + \\Delta_4) = Bricks(\\mathbf{X}) + \\Delta_5.</span>$</p>

    <p class="text-gray-300">determines input words  <span class="math">x_1, x_2, \\ldots, x_{t-1}</span>  of the second Bricks layer. Note that this is a system of linear equations, and by solving it we can determine the full state.</p>

    <p class="text-gray-300">Overall we obtain a partial collision at a negligible cost (the cost for solving the linear system of equations can be approximated by  <span class="math">\\Omega(t^3)</span> , which is much smaller than the cost for constructing the collision in the case of a random permutation approximated by  <span class="math">p^{1/2}</span> ). We are not aware of any possible extension of such attack to more rounds and/or including Bars, which is left as an open problem for future work.</p>

      <h3 id="app-b.2" class="text-xl font-semibold mt-8">B.2 Degree and Density: Practical Results</h3>

    <p class="text-gray-300">Evaluating the actual density of the polynomial resulting from Bar applied to a single field element in  <span class="math">\\mathbb{F}_p</span> , where  <span class="math">p \\in \\{2^{64} - 2^{32} + 1, 2^{31} - 1\\}</span> , is infeasible in practice. Indeed, any enumeration and subsequent interpolation approach would take far too long.</p>

    <p class="text-gray-300">Therefore, in our experiments we focus on smaller finite fields defined by &quot;similar&quot; prime numbers. In particular, we focus on n-bit primes of the form  <span class="math">2^n - 2^{\\eta} + 1</span>  for  <span class="math">\\eta</span>  as close to n as possible. We then apply the S-box  <span class="math">S_i</span>  to smaller parts of the field element, exactly as in Bar where the S-box is applied to each 8-bit part of the larger field element. We also vary the sizes of the parts to which the  <span class="math">S_i</span>  are applied in order to get a broader picture.</p>

    <p class="text-gray-300">The results of our evaluation are shown in Table 6. For example, in the first case, where  <span class="math">p=2^8-2^4+1</span> ,  <span class="math">S_i</span>  is applied to the first 4 bits (starting from the least significant bit) and then to the next 4 bits, covering the entire field element. The size of these parts is indicated in the second column. As we can see, the maximum degree is reached for all tested primes of the form  <span class="math">2^n-2^{\\eta}+1</span> , where  <span class="math">\\eta&gt;1</span> . Moreover, for these primes, the density is always close to 100%, mostly matching it. We also applied  <span class="math">S_i</span>  to elements of  <span class="math">\\mathbb{F}_{2^n-1}</span>  directly, where  <span class="math">n \\in \\{5,7,13\\}</span> , which resulted in almost maximum-degree polynomials of low density (specifically, only 6, 18, and 629 monomials exist in the polynomial representation, respectively). This suggests that increasing the number of S-box applications per field element (i.e., increasing the number of smaller parts to which  <span class="math">S_i</span>  are applied) is beneficial for the density of the resulting polynomial.</p>

    <p class="text-gray-300">We also evaluated the degrees and density values resulting from the inverse S-boxes applied to the field elements, in order to get an estimation of the algebraic strength of the inverse operation. The results match the results given in Table 6, where always more than 99% monomials are reached together with a degree close to the maximum.</p>

    <p class="text-gray-300"><strong>Table 6.</strong> Degree and density of the polynomials resulting from Bar applied to various field elements.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\overline{p}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bit splittings</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Degree</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Density</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^8 - 2^4 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{4, 4\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">239 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13} - 2^8 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{8,5\\}, \\{4,4,5\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7935 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&gt;99% (7934/7935)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13} - 2^5 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{5,8\\},\\{5,4,4\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8159 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&gt;99% (8157/8159)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14} - 2^{10} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{10,4\\},\\{5,5,4\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">15359 \\ (= p - 2)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">&gt;99\\% \\ (15358/15359)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14} - 2^4 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{4, 10\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16367 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">100%</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14} - 2^4 + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{4, 5, 5\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16367 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">&gt;99\\% \\ (16364/16367)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13}-1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">{5,8}, {8,5}, {4,9}, {9,4}</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8189 (= p - 2)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&gt; 99% (8188/8189)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^7 - 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{3,4\\},\\{4,3\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">125 \\ (= p - 2)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&gt;99% (124/125)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">{2^5-1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">26 \\ (= p - 5)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx 21\\% \\ (6/29)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^7 - 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">120 \\ (= p - 7)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx 14\\% \\ (18/125)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13}-1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">8178 \\ (= p - 13)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\approx 8\\% \\ (629/8189)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 7.</strong> Degree and density of the polynomials after a single round, where t=4 and two input variables are used (with the other two input elements being fixed).</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">p</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bit splittings</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Degree</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Density</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\begin{array}{r} 2^8 - 2^4 + 1 \\ 2^7 - 1 \\ 2^7 - 1 \\end{array} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\{4,4\\}</span> <span class="math">\\{3,4\\}</span> <span class="math">\\{4,3\\}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">239 (= p - 2) <span class="math">125 (= p - 2)</span> <span class="math">125 (= p - 2)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&gt; 99% (28785/28920)<br>&gt; 98% (7919/8001)<br>&gt; 98% (7919/8001)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Results for</strong>  <span class="math">\\mathbb{F}_p^t</span> . We also ran tests regarding the density over the entire state. Naturally, this task gets harder with an increased number of rounds, since the degrees are rising too quickly. In our tests we focused on  <span class="math">p \\in \\{2^8 - 2^4 + 1, 2^7 - 1\\}</span>  and t = 4, and we give the results together with the sizes of the smaller S-boxes in Table 7.</p>

    <p class="text-gray-300">As can be seen, the maximum number of monomials is almost reached after a single round. We suspect that some of the monomials are not reached due to cancellations, which is reasonable when considering these small prime fields. Still, we acknowledge this fact by adding another round on top of that in order to ensure that all polynomial representations of the state are dense and of maximum degree. Thus, having 6 rounds achieves 4 rounds of security margin regarding degrees and density of polynomials.</p>

      <h3 id="app-b.3" class="text-xl font-semibold mt-8">B.3 Details about GB Attacks</h3>

    <p class="text-gray-300">Algebraic Model for Bar. We suggest the following algebraic model for Bar for a decomposition of a prime field element into m buckets with sizes</p>

    <p class="text-gray-300"><span class="math">2^{s_1}, 2^{s_2}, \\ldots, 2^{s_m}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} x = x_1b_1 + x_2b_2 + \\dots + x_mb_m, \\\\ 0 = \\prod_{j=0}^{2^{s_i}-1} (x_i - j), &amp; 1 \\le i \\le m, \\\\ y = \\mathcal{L}_1(x_1)b_1 + \\mathcal{L}_2(x_2)b_2 + \\dots + \\mathcal{L}_m(x_m)b_m. \\end{cases}</span>$</p>

    <p class="text-gray-300">Here,  <span class="math">b_1=1</span>  and  <span class="math">b_i:=2^{s_1+\\cdots+s_i}</span> , for  <span class="math">2\\leq i\\leq m</span> , and  <span class="math">\\mathcal{L}_i:\\mathbb{F}_p\\to\\mathbb{F}_p</span>  is the interpolation polynomial over  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">\\binom{s_i-1}{n}</span>  for the S-box  <span class="math">\\mathcal{S}_i</span>  given by</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{L}_{i}(x_{i}) := \\sum_{0 \\leq k \\leq 2^{s_{i}} - 1} \\mathcal{S}_{i}(k) \\prod_{\\substack{0 \\leq j \\leq 2^{s_{i}} - 1 \\\\ j \\neq k}} \\frac{x_{i} - j}{k - j}.</span>$</p>

    <p class="text-gray-300">The resulting system consists of m+2 equations, namely m equations of respective degrees  <span class="math">2^{s_1}, \\ldots, 2^{s_m}, 1</span>  equation of degree  <span class="math">\\max_i (2^{s_i} - 1)</span> , and 1 equation of degree 1. The m+2 variables are  <span class="math">x_1, \\ldots, x_m, x, y</span> .</p>

    <p class="text-gray-300">Algebraic Model for SmallWeak1R-CICO. We consider the CICO problem SmallWeak1R-CICO that fixes v=1 words to 0 in the input and output, respectively. In other words, we are looking for  <span class="math">i_2, i_3, i_4, o_2, o_3, o_4 \\in \\mathbb{F}_p</span>  such that</p>

    <p class="text-gray-300">SmallWeak1R
<span class="math">$(0, i_2, i_3, i_4) = (0, o_2, o_3, o_4)</span>$
.</p>

    <p class="text-gray-300">The function  <span class="math">\\mathtt{SmallWeak1R} = \\mathtt{Concrete&#x27;} \\circ \\mathtt{Bricks} \\circ \\mathtt{Bars} \\circ \\mathtt{Concrete&#x27;}</span>  is a small-scale and weakened version of one round of Monolith defined on t=4 words and u=2 Bar functions in the Bars layer. For  <span class="math">\\mathtt{Concrete&#x27;}</span> , we use the circulant matrix  <span class="math">M=\\mathrm{circ}(2,1,1,1)</span> , which is not MDS and thus weaker than the MDS matrix in Monolith. Our algebraic model for  <span class="math">\\mathtt{SmallWeak1R-CICO}</span> , denoted by the same name, is given by the following system of equations:</p>

    <p class="text-gray-300"><span class="math">$\\left\\{ \\begin{array}{l} 0 = \\mathtt{Concrete&#x27;}^{-1}(v_1,v_2,v_3,v_4)_1, \\\\ w_1 = \\mathtt{Bar}(u_1), \\\\ w_2 = \\mathtt{Bar}(u_2), \\\\ 0 = (\\mathtt{Concrete&#x27;} \\circ \\mathtt{Bricks})(w_1,w_2,v_3,v_4)_1. \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">Here,  <span class="math">\\mathcal{H}(\\cdot)_i</span>  denotes the <em>i</em>-th element of the output of the function  <span class="math">\\mathcal{H}</span>  for  <span class="math">i \\in \\{1,2,3,4\\}</span> . We note that each Bar function decomposes a prime field element into m=2 buckets, hence,  <span class="math">w_i=\\mathrm{Bar}(u_i)</span>  denotes above algebraic model for Bar with a decomposition into m=2 buckets. The resulting equation system consists of 10 equations with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>4 equations for each Bar system  <span class="math">w_i = Bar(u_i)</span> , i = 1, 2, and</li>
      <li>2 equations for modelling the CICO constraint at the input and the output.</li>
    </ul>

    <p class="text-gray-300">In total, we have 10 variables, namely  <span class="math">u_1, u_2, u_3, u_4, w_1, w_2</span>  and 2 internal variables for each Bar system.</p>

      <h3 id="app-b.4" class="text-xl font-semibold mt-8"><strong>B.4</strong> Non-Applicable Attacks</h3>

    <p class="text-gray-300">We emphasize that we do not claim security of Monolith against zero-sum partitions [BCC11] (which can be set up via higher-order differentials [Knu94; BCD+20] and/or integral/square attacks [DKR97]). In such an attack, the goal is to find a collection of disjoint sets of inputs and corresponding outputs for the given permutation that sum to zero (i.e., satisfy the zero-sum property). Our choice is motivated by the fact that, to the best of our knowledge, it is not possible to turn such a distinguisher into an attack on the hash and/or compression function. For example, in the case of SHA-3/KECCAK [Nat15; BDP+11], while 24 rounds of KECCAK-f can be distinguished from a random permutation using a zero-sum partition [BCC11] (that is, full KECCAK-f), preimage/collision attacks on KECCAK can only be set up for up to 6 rounds of KECCAK-f [GLL+20]. Indeed, the authors of KECCAK-f deem a 12-round version of the primitive to provide ample security margin [BDP+18]. For this reason and as already done in similar work [GKR+21; GHR+23], we ignore zero-sum partitions for practical applications.</p>

    <p class="text-gray-300">In Table 8, we give the runtime of each part of the Monolith permutation for both a constant- and variable-time implementation.</p>

    <p class="text-gray-300">Table 8. Native performance of each different round function in Monolith. Implemented in Rust.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Operation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time <span class="math">(ns)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Const. Time <span class="math">(ns)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p = 2^{64} - 2^{32} + 1:</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Concrete</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bricks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bars</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">p = 2^{31} - 1:</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t = 24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Concrete</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bricks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Bars</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Arithmetization Details</h2>

      <h3 id="app-d.1" class="text-xl font-semibold mt-8">D.1 R1CS</h3>

    <p class="text-gray-300">It is possible, though more expensive, to implement Monolith in legacy proof systems that only support R1CS equations without any table lookups. In contrast to Reinforced Concrete, our design admits a reasonably small R1CS</p>

    <p class="text-gray-300">representation described in the following. First, we use t-1 constraints to generate equations for Bricks. For Bars, we decompose each element that goes into a Bar into bits thus using one constraint per Bar for the actual decomposition plus  <span class="math">\\log_2(p) \\cdot \\# \\text{Bar}</span>  constraints for ensuring that the bits are either 0 or 1. Then each output bit of Bar requires 3 multiplications (2 for AND and 1 for XOR) for the 8-bit S-box and 2 multiplications for the 7-bit one as used in Monolith-31. By combining the composition constraints with the following bricks layer we get 1028 constraints for Monolith-64 and 944 constraints for Monolith-31 per Bars. Finally, the Concrete layer can be included in the constraints of Bricks and Bars, resulting in a total for  <span class="math">R \\cdot (1027 + t)</span>  R1CS constraints for Monolith-64 and  <span class="math">R \\cdot (943 + t)</span>  constraints for Monolith-31, where R is the number of rounds.</p>

    <p class="text-gray-300">The Tip5 function applies four 64-bit S-boxes with lookups per round, so 32 8-bit lookups per round. It also uses 12 degree-7 power functions per round. We allocate variables for the outputs of the power functions in addition to 64 lookup variables per round.</p>

    <p class="text-gray-300">Similarly, the Tip4' function also applies 32 8-bit lookups per round to the smaller state. However, it uses 8 degree-7 power functions per round, proportionally reducing the number of variables.</p>

    <p class="text-gray-300">The Poseidon2 function (as well as Poseidon which has the same number of rounds and the same arithmetization) with t=12 defined for  <span class="math">p_{Goldilocks}</span>  has 8 full and 22 partial rounds, thus 118 degree-7 functions in total. We allocate variables for all outputs of the S-boxes, and link the others via linear equations.</p>

    <p class="text-gray-300">Regarding Rescue-Prime, an instance with t=12 defined for  <span class="math">p_{\\text{Goldilocks}}</span>  requires 8 rounds which each consist of two subrounds which alternate between nonlinear layers featuring the  <span class="math">x^d</span>  and  <span class="math">x^{1/d}</span>  power maps. Due to this construction one can find degree-7 constraints spanning a whole round of rescue, leading to 96 degree-7 constraints in total.</p>

      <h3 id="app-d.3" class="text-xl font-semibold mt-8">D.3 Multiround Constraints for Monolith</h3>

    <p class="text-gray-300">We consider  <span class="math">p = p_{\\texttt{Goldilocks}}</span>  and t = 12. When implementing both Monolith and Tip5 in a single gate, we can immediately observe various similarities. For example, considering 8-bit lookups, the number of lookups is almost the same, with Tip5 using slightly fewer ones due to its lower number of rounds (note that both permutations use four lookup words per round). Moreover, the number of necessary columns is similar in a round-based approach.</p>

    <p class="text-gray-300">The major advantage of Monolith becomes apparent after considering the degree of the constraints. Indeed, while Tip5 uses a maximum degree of 7 (which is the smallest integer d such that  <span class="math">\\gcd(p_{\\texttt{Goldilocks}}-1,d)=1)</span> , Monolith uses a maximum degree of only 2. Not only does this lead to more efficient constraints, but it allows for different tradeoffs. For example, consider  <span class="math">p=p_{\\texttt{Goldilocks}}, t=12</span>  and a state after the Concrete layer defined by 12 variables  <span class="math">w_1^{(1)},\\ldots w_{12}^{(1)}</span> . After the subsequent application of Bars, we add 4 new variables  <span class="math">w_1^{(2)},\\ldots,w_4^{(2)}</span>  for the state</p>

    <p class="text-gray-300">elements modified by the lookup table. We now apply Bricks and then Concrete to the state. Note that describing the state in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}</span>  after these transformations results in degree-2 constraints (ignoring the table lookups), since only one Bricks layer has been applied. Hence, we may now choose to only add 4 new variables  <span class="math">w_1^{(3)}, \\ldots, w_4^{(3)}</span>  after the application of the last Concrete layer at the positions of the table lookups. After the next Bars layer, the state is defined by 8 polynomial equations in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}</span>  of degree 2 and by the 4 new variables  <span class="math">w_1^{(4)}, \\ldots, w_4^{(4)}</span>  resulting from the table lookups. After applying the next Bricks and Concrete layers, we arrive at a state defined by 12 polynomial constraints in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}, w_1^{(4)}, \\ldots, w_4^{(4)}</span>  of degree 4. A graphical overview of this approach is shown in Fig. 5.</p>

    <p class="text-gray-300">    <img src="_page_46_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5. Variables (or trace elements) when using Monolith with degree-4 constraints. Newly added variables are emphasized in <strong>bold</strong> and the degree indicates the maximum degree of the polynomial equations describing the corresponding state in the given variables.</p>

    <p class="text-gray-300">As a result, with degree-4 constraints we can save t-u trace elements in each pair of rounds, where u is the number of Bar applications in the Bars layers. This allows us to achieve a slimmer row with even fewer columns. We point out that this advantage of Monolith's low degree also applies in a similar fashion when comparing to other hash functions which use  <span class="math">x^d</span> , such as Poseidon, Poseidon2, Rescue, Griffin, Anemoi, and many more.</p>

    </section>
`;
---

<BaseLayout title="Monolith: Circuit-Friendly Hash Functions with New Nonlinear... (2023/1025)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1025
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Hash Functions in Zero-Knowledge Frameworks</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Our Contributions</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Fast and Circuit-Friendly Functions over Fp</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Chunks and Buckets</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The Kintsugi Bar</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Well-Definition and Bijectivity</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Considerations about the Kintsugi Strategy</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Statistical and Algebraic Properties</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Feistel Type-3 Layer and the Wide Trail Strategy</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Specification of Monolith</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Modes of Operation</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Permutation Structure</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Bars</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Bricks</a></li>
            <li><a href="#sec-4.5" class="hover:text-white">Concrete</a></li>
            <li><a href="#sec-4.6" class="hover:text-white">Number of Rounds and Security Claims</a></li>
            <li><a href="#sec-4.7" class="hover:text-white">Security Analysis</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Security Analysis: Statistical Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">(Truncated) Differential and Linear Cryptanalysis</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Rebound Attacks</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Other Statistical Attacks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Security Analysis: Algebraic Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Degree of the Bars Polynomials</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Security against Algebraic Attacks via Bars</a></li>
            <li><a href="#sec-6.3" class="hover:text-white">Solving the Multivariate CICO Problem with Gr&ouml;bner Bases</a></li>
            <li><a href="#sec-6.4" class="hover:text-white">Algebraic Attacks over \mathbb&#123;F&#125;_2</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-7" class="hover:text-white">Performance Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-7.1" class="hover:text-white">Native Performance</a></li>
            <li><a href="#sec-7.2" class="hover:text-white">Performance in Proof Systems</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Fast Reduction for Special Primes</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">Fast Reduction for Primes of the Form &#981; 2 &minus; &#981; + 1</a></li>
            <li><a href="#app-a.2" class="hover:text-white">Fast Reduction for Primes of the Form 2 &rho; &minus; 1</a></li>
            <li><a href="#app-a.3" class="hover:text-white">Generation of Round Constants</a></li>
          </ol>
        </li>
        <li>
          <a href="#app-b" class="hover:text-white">Security Analysis - Additional Material</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-b.1" class="hover:text-white">Rebound Collision Attack on the 3-Round (Weakened) Monolith</a></li>
            <li><a href="#app-b.2" class="hover:text-white">Degree and Density: Practical Results</a></li>
            <li><a href="#app-b.3" class="hover:text-white">Details about GB Attacks</a></li>
            <li><a href="#app-b.4" class="hover:text-white">Non-Applicable Attacks</a></li>
          </ol>
        </li>
        <li><a href="#app-c" class="hover:text-white">Benchmarks of Different Round Functions</a></li>
        <li>
          <a href="#app-d" class="hover:text-white">Arithmetization Details</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-d.1" class="hover:text-white">R1CS</a></li>
            <li><a href="#app-d.2" class="hover:text-white">Circuits for Other Hash Functions</a></li>
            <li><a href="#app-d.3" class="hover:text-white">Multiround Constraints for Monolith</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="monolith-circuit-friendly-hash-functions-with-new-nonlinear-2023" />
  </article>
</BaseLayout>
