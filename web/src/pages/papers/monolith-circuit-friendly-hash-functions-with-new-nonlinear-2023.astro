---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1025';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Monolith: Circuit-Friendly Hash Functions with New Nonlinear Layers for Fast and Constant-Time Implementations';
const AUTHORS_HTML = 'Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, Roman Walch';

const CONTENT = `    <p class="text-gray-300">Lorenzo Grassi2,<sup>5</sup> , Dmitry Khovratovich3,<sup>7</sup> , Reinhard Lüftenegger<sup>1</sup> , Christian Rechberger<sup>1</sup> , Markus Schofnegger<sup>4</sup> , and Roman Walch1,<sup>6</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Graz University of Technology (Austria) Ponos Technology (Switzerland) Ethereum Foundation (Luxembourg) Horizen Labs (United States) Ruhr University Bochum (Germany) TACEO (Austria) ABDK Consulting (Estonia)</p>
    </blockquote>

    <p class="text-gray-300">Abstract. Hash functions are a crucial component in incrementally verifiable computation (IVC) protocols and applications. Among those, recursive SNARKs and folding schemes require hash functions to be both fast in native CPU computations and compact in algebraic descriptions (constraints). However, neither SHA-2/3 nor newer algebraic constructions, such as Poseidon, achieve both requirements.</p>

    <p class="text-gray-300">In this work we overcome this problem in several steps. First, for certain prime field domains we propose a new design strategy called Kintsugi, which explains how to construct nonlinear layers of high algebraic degree which allow fast native implementations and at the same time also an efficient circuit description for zero-knowledge applications. Then we suggest another layer, based on the Feistel Type-3 scheme, and prove wide trail bounds for its combination with an MDS matrix.</p>

    <p class="text-gray-300">We propose a new permutation design named Monolith to be used as a sponge or compression function. It is the first arithmetization-oriented function with a native performance comparable to SHA3-256. At the same time, it outperforms Poseidon in a circuit using the Merkle tree prover in the Plonky2 framework. Contrary to previously proposed designs, Monolith also allows for efficient constant-time native implementations which mitigates the risk of side-channel attacks.</p>

    <p class="text-gray-300">Zero-knowledge use cases and particularly the area of computational integrity combined with zero knowledge have seen a rise in popularity in the last couple of years. Many new protocols <a href="#page-34-0">\\[GWC19;</a> <a href="#page-37-0">ZGK+22;</a> <a href="#page-35-0">KST22;</a> [BC23\\]](#page-31-0) and low-level primitives <a href="#page-30-0">\\[AGR+16;</a> <a href="#page-30-1">AAE+20;</a> [GKR+21\\]](#page-33-0) have been designed and published <span id="page-1-1"></span>recently, in an attempt to increase the performance in this setting. The emergence of folding techniques and recursive SNARKs (incrementally verifiable computation, or IVC [\\[Val08\\]](#page-37-1)) make it possible to efficiently prove the integrity of complex computations. Proofs covering up to 2 <sup>27</sup> operations are known<a href="#page-1-0">1</a> whereas SNARK-based verifiable delay functions (VDFs) might require proving up to 2 40 operations [\\[KMT22\\]](#page-35-1). A single IVC operation is typically a compact arithmetic computation (polynomial) in a certain prime field or an assertion to some lowdegree polynomial predicate. With VC programs (also called circuits) being that large and containing cryptographic protocols, more and more programs contain hash functions as subroutines. Hash functions and their underlying permutations are used not only for data integrity checks, but also to instantiate commitment schemes, authenticated encryption <a href="#page-36-0">\\[PSS19;</a> [CFG+22\\]](#page-32-0), non-interactive proofs based on the Fiat–Shamir transform, and many other techniques.</p>

    <p class="text-gray-300">Hash Functions in IVC Applications. For typical applications of hash functions (e.g., integrity checks) standard choices like SHA-2 or SHA-3 are usually not the bottleneck. However, this is different in IVC applications mentioned above. For hashing and membership proofs in ZK, e.g. in folding schemes <a href="#page-35-0">\\[KST22;</a> <a href="#page-35-2">KS23;</a> [BC23\\]](#page-31-0) or private mixers [\\[PSS19\\]](#page-36-0), the size of hash functions as an arithmetic circuit over a prime field is more important than the "native" software performance (e.g., on an x86 architecture). Several new hash functions have tried to bridge this gap <a href="#page-30-0">\\[AGR+16;</a> <a href="#page-30-1">AAE+20;</a> <a href="#page-33-1">GHR+23;</a> <a href="#page-33-0">GKR+21;</a> <a href="#page-37-2">SAD20;</a> [BBC+23\\]](#page-31-1).</p>

    <p class="text-gray-300">Hash functions may also be used as a commitment tool in IVC frameworks where the underlying commitment scheme is not homomorphic (STARKs being a notable example [\\[BBH+19\\]](#page-31-2)). With a prover and a verifier engaging in commitopen protocols over prime fields, this setting requires to efficiently construct a Merkle tree in a prime field domain over large amounts of data. So far, the computations were performed natively on x86 hardware and not (yet) inside a circuit. Here, classical hash functions have been used until recently.</p>

    <p class="text-gray-300">Both cases appear in recursive schemes, in particular in recursive STARKs [\\[COS20\\]](#page-32-1), which are an attractive IVC concept due to relatively little overhead and the possibility of parallelism for large or long computations. These schemes are used in an increasing number of applications, including zero-knowledge virtual machines <a href="#page-33-2">\\[Fou22;</a> <a href="#page-36-1">Pol22b;</a> [Zha22\\]](#page-37-3) and decentralized signature aggregation [\\[But22\\]](#page-32-2) protocols as notable examples. In recursive STARKs the computation and its proof are broken into chunks C1, C2, . . . , C<sup>k</sup> and subproofs π1, . . . , π<sup>k</sup> such that the proof π<sup>i</sup> certifies that chunks from C<sup>1</sup> to C<sup>i</sup> are computed correctly by utilizing the previous proof πi−<sup>1</sup> and a proof for C<sup>i</sup> . In order to create π<sup>i</sup> , the prover computes a Merkle tree over the witness data and then proves some tree openings in a circuit. Thus, the same hash function is used in the circuit and in the native computation. In this scenario, up to 90% of a prover's computation may be spent on the hash function call and proofs <a href="#page-32-1">\\[COS20;</a> [RIS23a\\]](#page-36-2), and a construction of a function that excels in both areas is a crucial open problem.</p>

    <p class="text-gray-300"><span id="page-1-0"></span><sup>1</sup> <https://research.protocol.ai/sites/snarks/></p>

    <p class="text-gray-300"><span id="page-2-1"></span>Lookups and Small Domains. Two recent developments in IVC are relevant to our design. The first one is the lookup technique. Starting with Plookup, the IVC operations include not only arithmetic expressions but also lookup statements of the form a ∈ T, where T is a table available to the verifier <a href="#page-34-1">\\[GW20;</a> <a href="#page-36-3">PH23;</a> [STW23\\]](#page-37-4). For some polynomial commitment schemes (but not for FRI), the table may be preprocessed <a href="#page-37-5">\\[ZBK+22;</a> <a href="#page-37-0">ZGK+22;</a> [EFG22\\]](#page-33-3) so that its size does not contribute to the online prover cost. The lookup technique not only reduces the cost of traditional hash functions in circuits but also allows for cheap transformations of high algebraic degree <a href="#page-33-4">\\[GKL+22;</a> [SLS+23\\]](#page-37-6).<a href="#page-2-0">2</a></p>

    <p class="text-gray-300">Another improvement is purely technical but nevertheless vital for the performance. It is the use of small prime fields of ≤ 64 bits of special form like 2 <sup>k</sup>−1 or 2 <sup>m</sup> −2 <sup>k</sup> + 1 <a href="#page-36-4">\\[Pol22a;</a> <a href="#page-36-5">Pol23;</a> [RIS23b\\]](#page-37-7), which allow for more efficient arithmetic operations. STARK proofs [\\[BBH+19\\]](#page-31-2) can use them since they do not require a group where the discrete logarithm problem is assumed to be hard. The performance growth is significant: switching to an efficient 64-bit field improves the performance by a factor of up to 10 for the Poseidon hash function [\\[GKS23\\]](#page-34-2). Moreover, the modular reduction for these fields can often be implemented with mere additions and bit shifts, which are vectorizable on modern CPU architectures and faster than in larger and more generic prime fields. Small fields for IVC applications are also prominent in other recent works <a href="#page-34-3">\\[HLN23;</a> [Hab23\\]](#page-34-4).</p>

    <p class="text-gray-300">We approach the problem of creating a hash function that is simultaneously fast and circuit-friendly in several steps. First we summarize the technical ideas of the new design, and then we introduce the new hash function Monolith.</p>

    <p class="text-gray-300">Efficient Nonlinearity and Compact Circuits over Prime Fields. Our first main contribution is a generic design of components over certain prime fields, which can be implemented with just a few (and possibly vector) constanttime instructions on the x86 architecture, and can be written as a small circuit. This strategy, called Kintsugi, significantly improves upon the ideas behind Reinforced Concrete [\\[GKL+22\\]](#page-33-4) and Tip5 [\\[SLS+23\\]](#page-37-6), yielding faster and constant-time-friendly S-boxes. These new S-boxes are defined by first splitting a field element into smaller bit arrays. Then, constant-time-friendly S-boxes using Daemen's χ function and similar ones [\\[Dae95\\]](#page-32-3) are applied to these arrays, which can be parallelized with fast vector instructions and implemented as lookup tables in circuits. Finally, the outputs are assembled back to a field element with no overflow or collision, which is asserted in circuits with minimal overhead.</p>

    <p class="text-gray-300">Low-Degree Components with Provable Differential Bounds. Our second contribution is a concept of using a Feistel Type-3 [\\[ZMI89\\]](#page-37-8) function together with an MDS layer. It can be seen as a replacement for the power function x d</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>2</sup> <https://zcash.github.io/halo2/design/gadgets/sha256/table16.html></p>

    <p class="text-gray-300"><span id="page-3-1"></span>from Poseidon [GKR+21] and similar constructions. The advantage is that we can use faster squaring operations (i.e.,  <span class="math">x^2</span> ) instead of more expensive (as d must be coprime with p-1) power functions over  <span class="math">\\mathbb{F}_p</span> , and simultaneously obtain low-degree predicates in circuits.</p>

    <p class="text-gray-300">Notably,  <span class="math">x \\mapsto x^2</span>  is not invertible over  <span class="math">\\mathbb{F}_p</span> , and hence we cannot use this component to build an invertible SPN. However, we can exploit a Feistel scheme to make the entire construction invertible. A discussion regarding the risks of using non-bijective components for designing symmetric primitives in which the internal state is not obfuscated by a secret can be found in [Gra23].</p>

    <p class="text-gray-300">Although the Feistel layer alone is known to have weak diffusion, we show that together with an MDS matrix it comes close to a regular SPN. To the best of our knowledge, we are the first to prove the results on the differential properties of the component using a strategy analogous to the wide trail design [DR02]. In particular, we prove lower bounds on the number of active nonlinear functions in trails. Similar to extended generalized Feistel networks introduced in [BMT13], we believe that this result and its possible extension to Feistel structures of other types may be useful in the design of any symmetric primitive, including those for more classical settings (as already happened for the Lilliput cipher [BFM+16]).</p>

    <p class="text-gray-300">Monolith: Fast, Constant-Time, Circuit-Friendly. All of these techniques lead us to the design of Monolith, a family of permutations which are efficient in native software, in hardware, and inside of circuits. This permutation can then be turned into a hash function and other permutation-based schemes.<sup>3</sup></p>

    <p class="text-gray-300">Construction of Monolith. Our scheme has a few rounds using three different components. We adopt the naming convention of Reinforced Concrete.</p>

    <p class="text-gray-300">The first component is Bricks (Section 4.4), which is instantiated with a Feistel Type-3 construction with square mappings. The second component is Concrete (Section 4.5), which is the multiplication with a circulant MDS matrix. Together with Bricks it provides the diffusion necessary to protect against statistical attacks. The third and last component is Bars (Section 4.3), which is based on the Kintsugi outlined above. We prove that each such Bar operation has a high degree and provides high security against algebraic attacks. The Bar function is applied only to a few field elements in each round.</p>

    <p class="text-gray-300">The combination of these three components provides security against statistical and algebraic attacks while allowing for an efficient implementation. Our initial analysis has found a 3-round attack on a weakened version, and also suggests that all potential attacks should stop at 4 rounds. Since improvements are expected, we set the number of rounds uniformly to 6.</p>

    <p class="text-gray-300">Performance. We give an extensive comparison between our new proposal and its competitors in Section 7. Our benchmarks confirm that the native performance of Monolith is comparable to SHA-3, which makes it the first circuit-friendly</p>

    <p class="text-gray-300"><span id="page-3-0"></span><sup>&</sup>lt;sup>3</sup> A <em>monolithic</em> building is a seamless structure where components are intimately fused in order to provide the most secure and robust construction.</p>

    <p class="text-gray-300"><span id="page-4-2"></span><img src="_page_4_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-4-0"></span>Fig. 1. Comparison of hash functions in various settings (logarithmic scale). The native benchmarks ("Time", "Const Time") are from Table <a href="#page-26-0">3,</a> the numbers for Monolith-64, Poseidon, and Poseidon2 are taken for the 64-bit prime field and a state size of t = 12. Proof (IVC) timings are benchmarks for a proof of preimage knowledge (Table <a href="#page-29-0">5\\)</a>. Numbers for SHA3-256 and SHA-256 are extrapolated from a circom implementation using R1CS [\\[Bal23\\]](#page-31-3).</p>

    <p class="text-gray-300">compression function achieving this goal. At the same time, Monolith is efficient within IVC systems. In contrast to Reinforced Concrete, Monolith also allows for a constant-time implementation without significant performance loss.</p>

    <p class="text-gray-300">A performance overview is given in Fig. <a href="#page-4-0">1.</a> We test the IVC performance on Plonky2 [\\[Pol22a\\]](#page-36-4), a popular choice for FRI-based proofs. Compared to Tip5, Monolith is around twice as fast and gives the user more freedom regarding the choice of the prime number (including the recent 31-bit prime used in [\\[RIS23b\\]](#page-37-7) due to advantageous implementation characteristics). Moreover, compared to the widely used Poseidon permutation, Monolith shows a native performance improvement by a factor of around 15. Finally, Monolith allows for an efficient circuit implementation, since it can be represented by a low number of degree-2 constraints, leading to a faster performance compared to Poseidon when implemented in Plonky2 (see Table <a href="#page-29-0">5\\)</a>.</p>

    <p class="text-gray-300">When working over Fp, informally, we cannot just split a field element into smaller chunks, process them independently, and then reassemble. This is due to the fact that the field size is a prime and thus cannot be represented as a product of smaller domains.</p>

    <p class="text-gray-300">To solve this problem, we present a generic strategy for specific prime numbers. Elements of it can be found in earlier works on Reinforced Concrete [\\[GKL+22\\]](#page-33-4) and Tip5 [\\[SLS+23\\]](#page-37-6). The main principles are as follows.</p>

    <p class="text-gray-300"><span id="page-5-2"></span><img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-5-1"></span>Fig. 2. The Kintsugi strategy.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Split the integer form of a field element into chunks according to carefully chosen boundaries aligned with the sum of the powers of two such that the resulting chunks fit a lookup table in a ZK circuit.</li>

      <li>2. Identify the combination of chunk values that never appear due to the fact that p is not a power of two.</li>

      <li>3. Design intra-chunk transformations  <span class="math">S_i</span>  such that</li>

      <li>impossible chunk combinations never appear (e.g. by making some chunk values fixed points), and</li>

      <li>they can be implemented in constant time, for example with an AndRX (AND-rotation-XOR) transformation [AJN14].</li>

      <li>4. Combine the chunks back into a large element, after a possible shuffle (only operations guaranteeing that the output element is in the field are possible).</li>

    </ul>

    <p class="text-gray-300">We call this strategy Kintsugi.<sup>4</sup> An illustration is shown in Fig. 2.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.1 Chunks and Buckets</h4>

    <p class="text-gray-300">In order to formally define the Kintsugi strategy, we need to introduce some notations. For a prime  <span class="math">p \\geq 5</span> , we define p' as</p>

    <div class="my-4 text-center"><span class="math-block">p&#x27; = \\begin{cases} p - 1 &amp; \\text{if } p \\equiv 1 \\bmod 4, \\\\ p &amp; \\text{otherwise.} \\end{cases}</span></div>

    <p class="text-gray-300">Consider the binary representation of p' of length  <span class="math">\\rho := \\lceil \\log_2(p&#x27;) \\rceil</span> . It has the form (most significant bit coming first)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$p' = 1 \\dots 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 \\dots 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 \\dots 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{cases} 0 \\dots 0 \\text{ or } \\\\ 1 \\dots 1, \\end{cases}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\cdot \\mid \\mid \\cdot</span>  denotes concatenation, that is, it consists of alternating sequences of ones and zeroes. The first sequence is always a 1-sequence, while the last one can be either a 0- or a 1-sequence.</p>

    <p class="text-gray-300"><span id="page-5-0"></span><sup>&</sup>lt;sup>4</sup> Kintsugi is the Japanese art of repairing broken pottery by mending the areas of breakage with lacquer dusted or mixed with e.g. powdered gold. Here, we break the state and we recombine it after applying a particular function to each small chunk.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Given p' as before, we denote its 1-/0-sequences as chunks (respectively, 1-chunks and 0-chunks).</p>

    <p class="text-gray-300">Given the lengths of 1-chunks  <span class="math">\\nu_1, \\nu_2, \\dots, \\nu_{\\xi}</span>  and the lengths of 0-chunks  <span class="math">\\mu_1, \\mu_2, \\dots, \\mu_{\\xi}</span>  (both from left to right), and  <span class="math">\\omega_i = \\sum_{j \\geq i} (\\nu_{i+1} + \\mu_i)</span> , we obtain</p>

    <p class="text-gray-300"><span id="page-6-0"></span> <span class="math-block">p&#x27; = \\sum_{i=1}^{\\xi} 2^{\\omega_i} \\cdot (2^{\\nu_i} - 1). \\tag{1}</span></p>

    <p class="text-gray-300">For efficiency, we may split each chunk into sub-chunks, called <em>buckets</em>. Each S-box will then work independently on each bucket. To obtain simple conditions for invertibility, we require the buckets to be aligned with chunk boundaries, i.e., we require that <em>buckets do not overlap chunks</em>. We formalize this in the following.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> Let p be a prime with 1- and 0-chunks defined by Eq. (1) and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{T} = \\{\\tau_1, \\dots, \\tau_s\\}</span></div>

    <p class="text-gray-300">be a bucket decomposition, i.e., some positive integers  <span class="math">\\tau_1, \\ldots, \\tau_s</span>  such that  <span class="math">\\sum_{i=1}^s \\tau_i = \\rho = \\lceil \\log_2 p&#x27; \\rceil</span> . We say that the bucket decomposition T is aligned with p' if for every  <span class="math">i \\in \\{1, 2, \\ldots, \\xi\\}</span>  there exist  <span class="math">k_i, l_i</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\nu_i = \\sum_{j=k_i}^{j &lt; l_i} \\tau_j \\quad and \\quad \\mu_i = \\sum_{j=l_i}^{j &lt; k_{i+1}} \\tau_j.</span></div>

    <p class="text-gray-300">This means that for every i the i-th 1-chunk covers buckets from  <span class="math">k_i</span>  to  <span class="math">l_i</span>  (exclusive). Such buckets are called 1-buckets. Further, the i-th 0-chunk covers buckets from  <span class="math">l_i</span>  to  <span class="math">k_{i+1}</span>  (exclusive). These are called 0-buckets. This decomposition is illustrated (with small buckets) in Figure 3.</p>

    <p class="text-gray-300"><img src="_page_6_Figure_9.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-6-1"></span><strong>Fig. 3.</strong> Chunk and an aligned bucket decomposition of the number 52860. Here  <span class="math">\\xi = 3</span>  and s = 7.</p>

    <p class="text-gray-300">Finally, we impose that the buckets are not too small, in order to avoid potential security issues. Indeed, the number of fixed points and/or invariant subspaces for Kintsugi becomes too large when the buckets are too small.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> The bucket decomposition is efficient if  <span class="math">\\tau_i \\geq 3</span>  for each  <span class="math">i \\geq 1</span> .</p>

    <p class="text-gray-300">This condition puts a constraint on p. However, we believe it is satisfied by the majority of the primes used in cryptography, including the ones used in our work. We highlight that we worked with p' directly instead of p, since this just given efficiency condition is never satisfied by  <span class="math">p \\ge 5</span>  if  <span class="math">p = 1 \\mod 4</span> .</p>

    <h2 id="sec-7" class="text-2xl font-bold">2.2 The Kintsugi Bar</h2>

    <p class="text-gray-300">The nonlinear component Bar, based on Kintsugi, is defined as follows. Let  <span class="math">\\tau_1, \\tau_2, \\ldots, \\tau_s</span>  be an efficient and aligned bucket decomposition for p as in Eq. (1). Then, for  <span class="math">\\mathcal{C}</span> ,  <span class="math">\\mathcal{S}</span> , and  <span class="math">\\mathcal{D}</span>  described in the following, the component operates as</p>

    <p class="text-gray-300"><span id="page-7-0"></span> <span class="math-block">x \\mapsto \\mathcal{C} \\circ \\mathcal{S} \\circ \\mathcal{D}(x).</span>  (2)</p>

    <p class="text-gray-300"><strong>Decomposition</strong>  <span class="math">\\mathcal{D}</span> . The decomposition  <span class="math">\\mathcal{D}</span> , i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">x \\in \\mathbb{F}_p \\mapsto (x_1&#x27;, x_2&#x27;, \\dots, x_s&#x27;) \\in \\mathbb{Z}_{2^{\\tau_1}} \\times \\mathbb{Z}_{2^{\\tau_2}} \\times \\dots \\times \\mathbb{Z}_{2^{\\tau_s}},</span></div>

    <p class="text-gray-300">decomposes the original field element  <span class="math">x \\in \\mathbb{F}_p</span>  into s > 1 buckets  <span class="math">x&#x27;_1, \\dots, x&#x27;_s</span>  s.t.</p>

    <div class="my-4 text-center"><span class="math-block">x = \\sum_{i=1}^{s} 2^{\\rho_i} \\cdot x_i&#x27;</span></div>

    <p class="text-gray-300">over integers, where  <span class="math">\\rho_1 = 0</span>  and  <span class="math">\\rho_i = \\sum_{j&gt;i} \\tau_j</span> . As the bucket decomposition is aligned, we get that each bucket is either a 1- or 0-bucket.</p>

    <p class="text-gray-300"><strong>S-Boxes</strong>  <span class="math">\\mathcal{S}</span> . The operation  <span class="math">\\mathcal{S}</span>  applies s invertible S-boxes in parallel, i.e.,</p>

    <p class="text-gray-300"><span id="page-7-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$S(x'_1, x'_2, \\dots, x'_s) = S_1(x'_1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_2(x'_2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_s(x'_s),$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(3)</p>

    <p class="text-gray-300"><span id="page-7-1"></span>where  <span class="math">S_i: \\mathbb{Z}_{2^{\\tau_i}} \\to \\mathbb{Z}_{2^{\\tau_i}}</span>  and we require that</p>

    <p class="text-gray-300"><span class="math-block">\\mathbf{1}^{\\tau_i}</span>  is a fixed point if  <span class="math">\\mathcal{S}_i</span>  operates on a 1-bucket of  <span class="math">p&#x27;</span> , and  <span class="math">\\mathbf{0}^{\\tau_i}</span>  is a fixed point if  <span class="math">\\mathcal{S}_i</span>  operates on a 0-bucket of  <span class="math">p&#x27;</span> . (4)</p>

    <p class="text-gray-300">Hence, a z-chunk of p' must be mapped via  <span class="math">S_i</span>  into a z-chunk, where  <span class="math">z \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300"><strong>Composition</strong>  <span class="math">\\mathcal{C}</span> . The final operation  <span class="math">\\mathcal{C}</span>  is the inverse of the decomposition. Given  <span class="math">(x&#x27;_1, x&#x27;_2, \\ldots, x&#x27;_s) \\in \\mathbb{Z}_{2^{\\tau_1}} \\times \\mathbb{Z}_{2^{\\tau_2}} \\times \\ldots \\times \\mathbb{Z}_{2^{\\tau_s}}</span>  as before, it simply computes</p>

    <div class="my-4 text-center"><span class="math-block">y = \\sum_{i=1}^{s} 2^{\\rho_i} \\cdot x_i&#x27; \\bmod p \\in \\mathbb{F}_p,</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho_1 = 0</span>  and  <span class="math">\\rho_i = \\sum_{j&gt;i} \\tau_j</span> .</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.3 Well-Definition and Bijectivity</h2>

    <p class="text-gray-300">Here we prove that our  <span class="math">\\mathcal{C} \\circ \\mathcal{S} \\circ \\mathcal{D}(\\cdot)</span>  defined in Eq. (2) and in particular its  <span class="math">\\mathcal{S}</span>  components are invertible and well-defined.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let p be a prime and  <span class="math">\\{\\tau_i\\}</span>  the bucket decomposition aligned with p'. Then Kintsugi (Eq. (2)) with the S-boxes satisfying Eq. (4) is bijective over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We consider the natural extension of the transformation  <span class="math">C \\circ S \\circ D(\\cdot)</span>  to the domain  <span class="math">\\mathbb{Z}_{2^{\\rho}}</span>  and denote it by  <span class="math">\\mathcal{T}</span> . Then we proceed in two steps. First we prove that  <span class="math">\\mathcal{T}</span>  is bijective over  <span class="math">\\mathbb{Z}_{2^{\\rho}}</span> . Then we prove that for any x < p we have  <span class="math">\\mathcal{T}(x) &lt; p</span> . These two facts imply the result.</p>

    <p class="text-gray-300">Transformation  <span class="math">\\mathcal{T}</span> . We define  <span class="math">\\mathcal{T}: \\mathbb{Z}_{2^p} \\to \\mathbb{Z}_{2^p}</span>  as  <span class="math">\\mathcal{T}:=\\mathcal{C}&#x27; \\circ \\mathcal{S} \\circ \\mathcal{D}&#x27;(\\cdot)</span> , where  <span class="math">\\mathcal{D}&#x27;</span>  is a generalization of  <span class="math">\\mathcal{D}</span>  that takes inputs from  <span class="math">\\mathbb{Z}_{2^p}</span>  instead of  <span class="math">\\mathbb{Z}_p</span> , i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">x \\in \\mathbb{Z}_{2^{\\rho}} \\mapsto (x&#x27;_1, x&#x27;_2, \\dots, x&#x27;_s) \\in \\mathbb{Z}_{2^{\\tau_1}} \\times \\mathbb{Z}_{2^{\\tau_2}} \\times \\dots \\times \\mathbb{Z}_{2^{\\tau_s}},</span></div>

    <p class="text-gray-300">where  <span class="math">x = \\sum_{i=1}^{s} 2^{\\rho_i} \\cdot x_i&#x27;</span>  as before. Further,  <span class="math">\\mathcal{S}</span>  is defined as before and  <span class="math">\\mathcal{C}&#x27;</span>  is the inverse of  <span class="math">\\mathcal{D}&#x27;</span>  (basically, it corresponds to  <span class="math">\\mathcal{C}</span>  without the modular reduction).</p>

    <p class="text-gray-300">Bijectivity of  <span class="math">\\mathcal{T}</span> . This follows from the fact that  <span class="math">\\mathcal{D}&#x27;</span> ,  <span class="math">\\mathcal{S}</span> , and  <span class="math">\\mathcal{C}&#x27;</span>  are bijective.</p>

    <p class="text-gray-300">Finally, we have to prove that  <span class="math">\\forall x \\in \\{0, \\dots, p-1\\} : \\mathcal{T}(x) \\in \\{0, \\dots, p-1\\}</span> . Let us start by analyzing the case x = p-1. If p-1 = p' (i.e.,  <span class="math">p \\neq 1 \\mod 4</span> ), then all S-boxes act as identity functions (due to Eq. (4)), and thus  <span class="math">\\mathcal{T}(x) = x &lt; p</span> . Instead, if  <span class="math">x = p-1 \\neq p&#x27;</span> , then  <span class="math">\\mathcal{D}(x)</span>  differs from  <span class="math">\\mathcal{D}(p&#x27;)</span>  in the first bucket: the former ends with 10 and the latter with 11. As  <span class="math">2^{\\tau_s} - 1</span>  is a fixed point of the S-box  <span class="math">\\mathcal{S}_s</span> , we get that  <span class="math">\\mathcal{S}_s(x_s&#x27;) &lt; 2^{\\tau_s} - 1 = z_s</span>  and so  <span class="math">\\mathcal{T}(x) &lt; p&#x27; \\leq p</span> .</p>

    <p class="text-gray-300">Next, let us consider the case x . Consider the binary form of <math>x, and let b be the most significant bit in which it differs from p'. Clearly, b is in a 1-bucket of p' with some index i. Note that for each j < i all S-boxes  <span class="math">S_j</span>  act as identity functions, that is,  <span class="math">S_i(x_i) = S(z_i) = z_i</span> . For  <span class="math">x_i&#x27; &lt; 2^{\\tau_i} - 1 = z_i</span> , we have  <span class="math">S_i(x_i&#x27;) &lt; 2^{\\tau_i} - 1 = z_i</span>  as  <span class="math">2^{\\tau_i} - 1</span>  is a fixed point of the S-box  <span class="math">S_i</span> . This implies that if x , then <math>T(x) .</p>

    <p class="text-gray-300">The two previous facts together with  <span class="math">\\mathcal{T}</span>  being bijective imply that  <span class="math">\\mathcal{T}(x) &gt; p-1</span>  for each x > p-1. It follows that  <span class="math">\\mathcal{C} \\circ \\mathcal{S} \\circ \\mathcal{D}(x) \\in \\mathbb{F}_p</span>  for each  <span class="math">x \\in \\mathbb{F}_p</span> .</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.4 Considerations about the Kintsugi Strategy</h2>

    <p class="text-gray-300">Due to the isomorphism between  <span class="math">\\mathbb{F}_2^{\\tau_i}</span>  and  <span class="math">\\mathbb{F}_{2^{\\tau_i}}</span> , almost any invertible AndRX transformation works well for  <span class="math">\\mathcal{S}</span>  and can be implemented in constant time as its components are basic x86 operations. Here we give some examples for  <span class="math">p = 2^n - 1</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bit Shuffle. Clearly, both  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  are fixed points under the bit shuffling operation for any  <span class="math">\\tau</span> . Moreover, it is essentially for free in hardware.</li>

    </ul>

    <p class="text-gray-300"><span id="page-9-1"></span>- Efficient Linear Operations. Linear operations over  <span class="math">\\mathbb{F}_2^{\\tau}</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">x \\mapsto x \\oplus (x \\lll i) \\oplus (x \\lll j)</span></div>

    <p class="text-gray-300">with nonzero  <span class="math">i \\neq j</span> , and where  <span class="math">\\ll</span>  denotes the circular shift operation, are (i) invertible for odd  <span class="math">\\tau</span>  and (ii) result in  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  being fixed points.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient Nonlinear Operations. Nonlinear operations over  <span class="math">\\mathbb{F}_2^{\\tau}</span>  such as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">x \\mapsto x \\oplus (\\bar{x} \\lll 1) \\odot (x \\lll 2)</span></div>

    <p class="text-gray-300">for odd  <span class="math">\\tau</span> , where  <span class="math">\\bar{x} := x \\oplus \\mathbf{1}^{\\tau}</span> , are also possible. This corresponds to the  <span class="math">\\chi</span> -function [Dae95, Table A.1] already used in Keccak/SHA-3, which is known to be invertible for  <span class="math">\\gcd(\\tau, 2) = 1</span> . Moreover,  <span class="math">\\mathbf{1}^{\\tau}</span>  and  <span class="math">\\mathbf{0}^{\\tau}</span>  are fixed points.</p>

    <p class="text-gray-300">An additional bit rotation may be needed to reduce the number of fixed points.</p>

    <p class="text-gray-300">Bars in Kintsugi and Reinforced Concrete. There are various differences between the Kintsugi strategy just described and the Bars functions proposed in Reinforced Concrete (and later used in Tip5). In Reinforced Concrete an element of  <span class="math">\\mathbb{F}_p</span>  is represented as a vector from  <span class="math">\\mathbb{Z}_{p_1} \\times \\cdots \\times \\mathbb{Z}_{p_l}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We rely on the structure of the prime p. Thanks to its composition of a few powers of two, the decomposition now is simply a bit extraction rather than a chain of modular reductions, which is expensive both natively and inside the proof system. The bijectivity of Kintsugi is guaranteed under the minor and easily satisfied condition that some specific inputs are fixed points.</li>

      <li>The S-boxes of Reinforced Concrete or Tip5 do not have a simple representation and must be implemented as tables both for native and circuit computations. The Kintsugi strategy instantiates the S-boxes with AndRX transformations, which are fast and constant-time in native x86 implementations but can easily be transformed to table lookups for circuits.</li>

    </ul>

    <p class="text-gray-300">Side-Channel Leakage and Countermeasures. Lookup tables in symmetric primitives are a well-known source of side channel leakage. When confidential information is processed (e.g., committing to coin secrets with ZK hash functions in privacy-preserving payment systems), an adversary may recover a large portion of it from timing differences of lookups into memory or caches. These techniques are well-known since at least two decades in the context of encryption [Pag02; Ber05; OST06], and the high-level ideas have found first applications in zero-knowledge proof systems [TBP20]. The lookup-oriented designs Reinforced Concrete and Tip5 use specific tables for which a constant-time implementation with reasonable overhead is nontrivial. It is thus of utmost importance to have a design where lookups can be replaced with constant-time operations.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2.5 Statistical and Algebraic Properties</h2>

    <p class="text-gray-300">Here we prove a generic statement that links algebraic and statistical properties of mappings over  <span class="math">\\mathbb{F}_p</span> , which we will use in the security analysis of Monolith.</p>

    <p class="text-gray-300"><span id="page-10-2"></span><strong>Lemma 2.</strong> Let  <span class="math">p \\geq 3</span>  be a prime number, and let  <span class="math">\\mathcal{F}_{sq}</span>  denote the squaring function  <span class="math">x \\to x^2</span>  over  <span class="math">\\mathbb{F}_p</span> . Let  <span class="math">\\mathsf{F}_{sq}</span>  be any interpolant of  <span class="math">\\mathcal{F}_{sq}</span>  over  <span class="math">\\mathbb{F}_2^{\\lceil \\log_2 p \\rceil}</span> , i.e., for any a < p and its bit representation  <span class="math">\\mathsf{a}</span>  we have that  <span class="math">\\mathsf{F}_{sq}(\\mathsf{a})</span>  is the bit representation of  <span class="math">\\mathcal{F}_{sq}(\\mathsf{a})</span> . Then  <span class="math">\\mathsf{F}_{sq}</span>  has (multivariate) degree at least d, where d is the maximum positive integer such that  <span class="math">d &lt; \\log_2 \\sqrt{p}</span>  and  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd.<sup>5</sup></p>

    <p class="text-gray-300"><em>Proof.</em> We prove this result by contradiction. Suppose that the degree of  <span class="math">\\mathsf{F}_{sq}</span>  is smaller than d. Then the XOR sum of its outputs over any hypercube of dimension d is equal to zero [Lai94], including the hypercube</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{H} := \\{ \\mathsf{a}_0 = (0,0,\\dots,0), \\dots, \\mathsf{a}_{2^d-1} = (0,\\dots,0,\\underbrace{1,\\dots,1}_{d \\text{ ones}}) \\}.</span></div>

    <p class="text-gray-300">Note that  <span class="math">\\mathcal{F}(a_i) = i^2 &lt; p</span>  by the definition of d. Now consider  <span class="math">\\mathfrak{B} = \\{\\mathsf{a}_i \\in \\mathfrak{H} \\mid i &gt; 2^{d-0.5}\\}</span> , so that (i)  <span class="math">2^{2d} &gt; \\mathcal{F}(b \\in \\mathfrak{B}) &gt; 2^{2d-1}</span>  and (ii) the 2d-th least significant bit is set. By simple computation, the size of  <span class="math">\\mathfrak{B}</span>  is  <span class="math">2^d - \\lceil 2^{d-0.5} \\rceil</span> . Whenever this number is odd,  <span class="math">\\mathsf{F}</span>  does not XOR to 0 at the 2d-th least significant bit, which contradicts the previous fact. As a result, the squaring has at least degree d if  <span class="math">\\lfloor 2^{d-0.5} \\rfloor</span>  is odd and  <span class="math">d &lt; \\log_2 \\sqrt{p}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-10-1"></span><strong>Lemma 3 (Differential).</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself with a differential  <span class="math">\\Delta_I \\to \\Delta_O</span>  holding with probability  <span class="math">0 &lt; \\alpha &lt; 1</span> , i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p \\mid \\mathcal{F}(x + \\Delta_I) = \\mathcal{F}(x) + \\Delta_O\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p \\cdot \\alpha<span class="math"> . Then we have  </span>\\deg(\\mathcal{F}) > \\alpha \\cdot p<span class="math"> , where  </span>\\deg(\\mathcal{F})<span class="math">  is the degree of  </span>\\mathcal{F}<span class="math">  as a polynomial over  </span>\\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> By definition,  <span class="math">\\mathcal{F}(x + \\delta_{in}) = \\mathcal{F}(x) + \\delta_{out}</span>  has at least  <span class="math">\\alpha \\cdot p</span>  solutions  <span class="math">x_1, x_2, \\ldots, x_{\\alpha p}</span> . Therefore, the polynomial  <span class="math">\\mathcal{G}(x) := \\mathcal{F}(x + \\delta_{in}) - \\mathcal{F}(x) - \\delta_{out}</span>  is divisible by the polynomial  <span class="math">(x - x_1) \\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_{\\alpha \\cdot p})</span>  of degree  <span class="math">\\alpha \\cdot p</span> , and so it has a degree of at least  <span class="math">\\alpha \\cdot p</span> . As the degree of the polynomial  <span class="math">\\mathcal{G}</span>  is smaller than the degree of  <span class="math">\\mathcal{F}</span>  by 1, we obtain that  <span class="math">\\deg(\\mathcal{F}) &gt; \\alpha \\cdot p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 4 (Linear Approximation).</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself such that there exists a linear approximation (a,b) with probability  <span class="math">0 &lt; \\beta &lt; 1</span> , that is,  $\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{F}(x) = a \\cdot x + b\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p} = \\beta<span class="math"> . Then we have  </span>\\deg(\\mathcal{F}) \\geq \\beta \\cdot p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> By definition, the equation  <span class="math">\\mathcal{F}(x) = A \\cdot x + B</span>  has at least  <span class="math">\\beta \\cdot p</span>  solutions  <span class="math">x_1, x_2, \\ldots, x_{\\beta \\cdot p}</span> . Therefore, the polynomial  <span class="math">\\mathcal{G}(x) := \\mathcal{F}(x) - (a \\cdot x + b)</span>  is divisible by the polynomial  <span class="math">(x - x_1) \\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_{\\beta p})</span>  of degree  <span class="math">\\beta \\cdot p</span> . Similar to before, we conclude that F has degree at least equal to  <span class="math">\\beta \\cdot p</span> .</p>

    <p class="text-gray-300">Based on the previous result, we can immediately conclude the following.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Corollary 1.</strong> Let  <span class="math">\\mathcal{F}</span>  be a function that maps  <span class="math">\\mathbb{F}_p</span>  to itself with b < p fixed points, that is,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{x \\in \\mathbb{F}_p : F(x) = x\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= b<span class="math"> . It follows that  </span>\\deg(\\mathcal{F}) \\geq b$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-10-0"></span><sup>&</sup>lt;sup>5</sup> For example,  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd for  <span class="math">d \\in \\{2, 4, 5, 6, 7, 9, 10, 11, 12, 13, 15, 16, 21, \\dots \\}</span> .</p>

    <p class="text-gray-300">The Kintsugi Bar is nonlinear but we will see in Section <a href="#page-19-0">6.1</a> that its high algebraic degree comes at the cost of weak differential properties. Thus if being used in an SPN construction, it would make it vulnerable to statistical (e.g., differential) cryptanalysis. For this reason, we introduce another nonlinear component defined as a Feistel Type-3 network [\\[ZMI89\\]](#page-37-8) that complements Kintsugi Bars. By instantiating it via low-degree functions, it will allow us to provide strong argument for guaranteeing resistance against differential and statistical attacks in general. We follow the naming convention of Reinforced Concrete (the first lookup-based ZK-friendly hash function) where the nonlinear layer providing protection against statistical attacks is called Bricks, and use the same name for uniformity.</p>

    <p class="text-gray-300">Feistel Type-3. The Feistel Type-3 network is a member of a larger Feistel family [\\[HR10\\]](#page-34-6), which has been largely neglected in favour of SPN schemes in block cipher and hash function design, primarily for its complexity and worse diffusion properties. As already recalled in the introduction, a potential drawback of SPN schemes regards the fact that their invertibility depends on the fact that all their internal components are invertible as well. As it is well known, this is not the case of Feistel networks, which remain invertible independently of the details of their internal functions. For many prime order groups used in SNARKs, the smallest invertible power mapping is x 5 . As a result, we have found the Feistel Type-3 newtork instantiated with square maps x 7→ x 2 to be particularly attractive as it is cheaper in circuits and, most importantly, its blend with an MDS layer yields statistical properties similar to those in regular SPNs.</p>

    <p class="text-gray-300">With nonlinear F<sup>i</sup> , Bricks<sup>F</sup> for t elements x1, . . . , x<sup>t</sup> is defined as</p>

    <p class="text-gray-300"><span id="page-11-0"></span>Bricks<sup>F</sup> <span class="math-block">(x_1, ..., x_t) := (x_1, x_2 + \\mathcal{F}_1(x_1), x_3 + \\mathcal{F}_2(x_2), ..., x_t + \\mathcal{F}_{t-1}(x_{t-1})).</span>  (5)</p>

    <p class="text-gray-300">Diffusion Layer. While Bricks<sup>F</sup> alone does not provide fast diffusion, a combination with a matrix layer increases the diffusion properties <a href="#page-32-4">\\[BMT13;</a> [BFM+16\\]](#page-32-5). This approach is well-known in the SPN design as the wide trail strategy [\\[DR01\\]](#page-33-6), where a lower bound for the number of "active" nonlinear components in any differential trail is proven, leading to strong arguments against differential attacks.</p>

    <p class="text-gray-300">Here we follow this line of research, and for the first time we derive bounds for the SPN structure where the nonlinear layer is a Feistel Type-3 function. For this, we work with matrices of Maximum Distance Separable (MDS) Codes for maximizing the number of active Fp-words over two consecutive rounds.</p>

    <p class="text-gray-300">Our New Bound. Now we obtain our main result on the differential properties of the Feistel-Type3-MDS combination. Our new bound improves the ones recently proposed in [\\[Gra23\\]](#page-34-5) for an analogous (but different) scheme.</p>

    <p class="text-gray-300"><span id="page-11-1"></span>Proposition 1. Consider an R-round construction, where each round consists of the application of Bricks<sup>F</sup> over F t <sup>q</sup> as in Eq. <a href="#page-11-0">\\(5\\)</a> followed by the multiplication with a  <span class="math">t \\times t</span>  MDS matrix. The minimum number  <span class="math">\\hat{c}</span>  of active functions  <span class="math">\\mathcal{F}_i</span>  in any differential trail satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{c} \\geq (t-1) \\cdot \\left(\\frac{3R-2-(-2)^{1-R}}{9}\\right) \\geq (t-1) \\cdot \\left(\\frac{3R-2.5}{9}\\right) \\, .</span></div>

    <p class="text-gray-300"><em>Proof.</em> Denote the number of active words in the input and the output of the i-th Bricks<sup>F</sup> layer by  <span class="math">a_i</span>  and  <span class="math">b_i</span> , respectively. Then we exploit two properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each active input word  <span class="math">x_i</span>  to  <span class="math">Bricks^F</span>  activates  <span class="math">\\mathcal{F}_i</span>  if i < t, hence a words activate at least a 1 functions  <span class="math">\\mathcal{F}_i</span> .</li>

      <li>Each active output word  <span class="math">y_i</span>  of  <span class="math">\\operatorname{Bricks}^F</span>  implies that  <span class="math">\\mathcal{F}_{i-1}</span>  or  <span class="math">\\mathcal{F}_{i-2}</span>  is active if i > 1. Hence b words activate at least  <span class="math">\\frac{b-1}{2}</span>  functions.</li>

    </ul>

    <p class="text-gray-300">With the MDS property, which states that  <span class="math">b_k + a_{k+1} \\ge t + 1</span>  for each  <span class="math">k \\ge 1</span> , we obtain the following for the number  <span class="math">c_k</span>  of active functions  <span class="math">\\mathcal{F}_i</span>  in round k:</p>

    <div class="my-4 text-center"><span class="math-block">c_{1} \\geq \\max \\left\\{ a_{1} - 1, \\frac{b_{1} - 1}{2} \\right\\}, \\quad b_{1} + a_{2} \\geq t + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">c_{2} \\geq \\max \\left\\{ a_{2} - 1, \\frac{b_{2} - 1}{2} \\right\\}, \\quad b_{2} + a_{3} \\geq t + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vdots</span></div>

    <div class="my-4 text-center"><span class="math-block">c_{r-1} \\geq \\max \\left\\{ a_{r-1} - 1, \\frac{b_{r-1} - 1}{2} \\right\\}, \\quad b_{r-1} + a_{r} \\geq t + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">c_{r} \\geq \\max \\left\\{ a_{r} - 1, \\frac{b_{r-1} - 1}{2} \\right\\},</span></div>

    <p class="text-gray-300">for r rounds. Summing each two consecutive inequalities for  <span class="math">c_i</span> , we obtain</p>

    <p class="text-gray-300"><span id="page-12-0"></span> <span class="math-block">2c_i + c_{i+1} \\ge 2\\frac{b_{i-1}}{2} + (a_{i+1} - 1) = b_i + a_{i+1} - 2 \\ge t - 1</span> (6)</p>

    <p class="text-gray-300">with the last inequality being the MDS property.</p>

    <p class="text-gray-300">W.l.o.g., let us find a bound for  <span class="math">\\hat{c}:=c_1+\\cdots+c_R</span>  where all  <span class="math">c_i</span>  are non-negative real values satisfying Eq. (6). First, the optimal  <span class="math">\\{c_i\\}</span>  make all inequalities equal. Indeed, suppose that  <span class="math">2c_j+c_{j+1}&gt;t-1</span>  but for all k>j we have  <span class="math">2c_k+c_{k+1}=t-1</span> . Then by using  <span class="math">c&#x27;_j=c_j-\\epsilon</span> ,  <span class="math">c&#x27;_{j-1}=c_{j-1}+\\epsilon/2</span> ,  <span class="math">c&#x27;_{j-2}=c_{j-2}-\\epsilon/4</span>  for a small  <span class="math">\\epsilon</span>  Eq. (6) is still satisfied but  <span class="math">c_{min}</span>  decreases by  <span class="math">\\epsilon\\cdot(1-1/2+1/4-1/8+\\cdots)&gt;0</span> . Thus all inequalities are equations, i.e.,</p>

    <p class="text-gray-300"><span class="math-block">2c_i + c_{i+1} = t - 1</span> .</p>

    <p class="text-gray-300">Then we observe that in the optimal  <span class="math">\\{c_i\\}</span>  it should hold that  <span class="math">c_R = 0</span> . Indeed otherwise we apply the same trick by setting  <span class="math">c_R&#x27; = c_R - \\epsilon</span> ,  <span class="math">c_{R-1}&#x27; = c_{R-1} + \\epsilon/2</span>  etc., again decreasing  <span class="math">c_{min}</span> . Thus, the minimum is achieved by  <span class="math">c_R = 0</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">c_{R-1} = \\frac{t-1}{2}, \\quad c_{R-2} = \\frac{t-1}{4}, \\quad c_{R-3} = \\frac{3(t-1)}{8}, \\quad \\dots, \\quad c_{R-i} = \\frac{t-1}{3} \\cdot \\left(1 + \\frac{(-1)^{i+1}}{2^i}\\right).</span></div>

    <p class="text-gray-300">Substituting these values into the formula for  <span class="math">\\hat{c}</span> , we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\hat{c} &amp;= \\sum_{i=0}^{R-1} \\frac{t-1}{3} \\left( 1 + \\frac{(-1)^{i+1}}{2^i} \\right) = \\frac{t-1}{3} \\sum_{i=0}^{R-1} \\left( 1 + \\frac{(-1)^{i+1}}{2^i} \\right) = \\frac{t-1}{3} \\left( R - \\sum_{i=0}^{R-1} (-2)^{-i} \\right) \\\\ &amp;= \\frac{t-1}{3} \\left( R - \\frac{2(1-(-2)^{-R})}{3} \\right) = (t-1) \\left( \\frac{3R-2-(-2)^{1-R}}{9} \\right). \\end{split}</span></div>

    <p class="text-gray-300"><span id="page-13-2"></span>Remark 1 (On the Design Rationale). Our choice of Feistel versus SPN is purely performance-driven: fewer non-constant field multiplications in the former when using  <span class="math">x \\mapsto x^2</span> . However, neither Feistel Type-3 nor Type-2<sup>6</sup> alone would provide good statistical properties [HR10]. Notably, the combination of Type-2 with an MDS layer would not allow us to derive optimal bounds regarding the number of active nonlinear functions in such a simple and elegant way either.</p>

    <p class="text-gray-300">Monolith is a family of permutations which can be used within hash functions and other constructions. They use prime fields  <span class="math">\\mathbb{F}_p</span>  with two options for p, namely</p>

    <p class="text-gray-300"><span id="page-13-1"></span> <span class="math-block">p_{\\text{Goldilocks}} = 2^{64} - 2^{32} + 1</span>  and  <span class="math">p_{\\text{Mersenne}} = 2^{31} - 1.</span>  (7)</p>

    <p class="text-gray-300">The permutation Monolith-64 is defined over  <span class="math">p_{\\texttt{Goldilocks}}</span>  with the state consisting of t=8 or t=12 elements. The permutation Monolith-31 is defined over  <span class="math">p_{\\texttt{Mersenne}}</span>  with the state consisting of t=16 or t=24 elements.</p>

    <p class="text-gray-300">Monolith supports sponge modes and a 2-to-1 compression function.</p>

    <p class="text-gray-300"><strong>Sponge-Based Schemes.</strong> First, Monolith can instantiate a sponge [BDP+07; BDP+08] and thus various symmetric constructions such as variable-length hash functions, commitment schemes, authenticated encryption, and stream ciphers. The recently proposed SAFE framework [AKM+22; KBM23] instructs how to handle domain separation and padding in these constructions. In a sponge, the permutation state is split into an outer part with a rate of r elements and an inner part with a capacity of c elements. As we uniformly suggest a security level close to 128 bits, we set  <span class="math">c = \\left\\lfloor \\frac{256}{\\rho} \\right\\rfloor</span>  and r = 2c.</p>

    <p class="text-gray-300"><strong>2-to-1 Compression Function.</strong> We also suggest a fixed-length 2-to-1 compression function. Concretely, it takes  <span class="math">t \\ \\mathbb{F}_p</span>  elements as input and produces  <span class="math">t/2 \\ \\mathbb{F}_p</span>  elements as output. It is defined as  <span class="math">x \\in \\mathbb{F}_p^t \\mapsto \\mathrm{Tr}_{t/2}(\\mathcal{P}(x)+x) \\in \\mathbb{F}_p^t</span> , where  <span class="math">\\mathrm{Tr}_{t/2}</span>  yields the first t/2 elements of the inputs. This compression function can be used in Merkle trees and has recently also been applied in similar constructions, including Anemoi [BBC+23], GRIFFIN [GHR+23], and POSEIDON2 [GKS23]. For a security level of close to 128 bits, we set  <span class="math">t = \\left\\lfloor \\frac{512}{\\rho} \\right\\rfloor</span> , i.e., t = 8 for the 64-bit field and t = 16 for the 31-bit field (factually yielding slightly less than 128 bits).</p>

    <p class="text-gray-300"><span id="page-13-0"></span><sup>&</sup>lt;sup>6</sup> Type-2 Feistel turns state  <span class="math">\\{x_i\\}</span>  into  <span class="math">\\{y_i\\}</span>  where odd elements remain untouched and  <span class="math">y_{2i} = x_{2i+1} + \\mathcal{F}_i(x_{2i})</span> .</p>

    <p class="text-gray-300"><img src="_page_14_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-14-1"></span>Fig. 4. One round of the Monolith construction, where  <span class="math">x_i, y_i \\in \\mathbb{F}_p</span> .</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">4.2 Permutation Structure</h4>

    <p class="text-gray-300">The Monolith permutation is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{Monolith}(\\cdot) = \\mathcal{R}_R \\circ \\cdots \\circ \\mathcal{R}_2 \\circ \\mathcal{R}_1 \\circ \\mathtt{Concrete}(\\cdot),</span></div>

    <p class="text-gray-300">where R is the number of rounds and  <span class="math">\\mathcal{R}_i</span>  over  <span class="math">\\mathbb{F}_p^t</span>  are defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_i(\\cdot) = c^{(i)} + \\mathtt{Concrete} \\circ \\mathtt{Bricks} \\circ \\mathtt{Bars}(\\cdot), \\qquad \\forall i \\in \\{1, 2, \\dots, R\\},</span></div>

    <p class="text-gray-300">where Concrete is a linear operation, Bars and Bricks are nonlinear operations over  <span class="math">\\mathbb{F}_p^t</span> ,  <span class="math">c^{(1)}, \\ldots, c^{(r-1)} \\in \\mathbb{F}_p^t</span>  are pseudo-random round constants, and  <span class="math">c^{(r)} = \\mathbf{0}</span> . Note that a single Concrete operation is applied before the first round. A graphical overview of one round of the construction is shown in Fig. 4.</p>

    <p class="text-gray-300">Round Constant Generation. The actual values of pseudo-randomly chosen round constants have no impact on the security. For completeness we provide a generation method in Appendix A.3.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6"><strong>4.3</strong> Bars</h4>

    <p class="text-gray-300">The Bars layer is defined as</p>

    <p class="text-gray-300"><span id="page-14-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Bars(x_1, x_2, \\dots, x_t) := Bar(x_1) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bar(x_u) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{u+1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_t$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (8)</p>

    <p class="text-gray-300">for a t-element state, where  <span class="math">\\mathbf{u} \\in \\{1,\\ldots,t\\}</span>  denotes the number of Bar applications in a single round. We select  <span class="math">\\mathbf{u}</span>  such that  <span class="math">\\mathbf{u} \\cdot \\log_2 p \\approx 256</span> , i.e., the nonlinear part occupies around 256 bits of the state. Each Bar application is defined as</p>

    <div class="my-4 text-center"><span class="math-block">Bar(x) = C \\circ S \\circ D(x),</span></div>

    <p class="text-gray-300">where C, S and D are the operations defined in Section 2. In the following, we describe them individually for Monolith-64 and Monolith-31.</p>

    <p class="text-gray-300"><span id="page-15-5"></span>Bars for Monolith-64. In Eq. (8) we set  <span class="math">t \\in \\{8, 12\\}</span>  (compression or sponge, resp.) and we set u = 4 (i.e., 4 Bar operations are applied in each round).</p>

    <p class="text-gray-300">Operations  <span class="math">\\mathcal{D}</span>  and  <span class="math">\\mathcal{C}</span> . We use a decomposition into 8-bit values such that</p>

    <div class="my-4 text-center"><span class="math-block">x = 2^{56}x_8&#x27; + 2^{48}x_7&#x27; + 2^{40}x_6&#x27; + 2^{32}x_5&#x27; + 2^{24}x_4&#x27; + 2^{16}x_3&#x27; + 2^8x_2&#x27; + x_1&#x27;.</span></div>

    <p class="text-gray-300">The composition  <span class="math">\\mathcal{C}</span>  is the inverse operation of the decomposition  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">S-Boxes S. In Eq. (3) we set s = 8. Then all  <span class="math">S_i</span>  over  <span class="math">\\mathbb{F}_2^8</span>  are defined as</p>

    <p class="text-gray-300"><span id="page-15-3"></span> <span class="math-block">S_i(y) = (y \\oplus ((\\overline{y} \\ll 1) \\odot (y \\ll 2) \\odot (y \\ll 3))) \\ll 1, \\tag{9}</span></p>

    <p class="text-gray-300">where  <span class="math">\\ll</span>  is a circular shift (here we interpret an integer as a big-endian 8-bit string) and  <span class="math">\\overline{y}</span>  is the bitwise negation (see [Dae95, Table A.1]).</p>

    <p class="text-gray-300">Bars for Monolith-31. In Eq. (8) we set  <span class="math">t \\in \\{16, 24\\}</span>  (compression or sponge, resp.) and we set u = 8 (i.e., 8 Bar operations are applied in each round).</p>

    <p class="text-gray-300">Operations  <span class="math">\\mathcal{D}</span>  and  <span class="math">\\mathcal{C}</span> . The decomposition  <span class="math">\\mathcal{D}</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">x = 2^{24}x_4&#x27; + 2^{16}x_3&#x27; + 2^8x_2&#x27; + x_1&#x27;,</span></div>

    <p class="text-gray-300">where  <span class="math">x_4&#x27; \\in \\mathbb{Z}_2^7</span>  and  <span class="math">x_3&#x27;, x_2&#x27;, x_1&#x27; \\in \\mathbb{Z}_2^8</span> . The composition  <span class="math">\\mathcal{C}</span>  is the inverse of  <span class="math">\\mathcal{D}</span> .</p>

    <p class="text-gray-300">S-Boxes S. In Eq. (3) we set s=4 using  <span class="math">\\{8,7\\}</span> -bit lookup tables. Then, for  <span class="math">y\\in\\mathbb{F}_2^8</span>  and  <span class="math">y&#x27;\\in\\mathbb{F}_2^7</span> , the S-boxes are defined as (see [Dae95, Table A.1])</p>

    <p class="text-gray-300"><span id="page-15-4"></span> <span class="math-block">\\forall i \\in \\{1, 2, \\dots, s-1\\}: \\quad \\mathcal{S}_i(y) = \\left(y \\oplus \\left((\\overline{y} \\ll 1) \\odot (y \\ll 2) \\odot (y \\ll 3)\\right)\\right) \\ll 1,</span> <span class="math-block">\\mathcal{S}_s(y&#x27;) = \\left(y&#x27; \\oplus \\left((\\overline{y&#x27;} \\ll 1) \\odot (y&#x27; \\ll 2)\\right)\\right) \\ll 1.</span> (10)</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.4 Bricks</h4>

    <p class="text-gray-300">The component Bricks over  <span class="math">\\mathbb{F}_p^t</span>  is defined as a Feistel Type-3 Bricks<sup>F</sup> (Eq. (5)) with  <span class="math">x \\mapsto x^2</span> , i.e., Bricks <span class="math">(x_1, \\dots, x_t) := (x_1, x_2 + x_1^2, x_3 + x_2^2, \\dots, x_t + x_{t-1}^2)</span> .</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">4.5 Concrete</h4>

    <p class="text-gray-300">The Concrete layer is defined as  <span class="math">\\operatorname{Concrete}(x_1,\\ldots,x_t) := M \\times (x_1,\\ldots,x_t)^T</span> , where  <span class="math">M \\in \\mathbb{F}_n^{t \\times t}</span>  is an MDS matrix.</p>

    <p class="text-gray-300">If  <span class="math">p = 2^{64} - 2^{32} + 1</span> , then M = circ(23, 8, 13, 10, 7, 6, 21, 8) for t = 8 and M = circ(7, 23, 8, 26, 13, 10, 9, 7, 6, 22, 21, 8) for t = 12. These two circulant matrices defined for the Goldilocks prime  <span class="math">p_{\\text{Goldilocks}}</span>  correspond to the ones found and implemented by the Winterfell STARK library. These matrices have the unique</p>

    <p class="text-gray-300"><span id="page-15-2"></span><sup>&</sup>lt;sup>7</sup> https://github.com/facebook/winterfell/tree/main/crypto/src/hash/mds</p>

    <p class="text-gray-300"><span id="page-16-1"></span>Table 1. Parameters for Monolith.</p>

    <p class="text-gray-300"><span id="page-16-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Name</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds <span class="math">R</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Wie 2-to-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\begin{array}{c} \\text{dth } t \\\\ \\text{Sponge} \\end{array}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Bar <span class="math">u</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-64 Monolith-31</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{ c c c c c c c c c c c c c c c c c c c</span></td>

            <td class="px-3 py-2 border-b border-gray-700">128<br>124</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">8<br>16</td>

            <td class="px-3 py-2 border-b border-gray-700">12<br>24</td>

            <td class="px-3 py-2 border-b border-gray-700">4 8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">advantage of having small elements in the time and frequency domain (i.e., before and after DFT application), allowing for especially fast native performance.</p>

    <p class="text-gray-300">If  <span class="math">p = 2^{31} - 1</span>  and t = 16, M is the  <span class="math">16 \\times 16</span>  matrix from Tip5 [SLS+23]<sup>8</sup>, i.e.,</p>

    <p class="text-gray-300"> <span class="math">M = \\text{circ}(61402, 1108, 28750, 33823, 7454, 43244, 53865, 12034, \\\\ 56951, 27521, 41351, 40901, 12021, 59689, 26798, 17845).</span></p>

    <p class="text-gray-300">If  <span class="math">p=2^{31}-1</span>  and t=24, M is a  <span class="math">24\\times 24</span>  submatrix of the  <span class="math">32\\times 32</span>  circulant MDS matrix constructed from [HS24]. This particular design choice is explained in Section 7.1. The  <span class="math">32\\times 32</span>  circulant MDS matrix is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} M &amp;= \\mathrm{circ}(0\\texttt{x}536\\texttt{C}316, 0\\texttt{x}1\\texttt{D}\\texttt{D}20\\texttt{A}84, 0\\texttt{x}43\\texttt{E}26541, 0\\texttt{x}52\\texttt{B}22\\texttt{B}8\\mathsf{D}, 0\\texttt{x}37\\texttt{D}\\texttt{A}\\texttt{B}\\texttt{D}\\mathsf{F}0, 0\\texttt{x}54\\texttt{O}\\texttt{E}\\texttt{C}066, \\\\ 0\\texttt{x}3015718\\texttt{D}, 0\\texttt{x}5\\texttt{A}99\\texttt{E}14\\texttt{C}, 0\\texttt{x}23637285, 0\\texttt{x}4\\texttt{C}8\\texttt{A}2\\texttt{F}76, 0\\texttt{x}5\\texttt{D}\\texttt{E}\\texttt{C}4\\texttt{E}6\\texttt{E}, 0\\texttt{x}374\\texttt{E}\\texttt{E}8\\texttt{D}6, \\\\ 0\\texttt{x}27\\texttt{E}\\texttt{D}\\texttt{A}4\\texttt{D}8, 0\\texttt{x}665\\texttt{D}30\\texttt{D}3, 0\\texttt{x}32\\texttt{E}44597, 0\\texttt{x}43\\texttt{C}7\\texttt{E}2\\texttt{B}3, 0\\texttt{x}67\\texttt{C}4\\texttt{C}603, 0\\texttt{x}78\\texttt{A}8631\\texttt{F}, \\\\ 0\\texttt{x}452\\texttt{F}77\\texttt{E}3, 0\\texttt{x}39\\texttt{F}03\\texttt{D}\\texttt{F}, 0\\texttt{x}743\\texttt{D}\\texttt{B}\\texttt{F}\\texttt{E}0, 0\\texttt{x}4\\texttt{D}\\texttt{A}05\\texttt{A}48, 0\\texttt{x}5\\texttt{F}027940, 0\\texttt{x}8293632, \\\\ 0\\texttt{x}50\\texttt{F}2\\texttt{C}76\\texttt{A}, 0\\texttt{x}7\\texttt{B}773729, 0\\texttt{x}577\\texttt{D}\\texttt{E}8\\texttt{B}0, 0\\texttt{x}73\\texttt{B}1\\texttt{E}\\texttt{A}\\texttt{C}6, 0\\texttt{x}5\\texttt{B}\\texttt{D}\\texttt{A}7\\texttt{D}29, 0\\texttt{x}67\\texttt{A}\\texttt{A}4375, \\\\ 0\\texttt{x}\\texttt{D}\\texttt{B}\\texttt{A}\\texttt{B}\\texttt{E}33, 0\\texttt{x}2655\\texttt{E}5\\texttt{A}1). \\end{split}</span></div>

    <h2 id="sec-18" class="text-2xl font-bold">4.6 Number of Rounds and Security Claims</h2>

    <p class="text-gray-300">We suggest to use R=6 rounds for Monolith-64 and Monolith-31 (see Table 1) and claim  <span class="math">2\\log_2(p_{\\texttt{Goldilocks}})\\approx 128</span>  bits and  <span class="math">4\\log_2(p_{\\texttt{Mersenne}})\\approx 124</span>  bits of security for Monolith-64 and Monolith-31, respectively.</p>

    <p class="text-gray-300">Remark 2. We do not claim that the Monolith permutation does not have any non-generic property (or "indifferentiable from random"). In particular, we do not consider certain permutation distinguishers – such as the integral one [DKR97] or the zero-sum partitions [KR07; BCC11] – that have not ever resulted in collision or preimage attacks for similar designs. We refer to Appendix B.3 for more details.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">4.7 Security Analysis</h4>

    <p class="text-gray-300">The numbers of rounds are conservatively chosen based on the security analysis proposed in Section 5 and Section 6. As some of the components or combinations</p>

    <p class="text-gray-300"><span id="page-16-0"></span> <span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span>  It is also MDS for  <span class="math">p_{\\tt Mersenne}</span>  as proved in <code>https://github.com/Neptune-Crypto/twenty-first/blob/master/twenty-first/src/shared\\_math/tip5.rs</code></p>

    <p class="text-gray-300"><span id="page-17-3"></span>are new, our analysis contains several nontrivial ideas and may be of separate interest to cryptanalysts and designers.</p>

    <p class="text-gray-300">First, in the spirit of the wide trail strategy, [\\[DR02\\]](#page-33-5), we prove tight bounds for the number of active squarings in differential characteristics for the Type-3 Feistel-MDS combination in Section <a href="#page-17-1">5.1.</a> We also study rebound attacks in Section <a href="#page-18-0">5.3,</a> a research direction that is often missed in the ZK hash function design. We demonstrate practical attacks on a reduced version of Monolith and argue the security of the full version.</p>

    <p class="text-gray-300">Using differential and linear properties of Bar, we prove lower bounds on its algebraic degree in Section <a href="#page-19-0">6.1,</a> which implies resistance against algebraic attacks after a few rounds. In this regard, we additionally study the complexity of Gröbner basis attacks on toy versions of Monolith with smaller primes but still realistic Bars layers in Section <a href="#page-22-0">6.3.</a></p>

    <p class="text-gray-300">To summarize, we are not able to even break 5 rounds of the proposed scheme with any basic attacks proposed in the literature. As future work, we encourage to study reduced-round and/or toy variants of our design.</p>

    <p class="text-gray-300">Given pairs of inputs with some fixed input differences, differential cryptanalysis [\\[BS90\\]](#page-32-7) considers the probability distribution of the corresponding output differences produced by the cryptographic primitive. Since the Bars layer is not supposed to have good statistical properties, we simply assume that the attacker can skip it with probability 1.</p>

    <p class="text-gray-300"><span id="page-17-2"></span>As the maximum differential probability of the square map is 1/p, Proposition <a href="#page-11-1">1</a> immediately implies the following bound.</p>

    <p class="text-gray-300">Corollary 2. Any 4-round differential characteristic for Monolith has a probability of at most p −9(t−1) <sup>8</sup> .</p>

    <p class="text-gray-300">As a result, any characteristic that spans over 5 rounds and more would cover more squarings than the number of state elements, and thus a solution to it cannot be found by standard means. Therefore, a differential-based collision attack on 5 rounds looks infeasible.</p>

    <p class="text-gray-300">Linear Attacks. Linear cryptanalysis [\\[Mat93\\]](#page-36-8) exploits the existence of linear approximations. For primitives over binary fields, the attack makes use of the high correlations [\\[DGV94\\]](#page-33-8) between sums of input bits and sums of output bits. The generalization of this attack over prime fields has been proposed in <a href="#page-32-8">\\[BSV07;</a> [DGG+21\\]](#page-32-9). We claim that our scheme is secure against this approach, due to the low correlation of the map x 7→ x 2 (as for the case of differential attacks).</p>

    <p class="text-gray-300"><span id="page-18-1"></span>Truncated Differentials. Truncated differential attacks [Knu94] are used mostly against primitives that have incomplete diffusion over a few rounds. This is not the case here since (i) Bricks is a full nonlinear layer, and (ii) the Concrete matrix is MDS. We have not found any other attacks where a truncated differential can be used as a subroutine either.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.2 Rebound Attacks</h4>

    <p class="text-gray-300">Rebound attacks [MRS+09] have been widely used to analyze the security of various types of hash functions against shortcut collision attacks since the beginning of the SHA-3 competition. It starts by choosing internal state values in the middle of the computation, and then computing in the forward and backward directions to arrive at the inputs and outputs. It is useful to think of it as having central (often called "inbound") and the above mentioned "outbound" parts. In the attack, solutions to the inbound phase are first found, and then are filtered in the outbound phase.</p>

    <p class="text-gray-300">Whereas it is not possible to prove the resistance to the rebound attacks rigorously, we can provide some meaningful arguments to demonstrate that they are not feasible. The inbound phase deals with truncated and regular differentials. By Corollary 2 we see that a solution for a 5-round differential cannot be found, and so the inbound phase cannot cover more than 4 Bricks layers. In the outbound phase, the Concrete layers that surround these Bricks layers make all differentials diffuse to the entire state, so that the next Bricks layers destroy all of those. We hence conclude that 6 rounds of Monolith are sufficient to prevent rebound attacks. We refer to Appendix B.1 for more details.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.3 Other Statistical Attacks</h3>

    <p class="text-gray-300">We claim that 6 rounds are sufficient for preventing other statistical attacks as well. Here we provide argument to support such conclusion for one of the most powerful statistical attacks against a hash function, that is, the rebound attack. For that goal, we propose an analysis of the number of the fixed points and of the truncated differential characteristics.</p>

    <p class="text-gray-300">Fixed Points. Contrary to Reinforced Concrete, the Bars layer of Monolith has very few fixed points. Both local maps  <span class="math">x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2) \\odot (x \\ll 3))</span>  and  <span class="math">x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2))</span>  have about  <span class="math">(7/4)^n</span>  fixed points (for even and odd n, respectively) when considered over  <span class="math">\\mathbb{F}_2^n</span>  (a bit value is preserved if the product of nearby bits is 0). However, all of them except  <span class="math">\\mathbf{0}</span>  and  <span class="math">\\mathbf{1} = 2^n - 1</span>  are destroyed by the circular shift (verified experimentally).</p>

    <p class="text-gray-300">A Bar of Monolith-64, consisting of 8 such S-boxes, admits  <span class="math">2^8-2^4+1=241</span>  fixed points out of  <span class="math">2^{64}-2^{32}+1</span> . This implies that the probability that a point is fixed is approximately  <span class="math">2^{-56}</span>  for Bar and less than  <span class="math">2^{-56\\cdot 4}=2^{-224}</span>  for Bars. Similarly, a Bar of Monolith-31 admits  <span class="math">2^4-1=15</span>  fixed points out of  <span class="math">2^{31}-1</span> .</p>

    <p class="text-gray-300"><span id="page-19-3"></span>This implies that the probability that a point is fixed is approximately  <span class="math">2^{-27}</span>  for Bar and less than  <span class="math">2^{-27\\cdot 8}=2^{-216}</span>  for Bars.</p>

    <p class="text-gray-300">For comparison, we recall that a Bar of Reinforced Concrete has  <span class="math">2^{134.5}</span>  fixed points out of  <span class="math">2^{254}</span>  possibilities. Hence, the probability of encountering a fixed point is approximately  <span class="math">2^{-119.5\\cdot 3}=2^{-358.5}</span>  for Bars. At the current state of the art, we are not aware of any attack that exploits these fixed points.</p>

    <p class="text-gray-300">Invariant Subspace Attacks. An invariant subspace attack exploits the existence of a subspace  <span class="math">\\mathfrak{X} \\subseteq \\mathbb{F}_p^t</span>  that remains invariant under the round function. (Note that we do not require that the coset of such subspace does not change as well.) Such attack is particular effective either in the case of keyed ciphers instantiated with weak keys [LAA+11; LMR15], or/and in the case of partial SPN schemes, in which part of the state remains unchanged after the application of the nonlinear layer. In this second case, the linear layer and the round constants can be carefully chosen in order to break such invariant subspaces, as shown in [GRS21; GSW+21].</p>

    <p class="text-gray-300">In our design, Bars layer is a partial nonlinear layer. However, such layer is combined with another nonlinear layer instantiated with Feistel Type-3 Bricks<sup>F</sup>. Even considering a weaker version of the scheme instantiated by a single nonlinear layer of the form  <span class="math">\\text{Bar}(x_1) \\mid\\mid \\cdots \\mid\\mid \\text{Bar}(x_u) \\mid\\mid x_u^2 + x_{u+1} \\mid\\mid x_{u+1}^2 + x_{u+2} \\cdots \\mid\\mid x_{t-1}^2 + x_t</span> , and due to the fact that the linear layer is instantiated with an MDS matrix, we have not found any non-trivial invariant subspace that covers more than a single round of Monolith.</p>

    <p class="text-gray-300">Cryptanalytic successes such as Gröbner basis attacks on Friday and Jarvis [ACG+19], attacks on MiMC combining higher-order differential distinguishers with polynomial factorization [EGL+20; BCP23; LP19; RAS20], or an attack on Grendel [GKR+22] leveraging polynomial factorization are a stark warning that through analysis of such attack vectors is important. While the use of Bars is intuitively expected to frustrate such attacks, it is nevertheless essential to establish a sound basis for arguments against such attacks.</p>

    <p class="text-gray-300"><span id="page-19-2"></span><strong>Lemma 5.</strong> Let n > 4 be such that  <span class="math">\\gcd(n,3) = 1</span> . Let S be the invertible map over  <span class="math">\\mathbb{F}_2^n</span>  given Eq. (9), that is,  <span class="math">x \\mapsto (x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2) \\odot (x \\ll 3))) \\ll 1</span> . Let  <span class="math">\\overline{S}</span>  be the corresponding mapping but over  <span class="math">\\mathbb{Z}_{2^n}</span> , where the elements of  <span class="math">\\mathbb{F}_2^n</span>  are viewed as the big-endian counterparts of elements from  <span class="math">\\mathbb{Z}_{2^n}</span> .</p>

    <p class="text-gray-300">The map  <span class="math">\\overline{S}</span>  has differential probability at least 13/64 over  <span class="math">\\mathbb{Z}_{2^n}</span> . Particularly the pair (x, x+1) for even x is mapped into (y, y+2) for some  <span class="math">y \\equiv 0, 1 \\pmod{4}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Consider two input states x, x' with a single bit difference in the <em>i</em>-th bit, that is,  <span class="math">x_i = 1 \\oplus x&#x27;_i = 0</span>  and  <span class="math">x_j = x&#x27;_j</span>  for  <span class="math">j \\neq i</span> . Let us derive sufficient conditions</p>

    <p class="text-gray-300">for which the output states y, y' via S differ in the (i-1)-th bit only (note the final shift  <span class="math">\\ll</span>  1). By simple computation, this occurs if the product in the S-box bit mapping is 0 whenever the i-th bit is XORed or is part of the product, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\overline{x_{i+1}} \\odot x_{i+2} \\odot x_{i+3} = 0, \\quad x_{i+1} \\odot x_{i+2} = 0, \\quad \\overline{x_{i-1}} \\odot x_{i+1} = 0, \\quad \\overline{x_{i-2}} \\odot x_{i-1} = 0.</span></div>

    <p class="text-gray-300">The number of 5-tuples satisfying this system is 13 out of 32 possible. Therefore, a differential for S over  <span class="math">\\mathbb{F}_2^n</span>  holds with probability 13/32.</p>

    <p class="text-gray-300">For i = n, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\{(x_1,\\ldots,x_{n-1},0),(x_1,\\ldots,x_{n-1},1)\\} \\xrightarrow{S} \\{(y_1,\\ldots,y_{n-2},0,y_n),(y_1,\\ldots,y_{n-2},1,y_n)\\}.</span></div>

    <p class="text-gray-300">By simple computation, the same result holds for  <span class="math">\\overline{S}</span> , i.e.,  <span class="math">\\{x=2\\cdot x&#x27; \\text{ (even)}, x+1\\} \\xrightarrow{\\overline{S}} \\{y,y+2\\}</span> . The result follows immediately.</p>

    <p class="text-gray-300"><span id="page-20-0"></span><strong>Lemma 6.</strong> The Bar function for  <span class="math">p = 2^{64} - 2^{32} + 1</span>  (Section 4.3) has differential probability at least 13/64 over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> For every even x < p-1 we have that x+1 < p. Let  <span class="math">\\mathcal{D}</span>  of Bar decompose x to  <span class="math">x_1, x_2, \\ldots, x_s</span> . Then we have that  <span class="math">\\mathcal{D}(x+1)</span>  differs from  <span class="math">\\mathcal{D}(x)</span>  in the last bucket only, and we have  <span class="math">S(x_s+1)=S(x)+2</span>  from Lemma 5 with probability 13/32. Therefore for the full Bar function we have Bar(x+1)=Bar(x)+2 for at least  <span class="math">13(2^{64}-2^{32})/64</span>  values of x, which gives the lemma statement.</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Let n > 4 be such that gcd(n, 2) = 1. Let S' be the invertible map over  <span class="math">\\mathbb{F}_2^n</span>  given Eq. (10), that is,  <span class="math">x \\mapsto (x \\oplus ((\\overline{x} \\ll 1) \\odot (x \\ll 2))) \\ll 1</span> . Let  <span class="math">\\overline{S}&#x27;</span>  be the corresponding mapping but over  <span class="math">\\mathbb{Z}_{2^n}</span> , where the elements of  <span class="math">\\mathbb{F}_2^n</span>  are viewed as the big-endian counterparts of elements from  <span class="math">\\mathbb{Z}_{2^n}</span> .</p>

    <p class="text-gray-300">The map  <span class="math">\\overline{S}&#x27;</span>  has differential probability at least 1/8 over  <span class="math">\\mathbb{Z}_{2^n}</span> . Particularly, the pair (x, x+1) for even x is mapped into (y, y+2) for some  <span class="math">y \\equiv 0, 1 \\pmod{4}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof repeats that of Lemma 5 with the system of equations for  <span class="math">x_i</span>  appearing as  <span class="math">\\overline{x_{i+1}} \\odot x_{i+2} = 0</span> ,  <span class="math">x_{i+1} = 0</span> , and  <span class="math">\\overline{x_{i-1}} = 0</span> . The number of 3-tuples satisfying this system is 1 out of 8 possible. Thus, for i = n we have a differential for S' with probability 1/8:</p>

    <div class="my-4 text-center"><span class="math-block">\\{(x_1,\\ldots,x_{n-1},0),(x_1,\\ldots,x_{n-1},1)\\} \\xrightarrow{S&#x27;} \\{(y_1,\\ldots,y_{n-2},0,y_n),(y_1,\\ldots,y_{n-2},1,y_n)\\}.</span></div>

    <p class="text-gray-300">Simultaneously, for  <span class="math">\\overline{S}&#x27;</span> , we have that  <span class="math">\\{x = 2x&#x27; \\text{ (even)}, x+1\\} \\xrightarrow{\\overline{S}&#x27;} \\{y, y+2\\}</span> . The result follows immediately.</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> The Bar function for  <span class="math">p = 2^{31} - 1</span>  (Section 4.3) has differential probability at least 1/16 over  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">The proof is identical to that of Lemma 6. With Lemma 3, we obtain the following bound on the degree of Bar.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> The Bar operation (and its inverse) has degree at least (i)  <span class="math">2^{59}</span>  for  <span class="math">p = 2^{64} - 2^{32} + 1</span> , and (ii)  <span class="math">2^{27}</span>  for  <span class="math">p = 2^{31} - 1</span> .</p>

    <p class="text-gray-300"><span id="page-21-0"></span>Additional data about the degree of Bars for various p as well as density estimates are presented in Appendix B.2. Our practical tests on toy-Bars functions defined on smaller prime fields showed that the corresponding interpolation polynomial is dense and of high (usually, maximum or close to maximum) degree.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">6.2 Security against Algebraic Attacks via Bars</h4>

    <p class="text-gray-300">Here we consider attacks that exploit the fact that several rounds of the permutation do not have maximum possible algebraic degree. For this, we interpret the output elements as polynomials of the input elements. Then we formulate a collision or a preimage attack as a system of equations and try to solve it.</p>

    <p class="text-gray-300">Interpolation Attacks. Interpolation attacks [JK97] exploit the degree of a component to reconstruct its polynomial and solve a system of equations. However, we have demonstrated that the degree of the Bar component is close to p. Therefore, after at most 2 rounds of Monolith, the degree in each variable becomes almost p, which implies that mounting the attack is infeasible.</p>

    <p class="text-gray-300">Note that the Bars layer is partial, using only u Bar components. Thus, excluding the Type-3 Feistel layer, it may be possible to pass r rounds by guessing  <span class="math">r \\cdot u</span>  intermediate variables. However, as  <span class="math">u \\ge t/3</span> , this is possible for at most 2 rounds (without exhausting the degrees of freedom). We conclude that it is not feasible to apply simple algebraic attacks on 4 or more rounds of Monolith.</p>

    <p class="text-gray-300">Solving a CICO Problem with Univariate polynomials. In the CICO problem, the goal is to find a solution to the system of v polynomial equations of t-v input variables (as the remaining v ones are set to zero). More formally:</p>

    <p class="text-gray-300"><strong>Definition 4 (CICO Security).</strong> A permutation  <span class="math">\\mathcal{P}: \\mathbb{F}_p^t \\to \\mathbb{F}_p^t</span>  is v-CICO secure if no algorithm with expected complexity smaller than  <span class="math">p^v</span>  finds  <span class="math">I_1 \\in \\mathbb{F}_p^{t-v}</span>  and  <span class="math">O_2 \\in \\mathbb{F}_p^{t-v}</span>  such that  <span class="math">\\mathcal{P}(\\mathbf{0}^v \\mid\\mid I_1) = \\mathbf{0}^v \\mid\\mid O_2</span> .</p>

    <p class="text-gray-300">The univariate system appears if v=t-1 or we guess t-v-1 variables. Note that our guess may be invalid if the number of equations exceeds the number of variables, so we have to repeat the guess  <span class="math">p^{v-1}</span>  times. Note also that p is smaller than  <span class="math">2^{128}</span>  so  <span class="math">p^{v-1}</span>  may still be feasible.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If v=1 and we have guessed t-2 variables, then we have to solve a single polynomial equation faster than in time p. The degree of the polynomial reaches p after 2 applications of the Bars layer, i.e., after 2 rounds. Therefore, solving the equation will require time  <span class="math">\\approx p</span> .</li>

      <li>If v > 1, and we have guessed t v 1 variables, then the probability that a CICO solution exists for a particular guess is  <span class="math">p^{-(v-1)}</span> , since we only solve one equation and hope for other v 1 to hold. A system of polynomial equations has degree close to p, so solving it would cost at least p time for any guess. Multiplying by the number of guesses, we obtain that the total complexity still exceeds  <span class="math">p \\cdot p^{v-1} = p^v</span> .</li>

    </ul>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">6.3 Solving the Multivariate CICO Problem with Gröbner Bases</h4>

    <p class="text-gray-300">In a general case, we model the CICO problem as a system of multivariate polynomial equations generating a zero-dimensional ideal. The main technique for solving these systems is to use Gröbner bases and apply the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-22-1"></span>1. Compute a Gröbner basis for the zero-dimensional ideal of the system of polynomial equations with respect to the <em>degrevlex</em> term order.</li>

      <li>2. Convert the degrevlex Gröbner basis into a lex Gröbner basis using the FGLM algorithm [FGL+93].</li>

      <li>3. Factor the univariate polynomial in the <em>lex</em> Gröbner basis and determine the solutions for the corresponding variable. Back-substitute those solutions, if needed, to determine solutions for the other variables.</li>

    </ul>

    <p class="text-gray-300">The total complexity of a Gröbner basis attack is hence the sum of the respective complexities of the above steps. We argue that even step 1. is prohibitively expensive for Monolith.</p>

    <p class="text-gray-300">The complexity of computing a Gröbner basis with (matrix-based) algorithms such as Lazard [Laz79; Laz83], F4 [Fau99], or Matrix-F5 [BFS15] for an equation system with  <span class="math">n_e</span>  equations in  <span class="math">n_v</span>  variables over a field  <span class="math">\\mathbb F</span>  can be bounded by</p>

    <p class="text-gray-300"><span id="page-22-2"></span> <span class="math-block">\\mathcal{O}\\left(n_e \\cdot \\binom{n_v + d_{\\text{solv}}}{n_v}^{\\omega}\\right) \\tag{11}</span></p>

    <p class="text-gray-300">operations in  <span class="math">\\mathbb{F}</span> . Here,  <span class="math">d_{\\rm solv}</span>  denotes the solving degree and  <span class="math">\\omega</span>  denotes the linear algebra exponent. Intuitively,  <span class="math">d_{\\rm solv}</span>  corresponds to the maximum degree attained during a Gröbner basis computation. Thus, the overall complexity of computing a Gröbner basis can be understood as bounded by row-reducing (full-rank) matrices of size  <span class="math">n_e \\cdot \\binom{n_v+i-1}{i} \\times \\binom{n_v+i-1}{i}</span> , for  <span class="math">i=0,1,\\ldots,d_{\\rm solv}</span> , eventually, leading to the bound in Eq. (11). In practice, the Macaulay matrices built during a Gröbner basis computation might be sparse and have a substantial rank defect, and Eq. (11) does not account for this particular structure in the Macaulay matrices.</p>

    <p class="text-gray-300">Rationale for our Security Arguments. As a conservative choice and to account for the structured Macaulay matrices in the algebraic model for Monolith, in Eq. (11) we drop any factors from the asymptotic  <span class="math">\\mathcal{O}(\\cdot)</span>  notation and set  <span class="math">n_e = \\omega = 1</span> , and, hence, use  <span class="math">\\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{solv}}) = \\binom{n_v + d_{\\text{solv}}}{n_v}</span>  as a guideline for estimating the complexity of actual Gröbner basis computations. We stress that setting  <span class="math">\\omega = 1</span>  is a highly optimistic scenario from an attacker's viewpoint.</p>

    <p class="text-gray-300">Establishing concrete estimates for  <span class="math">\\mathcal{C}_{\\mathrm{GB}}</span> , hence, boils down to bounding the solving degree  <span class="math">d_{\\mathrm{solv}}</span> . This task is in general a difficult problem in its own regard, often as hard as actually computing a Gröbner basis. However, for the special case of (semi-)regular sequences, there exist bounds on  <span class="math">d_{\\mathrm{solv}}</span> . In particular, for regular sequences  <span class="math">d_{\\mathrm{solv}}</span>  is upper-bounded by the <em>Macaulay bound</em> [BFS15]</p>

    <div class="my-4 text-center"><span class="math-block">d_{\\text{Mac}} := 1 + \\sum_{i=1}^{n_e} (d_i - 1). \\tag{12}</span></div>

    <p class="text-gray-300"><span id="page-23-2"></span>Informally, the case of regular sequences can be regarded as a generic case, formalizing the notion of "random polynomial systems". Although the assumption of regular sequences often fails for algebraic models of circuit-friendly primitives, comparing a given algebraic model with this generic case can still be an informative approach and help to establish heuristic estimates for the complexity of Gröbner basis computations when practical experiments are infeasible. In our analysis, we compare the actual solving degree dsolv from our practical experiments with dMac. This allows us to extrapolate trends from the aquired data points to large-scale instances, which are computationally intractable.</p>

    <p class="text-gray-300">When analyzing a given algebraic model, another problem is scalability: it is nontrivial to properly scale down the original system of equations to some smallscale variant that is solvable on a standard machine. We tackle this problem and estimate the complexity of a Gröbner basis attack on the CICO problem for full-scale Monolith as described below. We point out that we only focus on step <a href="#page-22-1">1.</a> of a Gröbner basis attack and show that already the complexity of this step exceeds the generic CICO security level.</p>

    <p class="text-gray-300">– We consider a small-scale, weakened version of one round of Monolith, denoted SmallWeak1R, with a small state of only t = 4 elements, and u=2 Bar functions in the Bars layer. We have</p>

    <div class="my-4 text-center"><span class="math-block">{\\tt SmallWeak1R} := {\\tt Concrete&#x27;} \\circ {\\tt Bricks} \\circ {\\tt Bars} \\circ {\\tt Concrete&#x27;},</span></div>

    <p class="text-gray-300">where for Concrete′ we use the circulant matrix M = circ(2, 1, 1, 1), which is not MDS and thus weaker than the MDS matrix used in Monolith. For Bricks, we use the same Bricks as described in Section <a href="#page-15-0">4.4,</a> with t = 4. The Bars function is the same function described in Section <a href="#page-14-0">4.3,</a> with t = 4 and a decomposition into m = 2 buckets for all small primes for which we run actual computations, see also Table <a href="#page-24-0">2.</a> For the S-Box functions inside Bar, we use suitable functions from <a href="#page-32-3">\\[Dae95,</a> Table A.1].</p>

    <p class="text-gray-300">– We use the following CICO problem, called SmallWeak1R-CICO, in our analysis: find i2, i3, i4, o2, o3, o<sup>4</sup> ∈ F<sup>p</sup> such that</p>

    <p class="text-gray-300"><span id="page-23-0"></span> <span class="math-block">\\mathtt{SmallWeak1R}(0, i_2, i_3, i_4) = (0, o_2, o_3, o_4). \\tag{13}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We suggest an arguably optimal model for SmallWeak1R-CICO, denoted by the same name, as a system of polynomial equations (see Appendix <a href="#page-42-0">B.3\\)</a>.</li>

      <li>For various small primes, we run actual GB computations on the model SmallWeak1R-CICO and observe that for these small-scale instances</li>

    </ul>

    <p class="text-gray-300"><span class="math-block">d_{\\text{solv}} \\ge d_{\\text{Mac}}/4</span> .</p>

    <p class="text-gray-300">– Extrapolating heuristically, we argue that the complexity of computing a Gröbner basis for SmallWeak1R-CICO, also for larger primes, is around</p>

    <p class="text-gray-300"><span id="page-23-1"></span> <span class="math-block">C_{\\rm GB}(n_v, d_{\\rm Mac}/4) = \\binom{n_v + d_{\\rm Mac}/4}{n_v}.</span>  (14)</p>

    <p class="text-gray-300"><span id="page-24-0"></span>Table 2. Results of Gröbner basis computations on several instances of SmallWeak1R-CICO, described in Eq. (13), for various small primes p, decomposition into m=2 buckets with bucket sizes  <span class="math">2^{s_1}</span> ,  <span class="math">2^{s_2}</span> , and extrapolation to 1R-CICO. Here,  <span class="math">n_e</span>  and  <span class="math">n_v</span>  denotes the number of equations and variables, respectively. The degree  <span class="math">d_{\\text{solv}}</span>  denotes the maximum degree reached during a GB computation with Magma. T is the runtime in microseconds  <span class="math">(10^{-6})</span> . For the complexity  <span class="math">\\mathcal{C}</span>  we use the estimate  <span class="math">\\mathcal{C} = \\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{Mac}}/4)</span> . Extrapolated estimates are in italic.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SmallWeak1R-CICO</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1R-CICO</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p_{\\rm Mers.}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p_{\\mathrm{Goldil.}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p_{\\rm Mers.}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p_{\\mathrm{Goldil.}}</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n_e, n_v</span></td>

            <td class="px-3 py-2 border-b border-gray-700">10, 10</td>

            <td class="px-3 py-2 border-b border-gray-700">10, 10</td>

            <td class="px-3 py-2 border-b border-gray-700">10, 10</td>

            <td class="px-3 py-2 border-b border-gray-700">10, 10</td>

            <td class="px-3 py-2 border-b border-gray-700">14, 14</td>

            <td class="px-3 py-2 border-b border-gray-700">22, 22</td>

            <td class="px-3 py-2 border-b border-gray-700">64,64</td>

            <td class="px-3 py-2 border-b border-gray-700">48, 48</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">s_i</span></td>

            <td class="px-3 py-2 border-b border-gray-700">2, 2</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 3</td>

            <td class="px-3 py-2 border-b border-gray-700">2, 4</td>

            <td class="px-3 py-2 border-b border-gray-700">4, 3</td>

            <td class="px-3 py-2 border-b border-gray-700">8,8,8,7</td>

            <td class="px-3 py-2 border-b border-gray-700">8,,8</td>

            <td class="px-3 py-2 border-b border-gray-700">8,8,8,7</td>

            <td class="px-3 py-2 border-b border-gray-700">8,,8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">u</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">d_{\\rm Mac}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">2294</td>

            <td class="px-3 py-2 border-b border-gray-700">4590</td>

            <td class="px-3 py-2 border-b border-gray-700">9177</td>

            <td class="px-3 py-2 border-b border-gray-700">9181</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">d_{\\rm solv}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">573</td>

            <td class="px-3 py-2 border-b border-gray-700">1147</td>

            <td class="px-3 py-2 border-b border-gray-700">2295</td>

            <td class="px-3 py-2 border-b border-gray-700">2296</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">d_{\\mathrm{Mac}}:d_{\\mathrm{solv}}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1.62</td>

            <td class="px-3 py-2 border-b border-gray-700">2.43</td>

            <td class="px-3 py-2 border-b border-gray-700">3.47</td>

            <td class="px-3 py-2 border-b border-gray-700">3.08</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\log_2 T</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16.5</td>

            <td class="px-3 py-2 border-b border-gray-700">21.5</td>

            <td class="px-3 py-2 border-b border-gray-700">25.5</td>

            <td class="px-3 py-2 border-b border-gray-700">30.5</td>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700"><u>-</u></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\log_2 \\mathcal{C}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">10.8</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">22.7</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">92.2</td>

            <td class="px-3 py-2 border-b border-gray-700">154</td>

            <td class="px-3 py-2 border-b border-gray-700">419.8</td>

            <td class="px-3 py-2 border-b border-gray-700">333.7</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the original, full-sized primes  <span class="math">p_{\\texttt{Goldilocks}}</span>  and  <span class="math">p_{\\texttt{Mersenne}}</span> , this yields a complexity estimate for solving SmallWeak1R-CICO via Gröbner basis techniques of  <span class="math">2^{154}</span>  operations in  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p=p_{\\texttt{Goldilocks}}</span> , and  <span class="math">2^{93}</span>  operations for  <span class="math">p=p_{\\texttt{Mersenne}}</span> . Compared to the generic CICO-security level of  <span class="math">2^{64}</span>  and  <span class="math">2^{31}</span>  function calls for  <span class="math">p_{\\texttt{Goldilocks}}</span>  and  <span class="math">p_{\\texttt{Mersenne}}</span> , respectively, our analysis suggests ample security margin against Gröbner basis attacks on SmallWeak1R-CICO.</p>

    <p class="text-gray-300">Based on the (heuristic) estimate presented in Eq. (14), we argue that one round of full Monolith given by 1R := Concrete  <span class="math">\\circ</span>  Bricks  <span class="math">\\circ</span>  Bars  <span class="math">\\circ</span>  Concrete provides ample security against Gröbner basis attacks as well. Intuitively, it is reasonable to assume that an increased state size and/or an increased field size do not make the attacks more efficient (given the same ratio of CICO constraints and Bar applications).</p>

    <p class="text-gray-300">In more detail, let 1R-CICO denote the following CICO-problem for 1R: find  <span class="math">I_1,O_2\\in\\mathbb{F}_p^{t-v}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">1R(\\mathbf{0}^v, I_1) = (\\mathbf{0}^v, O_2),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{0}^v</span>  denotes a v-tuple with all entries being zero. For  <span class="math">p_{\\texttt{Goldilocks}}</span> , we have t=12, v=4, and for  <span class="math">p_{\\texttt{Mersenne}}</span>  we have t=24, v=8. This amounts to a generic CICO-security level of  <span class="math">2^{256}</span>  and  <span class="math">2^{248}</span>  function calls, respectively. Extrapolating Eq. (14), we arrive at an estimated Gröbner basis complexity for 1R-CICO of  <span class="math">2^{334}</span>  operations in  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p=p_{\\texttt{Goldilocks}}</span> , and  <span class="math">2^{420}</span>  operations for  <span class="math">p=p_{\\texttt{Mersenne}}</span> . We summarize the results of our Gröbner basis analysis in Table 2.</p>

    <p class="text-gray-300"><strong>Discussion of Gröbner Basis Experiments.</strong> The results of our Gröbner basis experiments on small-scale instances of SmallWeak1R-CICO, described in Eq. (13), are depicted in Table 2. We conducted our experiments on a machine</p>

    <p class="text-gray-300"><span id="page-25-6"></span>with an Intel Xeon E5-2630 v3 @ 2.40 GHz (32 cores) and 378 GB RAM under Debian 11 using Magma V2.26-2.</p>

    <p class="text-gray-300">For the maximum degree  <span class="math">d_{\\text{solv}}</span>  reached during a Gröbner basis computation, we see that the ratio  <span class="math">d_{\\text{Mac}}</span> :  <span class="math">d_{\\text{solv}}</span>  is higher than 4. Moreover,  <span class="math">\\mathcal{C} = \\mathcal{C}_{\\text{GB}}(n_v, d_{\\text{Mac}}/4)</span>  can be seen as a lower bound for the actual computation time T.</p>

    <p class="text-gray-300">We also consider algebraic attacks working over the binary field  <span class="math">\\mathbb{F}_2</span> , due to the low degree of Bars in this setting. Here we demonstrate that the squaring operation of Bricks has a high degree as a multivariate polynomial over  <span class="math">\\mathbb{F}_2</span> .</p>

    <p class="text-gray-300">Since  <span class="math">\\lceil 2^{d-0.5} \\rceil</span>  is odd for d=15 and d=30, Lemma 2 implies the following bound on the degree of the squaring function over  <span class="math">\\mathbb{F}_2</span> .</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let  <span class="math">p \\in \\{p_{Mersenne}, p_{Goldilocks}\\}</span>  (7). Let  <span class="math">\\mathsf{F}_{sq}</span>  be an interpolant over  <span class="math">\\mathbb{F}_2^{\\lceil \\log_2 p \\rceil}</span>  of the squaring operation  <span class="math">\\mathcal{F}(x) = x^2</span>  over  <span class="math">\\mathbb{F}_p</span> . Then  <span class="math">\\mathsf{F}_{sq}</span>  has degree (multivariate over  <span class="math">\\mathbb{F}_2</span> ) at least d, where (i) d = 30 for  <span class="math">p = 2^{64} - 2^{32} + 1</span> , and (ii) d = 15 for  <span class="math">p = 2^{31} - 1</span> .</p>

    <p class="text-gray-300">Since Bars is of degree 2 over  <span class="math">\\mathbb{F}_2</span> , and since Concrete is a nonlinear function over a binary field, we claim that Monolith is secure against algebraic attacks instantiated over the binary field.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">7.1 Native Performance</h4>

    <p class="text-gray-300">We compare the performance of Monolith and competitors in Table 3. All benchmarks were taken on an AMD Ryzen 9 7900X CPU (singlethreaded, 4.7 GHz).</p>

    <p class="text-gray-300">We included implementations of Monolith into the framework in [IAI21], and also added instantiations of widely popular Poseidon [GKR+21], its modification Poseidon2 [GKS23], and also Griffin [GHR+23] with  <span class="math">p=2^{64}-2^{32}+1</span>  following their original instance generation scripts. We benchmark these hash functions with a state size of t=8 for the compression mode and of t=12 for the sponge mode in order to have a fair comparison. We also compare against Tip5 with its fixed state size of t=16 using the implementation from [SLS+23], and against Tip4', a faster instance of Tip5 with a fixed state size t=12, using the implementation from [Sal23]. We also compare against Reinforced Concrete instantiated with the scalar field of the BN254 curve, and against SHA3-256/SHA-256 as implemented in RustCrypto. The constant-time versions of Tip5 and Reinforced Concrete is our modification of the original code, which may not be optimized, thus it is given as an estimate.</p>

    <p class="text-gray-300"><span id="page-25-2"></span><sup>&</sup>lt;sup>9</sup> The source code is available at https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo/-/tree/master/plain\\_impls.</p>

    <p class="text-gray-300"><span id="page-25-3"></span> <span class="math">&lt;sup&gt;^{10}&lt;/sup&gt;</span>  https://github.com/Neptune-Crypto/twenty-first</p>

    <p class="text-gray-300"><span id="page-25-4"></span><sup>11</sup> https://github.com/Nashtare/winterfell</p>

    <p class="text-gray-300"><span id="page-25-5"></span><sup>12</sup> https://github.com/RustCrypto/hashes</p>

    <p class="text-gray-300"><span id="page-26-0"></span>Table 3. Native performance in nano seconds (ns) of different hash functions for variable and constant time implementations. Benchmarks are given for one permutation call, i.e., hashing ≈ 500 bits for all but SHA functions. Estimates are in italic.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hashing algorithm</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (ns)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Const. Time (ns)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2-to-1 sponge 2-to-1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">sponge</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p = 264 −<br>32 + 1:<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 12</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-64</td>

            <td class="px-3 py-2 border-b border-gray-700">129.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">210.5 148.5</td>

            <td class="px-3 py-2 border-b border-gray-700">230.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">1897.6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3288.7 2347.6</td>

            <td class="px-3 py-2 border-b border-gray-700">4059.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon2</td>

            <td class="px-3 py-2 border-b border-gray-700">944.6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1291.5 1149.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1617.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rescue-Prime</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12128.0 19095.0 12128</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">19095</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Griffin</td>

            <td class="px-3 py-2 border-b border-gray-700">1815.0</td>

            <td class="px-3 py-2 border-b border-gray-700">1988.4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tip5 (t = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">463.6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">500</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tip4′</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">247.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">p = 231 −<br>1:</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">t = 24 t = 16</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 24</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-31</td>

            <td class="px-3 py-2 border-b border-gray-700">210.3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">924.2 237.9</td>

            <td class="px-3 py-2 border-b border-gray-700">946.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">4478.8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8539.7 4372.9</td>

            <td class="px-3 py-2 border-b border-gray-700">8538.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon2</td>

            <td class="px-3 py-2 border-b border-gray-700">792.8</td>

            <td class="px-3 py-2 border-b border-gray-700">1257.4</td>

            <td class="px-3 py-2 border-b border-gray-700">840.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1355.3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">| Other:                      |           |                       |               |                  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reinforced Concrete (BN254)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1467.1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20000</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SHA-256</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">45.3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we compare Monolith-31 with Poseidon and Poseidon2 over the pMersenne prime field and state sizes of t = 16 and t = 24 (again for sponge and compression mode), as well as for a constant time implementation (constant time F<sup>p</sup> operations and no lookup tables). We see that Monolith-64 is significantly faster than any other arithmetization-oriented hash function. For example, the fastest one, i.e., Poseidon2, is slower by a factor 7.3 for t = 8. Tip4′ , the fastest lookup table based design, is also slower by a factor of 1.9 when using Monolith with the compression mode, and also slower by 36 ns compared to Monolith with the same state size t = 12.</p>

    <p class="text-gray-300">Most interestingly, the performance gap between arithmetization-friendly hash functions and traditional ones is now closed, with SHA3-256 being slower than Monolith-64 with t = 8 and only faster by 21 ns than Monolith-64 in the sponge mode with t = 12.</p>

    <p class="text-gray-300">Regarding Monolith-31 for the 31 bit Mersenne prime field we observe that we still get a fast native performance with 210 ns for t = 16. This is significantly faster than Tip5 which has the same state size, but is implemented with the larger 64 bit prime field. Only for t = 24 we observe a slower native performance which is due to the usage of a 32×32 circular MDS matrix in the Concrete layer, which we use to be able to implement it via a radix-2 FFT (see Note on MDS <span id="page-27-1"></span>Matrices below). However, competing designs, such as Tip5 also rely on MDS matrices and thus will either suffer from the same performance loss, or if they come up with better matrices/implementations, these can be used in Monolith-31 as well. Nonetheless, one can observe that Monolith-31 is still faster than the closest competitor for the same field and state size, i.e., Poseidon2, by 300 ns.</p>

    <p class="text-gray-300">Unlike other lookup-based designs, Monolith does not rely on lookup tables and its structure allows for constant-time implementations without significant performance loss. The binary  <span class="math">\\chi</span> -like layer can be efficiently implemented using a vectorized implementation that does not require an explicit (de-)composition, while unrolling the lookup-tables containing repeated power maps in Reinforced Concrete, Tip5, and Tip4' adds considerable workload to the computation. Thus, the overhead of going to a constant-time implementation only consists of supporting constant-time prime field arithmetic for Monolith, which can help in efficiently preventing side-channel attacks such as the ones proposed in [TBP20].</p>

    <p class="text-gray-300">Using a constant-time reduction leads to a slight slowdown in our comparison. However, the resulting runtimes are still significantly faster than the nonconstant-time runtimes of other circuit-friendly hash functions, such as Poseidon and Griffin, and Tip4' for t=8 and t=12. Moreover, a constant-time Monolith-64 in compression mode is still faster than SHA3-256 for t=8 (although we acknowledge the different security margin of the two constructions).</p>

    <p class="text-gray-300">Finally, for completeness, we give the runtime of each part of the Monolith permutation for both a constant- and variable-time version in Appendix C.</p>

    <p class="text-gray-300">Note on MDS Matrices. We use matrix multiplications based on fast Fourier transforms and circulant matrices for the linear layer of Monolith. For  <span class="math">t \\in \\{8, 12, 16\\}</span>  we use matrices whose dimensions correspond to the state size. However, for t = 24, we use a circulant matrix of dimension  <span class="math">32 \\times 32</span>  [HS24].<sup>13</sup> This allows us to efficiently employ a radix-2 algorithm. In more detail, if the input to the linear layer is  <span class="math">(x_1, \\ldots, x_{24})</span> , the output is defined by</p>

    <div class="my-4 text-center"><span class="math-block">(y_1, \\dots, y_{24})^T = \\text{Tr}_{24}(M \\times (x_1, \\dots, x_{24}, \\underbrace{0, \\dots, 0}_{\\text{8 zeroes}})^T),</span></div>

    <p class="text-gray-300">where  <span class="math">M \\in \\mathbb{F}^{32 \\times 32}</span>  and  <span class="math">\\operatorname{Tr}(\\cdot)_n</span>  yields the first n elements of the input. While the multiplication uses a  <span class="math">32 \\times 32</span>  MDS matrix, the final output will be the result of the multiplication by a  <span class="math">24 \\times 24</span>  (non-circulant) MDS matrix, since every submatrix of an MDS matrix is also MDS. This approach leads to an advantage of around 15% compared to the naive multiplication with a generic  <span class="math">24 \\times 24</span>  matrix.</p>

    <p class="text-gray-300">A modern zero-knowledge proof system defines arithmetization rules for the circuit it attempts to prove. Most new proof systems support the <em>Plonkish</em> arithmetization, where all input, output, and intermediate variables are put into a</p>

    <p class="text-gray-300"><span id="page-27-0"></span>We emphasize that it is unknown how to efficiently construct a  <span class="math">24 \\times 24</span>  circulant MDS matrix over  <span class="math">\\mathbb{F}_p</span>  for large p.</p>

    <p class="text-gray-300"><span id="page-28-1"></span><span id="page-28-0"></span><strong>Table 4.</strong> Plonkish arithmetization comparison for various 64-bit schemes. The numbers are for a single permutation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Primitive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lookups</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Nonlinear constraints</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Area-degree<br>product</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-64-compression</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">460</td>

            <td class="px-3 py-2 border-b border-gray-700">920</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-64-sponge</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">480</td>

            <td class="px-3 py-2 border-b border-gray-700">960</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tip5</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">380</td>

            <td class="px-3 py-2 border-b border-gray-700">2660</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Tip4'</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">360</td>

            <td class="px-3 py-2 border-b border-gray-700">2520</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon/Poseidon2 (sponge)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">826</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rescue-Prime (sponge)</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">672</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">witness matrix W with a fixed number of rows and columns. The data in each row is restricted by polynomial equations determining the values and computations used. One of these generic equations of degree 2 is  <span class="math">a_ix_1x_2 + b_ix_3 + c_ix_4 + d_i = 0</span> , where  <span class="math">a_i, b_i, c_i, d_i</span>  are public constants for the i-th row [GWC19]. The Plonkish arithmetization allows for different tradeoffs w.r.t. the number of columns, variables being used, and the final degrees. Additionally, various tuples within a row may be constrained to a set of values in a predefined table  <span class="math">\\mathfrak{T}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A precise comparison of different arithmetizations is hard without implementing and testing. However, a significant part of the work is to construct s degree- <span class="math">\\rho</span>  polynomials for the witness columns and to prove that they satisfy the polynomial equations. The total work is then estimated as an element in  <span class="math">\\mathcal{O}(d \\cdot \\rho \\cdot s)</span> , where d is the maximum degree of a row polynomial. The cost of using table lookups for FRI-based schemes is currently equivalent to the use of a single polynomial of degree  $t = \\max\\{\\rho,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we give possible arithmetizations for translating Monolith into a set of Plonkish constraints and refer to Appendix D.1 for R1CS constraints. Our Plonkish arithmetization is designed to accommodate lookup constraints capable of efficiently looking up 8-bit values. If the proof system is able to use larger tables (e.g., 16-bit ones), then multiple lookup constraints can be combined into just one larger constraint, reducing the total number of constraints.</p>

    <p class="text-gray-300"><strong>Plonkish Arithmetization.</strong> Each composition Concrete  <span class="math">\\circ</span>  Bricks is described with t polynomial equations of degree 2. Then, for each Bar in the Bars layer, we enforce the correct relations with  <span class="math">x = \\sum_{i=1}^m 2^{\\sum_{j=1}^i s_j} x_i&#x27;</span>  and  <span class="math">y = \\sum_{i=1}^m 2^{\\sum_{j=1}^i s_j} y_i&#x27;</span> , while also making sure that the limbs in the decomposition correspond to field elements. For  <span class="math">p_{\\text{Goldilocks}}</span> , this means enforcing that either the least significant 32 bits of Bar's input are 0 or the most significant bits are not all 1, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">(x_4 2^{24} + x_3 2^{16} + x_2 2^8 + x_1)(x_8 2^{24} + x_7 2^{16} + x_6 2^8 + x_5 - z) = 0, \\quad z&#x27;(z - 2^{32} + 1) = 1.</span></div>

    <p class="text-gray-300">For  <span class="math">p_{\\texttt{Mersenne}} = \\texttt{Ox7ffffffff}</span>  we need to make sure that the combined values are  <span class="math">\\neq p</span> , which is equivalent to them not being  <span class="math">2^8 - 1</span>  (three) or  <span class="math">2^7 - 1</span>  (one), i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">(x_4 + x_3 + x_2 + x_1 - 2^7 - 3 \\cdot 2^8 + 4) \\cdot z&#x27; = 1.</span></div>

    <p class="text-gray-300">Table 5. Proving performance in Plonky2 using pGoldilocks and sponge mode.</p>

    <p class="text-gray-300"><span id="page-29-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Permutation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Size (kB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monolith-64-sponge</td>

            <td class="px-3 py-2 border-b border-gray-700">3.49</td>

            <td class="px-3 py-2 border-b border-gray-700">0.63</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">6.23</td>

            <td class="px-3 py-2 border-b border-gray-700">1.12</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe the application of s individual S-boxes with s lookup constraints (x1, y1), (x2, y2), . . . ,(xs, ys). These also include the range checks for each input which are also necessary for the correctness of the constraints above.</p>

    <p class="text-gray-300">Apart from 2s lookup variables per Bar, we define u variables at the output of the first Concrete layer (these are the inputs to the Bars layer) and t variables at the output of each of the following Concrete layers (except for the last one). The reason is that the variables after the first Concrete layer store linear relations in the input, and only the u variables entering the Bars layer are needed. For the last layer, the output variables can be used directly. In total, we have 6 · (2us + u) + 5t + u variables, where {u = 4, s = 8} for the pGoldilocks case and {u = 8, s = 4} for the pMersenne case (considering S-boxes of ≈ 8 bits).</p>

    <p class="text-gray-300">In Table <a href="#page-28-0">4</a> we compare the (non-optimized) arithmetization of Monolith with the ones of other 64-bit designs (see Appendix <a href="#page-45-0">D.2</a> for details). To achieve a fair comparison, we do not apply any constraint or witness optimization but try to follow the same approach. We see that both the number of lookups and constraints in Monolith is slightly larger than in Tip5 and Tip4', but the constraint degree is smaller by the factor of 3.5, which should result in an overall decrease of the prover time by a factor of at least 2 (estimated as area-degree product). This is reasonable since Tip5 and Tip4' are able to process more field elements with a permutation call. Poseidon, Poseidon2, and Rescue-Prime due to their comparably small witness size and no lookup tables are estimated to still provide faster proving performance, closely followed by Monolith-64 with its low-degree nonlinear layers. Again, we stress that these numbers are derived from non-optimized arithmetizations and are subject to change. For example, one can leverage the low degree of Monolith to reduce witness size by trading with a larger degree round function. We refer to Appendix <a href="#page-45-1">D.3</a> for details. Furthermore, these estimates are based on a simplified performance metric (areadegree-product) which does not consider every aspect of prover performance, and benchmarks in real proof systems might differ.</p>

    <p class="text-gray-300">Benchmarks in Plonky2. We implemented Monolith-64 in the Plonky2<a href="#page-29-1">14</a> proof system to verify the estimations of Table <a href="#page-28-0">4.</a> <a href="#page-29-2">15</a> Plonky2 uses FRI commitments and hence works well with small prime fields. Since it already comes with a custom gate of Poseidon in sponge mode (t = 12) where the entire gate is put into just one row of the trace, we implement Monolith-64-sponge with the same parameters. To highlight the main advantage of Monolith-64, namely its fast</p>

    <p class="text-gray-300"><span id="page-29-1"></span><sup>14</sup> <https://github.com/mir-protocol/plonky2></p>

    <p class="text-gray-300"><span id="page-29-2"></span><sup>15</sup> Our implementation is available at <https://github.com/HorizenLabs/monolith>.</p>

    <p class="text-gray-300">native performance, we benchmark proving a Monolith-64 permutation while using Monolith-64 as the hash function to build the Merkle trees. Similarly, we benchmark Poseidon when using Poseidon as the hash function (which is the default setting in Plonky2). The results can be seen in Table <a href="#page-29-0">5.</a> One can observe that since Monolith requires more witnesses than Poseidon and both gates use just one row in the trace, the resulting proof is larger. However, the combination of proving Monolith-64 while using it at as the Plonky2 hash function leads to half the prover and verifier runtime compared to Poseidon.</p>

    <p class="text-gray-300">This work was partially supported by a gift from the Ethereum foundation. Lorenzo Grassi is partially supported by the German Research foundation (DFG) within the framework of the Excellence Strategy of the Federal Government and the States – EXC 2092 CaSa – 39078197. Roman Walch was supported by the "DDAI" COMET Module within the COMET – Competence Centers for Excellent Technologies Programme, funded by the Austrian Federal Ministry for Transport, Innovation and Technology (bmvit), the Austrian Federal Ministry for Digital and Economic Affairs (bmdw), the Austrian Research Promotion Agency (FFG), the province of Styria (SFG) and partners from industry and academia. The COMET Programme is managed by FFG.</p>

    <p class="text-gray-300">Finally, we thank Nicholas Mainardi for helping with the implementation of Monolith in Plonky2 and for improving the efficiency of the gate. We also thank the anonymous Eurocrypt'24 Reviewers for their comments, especially for the observation regarding Eq. <a href="#page-12-0">\\(6\\)</a> which allows us to reduce the (longer) original proof of Proposition <a href="#page-11-1">1.</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-30-1"></span>[AAE+20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. "Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols". In: IACR Trans. Symmetric Cryptol. 2020.3 (2020), pp. 1–45 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-30-2"></span>[ACG+19] Martin R. Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, et al. "Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC". In: ASIACRYPT 2019. Vol. 11923. LNCS. 2019, pp. 371–397 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-30-0"></span>[AGR+16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. "MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity". In: ASIACRYPT 2016. Vol. 10031. LNCS. 2016, pp. 191–219 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2\\)</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-31-4"></span>[AJN14] Jean-Philippe Aumasson, Philipp Jovanovic, and Samuel Neves. "NORX: Parallel and Scalable AEAD". In: ESORICS 2014. Vol. 8713. LNCS. 2014, pp. 19–36 (cit. on p. <a href="#page-5-2">6\\)</a>.</li>

      <li><span id="page-31-7"></span>[AKM+22] Jean-Philippe Aumasson, Dmitry Khovratovich, Bart Mennink, and Porçu Quine. SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications. <https://eprint.iacr.org/2023/522>. 2022 (cit. on p. <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-31-3"></span>[Bal23] Balazs Komuves. hash-circuits. 2023. url: <a href="https://github.com/bkomuves/hash-circuits">https://github.com/</a> <a href="https://github.com/bkomuves/hash-circuits">bkomuves/hash-circuits</a> (visited on 10/06/2023) (cit. on p. <a href="#page-4-2">5\\)</a>.</li>

      <li><span id="page-31-1"></span>[BBC+23] Clémence Bouvier, Pierre Briaud, Pyrros Chaidos, Léo Perrin, Robin Salen, Vesselin Velichkov, et al. "New Design Techniques for Efficient Arithmetization-Oriented Hash Functions: Anemoi Permutations and Jive Compression Mode". In: CRYPTO 2023. Vol. 14083. LNCS. 2023, pp. 507–539 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-31-2"></span>[BBH+19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. "Scalable Zero Knowledge with No Trusted Setup". In: CRYPTO 2019. Vol. 11694. LNCS. 2019, pp. 701–732 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-31-0"></span>[BC23] Benedikt Bünz and Binyi Chen. "ProtoStar: Generic Efficient Accumulation/Folding for Special Sound Protocols". In: IACR Cryptol. ePrint Arch. (2023). <https://eprint.iacr.org/2023/620>, p. 620 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-31-8"></span>[BCC11] Christina Boura, Anne Canteaut, and Christophe De Cannière. "Higher-Order Differential Properties of Keccak and Luffa". In: FSE 2011. Vol. 6733. LNCS. 2011, pp. 252–269 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-31-10"></span>[BCD+20] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Gaëtan Leurent, et al. "Out of Oddity - New Cryptanalytic Techniques Against Symmetric Primitives Optimized for Integrity Proof Systems". In: CRYPTO 2020. Vol. 12172. LNCS. 2020, pp. 299–328 (cit. on p. <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-31-9"></span>[BCP23] Clémence Bouvier, Anne Canteaut, and Léo Perrin. "On the algebraic degree of iterated power functions". In: Des. Codes Cryptogr. 91.3 (2023), pp. 997–1033. doi: <a href="https://doi.org/10.1007/S10623-022-01136-X">10.1007/S10623- 022- 01136- X</a> (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-31-5"></span>[BDP+07] G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche. Sponge functions. In: Ecrypt Hash Workshop 2007, <a href="http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html">http://www.csrc.</a> <a href="http://www.csrc.nist.gov/pki/HashWorkshop/Public Comments/2007_May.html">nist.gov/pki/HashWorkshop/PublicComments/2007\\\\_May.html</a>. 2007 (cit. on p. <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-31-6"></span>[BDP+08] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. "On the Indifferentiability of the Sponge Construction". In: EUROCRYPT 2008. Vol. 4965. LNCS. 2008, pp. 181–197 (cit. on p. <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-31-11"></span>[BDP+11] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. Note on zero-sum distinguishers of Keccak-f. Available at</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><https://keccak.team/files/NoteZeroSum.pdf>. 2011 (cit. on p. <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-32-11"></span>[BDP+18] Guido Bertoni, Joan Daemen, Michaël Peeters, Gilles Van Assche, Ronny Van Keer, and Benoît Viguier. "KangarooTwelve: Fast Hashing Based on Keccak-p". In: ACNS 2018. Vol. 10892. LNCS. 2018, pp. 400–418 (cit. on p. <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-32-6"></span>[Ber05] Daniel J. Bernstein. Cache-timing attacks on AES. Avaiable at <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf">http://cr.yp.to/antiforgery/cachetiming- 20050414.pdf</a>. 2005 (cit. on p. <a href="#page-9-1">10\\)</a>.</li>

      <li><span id="page-32-5"></span>[BFM+16] Thierry P. Berger, Julien Francq, Marine Minier, and Gaël Thomas. "Extended Generalized Feistel Networks Using Matrix Representation to Propose a New Lightweight Block Cipher: Lilliput". In: IEEE Trans. Computers 65.7 (2016), pp. 2074–2089 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12\\)</a>.</li>

      <li><span id="page-32-10"></span>[BFS15] Magali Bardet, Jean-Charles Faugère, and Bruno Salvy. "On the Complexity of the F5 Gröbner Basis Algorithm". In: Journal of Symbolic Computation 70 (2015), pp. 49–70 (cit. on p. <a href="#page-22-3">23\\)</a>.</li>

      <li><span id="page-32-4"></span>[BMT13] Thierry P. Berger, Marine Minier, and Gaël Thomas. "Extended Generalized Feistel Networks Using Matrix Representation". In: SAC 2013. Vol. 8282. LNCS. 2013, pp. 289–305 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12\\)</a>.</li>

      <li><span id="page-32-7"></span>[BS90] Eli Biham and Adi Shamir. "Differential Cryptanalysis of DES-like Cryptosystems". In: CRYPTO 1990. Vol. 537. LNCS. 1990, pp. 2– 21 (cit. on p. <a href="#page-17-3">18\\)</a>.</li>

      <li><span id="page-32-8"></span>[BSV07] Thomas Baignères, Jacques Stern, and Serge Vaudenay. "Linear Cryptanalysis of Non Binary Ciphers". In: Selected Areas in Cryptography – SAC 2007. Vol. 4876. LNCS. 2007, pp. 184–211 (cit. on p. <a href="#page-17-3">18\\)</a>.</li>

      <li><span id="page-32-2"></span>[But22] Vitalik Buterin. What we want out of STARK signature aggregation. available at <https://t.ly/UZMKw>. 2022 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-32-0"></span>[CFG+22] Shumo Chu, Boyuan Feng, Brandon H. Gomes, Francisco Hernández Iglesias, and Todd Norton. MantaPay Protocol Specification. available at <a href="https://github.com/Manta-Network/spec/blob/main/manta-pay/spec.pdf">https://github.com/Manta- Network/spec/blob/</a> <a href="https://github.com/Manta-Network/spec/blob/main/manta-pay/spec.pdf">main/manta-pay/spec.pdf</a>. 2022 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-32-1"></span>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. "Fractal: Postquantum and Transparent Recursive Proofs from Holography". In: EUROCRYPT 2020. Vol. 12105. LNCS. 2020, pp. 769–793 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-32-3"></span>[Dae95] Joan Daemen. Cipher and hash function design strategies based on linear and differential cryptanalysis. Doctoral Dissertation. Available at <a href="https://cs.ru.nl/~joan/papers/JDA_Thesis_1995.pdf">https://cs.ru.nl/~joan/papers/JDA\\\\_Thesis\\\\_1995.</a> <a href="https://cs.ru.nl/~joan/papers/JDA_Thesis_1995.pdf">pdf</a>. 1995 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-9-1">10,</a> <a href="#page-15-5">16,</a> <a href="#page-23-2">24\\)</a>.</li>

      <li><span id="page-32-9"></span>[DGG+21] Christoph Dobraunig, Lorenzo Grassi, Anna Guinet, and Daniël Kuijsters. "Ciminion: Symmetric Encryption Based on Toffoli-Gates over Large Finite Fields". In: Advances in Cryptology - EURO-CRYPT 2021. Vol. 12697. LNCS. 2021, pp. 3–34 (cit. on p. <a href="#page-17-3">18\\)</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-33-8"></span>[DGV94] Joan Daemen, René Govaerts, and Joos Vandewalle. "Correlation Matrices". In: FSE 1994. Vol. 1008. LNCS. 1994, pp. 275–285 (cit. on p. <a href="#page-17-3">18\\)</a>.</li>

      <li><span id="page-33-7"></span>[DKR97] Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. "The Block Cipher Square". In: FSE 1997. Vol. 1267. LNCS. 1997, pp. 149–165 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-33-6"></span>[DR01] Joan Daemen and Vincent Rijmen. "The Wide Trail Design Strategy". In: Cryptography and Coding - IMA International Conference 2001. Vol. 2260. LNCS. 2001, pp. 222–238 (cit. on p. <a href="#page-11-2">12\\)</a>.</li>

      <li><span id="page-33-5"></span>[DR02] Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES - The Advanced Encryption Standard. Information Security and Cryptography. Available at <a href="https://cs.ru.nl/~joan/papers/JDA_VRI_Rijndael_2002.pdf">https://cs.ru.nl/~joan/papers/</a> <a href="https://cs.ru.nl/~joan/papers/JDA_VRI_Rijndael_2002.pdf">JDA\\\\_VRI\\\\_Rijndael\\\\_2002.pdf</a>. Springer, 2002 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-17-3">18\\)</a>.</li>

      <li><span id="page-33-3"></span>[EFG22] Liam Eagen, Dario Fiore, and Ariel Gabizon. "cq: Cached quotients for fast lookups". In: IACR Cryptol. ePrint Arch. (2022). <a href="https://eprint.iacr.org/2022/1763">https:</a> <a href="https://eprint.iacr.org/2022/1763">//eprint.iacr.org/2022/1763</a> (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-33-9"></span>[EGL+20] Maria Eichlseder, Lorenzo Grassi, Reinhard Lüftenegger, Morten Øygarden, Christian Rechberger, Markus Schofnegger, et al. "An Algebraic Attack on Ciphers with Low-Degree Round Functions: Application to Full MiMC". In: IACR Cryptol. ePrint Arch. (2020), p. 182 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-33-11"></span>[Fau99] Jean-Charles Faugère. "A New Efficient Algorithm for Computing Gröbner Bases (F4)". In: Journal of Pure and Applied Algebra 139 (1999), pp. 61–88. doi: <a href="https://doi.org/10.1016/S0022-4049(99">10.1016/S0022-4049\\(99\\)00005-5</a>00005-5) (cit. on p. <a href="#page-22-3">23\\)</a>.</li>

      <li><span id="page-33-10"></span>[FGL+93] Jean-Charles Faugère, Patrizia M. Gianni, Daniel Lazard, and Teo Mora. "Efficient Computation of Zero-Dimensional Gröbner Bases by Change of Ordering". In: J. Symb. Comput. 16.4 (1993), pp. 329– 344 (cit. on p. <a href="#page-22-3">23\\)</a>.</li>

      <li><span id="page-33-2"></span>[Fou22] Ethereum Foundation. ZKEVM Introduction. <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md">https://github.</a> <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md">com / privacy - scaling - explorations / zkevm - specs / blob /</a> <a href="https://github.com/privacy-scaling-explorations/zkevm-specs/blob/master/specs/introduction.md">master/specs/introduction.md</a>. 2022 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-33-1"></span>[GHR+23] Lorenzo Grassi, Yonglin Hao, Christian Rechberger, Markus Schofnegger, Roman Walch, and Qingju Wang. "Horst Meets Fluid-SPN: Griffin for Zero-Knowledge Applications". In: CRYPTO 2023. Vol. 14083. LNCS. 2023, pp. 573–606 (cit. on pp. <a href="#page-1-1">2,</a> <a href="#page-13-2">14,</a> <a href="#page-25-6">26,</a> <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-33-4"></span>[GKL+22] Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. "Reinforced Concrete: A Fast Hash Function for Verifiable Computation". In: ACM CCS. 2022, pp. 1323–1335 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5\\)</a>.</li>

      <li><span id="page-33-0"></span>[GKR+21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. "Poseidon: A New Hash Function for Zero-Knowledge Proof Systems". In: USENIX Security Symposium. USENIX Association, 2021, pp. 519–535 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2,</a> <a href="#page-3-1">4,</a> <a href="#page-25-6">26,</a> <a href="#page-44-2">45\\)</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-34-10"></span>[GKR+22] Lorenzo Grassi, Dmitry Khovratovich, Sondre Rønjom, and Markus Schofnegger. "The Legendre Symbol and the Modulo-2 Operator in Symmetric Schemes over Fnp Preimage Attack on Full Grendel". In: IACR Trans. Symmetric Cryptol. 2022.1 (2022), pp. 5–37 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-34-2"></span>[GKS23] Lorenzo Grassi, Dmitry Khovratovich, and Markus Schofnegger. "Poseidon2: A Faster Version of the Poseidon Hash Function". In: AFRICACRYPT 2023. Vol. 14064. LNCS. 2023, pp. 177–203 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-13-2">14,</a> <a href="#page-25-6">26\\)</a>.</li>

      <li><span id="page-34-12"></span>[GLL+20] Jian Guo, Guohong Liao, Guozhen Liu, Meicheng Liu, Kexin Qiao, and Ling Song. "Practical Collision Attacks against Round-Reduced SHA-3". In: J. Cryptol. 33.1 (2020), pp. 228–270 (cit. on p. <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-34-5"></span>[Gra23] Lorenzo Grassi. "Bounded Surjective Quadratic Functions over F n p for MPC-/ZK-/FHE-Friendly Symmetric Primitives". In: IACR Trans. Symmetric Cryptol. 2023.2 (2023), pp. 94–131 (cit. on pp. <a href="#page-3-1">4,</a> <a href="#page-11-2">12\\)</a>.</li>

      <li><span id="page-34-8"></span>[GRS21] Lorenzo Grassi, Christian Rechberger, and Markus Schofnegger. "Proving Resistance Against Infinitely Long Subspace Trails: How to Choose the Linear Layer". In: IACR Trans. Symmetric Cryptol. 2021.2 (2021), pp. 314–352 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-34-9"></span>[GSW+21] Chun Guo, François-Xavier Standaert, Weijia Wang, Xiao Wang, and Yu Yu. "Provable Security of SP Networks with Partial Non-Linear Layers". In: IACR Trans. Symmetric Cryptol. 2021.2 (2021), pp. 353–388 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-34-1"></span>[GW20] Ariel Gabizon and Zachary J. Williamson. "plookup: A simplified polynomial protocol for lookup tables". In: IACR Cryptol. ePrint Arch. (2020) (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-34-0"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge. Cryptology ePrint Archive, Report 2019/953. 2019 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-28-1">29\\)</a>.</li>

      <li><span id="page-34-4"></span>[Hab23] Ulrich Haböck. Brakedown's expander code. Cryptology ePrint Archive, Paper 2023/769. <https://eprint.iacr.org/2023/769>. 2023 (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-34-3"></span>[HLN23] Ulrich Haböck, Daniel Lubarov, and Jacqueline Nabaglo. Reed-Solomon Codes over the Circle Group. Cryptology ePrint Archive, Paper 2023/824. <https://eprint.iacr.org/2023/824>. 2023 (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-34-6"></span>[HR10] Viet Tung Hoang and Phillip Rogaway. "On generalized Feistel networks". In: Annual Cryptology Conference. Springer. 2010, pp. 613– 630 (cit. on pp. <a href="#page-11-2">12,</a> <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-34-7"></span>[HS24] Ulrich Haböck and Markus Schofnegger. "Efficient MDS Matrices from Linear Codes". In preparation. 2024 (cit. on pp. <a href="#page-16-2">17,</a> <a href="#page-27-1">28\\)</a>.</li>

      <li><span id="page-34-11"></span>[IAI21] IAIK. Hash functions for Zero-Knowledge applications Zoo. <a href="https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo">https:</a> <a href="https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo">//extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo</a>. IAIK, Graz University of Technology. Aug. 2021 (cit. on p. <a href="#page-25-6">26\\)</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-35-10"></span>[JK97] Thomas Jakobsen and Lars R. Knudsen. "The Interpolation Attack on Block Ciphers". In: FSE 1997. Vol. 1267. LNCS. 1997, pp. 28–40 (cit. on p. <a href="#page-21-0">22\\)</a>.</li>

      <li><span id="page-35-4"></span>[KBM23] Dmitry Khovratovich, Mario Marhuenda Beltrán, and Bart Mennink. "Generic Security of the SAFE API and Its Applications". In: IACR Cryptol. ePrint Arch. (2023). to appear at ASIACRYPT'23, p. 520 (cit. on p. <a href="#page-13-2">14\\)</a>.</li>

      <li><span id="page-35-1"></span>[KMT22] Dmitry Khovratovich, Mary Maller, and Pratyush Ranjan Tiwari. "MinRoot: Candidate Sequential Function for Ethereum VDF". In: IACR Cryptol. ePrint Arch. (2022) (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-35-6"></span>[Knu94] Lars R. Knudsen. "Truncated and Higher Order Differentials". In: FSE 1994. Vol. 1008. LNCS. 1994, pp. 196–211 (cit. on pp. <a href="#page-18-1">19,</a> <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-35-5"></span>[KR07] Lars R. Knudsen and Vincent Rijmen. "Known-Key Distinguishers for Some Block Ciphers". In: Advances in Cryptology - ASI-ACRYPT 2007. Vol. 4833. LNCS. 2007, pp. 315–324 (cit. on p. <a href="#page-16-2">17\\)</a>.</li>

      <li><span id="page-35-2"></span>[KS23] Abhiram Kothapalli and Srinath T. V. Setty. "HyperNova: Recursive arguments for customizable constraint systems". In: IACR Cryptol. ePrint Arch. (2023). <a href="https://eprint.iacr.org/2023/573">https://eprint.iacr.org/2023/</a> <a href="https://eprint.iacr.org/2023/573">573</a>, p. 573 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-35-0"></span>[KST22] Abhiram Kothapalli, Srinath T. V. Setty, and Ioanna Tzialla. "Nova: Recursive Zero-Knowledge Arguments from Folding Schemes". In: CRYPTO 2022. Vol. 13510. LNCS. 2022, pp. 359–388 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-35-7"></span>[LAA+11] Gregor Leander, Mohamed Ahmed Abdelraheem, Hoda AlKhzaimi, and Erik Zenner. "A Cryptanalysis of PRINTcipher: The Invariant Subspace Attack". In: CRYPTO 2011. Vol. 6841. LNCS. 2011, pp. 206–221 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-35-3"></span>[Lai94] Xuejia Lai. "Higher Order Derivatives and Differential Cryptanalysis". In: Communications and Cryptography: Two Sides of One Tapestry. Springer US, 1994, pp. 227–233 (cit. on p. <a href="#page-10-2">11\\)</a>.</li>

      <li><span id="page-35-11"></span>[Laz79] Daniel Lazard. "Systems of Algebraic Equations". In: International Symposium on Symbolic and Algebraic Computation - EUROSAM 1979. Ed. by Edward W. Ng. Vol. 72. Lecture Notes in Computer Science. Springer, 1979, pp. 88–94 (cit. on p. <a href="#page-22-3">23\\)</a>.</li>

      <li><span id="page-35-12"></span>[Laz83] Daniel Lazard. "Gröbner Bases, Gaussian Elimination and Resolution of Systems of Algebraic Equations". In: European Conference on Computer Algebra - EUROCAL 1983. Ed. by J. A. van Hulzen. Vol. 162. Lecture Notes in Computer Science. Springer, 1983, pp. 146–156 (cit. on p. <a href="#page-22-3">23\\)</a>.</li>

      <li><span id="page-35-8"></span>[LMR15] Gregor Leander, Brice Minaud, and Sondre Rønjom. "A Generic Approach to Invariant Subspace Attacks: Cryptanalysis of Robin, iSCREAM and Zorro". In: EUROCRYPT 2015. Vol. 9056. LNCS. 2015, pp. 254–283 (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-35-9"></span>[LP19] Chaoyun Li and Bart Preneel. "Improved Interpolation Attacks on Cryptographic Primitives of Low Algebraic Degree". In: Selected</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Areas in Cryptography SAC 2019 26th International Conference, Waterloo, ON, Canada, August 12-16, 2019, Revised Selected Papers. Ed. by Kenneth G. Paterson and Douglas Stebila. Vol. 11959. Lecture Notes in Computer Science. Springer, 2019, pp. 171–193. doi: <a href="https://doi.org/10.1007/978-3-030-38471-5\\_8">10.1007/978-3-030-38471-5\\\\\\_8</a> (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-36-8"></span>[Mat93] Mitsuru Matsui. "Linear Cryptanalysis Method for DES Cipher". In: EUROCRYPT 1993. Vol. 765. LNCS. 1993, pp. 386–397 (cit. on p. <a href="#page-17-3">18\\)</a>.</li>

      <li><span id="page-36-9"></span>[MRS+09] Florian Mendel, Christian Rechberger, Martin Schläffer, and Søren S. Thomsen. "The Rebound Attack: Cryptanalysis of Reduced Whirlpool and Grøstl". In: FSE 2009. Vol. 5665. LNCS. 2009, pp. 260–276 (cit. on p. <a href="#page-18-1">19\\)</a>.</li>

      <li><span id="page-36-11"></span>[Nat15] National Institute of Standards and Technology. "SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions". In: Federal Information Processing Standards Publication (FIPS) (202 2015) (cit. on p. <a href="#page-44-2">45\\)</a>.</li>

      <li><span id="page-36-7"></span>[OST06] Dag Arne Osvik, Adi Shamir, and Eran Tromer. "Cache Attacks and Countermeasures: The Case of AES". In: CT-RSA 2006. Vol. 3860. LNCS. 2006, pp. 1–20 (cit. on p. <a href="#page-9-1">10\\)</a>.</li>

      <li><span id="page-36-6"></span>[Pag02] D. Page. Theoretical Use of Cache Memory as a Cryptanalytic Side-Channel. Cryptology ePrint Archive. <a href="https://eprint.iacr.org/2002/169">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2002/169">2002/169</a>. 2002 (cit. on p. <a href="#page-9-1">10\\)</a>.</li>

      <li><span id="page-36-3"></span>[PH23] Shahar Papini and Ulrich Haböck. "Improving logarithmic derivative lookups using GKR". In: IACR Cryptol. ePrint Arch. (2023). <https://eprint.iacr.org/2023/1284> (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-36-4"></span>[Pol22a] Polygon. Introducing Plonky2. 2022 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5\\)</a>.</li>

      <li><span id="page-36-1"></span>[Pol22b] Polygon. zkEVM Documentation. <a href="https://docs.hermez.io/zkEVM/Overview/Overview/">https : / / docs . hermez . io /</a> <a href="https://docs.hermez.io/zkEVM/Overview/Overview/">zkEVM/Overview/Overview/</a>. 2022 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-36-5"></span>[Pol23] Polygon. Plonky3. 2023. url: <a href="https://github.com/Plonky3/Plonky3">https : / / github . com / Plonky3 /</a> <a href="https://github.com/Plonky3/Plonky3">Plonky3</a> (visited on 06/12/2023) (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-36-0"></span>[PSS19] Alexey Pertsev, Roman Semenov, and Roman Storm. Tornado Cash Privacy Solution Version 1.4. available at <a href="https://t.ly/ys_pW">https://t.ly/ys\\\\_pW</a>. 2019 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-36-10"></span>[RAS20] Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer. "Interpolation Cryptanalysis of Unbalanced Feistel Networks with Low Degree Round Functions". In: Selected Areas in Cryptography - SAC 2020 - 27th International Conference, Halifax, NS, Canada (Virtual Event), October 21-23, 2020, Revised Selected Papers. Ed. by Orr Dunkelman, Michael J. Jacobson Jr., and Colin O'Flynn. Vol. 12804. Lecture Notes in Computer Science. Springer, 2020, pp. 273–300. doi: <a href="https://doi.org/10.1007/978-3-030-81652-0\\_11">10 . 1007 / 978 - 3 - 030 - 81652 - 0 \\ \\\\_11</a> (cit. on p. <a href="#page-19-3">20\\)</a>.</li>

      <li><span id="page-36-2"></span>[RIS23a] Jeremy Bruestle (RISC0). private communication. 2023 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-37-7"></span>[RIS23b] RISC Zero. RISC Zero : General-Purpose Verifiable Computing. 2023 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5\\)</a>.</li>

      <li><span id="page-37-2"></span>[SAD20] Alan Szepieniec, Tomer Ashur, and Siemen Dhooghe. Rescue-Prime: a Standard Specification (SoK). Cryptology ePrint Archive, Report 2020/1143. 2020 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-37-10"></span>[Sal23] Robin Salen. Two additional instantiations from the Tip5 hash function construction. <a href="https://toposware.com/paper_tip5.pdf">https://toposware.com/paper\\\\_tip5.pdf</a>. 2023 (cit. on p. <a href="#page-25-6">26\\)</a>.</li>

      <li><span id="page-37-6"></span>[SLS+23] Alan Szepieniec, Alexander Lemmens, Jan Ferdinand Sauer, Bobbin Threadbare, and Al-Kindi. The Tip5 Hash Function for Recursive STARKs. Cryptology ePrint Archive, Paper 2023/107. <a href="https://eprint.iacr.org/2023/107">https:</a> <a href="https://eprint.iacr.org/2023/107">//eprint.iacr.org/2023/107</a>. 2023 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-4-2">5,</a> <a href="#page-16-2">17,</a> <a href="#page-25-6">26\\)</a>.</li>

      <li><span id="page-37-4"></span>[STW23] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. "Unlocking the lookup singularity with Lasso". In: IACR Cryptol. ePrint Arch. (2023). <https://eprint.iacr.org/2023/1216> (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-37-9"></span>[TBP20] Florian Tramèr, Dan Boneh, and Kenny Paterson. "Remote Side-Channel Attacks on Anonymous Transactions". In: USENIX Security Symposium. USENIX Association, 2020, pp. 2739–2756 (cit. on pp. <a href="#page-9-1">10,</a> <a href="#page-27-1">28\\)</a>.</li>

      <li><span id="page-37-1"></span>[Val08] Paul Valiant. "Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency". In: TCC 2008. Vol. 4948. LNCS. 2008, pp. 1–18 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-37-5"></span>[ZBK+22] Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. "Caulk: Lookup Arguments in Sublinear Time". In: CCS. ACM, 2022, pp. 3121–3134 (cit. on p. <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-37-0"></span>[ZGK+22] Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Ràfols. Baloo: Nearly Optimal Lookup Arguments. Cryptology ePrint Archive. <https://eprint.iacr.org/2022/1565>. 2022 (cit. on pp. <a href="#page-0-0">1,</a> <a href="#page-2-1">3\\)</a>.</li>

      <li><span id="page-37-3"></span>[Zha22] Ye Zhang. Introducing zkEVM. <https://scroll.io/blog/zkEVM>. 2022 (cit. on p. <a href="#page-1-1">2\\)</a>.</li>

      <li><span id="page-37-8"></span>[ZMI89] Yuliang Zheng, Tsutomu Matsumoto, and Hideki Imai. "On the Construction of Block Ciphers Provably Secure and Not Relying on Any Unproved Hypotheses". In: CRYPTO 1989. Vol. 435. LNCS. 1989, pp. 461–480 (cit. on pp. <a href="#page-2-1">3,</a> <a href="#page-11-2">12\\)</a>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1<br>Hash Functions in Zero-Knowledge Frameworks</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.2<br>Our Contributions</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Fast and Circuit-Friendly Functions over Fp<br></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.1<br>Chunks and Buckets</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.2<br>The Kintsugi Bar</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.3<br>Well-Definition and Bijectivity</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.4<br>Considerations about the Kintsugi Strategy</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.5<br>Statistical and Algebraic Properties</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Feistel Type-3 Layer and the Wide Trail Strategy</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">Specification of Monolith</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1<br>Modes of Operation</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.2<br>Permutation Structure</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.3<br>Bars</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.4<br>Bricks</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.5<br><br>Concrete</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.6<br>Number of Rounds and Security Claims</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.7<br>Security Analysis</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Security Analysis: Statistical Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1<br>(Truncated) Differential and Linear Cryptanalysis</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2<br>Rebound Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.3<br>Other Statistical Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">19</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Security Analysis: Algebraic Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.1<br>Degree of the Bars Polynomials</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.2<br>Security against Algebraic Attacks via Bars</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6.3<br>Solving the Multivariate CICO Problem with Gröbner Bases</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Algebraic Attacks over F2<br>6.4<br></td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Performance Evaluation</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.1<br>Native Performance</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.2<br>Performance in Proof Systems</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Fast Reduction for Special Primes</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2 −<br>A.1<br>Fast Reduction for Primes of the Form ϕ<br>ϕ + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ρ −<br>A.2<br>Fast Reduction for Primes of the Form 2<br>1</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.3<br>Generation of Round Constants</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">Security Analysis – Additional Material</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.1<br>Rebound Collision Attack on the 3-Round (Weakened) Monolith</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.2<br>Degree and Density: Practical Results</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.3<br>Details about GB Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.4<br>Non-Applicable Attacks</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">Benchmarks of Different Round Functions</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">Arithmetization Details</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D.1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1CS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">45</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Circuits for Other Hash Functions</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Multiround Constraints for Monolith</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">A.1 Fast Reduction for Primes of the Form ϕ <sup>2</sup> − ϕ + 1</h4>

    <p class="text-gray-300">Here we describe the fast reduction modulo a prime number of the form ϕ <sup>2</sup>−ϕ+1. Note that this includes p = 2<sup>64</sup> −2 <sup>32</sup> + 1, where ϕ = 232. We focus on the case of a multiplication, where two n-bit inputs result in an output of at most 2n bits.</p>

    <p class="text-gray-300">Given F<sup>p</sup> for p = ϕ <sup>2</sup> − ϕ + 1, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\phi^2 = \\phi - 1 \\implies \\phi^3 = \\phi^2 - \\phi = -1.</span></div>

    <p class="text-gray-300">Now, let us write a value x to be reduced as</p>

    <div class="my-4 text-center"><span class="math-block">x = x_0 + \\phi^2 x_1 + \\phi^3 x_2,</span></div>

    <p class="text-gray-300">where x<sup>0</sup> ∈ Z2<sup>n</sup> and x1, x<sup>2</sup> ∈ Z2n/<sup>2</sup> . Then</p>

    <div class="my-4 text-center"><span class="math-block">x = x_0 + (\\phi - 1)x_1 - x_2 \\pmod{p},</span></div>

    <p class="text-gray-300">where note that log<sup>2</sup> (x<sup>0</sup> + (ϕ − 1)x<sup>1</sup> − x2) ≈ log<sup>2</sup> (p). This reduction can be computed using only a small number of additions and subtractions.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">A.2 Fast Reduction for Primes of the Form 2 <sup>ρ</sup> − 1</h4>

    <p class="text-gray-300">Here we describe the fast reduction modulo a prime number of the form 2 <sup>ρ</sup> − 1 which includes p = 2<sup>31</sup> − 1. We focus on the case of a multiplication, where two ρ-bit inputs result in an output of at most 2ρ bits.</p>

    <p class="text-gray-300">Given F<sup>p</sup> for p = 2<sup>ρ</sup> − 1, it follows that 2 <sup>ρ</sup> = 1 + p. Now, let us write a value x to be reduced as</p>

    <div class="my-4 text-center"><span class="math-block">x = x_0 + 2^{\\rho} x_1,</span></div>

    <p class="text-gray-300">where x<sup>0</sup> ∈ Z<sup>2</sup> <sup>ρ</sup> and x<sup>1</sup> ∈ Fp. Then</p>

    <div class="my-4 text-center"><span class="math-block">x = x_0 + x_1 + \\underbrace{(2^{\\rho} - 1) \\cdot x_1}_{=0 \\pmod{p}} = x_0 + x_1 \\pmod{p}.</span></div>

    <p class="text-gray-300">This reduction can be computed using only a small number of additions and binary shifts.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">A.3 Generation of Round Constants</h4>

    <p class="text-gray-300">The round constants  <span class="math">c_1^{(i)}, c_2^{(i)}, \\ldots, c_t^{(i)}</span>  for the i-th round are generated using the well-known approach of seeding a pseudo-random number generator and reading its output stream. In particular, we use SHAKE-128 with rejection sampling, i.e., we discard elements which are not in  <span class="math">\\mathbb{F}_p</span> . SHAKE-128, thereby, is seeded with the initial seed "Monolith" followed by the state size t and number of rounds R, each represented as one byte, the prime p represented by  <span class="math">\\lceil \\log_2(p)/8 \\rceil</span>  bytes in little endian representation, and the decomposition sizes in the bar layer, where each  <span class="math">s_i</span>  is represented as one byte. As concrete examples, the seed is</p>

    <p class="text-gray-300">b'Monolith\\x08\\x06\\x01\\x00\\x00\\x0f\\xff\\xff\\xff\\xff\\xff\\xff\\xff</p>

    <p class="text-gray-300">for Monolith-64 with t = 8 and R = 6, and</p>

    <p class="text-gray-300"> <span class="math">b&#x27;Monolith\\\\x10\\\\x06\\\\xff\\\\xff\\\\xff\\\\x7f\\\\x08\\\\x08\\\\x08\\\\x07&#x27;</span></p>

    <p class="text-gray-300">for Monolith-31 with t = 16 and R = 6.</p>

    <p class="text-gray-300">The best rebound attack that we have found is a near-collision attack on the reduced 3-round permutation without the Bars layer. We show how to find a state that satisfies a differential  <span class="math">\\Delta_1 \\to \\Delta_8</span>  for certain  <span class="math">\\Delta_1, \\Delta_8</span>  which are equal in the last  <span class="math">\\mathbb{F}_p</span>  word, i.e.,  <span class="math">\\Delta_{1,t} = \\Delta_{8,t}</span> . As a concrete application, this yields a zero difference in this word for the compression function  <span class="math">x \\mapsto \\operatorname{Tr}_{t/2}(\\mathcal{P}(x) + x)</span> , which is a near-collision.</p>

    <p class="text-gray-300">The inbound phase covers 3 layers of Bricks separated by 2 Concrete layers:</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_1 \\xleftarrow{\\mathsf{Concrete}}_{t \\to 1} \\Delta_2 \\xleftarrow{\\mathsf{Bricks}}_{1} \\underbrace{\\Delta_3 \\xrightarrow{\\mathsf{Concrete}}_{1 \\to t} \\Delta_4 \\xleftarrow{\\mathsf{Bricks}}_{t \\to 1} \\Delta_5 \\xrightarrow{\\mathsf{Concrete}}_{t \\leftarrow 2} \\Delta_6 \\xrightarrow{\\mathsf{Bricks}}_{2} \\Delta_7}_{\\text{inbound phase}} \\xrightarrow{\\mathsf{Concrete}}_{2 \\to t} \\Delta_8.</span></div>

    <p class="text-gray-300">To find such a state pair, we apply the following approach.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. In the inbound phase we arbitrarily choose  <span class="math">\\delta</span>  and set  <span class="math">\\Delta_3 = [0, 0, \\dots, 0, \\delta]</span>  such that its nonzero difference is in the last word only and propagates through  <span class="math">\\mathtt{Bricks}^{-1}</span>  untouched. That is,  <span class="math">\\Delta_2 = \\Delta_3</span> . Let  <span class="math">\\Delta_1</span>  be  <span class="math">\\mathtt{Concrete}^{-1}(\\Delta_2)</span> .</li>

      <li>2. The inbound phase covers the expansion of  <span class="math">\\Delta_2</span>  to t words and back to the 2-word difference  <span class="math">\\Delta_7 = [0,0,\\ldots,0,\\delta_2,\\delta_3]</span> . Note that we have  <span class="math">\\Delta_6 = [0,0,\\ldots,0,\\delta_2,\\delta_4]</span> . We arbitrarily set  <span class="math">\\delta_2,\\delta_3</span>  such that  <span class="math">\\Delta_{8,t} = \\Delta_{1,t}</span>  and then choose  <span class="math">\\delta_4</span>  such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{Concrete}(\\Delta_2) = \\Delta_{4,1} = \\Delta_{5,1} = \\mathtt{Concrete}^{-1}(\\Delta_6).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As a result, the differential path for the full 3-round scheme is established, and we determine the state. The  <span class="math">(\\delta_3, \\delta_4)</span>  differential determines the input word  <span class="math">x_{t-1}</span>  of the third Bricks layer, and the equation</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Bricks(\\mathbf{X} + \\Delta_4) = Bricks(\\mathbf{X}) + \\Delta_5.</span></div>

    <p class="text-gray-300">determines input words  <span class="math">x_1, x_2, \\ldots, x_{t-1}</span>  of the second Bricks layer. Note that this is a system of linear equations, and by solving it we can determine the full state.</p>

    <p class="text-gray-300">Overall we obtain a partial collision at a negligible cost (the cost for solving the linear system of equations can be approximated by  <span class="math">\\Omega(t^3)</span> , which is much smaller than the cost for constructing the collision in the case of a random permutation approximated by  <span class="math">p^{1/2}</span> ). We are not aware of any possible extension of such attack to more rounds and/or including Bars, which is left as an open problem for future work.</p>

    <h2 id="sec-42" class="text-2xl font-bold">B.2 Degree and Density: Practical Results</h2>

    <p class="text-gray-300">Evaluating the actual density of the polynomial resulting from Bar applied to a single field element in  <span class="math">\\mathbb{F}_p</span> , where  <span class="math">p \\in \\{2^{64} - 2^{32} + 1, 2^{31} - 1\\}</span> , is infeasible in practice. Indeed, any enumeration and subsequent interpolation approach would take far too long.</p>

    <p class="text-gray-300">Therefore, in our experiments we focus on smaller finite fields defined by "similar" prime numbers. In particular, we focus on n-bit primes of the form  <span class="math">2^n - 2^{\\eta} + 1</span>  for  <span class="math">\\eta</span>  as close to n as possible. We then apply the S-box  <span class="math">S_i</span>  to smaller parts of the field element, exactly as in Bar where the S-box is applied to each 8-bit part of the larger field element. We also vary the sizes of the parts to which the  <span class="math">S_i</span>  are applied in order to get a broader picture.</p>

    <p class="text-gray-300">The results of our evaluation are shown in Table 6. For example, in the first case, where  <span class="math">p=2^8-2^4+1</span> ,  <span class="math">S_i</span>  is applied to the first 4 bits (starting from the least significant bit) and then to the next 4 bits, covering the entire field element. The size of these parts is indicated in the second column. As we can see, the maximum degree is reached for all tested primes of the form  <span class="math">2^n-2^{\\eta}+1</span> , where  <span class="math">\\eta&gt;1</span> . Moreover, for these primes, the density is always close to 100%, mostly matching it. We also applied  <span class="math">S_i</span>  to elements of  <span class="math">\\mathbb{F}_{2^n-1}</span>  directly, where  <span class="math">n \\in \\{5,7,13\\}</span> , which resulted in almost maximum-degree polynomials of low density (specifically, only 6, 18, and 629 monomials exist in the polynomial representation, respectively). This suggests that increasing the number of S-box applications per field element (i.e., increasing the number of smaller parts to which  <span class="math">S_i</span>  are applied) is beneficial for the density of the resulting polynomial.</p>

    <p class="text-gray-300">We also evaluated the degrees and density values resulting from the inverse S-boxes applied to the field elements, in order to get an estimation of the algebraic strength of the inverse operation. The results match the results given in Table 6, where always more than 99% monomials are reached together with a degree close to the maximum.</p>

    <p class="text-gray-300"><span id="page-42-1"></span><strong>Table 6.</strong> Degree and density of the polynomials resulting from Bar applied to various field elements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\overline{p}</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bit splittings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Density</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^8 - 2^4 + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{4, 4\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">239 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">100%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{13} - 2^8 + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{8,5\\}, \\{4,4,5\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">7935 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">>99% (7934/7935)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{13} - 2^5 + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{5,8\\},\\{5,4,4\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">8159 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">>99% (8157/8159)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{14} - 2^{10} + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{10,4\\},\\{5,5,4\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">15359 \\ (= p - 2)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">&gt;99\\% \\ (15358/15359)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{14} - 2^4 + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{4, 10\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16367 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">100%</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{14} - 2^4 + 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{4, 5, 5\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">16367 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">&gt;99\\% \\ (16364/16367)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{13}-1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">{5,8}, {8,5}, {4,9}, {9,4}</td>

            <td class="px-3 py-2 border-b border-gray-700">8189 (= p - 2)</td>

            <td class="px-3 py-2 border-b border-gray-700">> 99% (8188/8189)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^7 - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{3,4\\},\\{4,3\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">125 \\ (= p - 2)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">>99% (124/125)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">{2^5-1}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">26 \\ (= p - 5)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 21\\% \\ (6/29)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^7 - 1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">_</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">120 \\ (= p - 7)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 14\\% \\ (18/125)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{13}-1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">8178 \\ (= p - 13)</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\approx 8\\% \\ (629/8189)</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Table 7.</strong> Degree and density of the polynomials after a single round, where t=4 and two input variables are used (with the other two input elements being fixed).</p>

    <p class="text-gray-300"><span id="page-42-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bit splittings</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Density</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> \\begin{array}{r} 2^8 - 2^4 + 1 \\\\ 2^7 - 1 \\\\ 2^7 - 1 \\end{array} </span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\{4,4\\}</span> <span class="math">\\{3,4\\}</span> <span class="math">\\{4,3\\}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">239 (= p - 2) <span class="math">125 (= p - 2)</span> <span class="math">125 (= p - 2)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">> 99% (28785/28920)<br>> 98% (7919/8001)<br>> 98% (7919/8001)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Results for</strong>  <span class="math">\\mathbb{F}_p^t</span> . We also ran tests regarding the density over the entire state. Naturally, this task gets harder with an increased number of rounds, since the degrees are rising too quickly. In our tests we focused on  <span class="math">p \\in \\{2^8 - 2^4 + 1, 2^7 - 1\\}</span>  and t = 4, and we give the results together with the sizes of the smaller S-boxes in Table 7.</p>

    <p class="text-gray-300">As can be seen, the maximum number of monomials is almost reached after a single round. We suspect that some of the monomials are not reached due to cancellations, which is reasonable when considering these small prime fields. Still, we acknowledge this fact by adding another round on top of that in order to ensure that all polynomial representations of the state are dense and of maximum degree. Thus, having 6 rounds achieves 4 rounds of security margin regarding degrees and density of polynomials.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">B.3 Details about GB Attacks</h4>

    <p class="text-gray-300">Algebraic Model for Bar. We suggest the following algebraic model for Bar for a decomposition of a prime field element into m buckets with sizes</p>

    <p class="text-gray-300"> <span class="math">2^{s_1}, 2^{s_2}, \\ldots, 2^{s_m}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} x = x_1b_1 + x_2b_2 + \\dots + x_mb_m, \\\\ 0 = \\prod_{j=0}^{2^{s_i}-1} (x_i - j), &amp; 1 \\le i \\le m, \\\\ y = \\mathcal{L}_1(x_1)b_1 + \\mathcal{L}_2(x_2)b_2 + \\dots + \\mathcal{L}_m(x_m)b_m. \\end{cases}</span></div>

    <p class="text-gray-300">Here,  <span class="math">b_1=1</span>  and  <span class="math">b_i:=2^{s_1+\\cdots+s_i}</span> , for  <span class="math">2\\leq i\\leq m</span> , and  <span class="math">\\mathcal{L}_i:\\mathbb{F}_p\\to\\mathbb{F}_p</span>  is the interpolation polynomial over  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">\\binom{s_i-1}{n}</span>  for the S-box  <span class="math">\\mathcal{S}_i</span>  given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_{i}(x_{i}) := \\sum_{0 \\leq k \\leq 2^{s_{i}} - 1} \\mathcal{S}_{i}(k) \\prod_{\\substack{0 \\leq j \\leq 2^{s_{i}} - 1 \\\\ j \\neq k}} \\frac{x_{i} - j}{k - j}.</span></div>

    <p class="text-gray-300">The resulting system consists of m+2 equations, namely m equations of respective degrees  <span class="math">2^{s_1}, \\ldots, 2^{s_m}, 1</span>  equation of degree  <span class="math">\\max_i (2^{s_i} - 1)</span> , and 1 equation of degree 1. The m+2 variables are  <span class="math">x_1, \\ldots, x_m, x, y</span> .</p>

    <p class="text-gray-300">Algebraic Model for SmallWeak1R-CICO. We consider the CICO problem SmallWeak1R-CICO that fixes v=1 words to 0 in the input and output, respectively. In other words, we are looking for  <span class="math">i_2, i_3, i_4, o_2, o_3, o_4 \\in \\mathbb{F}_p</span>  such that</p>

    <p class="text-gray-300">SmallWeak1R <span class="math-block">(0, i_2, i_3, i_4) = (0, o_2, o_3, o_4)</span> .</p>

    <p class="text-gray-300">The function  <span class="math">\\mathtt{SmallWeak1R} = \\mathtt{Concrete&#x27;} \\circ \\mathtt{Bricks} \\circ \\mathtt{Bars} \\circ \\mathtt{Concrete&#x27;}</span>  is a small-scale and weakened version of one round of Monolith defined on t=4 words and u=2 Bar functions in the Bars layer. For  <span class="math">\\mathtt{Concrete&#x27;}</span> , we use the circulant matrix  <span class="math">M=\\mathrm{circ}(2,1,1,1)</span> , which is not MDS and thus weaker than the MDS matrix in Monolith. Our algebraic model for  <span class="math">\\mathtt{SmallWeak1R-CICO}</span> , denoted by the same name, is given by the following system of equations:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} 0 = \\mathtt{Concrete&#x27;}^{-1}(v_1,v_2,v_3,v_4)_1, \\\\ w_1 = \\mathtt{Bar}(u_1), \\\\ w_2 = \\mathtt{Bar}(u_2), \\\\ 0 = (\\mathtt{Concrete&#x27;} \\circ \\mathtt{Bricks})(w_1,w_2,v_3,v_4)_1. \\end{array} \\right.</span></div>

    <p class="text-gray-300">Here,  <span class="math">\\mathcal{H}(\\cdot)_i</span>  denotes the <em>i</em>-th element of the output of the function  <span class="math">\\mathcal{H}</span>  for  <span class="math">i \\in \\{1,2,3,4\\}</span> . We note that each Bar function decomposes a prime field element into m=2 buckets, hence,  <span class="math">w_i=\\mathrm{Bar}(u_i)</span>  denotes above algebraic model for Bar with a decomposition into m=2 buckets. The resulting equation system consists of 10 equations with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4 equations for each Bar system  <span class="math">w_i = Bar(u_i)</span> , i = 1, 2, and</li>

      <li>2 equations for modelling the CICO constraint at the input and the output.</li>

    </ul>

    <p class="text-gray-300">In total, we have 10 variables, namely  <span class="math">u_1, u_2, u_3, u_4, w_1, w_2</span>  and 2 internal variables for each Bar system.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8"><strong>B.4</strong> Non-Applicable Attacks</h3>

    <p class="text-gray-300">We emphasize that we do not claim security of Monolith against zero-sum partitions [BCC11] (which can be set up via higher-order differentials [Knu94; BCD+20] and/or integral/square attacks [DKR97]). In such an attack, the goal is to find a collection of disjoint sets of inputs and corresponding outputs for the given permutation that sum to zero (i.e., satisfy the zero-sum property). Our choice is motivated by the fact that, to the best of our knowledge, it is not possible to turn such a distinguisher into an attack on the hash and/or compression function. For example, in the case of SHA-3/KECCAK [Nat15; BDP+11], while 24 rounds of KECCAK-f can be distinguished from a random permutation using a zero-sum partition [BCC11] (that is, full KECCAK-f), preimage/collision attacks on KECCAK can only be set up for up to 6 rounds of KECCAK-f [GLL+20]. Indeed, the authors of KECCAK-f deem a 12-round version of the primitive to provide ample security margin [BDP+18]. For this reason and as already done in similar work [GKR+21; GHR+23], we ignore zero-sum partitions for practical applications.</p>

    <p class="text-gray-300">In Table 8, we give the runtime of each part of the Monolith permutation for both a constant- and variable-time implementation.</p>

    <p class="text-gray-300"><span id="page-44-5"></span>Table 8. Native performance of each different round function in Monolith. Implemented in Rust.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time <span class="math">(ns)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Const. Time <span class="math">(ns)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p = 2^{64} - 2^{32} + 1:</span></td>

            <td class="px-3 py-2 border-b border-gray-700">t = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 12</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 8</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Concrete</td>

            <td class="px-3 py-2 border-b border-gray-700">19.5</td>

            <td class="px-3 py-2 border-b border-gray-700">33.6</td>

            <td class="px-3 py-2 border-b border-gray-700">19.5</td>

            <td class="px-3 py-2 border-b border-gray-700">33.6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bricks</td>

            <td class="px-3 py-2 border-b border-gray-700">12.2</td>

            <td class="px-3 py-2 border-b border-gray-700">19.3</td>

            <td class="px-3 py-2 border-b border-gray-700">16.0</td>

            <td class="px-3 py-2 border-b border-gray-700">21.8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bars</td>

            <td class="px-3 py-2 border-b border-gray-700">10.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9</td>

            <td class="px-3 py-2 border-b border-gray-700">10.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">p = 2^{31} - 1:</span></td>

            <td class="px-3 py-2 border-b border-gray-700">t = 16</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 24</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 16</td>

            <td class="px-3 py-2 border-b border-gray-700">t = 24</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Concrete</td>

            <td class="px-3 py-2 border-b border-gray-700">31.8</td>

            <td class="px-3 py-2 border-b border-gray-700">112.6</td>

            <td class="px-3 py-2 border-b border-gray-700">31.9</td>

            <td class="px-3 py-2 border-b border-gray-700">115.1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bricks</td>

            <td class="px-3 py-2 border-b border-gray-700">17.0</td>

            <td class="px-3 py-2 border-b border-gray-700">21.7</td>

            <td class="px-3 py-2 border-b border-gray-700">17.0</td>

            <td class="px-3 py-2 border-b border-gray-700">21.7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bars</td>

            <td class="px-3 py-2 border-b border-gray-700">8.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

            <td class="px-3 py-2 border-b border-gray-700">8.4</td>

            <td class="px-3 py-2 border-b border-gray-700">12.0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h2 id="sec-46" class="text-2xl font-bold">D Arithmetization Details</h2>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">D.1 R1CS</h4>

    <p class="text-gray-300">It is possible, though more expensive, to implement Monolith in legacy proof systems that only support R1CS equations without any table lookups. In contrast to Reinforced Concrete, our design admits a reasonably small R1CS</p>

    <p class="text-gray-300">representation described in the following. First, we use t-1 constraints to generate equations for Bricks. For Bars, we decompose each element that goes into a Bar into bits thus using one constraint per Bar for the actual decomposition plus  <span class="math">\\log_2(p) \\cdot \\# \\text{Bar}</span>  constraints for ensuring that the bits are either 0 or 1. Then each output bit of Bar requires 3 multiplications (2 for AND and 1 for XOR) for the 8-bit S-box and 2 multiplications for the 7-bit one as used in Monolith-31. By combining the composition constraints with the following bricks layer we get 1028 constraints for Monolith-64 and 944 constraints for Monolith-31 per Bars. Finally, the Concrete layer can be included in the constraints of Bricks and Bars, resulting in a total for  <span class="math">R \\cdot (1027 + t)</span>  R1CS constraints for Monolith-64 and  <span class="math">R \\cdot (943 + t)</span>  constraints for Monolith-31, where R is the number of rounds.</p>

    <p class="text-gray-300">The Tip5 function applies four 64-bit S-boxes with lookups per round, so 32 8-bit lookups per round. It also uses 12 degree-7 power functions per round. We allocate variables for the outputs of the power functions in addition to 64 lookup variables per round.</p>

    <p class="text-gray-300">Similarly, the Tip4' function also applies 32 8-bit lookups per round to the smaller state. However, it uses 8 degree-7 power functions per round, proportionally reducing the number of variables.</p>

    <p class="text-gray-300">The Poseidon2 function (as well as Poseidon which has the same number of rounds and the same arithmetization) with t=12 defined for  <span class="math">p_{Goldilocks}</span>  has 8 full and 22 partial rounds, thus 118 degree-7 functions in total. We allocate variables for all outputs of the S-boxes, and link the others via linear equations.</p>

    <p class="text-gray-300">Regarding Rescue-Prime, an instance with t=12 defined for  <span class="math">p_{\\text{Goldilocks}}</span>  requires 8 rounds which each consist of two subrounds which alternate between nonlinear layers featuring the  <span class="math">x^d</span>  and  <span class="math">x^{1/d}</span>  power maps. Due to this construction one can find degree-7 constraints spanning a whole round of rescue, leading to 96 degree-7 constraints in total.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">D.3 Multiround Constraints for Monolith</h4>

    <p class="text-gray-300">We consider  <span class="math">p = p_{\\texttt{Goldilocks}}</span>  and t = 12. When implementing both Monolith and Tip5 in a single gate, we can immediately observe various similarities. For example, considering 8-bit lookups, the number of lookups is almost the same, with Tip5 using slightly fewer ones due to its lower number of rounds (note that both permutations use four lookup words per round). Moreover, the number of necessary columns is similar in a round-based approach.</p>

    <p class="text-gray-300">The major advantage of Monolith becomes apparent after considering the degree of the constraints. Indeed, while Tip5 uses a maximum degree of 7 (which is the smallest integer d such that  <span class="math">\\gcd(p_{\\texttt{Goldilocks}}-1,d)=1)</span> , Monolith uses a maximum degree of only 2. Not only does this lead to more efficient constraints, but it allows for different tradeoffs. For example, consider  <span class="math">p=p_{\\texttt{Goldilocks}}, t=12</span>  and a state after the Concrete layer defined by 12 variables  <span class="math">w_1^{(1)},\\ldots w_{12}^{(1)}</span> . After the subsequent application of Bars, we add 4 new variables  <span class="math">w_1^{(2)},\\ldots,w_4^{(2)}</span>  for the state</p>

    <p class="text-gray-300">elements modified by the lookup table. We now apply Bricks and then Concrete to the state. Note that describing the state in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}</span>  after these transformations results in degree-2 constraints (ignoring the table lookups), since only one Bricks layer has been applied. Hence, we may now choose to only add 4 new variables  <span class="math">w_1^{(3)}, \\ldots, w_4^{(3)}</span>  after the application of the last Concrete layer at the positions of the table lookups. After the next Bars layer, the state is defined by 8 polynomial equations in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}</span>  of degree 2 and by the 4 new variables  <span class="math">w_1^{(4)}, \\ldots, w_4^{(4)}</span>  resulting from the table lookups. After applying the next Bricks and Concrete layers, we arrive at a state defined by 12 polynomial constraints in  <span class="math">w_5^{(1)}, \\ldots w_{12}^{(1)}, w_1^{(2)}, \\ldots, w_4^{(2)}, w_1^{(4)}, \\ldots, w_4^{(4)}</span>  of degree 4. A graphical overview of this approach is shown in Fig. 5.</p>

    <p class="text-gray-300"><img src="_page_46_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-46-0"></span>Fig. 5. Variables (or trace elements) when using Monolith with degree-4 constraints. Newly added variables are emphasized in <strong>bold</strong> and the degree indicates the maximum degree of the polynomial equations describing the corresponding state in the given variables.</p>

    <p class="text-gray-300">As a result, with degree-4 constraints we can save t-u trace elements in each pair of rounds, where u is the number of Bar applications in the Bars layers. This allows us to achieve a slimmer row with even fewer columns. We point out that this advantage of Monolith's low degree also applies in a similar fashion when comparing to other hash functions which use  <span class="math">x^d</span> , such as Poseidon, Poseidon2, Rescue, Griffin, Anemoi, and many more.</p>`;
---

<BaseLayout title="Monolith: Circuit-Friendly Hash Functions with New Nonlinear... (2023/1025)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1025
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
