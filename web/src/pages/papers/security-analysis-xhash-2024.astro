---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/605';
const CRAWLER = 'marker';
---

<BaseLayout title="Security Analysis of XHASH8/12 (2024/605)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Security Analysis of XHASH8/12
      </h1>
      <p class="text-gray-400 mb-2">
        L&eacute;o Perrin
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; Full Version &middot; eprint 2024/605
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">On the Padding</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">Description</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                On its Security for a Fixed Rate</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">A Potential Issue</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">On Algebraic Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">State-of-the-Art</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Constructing a Security Claim Against
                Root Finding</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">Modeling XHash</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                A Specific Monomial Ordering</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Arguing Security Against Gr&ouml;bner-based
            Algebraic Attacks</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Towards a Pencil/Paper Argument</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">Experimental Results</a>
            </li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- NOTATIONS                                                    -->
    <!-- ============================================================ -->

    <section id="notations" class="mb-10">
      <h2 class="text-2xl font-bold">Notations</h2>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        text-sm">
        <li>
          <span class="math">
            q = 2^&#123;64&#125; - 2^&#123;32&#125; + 1
          </span> the field size.
        </li>
        <li>
          <span class="math">\mathbb&#123;F&#125;_q</span> the field
          with <span class="math">q</span> elements. Elements of
          <span class="math">\mathbb&#123;F&#125;_q</span> are called
          &ldquo;words&rdquo;.
        </li>
        <li>
          <span class="math">r</span> the rate (size of the outer
          part), expressed in words.
        </li>
        <li>
          <span class="math">c</span> the capacity (size of the inner
          part), expressed in words.
        </li>
        <li>
          <span class="math">\ell</span> is the number of inverse
          power maps applied in each round.
        </li>
        <li>
          <span class="math">\pi^&#123;8&#125;</span> the full XHASH8
          permutation
          (<span class="math">\ell = 8</span>).
        </li>
        <li>
          <span class="math">\pi^&#123;12&#125;</span> the full
          XHASH12 permutation
          (<span class="math">\ell = 12</span>).
        </li>
      </ul>
    </section>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We have investigated both the padding scheme and the
        applicability of algebraic attacks to both XHash8 and XHash12.
        The only vulnerability of the padding scheme we can find is
        plausibly applicable only in the multi-rate setting &mdash; for
        which the authors make no claim &mdash; and is safe otherwise.
      </p>
      <p class="text-gray-300">
        For algebraic attack relying on the computation and
        exploitation of a Gr&ouml;bner basis, our survey of the
        literature suggests to base a security argument on the
        complexity of the variable elimination step rather than that of
        the computation of the Gr&ouml;bner basis itself. Indeed, it
        turns out that the latter complexity is hard to estimate
        &mdash; and is sometimes literally non-existent. Focusing on
        the elimination step, we propose a generalization of the
        &ldquo;FreeLunch&rdquo; approach which, under a reasonable
        conjecture about the behaviour of the degree of polynomial
        ideals of dimension 0, is sufficient for us to argue that both
        XHash8 and XHash12 are safe against such attacks.
      </p>
      <p class="text-gray-300">
        We implemented a simplified version of the generation (and
        resolution) of the corresponding set of equations in SAGE,
        which allowed us to validate our conjecture at least
        experimentally, and in fact to show that the lower bound it
        provides on the ideal degree is not tight &mdash; meaning we
        are a priori underestimating the security of these permutations
        against the algebraic attacks we consider.
      </p>
      <p class="text-gray-300">
        At this stage, if used as specified, these hash functions seem
        safe from Gr&ouml;bner bases-based algebraic attacks.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. ON THE PADDING                                            -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. On the Padding</h2>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Description
      </h3>
      <p class="text-gray-300">
        In a sponge-based hash function, the usual approach consists in
        appending a &ldquo;1&rdquo; to the message, and then to add
        enough zeroes to the result in order to obtain a new message
        with a length that is a multiple of the rate
        <span class="math">r</span>. This ensures that two distinct
        messages will yield two different digests, which would not be
        the case if only zeroes were added as
        <span class="math">m</span> and
        <span class="math">m \| 0</span> would otherwise yield the
        same hash. However, in this case, if the initial message is
        already of a length that is a multiple of
        <span class="math">r</span>, then hashing it requires
        processing yet another block, meaning one more call to the
        permutation. The problem is well known, and has already been
        discussed e.g. in [Hir16].
      </p>
      <p class="text-gray-300">
        The approach used in XHash is similar, in that zeroes are also
        added to obtain a message of the correct length, without adding
        any &ldquo;1&rdquo;. As a consequence, in order to distinguish
        <span class="math">m</span> from
        <span class="math">m \| 0</span>, the internal state of the
        sponge is initialized differently: instead of receiving an
        all-zero state, the first word of the capacity is set to a
        value that depends on the congruence modulo
        <span class="math">r</span> of the message length. While this
        is not stated in the specification [AKM23], the values used
        could also depend on the rate itself in order to ensure domain
        separation between sponge instances using different rates. As
        it is, XHash does not take the rate directly into account.
      </p>
      <p class="text-gray-300">
        More formally, the hashing mode of the XHash family operates as
        follows on a message
        <span class="math">
          m = (m_0, \ldots, m_&#123;t-1&#125;)
        </span>
        of <span class="math">t</span> words of
        <span class="math">\mathbb&#123;F&#125;_q</span>.
      </p>
      <p class="text-gray-300">
        <strong>Initialization.</strong> The initial state is
        initialized as
        <span class="math">
          x = \mathsf&#123;StateInit&#125;(t \bmod r)
        </span>.
      </p>
      <p class="text-gray-300">
        <strong>Padding.</strong> The message is padded with 0 to
        obtain a message
        <span class="math">
          m' = (m_0, \ldots, m_&#123;t-1&#125;, 0, \ldots, 0)
        </span>
        of length <span class="math">t' \ge t</span>, where the
        number of 0 is the smallest such that
        <span class="math">t'</span> is a multiple of
        <span class="math">r</span>.
      </p>
      <p class="text-gray-300">
        <strong>Absorption.</strong> For
        <span class="math">
          i \in \&#123;0, \ldots, t'/r)
        </span>, do
        <span class="math">
          x = \pi\left(m'_&#123;ri&#125;, \ldots,
          m'_&#123;ri+r-1&#125;, x_r, x_&#123;r+1&#125;,
          \ldots, x_&#123;11&#125;\right)
        </span>,
        where <span class="math">\pi</span> is either the XHash8 or
        XHash12 permutation.
      </p>
      <p class="text-gray-300">
        <strong>Squeezing.</strong> The first 4 words of the outer part
        are output as the digest.
      </p>
      <p class="text-gray-300">
        It is crucial (but easy to ensure) that
        <span class="math">\mathsf&#123;StateInit&#125;</span> has no
        collision. Below, we assume that it is indeed collision-free.
      </p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 On its Security for a Fixed Rate
      </h3>
      <p class="text-gray-300">
        While there is no formal proof for the security of this mode at
        this stage, it is easy to check that its specifics have no
        impact on the usual generic attacks.
      </p>
      <p class="text-gray-300">
        <strong>Collision Search.</strong> The best attack consists in
        absorbing random messages until we find two that match in the
        inner part. We can then absorb identical messages to force an
        identical content in the rate as well, meaning that the full
        internal states are then identical. The complexity is roughly
        the square root of the space corresponding to the capacity, and
        as we can see the specifics of the initialization have not
        appeared in the description of this attack.
      </p>
      <p class="text-gray-300">
        <strong>Preimage.</strong> The preimage search also relies on
        finding a collision in the capacity, except that we go forward
        (as in the collision search), and backwards (from the targeted
        digest) using that <span class="math">\pi</span> is a
        permutation. Again, the specifics of the initialization do not
        matter.
      </p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8 mb-3">
        1.3 A Potential Issue
      </h3>
      <p class="text-gray-300">
        In XHash, the rate is fixed. However, should it be allowed to
        vary, then the current implementation of
        <span class="math">\mathsf&#123;StateInit&#125;</span> could
        be a problem. Indeed, in this case,
        <span class="math">
          \mathsf&#123;StateInit&#125;(t \bmod r)
        </span>
        is a state of 12 words, namely
        <span class="math">
          (t \bmod r, 0, 0, \ldots, 0)
        </span>.
        The inner part of the state consists in the first
        <span class="math">12 - r</span> words, and the outer part in
        the last <span class="math">r</span> ones.
      </p>
      <p class="text-gray-300">
        As a consequence, it is possible to find collisions across
        instances of XHash that use different rates, i.e. in the
        multi-rate model [GJMG11]. For instance, we can use the
        rate/message pairs shown in Table 1, where 0 corresponds to a
        zero that was present in the state before the absorption of the
        message. After the absorption of each message by its
        corresponding sponge instance, the states will match.
      </p>

      <div class="overflow-x-auto my-6">
        <table class="w-full text-sm">
          <caption class="text-gray-400 text-xs mb-2">
            Table 1: Building multi-rate collisions through the
            padding.
          </caption>
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left p-2 text-gray-300">
                <span class="math">r</span>
              </th>
              <th class="text-left p-2 text-gray-300">
                <span class="math">m</span>
              </th>
              <th class="text-left p-2 text-gray-300">
                <span class="math">C</span>
              </th>
              <th class="text-left p-2 text-gray-300">
                State after absorption
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-400">
            <tr class="border-b border-gray-800">
              <td class="p-2">4</td>
              <td class="p-2">(1, 2, 3, 4)</td>
              <td class="p-2">0</td>
              <td class="p-2">
                <span class="math">
                  (C, 0, 0, \ldots, 0, 1, 2, 3, 4)
                </span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="p-2">5</td>
              <td class="p-2">(0, 1, 2, 3, 4)</td>
              <td class="p-2">0</td>
              <td class="p-2">
                <span class="math">
                  (C, 0, \ldots, 0, 0, 1, 2, 3, 4)
                </span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <p class="text-gray-300">
        <strong>Possible Mitigations.</strong> Avoiding this problem
        can be done in several ways.
      </p>
      <ol class="list-decimal list-inside space-y-2 text-gray-300
        text-sm ml-4">
        <li>
          Ensure that the rate is not to be changed under any
          circumstance.
        </li>
        <li>
          Use another formula for the computation of
          <span class="math">\mathsf&#123;StateInit&#125;</span> to
          add a direct dependency in the rate, e.g. replace
          <span class="math">
            \mathsf&#123;StateInit&#125;(t) = t \bmod r
          </span>
          with
          <span class="math">
            \mathsf&#123;StateInit&#125;(t, r) =
            r \cdot 2^&#123;4&#125; + (t \bmod r)
          </span>.
          Since the state size is of 12 words, this prevents
          collisions.
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- 2. ON ALGEBRAIC ATTACKS                                      -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. On Algebraic Attacks</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 State-of-the-Art
      </h3>
      <p class="text-gray-300">
        Arguing security against algebraic attacks is a complicated
        task as these are not so well understood at this stage, and the
        interplay between the &ldquo;algebraic&rdquo; part and more
        classical techniques can sometimes be used to an attacker's
        advantage to lower the overall complexity of the attack.
      </p>
      <p class="text-gray-300">
        By &ldquo;algebraic&rdquo; attack, we mean attacks that
        ultimately culminate with the resolution of a (system of)
        equation(s), of which the roots need to be found. Univariate
        techniques can sometimes be applied, but it does not seem
        relevant here:
      </p>
      <ol class="list-decimal list-inside space-y-2 text-gray-300
        text-sm ml-4">
        <li>
          the degree of the inverse function is close to the maximum
          possible, meaning that the univariate degree in any linear
          combination of the inputs will very quickly become unusable;
          and
        </li>
        <li>
          the field size
          (<span class="math">
            q = 2^&#123;64&#125; - 2^&#123;32&#125; + 1
          </span>)
          is not that large, meaning that a univariate approach would
          need to be more efficient than a simple brute-force on one
          word: a hard task here.
        </li>
      </ol>
      <p class="text-gray-300">
        It then leads us to focus on multivariate approaches, i.e. to
        write a system of multivariate equations, that we would then
        need to solve. Using a terminology inspired by the one
        introduced in [BBL+24], we can divide these attacks into
        several steps, as follows.
      </p>

      <p class="text-gray-300">
        <strong>SysGen.</strong> First, the system of equation needs to
        be generated. Several heuristics are available to this end, but
        all of them have to introduce new variables whenever a
        <span class="math">d</span>-th root is used as it is the
        compositional inverse of these operations that is of a low
        degree. This step can further be simplified using techniques
        from &ldquo;classical&rdquo; symmetric cryptanalysis, typically
        based on the probability one propagation of some affine spaces.
        This was used to shave off two SPN rounds generically in
        [BBLP22], with the conditions that the S-boxes are monomials
        over the base field considered, and that the cipher/permutation
        starts with an S-box layer. Similar tricks were deployed
        against Griffin and Arion in [BBL+24], but could not be
        leveraged against Anemoi.
      </p>
      <p class="text-gray-300">
        The system that is generated in the end is not uniquely
        defined: different generation strategies will yield different
        systems. For instance, using affine spaces to simplify it will
        remove some equations. Similarly, we can prefer to introduce
        new variables and equations in order to get more equations of a
        lower degree. The existence of an efficient SysGen procedure is
        implied by arithmetization-orientation, but it is not
        necessarily the approach used in attacks.
      </p>
      <p class="text-gray-300">
        Note that the algorithms used in the next steps are better
        understood in the case where the system is expected to have a
        unique (or just a few) solutions. This further adds constraints
        for the SysGen step, but they are easily handled: the expected
        number of solutions is easily estimated assuming e.g. that the
        hash function behaves like a random function, and the input can
        be constrained for instance by forcing it to be in a vector
        space of the appropriate dimension.
      </p>

      <p class="text-gray-300">
        <strong>Gr&ouml;bFind.</strong> Once a system is obtained, it
        is necessary first to endow it with a structure that will allow
        us to work with it. This in particular allows us to do the
        polynomial arithmetic we need, e.g. to reduce large degree
        polynomials modulo lower degree ones. The equations we have
        obtained define an ideal: since we investigate their common
        roots, any linear combination will also have these roots. An
        ideal of polynomials has a Gr&ouml;bner basis, a particular
        set of polynomials that essentially allow us to properly define
        a reduction modulo this ideal.
      </p>
      <p class="text-gray-300">
        A Gr&ouml;bner basis is defined for a given monomial ordering.
        Several of these are well known. In particular, a Gr&ouml;bner
        basis in lexicographic order can greatly simplify the next
        steps. On the other hand, the complexity of finding a
        Gr&ouml;bner basis is highly dependent on said ordering. In
        general, in order to obtain a basis e.g. in grevlex order given
        any ideal, we need to use either F4 or F5 [Fau99, Fau02].
        Unfortunately, efficient open source implementations are hard
        to find.
      </p>

      <p class="text-gray-300">
        <strong>VarElim.</strong> Once a Gr&ouml;bner basis is known,
        we use its structure to extract a univariate polynomial in one
        of the variables. This extraction step is usually done by
        reordering the Gr&ouml;bner basis, i.e. by obtaining a
        Gr&ouml;bner basis for a different monomial order, one that is
        suitable for this purpose. It is usually the lexicographic one.
        This change of order can be done using the FGLM [FGLM93]
        algorithm, whose complexity is precisely known as it boils down
        to linear polynomial arithmetic. It depends on a quantity
        called the degree of the ideal
        (<span class="math">D_I</span>), and corresponds to the number
        of roots the system has in the algebraic closure of the field
        considered. This number is much, much higher than the number of
        solutions in the field itself (typically 0, 1 or 2).
      </p>
      <p class="text-gray-300">
        More custom approaches are sometimes possible; for instance,
        the authors of [BBL+24] introduced the combination of MatMul
        and PolyDet: the idea is to bypass the cost of a full FGLM run
        by focusing on a single variable that is of particular interest
        in their case.
      </p>

      <p class="text-gray-300">
        <strong>UniSolve.</strong> By design, we expect a solution to
        exist. Thus, once a univariate equation is extracted, we solve
        it using well known techniques to get a first root of the
        system. We then substitute its value in the other equations,
        and deduce an assignment for all the variables. This works
        provided that the equations have the correct structure, but
        this is the case for an output of FGLM (under some reasonable
        assumptions that have been found to hold in practice when
        attacking AOPs).
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Constructing a Security Claim Against Root Finding
      </h3>
      <p class="text-gray-300">
        What would happen if we tried to build a security claim against
        root-finding attacks against each of the steps described above?
      </p>

      <p class="text-gray-300">
        <strong>SysGen.</strong> As we established during the
        discussion above, heuristics exist to lower the complexity of
        this step, however, it is also possible to mitigate them using
        appropriate counter-measures (such as starting with a linear
        diffusion layer). Furthermore, as this step cannot be avoided,
        it could make sense to base a security claim on the complexity
        of this step. However, this complexity is hard to estimate, and
        (as shown in [BBL+24]) tends to be much lower than other steps
        of the attack. Besides, running for instance a preimage search
        multiple times for different preimages would lead to systems
        that are essentially identical, except for some constants in
        the very last equations. As a consequence, the cost of this
        step could be amortized over several attacks.
      </p>
      <p class="text-gray-300">
        In the end, we claim that relying on this step for a security
        bound would not lead to meaningful results.
      </p>

      <p class="text-gray-300">
        <strong>Gr&ouml;bFind.</strong> Experimental results often
        indicated that this step was the longest in the attack against
        an AOP, which lead the authors of several primitives to follow
        those of Rescue [AAB+20], and base their security claims using
        an estimate of the complexity of F4 or F5 (e.g. Griffin
        [GHR+23], Anemoi [BBC+23] and Arion [RST23]).
      </p>
      <p class="text-gray-300">
        While there is no reason to challenge these experimental
        results, such claims are now unfortunately falling short.
        Indeed, it turns out that it is possible to find monomial
        orderings such that the system obtained during the SysGen step
        is immediately a Gr&ouml;bner basis. To the best of our
        knowledge, this was first put forward to investigate the AES
        [BPW06], and then adapted to the cryptanalysis of AOPs by two
        independent teams investigating different algorithms: the
        authors of [BBL+24] described the &ldquo;freelunch&rdquo;
        approach, which they applied to Anemoi, Arion, XHash8 and in
        particular Griffin; while Steiner very recently put forward
        papers presenting such orderings for Poseidon [Ste24b] and
        Rescue [Ste24a].
      </p>

      <p class="text-gray-300">
        <strong>VarElim.</strong> The complexity of FGLM is well known
        and &ldquo;stable&rdquo;: while the complexity of
        Gr&ouml;bFind can only be upper-bounded (while we would need a
        lower bound anyway), that of FGLM is tight. Furthermore, even
        though the technique presented in [BBL+24] is more efficient
        than FGLM, its complexity has a similar structure. Variants of
        FGLM exist that can be applied e.g. to sparser systems. The
        applicability of these variants is not so clear, but their
        complexity also depends on the same quantity: the ideal degree
        <span class="math">D_I</span>.
      </p>
      <p class="text-gray-300">
        We will thus base our security argument on the complexity of
        this step.
      </p>

      <p class="text-gray-300">
        <strong>UniSolve.</strong> The complexity of this step is
        tightly known, and is negligible compared to all the other
        steps considered here. It cannot serve as the basis for a
        security claim.
      </p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Modeling XHash
      </h3>
      <p class="text-gray-300">
        In what follows, letters
        <span class="math">x, y</span> denote variables in
        <span class="math">\mathbb&#123;F&#125;_q</span>, and Greek
        letters denote multivariate polynomials of
        <span class="math">\mathbb&#123;F&#125;_q</span>. The inner
        operations of XHash are denoted with upper case Latin letters.
      </p>

      <p class="text-gray-300">
        <strong>General Approach.</strong> For both instances of XHash,
        we use a similar approach. In order to ensure that the system
        is expected to have a single solution (or at most a few), we
        need to restrict the input to a vector space of dimension
        <span class="math">r</span>, being the rate. The simplest
        approach consists simply in starting with variables
        <span class="math">
          x_0, \ldots, x_&#123;r-1&#125;
        </span>
        for the input of the permutation, setting the others to 0.
      </p>
      <p class="text-gray-300">
        Then we construct polynomial constraints ensuring that the
        internal state at the output of the permutation is indeed the
        image of the initial state after the relevant operations.
        Passing through low degree operations is easy as we simply need
        to directly update the polynomials by composing them with said
        operations. For the (partial) layer of 7th root, we proceed
        differently: we introduce variables
        <span class="math">y_j^i</span> just after each 7th root,
        <span class="math">i</span> being the round index and
        <span class="math">j</span> the word index.
      </p>

      <p class="text-gray-300">
        <strong>First Round.</strong> For the first round, we simply
        need to encode that the inputs of each 7th root are obtained by
        applying two MDS layers and a layer of small monomials (along
        with the appropriate round constants). We deduce 12 equations
        (resp. 8) for XHash12 (resp. XHash8) of the following shape:
      </p>
      <div class="math-block">
        (y_j^1)^7 = C_1 + L_j \left( S \left( L \left(
        C_0 + \vec&#123;x&#125; \right) \right) \right) =
        \alpha_j(x) \, .
      </div>
      <p class="text-gray-300">
        In order to look for solutions of the CICO problem &mdash; or
        indeed for preimages, we need to fix the capacity words to 0.
        To this end, we consider that
        <span class="math">
          \vec&#123;x&#125; = (x_0, \ldots, x_&#123;r-1&#125;,
          0, \ldots, 0)
        </span>.
      </p>

      <p class="text-gray-300">
        <strong>Middle Rounds.</strong> We get equations of the
        following types for the middle rounds of XHash12:
      </p>
      <div class="math-block">
        (y_j^&#123;i+1&#125;)^7 = C_i + L_j \left( S \left(
        L \left( C_i + T(y^i) \right) \right) \right) =
        \mu_j^i(y^i) \, .
        \tag&#123;1&#125;
      </div>
      <p class="text-gray-300">
        Since the layer of small S-boxes
        (<span class="math">S</span>) and the layer of big S-boxes
        (<span class="math">T</span>) are both of degree 7, and since
        the MDS layer ensures that all outputs depend on all inputs, we
        have that <span class="math">\mu_j^i</span> is always of
        degree
        <span class="math">7^2 = 49</span>.
      </p>
      <p class="text-gray-300">
        For XHash8, the situation is similar except that we introduce
        fewer such variables (only 8 per round), and that the
        polynomial constraints take as input the variables from all the
        previous rounds, not only the immediate predecessor. It
        complicates writing a closed formula for these constraints, but
        they can be generated recursively starting from the first one
        with a computer program that updates the expression of the
        polynomials corresponding to the &ldquo;identity&rdquo; boxes
        in the high degree layer and keeps those in memory. We then get
        equations of the form
      </p>
      <div class="math-block">
        (y_j^&#123;i+1&#125;)^7 =
        \overline&#123;\mu&#125;_j^i(y^i, y^&#123;i-1&#125;,
        \ldots, y^1, x) \, ,
        \tag&#123;2&#125;
      </div>
      <p class="text-gray-300">
        which are obtained by applying
        <span class="math">L</span> to a vector whose
        <span class="math">j</span>-th coordinate is
        <span class="math">y_j^i</span> if there is a 7th root at
        that position, and
        <span class="math">
          \mu_j^&#123;i-1&#125;(y^&#123;i-1&#125;, \ldots, x)
        </span>
        otherwise. As for
        <span class="math">\mu</span>, the polynomials
        <span class="math">\overline&#123;\mu&#125;</span> are of
        degree 49 in <span class="math">y^i</span>. However, their
        degree in the previous variables is higher since each of those
        went through operations of degree 49 during each round.
      </p>

      <p class="text-gray-300">
        <strong>Final Rounds.</strong> For the final round, we do not
        introduce any new variable. However, we add one equation per
        word whose value needs to be set to a specific value.
        Essentially, we get several affine combinations of the image
        under the big S-box of the
        <span class="math">y_j^&#123;N_r&#125;</span> and (for
        XHash8) some complex polynomials in all the previous variables
        which we denote
        <span class="math">\sigma</span>.
      </p>

      <p class="text-gray-300">
        <strong>Bypassing Rounds.</strong> A natural attack angle at
        this stage is to try and simplify the system using the
        knowledge of its structure, a trick usually achieved by
        carefully tracking the propagation of some affine spaces. This
        was applied with some success to several SPNs in [BBLP22], and
        even more so against both Griffin and Arion [BBL+24] due to the
        specifics of their non-linear layer &mdash; in particular, the
        fact that the non-linear layer of Griffin is affine over large
        affine spaces.
      </p>
      <p class="text-gray-300">
        However, we could not find such heuristics here. In the first
        round, the first MDS layer restricts the control needed to
        apply the technique from [BBLP22]. The fact that the non-linear
        layer is of very high degree everywhere then prevents the
        applicability of the technique from [BBL+24]. The
        monomial-based non-linear layer could have potentially led to
        the existence of chains of subspaces, as in [BCP23], but the
        dense and structure-less round constants are an effective
        counter-measure against it.
      </p>
      <p class="text-gray-300">
        Furthermore, the use of the monomial over
        <span class="math">\mathbb&#123;F&#125;_&#123;q^3&#125;</span>
        in the big S-box layer makes it complicated to play with the
        algebraic representation of several rounds by tightly
        interweaving its 3 input variables.
      </p>
      <p class="text-gray-300">
        Overall, while the threat from &ldquo;free&rdquo; rounds might
        a priori be pressing due to the low total number of rounds, it
        seems like the built-in countermeasures make such threats
        impractical.
      </p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 A Specific Monomial Ordering
      </h3>
      <p class="text-gray-300">
        In the end, we have two types of variables: the
        <span class="math">x_j</span>, that correspond to the input,
        and the <span class="math">y_j^i</span>, that are grouped in
        layers corresponding to the round at which they are introduced.
        We order them using a weighted grevlex order, whereby variables
        <span class="math">x_j</span> have weight 1, and a variable
        <span class="math">y_j^i</span> (introduced during round
        <span class="math">i</span>) has weight
        <span class="math">\alpha^&#123;2i&#125;</span>.
      </p>
      <p class="text-gray-300">
        Our system of equations is of the form
      </p>
      <div class="math-block">
        \begin&#123;cases&#125;
        0 = (y_0^0)^7 - \alpha_0(\vec&#123;x&#125;) \\
        \vdots \\
        0 = (y_&#123;\ell-1&#125;^0)^7 -
        \alpha_&#123;\ell-1&#125;(\vec&#123;x&#125;)
        \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        where <span class="math">\ell = 8</span> for XHash8 and
        <span class="math">\ell = 12</span> for XHash12.
      </p>
      <p class="text-gray-300">
        By construction, our custom ordering ensures that the leading
        monomials in all the starting and middle equations are
        different variables (namely, all the
        <span class="math">y_j^i</span>). For XHash8, in the case
        where we only try to force one 0 in the input and in the
        output, this is exactly a FreeLunch system: the leading
        monomial in the last equation is of the form
        <span class="math">x_0^&#123;49(r+1)&#125;</span>, meaning
        that it is yet another variable, and that the whole system is a
        Gr&ouml;bner basis out-of-the-box.
      </p>
      <p class="text-gray-300">
        Unfortunately, it is not the case for XHash12, or when the
        number of attacked output blocks (and thus the number of
        variables in <span class="math">\vec&#123;x&#125;</span>) is
        at least equal to 2. Still, we do have that the leading
        monomials in all but the final equations are pairwise distinct.
      </p>

      <p class="text-gray-300">
        <strong>On XHash12.</strong> In XHash12, the input variables do
        not play a specific role since the inverse monomial layers are
        full. Indeed, we lose the ability to force the input variables
        to play a specific role in the last round, and thus cannot have
        the <span class="math">x_j</span> be the only variables in
        the leading monomials in any equation.
      </p>
      <p class="text-gray-300">
        We thus considered alternative strategies to build the system
        of equations for XHash12, and in particular to build the
        weights so that they decrease with the number of rounds, thus
        forcing the <span class="math">x_i</span> to be the leading
        terms in the first round, the
        <span class="math">\vec&#123;y^i&#125;</span> to be the
        leading terms in the second round, etc. However, the inner
        workings of the round function prevented us from going further:
        it is &ldquo;easy&rdquo; to force
        <span class="math">y^d</span> to be the leading term of an
        equation of the form
        <span class="math">y^d - P(y, \vec&#123;x&#125;)</span>, but
        much more complicated to pick a specific variable intervening
        in the rather dense polynomial
        <span class="math">P</span>, and have it be the only variable
        in the leading monomial of such an equation.
      </p>
      <p class="text-gray-300">
        In the end, we use the same encoding for XHash12 as we do for
        XHash8, and in fact we can build both using the same program.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. ARGUING SECURITY AGAINST GROEBNER-BASED ALGEBRAIC ATTACKS -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Arguing Security Against Gr&ouml;bner-based Algebraic
        Attacks
      </h2>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Towards a Pencil/Paper Argument
      </h3>
      <p class="text-gray-300">
        Unfortunately, at this stage, we do not know of a way to
        construct a Gr&ouml;bner basis for free out of either
        permutation in the case where several words need to be
        controlled. However, under a reasonable conjecture, we can
        derive sufficient bounds. To describe this conjecture, we first
        need the following definition.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (b-Almost Basal)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            We call <em>b-almost basal</em> (b-AB) a system of
            <span class="math">n</span> polynomials
            <span class="math">P_i</span> in variables
            <span class="math">
              (x_0, \ldots, x_&#123;n-1&#125;)
            </span>,
            where <span class="math">b > 0</span> is an integer, when
            the following properties hold:
          </p>
          <ul class="list-disc list-inside space-y-2 text-gray-300
            text-sm ml-4">
            <li>
              <strong>Non-degenerate:</strong> the ideal spanned by
              these polynomials is of dimension 0;
            </li>
            <li>
              <strong>Basal part:</strong> there exists a monomial
              order such that the leading term of
              <span class="math">P_i</span>,
              <span class="math">i &lt; b</span>, is the monomial
              <span class="math">x_i^&#123;d_i&#125;</span> for some
              integer <span class="math">d_i > 0</span>.
            </li>
          </ul>
        </div>
      </div>

      <p class="text-gray-300">
        The idea of this notion is to describe a set of multivariate
        polynomials which is &ldquo;partially&rdquo; a Gr&ouml;bner
        basis. Indeed, it is sufficient for polynomials to form a
        Gr&ouml;bner basis that the leading term in each
        <span class="math">P_i</span> is of the form
        <span class="math">x_i^&#123;d_i&#125;</span>. In a b-AB
        system, the first <span class="math">b</span> polynomials
        have this shape. In fact, an
        <span class="math">n</span>-AB system is a Gr&ouml;bner
        basis.
      </p>

      <p class="text-gray-300">
        Such a system has the following structure (Figure 1): the basal
        part consists of
      </p>
      <div class="math-block">
        \begin&#123;cases&#125;
        x_0^&#123;d_0&#125; - P_0'(x_0, \ldots, x_&#123;n-1&#125;) \\
        x_1^&#123;d_1&#125; - P_1'(x_0, \ldots, x_&#123;n-1&#125;) \\
        \vdots \\
        x_&#123;b-1&#125;^&#123;d_&#123;b-1&#125;&#125; -
        P_&#123;b-1&#125;'(x_0, \ldots, x_&#123;n-1&#125;)
        \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        followed by the remaining polynomials
        <span class="math">
          P_b(x_0, \ldots, x_&#123;n-1&#125;), \ldots,
          P_&#123;n-1&#125;(x_0, \ldots, x_&#123;n-1&#125;)
        </span>
        where
        <span class="math">
          P_i(x) = x_i^&#123;d_i&#125; - P_i'(x)
        </span>.
      </p>
      <p class="text-gray-300">
        Using this notion, we are ready to state the following
        conjecture.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Conjecture 1 (Monotonous Ideal Degree Conjecture (MIDC))
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For a b-AB system, the degree
            <span class="math">D_I</span> of the ideal is lower
            bounded by
          </p>
          <div class="math-block">
            D_I \ge \prod_&#123;i=0&#125;^&#123;b-1&#125; d_i \, .
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        The intuition behind this conjecture is simple: the ideal
        degree corresponds to the number of solutions the system has
        in the algebraic closure of the underlying field, and this
        conjecture postulates that this number does not decrease when
        we take into account the last equations. That is where the term
        &ldquo;monotonous&rdquo; comes from: we assume that the ideal
        degree increases or stays constant but does not decrease when
        we consider more equations. To put it differently, this
        conjecture posits that the actual Gr&ouml;bner basis of the
        system contains the basal part, and that the last equations
        (those not in the basal part) do not decrease the ideal degree.
      </p>
      <p class="text-gray-300">
        This conjecture is obviously true when
        <span class="math">b = n</span>: in this case, the system is
        a Gr&ouml;bner basis, and the number of monomials &ldquo;under
        the staircase&rdquo; is indeed
        <span class="math">
          \prod_&#123;i=0&#125;^&#123;n-1&#125; d_i
        </span>.
      </p>
      <p class="text-gray-300">
        According to our experiments, for a simplified XHash, this
        conjecture holds. In fact, in our experiments, we do have that
        <span class="math">
          D_I = \prod_&#123;i=0&#125;^&#123;n-1&#125; d_i
        </span>,
        even though the last polynomials have identical leading terms.
        In that case the last equations participate as if they had
        different leading terms. Still, we deem it safer at this stage
        to only take the basal part into account when making a security
        claim.
      </p>

      <p class="text-gray-300">
        <strong>On the Security of XHash.</strong> Applying our attack
        strategy against one word in XHash8, i.e. solving a CICO
        instance with one 0 in the input and one in the output, we
        simply obtain a FreeLunch [BBL+24] system. It is a particular
        case of an <span class="math">n</span>-AB system.
      </p>
      <p class="text-gray-300">
        Under the MIDC, the ideal degree corresponding to an attack on
        <span class="math">w</span> words is lower bounded by the
        complexity of attacking 1 word. Indeed, when
        <span class="math">w > 1</span>, the first equations still
        form a basal part of the polynomial system, and only the last
        <span class="math">w - 1</span> equations are not basal. As
        a consequence, we get a bound on
        <span class="math">D_I</span> which corresponds to its value
        in the <span class="math">w = 1</span> case, namely
        <span class="math">
          D_I \ge d^&#123;\ell N_r&#125;
        </span>.
      </p>
      <p class="text-gray-300">
        For XHash8, even ignoring the presence of the first equation
        with leading term <span class="math">x_0</span> among the
        final equations, we get that
        <span class="math">
          D_I \ge d^&#123;3 \times 8&#125; \approx 2^&#123;67&#125;
        </span>.
        Adding the equation in <span class="math">x_0</span>, which
        also satisfies the criteria to be part of the basal part, we
        get
        <span class="math">
          D_I \ge d^&#123;3 \times 8&#125; \times d^&#123;3 \times
          2&#125; \approx 2^&#123;84&#125;
        </span>.
        As a consequence, in order for Gr&ouml;bner-based algebraic
        attacks to be a threat against XHash8, we would need two
        things:
      </p>
      <ol class="list-decimal list-inside space-y-2 text-gray-300
        text-sm ml-4">
        <li>
          that the bound for <span class="math">D_I</span> is tight
          (experiments indicate that it is not), and
        </li>
        <li>
          an FGLM-like algorithm with a complexity strictly
          sub-quadratic in <span class="math">D_I</span> &mdash; in
          fact, a complexity proportional to
          <span class="math">D_I^&#123;1.5&#125;</span> would give a
          complexity around
          <span class="math">2^&#123;126&#125;</span> in this case:
          barely an attack.
        </li>
      </ol>
      <p class="text-gray-300">
        For XHash12, we get a bound of
        <span class="math">
          D_I \ge d^&#123;3 \times 12&#125; \approx 2^&#123;101&#125;
        </span>,
        which is even higher &mdash; and thus safer.
      </p>
      <p class="text-gray-300">
        At this stage, we expect neither the bounds to be tight nor
        such an algorithm to exist. Thus, we claim that XHash8 is safe
        against Gr&ouml;bner-based algebraic attack.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Experimental Results
      </h3>
      <p class="text-gray-300">
        It is easy to design (and implement) a system of equations
        corresponding to an attack against a greatly simplified XHash8,
        differing from the real one in the following ways.
      </p>
      <ul class="list-disc list-inside space-y-2 text-gray-300
        text-sm ml-4">
        <li>
          Use <span class="math">x \mapsto x^3</span> as a small
          S-box,
        </li>
        <li>
          Use a lower value for <span class="math">p</span> (namely,
          <span class="math">p = 2^&#123;16&#125; - 17</span>) such
          that <span class="math">x \mapsto x^3</span> is a
          permutation,
        </li>
        <li>
          Decrease the number of branches, and consider different
          patterns for the application of the cubic roots.
        </li>
        <li>
          Resize the big S-box to operate on
          <span class="math">
            \mathbb&#123;F&#125;_p^2
          </span>
          rather than
          <span class="math">
            \mathbb&#123;F&#125;_p^3
          </span>;
          and allow its replacement by a simple (full) layer of
          branch-wide monomials (to better understand the impact of big
          S-boxes).
        </li>
      </ul>
      <p class="text-gray-300">
        The attached Python script does just that. We call
        <span class="math">\ell</span> the number of cubic roots
        applied in parallel in each round (so that
        <span class="math">\ell = 8</span> for XHash8 for instance),
        and <span class="math">w</span> the number both of
        <span class="math">x_i</span> and of final equations.
      </p>

      <p class="text-gray-300">
        <strong>Confirming the MIDC.</strong> Running experiments on a
        small number of rounds, we have found that the Monotonous
        Ideal Degree Conjecture held. In fact, a stronger result seems
        to hold in the case of XHash8: in this case, the ideal degree
        seems equal to
      </p>
      <div class="math-block">
        \underbrace&#123;d^&#123;\ell r&#125;&#125;_&#123;y_i&#125;
        \times
        \underbrace&#123;d^&#123;k \times
        2r&#125;&#125;_&#123;x_j&#125;
      </div>
      <p class="text-gray-300">
        which is
        <span class="math">(w - 1) \cdot 2r</span> times bigger than
        the bound given by the conjecture.
      </p>

      <p class="text-gray-300">
        <strong>On the Impact of
        <span class="math">T</span>.</strong>
        The much denser operation (operating over
        <span class="math">
          \mathbb&#123;F&#125;_&#123;q^3&#125;
        </span>)
        does not influence the degree of the ideal. In that sense, it
        a priori does not provide more resistance against algebraic
        attacks than a simpler layer of monomials applied on each
        branch.
      </p>
      <p class="text-gray-300">
        However, in practice, it does imply some important properties.
        First, its greater density means that all the polynomials have
        an observably higher Hamming weight &mdash; a property which
        gets stronger as the exponent increases. This means that the
        equations are hard to generate and to manipulate, and that
        targeting the (elimination of) specific terms is likely to be
        much more complicated. More importantly, making the polynomials
        denser is important to prevent algorithms targeting sparse
        systems from becoming applicable.
      </p>
      <p class="text-gray-300">
        Furthermore, by operating on several words at once, it prevents
        an attacker from singling out any of them. Being able to do
        this is important to select which variables to pick as the
        leading monomials, or to find heuristics to bypass rounds for
        free. As a consequence, we consider that these layers offer a
        significant security increase, albeit not one that is directly
        visible in the ideal degree.
      </p>

      <p class="text-gray-300">
        <strong>Comparing XHash8 and XHash12.</strong> Unsurprisingly,
        computing the actual value of
        <span class="math">D_I</span> takes a lot longer for a
        simplified XHash with a full layer of cubic roots. Intuitively,
        this makes sense: in this case, the polynomials obtained are
        further from being a Gr&ouml;bner basis, and thus SAGE needs
        to work harder to obtain one in order to compute this quantity.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-none space-y-2 text-gray-400 text-sm">
        <li>
          [AAB+20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson,
          Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key
          primitives for advanced cryptographic protocols. IACR
          Transactions on Symmetric Cryptology,
          2020(3):1&ndash;45, 2020.
        </li>
        <li>
          [AKM23] Tomer Ashur, Al Kindi, and Mohammad Mahzoun. XHash8
          and XHash12: Efficient STARK-friendly hash functions.
          Cryptology ePrint Archive, Paper 2023/1045, 2023.
        </li>
        <li>
          [BBC+23] Cl&eacute;mence Bouvier, Pierre Briaud, Pyrros
          Chaidos, L&eacute;o Perrin, Robin Salen, Vesselin Velichkov,
          and Danny Willems. New design techniques for efficient
          arithmetization-oriented hash functions: Anemoi permutations
          and Jive compression mode. In Advances in Cryptology &ndash;
          CRYPTO 2023, volume 14083 of LNCS, pages 507&ndash;539.
          Springer, 2023.
        </li>
        <li>
          [BBL+24] Augustin Bariant, Aur&eacute;lien Boeuf, Axel
          Lemoine, Irati Manterola Ayala, Morten &Oslash;ygarden,
          L&eacute;o Perrin, and H&aring;vard Raddum. The algebraic
          freelunch: Efficient Gr&ouml;bner basis attacks against
          arithmetization-oriented primitives. Cryptology ePrint
          Archive, Paper 2024/347, 2024.
        </li>
        <li>
          [BBLP22] Augustin Bariant, Cl&eacute;mence Bouvier,
          Ga&euml;tan Leurent, and L&eacute;o Perrin. Algebraic
          attacks against some arithmetization-oriented primitives.
          IACR Transactions on Symmetric Cryptology,
          2022(3):73&ndash;101, 2022.
        </li>
        <li>
          [BCP23] Aur&eacute;lien Boeuf, Anne Canteaut, and
          L&eacute;o Perrin. Propagation of subspaces in primitives
          with monomial S-boxes: Applications to Rescue and variants
          of the AES. IACR Transactions on Symmetric Cryptology,
          2023(4):270&ndash;298, Dec. 2023.
        </li>
        <li>
          [BPW06] Johannes Buchmann, Andrei Pyshkin, and Ralf-Philipp
          Weinmann. A zero-dimensional Gr&ouml;bner basis for
          AES-128. In Fast Software Encryption &ndash; FSE 2006,
          volume 4047 of LNCS, pages 78&ndash;88. Springer, 2006.
        </li>
        <li>
          [Fau99] Jean-Charles Faug&egrave;re. A new efficient
          algorithm for computing Gr&ouml;bner bases (F4). Journal of
          Pure and Applied Algebra,
          139(1&ndash;3):61&ndash;88, 1999.
        </li>
        <li>
          [Fau02] Jean-Charles Faug&egrave;re. A new efficient
          algorithm for computing Gr&ouml;bner bases without reduction
          to zero (F5). In Proceedings of ISSAC 2002, pages
          75&ndash;83, 2002.
        </li>
        <li>
          [FGLM93] Jean-Charles Faug&egrave;re, Patrizia Gianni,
          Daniel Lazard, and Teo Mora. Efficient computation of
          zero-dimensional Gr&ouml;bner bases by change of ordering.
          Journal of Symbolic Computation,
          16(4):329&ndash;344, 1993.
        </li>
        <li>
          [GHR+23] Lorenzo Grassi, Yonglin Hao, Christian Rechberger,
          Markus Schofnegger, Roman Walch, and Qingju Wang. Horst
          meets Fluid-SPN: Griffin for zero-knowledge applications. In
          Advances in Cryptology &ndash; CRYPTO 2023, volume 14083 of
          LNCS, pages 573&ndash;606. Springer, 2023.
        </li>
        <li>
          [GJMG11] Bertoni Guido, Daemen Joan, Peeters Micha&euml;l,
          and Van Assche Gilles. Cryptographic sponge functions, 2011.
        </li>
        <li>
          [Hir16] Shoichi Hirose. Sequential hashing with minimum
          padding. NIST Workshop on Lightweight Cryptography
          2016, 2016.
        </li>
        <li>
          [RST23] Arnab Roy, Matthias Johann Steiner, and Stefano
          Trevisani. Arion: Arithmetization-oriented permutation and
          hashing from generalized triangular dynamical systems, 2023.
        </li>
        <li>
          [Ste24a] Matthias Johann Steiner. Zero-dimensional
          Gr&ouml;bner bases for Rescue-XLIX. Cryptology ePrint
          Archive, Paper 2024/468, 2024.
        </li>
        <li>
          [Ste24b] Matthias Johann Steiner. A zero-dimensional
          Gr&ouml;bner basis for Poseidon. Cryptology ePrint Archive,
          Paper 2024/310, 2024.
        </li>
      </ol>
    </section>

  </article>
</BaseLayout>
