---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/419';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Algebraic Cryptanalysis of STARK-Friendly Designs: Application to MARVELlous and MiMC';
const AUTHORS_HTML = 'Martin R.  Albrecht, Carlos Cid, Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger';

const CONTENT = `    <p class="text-gray-300">Martin R. Albrecht<span class="math">^{1}</span>, Carlos Cid<span class="math">^{1,2}</span>, Lorenzo Grassi<span class="math">^{5,6}</span>, Dmitry Khovratovich<span class="math">^{3,4,7}</span>, Reinhard Lüftenegger<span class="math">^{5}</span>, Christian Rechberger<span class="math">^{5}</span>, and Markus Schofnegger<span class="math">^{5}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Information Security Group, Royal Holloway, University of London <span class="math">^{2}</span> Simula UiB <span class="math">^{3}</span> Dusk Network <span class="math">^{4}</span> ABDK Consulting <span class="math">^{5}</span> IAIK, Graz University of Technology <span class="math">^{6}</span> Know-Center <span class="math">^{7}</span> Evernym Inc. firstname.lastname@rhul.ac.uk, khovratovich@gmail.com, firstname.lastname@iaik.tugraz.at</p>

    <p class="text-gray-300">Abstract. The block cipher JARVIS and the hash function FRIDAY, both members of the MARVELLOUS family of cryptographic primitives, are among the first proposed solutions to the problem of designing symmetric-key algorithms suitable for transparent, post-quantum secure zero-knowledge proof systems such as ZK-STARKs. In this paper we describe an algebraic cryptanalysis of JARVIS and FRIDAY and show that the proposed number of rounds is not sufficient to provide adequate security. In JARVIS, the round function is obtained by combining a finite field inversion, a full-degree affine permutation polynomial and a key addition. Yet we show that even though the high degree of the affine polynomial may prevent some algebraic attacks (as claimed by the designers), the particular algebraic properties of the round function make both JARVIS and FRIDAY vulnerable to Gröbner basis attacks. We also consider MiMC, a block cipher similar in structure to JARVIS. However, this cipher proves to be resistant against our proposed attack strategy. Still, our successful cryptanalysis of JARVIS and FRIDAY does illustrate that block cipher designs for "algebraic platforms" such as STARKs, FHE or MPC may be particularly vulnerable to algebraic attacks.</p>

    <p class="text-gray-300">Keywords: Gröbner Basis, MARVELLOUS, Jarvis, Friday, MiMC, ZK-STARKs, Algebraic Cryptanalysis, Arithmetic Circuits</p>

    <p class="text-gray-300">Background. Whenever a computation on sensitive data is outsourced to an untrusted machine, one has to ensure that the result is correct. Examples are</p>

    <p class="text-gray-300">database updates, user authentications, and elections. The underlying problem, formally called computational integrity, has been theoretically solved since the 1990s with the emergence of the PCP theorem. But the performance of actual implementations was too poor to handle any computation of practical interest. Only recently a few proof systems have appeared where the proving time is quasi-linear in the computation length (which is typically represented as an arithmetic circuit), e.g. ZK-SNARKs <em>[x21]</em>, Bulletproofs <em>[x1]</em>, and ZK-STARKs <em>[x2]</em>. While they all share the overall structure, these proof systems differ in details such as the need of a trusted setup, proof size, verifier scalability, and post-quantum resistance.</p>

    <p class="text-gray-300">The cryptographic protocols that make use of such systems for zero-knowledge proofs often face the problem that whenever a hash function is involved, the associated circuit is typically long and complex, and thus the hash computation becomes a bottleneck in the proof. An example is the Zerocash cryptocurrency protocol <em>[x3]</em>: in order to spend a coin anonymously, one has to present a zero-knowledge proof that the coin is in the set of all valid coins, represented by a Merkle tree with coins as leaves. When a traditional hash function such as SHA-256 is used in the Merkle tree, the proof generation takes almost a minute for 28-level trees such as in Zcash <em>[x12]</em>, which represents a real obstacle to the widespread use of privacy-oriented cryptocurrencies.</p>

    <p class="text-gray-300">The demand for symmetric-key primitives addressing the needs of specific proof systems has been high, but only a few candidates have been proposed so far: a hash function based on Pedersen commitments <em>[x12]</em>, MPC-oriented LowMC <em>[x1]</em>, and big-field MiMC <em>[AGR+16, AGP+19]</em>. Even worse, different ZK proof systems use distinct computation representations. Concretely, ZK-SNARKs prefer pairing-friendly curves over prime scalar fields, Bulletproofs uses a fast curve over a scalar field, whereas ZK-STARKs are most comfortable operating over binary fields. Hence, the issue of different representations further limits the design space of ZK-friendly primitives.</p>

    <h5 id="sec-3" class="text-base font-semibold mt-4">STARKs</h5>

    <p class="text-gray-300">ZK-STARKs <em>[x1]</em> is a novel proof system which, in contrast to SNARKs, does not need a trusted setup phase and whose security relies only on the existence of collision-resistant hash functions. The computation is represented as an execution trace, with polynomial relations among the trace elements. Concretely, the trace registers must be elements of some large binary field, and the polynomials should have low degree. The proof generation time is approximately <span class="math">O(S\\log S)</span>, where</p>

    <p class="text-gray-300"><span class="math">S\\approx(\\text{Maximum polynomial degree}\\times\\text{Trace length})\\,.</span></p>

    <p class="text-gray-300">The STARK paper came with a proposal to use Rijndael-based hash functions, but as these have been shown to be insecure <em>[x11]</em>, custom designs are clearly needed.</p>

    <p class="text-gray-300">Jarvis and Friday. Ashur and Dhooghe recently addressed this need with the proposal of the block cipher Jarvis and the hash function Friday <em>[x1]</em>. The primitives were immediately endorsed by the ZK-STARK authors as possible solutions to reduce the STARK generation cost in many applications. The new hash function was claimed to offer up to a 20-fold advantage over Pedersen hashes and an advantage by a factor of 2.5 over MiMC-based hash functions, regarding the STARK proof generation time <em>[x4]</em>.</p>

    <p class="text-gray-300">Albeit similar in spirit to MiMC, Jarvis comes with novel design elements in order to considerably reduce the number of rounds, while still aiming to provide adequate security. In the original proposal several types of algebraic attacks were initially ruled out, and security arguments from Rijndael/AES were used to inform the choice of the number of rounds, leading to a statement that attacks were expected to cover up to three rounds only. An extra security margin was added, leading to a recommendation of 10 rounds for the variant with an expected security of 128 bits. Variants with higher claims of security were also specified.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Algebraic Attacks</h4>

    <p class="text-gray-300">This class of attacks aims to utilise the algebraic properties of a construction. One example is the Gröbner basis attack, which proceeds by modelling the underlying primitive as a multivariate system of equations which is then solved using off-the-shelf Gröbner basis algorithms <em>[x5, x11, x14, x12]</em>. After some initial success against certain stream cipher constructions <em>[x10, x11]</em>, algebraic attacks were also considered against block ciphers <em>[x22, x13]</em>, albeit with limited success. Even approaches combining algebraic and statistical techniques <em>[x2]</em> were later shown not to outperform known cryptanalytic techniques <em>[WSM+11]</em>. As a result algebraic attacks are typically not considered a major concern for new block ciphers. We note however that Gröbner basis methods have proven fruitful for attacking a number of public-key schemes <em>[FGO+10, x2, ACF+14, FPP+14, FGP+15]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Contribution</h4>

    <p class="text-gray-300">In this paper we show that, while the overall design approach of Jarvis and Friday seems sound, the choice for the number of rounds is not sufficient to offer adequate security. We do this by mounting algebraic attacks on the full-round versions of the primitives with the help of Gröbner bases. Our results show that designers of symmetric-key constructions targeting “algebraic platforms” – such as STARKs, FHE and MPC – must pay particular attention to the algebraic structure of their ciphers, and that algebraic attacks should receive renewed attention from the cryptographic community.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Organisation</h4>

    <p class="text-gray-300">The remainder of this work is organised as follows. In Section 2 we briefly describe the block cipher Jarvis and the hash function Friday. Following, we discuss various algebraic attacks in Section 3, including higher-order differential attacks, interpolation attacks, and in particular attacks using Gröbner</p>

    <p class="text-gray-300">bases. In the following sections, we describe our attacks, including key-recovery attacks on Jarvis in Section 4 and preimage attacks on Friday in Section 5. In Section 6, we describe our experimental results from running the attacks and discuss our findings. Finally, in Section 7 we analyse the S-box layer of Jarvis and compare it to the AES.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 MARVELlous</h2>

    <p class="text-gray-300">MARVELlous <em>[x1, x2]</em> is a family of cryptographic primitives specifically designed for STARK applications. It includes the block cipher Jarvis as well as Friday, a hash function based on this block cipher. We briefly describe the two primitives in this section.</p>

    <p class="text-gray-300">As usual, we identify functions on <span class="math">\\mathbb{F}_{2^{n}}</span> with elements in the quotient ring</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}:=\\mathbb{F}_{2^{n}}[X]/\\langle X^{2^{n}}-X\\rangle.</span></p>

    <p class="text-gray-300">Whenever it is clear from the context, we refer to the corresponding polynomial representation in the above quotient ring when we speak of a function on <span class="math">\\mathbb{F}_{2^{n}}</span> and use the notation <span class="math">F(X)</span>, or just <span class="math">F</span>, for the coset <span class="math">F(X)+\\langle X^{2^{n}}-X\\rangle\\in\\mathcal{R}</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Jarvis</h3>

    <p class="text-gray-300">Jarvis is a family of block ciphers operating on a state and a key of <span class="math">n</span> bits, thus working entirely over the finite field <span class="math">\\mathbb{F}_{2^{n}}</span>. The construction is based on ideas used by the AES, most prominently the <em>wide-trail design</em> strategy, which guarantees security against differential and linear (statistical) attacks. However, where AES uses multiple small S-boxes in every round, Jarvis applies a single nonlinear transformation to the whole state, essentially using one large <span class="math">n</span>-bit S-box. The S-box of Jarvis is defined as the generalised inverse function <span class="math">S\\!:\\!\\mathbb{F}_{2^{n}}\\to\\mathbb{F}_{2^{n}}</span> with</p>

    <p class="text-gray-300">\\[ S(x):=\\begin{cases}x^{-1}&x\\neq 0\\\\ 0&x=0,\\end{cases} \\]</p>

    <p class="text-gray-300">which corresponds to the element</p>

    <p class="text-gray-300"><span class="math">S(X):=X^{2^{n}-2}\\in\\mathcal{R}.</span></p>

    <p class="text-gray-300">We note that this specific S-box makes the construction efficient in the STARK setting, because verifying it uses only one quadratic constraint (note that for non-zero <span class="math">x\\in\\mathbb{F}_{2^{n}}</span> the equality <span class="math">\\frac{1}{x}=y</span> is equivalent to the equality <span class="math">x\\cdot y=1</span>, and the constraint for the full S-box can be written as <span class="math">x^{2}\\cdot y+x=0</span>). We refer to <em>[x1, x2]</em> for more details.</p>

    <p class="text-gray-300">The linear layer of Jarvis is composed by evaluating a high-degree affine polynomial</p>

    <p class="text-gray-300"><span class="math">A(X):=L(X)+\\hat{c}\\in\\mathcal{R},</span></p>

    <p class="text-gray-300">where  <span class="math">\\hat{c} \\in \\mathbb{F}_{2^n}</span>  is a constant and</p>

    <div class="my-4 text-center"><span class="math-block">L (X) := \\sum_ {i = 0} ^ {n - 1} l _ {2 ^ {i}} \\cdot X ^ {2 ^ {i}} \\in \\mathcal {R}</span></div>

    <p class="text-gray-300">is a linearised permutation polynomial. Note that the set of all linearised permutation polynomials in  <span class="math">\\mathcal{R}</span>  forms a group under composition modulo  <span class="math">X^{2^n} - X</span> , also known as the Betti-Mathieu group [LN96].</p>

    <p class="text-gray-300">In JARVIS, the polynomial  <span class="math">A</span>  is built from two affine monic permutation polynomials  <span class="math">B, C</span>  of degree 4, that is</p>

    <div class="my-4 text-center"><span class="math-block">B (X) := L _ {B} (X) + b _ {0} := X ^ {4} + b _ {2} X ^ {2} + b _ {1} X + b _ {0} \\in \\mathcal {R}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">C (X) := L _ {C} (X) + c _ {0} := X ^ {4} + c _ {2} X ^ {2} + c _ {1} X + c _ {0} \\in \\mathcal {R}</span></div>

    <p class="text-gray-300">satisfying the equation</p>

    <div class="my-4 text-center"><span class="math-block">A = C \\circ B ^ {- 1}.</span></div>

    <p class="text-gray-300">The operator  <span class="math">\\circ</span>  indicates composition modulo  <span class="math">X^{2^n} - X</span>  and  <span class="math">B^{-1}</span>  denotes the compositional inverse of  <span class="math">B</span>  (with respect to the operator  <span class="math">\\circ</span> ) given by</p>

    <div class="my-4 text-center"><span class="math-block">B ^ {- 1} (X) := L _ {B} ^ {- 1} (X) + L _ {B} ^ {- 1} (b _ {0}).</span></div>

    <p class="text-gray-300">Here,  <span class="math">L_B^{-1}</span>  denotes the inverse of  <span class="math">L_B</span>  under composition modulo  <span class="math">X^{2^n} - X</span> , or in other words, the inverse of  <span class="math">L_B</span>  in the Betti-Mathieu group. We highlight that the inverse  <span class="math">B^{-1}</span>  shares the same affine structure with  <span class="math">B</span> , i.e. it is composed of a linearised permutation polynomial  <span class="math">L_B^{-1}</span>  and a constant term in  <span class="math">\\mathbb{F}_{2^n}</span> , but has a much higher degree.</p>

    <p class="text-gray-300">One round of JARVIS is shown in Figure 1. Additionally, a whitening key  <span class="math">k_{0}</span>  is applied before the first round.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: One round of the JARVIS block cipher. For simplicity, the addition of the whitening key is omitted.</p>

    <p class="text-gray-300"><strong>Key Schedule</strong> The key schedule of JARVIS shares similarities with the round function itself, the main difference being that the affine transformations are omitted. In the key schedule, the first key  <span class="math">k_{0}</span>  is the master key and the next round key  <span class="math">k_{i+1}</span>  is calculated by adding a round constant  <span class="math">c_{i}</span>  to the (generalised) inverse  <span class="math">S(k_{i})</span>  of the previous round key  <span class="math">k_{i}</span> . One round of the key schedule is depicted in Figure 2.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: The key schedule used by the JARVIS block cipher.</p>

    <p class="text-gray-300">The first round constant  <span class="math">c_{0}</span>  is randomly selected from  <span class="math">\\mathbb{F}_{2^n}</span> , while subsequent round constants  <span class="math">c_{i}, 1 \\leq i \\leq r</span> , are calculated using the relation</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} := a \\cdot c _ {i - 1} + b</span></div>

    <p class="text-gray-300">for random elements  <span class="math">a, b \\in \\mathbb{F}_{2^n}</span> .</p>

    <p class="text-gray-300">Instantiations The authors of [AD18] propose four instances of JARVIS- <span class="math">n</span> , where  <span class="math">n \\in \\{128, 160, 192, 256\\}</span> . For each of these instances the values  <span class="math">c_1</span> ,  <span class="math">a</span> ,  <span class="math">b</span> , and the polynomials  <span class="math">B</span>  and  <span class="math">C</span>  are specified. Table 1 presents the recommended number of rounds  <span class="math">r</span>  for each instance, where the claimed security level is equal to the key size (and state size)  <span class="math">n</span> . We will use  <span class="math">r \\in \\mathbb{N}</span>  throughout this paper to denote the number of rounds of a specific instance.</p>

    <p class="text-gray-300">Table 1: Instances of the JARVIS block cipher [AD18].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># of rounds r</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JARVIS-128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JARVIS-160</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JARVIS-192</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">JARVIS-256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FRIDAY is a hash function based on a Merkle-Damgård construction, where the block cipher JARVIS is transformed into a compression function using the Miyaguchi-Preneel scheme. In this scheme, a (padded) message block  <span class="math">m_i</span> ,  <span class="math">1 \\leq i \\leq t</span> , serves as input  <span class="math">m</span>  to a block cipher  <span class="math">E(m,k)</span>  and the respective previous hash value  <span class="math">h_{i-1}</span>  serves as key  <span class="math">k</span> . The output of the block cipher is then added to the sum of  <span class="math">m_i</span>  and  <span class="math">h_{i-1}</span> , resulting in the new hash value  <span class="math">h_i</span> . The first hash value  <span class="math">h_0</span>  is an initialization vector and taken to be the zero element in  <span class="math">\\mathbb{F}_{2^n}</span>  in the case of FRIDAY. The final state  <span class="math">h_t</span>  is the output of the hash function. The hash function FRIDAY is thus defined by the following iterative formula</p>

    <div class="my-4 text-center"><span class="math-block">h _ {0} := I V := 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">h _ {i} := E \\left(m _ {i}, h _ {i - 1}\\right) + h _ {i - 1} + m _ {i},</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\leq i \\leq t</span> , as illustrated in Figure 3.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: The FRIDAY hash function.</p>

    <p class="text-gray-300">From an algebraic point of view, JARVIS offers security mainly by delivering a high degree for its linear transformations and for the S-box. In the original proposal, the authors analyse the security against various algebraic attack vectors, such as higher-order differential attacks and interpolation attacks.</p>

    <p class="text-gray-300">Higher-order differential attacks [Knu95] can be regarded as algebraic attacks that exploit the low algebraic degree of a nonlinear transformation. If this degree is low enough, an attack using multiple plaintexts and their corresponding ciphertexts can be mounted. In more detail, if the algebraic degree of a Boolean function  <span class="math">f</span>  is  <span class="math">d</span> , then when applying  <span class="math">f</span>  to all elements of an affine vector space  <span class="math">\\mathcal{V} \\oplus c</span>  of dimension  <span class="math">&amp;gt; d</span>  and taking the sum of these values, the result is 0, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\bigoplus_ {v \\in \\mathcal {V} \\oplus c} v = \\bigoplus_ {v \\in \\mathcal {V} \\oplus c} f (v) = 0.</span></div>

    <p class="text-gray-300">Finding such a distinguisher possibly allows the attacker to recover the secret key.</p>

    <p class="text-gray-300">However, higher-order differential attacks pose no threat to JARVIS. Indeed, the algebraic degree of  <span class="math">S(X) = X^{2^n - 2}</span>  is the Hamming weight of  <span class="math">2^n - 2</span> , which is equal to  <span class="math">n - 1</span>  and thus maximal (note that the S-box is a permutation). This makes higher-order differential attacks and zero-sum distinguishers infeasible after only one round of JARVIS.</p>

    <p class="text-gray-300">Interpolation attacks were introduced in 1997 [JK97] and are another type of algebraic attack where the attacker constructs the polynomial corresponding to the encryption (or decryption) function without knowing the secret key. The basis of interpolation attacks is a consequence of the Fundamental Theorem of Algebra: given  <span class="math">d + 1</span>  pairs  <span class="math">(x_0, y_0), \\ldots, (x_d, y_d)</span>  of elements in a certain field  <span class="math">\\mathbb{F}</span> , there is a unique polynomial  <span class="math">P(X) \\in \\mathbb{F}[X]</span>  of degree at most  <span class="math">d</span>  which satisfies</p>

    <div class="my-4 text-center"><span class="math-block">P (x _ {i}) = y _ {i}</span></div>

    <p class="text-gray-300">for all <span class="math">0\\leq i\\leq d</span>. To put it another way, the polynomial <span class="math">P(X)</span> interpolates the given pairs <span class="math">(x_{i},y_{i})</span>, which is why it deserves the denotation interpolation polynomial. There are several approaches for calculating all the coefficients of the interpolation polynomial. A classical technique is to choose Lagrange’s basis <span class="math">(L_{0},L_{1},\\ldots,L_{d})</span>, with</p>

    <p class="text-gray-300"><span class="math">L_{i}(X):=\\prod_{j=0\\atop j\\neq i}^{d}\\frac{X-x_{j}}{x_{i}-x_{j}}\\in\\mathbb{F}[X]\\,,</span></p>

    <p class="text-gray-300">as a basis for the <span class="math">\\mathbb{F}</span>-vector space <span class="math">\\mathbb{F}[X]</span> and read off the solution <span class="math">(p_{0},\\ldots,p_{d})</span> from the resulting system of equations</p>

    <p class="text-gray-300"><span class="math">y_{i}=P(x_{i})=p_{0}L_{0}(x_{i})+p_{1}L_{1}(x_{i})+\\ldots+p_{d}L_{d}(x_{i}),\\,0\\leq i\\leq d.</span></p>

    <p class="text-gray-300">Lagrange’s basis leads to a complexity of <span class="math">\\mathcal{O}(d^{2})</span> field operations and so does Newton’s basis <span class="math">\\{N_{0},N_{1},\\ldots,N_{d}\\}</span> with</p>

    <p class="text-gray-300"><span class="math">N_{i}(X):=\\prod_{j=0}^{i-1}(X-x_{j})\\in\\mathbb{F}[X]\\,.</span></p>

    <p class="text-gray-300">A different approach uses the fact that polynomial interpolation can be reduced to polynomial evaluation, as discussed by Horowitz <em>[x10]</em> and Kung <em>[x13]</em>, leading to a complexity of <span class="math">\\mathcal{O}(d\\log^{2}d)</span> field operations. In essence, this approach relies on the Fast Fourier Transform for polynomial multiplication.</p>

    <p class="text-gray-300">From the above complexity estimates, it is thus desirable that the polynomial representation of the encryption function reaches a high degree and forces all possible monomials to appear. In Jarvis, a high word-level degree is already reached after only one round; additionally the polynomial expression of the encryption function is also dense after only two rounds. It follows that interpolation attacks pose no threat to Jarvis.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.3 Gröbner Basis Attacks</h3>

    <p class="text-gray-300">The first step in a Gröbner basis attack is to describe the primitive by a system of polynomial equations. Subsequently, a Gröbner basis <em>[x2, x4]</em> for the ideal defined by the corresponding polynomials is calculated and finally used to solve for specified variables. In more detail, Gröbner basis attacks consist of three phases:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set up an equation system and compute a Gröbner basis (typically for the degrevlex term order for performance reasons) using an algorithm such as Buchberger’s algorithm <em>[x2]</em>, F4 <em>[x7]</em>, or F5 <em>[x8]</em>.</li>

      <li>Perform a change of term ordering for the computed Gröbner basis (typically going from the degrevlex term order to the lex one, which facilitates</li>

    </ol>

    <p class="text-gray-300">computing elimination ideals and hence eliminating variables) using an algorithm such as FGLM <em>[FGL+93]</em>. Note that in our applications all systems of algebraic equations result in zero-dimensional ideals, i.e. the systems have only finitely many solutions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Solve the univariate equation for the last variable using a polynomial factoring algorithm, and substitute into other equations to obtain the full solution of the system.</li>

    </ol>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Cost of Gröbner Basis Computation</h4>

    <p class="text-gray-300">For a generic system of <span class="math">n_{e}</span> polynomial equations</p>

    <p class="text-gray-300"><span class="math">F_{1}(x_{1},\\ldots,x_{n_{v}})=F_{2}(x_{1},\\ldots,x_{n_{v}})=\\cdots=F_{n_{e}}(x_{1},\\ldots,x_{n_{v}})=0</span></p>

    <p class="text-gray-300">in <span class="math">n_{v}</span> variables <span class="math">x_{1},\\ldots,x_{n_{v}}</span>, the complexity of computing a Gröbner basis <em>[BFP+12]</em> is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{GB}}\\in\\mathcal{O}\\left(\\binom{n_{v}+D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}\\right)^{\\omega},</span> (1)</p>

    <p class="text-gray-300">where <span class="math">2\\leq\\omega&lt;3</span> is the linear algebra exponent representing the complexity of matrix multiplication and <span class="math">D_{\\mathrm{reg}}</span> is the degree of regularity. The constants hidden by <span class="math">\\mathcal{O}(\\cdot)</span> are relatively small, which is why <span class="math">\\binom{n_{v}+D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}^{\\omega}</span> is typically used directly. In general, computing the degree of regularity is a hard problem. However, the degree of regularity for “regular sequences” <em>[BFS+05]</em> is given by</p>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{reg}}=1+\\sum_{i=1}^{n_{e}}(d_{i}-1),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">d_{i}</span> is the degree of <span class="math">F_{i}</span>. Regular sequences have <span class="math">n_{e}=n_{v}</span>. More generally, for “semi-regular sequences” (the generalisation of regular sequences to <span class="math">n_{e}&gt;n_{v}</span>) the degree of regularity can be computed as the index of the first non-positive coefficient in</p>

    <p class="text-gray-300"><span class="math">H(z)=\\frac{1}{\\left(1-z\\right)^{n_{v}}}\\times\\prod_{i=1}^{n_{e}}(1-z^{d_{i}}).</span></p>

    <p class="text-gray-300">It is conjectured that most sequences are semi-regular <em>[Frö85]</em>. Indeed, experimental evidence suggests random systems behave like semi-regular systems with high probability. Hence, assuming our target systems of equations behave like semi-regular sequences, i.e. they have no additional structure, the complexity of computing a Gröbner basis depends on (a) the number of equations <span class="math">n_{e}</span>, (b) the degrees <span class="math">d_{1},d_{2},\\ldots,d_{n_{e}}</span> of the equations, and (c) the number of variables <span class="math">n_{v}</span>. Crucially, our experiments described later in the paper indicate that the systems considered in this work do not behave like regular sequences.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Cost of Gröbner Basis Conversion</h4>

    <p class="text-gray-300">The complexity of the FGLM algorithm <em>[FGL+93]</em> is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{FGLM}}\\in\\mathcal{O}\\left(n_{v}\\cdot\\deg(\\mathcal{I})^{3}\\right),</span> (3)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\deg(\\mathcal{I})</span> is called the <em>degree of the ideal</em> and defined as the dimension of the quotient ring <span class="math">\\mathbb{F}[X_{1},X_{2},\\ldots,X_{n}]/\\mathcal{I}</span> as an <span class="math">\\mathbb{F}</span>-vector space. For the systems we are considering in this paper – which are expected to have a unique solution in <span class="math">\\mathbb{F}</span> – the dimension of <span class="math">R/\\mathcal{I}</span> corresponds to the degree of the unique univariate polynomial equation in the reduced Gröbner basis with respect to the canonical lexicographic order <em>[x11, Theorem 3.7.25]</em>. Again, the hidden constants are small, permitting to use <span class="math">n_{v}\\cdot\\deg(\\mathcal{I})^{3}</span> directly. A sparse variant of the algorithm also exists <em>[x9]</em> with complexity <span class="math">\\mathcal{O}\\left(\\deg(\\mathcal{I})(N_{1}+n_{v}\\log\\deg(\\mathcal{I}))\\right)</span>, where <span class="math">N_{1}</span> is the number of nonzero entries of a multiplication matrix, which is sparse even if the input system spanning <span class="math">\\mathcal{I}</span> is dense. Thus, the key datum to establish for estimating the cost of this step is <span class="math">\\deg(\\mathcal{I})</span>.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Cost of Factoring</h4>

    <p class="text-gray-300">Finally, we need to solve for the last variable using the remaining univariate polynomial equation obtained by computing all necessary elimination ideals. This can be done by using a factorisation algorithm. For example, the complexity of a modified version of the Berlekamp algorithm <em>[x10]</em> to factorise a polynomial <span class="math">P</span> of degree <span class="math">D</span> over <span class="math">\\mathbb{F}_{2^{n}}</span> is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{Sol}}\\in\\mathcal{O}\\left(D^{3}n^{2}+Dn^{3}\\right).</span> (4)</p>

    <p class="text-gray-300">In our context, we can however reduce the cost of this step by performing the first and second steps of the attack for two (or more) (plaintext, ciphertext) pairs and then considering the GCD of the resulting univariate polynomials, which are univariate in the secret key variable <span class="math">k_{0}</span>. Computing polynomial GCDs is quasi-linear in the degree of the input polynomials. In particular, we expect</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}_{\\mathrm{Sol}}\\in\\mathcal{O}\\left(D(\\log(D))^{2}\\right).</span> (5)</p>

    <p class="text-gray-300">We will again drop the <span class="math">\\mathcal{O}(\\cdot)</span> and use the expressions directly.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Our Algebraic Attacks on <em>MARVELLOUS</em></h4>

    <p class="text-gray-300">All attacks on MARVELLOUS presented in this paper are inherently Gröbner basis attacks which, on the one hand, are based on the fact that the S-box <span class="math">S(X)=X^{2^{n}-2}</span> of Jarvis can be regarded as the function <span class="math">S\\!:\\!\\mathbb{F}_{2^{n}}\\to\\mathbb{F}_{2^{n}}</span>, where</p>

    <p class="text-gray-300"><span class="math">S(x)=x^{-1}</span></p>

    <p class="text-gray-300">for all elements <em>except</em> the zero element in <span class="math">\\mathbb{F}_{2^{n}}</span>. As a consequence, the relation</p>

    <p class="text-gray-300"><span class="math">y=S(x)=x^{-1}</span></p>

    <p class="text-gray-300">can be rewritten as an equation of degree <span class="math">2</span> in two variables, namely</p>

    <p class="text-gray-300"><span class="math">x\\cdot y=1,</span></p>

    <p class="text-gray-300">which holds everywhere except for the zero element in <span class="math">\\mathbb{F}_{2^{n}}</span>. We will use this relation in our attacks, noting that <span class="math">x=0</span> occurs with a negligibly small probability for <span class="math">n\\geq 128</span></p>

    <p class="text-gray-300">On the other hand, we exploit the fact that the decomposition of the affine polynomial <span class="math">A</span> originates from two low-degree polynomials <span class="math">B</span> and <span class="math">C</span>. When setting up the associated equations for Jarvis, we introduce intermediate variables in such a way that the low degree of <span class="math">B</span> and <span class="math">C</span> comes into effect, and then show that the particular combination of the inverse S-box <span class="math">S(X)=X^{2^{n}-2}</span> with the affine layer in Jarvis is vulnerable to Gröbner basis attacks.</p>

    <p class="text-gray-300">Based on the above observations, we describe in the next sections:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a key-recovery attack on reduced-round Jarvis and an optimised key-recovery attack on full-round Jarvis;</li>

      <li>its extension to a (two-block) preimage attack on full-round Friday;</li>

      <li>a more efficient direct preimage attack on full-round Friday.</li>

    </ul>

    <h2 id="sec-18" class="text-2xl font-bold">4 Gröbner Basis Computation for Jarvis</h2>

    <p class="text-gray-300">We first describe a straightforward approach, followed by various optimisations which are necessary to extend the attack to all rounds.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.1 Reduced-Round Jarvis</h3>

    <p class="text-gray-300">Let <span class="math">B,C\\in\\mathcal{R}</span> be the polynomials of the affine layer in Jarvis. Furthermore, in round <span class="math">i</span> of Jarvis let us denote the intermediate state between the application of <span class="math">B^{-1}</span> and <span class="math">C</span> as <span class="math">x_{i}</span>, for <span class="math">1\\leq i\\leq r</span> (see Figure 4).</p>

    <p class="text-gray-300">Fig. 4: Intermediate state <span class="math">x_{i}</span> in one round of the encryption path.</p>

    <p class="text-gray-300">As a result, two consecutive rounds of Jarvis can be related by the equation</p>

    <p class="text-gray-300"><span class="math">(C(x_{i})+k_{i})\\cdot B(x_{i+1})=1</span> (6)</p>

    <p class="text-gray-300">for <span class="math">1\\leq i\\leq r-1</span>. As both polynomials <span class="math">B</span> and <span class="math">C</span> have degree 4, equation (6) yields a system of <span class="math">r-1</span> polynomial equations, each of degree 8, in the variables <span class="math">x_{1},\\ldots,x_{r}</span> and <span class="math">k_{0},\\ldots,k_{r}</span>. To make the system dependent on the plaintext <span class="math">p</span> and the ciphertext <span class="math">c</span>, we add the two equations</p>

    <p class="text-gray-300"><span class="math">B(x_{1})\\cdot(p+k_{0})</span> <span class="math">=1,</span> (7) <span class="math">C(x_{r})</span> <span class="math">=c+k_{r}</span> (8)</p>

    <p class="text-gray-300">to this system. Additionally, two successive round keys are connected through the equation</p>

    <p class="text-gray-300"><span class="math">(k_{i+1}+c_{i})\\cdot k_{i}=1</span> (9)</p>

    <p class="text-gray-300">for <span class="math">0\\leq i\\leq r-1</span>. In total, the above description of Jarvis amounts to <span class="math">2\\cdot r+1</span> equations in <span class="math">2\\cdot r+1</span> variables, namely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">r-1</span> equations of degree <span class="math">8</span> (equation (6)),</li>

      <li>one equation of degree <span class="math">5</span> (equation (7)),</li>

      <li>one equation of degree <span class="math">4</span> (equation (8)),</li>

      <li><span class="math">r</span> equations of degree <span class="math">2</span> (equation (9)),</li>

    </ul>

    <p class="text-gray-300">in the <span class="math">2\\cdot r+1</span> variables <span class="math">x_{1},\\ldots,x_{r}</span> and <span class="math">k_{0},\\ldots,k_{r}</span>. Since the number of equations is equal to the number of variables, we can estimate the complexity of a Gröbner basis attack by using Equation (2). According to this estimate, the computation of a Gröbner basis for the above system of equations is prohibitively expensive for full-round Jarvis. For example, Equation (2) predicts a complexity of <span class="math">\\approx 120</span> bits (when setting <span class="math">\\omega=2.8</span>) for computing a Gröbner basis for <span class="math">r=6</span>. However, we note that we were able to compute such a basis in practice (Section 6), which indicates that the above estimate is too pessimistic.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.2 Optimisations for an attack on Full-Round Jarvis</h3>

    <p class="text-gray-300">In order to optimise the computation from the previous section and extend it to full-round Jarvis, we introduce two main improvements. First, we reduce the number of variables and equations used for intermediate states. Secondly, we relate all round keys to the master key, which helps to further reduce the number of variables.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">A More Efficient Description of Intermediate States</h4>

    <p class="text-gray-300">The main idea is to reduce the number of equations and variables for intermediate states at the expense of an increased degree in some of the remaining equations. By relating a fixed intermediate state <span class="math">x_{i}</span> to the respective preceding and succeeding intermediate states <span class="math">x_{i-1}</span> and <span class="math">x_{i+1}</span>, we obtain the equations</p>

    <p class="text-gray-300"><span class="math">B(x_{i})</span> <span class="math">=\\frac{1}{C(x_{i-1})+k_{i-1}},</span> (10) <span class="math">C(x_{i})</span> <span class="math">=\\frac{1}{B(x_{i+1})}+k_{i}</span> (11)</p>

    <p class="text-gray-300">for <span class="math">2\\leq i\\leq r-1</span>. Since both <span class="math">B</span> and <span class="math">C</span> are <em>monic affine</em> polynomials of degree <span class="math">4</span>, we claim that it is possible to find <em>monic affine</em> polynomials</p>

    <p class="text-gray-300"><span class="math">D(X):=X^{4}+d_{2}X^{2}+d_{1}X+d_{0}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">E(X):=X^{4}+e_{2}X^{2}+e_{1}X+e_{0},</span></p>

    <p class="text-gray-300">also of degree <span class="math">4</span>, such that</p>

    <p class="text-gray-300"><span class="math">D(B)=E(C).</span></p>

    <p class="text-gray-300">Indeed, comparing corresponding coefficients of <span class="math">D(B)</span> and <span class="math">E(C)</span> yields a system of 5 linear equations in the 6 unknown coefficients <span class="math">d_{0},d_{1},d_{2},e_{0},e_{1},e_{2}</span>, which can then be solved. We explain the construction of <span class="math">D</span> and <span class="math">E</span> in more detail in Appendix A.</p>

    <p class="text-gray-300">From now on let us assume we have already found appropriate polynomials <span class="math">D</span> and <span class="math">E</span>. After applying <span class="math">D</span> and <span class="math">E</span> to Equation (10) and Equation (11), respectively, we equate the right-hand side parts of the resulting equations and get</p>

    <p class="text-gray-300"><span class="math">D\\left(\\frac{1}{C(x_{i-1})+k_{i-1}}\\right)=E\\left(\\frac{1}{B(x_{i+1})}+k_{i}\\right)</span> (12)</p>

    <p class="text-gray-300">for <span class="math">2\\leq i\\leq r-1</span>. Eventually we obtain a system of polynomial equations of degree 36 by clearing denominators in Equation (12).</p>

    <p class="text-gray-300">The crucial point is that variables for every second intermediate state may now be dropped out of the description of Jarvis. This is because we can consider either only evenly indexed states or only odd ones, and by doing so, we have essentially halved the number of equations and variables needed to describe intermediate states. We note that in all optimised versions of our attacks we only work with <em>evenly</em> indexed intermediate states, as this choice allows for a more efficient description of Jarvis compared to working with odd ones.</p>

    <p class="text-gray-300">Finally we relate the plaintext <span class="math">p</span> and the ciphertext <span class="math">c</span> to the appropriate intermediate state <span class="math">x_{2}</span> and <span class="math">x_{r}</span>, respectively, and set</p>

    <p class="text-gray-300"><span class="math">D\\left(\\frac{1}{p+k_{0}}\\right)</span> <span class="math">=E\\left(\\frac{1}{B(x_{2})}+k_{1}\\right),</span> (13) <span class="math">C(x_{r})+k_{r}</span> <span class="math">=c.</span> (14)</p>

    <p class="text-gray-300">Here, the degree of Equation (13) is 24, while Equation (14) has degree 4.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">Remarks.</h5>

    <p class="text-gray-300">It is worth pointing out that the above description uses several implicit assumptions. First, it may happen that some intermediate states become zero, with the consequence that our approach will not find a solution. However, this case only occurs with a negligibly small probability, in particular when considering instances with <span class="math">n\\geq 128</span>. If this event occurs we can use another plaintext-ciphertext pair. Secondly, when we solve the optimised system of equations (i.e. the system we obtain after applying <span class="math">D</span> and <span class="math">E</span>), not all of the solutions we find for this system are guaranteed to be valid solutions for the original system of equations. Lastly, Equation (14) implicitly assumes an even number of rounds. If we wanted to attack an odd number of rounds instead, this equation had to be adjusted accordingly.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">3.2.2 Relating Round Keys to the Master Key</h4>

    <p class="text-gray-300">Two consecutive round keys in Jarvis are connected by the relation</p>

    <p class="text-gray-300"><span class="math">k_{i+1}=\\frac{1}{k_{i}}+c_{i}</span></p>

    <p class="text-gray-300">if  <span class="math">k_{i} \\neq 0</span> , which is true with high probability for large state sizes  <span class="math">n</span> . As a consequence, each round key is a rational function of the master key  <span class="math">k_{0}</span>  of degree 1, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">k _ {i + 1} = \\frac {\\alpha_ {i} \\cdot k _ {0} + \\beta_ {i}}{\\gamma_ {i} \\cdot k _ {0} + \\delta_ {i}}.</span></div>

    <p class="text-gray-300">We provide the exact values for  <span class="math">\\alpha_{i}</span> ,  <span class="math">\\beta_{i}</span> ,  <span class="math">\\gamma_{i}</span> , and  <span class="math">\\delta_{i}</span>  in Appendix B. Expressing  <span class="math">k_{i}</span>  as a rational function of  <span class="math">k_{0}</span>  in Equation (12) and Equation (14) raises the total degree of these equations to 40 and 5, respectively. On the other hand, the degree of Equation (13) remains unchanged.</p>

    <p class="text-gray-300">Assuming the number of rounds  <span class="math">r</span>  to be even, the aforementioned two improvements yield</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\frac{r}{2} - 1</span>  equations of degree 40 (equation (12)),</li>

      <li>one equation of degree 24 (equation (13)),</li>

      <li>one equation of degree 5 (equation (14)),</li>

    </ul>

    <p class="text-gray-300">in  <span class="math">\\frac{r}{2} + 1</span>  variables (the intermediate states  <span class="math">x_{2}, x_{4}, \\ldots, x_{r}</span>  and the master key  <span class="math">k_{0}</span> ). Since the number of equations equals the number of variables, we may calculate the degree of regularity using Equation (2), again assuming the system behaves like a regular sequence.</p>

    <p class="text-gray-300">Our results for the degree of regularity, and thus also for the complexity of computing a Gröbner basis, are listed in Table 2. Note that we assume  <span class="math">\\omega = 2.8</span> . However, this is possibly a pessimistic choice, as the regarded systems are sparse. We therefore also give the complexities for  <span class="math">\\omega = 2</span>  in parentheses.</p>

    <p class="text-gray-300">Table 2: Complexity estimates of Gröbner basis computations for  <span class="math">r</span> -round JARVIS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">nv</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dreg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity in bits</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">63 (45)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">145</td>

            <td class="px-3 py-2 border-b border-gray-700">82 (58)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10 (JARVIS-128)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">184</td>

            <td class="px-3 py-2 border-b border-gray-700">100 (72)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12 (JARVIS-192)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">119 (85)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14 (JARVIS-256)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">262</td>

            <td class="px-3 py-2 border-b border-gray-700">138 (98)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">301</td>

            <td class="px-3 py-2 border-b border-gray-700">156 (112)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">340</td>

            <td class="px-3 py-2 border-b border-gray-700">175 (125)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">379</td>

            <td class="px-3 py-2 border-b border-gray-700">194 (138)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These values show that we are able to compute Gröbner bases for, and therefore successfully attack, all full-round versions of JARVIS. We note that, even</p>

    <p class="text-gray-300">when pessimistically assuming that the memory complexity of a Gröbner basis computation is asymptotically the same as its time complexity (the memory complexity of any algorithm is bounded by its time complexity) and when considering the time-memory product (which is highly pessimistic from an attacker's point of view), our attacks against JARVIS-256 are still valid.</p>

    <p class="text-gray-300">In this section, we let  <span class="math">F: \\mathbb{F}_{2^n} \\times \\mathbb{F}_{2^n} \\to \\mathbb{F}_{2^n}</span>  indicate the application of one block of FRIDAY.</p>

    <p class="text-gray-300">Using the same equations as for JARVIS described in Section 4, a preimage attack on FRIDAY may also be mounted. At its heart, the attack on FRIDAY with  <span class="math">r</span>  rounds is an attack on JARVIS with  <span class="math">r - 1</span>  rounds.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 5: Two blocks of FRIDAY.</p>

    <p class="text-gray-300">We work with two blocks of FRIDAY, hence a message  <span class="math">m</span>  is the concatenation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m = m _ {1} \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m _ {2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">of two message blocks  <span class="math">m_1, m_2 \\in \\mathbb{F}_{2^n}</span> . The output of the first block is denoted by  <span class="math">h_1</span>  and the known (final) hash value of the second block is denoted by  <span class="math">h_2</span> . The hash values  <span class="math">h_1</span>  and  <span class="math">h_2</span>  can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">h _ {1} = F (m _ {1}, I V)</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">h _ {2} = F (m _ {2}, h _ {1}).</span></div>

    <p class="text-gray-300">The initialization vector  <span class="math">IV</span>  is just the zero element in  <span class="math">\\mathbb{F}_{2^n}</span> . We refer to Figure 5 for an illustration of the introduced notation.</p>

    <p class="text-gray-300">Our preimage attack proceeds as follows: in the first part, we use random values  <span class="math">\\hat{m}_1</span>  for the input to the first block to populate a table  <span class="math">T_1</span>  in which each</p>

    <p class="text-gray-300">entry contains a pair <span class="math">(\\hat{m}_{1},\\hat{h}_{1})</span>, where <span class="math">\\hat{h}_{1}</span> denotes the corresponding intermediate hash value</p>

    <p class="text-gray-300"><span class="math">\\hat{h}_{1}:=F(\\hat{m}_{1},IV).</span></p>

    <p class="text-gray-300">In the second part, we find pairs <span class="math">(m^{\\prime}_{2},h^{\\prime}_{1})</span> with</p>

    <p class="text-gray-300"><span class="math">F(m^{\\prime}_{2},h^{\\prime}_{1})=h_{2},</span></p>

    <p class="text-gray-300">or in other words, pseudo preimages for the known hash value <span class="math">h_{2}</span>. To find such a pseudo preimage, we fix the sum <span class="math">m_{2}+h_{1}</span> to an arbitrary value <span class="math">v_{0}\\in\\mathbb{F}_{2^{n}}</span>, i.e. we set</p>

    <p class="text-gray-300"><span class="math">v_{0}:=m_{2}+h_{1}.</span></p>

    <p class="text-gray-300">This has two effects:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the second block, the value <span class="math">v_{1}</span> entering the first round of Jarvis is fixed and known until the application of the second round key. Essentially, this means that one round of Jarvis can be skipped.</li>

      <li>Since <span class="math">v_{0}=m_{2}+h_{1}</span> is fixed and known, the final output <span class="math">v_{2}</span> of Jarvis is defined by</li>

    </ol>

    <p class="text-gray-300"><span class="math">v_{2}:=v_{0}+h_{2}</span></p>

    <p class="text-gray-300">and thus also known.</p>

    <p class="text-gray-300">In the current scenario, the intermediate hash value <span class="math">h_{1}</span> serves as master key for the <span class="math">r</span> round keys <span class="math">k_{1},k_{2},\\ldots,k_{r}</span> applied in the second block. Using <span class="math">v_{1}</span> as plaintext and <span class="math">v_{2}</span> as ciphertext, an attack on Jarvis with <span class="math">r-1</span> rounds is sufficient to reveal these round keys. Once one of the round keys is recovered, we calculate the second part <span class="math">h^{\\prime}_{1}</span> of a pseudo preimage <span class="math">(m^{\\prime}_{2},h^{\\prime}_{1})</span> by applying the inverse key schedule to the recovered key. Finally, we set</p>

    <p class="text-gray-300"><span class="math">m^{\\prime}_{2}:=h^{\\prime}_{1}+v_{0}</span></p>

    <p class="text-gray-300">and thereby obtain the remaining part of a pseudo preimage. How the presented pseudo preimage attack on <span class="math">r</span>-round Friday reduces to a key-recovery attack on <span class="math">(r-1)</span>-round Jarvis is outlined in Figure 6.</p>

    <p class="text-gray-300">Conceptually, we repeat the pseudo preimage attack many times (for different values of <span class="math">v_{0}</span>) and store the resulting pairs <span class="math">(m^{\\prime}_{2},h^{\\prime}_{1})</span> in a table <span class="math">T_{2}</span>. The aim is to produce matching entries <span class="math">(\\hat{m}_{1},\\hat{h}_{1})</span> and <span class="math">(m^{\\prime}_{2},h^{\\prime}_{1})</span> in <span class="math">T_{1}</span> and <span class="math">T_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\hat{h}_{1}=h^{\\prime}_{1},</span></p>

    <p class="text-gray-300">which implies</p>

    <p class="text-gray-300"><span class="math">F(m^{\\prime}_{2},F(\\hat{m}_{1},IV))=F(m^{\\prime}_{2},\\hat{h}_{1})=F(m^{\\prime}_{2},h^{\\prime}_{1})=h_{2},</span></p>

    <p class="text-gray-300">giving us the preimage <span class="math">(\\hat{m}_{1},m^{\\prime}_{2})</span> we are looking for.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 6: Internals of the second block of Friday. The values <span class="math">v_{0}</span>, <span class="math">v_{1}</span> and <span class="math">v_{2}</span> are known.</p>

    <p class="text-gray-300">The (input, output) pairs <span class="math">(v_{1},v_{2})</span> we use for the underlying key-recovery attack on Jarvis are not proper pairs provided by, e.g., an encryption oracle for Jarvis. Thus, it may happen that for some pairs <span class="math">(v_{1},v_{2})</span> the key-recovery attack does not succeed, i.e. there is no key <span class="math">h_{1}^{\\prime}</span> which maps <span class="math">v_{1}</span> to <span class="math">v_{2}</span>. The probability for such an event is</p>

    <p class="text-gray-300"><span class="math">P_{\\text{fail}}=\\left(\\frac{2^{n}-1}{2^{n}}\\right)^{2^{n}}=\\left(1-\\frac{1}{2^{n}}\\right)^{2^{n}}\\approx\\lim_{k\\rightarrow\\infty}\\left(1-\\frac{1}{k}\\right)^{k}=\\frac{1}{e}</span></p>

    <p class="text-gray-300">for large <span class="math">n</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.2 Complexity of Generating Pseudo Preimages</h3>

    <p class="text-gray-300">The cost of generating pseudo preimages is not negligible. Hence, we cannot afford to generate tables <span class="math">T_{1}</span> and <span class="math">T_{2}</span>, each with <span class="math">2^{\\frac{n}{2}}</span> entries, and then look for a collision. However, given the attack complexities for Jarvis in Table 2, an attack on 9-round Jarvis has a complexity of around 83 bits (assuming <span class="math">\\omega=2.8</span>). Considering Jarvis-128, for example, this means we can generate up to <span class="math">2^{45}</span> pseudo preimages.</p>

    <p class="text-gray-300">Let us assume we calculate <span class="math">2^{10}</span> pseudo preimages <span class="math">(\\hat{m}_{1},m_{1}^{\\prime})</span> and <span class="math">2^{\\frac{n}{2}}</span> intermediate pairs <span class="math">(\\hat{m}_{1},\\hat{h}_{1})</span>, in both cases for Friday instantiated with Jarvis-128. This leaves us with a table <span class="math">T_{1}</span> containing <span class="math">2^{\\frac{n}{2}}</span> <span class="math">(\\hat{m}_{1},\\hat{h}_{1})</span> pairs and a table <span class="math">T_{2}</span> containing <span class="math">2^{10}</span> <span class="math">(m_{2}^{\\prime},h_{1}^{\\prime})</span> pairs.</p>

    <p class="text-gray-300">Assuming that all hash values in <span class="math">T_{1}</span> are pairwise distinct and that also all hash values in <span class="math">T_{2}</span> are pairwise distinct, the probability that we find at least one hash collision between a pair in <span class="math">T_{1}</span> and a pair in <span class="math">T_{2}</span> is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$P=1-\\prod_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\left(1-\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{128}-i}\\right),$ (15)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is, unfortunately, too low for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\frac{n}{2}}<span class="math">. However, we can increase this probability by generating more entries for </span>T_{1}<span class="math">. Targeting a total complexity of, e.g., </span>\\approx 120<span class="math"> bits, we can generate </span>2^{118}$ such entries. Note that the number of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">expected collisions in a table of  <span class="math">m</span>  random  <span class="math">n</span> -bit entries is</p>

    <div class="my-4 text-center"><span class="math-block">N _ {c} = m - 2 ^ {n} + 2 ^ {n} \\cdot \\left(\\frac {2 ^ {n} - 1}{2 ^ {n}}\\right) ^ {m}.</span></div>

    <p class="text-gray-300">Therefore, the expected number of unique values in such a table is</p>

    <div class="my-4 text-center"><span class="math-block">N _ {u} = \\left(1 - \\frac {N _ {c}}{m}\\right) \\cdot m = m - N _ {c} = 2 ^ {n} - 2 ^ {n} \\cdot \\left(\\frac {2 ^ {n} - 1}{2 ^ {n}}\\right) ^ {m}.</span></div>

    <p class="text-gray-300">We want that  <span class="math">N_{u} \\geq 2^{118}</span> , and by simple computation it turns out that  <span class="math">2^{119}</span>  hash evaluations are sufficient with high probability. Using these values in Equation (15) yields a success probability of around 63 percent.</p>

    <h2 id="sec-28" class="text-2xl font-bold">5.3 Direct Preimage Attack on FRIDAY</h2>

    <p class="text-gray-300">The preimage attack we present in this section works with one block of FRIDAY, as shown in Figure 7.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 7: Preimage attack on FRIDAY using one message block.</p>

    <p class="text-gray-300">The description of the intermediate states  <span class="math">x_{1}, \\ldots, x_{r}</span>  yields the same system of equations as before; however, in contrast to the optimised attack on JARVIS described in Section 4.2, in the current preimage attack on FRIDAY the master key  <span class="math">k_{0}</span>  and thus all subsequent round keys  <span class="math">k_{1}, \\ldots, k_{r}</span>  are known. As an effect, we do not need to express round keys as a rational function of  <span class="math">k_{0}</span>  anymore. For the sake of completeness, we give Equation (12) once more and note that the degree now decreases to 32 (from formerly 40). It holds that</p>

    <div class="my-4 text-center"><span class="math-block">D \\left(\\frac {1}{C (x _ {i - 1}) + k _ {i - 1}}\\right) = E \\left(\\frac {1}{B (x _ {i + 1})} + k _ {i}\\right)</span></div>

    <p class="text-gray-300">for  <span class="math">2 \\leq i \\leq r - 1</span> . Moreover, an additional equation is needed to describe the structure of the Miyaguchi-Preneel compression function (see Figure 6), namely</p>

    <div class="my-4 text-center"><span class="math-block">B (x _ {1}) \\cdot (C (x _ {r}) + k _ {r} + h _ {1}) = 1.</span></div>

    <p class="text-gray-300">Again, we assume an even number of rounds <span class="math">r</span> and work with intermediate states <span class="math">x_{2}, x_{4}, \\ldots, x_{r}</span>, which is why we need to apply the transformations <span class="math">D</span> and <span class="math">E</span> to cancel out the state <span class="math">x_{1}</span> in the above equation. Thus, eventually we have</p>

    <div class="my-4 text-center"><span class="math-block">D \\left(\\frac {1}{C \\left(x _ {r}\\right) + k _ {r} + h _ {1}}\\right) = E \\left(\\frac {1}{B \\left(x _ {2}\\right)} + k _ {1}\\right). \\tag {16}</span></div>

    <p class="text-gray-300">Here, <span class="math">h_1</span> denotes the hash value for which we want to find a preimage <span class="math">m_1&#x27;</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">F (m _ {1} ^ {\\prime}, h _ {0}) = h _ {1}.</span></div>

    <p class="text-gray-300">To obtain <span class="math">m_1&#x27;</span> we solve for the intermediate state <span class="math">x_r</span> and calculate</p>

    <div class="my-4 text-center"><span class="math-block">m _ {1} ^ {\\prime} := C (x _ {r}) + k _ {r} + h _ {1} + h _ {0}.</span></div>

    <p class="text-gray-300">The value <span class="math">h_0 = k_0</span> can be regarded as the initialisation vector and is the zero element in <span class="math">\\mathbb{F}_{2^n}</span>. The above attack results in:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\frac{r}{2} - 1</span> equations of degree 32 coming from Equations (12) when considering even intermediate states, and</li>

      <li>one equation of degree 32 coming from Equation (16),</li>

    </ul>

    <p class="text-gray-300">in the <span class="math">\\frac{r}{2}</span> variables <span class="math">x_{2}, x_{4}, \\ldots, x_{r}</span>. The number of equations is the same as the number of variables, and we can again use Equation (2) to estimate the degree of regularity. The complexities of the Gröbner basis computations are summarised in Table 3, where we pessimistically assume <span class="math">\\omega = 2.8</span>, but also give the complexities for <span class="math">\\omega = 2</span> in parentheses.</p>

    <p class="text-gray-300">Table 3: Complexity estimates for the Gröbner basis step in preimage attacks on FRIDAY using <span class="math">r</span>-round JARVIS.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n_{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_{reg}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity in bits</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">48 (34)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">65 (47)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10 (JARVIS-128)</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">83 (59)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12 (JARVIS-192)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">187</td>

            <td class="px-3 py-2 border-b border-gray-700">101 (72)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14 (JARVIS-256)</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">218</td>

            <td class="px-3 py-2 border-b border-gray-700">118 (85)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">249</td>

            <td class="px-3 py-2 border-b border-gray-700">136 (97)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">280</td>

            <td class="px-3 py-2 border-b border-gray-700">154 (110)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">311</td>

            <td class="px-3 py-2 border-b border-gray-700">172 (123)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall that our attack has three steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set up an equation system and compute a Gröbner basis using, e.g., the F4 algorithm <em>[x10]</em>, with cost <span class="math">\\mathcal{C}_{\\mathrm{GB}}</span>.</li>

      <li>Perform a change of term ordering for the computed Gröbner basis using the FGLM algorithm <em>[FGL+93]</em>, with cost <span class="math">\\mathcal{C}_{\\mathrm{FGLM}}</span>.</li>

      <li>Solve the remaining univariate equation for the last variable using a polynomial factoring algorithm, substitute into other equations, with cost <span class="math">\\mathcal{C}_{\\mathrm{Sol}}</span>.</li>

    </ol>

    <p class="text-gray-300">For the overall cost of the attack we have:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{C}</span> <span class="math">:=2\\,\\mathcal{C}_{\\mathrm{GB}}+2\\,\\mathcal{C}_{\\mathrm{FGLM}}+\\mathcal{C}_{\\mathrm{Sol}},</span> <span class="math">\\mathcal{C}</span> <span class="math">:=2\\,\\left(\\binom{n_{v}+D}{D}^{\\omega}\\right)+2\\,\\left(n_{v}\\cdot D_{u}{}^{3}\\right)+\\left(D_{u}\\log^{2}D_{u}\\right).</span></p>

    <p class="text-gray-300">We can estimate <span class="math">\\mathcal{C}_{\\mathrm{GB}}</span> if we assume that our systems behave like regular sequences. For the <span class="math">\\mathcal{C}_{\\mathrm{FGLM}}</span> and <span class="math">\\mathcal{C}_{\\mathrm{Sol}}</span> we need to establish the degree <span class="math">D_{u}</span> of the univariate polynomial recovered, for which however we do not have an estimate. We have therefore implemented our attacks on Jarvis and Friday using Sage v8.6 <em>[Ste+19]</em> with Magma v2.20–5 <em>[BCP97]</em> as the Gröbner basis engine. In particular, we implemented both the unoptimised and the optimised variants of the attacks from Sections 4.2 and 5.3.</p>

    <p class="text-gray-300">We observed that our attacks performed significantly better in our experiments than predicted. On the one hand, our Gröbner basis computations reached significantly lower degrees <span class="math">D</span> than the (theoretically) expected <span class="math">D_{\\mathrm{reg}}</span>. Furthermore, the degrees of the univariate polynomials seem to grow as <span class="math">\\approx 2\\cdot 5^{r}</span> (Jarvis) and as <span class="math">\\approx 2\\cdot 4^{r}</span> (Friday), respectively, suggesting the second and third steps of our attack are relatively cheap.</p>

    <p class="text-gray-300">We therefore conclude that the complexities given in Tables 2 and 3 are conservative upper bounds for our attacks on Jarvis and Friday. We summarise our findings in Table 4, and the source code of our attacks on MARVELlous is available on GitHub.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">6.1 Comparison with MiMC</h3>

    <p class="text-gray-300">We note that the same attack strategy – direct Gröbner basis computation to recover the secret key – also applies, in principle, to MiMC, as pointed out by <em>[x1]</em>. In particular, it is easy to construct a multivariate system of equations for MiMC with degree 3 that is already a Gröbner basis by introducing a new state variable per round. This makes the first step of a Gröbner basis attack free. However, then the change of ordering has to essentially undo the</p>

    <p class="text-gray-300">Table 4: Experimental results using Sage.</p>

    <p class="text-gray-300">|  JARVIS (optimised)  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 2</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 3</td>

            <td class="px-3 py-2 border-b border-gray-700">67</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">1280</td>

            <td class="px-3 py-2 border-b border-gray-700">9.4s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 3</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">6144</td>

            <td class="px-3 py-2 border-b border-gray-700">891.4s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 4</td>

            <td class="px-3 py-2 border-b border-gray-700">106</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">28672</td>

            <td class="px-3 py-2 border-b border-gray-700">99989.0s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  JARVIS (unoptimised)  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3 4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">25</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">29</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">10</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">20</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0.5s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 6</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">6144</td>

            <td class="px-3 py-2 border-b border-gray-700">2559.8s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 7</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">28672</td>

            <td class="px-3 py-2 border-b border-gray-700">358228.6s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  FRIDAY  |   |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">39</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3.6s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 3</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">36.5s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 3</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">2095.2s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the table,  <span class="math">r</span>  denotes the number of rounds,  <span class="math">D_{\\mathrm{reg}}</span>  is the expected degree of regularity under the assumption that the input system is regular,  <span class="math">n_v</span>  is the number of variables,  <span class="math">2 \\cdot \\log_2\\left(\\frac{n_v + D_{\\mathrm{reg}}}{D_{\\mathrm{reg}}}\\right)</span>  is the expected bit security for  <span class="math">\\omega = 2</span>  under the regularity assumption,  <span class="math">D</span>  is the highest degree reached during the Gröbner basis computation, and  <span class="math">2 \\cdot \\log_2\\left(\\frac{n_v + D}{D}\\right)</span>  is the expected bit security for  <span class="math">\\omega = 2</span>  based on our experiments. The degree of the recovered univariate polynomial used for solving the system is denoted as  <span class="math">D_u</span> .</p>

    <p class="text-gray-300">construction to recover a univariate polynomial of degree <span class="math">D_{u}\\approx 3^{r}</span>. Performing this step twice produces two such polynomials from which we can recover the key by applying the GCD algorithm with complexity <span class="math">\\tilde{\\mathcal{O}}\\left(3^{r}\\right)</span>. In <em>[AGR+16]</em>, the security analysis implicitly assumes that steps 1 and 2 of our attack are free by constructing the univariate polynomial directly and costing only the third and final step of computing the GCD.</p>

    <p class="text-gray-300">The reason our Gröbner basis attacks are so effective against Friday and Jarvis is that the particular operations used in the ciphers – finite field inversion and low-degree linearised polynomials – allow us to construct a polynomial system with a relatively small number of variables, which can in turn be efficiently solved using our three-step attack strategy. We have not been able to construct such amenable systems for MiMC.</p>

    <h2 id="sec-31" class="text-2xl font-bold">7 Comparing the S-Boxes of Jarvis and the AES</h2>

    <p class="text-gray-300">The non-linear operation in Jarvis shows similarities with the AES S-box <span class="math">S_{\\text{AES}}(X)</span>. In particular, <span class="math">S_{\\text{AES}}(X)</span> is the composition of an <span class="math">\\mathbb{F}_{2}</span>-affine function <span class="math">A_{\\text{AES}}</span> and the multiplicative inverse of the input in <span class="math">\\mathbb{F}_{2^{8}}</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">S_{\\text{AES}}(X)=A_{\\text{AES}}(X^{254}),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">A_{\\text{AES}}(X)=\\texttt{0x8F}\\cdot X^{128}+\\texttt{0xB5}\\cdot X^{64}+\\texttt{0x01}\\cdot X^{32}+\\texttt{0xF4}\\cdot X^{16}+</span> <span class="math">\\texttt{0x25}\\cdot X^{8}+\\texttt{0xF9}\\cdot X^{4}+\\texttt{0x09}\\cdot X^{2}+\\texttt{0x05}\\cdot X+\\texttt{0x63}.</span></p>

    <p class="text-gray-300">In Jarvis, we can also view the S-box as</p>

    <p class="text-gray-300"><span class="math">S(X)=A(X^{254}),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">A(X)=(C\\circ B^{-1})(X)</span></p>

    <p class="text-gray-300">and both <span class="math">B</span> and <span class="math">C</span> are of degree 4. In this section we show that <span class="math">A_{\\text{AES}}</span> <em>cannot</em> be split into</p>

    <p class="text-gray-300"><span class="math">A_{\\text{AES}}(X)=(\\hat{C}\\circ\\hat{B}^{-1})(X),</span></p>

    <p class="text-gray-300">with both <span class="math">\\hat{B}</span> and <span class="math">\\hat{C}</span> of low degree. To see this, first note that above decomposition implies</p>

    <p class="text-gray-300"><span class="math">\\hat{B}(X)=A_{\\text{AES}}^{-1}(\\hat{C}(X)),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">A_{\\text{AES}}^{-1}(X)=\\texttt{0x6E}\\cdot X^{128}+\\texttt{0xDB}\\cdot X^{64}+\\texttt{0x59}\\cdot X^{32}+\\texttt{0x78}\\cdot X^{16}+</span> <span class="math">\\texttt{0x5A}\\cdot X^{8}+\\texttt{0x7F}\\cdot X^{4}+\\texttt{0xFE}\\cdot X^{2}+\\texttt{0x5}\\cdot X+\\texttt{0x5}</span></p>

    <p class="text-gray-300">is the compositional inverse polynomial of <span class="math">A_{\\text{AES}}</span> satisfying the relation</p>

    <p class="text-gray-300"><span class="math">A_{\\text{AES}}^{-1}(A_{\\text{AES}}(x))=x,</span></p>

    <p class="text-gray-300">for every <span class="math">x\\in\\mathbb{F}_{2^{8}}</span>. Hence, to show that at least one of <span class="math">\\hat{B},\\hat{C}</span> is of degree <span class="math">&gt;4</span>, it suffices to compute <span class="math">A_{\\text{AES}}^{-1}(\\hat{C})</span> assuming a degree 4 for <span class="math">\\hat{C}</span>, and to show that then the corresponding <span class="math">\\hat{B}</span> has degree <span class="math">&gt;4</span>.</p>

    <p class="text-gray-300">Remark.</p>

    <p class="text-gray-300">First of all, note that since <span class="math">A_{\\mathrm{AES}}</span> has degree 128, it is always possible to find polynomials <span class="math">\\hat{C}</span> and <span class="math">\\hat{B}</span> of degree 8 such that the equality <span class="math">A_{\\mathrm{AES}}(X)=\\hat{C}(\\hat{B}^{-1}(X))</span> is satisfied. Indeed, if both <span class="math">\\hat{C}</span> and <span class="math">\\hat{B}</span> have degree 8, then each one of them have all monomials of degrees <span class="math">1,2,4</span> and 8. The equality <span class="math">A_{\\mathrm{AES}}(X)=\\hat{C}(\\hat{B}^{-1}(X))</span> is then satisfied if 8 equations (one for each monomial of <span class="math">A_{\\mathrm{AES}}</span>) in 8 variables (both <span class="math">\\hat{C}</span> and <span class="math">\\hat{B}</span> have 4 monomials each) are satisfied. Hence, a random polynomial <span class="math">A_{\\mathrm{AES}}</span> satisfies the equality <span class="math">A_{\\mathrm{AES}}(x)=\\hat{C}(\\hat{B}^{-1}(x))</span> with negligible probability if both <span class="math">\\hat{C}</span> and <span class="math">\\hat{B}</span> have degree at most 4.</p>

    <h5 id="sec-32" class="text-base font-semibold mt-4">Property of <span class="math">A_{\\mathrm{AES}}</span>.</h5>

    <p class="text-gray-300">Let us assume a degree-4 polynomial</p>

    <p class="text-gray-300"><span class="math">\\hat{C}(X)=\\hat{c}_{4}X^{4}+\\hat{c}_{2}X^{2}+\\hat{c}_{1}X+\\hat{c}_{0}.</span></p>

    <p class="text-gray-300">We can now write down <span class="math">A_{\\mathrm{AES}}^{-1}(\\hat{C}(X))</span>, which results in <span class="math">\\hat{B}(X)</span>. However, we want <span class="math">\\hat{B}</span> to be of degree at most 4, so we set all coefficients for the degrees <span class="math">8,16,32,64,128</span> to 0. This results in a system of five equations in the three variables <span class="math">\\hat{c}_{1},\\hat{c}_{2},\\hat{c}_{4}</span>, given in Appendix C. We tried to solve this system and confirmed that no solutions exist. Thus, the affine part of the AES S-box cannot be split into <span class="math">\\hat{C}(\\hat{B}^{-1}(X))</span> such that both <span class="math">\\hat{B}</span> and <span class="math">\\hat{C}</span> are of degree at most 4, whereas in Jarvis this is possible.</p>

    <p class="text-gray-300">As a result, from this point of view, the main difference between AES and Jarvis/Friday is that the linear polynomial used to construct the AES S-box does not have the splitting property used in our attacks, while the same is not true for the case of Jarvis/Friday. In this latter case, even if <span class="math">B(C^{-1})</span> has high degree, it depends only on 9 variables instead of <span class="math">n+1</span> as expected by a linearised polynomial of degree <span class="math">2^{n}</span> (where <span class="math">n\\geq 128</span>). Thus, a natural question to ask is what happens if we replace <span class="math">B</span> and <span class="math">C</span> with other polynomials of higher degree.</p>

    <h2 id="sec-33" class="text-2xl font-bold">8 Conclusion and Future Work</h2>

    <p class="text-gray-300">We have demonstrated that Jarvis and Friday are insecure against Gröbner basis attacks, mainly due to the algebraic properties of concatenating the finite field inversion with a function that is defined by composing two low-degree affine polynomials. In our attacks we modelled both designs as a system of polynomial equations in several variables. Additionally, we bridged equations over two rounds, with the effect of significantly reducing the number of variables needed to describe the designs.</p>

    <p class="text-gray-300">Following our analysis, the area sees a dynamic development. Authors of Jarvis and Friday have abandoned their design. Their new construction <em>[AABS+19]</em> is substantially different, although it still uses basic components which we were able to exploit in our analysis. Whether our particular method of bridging internal state equations can be applied to the new hash functions is subject to future work. A broader effort is currently underway to identify designs practically useful for a range of modern proof systems. A noteable competition compares three new designs (Marvelous <em>[AABS+19]</em>, Poseidon/Starkad <em>[GKK+19]</em>, and GMiMC <em>[AGP+19]</em>) with the more established MiMC.</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">We thank Tomer Ashur for fruitful discussions about Jarvis, Friday, and a preliminary version of our analysis. The research described in this paper was supported by the Royal Society International Exchanges grant “Domain Specific Ciphers” (IES\\R2\\170211).</p>

    <h2 id="sec-34" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABS+19] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. Cryptology ePrint Archive, Report 2019/426. https://eprint.iacr.org/2019/426. 2019 (cit. on pp. 4, 23).</li>

      <li>[AC09] Martin Albrecht and Carlos Cid. “Algebraic Techniques in Differential Cryptanalysis”. In: FSE 2009. Ed. by Orr Dunkelman. Vol. 5665. LNCS. Springer, Heidelberg, Feb. 2009, pp. 193–208. doi: 10.1007/978-3-642-03317-9_12 (cit. on p. 3).</li>

      <li>[ACF+14] Martin R. Albrecht, Carlos Cid, Jean-Charles Faugère, and Ludovic Perret. Algebraic Algorithms for LWE. Cryptology ePrint Archive, Report 2014/1018. http://eprint.iacr.org/2014/1018. 2014 (cit. on p. 3).</li>

      <li>[AD18] Tomer Ashur and Siemen Dhooghe. MARVELlous: a STARK-Friendly Family of Cryptographic Primitives. Cryptology ePrint Archive, Report 2018/1098. https://eprint.iacr.org/2018/1098. 2018 (cit. on pp. 3, 4, 6).</li>

      <li>[AG11] Sanjeev Arora and Rong Ge. “New Algorithms for Learning in Presence of Errors”. In: ICALP 2011, Part I. Ed. by Luca Aceto, Monika Henzinger, and Jiri Sgall. Vol. 6755. LNCS. Springer, Heidelberg, July 2011, pp. 403–415. doi: 10.1007/978-3-642-22006-7_34 (cit. on p. 3).</li>

      <li>[AGP+19] Martin R. Albrecht, Lorenzo Grassi, Leo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, et al. Feistel Structures for MPC, and More. Cryptology ePrint Archive, Report 2019/397, to appear in ESORICS 2019. https://eprint.iacr.org/2019/397. 2019 (cit. on pp. 2, 23).</li>

      <li>[AGR+16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. “MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity”. In: ASIACRYPT 2016, Part I. Ed. by Jung Hee Cheon and Tsuyoshi Takagi. Vol. 10031. LNCS. Springer, Heidelberg, Dec. 2016, pp. 191–219. doi: 10.1007/978-3-662-53887-6_7 (cit. on pp. 2, 22).</li>

    </ul>

    <p class="text-gray-300">[ARS+15] Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. “Ciphers for MPC and FHE”. In: EUROCRYPT 2015, Part I. Ed. by Elisabeth Oswald and Marc Fischlin. Vol. 9056. LNCS. Springer, Heidelberg, Apr. 2015, pp. 430–454. doi: 10.1007/978-3-662-46800-5_17 (cit. on p. 2).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Ash19] Tomer Ashur. Private Communication. Mar. 2019 (cit. on p. 20).</li>

      <li>[BBB+18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. “Bulletproofs: Short Proofs for Confidential Transactions and More”. In: 2018 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2018, pp. 315–334. doi: 10.1109/SP.2018.00020 (cit. on p. 2).</li>

      <li>[BBH+18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046. https://eprint.iacr.org/2018/046. 2018 (cit. on pp. 2, 4).</li>

      <li>[BCG+14] Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, et al. Zerocash: Decentralized Anonymous Payments from Bitcoin. Cryptology ePrint Archive, Report 2014/349. http://eprint.iacr.org/2014/349. 2014 (cit. on p. 2).</li>

      <li>[BCP97] Wieb Bosma, John Cannon, and Catherine Playoust. “The MAGMA Algebra System I: The User Language”. In: Journal of Symbolic Computation 24. Academic Press, 1997, pp. 235–265 (cit. on p. 20).</li>

      <li>[BFP12] Luk Bettale, Jean-Charles Faugère, and Ludovic Perret. “Solving polynomial systems over finite fields: improved analysis of the hybrid approach”. In: International Symposium on Symbolic and Algebraic Computation, ISSAC’12. ACM, 2012, pp. 67–74 (cit. on p. 9).</li>

      <li>[BFS+05] M Bardet, JC Faugere, B Salvy, and BY Yang. “Asymptotic behaviour of the index of regularity of quadratic semi-regular polynomial systems”. In: The Effective Methods in Algebraic Geometry Conference (MEGA). 2005, pp. 1–14 (cit. on p. 9).</li>

      <li>[BPW06] Johannes Buchmann, Andrei Pyshkin, and Ralf-Philipp Weinmann. “A Zero-Dimensional Gröbner Basis for AES-128”. In: FSE 2006. Ed. by Matthew J. B. Robshaw. Vol. 4047. LNCS. Springer, Heidelberg, Mar. 2006, pp. 78–88. doi: 10.1007/11799313_6 (cit. on p. 20).</li>

      <li>[BS18] Eli Ben-Sasson. State of the STARK. available at https://drive.google.com/file/d/10sa0MXu-04dfwn1YOSgN6CXOgWnsp-Tu/view. Nov. 2018 (cit. on p. 3).</li>

      <li>[Buc65] Bruno Buchberger. “Ein Algorithmus zum Auffinden der Basiselemente des Restklassenringes nach einem nulldimensionalen Poly-</li>

    </ul>

    <p class="text-gray-300">nomideal”. PhD thesis. University of Innsbruck, 1965 (cit. on pp. 3, 8).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CB07] Nicolas Courtois and Gregory V. Bard. “Algebraic Cryptanalysis of the Data Encryption Standard”. In: 11th IMA International Conference on Cryptography and Coding. Ed. by Steven D. Galbraith. Vol. 4887. LNCS. Springer, Heidelberg, Dec. 2007, pp. 152–169 (cit. on p. 3).</li>

      <li>[CLO97] David A. Cox, John Little, and Donal O’Shea. Ideals, Varieties, and Algorithms – An Introduction to Computational Algebraic Geometry and Commutative Algebra. 2nd ed. Undergraduate Texts in Mathematics. Springer, 1997 (cit. on pp. 3, 8).</li>

      <li>[Cou03a] Nicolas Courtois. “Fast Algebraic Attacks on Stream Ciphers with Linear Feedback”. In: CRYPTO 2003. Ed. by Dan Boneh. Vol. 2729. LNCS. Springer, Heidelberg, Aug. 2003, pp. 176–194. doi: 10.1007/978-3-540-45146-4_11 (cit. on p. 3).</li>

      <li>[Cou03b] Nicolas Courtois. “Higher Order Correlation Attacks, XL Algorithm and Cryptanalysis of Toyocrypt”. In: ICISC 02. Ed. by Pil Joong Lee and Chae Hoon Lim. Vol. 2587. LNCS. Springer, Heidelberg, Nov. 2003, pp. 182–199 (cit. on p. 3).</li>

      <li>[Fau02] Jean-Charles Faugère. “A new efficient algorithm for computing Gröbner bases without reduction to zero (F5)”. In: Proceedings of the 2002 International Symposium on Symbolic and Algebraic Computation ISSAC. Ed. by T. Mora. isbn: 1-58113-484-3. ACM Press, July 2002, pp. 75–83 (cit. on pp. 3, 8).</li>

      <li>[Fau99] Jean-Charles Faugère. “A new efficient algorithm for computing Gröbner bases (F4)”. In: Journal of Pure and Applied Algebra 139.1-3 (1999), pp. 61–88 (cit. on pp. 3, 8, 20).</li>

      <li>[FGL+93] Jean-Charles Faugère, Patrizia M. Gianni, Daniel Lazard, and Teo Mora. “Efficient Computation of Zero-Dimensional Gröbner Bases by Change of Ordering”. In: J. Symb. Comput. 16.4 (1993), pp. 329–344 (cit. on pp. 9, 20).</li>

      <li>[FGO+10] Jean-Charles Faugère, Valérie Gauthier, Ayoub Otmani, Ludovic Perret, and Jean-Pierre Tillich. A Distinguisher for High Rate McEliece Cryptosystems. Cryptology ePrint Archive, Report 2010/331. http://eprint.iacr.org/2010/331. 2010 (cit. on p. 3).</li>

      <li>[FGP+15] Jean-Charles Faugère, Danilo Gligoroski, Ludovic Perret, Simona Samardjiska, and Enrico Thomae. “A Polynomial-Time Key-Recovery Attack on MQQ Cryptosystems”. In: PKC 2015. Ed. by Jonathan Katz. Vol. 9020. LNCS. Springer, Heidelberg, 2015, pp. 150–174. doi: 10.1007/978-3-662-46447-2_7 (cit. on p. 3).</li>

      <li>[FM11] Jean-Charles Faugère and Chenqi Mou. “Fast algorithm for change of ordering of zero-dimensional Gröbner bases with sparse multiplication matrices”. In: Symbolic and Algebraic Computation, International Symposium, ISSAC 2011. Ed. by Éric Schost and Ioan</li>

    </ul>

    <p class="text-gray-300">nis Z. Emiris. ACM, 2011, pp. 115–122. DOI: 10.1145/1993886.1993908 (cit. on p. 10).</p>

    <p class="text-gray-300">[FPP14] Jean-Charles Faugère, Ludovic Perret, and Frédéric de Portzamparc. “Algebraic Attack against Variants of McEliece with Goppa Polynomial of a Special Form”. In: <em>ASIACRYPT 2014, Part I</em>. Ed. by Palash Sarkar and Tetsu Iwata. Vol. 8873. LNCS. Springer, Heidelberg, Dec. 2014, pp. 21–41. DOI: 10.1007/978-3-662-45611-8_2 (cit. on p. 3).</p>

    <p class="text-gray-300">[Frö85] Ralf Fröberg. “An inequality for Hilbert series of graded algebras”. In: <em>Mathematica Scandinavica</em> 56 (1985), pp. 117–144 (cit. on p. 9).</p>

    <p class="text-gray-300">[Gen07] Giulio Genovese. “Improving the algorithms of Berlekamp and Niederreiter for factoring polynomials over finite fields”. In: <em>J. Symb. Comput.</em> 42.1-2 (2007), pp. 159–177 (cit. on p. 10).</p>

    <p class="text-gray-300">[GKK+19] Lorenzo Grassi, Daniel Kales, Dmitry Khovratovich, Arnab Roy, Christian Rechberger, and Markus Schofnegger. <em>Starkad and Poseidon: New Hash Functions for Zero Knowledge Proof Systems</em>. Cryptology ePrint Archive, Report 2019/458. https://eprint.iacr.org/2019/458. 2019 (cit. on p. 23).</p>

    <p class="text-gray-300">[HBH+19] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. <em>Zcash protocol specification: Version 2019.0-beta-37 [Overwinter+Sapling]</em>. Tech. rep. available at https://github.com/zcash/zips/blob/master/protocol/protocol.pdf. Zerocoin Electric Coin Company, 2019 (cit. on p. 2).</p>

    <p class="text-gray-300">[Hor72] Ellis Horowitz. “A Fast Method for Interpolation Using Preconditioning”. In: <em>Information Processing Letters (IPL)</em>. Vol. 1. 4. June 1972, pp. 157–163 (cit. on p. 8).</p>

    <p class="text-gray-300">[JK97] Thomas Jakobsen and Lars R. Knudsen. “The Interpolation Attack on Block Ciphers”. In: <em>FSE’97</em>. Ed. by Eli Biham. Vol. 1267. LNCS. Springer, Heidelberg, Jan. 1997, pp. 28–40. DOI: 10.1007/BFb0052332 (cit. on p. 7).</p>

    <p class="text-gray-300">[KBN09] Dmitry Khovratovich, Alex Biryukov, and Ivica Nikolic. “Speeding up Collision Search for Byte-Oriented Hash Functions”. In: <em>CT-RSA 2009</em>. Ed. by Marc Fischlin. Vol. 5473. LNCS. Springer, Heidelberg, Apr. 2009, pp. 164–181. DOI: 10.1007/978-3-642-00862-7_11 (cit. on p. 2).</p>

    <p class="text-gray-300">[Knu95] Lars R. Knudsen. “Truncated and Higher Order Differentials”. In: <em>FSE’94</em>. Ed. by Bart Preneel. Vol. 1008. LNCS. Springer, Heidelberg, Dec. 1995, pp. 196–211. DOI: 10.1007/3-540-60590-8_16 (cit. on p. 7).</p>

    <p class="text-gray-300">[KR00] Martin Kreuzer and Lorenzo Robbiano. <em>Computational Commutative Algebra 1</em>. New York: Springer, 2000 (cit. on p. 10).</p>

    <p class="text-gray-300">[Kun73] Hsiang-Tsung Kung. <em>Fast Evaluation and Interpolation</em>. Tech. rep. Department of Computer Science, Carnegie-Mellon University, Jan. 1973 (cit. on p. 8).</p>

    <p class="text-gray-300">[LN96] Rudolf Lidl and Harald Niederreiter. Finite Fields. 2nd ed. Encyclopedia of Mathematics and its Applications. Cambridge University Press, 1996 (cit. on p. 5).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[MR02] Sean Murphy and Matthew J. B. Robshaw. “Essential Algebraic Structure within the AES”. In: CRYPTO 2002. Ed. by Moti Yung. Vol. 2442. LNCS. Springer, Heidelberg, Aug. 2002, pp. 1–16. doi: 10.1007/3-540-45708-9_1 (cit. on p. 3).</li>

      <li>[PHG+13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. “Pinocchio: Nearly Practical Verifiable Computation”. In: 2013 IEEE Symposium on Security and Privacy. IEEE Computer Society Press, May 2013, pp. 238–252. doi: 10.1109/SP.2013.47 (cit. on p. 2).</li>

      <li>[Ste+19] William Stein et al. Sage Mathematics Software Version 8.6. Available at http://www.sagemath.org. The Sage Development Team. 2019 (cit. on p. 20).</li>

      <li>[WSM+11] Meiqin Wang, Yue Sun, Nicky Mouha, and Bart Preneel. “Algebraic Techniques in Differential Cryptanalysis Revisited”. In: ACISP 11. Ed. by Udaya Parampalli and Philip Hawkes. Vol. 6812. LNCS. Springer, Heidelberg, July 2011, pp. 120–141 (cit. on p. 3).</li>

    </ul>

    <p class="text-gray-300">A Polynomials of Section 4.2</p>

    <p class="text-gray-300">In Section 4.2, we search for monic affine polynomials <span class="math">D,E</span> such that the equality</p>

    <p class="text-gray-300"><span class="math">D(B)=E(C)</span></p>

    <p class="text-gray-300">is satisfied, where <span class="math">B,C</span> are monic affine polynomials of degree 4. In particular, given</p>

    <p class="text-gray-300"><span class="math">B(X)=X^{4}+b_{2}X^{2}+b_{1}X+b_{0}\\quad\\text{and}\\quad C(X)=X^{4}+c_{2}X^{2}+c_{1}X+c_{0}</span></p>

    <p class="text-gray-300">the goal is to find</p>

    <p class="text-gray-300"><span class="math">D(X)=X^{4}+d_{2}X^{2}+d_{1}X^{1}+d_{0}\\quad\\text{and}\\quad E(X)=X^{4}+e_{2}X^{2}+e_{1}X+e_{0}</span></p>

    <p class="text-gray-300">such that <span class="math">D(B)=E(C)</span>.</p>

    <p class="text-gray-300">By comparing the corresponding coefficients of <span class="math">D(B)</span> and <span class="math">E(C)</span>, we obtain a system of 5 linear equations in the 6 variables <span class="math">d_{0},d_{1},d_{2},e_{0},e_{1},e_{2}</span>:</p>

    <p class="text-gray-300"><span class="math">d_{2}+e_{2}</span> <span class="math">=b_{2}^{4}+c_{2}^{4},</span> <span class="math">d_{1}+b_{2}^{2}\\cdot d_{2}+e_{1}+c_{2}^{2}\\cdot e_{2}</span> <span class="math">=b_{1}^{4}+c_{1}^{4},</span> <span class="math">b_{2}\\cdot d_{1}+b_{1}^{2}\\cdot d_{2}+c_{2}\\cdot e_{1}+c_{1}^{2}\\cdot e_{2}</span> <span class="math">=0,</span> <span class="math">b_{1}\\cdot d_{1}+c_{1}\\cdot e_{1}</span> <span class="math">=0,</span> <span class="math">d_{0}+b_{0}\\cdot d_{1}+b_{0}^{2}\\cdot d_{2}+e_{0}+c_{0}\\cdot e_{1}+c_{0}^{2}\\cdot e_{2}</span> <span class="math">=b_{0}^{4}+c_{0}^{4}.</span></p>

    <p class="text-gray-300">This system can be solved to recover <span class="math">D</span> and <span class="math">E</span>.</p>

    <h2 id="sec-35" class="text-2xl font-bold">Appendix B Constants <span class="math">\\alpha_{i}</span>, <span class="math">\\beta_{i}</span>, <span class="math">\\gamma_{i}</span>, and <span class="math">\\delta_{i}</span> for the Round Keys</h2>

    <p class="text-gray-300">Each round key <span class="math">k_{i+1}=\\frac{1}{k_{i}}+c_{i}</span> in Jarvis can be written as</p>

    <p class="text-gray-300"><span class="math">k_{i+1}=\\frac{\\alpha_{i}\\cdot k_{0}+\\beta_{i}}{\\gamma_{i}\\cdot k_{0}+\\delta_{i}},</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha_{i}</span>, <span class="math">\\beta_{i}</span>, <span class="math">\\gamma_{i}</span>, and <span class="math">\\delta_{i}</span> are constants. By simple computation, note that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">i=0</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">k_{1}=\\frac{1}{k_{0}}+c_{0}=\\frac{c_{0}k_{0}+1}{k_{0}},</span></p>

    <p class="text-gray-300">and <span class="math">\\alpha_{0}=c_{0},\\beta_{0}=1,\\gamma_{0}=1,\\delta_{0}=0</span>;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">i=1</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">k_{2}=\\frac{1}{k_{1}}+c_{1}=\\frac{(c_{0}c_{1}+1)k_{0}+c_{1}}{c_{0}k_{0}+1},</span></p>

    <p class="text-gray-300">and <span class="math">\\alpha_{1}=1+c_{0}c_{1},\\beta_{1}=c_{1},\\gamma_{1}=c_{0},\\delta_{1}=1</span>;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">i=2</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">k_{3}=\\frac{1}{k_{2}}+c_{2}=\\frac{(c_{0}c_{1}c_{2}+c_{0}+c_{2})k_{0}+c_{1}c_{2}+1}{(c_{0}c_{1}+1)k_{0}+c_{1}},</span></p>

    <p class="text-gray-300">and <span class="math">\\alpha_{2}=c_{0}c_{1}c_{2}+c_{0}+c_{2},\\beta_{2}=c_{1}c_{2}+1,\\gamma_{2}=c_{0}c_{1}+1,\\delta_{2}=c_{1}</span>;</p>

    <p class="text-gray-300">and so on. Thus, we can derive recursive formulas to calculate the remaining values for generic <span class="math">i \\geq 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_{i+1} = \\alpha_i \\cdot c_{i+1} + \\gamma_i,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\beta_{i+1} = \\beta_i \\cdot c_{i+1} + \\delta_i,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\gamma_{i+1} = \\alpha_i,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\delta_{i+1} = \\beta_i.</span></div>

    <h2 id="sec-36" class="text-2xl font-bold">C System of Equations from Section 7</h2>

    <p class="text-gray-300">The system of equations is constructed by symbolically computing <span class="math">A_{\\mathrm{AES}}^{-1}(\\hat{C}(x))</span>, as described in Section 7, and setting all coefficients for degrees 8, 16, 32, 64, 128 to 0. These are five possible degrees and the following equations are the sum of all coefficients belonging to each of these degrees:</p>

    <div class="my-4 text-center"><span class="math-block">0 \\mathrm{x} 5 \\mathrm{a} \\cdot \\hat{c}_1^8 + 0 \\mathrm{x} 7 \\mathrm{f} \\cdot \\hat{c}_2^4 + 0 \\mathrm{x} \\mathrm{f} \\cdot \\hat{c}_4^2 = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">0 \\mathrm{x} 7 8 \\cdot \\hat{c}_1^{16} + 0 \\mathrm{x} 5 \\mathrm{a} \\cdot \\hat{c}_2^8 + 0 \\mathrm{x} 7 \\mathrm{f} \\cdot \\hat{c}_4^4 = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">0 \\mathrm{x} 5 9 \\cdot \\hat{c}_1^{32} + 0 \\mathrm{x} 7 8 \\cdot \\hat{c}_2^{16} + 0 \\mathrm{x} 5 \\mathrm{a} \\cdot \\hat{c}_4^8 = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">0 \\mathrm{x} \\mathrm{d} \\mathrm{b} \\cdot \\hat{c}_1^{64} + 0 \\mathrm{x} 5 9 \\cdot \\hat{c}_2^{32} + 0 \\mathrm{x} 7 8 \\cdot \\hat{c}_4^{16} = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">0 \\mathrm{x} 6 \\mathrm{e} \\cdot \\hat{c}_1^{128} + 0 \\mathrm{x} \\mathrm{d} \\mathrm{b} \\cdot \\hat{c}_2^{64} + 0 \\mathrm{x} 5 9 \\cdot \\hat{c}_4^{32} = 0.</span></div>

    <p class="text-gray-300">By practical tests we found that no (nontrivial) coefficients <span class="math">\\hat{c}_1, \\hat{c}_2, \\hat{c}_4</span> satisfy all previous equalities, which means that there are no polynomials <span class="math">\\hat{B}</span> and <span class="math">\\hat{C}</span> both of degree 4 that satisfy <span class="math">A_{\\mathrm{AES}}(X) = (\\hat{C} \\circ \\hat{B}^{-1})(X)</span>.</p>

    <p class="text-gray-300">30</p>`;
---

<BaseLayout title="Algebraic Cryptanalysis of STARK-Friendly Designs: Applicati... (2019/419)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/419
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
