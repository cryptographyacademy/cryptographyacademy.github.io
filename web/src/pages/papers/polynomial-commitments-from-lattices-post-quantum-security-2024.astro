---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/281';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Polynomial Commitments from Lattices: Post-Quantum Security, Fast Verification and Transparent Setup';
const AUTHORS_HTML = 'Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, Hoeteck Wee';

const CONTENT = `    <p class="text-gray-300">Polynomial Commitments from Lattices: Post-Quantum Security, Fast Verification and Transparent Setup</p>

    <p class="text-gray-300">Valerio Cini^{1}, Giulio Malavolta^{2}, Ngoc Khanh Nguyen^{3}, and Hoeteck Wee^{1}</p>

    <p class="text-gray-300">^{1} NTT Research, Sunnyvale, CA, USA ^{2} Bocconi University, Milan, Italy ^{3} King’s College London, London, UK</p>

    <p class="text-gray-300">Abstract. Polynomial commitment scheme allows a prover to commit to a polynomial <span class="math">f\\in\\mathcal{R}[X]</span> of degree <span class="math">L</span>, and later prove that the committed function was correctly evaluated at a specified point <span class="math">x</span>; in other words <span class="math">f(x)=u</span> for public <span class="math">x,u\\in\\mathcal{R}</span>. Most applications of polynomial commitments, e.g. succinct non-interactive arguments of knowledge (SNARKs), require that (i) both the commitment and evaluation proof are succinct (i.e., polylogarithmic in the degree <span class="math">L</span>) - with the latter being efficiently verifiable, and (ii) no pre-processing step is allowed.</p>

    <p class="text-gray-300">Surprisingly, as far as plausibly quantum-safe polynomial commitments are concerned, the currently most efficient constructions only rely on weak cryptographic assumptions, such as security of hash functions. Indeed, despite making use of the underlying algebraic structure, prior lattice-based polynomial commitments still seem to be much behind the hash-based ones. Moreover, security of the aforementioned lattice constructions against quantum adversaries was never formally discussed.</p>

    <p class="text-gray-300">In this work, we bridge the gap and propose the first (asymptotically and concretely) efficient lattice-based polynomial commitment with transparent setup and post-quantum security. Our interactive variant relies on the standard (Module-)SIS problem, and can be made non-interactive in the random oracle model using Fiat-Shamir transformation. In addition, we equip the scheme with a knowledge soundness proof against quantum adversaries which can be of independent interest. In terms of concrete efficiency, for <span class="math">L=2^{20}</span> our scheme yields proofs of size <span class="math">2\\mathrm{X}</span> smaller than the hash-based FRI commitment <em>(Block et al., 2023)</em>, and <span class="math">70\\mathrm{X}</span> smaller than the very recent lattice-based construction by <em>Albrecht et al. (2024)</em>.</p>

    <h2 id="sec-1" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Succinct arguments allow an untrusted prover to convince a verifier that a given computation is correctly executed, while incurring communication and possibly verification time, that are much smaller than the computation size <em>(2004arXiv050606005K, , 2005)</em>. In the past decade, we have seen substantial theoretical and practical interest as well as remarkable progress in the construction of efficient succinct arguments, achieving different trade-offs between (transparent or trusted) setup, underlying assumptions and efficiency. In this work, we focus on succinct non-interactive arguments of knowledge (SNARKs) –such as those in <em>(BBHR18a, , 2004, GLS^{+}23, , 2023)</em>– that simultaneously satisfy all of the following requirements:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>supports computation in all of NP;</li>

      <li>achieves communication and verification time that are sublinear, ideally poly-logarithimic, in computation size;</li>

      <li>non-interactive or interactive and public-coin;</li>

      <li>relies on a transparent setup (that is, a common random string);</li>

      <li>achieves fast prover time that is quasi-linear in computation size;</li>

      <li>relies on well-studied hardness assumptions;</li>

      <li>relies on post-quantum assumptions only.</li>

    </ol>

    <p class="text-gray-300">Each of these properties is highly desirable from both a theoretical and practical stand-point. Moreover, properties (1) – (6) are crucial for various real-world applications, and indeed, several of the SNARKs currently in deployment <em>(BBHR18b, , 2022)</em> do satisfy all of (1) – (7). We refer to Fig 1 for a brief summary of prior SNARK constructions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(3)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(4)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(5)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(6)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(7)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Kil92,Mic94]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Gro16]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCC+16]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GWC19,CHM+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BFS20,BHR+21,Lee21]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BLNS20,BS23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CJJ22]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[ACL+22,CLM23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[FMN23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[AFLN23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BBHR18b,AHIV17,COS20,GLS+23,BGK+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓H</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCS23]</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓L</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. A brief (and incomplete) survey of prior SNARKs. The columns correspond to: (1) all of NP, (2) sublinear communication/verification, (3) non-interactive, (4) transparent set-up, (5) quasi-linear prover, (6) well-studied hardness, (7) post-quantum assumptions. In (7), L: lattices, H: hash functions, and a  <span class="math">\\sqrt{\\sqrt{\\nu}}</span>  indicates security against quantum adversaries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumptions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">225</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">230</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">FRI [BGK+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">RO</td>

            <td class="px-3 py-2 border-b border-gray-700">932KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4MB</td>

            <td class="px-3 py-2 border-b border-gray-700">2MB</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[FMN23]</td>

            <td class="px-3 py-2 border-b border-gray-700">PowerBASIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3.4MB</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">8.3MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SLAP [AFLN23]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">36.5MB</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">767MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS, RO</td>

            <td class="px-3 py-2 border-b border-gray-700">120KB</td>

            <td class="px-3 py-2 border-b border-gray-700">501KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.51MB</td>

            <td class="px-3 py-2 border-b border-gray-700">5.17MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 2. Efficiency comparison of plausibly post-quantum polynomial commitments over finite fields for the 128-bit security level (apart from  <span class="math">\\mathrm{[BGK^{+}23}</span> , Figure 6], where the sizes correspond to 80 bits of security), and degrees  <span class="math">L\\in \\{2^{15},2^{20},2^{25},2^{30}\\}</span> . For each construction, the Fiat-Shamir loss of  <span class="math">Q\\approx 2^{64}</span>  random oracle queries is taken into account. Data is taken as reported in the respective works.</p>

    <p class="text-gray-300">So far, almost all known schemes satisfying (1) - (7), including the aforementioned schemes in deployment, rely on hash functions, with the only exception being the recent work of Bootle, Chiesa and Sotiraki [BCS23], hence-forth BCS23, which is based on lattice assumptions. While the BCS23 scheme seems to be concretely less efficient than prior hash-based schemes, <span class="math">^{4}</span>  anecdotal evidence –notably the adoption of lattice-based schemes in the NIST PQC competition as the primary algorithms for both key encapsulation and signatures—suggests that lattice-based schemes could ultimately outperform hash-based ones with respect to many efficiency metrics. Indeed, putting property (2) aside, a recent lattice-based proof system by Beullens and Seiler [BS23] with linear-time verification achieves proof size that beats prior hash-based schemes by an order of magnitude.</p>

    <p class="text-gray-300">The currently most efficient constructions of SNARKs follow a common building template, i.e. combining an information-theoretic proof system called Polynomial IOP (PIOP)  <span class="math">\\left[\\mathrm{CHM}^{+}20\\right]</span> , together with an extractable polynomial commitment scheme [KZG10]. The latter one allows a party to commit to a polynomial  <span class="math">f</span>  of degree  <span class="math">L</span> , and later prove knowledge of the committed function that was correctly evaluated at a given point  <span class="math">x</span> , i.e.  <span class="math">f(x) = u</span> , where  <span class="math">x</span>  and  <span class="math">u</span>  are known to the verifier. Thus, it suffices to construct an extractable polynomial commitment scheme that satisfies (2)-(7).</p>

    <p class="text-gray-300">We present a new, simple and direct construction of lattice-based extractable polynomial commitments satisfying properties (2) - (7), with polylog  <span class="math">(L)</span>  communication and verification times, matching the asymptotic efficiency of the BCS23 scheme. The security of our scheme relies on the standard (Module)-SIS assumption. Our construction combines FRI-style folding [BBHR18a,BHR+21] with lattice homomorphism, a significant departure from the BCS23 approach which translates previous pairing-based schemes based on Bulletproofs to the lattice setting [Lee21,BBB+17,BCC+16].</p>

    <p class="text-gray-300">The simplicity of our construction together with the tight integration of lattice techniques further enables us to achieve the following improvements over the BCS23 scheme.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">No pre-processing.</h4>

    <p class="text-gray-300">Our polynomial commitment scheme achieves sublinear verification times without any pre-processing. This property is useful for building SNARKs for succinct R1CS instances with fast verification without pre-processing.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Concrete efficiency.</h4>

    <p class="text-gray-300">We combine a variant of our scheme with optimizations developed in the context of lattice-based zero knowledge <em>[x14, x15]</em> to obtain a concretely-efficient scheme with <span class="math">O(\\sqrt[3]{L})</span> proof size and verification complexity. In terms of concrete efficiency, for polynomials of degree <span class="math">L=2^{20}</span>, our scheme produces proofs of size <span class="math">2</span>X smaller than the hash-based non-interactive FRI commitment <em>[BGK^{+}23]</em>, <span class="math">6</span>X smaller than the lattice-based construction by Fenzi, Moghaddas, and Nguyen <em>[x10]</em> (which requires a trusted setup and relies on a non-standard assumption), and <span class="math">70</span>X smaller than the very recent work by Albrecht et al. <em>[x1]</em> (which requires a trusted setup). We provide a summary comparison in Figure 2.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Post-quantum security.</h4>

    <p class="text-gray-300">We show that our scheme is secure against quantum adversaries under the LWE assumption, by combining the quantum rewinding framework from <em>[x6, x14]</em>, with the notion of constructive post-quantum reduction from <em>[x3]</em>. Ours is the first polynomial commitment with a proof of security against a quantum adversary, and furthermore we obtain a negligible soundness error, filling a gap left open in <em>[x14]</em>.</p>

    <p class="text-gray-300">Our polynomial commitment enjoys several additional advantages over BCS23: (i) our scheme naturally supports multilinear polynomials, and can therefore be used in conjunction with proof systems such as Hyperplonk <em>[x5]</em>, or lookup arguments <em>[x17]</em>, (ii) we show explicitly how to achieve negligible soundness (whereas BCS23 would require parallel repetition <em>[x2]</em>), (iii) our scheme uses a single polynomial-sized modulus, which comes in handy when optimizing ring arithmetic in hardware, whereas BCS23 requires using two moduli, and the latter one is of super-polynomial size.</p>

    <p class="text-gray-300">While the concrete efficiency of our optimized scheme is still <span class="math">\\approx 10</span>X worse than the lattice-based proof system from <em>[x2]</em>, we believe that techniques of this work can pave a path towards practical quantum-safe polynomial commitments from lattices.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.2 Related Works</h3>

    <p class="text-gray-300">A notion of a polynomial commitment scheme was introduced by Kate, Zaverucha and Goldberg <em>[x12]</em>, who also proposed the first concrete instantiation from pairings. The widely-used KZG commitment is a core building block of SNARKs <em>[x16, CHM^{+}20, x2]</em>, and cryptocurrency applications <em>[x1]</em>. Unfortunately, it seems non-trivial to build a lattice analogue of KZG, and thus other approaches of building lattice-based polynomial commitments were considered.</p>

    <p class="text-gray-300">The most intuitive way to construct a polynomial commitment from lattices is to come up with a lattice-based commitment scheme, together with a split-and-fold interactive proof of polynomial evaluation, which can then be made non-interactive using the Fiat-Shamir transformation <em>[x11]</em>. For instance, polynomial evaluation relation <span class="math">f(x)=u</span> can be seen as a linear equation</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}1&x&x^{2}&\\cdots&x^{L}\\end{bmatrix}\\begin{bmatrix}f_{0}\\\\ \\vdots\\\\ f_{L}\\end{bmatrix}=u \\] (1)</p>

    <p class="text-gray-300">where <span class="math">(f_{0},f_{1},\\ldots,f_{L})</span> is the coefficient vector of <span class="math">L</span>. Then, one could naively apply an inner-product argument, such the lattice adaptation of Bulletproofs <em>[x1, x2, x4]</em>, to prove (1). The main bottleneck of the aforementioned works is verification complexity being linear in <span class="math">L</span>. This issue has been recently overcome with two orthogonal approaches: (i) <em>[x2]</em> proposed a new delegation protocol inspired by Dory <em>[x13]</em> that requires pre-processing,</p>

    <p class="text-gray-300">(ii) <em>[x10]</em> introduced more structure on the commitment that allows fast verification at the cost of relying on a new Vanishing-SIS assumption.</p>

    <p class="text-gray-300">An alternative approach for proving polynomial evaluations in a split-and-fold fashion was introduced in FRI <em>[x1]</em>, and later adapted to the lattice setting in <em>[x13]</em>. In order to achieve fast verification, the latter work relies on a new PowerBASIS assumption, which is an extension of the BASIS assumption <em>[x35]</em> with additional power structure. Moreover, the construction seems to be impractical due to the requirement on trusted setup, quadratic common reference string (CRS), and quadratic prover runtime. A very recent follow-up work by Albrecht et al. <em>[x1]</em> managed to reduce the CRS size, have a quasi-linear prover runtime, and rely on a standard Module-SIS assumption. Nevertheless, the need of a trusted setup still remains.</p>

    <p class="text-gray-300">Finally, there is a line of recent works on lattice-based functional commitments <em>[ACL^{+}22, x2, x1, x14, x23]</em> which can be naively used to prove (1). However, vast majority of those constructions requires pre-processing (i.e. knowing <span class="math">x</span> in advance). Moreover, only <em>[ACL^{+}22, x2, x1]</em> are extractable (although under a knowledge assumption) but a trusted setup is needed.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Additional related work.</h4>

    <p class="text-gray-300">The study of succinct arguments with concrete efficiency was initiated in the works of <em>[x20, x15, x26]</em>. Our protocol falls under the broader framework of compressed <span class="math">\\Sigma</span>-protocols <em>[x2]</em>, and the use of folding is also closely related to sum-check protocols <em>[x24, x3]</em>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Paper Organization</h3>

    <p class="text-gray-300">We provide a technical overview of our results in Section 2. Preliminaries and notation are described in Section 3. In Section 4 and Section 5 we describe our new commitment scheme together with a proof of evaluation. We then show how to instantiate a polynomial commitment scheme in Section 6. In Appendix A we propose a concretely efficient version of our protocol using cyclotomic rings. Finally, we provide a knowledge soundness proof against quantum adversaries in Appendix B.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 Technical Overview</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we provide an overview of our results and main techniques. In the following, we denote <span class="math">L</span> to be the length of the witness, <span class="math">\\lambda</span> is a security parameter, and <span class="math">\\kappa</span> denotes a statistical security parameter, where <span class="math">2^{-\\kappa}</span> will roughly be the knowledge soundness error. Here, we denote by $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ the infinity norm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 Succinct, extractable commitments from SIS</h3>

    <p class="text-gray-300">We start by constructing a succinct, extractable commitment based on hardness of the Shortest Integer Solution (SIS) problem <em>[x1]</em>. Concretely, the commitment to a vector of length <span class="math">L</span> has size <span class="math">\\mathsf{poly}(\\lambda,\\log L)</span>, and admits a public-coin interactive proof of knowledge with communication <span class="math">\\mathsf{poly}(\\lambda,\\log L)</span>, where <span class="math">\\lambda</span> is a security parameter. Binding holds under the SIS assumption, and since the focus of this work is on succinctness and not zero-knowledge, we do not require hiding.</p>

    <p class="text-gray-300">More generally, the scheme takes as input an additional parameter <span class="math">r</span>, and achieves:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">O(\\frac{\\log L}{\\log r})</span> rounds and communication <span class="math">r\\cdot\\mathsf{poly}(\\lambda)</span>;</li>

      <li>prover time <span class="math">r\\cdot L\\cdot\\mathsf{poly}(\\lambda)</span> and verification time <span class="math">r\\cdot\\mathsf{poly}(\\lambda)</span>.</li>

    </ul>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Homomorphic SIS commitment.</h4>

    <p class="text-gray-300">We start with the standard SIS commitment for vectors <span class="math">\\mathbf{f}\\in\\mathbb{Z}_{q}^{L}</span> given by</p>

    <p class="text-gray-300"><span class="math">\\mathbf{f}\\mapsto\\mathbf{A}\\cdot\\mathbf{G}^{-1}(\\mathbf{f})\\in\\mathbb{Z}_{q}^{n}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times L\\log q}</span> and <span class="math">\\mathbf{G}=\\mathbf{I}_{L}\\otimes\\mathbf{g}^{\\top}\\in\\mathbb{Z}_{q}^{L\\times L\\log q}</span> is the gadget matrix. The opening of a commitment <span class="math">\\mathbf{t}</span> to <span class="math">\\mathbf{f}</span> is a low-norm vector <span class="math">\\mathbf{s}\\in\\mathbb{Z}^{L\\log q}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}\\cdot\\mathbf{s}=\\mathbf{t}\\bmod q\\quad\\text{and}\\quad\\mathbf{G}\\cdot\\mathbf{s}=\\mathbf{f}\\bmod q.</span></p>

    <p class="text-gray-300">Binding follows readily from SIS. Next, observe that the scheme satisfies the following homomorphism property: given commitments  <span class="math">\\mathbf{t}_b</span>  to  <span class="math">\\mathbf{f}_b</span>  and openings  <span class="math">\\mathbf{s}_b</span> , where  <span class="math">b \\in \\{0,1\\}</span> , along with any small scalars  <span class="math">c_0, c_1 \\in \\mathbb{Z}_q</span> , we can compute a commitment  <span class="math">c_0 \\cdot \\mathbf{t}_0 + c_1 \\cdot \\mathbf{t}_1</span>  to  <span class="math">c_0 \\cdot \\mathbf{f}_0 + c_1 \\cdot \\mathbf{f}_1</span>  with opening  <span class="math">c_0 \\cdot \\mathbf{s}_0 + c_1 \\cdot \\mathbf{s}_1</span> .</p>

    <p class="text-gray-300">Tree-based variant. Following [PSTY13,LLNW16], we define a tree-like variant of the preceding scheme. Fix</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 3. Graphic representation of the tree-like variant for  <span class="math">\\ell = 1</span>  and  <span class="math">r = 2</span> . The vector  <span class="math">\\mathbf{f}</span>  is parsed as  <span class="math">\\mathbf{f} = (\\mathbf{f}_0, \\mathbf{f}_1)</span> , where  <span class="math">\\mathbf{f}_i \\in \\mathbb{Z}_q^{r \\kappa n}</span> , and  <span class="math">\\mathbf{f}_i = (\\mathbf{f}_{i0}, \\mathbf{f}_{i1})</span> , where  <span class="math">\\mathbf{f}_{ij} \\in \\mathbb{Z}_q^{\\kappa n}</span> . The expressions on the left hand side represent the concatenation of the nodes at the given depth.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A} \\in \\mathbb{Z}_q^{n \\times rn \\log q}</span> . Then,  <span class="math">(\\mathbf{I}_{L / rn} \\otimes \\mathbf{A}) \\cdot \\mathbf{G}^{-1}(\\mathbf{f}) \\in \\mathbb{Z}_q^{L / r}</span>  yields a commitment for  <span class="math">\\mathbf{f}</span>  with compression factor  <span class="math">r</span> ; using a  <span class="math">r</span> -ary tree of depth  <span class="math">\\ell + 1</span>  then yields compression factor  <span class="math">r^{\\ell + 1}</span> . Concretely, the commitment  <span class="math">\\mathbf{t} \\in \\mathbb{Z}_q^{\\kappa n}</span>  to a vector  <span class="math">\\mathbf{f} \\in \\mathbb{Z}_q^{r^{\\ell + 1} \\kappa n}</span>  is given by:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t} := \\left(\\mathbf {I} _ {\\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\underbrace {\\mathbf {G} _ {r \\kappa n} ^ {- 1} \\left(\\left(\\mathbf {I} _ {r \\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\mathbf {G} _ {r ^ {2} \\kappa n} ^ {- 1} \\left(\\cdots \\mathbf {G} _ {r ^ {\\ell} \\kappa n} ^ {- 1} \\left(\\left(\\mathbf {I} _ {r ^ {\\ell} \\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\underbrace {\\mathbf {G} _ {r ^ {\\ell + 1} \\kappa n} ^ {- 1} (\\mathbf {f})\\right)\\right)\\right)} _ {\\mathbf {s} _ {0}}. \\tag {2}</span></div>

    <p class="text-gray-300">The opening are short vectors  <span class="math">(\\mathbf{s}_0,\\dots ,\\mathbf{s}_{\\ell})</span>  where  <span class="math">\\mathbf{s}_j\\in \\mathbb{Z}^{r^{j + 1}\\kappa n\\log q}</span> , satisfying</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {\\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\mathbf {s} _ {0} = \\mathbf {t} \\bmod q,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {G} _ {r ^ {j + 1} \\kappa n} \\cdot \\mathbf {s} _ {j} = \\left(\\mathbf {I} _ {r ^ {j + 1} \\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\mathbf {s} _ {j + 1} \\quad \\text {f o r a l l} j \\in [ 0, \\ell - 1 ],</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {G} _ {r ^ {\\ell + 1} \\kappa n} \\cdot \\mathbf {s} _ {\\ell} = \\mathbf {f} \\bmod q,</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {j} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\quad \\text {f o r a l l} j \\in [ 0, \\ell ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">A key observation in this work is that the commitment scheme satisfies the following "folding-homomorphic" property: given a commitment  <span class="math">\\mathbf{t}</span>  to  <span class="math">\\mathbf{f}</span>  and its opening  <span class="math">(\\mathbf{s}_0, \\ldots, \\mathbf{s}_\\ell)</span> , as well as any  <span class="math">\\mathbf{C} \\in \\{0,1\\}^{\\kappa r \\times \\kappa}</span>  (a "folding challenge"), then we can compute a commitment to  <span class="math">(\\mathbf{C}^\\top \\otimes \\mathbf{I}) \\cdot \\mathbf{f} \\in \\mathbb{Z}_q^{r^\\ell \\kappa n}</span>  (a "folded function"). Concretely,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t} ^ {*} := \\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {G}\\right) \\cdot \\mathbf {s} _ {0} \\quad (\\text {a &quot; f o l d e d c o m m i t m e n t})</span></div>

    <p class="text-gray-300">is a commitment to  <span class="math">\\mathbf{f}^{*}\\coloneqq (\\mathbf{C}^{\\top}\\otimes \\mathbf{I})\\cdot \\mathbf{f}\\in \\mathbb{Z}_{q}^{r^{\\ell}\\kappa n}</span>  with opening</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {s} _ {0} ^ {*}, \\dots , \\mathbf {s} _ {\\ell - 1} ^ {*}\\right) := \\left(\\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {I}\\right) \\cdot \\mathbf {s} _ {1}, \\dots , \\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {I}\\right) \\cdot \\mathbf {s} _ {\\ell}\\right).</span></div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 4. Graphic representation of one round of "homomorphic-folding" via the "folding challenge"  <span class="math">\\mathbf{C}</span> , for  <span class="math">\\ell = 1</span>  and  <span class="math">r = 2</span> . For each  <span class="math">i \\in \\mathbb{Z}_r</span> , the challenge  <span class="math">\\mathbf{C}</span>  is used to "collapse" all  <span class="math">i</span> -th sibling leaves of the old tree into a single leaf of the new tree, i.e.,  <span class="math">\\mathbf{f}_b^* = \\mathbf{C}^\\top \\cdot (\\mathbf{f}_{0b}, \\mathbf{f}_{1b})</span> . Notice that the new tree (right) has depth one less than the old one (left).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof is a straightforward application of the mixed-product property, which tells us  <span class="math">\\mathbf{C}^{\\top} \\otimes \\mathbf{I}</span>  "commutes" with  <span class="math">\\mathbf{I} \\otimes \\mathbf{A}</span>  (see (11) for a precise statement). Moreover,  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_j^* \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq r\\kappa \\beta<span class="math">  for any  </span>j \\in [0, \\ell - 1]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Looking ahead, we will use the fact that to compute  <span class="math">\\mathbf{t}^*</span> , it suffices to know the short partial opening  <span class="math">\\mathbf{s}_0 \\in \\mathbb{Z}^{r\\kappa n \\log q}</span> .</p>

    <p class="text-gray-300">Considering for a moment the tree-based viewpoint pictured in Figure 3, the "folding procedure" can be described as follows: for each  <span class="math">i \\in \\mathbb{Z}_r</span> , the challenge  <span class="math">\\mathbf{C}</span>  is used to "collapse" all  <span class="math">i</span> -th sibling leaves together into a single leaf of a new tree. This is described pictorially in Figure 4. Using the algebraic structure of the hash function, such folding propagates to every node of the tree. Moreover, there is a  <span class="math">r</span> -fold decrease in the number of leaves of the new tree compared to those of the initial tree. Thus, in the process the depth of the tree is decreases by 1. Since the algebraic point of view, together with the tensor product notation, is more amenable to be used to work with, we are going to use the algebraic prospective only in the rest of the paper.</p>

    <p class="text-gray-300">Proof of knowledge via folding. Proof of knowledge proceeds recursively in  <span class="math">\\ell</span>  rounds via FRI-style folding [BBHR18a] (also used in  <span class="math">[\\mathrm{BHR}^{+}21,\\mathrm{FMN}23])</span> : to prove knowledge of an opening to  <span class="math">\\mathbf{f}\\in \\mathbb{Z}_q^{r^{\\ell +1}\\kappa n}</span>  for a commitment  <span class="math">\\mathbf{t}\\in \\mathbb{Z}_q^{\\kappa n}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover sends  <span class="math">\\mathbf{y} \\coloneqq \\mathbf{s}_0 \\in \\mathbb{Z}^{r\\kappa n \\log q}</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- the verifier checks that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is small and that  </span>(\\mathbf{I}_{\\kappa}\\otimes \\mathbf{A})\\cdot \\mathbf{y} = \\mathbf{t}<span class="math"> ; then sends a random challenge  </span>\\mathbf{C}\\gets \\{0,1\\}^{\\kappa r\\times \\kappa}$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>both parties derive the new commitment  <span class="math">\\mathbf{t}^<em> := (\\mathbf{C}^\\top \\otimes \\mathbf{G}) \\cdot \\mathbf{y}</span> , and the prover derives an opening of  <span class="math">\\mathbf{t}^</em></span>  to  <span class="math">\\mathbf{f}^* := (\\mathbf{C}^\\top \\otimes \\mathbf{I}) \\cdot \\mathbf{f}</span>  via the above-mentioned folding homomorphism property.</li>

    </ul>

    <p class="text-gray-300">We repeat the above protocol  <span class="math">\\ell</span>  times until we arrive at a commitment to a vector of length  <span class="math">\\kappa n</span> , for which the prover can simply send its opening, which will have norm at most  <span class="math">(r\\kappa)^{\\ell}\\beta</span> .</p>

    <p class="text-gray-300">Next, we need to construct a knowledge extractor that outputs  <span class="math">\\mathbf{f}</span>  along with an opening to  <span class="math">\\mathbf{f}</span> . The knowledge extractor is also constructed recursively, following the coordinate-wise extraction strategy from  <span class="math">[\\mathrm{BBC}^{+}18,\\mathrm{FMN}23]</span> . Informally, this means that we need to compute an opening of  <span class="math">\\mathbf{t}</span>  to  <span class="math">\\mathbf{f}</span>  given openings of  <span class="math">\\mathbf{t}_k^<em></span>  to  <span class="math">\\mathbf{f}^</em></span>  corresponding to different challenges  <span class="math">\\mathbf{C}_k</span> .</p>

    <p class="text-gray-300">The idea is to first run the cheating prover in the recursive step to obtain openings for some challenge  <span class="math">\\mathbf{C}_0</span> , and then rewind the cheating prover many times, so as to obtain openings for challenges  <span class="math">\\mathbf{C}_1, \\ldots, \\mathbf{C}_{r\\kappa}</span> , where  <span class="math">\\mathbf{C}_k</span>  agrees</p>

    <p class="text-gray-300">with <span class="math">\\mathbf{C}_0</span> in all columns except column <span class="math">k</span>. We can then argue that with probability <span class="math">1 - r\\kappa \\cdot 2^{-\\kappa}</span>, we can recover <span class="math">\\mathbf{f}</span> (respectively short <span class="math">\\mathbf{s}_j, j \\in [\\ell]</span>) given <span class="math">((\\mathbf{C}_k^\\top - \\mathbf{C}_0^\\top) \\otimes \\mathbf{I}) \\cdot \\mathbf{f}</span> (respectively <span class="math">((\\mathbf{C}_k^\\top - \\mathbf{C}_0^\\top) \\otimes \\mathbf{I}) \\cdot \\mathbf{s}_j, j \\in [\\ell]</span>) for all <span class="math">k \\in [r\\kappa]</span>. In each recursive step, we will need to rewind the cheating prover roughly <span class="math">(r\\kappa)</span> times, which means the overall extractor will need to make <span class="math">(r\\kappa)^\\ell</span> queries to a cheating prover. For vectors of length <span class="math">L \\approx r^\\ell</span>, the number of queries is bounded by <span class="math">\\approx L^2</span> as long as we choose <span class="math">r \\geq \\kappa</span>.</p>

    <p class="text-gray-300">As for the norm of the extracted openings, they increase by a factor of two after each recursive step. Since the initial opening, which is the last prover message, has norm <span class="math">(r\\kappa)^{\\ell}\\beta</span>, this means that the coefficients of the final extracted opening must be (in the absolute value) at most <span class="math">(2r\\kappa)^{\\ell}\\beta</span>. Moreover, the proof system modulus <span class="math">q</span> has to be at least larger than (twice) the extracted norm to ensure binding, and thus <span class="math">q = (2r\\kappa)^{\\ell}\\beta \\cdot \\mathsf{poly}(\\lambda)</span>. By setting parameters <span class="math">(r,k,\\ell)</span> as above, we get <span class="math">q = L^2\\cdot \\mathsf{poly}(\\lambda)</span>. This is a significant improvement over BCS23, where a super-polynomial modulus <span class="math">q = O(L^{\\log \\lambda})</span> is required for the soundness analysis.</p>

    <p class="text-gray-300">Finally, we give a rough estimation on the proof size of the protocol. First, to obtain negligible soundness error, we select <span class="math">r = \\kappa = O(\\lambda)</span>, and consequently <span class="math">\\ell = O\\left(\\frac{\\log L}{\\log\\lambda}\\right)</span>. Furthermore, for security of the underlying SIS assumption, we require at least <span class="math">n = O(\\lambda)</span>. Since for now we were using a gadget matrix with base two, we have <span class="math">\\beta = 1</span>. By assuming <span class="math">q = O((2r\\kappa)^{\\ell}\\beta) = O(L^{2})</span>, the total size of all the prover messages can be asymptotically bounded by</p>

    <div class="my-4 text-center"><span class="math-block">O \\left(\\lambda^ {3} \\cdot \\frac {\\log^ {3} L}{\\log \\lambda}\\right) \\quad \\text {bits}. \\tag {3}</span></div>

    <h2 id="sec-12" class="text-2xl font-bold">2.2 Upgrading to polynomial commitments</h2>

    <p class="text-gray-300">Next, we describe how to modify our extractable commitment scheme so that the prover can prove evaluation of the committed function <span class="math">\\mathbf{f} \\in \\mathbb{Z}_q^{r^{j+1}\\kappa n}</span> as a multilinear polynomial, with a small increase in communication and computation. Namely, in addition to the commitment <span class="math">\\mathbf{t}</span>, both the prover and the verifier receive <span class="math">\\mathbf{x}_0, \\ldots, \\mathbf{x}_\\ell \\in \\mathbb{Z}_q^r</span> and <span class="math">\\mathbf{u} \\in \\mathbb{Z}_q^{\\kappa n}</span>, and we want to check that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {\\kappa n} \\otimes \\mathbf {x} _ {\\ell} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {x} _ {\\ell - 1} ^ {\\top}\\right) \\dots \\left(\\mathbf {I} _ {r ^ {\\ell} \\kappa n} \\otimes \\mathbf {x} _ {0} ^ {\\top}\\right) \\cdot \\mathbf {f} = \\mathbf {u} \\tag {4}</span></div>

    <p class="text-gray-300">Observe that the computation as described above has the same <span class="math">r</span>-ary depth <span class="math">\\ell</span> tree structure as our commitment in (2). It is easy to see that for <span class="math">n = 1, \\kappa = 1, r = 2</span>, this captures polynomial evaluation for both multi-linear polynomials in <span class="math">\\ell + 1</span> variables and univariate polynomials of degree <span class="math">2^{\\ell + 1}</span>, where <span class="math">\\mathbf{f}</span> corresponds to the coefficient vector of these polynomials.</p>

    <p class="text-gray-300"><strong>Proof of evaluation via folding.</strong> We proceed recursively via FRI-style folding as before:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover sends <span class="math">\\mathbf{v} \\coloneqq (\\mathbf{I}_{r\\kappa n} \\otimes \\mathbf{x}_{\\ell - 1}^{\\top}) \\cdots (\\mathbf{I}_{r^{\\ell}\\kappa n} \\otimes \\mathbf{x}_0^{\\top}) \\cdot \\mathbf{f}</span> in addition to <span class="math">\\mathbf{y}</span>;</li>

      <li>verifier checks that <span class="math">(\\mathbf{I}_{\\kappa n}\\otimes \\mathbf{x}_{\\ell}^{\\top})\\cdot \\mathbf{v} = \\mathbf{t}</span> in addition to the previous checks on <span class="math">\\mathbf{y}</span>, then sends <span class="math">\\mathbf{C}\\gets \\{0,1\\}^{r\\kappa \\times \\kappa}</span> as before;</li>

      <li>both parties compute <span class="math">\\mathbf{u}^{<em>} \\coloneqq (\\mathbf{C}^{\\top} \\otimes \\mathbf{I}) \\cdot \\mathbf{v}</span> in addition <span class="math">\\mathbf{t}^{</em>}</span>;</li>

      <li>the prover derives the opening of <span class="math">\\mathbf{t}^<em></span> to <span class="math">\\mathbf{f}^</em></span> as before.</li>

    </ul>

    <p class="text-gray-300">The prover proceeds then recursively to prove that the committed function in <span class="math">\\mathbf{t}^<em></span> evaluates at <span class="math">(\\mathbf{x}_{\\ell -1},\\dots ,\\mathbf{x}_0)</span> to <span class="math">\\mathbf{u}^</em></span>. Completeness relies on the following equality, which again follows from the mixed-product property:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\mathbf {I} _ {\\kappa n} \\otimes \\mathbf {x} _ {\\ell - 1} ^ {\\top}\\right) \\dots \\left(\\mathbf {I} _ {r ^ {\\ell - 1} \\kappa n} \\otimes \\mathbf {x} _ {0} ^ {\\top}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {I}\\right) \\cdot \\mathbf {f})} ^ {\\mathbf {f} ^ {*}} \\\\ = \\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {I}\\right) \\cdot \\overbrace {\\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {x} _ {\\ell - 1} ^ {\\top}\\right) \\cdots \\left(\\mathbf {I} _ {r ^ {\\ell} \\kappa n} \\otimes \\mathbf {x} _ {0} ^ {\\top}\\right) \\cdot \\mathbf {f}} ^ {\\mathbf {u} ^ {*}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 5. Proof of knowledge of short  <span class="math">(\\mathbf{s}_0,\\mathbf{s}_1,\\mathbf{s}_2)\\in \\mathbb{Z}_q^{r\\kappa n\\log q}\\times \\mathbb{Z}_q^{r^2\\kappa n\\log q}\\times \\mathbb{Z}_q^{r^3\\kappa n\\log q}</span>  which satisfy Equations (5) and (6). Here,  <span class="math">\\mathcal{C} := \\{0,1\\}</span> .</p>

    <p class="text-gray-300">Formally, we define a relation  <span class="math">\\mathsf{R}_{\\ell,\\beta_{\\ell}}</span>  over instances  <span class="math">(\\mathbf{A}, \\mathbf{x}_0, \\ldots, \\mathbf{x}_{\\ell}, \\mathbf{u}, \\mathbf{t})</span> , where the witness is an opening (with norm at most  <span class="math">\\beta_{\\ell}</span> ) of  <span class="math">\\mathbf{t}</span>  to  <span class="math">\\mathbf{f}</span>  such that  <span class="math">\\mathbf{f}</span>  satisfies (4). Then, the recursive step can be viewed as a reduction from  <span class="math">\\mathsf{R}_{\\ell,\\beta_{\\ell}}</span>  to  <span class="math">\\mathsf{R}_{\\ell-1,\\beta_{\\ell-1}}</span>  (cf. Section 5).</p>

    <p class="text-gray-300">For the ease of presentation, we describe the combined protocol for  <span class="math">\\ell = 2</span>  in Figure 5 (and the more general setting in Figure 6); this protocol also serves as the starting point of our concretely-efficient scheme. The relation is specified by  <span class="math">\\mathbf{x}_0,\\mathbf{x}_1,\\mathbf{x}_2\\in \\mathbb{Z}_q^r</span> ,  <span class="math">\\mathbf{f}\\in \\mathbb{Z}_q^{r^3\\kappa n}</span>  and the output is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {u} := \\left(\\mathbf {I} _ {\\kappa n} \\otimes \\mathbf {x} _ {2} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r ^ {2} \\kappa n} \\otimes \\mathbf {x} _ {0} ^ {\\top}\\right) \\cdot \\mathbf {f} \\in \\mathbb {Z} _ {q} ^ {\\kappa n}. \\tag {5}</span></div>

    <p class="text-gray-300">That is, the goal is to show (5) holds given commitment</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t} = \\left(\\mathbf {I} _ {\\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\underbrace {\\mathbf {G} _ {r \\kappa n} ^ {- 1} \\left(\\left(\\mathbf {I} _ {r \\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\overbrace {\\mathbf {G} _ {r ^ {2} \\kappa n} ^ {- 1} \\left(\\left(\\mathbf {I} _ {r ^ {2} \\kappa} \\otimes \\mathbf {A}\\right) \\cdot \\underbrace {\\mathbf {G} _ {r ^ {3} \\kappa n} ^ {- 1} (\\mathbf {f})}\\right)} ^ {\\mathbf {s} _ {1}}\\right)} _ {\\mathbf {s} _ {0}} \\in \\mathbb {Z} _ {q} ^ {\\kappa n}. \\tag {6}</span></div>

    <p class="text-gray-300">In other words, the protocol described in Figure 5 can be seen as the sequential repetition of above protocol twice, followed by the trivial protocol where the prover simply sends the witness to the verifier.</p>

    <p class="text-gray-300">Optimizations. The protocol above can be further optimized as follows. First, there is no need to set  <span class="math">\\mathbf{t}</span>  as a commitment, if we already send the partial opening  <span class="math">\\mathbf{s}_0</span>  in the clear. Hence, we can simply treat  <span class="math">\\mathbf{s}_0</span>  (or more efficiently,  <span class="math">\\mathbf{G}\\mathbf{s}_0</span> )</p>

    <p class="text-gray-300">as a commitment to <span class="math">\\mathbf{f}</span>. Moreover, for both asymptotic and concrete efficiency, it is more beneficial to consider gadget matrices with larger bases than <span class="math">2</span>, such as <span class="math">q^{1/\\alpha}</span> where <span class="math">\\alpha=O(1)</span>. Hence, we manage to asymptotically reduce the proof size to</p>

    <p class="text-gray-300"><span class="math">O\\left(\\lambda^{3}\\cdot\\frac{\\log^{2}L}{\\log\\lambda}\\right)\\quad\\text{bits}.</span> (7)</p>

    <p class="text-gray-300">Finally, for flexibility reasons, one may use different dimensions <span class="math">(r_{i})_{i}</span> for the matrices <span class="math">(\\mathbf{A}_{i})_{i}</span>, which could slightly reduce the total proof size.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.3 Concrete Efficiency via Cyclotomic Rings</h3>

    <p class="text-gray-300">Despite asymptotic efficiency, the previously described protocol seems to provide concretely large proofs. Indeed, when setting realistic parameters, such as <span class="math">L=2^{20}</span> and <span class="math">\\lambda=128</span>, the expression calculated in Eq. (7) becomes around <span class="math">2^{23}</span>, which would result in at least a few tens, if not hundred, megabytes. The dominant term is undoubtedly <span class="math">\\lambda^{3}</span>, which consists of the following three terms: (i) dimension <span class="math">n</span> responsible for SIS hardness, (ii) folding factor <span class="math">r</span>, and (iii) soundness amplification factor <span class="math">\\kappa</span>. Recall that the last parameter is responsible for keeping the soundness error <span class="math">r\\kappa\\cdot 2^{-\\kappa}</span> negligible, where the "2" comes from the size of the set <span class="math">\\mathcal{C}=\\{0,1\\}</span>. Obviously, to reduce <span class="math">\\kappa</span> one could naively pick a larger set of integers <span class="math">\\mathcal{C}</span> but this comes at the cost of the increased norm of the prover messages, and thus the proof system modulus.</p>

    <p class="text-gray-300">Motivated by the above limitations, we translate our protocol to the setting of power-of-two cyclotomic rings <span class="math">R_{q}:=\\mathbb{Z}_{q}[X]/(X^{d}+1)</span> where <span class="math">d=O(\\lambda)</span>. This allows us to pick an exponential-sized set <span class="math">\\mathcal{C}</span> of short-norm polynomials, e.g. with coefficients in <span class="math">\\{0,1\\}</span>. Consequently, we can set <span class="math">\\kappa=1</span>, and thus gain a potential factor of <span class="math">\\lambda</span> improvement in the proof size, while keeping the prover messages relatively short.</p>

    <p class="text-gray-300">Unfortunately, a serious issue arises when performing knowledge extraction. Indeed, for the previous protocol we relied on a crucial property of <span class="math">\\mathcal{C}=\\{0,1\\}</span> that an inverse of any two distinct challenges is short. In the ring setting, such sets can have at most polynomial size <em>[x1]</em>, which would limit us to <span class="math">\\kappa=O(\\lambda/\\log\\lambda)</span>. Of course, one could stick with exponential-sized challenge spaces <span class="math">\\mathcal{C}</span> of binary polynomials and stubbornly continue the knowledge soundness argument as before. Then, instead of trying to extract a short witness <span class="math">\\bar{\\mathbf{s}}</span> which satisfies some relations, we would extract a (possibly large) witness <span class="math">\\bar{\\mathbf{s}}</span>, together with a scalar <span class="math">\\bar{c}</span> called slack, such that <span class="math">\\bar{c}\\cdot\\bar{\\mathbf{s}}</span> is short. We show that our commitment scheme is binding with respect to such relaxed openings. However, performing an analogue extraction strategy from Section 2.1 in the ring setting yields a slack <span class="math">\\bar{c}</span> of huge norm <span class="math">O(\\lambda^{2^{\\ell}})</span>. Since, for binding purposes, the proof system modulus has to be larger than the slack norm, when setting <span class="math">\\ell=\\log L</span> we get that <span class="math">\\log q=O(L)</span>, and thus the protocol loses the succinctness property. Concretely, this becomes problematic even for relatively small values of <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">Since here we are interested in concrete efficiency, we consider the protocol in Figure 5 as a base case of our polynomial commitment scheme with communication and verifier complexity <span class="math">O(\\sqrt[3]{L})</span> and <span class="math">\\ell=2</span>. In addition, to further decrease the slack norm, we substitute the second part of the protocol with a new exact proof of knowledge of a short vector <span class="math">\\mathbf{s}\\in R_{q}^{rm}</span> which satisfies</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\mathbf{I}_{r}\\otimes\\mathbf{A})\\cdot\\mathbf{s}=\\mathbf{t}\\quad\\text{and}\\quad\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta.$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, "exact" means that the extracted vector <span class="math">\\mathbf{s}</span> is indeed short, and thus no slack is required. To this end, we apply the approximate range proof methodology from <em>[x2, x10]</em>, which says that if a random projection <span class="math">\\overrightarrow{p}=P\\cdot\\overrightarrow{v}\\mod q</span> is short, where <span class="math">P\\leftarrow\\chi^{\\lambda\\times m}</span> is a uniformly random matrix with small coefficients over <span class="math">\\mathbb{Z}_{q}</span> and <span class="math">\\overrightarrow{v}\\in\\mathbb{Z}_{q}^{m}</span>, then with an overwhelming probability <span class="math">\\overrightarrow{v}</span> must also be short.</p>

    <p class="text-gray-300">The protocol starts by the verifier sending the projection matrix <span class="math">P\\leftarrow\\chi^{\\lambda\\times md}</span>, to which the prover replies with the projection</p>

    <p class="text-gray-300"><span class="math">\\overrightarrow{p}:=(I_{r}\\otimes P)\\cdot\\overrightarrow{s}\\in\\mathbb{Z}_{q}^{r\\lambda},</span> (9)</p>

    <p class="text-gray-300">where <span class="math">\\overrightarrow{s}:=(\\overrightarrow{s}_{1},\\ldots,\\overrightarrow{s}_{r})\\in\\mathbb{Z}_{q}^{rmd}</span> is the coefficient vector of <span class="math">\\mathbf{s}</span>. The verifier can manually check that <span class="math">\\overrightarrow{p}</span> is short, which intuitively proves that <span class="math">\\overrightarrow{s}</span> must be short as long as we prove well-formedness of the projection <span class="math">\\overrightarrow{p}</span>.</p>

    <p class="text-gray-300">By applying the <span class="math">\\mathbb{Z}_{q}</span>-to-<span class="math">R_{q}</span> transformation presented in <em>[x11]</em>, we reduce proving (9) to proving a tensor-type equation over <span class="math">R_{q}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{r}\\otimes\\mathbf{N})\\cdot\\mathbf{s}=\\boldsymbol{\\gamma}</span> (10)</p>

    <p class="text-gray-300"><span class="math">\\mathbf{N}</span> and <span class="math">\\boldsymbol{\\gamma}</span> can be computed by the verifier (we omit the exact formulas for the sake of presentation). Finally, proving Equations (8) and (10) follows exactly as in Section 2.1. The overall ring-based protocol is summarized in Figure 7 and described in Appendix A.</p>

    <p class="text-gray-300">We highlight that in the knowledge extraction of our <span class="math">O(\\sqrt[3]{L})</span>-size protocol we still need to account for slack. Indeed, our exact proof system is only applied in the second phase, while the first one remains the same as in Figure 5. To completely remove slack from the extraction analysis, one would need to be able to efficiently prove this type of statements over <span class="math">\\mathbb{Z}_{q}</span>:</p>

    <p class="text-gray-300"><span class="math">\\overrightarrow{p}:=(I_{r}\\otimes P_{1})\\cdot(I_{r^{2}}\\otimes P_{2})\\cdot\\overrightarrow{s}.</span></p>

    <p class="text-gray-300">One may try to follow our methodology for the “single-tensor” case presented above. Unfortunately, it is non-trivial whether one could reduce the equation (using techniques from <em>[x20]</em> or otherwise) to an equivalent tensor-type statement over <span class="math">R_{q}</span>. Hence, in the security analysis we need to deal with the slack norm, but it is greatly reduced thanks to the exact proof in the second part of the protocol.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.4 Post-Quantum Security</h3>

    <p class="text-gray-300">Proving post-quantum security of our polynomial commitment boils down to finding an extractor that, given a (quantum) adversary that succeeds in the protocol with non-negligible probability, recovers a valid committed polynomial with a similar probability. The main challenge in these settings is that, in general, one cannot freely rewind quantum algorithms, without violating the no-cloning theorem. Fortunately a series of work have developed the necessary technical toolkit to carry over rewinding arguments in the quantum settings. Relevantly for us, the work of <em>[x19]</em>, which in turn builds in the framework of <em>[x5]</em>, shows a general theorem for rewinding folding-like protocols. Specifically, they show that if a protocol is (i) recursive special sound and (ii) last-round collapsing, then it is indeed possible to rewind the attacker and recover a witness via a quantum extractor, which is the moral analogue of the classical algorithm.</p>

    <p class="text-gray-300">To understand the challenge, let us first see what goes wrong in applying the theorem of <em>[x19]</em> to our settings. First of all, it is actually easy to show that our protocol is last-round collapsing. As we have seen, our protocol is obtained by sequentially composing a 2-round subroutine: the partial transcript <span class="math">(z_{0},c_{1},\\ldots,z_{i-1},c_{i})</span> for the first <span class="math">i</span> rounds determines a “partial statement/witness pair” <span class="math">(x_{i},w_{i})</span>. The “partial witness” <span class="math">w_{i}</span> can be computed by the prover given the initial witness <span class="math">w_{0}</span> and the protocol transcript. Loosely speaking, last-round collapsing says that measuring the register that contains <span class="math">w_{i}</span> should be “undetectable” (provided it is a valid witness). Given recent works <em>[x21, x18]</em> that show that the SIS-function is collapsing <em>[x26]</em>, a sufficient condition to achieve the last-round collapsing property is that</p>

    <p class="text-gray-300"><span class="math">x_{i}</span>”contains a SIS-hash of” <span class="math">w_{i}</span>.</p>

    <p class="text-gray-300">Roughly speaking, in our protocol, we have</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}\\otimes\\mathbf{A})\\cdot w_{i}=x_{i}</span></p>

    <p class="text-gray-300">Hence, the above condition is verified, and undetectability of the measurement follows immediately by the LWE assumption, by invoking <em>[x21, x18]</em>.</p>

    <p class="text-gray-300">However, the trouble starts when considering recursive special soundness. The somewhat subtle point here is that the regular notion of special soundness describes an extractor that, given responses for uniformly sampled challenges, is able to recover the witness. Instead, our protocol satisfies the weaker notion of coordinate-wise special soundness, where the extractor is only guaranteed to work if the adversary provides correct answers for challenges sampled from a highly correlated distribution. The specifics of this distributions are irrelevant for the purpose of this discussion, and it suffices to remark that the extractor from <em>[x19]</em> crucially relies on the fact that the queries to the adversary are (close to) independently sampled. As a result, when applied to our protocol, there is no guarantee that the extractor of <em>[x19]</em> succeeds.</p>

    <p class="text-gray-300">We bypass this technical hurdle by combining the rewinding strategy of <em>[x10]</em>, with the techniques introduced by a recent work of Bitansky et al. <em>[x3]</em>. This work introduces a general strategy to translate classical reductions to post-quantum strategies. Relevantly for us, they show a method to simulate a reduction against a stateless adversary, even when the actual adversary can maintain a state across several queries. This allows us to treat the quantum adversary as if they “forgot” about previous queries, and therefore their response is (statistically close to) independent for each individual query. Carefully combining this simulator with (a variant of) the extraction strategy of <em>[x10]</em>, yields the final extractor.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations. We use boldface lower case for row vectors (e.g. <span class="math">\\mathbf{r}</span>) and boldface upper case for matrices (e.g. <span class="math">\\mathbf{R}</span>). For integral vectors and matrices (i.e., those over <span class="math">\\mathbb{Z}</span>), we use the notation $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{r}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to denote the maximum absolute value over all the entries. We use </span>v\\leftarrow D<span class="math"> to denote a random sample from a distribution </span>D<span class="math">, as well as </span>v\\leftarrow S<span class="math"> to denote a uniformly random sample from a set </span>S<span class="math">. We use </span>\\approx_{s}<span class="math"> and </span>\\approx_{c}<span class="math"> as the abbreviation for statistically close and computationally indistinguishable. For integers </span>a\\leq b<span class="math">, we denote </span>[a,b]:=\\{a,a+1,\\ldots,b\\}<span class="math">, and in particular </span>[n]:=[1,n]<span class="math"> for </span>n\\geq 1<span class="math">. Let </span>\\alpha,\\delta,q\\in\\mathbb{Z}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{g}_{\\alpha,q}=(1,\\delta,\\delta^{2},\\ldots,\\delta^{\\alpha-1})\\in\\mathbb{Z}^{\\alpha},</span></p>

    <p class="text-gray-300">where <span class="math">\\alpha=\\log_{\\beta}q</span>. The gadget matrix <span class="math">\\mathbf{G}_{n,\\alpha,q}=\\mathbf{g}_{\\alpha,q}\\otimes\\mathbf{I}_{n}\\in\\mathbb{Z}^{n\\times n\\cdot\\alpha}</span>. For any <span class="math">t\\in\\mathbb{Z}</span>, the function <span class="math">\\mathbf{G}_{n,\\alpha,q}^{-1}:\\mathbb{Z}_{q}^{n\\times t}\\rightarrow\\{0,1\\}^{n\\cdot\\alpha\\times t}</span> expands each entry <span class="math">a\\in\\mathbb{Z}_{q}</span> of the input matrix into a column of size <span class="math">\\alpha</span> consisting of the base-<span class="math">\\delta</span> representation of <span class="math">a</span>. For any matrix <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times t}</span> it holds that <span class="math">\\mathbf{G}_{n,\\alpha,q}\\cdot\\mathbf{G}_{n,\\alpha,q}^{-1}(\\mathbf{A})=\\mathbf{A}\\bmod q</span>. We drop parameters <span class="math">\\alpha</span> and <span class="math">q</span> when they are clear from context.</p>

    <p class="text-gray-300">Properties of Kronecker product. If <span class="math">\\mathbf{A}</span>, <span class="math">\\mathbf{B}</span>, <span class="math">\\mathbf{C}</span>, and <span class="math">\\mathbf{D}</span>, are matrices of such size that one can form the matrix products <span class="math">\\mathbf{A}\\cdot\\mathbf{C}</span>, and <span class="math">\\mathbf{B}\\cdot\\mathbf{D}</span>, then</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{A}\\otimes\\mathbf{B})\\cdot(\\mathbf{C}\\otimes\\mathbf{D})=(\\mathbf{A}\\cdot\\mathbf{C})\\otimes(\\mathbf{B}\\cdot\\mathbf{D}).</span></p>

    <p class="text-gray-300">This is called the mixed-product property because it mixes the ordinary matrix product and the Kronecker product. An easy corollary is the following statement, which is a formalization of the statement “<span class="math">\\mathbf{X}\\otimes\\mathbf{I}</span> and <span class="math">\\mathbf{I}\\otimes\\mathbf{Y}</span> commutes”:</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{X}\\otimes\\mathbf{I}_{t\\text{-}\\mathsf{nrow}(\\mathbf{Y})})\\cdot(\\mathbf{I}_{t\\text{-}\\mathsf{ncol}(\\mathbf{X})}\\otimes\\mathbf{Y})=(\\mathbf{I}_{t\\text{-}\\mathsf{nrow}(\\mathbf{X})}\\otimes\\mathbf{Y})\\cdot(\\mathbf{X}\\otimes\\mathbf{I}_{t\\text{-}\\mathsf{ncol}(\\mathbf{Y})})</span> (11)</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.1 Commitment Scheme</h3>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A (non-interactive) commitment scheme over <span class="math">\\mathcal{M}</span> with slack space <span class="math">\\mathcal{S}</span> is a tuple of polynomial-time probabilistic algorithms <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},d)\\rightarrow\\mathsf{pp}</span>: Sample public parameters given a security parameter <span class="math">\\lambda</span> and message length <span class="math">d</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},f)\\rightarrow(C,\\mathsf{st})</span>: Use the public parameters <span class="math">\\mathsf{pp}</span> to compute a commitment <span class="math">C</span> to a message <span class="math">f\\in\\mathcal{M}</span> and an auxiliary state <span class="math">\\mathsf{st}</span>.</li>

      <li><span class="math">\\mathsf{Open}(\\mathsf{pp},C,f,\\mathsf{st},s)\\rightarrow b</span>: Takes public parameters <span class="math">\\mathsf{pp}</span>, a commitment <span class="math">C</span>, a message <span class="math">f\\in\\mathcal{M}</span>, an auxiliary state <span class="math">\\mathsf{st}</span>, and a relaxation factor <span class="math">s\\in\\mathcal{S}</span> and outputs a bit <span class="math">b</span> indicating whether <span class="math">C</span> is a valid commitment to <span class="math">f</span> under <span class="math">\\mathsf{pp}</span>.</li>

    </ul>

    <p class="text-gray-300">We require commitment schemes to satisfy the following completeness and (relaxed) binding properties.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2 (Completeness).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> satisfies completeness if for all <span class="math">\\lambda,d\\in\\mathbb{N}</span>, and for every <span class="math">f\\in\\mathcal{M}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\Pr\\bigg{[}\\mathsf{Open}(\\mathsf{pp},C,f,\\mathsf{st},\\bot)=1\\ \\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\begin{array}[]{c}\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},d)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(C,\\mathsf{st})\\leftarrow\\mathsf{Commit}(\\mathsf{pp},f)\\end{array}\\bigg{]}\\geq 1-\\mathsf{negl}(\\lambda). \\]</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3 (Relaxed Binding).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> satisfies relaxed binding if for every PPT adversary <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300">\\[ \\Pr\\bigg{[}\\begin{array}[]{c}f\\neq f^{\\prime}\\text{ with }f,f^{\\prime}\\in\\mathcal{M}\\\\ \\wedge\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Open}(\\mathsf{pp},C,f,\\mathsf{st},s)=\\mathsf{Open}(\\mathsf{pp},C,f^{\\prime},\\mathsf{st}^{\\prime},s^{\\prime})\\end{array}\\bigg{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\begin{array}[]{c}\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda},d)\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(C,(f,\\mathsf{st},s),(f^{\\prime},\\mathsf{st}^{\\prime},s^{\\prime}))\\leftarrow\\mathcal{A}(\\mathsf{pp})\\end{array}\\bigg{]}\\leq\\mathsf{negl}(\\lambda). \\]</p>

    <p class="text-gray-300">3.2 Interactive Proofs</p>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{R} \\subseteq \\{0,1\\}^<em> \\times \\{0,1\\}^</em> \\times \\{0,1\\}^*</span> be a ternary relation. If <span class="math">(\\mathsf{pp}, x, w) \\in \\mathfrak{R}</span>, we say that <span class="math">\\mathsf{pp}</span> are the public parameters, <span class="math">x</span> is a statement and <span class="math">w</span> is a witness for <span class="math">x</span>. For fixed <span class="math">\\mathsf{pp}</span> and <span class="math">x</span>, we define the set <span class="math">\\Re(\\mathsf{pp}, x) := \\{w : (\\mathsf{pp}, x, w) \\in \\Re\\}</span>.</p>

    <p class="text-gray-300"><strong>Definition 4 (Interactive Proof System).</strong> Let <span class="math">\\ell \\geq 0</span> be an integer. A <span class="math">(2\\ell + 1)</span>-message public-coin argument system <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> for a relation <span class="math">\\Re</span> consists of a PPT algorithm <span class="math">\\mathsf{Setup}</span> and a <span class="math">(2\\ell + 1)</span>-message protocol between an interactive PPT prover <span class="math">\\mathcal{P}</span> and an interactive PPT verifier <span class="math">\\mathcal{V}</span>, is associated to a tuple of spaces <span class="math">(X, W, (Z_{i-1}, C_i)_{i \\in [\\ell]}, Z_\\ell)</span>, and has the following structural properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <span class="math">\\mathsf{Setup}</span> algorithm takes as input the security parameter <span class="math">1^{\\lambda}</span> and outputs some public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li>Both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> receive as input the public parameters <span class="math">\\mathsf{pp}</span> and a statement <span class="math">x_0 = x \\in X</span>. The prover <span class="math">\\mathcal{P}</span> additionally receives a witness <span class="math">w_0 = w \\in W</span>.</li>

      <li>The public parameters, the statement <span class="math">x_0</span>, and the <span class="math">2\\ell + 1</span> messages sent by <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> in the protocol, called collectively a transcript is labelled by</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pp}, x_0, z_0, c_1, \\dots, z_{\\ell-1}, c_\\ell, z_\\ell),</span></div>

    <p class="text-gray-300">where <span class="math">z_i \\in Z_i</span> is sent by <span class="math">\\mathcal{P}</span>, and <span class="math">c_i \\in C_i</span> is sent by <span class="math">\\mathcal{V}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenges <span class="math">c_i</span> are sampled by <span class="math">\\mathcal{V}</span> uniformly randomly from <span class="math">C_i</span>.</li>

    </ul>

    <p class="text-gray-300">A transcript <span class="math">(\\mathsf{pp}, x_0, z_0, c_1, \\ldots, z_{\\ell-1}, c_\\ell, z_\\ell)</span> is said to be accepting for <span class="math">\\Pi</span> if it holds that <span class="math">\\mathcal{V}(\\mathsf{pp}, x_0, z_0, c_1, \\ldots, z_{\\ell-1}, c_\\ell, z_\\ell) = 1</span>.</p>

    <p class="text-gray-300">We recall a few basic properties of interactive proof systems: completeness and knowledge soundness.</p>

    <p class="text-gray-300"><strong>Definition 5 (Completeness).</strong> A proof system <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> for the relation <span class="math">\\Re</span> has statistical completeness with correctness error <span class="math">\\epsilon</span> if for all adversaries <span class="math">\\mathcal{A}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 0 \\wedge (\\mathsf{pp}, x, w) \\in \\Re \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda}) \\\\ (x, w) \\leftarrow \\mathcal{A}(\\mathsf{pp}) \\\\ (\\mathsf{tr}, b) \\leftarrow \\langle \\mathcal{P}(\\mathsf{pp}, x, w), \\mathcal{V}(\\mathsf{pp}, x) \\rangle \\end{array} \\right] \\leq \\epsilon(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Furthermore, we say that <span class="math">\\Pi</span> satisfies perfect completeness if <span class="math">\\epsilon = 0</span>.</p>

    <p class="text-gray-300"><strong>Definition 6 (Knowledge Soundness).</strong> A proof system <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> is knowledge sound with knowledge error <span class="math">\\kappa</span> for the relation <span class="math">\\Re^<em></span> if there exists an expected PPT extractor <span class="math">\\mathcal{E}</span> such that for any stateful PPT adversary <span class="math">\\mathcal{P}^</em></span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b = 1 \\wedge (\\mathsf{pp}, x, w) \\notin \\Re^* \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{Setup}(1^{\\lambda}) \\\\ (x, \\mathsf{st}) \\leftarrow \\mathcal{P}^<em>(\\mathsf{pp}) \\\\ (\\mathsf{tr}, b) \\leftarrow \\langle \\mathcal{P}^</em>(\\mathsf{pp}, x, \\mathsf{st}), \\mathcal{V}(\\mathsf{pp}, x) \\rangle \\\\ w \\leftarrow \\mathcal{E}_{\\mathcal{P}^*}(\\mathsf{pp}, x) \\end{array} \\right] \\leq \\kappa(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Here, the extractor <span class="math">\\mathcal{E}</span> has a black-box oracle access to the (malicious) prover <span class="math">\\mathcal{P}^*</span> and can rewind it to any point in the interaction.</p>

    <p class="text-gray-300">An additional property that one might require is that the proof system is "friendly to recursive composition". We formalize such a property in the following definition, which is inspired by the notion of reduction of knowledge, recently introduced by Kothapalli and Parno [KP23].</p>

    <p class="text-gray-300"><strong>Definition 7 (Recursive-Friendly Proof System).</strong> A <span class="math">(2\\ell + 1)</span>-message public-coin argument system <span class="math">\\Pi = (\\mathsf{Setup}, \\mathcal{P}, \\mathcal{V})</span> for a relation <span class="math">\\Re</span> is said to be recursive friendly if for all <span class="math">i \\in [0, \\ell-1]</span> there exists associated relation <span class="math">\\Re_{\\ell-i}</span>, and deterministic algorithms <span class="math">\\mathsf{P}_i, \\mathsf{V}_i, \\mathsf{NextW}_i</span>, and <span class="math">\\mathsf{NextX}_i</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Re_{\\ell} = \\Re</span>,</li>

      <li><span class="math">\\mathsf{P}_i(\\mathsf{pp}, x_i, w_i) \\to z_i</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, and statement-witness pair <span class="math">(x_i, w_i)</span>. It returns <span class="math">z_i</span>, i.e., the <span class="math">i</span>-th prover's message.</li>

      <li><span class="math">\\mathsf{V}_i(\\mathsf{pp}, x_i, z_i) \\to b_i</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, statement <span class="math">x_i</span>, and message <span class="math">z_i</span>. It returns a bit <span class="math">b_i</span>.</li>

    </ul>

    <p class="text-gray-300">12</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{NextW}_{i}(\\mathsf{pp},x_{i},w_{i},c_{i+1})\\to w_{i+1}</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, statement-witness pair <span class="math">(x_{i},w_{i})</span> and challenge <span class="math">c_{i+1}</span>. It produces a new witness <span class="math">w_{i+1}</span> associated with <span class="math">\\mathfrak{R}_{\\ell-i-1}</span>.</li>

      <li><span class="math">\\mathsf{NextX}_{i}(\\mathsf{pp},x_{i},z_{i},c_{i+1})\\to x_{i+1}</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, statement <span class="math">x_{i}</span>, prover’s message <span class="math">z_{i}</span>, and challenge <span class="math">c_{i+1}</span>. It produces a new statement <span class="math">x_{i+1}</span> associated with <span class="math">\\mathfrak{R}_{\\ell-i-1}</span>.</li>

      <li>The last prover’s message corresponds to the reduced witness associate to <span class="math">\\mathfrak{R}_{0}</span>, i.e., <span class="math">z_{\\ell}\\coloneqq w_{\\ell}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> accepts if <span class="math">b_{0},\\ldots,b_{\\ell-1}=1</span> and <span class="math">(\\mathsf{pp},x_{\\ell},w_{\\ell})\\in\\mathfrak{R}_{0}</span>.</li>

    </ul>

    <p class="text-gray-300">A recursive-friendly argument system for <span class="math">\\mathfrak{R}</span> is said to be round-by-round complete for the tuple of relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[0,\\ell]}</span> if for all <span class="math">i\\in[0,\\ell-1]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b_{i}=1</span> whenever <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathfrak{R}_{\\ell-i}</span>,</li>

      <li><span class="math">(\\mathsf{pp},x_{i+1},w_{i+1})\\in\\mathfrak{R}_{\\ell-i-1}</span> whenever <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathfrak{R}_{\\ell-i}</span>.</li>

    </ul>

    <p class="text-gray-300">It is easy to show that round-by-round completeness implies (standard) completeness of the proof system.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell+1)</span>-message public-coin recursive friendly argument system for a relation <span class="math">\\mathfrak{R}</span> with associated relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[0,\\ell]}</span>. If <span class="math">\\Pi</span> is round-by-round for the tuple of relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[0,\\ell]}</span>, then <span class="math">\\Pi</span> is complete for the relation <span class="math">\\mathfrak{R}</span>.</p>

    <p class="text-gray-300">A formal proof of Theorem 1 can be found in Appendix C.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.3 Polynomial Commitment Scheme</h3>

    <p class="text-gray-300">Polynomial commitment schemes extend commitments with the ability to prove evaluations of the committed function.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PC}=(\\mathsf{Setup}_{\\mathsf{CM}},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Setup}_{\\mathsf{IP}},\\mathcal{P},\\mathcal{V})</span> be a tuple of algorithms. <span class="math">\\mathsf{PC}</span> is a functional commitment scheme for function class <span class="math">\\mathcal{F}</span> with slack space <span class="math">\\mathcal{S}</span> if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{Setup}_{\\mathsf{CM}},\\mathsf{Commit},\\mathsf{Open})</span> is a commitment scheme over the function class</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{M}\\coloneqq\\mathcal{F}</span></p>

    <p class="text-gray-300">with slack space <span class="math">\\mathcal{S}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{Setup}_{\\mathsf{IP}},\\mathcal{P},\\mathcal{V})</span> is a proof system (Definition 4) for the relation</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},(\\mathsf{pp}_{\\mathsf{CM}},C,\\mathbf{x},\\mathbf{u}),(f,\\mathsf{st}))\\in\\mathfrak{R}\\quad\\Longleftrightarrow\\quad\\mathsf{Open}(\\mathsf{pp}_{\\mathsf{CM}},C,f,\\mathsf{st},\\bot)=1\\wedge f(\\mathbf{x})=\\mathbf{u}</span></p>

    <p class="text-gray-300">The class of function <span class="math">\\mathcal{F}</span>, supported by a polynomial commitment scheme will be a set of polynomials. See Section 6 for the classes of polynomials that we consider. We say that the polynomial commitment scheme satisfies the evaluation completeness and knowledge soundness properties if <span class="math">(\\mathsf{Setup}_{\\mathsf{IP}},\\mathcal{P},\\mathcal{V})</span> is complete and knowledge sound respectively.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.4 Coordinate-Wise Special Soundness</h3>

    <p class="text-gray-300">We recall the notion of coordinate-wise special soundness from <em>[x10]</em>. Let <span class="math">S</span> be a finite set and <span class="math">\\xi\\in\\mathbb{N}</span> denote the number of coordinates. First, take two vectors <span class="math">\\mathbf{x}\\coloneqq(x_{1},\\ldots,x_{\\xi}),\\mathbf{y}\\coloneqq(y_{1},\\ldots,y_{\\xi})\\in S^{\\xi}</span>. Then, we define the following relation "<span class="math">\\equiv_{i}</span>" for fixed <span class="math">i\\in[\\xi]</span> as:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{x}\\equiv_{i}\\mathbf{y}\\iff x_{i}\\neq y_{i}\\wedge\\forall j\\in[\\xi]\\backslash\\{i\\},x_{j}=y_{j}\\enspace.</span></p>

    <p class="text-gray-300">In other words, vectors <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y}</span> have the same entries in all coordinates apart from the <span class="math">i</span>-th one. For <span class="math">\\xi=1</span>, the relations boil down to checking whether two elements are distinct. Next, we define the set</p>

    <p class="text-gray-300"><span class="math">\\Gamma(S,\\xi)\\coloneqq\\big{\\{}(\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{\\xi+1})\\in(S^{\\xi})^{\\xi+1}:\\exists k\\in[\\xi+1],\\forall i\\in[\\xi],\\exists j\\in[\\xi+1]\\backslash\\{k\\},\\mathbf{x}_{k}\\equiv_{i}\\mathbf{x}_{j}\\big{\\}}</span></p>

    <p class="text-gray-300">Now, we can define (round-by-round) coordinate-wise special soundness for recursive-friendly proof system, adapting the definition from <em>[x10]</em>.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 9 (Round-by-Round Coordinate-Wise Special Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell+1)</span>-message public-coin recursive friendly argument system for relation <span class="math">\\mathfrak{R}</span>. The protocol <span class="math">\\Pi</span> is said to be round-by-round <span class="math">\\xi</span>-coordinate-wise special sound for relations <span class="math">(\\mathfrak{R}_{\\ell-i}^{<em>})_{i\\in[0,\\ell]}</span> if the challenge space equals <span class="math">S^{\\xi}</span> and for any <span class="math">i\\in[0,\\ell-1]</span> there exists an extractor <span class="math">\\mathsf{Ext}_{i}</span> that given as input <span class="math">(\\mathsf{pp},x_{i})</span> and <span class="math">(\\xi+1)</span> transcripts <span class="math">(z_{i},c_{i+1}^{(k)})</span>, where the challenges together lie in <span class="math">\\Gamma(S,\\xi)</span> and such that <span class="math">b_{i}=1</span>, where <span class="math">b_{i}\\leftarrow\\mathsf{V}_{i}(\\mathsf{pp},x_{i},z_{i})</span>, together with <span class="math">w_{i+1}^{(k)}</span> such that <span class="math">\\left(\\mathsf{pp},\\mathsf{NextX}_{i}(\\mathsf{pp},x_{i},(z_{i},c_{i+1}^{(k)})),w_{i+1}^{(k)}\\right)\\in\\mathfrak{R}_{\\ell-i-1}^{</em>}</span>, returns <span class="math">w_{i}</span> such that <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathfrak{R}_{\\ell-i}^{*}</span>.</p>

    <p class="text-gray-300">It is easy to show that round-by-round coordinate-wise special soundness implies implies coordinate-wise special soundness as defined in <em>[x10, Definition 2.30]</em>. Furthermore, it was shown in <em>[x10, Lemma 2.31]</em> that coordinate-wise special soundness implies knowledge soundness in the interactive setting, against a classical adversary. Putting everything together, we obtain the following result.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell+1)</span>-message public-coin recursive friendly argument system for a relation <span class="math">\\mathfrak{R}</span> with associated relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[0,\\ell]}</span>. If <span class="math">\\Pi</span> is round-by-round <span class="math">\\xi</span>-coordinate-wise special sound for the tuple of relations <span class="math">(\\mathfrak{R}_{\\ell-i}^{<em>})_{i\\in[0,\\ell]}</span> and <span class="math">(\\xi+1)^{\\ell}=\\mathsf{poly}(\\lambda)</span>, then <span class="math">\\Pi</span> is knowledge sound for the relation <span class="math">\\mathfrak{R}_{\\ell}^{</em>}</span> with knowledge error $\\ell\\xi/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A formal proof of Theorem 2 can be found in Appendix C.</p>

    <p class="text-gray-300">We skip writing <span class="math">\\xi</span> when it is clear from the context. Also, the definition can be easily extended to support different arities <span class="math">\\xi_{1},\\ldots,\\xi_{\\ell}</span>.</p>

    <p class="text-gray-300">Next, we show a technical lemma which uses the coordinate-wise property defined above.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Let <span class="math">\\xi\\geq 1</span>. Given <span class="math">\\mathbf{C}_{0},\\mathbf{C}_{1},\\ldots,\\mathbf{C}_{\\xi}\\in\\Gamma(\\{0,1\\}^{h},\\xi)</span>, i.e., satisfying the coordinate-wise property, we can compute a matrix <span class="math">\\mathbf{H}\\in\\{0,\\pm 1\\}^{h(\\xi+1)\\times\\xi}</span> such that:</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{C}_{0}\\mid\\mathbf{C}_{1}\\mid\\cdots\\mid\\mathbf{C}_{\\xi}]\\cdot\\mathbf{H}=\\mathbf{I}_{\\xi}</span></p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{e}_{i}</span> denote the <span class="math">i</span>-th unit vector in <span class="math">\\mathbb{Z}^{h(\\xi+1)}</span>. Without loss of generality, we can assume <span class="math">\\mathbf{C}_{0}</span> and <span class="math">\\mathbf{C}_{i}</span> only differ in the <span class="math">k</span>-th row. Therefore, the only non-zero row of <span class="math">\\bar{\\mathbf{C}}_{i}\\coloneqq\\mathbf{C}_{0}-\\mathbf{C}_{k}</span> is the <span class="math">k</span>-th one. Moreover, since both <span class="math">\\mathbf{C}_{0}</span> and <span class="math">\\mathbf{C}_{k}</span> are binary matrices, <span class="math">\\bar{\\mathbf{C}}_{k}\\in\\{0,\\pm 1\\}^{\\xi\\times h}</span>. Let <span class="math">s_{k}\\in[h]</span> be such that <span class="math">\\bar{\\mathbf{C}}_{k}[k,s_{k}]\\neq 0</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{h}_{k}\\coloneqq\\bar{\\mathbf{C}}_{k}[k,s_{k}]\\cdot(\\mathbf{e}_{s_{k}}-\\mathbf{e}_{s_{k}+kh})\\in\\mathbb{Z}^{h(\\xi+1)}.</span></p>

    <p class="text-gray-300">Therefore, by defining</p>

    <p class="text-gray-300"><span class="math">\\mathbf{H}\\coloneqq[\\mathbf{h}_{1}\\mid\\ldots\\mid\\mathbf{h}_{\\xi}]\\in\\mathbb{Z}^{h(\\xi+1)\\times\\xi},</span></p>

    <p class="text-gray-300">we obtain that</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{C}_{0}\\mid\\mathbf{C}_{1}\\mid\\cdots\\mid\\mathbf{C}_{\\xi}]\\cdot\\mathbf{H}=\\mathbf{I}_{\\xi}.</span></p>

    <p class="text-gray-300">as claimed. This concludes the proof. ∎</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 Basic Commitment Scheme</h2>

    <p class="text-gray-300">Let <span class="math">\\mathsf{CM}=(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{Open})</span> be a tuple of algorithms defined as follows</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda},L=r^{\\ell+1}\\kappa n\\tau)</span> : Let <span class="math">r,\\kappa,n,\\tau,\\ell,\\alpha\\in\\mathbb{N}</span>. Sample <span class="math">\\mathbf{A}\\leftarrow\\mathbb{Z}_{q}^{n\\times rn\\alpha}</span>. Set <span class="math">\\mathsf{pp}=\\{\\mathbf{A}\\}</span>, and return <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp},\\mathbf{f}\\in\\mathbb{Z}_{q}^{r^{\\ell+1}\\kappa n\\tau})</span>: Compute</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{t}=(\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{G}_{r\\kappa n\\tau}^{-1}\\left((\\mathbf{I}_{r\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{G}_{r^{2}\\kappa n\\tau}^{-1}\\Big{(}\\cdots\\mathbf{G}_{r^{\\ell}\\kappa n\\tau}^{-1}\\big{(}(\\mathbf{I}_{r^{\\ell}\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{G}_{r^{\\ell+1}\\kappa n\\tau}^{-1}(\\mathbf{f})\\big{)}\\Big{)}\\right)\\in\\mathbb{Z}_{q}^{\\kappa n\\tau}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{s}_{j}\\coloneqq\\mathbf{G}_{r^{j+1}\\kappa n\\tau}^{-1}\\Bigg{(}(\\mathbf{I}_{r^{j+1}\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{G}_{r^{j+2}\\kappa n\\tau}^{-1}\\Big{(}\\cdots\\mathbf{G}_{r^{\\ell}\\kappa n\\tau}^{-1}\\big{(}(\\mathbf{I}_{r^{\\ell}\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{G}_{r^{\\ell+1}\\kappa n\\tau}^{-1}(\\mathbf{f})\\big{)}\\Big{)}\\Bigg{)}\\in\\mathbb{Z}^{r^{j+1}\\kappa n\\tau\\alpha}</span></p>

    <p class="text-gray-300">for <span class="math">j\\in[0,\\ell]</span>. Set <span class="math">\\mathsf{st}=(\\mathbf{s}_{j})_{j\\in[0,\\ell]}</span> and return <span class="math">(\\mathbf{t},\\mathsf{st})</span>.</p>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Explanation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λ</td>

            <td class="px-3 py-2 border-b border-gray-700">security parameter</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">modulus</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">bound on the dimension of the committed vector</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">height of the matrix A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">"folding" factor</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α</td>

            <td class="px-3 py-2 border-b border-gray-700">width of the vector gT</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">statistical parameter</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">number of nested G-1(·)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">δ</td>

            <td class="px-3 py-2 border-b border-gray-700">bound on norm of G's preimages</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">bound check on norm of opening</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Summary of parameters and notation used in Sections 4 and 5 and Appendix A</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Open  <span class="math">(\\mathsf{pp},\\mathbf{t},\\mathbf{f},\\mathsf{st},\\bot)</span> : Parse  <span class="math">\\mathsf{st} = (\\mathbf{s}_j)_{j\\in [0,\\ell ]}</span> . Return 1 if and only if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left(\\mathbf{I}_{\\kappa \\tau}\\otimes \\mathbf{A}\\right)\\cdot \\mathbf{s}_0 = \\mathbf{t}\\bmod q,</span> <span class="math">\\mathbf{G}_{r^{j + 1}\\kappa n\\tau}\\cdot \\mathbf{s}_j = (\\mathbf{I}_{r^{j + 1}\\kappa n\\tau}\\otimes \\mathbf{A})\\cdot \\mathbf{s}_{j + 1}</span>  for all  <span class="math">j\\in [0,\\ell -1]</span> <span class="math">\\mathbf{G}_{r^{\\ell +1}\\kappa n\\tau}\\cdot \\mathbf{s}_{\\ell} = \\mathbf{f}\\bmod q,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">  for all  </span>j\\in [0,\\ell ]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we show that the basic commitment scheme satisfies completeness and binding.</p>

    <p class="text-gray-300">Theorem 3 (Completeness). The commitment scheme CM, with  <span class="math">\\beta \\geq \\delta</span> , is complete.</p>

    <p class="text-gray-300">Proof. This follows trivially from the definition of  <span class="math">\\mathbf{G}^{-1}(\\cdot)</span> .</p>

    <p class="text-gray-300">Theorem 4 (Binding). The commitment scheme CM is binding assuming  <span class="math">\\mathsf{SIS}_{n,rn\\alpha,q,\\beta&#x27;}</span>  with  <span class="math">\\beta&#x27; \\geq 2\\beta</span> .</p>

    <p class="text-gray-300">A formal proof of Theorem 4 can be found in Appendix D.</p>

    <p class="text-gray-300">In this section, we construct a simple and asymptotically efficient protocol for proving that  <span class="math">\\mathbf{f} \\in \\mathbb{Z}_q^{r^{\\ell + 1}\\kappa n\\tau}</span>  is such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {\\kappa n} \\otimes \\mathbf {X} _ {\\ell}\\right) \\cdot \\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {X} _ {\\ell - 1}\\right) \\dots \\left(\\mathbf {I} _ {r ^ {\\ell} \\kappa n} \\otimes \\mathbf {X} _ {0}\\right) \\cdot \\mathbf {f} = \\mathbf {u} \\bmod q</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{X}_j\\in \\mathbb{Z}_q^{\\tau \\times r\\tau}</span>  and  <span class="math">\\mathbf{u}\\in \\mathbb{Z}_q^{\\kappa n\\tau}</span> . In order to do so, consider the following relation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R _ {\\ell , \\beta_ {\\ell}} := \\left\\{\\left( \\begin{array}{c} \\mathsf {p p} := (q, n, \\alpha , \\tau , \\kappa , r), \\\\ (\\mathbf {A}, \\mathbf {t}, (\\mathbf {X} _ {j}) _ {j \\in [ 0, \\ell ]}, \\mathbf {u}), \\\\ ((\\mathbf {s} _ {j}) _ {j \\in [ 0, \\ell ]}, \\mathbf {f}) \\end{array} \\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\forall j \\in [ 0, \\ell ], \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {j} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {\\ell}, \\\\ \\forall j \\in [ 0, \\ell - 1 ], \\mathbf {G} _ {r ^ {\\ell + 1} \\kappa n \\tau} \\cdot \\mathbf {s} _ {j} = (\\mathbf {I} _ {r ^ {\\ell + 1} \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\mathbf {s} _ {j + 1}, \\\\ (\\mathbf {I} _ {\\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\mathbf {s} _ {0} = \\mathbf {t}, \\mathbf {G} _ {r ^ {\\ell + 1} \\kappa n \\tau} \\cdot \\mathbf {s} _ {\\ell} = \\mathbf {f}, \\\\ \\prod_ {j = 0} ^ {\\ell} (\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - j}) \\cdot \\mathbf {f} = \\mathbf {u} \\end{array} \\right. \\right\\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where instance  <span class="math">x</span>  and witness  <span class="math">w</span>  are respectively</p>

    <div class="my-4 text-center"><span class="math-block">x = x _ {0} := \\left(\\mathbf {A} \\in \\mathbb {Z} _ {q} ^ {n \\times r n \\alpha}, \\mathbf {t} \\in \\mathbb {Z} _ {q} ^ {\\kappa n \\tau}, \\left(\\mathbf {X} _ {j} \\in \\mathbb {Z} _ {q} ^ {\\tau \\times r \\tau}\\right) _ {j \\in [ 0, \\ell ]}, \\mathbf {u} \\in \\mathbb {Z} _ {q} ^ {\\kappa n \\tau}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">w = w _ {0} := \\left(\\left(\\mathbf {s} _ {j} \\in \\mathbb {Z} ^ {r ^ {j + 1} \\kappa n \\tau \\alpha}\\right) _ {j \\in [ 0, \\ell ]}, \\mathbf {f} \\in \\mathbb {Z} _ {q} ^ {r ^ {\\ell + 1} \\kappa n \\tau}\\right)</span></div>

    <p class="text-gray-300">Notice that the witness corresponds to the output of the opening algorithm Open of the commitment scheme from Section 4. In Section 5.1 we construct a recursive-friendly proof system  <span class="math">\\varPi</span>  (see Fig. 6) for the relation  <span class="math">\\mathsf{R}_{\\ell, \\beta}</span> , and in Section 5.2 deduce completeness and knowledge soundness of  <span class="math">\\varPi</span> .</p>

    <p class="text-gray-300">5.1 Building Block and Construction</p>

    <p class="text-gray-300">Recall that a recursive-friendly <span class="math">(2\\ell+1)</span>-message argument system for relation <span class="math">\\mathsf{R}=\\mathsf{R}_{\\ell,\\beta_{\\ell}}</span> is described by a tuple of relations <span class="math">\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span> and deterministic algorithms <span class="math">\\mathsf{P}_{i},\\mathsf{V}_{i},\\mathsf{NextX}_{i},\\mathsf{NextW}_{i}</span>, for <span class="math">i\\in[0,\\ell-1]</span>, that allow to reduce the task of checking that an instance <span class="math">(x_{i},w_{i})\\in\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span> to that checking that <span class="math">(x_{i+1},w_{i+1})\\in\\mathsf{R}_{\\ell-i-1,\\beta_{\\ell-i-1}}</span>. For <span class="math">i\\in[0,\\ell]</span>, let <span class="math">\\beta_{\\ell-i-1}=(r\\kappa)^{i}\\beta</span> . We start by describing algorithms <span class="math">\\mathsf{P}_{i},\\mathsf{V}_{i},\\mathsf{NextX}_{i}</span>, and <span class="math">\\mathsf{NextW}_{i}</span>, for <span class="math">i\\in[0,\\ell-1]</span>.</p>

    <p class="text-gray-300">Reducing <span class="math">\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span> to <span class="math">\\mathsf{R}_{\\ell-i-1,\\beta_{\\ell-i-1}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let</li>

    </ul>

    <p class="text-gray-300"><span class="math">x_{i}=\\left(\\mathbf{A},\\mathbf{t}^{(i)},(\\mathbf{X}_{j})_{j\\in[0,\\ell-i]},\\mathbf{u}^{(i)}\\right)</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">w_{i}=\\left((\\mathbf{s}^{(i)}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{f}^{(i)}\\right)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{P}_{i}</span>, on input <span class="math">\\mathsf{pp},x_{i},w_{i}</span>, returns <span class="math">z_{i}=(\\mathbf{y}_{i},\\mathbf{v}_{i})</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{y}_{i}</span> <span class="math">\\coloneqq\\mathbf{s}^{(i)}_{0}\\in\\mathcal{R}_{q}^{r\\kappa n\\tau\\alpha}</span> <span class="math">\\mathbf{v}_{i}</span> <span class="math">\\coloneqq(\\mathbf{I}_{r\\kappa n}\\otimes\\mathbf{X}_{\\ell-i-1})\\cdots(\\mathbf{I}_{r^{\\ell-i}\\kappa n}\\otimes\\mathbf{X}_{0})\\cdot\\mathbf{f}^{(i)}\\in\\mathbb{Z}_{q}^{r\\kappa n\\tau}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}_{i}</span> on input <span class="math">\\mathsf{pp},x_{i},z_{i}</span>, sets <span class="math">b_{i}=1</span> if the following checks pass</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{y}_{i}</span> <span class="math">\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{t}^{(i)}\\bmod q</span> <span class="math">\\bigwedge</span> $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel{{\\scriptstyle?}}{{\\leq}}\\beta_{\\ell-i},$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{\\kappa n}\\otimes\\mathbf{X}_{\\ell-i})\\cdot\\mathbf{v}_{i}</span> <span class="math">\\stackrel{{\\scriptstyle?}}{{=}}\\mathbf{u}^{(i)}\\bmod q.</span></p>

    <p class="text-gray-300">Else, it sets <span class="math">b_{i}=0</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A uniformly random challenge <span class="math">c_{i+1}=\\mathbf{C}_{i+1}\\in\\{0,1\\}^{r\\kappa\\times\\kappa}</span> is sampled.</li>

      <li><span class="math">\\mathsf{NextX}_{i}</span>, on input <span class="math">\\mathsf{pp},x_{i},z_{i},c_{i+1}</span>, sets</li>

    </ul>

    <p class="text-gray-300"><span class="math">x_{i+1}\\coloneqq\\left(\\mathbf{A},\\mathbf{t}^{(i+1)},(\\mathbf{X}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{u}^{(i+1)}\\right)</span> (13)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathbf{t}^{(i+1)}\\coloneqq(\\mathbf{C}_{i+1}^{\\top}\\otimes\\mathbf{I}_{n\\tau})\\cdot\\mathbf{G}_{r\\kappa n\\tau}\\cdot\\mathbf{y}_{i},</span> <span class="math">\\mathbf{u}^{(i+1)}\\coloneqq(\\mathbf{C}_{i+1}^{\\top}\\otimes\\mathbf{I}_{n\\tau})\\cdot\\mathbf{v}_{i}.</span> (14)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{NextW}_{i}</span>, on input <span class="math">(\\mathsf{pp},x_{i},w_{i},c_{i+1})</span> sets</li>

    </ul>

    <p class="text-gray-300"><span class="math">w_{i+1}\\coloneqq\\left((\\mathbf{s}^{(i+1)}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{f}^{(i+1)}\\right)</span> (15)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">\\mathbf{s}^{(i+1)}_{j}</span> <span class="math">\\coloneqq(\\mathbf{C}_{i+1}^{\\top}\\otimes\\mathbf{I}_{r^{j+1}n\\tau\\alpha})\\cdot\\mathbf{s}^{(i)}_{j+1}\\in\\mathbb{Z}^{r^{j+1}\\kappa n\\tau\\alpha}\\quad\\text{for }j\\in[0,\\ell-i-1]</span> (16) <span class="math">\\mathbf{f}^{(i+1)}\\coloneqq(\\mathbf{C}_{i+1}^{\\top}\\otimes\\mathbf{I}_{r^{\\ell-i}n\\tau})\\cdot\\mathbf{f}^{(i)}\\in\\mathbb{Z}_{q}^{r^{\\ell-i}\\kappa n\\tau}</span></p>

    <p class="text-gray-300">The overall protocol <span class="math">\\Pi</span> is described in Figure 6: the initial statement and witness are parsed as</p>

    <p class="text-gray-300"><span class="math">x</span> <span class="math">=x_{0}=\\left(\\mathbf{A},\\mathbf{t},(\\mathbf{X}_{j})_{j\\in[0,\\ell]},\\mathbf{u}\\right)=\\left(\\mathbf{A},\\mathbf{t}^{(0)},(\\mathbf{X}_{j})_{j\\in[0,\\ell]},\\mathbf{u}^{(0)}\\right),</span> <span class="math">w</span> <span class="math">=w_{0}=\\left((\\mathbf{s}_{j})_{j\\in[0,\\ell]},\\mathbf{f}\\right)=\\left((\\mathbf{s}^{(0)}_{j})_{j\\in[0,\\ell]},\\mathbf{f}^{(0)}\\right).</span></p>

    <p class="text-gray-300">In Section 5.2, we will show that <span class="math">\\Pi</span> is round-by-round complete (Lemma 2) and round-by-round coordinate-wise special sound (Lemma 3). These results imply, by Theorem 1 and 2, that <span class="math">\\Pi</span> is complete and knowledge sound.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 6. The top part describes the interface of a generic recursive-friendly proof system, the middle part recalls statement, witness, and relation used in the  <span class="math">i</span> -th round of the interaction, and the bottom part describes the instatiation of the generic algorithms in our proof system  <span class="math">\\varPi</span> . The messages  <span class="math">(z_{i},c_{i + 1}) = ((\\mathbf{y}_{i},\\mathbf{v}_{i}),\\mathbf{C}_{i + 1})</span>  correspond to reducing  <span class="math">\\mathsf{R}_{\\ell -i,\\beta_{\\ell -i}}</span>  to  <span class="math">\\mathsf{R}_{\\ell -i - 1,\\beta_{\\ell -i - 1}}</span> , and the message  <span class="math">w_{\\ell} = (\\mathbf{y}_{\\ell},\\mathbf{v}_{\\ell})</span>  corresponds to the witness for  <span class="math">\\mathsf{R}_{0,\\beta_0}</span> . The challenge space is  <span class="math">\\{0,1\\}^{r\\kappa \\times \\kappa}</span> .</p>

    <p class="text-gray-300">5.2 Completeness and Security Analysis</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Lemma 2 (Round-by-Round Completeness).</h6>

    <p class="text-gray-300">The recursive-friendly proof system <span class="math">\\Pi</span> is round-by-round complete for the tuple of relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[0,\\ell]}=(\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}})_{i\\in[0,\\ell]}</span>, where <span class="math">\\beta_{\\ell-i}=(r\\kappa)^{i}\\beta</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{pp}=(q,n,\\alpha,\\tau,\\kappa,r)</span> and <span class="math">i\\in[0,\\ell-1]</span>. We need to show that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b_{i}=1</span> whenever <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span>,</li>

      <li><span class="math">(\\mathsf{pp},x_{i+1},w_{i+1})\\in\\mathsf{R}_{\\ell-i-1}</span> whenever <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span>.</li>

    </ol>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">x_{i}</span> <span class="math">=\\Big{(}\\mathbf{A},\\mathbf{t}^{(i)},(\\mathbf{X}_{j})_{j\\in[0,\\ell-i]},\\mathbf{u}^{(i)}\\Big{)}</span> <span class="math">w_{i}</span> <span class="math">=\\Big{(}(\\mathbf{s}^{(i)}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{f}^{(i)}\\Big{)}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">x_{i+1}</span> <span class="math">=\\Big{(}\\mathbf{A},\\mathbf{t}^{(i+1)},(\\mathbf{X}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{u}^{(i+1)}\\Big{)}</span> <span class="math">w_{i+1}</span> <span class="math">=\\Big{(}(\\mathbf{s}^{(i+1)}_{j})_{j\\in[0,\\ell-i-1]},\\mathbf{f}^{(i+1)}\\Big{)}</span></p>

    <p class="text-gray-300">computed as in Section 5.1.</p>

    <p class="text-gray-300">Since <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathsf{R}_{\\ell-i,\\beta_{\\ell-i}}</span>, in particular one has that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\overbrace{\\mathbf{s}^{(i)}_{0}}^{\\mathbf{y}_{i}}=\\mathbf{t}^{(i)},\\qquad\\overbrace{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}^{(i)}_{0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{\\mathbf{y}_{i}}\\leq\\beta_{\\ell-i},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{\\kappa n}\\otimes\\mathbf{X}_{\\ell-i})\\cdot\\overbrace{\\prod_{j=1}^{\\ell-i}(\\mathbf{I}_{r^{j}\\kappa n}\\otimes\\mathbf{X}_{\\ell-i-j})\\cdot\\mathbf{f}^{(i)}}^{\\mathbf{y}_{i}}=\\prod_{j=0}^{\\ell-i}(\\mathbf{I}_{r^{j}\\kappa n}\\otimes\\mathbf{X}_{\\ell-i-j})\\cdot\\mathbf{f}^{(i)}=\\mathbf{u}^{(i)}.</span></p>

    <p class="text-gray-300">Therefore, the constraints checked by <span class="math">\\mathsf{V}_{i}</span> in Eq. (12) are all satisfied and <span class="math">b_{i}=1</span>. Next, let us consider the relation <span class="math">\\mathsf{R}_{\\ell-i-1,\\beta_{\\ell-i-1}}</span> and verify that indeed <span class="math">(x_{i+1},w_{i+1})\\in\\mathsf{R}_{\\ell-i-1,\\beta_{\\ell-i-1}}</span>. We need to verify that the following constraints hold</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathsf{R}_{\\ell-i-1,\\beta_{\\ell-i-1}}:\\left\\{\\begin{array}[]{c}\\forall j\\in[0,\\ell-i-1],\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}^{(i+1)}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta_{\\ell-i-1},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\forall j\\in[0,\\ell-i-2],\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}^{(i+1)}_{j}=(\\mathbf{I}_{r^{j+1}\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i+1)}_{j+1},\\\\ (\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i+1)}_{0}=\\mathbf{t}^{(i+1)},\\;\\mathbf{G}_{r^{\\ell-i}\\kappa n\\tau}\\cdot\\mathbf{s}^{(i+1)}_{\\ell-i-1}=\\mathbf{f}^{(i+1)},\\\\ \\prod_{j=0}^{\\ell-i-1}(\\mathbf{I}_{r^{j}\\kappa n}\\otimes\\mathbf{X}_{\\ell-i-j-1})\\cdot\\mathbf{f}^{(i+1)}=\\mathbf{u}^{(i)}\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">As far as the norm is concerned, for all <span class="math">j\\in[0,\\ell-i-1]</span>, one has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}^{(i+1)}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{C}_{i+1}^{\\top}\\otimes\\mathbf{I}_{r^{j}\\tau n\\alpha})\\cdot\\mathbf{s}^{(i)}_{j+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">=r\\kappa\\beta_{\\ell-i}</span> <span class="math">=r\\kappa\\cdot(r\\kappa)^{i}\\beta</span> <span class="math">=(r\\kappa)^{i+1}\\beta</span> <span class="math">=\\beta_{\\ell-i-1}.</span></p>

    <p class="text-gray-300">For the remaining checks, we are going to repeatedly make use of the identity from Eq. (11).</p>

    <p class="text-gray-300">For <span class="math">j\\in[\\ell-i-1]</span>, we start with the identity</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{r^{i}\\kappa\\tau}\\otimes\\mathbf{G}_{\\kappa})\\cdot\\mathbf{s}^{(i)}_{j}=(\\mathbf{I}_{r^{j+1}\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i)}_{j+1}.</span></p>

    <p class="text-gray-300">Multiplying both sides by <span class="math">\\mathbf{C}_{i+1}^{\\top} \\otimes \\mathbf{I}_{r^{j}n\\tau}</span> on the left, which "commutes" with both <span class="math">\\mathbf{I}_{r^{j}\\kappa\\tau} \\otimes \\mathbf{G}_{n}</span> and <span class="math">\\mathbf{I}_{r^{j+1}\\kappa\\tau} \\otimes \\mathbf{A}</span> as formalized in (11) to yield</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {r ^ {j} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {j} n \\tau \\alpha}\\right) \\cdot \\mathbf {s} _ {j} ^ {(i)}} ^ {\\mathbf {s} _ {j - 1} ^ {(i + 1)}} = \\left(\\mathbf {I} _ {r ^ {j} \\kappa \\tau} \\otimes \\mathbf {A}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {j + 1} n \\tau \\alpha}\\right) \\cdot \\mathbf {s} _ {j + 1} ^ {(i)}}</span></div>

    <p class="text-gray-300">Similarly, if we start with the identities</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {G} _ {n}\\right) \\cdot \\mathbf {s} _ {0} ^ {(i)} = \\left(\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {A}\\right) \\cdot \\mathbf {s} _ {1} ^ {(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {r ^ {\\ell - i + 1} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}\\right) \\cdot \\mathbf {s} _ {\\ell - i} ^ {(i)} = \\mathbf {f} ^ {(i)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {j = 1} ^ {\\ell - i} \\left(\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j}\\right) \\cdot \\mathbf {f} ^ {(i)} = \\mathbf {v} _ {i}</span></div>

    <p class="text-gray-300">and again multiply both sides on the left by <span class="math">\\mathbf{C}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{n\\tau}</span>, <span class="math">\\mathbf{C}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{r^{\\ell -i}n\\tau}</span>, and <span class="math">\\mathbf{C}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{n\\tau}</span> respectively, which "commute" with <span class="math">\\mathbf{I}_{r\\kappa \\tau}\\otimes \\mathbf{A}</span>, <span class="math">\\mathbf{I}_{r^{\\ell -i + 1}\\kappa \\tau}\\otimes \\mathbf{G}</span>, and <span class="math">\\mathbf{I}_{r^j\\kappa n}\\otimes \\mathbf{X}_{\\ell -i - j}</span> respectively, yields</p>

    <div class="my-4 text-center"><span class="math-block">\\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {n \\tau}\\right) \\cdot \\left(\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {G} _ {n}\\right) \\cdot \\mathbf {s} _ {0} ^ {(i)}} ^ {\\mathbf {t} ^ {(i + 1)}} = \\left(\\mathbf {I} _ {\\kappa \\tau} \\otimes \\mathbf {A}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} ^ {\\top} \\otimes \\mathbf {I} _ {r n \\tau \\alpha}\\right) \\cdot \\mathbf {s} _ {1} ^ {(i)}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {r ^ {\\ell - i} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i - 1} n \\tau \\alpha}\\right) \\cdot \\mathbf {s} _ {\\ell - i} ^ {(i)}} ^ {\\mathbf {s} _ {\\ell - i - 1} ^ {(i + 1)}} = \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i} n \\tau}\\right) \\cdot \\mathbf {f} ^ {(i)}},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {j = 1} ^ {\\ell - i} \\left(\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j}\\right) \\cdot \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i} n \\tau}\\right) \\cdot \\mathbf {f} ^ {(i)}} ^ {\\mathbf {f} ^ {(i + 1)}} = \\overbrace {\\left(\\mathbf {C} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {n \\tau}\\right) \\cdot \\mathbf {v} _ {i}} ^ {\\mathbf {u} _ {i + 1}}.</span></div>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">By Theorem 1, this directly implies that <span class="math">\\varPi</span> is complete for the relation <span class="math">\\mathsf{R}_{\\ell,\\beta_{\\ell}}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 1 (Completeness).</strong> The recursive-friendly proof system <span class="math">\\varPi</span> is complete for the relation <span class="math">\\mathsf{R}_{\\ell,\\beta_{\\ell}}</span>.</p>

    <p class="text-gray-300">Next, we prove that <span class="math">\\varPi</span> is round-by-round coordinate-wise special sound.</p>

    <p class="text-gray-300"><strong>Lemma 3 (Round-by-Round Coordinate-Wise Special Soundness).</strong> The recursive-friendly proof system <span class="math">\\varPi</span> is round-by-round coordinate-wise special sound for the tuple of relations <span class="math">(\\mathfrak{R}_{\\ell -i}^{<em>})_{i\\in [0,\\ell ]} = (\\mathsf{R}_{\\ell -i,\\beta_{\\ell -i}^{</em>}})_{i\\in [0,\\ell ]}</span>, where <span class="math">\\beta_{\\ell -i}^{<em>} = 2^{\\ell -i}\\beta_{0}^{</em>}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathsf{pp} = (q,n,\\alpha ,\\tau ,\\kappa ,r)</span>. For <span class="math">i\\in [0,\\ell -1]</span>, we define an efficient extractor <span class="math">\\mathsf{Ext}_i</span> that given <span class="math">r\\kappa +1</span> tuple of the form</p>

    <div class="my-4 text-center"><span class="math-block">x _ {i} = \\left(\\mathbf {A}, \\mathbf {t} ^ {(i)}, (\\mathbf {X} _ {j}) _ {j \\in [ 0, \\ell - i ]}, \\mathbf {u} ^ {(i)}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(z _ {i}, c _ {i + 1} ^ {(k)}\\right) = \\left(\\left(\\mathbf {y} _ {i}, \\mathbf {v} _ {i}\\right), \\mathbf {C} _ {i + 1, k}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">w _ {i + 1} ^ {(k)} = \\left(\\left(\\mathbf {s} _ {j, k} ^ {(i + 1)}\\right) _ {j \\in [ 0, \\ell - i - 1 ]}, \\mathbf {f} _ {k} ^ {(i + 1)}\\right)</span></div>

    <p class="text-gray-300">such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b_{i} = 1</span> , where  <span class="math">b_{i}\\gets \\mathsf{V}_{i}(\\mathsf{pp},x_{i},z_{i})</span></li>

      <li><span class="math">(\\mathbf{C}_{i + 1,k})_{k\\in [0,r\\kappa ]}\\in \\varGamma (\\{0,1\\}^{\\kappa},r\\kappa)</span>  , and</li>

      <li><span class="math">\\left(\\mathsf{pp},x_{i + 1}^{(k)},w_{i + 1}^{(k)}\\right)\\in \\mathsf{R}_{\\ell -i - 1,\\beta_{\\ell -i - 1}^*}</span>  for all  <span class="math">k\\in [0,r\\kappa ]</span>  , where  <span class="math">x_{i + 1}^{(k)} = \\mathsf{NextX}_i\\left(\\mathsf{pp},x_i,z_i,c_{i + 1}^{(k)}\\right),</span></li>

    </ol>

    <p class="text-gray-300">outputs <span class="math">w_{i}</span> such that <span class="math">(\\mathsf{pp},x_i,w_i)\\in \\mathsf{R}_{\\ell -i,\\beta_{\\ell -i}^<em>}</span>, where <span class="math">\\beta_{\\ell -i}^{</em>} = 2^{\\ell -i}\\beta_{0}^{*}</span>.</p>

    <p class="text-gray-300">Since <span class="math">(\\mathbf{C}_{i + 1,k})_{k\\in [0,r\\kappa ]}\\in \\varGamma (\\{0,1\\}^{\\kappa},r\\kappa)</span>, by Lemma 1, we know that exists <span class="math">\\mathbf{H}_{i + 1}\\in \\{0,1\\}^{\\kappa (r\\kappa +1)\\times r\\kappa}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\mathbf {C} _ {i + 1, 0} \\mid \\mathbf {C} _ {i + 1, 1} \\mid \\dots \\mid \\mathbf {C} _ {i + 1, r \\kappa} \\right] \\cdot \\mathbf {H} _ {i + 1} = \\mathbf {I} _ {r \\kappa}.</span></div>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}_i^{\\mathrm{efbr}}</span> outputs <span class="math">w_{i}\\coloneqq ((\\mathbf{s}_{j}^{(i)})_{j\\in [0,\\ell -i]},\\mathbf{f}^{(i)})</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} _ {0} ^ {(i)} := \\mathbf {y} _ {i}, \\qquad \\qquad \\mathbf {f} ^ {(i)} := (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i} n \\tau}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j - 1, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {f} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right],</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} _ {j} ^ {(i)} := (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {j} n \\tau \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j - 1, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j - 1, r \\kappa} ^ {(i + 1)} \\end{array} \\right] \\quad \\text{for } j \\in [ \\ell - i ].</span></div>

    <p class="text-gray-300">We claim that <span class="math">w_{i} = ((\\mathbf{s}_{j}^{(i)})_{j\\in [0,\\ell -i]},\\mathbf{f}^{(i)})</span> is a valid witness for the statement <span class="math">x_{i}</span> with respect to the relation <span class="math">\\mathsf{R}_{\\ell -i,\\beta_{\\ell -i}^*}</span>. For that, we need to check that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {\\ell - i, \\beta_ {\\ell - i} ^ {*}}: \\left\\{ \\begin{array}{c} \\forall j \\in [ 0, \\ell - i ], \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {j} ^ {(i)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {\\ell - i} ^ {*}, \\\\ \\forall j \\in [ 0, \\ell - i - 1 ], \\mathbf {G} _ {r ^ {j + 1} \\kappa n \\tau} \\cdot \\mathbf {s} _ {j} ^ {(i)} = (\\mathbf {I} _ {r ^ {j + 1} \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\mathbf {s} _ {j + 1} ^ {(i)}, \\\\ (\\mathbf {I} _ {\\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\mathbf {s} _ {0} ^ {(i)} = \\mathbf {t} ^ {(i)}, \\mathbf {G} _ {r ^ {\\ell - i + 1} \\kappa n \\tau} \\cdot \\mathbf {s} _ {\\ell - i} ^ {(i)} = \\mathbf {f} ^ {(i)}, \\\\ \\prod_ {j = 0} ^ {\\ell - i} (\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j}) \\cdot \\mathbf {f} ^ {(i)} = \\mathbf {u} ^ {(i)} \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By construction of <span class="math">\\mathbf{H}_{i + 1}</span>, for all <span class="math">j\\in [\\ell -i]</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} _ {j} ^ {(i)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left[ \\begin{array}{c} \\mathbf {s} _ {j - 1, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j - 1, r \\kappa} ^ {(i + 1)} \\end{array} \\right] \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot 2 ^ {\\ell - i - 1} \\beta_ {0} ^ {<em>} = 2 ^ {\\ell - i} \\beta_ {0} ^ {</em>} = \\beta_ {\\ell - i} ^ {*}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Therefore, the norm bound is satisfied. Further, by assumption since <span class="math">b_{i} = 1</span>, we have that <span class="math">\\mathbf{y}_i</span> satisfies Eq. (12), i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {\\kappa \\tau} \\otimes \\mathbf {A}\\right) \\cdot \\overbrace {\\mathbf {y} _ {i}} ^ {\\mathbf {s} _ {0} ^ {(i)}} = \\mathbf {t} ^ {(i)}</span></div>

    <p class="text-gray-300">We now consider a bunch of identities, which all follows from the fact that, by assumption <span class="math">(x_{i + 1}^{(k)},w_{i + 1}^{(k)})\\in \\mathsf{R}_{\\ell -i - 1,\\beta_{\\ell -i - 1}^*}</span> for all <span class="math">k\\in [0,r\\kappa ]</span>. Parse</p>

    <div class="my-4 text-center"><span class="math-block">x _ {i + 1} ^ {(k)} = \\left(\\mathbf {A}, \\mathbf {t} _ {k} ^ {(i + 1)}, (\\mathbf {X} _ {j}) _ {j \\in [ 0, \\ell - i - 1 ]}, \\mathbf {u} _ {k} ^ {(i + 1)}\\right)</span></div>

    <p class="text-gray-300">Start by considering the identity</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {(r \\kappa + 1) \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {0, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {0, r \\kappa} ^ {(i + 1)} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {t} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {t} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right] = \\left( \\begin{array}{c} \\left[ \\begin{array}{c} \\mathbf {C} _ {i + 1, 0} ^ {\\top} \\\\ \\vdots \\\\ \\mathbf {C} _ {i + 1, r \\kappa} ^ {\\top} \\end{array} \\right] \\otimes \\mathbf {I} _ {n \\tau} \\end{array} \\right) \\cdot (\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot \\mathbf {y} _ {i}.</span></div>

    <p class="text-gray-300">Multiplying both sides by <span class="math">\\mathbf{H}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{n\\tau}</span> on the left, which "commutes" with <span class="math">\\mathbf{I}_{(r\\kappa +1)\\kappa \\tau}\\otimes \\mathbf{A}</span> as formalized in (11), yields</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\overbrace {\\left(\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r n \\tau \\alpha}\\right) \\cdot \\left( \\begin{array}{c} \\mathbf {s} _ {0 , 0} ^ {(i)} \\\\ \\vdots \\\\ \\mathbf {s} _ {0 , r \\kappa} ^ {(i + 1)} \\end{array} \\right)} ^ {\\mathbf {s} _ {0} ^ {(i)} = (\\mathbf {I} _ {r \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot \\overbrace {\\mathbf {y} _ {i}} ^ {\\mathbf {s} _ {0} ^ {(i)}}</span></div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">Next, for any  <span class="math">j \\in [\\ell - i - 1]</span> , starting with identity</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {(r \\kappa + 1) r ^ {j} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j - 1, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j - 1, r \\kappa} ^ {(i + 1)} \\end{array} \\right] = (\\mathbf {I} _ {(r \\kappa + 1) r ^ {j} \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j, r \\kappa} ^ {(i + 1)} \\end{array} \\right]</span></div>

    <p class="text-gray-300">and again multiplying both sides by  <span class="math">\\mathbf{H}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{r^{j}n\\tau}</span>  on the left, we get</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {r ^ {j + 1} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {j} n \\tau \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j - 1, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j - 1, r \\kappa} ^ {(i + 1)} \\end{array} \\right] = (\\mathbf {I} _ {r ^ {j + 1} \\kappa \\tau} \\otimes \\mathbf {A}) \\cdot (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {j + 1} n \\tau \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {j, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {j, r \\kappa} ^ {(i + 1)} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Similarly, one can observe multiplying by  <span class="math">\\mathbf{H}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{r^{\\ell -i - 1}n\\tau}</span>  on the left the identity</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {(r \\kappa + 1) r ^ {\\ell - i - 1} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {\\ell - i, 0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {\\ell - i, r \\kappa} ^ {(i + 1)} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {f} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {f} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right]</span></div>

    <p class="text-gray-300">yields</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {I} _ {r ^ {\\ell - i} \\kappa \\tau} \\otimes \\mathbf {G} _ {n}) \\cdot (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i} n \\tau \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {s} _ {\\ell - i - 1} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {s} _ {\\ell - i, r \\kappa} ^ {(i + 1)} \\end{array} \\right] = (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i - 1} n \\tau}) \\cdot \\left[ \\begin{array}{c} \\mathbf {f} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {f} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Finally, if we consider identity</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {r \\kappa + 1} \\otimes \\prod_ {j = 0} ^ {\\ell - i - 1} \\left(\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j - 1}\\right)\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {f} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {f} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right] = \\left[ \\begin{array}{c} \\mathbf {u} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {u} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right] = \\left(\\left[ \\begin{array}{c} \\mathbf {C} _ {i + 1, 0} ^ {\\top} \\\\ \\vdots \\\\ \\mathbf {C} _ {i + 1, r \\kappa} ^ {\\top} \\end{array} \\right] \\otimes \\mathbf {I} _ {n \\tau}\\right) \\cdot \\mathbf {v} _ {i},</span></div>

    <p class="text-gray-300">multiplying both sides by  <span class="math">(\\mathbf{I}_{r\\kappa n}\\otimes \\mathbf{X}_{\\ell -i})\\cdot (\\mathbf{H}_{i + 1}^{\\top}\\otimes \\mathbf{I}_{n\\tau})</span>  on the left, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_ {j = 0} ^ {\\ell - i} (\\mathbf {I} _ {r ^ {j} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j}) \\cdot \\mathbf {f} ^ {(i)} = (\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i}) \\cdot \\prod_ {j = 0} ^ {\\ell - i - 1} (\\mathbf {I} _ {r ^ {j + 1} \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i - j - 1}) \\cdot (\\mathbf {H} _ {i + 1} ^ {\\top} \\otimes \\mathbf {I} _ {r ^ {\\ell - i - 1} n \\tau}) \\cdot \\left[ \\begin{array}{c} \\mathbf {f} _ {0} ^ {(i + 1)} \\\\ \\vdots \\\\ \\mathbf {f} _ {r \\kappa} ^ {(i + 1)} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {X} _ {\\ell - i}\\right) \\cdot \\mathbf {v} _ {i} \\\\ = \\mathbf {u} ^ {(i)}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where in the last equality we have used the fact that  <span class="math">\\mathbf{v}_i</span>  satisfies Eq. (12), as  <span class="math">b_{i} = 1</span> .</p>

    <p class="text-gray-300">This shows that  <span class="math">w_{i} = \\left((\\mathbf{s}_{j}^{(i)})_{j\\in [0,\\ell -i - 1]},\\mathbf{f}^{(i)}\\right)</span>  is indeed a valid witness for the statement  <span class="math">x_{i}</span>  with respect to the relation  <span class="math">\\mathsf{R}_{\\ell -i,\\beta_{\\ell -i}^*}</span>  and concludes the proof.</p>

    <p class="text-gray-300">Setting  <span class="math">\\beta_0^* = \\beta_0 = (r\\kappa)^\\ell \\beta</span> , by Theorem 2, this directly implies that  <span class="math">\\varPi</span>  is knowledge sound for the relation  <span class="math">\\mathsf{R}_{\\ell,(2r\\kappa)^\\ell \\beta}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">τ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(log L/ log r log(rλ))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log L/ log r log(rλ))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log L/ log r)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Parameters as a function of  <span class="math">L, r</span>  ,and  <span class="math">\\lambda</span>  .</p>

    <p class="text-gray-300">Theorem 2 (Knowledge Soundness). The proof system  <span class="math">\\Pi</span>  for the relation  <span class="math">\\mathsf{R}_{\\ell, \\beta}</span>  is knowledge sound for the relation  <span class="math">\\mathsf{R}_{\\ell, (2r\\kappa)^{\\ell} \\beta}</span> , with soundness error at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\ell r \\kappa}{2 ^ {\\kappa}}.</span></div>

    <p class="text-gray-300">Remark 1. In particular, this term becomes negligible for  <span class="math">\\kappa = O(\\lambda)</span> .</p>

    <p class="text-gray-300">The commitment and proof size (in bits) are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commitment size  $= \\underbrace{\\kappa n\\tau\\log q}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\text {p r o o f s i z e} = \\sum_ {i = 0} ^ {\\ell} \\left(\\underbrace {r \\kappa n \\tau \\alpha \\lceil \\log ((r \\kappa) ^ {i} \\beta) \\rceil} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {y} _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\underbrace {r \\kappa n \\tau \\log q} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {v} _ {i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\\\ \\approx r \\kappa n \\tau \\left(\\frac {(\\ell + 1) \\ell}{2} \\alpha \\log (r \\kappa) + (\\ell + 1) \\alpha \\log \\beta + (\\ell + 1) \\log q\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The prover runtime is dominated by the time required to compute the different  <span class="math">\\mathbf{s}_j^{(i)}</span> . In order to compute them, it has to perform</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {j = 1} ^ {\\ell - 1} \\sum_ {i = 0} ^ {\\ell - j} r ^ {i + 1} n \\tau \\alpha \\leq n \\tau \\alpha \\sum_ {j = 1} ^ {\\ell} j r ^ {\\ell + 1 - j} \\\\ = n \\tau \\alpha r ^ {\\ell + 1} \\sum_ {j = 1} ^ {\\ell} j r ^ {- j} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">multiplication of matrices of size  <span class="math">\\kappa \\times r\\kappa</span>  by vectors of size  <span class="math">r\\kappa</span> . Notice that the last sum can be bounded by  <span class="math">\\frac{1 / r}{(1 - 1 / r)^2} \\leq 4 / r</span> , since  <span class="math">r \\geq 2</span> . The verifier overhead is dominated by performing  <span class="math">\\ell n\\tau</span>  multiplication of binary matrices of size  <span class="math">\\kappa \\times r\\kappa</span>  by  <span class="math">\\mathbb{Z}_q</span>  vectors of size  <span class="math">r\\kappa</span>  and  <span class="math">\\ell \\kappa n</span>  multiplication of matrices of size  <span class="math">\\tau \\times r\\tau</span>  and  <span class="math">n \\times rn\\alpha</span>  by vectors of size  <span class="math">r\\tau</span>  and  <span class="math">rn\\alpha</span>  respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r = O(1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r = O(λ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r = Lε</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">λ·log L/2λ</td>

            <td class="px-3 py-2 border-b border-gray-700">λ2·log L/2λ·log λ</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ·Lε/2λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ2·log L·log λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ2·log L)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ2·log L)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ2·(log L)2·log λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ3·(log L)2/2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ2·Lε·log L)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">L·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">L·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">L1+ε·poly(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">log L·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">log L·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">Lε·poly(λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">extractor runtime</td>

            <td class="px-3 py-2 border-b border-gray-700">L·λlog L·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">L2·poly(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">L·poly(λ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Asymptotic efficiency, as a function of  <span class="math">L</span>  and  <span class="math">\\lambda</span>  ,for different choices of  <span class="math">r</span>  ,where  <span class="math">\\epsilon  \\in  \\left( {0,1}\\right)</span>  .</p>

    <p class="text-gray-300">Setting parameters as in Table 2, we get that soundness error, commitment size, proof size, prover runtime, verifier runtime, and extractor runtime are respectively</p>

    <p class="text-gray-300">soundness error  <span class="math">\\leq \\frac{\\lambda\\cdot r\\cdot\\log L}{2^{\\lambda}\\cdot\\log r}</span></p>

    <p class="text-gray-300">commitment size  <span class="math">= O\\left(\\lambda^2\\cdot \\frac{\\log L}{\\log r}\\cdot \\log (r\\lambda)\\right)</span></p>

    <p class="text-gray-300">proof size  <span class="math">= O\\left(\\lambda^2\\cdot r\\cdot \\left(\\frac{\\log L}{\\log r}\\right)^2\\cdot \\log (r\\lambda)\\right)</span></p>

    <p class="text-gray-300">prover runtime  <span class="math">\\leq r^2\\cdot L\\cdot \\sum_{j = 1}^{\\log N / \\log r}jr^{-j}\\cdot \\mathsf{poly}(\\lambda)</span></p>

    <p class="text-gray-300">verifier runtime  <span class="math">\\leq r\\cdot \\frac{\\log L}{\\log r}\\cdot \\mathsf{poly}(\\lambda)</span></p>

    <p class="text-gray-300">extractor runtime  <span class="math">\\leq (r\\cdot \\lambda)^{\\log L / \\log r}\\cdot \\mathsf{poly}(\\lambda) = L\\cdot \\lambda^{\\log L / \\log r}\\cdot \\mathsf{poly}(\\lambda)</span></p>

    <p class="text-gray-300">For different choices of  <span class="math">r</span> , we get different trade-offs as shown in Table 3.</p>

    <p class="text-gray-300">Combining the commitment scheme from Section 4, together with the protocol from Section 5, we obtain a polynomial commitment for the class of functions characterized as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the function is specified by  <span class="math">\\mathbf{f} \\in \\mathbb{Z}_q^{r^{\\ell + 1}\\kappa n\\tau}</span> ,</li>

      <li>the input domain for the function is  <span class="math">\\mathbb{Z}_q^\\eta</span> , for some  <span class="math">\\eta \\in \\mathbb{N}</span></li>

      <li>given an input  <span class="math">\\mathbf{X}_i\\in \\mathbb{Z}_q^{\\tau \\times r\\tau}</span> , the output of the function is given by</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {I} _ {\\kappa n} \\otimes \\mathbf {X} _ {\\ell}\\right) \\cdot \\left(\\mathbf {I} _ {r \\kappa n} \\otimes \\mathbf {X} _ {\\ell - 1}\\right) \\dots \\left(\\mathbf {I} _ {r ^ {\\ell} \\kappa n} \\otimes \\mathbf {X} _ {0}\\right) \\cdot \\mathbf {f}</span></div>

    <p class="text-gray-300">Using such a structure, we can represent the evaluation of both multi-linear polynomials and univariate polynomials via the inner-product of  <span class="math">\\mathbf{f}</span> , the vector of coefficients of the given polynomial  <span class="math">f</span> , with a vector of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {\\ell} ^ {\\top} \\cdot \\left(\\mathbf {I} _ {r _ {\\ell}} \\otimes \\mathbf {x} _ {\\ell - 1} ^ {\\top}\\right) \\dots \\left(\\mathbf {I} _ {r _ {\\ell} \\dots r _ {1}} \\otimes \\mathbf {x} _ {0} ^ {\\top}\\right)</span></div>

    <p class="text-gray-300">for an appropriate choice of parameters. In particular,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for multi-linear polynomials <span class="math">\\mathbb{Z}_{q}[X_{0},X_{1},\\ldots,X_{\\eta}]</span> evaluated at <span class="math">(x_{0},x_{1},\\ldots,x_{\\eta})</span>, just set <span class="math">\\mathbf{x}_{i}^{\\top}=[1\\quad x_{i}]\\in\\mathbb{Z}_{q}^{2}</span>, for <span class="math">i\\in[0,\\eta]</span>.</li>

      <li>for univariate polynomials evaluated at <span class="math">x\\in\\mathbb{Z}_{q}</span> of degree <span class="math">&lt;r_{0}\\cdots r_{\\ell}</span>, set <span class="math">\\mathbf{x}_{i}[j_{i}]=x^{R_{i}(j_{i}-1)}</span>, with <span class="math">\\mathbf{x}_{i}\\in\\mathbb{Z}_{q}^{r_{i}}</span>, for <span class="math">i\\in[0,\\ell]</span>.</li>

    </ul>

    <p class="text-gray-300">This is formalized in Lemma 13 and proven in Appendix E.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 3 (Univariate Polynomials).</h6>

    <p class="text-gray-300">Let <span class="math">n,\\beta,\\ell,\\tau,\\kappa,\\alpha</span> as in Section 5.3 with <span class="math">r=\\lambda</span> and <span class="math">L=N</span> Assume <span class="math">\\mathsf{SIS}_{n,(\\ell+1)rn\\alpha,q,\\beta^{\\prime}}</span> with <span class="math">\\beta^{\\prime}\\geq(2r\\lambda)^{\\ell}\\beta</span>. Then, there is a knowledge sound functional commitment scheme for the function class <span class="math">\\mathcal{F}=\\mathbb{Z}_{q}^{&lt;N}[X]</span> of univariate polynomials of degree <span class="math">&lt;N</span> and input domain <span class="math">\\mathbb{Z}_{q}</span>, with the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error <span class="math">\\frac{\\lambda^{2}\\cdot\\log N}{2^{\\lambda}\\cdot\\log\\lambda}</span>,</li>

      <li>commitment size <span class="math">O(\\lambda^{2}\\cdot\\log N)</span>,</li>

      <li>proof size <span class="math">O\\left(\\lambda^{3}\\frac{(\\log N)^{2}}{\\log\\lambda}\\right)</span>,</li>

      <li>prover runtime <span class="math">N\\cdot\\textup{poly}(\\lambda)</span>, and</li>

      <li>verifier runtime <span class="math">\\log N\\cdot\\textup{poly}(\\lambda)</span>.</li>

    </ul>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 4 (Multi-Linear Polynomials).</h6>

    <p class="text-gray-300">Let <span class="math">n,\\beta,\\ell,\\tau,\\kappa,\\alpha</span> as in Section 5.3 with <span class="math">r=\\lambda</span> and <span class="math">L=2^{\\eta}</span> Assume <span class="math">\\mathsf{SIS}_{n,(\\ell+1)rn\\alpha,q,\\beta^{\\prime}}</span> with <span class="math">\\beta^{\\prime}\\geq(2r\\lambda)^{\\ell}\\beta</span>. Then, there is a knowledge sound functional commitment scheme for the function class <span class="math">\\mathcal{F}=\\mathbb{Z}_{q}^{&lt;2}[X_{1},\\ldots,X_{\\eta}]</span> of multi-linear polynomials in <span class="math">\\eta</span> variables and input domain <span class="math">\\mathbb{Z}_{q}^{\\eta}</span>, with the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error <span class="math">\\frac{\\lambda^{2}\\cdot\\eta}{2^{\\lambda}\\cdot\\log\\lambda}</span>,</li>

      <li>commitment size <span class="math">O(\\lambda^{2}\\cdot\\eta)</span>,</li>

      <li>proof size <span class="math">O\\left(\\lambda^{3}\\frac{\\eta^{2}}{\\log\\lambda}\\right)</span>,</li>

      <li>prover runtime <span class="math">2^{\\eta}\\cdot\\textup{poly}(\\lambda)</span>, and</li>

      <li>verifier runtime <span class="math">\\eta\\cdot\\textup{poly}(\\lambda)</span>.</li>

    </ul>

    <h2 id="sec-37" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ACK21] Thomas Attema, Ronald Cramer, and Lisa Kohl. A compressed <span class="math">\\Sigma</span>-protocol theory for lattices. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part II, volume 12826 of LNCS, pages 549–579, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>[ACL^{+}22] Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. Lattice-based SNARKs: Publicly verifiable, preprocessing, and recursively composable - (extended abstract). In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part II, volume 13508 of LNCS, pages 102–132. Springer, Heidelberg, August 2022.</li>

      <li>[AF22] Thomas Attema and Serge Fehr. Parallel repetition of (<span class="math">k_{1},\\ldots,k_{\\mu}</span>)-special-sound multi-round interactive proofs. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part I, volume 13507 of LNCS, pages 415–443. Springer, Heidelberg, August 2022.</li>

      <li>[AFLN23] Martin R. Albrecht, Giacomo Fenzi, Oleksandra Lapiha, and Ngoc Khanh Nguyen. Slap: Succinct lattice-based polynomial commitments from standard assumptions. Cryptology ePrint Archive, Paper 2023/1469, 2023. https://eprint.iacr.org/2023/1469.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2087–2104. ACM Press, October / November 2017.</li>

      <li>[Ajt96] Miklós Ajtai. Generating hard instances of lattice problems (extended abstract). In 28th ACM STOC, pages 99–108. ACM Press, May 1996.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">AL21. Martin R. Albrecht and Russell W. F. Lai. Subtractive sets over cyclotomic rings - limits of Schnorr-like arguments over lattices. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part II, volume 12826 of LNCS, pages 519–548, Virtual Event, August 2021. Springer, Heidelberg. 3, 9</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ALS20. Thomas Attema, Vadim Lyubashevsky, and Gregor Seiler. Practical product proofs for lattice commitments. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part II, volume 12171 of LNCS, pages 470–499. Springer, Heidelberg, August 2020.</li>

      <li>Ard23. Andy Arditi. Kzg in practice: Polynomial commitment schemes and their usage in scaling ethereum, 2023. https://scroll.io/blog/kzg.</li>

      <li>BBB^{+}17. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. Cryptology ePrint Archive, Report 2017/1066, 2017. https://eprint.iacr.org/2017/1066.</li>

      <li>BBC^{+}18. Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 669–699. Springer, Heidelberg, August 2018.</li>

      <li>BBHR18a. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018.</li>

      <li>BBHR18b. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046.</li>

      <li>BBK22. Nir Bitansky, Zvika Brakerski, and Yael Tauman Kalai. Constructive post-quantum reductions. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part III, volume 13509 of LNCS, pages 654–683. Springer, Heidelberg, August 2022.</li>

      <li>BCFL22. David Balbás, Dario Catalano, Dario Fiore, and Russell W. F. Lai. Functional commitments for circuits from falsifiable assumptions. Cryptology ePrint Archive, Report 2022/1365, 2022. https://eprint.iacr.org/2022/1365.</li>

      <li>BCHO22. Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orrù. Gemini: Elastic SNARKs for diverse environments. In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 427–457. Springer, Heidelberg, May / June 2022.</li>

      <li>BCSS21. Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. Sumcheck arguments and their applications. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 742–773, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>BCS23. Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. Lattice-based succinct arguments for NP with polylogarithmic-time verification. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 227–251. Springer, Heidelberg, August 2023.</li>

      <li>BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</li>

      <li>BGK^{+}23. Alexander R. Block, Albert Garreta, Jonathan Katz, Justin Thaler, Pratyush Ranjan Tiwari, and Michal Zajac. Fiat-shamir security of fri and related snarks. Cryptology ePrint Archive, Paper 2023/1071, 2023. https://eprint.iacr.org/2023/1071.</li>

      <li>BHR^{+}21. Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Time- and space-efficient arguments from groups of unknown order. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part IV, volume 12828 of LNCS, pages 123–152, Virtual Event, August 2021. Springer, Heidelberg.</li>

      <li>BL17. Carsten Baum and Vadim Lyubashevsky. Simple amortized proofs of shortness for linear relations over polynomial rings. Cryptology ePrint Archive, Report 2017/759, 2017. https://eprint.iacr.org/2017/759.</li>

      <li>BLNS20. Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. A non-PCP approach to succinct quantum-safe zero-knowledge. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part II, volume 12171 of LNCS, pages 441–469. Springer, Heidelberg, August 2020.</li>

      <li>BS23. Ward Beullens and Gregor Seiler. LaBRADOR: Compact proofs for R1CS from module-SIS. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part V, volume 14085 of LNCS, pages 518–548. Springer, Heidelberg, August 2023.</li>

      <li>CBBZ23. Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part II, volume 14005 of LNCS, pages 499–530. Springer, Heidelberg, April 2023.</li>

    </ul>

    <p class="text-gray-300">CHM^{+}20. Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Heidelberg, May 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] AJL22. Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. SNARGs for <span class="math">\\mathcal{P}</span> from LWE. In 62nd FOCS, pages 68–79. IEEE Computer Society Press, February 2022.</li>

      <li>[23] CLM23. Valerio Cini, Russell W. F. Lai, and Giulio Malavolta. Lattice-based succinct arguments from vanishing polynomials - (extended abstract). In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 72–105. Springer, Heidelberg, August 2023.</li>

      <li>[24] CMSZ22. Alessandro Chiesa, Fermi Ma, Nicholas Spooner, and Mark Zhandry. Post-quantum succinct arguments: Breaking the quantum rewinding barrier. In 62nd FOCS, pages 49–58. IEEE Computer Society Press, February 2022.</li>

      <li>[25] CMS20. Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, Heidelberg, May 2020.</li>

      <li>[26] dCP23. Leo de Castro and Chris Peikert. Functional commitments for all functions, with transparent setup and from SIS. In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part III, volume 14006 of LNCS, pages 287–320. Springer, Heidelberg, April 2023.</li>

      <li>[27] DFM20. Jelle Don, Serge Fehr, and Christian Majenz. The measure-and-reprogram technique 2.0: Multi-round fiat-shamir and more. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 602–631. Springer, Heidelberg, August 2020.</li>

      <li>[28] DKL^{+}18. Léo Ducas, Eike Kiltz, Tancrède Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehlé. Crystals-dilithium: A lattice-based digital signature scheme. IACR Trans. Cryptogr. Hardw. Embed. Syst., 2018(1):238–268, 2018.</li>

      <li>[29] FLV23. Ben Fisch, Zeyu Liu, and Psi Vesely. Orbweaver: Succinct linear functional commitments from lattices. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 106–131. Springer, Heidelberg, August 2023.</li>

      <li>[30] FMN23. Giacomo Fenzi, Hossein Moghaddas, and Ngoc Khanh Nguyen. Lattice-based polynomial commitments: Towards asymptotic and concrete efficiency. Cryptology ePrint Archive, Paper 2023/846, 2023. https://eprint.iacr.org/2023/846.</li>

      <li>[31] FS87. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</li>

      <li>[32] GHL22. Craig Gentry, Shai Halevi, and Vadim Lyubashevsky. Practical non-interactive publicly verifiable secret sharing with thousands of parties. In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part I, volume 13275 of LNCS, pages 458–487. Springer, Heidelberg, May / June 2022.</li>

      <li>[33] GLS^{+}23. Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 193–226. Springer, Heidelberg, August 2023.</li>

      <li>[34] Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.</li>

      <li>[35] Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[36] GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[37] IKO07. Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Efficient arguments without short pcps. In Conference on Computational Complexity (CCC 2007), pages 278–291, 2007.</li>

      <li>[38] Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732. ACM Press, May 1992.</li>

      <li>[39] KP23. Abhiram Kothapalli and Bryan Parno. Algebraic reductions of knowledge. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part IV, volume 14084 of LNCS, pages 669–701. Springer, Heidelberg, August 2023.</li>

      <li>[40] KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</li>

      <li>[41] Lee21. Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. In Kobbi Nissim and Brent Waters, editors, TCC 2021, Part II, volume 13043 of LNCS, pages 1–34. Springer, Heidelberg, November 2021.</li>

      <li>[42] LFKN90. Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In 31st FOCS, pages 2–10. IEEE Computer Society Press, October 1990.</li>

    </ul>

    <p class="text-gray-300">LLNW16. Benoît Libert, San Ling, Khoa Nguyen, and Huaxiong Wang. Zero-knowledge arguments for lattice-based accumulators: Logarithmic-size ring signatures and group signatures without trapdoors. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 1–31. Springer, Heidelberg, May 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[22] LMS22. Russell W. F. Lai, Giulio Malavolta, and Nicholas Spooner. Quantum rewinding for many-round protocols. In Eike Kiltz and Vinod Vaikuntanathan, editors, TCC 2022, Part I, volume 13747 of LNCS, pages 80–109. Springer, Heidelberg, November 2022.</li>

      <li>[23] LMS23. Jiahui Liu, Hart Montgomery, and Mark Zhandry. Another round of breaking and making quantum money: How to not build it from lattices, and more. In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part I, volume 14004 of LNCS, pages 611–638. Springer, Heidelberg, April 2023.</li>

      <li>[24] LNP22. Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. Lattice-based zero-knowledge proofs and applications: Shorter, simpler, and more general. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part II, volume 13508 of LNCS, pages 71–101. Springer, Heidelberg, August 2022.</li>

      <li>[25] LNS21. Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. Shorter lattice-based zero-knowledge proofs via one-time commitments. In Juan Garay, editor, PKC 2021, Part I, volume 12710 of LNCS, pages 215–241. Springer, Heidelberg, May 2021.</li>

      <li>[26] LS15. Adeline Langlois and Damien Stehlè. Worst-case to average-case reductions for module lattices. Des. Codes Cryptogr., 75(3):565–599, 2015.</li>

      <li>[27] LS18. Vadim Lyubashevsky and Gregor Seiler. Short, invertible elements in partially splitting cyclotomic rings and applications to lattice-based zero-knowledge proofs. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 204–224. Springer, Heidelberg, April / May 2018.</li>

      <li>[28] LZ19. Qipeng Liu and Mark Zhandry. Revisiting post-quantum Fiat-Shamir. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part II, volume 11693 of LNCS, pages 326–355. Springer, Heidelberg, August 2019.</li>

      <li>[29] MBKM19. Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019.</li>

      <li>[30] Mic94. Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society Press, November 1994.</li>

      <li>[31] MR09. Daniele Micciancio and Oded Regev. Lattice-based Cryptography, pages 147–191. Springer Berlin Heidelberg, Berlin, Heidelberg, 2009.</li>

      <li>[32] NC11. Michael A. Nielsen and Isaac L. Chuang. Quantum Computation and Quantum Information: 10th Anniversary Edition. Cambridge University Press, 2011.</li>

      <li>[33] Pol22. Polygon Zero Team. Plonky2: Fast recursive arguments with PLONK and FRI, 2022. https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf.</li>

      <li>[34] PSTY13. Charalampos Papamanthou, Elaine Shi, Roberto Tamassia, and Ke Yi. Streaming authenticated data structures. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 353–370. Springer, Heidelberg, May 2013.</li>

      <li>[35] SMBW12. Srinath T. V. Setty, Richard McPherson, Andrew J. Blumberg, and Michael Walfish. Making argument systems for outsourced computation practical (sometimes). In NDSS 2012. The Internet Society, February 2012.</li>

      <li>[36] STW23. Srinath Setty, Justin Thaler, and Riad Wahby. Unlocking the lookup singularity with lasso. Cryptology ePrint Archive, Paper 2023/1216, 2023. https://eprint.iacr.org/2023/1216.</li>

      <li>[37] Unr16. Dominique Unruh. Computationally binding quantum commitments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 497–527. Springer, Heidelberg, May 2016.</li>

      <li>[38] WV23. Hoeteck Wee and David J. Wu. Succinct vector, polynomial, and functional commitments from lattices. In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part III, volume 14006 of LNCS, pages 385–416. Springer, Heidelberg, April 2023.</li>

    </ul>

    <h2 id="sec-38" class="text-2xl font-bold">Appendix A More Efficient Constructions over Cyclotomic Rings</h2>

    <p class="text-gray-300">In this section we provide a concretely efficient proof of polynomial evaluation over power-of-two cyclotomic rings. Asymptotically, the protocol achieves <span class="math">O(\\sqrt[3]{L})</span> communication and verifier complexity. However, due to small growth in stretch and slack, we manage to obtain concretely small parameters.</p>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Background</h5>

    <p class="text-gray-300">We work over the ring <span class="math">R_{q}:=\\mathbb{Z}_{q}[X]/(X^{d}+1)</span>, where <span class="math">d</span> is a power-of-two and <span class="math">q</span> is an odd prime. For a polynomial <span class="math">p\\in R_{q}</span>, we will use the arrow notation, e.g. <span class="math">\\overrightarrow{p}\\in\\mathbb{Z}_{q}^{d}</span>, to denote its coefficient vector. The notation</p>

    <p class="text-gray-300">tends naturally to vectors over <span class="math">R_{q}</span>. Conversely, for a vector <span class="math">\\overrightarrow{p}</span> over <span class="math">\\mathbb{Z}_{q}</span> of length divisible by <span class="math">d</span>, we define <span class="math">\\mathbf{p}</span> to be the polynomial vector over <span class="math">R_{q}</span> with the coefficient vector <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly as before, for <span class="math">f=\\sum_{i=0}^{d-1}f_{i}\\cdot X^{i}\\in R_{q}</span>, we define the infinity norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=\\max_{i\\in[0,d-1]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Definition of the norm extends naturally to vectors and matrices over </span>R_{q}<span class="math">. We use the well-known facts that for any </span>f,g\\in R_{q}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\cdot g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq d\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In this section, we work with primes </span>q\\equiv 5\\pmod{8}<span class="math">. Then, by the main result of Lyubashevsky and Seiler <em>[x18]</em> we know that any non-zero </span>f\\in R_{q}<span class="math"> such that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\sqrt{q/2}<span class="math"> is invertible over </span>R_{q}$. Hence, we define the challenge space</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{C}:=\\{c\\in R_{q}:\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for <span class="math">\\kappa&lt;\\sqrt{q/8}</span>. Then, any difference of two distinct challenges in <span class="math">\\mathcal{C}</span> is invertible over <span class="math">R_{q}</span>.</p>

    <p class="text-gray-300">For proving shortness of the committed vectors, we will use a strategy called approximate range proof <em>[x1, x16, x15]</em>. Namely, to prove that an integer vector <span class="math">\\overrightarrow{s}\\in\\mathbb{Z}_{q}^{m}</span> is short, the prover asks the verifier for a random ternary matrix <span class="math">P\\leftarrow\\chi^{\\lambda\\times m}</span>, where <span class="math">\\chi</span> is the distribution over <span class="math">\\{-1,0,1\\}</span> so that <span class="math">\\chi(-1)=\\chi(1)=1/4</span> and <span class="math">\\chi(0)=1/2</span>, and then outputs a short projection <span class="math">\\overrightarrow{y}:=P\\cdot\\overrightarrow{s}\\in\\mathbb{Z}_{q}^{\\lambda}</span>. The verifier finally checks that <span class="math">\\overrightarrow{y}</span> has short coefficients. The core argument in approximate range proofs is that if <span class="math">\\overrightarrow{s}</span> has large coefficients, then so does <span class="math">P\\cdot\\overrightarrow{s}</span> (with an overwhelming probability over <span class="math">P</span>).</p>

    <p class="text-gray-300">To facilitate from approximate range proofs, one should be able to prove linear relations over <span class="math">\\mathbb{Z}_{q}</span>, e.g. <span class="math">\\overrightarrow{y}=P\\cdot\\overrightarrow{s}</span>. To this end, we apply the transformation from <em>[x17]</em>, which maps relations from <span class="math">\\mathbb{Z}_{q}</span> to <span class="math">R_{q}</span>. Concretely, let <span class="math">\\sigma_{-1}:R\\to R</span> be the Galois automorphism which maps <span class="math">X\\mapsto X^{-1}</span>. Then, for any two polynomials <span class="math">f,g\\in R</span> with coefficient vectors <span class="math">\\overrightarrow{f}</span> and <span class="math">\\overrightarrow{g}</span> respectively, the constant coefficient of <span class="math">\\sigma_{-1}(f)\\cdot g\\in R</span> is equal to <span class="math">\\langle\\overrightarrow{f},\\overrightarrow{g}\\rangle</span>. This means that proving linear equations over <span class="math">\\mathbb{Z}_{q}</span> can be translated into proving statements about (constant coefficients of) elements in <span class="math">R_{q}</span>. An identical result holds for vectors over <span class="math">R_{q}</span>, where for an arbitrary <span class="math">\\mathbf{f}\\in R_{q}</span>, <span class="math">\\sigma_{-1}(\\mathbf{f})\\in R_{q}^{n}</span> is the vector with <span class="math">\\sigma_{-1}</span> applied to each component separately. For a polynomial in <span class="math">R_{q}</span>, we use “tilde” to denote its constant coefficient, e.g. <span class="math">\\hat{f}\\in\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">As before, we consider the gadget vector <span class="math">\\mathbf{g}^{\\top}=(1,\\delta,\\delta^{2},\\ldots,\\delta^{\\alpha-1})\\in R^{\\alpha}</span>, where <span class="math">\\alpha:=\\lceil\\log_{\\delta}q\\rceil</span>. For <span class="math">n\\geq 1</span>, we denote <span class="math">\\mathbf{G}_{n}:=\\mathbf{I}_{n}\\otimes\\mathbf{g}^{\\top}\\in R^{n\\times\\alpha n}</span>.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Hardness assumption</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Binding and the coordinate-wise special soundness properties will rely on the hardness of the Module SIS problem <em>[x16]</em>. Namely, the (infinity-norm) <span class="math">\\mathsf{MSIS}_{n,m,q,d,\\beta}</span> problem asks an adversary, which is given a uniformly random matrix <span class="math">\\mathbf{A}\\leftarrow R_{q}^{n\\times m}</span>, to find a non-zero short vector <span class="math">\\mathbf{z}\\in R_{q}^{m}</span>, such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math"> and </span>\\mathbf{A}\\cdot\\mathbf{z}=\\mathbf{0}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-41" class="text-base font-semibold mt-4">Technical lemma for soundness</h5>

    <p class="text-gray-300">Looking ahead, to prove coordinate-wise special soundness, we will use the ring version of Lemma 1.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\xi\\geq 1</span>. Given <span class="math">\\mathbf{c}_{0},\\ldots,\\mathbf{c}_{\\xi}\\in\\Gamma(\\mathcal{C},\\xi)</span>, i.e., satisfying the coordinate-wise property, we can compute a matrix <span class="math">\\mathbf{H}=(\\mathbf{h}_{i})_{i\\in\\xi}\\in R_{q}^{(\\xi+1)\\times\\xi}</span> and a vector <span class="math">\\mathbf{c}^{*}\\in(R_{q}^{\\times})^{\\xi}</span> such that:</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{c}_{0}\\mid\\mathbf{c}_{1}\\mid\\cdots\\mid\\mathbf{c}_{\\xi}]\\cdot\\mathbf{H}=\\mathbf{I}_{\\xi}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\kappa<span class="math"> for any </span>i\\in[\\xi]<span class="math">. Moreover, for </span>i\\in[\\xi]<span class="math">, </span>r\\geq 1<span class="math"> and any vector </span>\\mathbf{y}\\in R_{q}^{r(\\xi+1)}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}^{*}\\cdot(\\mathbf{h}_{i}^{\\top}\\otimes\\mathbf{I}_{r})\\cdot\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{e}_{i}</span> denote the <span class="math">i</span>-th unit vector in <span class="math">R_{q}^{\\xi+1}</span>. Assume without loss of generality that <span class="math">\\mathbf{c}_{0}</span> differs from any other <span class="math">\\mathbf{c}_{i}</span> exactly in the <span class="math">i</span>-th coordinate. Hence, for each <span class="math">i</span> we can write <span class="math">\\mathbf{c}_{0}-\\mathbf{c}_{i}=(c_{0,i}-c_{i,i})\\cdot\\mathbf{e}_{i}</span>. We know that $0<\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{0,i}-c_{i,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\kappa<\\sqrt{q/2}<span class="math"> and thus </span>c_{i}^{*}:=c_{0,i}-c_{i,i}<span class="math"> is invertible over </span>R_{q}$. Thus, define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{h}_{i}:=\\frac{1}{c_{i}^{*}}\\cdot(\\mathbf{e}_{1}-\\mathbf{e}_{i+1})\\in\\mathbb{Z}^{\\xi+1}.</span> (17)</p>

    <p class="text-gray-300">By setting <span class="math">\\mathbf{H}=[\\mathbf{h}_{0}\\mid\\mathbf{h}_{1}\\mid\\cdots\\mid\\mathbf{h}_{\\xi}]</span> and <span class="math">\\mathbf{c}^{<em>}:=(c_{1}^{</em>},\\ldots,c_{\\xi}^{*})</span> the first part of the statement follows. As for the latter one, note that for <span class="math">\\mathbf{y}:=(\\mathbf{y}_{0},\\ldots,\\mathbf{y}_{\\xi})</span> and <span class="math">i\\in[\\xi]</span> we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}^{*}\\cdot(\\mathbf{h}_{i}^{\\top}\\otimes\\mathbf{I}_{r})\\cdot\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}^{<em>}\\cdot\\frac{1}{c_{i}^{</em>}}\\cdot(\\mathbf{y}_{0}-\\mathbf{y}_{i})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Relation. Let <span class="math">n, r_0, r_1, r_2 \\in \\mathbb{N}</span> and denote <span class="math">L = r_0r_1r_2n</span>. The difference from the previous protocol is that now we will consider different matrices <span class="math">\\mathbf{A}_1, \\mathbf{A}_2</span>, as this gives more flexibility when setting concrete parameters. The binding property follows straightforwardly as before. The relation we are interested in can be described as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{\\beta} := \\left\\{ \\left( \\begin{array}{c} \\mathrm{pp} := (q, d, n, \\alpha, r_0, r_1, r_2), \\\\ \\left((\\mathbf{A}_1, \\mathbf{A}_2), \\mathbf{t}, \\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2, u\\right), \\\\ \\left(\\mathbf{s}_1, \\mathbf{s}_2\\right) \\end{array} \\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\max_{i \\in [2]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta, \\\\ \\mathbf{t} = (\\mathbf{I}_{r_0} \\otimes \\mathbf{A}_1) \\cdot \\mathbf{s}_1, \\\\ \\mathbf{G}_{r_0r_1n} \\cdot \\mathbf{s}_1 = (\\mathbf{I}_{r_0r_1} \\otimes \\mathbf{A}_2) \\cdot \\mathbf{s}_2, \\\\ \\mathbf{x}_0^\\top \\cdot (\\mathbf{I}_{r_0} \\otimes \\mathbf{x}_1^\\top) \\cdot (\\mathbf{I}_{r_0r_1} \\otimes \\mathbf{x}_2^\\top) \\cdot \\mathbf{G}_{r_0r_1r_2n} \\cdot \\mathbf{s}_2 = u \\end{array} \\right\\}. \\tag{18}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">(\\mathbf{A}_1, \\mathbf{A}_2) \\in R_q^{n \\times r_1 n\\alpha} \\times R_q^{n \\times r_2 n\\alpha}</span>, <span class="math">(\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2) \\in R_q^{r_0} \\times R_q^{r_1} \\times R_q^{r_2 n}</span> and <span class="math">(\\mathbf{s}_1, \\mathbf{s}_2) \\in R_q^{r_0 r_1 n\\alpha} \\times R_q^{r_0 r_1 r_2 n\\alpha}</span>.</p>

    <p class="text-gray-300">Remark 2. Notice that we use a different indexing of the vector <span class="math">\\mathbf{x}_i</span> here compared to the one used in Section 5.</p>

    <h2 id="sec-44" class="text-2xl font-bold">A.1 Construction</h2>

    <p class="text-gray-300">In Figure 7 we provide a protocol for proving <span class="math">\\mathsf{R}_{\\beta}</span>. In the following, we provide intuition and prove completeness on the fly. The prover starts by sending <span class="math">\\mathbf{v}_0 \\in R_q^{r_0}</span>, where</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{v}_0 := \\left(\\mathbf{I}_{r_0} \\otimes \\mathbf{x}_1^\\top\\right) \\cdot \\left(\\mathbf{I}_{r_0r_1} \\otimes \\mathbf{x}_2^\\top\\right) \\cdot \\mathbf{G}_{r_0r_1r_2n} \\cdot \\mathbf{s}_2.</span></div>

    <p class="text-gray-300">The verifier checks whether</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x}_0^\\top \\cdot \\mathbf{v}_0 \\stackrel{?}{=} u.</span></div>

    <p class="text-gray-300">If so, it responds by outputting <span class="math">\\mathbf{c}_1 \\gets \\mathcal{C}^{r_0}</span>. Then, the prover computes</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{y}_1 := \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n\\alpha}\\right) \\cdot \\mathbf{s}_1 \\in R_q^{r_1n\\alpha} \\quad \\text{and} \\quad \\mathbf{e} := \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1r_2n\\alpha}\\right) \\cdot \\mathbf{s}_2 \\in R_q^{r_1r_2n\\alpha}.</span></div>

    <p class="text-gray-300">Before we describe the next move, we present certain properties of <span class="math">\\mathbf{y}_1</span> and <span class="math">\\mathbf{e}</span> by a sequence of claims. To derive all of them, we continuously apply the mixed-product property of Kronecker product.</p>

    <p class="text-gray-300">Claim. <span class="math">\\mathbf{A}_1 \\cdot \\mathbf{y}_1 = (\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_n) \\cdot \\mathbf{t}</span>.</p>

    <p class="text-gray-300">Proof. By definition of <span class="math">\\mathbf{y}_1</span>, we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{A}_1 \\cdot \\mathbf{y}_1 = \\left(\\mathbf{I}_1 \\otimes \\mathbf{A}_1\\right) \\cdot \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n\\alpha}\\right) \\cdot \\mathbf{s}_1 = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_n\\right) \\cdot \\left(\\mathbf{I}_{r_0} \\otimes \\mathbf{A}_1\\right) \\cdot \\mathbf{s}_1 = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_n\\right) \\cdot \\mathbf{t}.</span></div>

    <p class="text-gray-300">Claim. <span class="math">\\mathbf{G}_{r_1n} \\cdot \\mathbf{y}_1 = (\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2) \\cdot \\mathbf{e}</span>.</p>

    <p class="text-gray-300">Proof. By definition of <span class="math">\\mathbf{y}_1</span> and <span class="math">\\mathbf{e}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{G}_{r_1n} \\cdot \\mathbf{y}_1 = \\left(\\mathbf{I}_1 \\otimes \\mathbf{G}_{r_1n}\\right) \\cdot \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n\\alpha}\\right) \\cdot \\mathbf{s}_1 \\\\ = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n}\\right) \\cdot \\left(\\mathbf{I}_{r_0} \\otimes \\mathbf{G}_{r_1n}\\right) \\cdot \\mathbf{s}_1 \\\\ = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n}\\right) \\cdot \\mathbf{G}_{r_0r_1n} \\cdot \\mathbf{s}_1 \\\\ = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n}\\right) \\cdot \\left(\\mathbf{I}_{r_0r_1} \\otimes \\mathbf{A}_2\\right) \\cdot \\mathbf{s}_2 \\\\ = \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1n}\\right) \\cdot \\left(\\mathbf{I}_{r_0} \\otimes \\left(\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2\\right)\\right) \\cdot \\mathbf{s}_2 \\\\ = \\left(\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2\\right) \\cdot \\left(\\mathbf{c}_1^\\top \\otimes \\mathbf{I}_{r_1r_2n\\alpha}\\right) \\cdot \\mathbf{s}_2 \\\\ = \\left(\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2\\right) \\cdot \\mathbf{e}. \\end{array}</span></div>

    <p class="text-gray-300">Claim. <span class="math">\\mathbf{x}_1^\\top \\cdot (\\mathbf{I}_{r_1} \\otimes \\mathbf{x}_2^\\top) \\cdot \\mathbf{G}_{r_1r_2n} \\cdot \\mathbf{e} = \\mathbf{c}_1^\\top \\cdot \\mathbf{v}_0</span>.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 7. Interactive proof for the relation  <span class="math">\\mathsf{R}</span>  defined in Equation (18). Here, we define  <span class="math">l\\coloneqq \\lceil \\lambda /\\log q\\rceil</span></p>

    <p class="text-gray-300">Proof. Note that</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">$\\</p>

    <p class="text-gray-300">The verifier concludes by checking whether</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} _ {2} \\cdot \\mathbf {y} _ {2} \\stackrel {?} {=} (\\mathbf {c} _ {2} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\mathbf {G} _ {r _ {1} n} \\cdot \\mathbf {y} _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} _ {2} ^ {\\top} \\cdot \\mathbf {G} _ {r _ {2} n} \\cdot \\mathbf {y} _ {2} \\stackrel {?} {=} \\mathbf {c} _ {2} ^ {\\top} \\cdot \\mathbf {n} _ {1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {N} \\cdot \\mathbf {y} _ {2} \\stackrel {?} {=} (\\mathbf {c} _ {2} ^ {\\top} \\otimes \\mathbf {I} _ {l}) \\cdot \\left[ \\begin{array}{c} \\gamma_ {1, 1} \\\\ \\vdots \\\\ \\gamma_ {l, r _ {1}} \\end{array} \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {y} _ {2} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel {?} {\\leq} \\beta_ {2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We note that the first three equations follow directly from the mixed-product property, that is:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{A} \\cdot \\mathbf{y}_2 = \\mathbf{A} \\cdot (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_{r_2n\\alpha}) \\cdot \\mathbf{e} = (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_n) \\cdot (\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2) \\cdot \\mathbf{e} = (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_n) \\cdot \\mathbf{G}_{r_1n} \\cdot \\mathbf{y}_1,</span></li>

      <li><span class="math">\\mathbf{x}_2^\\top \\cdot \\mathbf{G}_{r_2n} \\cdot \\mathbf{y}_2 = \\mathbf{x}_2^\\top \\cdot \\mathbf{G}_{r_2n} \\cdot (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_{r_2n\\alpha}) \\cdot \\mathbf{e} = \\mathbf{x}_2^\\top \\cdot (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_{r_2n}) \\cdot \\mathbf{G}_{r_1r_2n} \\cdot \\mathbf{e} = \\mathbf{c}_2^\\top \\cdot (\\mathbf{I}_{r_1} \\otimes \\mathbf{x}_2^\\top) \\cdot \\mathbf{G}_{r_1r_2n} \\cdot \\mathbf{e} = \\mathbf{c}^\\top \\cdot \\mathbf{n}_1,</span></li>

      <li><span class="math">\\mathbf{N}\\cdot \\mathbf{y}_2 = \\mathbf{N}\\cdot (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_{r_2n\\alpha})\\cdot \\mathbf{e} = (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_l)\\cdot (\\mathbf{I}_{r_1}\\otimes \\mathbf{N}) = (\\mathbf{c}_2^\\top \\otimes \\mathbf{I}_l)\\cdot \\left[ \\begin{array}{c}\\gamma_{1,1}\\\\ \\vdots \\\\ \\gamma_{l,r_1} \\end{array} \\right].</span></li>

    </ol>

    <p class="text-gray-300">The norm bounds will be set appropriately to satisfy completeness.</p>

    <h2 id="sec-45" class="text-2xl font-bold">A.2 Completeness and Security Analysis</h2>

    <p class="text-gray-300">In this section we prove completeness and coordinate-wise special soundness.</p>

    <p class="text-gray-300"><strong>Lemma 5 (Completeness).</strong> Let  <span class="math">\\beta_{1} \\geq \\beta r_{0}\\kappa d, \\beta_{p} \\geq \\beta_{1}r_{2}n\\alpha d</span>  and  <span class="math">\\beta_{2} \\geq \\beta_{1}r_{1}\\kappa d</span> . Then, the protocol in Figure 7 for relation  <span class="math">\\mathsf{R}_{\\beta}</span>  satisfies completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> All the algebraic relations hold for an honest prover as described in the overview above. Hence, we only focus on the norm bound checks. Let us parse  <span class="math">\\mathbf{c}_i \\coloneqq (c_{i,1},\\ldots ,c_{i,r_{i - 1}})</span>  and  <span class="math">\\mathbf{s}_i \\coloneqq (\\mathbf{s}_{i,1},\\dots,\\mathbf{s}_{i,r_0})</span>  for  <span class="math">i = 1,2</span> . Then, by the triangle inequality we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {y} _ {1} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\mathbf {c} _ {1} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n \\alpha}\\right) \\cdot \\mathbf {s} _ {1} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 1} ^ {r _ {0}} c _ {1, i} \\cdot \\mathbf {s} _ {1, i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_ {i = 1} ^ {r _ {0}} \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {1, i} \\cdot \\mathbf {s} _ {1, i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta r _ {0} \\kappa d \\leq \\beta_ {1}. \\tag {23}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly,  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_1<span class="math"> . Next, we parse  </span>\\mathbf{e} \\coloneqq (\\mathbf{e}_1,\\dots ,\\mathbf{e}_{r_1})<span class="math">  and  </span>\\vec{c} \\coloneqq (\\vec{c}_1,\\dots ,\\vec{c}_{r_1})$ . Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {p} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(I _ {r _ {1}} \\otimes P) \\cdot \\vec {c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\max _ {i \\in [ r _ {1} ]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\cdot \\vec {c} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {1} r _ {2} n \\alpha d \\leq \\beta_ {p}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Finally,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {y} _ {2} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\mathbf {c} _ {2} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {2} n \\alpha}\\right) \\cdot \\mathbf {e} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {i = 1} ^ {r _ {1}} c _ {2, i} \\cdot \\mathbf {e} _ {i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_ {i = 1} ^ {r _ {1}} \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {2, i} \\cdot \\mathbf {e} _ {i} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta_ {1} r _ {1} \\kappa d \\leq \\beta_ {2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As standard in lattice-based proof systems, we define an extractor which finds a witness w.r.t. a relaxed relation – here we define it as:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf {R} _ {\\beta , \\eta} ^ {*} := \\left\\{\\left( \\begin{array}{c} \\mathsf {p p} := (q, d, n, \\alpha , r _ {0}, r _ {1}, r _ {2}), \\\\ ((\\mathbf {A} _ {1}, \\mathbf {A} _ {2}), \\mathbf {t}, \\mathbf {x} _ {0}, \\mathbf {x} _ {1}, \\mathbf {x} _ {2}, u), \\\\ (\\mathbf {s} _ {1}, \\mathbf {s} _ {2}, \\mathbf {c}) \\end{array} \\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\max  _ {i \\in [ 2 ], j \\in [ r _ {0} ]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} \\cdot \\mathbf {s} _ {i, j} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta , \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\eta , \\\\ \\mathbf {c} \\in (R _ {q} ^ {\\times}) ^ {r _ {0}}, \\mathbf {t} = (\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {A} _ {1}) \\cdot \\mathbf {s} _ {1}, \\\\ \\mathbf {G} _ {r _ {0} r _ {1} n} \\cdot \\mathbf {s} _ {1} = (\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {A} _ {2}) \\cdot \\mathbf {s} _ {2}, \\\\ \\mathbf {x} _ {0} ^ {\\top} \\cdot (\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}) \\cdot (\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top}) \\cdot \\mathbf {G} _ {r _ {0} r _ {1} r _ {2} n} \\cdot \\mathbf {s} _ {2} = u \\end{array} \\right. \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where we denote  <span class="math">\\mathbf{s}_i\\coloneqq (\\mathbf{s}_{i,1},\\dots ,\\mathbf{s}_{i,r_0})</span>  for  <span class="math">i = 1,2</span>  and  <span class="math">\\mathbf{c}\\coloneqq (c_{1},\\ldots ,c_{r_{0}})</span> . The witness now consists of a vector of invertible scalars  <span class="math">\\mathbf{c}\\in (R_q^\\times)^{r_0}</span>  of small norm such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j\\cdot \\mathbf{s}_{i,j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is short for  </span>i = 1,2<span class="math">  and  </span>j\\in [r_0]<span class="math"> . In particular, the vectors  </span>\\mathbf{s}_1,\\mathbf{s}_2<span class="math">  do not need to be short anymore. Similar reasoning as in [ALS20] can be applied to show that the commitment scheme is binding w.r.t. relaxed openings  </span>(\\mathbf{s}_1,\\mathbf{s}_2,c)$  under the Module-SIS assumption.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">32</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 6 (Relaxed Binding). Let  <span class="math">\\mathsf{pp} := (q, d, n, \\alpha, r_0, r_1, r_2)</span>  and  <span class="math">x := ((\\mathbf{A}_1, \\mathbf{A}_2), \\mathbf{t}, \\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2, u)</span> . Given two tuples  <span class="math">w := (\\mathbf{s}_1, \\mathbf{s}_2, \\mathbf{c})</span>  and  <span class="math">w&#x27; := (\\mathbf{s}_1&#x27;, \\mathbf{s}_2&#x27;, \\mathbf{c}&#x27;)</span>  such that  <span class="math">(\\mathsf{pp}, x, w), (\\mathsf{pp}, x, w&#x27;) \\in \\mathsf{R}_{\\beta, \\eta}^*</span>  and  <span class="math">\\mathbf{s}_i \\neq \\mathbf{s}_i&#x27;</span>  for some  <span class="math">i \\in [2]</span> , there is an efficient deterministic algorithm which finds a non-zero vector  <span class="math">\\mathbf{z} \\in R_q^{r_1n\\alpha}</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\eta\\beta d<span class="math">  and  </span>\\mathbf{A}_i \\cdot \\mathbf{z} = \\mathbf{0}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. We start with a trivial observation that finding a short, non-zero solution to  <span class="math">(\\mathbf{I}_{r_0\\dots r_{i - 1}}\\otimes \\mathbf{A}_i)</span>  directly implies finding a short and non-zero solution to  <span class="math">\\mathbf{A}_i</span></p>

    <p class="text-gray-300">Suppose  <span class="math">i = 1</span> , say  <span class="math">\\mathbf{s}_{1,j} \\neq \\mathbf{s}_{1,j}&#x27;</span>  for some  <span class="math">j \\in [r_0]</span> . Then, by definition of  <span class="math">\\mathsf{R}_{\\beta,\\eta}^*</span>  we have  <span class="math">\\mathbf{A}_1 \\cdot (\\mathbf{s}_{1,j} - \\mathbf{s}_{1,j}&#x27;) = \\mathbf{0}</span> . Also, since  <span class="math">c_j, c_j&#x27;</span>  are invertible,  <span class="math">c_j \\cdot c_j&#x27; \\cdot (\\mathbf{s}_{1,j} - \\mathbf{s}_{1,j}&#x27;)</span>  is non-zero. Hence, to conclude we notice that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} \\cdot c _ {j} ^ {\\prime} \\cdot \\left(\\mathbf {s} _ {1, j} - \\mathbf {s} _ {1, j} ^ {\\prime}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} ^ {\\prime} \\cdot \\left(c _ {j} \\cdot \\mathbf {s} _ {1, j}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {j} \\cdot \\left(c _ {j} ^ {\\prime} \\cdot \\mathbf {s} _ {1, j} ^ {\\prime}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\eta \\beta d.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now assume that  <span class="math">\\mathbf{s}_1 = \\mathbf{s}_1&#x27;</span>  and  <span class="math">\\mathbf{s}_2 \\neq \\mathbf{s}_2&#x27;</span>  - say  <span class="math">\\mathbf{s}_{2,j} \\neq \\mathbf{s}_{2,j}&#x27;</span>  for some  <span class="math">j \\in [r_0]</span> . Note that we have  <span class="math">(\\mathbf{I}_{r_1} \\otimes \\mathbf{A}_2) \\cdot (\\mathbf{s}_{2,j} - \\mathbf{s}_{2,j}&#x27;) = \\mathbf{0}</span> . Using the same argument as before, we deduce that  <span class="math">c_j \\cdot c_j&#x27; \\cdot (\\mathbf{s}_{2,j} - \\mathbf{s}_{2,j}&#x27;)</span>  is non-zero and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_j \\cdot c_j' \\cdot (\\mathbf{s}_{2,j} - \\mathbf{s}_{2,j}') \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\eta\\beta d$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We focus on coordinate-wise special soundness with respect to the relaxed relation above. Note that having the verifier sample  <span class="math">P \\gets \\chi^{\\lambda \\times r_2n\\alpha d}</span>  is the same as generating a uniformly random binary matrix  $[P_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_1] \\gets \\{0,1\\}^{\\lambda \\times 2r_2n\\alpha d}<span class="math"> , and then both the prover and verifier computing  </span>P \\coloneqq P_0 - P_1<span class="math"> . We will use this modification when arguing coordinate-wise special soundness. In this case, we think of the challenge being sampled from  </span>(\\{0,1\\}^{\\lambda})^{2r_2n\\alpha d}<span class="math"> , i.e. there are  </span>2r_2n\\alpha d$  coordinates.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 7 (Coordinate-Wise Special Soundness). Let the protocol in Figure 7 be a nine-round public-coin interactive proof with challenge spaces  <span class="math">\\mathcal{C}^{r_0}</span> ,  <span class="math">(\\{0,1\\}^{\\lambda})^{2r_2n\\alpha d}</span> ,  <span class="math">(\\mathbb{Z}_q^l)^\\lambda</span>  and  <span class="math">\\mathcal{C}^{r_1}</span> . Fix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {p p} := (q, d, n, \\alpha , r _ {0}, r _ {1}, r _ {2}) \\quad a n d \\quad x := ((\\mathbf {A} _ {1}, \\mathbf {A} _ {2}), \\mathbf {t}, \\mathbf {x} _ {0}, \\mathbf {x} _ {1}, \\mathbf {x} _ {2}, u).</span></div>

    <p class="text-gray-300">Then, the protocol is coordinate-wise special sound for relation  <span class="math">\\mathsf{R}_{2\\max (\\beta_1,\\beta_p),2\\kappa}^*</span>  under the MSIS  <span class="math">n,r_2n\\alpha ,q,d,8\\kappa \\beta_2d</span>  assumption on matrix  <span class="math">\\mathbf{A}_2</span></p>

    <p class="text-gray-300">Proof. We follow Definition 11 and implicitly define the extractor Ext via the sequence of claims below.</p>

    <p class="text-gray-300">Claim. There is an efficient deterministic algorithm that, given as input  <span class="math">\\mathsf{pp}, x</span>  and  <span class="math">r_1 + 1</span>  transcripts  <span class="math">\\pi_0, \\ldots, \\pi_{r_1}</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {k} := (\\mathbf {v} _ {0}, \\mathbf {c} _ {1}, (\\mathbf {y} _ {1}, \\mathbf {v} _ {1}), (P _ {0}, P _ {1}), \\vec {p}, B, (\\gamma_ {i, j}) _ {i, j}, \\mathbf {c} _ {2} ^ {(k)}, \\mathbf {y} _ {2} ^ {(k)}),</span></div>

    <p class="text-gray-300">where  <span class="math">(\\mathbf{c}_2^{(0)},\\ldots ,\\mathbf{c}_2^{(r_1)})\\in \\varGamma (\\mathcal{C},r_1)</span> , such that  <span class="math">\\mathcal{V}_0(\\mathsf{pp},x,\\pi_k) = 1</span>  for all  <span class="math">k = 0,1,\\dots,r_1</span> , outputs a tuple  <span class="math">(\\pi^{<em>},\\mathbf{e}^{</em>},\\mathbf{c}_{2}^{<em>})</span>  for which  <span class="math">\\mathcal{V}_1(\\mathsf{pp},x,\\pi^</em>,(\\mathbf{e}^<em>,\\mathbf{c}_2^</em>)) = 1</span> .</p>

    <p class="text-gray-300">Proof. By Lemma 4 we can find a matrix  <span class="math">\\mathbf{H} \\in R_q^{(r_1 + 1) \\times r_1}</span>  and a vector  <span class="math">\\mathbf{c}_2^* \\in (R_q^\\times)^{r_1}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ \\mathbf {c} _ {2} ^ {(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c} _ {2} ^ {(r _ {1})} ] \\cdot \\mathbf {H} = \\mathbf {I} _ {r _ {1}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{2,i}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\kappa<span class="math">  for all  </span>i\\in [r_1]$ . Hence,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\left[ \\begin{array}{c} (\\mathbf {c} _ {2} ^ {(0)} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\\\ \\vdots \\\\ (\\mathbf {c} _ {2} ^ {(r _ {1}) ^ {\\top}} \\otimes \\mathbf {I} _ {n}) \\end{array} \\right] \\cdot \\mathbf {G} _ {r _ {1} n} \\cdot \\mathbf {y} _ {1} = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\left(\\left[ \\begin{array}{c} \\mathbf {c} _ {2} ^ {(0)} ^ {\\top} \\\\ \\vdots \\\\ \\mathbf {c} _ {2} ^ {(r _ {1}) ^ {\\top}} \\end{array} \\right] \\otimes \\mathbf {I} _ {n}\\right) \\cdot \\mathbf {G} _ {r _ {1} n} \\cdot \\mathbf {y} _ {1} = \\mathbf {G} _ {r _ {1} n} \\cdot \\mathbf {y} _ {1}.</span></div>

    <p class="text-gray-300">Moreover, by the verification equations in  <span class="math">\\mathcal{V}_0</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\left[ \\begin{array}{c} (\\mathbf {c} _ {2} ^ {(0)} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\\\ \\vdots \\\\ (\\mathbf {c} _ {2} ^ {(r _ {1}) ^ {\\top}} \\otimes \\mathbf {I} _ {n}) \\end{array} \\right] \\cdot \\mathbf {G} _ {r _ {1} n} \\cdot \\mathbf {y} _ {1} = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot (\\mathbf {I} _ {r _ {1} + 1} \\otimes \\mathbf {A} _ {2}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {2} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {2} ^ {(r _ {1})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {A} _ {2}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {2} n \\alpha}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {2} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {2} ^ {(r _ {1})} \\end{array} \\right]. \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V0(pp, x, π)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V1(pp, x, π·(e*, e2))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: Parse π := (v0, c1, (y1, v1), (P0, P1), p, B, (γi,j)i,j, c2, y2)</td>

            <td class="px-3 py-2 border-b border-gray-700">1: Parse e<em> := (e1</em>, ..., e<em>1) and c2</em> := (c2<em>, 1, ..., c2</em>, r1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: P := P0 - P1</td>

            <td class="px-3 py-2 border-b border-gray-700">2: Parse π := (v0, c1, (y1, v1), (P0, P1), p, B, (γi,j)i,j)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: Parse B := (b1<em>)i∈[0], B · P := (∇1</em>)i∈[0]</td>

            <td class="px-3 py-2 border-b border-gray-700">3: P := P0 - P1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: Parse p := (p1<em>, ..., p</em>1)</td>

            <td class="px-3 py-2 border-b border-gray-700">4: Parse B := (b1<em>)i∈[0], B · P := (∇1</em>)i∈[0]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: V := (σ-1(v))i∈[0]</td>

            <td class="px-3 py-2 border-b border-gray-700">5: Parse p := (p1<em>, ..., p</em>1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6: γ := [γ1,1, ..., γ1,r1]</td>

            <td class="px-3 py-2 border-b border-gray-700">6: V := (σ-1(v))i∈[0]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7: Return 1 if all the following hold:</td>

            <td class="px-3 py-2 border-b border-gray-700">7: γ := [γ1,1, ..., γ1,r1]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8: x0* · v0 = u1</td>

            <td class="px-3 py-2 border-b border-gray-700">8: Return 1 if all the following hold:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9: x1<em> · v1 = c1</em> · v0,</td>

            <td class="px-3 py-2 border-b border-gray-700">9: x0* · v0 = u1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10: x2<em> · Gr2n · y2 = c2</em> · v1,</td>

            <td class="px-3 py-2 border-b border-gray-700">10: x1<em> · v1 = c1</em> · v0,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11: ∀i ∈ [0], j ∈ [r1], γi,j = (b1, pj),</td>

            <td class="px-3 py-2 border-b border-gray-700">11: ∀i ∈ [0], j ∈ [r1], γi,j = (b1, pj),</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12: A1 · y1 = (c1* ⊗ L) · t,</td>

            <td class="px-3 py-2 border-b border-gray-700">12: A1 · y1 = (c1* ⊗ L) · t,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13: A2 · y2 = (c2* ⊗ L) · Gr1n · y1,</td>

            <td class="px-3 py-2 border-b border-gray-700">13:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ β1,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ βp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14: V · y2 = (c2* ⊗ L) · γ,</td>

            <td class="px-3 py-2 border-b border-gray-700">14: (L1 ⊗ A2) · e* = Gr1n · y1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ β1,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ βp,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ β2</td>

            <td class="px-3 py-2 border-b border-gray-700">15: {L1 ⊗ x2<em> · Gr2n} · e</em> = v1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  16: Else, return 0 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V2(pp, x, π, (e*, e2))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16: (L1 ⊗ V) · e* = [γ1,1]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: Parse π := (v0, c1, (y1, v1), (P0, P1), p)</td>

            <td class="px-3 py-2 border-b border-gray-700">17: ∀ ∈ [r1],</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">c1<em> · e</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2β2 and</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">c1*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2κ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: P := P0 - P1</td>

            <td class="px-3 py-2 border-b border-gray-700">18: Else, return 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: Return 1 if all the following hold:</td>

            <td class="px-3 py-2 border-b border-gray-700">V0(pp, x, π, e*)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: x0* · v0 = u1</td>

            <td class="px-3 py-2 border-b border-gray-700">1: Parse e<em> := (e1</em>, ..., e*1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6: x1<em> · v1 = c1</em> · v0,</td>

            <td class="px-3 py-2 border-b border-gray-700">2: Parse π := (v0, c1, (y1, v1))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7: A1 · y1 = (c1* ⊗ L) · t,</td>

            <td class="px-3 py-2 border-b border-gray-700">3: Return 1 if all the following hold:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ β1,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ βp</td>

            <td class="px-3 py-2 border-b border-gray-700">4: x0* · v0 = u1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9: (L1 ⊗ x2<em> · Gr2n) · e</em> = v1</td>

            <td class="px-3 py-2 border-b border-gray-700">5: x1<em> · v1 = c1</em> · v0,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10: (L1 ⊗ x2<em> · Gr2n) · e</em> = v1</td>

            <td class="px-3 py-2 border-b border-gray-700">6: A1 · y1 = (c1* ⊗ L) · t,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11: (L1 ⊗ P) · ∇* = p</td>

            <td class="px-3 py-2 border-b border-gray-700">7:</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ β1,</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">e*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2βp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12: ∀ ∈ [r1],</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">c2<em>, i · e</em></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2β2 and</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">c2*, i</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤ 2κ</td>

            <td class="px-3 py-2 border-b border-gray-700">8: (L1 ⊗ A2) · e* = Gr1n · y1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13: Else, return 0</td>

            <td class="px-3 py-2 border-b border-gray-700">9: {L1 ⊗ x2<em> · Gr2n} · e</em> = v1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | 10: Else, return 0  |</p>

    <p class="text-gray-300">Fig. 8. Partial verification algorithms used for the proof of coordinate-wise special soundness.</p>

    <p class="text-gray-300">Hence, define</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {e} ^ {*} := \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {2} n \\alpha}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {2} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {2} ^ {(r _ {1})} \\end{array} \\right] \\in R _ {q} ^ {r _ {1} r _ {2} n \\alpha}</span></div>

    <p class="text-gray-300">and split  <span class="math">\\mathbf{e}^{<em>} = (\\mathbf{e}_{1}^{</em>},\\dots ,\\mathbf{e}_{r_{1}}^{*})</span>  . Then, again by Lemma 4 we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {2, i} ^ {<em>} \\cdot \\mathbf {e} _ {i} ^ {</em>} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {2, i} ^ {*} \\cdot (\\mathbf {h} _ {i} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {2} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {2} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {2} ^ {(r _ {1})} \\end{array} \\right] \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {y} _ {2} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\beta_ {2}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Thus, the algorithm outputs</p>

    <div class="my-4 text-center"><span class="math-block">\\pi^ {*} := \\left(\\mathbf {v} _ {0}, \\mathbf {c} _ {1}, \\left(\\mathbf {y} _ {1}, \\mathbf {v} _ {1}\\right), \\left(P _ {0}, P _ {1}\\right), \\vec {p}, B, \\left(\\gamma_ {i, j}\\right) _ {i, j}\\right), \\quad \\left(\\mathbf {e} ^ {*}, \\mathbf {c} _ {2} ^ {*}\\right).</span></div>

    <p class="text-gray-300">Similarly as done above, one can check that all the verification equations in  <span class="math">\\mathcal{V}_1</span>  are satisfied.</p>

    <p class="text-gray-300">Claim. There is an efficient deterministic algorithm that, given as input  <span class="math">\\mathsf{pp}</span> ,  <span class="math">x</span>  and  <span class="math">\\lambda + 1</span>  tuples  <span class="math">\\left(\\pi_k, \\mathbf{e}^{<em>(k)}, \\mathbf{c}_2^{</em>(k)}\\right)_{0 \\leq k \\leq \\lambda}</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {k} := \\left(\\mathbf {v} _ {0}, \\mathbf {c} _ {1}, \\left(\\mathbf {y} _ {1}, \\mathbf {v} _ {1}\\right), \\left(P _ {0}, P _ {1}\\right), \\vec {p}, B ^ {(k)}, \\left(\\gamma_ {i, j} ^ {(k)}\\right) _ {i, j}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and  <span class="math">(B^{(0)},\\ldots ,B^{(\\lambda)})\\in \\Gamma (\\mathbb{Z}_q^l,\\lambda)</span>  such that  <span class="math">\\mathcal{V}_1\\left(\\mathsf{pp},x,\\pi_k,\\mathbf{e}^{<em>(k)},\\mathbf{c}_2^{</em>(k)}\\right) = 1</span>  for all  <span class="math">k = 0,1,\\dots ,\\lambda</span>  , either outputs a tuple  <span class="math">(\\pi^{<em>},\\mathbf{e}^{</em>},\\mathbf{c}_{2}^{<em>})</span>  for which  <span class="math">\\mathcal{V}_2(\\mathsf{pp},x,\\pi^</em>,(\\mathbf{e}^<em>,\\mathbf{c}_2^</em>)) = 1</span>  , or a non-zero vector  <span class="math">\\mathbf{z}</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 8\\kappa \\beta_{2}d<span class="math">  and  </span>\\mathbf{A}_2\\cdot \\mathbf{z} = \\mathbf{0}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. First of all, if there exist some  <span class="math">i \\neq j</span>  such that  <span class="math">\\mathbf{e}^{<em>(i)} = \\mathbf{e}^{</em>(j)}</span> , then by arguing as in Lemma 6 we can find a short non-zero solution  <span class="math">\\mathbf{z}</span>  to  <span class="math">\\mathbf{A}_2</span>  of norm at most  <span class="math">8\\kappa \\beta_2 d</span> . Otherwise, define  <span class="math">\\mathbf{e}^<em> := \\mathbf{e}^{</em>(0)} = \\ldots = \\mathbf{e}^{<em>(\\lambda)}</span>  and  <span class="math">\\mathbf{c}_2^</em> := \\mathbf{c}_2^{*(0)}</span> . We</p>

    <p class="text-gray-300">only need to show that</p>

    <p class="text-gray-300"><span class="math">(I_{r_{1}}\\otimes P)\\cdot\\overrightarrow{e}^{*}=\\overrightarrow{p}.</span></p>

    <p class="text-gray-300">To this end, assume that for some <span class="math">j\\in[r_{1}]</span> we have <span class="math">P\\cdot\\overrightarrow{e}_{j}^{<em>}\\neq\\overrightarrow{p}_{j}</span> and let <span class="math">i\\in[\\lambda]</span> be the index for which <span class="math">\\overrightarrow{\\varphi}_{i}^{\\top}\\cdot\\overrightarrow{e}_{j}^{</em>}\\neq p_{j,i}</span>, where <span class="math">\\overrightarrow{\\varphi}_{j}^{\\top}</span> is the <span class="math">i</span>-th row of <span class="math">P</span>.</p>

    <p class="text-gray-300">Suppose without loss of generality that <span class="math">B^{(0)}</span> and <span class="math">B^{(i)}</span> differ exactly in the <span class="math">i</span>-th column, say position <span class="math">t\\in[l]</span>. From verification equations of <span class="math">\\mathcal{V}_{1}</span> and the relationship between constant coefficients of <span class="math">R_{q}</span> elements and inner products over <span class="math">\\mathbb{Z}_{q}</span> we know that</p>

    <p class="text-gray-300"><span class="math">B^{(0)}\\cdot(\\overrightarrow{p}_{j}-P\\cdot\\overrightarrow{e}_{j})=\\overrightarrow{0}\\quad\\text{and}\\quad B^{(i)}\\cdot(\\overrightarrow{p}_{j}-P\\cdot\\overrightarrow{e}_{j})=\\overrightarrow{0}.</span></p>

    <p class="text-gray-300">By subtracting the two equations, and focusing on the <span class="math">t</span>-th row of <span class="math">B^{(0)}-B^{(i)}</span>, we note that</p>

    <p class="text-gray-300"><span class="math">(B^{(0)}[i,t]-B^{(i)}[i,t])\\cdot(p_{j,i}-\\overrightarrow{\\varphi}_{i}^{\\top}\\cdot\\overrightarrow{e}_{j}^{*})=0.</span></p>

    <p class="text-gray-300">Since <span class="math">B^{(0)}[i,t]-B^{(i)}[i,t]\\in\\mathbb{Z}_{q}^{\\times}</span>, we deduce that <span class="math">p_{j,i}=\\overrightarrow{\\varphi}_{i}^{\\top}\\cdot\\overrightarrow{e}_{j}^{*}</span> which leads to a contradiction. ∎</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Claim.</h6>

    <p class="text-gray-300">There is an efficient deterministic algorithm that, given as input <span class="math">\\mathsf{pp}</span>, <span class="math">x</span> and <span class="math">2r_{2}n\\alpha d</span> tuples <span class="math">\\left(\\pi_{k},\\mathbf{e}^{<em>(k)},\\mathbf{c}_{2}^{</em>(k)}\\right)_{0\\leq k\\leq 2r_{2}n\\alpha d}</span>:</p>

    <p class="text-gray-300"><span class="math">\\pi_{k}:=(\\mathbf{v}_{0},\\mathbf{c}_{1},(\\mathbf{y}_{1},\\mathbf{v}_{1}),(P_{0}^{(k)},P_{1}^{(k)}),\\overrightarrow{p}^{k})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\text{where}\\quad([P_{0}^{(0)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{1}^{(0)}],\\ldots,[P_{0}^{(2r_{2}n\\alpha d)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{1}^{(2r_{2}n\\alpha d)}])\\in\\Gamma(\\{0,1\\}^{\\lambda},2r_{2}n\\alpha d),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">such that <span class="math">\\mathcal{V}_{2}(\\mathsf{pp},x,\\pi_{k},\\mathbf{e}^{<em>(k)},\\mathbf{c}_{2}^{</em>(k)})</span> for all <span class="math">k=0,1,\\ldots,2r_{2}n\\alpha d</span>, either outputs a pair <span class="math">(\\pi^{<em>},\\mathbf{e}^{</em>})</span> for which <span class="math">\\mathcal{V}_{3}(\\mathsf{pp},x,\\pi^{<em>},\\mathbf{e}^{</em>})=1</span>, or a non-zero vector <span class="math">\\mathbf{z}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{z}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 8\\kappa\\beta_{2}d<span class="math"> and </span>\\mathbf{A}_{2}\\cdot\\mathbf{z}=\\mathbf{0}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-47" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly as above, we can only focus on the case <span class="math">\\mathbf{e}^{<em>}:=\\mathbf{e}^{</em>(0)}=\\ldots=\\mathbf{e}^{*(\\lambda)}</span>. To conclude the claim, we need to show that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{e}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overrightarrow{e}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_{p}<span class="math">. Suppose for some </span>j\\in[r_{1}]<span class="math"> we have </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overrightarrow{e}_{j}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{j,i}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2\\beta_{p}<span class="math"> for some </span>i\\in[r_{2}n\\alpha d]<span class="math">. Assume without loss of generality that </span>[P_{0}^{(0)}\\mid P_{1}^{(0)}]<span class="math"> and </span>[P_{0}^{(i)}\\mid P_{1}^{(i)}]<span class="math"> differ exactly in the </span>i<span class="math">-th column, say position </span>t\\in[\\lambda]<span class="math">. Since </span>i\\leq r_{2}n\\alpha d<span class="math">, we have </span>P_{1}^{(0)}=P_{1}^{(i)}<span class="math">. Next, from the verification equations for </span>\\mathcal{V}_{2}$ we know that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(P_{0}^{(0)}-P_{1}^{(0)})\\cdot\\overrightarrow{e}_{j}^{<em>}=\\overrightarrow{p}_{j}^{(0)}\\quad\\text{and}\\quad(P_{0}^{(i)}-P_{1}^{(i)})\\cdot\\overrightarrow{e}_{j}^{</em>}=\\overrightarrow{p}_{j}^{(i)}.</span></p>

    <p class="text-gray-300">By subtracting the two equations we obtain</p>

    <p class="text-gray-300"><span class="math">(P_{0}^{(0)}-P_{0}^{(i)})\\cdot\\overrightarrow{e}_{j}^{*}=\\overrightarrow{p}_{j}^{(0)}-\\overrightarrow{p}_{j}^{(i)}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Looking at the <span class="math">t</span>-th row of <span class="math">P_{0}^{(0)}-P_{0}^{(i)}</span>, it is equal, up to a sign, to the unit vector with <span class="math">1</span> in the <span class="math">i</span>-th position and <span class="math">0</span> everywhere else. This means that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{j,i}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{j,i}^{(0)}-p_{j,i}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_{p}$ which yields a contradiction. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To conclude the proof of coordinate-wise special soundness, consider having <span class="math">r_{0}+1</span> tuples <span class="math">(\\pi_{k},\\mathbf{e}^{*(k)})_{0\\leq k\\leq r_{0}}</span>, where we denote</p>

    <p class="text-gray-300"><span class="math">\\pi_{k}:=(\\mathbf{v}_{0},\\mathbf{c}_{1}^{(k)},(\\mathbf{y}_{1}^{(k)},\\mathbf{v}_{1}^{(k)})),</span></p>

    <p class="text-gray-300">such that <span class="math">\\mathcal{V}_{3}(\\mathsf{pp},x,\\pi_{k},\\mathbf{e}^{<em>(k)})</span> for all <span class="math">k=0,1,\\ldots,r_{0}</span>. First, by Lemma 4 we can find a matrix <span class="math">\\mathbf{H}\\in R_{q}^{(r_{0}+1)\\times r_{0}}</span> and a vector <span class="math">\\mathbf{c}_{1}^{</em>}\\in(R_{q}^{\\times})^{r_{0}}</span> such that</p>

    <p class="text-gray-300"><span class="math">[\\mathbf{c}_{1}^{(0)}\\mid\\cdots\\mid\\mathbf{c}_{1}^{(r_{0})}]\\cdot\\mathbf{H}=\\mathbf{I}_{r_{0}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{1,i}^{*}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\kappa<span class="math">  for all  </span>i\\in [r_0]<span class="math"> . Hence, from the verification equations for  </span>\\nu_{3}$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} (\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {A} _ {1}) \\cdot (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot (\\mathbf {I} _ {r + 1} \\otimes \\mathbf {A} _ {1}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] \\\\ = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\left[ \\begin{array}{c} (\\mathbf {c} _ {1} ^ {(0) ^ {\\top}} \\otimes \\mathbf {I} _ {n}) \\\\ \\vdots \\\\ (\\mathbf {c} _ {1} ^ {(r _ {1}) ^ {\\top}} \\otimes \\mathbf {I} _ {n}) \\end{array} \\right] \\cdot \\mathbf {t} \\\\ = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {n}) \\cdot \\left(\\left[ \\begin{array}{c} \\mathbf {c} _ {1} ^ {(0) ^ {\\top}} \\\\ \\vdots \\\\ \\mathbf {c} _ {1} ^ {(r _ {1}) ^ {\\top}} \\end{array} \\right] \\otimes \\mathbf {I} _ {n}\\right) \\cdot \\mathbf {t} \\\\ = \\mathbf {t}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, we set the extracted witness:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} _ {1} ^ {*} := (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] \\quad \\text {a n d} \\quad \\mathbf {s} _ {2} ^ {*} := (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} r _ {2} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right].</span></div>

    <p class="text-gray-300">Indeed, note that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {G} _ {r _ {0} r _ {1} n} \\cdot \\mathbf {s} _ {1} ^ {*} = (\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {G} _ {r _ {1} n}) \\cdot (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] \\\\ = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n}) \\cdot (\\mathbf {I} _ {r + 1} \\otimes \\mathbf {G} _ {r _ {1} n}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] \\\\ = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n}) \\cdot \\left[ \\begin{array}{c} (\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {A} _ {2}) \\cdot \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ (\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {A} _ {2}) \\cdot \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = (\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n}) \\cdot (\\mathbf {I} _ {r _ {0} + 1} \\otimes (\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {A} _ {2})) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {A} _ {2}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} r _ {2} n \\alpha}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {A} _ {2}\\right) \\cdot \\mathbf {s} _ {2} ^ {*}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Next, we need to show that  <span class="math">\\mathbf{x}_0^\\top \\cdot (\\mathbf{I}_{r_0} \\otimes \\mathbf{x}_1^\\top) \\cdot (\\mathbf{I}_{r_0 r_1} \\otimes \\mathbf{x}_2^\\top) \\cdot \\mathbf{G}_{r_0 r_1 r_2 n} \\cdot \\mathbf{s}_2 = u</span> . Since we know that  <span class="math">\\mathbf{t}_0^\\top \\cdot \\mathbf{v}_0 = u</span> , it is sufficient to show that  <span class="math">(\\mathbf{I}_{r_0} \\otimes \\mathbf{x}_1^\\top) \\cdot (\\mathbf{I}_{r_0 r_1} \\otimes \\mathbf{x}_2^\\top) \\cdot \\mathbf{G}_{r_0 r_1 r_2 n} \\cdot \\mathbf{s}_2 = \\mathbf{v}_0</span> . By the verification equations of  <span class="math">\\mathcal{V}_3</span>  we get:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top}\\right) \\cdot \\mathbf {G} _ {r _ {0} r _ {1} r _ {2} n} \\cdot \\mathbf {s} _ {2} ^ {*} \\\\ = \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top}\\right) \\cdot \\mathbf {G} _ {r _ {0} r _ {1} r _ {2} n} \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} r _ {2} n \\alpha}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} r _ {2} n}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} + 1} \\otimes \\mathbf {G} _ {r _ {1} r _ {2} n}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1}}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} + 1} \\otimes \\left(\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top}\\right)\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} + 1} \\otimes \\mathbf {G} _ {r _ {1} r _ {2} n}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1}}\\right) \\cdot \\left(\\mathbf {I} _ {r _ {0} + 1} \\otimes \\left(\\mathbf {I} _ {r _ {1}} \\otimes \\mathbf {x} _ {2} ^ {\\top} \\mathbf {G} _ {r _ {1} r _ {2} n}\\right)\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {e} ^ {* (0)} \\\\ \\vdots \\\\ \\mathbf {e} ^ {* (r _ {0})} \\end{array} \\right] \\\\ = \\left(\\mathbf {I} _ {r _ {0}} \\otimes \\mathbf {x} _ {1} ^ {\\top}\\right) \\cdot \\left(\\mathbf {H} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1}}\\right) \\cdot \\left[ \\begin{array}{c} \\mathbf {v} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {v} _ {1} ^ {(r _ {0})} \\end{array} \\right] \\\\ = \\mathbf {H} ^ {\\top} \\cdot (\\mathbf {I} _ {r _ {0} + 1} \\otimes \\mathbf {x} _ {1} ^ {\\top}) \\cdot \\left[ \\begin{array}{c} \\mathbf {v} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {v} _ {1} ^ {(r _ {0})} \\end{array} \\right] \\\\ = \\mathbf {H} ^ {\\top} \\cdot \\left[ \\begin{array}{c} \\mathbf {c} _ {1} ^ {(0) ^ {\\top}} \\\\ \\vdots \\\\ \\mathbf {c} _ {1} ^ {(r _ {0}) ^ {\\top}} \\end{array} \\right] \\cdot \\mathbf {v} _ {0} \\\\ = \\mathbf {v} _ {0}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Finally, we show the norm bounds. Let us split  <span class="math">\\mathbf{s}_i^<em> \\coloneqq (\\mathbf{s}_{i,1}^</em>, \\ldots, \\mathbf{s}_{i,r_0}^*)</span>  for  <span class="math">i = 1,2</span> . Then, by Lemma 4 for  <span class="math">j \\in [r_0]</span>  we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {1, j} ^ {<em>} \\cdot \\mathbf {s} _ {1, j} ^ {</em>} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {1, j} ^ {*} \\cdot (\\mathbf {h} _ {j} ^ {\\top} \\otimes \\mathbf {I} _ {r _ {1} n \\alpha}) \\cdot \\left[ \\begin{array}{c} \\mathbf {y} _ {1} ^ {(0)} \\\\ \\vdots \\\\ \\mathbf {y} _ {1} ^ {(r _ {1})} \\end{array} \\right] \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\beta_ {1}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, we show that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{1,j}^{<em>}\\cdot \\mathbf{s}_{2,j}^{</em>}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_{p}$ . Therefore, we conclude that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {p p}, x, \\left(\\mathbf {s} _ {1} ^ {*}, \\mathbf {s} _ {2} ^ {*}, \\mathbf {c} _ {1} ^ {*}\\right)\\right) \\in \\mathsf {R} _ {2 \\max  \\left(\\beta_ {1}, \\beta_ {p}\\right), 2 \\kappa} ^ {s}.</span></div>

    <p class="text-gray-300">We highlight that, in a concrete instantiation, matrix  <span class="math">\\mathbf{A}_2</span>  will be uniformly random. This means that the extraction algorithms will either extract the (partial) witnesses, or find a valid Module-SIS solution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">212</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">216</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log q</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">κ</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r0</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r1</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">106KB</td>

            <td class="px-3 py-2 border-b border-gray-700">242KB</td>

            <td class="px-3 py-2 border-b border-gray-700">542KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">185KB</td>

            <td class="px-3 py-2 border-b border-gray-700">602KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.77MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Concrete parameters, together with commitment and proof sizes, for security level  <span class="math">\\lambda  = {128}</span>  .</p>

    <p class="text-gray-300">Soundness error. By a simple generalisation of [FMN23, Lemma 2.31] to multiple (possibly distinct) challenge spaces, we deduce that the knowledge soundness error of the protocol is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {r _ {0} + r _ {1}}{(2 \\kappa + 1) ^ {d}} + \\frac {2 r _ {2} n \\alpha d}{2 ^ {\\lambda}} + \\frac {\\lambda}{q ^ {l}} \\leq \\frac {r _ {0} + r _ {1}}{(2 \\kappa + 1) ^ {d}} + \\frac {2 r _ {2} n \\alpha d + \\lambda}{2 ^ {\\lambda}}.</span></div>

    <p class="text-gray-300">This term becomes negligible for  <span class="math">d = O(\\lambda)</span>  and  <span class="math">\\kappa = O(1)</span> .</p>

    <p class="text-gray-300">We propose concrete instantiation of our protocol for various values of  <span class="math">L</span> . To begin with, one can bound the commitment size by  <span class="math">r_0 \\cdot nd[\\log q]</span> , and the prover messages as follows:</p>

    <div class="my-4 text-center"><span class="math-block">r _ {0} \\cdot d \\lceil \\log q \\rceil + r _ {1} \\cdot (n \\alpha d \\lceil \\log (2 \\beta_ {1}) \\rceil + d \\lceil \\log q \\rceil + \\lambda \\lceil \\log (2 \\beta_ {p}) \\rceil + l d \\lceil \\log q \\rceil) + r _ {2} \\cdot n \\alpha d \\lceil \\log (2 \\beta_ {2}) \\rceil .</span></div>

    <p class="text-gray-300">Assuming that lattice parameters  <span class="math">n, d</span>  are polynomial in  <span class="math">\\lambda</span> , by picking  <span class="math">r_0, r_1, r_2 \\in O_{\\lambda}(\\sqrt[3]{L})</span> , we yield proofs of size  <span class="math">O_{\\lambda}(\\sqrt[3]{L})</span>  ring elements. Similar reasoning can be applied to show that the verifier runs in sublinear time.</p>

    <p class="text-gray-300">We instantiate our protocol with parameters shown in Table 4. For comparison with prior works, e.g. [BS23,FMN23], we aim for 128-bit security. This corresponds to the root Hermite factor  <span class="math">\\delta_{\\mathrm{rbf}}</span>  being around 1.0044. To measure hardness of (Module-)SIS, we first naively translate the infinity norm of our solution to the  <span class="math">\\ell_2</span>  norm, and then we follow the heuristic methodology from [MR09], i.e.,  <span class="math">\\mathsf{MSIS}_{n,m,q,d,\\beta^<em>}</span>  is hard when  <span class="math">\\beta^{</em>}\\sqrt{md} \\leq 2^{2\\sqrt{nd\\log q\\log\\delta_{\\mathrm{df}}}}</span> . Note that one may get smaller sizes by considering cryptanalysis of the infinity norm Module-SIS as in Dilithium [DKL+18].</p>

    <p class="text-gray-300">As shown in the table, picking small values for  <span class="math">d</span>  results in the smallest sizes. The reason is that having small  <span class="math">d</span>  implies large  <span class="math">n</span>  to maintain security. Hence, keeping in mind that  <span class="math">r_0r_1r_2 = L / n</span> , we can pick smaller values for  <span class="math">r_0, r_1</span>  and  <span class="math">r_2</span> . Of course, we cannot choose very small ring dimension  <span class="math">d</span> , since then  <span class="math">\\kappa</span>  needs to be increased drastically to keep the challenge space  <span class="math">\\mathcal{C}</span>  exponential-size. Consequently, we found the trade-off in  <span class="math">(d,\\kappa) = (32,8)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Optimizations. As shown in Lemmas 5 and 7, parameters  <span class="math">\\beta_{1},\\beta_{2},\\beta_{p}</span>  have significant impact on both security and performance. In order to increase efficiency, we can derive smaller values for  <span class="math">\\beta_{1},\\beta_{2},\\beta_{p}</span>  using probabilistic bounds. For example, to bound  <span class="math">\\vec{p}</span> , we can use the heuristic from [GHL22, Corollary 3.2] which says that for any vector  <span class="math">\\vec{s} \\in \\mathbb{Z}^k</span> , with an overwhelming probability over  <span class="math">\\vec{\\varphi} \\gets \\chi^k</span> , we have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{\\varphi},\\vec{s}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 9.75 \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{n}<span class="math"> . This allows us to pick  </span>\\beta_{p} := 9.75 \\cdot \\beta_{1}\\sqrt{r_{2}n\\alpha d}<span class="math"> . As for  </span>\\beta_{1}<span class="math">  (and analogously for  </span>\\beta_{2}<span class="math"> ) we heuristically find an upper-bound on the largest singular values of the row vectors  </span>\\vec{c}_{1}^{\\top} \\gets [-\\kappa ,\\kappa]^{r_{0}d}<span class="math"> , which enables us to estimate  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i = 1}^{r_0}c_{1,i}\\mathbf{s}_{1,i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  in Equation (23) more efficiently.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another important optimization is to rely on the Hermite Normal Form Module-SIS problem instead of the plain Module-SIS. Concretely, we assume that matrices  <span class="math">\\mathbf{A}_i</span>  are of the form  <span class="math">\\mathbf{A}_i \\coloneqq [\\mathbf{A}_i&#x27; \\mid \\mathbf{I}_n]</span> . The advantage comes from the fact that then we do not need some parts of the vectors  <span class="math">\\mathbf{y}_1, \\mathbf{y}_2</span> , since they can be computed directly by the verifier.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">215</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">220</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">225</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">230</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">commitment size</td>

            <td class="px-3 py-2 border-b border-gray-700">65KB</td>

            <td class="px-3 py-2 border-b border-gray-700">118KB</td>

            <td class="px-3 py-2 border-b border-gray-700">570KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2.20MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">120KB</td>

            <td class="px-3 py-2 border-b border-gray-700">501KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.51MB</td>

            <td class="px-3 py-2 border-b border-gray-700">5.17MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5. Efficiency of our polynomial commitment scheme over a finite field  <span class="math">\\mathbb{Z}_q</span> , where  <span class="math">q \\approx 2^{60}</span> . We aim for 128-bit security and include the linear loss  <span class="math">Q</span>  from the Fiat-Shamir transformation. Concretely, we assume that the adversary makes at most  <span class="math">Q = 2^{64}</span>  queries.</p>

    <p class="text-gray-300">For instance, if we write  <span class="math">\\mathbf{y}_1 \\coloneqq (\\mathbf{y}_{1,0},\\mathbf{y}_{1,1}) \\in R_q^{c_1n\\alpha} \\times R_q^n</span> , then it is sufficient to only send  <span class="math">\\mathbf{y}_{1,0}</span>  to the verifier. Indeed, they can compute  <span class="math">\\mathbf{y}_{1,1}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {y} _ {1, 1} := \\left(\\mathbf {c} _ {1} ^ {\\top} \\otimes \\mathbf {I} _ {n}\\right) \\cdot \\mathbf {t} - \\mathbf {A} _ {1} ^ {\\prime} \\cdot \\mathbf {y} _ {1, 0}.</span></div>

    <p class="text-gray-300">All the other verification relations can be checked using the newly generated  <span class="math">\\mathbf{y}_{1,1}</span> . A natural future step for optimization would be to also drop the low-order bits of the commitment  <span class="math">\\mathbf{t}</span>  as in  <span class="math">[\\mathrm{DKL}^{+}18]</span> .</p>

    <p class="text-gray-300">We provide an efficient instantiation of a polynomial commitment scheme over finite fields  <span class="math">\\mathbb{Z}_q</span>  using the evaluation protocol from Appendix A. For fair comparison, we include the security loss from the Fiat-Shamir transformation and assume the adversary makes at most  <span class="math">2^{64}</span>  random oracle queries. To accommodate for this loss, we set  <span class="math">\\lambda = 192</span> . All the other parameters are picked as in Appendix A.3 and the resulting sizes are summarized in Table 5.</p>

    <p class="text-gray-300">To achieve this, we first apply the generic transformation from [AFLN23, Section 5.5], which reduces proving polynomial evaluations over  <span class="math">\\mathbb{Z}_q</span>  for degree  <span class="math">L</span>  polynomials to proving polynomial evaluations over  <span class="math">R_{q}</span>  for degree  <span class="math">L / d</span>  polynomials. This comes at a cost of sending an extra  <span class="math">R_{q}</span>  element. Motivated by this observation, we choose  <span class="math">d = 256</span> . Then, instead of picking arbitrary binary/ternary polynomials from  <span class="math">\\mathcal{C}</span> , which would result in a challenge space much bigger than  <span class="math">2^{192}</span> , we define  <span class="math">\\mathcal{C}</span>  to contain polynomials with ternary coefficients in  <span class="math">\\{-1,0,1\\}</span>  and fixed Hamming weight  <span class="math">\\omega = 39</span> . This allows us to moderately reduce  <span class="math">\\beta_{1},\\beta_{2},\\beta_{p}</span> , as well as the norms of the extracted witness.</p>

    <p class="text-gray-300">In the following we show a general theorem for post-quantum security of polynomial commitments. Specifically, we show that coordinate-wise special soundness implies knowledge soundness, even against quantum attackers. Combining this the fact that the scheme in Section 5 is last-round collapsing (to be defined later), this implies the post-quantum security of our basic polynomial commitment. For notational convenience, we will denote by</p>

    <div class="my-4 text-center"><span class="math-block">V _ {\\mathfrak {p p}, x} \\left(c _ {1}, \\dots , c _ {\\ell}, z _ {1}, \\dots , z _ {\\ell}, z _ {\\ell + 1}\\right) \\in \\{0, 1 \\}</span></div>

    <p class="text-gray-300">the predicate that, on input a set of challenges and the corresponding responses, determines whether they form an accepting transcript. For notational convenience, we drop the identifiers  <span class="math">\\mathsf{pp}</span>  and  <span class="math">x</span>  whenever clear from the context and use (slightly) different indexing of the prover's message and witnesses to the one used in Definition 4. In particular, we will start by counting from 1 here, compared to 0 as used before. We recall the following consequence of Markov's inequality.</p>

    <p class="text-gray-300">Lemma 8. Let  <span class="math">X</span>  be a random variable supported on  <span class="math">[0,1]</span> . Then for all  <span class="math">\\alpha \\geq 0</span>  it holds that  <span class="math">\\operatorname*{Pr}[X \\geq \\alpha] \\geq \\mathbb{E}[X] - \\alpha</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We recall some basic concepts of quantum information, and we refer the reader to [NC11] for a comprehensive introduction. A (pure) quantum state is a vector  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\rangle<span class="math">  in a complex Hilbert space  </span>\\mathcal{H}<span class="math">  with  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\rangle \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> ; in this work,  </span>\\mathcal{H}<span class="math">  is finite-dimensional. A density matrix is a positive semi-definite Hermitian operator  </span>\\rho \\in \\mathcal{H}<span class="math">  with  </span>\\mathrm{Tr}(\\rho) = 1$ . A density</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">matrix represents a probabilistic mixture of pure states (a mixed state); the density matrix corresponding to the pure state <span class="math">\\ket{\\psi}</span> is <span class="math">\\bra{\\psi}\\ket{\\psi}</span>. Typically we divide a Hilbert space into registers, e.g., <span class="math">\\mathcal{H}=\\mathcal{H}_{0}\\otimes\\mathcal{H}_{1}</span>. A unitary operation is a complex square matrix <span class="math">U</span> such that <span class="math">UU^{\\dagger}=\\mathsf{Id}</span>. The operation <span class="math">U</span> transforms the pure state <span class="math">\\ket{\\psi}</span> to the pure state <span class="math">U\\ket{\\psi}</span>, and the density matrix <span class="math">\\rho</span> to the density matrix <span class="math">U\\rho U^{\\dagger}</span>.</p>

    <p class="text-gray-300">A projector <span class="math">\\Pi</span> is a Hermitian operator such that <span class="math">\\Pi^{2}=\\Pi</span>. A projective measurement is a collection of projectors</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}=\\{\\Pi_{i}\\}_{i\\in S}\\quad\\text{such that}\\quad\\sum_{i\\in S}\\Pi_{i}=\\mathsf{Id},</span></p>

    <p class="text-gray-300">which implies that <span class="math">\\Pi_{i}\\Pi_{j}=0</span> for all distinct <span class="math">i</span> and <span class="math">j</span>. The application of <span class="math">\\mathsf{P}</span> to a pure state <span class="math">\\ket{\\psi}</span> yields outcome <span class="math">i\\in S</span> with probability <span class="math">p_{i}=\\left\\lVert\\Pi_{i}\\ket{\\psi}\\right\\rVert^{2}</span>, in which case the post-measurement state is <span class="math">\\ket{\\psi_{i}}=\\Pi_{i}\\ket{\\psi}/\\sqrt{p_{i}}</span>. We refer to the post-measurement state <span class="math">\\ket{\\psi_{i}}</span> as the result of applying <span class="math">\\mathsf{P}</span> to <span class="math">\\ket{\\psi}</span> and post-selecting (conditioning) on outcome <span class="math">i</span>. A two-outcome projective measurement is called a binary projective measurement, and is written as <span class="math">\\mathsf{P}=\\{\\Pi,\\mathsf{Id}-\\Pi\\}</span>.</p>

    <p class="text-gray-300">General (non-unitary) evolution of a quantum state can be represented via a completely-positive trace- preserving (CPTP) map, whose precise definition is not important for this work. We only use the fact that for every CPTP map there exists a unitary dilation <span class="math">U</span>, that operates on an extended Hilbert space. The unitary dilation is not necessarily unique, but its circuit complexity is linear in that of the original CPTP map.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Interactive Quantum Circuits.</h4>

    <p class="text-gray-300">In this work, we model the attacker as an interactive quantum circuits, where an <span class="math">\\ell</span>-round interactive circuit consists of a sequence of unitaries <span class="math">U_{1},\\ldots,U_{\\ell}</span> where</p>

    <p class="text-gray-300"><span class="math">U_{i}:C_{i}\\rightarrow U(\\mathcal{A}\\otimes\\mathcal{Z})</span></p>

    <p class="text-gray-300">and we think of <span class="math">\\mathcal{Z}</span> as the register containing the response of the adversary, whereas <span class="math">\\mathcal{A}</span> contains its internal state. We denote by <span class="math">U_{i}(c_{i})</span> the <span class="math">i</span>-th unitary classically controlled on <span class="math">c_{i}</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">U_{i}=\\sum_{c_{i}\\in C_{i}}\\ket{c_{i}}\\bra{c_{i}}U_{i}(c_{i}).</span></p>

    <p class="text-gray-300">The size of an interactive quantum circuit is the sum of the sizes of the circuits implementing the unitaries <span class="math">U_{1},\\ldots,U_{\\ell}</span>. We can then simulate an interaction with the adversary with initial state <span class="math">\\ket{\\psi}</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize <span class="math">\\mathcal{A}\\otimes\\mathcal{Z}_{1}</span> with <span class="math">\\ket{\\psi}</span> and <span class="math">\\tau</span> as an empty string.</li>

      <li>Measure <span class="math">\\mathcal{Z}_{1}</span> in the computational basis to obtain a first message <span class="math">z_{1}</span>.</li>

      <li>Append <span class="math">z_{1}</span> to <span class="math">\\tau</span>.</li>

      <li>For <span class="math">i=1,\\ldots,\\ell</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">c_{i}\\leftarrow C_{i}</span>.</li>

      <li>Apply the unitary <span class="math">U_{i}(c_{i})</span> to <span class="math">\\mathcal{A}\\otimes\\mathcal{Z}_{i+1}</span>.</li>

      <li>Measure <span class="math">\\mathcal{Z}_{i+1}</span> in the computational basis to obtain a response <span class="math">z_{i+1}</span>.</li>

      <li>Append <span class="math">(c_{i},z_{i+1})</span> to <span class="math">\\tau</span>.</li>

      <li>Return <span class="math">V(\\tau)</span>.</li>

    </ul>

    <p class="text-gray-300">In particular, the interaction is public coin. Note again that we restrict the operation of the adversary in each round to be unitary except for the measurement of <span class="math">\\mathcal{Z}_{i+1}</span> in the computational basis.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">B.2 Last-Round Collapsing</h3>

    <p class="text-gray-300">We recall the definition of last-round collapsing adapted from <em>[x14]</em>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 10 (Last Round Collapsing).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell+1)</span>-round recursive-friendly proof system <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> for the relation <span class="math">\\mathfrak{R}_{\\ell}</span> with associated relations <span class="math">(\\mathfrak{R}_{\\ell-i})_{i\\in[\\ell+1]}</span>. For each <span class="math">i\\in[\\ell+1]</span>, let <span class="math">\\Pi_{i}</span> be the <span class="math">(2i+1)</span>-message protocol obtained by running the first <span class="math">2i</span>-round of <span class="math">\\Pi</span> and where the last message is the witness of the reduced relation <span class="math">\\mathfrak{R}_{\\ell-i+1}</span>. The verifier of <span class="math">\\Pi_{i}</span> accepts the interactions if and only if <span class="math">\\mathsf{V}_{j}(\\mathsf{pp},x_{j},z_{j})=1</span> for all <span class="math">j\\in[i]</span> and</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},x_{i},w_{i}\\right)\\in\\mathfrak{R}_{\\ell-i+1}</span>. The protocol <span class="math">\\Pi</span> is said to be last-round collapsing if for all <span class="math">i\\leq[\\ell+1]</span> and for any QPT adversary <span class="math">\\mathcal{P}^{*}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[1=\\mathsf{LRCollapsing}^{(0)}_{\\Pi_{i},\\mathcal{P}^{<em>}}\\right]-\\Pr\\left[1=\\mathsf{LRCollapsing}^{(1)}_{\\Pi_{i},\\mathcal{P}^{</em>}}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the experiment <span class="math">\\mathsf{LRCollapsing}^{(b)}_{\\Pi_{i},\\mathcal{P}^{*}}</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The challenger runs <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span>.</li>

      <li>The challenger activates the prover <span class="math">x_{1}\\leftarrow\\mathcal{P}^{*}(\\mathsf{pp})</span>.</li>

      <li>The challenger and the prover jointly execute the <span class="math">\\Pi_{i}</span> up until measuring the last message of the adversary. Let</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},x_{1},\\mathbf{c},\\mathbf{z}\\right)\\quad\\text{where}\\quad\\mathbf{c}=(c_{1},\\ldots,c_{i-1})\\quad\\text{and}\\quad\\mathbf{z}=(z_{1},\\ldots,z_{i-1})</span></p>

    <p class="text-gray-300">denote the transcript thus far (excluding the last message) and let <span class="math">\\mathcal{W}</span> be the register that contains the state corresponding to the last message of the adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j\\in[i]</span>, let <span class="math">x_{j}=\\mathsf{NextX}_{\\leq j-1}(\\mathsf{pp},x_{1},z_{1},\\ldots,z_{j-1},c_{1},\\ldots,c_{j-1})</span>. If <span class="math">\\mathsf{V}_{j}(\\mathsf{pp},x_{j},z_{j})=0</span> for any <span class="math">j\\in[i-1]</span> abort the experiment, else proceed.</li>

      <li>Let <span class="math">V_{\\mathsf{pp},x_{1}}(\\mathbf{c},\\mathbf{z})</span> denote some unitary dilation of the verification predicate, i.e., the predicate checking that <span class="math">(\\mathsf{pp},x_{i},w_{i})\\in\\mathfrak{R}_{\\ell-i+1}</span>, where <span class="math">w_{i}</span> is the content of <span class="math">\\mathcal{W}</span>. Apply <span class="math">V_{\\mathsf{pp},x_{1}}(\\mathbf{c},\\mathbf{z})</span> to <span class="math">\\mathcal{W}</span> along with some fresh ancillas, measure the register that contains the output bit, then apply <span class="math">V_{\\mathsf{pp},x_{1}}(\\mathbf{c},\\mathbf{z})^{\\dagger}</span>.</li>

      <li>If the output of the measurement is <span class="math">0</span> abort the experiment, else proceed.</li>

      <li>If <span class="math">b=0</span>: Do nothing.</li>

      <li>If <span class="math">b=1</span>: Measure <span class="math">\\mathcal{W}</span> in the computational basis, and discard the outcome of the measurement.</li>

      <li>Return all registers to the prover and return whatever the prover returns.</li>

    </ul>

    <p class="text-gray-300">Next, we show that the protocol specified in Section 5 is last-round collapsing. For each <span class="math">i\\in[\\ell+1]</span>, the last message of <span class="math">\\Pi_{i}</span> consists of the "reduced witness" <span class="math">w_{i}</span> which is composed of a tuple of vectors</p>

    <p class="text-gray-300"><span class="math">\\left((\\mathbf{s}^{(i)}_{j})_{i\\in[0,\\ell-i+1]},\\mathbf{f}^{(i)}\\right)\\quad\\text{such that}\\quad</span> <span class="math">(\\mathbf{I}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i)}_{j}=\\mathbf{t}^{(i)}</span> <span class="math">(\\mathbf{I}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i)}_{0}=\\mathbf{t}^{(i)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(\\mathbf{I}\\otimes\\mathbf{A})\\cdot\\mathbf{s}^{(i)}_{j+1}=\\mathbf{G}\\cdot\\mathbf{s}^{(i)}_{j}\\quad\\text{and}\\quad\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}^{(i)}_{j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 0$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbf{f}^{(i)}=\\mathbf{G}\\cdot\\mathbf{s}^{(i)}_{\\ell-i}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbf{t}^{(i)}</span> is a variable that can be publicly computed from the previous messages. Since <span class="math">\\mathbf{f}^{(i)}</span> is uniquely determined by <span class="math">\\mathbf{s}^{(i)}_{\\ell-i+1}</span>, undetectability of the measurement follows immediately by the LWE assumption, by invoking recent works <em>[x19, x23]</em> that show that the SIS-function is collapsing <em>[x30]</em> The collapsing property of <span class="math">\\mathbf{A}</span> extends to <span class="math">(\\mathbf{I}\\otimes\\mathbf{A})</span> via hybrid argument.</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">B.3 The Quantum Extractor</h3>

    <p class="text-gray-300">In the following we specify the quantum extractor, which shows that coordinate-wise special soundness implies knowledge soundness.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">Simplifying Assumptions.</h4>

    <p class="text-gray-300">We are going to make the following simplifying assumptions on the adversary, which will be later lifted using generic compilers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistent: Let <span class="math">\\mathsf{M}=\\{\\Pi,\\mathsf{Id}-\\Pi\\}</span> be a binary-outcome projective measurement and let <span class="math">p</span> be the probability that of the first outcome, for a given state of the adversary <span class="math">\\rho</span>. Then there exists an estimate procedure <span class="math">\\mathsf{ValEst}_{\\mathsf{M}}</span> acting on two registers</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{ValEst}_{\\mathsf{M}}:\\mathcal{H}\\to\\mathcal{H}\\otimes\\mathcal{O}.</span></p>

    <p class="text-gray-300">In an abuse of notation, we will denote by <span class="math">(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho)</span> application of the map on a state <span class="math">\\rho\\in\\mathcal{H}</span>, followed by a measurement in the computational basis of the <span class="math">\\mathcal{O}</span> register. Then the following two properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{E}[p^{*}]=p</span>.</li>

      <li>For any inverse-polynomial <span class="math">\\eta</span>, it holds that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{max}_{i}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p^{*}-p_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\eta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">p_{i}</span> is the success probability of <span class="math">\\mathsf{M}</span> on the attacker state, after the <span class="math">i</span>-th application of any other <span class="math">k</span>-outcome projective measurement.</p>

    <p class="text-gray-300">The runtime of the adversary will depend polynomially on <span class="math">\\eta</span> and <span class="math">k</span>, although in this work we will only consider the case where <span class="math">k=2</span> so we will ignore this factor in what follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Stateless: The output or the runtime of the adversary does not depend on the number of the invocation, nor on previous queries. In particular, this means that successive invocations of the adversary will always result in the same output distribution.</li>

    </ul>

    <p class="text-gray-300">To lift the first restriction, we will use the state-repair procedure from <em>[x10]</em>, which allows us to restore the success probability for a given predicate, provided that the state was not disturbed too much. To lift the second restriction, we will use the technique from <em>[x3]</em>, which allows us to simulate an stateless adversary, even though the original adversary might be stateful. Importantly, the latter transformation relies on the queries sent to the adversary to be non-adaptive. We provide more details in Appendix B.5.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">Parameters.</h4>

    <p class="text-gray-300">The description of the extractor below will induce the following parameters. For ease of understanding, we report them below, along with an intuitive explanation of what the parameter describes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell</span> : Number of rounds of the protocol.</li>

      <li><span class="math">\\xi+1</span> : Arity of the extraction tree, i.e., number of transcripts that the extractor needs at each round of the protocol.</li>

      <li><span class="math">\\eta</span>: The persistence parameter of the algorithm (see above).</li>

      <li><span class="math">n</span>: Number of iteration necessary to amplify the success probability of the extractor.</li>

      <li><span class="math">\\gamma_{0},\\ldots,\\gamma_{\\ell}</span> : Threshold gap necessary for the extractor to visit a subtree in the recursion.</li>

    </ul>

    <p class="text-gray-300">As we shall see in the analysis below, we will set</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\gamma_{i}=\\left(\\eta+\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)+\\frac{1}{\\sqrt{n}}\\right)(\\ell-i)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">whereas <span class="math">n</span> will be a fixed polynomial in the security parameter and <span class="math">\\eta</span> a larger polynomial in the security parameter one. In particular we want that <span class="math">e^{-\\sqrt{n}}</span> should be a negligible function in the security parameter, whereas <span class="math">\\eta n</span> should be close to <span class="math">0</span>.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">Last-Round Extractor.</h4>

    <p class="text-gray-300">The description of our extractor will be recursive, where the <span class="math">i</span>-th recursion of the extractor will take as input the previous set of randomnesses <span class="math">(c_{1},\\ldots,c_{\\ell-1})</span> and responses <span class="math">\\mathbf{z}=(z_{1},\\ldots,z_{\\ell})</span> and will extract the witness for the last round of the protocol, given the current state of the attacker. The base case extractor <span class="math">\\mathsf{Ext}_{\\ell}</span> takes as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A set of challenges <span class="math">\\mathbf{c}=(c_{1},\\ldots,c_{\\ell-1})</span>.</li>

      <li>A set of adversarial responses <span class="math">\\mathbf{z}=(z_{1},\\ldots,z_{\\ell})</span>.</li>

      <li>The state of the attacker <span class="math">\\rho</span>.</li>

      <li>A success probability <span class="math">p_{\\ell}</span>.</li>

    </ul>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}_{\\ell}</span> proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">s=1,\\ldots,n</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">c_{\\ell}\\leftarrow S^{\\xi}</span> uniformly at random.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Denote by <span class="math">\\mathsf{V}(\\mathbf{c},c_{\\ell},\\mathbf{z})</span> the projective measurement defined as</li>

    </ul>

    <p class="text-gray-300"><span class="math">V(\\mathbf{c},c_{\\ell},\\mathbf{z})=\\{\\Pi_{\\mathbf{c},c_{\\ell},\\mathbf{z}},\\mathsf{Id}-\\Pi_{\\mathbf{c},c_{\\ell},\\mathbf{z}}\\}\\quad\\text{where}\\quad\\Pi_{\\mathbf{c},c_{\\ell},\\mathbf{z}}=\\sum_{w:V(\\mathbf{c},c_{\\ell},\\mathbf{z},w)=1}U_{\\ell}(c_{\\ell})^{\\dagger}\\ket{w}\\bra{w}U_{\\ell}(c_{\\ell}).</span> (24)</p>

    <p class="text-gray-300">Apply <span class="math">V(\\mathbf{c},c_{\\ell},\\mathbf{z})</span> to the state of the attacker and denote by <span class="math">b</span> the observed outcome.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">b=1</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">U_{\\ell}(c_{\\ell})</span> to the state of the attacker.</li>

      <li>Let <span class="math">\\mathcal{W}</span> be the register that contains the response of the adversary. Measure the register in the computational basis and let <span class="math">w_{0}</span> be the result of the measurement. Add <span class="math">\\{0,c_{\\ell},w_{0}\\}</span> to the set <span class="math">W_{s}</span>.</li>

      <li>Apply <span class="math">U_{\\ell}(c_{\\ell})^{\\dagger}</span> to the state of the attacker.</li>

      <li>For <span class="math">j=1,\\ldots,\\xi</span>, let <span class="math">s_{j}</span> be the <span class="math">j</span>-th coordinate of <span class="math">c_{\\ell}</span>. Then run the following loop <span class="math">n</span> times:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">s^{<em>}\\leftarrow S\\setminus\\{s_{j}\\}</span> and substitute the <span class="math">j</span>-th coordinate with <span class="math">s^{</em>}</span>.</li>

      <li>Apply <span class="math">V(\\mathbf{c},c_{\\ell},\\mathbf{z})</span> as defined in Eq. (24) to the state of the attacker and denote by <span class="math">b</span> the observed outcome.</li>

      <li>If <span class="math">b=1</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">U_{\\ell}(c_{\\ell})</span> to the state of the attacker.</li>

      <li>Let <span class="math">\\mathcal{W}</span> be the register that contains the response of the adversary. Measure the register in the computational basis and let <span class="math">w_{j}</span> be the result of the measurement. If no entry starting with <span class="math">j</span> is present, add <span class="math">\\{j,c_{\\ell},w_{j}\\}</span> to the set <span class="math">W_{s}</span>.</li>

      <li>Apply <span class="math">U_{\\ell}(c_{\\ell})^{\\dagger}</span> to the state of the attacker.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If there exists no <span class="math">s</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\xi+1<span class="math">, then return </span>\\bot<span class="math">. Else return the output of the classical extractor on such a set </span>W_{s}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">General Extractor.</h4>

    <p class="text-gray-300">Before describing the extractor in its full generality, it is useful to define a few additional subroutines. For a set of challenges <span class="math">\\mathbf{c}=(c_{1},\\ldots,c_{i-1})</span> and a set of responses <span class="math">\\mathbf{z}=(z_{1},\\ldots,z_{i-1})</span>, we define the projective measurement <span class="math">\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})=\\{\\Pi_{i,\\mathbf{c},\\mathbf{z}},\\mathsf{Id}-\\Pi_{i,\\mathbf{c},\\mathbf{z}}\\}</span> where</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i,\\mathbf{c},\\mathbf{z}}=\\sum_{c_{i+1},\\ldots,c_{\\ell}\\in C}\\sum_{\\mathbf{w}:V(\\mathbf{c},c_{i+1},\\ldots,c_{\\ell},\\mathbf{z},\\mathbf{w})=1}U_{i}(c_{i})^{\\dagger}\\ldots U_{\\ell}(c_{\\ell})^{\\dagger}\\ket{\\mathbf{w}}\\bra{\\mathbf{w}}U_{\\ell}(c_{\\ell})\\ldots U_{i}(c_{i})</span> (25)</p>

    <p class="text-gray-300">i.e., <span class="math">\\Pi_{i,\\mathbf{c},\\mathbf{z}}</span> projects onto all valid transcripts for randomly chosen subsequent challenges. Note that <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span> estimates the success probability of the adversary, for a given prefix. Let us denote by <span class="math">E(i,\\mathbf{c},\\mathbf{z})</span> some unitary dilation of the procedure <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span>. We then define the projective measurement <span class="math">\\mathsf{Thresh}(\\mathbf{c},\\mathbf{z},\\gamma_{i-1})=\\{\\Pi_{\\mathbf{c},\\mathbf{z},\\gamma_{i-1}},\\mathsf{Id}-\\Pi_{\\mathbf{c},\\mathbf{z},\\gamma_{i-1}}\\}</span> where</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathbf{c},\\mathbf{z},\\gamma_{i-1}}=\\sum_{p^{<em>}\\geq\\gamma_{i-1}}E(i,\\mathbf{c},\\mathbf{z})^{\\dagger}\\ket{p^{</em>}}\\bra{p^{*}}E(i,\\mathbf{c},\\mathbf{z})</span> (26)</p>

    <p class="text-gray-300">where the projection acts on the <span class="math">\\mathcal{O}</span> register and it is tensored with <span class="math">\\mathsf{Id}</span> appropriately. We are now ready to describe the extractor in its full generality. Our top-level extractor <span class="math">\\mathsf{Ext}</span> proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input a state <span class="math">\\rho\\in\\mathcal{Z}_{1}\\otimes\\mathcal{A}</span></li>

      <li>Run <span class="math">(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}(1)}(\\rho)</span> and abort if <span class="math">p^{*}&lt;\\gamma_{0}</span>.</li>

      <li>Run a unitary dilation of <span class="math">\\mathsf{Ext}_{1}(\\rho^{<em>},p^{</em>})</span> and return the result of measuring the output register in the computational basis.</li>

    </ul>

    <p class="text-gray-300">We then define the <span class="math">i</span>-the level extractor recursively. On input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A set of challenges <span class="math">\\mathbf{c}=(c_{1},\\ldots,c_{i-1})</span>.</li>

      <li>A set of adversarial responses <span class="math">\\mathbf{z}=(z_{1},\\ldots,z_{i})</span></li>

      <li>The state of the attacker <span class="math">\\rho</span>.</li>

      <li>A success probability <span class="math">p_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">The extractor <span class="math">\\mathsf{Ext}_{i}</span> proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">s=1,\\ldots,n</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">c_{i}\\leftarrow S^{\\xi}</span> uniformly.</li>

      <li>Apply <span class="math">U_{i}(c_{i})</span> to the state of the attacker.</li>

      <li>Apply <span class="math">\\mathsf{Thresh}(\\mathbf{c},c_{i},\\mathbf{z},\\gamma_{i})</span> as defined in Eq. (26) to the state of the attacker and let <span class="math">b^{\\prime}</span> be the observed outcome.</li>

      <li>If <span class="math">b^{\\prime}=1</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">E(i+1,\\mathbf{c},c_{i},\\mathbf{z})</span> to the state of the attacker.</li>

      <li>Run an arbitrary unitary dilation of the extractor <span class="math">\\mathsf{Ext}_{i+1}(\\mathbf{c},c_{i},\\mathbf{z})</span> on the registers <span class="math">\\mathcal{A}\\otimes\\mathcal{O}\\otimes\\mathcal{Z}_{i+1}</span></li>

      <li>Apply the projective measurement that determines whether the witness contained in register <span class="math">\\mathcal{W}</span> is valid, and denote by <span class="math">b</span> the observed outcome.</li>

      <li>If <span class="math">b=1</span> measure <span class="math">\\mathcal{W}</span> in the computational basis and denote by <span class="math">w_{0}</span> the result of the measurement. Add <span class="math">\\{0,c_{i},w_{0}\\}</span> to <span class="math">W_{s}</span>.</li>

      <li>Apply the conjugate transpose of the unitary implementation of <span class="math">\\mathsf{Ext}_{i+1}(\\mathbf{c},c_{i},\\mathbf{z})</span>.</li>

      <li>Apply <span class="math">E(i+1,\\mathbf{c},c_{i},\\mathbf{z})^{\\dagger}</span> to the state of the attacker.</li>

      <li>Apply <span class="math">U_{i}(c_{i})^{\\dagger}</span> to the state of the attacker.</li>

      <li>For <span class="math">j=1,\\ldots,\\xi</span>, let <span class="math">s_{j}</span> be the <span class="math">j</span>-th coordinate of <span class="math">c_{i}</span>. Then run the following loop <span class="math">n</span> times:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">s^{<em>}\\leftarrow S\\setminus\\{s_{j}\\}</span> and substitute the <span class="math">j</span>-th coordinate of <span class="math">c_{i}</span> with <span class="math">s^{</em>}</span>.</li>

      <li>Apply <span class="math">U_{i}(c_{i})</span> to the state of the attacker.</li>

      <li>Apply <span class="math">\\mathsf{Thresh}(\\mathbf{c},c_{i},\\mathbf{z},\\gamma_{i})</span> as defined in Eq. (26) to the state of the attacker and let <span class="math">b^{\\prime}</span> be the observed outcome.</li>

      <li>If <span class="math">b^{\\prime}=1</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply <span class="math">E(i+1,\\mathbf{c},c_{i},\\mathbf{z})</span> to the state of the attacker.</li>

      <li>Run an arbitrary unitary dilation of the extractor <span class="math">\\mathsf{Ext}_{i+1}(\\mathbf{c},c_{i},\\mathbf{z})</span> on the registers <span class="math">\\mathcal{A}\\otimes\\mathcal{O}\\otimes\\mathcal{Z}_{i+1}</span>.</li>

      <li>Apply the projective measurement that determines whether the witness contained in register <span class="math">\\mathcal{W}</span> is valid, and denote by <span class="math">b</span> the observed outcome.</li>

      <li>If <span class="math">b=1</span> measure <span class="math">\\mathcal{W}</span> in the computational basis and denote by <span class="math">w_{j}</span> the result of the measurement. Add <span class="math">\\{j,c_{i},w_{j}\\}</span> to <span class="math">W_{s}</span>.</li>

      <li>Apply the conjugate transpose of the unitary implementation of <span class="math">\\mathsf{Ext}_{i+1}(\\mathbf{c},c_{i},\\mathbf{z})</span>.</li>

      <li>Apply <span class="math">E(i+1,\\mathbf{c},c_{i},\\mathbf{z})^{\\dagger}</span> to the state of the attacker.</li>

      <li>Apply <span class="math">U_{i}(c_{i})^{\\dagger}</span> to the state of the attacker.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If there exists no <span class="math">s</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\xi+1<span class="math">, then return </span>\\bot<span class="math">. Else return the output of the classical extractor on such a set </span>W_{s}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">B.4 Analysis of the Extractor</h3>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Soundness Gap.</h4>

    <p class="text-gray-300">In the following we bound the gap between the success probability of the attacker and the probability that the extractor succeeds in recovering a valid witness. Here we state the main technical statement that will be useful for our analysis.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">For all <span class="math">i=1,\\ldots,\\ell</span>, all <span class="math">\\mathbf{c}=(c_{1},\\ldots,c_{i-1})</span>, all <span class="math">\\mathbf{z}=(z_{1},\\ldots,z_{i-1})</span> , and all states <span class="math">\\rho\\in\\mathcal{Z}_{i}\\otimes\\mathcal{A}</span>, the following distributions are computationally indistinguishable</p>

    <p class="text-gray-300">\\[ \\left\\{\\begin{array}[]{c}\\text{Apply }(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}(\\rho)\\\\ \\text{Return }0\\text{ if }p^{<em>}<\\gamma_{i-1}\\\\ \\text{Run }\\{w,\\bot\\}\\leftarrow\\mathsf{Ext}_{i}(\\mathbf{c},\\mathbf{z},\\rho^{</em>},p^{*})\\\\ \\text{Return }1\\text{ if }w\\text{ is a valid witness, and }0\\text{ otherwise}\\end{array}\\right\\}\\approx\\{\\text{Apply }\\mathsf{Thresh}(\\mathbf{c},\\mathbf{z},\\gamma_{i-1})\\text{ to }\\rho\\} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\gamma_{i}=\\left(\\eta+\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)+\\frac{1}{\\sqrt{n}}\\right)(\\ell-i)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First we recall that the projective measurement <span class="math">\\mathsf{Thresh}(\\mathbf{c},\\mathbf{z},\\gamma_{i-1})</span> partitions the state space into states where the probability <span class="math">p^{<em>}</span> estimated by <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span> is smaller or greater equal than <span class="math">\\gamma_{i-1}</span>. In the latter case, both distributions output <span class="math">0</span> with certainty, so to prove the statement it suffices to bound the probability that <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span> outputs some <span class="math">p^{</em>}\\geq\\gamma_{i-1}</span> but the extractor <span class="math">\\mathsf{Ext}_{i}</span> fails. We prove this bound by induction.</p>

    <p class="text-gray-300">ase <span class="math">i=\\ell</span>. We consider the following sequence of hybrids distribution.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{0}</span>: This is the original distribution on the LHS.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Hyb}_{1}</span>: We modify the last round extractor so that the answer of the adversary on register <span class="math">\\mathcal{W}</span> is no longer measured and instead the tuple <span class="math">\\{j,\\cdot,\\bot\\}</span> is added to <span class="math">W_{s}</span> (if <span class="math">b=1</span>). The extraction is considered successful if there exists an <span class="math">s</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\xi+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the last-round collapsing property of the protocol, the distributions induced by the two hybrids are computationally indistinguishable. Importantly, in the latter hybrid all measurements performed after <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span> are binary-outcome, and therefore from this point on we can assume that the adversary is <span class="math">\\eta</span>-persistent.</p>

    <p class="text-gray-300">Let us now consider one of the <span class="math">s</span> iterations of the external loop of the last round extractor. We define the following random variables</p>

    <p class="text-gray-300">\\[ X_{0}=\\begin{cases}1&\\text{if }1=V(\\mathbf{c},c_{\\ell})\\\\ 0&\\text{otherwise}\\end{cases}\\quad\\text{and}\\quad\\begin{cases}1&\\{j,\\cdot,\\cdot\\}\\notin W_{s}\\\\ 0&\\text{otherwise}\\end{cases}\\Biggr{\\}}_{j=1,\\ldots,\\xi}. \\]</p>

    <p class="text-gray-300">Then we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[X_{0}=1\\ \\&amp;\\ \\sum_{j}X_{j}=\\xi\\right]</span> <span class="math">=\\Pr\\left[X_{0}=1\\right]-\\Pr\\left[X_{0}=1\\ \\&amp;\\ \\sum_{j}X_{j}&lt;\\xi\\right]</span> <span class="math">=\\Pr\\left[X_{0}=1\\right]-\\Pr\\left[X_{0}=1\\ \\&amp;\\ \\exists\\ j:X_{j}=0\\right]</span> <span class="math">\\geq\\Pr\\left[X_{0}=1\\right]-\\sum_{j=1}^{\\xi}\\Pr\\left[X_{0}=1\\ \\&amp;\\ X_{j}=0\\right]</span></p>

    <p class="text-gray-300">by a union bound. We are now going to bound the term <span class="math">\\Pr\\left[X_{0}=1\\ \\&amp;\\ X_{j}=0\\right]</span> for any <span class="math">j</span>. Let us define the set of challenges</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Bad}_{j}=\\left\\{c_{\\ell}\\in S^{\\xi}:\\exists\\ s_{j}\\ \\text{s.t.}\\ \\Pr_{s^{<em>}\\leftarrow S\\setminus\\{s_{j}\\}}\\left[1=\\mathsf{V}(\\mathbf{c},\\mathsf{Sub}(c_{\\ell},j,s^{</em>}),\\mathbf{z})\\right]&lt;1/\\sqrt{n}\\right\\}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Sub}(c_{\\ell},j,s^{<em>})</span> returns the string <span class="math">c_{\\ell}</span>, except with the <span class="math">j</span>-coordinate set to <span class="math">s^{</em>}</span>. Then we consider two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">c_{\\ell}\\notin\\mathsf{Bad}_{j}</span>: Taking the contrapositive, we can conclude that, no matter the choice of <span class="math">s_{j}</span>, the success probability of the measurement is at least <span class="math">1/\\sqrt{n}</span>. Thus, the probability that none of the iterations in the inner loop succeeds is bounded by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left(1-\\frac{1}{\\sqrt{n}}+\\eta\\right)^{n}\\leq e^{-n/\\sqrt{n}+\\eta n}=e^{-\\sqrt{n}+\\eta n}</span></p>

    <p class="text-gray-300">where the additive component <span class="math">\\eta</span> comes from the fact that the algorithm is assumed to be <span class="math">\\eta</span>-persistent and the independence of the measurement is guaranteed by the fact that the algorithm is stateless.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">c_{\\ell}\\in\\mathsf{Bad}_{j}</span>: In this case we bound the probability that <span class="math">X_{0}=1</span> alone. It is useful to observe that if a challenge <span class="math">c_{\\ell}\\in\\mathsf{Bad}_{j}</span> then all challenges which differ only on the <span class="math">j</span>-th coordinate also belong to <span class="math">\\mathsf{Bad}_{j}</span>. This means that we can partition the set <span class="math">\\mathsf{Bad}_{j}</span> into sets each of size exactly $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For a given set </span>B<span class="math">, we denote by </span>\\mathsf{Rep}(B)<span class="math"> an element representative of this set, chosen arbitrarily. We also denote the union of such sets as </span>\\mathsf{BadS}_{j}$. Then we have that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr_{c_{\\ell}\\leftarrow\\mathsf{Bad}_{j}}\\left[X_{0}=1\\right]</span> $=\\sum_{c_{\\ell}\\in\\mathsf{Bad}_{j}}\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Bad}_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr\\left[1=\\mathsf{V}(\\mathbf{c},c_{\\ell},\\mathbf{z})\\right]$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$<\\frac{1}{\\sqrt{n}}+\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the last inequality holds because for any <span class="math">c_{\\ell}\\in R</span> with <span class="math">j</span>-th coordinate <span class="math">s_{j}</span> we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr_{s^{<em>}\\leftarrow S\\setminus\\{s_{j}\\}}\\left[1=\\mathsf{V}(\\mathbf{c},\\mathsf{Sub}(c_{\\ell},j,s^{</em>}),\\mathbf{z})\\right]</span> $=\\sum_{s^{*}\\leftarrow S\\setminus\\{s_{j}\\}}\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\Pr\\left[1=\\mathsf{V}(\\mathbf{c},\\mathsf{Sub}(c_{\\ell},j,s^{*}),\\mathbf{z})\\right]$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\geq\\sum_{s^{*}\\leftarrow S}\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\Pr\\left[1=\\mathsf{V}(\\mathbf{c},\\mathsf{Sub}(c_{\\ell},j,s^{*}),\\mathbf{z})\\right]-\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=\\Pr_{s^{<em>}\\leftarrow S}\\left[1=\\mathsf{V}(\\mathbf{c},\\mathsf{Sub}(c_{\\ell},j,s^{</em>}),\\mathbf{z})\\right]-\\frac{1}{</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700">}.$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By an application of the triangle inequality, and recalling that the success probability of the adversary is <span class="math">p^{*}\\geq\\gamma_{t-1}</span>, we can conclude that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr\\left[X_{0}=1\\ \\&amp;\\ \\sum_{j}X_{j}=\\xi\\right]</span> $\\geq\\Pr\\left[X_{0}=1\\right]-\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq\\frac{1}{\\sqrt{n}}</span></p>

    <p class="text-gray-300">where we have used the fact that the algorithm is <span class="math">\\eta</span>-persistent. Appealing to the independence of different measurements across the outer loop, we can conclude that the probability that the extractor fails is bounded by</p>

    <p class="text-gray-300"><span class="math">\\left(1-\\frac{1}{\\sqrt{n}}\\right)^{n}\\leq e^{-\\sqrt{n}}.</span></p>

    <h5 id="sec-64" class="text-base font-semibold mt-4">Inductive Step</h5>

    <p class="text-gray-300">We consider the following sequence of hybrids distribution.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{0}</span>: This is the original distribution on the LHS.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{Hyb}_{1}</span>: We modify the extractor so that the answer of the adversary on register <span class="math">\\mathcal{W}</span> is no longer measured and instead the tuple <span class="math">\\{j,\\cdot,\\bot\\}</span> is added to <span class="math">W_{s}</span> (if <span class="math">b=1</span>). The extraction is considered successful if there exists an <span class="math">s</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_{s}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\xi+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Indistinguishability follows by last-round collapsing. At this point, all measurements performed after <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span> are binary-outcome, and therefore from this point on we can assume that the adversary is <span class="math">\\eta</span>-persistent.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Hyb}_{2}</span>: We now add the tuple <span class="math">\\{j,\\cdot,\\bot\\}</span> to <span class="math">W_{s}</span> if <span class="math">b^{\\prime}=1</span> and we skip the call of the the extractor <span class="math">\\mathsf{Ext}_{i+1}</span>.</li>

    </ul>

    <p class="text-gray-300">Indistinguishability of this hybrid follows by induction hypothesis. Using the same notation and argument as we used above (barring some obvious syntactical modifications) we can show that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[X_{0}=1\\ \\&\\ \\sum_{j}X_{j}=\\xi\\right]\\geq\\Pr\\left[X_{0}=1\\right]-\\eta-\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At this point we can appeal to Lemma 8 (Markov) to bound</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[X_{0}=1\\right]\\geq\\mathbb{E}[X_{0}]-\\gamma_{i}\\geq\\gamma_{i+1}-\\gamma_{i}=\\eta+\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)+\\frac{1}{\\sqrt{n}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Plugging things together, we obtain that each iteration of the outer loop is successful with probability at least <span class="math">1/\\sqrt{n}</span>. We can therefore bound the probability that at least one iteration is successful to be at least <span class="math">1-e^{\\sqrt{n}}</span>, similarly as above. This concludes our proof.</p>

    <p class="text-gray-300">We are now ready to state the main theorem.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be public-coin <span class="math">\\ell</span>-round interactive recursive friendly proof system for relation <span class="math">\\mathsf{R}</span> and suppose the challenge space of <span class="math">\\mathcal{V}</span> in each round is <span class="math">S^{\\xi}</span>. If <span class="math">\\Pi</span> is <span class="math">\\xi</span>-coordinate-wise special-sound and last-round collapsing, then for any polynomial <span class="math">\\ell</span>, the protocol is knowledge sound with knowledge error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{\\ell\\cdot\\xi}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{1}{\\mathsf{poly}(\\lambda)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for a vanishing inverse-polynomial <span class="math">1/\\mathsf{poly}(\\lambda)</span>. The runtime of the extractor depends on <span class="math">\\mathsf{poly}(\\lambda)</span>.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof follows by observing that the expected value of <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(1)}(\\rho)</span> is precisely the success probability of the attacker. Thus, by an application of Lemma 8 (Markov) and Lemma 9, we obtain that the soundness gap is negligibly close to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\gamma_{0}=\\left(\\eta+\\xi\\left(e^{-\\sqrt{n}+\\eta n}+\\frac{1}{\\sqrt{n}}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)+\\frac{1}{\\sqrt{n}}\\right)\\cdot\\ell.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We obtain the theorem statement by setting <span class="math">\\eta</span> and <span class="math">n</span> to be growing polynomials in the security parameter.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">Runtime of the Extractor.</h4>

    <p class="text-gray-300">To bound the runtime of the extractor it suffices to observe that Lemma 9 shows that the (unitary dilation of the) extractor <span class="math">\\mathsf{Ext}_{i+1}</span> is invoked at most <span class="math">n^{2}\\cdot 2(\\xi+1)</span> times by the extractor <span class="math">\\mathsf{Ext}_{i}</span>. Therefore, the above extraction procedure can be implemented (approximately, up to negligible factors) with a quantum algorithm of size</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ext}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{poly}(\\lambda)+n^{2}(2\\xi+2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Ext}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the dependency in <span class="math">\\eta</span> is absorbed in the first summand. Solving the recursion, we obtain that the total runtime of the extractor is bounded by</p>

    <p class="text-gray-300"><span class="math">\\mathsf{poly}(\\lambda)\\cdot\\sum_{i=1}^{\\ell}2n^{2i}(2\\xi+2)^{i}.</span></p>

    <p class="text-gray-300">For constant-round protocols, the above bound is a polynomial in the security parameters. For log-round protocol, the runtime of the extractor is slightly super-polynomial.</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">B.5 From Simplified Adversaries to General Adversaries</h3>

    <p class="text-gray-300">In the following we discuss how to lift the simplifying assumptions on the nature of the attacker.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">Persistence.</h4>

    <p class="text-gray-300">First, we show how to make sure that the attacker is persistent, i.e., that the success probability drops by at most <span class="math">\\eta</span>. The transformation relies on the following (adapted) state-repair lemma from <em>[CMSZ22]</em>. We recall a special case of the statement proven in <em>[CMSZ22]</em>, where we restrict our attention to binary-outcome measurements (as opposed to general projective measurements), which will suffice for our purposes.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}</span> be a Hilbert space. There exist efficient quantum algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho,1^{\\varepsilon})</span>: On input a binary-outcome projective measurement <span class="math">\\mathsf{M}</span>, and an accuracy parameter <span class="math">1^{\\varepsilon}</span>, outputs a quantum state <span class="math">\\rho^{<em>}\\in\\mathcal{H}</span> and a value <span class="math">p^{</em>}\\in[0,1]</span>.</li>

      <li><span class="math">\\sigma^{<em>}\\leftarrow\\mathsf{Repair}_{\\mathsf{M},\\mathsf{N}}(\\sigma,y,p,1^{\\varepsilon})</span>: On input two binary-outcome projective measurements <span class="math">\\mathsf{M}</span> and <span class="math">\\mathsf{N}</span>, a state <span class="math">\\sigma\\in\\mathcal{H}</span>, an outcome <span class="math">y\\in\\{0,1\\}</span>, a probability <span class="math">p\\in[0,1]</span> and an accuracy parameter <span class="math">1^{\\varepsilon}</span>, outputs a quantum state <span class="math">\\sigma^{</em>}\\in\\mathcal{H}</span>.</li>

    </ul>

    <p class="text-gray-300">Such that the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Value Estimate) <span class="math">\\mathbb{E}[p^{<em>}:\\left(\\rho^{</em>},p^{*}\\right)\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho,1^{\\varepsilon})]=\\Pr[(\\cdot,1)\\leftarrow\\mathsf{M}(\\rho)]</span>.</li>

      <li>(Estimate is Almost Projective) For any <span class="math">\\varepsilon\\geq\\varepsilon^{\\prime}&gt;0</span> it holds that:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p^{*}-p^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\varepsilon:\\begin{matrix}(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho,1^{\\varepsilon})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(\\rho^{<strong>},p^{</strong>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho^{*},1^{\\varepsilon^{\\prime}})\\end{matrix}\\right]\\leq\\varepsilon.$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(State Repair) For any <span class="math">\\varepsilon&gt;0</span> it holds that:</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}&(\\rho^{<em>},p^{</em>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\rho,1^{\\varepsilon})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho^{*}-p^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\varepsilon:&(\\sigma,y)\\leftarrow\\mathsf{N}(\\rho^{*})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&\\sigma^{<em>}\\leftarrow\\mathsf{Repair}_{\\mathsf{M},\\mathsf{N}}(\\sigma,y,p^{</em>},1^{\\varepsilon})\\\\ &(\\rho^{<strong>},p^{</strong>})\\leftarrow\\mathsf{ValEst}_{\\mathsf{M}}(\\sigma^{*},1^{\\varepsilon})\\end{matrix}\\right]\\leq\\varepsilon. \\]</p>

    <p class="text-gray-300">Equipped with this lemma, it is easy to modify the extractor to make sure that persistence is maintained: At the beginning of each iteration, we run the estimation procedure <span class="math">\\mathsf{ValEst}_{\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})}</span>, where the measurement <span class="math">\\mathsf{M}(i,\\mathbf{c},\\mathbf{z})</span> is defined in Eq. (25). Then, at the end of each loop (specifically, after applying the unitary <span class="math">U_{i}(c_{i})^{\\dagger}</span>) we run the state repair procedure appropriately, regardless of the outcome. Note that this excludes the measurements on the register <span class="math">\\mathcal{W}</span>, which are not binary-outcome. In that case, we simply perform these measurement without any state repair. In the analysis, we can argue that these measurement do not affect the success probability of the attacker, by appealing to the last-round collapsing property of the protocol.</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">Statelessness.</h4>

    <p class="text-gray-300">In general, the only guarantee of the above theorem is that the success probability of the attacker is preserved across calls, however the distribution of the attacker’s answers may change arbitrarily. On the other hand, our analysis crucially relies on the attacker’s answers being independent even for correlated queries. To make sure that this is the case, we will leverage the technique of <em>[x11]</em>. We recall the following (adapted) lemma.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">There exists a polynomial time simulator <span class="math">\\mathsf{Sim}</span> such that the following holds. Let <span class="math">\\mathsf{Adv}</span> be an <span class="math">\\eta</span>-persistent solver (with a state of size <span class="math">\\theta</span>) for a given verification predicate <span class="math">P</span>, and let <span class="math">\\{D_{\\lambda}\\}_{\\lambda}</span> be an efficiently samplable distribution ensemble over problem instances for <span class="math">\\mathsf{Adv}</span>. Then there exits an <span class="math">\\eta</span>-persistent (by possibly inefficient) distribution over stateless solvers <span class="math">\\mathsf{Adv}^{<em>}</span>. Consider the process of sampling <span class="math">\\mathbf{x}\\leftarrow D_{\\lambda}</span> and denote by <span class="math">\\mathsf{Adv}^{</em>}(1^{\\lambda},\\mathbf{x})</span> the transcript of the process that sequentially feeds the queries in <span class="math">\\mathbf{x}</span> to <span class="math">\\mathsf{Adv}^{*}</span>. Then the simulator <span class="math">\\mathsf{Sim}</span> makes non-adaptive black-box access to <span class="math">\\mathsf{Adv}</span> and the statistical distance of the following distributions is at most <span class="math">\\delta</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{*}(1^{\\lambda},\\mathbf{x})\\approx\\mathsf{Sim}^{\\mathsf{Adv},D}(1^{\\lambda},1^{\\theta},1^{1/\\delta},\\mathbf{x})</span></p>

    <p class="text-gray-300">for an arbitrary inverse-polynomial <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">To get some context, the way the simulation proceeds is by alternating real queries by fake queries (but sampled from the correct distribution) to ensure that the state of the adversary cannot reliably memorize prior queries, thus biasing the output distribution. Importantly, the simulator needs to fix the set of real queries ahead of time. In our protocol, we can use this technique to lift the extraction against stateful adversary as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <span class="math">i</span>-th extractor samples the set of challenges ahead of time. Note that this is just a syntactical modification, since the queries to the adversary are correlated but already chosen non-adaptively.</li>

      <li>Instead of running the adversary directly, run the simulator <span class="math">\\mathsf{Sim}</span> with appropriately set parameters. For the last-round extractor we will set the verification predicate <span class="math">P</span> to be the predicate that checks whether the answer of the adversary is valid or not, whereas for the general extractor we will set the predicate <span class="math">P</span> to be the <span class="math">\\mathsf{Thresh}</span> measurement. Note that in both cases the predicates have binary output.</li>

    </ul>

    <p class="text-gray-300">In the analysis, we can then appeal to the above lemma, to ensure that the response of the adversary are statistically close to that of a stateless one.</p>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">B.6 Non-Interactive Security in the QROM</h3>

    <p class="text-gray-300">To argue security of the non-interactive variant of the protocol in the quantum random oracle model (QROM), it suffices to recall the following statement from <em>[x14]</em>.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 12.</h6>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be an integer, and <span class="math">X_{0}</span>, <span class="math">X,Y</span> be finite sets. There exists an <span class="math">\\ell</span>-message polynomial-time quantum algorithm <span class="math">\\mathsf{Sim}</span> that is receives <span class="math">y_{i}</span> only after outputting <span class="math">x_{i-1}</span>, such that the following holds. Let <span class="math">\\mathsf{Adv}</span> be an arbitrary quantum</p>

    <p class="text-gray-300">oracle algorithm that makes <span class="math">Q</span> queries to a uniformly random function <span class="math">H:(X_0\\cup Y)\\times X\\to Y</span> and outputs a tuple <span class="math">(x_0,\\ldots ,x_\\ell)</span>. Then for any <span class="math">\\tilde{x}\\in X_0\\times X^\\ell</span> without duplicate entries, any predicate <span class="math">V</span>:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Pr \\left[ (x _ {0}, \\dots , x _ {\\ell}) = \\tilde {x} \\&amp; V (x _ {0}, y _ {1}, \\dots , y _ {\\ell}, x _ {\\ell}) = 1: (x _ {0}, \\dots , x _ {\\ell}) \\leftarrow \\operatorname {S i m} ^ {\\mathsf {A d v}} (y _ {1}, \\dots , y _ {\\ell}) \\right] \\\\ \\geq \\frac {\\ell !}{(Q + \\ell + 1) ^ {2 \\ell}} \\Pr \\left[ (x _ {0}, \\dots , x _ {\\ell}) = \\tilde {x} \\&amp; V (x _ {0}, H (x _ {0}), \\dots , H (y _ {c - 1}, x _ {c - 1}), x _ {\\ell}) = 1: (x _ {0}, \\dots , x _ {\\ell}) \\leftarrow \\mathsf {A d v} ^ {H} \\right] \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\varepsilon_ {\\tilde {x}} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where the first probability is taken over the random choice of <span class="math">(y_{1},\\ldots ,y_{\\ell})</span> and the second probability is taken over the random choice of <span class="math">H</span>. Furthermore</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {\\tilde {x}} \\varepsilon_ {\\tilde {x}} = \\frac {\\ell !}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For constant-round protocols, the simulator Sim is a valid prover (since it receives and sends message in sequence) with success probability polynomially related to that of Adv. This allows us to reduce the soundness to that of the interactive protocol in a black-box manner.</p>

    <h2 id="sec-75" class="text-2xl font-bold">C Omitted Proofs from Section 3</h2>

    <p class="text-gray-300">Theorem 1. Let <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell +1)</span>-message public-coin recursive friendly argument system for a relation <span class="math">\\Re</span> with associated relations <span class="math">(\\Re_{\\ell -i})_{i\\in [0,\\ell]}</span>. If <span class="math">\\Pi</span> is round-by-round for the tuple of relations <span class="math">(\\Re_{\\ell -i})_{i\\in [0,\\ell]}</span>, then <span class="math">\\Pi</span> is complete for the relation <span class="math">\\Re</span>.</p>

    <p class="text-gray-300">Proof. By definition of round-by-round completeness (Definition 7) we know that the following two implications are true for all <span class="math">i \\in [0, \\ell - 1]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(\\mathsf{pp},x_i,w_i)\\in \\Re_{\\ell -i}</span>, then <span class="math">b_{i} = 1</span>,</li>

      <li>if <span class="math">(\\mathsf{pp},x_i,w_i)\\in \\Re_{\\ell -i}</span>, then <span class="math">(\\mathsf{pp},x_{i + 1},w_{i + 1})\\in \\Re_{\\ell -i - 1}</span>.</li>

    </ul>

    <p class="text-gray-300">It follows that, if <span class="math">(\\mathsf{pp},x_0,w_0)\\in \\Re_{\\ell}</span>, then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b_{i} = 1</span>, for all <span class="math">i \\in [0, \\ell - 1]</span>,</li>

      <li><span class="math">(\\mathsf{pp},x_{\\ell},w_{\\ell})\\in \\Re_{0}</span></li>

    </ul>

    <p class="text-gray-300">which means that the verifier <span class="math">\\mathcal{V}</span> accepts. Notice that <span class="math">\\Re_{\\ell} = \\Re</span>. This concludes the proof.</p>

    <p class="text-gray-300">Before proving Theorem 2, let us recall the definition of coordinate-wise special soundness.</p>

    <p class="text-gray-300">Definition 11 (Coordinate-Wise Special Soundness [FMN23]). Let <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be public-coin <span class="math">(2\\ell +1)</span>-round interactive proof system for relation <span class="math">\\Re</span>, where in each round the verifier picks a uniformly random challenge from <span class="math">S^{\\ell}</span>. A tree of transcripts is a set of <span class="math">(\\xi +1)^{\\ell}</span> arranged in the following tree structure. The nodes in the tree correspond to the prover's messages and the edges correspond to the verifier's challenges. Each node at depth <span class="math">i</span> has exactly <span class="math">\\xi +1</span> children corresponding to <span class="math">\\xi +1</span> distinct challenges which, as a concatenated vector, lie in <span class="math">\\Gamma (S,\\xi)</span>. Every transcript corresponds to exactly one path from the root to a leaf node. We say that <span class="math">\\Pi</span> is <span class="math">\\xi</span>-coordinate-wise special sound if there is a polynomial time algorithm <span class="math">\\mathcal{E}</span> that given a statement <span class="math">x</span> and the tree of transcripts, outputs a witness <span class="math">w</span> such that <span class="math">(\\mathsf{pp},x,w)\\in \\Re</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. Let <span class="math">\\Pi = (\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(2\\ell +1)</span>-message public-coin recursive friendly argument system for a relation <span class="math">\\Re</span> with associated relations <span class="math">(\\Re_{\\ell -i})_{i\\in [0,\\ell]}</span>. If <span class="math">\\Pi</span> is round-by-round <span class="math">\\xi</span>-coordinate-wise special sound for the tuple of relations <span class="math">(\\Re_{\\ell -i}^{<em>})_{i\\in [0,\\ell]}</span> and <span class="math">(\\xi +1)^{\\ell} = \\mathsf{poly}(\\lambda)</span>, then <span class="math">\\Pi</span> is knowledge sound for the relation <span class="math">\\Re_{\\xi}^{</em>}</span> with knowledge error $\\ell \\xi /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">Proof. We will prove that <span class="math">\\Pi</span> is <span class="math">\\xi</span>-coordinate-wise special sound for relation <span class="math">\\mathsf{R}_{\\ell,\\beta_{\\ell}^{<em>}}</span>. By </em>[x13, Definition 2.30]<em>, since <span class="math">\\beta_{\\ell}^{</em>}=(2r\\kappa)^{\\ell}\\beta</span>, this will prove the theorem. Let</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},x_{0},z_{0},c_{1}^{(k_{1})},\\ldots,z_{i-1}^{(k_{1},\\ldots,k_{i-1})},c_{i}^{(k_{1},\\ldots,k_{i})},\\ldots,z_{\\ell-1}^{(k_{1},\\ldots,k_{\\ell-1})},c_{\\ell}^{(k_{1},\\ldots,k_{\\ell})},w_{\\ell}^{(k_{1},\\ldots,k_{\\ell})}\\right)</span></p>

    <p class="text-gray-300">where <span class="math">k_{1},\\ldots,k_{\\ell}\\in[\\xi+1]</span>, be a tree of transcripts. For each <span class="math">i\\in[\\ell]</span>, <span class="math">k_{1},\\ldots,k_{\\ell}\\in[\\xi+1]</span>, let</p>

    <p class="text-gray-300"><span class="math">x_{i}^{(k_{1},\\ldots,k_{i})}\\coloneqq\\mathsf{NextX}_{\\leq i-1}\\left(\\mathsf{pp},x_{0},z_{0},\\ldots,z_{i-1}^{(k_{1},\\ldots,k_{i-1})},c_{1}^{(k_{1})},\\ldots,c_{i}^{(k_{1},\\ldots,k_{i})}\\right)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{NextX}_{\\leq i}</span> is defined recursively.</p>

    <p class="text-gray-300">By definition of tree of transcripts, we have</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}_{i}\\left(\\mathsf{pp},x_{i}^{(k_{1},\\ldots,k_{i})},z_{i}^{(k_{1},\\ldots,k_{i})}\\right)=1</span>, for all <span class="math">i\\in[0,\\ell-1]</span>, <span class="math">k_{1},\\ldots,k_{i}\\in[\\xi+1]</span>,</li>

      <li><span class="math">\\left(\\mathsf{pp},x_{\\ell}^{(k_{1},\\ldots,k_{\\ell})},w_{\\ell}^{(k_{1},\\ldots,k_{\\ell})}\\right)\\in\\mathfrak{R}_{0}</span>, for all <span class="math">k_{1},\\ldots,k_{\\ell}\\in[\\xi+1]</span>.</li>

    </ul>

    <p class="text-gray-300">Claim. For each <span class="math">i\\in[0,\\ell]</span>, <span class="math">k_{1},\\ldots,k_{i}\\in[\\xi+1]</span>, there exists an extractor <span class="math">\\mathsf{Ext}_{i}</span> that, given as input a tree of transcripts, outputs <span class="math">w_{i}^{(k_{1},\\ldots,k_{i-1},k_{i})}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},\\mathsf{NextX}_{i-1}\\left(\\mathsf{pp},x_{i-1}^{(k_{1},\\ldots,k_{i-1})},z_{i-1}^{(k_{1},\\ldots,k_{i-1})},c_{i}^{(k_{1},\\ldots,k_{i-1},k_{i})}\\right),w_{i}^{(k_{1},\\ldots,k_{i-1},k_{i})}\\right)\\in\\mathfrak{R}_{\\ell-i}^{*}</span></p>

    <p class="text-gray-300">Given the claim, we can finish the proof of the theorem. For <span class="math">\\ell=0</span>, we have that there exists <span class="math">\\mathsf{Ext}_{0}</span> that outputs <span class="math">w_{0}</span> such that</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},x_{0},w_{0})\\in\\mathfrak{R}_{\\ell}^{*}</span></p>

    <p class="text-gray-300">as desired. ∎</p>

    <p class="text-gray-300">It remains to prove the claim.</p>

    <p class="text-gray-300">Proof. We are going to proceed by induction on <span class="math">i</span>.</p>

    <p class="text-gray-300">Base Case: <span class="math">i=\\ell</span>. The extractor <span class="math">\\mathsf{Ext}_{\\ell}</span>, on input a tree of transcripts, simply outputs <span class="math">w_{\\ell}^{(k_{1},\\ldots,k_{\\ell})}</span> from the tree of transcripts. Indeed, by definition of tree of transcripts, one has that</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},x_{\\ell}^{(k_{1},\\ldots,k_{\\ell})},w_{\\ell}^{(k_{1},\\ldots,k_{\\ell})}\\right)\\in\\mathfrak{R}_{0}</span></p>

    <p class="text-gray-300">for all <span class="math">k_{1},\\ldots,k_{\\ell}\\in[\\xi+1]</span>, as required.</p>

    <p class="text-gray-300">Induction Hypothesis. Let <span class="math">i+1\\leq\\ell</span>. There exists an extractor <span class="math">\\mathsf{Ext}_{i+1}</span> that, given as input a tree of transcripts, outputs <span class="math">w_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},\\mathsf{NextX}_{i}\\left(\\mathsf{pp},x_{i}^{(k_{1},\\ldots,k_{i})},z_{i}^{(k_{1},\\ldots,k_{i})},c_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}\\right),w_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}\\right)\\in\\mathfrak{R}_{\\ell-i-1}^{*}</span></p>

    <p class="text-gray-300">Inductive Step. Given the induction hypothesis, we need to show the existence of an extractor <span class="math">\\mathsf{Ext}_{i}</span>. Notice that</p>

    <p class="text-gray-300"><span class="math">x_{i}^{(k_{1},\\ldots,k_{i})},\\quad z_{i}^{(k_{1},\\ldots,k_{i})},\\quad c_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})},\\quad w_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}</span> (27)</p>

    <p class="text-gray-300">are such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{V}_{i}\\left(\\mathsf{pp},x_{i}^{(k_{1},\\ldots,k_{i})},z_{i}^{(k_{1},\\ldots,k_{i})}\\right)=1</span>,</li>

      <li><span class="math">\\left(c_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}\\right)_{k_{i+1}\\in[0,\\xi]}\\in\\Gamma(S,\\xi)</span>,</li>

    </ul>

    <p class="text-gray-300">where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\left(\\mathsf{pp},x_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})},w_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}\\right)\\in\\mathfrak{R}^{*}_{\\ell-i-1}</span> where <span class="math">x_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}=\\mathsf{NextX}_{i}\\left(\\mathsf{pp},x_{i}^{(k_{1},\\ldots,k_{i})},z_{i}^{(k_{1},\\ldots,k_{i})},c_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}\\right)</span>,</li>

    </ul>

    <p class="text-gray-300">where the first two properties follow by definition of tree of transcripts, and the last one by the induction hypothesis. This means that the tuple on Equation (27) satisfies Definition 9: there exists an extractor <span class="math">\\mathsf{Ext}_{i}^{\\mathsf{rbr}}</span> that, on input such a tuple, outputs <span class="math">w_{i}^{(k_{1},\\ldots,k_{i})}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{pp},x_{i}^{(k_{1},\\ldots,k_{i})},w_{i}^{(k_{1},\\ldots,k_{i})}\\right)\\in\\mathfrak{R}^{*}_{\\ell-i}.</span></p>

    <p class="text-gray-300">Then, we define recursively the extractor <span class="math">\\mathsf{Ext}_{i}</span> as follows: on input a tree of transcripts, <span class="math">\\mathsf{Ext}_{i}</span> runs <span class="math">\\mathsf{Ext}_{i+1}</span> to obtain <span class="math">w_{i+1}^{(k_{1},\\ldots,k_{i},k_{i+1})}</span>. It then runs <span class="math">\\mathsf{Ext}_{i}^{\\mathsf{rbr}}</span> on input the tuple from Equation (27), and return whatever <span class="math">\\mathsf{Ext}_{i}^{\\mathsf{rbr}}</span> returns. This concludes the proof of the claim. ∎</p>

    <h2 id="sec-76" class="text-2xl font-bold">Appendix D Omitted Proofs from Section 4</h2>

    <h6 id="sec-77" class="text-base font-medium mt-4">Theorem 4 (Binding).</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">\\mathsf{CM}</span> is binding assuming <span class="math">\\mathsf{SIS}_{n,rn\\alpha,q,\\beta^{\\prime}}</span> with <span class="math">\\beta^{\\prime}\\geq 2\\beta</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We reduce directly to the hardness of the <span class="math">\\mathsf{SIS}_{n,rn\\alpha,q,\\beta^{\\prime}}</span> problem. Parse <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{n\\times rn\\alpha}</span> from the <span class="math">\\mathsf{SIS}_{n,(\\ell+1)rn\\alpha,q,\\beta^{\\prime}}</span> instance, and let and <span class="math">\\mathsf{pp}=\\{\\mathbf{A}\\}</span>. Such <span class="math">\\mathsf{pp}</span> is distributed exactly as in the real scheme. Now, suppose by contradiction that an adversary <span class="math">\\mathcal{A}</span>, on input <span class="math">\\mathsf{pp}</span>, breaks the binding property, i.e., it produces <span class="math">(\\mathbf{t},((\\mathbf{s}_{0,j})_{j\\in[0,\\ell]},\\mathbf{f}_{0}),((\\mathbf{s}_{1,j})_{j\\in[0,\\ell]},\\mathbf{f}_{1}))</span> such that <span class="math">\\mathbf{f}_{0}\\neq\\mathbf{f}_{1}</span> and</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{r\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{b,0}=\\mathbf{t}\\bmod q,</span> (28) <span class="math">\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{b,j}=(\\mathbf{I}_{r^{j+1}\\kappa n\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{b,j+1}\\quad\\text{ for all }j\\in[0,\\ell-1],</span> <span class="math">\\mathbf{G}_{r^{\\ell+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{b,\\ell}=\\mathbf{f}_{b}\\bmod q,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{b,j}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta\\quad\\text{ for all }j\\in[0,\\ell].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for <span class="math">b\\in\\{0,1\\}</span>. We are going to use the following observation</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathsf{SIS}</span> is hard w.r.t. <span class="math">\\mathbf{B}</span>, then <span class="math">\\mathsf{SIS}</span> is hard w.r.t. <span class="math">\\mathbf{I}_{k}\\otimes\\mathbf{B}</span>, for any <span class="math">k\\in\\mathbb{N}</span>.</li>

    </ul>

    <p class="text-gray-300">Consider the largest <span class="math">j\\in[0,\\ell]</span> such that</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{I}_{r^{j}\\kappa n\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{0,j}=(\\mathbf{I}_{r^{j}\\kappa n\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{1,j}\\bmod q</span> (29)</p>

    <p class="text-gray-300">Such a <span class="math">j</span> exists because <span class="math">(\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{0,0}=\\mathbf{t}=(\\mathbf{I}_{\\kappa\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{1,0}\\bmod q</span>. Next, we claim that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{0,j}\\neq\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{1,j}</span></p>

    <p class="text-gray-300">This follows by a case analysis:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">j=\\ell</span>, then since <span class="math">\\mathbf{f}_{0}\\neq\\mathbf{f}_{1}</span>, we have <span class="math">\\mathbf{G}_{r^{\\ell+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{0,\\ell}=\\mathbf{f}_{0}\\neq\\mathbf{f}_{1}=\\mathbf{G}_{r^{\\ell+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{1,\\ell}</span>;</li>

      <li>if <span class="math">j&lt;\\ell</span>, then by the maximality of <span class="math">j</span>, we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\overbrace{\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{0,j}}^{\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{0,j}}\\overbrace{(\\mathbf{I}_{r^{j+1}\\kappa n\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{0,j+1}}^{\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{1,j}}\\overbrace{(\\mathbf{I}_{r^{j+1}\\kappa n\\tau}\\otimes\\mathbf{A})\\cdot\\mathbf{s}_{1,j+1}}^{\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{1,j}}</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{0,j}\\neq\\mathbf{G}_{r^{j+1}\\kappa n\\tau}\\cdot\\mathbf{s}_{1,j}</span>, we deduce that <span class="math">\\mathbf{s}_{0,j}\\neq\\mathbf{s}_{1,j}</span>, and therefore <span class="math">\\mathbf{s}_{0,j}-\\mathbf{s}_{1,j}</span> is a valid <span class="math">\\mathsf{SIS}</span> solution w.r.t. <span class="math">(\\mathbf{I}_{r^{j}\\kappa n\\tau}\\otimes\\mathbf{A})</span>. Using the observations mentioned before, this concludes the proof. ∎</p>

    <h2 id="sec-79" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">E Omitted Proofs from Section 6</p>

    <p class="text-gray-300">Lemma 13. Let <span class="math">\\mathbf{x}[i]</span> denote the <span class="math">i</span>-th entry of the vector <span class="math">\\mathbf{x}</span> (counting from 1). Consider vectors <span class="math">\\mathbf{x}_i \\in \\mathbb{Z}_q^{r_i}</span>, <span class="math">i \\in [0, \\ell]</span> and the vector</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x}^{\\top} := \\mathbf{x}_{\\ell}^{\\top} \\cdot (\\mathbf{I}_{r_{\\ell}} \\otimes \\mathbf{x}_{\\ell-1}^{\\top}) \\cdots (\\mathbf{I}_{r_{\\ell} \\cdots r_{1}} \\otimes \\mathbf{x}_{0}^{\\top}).</span></div>

    <p class="text-gray-300">Then, for all <span class="math">j_{i} \\in [r_{i}]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x}[1 + \\sum_{i=0}^{\\ell} R_{i}(j_{i} - 1)] = \\prod_{i=0}^{\\ell} \\mathbf{x}_{i}[j_{i}].</span></div>

    <p class="text-gray-300">where <span class="math">R_{i} = r_{0}\\cdots r_{i-1}</span>.</p>

    <p class="text-gray-300">Proof. We prove the claim by induction on <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">Base Case: <span class="math">\\ell = 0</span>. We have <span class="math">\\mathbf{x}^{\\top} = \\mathbf{x}_0^{\\top}</span>. Therefore, for all <span class="math">j_0 \\in [r_0]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{x}[1 + \\sum_{i=0}^{\\ell} R_{i,\\ell}(j_{i} - 1)] &amp;amp;= \\mathbf{x}[1 + R_{0}(j_{0} - 1)] \\\\ &amp;amp;= \\mathbf{x}_{0}[1 + (j_{0} - 1)] \\\\ &amp;amp;= \\mathbf{x}_{0}[j_{0}] \\\\ &amp;amp;= \\prod_{i=0}^{\\ell} \\mathbf{x}_{i}[j_{0}]. \\end{aligned}</span></div>

    <p class="text-gray-300">Inductive Step. Suppose the claim is true for some <span class="math">\\ell \\geq 1</span>, and consider</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{x}^{\\top} &amp;amp;= \\mathbf{x}_{\\ell}^{\\top} \\cdot (\\mathbf{I}_{r_{\\ell}} \\otimes \\mathbf{x}_{\\ell-1}^{\\top}) \\cdot (\\mathbf{I}_{r_{\\ell} r_{\\ell-1}} \\otimes \\mathbf{x}_{\\ell-2}^{\\top}) \\cdots (\\mathbf{I}_{r_{\\ell} \\cdots r_{2} r_{1}} \\otimes \\mathbf{x}_{r_{0}}^{\\top}) \\\\ &amp;amp;= \\mathbf{x}_{\\ell}^{\\top} \\cdot \\left( \\mathbf{I}_{r_{\\ell}} \\otimes \\underbrace{\\left( \\mathbf{x}_{\\ell-1}^{\\top} \\cdot (\\mathbf{I}_{r_{\\ell-1}} \\otimes \\mathbf{x}_{\\ell-2}^{\\top}) \\cdots (\\mathbf{I}_{r_{\\ell-1} \\cdots r_{1}} \\otimes \\mathbf{x}_{0}^{\\top}) \\right)}_{\\tilde{\\mathbf{x}}} \\right) \\end{aligned}</span></div>

    <p class="text-gray-300">By induction hypothesis, we have that for all <span class="math">j_{i} \\in [r_{i}]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\overline{\\mathbf{x}}[1 + \\sum_{i=0}^{\\ell-1} R_{i}(j_{i} - 1)] = \\prod_{i=0}^{\\ell-1} \\mathbf{x}_{i}[j_{i}].</span></div>

    <p class="text-gray-300">On the other hand, for <span class="math">j_{\\ell} \\in [r_{\\ell}]</span> and <span class="math">j \\in [r_0 \\cdots r_{\\ell-1}]</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{x}[1 + (r_{0} \\cdots r_{\\ell-1}) \\cdot (j_{\\ell} - 1) + (j - 1)] = \\mathbf{x}_{\\ell}[j_{\\ell}] \\cdot \\bar{\\mathbf{x}}[j]</span></div>

    <p class="text-gray-300">Writing <span class="math">j = 1 + \\sum_{i=0}^{\\ell-1} R_i(j_i - 1)</span> for <span class="math">j_i \\in [r_i]</span>, and using that <span class="math">R_{\\ell} = r_0 \\cdots r_{\\ell-1}</span>, we deduce that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{x}[1 + \\sum_{i=0}^{\\ell} R_{i}(j_{i} - 1)] &amp;amp;= \\mathbf{x}[1 + R_{\\ell}(j_{\\ell} - 1) + \\sum_{i=0}^{\\ell-1} R_{i}(j_{i} - 1)] \\\\ &amp;amp;= \\mathbf{x}[1 + (r_{0} \\cdots r_{\\ell-1}) \\cdot (j_{\\ell} - 1) + (j - 1)] \\\\ &amp;amp;= \\mathbf{x}_{\\ell}[j_{\\ell}] \\cdot \\bar{\\mathbf{x}}[j] \\\\ &amp;amp;= \\mathbf{x}_{\\ell}[j_{\\ell}] \\cdot \\prod_{i=0}^{\\ell-1} \\mathbf{x}_{i}[j_{i}] \\\\ &amp;amp;= \\prod_{i=0}^{\\ell} \\mathbf{x}_{i}[j_{i}], \\end{aligned}</span></div>

    <p class="text-gray-300">as claimed. This concludes the proof.</p>`;
---

<BaseLayout title="Polynomial Commitments from Lattices: Post-Quantum Security,... (2024/281)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/281
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
