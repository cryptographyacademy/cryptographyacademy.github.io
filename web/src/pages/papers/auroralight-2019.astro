---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/601';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="AuroraLight (2019/601)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        AuroraLight: Improved prover efficiency and SRS size
        in a Sonic-like system
      </h1>
      <p class="text-gray-400 mb-2">
        Ariel Gabizon
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; Full Version &middot; eprint 2019/601
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                The three modes of Sonic</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Our results compared to [MBKM19]</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">
                Organization of paper</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            Terminology/conventions</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            The [KZG10] scheme as used in Sonic</a>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            The main construction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                The main protocol</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Protocol summary</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            Batching arbitrary proofs with the Sonic helper</a>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Getting zero-knowledge</a>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">
            Open question: getting a fully succinct verifier</a>
        </li>
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ol>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Abstract</h2>
      <p class="text-gray-300">
        Using ideas from the recent Aurora zk-STARK of Ben-Sasson et
        al. [BCR+19], we present a zk-SNARK with a universal and
        updatable SRS similar to the recent construction of Maller et
        al. [MBKM19], called Sonic. Compared to Sonic, our
        construction achieves significantly better prover run time
        (less than half) and smaller SRS size (one sixth). However,
        we only achieve amortized succinct verification time for
        batches of proofs, either when the proofs are generated in
        parallel or in [MBKM19]&rsquo;s helper setting, and our
        proofs are longer than those of [MBKM19] (but still contain a
        constant number of field and group elements).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">1 &ensp; Introduction</h2>

      <p class="text-gray-300">
        Due to real-world deployments of zk-SNARKs, e.g. Zcash; it
        has become of significant interest to have the structured
        reference string (SRS) be constructible in a &ldquo;universal
        and updatable&rdquo; fashion. Meaning that the same parameters
        (a different term for the SRS) can be used for statements
        about all circuits/computations of a certain bounded size; and
        that at any point in time the parameters can be updated by a
        new party, such that the honesty of only one party from all
        updaters up to that point is required for soundness. A natural
        direction to achieve this, is by having an &ldquo;SRS of
        monomials&rdquo; meaning that the SRS consists solely of
        elements
        <span class="math">g^&#123;x^i&#125;</span>
        for a secret uniform
        <span class="math">x</span>.
        Roughly speaking, such elements are easy to update as the new
        party can just raise them to power
        <span class="math">s^i</span>
        for their secretly chosen
        <span class="math">s</span>.
      </p>

      <p class="text-gray-300 mt-4">
        Maller et al. [MBKM19] noticed that the polynomial commitment
        scheme of Kate, Zaverucha and Goldberg [KZG10] is very helpful
        in this context, as such an SRS of monomials is sufficient in
        [KZG10] to verifiably evaluate values of low-degree
        polynomials committed to by the prover &ndash; this being
        perhaps the main problem to be dealt with (without the luxury
        of an SRS) in PCP constructions using techniques such as
        low-degree testing (starting from [BFL91]) and PCPs of
        proximity [BS08] (and in more modern works also IOPs of
        proximity [BCG+17]).
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        The Sonic approach
      </h3>
      <p class="text-gray-300">
        [MBKM19]&rsquo;s Sonic uses a variant of the arithmetization
        of Bootle et al. [BCC+16] to create a situation where a
        certain polynomial of the prover can have a zero constant
        coefficient only when the prover has a satisfying assignment.
        Roughly, this is achieved by using Laurent polynomials with
        both negative and positive powers, such that their product
        cancels out in the constant term only when a satisfying
        assignment was used to construct them. A lot of the ingenuity
        of [MBKM19] is that though the polynomials from [BCC+16] are
        bi-variate and [KZG10] is only efficient for univariate
        polynomials (in the sense of linear time proving in the
        degree) they are able to maneuver in a way that only requires
        to commit and evaluate univariate restrictions of the original
        bi-variates. However, using negative powers for the
        cancellation trick comes at a price of having the polynomials
        ultimately plugged in to the [KZG10] scheme have a larger
        range of powers &ndash; roughly a
        <span class="math">7n</span>
        size range from
        <span class="math">-4n</span>
        to
        <span class="math">3n</span>
        (where
        <span class="math">n</span>
        is the number of multiplication gates in our circuit).
        Furthermore, [MBKM19] need to put a &ldquo;hole&rdquo; in
        this range to disallow the constant coefficient, which doubles
        the SRS size.
      </p>

      <p class="text-gray-300 mt-4">
        The main point is that the number of prover exponentiations
        and SRS size is directly tied to the size of this range when
        using [KZG10].
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        The Aurora approach
      </h3>
      <p class="text-gray-300">
        Instead, we use a nice algebraic trick from the Aurora IOP
        [BCR+19]. [BCR+19] uses a lemma (Lemma 4.1) connecting
        between the value of a polynomial&rsquo;s constant
        coefficient, and its sum on a multiplicative subgroup. Together
        with a randomized sum check arithmetization in the style of
        [BCG+17, BCR+19], this allows us to create a &ldquo;constant
        coefficient=0 iff prover has witness&rdquo; situation without
        using negative powers. This enables only dealing with (regular
        not Laurent) polynomials of degree at most
        <span class="math">2n</span>;
        i.e. we have reduced the &ldquo;monomial range&rdquo; of Sonic
        from
        <span class="math">7n</span>
        to
        <span class="math">2n</span>,
        and do not need to deal with a &ldquo;hole&rdquo; in this
        range disallowing a constant coefficient. Moreover, all but
        one of the prover polynomials will have degree at most
        <span class="math">n</span>,
        which further helps reduce prover run time. On the other hand,
        we have five polynomials to deal with rather than two as in
        [MBKM19], which is why our proofs are longer than
        Sonic&rsquo;s.
      </p>

      <p class="text-gray-300 mt-4">
        Before comparing performance with [MBKM19] in more detail, we
        discuss the three settings in which both our construction and
        Sonic can be used.
      </p>

      <!-- Section 1.1 -->
      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 &ensp; The three modes of Sonic
      </h3>

      <p class="text-gray-300">
        The basic version of the Sonic verifier, as well as ours, is
        succinct (i.e.
        <span class="math">\text&#123;polylog&#125;(\lambda)</span>
        running time) except for the need to evaluate a polynomial
        <span class="math">s(X, Y)</span>
        of
        <span class="math">O(n)</span>
        monomials. The evaluation of
        <span class="math">s</span>
        in Sonic is done once per proof, at a point
        <span class="math">(z, y)</span>
        chosen by the verifier during the protocol. There are three
        ways to deal with this evaluation.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Parallel proof generation for a batch:</strong>
        The crucial point is that the values
        <span class="math">z, y</span>
        are only revealed to the prover at certain points in the
        protocol; but beyond this, there is no dependence between the
        values
        <span class="math">z, y</span>
        and the specific statement proven &ndash; they just need to be
        uniform. It follows that if proofs are generated in parallel,
        e.g. in practice by posting the first part of all proofs on a
        blockchain and getting the random challenge
        <span class="math">z</span>
        afterwords and continuing similarly for
        <span class="math">y</span>
        &ndash; then the verifier can use the same
        <span class="math">(z, y)</span>
        for a whole batch of proofs and do the non-succinct
        <span class="math">s</span>
        evaluation only once per batch. [MBKM19] do not explicitly
        discuss this mode, but we think it may be the most practical
        both for their construction and ours.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Arbitrary batching using an untrusted helper:</strong>
        [MBKM19] develop a method where a batch of evaluations
        <span class="math">\&#123;s(z^j, y^j)\&#125;_&#123;j \in [m]&#125;</span>
        can be performed by an untrusted helper and a proof can be
        given to the verifier that the evaluations are all correct.
        Verification of this proof only requires one evaluation of
        <span class="math">s</span>.
        Hence, using this &ldquo;helper mode&rdquo; we can verify an
        arbitrary batch of proofs generated without any
        synchronization, with a non-succinct operation done only once
        per batch. This mode incurs the cost of needing such a helper,
        and adding the evaluation
        <span class="math">s(z^j, y^j)</span>
        and proof of correct evaluation, which increase the proof
        size. Our scheme can also leverage the Sonic helper, however
        with larger cost to proof size as we have six polynomials per
        proof that need to be evaluated by the verifier instead of
        one. See details in Section 5.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Fully succinct mode:</strong>
        [MBKM19] in fact manage to design a proof system that allows
        a fully succinct (i.e. not just in the amortized sense)
        verifier to verify that the evaluation
        <span class="math">s(z, y)</span>
        is correct. However, their fully succinct mode requires
        significant increase of the constants in proof size, proving
        and verification time and may be less practical. Our
        construction does not currently support this mode, but it
        seems possible an extension to this mode can be done. We pose
        this as an open question with more details in Section 7.
      </p>

      <!-- Section 1.2 -->
      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 &ensp; Our results compared to [MBKM19]
      </h3>

      <p class="text-gray-300">
        We compare the performance of Sonic to our system when
        generating proofs for arithmetic circuits with
        <span class="math">n</span>
        multiplication gates, or analogously, an R1CS system with
        <span class="math">n</span>
        constraints. Motivated by the discussion in Section 1.1 about
        settings of batched proofs &ndash; we omit from the tables the
        once per batch computations of the verifier. These are similar
        in Sonic and our system and are linear in the circuit size.
      </p>

      <p class="text-gray-300 mt-4">
        The first two columns in Table 1 describe SRS size when only
        knowing a bound
        <span class="math">d</span>
        on the circuit size/number of R1CS constraints; and then the
        reduced size possible to work with when knowing the exact size
        <span class="math">n</span>
        of the circuit.
      </p>

      <p class="text-gray-300 mt-4">
        When describing proof sizes, we separate between the elements
        from the prover in the parallel generation setting, and the
        additional elements from the helper in the helped setting.
      </p>

      <p class="text-gray-300 mt-4">
        We omit
        <span class="math">O(1)</span>
        factors. For example, in the fixed circuit size SRS size, we
        omit the constant number of
        <span class="math">\mathbb&#123;G&#125;_2</span>
        elements needed in the SRS both in Sonic and our system. We
        also mention that adding zero-knowledge increases by a small
        constant the number of prover exponentiations both in our
        system, and it seems, in Sonic.
      </p>

      <p class="text-gray-300 mt-4">
        In a nutshell, our construction has better prover run time and
        SRS size; while Sonic has smaller proofs, less auxiliary data
        and extra verifier work in helper mode, and a fully succinct
        verifier mode. Thus, the advantage of this work is most
        prominent in the parallel proof generation setting.
      </p>

      <!-- Table 1 -->
      <div class="overflow-x-auto my-6">
        <p class="text-gray-400 text-sm font-semibold mb-2">
          Table 1: Prover comparison
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 px-3 text-gray-300"></th>
              <th class="text-left py-2 px-3 text-gray-300">
                SRS size
                <span class="math">\leq d</span>
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                SRS size
                <span class="math">= n</span>
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                Prover work
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                Proof length
              </th>
            </tr>
          </thead>
          <tbody>
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3 text-gray-300 font-semibold">
                Sonic
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">12d \; \mathbb&#123;G&#125;_1, \; 12d \; \mathbb&#123;G&#125;_2</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">12n \; \mathbb&#123;G&#125;_1</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">18n \; \mathbb&#123;G&#125;_1</span> exp
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">2 \; \mathbb&#123;G&#125;_1, \; 4 \; \mathbb&#123;F&#125;</span>
              </td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3 text-gray-300 font-semibold">
                This work
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">2d \; \mathbb&#123;G&#125;_1, \; 2d \; \mathbb&#123;G&#125;_2</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">2n \; \mathbb&#123;G&#125;_1</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">8n \; \mathbb&#123;G&#125;_1</span> exp
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">4 \; \mathbb&#123;G&#125;_1, \; 6 \; \mathbb&#123;F&#125;</span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- Section 1.3 -->
      <h3 id="sec-1.3" class="text-xl font-semibold mt-8 mb-3">
        1.3 &ensp; Organization of paper
      </h3>

      <p class="text-gray-300">
        Section 2 contains terminology we will use. Section 3 contains
        an adaptation of the [KZG10] scheme similar to that of
        [MBKM19] that we will use. Section 4 contains our main
        construction assuming a polynomial commitment scheme as a
        black box. Section 5 shows how to adapt the Sonic helper mode
        to our construction. Section 6 shows how to add
        zero-knowledge to our construction. Section 7 discusses a
        possible extension to get a fully succinct verifier.
      </p>

      <!-- Table 2 -->
      <div class="overflow-x-auto my-6">
        <p class="text-gray-400 text-sm font-semibold mb-2">
          Table 2: Verifier comparison per proof in batch,
          P=pairing
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 px-3 text-gray-300"></th>
              <th class="text-left py-2 px-3 text-gray-300">
                Verifier work
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                Elem. from helper
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                Extra verifier work in helper mode
              </th>
              <th class="text-left py-2 px-3 text-gray-300">
                Fully succinct ver. mode?
              </th>
            </tr>
          </thead>
          <tbody>
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3 text-gray-300 font-semibold">
                Sonic
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">5P</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">2 \; \mathbb&#123;G&#125;_1, \; 3 \; \mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">4P</span>
              </td>
              <td class="py-2 px-3 text-gray-300">Yes</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 px-3 text-gray-300 font-semibold">
                This work
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">5P</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">10 \; \mathbb&#123;G&#125;_1, \; 8 \; \mathbb&#123;F&#125;</span>
              </td>
              <td class="py-2 px-3 text-gray-300">
                <span class="math">12P</span>
              </td>
              <td class="py-2 px-3 text-gray-300">No</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 2. TERMINOLOGY / CONVENTIONS                                 -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        2 &ensp; Terminology/conventions
      </h2>

      <p class="text-gray-300">
        We assume our field
        <span class="math">\mathbb&#123;F&#125;</span>
        is of prime order. We denote by
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt;d&#125;[X]</span>
        the set of univariate polynomials over
        <span class="math">\mathbb&#123;F&#125;</span>
        of degree smaller than
        <span class="math">d</span>.
        We assume all algorithms described receive as an implicit
        parameter the security parameter
        <span class="math">\lambda</span>.
      </p>

      <p class="text-gray-300 mt-4">
        Whenever we use the term &ldquo;efficient&rdquo;, we mean an
        algorithm running in time
        <span class="math">\text&#123;poly&#125;(\lambda)</span>.
        Furthermore, we assume an &ldquo;object generator&rdquo;
        <span class="math">\mathcal&#123;O&#125;</span>
        that is run with input
        <span class="math">\lambda</span>
        before all protocols, and returns all fields and groups used.
        Specifically, in our protocol
        <span class="math">\mathcal&#123;O&#125;(\lambda) = (\mathbb&#123;F&#125;, \mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t, e, g_1, g_2, g_t)</span>
        where
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-4 space-y-2">
        <li>
          <span class="math">\mathbb&#123;F&#125;</span>
          is a prime field of super-polynomial size
          <span class="math">r = \lambda^&#123;\omega(1)&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t</span>
          are all groups of size
          <span class="math">r</span>,
          and
          <span class="math">e</span>
          is an efficiently computable non-degenerate pairing
          <span class="math">e : \mathbb&#123;G&#125;_1 \times \mathbb&#123;G&#125;_2 \to \mathbb&#123;G&#125;_t</span>.
        </li>
        <li>
          <span class="math">g_1, g_2</span>
          are uniformly chosen generators such that
          <span class="math">e(g_1, g_2) = g_t</span>.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        We usually let the
        <span class="math">\lambda</span>
        parameter be implicit, i.e. write
        <span class="math">\mathbb&#123;F&#125;</span>
        instead of
        <span class="math">\mathbb&#123;F&#125;(\lambda)</span>.
        We write
        <span class="math">\mathbb&#123;G&#125;_1</span>
        and
        <span class="math">\mathbb&#123;G&#125;_2</span>
        additively. We use the notations
        <span class="math">[x]_1 := x \cdot g_1</span>
        and
        <span class="math">[x]_2 := x \cdot g_2</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Random oracles</strong> &ensp;
        We describe public-coin interactive protocols between a prover
        and verifier; when deriving results for non-interactive
        protocols, we implicitly assume we can get a proof length
        equal to the total communication of the prover, using the
        Fiat-Shamir transform/a random oracle. Using this reduction
        between interactive and non-interactive protocols, we can
        refer to the &ldquo;proof length&rdquo; of an interactive
        protocol.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. THE [KZG10] SCHEME AS USED IN SONIC                      -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        3 &ensp; The [KZG10] scheme as used in Sonic
      </h2>

      <p class="text-gray-300">
        We recall the [KZG10] scheme with two enhancements of
        [MBKM19] that will be important for us: The first is enabling
        a commitment to all degrees up to a certain size, rather than
        just the maximal degree. The second is &ldquo;batch
        openings&rdquo; of several polynomials at the same point
        <span class="math">z \in \mathbb&#123;F&#125;</span>.
        We define a polynomial commitment scheme with these
        enhancements in mind.
      </p>

      <!-- Definition 3.1 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 3.1
        </p>
        <p class="text-gray-300">
          A
          <span class="math">d</span>-polynomial commitment scheme
          consists of
        </p>
        <ul class="list-disc list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            <span class="math">\text&#123;Gen&#125;(d)</span>
            &ndash; is a randomized algorithm that outputs an SRS
            <span class="math">\sigma</span>.
          </li>
          <li>
            <span class="math">\text&#123;com&#125;(f, \text&#123;max&#125;, \sigma)</span>
            &ndash; that given a polynomial
            <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt;\text&#123;max&#125;&#125;[X]</span>,
            where
            <span class="math">\text&#123;max&#125; \leq d</span>,
            returns a commitment
            <span class="math">\text&#123;cm&#125;</span>
            to
            <span class="math">f</span>.
          </li>
          <li>
            A public coin protocol
            <span class="math">\text&#123;open&#125;</span>
            between parties
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            and
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>.
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            is given
            <span class="math">f_1, \ldots, f_t \in \mathbb&#123;F&#125;_&#123;&lt;d&#125;[X]</span>.
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            and
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            are both given integer
            <span class="math">t = \text&#123;poly&#125;(\lambda)</span>,
            <span class="math">\text&#123;cm&#125;_1, \ldots, \text&#123;cm&#125;_t</span>
            &ndash; the alleged commitments to
            <span class="math">f_1, \ldots, f_t</span>,
            integers
            <span class="math">0 &lt; d_1, \ldots, d_t \leq d</span>,
            <span class="math">z \in \mathbb&#123;F&#125;</span>
            and
            <span class="math">s_1, \ldots, s_t \in \mathbb&#123;F&#125;</span>
            &ndash; the alleged correct openings
            <span class="math">f_1(z), \ldots, f_t(z)</span>.
            At the end of the protocol
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            outputs
            <span class="math">\text&#123;acc&#125;</span>
            or
            <span class="math">\text&#123;rej&#125;</span>.
          </li>
        </ul>
        <p class="text-gray-300 mt-2">such that</p>
        <ul class="list-disc list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            <strong>Completeness:</strong> Fix integer
            <span class="math">t</span>,
            <span class="math">z \in \mathbb&#123;F&#125;</span>,
            <span class="math">f_1, \ldots, f_t \in \mathbb&#123;F&#125;_&#123;&lt;d&#125;[X]</span>
            and
            <span class="math">0 &lt; d_1, \ldots, d_t \leq d</span>
            such that
            <span class="math">\deg(f_i) &lt; d_i</span>.
            Suppose that for each
            <span class="math">i \in [t]</span>,
            <span class="math">\text&#123;cm&#125;_i = \text&#123;com&#125;(f_i, d_i, \sigma)</span>.
            Then if
            <span class="math">\text&#123;open&#125;</span>
            is run correctly with values
            <span class="math">t, z, \&#123;\text&#123;cm&#125;_i, d_i, f_i(z)\&#125;_&#123;i \in [t]&#125;</span>,
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            outputs
            <span class="math">\text&#123;acc&#125;</span>
            with probability one.
          </li>
          <li>
            <strong>Knowledge soundness in the generic group
            model:</strong> There exists an efficient
            <span class="math">E</span>
            such that for any efficient generic group model adversary
            <span class="math">A</span>
            the probability of
            <span class="math">A</span>
            winning the following game is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>
            over the randomness of
            <span class="math">A</span>
            and
            <span class="math">\text&#123;Gen&#125;</span>.
            <ol class="list-decimal list-inside ml-4 mt-2 space-y-1">
              <li>
                Given
                <span class="math">\sigma</span>,
                <span class="math">A</span>
                outputs
                <span class="math">t, \text&#123;cm&#125;_1, \ldots, \text&#123;cm&#125;_t</span>.
              </li>
              <li>
                <span class="math">E</span>,
                given access to the state of
                <span class="math">A</span>
                outputs
                <span class="math">f_1, \ldots, f_t \in \mathbb&#123;F&#125;_&#123;&lt;d&#125;[X]</span>.
              </li>
              <li>
                <span class="math">A</span>
                outputs
                <span class="math">0 &lt; d_1, \ldots, d_t \leq d</span>,
                <span class="math">s_1, \ldots, s_t \in \mathbb&#123;F&#125;</span>,
                <span class="math">z \in \mathbb&#123;F&#125;</span>.
              </li>
              <li>
                <span class="math">A</span>
                takes the part of
                <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
                in the protocol
                <span class="math">\text&#123;open&#125;</span>
                with inputs
                <span class="math">\text&#123;cm&#125;_1, \ldots, \text&#123;cm&#125;_t</span>,
                <span class="math">d_1, \ldots, d_t</span>,
                <span class="math">s_1, \ldots, s_t</span>.
              </li>
              <li>
                <span class="math">A</span>
                wins if
                <span class="math">V</span>
                outputs
                <span class="math">\text&#123;acc&#125;</span>
                at the end of the protocol, and for some
                <span class="math">i \in [t]</span>,
                <span class="math">s_i \neq f_i(z)</span>
                or
                <span class="math">\deg(f_i) \geq d_i</span>.
              </li>
            </ol>
          </li>
        </ul>
      </div>

      <p class="text-gray-300">
        We describe the following scheme based on [KZG10, MBKM19]. It
        is in fact a slightly simpler scheme than in [MBKM19] because,
        as explained in the introduction, there is no need to deal
        with holes in the allowed range of degrees.
      </p>

      <ol class="list-decimal list-inside text-gray-300 mt-4
        space-y-4">
        <li>
          <span class="math">\text&#123;Gen&#125;(d)</span>:
          choose uniform
          <span class="math">x \in \mathbb&#123;F&#125;</span>.
          Output
          <span class="math">\sigma = ([1]_1, [x]_1, \ldots, [x^&#123;d-1&#125;]_1, [x]_2, [1]_2, [x^&#123;-1&#125;]_2, \ldots, [x^&#123;-(d-1)&#125;]_2)</span>.
        </li>
        <li>
          <span class="math">\text&#123;com&#125;(f, d', \sigma) := [x^&#123;d - d'&#125; \cdot f(x)]_1</span>.
        </li>
        <li>
          <span class="math">\text&#123;open&#125;(\&#123;\text&#123;cm&#125;_i\&#125;, \&#123;d_i\&#125;, \&#123;s_i\&#125;, z)</span>:
          <ol class="list-[lower-alpha] list-inside ml-4 mt-2
            space-y-3">
            <li>
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              sends random
              <span class="math">\gamma \in \mathbb&#123;F&#125;</span>.
            </li>
            <li>
              <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
              computes the polynomial
              <div class="math-block">
                h(X) := \sum_&#123;i=1&#125;^&#123;t&#125; \gamma^i
                \cdot \frac&#123;f_i(X) - f_i(z)&#125;&#123;X - z&#125;
              </div>
              and using
              <span class="math">\sigma</span>
              computes and sends
              <span class="math">W := [h(x)]_1</span>.
            </li>
            <li>
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              computes the elements
              <div class="math-block">
                F := \prod_&#123;i \in [t]&#125;
                e\!\left(\gamma^i \cdot \text&#123;cm&#125;_i,
                \left[x^&#123;d_i - d&#125;\right]_2\right),
                \quad v := \left[\sum_&#123;i \in [t]&#125;
                \gamma^i \cdot s_i\right]_1
              </div>
            </li>
            <li>
              <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
              outputs
              <span class="math">\text&#123;acc&#125;</span>
              if and only if
              <div class="math-block">
                F = e(v - z \cdot W, [1]_2) \cdot e(W, [x]_2).
              </div>
            </li>
          </ol>
        </li>
      </ol>

      <p class="text-gray-300 mt-4">
        Note that
        <span class="math">|\sigma| = 2d</span>
        in the above scheme. <em>However</em>, a crucial point is that
        once we fix
        <span class="math">\ell</span>
        values from which we will always choose
        <span class="math">\&#123;d_1, \ldots, d_t\&#125;</span>,
        we can work with a subvector of
        <span class="math">\sigma</span>
        of size
        <span class="math">d + \ell</span>.
        In our SNARK, given a circuit size, we will only need
        <span class="math">\ell = 3</span>
        of the
        <span class="math">\mathbb&#123;G&#125;_2</span>
        values from
        <span class="math">\sigma</span>
        in our SRS.
      </p>

      <p class="text-gray-300 mt-4">
        The following is implied almost directly by Theorem 6.1 and
        Appendix C.1 of [MBKM19]. We leverage that the pairings in
        step 3c can be batched for indices
        <span class="math">i, j</span>
        such that
        <span class="math">d_i = d_j</span>.
      </p>

      <!-- Lemma 3.2 -->
      <div class="formal-block formal-block-lemma my-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 3.2
        </p>
        <p class="text-gray-300">
          Fix any
          <span class="math">d</span>
          and assume the
          <span class="math">d</span>-power bi-linear Strong Diffie
          Hellman assumption holds. Then the above scheme is a
          <span class="math">d</span>-polynomial commitment scheme
          such that
        </p>
        <ol class="list-decimal list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            requires
            <span class="math">\text&#123;max&#125;</span>
            <span class="math">\mathbb&#123;G&#125;_1</span>
            exponentiations for computing
            <span class="math">\text&#123;com&#125;(f, \text&#123;max&#125;, \sigma)</span>.
          </li>
          <li>
            <span class="math">P_&#123;\text&#123;poly&#125;&#125;</span>
            requires
            <span class="math">\sum_&#123;i=1&#125;^t O(d_i \log(d_i))</span>
            field operations and
            <span class="math">\sum_&#123;i=1&#125;^t d_i</span>
            exponentiations for computing
            <span class="math">\text&#123;open&#125;(\&#123;\text&#123;cm&#125;_i\&#125;_&#123;i \in [t]&#125;, \&#123;d_i\&#125;_&#123;i \in [t]&#125;, \&#123;s_i\&#125;_&#123;i \in [t]&#125;, z)</span>.
          </li>
          <li>
            <span class="math">V_&#123;\text&#123;poly&#125;&#125;</span>
            requires
            <span class="math">t^* + 2</span>
            pairings, where
            <span class="math">t^*</span>
            is the number of distinct values amongst
            <span class="math">d_1, \ldots, d_t</span>.
          </li>
        </ol>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 4. THE MAIN CONSTRUCTION                                     -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        4 &ensp; The main construction
      </h2>

      <p class="text-gray-300">
        We begin by converting R1CS to a format that is convenient for
        us. We denote by
        <span class="math">n</span>
        the number of private inputs and the number of constraints
        which we assume are equal (can be achieved by adding dummy
        variables or constraints if needed). We denote by
        <span class="math">\ell</span>
        the number of public inputs; and define
        <span class="math">N := n + \ell</span>.
        We assume the first
        <span class="math">n</span>
        variables correspond to the private inputs.
      </p>

      <p class="text-gray-300 mt-4">
        We assume we have a multiplicative subgroup
        <span class="math">H \subset \mathbb&#123;F&#125;</span>
        of size
        <span class="math">n</span>.
        Somewhat confusingly, it will be convenient to identify the
        elements of
        <span class="math">H</span>
        with the integers
        <span class="math">\&#123;0, 1, \ldots, n-1\&#125;</span>
        when using them as exponents.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        Tweaking R1CS to our format
      </h3>
      <p class="text-gray-300">
        Our original R1CS consists of the constraints: For all
        <span class="math">i \in [n]</span>
      </p>
      <div class="math-block">
        (a_i \cdot x)(b_i \cdot x) - (c_i \cdot x) = 0,
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\cdot</span>
        denotes inner product of vectors of length
        <span class="math">N</span>.
        We modify the system to &ldquo;flatten&rdquo; linear
        combinations to variables. That is, we add two vectors of
        variables
        <span class="math">y, z \in \mathbb&#123;F&#125;^n</span>
        and look at the following system with
        <span class="math">3n</span>
        constraints:
      </p>
      <p class="text-gray-300 mt-2">
        For all
        <span class="math">i \in [n]</span>
      </p>
      <ol class="list-decimal list-inside text-gray-300 mt-2
        space-y-1">
        <li>
          <span class="math">y_i \cdot z_i - (c_i \cdot x) = 0</span>.
        </li>
        <li>
          <span class="math">y_i - (a_i \cdot x) = 0</span>.
        </li>
        <li>
          <span class="math">z_i - (b_i \cdot x) = 0</span>.
        </li>
      </ol>

      <p class="text-gray-300 mt-4">
        Note that above
        <span class="math">y_i, z_i \in \mathbb&#123;F&#125;</span>
        but
        <span class="math">a_i, b_i, c_i, x \in \mathbb&#123;F&#125;^N</span>.
        Similarly to the original system, we call
        <span class="math">x_&#123;n+1&#125;, \ldots, x_N</span>
        the public variables of this system, and all other variables
        private variables.
      </p>

      <h3 class="text-xl font-semibold mt-8 mb-3">
        A lemma about sums on subgroups
      </h3>
      <p class="text-gray-300">
        We use the following fact mentioned in Remark 5.6 in
        [BCR+19] that is crucial to the Aurora system, as well as ours:
      </p>

      <!-- Lemma 4.1 -->
      <div class="formal-block formal-block-lemma my-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 4.1
        </p>
        <p class="text-gray-300">
          Fix any
          <span class="math">f \in \mathbb&#123;F&#125;_&#123;\leq n&#125;[X]</span>.
          Then for any multiplicative subgroup
          <span class="math">H \subset \mathbb&#123;F&#125;</span>
          with
          <span class="math">|H| = n</span>,
        </p>
        <div class="math-block">
          \sum_&#123;a \in H&#125; f(a) = 0
        </div>
        <p class="text-gray-300">
          if and only if
          <span class="math">f</span>
          has a zero constant term.
        </p>
      </div>

      <!-- Section 4.1 -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 &ensp; The main protocol
      </h3>

      <p class="text-gray-300">
        When describing the protocol we assume we have a
        <span class="math">2n</span>-polynomial commitment scheme as
        defined in Section 3.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Step 1: prover committing to witness</strong> &ensp;
        The prover
        <span class="math">\mathbf&#123;P&#125;</span>
        starts by computing three polynomials representing the
        satisfying assignment
        <span class="math">(x, y, z) \in \mathbb&#123;F&#125;^&#123;3n&#125;</span>
        of the private variables. Specifically, polynomials
        <span class="math">W, Y, Z \in \mathbb&#123;F&#125;_&#123;\leq n&#125;[X]</span>,
        such that for each
        <span class="math">i \in H</span>,
        <span class="math">W(i) = x_i</span>,
        <span class="math">Y(i) = y_i</span>,
        and
        <span class="math">Z(i) = z_i</span>.
        <span class="math">\mathbf&#123;P&#125;</span>
        sends polynomial commitments to
        <span class="math">W, Y, Z</span>,
        with parameter
        <span class="math">\text&#123;max&#125; = n</span>,
        to the verifier
        <span class="math">\mathbf&#123;V&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Step 2: verifier choosing a challenge; prover and
        verifier reducing to sumcheck</strong> &ensp;
        <span class="math">\mathbf&#123;V&#125;</span>
        chooses random
        <span class="math">r, r', r'' \in \mathbb&#123;F&#125;</span>
        which it sends to
        <span class="math">\mathbf&#123;P&#125;</span>.
        They both now independently reduce the satisfiability check to
        a sum check as follows: Look at the sum
      </p>
      <div class="math-block">
        \sum_&#123;i \in H&#125; r^i(y_i z_i - c_i \cdot x)
        + \sum_&#123;i \in H&#125; r'^i(y_i - a_i \cdot x)
        + \sum_&#123;i \in H&#125; r''^i(z_i - b_i \cdot x).
      </div>
      <p class="text-gray-300">
        Note that the sum is always zero for a satisfying assignment,
        and non-zero except with probability
        <span class="math">n / |\mathbb&#123;F&#125;|</span>
        over
        <span class="math">r, r', r''</span>
        for a non-satisfying one. Rearrange the sum as
      </p>
      <div class="math-block">
        \sum_&#123;i \in H&#125; r^i y_i z_i
        + \sum_&#123;i \in H&#125; r'^i y_i
        + \sum_&#123;i \in H&#125; r''^i z_i
        + \sum_&#123;i \in H&#125; \alpha_i x_i
        + \alpha_0
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\alpha_i</span>
        is a coefficient containing some polynomial expression in
        <span class="math">r, r', r'', \&#123;a_&#123;i,j&#125;, b_&#123;i,j&#125;, c_&#123;i,j&#125;\&#125;</span>;
        and also the public inputs
        <span class="math">x_&#123;n+1&#125;, \ldots, x_N</span>
        in the case of
        <span class="math">\alpha_0</span>.
        Now compute
        <span class="math">R, R', R'', Q \in \mathbb&#123;F&#125;_&#123;&lt;n&#125;[X]</span>,
        such that for
        <span class="math">i \in H</span>,
        <span class="math">R(i) = r^i</span>,
        <span class="math">R'(i) = r'^i</span>,
        <span class="math">R''(i) = r''^i</span>,
        <span class="math">Q(i) = \alpha_i</span>.
        Define the polynomial
        <span class="math">D \in \mathbb&#123;F&#125;_&#123;&lt;n&#125;[X]</span>
        by
      </p>
      <div class="math-block">
        D := R \cdot Y \cdot Z + R' \cdot Y + R'' \cdot Z
        + Q \cdot W + \alpha_0 / n.
      </div>
      <p class="text-gray-300">
        Our sum above becomes
      </p>
      <div class="math-block">
        \sum_&#123;i \in H&#125; D(i).
      </div>
      <p class="text-gray-300">
        We have thus reduced our problem to a polynomial sumcheck. To
        be able to use Lemma 4.1, as in [BCR+19], we use polynomial
        division.
      </p>

      <p class="text-gray-300 mt-4">
        Let
        <span class="math">Z_H(X) := \prod_&#123;a \in H&#125; (X - a) = X^n - 1</span>.
        <span class="math">\mathbf&#123;P&#125;</span>
        computes
        <span class="math">g \in \mathbb&#123;F&#125;_&#123;&lt;2n&#125;[X]</span>,
        <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt;n-1&#125;[X]</span>
        such that
      </p>
      <div class="math-block">
        D(X) = g(X) \cdot Z_H(X) + X \cdot f(X).
      </div>
      <p class="text-gray-300">
        Note that from polynomial division combined with Lemma 4.1 if
        the sum vanishes &ndash; such
        <span class="math">f, g</span>
        indeed exist.
        <span class="math">\mathbf&#123;P&#125;</span>
        sends commitments of
        <span class="math">g</span>
        with parameter
        <span class="math">\text&#123;max&#125; = 2n</span>
        and
        <span class="math">f</span>
        with parameter
        <span class="math">\text&#123;max&#125; = n - 1</span>
        to
        <span class="math">\mathbf&#123;V&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Step 3: Verifier verifying the sumcheck by opening
        commitments and checking a polynomial identity</strong> &ensp;
        Note that if
        <span class="math">g</span>
        and
        <span class="math">f</span>
        are well-formed in the sense that indeed
        <span class="math">D(X) = g(X) \cdot Z_H(X) + X \cdot f(X)</span>,
        then
        <span class="math">D(a) = a \cdot f(a)</span>
        for any
        <span class="math">a \in H</span>.
        In such a case it thus suffices that
        <span class="math">\mathbf&#123;V&#125;</span>
        check that
      </p>
      <div class="math-block">
        \sum_&#123;a \in H&#125; a \cdot f(a) = 0.
      </div>
      <p class="text-gray-300">
        However, since
        <span class="math">\deg(f) &lt; n - 1</span>
        is guaranteed by the commitment scheme, we have that
        <span class="math">f'(X) := X \cdot f(X)</span>
        is a polynomial of degree
        <span class="math">&lt; n</span>
        with zero constant coefficient; therefore the sum vanishes by
        Lemma 4.1. Hence,
        <span class="math">\mathbf&#123;V&#125;</span>
        need only check that indeed
        <span class="math">D = g \cdot Z_H + X \cdot f</span>.
      </p>

      <p class="text-gray-300 mt-4">
        For this purpose,
        <span class="math">\mathbf&#123;V&#125;</span>
        chooses a random
        <span class="math">z \in \mathbb&#123;F&#125;</span>
        and asks for the openings
        <span class="math">Y(z), Z(z), W(z), g(z), f(z)</span>.
        Using
        <span class="math">Y(z), Z(z), W(z)</span>
        together with
        <span class="math">R(z), R'(z), R''(z), Q(z), \alpha_0</span>
        that it can compute by itself,
        <span class="math">\mathbf&#123;V&#125;</span>
        computes
        <span class="math">D(z)</span>.
        Now
        <span class="math">\mathbf&#123;V&#125;</span>
        checks if
      </p>
      <div class="math-block">
        D(z) = g(z) \cdot Z_H(z) + z \cdot f(z),
      </div>
      <p class="text-gray-300">
        and outputs
        <span class="math">\text&#123;acc&#125;</span>
        if and only if the equality holds. Using Schwartz-Zippel, the
        probability of a false assignment leading to acceptance (via
        this identity or a bad choice of
        <span class="math">r, r', r''</span>
        above) is at most
        <span class="math">4n / |\mathbb&#123;F&#125;|</span>.
      </p>

      <!-- Section 4.2 -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 &ensp; Protocol summary
      </h3>

      <p class="text-gray-300">
        For convenience, we summarize the main protocol steps
        deferring to the more detailed description above for missing
        details.
      </p>

      <ol class="list-decimal list-inside text-gray-300 mt-4
        space-y-3">
        <li>
          <span class="math">\mathbf&#123;P&#125;</span>
          sends
          <span class="math">\text&#123;cm&#125;(W, n, \sigma)</span>,
          <span class="math">\text&#123;cm&#125;(Y, n, \sigma)</span>,
          <span class="math">\text&#123;cm&#125;(Z, n, \sigma)</span>
          to
          <span class="math">\mathbf&#123;V&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span>
          chooses random
          <span class="math">r, r', r'' \in \mathbb&#123;F&#125;</span>
          and sends them to
          <span class="math">\mathbf&#123;P&#125;</span>.
          They both derive the polynomials
          <span class="math">R, R', R''</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span>
          computes
          <span class="math">D</span>.
          <span class="math">\mathbf&#123;P&#125;</span>
          computes
          <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt;n-1&#125;[X]</span>,
          <span class="math">g \in \mathbb&#123;F&#125;_&#123;&lt;2n&#125;[X]</span>
          such that
          <span class="math">D(X) = g(X) \cdot Z_H(X) + X \cdot f(X)</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span>
          sends
          <span class="math">\text&#123;cm&#125;(g, 2n, \sigma)</span>,
          <span class="math">\text&#123;cm&#125;(f, n-1, \sigma)</span>
          to
          <span class="math">\mathbf&#123;V&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span>
          chooses random
          <span class="math">z \in \mathbb&#123;F&#125;</span>
          and sends
          <span class="math">z</span>
          to
          <span class="math">\mathbf&#123;P&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span>
          sends
          <span class="math">s_W = W(z)</span>,
          <span class="math">s_Y = Y(z)</span>,
          <span class="math">s_Z = Z(z)</span>,
          <span class="math">s_f = f(z)</span>,
          <span class="math">s_g = g(z)</span>
          to
          <span class="math">\mathbf&#123;V&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span>
          and
          <span class="math">\mathbf&#123;V&#125;</span>
          engage in the protocol
          <span class="math">\text&#123;open&#125;(5, \&#123;n, n, n, n-1, 2n\&#125;, \&#123;W, Y, Z, f, g\&#125;, \&#123;s_W, s_Y, s_Z, s_f, s_g\&#125;)</span>.
          <span class="math">\mathbf&#123;V&#125;</span>
          outputs
          <span class="math">\text&#123;rej&#125;</span>
          if the protocol verifier did.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span>
          computes the alleged value of
          <span class="math">D(z)</span>,
          as
          <div class="math-block">
            s_D := R(z) s_Y s_Z + R'(z) s_Y + R''(z) s_Z
            + Q(z) s_W + \alpha_0
          </div>
          and outputs
          <span class="math">\text&#123;acc&#125;</span>
          if and only if
          <div class="math-block">
            s_D = s_g \cdot Z_H(z) + z \cdot s_f.
          </div>
        </li>
      </ol>

      <p class="text-gray-300 mt-4">
        <strong>Parallel proof generation</strong> &ensp;
        Parallel proof generation with efficient amortized
        verification, as mentioned in Section 1.1, is achieved by
        running most steps separately for each public input, but
        jointly in steps 2 and 5, i.e. use the same verifier
        randomness
        <span class="math">r, r', r'', z</span>
        for all proofs. When this is done the values
        <span class="math">R(z), R'(z), R''(z), Q(z)</span>
        can be computed just once for all proofs in step 8.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Saving one field element as in Sonic</strong> &ensp;
        Note that in the equation checked by
        <span class="math">\mathbf&#123;V&#125;</span>
        in step 8, when
        <span class="math">z \neq 0</span>,
        the value
        <span class="math">s_f</span>
        that will cause acceptance is uniquely determined by the other
        four values
        <span class="math">s_W, s_Y, s_Z, s_g</span>.
        Thus
        <span class="math">\mathbf&#123;V&#125;</span>
        can compute it himself as
      </p>
      <div class="math-block">
        s_f := \left(s_D - s_g \cdot Z_H(z)\right) / z,
      </div>
      <p class="text-gray-300">
        and check its correctness in the protocol
        <span class="math">\text&#123;open&#125;</span>
        of step 7.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. BATCHING ARBITRARY PROOFS WITH THE SONIC HELPER           -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        5 &ensp; Batching arbitrary proofs with the Sonic helper
      </h2>

      <p class="text-gray-300">
        As in [MBKM19], the heavy/non-succinct part of the verifier
        computation is evaluating polynomials whose size is as large
        as the circuit/number of R1CS constraints. Sonic has a clever
        solution for this &ndash; using an untrusted helper. The
        helper computes the polynomial evaluations for the verifier,
        and is able to prove the evaluations are correct. This is what
        [MBKM19] call a <em>signature of correct computation</em>. As
        we need to use the Sonic helper on several different
        polynomials in related evaluation points, it will be
        convenient to use a definition that supports multiple
        polynomials and evaluation points, at the cost of a more
        complicated definition of SCC.
      </p>

      <!-- Definition 5.1 -->
      <div class="formal-block formal-block-definition my-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 5.1
        </p>
        <p class="text-gray-300">
          A protocol
          <span class="math">\mathscr&#123;P&#125;</span>
          between two-parties
          <span class="math">(\mathsf&#123;P&#125;_&#123;\mathsf&#123;sc&#125;&#125;, \mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;)</span>
          is a
          <span class="math">(t, \&#123;m_i\&#125;_&#123;i \in [t]&#125;, d)</span>-signature
          of correct computation
          (<span class="math">(t, \&#123;m_i\&#125;_&#123;i \in [t]&#125;, d)</span>-SCC)
          if, when both parties are given
          <span class="math">s_1, \ldots, s_t \in \mathbb&#123;F&#125;_&#123;&lt;d&#125;[X, Y]</span>
          and a sequence of values
          <span class="math">S = \&#123;(x_&#123;i,j&#125;, y_&#123;i,j&#125;, s_&#123;i,j&#125;) \in \mathbb&#123;F&#125;^3\&#125;_&#123;i \in [t], j \in [m_i]&#125;</span>,
          <span class="math">\mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>
          ends up outputting a value
          <span class="math">\text&#123;res&#125; \in \&#123;\text&#123;acc&#125;, \text&#123;rej&#125;\&#125;</span>
          such that
        </p>
        <ol class="list-decimal list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            <strong>Completeness:</strong> If for every
            <span class="math">i \in [t], j \in [m_i]</span>,
            <span class="math">s_&#123;i,j&#125; = s_i(x_&#123;i,j&#125;, y_&#123;i,j&#125;)</span>,
            and
            <span class="math">(\mathsf&#123;P&#125;_&#123;\mathsf&#123;sc&#125;&#125;, \mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;)</span>
            follow the protocol then
            <span class="math">\mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>
            outputs
            <span class="math">\text&#123;acc&#125;</span>
            with probability one.
          </li>
          <li>
            <strong>Soundness:</strong> For any efficient generic group
            adversary
            <span class="math">A</span>
            playing the part of
            <span class="math">\mathsf&#123;P&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>,
            if for some
            <span class="math">i \in [t], j \in [m_i]</span>,
            <span class="math">s_&#123;i,j&#125; \neq s_i(x_&#123;i,j&#125;, y_&#123;i,j&#125;)</span>,
            then the probability that
            <span class="math">\mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>
            outputs
            <span class="math">\text&#123;acc&#125;</span>
            is
            <span class="math">\text&#123;negl&#125;(\lambda)</span>.
          </li>
        </ol>
      </div>

      <p class="text-gray-300">
        The following lemma follows from [MBKM19]&rsquo;s helped-SCC
        protocol, together with their batched opening commitment
        scheme as described in Section 3.
      </p>

      <!-- Lemma 5.2 -->
      <div class="formal-block formal-block-lemma my-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 5.2
        </p>
        <p class="text-gray-300">
          Fix integers
          <span class="math">t</span>,
          <span class="math">\&#123;m_i\&#125;_&#123;i \in [t]&#125;</span>,
          <span class="math">d</span>.
          There is a public coin
          <span class="math">(t, \&#123;m_i\&#125;_&#123;i \in [t]&#125;, d)</span>-SCC
          such that the following holds. Let
          <span class="math">S = \&#123;(x_&#123;i,j&#125;, y_&#123;i,j&#125;, s_&#123;i,j&#125;) \in \mathbb&#123;F&#125;^3\&#125;_&#123;i \in [t], j \in [m_i]&#125;</span>
          be the common input to
          <span class="math">\mathsf&#123;P&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>
          and
          <span class="math">\mathsf&#123;V&#125;_&#123;\mathsf&#123;sc&#125;&#125;</span>
          in the beginning of the protocol.
        </p>
        <p class="text-gray-300 mt-2">Suppose that</p>
        <ol class="list-decimal list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            <span class="math">m^*</span>
            is the sum over
            <span class="math">i \in [t]</span>
            of the number of distinct values in
            <span class="math">\&#123;y_&#123;i,j&#125;\&#125;_&#123;j \in [m_i]&#125;</span>.
          </li>
          <li>
            <span class="math">m^&#123;**&#125;</span>
            is the number of distinct values in
            <span class="math">\&#123;y_&#123;i,j&#125;\&#125;_&#123;i \in [t], j \in [m_i]&#125;</span>.
          </li>
          <li>
            <span class="math">m^&#123;***&#125;</span>
            is the number of distinct values in
            <span class="math">\&#123;x_&#123;i,j&#125;\&#125;_&#123;i \in [t], j \in [m_i]&#125;</span>.
          </li>
        </ol>
        <p class="text-gray-300 mt-2">Then</p>
        <ul class="list-disc list-inside text-gray-300 mt-2
          space-y-2">
          <li>
            The total prover communication in the protocol consists of
            <span class="math">m^* + m^&#123;**&#125; + m^&#123;***&#125; + t</span>
            <span class="math">\mathbb&#123;G&#125;_1</span>
            elements and
            <span class="math">m^* + t</span>
            field elements.
          </li>
          <li>
            The verifier computation consists of one evaluation of each
            <span class="math">s_i</span>
            and
            <span class="math">3(m^&#123;**&#125; + m^&#123;***&#125; + t)</span>
            pairings.
          </li>
          <li>
            The SRS required for the scheme is the same as that of the
            <span class="math">d</span>-polynomial commitment scheme
            described in Section 3.
          </li>
        </ul>
      </div>

      <p class="text-gray-300">
        Let us see how Lemma 5.2 helps us improve verifier efficiency
        in the batch helped model: The heavy verifier computations
        &ndash; meaning those linear instead of polylogarithmic in the
        number of constraints &ndash; are the evaluation at the point
        <span class="math">z</span>
        of the polynomials
        <span class="math">Q, R, R', R''</span>.
        Recall that
        <span class="math">R, R', R''</span>
        were defined by a random choice of
        <span class="math">r \in \mathbb&#123;F&#125;</span>.
        We could in fact think of them all as bi-variate polynomials
        evaluated at
        <span class="math">(r, z)</span>
        (<span class="math">R', R''</span>
        are the same bi-variate polynomial as
        <span class="math">R</span>
        when viewed this way); we claim that as bivariate polynomials
        they are all members of
        <span class="math">\mathbb&#123;F&#125;_&#123;\leq n&#125;[X, Y]</span>:
        Let
        <span class="math">\&#123;L_i \in \mathbb&#123;F&#125;[Y]\&#125;_&#123;i \in H&#125;</span>
        be the Lagrange basis with respect to
        <span class="math">H</span>.
        That is,
        <span class="math">L_i</span>
        is the unique polynomial of degree less than
        <span class="math">n</span>
        with
        <span class="math">L(i) = 1</span>
        and
        <span class="math">L(j) = 0</span>
        for
        <span class="math">i \neq j \in H</span>.
        Now, we can see that
      </p>
      <div class="math-block">
        R(X, Y) = \sum_&#123;i \in H&#125; X^i \cdot L_i(Y)
      </div>

      <p class="text-gray-300 mt-4">
        Similarly,
        <span class="math">Q</span>
        was defined by a random choice of
        <span class="math">r, r', r'' \in \mathbb&#123;F&#125;</span>
        and thus can be thought of as a sum of three bivariates
        <span class="math">Q_1, Q_2, Q_3</span>
        with
      </p>
      <div class="math-block">
        Q_j(X, Y) = \sum_&#123;i \in H&#125;
        \alpha_&#123;i,j&#125;(X) \cdot L_i(Y)
      </div>
      <p class="text-gray-300">
        for some
        <span class="math">\alpha_&#123;i,j&#125;(X) \in \mathbb&#123;F&#125;_&#123;&lt;n&#125;[X]</span>,
        such that the total number of non-zero coefficients in
        <span class="math">\&#123;\alpha_&#123;i,j&#125;(X)\&#125;</span>
        is bounded by the number of wires in the circuit we
        constructed the R1CS from; hence we can assume it is
        <span class="math">O(n)</span>.
      </p>

      <p class="text-gray-300 mt-4">
        What will be important for us is that given
        <span class="math">z \in \mathbb&#123;F&#125;</span>,
        the values
        <span class="math">\&#123;L_i(z)\&#125;_&#123;i \in H&#125;</span>
        can be computed in at most
        <span class="math">O(n)</span>
        field operations (as
        <span class="math">L_i(Y) = \frac&#123;Y^n - 1&#125;&#123;Y - i&#125; \cdot \frac&#123;i - 1&#125;&#123;i^n - 1&#125;</span>).
        Thus, a helper can use the protocol of Lemma 5.2, to compute
        <span class="math">Q(r, r', r'', z)</span>,
        <span class="math">R(r, z)</span>,
        <span class="math">R(r', z)</span>,
        <span class="math">R(r'', z)</span>
        for
        <span class="math">\mathbf&#123;V&#125;</span>
        and convince him the values are correct.
      </p>

      <p class="text-gray-300 mt-4">
        Mapping our situation to Lemma 5.2, for one execution of the
        main protocol we have
      </p>
      <ol class="list-decimal list-inside text-gray-300 mt-2
        space-y-2">
        <li>
          <span class="math">t = 4</span>:
          Our polynomials are
          <span class="math">Q_1, Q_2, Q_3, R</span>.
        </li>
        <li>
          <span class="math">m^* = 4</span>:
          Our second coordinate is always
          <span class="math">z</span>.
        </li>
        <li>
          <span class="math">m^&#123;**&#125; = 3</span>:
          The options for the first coordinate in all polynomials are
          <span class="math">r, r', r''</span>.
        </li>
        <li>
          <span class="math">m^&#123;***&#125; = 1</span>:
          Again, because our second coordinate is always
          <span class="math">z</span>.
        </li>
      </ol>

      <p class="text-gray-300 mt-4">
        On the other hand, when batching arbitrary proofs, there will
        not necessarily be any overlap between the values of the
        coordinates of evaluation points. It follows from Lemma 5.2
        that, for a batch of
        <span class="math">T</span>
        proofs, the helper mode adds
        <span class="math">8T + 4</span>
        <span class="math">\mathbb&#123;G&#125;_1</span>
        elements and
        <span class="math">10T + 4</span>
        field elements to the proofs (including a
        <span class="math">6T</span>
        factor for the evaluations of
        <span class="math">R, Q_1, Q_2, Q_3</span>
        themselves), and
        <span class="math">12T + 12</span>
        pairing operations to the verifier.
      </p>

      <p class="text-gray-300 mt-4">
        This while requiring the verifier to only perform
        <span class="math">O(n)</span>
        field operations to compute the polynomials
        <span class="math">Q_1, Q_2, Q_3, R</span>
        at a single point, (instead of
        <span class="math">O(n \cdot T)</span>
        without the helper).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. GETTING ZERO-KNOWLEDGE                                    -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        6 &ensp; Getting zero-knowledge
      </h2>

      <p class="text-gray-300">
        We sketch how to add zero-knowledge to our scheme. The
        information given by the prover is limited to two evaluations
        of the polynomials
        <span class="math">W, Y, Z, f, g</span>
        (one evaluation in the exponent during commitment, and one
        during opening). We need these evaluations not to leak any
        information. Note first that when the prover is honest, the
        evaluations of
        <span class="math">g</span>
        are a function of the previous ones determined by the verifier
        equation. Thus, it is enough to show the evaluations of
        <span class="math">W, Y, Z, f</span>
        don&rsquo;t leak information.
      </p>

      <p class="text-gray-300 mt-4">
        The natural method in such cases (see e.g. [GGPR13, BCGV16,
        BCR+19]) is to add to the polynomials random multiples of
        <span class="math">Z_H</span>.
        This doesn&rsquo;t completely work in our case as
        <span class="math">f</span>
        is the result of a modulo
        <span class="math">Z_H</span>
        operation that would neutralize this randomization. So, we
        must take a slightly more cumbersome &ldquo;two-layered&rdquo;
        randomization approach:
      </p>

      <p class="text-gray-300 mt-4">
        We assume the last two indices
        <span class="math">x_&#123;n-2&#125;, x_&#123;n-1&#125;, y_&#123;n-2&#125;, y_&#123;n-1&#125;, z_&#123;n-2&#125;, z_&#123;n-1&#125;</span>
        of
        <span class="math">x, y, z</span>
        do not participate in any constraints (this can be achieved by
        padding the original R1CS with two unused variables). Let
        <span class="math">H_0 := H \setminus \&#123;n-2, n-1\&#125;</span>.
      </p>

      <p class="text-gray-300 mt-4">
        The prover
        <span class="math">\mathbf&#123;P&#125;</span>
        will choose six random degree one polynomials
        <span class="math">L_W^0, L_W^1, L_Y^0, L_Y^1, L_Z^0, L_Z^1</span>
        and define
      </p>

      <ul class="list-disc list-inside text-gray-300 mt-2 space-y-2">
        <li>
          <span class="math">W' := W + L_W^0 Z_&#123;H_0&#125; + L_W^1 Z_H</span>.
        </li>
        <li>
          <span class="math">Y' := Y + L_Y^0 Z_&#123;H_0&#125; + L_Y^1 Z_H</span>.
        </li>
        <li>
          <span class="math">Z' := Z + L_Z^0 Z_&#123;H_0&#125; + L_Z^1 Z_H</span>.
        </li>
      </ul>

      <p class="text-gray-300 mt-4">
        <span class="math">\mathbf&#123;P&#125;</span>
        will conduct the protocol with
        <span class="math">W', Y', Z'</span>
        instead of
        <span class="math">W, Y, Z</span>.
        We claim this results in a zero-knowledge protocol.
      </p>

      <p class="text-gray-300 mt-4">
        Note first that
        <span class="math">W', Y', Z'</span>
        satisfy the R1CS constraints when
        <span class="math">W, Y, Z</span>
        did as they coincide on
        <span class="math">H_0</span>.
      </p>

      <p class="text-gray-300 mt-4">
        Also, fixing any
        <span class="math">\tau, z \in \mathbb&#123;F&#125;</span>;
        the twelve values
        <span class="math">W'(\tau), W'(z), (W' \bmod Z_H)(\tau), (W' \bmod Z_H)(z)</span>,
        <span class="math">Y'(\tau), Y'(z), (Y' \bmod Z_H)(\tau), (Y' \bmod Z_H)(z)</span>,
        <span class="math">Z'(\tau), Z'(z), (Z' \bmod Z_H)(\tau), (Z' \bmod Z_H)(z)</span>
        are all uniform and independent.
      </p>

      <p class="text-gray-300 mt-4">
        Thus, the two evaluations of
        <span class="math">W', Y', Z'</span>
        give no information. The two evaluations of
        <span class="math">f</span>
        are a function of the verifier randomness together with the
        evaluations at
        <span class="math">\tau, z</span>
        of
        <span class="math">(W' \bmod Z_H), (Y' \bmod Z_H), (Z' \bmod Z_H)</span>,
        which can thus be simulated by choosing the latter evaluations
        independently and uniformly and computing
        <span class="math">f</span>
        from them.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. OPEN QUESTION                                             -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        7 &ensp; Open question: getting a fully succinct verifier
      </h2>

      <p class="text-gray-300">
        [MBKM19] give a
        <span class="math">(1, d)</span>-SCC
        where the run time of
        <span class="math">V_&#123;\text&#123;sc&#125;&#125;</span>
        is polylogarithmic in
        <span class="math">d</span>;
        i.e. the verifier is fully succinct, in the following
        restricted case. The polynomial
        <span class="math">s(X, Y)</span>
        can be written as a sum of a constant number of polynomials of
        the form
      </p>
      <div class="math-block">
        \sum_&#123;i \in [d]&#125; a_i X^i Y^&#123;\sigma(i)&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\sigma</span>
        is a permutation of
        <span class="math">[d]</span>.
        Our polynomials
        <span class="math">Q_1, Q_2, Q_3, R</span>
        from Section 5 are not of this form. However, it seems
        plausible the construction can be made to work while changing
        the polynomials into this form.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Acknowledgements</h2>
      <p class="text-gray-300">
        We thank Mary Maller for sharing details of the [MBKM19]
        construction, even while it was a work in progress, which
        inspired and motivated this work. We thank Sean Bowe for
        discussions on Sonic.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">References</h2>
      <ul class="space-y-3 text-sm text-gray-400">
        <li id="ref-BCC+16">
          <strong class="text-gray-300">[BCC+16]</strong>
          J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit.
          Efficient zero-knowledge arguments for arithmetic circuits
          in the discrete log setting. In <em>Advances in Cryptology
          &ndash; EUROCRYPT 2016</em>, pages 327&ndash;357, 2016.
        </li>
        <li id="ref-BCG+17">
          <strong class="text-gray-300">[BCG+17]</strong>
          E. Ben-Sasson, A. Chiesa, A. Gabizon, M. Riabzev, and
          N. Spooner. Interactive oracle proofs with constant rate and
          query complexity. In <em>44th International Colloquium on
          Automata, Languages, and Programming, ICALP 2017</em>,
          pages 40:1&ndash;40:15, 2017.
        </li>
        <li id="ref-BCGV16">
          <strong class="text-gray-300">[BCGV16]</strong>
          E. Ben-Sasson, A. Chiesa, A. Gabizon, and M. Virza.
          Quasi-linear size zero knowledge from linear-algebraic PCPs.
          In <em>Theory of Cryptography &ndash; TCC 2016-A</em>,
          pages 33&ndash;64, 2016.
        </li>
        <li id="ref-BCR+19">
          <strong class="text-gray-300">[BCR+19]</strong>
          E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner,
          M. Virza, and N. P. Ward. Aurora: Transparent succinct
          arguments for R1CS. In <em>Advances in Cryptology &ndash;
          EUROCRYPT 2019</em>, pages 103&ndash;128, 2019.
        </li>
        <li id="ref-BFL91">
          <strong class="text-gray-300">[BFL91]</strong>
          L. Babai, L. Fortnow, and C. Lund. Non-deterministic
          exponential time has two-prover interactive protocols.
          <em>Computational Complexity</em>, 1:3&ndash;40, 1991.
        </li>
        <li id="ref-BS08">
          <strong class="text-gray-300">[BS08]</strong>
          E. Ben-Sasson and M. Sudan. Short PCPs with polylog query
          complexity. <em>SIAM J. Comput.</em>, 38(2):551&ndash;607,
          2008.
        </li>
        <li id="ref-GGPR13">
          <strong class="text-gray-300">[GGPR13]</strong>
          R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic
          span programs and succinct NIZKs without PCPs. In
          <em>Advances in Cryptology &ndash; EUROCRYPT 2013</em>,
          pages 626&ndash;645, 2013.
        </li>
        <li id="ref-KZG10">
          <strong class="text-gray-300">[KZG10]</strong>
          A. Kate, G. M. Zaverucha, and I. Goldberg. Constant-size
          commitments to polynomials and their applications. In
          <em>Advances in Cryptology &ndash; ASIACRYPT 2010</em>,
          pages 177&ndash;194, 2010.
        </li>
        <li id="ref-MBKM19">
          <strong class="text-gray-300">[MBKM19]</strong>
          M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn.
          Sonic: Zero-knowledge SNARKs from linear-size universal and
          updateable structured reference strings. <em>IACR
          Cryptology ePrint Archive</em>, 2019:99, 2019.
        </li>
      </ul>
    </section>

    <PaperHistory slug="auroralight-2019" />
  </article>
</BaseLayout>
