---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1249';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Quantum cryptanalysis on some Generalized Feistel Schemes';
const AUTHORS_HTML = 'Xiaoyang Dong, Zheng Li, Xiaoyun Wang';

const CONTENT = `    <p class="text-gray-300">SCIENCE CHINA Information Sciences RESEARCH PAPER</p>

    <p class="text-gray-300">Xiaoyang DONG<span class="math">^{1}</span>, Zheng LI<span class="math">^{2}</span> &amp; Xiaoyun WANG<span class="math">^{1,2*}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span>Institute for Advanced Study, Tsinghua University, P. R. China {xiaoyangdong,xiaoyunwang}@tsinghua.edu.cn; <span class="math">^{2}</span>Key Laboratory of Cryptologic Technology and Information Security, Ministry of Education, Shandong University, P. R. China lixhengcn@mail.sdu.edu.cn</p>

    <p class="text-gray-300">Received ; accepted</p>

    <p class="text-gray-300">Abstract Post-quantum cryptography has attracted much attention from worldwide cryptologists. In ISIT 2010, Kuwakado and Morii gave a quantum distinguisher with polynomial time against 3-round Feistel networks. However, generalized Feistel schemes (GFS) have not been systematically investigated against quantum attacks. In this paper, we study the quantum distinguishers about some generalized Feistel schemes. For <span class="math">d</span>-branch Type-1 GFS (CAST256-like Feistel structure), we introduce <span class="math">(2d-1)</span>-round quantum distinguishers with polynomial time. For <span class="math">2d</span>-branch Type-2 GFS (RC6/CLEFIA-like Feistel structure), we give <span class="math">(2d+1)</span>-round quantum distinguishers with polynomial time. Classically, Moriai and Vaudenay proved that a 7-round 4-branch Type-1 GFS and 5-round 4-branch Type-2 GFS are secure pseudo-random permutations. Obviously, they are no longer secure in quantum setting.</p>

    <p class="text-gray-300">Using the above quantum distinguishers, we introduce generic quantum key-recovery attacks by applying the combination of Simon’s and Grover’s algorithms recently proposed by Leander and May. We denote <span class="math">n</span> as the bit length of a branch. For <span class="math">(d^{2}-d+2)</span>-round Type-1 GFS with <span class="math">d</span> branches, the time complexity is <span class="math">2^{(\\frac{4}{3}d^{2}-\\frac{3}{2}d+2)\\cdot\\frac{n}{2}}</span>, which is better than the quantum brute force search (Grover search) by a factor <span class="math">2^{(\\frac{1}{4}d^{2}+\\frac{1}{4}d)n}</span>. For <span class="math">4d</span>-round Type-2 GFS with <span class="math">2d</span> branches, the time complexity is <span class="math">2^{\\frac{d^{2}n}{2}}</span>, which is better than the quantum brute force search by a factor <span class="math">2^{\\frac{3d^{2}n}{2}}</span>.</p>

    <p class="text-gray-300">Keywords Generalized Feistel Schemes, Simon, Grover, Quantum Key-recovery, Quantum Cryptanalysis</p>

    <p class="text-gray-300">Citation Dong X Y, Li Z, Wang X Y. Quantum cryptanalysis on some Generalized Feistel Schemes. Sci China Inf Sci, 2016, (): xxxxxx, doi: xxxxxxxxxxxxx</p>

    <p class="text-gray-300">It is well known that several public key cryptosystem standards, such as RSA and ECC, have been broken by Shor’s algorithm [1] with a quantum computer. Recently, researchers find that quantum computing not only impacts the public key cryptography, but also could break many secret key schemes, which includes the key-recovery attacks against Even-Mansour ciphers [2], distinguishers against 3-round Feistel networks [3], key-recovery and forgery attacks on some MACs and authenticated encryption ciphers [4], key-recovery</p>

    <p class="text-gray-300">*Corresponding author (email: xiaoyunwang@tsinghua.edu.cn)</p>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">Table 1 Results on Type-1 (CAST256-like) GFS in quantum settings</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Branches d ≥ 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Distinguisher Round 2d-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key-recovery Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity (log)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trivial Bound (log)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r0=d2-d+2</td>

            <td class="px-3 py-2 border-b border-gray-700">(1/2d2-3/2d+2)·n/2</td>

            <td class="px-3 py-2 border-b border-gray-700">(d2-d+2)n/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r>r0</td>

            <td class="px-3 py-2 border-b border-gray-700">(1/2d2-3/2d+2)·n/2+(r-r0)n/2</td>

            <td class="px-3 py-2 border-b border-gray-700">rn/2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">attacks against FX constructions [5], and others. So to study the security of more classical and important cryptographic schemes against quantum attacks is urgently needed. At Asiacrypt 2017, NIST [6] reports the ongoing competition for post-quantum cryptographic algorithms, including signatures, encryptions and key-establishment. The ship for post-quantum crypto has sailed, cryptographic communities must get ready to welcome the post-quantum age.</p>

    <p class="text-gray-300">In a quantum computer, the adversaries could make quantum queries on some superposition quantum states of the relevant cryptosystem, which is the so-called quantum-CPA setting [7]. It is known that Grover's algorithm [8] could speed up brute force search. Given an  <span class="math">m</span> -bit key, Grover's algorithm allows to recover the key using  <span class="math">\\mathcal{O}(2^{m/2})</span>  quantum steps. It seems that doubling the key-length of one block cipher could achieve the same security against quantum attackers. However, Kuwakado and Morii [2] identified a new family of quantum attacks on certain generic constructions of secret key schemes. They showed that the Even-Mansour ciphers could be broken in polynomial time by Simon algorithm [9], which could find the period of a periodic function in polynomial time in a quantum computer. The following works by Kaplan et al. [4] revealed that many other secret key schemes could also be broken by Simon algorithm, such as CBC-MAC, PMAC, GMAC and some CAESAR candidates.</p>

    <p class="text-gray-300">Feistel block ciphers [10] are extremely important and extensively researched cryptographic schemes. It adopts an efficient Feistel network design. Historically, many block cipher standards such as DES, Triple-DES, MISTY1, Camellia and CAST-128 [11] are based on Feistel design. At CRYPTO 1989, Zheng et al. [12] summarised some generalized Feistel schemes (GFS) as Type-1/2/3 GFS. Many block ciphers are based on GFS designs. CAST-256 is based on Type-1 GFS, CLEFIA and RC6 are based on Type-2 GFS, MARS is based on Type-3 GFS, so Type-1/2/3 GFS are also denoted as CAST256-like Feistel scheme, RC6/CLEFIA-like Feistel scheme, and MARS-like Feistel scheme [13]. Chinese standard block cipher SMS4 is based on a different contracting Feistel scheme, we denote it as SMS4-like GFS.</p>

    <p class="text-gray-300">In a seminal work, Luby and Rackoff [14] proved that a three-round Feistel scheme is a secure pseudorandom permutation. However, Kuwakado and Morii [3] introduced a quantum distinguisher attack on 3-round Feistel ciphers, that could distinguish the cipher and a random permutation in polynomial time. At Asiacrypt 2000, Moriai and Vaudenay [13] studied some generalized Feistel schemes (GFS) and proved a 7-round 4-branch CAST256-like GFS and 5-round 4-branch RC6/CLEFIA-like GFS are secure pseudo-random permutations. Quantum distinguishers against those generalized Feistel schemes are missing.</p>

    <p class="text-gray-300">In this paper, we study the quantum distinguisher attacks on Type-1 GFS (CAST256-like), Type-2 GFS (RC6/CLEFIA-like) and others. For  <span class="math">d</span> -branch Type-1 GFS, we introduce  <span class="math">(2d - 1)</span> -round quantum distinguishers with polynomial time. For  <span class="math">2d</span> -branch Type-2 GFS (RC6/CLEFIA-like Feistel structure), we give  <span class="math">(2d + 1)</span> -round quantum distinguishers with polynomial time. Classically, Moriai and Vaudenay [13] proved that a 7-round 4-branch Type-1 GFS and 5-round 4-branch Type-2 GFS are secure pseudo-random permutations. Obviously, they are no longer secure in quantum setting. Denote the branch size as  <span class="math">n</span> . We introduce generic quantum key-recovery attacks on Type-1 and Type-2 GFS by applying the combination of Simon's and Grover's algorithms recently proposed by Leander and May. As shown in Table 1, for  <span class="math">(d^2 - d + 2)</span> -round Type-1 GFS with  <span class="math">d</span>  branches, the time complexity is  <span class="math">2^{(\\frac{1}{4}d^2 - \\frac{3}{2}d + 2) \\cdot \\frac{n}{2}}</span> , which is better than the quantum brute force search (Grover search) by a factor  <span class="math">2^{(\\frac{1}{4}d^2 + \\frac{1}{4}d)n}</span> . As shown in Table 2, for  <span class="math">4d</span> -round Type-2 GFS with  <span class="math">2d</span>  branches, the time complexity is  <span class="math">2^{\\frac{d^2n}{2}}</span> , which is better than the quantum brute force search by a factor  <span class="math">2^{\\frac{3d^2n}{2}}</span> .</p>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">Table 2 Results on Type-2 (RC6/CLEFIA-like) GFS in quantum settings</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Branches 2d ≥ 4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Distinguisher Round 2d + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Key-recovery Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity (log)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Trivial Bound (log)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r0=4d</td>

            <td class="px-3 py-2 border-b border-gray-700">d2/2n</td>

            <td class="px-3 py-2 border-b border-gray-700">2d2n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r>r0</td>

            <td class="px-3 py-2 border-b border-gray-700">d2+(r-r0)d/2n</td>

            <td class="px-3 py-2 border-b border-gray-700">rdn/2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">x_{j}^{0}</span>  the  <span class="math">j</span> th branch in the input;</p>

    <p class="text-gray-300"><span class="math">x_{j}^{i}</span>  the  <span class="math">j</span> th branch in the output of  <span class="math">i</span> th round,  <span class="math">i \\geqslant 1</span> ,  <span class="math">j \\geqslant 1</span> ;</p>

    <p class="text-gray-300"><span class="math">d</span>  the branch number of CAST256-like GFS;</p>

    <p class="text-gray-300">2d the branch number of RC6/CLEFIA-like GFS;</p>

    <p class="text-gray-300"><span class="math">n</span>  the bit length of a branch;</p>

    <p class="text-gray-300"><span class="math">R^i</span>  the  <span class="math">i</span> th  <span class="math">(i \\geqslant 1)</span>  round function of Type-1 (CAST256-like) GFS, the input and output are  <span class="math">n</span> -bit string,  <span class="math">n</span> -bit key is absorbed by  <span class="math">R^i</span> ;</p>

    <p class="text-gray-300"><span class="math">R_{j}^{i}</span>  the  <span class="math">j</span> th  <span class="math">(1\\leqslant j\\leqslant d)</span>  round function in the  <span class="math">i</span> th  <span class="math">(i\\geqslant 1)</span>  round function of Type-2 (RC6/CLEFIA -like) GFS, the input and output are  <span class="math">n</span> -bit string,  <span class="math">n</span> -bit key is absorbed by  <span class="math">R_{j}^{i}</span> .</p>

    <p class="text-gray-300">Our quantum attacks are based the two popular quantum algorithms, i.e. Simon algorithm [9] and Grover algorithm [8].</p>

    <p class="text-gray-300">Given a boolen function  <span class="math">f\\{0,1\\}^n \\to \\{0,1\\}^n</span> , that is known to be invariant under some  <span class="math">n</span> -bit XOR period  <span class="math">a</span> , find  <span class="math">a</span> . In other words, find  <span class="math">a</span>  by given:  <span class="math">f(x) = f(y) \\leftrightarrow x \\oplus y \\in \\{0^n, a\\}</span> .</p>

    <p class="text-gray-300">Classically, the optimal time to solve the problem is  <span class="math">\\mathcal{O}(2^{n/2})</span> . However, Simon [9] gives a quantum algorithm that provides exponential speedup and only requires  <span class="math">\\mathcal{O}(n)</span>  quantum queries to find  <span class="math">a</span> . The algorithm includes five quantum steps:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I. Initializing two  <span class="math">n</span> -bit quantum registers to state  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle^{\\otimes n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle^{\\otimes n}$ , one applies Hadamard transform to the first register to attain an equal superposition:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H ^ {\\otimes n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 \\rangle = \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {x \\in \\{0, 1 \\} ^ {n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 \\rangle . \\tag {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">II. A quantum query to the function  <span class="math">f</span>  maps this to the state</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {x \\in \\{0, 1 \\} ^ {n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f (x) \\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">III. Measuring the second register, the first register collapses to the state:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{\\sqrt {2}} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z \\rangle +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z \\oplus a \\rangle).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">IV. Applying Hadamard transform to the first register, we get:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{\\sqrt {2}} \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {y \\in \\{0, 1 \\} ^ {n}} (- 1) ^ {y \\cdot z} (1 + (- 1) ^ {y \\cdot a})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y \\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1 3-round quantum distinguisher</p>

    <p class="text-gray-300">V. The vectors  <span class="math">y</span>  such that  <span class="math">y \\cdot a = 1</span>  have amplitude 0. Hence, measuring the state yields a value  <span class="math">y</span>  that  <span class="math">y \\cdot a = 0</span> .</p>

    <p class="text-gray-300">Repeat  <span class="math">\\mathcal{O}(n)</span>  times, one obtains  <span class="math">a</span>  by solving a system of linear equations.</p>

    <p class="text-gray-300">Kuwakado and Morii [3] introduced a quantum distinguish attack on 3-round Feistel scheme by using Simon algorithm. As shown in Figure 1,  <span class="math">\\alpha_0</span>  and  <span class="math">\\alpha_{1}</span>  are arbitrary constants:</p>

    <div class="my-4 text-center"><span class="math-block">f: \\{0, 1 \\} \\times \\{0, 1 \\} ^ {n} \\quad \\rightarrow \\quad \\{0, 1 \\} ^ {n}</span></div>

    <div class="my-4 text-center"><span class="math-block">b, x \\quad \\mapsto \\quad \\alpha_ {b} \\oplus x _ {2} ^ {3}, \\text {w h e r e} (x _ {1} ^ {3}, x _ {2} ^ {3}) = E (\\alpha_ {b}, x),</span></div>

    <div class="my-4 text-center"><span class="math-block">f (b, x) = R _ {2} \\left(R _ {1} \\left(\\alpha_ {b}\\right) \\oplus x\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">f</span>  is periodic function that  <span class="math">f(b,x) = f(b\\oplus 1,x\\oplus R_1(\\alpha_0)\\oplus R_1(\\alpha_1))</span> . Then using Simon's algorithm, one can get the period  $s = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{1}(\\alpha_{0})\\oplus R_{1}(\\alpha_{1})$  in polynomial time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-6" class="text-2xl font-bold">3.2 Grover's algorithm</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The task is to find a marked element from a set  <span class="math">X</span> . We denote by  <span class="math">M \\subseteq X</span>  the subset of marked elements. Classically, one solves the problem with time  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . However, in a quantum computer, the problem is solved with high probability in time  </span>\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  using Grover's algorithm. The steps of the algorithm is as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I. Initializing a  <span class="math">n</span> -bit register  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle^{\\otimes n}$ . One applies Hadamard transform to the first register to attain an equal superposition:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H ^ {\\otimes n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0 \\rangle = \\frac {1}{\\sqrt {2 ^ {n}}} \\sum_ {x \\in \\{0, 1 \\} ^ {n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle . \\tag {2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">II. Construct an oracle  <span class="math">\\mathcal{O}</span> :  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle \\xrightarrow{\\mathcal{O}} (-1)^{f(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle<span class="math"> , where  </span>f(x) = 1<span class="math">  if  </span>x<span class="math">  is the correct state, and  </span>f(x) = 0$  otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">III. Apply Grover iteration for  <span class="math">R \\approx \\frac{\\pi}{4}\\sqrt{2^n}</span>  times:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[ (2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle \\langle \\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- I) \\mathcal {O} ] ^ {R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle \\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {0} \\rangle .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">IV. return  <span class="math">x_0</span> .</p>

    <p class="text-gray-300">Later, Brassard et al. [15] generalized the Grover search as amplitude amplification.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1. (Brassard, Hoyer, Mosca and Tapp [15]). Let  <span class="math">\\mathcal{A}</span>  be any quantum algorithm on  <span class="math">q</span>  qubits that uses no measurement. Let  <span class="math">\\mathcal{B}:\\mathbb{F}_2^q\\to \\{0,1\\}</span>  be a function that classifies outcomes of  <span class="math">\\mathcal{A}</span>  as good or bad. Let  <span class="math">p &amp;gt; 0</span>  be the initial success probability that a measurement of  $\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math">  is good. Set  </span>k = \\lceil \\frac{\\pi}{4\\theta}\\rceil$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2 FX constructions</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3 Quantum key-recovery attacks on 5-Round Feistel structures</p>

    <p class="text-gray-300">where  <span class="math">\\theta</span>  is defined via  <span class="math">sin^2 (\\theta) = p</span> . Moreover, define the unitary operator  <span class="math">Q = -\\mathcal{A}S_0\\mathcal{A}^{-1}S_{\\mathcal{B}}</span> , where the operator  <span class="math">S_{\\mathcal{B}}</span>  changes the sign of the good state</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle \\mapsto \\left\\{ \\begin{array}{c} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle \\text { if } \\mathcal {B} (x) = 1, \\\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\rangle \\text { if } \\mathcal {B} (x) = 0, \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">while  <span class="math">S_0</span>  changes the sign of the amplitude only for the zero state  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math"> . Then after the computation of  </span>Q^k\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math"> , a measurement yields good with probability a least  </span>\\max \\{1 - p, p\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assuming  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle = \\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math">  is the initial vector, whose projections on the good and the bad subspace are denoted  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_1\\rangle<span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_0\\rangle<span class="math"> . The state  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle = \\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math">  has angle  </span>\\theta<span class="math">  with the bad subspace, where  </span>sin^2 (\\theta) = p<span class="math"> . Each  </span>Q<span class="math">  iteration increase the angle to  </span>2\\theta<span class="math"> . Hence, after  </span>k\\approx \\frac{\\pi}{4\\theta}<span class="math"> , the angle roughly equals to  </span>\\pi /2<span class="math"> . Thus, the state after  </span>k$  iterations is almost orthogonal to the bad subspace. After measurement, it produces the good vector with high probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At Asiacrypt 2017, Leander and May [5] gave a quantum key-recovery attack on FX-construction shown in Figure 2:  <span class="math">Enc(x) = E_{k_0}(x + k_1) + k_2</span> . They introduce the function  <span class="math">f(k,x) = Enc(x) + E_k(x) = E_{k_0}(x + k_1) + k_2 + E_k(x)</span> . For the correct key guess  <span class="math">k = k_0</span> , we have  <span class="math">f(k,x) = f(k,x + k_1)</span>  for all  <span class="math">x</span> . However, for  <span class="math">k \\neq k_0</span> ,  <span class="math">f(k,\\cdot)</span>  is not periodic. They combine Simon and Grover algorithm to attack FX ciphers (such as PRINCE [16], PRIDE [17], DESX [18]) in the quantum-CPA model with complexity roughly  <span class="math">2^{32}</span> .</p>

    <p class="text-gray-300">Then Dong et al. [19] and Hosoyamada et al. [20] independently applied Leander et al.'s [5] attack to generic feistel constructions. As shown in Figure 3, they append 2-round feistel networks under the 3-round quantum distinguisher in Figure 1 to give a quantum key-recovery attack on 5-round feistel construction.</p>

    <p class="text-gray-300">Suppose the state size is <span class="math">n</span>, then the length of <span class="math">k_{i}</span> is <span class="math">n/2</span>. The following functions is defined:</p>

    <p class="text-gray-300"><span class="math">f(b,x_{R_{0}})=R_{2}(k_{2},x_{2}^{0}\\oplus R_{1}(k_{1},\\alpha_{b}))=\\alpha_{b}\\oplus x_{2}^{3}=\\alpha_{b}\\oplus R_{4}(k_{4},R_{5}(k_{5},x_{2}^{5})\\oplus x_{1}^{5})\\oplus x_{2}^{5},</span> (3)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">b\\in\\mathbb{F}_{2}</span>, <span class="math">\\alpha_{b}\\in\\mathbb{F}_{2}^{n/2}</span> is arbitrary constant and <span class="math">\\alpha_{0}\\neq\\alpha_{1}</span>, $(x_{1}^{5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}^{5})=Enc(\\alpha_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}^{0})<span class="math">. It is easy to verify that </span>f(b,x_{2}^{0})=f(b\\oplus 1,x_{2}^{0}\\oplus R_{1}(k_{1},\\alpha_{0})\\oplus R_{1}(k_{1},\\alpha_{1}))<span class="math">. Therefore, with the right key guess </span>(k_{4},k_{5})<span class="math">, </span>f(b,x_{2}^{0})=\\alpha_{b}\\oplus R_{4}(k_{4},R_{5}(k_{5},x_{2}^{5})\\oplus x_{1}^{5})<span class="math"> has a nontrivial period </span>s=1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{1}(k_{1},\\alpha_{0})\\oplus R_{1}(k_{1},\\alpha_{1})<span class="math">. However, if the guessed </span>(k_{4},k_{5})<span class="math"> is wrong, </span>f(b,x_{2}^{0})$ is a random function and not periodic with high probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300"><em>[19]</em> Let <span class="math">g</span>: <span class="math">\\mathbb{F}_{2}^{n}\\times\\mathbb{F}_{2}^{n/2+1}\\mapsto\\mathbb{F}_{2}^{n/2}</span> with</p>

    <p class="text-gray-300"><span class="math">(k_{4},k_{5},y)\\mapsto f(y)=f(b,x)=\\alpha_{b}\\oplus R_{4}(k_{4},R_{5}(k_{5},x_{2}^{5})\\oplus x_{1}^{5})\\oplus x_{2}^{5},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\alpha_{0},\\alpha_{1}</span> are two arbitrary constants, $(x_{1}^{5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}^{5})=Enc(\\alpha_{b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x)<span class="math">. Given quantum oracle to </span>g<span class="math"> and </span>Enc<span class="math">, </span>(k_{4},k_{5})<span class="math"> and </span>R_{1}(k_{1},\\alpha_{0})\\oplus R_{1}(k_{1},\\alpha_{1})<span class="math"> could be computed with </span>n+(n+1)(n+2+2\\sqrt{n/2+1})<span class="math"> qubits and about </span>2^{n/2}$ quantum queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Under the right key guess <span class="math">k_{4},k_{5}</span>, <span class="math">g(k_{4},k_{5},y)=g(k_{4},k_{5},y\\oplus s)</span>. Let, <span class="math">h</span>: <span class="math">\\mathbb{F}_{2}^{n}\\times\\mathbb{F}_{2}^{(n/2+1)^{l}}\\mapsto\\mathbb{F}_{2}^{(n/2)^{l}}</span> with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(k_{4},k_{5},y_{1},...,y_{l})\\mapsto g(k_{4},k_{5},y_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g(k_{4},k_{5},y_{l}).$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">U_{h}</span> be a quantum oracle that maps</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{4},k_{5},y_{1},...,y_{l},\\mathbf{0},...,\\mathbf{0}\\rangle\\mapsto</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{4},k_{5},y_{1},...,y_{l},h(k_{4},k_{5},y_{1},...,y_{l})\\rangle.$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similar to the work <em>[5]</em>, Dong and Wang <em>[19]</em> constructed the following quantum algorithm <span class="math">\\mathcal{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Preparing the initial <span class="math">(n+(n/2+1)l+nl/2)</span>-qubit state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{0}\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apply Hadamard <span class="math">H^{\\otimes n+(n/2+1)l}</span> on the first <span class="math">n+(n/2+1)l</span> qubits resulting in</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{k_{4},k_{5}\\in\\mathbb{F}_{2}^{n/2},y_{1},...,y_{l}\\in\\mathbb{F}_{2}^{n/2+1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{4},k_{5}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{1}\\rangle...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{l}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{0}\\rangle,$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where we omit the amplitudes <span class="math">2^{-(n+(n/2+1)l)/2}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Applying <span class="math">U_{h}</span> to the above state, we get:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{k_{4},k_{5}\\in\\mathbb{F}_{2}^{n/2},y_{1},...,y_{l}\\in\\mathbb{F}_{2}^{n/2+1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{4},k_{5}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{1}\\rangle...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{l}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h(k_{4},k_{5},y_{1},...,y_{l})\\rangle.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle=\\sum_{k_{4},k_{5}\\in\\mathbb{F}_{2}^{n/2},u_{1},...,u_{l},y_{1},...,y_{l}\\in\\mathbb{F}_{2}^{n/2+1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{4},k_{5}\\rangle(-1)^{\\langle u_{1},y_{1}\\rangle}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{1}\\rangle...(-1)^{\\langle u_{l},y_{l}\\rangle}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u_{l}\\rangle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h(k_{4},k_{5},y_{1},...,y_{l})\\rangle.$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the guessed <span class="math">k_{4},k_{5}</span> is right, after measurement of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle<span class="math">, the period </span>s<span class="math"> is orthogonal to all the </span>u_{1},...,u_{l}<span class="math">. According to Lemma 4 of <em>[5]</em>, choosing </span>l=2(n/2+1+\\sqrt{n/2+1})<span class="math"> is enough to compute a unique </span>s$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without measurement and considering the superposition $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle<span class="math">, Dong and Wang <em>[19]</em> introduced a classifier </span>\\mathcal{B}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Classifier <span class="math">\\mathcal{B}</span>. Define <span class="math">\\mathcal{B}:\\mathbb{F}_{2}^{n+(n/2+1)l}\\mapsto\\{0,1\\}</span> that maps <span class="math">(k_{4},k_{5},u_{1},...,u_{l})\\mapsto\\{0,1\\}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\overline{U}=\\langle u_{1},...,u_{l}\\rangle</span> be the linear span of all <span class="math">u_{i}</span>. If <span class="math">dim(\\overline{U})\\neq n/2</span>, output <span class="math">0</span>. Else, use Lemma 4 of <em>[5]</em> to compute the unique period <span class="math">s</span>.</li>

      <li>Check <span class="math">g(k_{4},k_{5},y)=g(k_{4},k_{5},y\\oplus s)</span> for a random given <span class="math">y</span>. If the identity holds, output <span class="math">1</span>. Else output <span class="math">0</span></li>

    </ol>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4 Round <span class="math">i</span> of CAST256-like GFS with <span class="math">d</span> branches</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Classifier <span class="math">\\mathcal{B}</span> partitions $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle<span class="math"> into a good subspace and a bad subspace: </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_1\\rangle +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_0\\rangle<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_1\\rangle<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_0\\rangle<span class="math"> denotes the projection onto the good subspace and bad subspace, respectively. For the good one </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\rangle<span class="math">, </span>\\mathcal{B}(x) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Classifier <span class="math">\\mathcal{B}</span> defines a unitary operator <span class="math">S_{\\mathcal{B}}</span> that conditionally change the sign of the quantum states:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k _ {4}, k _ {5} \\right\\rangle \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {1} \\right\\rangle \\dots \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {l} \\right\\rangle \\mapsto \\left\\{ \\begin{array}{c} - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k _ {4}, k _ {5} \\right\\rangle \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {1} \\right\\rangle \\dots \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {l} \\right\\rangle \\text { if } \\mathcal {B} \\left(k _ {4}, k _ {5}, u _ {1}, \\dots , u _ {l}\\right) = 1, \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k _ {4}, k _ {5} \\right\\rangle \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {1} \\right\\rangle \\dots \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">u _ {l} \\right\\rangle \\text { if } \\mathcal {B} \\left(k _ {4}, k _ {5}, u _ {1}, \\dots , u _ {l}\\right) = 0. \\end{array} \\right. \\tag {9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The complete amplification process is realized by repeatedly for <span class="math">t</span> times applying the unitary operator <span class="math">Q = -\\mathcal{A}S_0\\mathcal{A}^{-1}S_{\\mathcal{B}}</span> to the state $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi \\rangle = \\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math">, i.e. </span>Q^t\\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Initially, the angle between $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi\\rangle = \\mathcal{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0\\rangle<span class="math"> and the bad subspace </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_0\\rangle<span class="math"> is </span>\\theta<span class="math">, where </span>\\sin^2(\\theta) = p = \\langle \\varphi_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_1\\rangle<span class="math">. When </span>p<span class="math"> is smaller enough, </span>\\theta \\approx \\arcsin(\\sqrt{p}) \\approx 2^{-\\frac{n}{2}}<span class="math">. According to Theorem 1, after </span>k = \\left\\lceil \\frac{\\pi}{4\\theta} \\right\\rceil = \\left\\lceil \\frac{\\pi}{4 \\times 2^{-\\frac{n}{2}}} \\right\\rceil<span class="math"> Grover iterations </span>Q<span class="math">, the angle between resulting state and the bad subspace is roughly </span>\\pi/2<span class="math">. The probability </span>P_{good}<span class="math"> that the measurement yields a good state is about </span>\\sin^2(\\pi/2) = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The whole attack needs <span class="math">(n + (n / 2 + 1)l + nl / 2) = n + (n + 1)(n + 2 + 2\\sqrt{n / 2 + 1})</span> qubits. About <span class="math">k = \\left\\lceil \\frac{n}{4 \\times 2^{-\\frac{n}{2}}} \\right\\rceil = 2^{n / 2}</span> quantum queries are required to recover <span class="math">k_{4}, k_{5}</span>. Thus, in our quantum cryptanalysis on GFS, the first step is to find new quantum distinguishers, and then give a similar quantum key-recovery attacks by appending several rounds to the distinguishers.</p>

    <h2 id="sec-10" class="text-2xl font-bold">4.1 Quantum distinguishers on Type-1 (CAST256-like) GFS</h2>

    <p class="text-gray-300">As shown in Figure 4, the input of the cipher is divided into <span class="math">d</span> branches, i.e. <span class="math">x_{j}^{0}</span> for <span class="math">1 \\leqslant j \\leqslant d</span>, each of which has <span class="math">n</span>-bit, so the blocksize is <span class="math">d \\times n</span>. <span class="math">R^{i}</span> is the round function that absorbs <span class="math">n</span>-bit secret key and <span class="math">n</span>-bit input. We construct the corresponding quantum distinguisher on the <span class="math">(2d - 1)</span>-round cipher.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The intermediate state after the <span class="math">i</span>th round is <span class="math">x_{j}^{i}</span> for <span class="math">1 \\leqslant j \\leqslant d</span>, especially the output of the <span class="math">(2d - 1)</span>th round is denoted as $x_{1}^{2d - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}^{2d - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{d}^{2d - 1}<span class="math">. For the input of round function </span>R^{d}<span class="math">, we compute its symbolic expression with </span>x_{j}^{0}<span class="math"> for </span>1 \\leqslant j \\leqslant d$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">R ^ {d - 1} \\left(R ^ {d - 2} \\left(\\dots R ^ {3} \\left(R ^ {2} \\left(R ^ {1} \\left(x _ {1} ^ {0}\\right) \\oplus x _ {2} ^ {0}\\right) \\oplus x _ {3} ^ {0}\\right) \\dots \\oplus x _ {d - 2} ^ {0}\\right) \\oplus x _ {d - 1} ^ {0}\\right) \\oplus x _ {d} ^ {0}. \\tag {10}</span></div>

    <p class="text-gray-300">Similarly, the output of round function <span class="math">R^d</span> is <span class="math">x_1^0 \\oplus x_2^{2d-1}</span>. Thus, we get the following equation:</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {d} \\left(R ^ {d - 1} \\left(R ^ {d - 2} \\left(\\dots R ^ {3} \\left(R ^ {2} \\left(R ^ {1} \\left(x _ {1} ^ {0}\\right) \\oplus x _ {2} ^ {0}\\right) \\oplus x _ {3} ^ {0}\\right) \\dots \\oplus x _ {d - 2} ^ {0}\\right) \\oplus x _ {d - 1} ^ {0}\\right) \\oplus x _ {d} ^ {0}\\right) = x _ {1} ^ {0} \\oplus x _ {2} ^ {2 d - 1}. \\tag {11}</span></div>

    <p class="text-gray-300">In Equation (11), let <span class="math">x_1^0 = \\alpha_b (b = 0, 1, \\alpha_0, \\alpha_1)</span> are arbitrary constants, <span class="math">\\alpha_0 \\neq \\alpha_1)</span>, <span class="math">x_d^0 = x</span>, and all of <span class="math">x_1^0, x_2^0, \\ldots, x_d^0</span> be constants, we get</p>

    <div class="my-4 text-center"><span class="math-block">R ^ {d} \\left(R ^ {d - 1} \\left(R ^ {d - 2} \\left(\\dots R ^ {3} \\left(R ^ {2} \\left(R ^ {1} \\left(\\alpha_ {b}\\right) \\oplus x _ {2} ^ {0}\\right) \\oplus x _ {3} ^ {0}\\right) \\dots \\oplus x _ {d - 2} ^ {0}\\right) \\oplus x _ {d - 1} ^ {0}\\right) \\oplus x\\right) = \\alpha_ {b} \\oplus x _ {2} ^ {2 d - 1}. \\tag {12}</span></div>

    <p class="text-gray-300">Denote <span class="math">h(\\alpha_b) = R^{d-1}(R^{d-2}(\\ldots R^3(R^2(R^1(\\alpha_b) \\oplus x_2^0) \\oplus x_3^0) \\ldots \\oplus x_{d-2}^0) \\oplus x_{d-1}^0)</span>, then Equation (12) becomes <span class="math">R^d(h(\\alpha_b) \\oplus x) = \\alpha_b \\oplus x_2^{2d-1}</span>. We construct function <span class="math">f</span> as follows:</p>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5 7-round distinguisher on CAST256-like GFS with  <span class="math">d = 4</span></p>

    <div class="my-4 text-center"><span class="math-block">f: \\{0, 1 \\} \\times \\{0, 1 \\} ^ {n} \\quad \\rightarrow \\quad \\{0, 1 \\} ^ {n}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b, x \\quad \\mapsto \\quad \\alpha_ {b} \\oplus x _ {2} ^ {2 d - 1}, \\text {w h e r e} x _ {1} ^ {2 d - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {2} ^ {2 d - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {d} ^ {2 d - 1} = E (\\alpha_ {b}, x),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">f (b, x) = R ^ {d} \\left(h \\left(\\alpha_ {b}\\right) \\oplus x\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So  <span class="math">f(0,x) = f(1,x\\oplus h(\\alpha_0)\\oplus h(\\alpha_1)) = R_d(h(\\alpha_0)\\oplus x),f(1,x) = f(0,x\\oplus h(\\alpha_0)\\oplus h(\\alpha_1)) = R_d(h(\\alpha_1)\\oplus x).</span>  Thus  <span class="math">f(b,x) = f(b\\oplus 1,x\\oplus h(\\alpha_0)\\oplus h(\\alpha_1))</span>  . Therefore, function  <span class="math">f</span>  satisfies Simon's promise with  $s = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h(\\alpha_0)\\oplus h(\\alpha_1)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Example case of Type-1 (CAST256-like) with  <span class="math">d = 4</span> :</p>

    <p class="text-gray-300">When  <span class="math">d = 4</span> , we get 7-round quantum distinguisher as shown in Figure 5. Thus,  <span class="math">h(\\alpha_{b}) = R^{3}(R^{2}(R^{1}(\\alpha_{b})\\oplus x_{2}^{0})\\oplus x_{3}^{0})</span> , where  <span class="math">x_{2}^{0}</span>  and  <span class="math">x_{3}^{0}</span>  are constants.</p>

    <p class="text-gray-300">We first study the quantum key-recovery attack on CAST256-like GFS with  <span class="math">d = 4</span>  branches. Following the similar idea that combines Simon's and Grover's algorithms to attack Feistel structure [19] shown in Section 3.3, we append 7 rounds under the 7-round distinguisher to launch the attack. As shown in Figure 6, there are  <span class="math">4n</span> -bit key needed to be guessed by Grover's algorithm, which are highlighted in the red boxes of round functions. Thus, the 14-round quantum key-recovery attack needs about  <span class="math">2^{2n}</span>  time and  <span class="math">\\mathcal{O}(n^2)</span>  qubits. If we attack  <span class="math">r &amp;gt; 14</span>  rounds, we need guess  <span class="math">4n + (r - 14)n</span>  key bits by Grover's algorithm. Thus, the time complexity is  <span class="math">2^{2n + \\frac{(r - 14)n}{2}}</span> .</p>

    <p class="text-gray-300">Generally, for  <span class="math">d \\geqslant 3</span> , we could get  <span class="math">(2d - 1)</span> -round quantum distinguisher. We append  <span class="math">d^2 - 3d + 3</span>  rounds under the quantum distinguisher to attack  <span class="math">r_0 = d^2 - d + 2</span>  rounds CAST256-like GFS. Similarly, we need to guess  <span class="math">(\\frac{1}{2} d^2 - \\frac{3}{2} d + 2)n</span> -bit key by Grover's algorithm. Thus, for  <span class="math">r_0</span>  rounds, the time complexity is  <span class="math">(\\frac{1}{2} d^2 - \\frac{3}{2} d + 2) \\cdot \\frac{n}{2}</span>  queries, and  <span class="math">\\mathcal{O}(n^2)</span>  qubits are needed. If we attack  <span class="math">r &amp;gt; r_0</span>  rounds, we need guess  <span class="math">(\\frac{1}{2} d^2 - \\frac{3}{2} d + 2)n + (r - r_0)n</span>  key bits by Grover's algorithm. Thus, the time complexity is  <span class="math">2^{(\\frac{1}{2} d^2 - \\frac{3}{2} d + 2) \\cdot \\frac{n}{2} + \\frac{(r - r_0)n}{2}}</span> .</p>

    <p class="text-gray-300">If we use the quantum brute force search (Grover search) to recover the key, for  <span class="math">r</span> -round  <span class="math">d</span> -branch cipher, totally,  <span class="math">rn</span> -bit key need to be found, the complexity is  <span class="math">2^{rn/2}</span> . Thus, our attack is better than the quantum brute force search (Grover search) by a factor  <span class="math">2^{rn/2 - ((\\frac{1}{2}d^2 - \\frac{3}{2}d + 2) \\cdot \\frac{n}{2} + \\frac{(r - r_0)n}{2})} = 2^{(\\frac{1}{4}d^2 + \\frac{1}{4}d)n}</span> .</p>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6 14-round quantum key-recovery attack on CAST256-like GFS with <span class="math">d = 4</span></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 7 Round <span class="math">i</span> of RC6/CLEFIA-like GFS with <span class="math">2d</span> branches</p>

    <h2 id="sec-13" class="text-2xl font-bold">5.1 Quantum distinguishers on Type-2 (RC6/CLEFIA-like) GFS</h2>

    <p class="text-gray-300">As shown in Figure 7, the input of the cipher is divided into <span class="math">2d</span> branches, i.e. <span class="math">x_{j}^{0}</span> for <span class="math">1 \\leqslant j \\leqslant 2d</span>, each of which has <span class="math">n</span>-bit, so the blocksize is <span class="math">2d \\times n</span>. <span class="math">R_{l}^{i}</span> (<span class="math">1 \\leqslant l \\leqslant d</span>) is the <span class="math">j</span>th round function in <span class="math">i</span>th round that absorbs <span class="math">n</span>-bit secret key and <span class="math">n</span>-bit input. We construct the corresponding quantum distinguisher on the <span class="math">(2d + 1)</span>-round cipher.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The intermediate state after the <span class="math">i</span>th round is <span class="math">x_{j}^{i}</span> for <span class="math">1 \\leqslant j \\leqslant 2d</span>, especially the output of the <span class="math">(2d + 1)</span>th round is denoted as $x_{1}^{2d + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}^{2d + 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2d}^{2d + 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Case study, <span class="math">2d = 4</span>:</strong></p>

    <p class="text-gray-300">As shown in Figure 8 with <span class="math">2d = 4</span>, for the input of round function <span class="math">R_1^4</span> about <span class="math">x_j^0</span> for <span class="math">1 \\leqslant j \\leqslant 4</span>, we compute its symbolic expression: <span class="math">R_1^3 (R_1^2 (R_1^1 (x_1^0) \\oplus x_2^0) \\oplus x_3^0) \\oplus R_2^1 (x_3^0) \\oplus x_4^0</span>. The output of <span class="math">R_1^4</span> can be expressed as <span class="math">x_1^0 \\oplus x_4^5 \\oplus R_2^2 (R_2^1 (x_3^0) \\oplus x_4^0)</span>. Through <span class="math">R_1^4</span>, we obtain the following equation</p>

    <div class="my-4 text-center"><span class="math-block">R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(x _ {1} ^ {0}\\right) \\oplus x _ {2} ^ {0}\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) = x _ {1} ^ {0} \\oplus x _ {4} ^ {5} \\oplus R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right). \\tag {13}</span></div>

    <p class="text-gray-300">Let <span class="math">x_{1}^{0} = \\alpha_{b}</span>, <span class="math">x_{2}^{0} = x</span>, <span class="math">x_{3}^{0}</span>, <span class="math">x_{4}^{0}</span> be constants, it becomes</p>

    <div class="my-4 text-center"><span class="math-block">R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(\\alpha_ {b}\\right) \\oplus x\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) = \\alpha_ {b} \\oplus x _ {4} ^ {5} \\oplus R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right). \\tag {14}</span></div>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 8 5-round distinguisher on RC6/CLEFIA-like GFS with  <span class="math">2d = 4</span></p>

    <div class="my-4 text-center"><span class="math-block">f _ {4}: \\{0, 1 \\} \\times \\{0, 1 \\} ^ {n} \\rightarrow \\{0, 1 \\} ^ {n}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b, x \\mapsto \\alpha_ {b} \\oplus x _ {4} ^ {5} \\oplus R _ {2} ^ {2} (R _ {2} ^ {1} (x _ {3} ^ {0}) \\oplus x _ {4} ^ {0}), \\text {w h e r e} x _ {1} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {2} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {3} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {4} ^ {5} = E (\\alpha_ {b}, x),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {4} (b, x) = R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(\\alpha_ {b}\\right) \\oplus x\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus  <span class="math">f_{4}(b,x) = f_{4}(b\\oplus 1,x\\oplus R_{1}^{1}(\\alpha_{0})\\oplus R_{1}^{1}(\\alpha_{1}))</span> . Therefore, function  <span class="math">f_{4}</span>  satisfies Simon's promise with  $s = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_1^1 (\\alpha_0)\\oplus R_1^1 (\\alpha_1)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As shown in Figure 9 with  <span class="math">2d = 6</span> , for the input of round function  <span class="math">R_1^6</span>  about  <span class="math">x_j^0</span>  for  <span class="math">1 \\leqslant j \\leqslant 6</span> , we compute its symbolic expression:  <span class="math">R_1^5 (R_1^4 (R_1^3 (R_1^2 (R_1^1 (x_1^0) \\oplus x_2^0) \\oplus x_3^0) \\oplus R_2^1 (x_3^0) \\oplus x_4^0) \\oplus R_2^2 (R_2^1 (x_3^0) \\oplus x_4^0) \\oplus x_5^0) \\oplus R_2^3 (R_2^2 (R_2^1 (x_3^0) \\oplus x_4^0) \\oplus x_5^0) \\oplus R_3^1 (x_5^0) \\oplus x_6^0</span> .</p>

    <p class="text-gray-300">The output of  <span class="math">R_1^6</span>  can be expressed as  <span class="math">x_1^0 \\oplus x_6^7 \\oplus R_3^2 (R_3^1 (x_5^0) \\oplus x_6^0) \\oplus R_2^4 (R_2^3 (R_2^2 (R_2^1 (x_3^0) \\oplus x_4^0) \\oplus x_5^0) \\oplus R_3^1 (x_5^0) \\oplus x_6^0)</span> . Through  <span class="math">R_1^4</span> , we obtain the following</p>

    <div class="my-4 text-center"><span class="math-block">R _ {1} ^ {6} \\left(R _ {1} ^ {5} \\left(R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(x _ {1} ^ {0}\\right) \\oplus x _ {2} ^ {0}\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\oplus R _ {2} ^ {3} \\left(R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0} = x _ {1} ^ {0} \\oplus x _ {6} ^ {7} \\oplus R _ {3} ^ {2} \\left(R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0}\\right) \\oplus R _ {2} ^ {4} \\left(R _ {2} ^ {3} \\left(R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0}\\right).</span></div>

    <p class="text-gray-300">Let  <span class="math">x_1^0 = \\alpha_b</span> ,  <span class="math">x_2^0 = x</span> ,  <span class="math">x_3^0</span> ,  <span class="math">x_4^0</span> ,  <span class="math">x_5^0</span> ,  <span class="math">x_6^0</span>  be constants, it becomes</p>

    <div class="my-4 text-center"><span class="math-block">R _ {1} ^ {6} \\left[ R _ {1} ^ {5} \\left(R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(\\alpha_ {b}\\right) \\oplus x\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\oplus R _ {2} ^ {3} \\left(R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0} = \\alpha_ {b} \\oplus x _ {6} ^ {7} \\oplus R _ {3} ^ {2} \\left(R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0}\\right) \\oplus R _ {2} ^ {4} \\left(R _ {2} ^ {3} \\left(R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0}\\right).</span></div>

    <p class="text-gray-300">(16)</p>

    <div class="my-4 text-center"><span class="math-block">f _ {6}: \\{0, 1 \\} \\times \\{0, 1 \\} ^ {n} \\rightarrow \\{0, 1 \\} ^ {n}</span></div>

    <div class="my-4 text-center"><span class="math-block">b, x \\mapsto \\alpha_ {b} \\oplus x _ {6} ^ {7} \\oplus R _ {3} ^ {2} (R _ {3} ^ {1} (x _ {5} ^ {0}) \\oplus x _ {6} ^ {0}) \\oplus R _ {2} ^ {4} (R _ {2} ^ {3} (R _ {2} ^ {2} (R _ {2} ^ {1} (x _ {3} ^ {0}) \\oplus x _ {4} ^ {0})</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\oplus x _ {5} ^ {0}) \\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0}), \\text {w h e r e} x _ {1} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {2} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {3} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {4} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {5} ^ {5}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {6} ^ {5} = E \\left(\\alpha_ {b}, x\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {6} (b, x) = R _ {1} ^ {6} \\left[ R _ {1} ^ {5} \\left(R _ {1} ^ {4} \\left(R _ {1} ^ {3} \\left(R _ {1} ^ {2} \\left(R _ {1} ^ {1} \\left(\\alpha_ {b}\\right) \\oplus x\\right) \\oplus x _ {3} ^ {0}\\right) \\oplus R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\right. \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\oplus R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}) \\oplus R _ {2} ^ {3} \\left(R _ {2} ^ {2} \\left(R _ {2} ^ {1} \\left(x _ {3} ^ {0}\\right) \\oplus x _ {4} ^ {0}\\right) \\oplus x _ {5} ^ {0}\\right) \\oplus R _ {3} ^ {1} \\left(x _ {5} ^ {0}\\right) \\oplus x _ {6} ^ {0} ].</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus  <span class="math">f_{6}(b,x) = f_{6}(b\\oplus 1,x\\oplus R_{1}^{1}(\\alpha_{0})\\oplus R_{1}^{1}(\\alpha_{1}))</span> . Therefore, function  <span class="math">f_{6}</span>  satisfies Simon's promise with  $s = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_1^1 (\\alpha_0)\\oplus R_1^1 (\\alpha_1)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, for the  <span class="math">2d</span> -branch version, we can get corresponding function  <span class="math">f_{2d}</span>  satisfies Simon's promise with  $s = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_1^1 (\\alpha_0)\\oplus R_1^1 (\\alpha_1)<span class="math">  at  </span>2d$ th round.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">DONG XY, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 9 7-round distinguisher on RC6/CLEFIA-like GFS with  <span class="math">2d = 6</span></p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 10 8-round quantum key-recovery attack on RC/CLEFIA-like GFS with  <span class="math">2d = 4</span></p>

    <p class="text-gray-300">Firstly, we study the quantum key-recovery attack on RC6/CLEFIA-like GFS with  <span class="math">2d = 4</span>  branches. Similarly, combining Simon's and Grover's algorithms shown in Section 3.3, three rounds are appended under the 5-round distinguisher to launch the attack. As shown in Figure 10, there are  <span class="math">4n</span> -bit key needed to be guessed by Grover's algorithm, which are highlighted in the red boxes of round functions. Thus, the 8-round quantum key-recovery attack needs about  <span class="math">2^{2n}</span>  queries and  <span class="math">\\mathcal{O}(n^2)</span>  qubits. If we attack  <span class="math">r &amp;gt; 8</span>  rounds, we need guess  <span class="math">4n + (r - 8) \\times 2n</span>  key bits by Grover's algorithm. Thus, the time complexity is  <span class="math">2^{2n + \\frac{(r - 8) \\times 2n}{2}} = 2^{(r - 6)n}</span> .</p>

    <p class="text-gray-300">Then, for the case of  <span class="math">2d = 6</span> , we append 5 rounds after the 7-round distinguisher to launch the 12-round quantum key-recovery attack as shown in Figure 11.  <span class="math">9n</span>  key bits highlighted in red need to be guessed by Grover's algorithm. Thus, the time complexity is  <span class="math">2^{\\frac{9n}{2}}</span>  and  <span class="math">\\mathcal{O}(n^2)</span>  qubits are needed. When we attack  <span class="math">r &amp;gt; 12</span>  rounds,  <span class="math">9n + (r - 12) \\times 3n</span>  key bits need to be guessed by Grover's algorithm. So the time complexity is  <span class="math">2^{\\frac{9n}{2} + \\frac{(r - 12) \\times 3n}{2}} = 2^{\\frac{(r - 9)3n}{2}}</span> .</p>

    <p class="text-gray-300">Generally, for  <span class="math">2d \\geqslant 4</span> , we could get  <span class="math">(2d + 1)</span> -round quantum distinguisher. We append  <span class="math">2d - 1</span>  rounds under the quantum distinguisher to attack  <span class="math">r_0 = 4d</span>  round RC/CLEFIA-like GFS. Similarly, we need to guess  <span class="math">d^2 n</span> -bit key by Grover's algorithm. Thus, for  <span class="math">r_0</span>  rounds, the time complexity is  <span class="math">\\frac{d^2n}{2}</span>  queries, and  <span class="math">\\mathcal{O}(n^2)</span>  qubits are needed. If we attack  <span class="math">r &amp;gt; r_0</span>  rounds, we need guess  <span class="math">d^2 n + (r - r_0)dn</span>  key bits by Grover's</p>

    <p class="text-gray-300">DONG X Y, et al. Sci China Inf Sci</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 11 12-round quantum key-recovery attack on RC/CLEFIA-like GFS with  <span class="math">2d = 6</span></p>

    <p class="text-gray-300">algorithm. Thus, the time complexity is  <span class="math">2^{\\frac{d^2 + (r - r_0)d}{2} n}</span> .</p>

    <p class="text-gray-300">If we use the quantum brute force search (Grover search) to recover the key, for  <span class="math">r</span> -round  <span class="math">2d</span> -branch cipher, totally,  <span class="math">rdn</span> -bit key need to be found, the complexity is  <span class="math">2^{rdn/2}</span> . Thus, our attack is better than the quantum brute force search (Grover search) by a factor  <span class="math">2^{rdn/2 - \\frac{d^2 + (r - r_0)d}{2} n} = 2^{\\frac{3d^2n}{2}}</span> .</p>

    <p class="text-gray-300">This paper studies quantum distinguishers and quantum key-recovery attacks on two generalized Feistel schemes (GFS): Type-1 (CAST256-like) and Type-2 (RC6/CLEFIA-like) GFS. For  <span class="math">d</span> -branch Type-1 GFS, we introduce  <span class="math">(2d - 1)</span> -round quantum distinguishers with polynomial time. For  <span class="math">2d</span> -branch Type-2 GFS, we give  <span class="math">(2d + 1)</span> -round quantum distinguishers with polynomial time. Classically, Moriai and Vaudenay [13] proved that a 7-round 4-branch Type-1 GFS and 5-round 4-branch Type-2 GFS are secure pseudo-random permutations. Obviously, they are no longer secure in quantum setting.</p>

    <p class="text-gray-300">Using the above quantum distinguishers, we introduce generic quantum key-recovery attacks by applying the combination of Simon's and Grover's algorithms recently proposed by Leander and May. We denote  <span class="math">n</span>  as the bit length of a branch. For  <span class="math">(d^2 - d + 2)</span> -round Type-1 GFS with  <span class="math">d</span>  branches, the time complexity is  <span class="math">2^{(\\frac{1}{2} d^2 - \\frac{3}{2} d + 2) \\cdot \\frac{n}{2}}</span> , which is better than the quantum brute force search (Grover search) by a factor  <span class="math">2^{(\\frac{1}{4} d^2 + \\frac{1}{4} d)n}</span> . For 4d-round Type-2 GFS with 2d branches, the time complexity is  <span class="math">2^{\\frac{d^2n}{2}}</span> , which is better than the quantum brute force search by a factor  <span class="math">2^{\\frac{3d^2n}{2}}</span> .</p>

    <p class="text-gray-300">Open discussion: The Chinese standard block cipher SMS4 is based on a different contracting Feistel scheme, we denote it as SMS4-like GFS. For the 4-branch case, we could find a 5-round quantum distinguisher that works with  <span class="math">\\mathcal{O}(n)</span> . However, Zhang and Wu [21] proved that 7-round 4-branch SMS4-like GFS is a pseudo-random permutation. So our quantum distinguisher does not violate Zhang and Wu's claim. It will be interesting to find quantum distinguisher with more rounds.</p>

    <p class="text-gray-300">This work is supported by the National Key Research and Development Program of China (No. 2017Y-FA0303903), Project funded by China Postdoctoral Science Foundation (No. 2017M620807), National Cryptography Development Fund (No. MMJJ20170121), Zhejiang Province Key R&amp;D Project (No. 2017C01062), the National Natural Science Foundation of China (No. 61672019), the Fundamental Research Funds of Shandong University (No. 2016JC029).</p>

    <p class="text-gray-300">Conflict of interest</p>

    <p class="text-gray-300">The authors declare that they have no conflict of interest.</p>

    <h2 id="sec-18" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Shor P W. Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer. SIAM Journal on Computing, 1997, 26(5):1484–1509.</li>

      <li>[2] Kuwakado H, Morii M. Security on the quantum-type even-mansour cipher. In: International symposium on information theory and its applications, ISITA 2012. IEEE, 2012. 312–316.</li>

      <li>[3] Kuwakado H, Morii M. Quantum distinguisher between the 3-round feistel cipher and the random permutation. In: International symposium on information theory, ISIT 2010. IEEE, 2010. 2682–2685.</li>

      <li>[4] Kaplan M, Leurent G, Leverrier A, et al. Breaking symmetric cryptosystems using quantum period finding. In: Robshaw M, Katz J, eds. Advances in Cryptology - CRYPTO 2016. Lecture Notes in Computer Science, Vol 9815. Berlin: Springer-Verlag, 2016. 207–237.</li>

      <li>[5] Leander G, May A. Grover meets simon - quantumly attacking the FX-construction. In: Takagi T, Peyrin T, eds. Advances in Cryptology - ASIACRYPT 2017, Part II. Lecture Notes in Computer Science, Vol 10625. Cham: Springer, 2017. 161–178.</li>

      <li>[6] Takagi T, Peyrin T. Advances in Cryptology - ASIACRYPT 2017, Part I. Lecture Notes in Computer Science, Vol 10624. Berlin: Springer-Verlag, 2017. 1-813.</li>

      <li>[7] Boneh D, Zhandry M. Secure signatures and chosen ciphertext security in a quantum computing world. In: Canetti R, Garay J A, eds. Advances in Cryptology - CRYPTO 2013. Lecture Notes in Computer Science, Vol 8043. Berlin: Springer-Verlag, 2013. 361–379.</li>

      <li>[8] Grover L K. A fast quantum mechanical algorithm for database search. In: Miller G L, eds. Proceedings of STOC 1996. ACM, 1996. 212–219.</li>

      <li>[9] Simon D R. On the power of quantum computation. SIAM Journal on Computing, 1997, 26(5):1474–1483.</li>

      <li>[10] Feistel H, Notz W A, Smith J L. Some cryptographic techniques for machine-to-machine data communications. In: Proceedings of the IEEE, 1975, 63(11): 1545–1554.</li>

      <li>[11] International Organization for Standardization(ISO). International Standard- ISO/IEC 18033-3, Information technology-Security techniques-Encryption algorithms -Part 3: Block ciphers. 2010.</li>

      <li>[12] Zheng Y L, Matsumoto T, Imai H. On the Construction of Block Ciphers Provably Secure and Not Relying on Any Unproved Hypotheses. In: Brassard G, eds. Advances in Cryptology - CRYPTO 1989. Lecture Notes in Computer Science, Vol 435. New York: Springer-Verlag, 1989. 461–480.</li>

      <li>[13] Moriai S, Vaudenay S. On the Pseudorandomness of Top-Level Schemes of Block Ciphers. In: Okamoto T,eds. Advances in Cryptology - ASIACRYPT 2000. Lecture Notes in Computer Science, Vol 1976. Berlin: Springer-Verlag, 2000. 289–302.</li>

      <li>[14] Luby M G, Rackoff C. How to construct pseudorandom permutations from pseudorandom functions. SIAM Journal on Computing, 1988, 17(2):373–386.</li>

      <li>[15] Brassard G, Hoyer P, Mosca M, et al. Quantum amplitude amplification and estimation. arXiv: Quantum Physics, 2000.</li>

      <li>[16] Julia Borghoff, Canteaut A, Güneysu T, Kavun E B, et al. PRINCE - A Low-Latency Block Cipher for Pervasive Computing Applications - Extended Abstract. In: Wang X Y, Sako K, eds. Advances in Cryptology - ASIACRYPT 2012. Lecture Notes in Computer Science, Vol 7658. Berlin: Springer-Verlag, 2009. 208–225.</li>

      <li>[17] Albrecht M R, Driessen B, Kavun E B, et al. Block ciphers - focus on the linear layer (feat. PRIDE). In: Garay J A, Gennaro R, eds. Advances in Cryptology - CRYPTO 2014. Lecture Notes in Computer Science, Vol 8616. Berlin: Springer-Verlag, 2014. 57–76.</li>

      <li>[18] Kilian J, Rogaway P. How to Protect DES Against Exhaustive Key Search. In: Koblitz N, eds. Advances in Cryptology - CRYPTO 1996. Lecture Notes in Computer Science, Vol 1109. Berlin: Springer-Verlag, 1996. 252–267.</li>

      <li>[19] Dong X Y, Wang X Y. Quantum key-recovery attack on Feistel structures. Cryptology ePrint Archive, Report 2017/1199, 2017. https://eprint.iacr.org/2017/1199.</li>

      <li>[20] Hosoyamada A, Sasaki Y. Quantum meet-in-the-middle attacks: Applications to generic feistel constructions. Cryptology ePrint Archive, Report 2017/1229, 2017. https://eprint.iacr.org/2017/1229.</li>

      <li>[21] Zhang L T, Wu W L. Pseudorandomness and super pseudorandomness on the unbalanced feistel networks with contracting functions. Chinese Journal of Computers, 2009, 32(07).</li>

    </ul>`;
---

<BaseLayout title="Quantum cryptanalysis on some Generalized Feistel Schemes (2017/1249)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1249
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
