---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/437';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-19';
const TITLE_HTML = 'A Note on the Unsoundness of vnTinyRAM&#x27;s SNARK';
const AUTHORS_HTML = 'Unknown authors';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold"><strong>Abstract</strong></h2>

    <p class="text-gray-300">Gennaro, Gentry, Parno, and Raykova (GGPR) introduced Quadratic Arithmetic Programs (QAPs) as a way of representing arithmetic circuits in a form amendable to highly efficient cryptographic protocols [11], particularly for verifiable computation and succinct non-interactive arguments [12]. Subsequently, Parno, Gentry, Howell, and Raykova introduced an improved cryptographic protocol (and implementation), which they dubbed Pinocchio [13].</p>

    <p class="text-gray-300">Ben-Sasson et al. [5] then introduced a lightly modified version of the Pinocchio protocol and implemented it as part of their libsnark distribution. Later work by the same authors employed this protocol [2–4, 10], as did a few works by others [1, 14]. Many of these works cite the version of the paper which was published at USENIX Security [6]. However, the protocol does not appear in that peer-reviewed paper; instead, it appears only in a technical report [5], where it is justified via a lemma that lacks a proof. Unfortunately, the lemma is incorrect, and the modified protocol is unsound. With probability one, an adversary can submit false statements and proofs that the verifier will accept. We demonstrate this theoretically, as well as with concrete examples in which the protocol's implementation in libsnark accepts invalid statements.</p>

    <p class="text-gray-300">Fixing this problem requires different performance tradeoffs, indicating that the performance results reported by papers building on this protocol [1–4, 6, 10, 14] are, to a greater or lesser extent, inaccurate.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Background: Quadratic Arithmetic Programs</h2>

    <p class="text-gray-300">Gennaro, Gentry, Parno, and Raykova (GGPR) introduced Quadratic Arithmetic Programs (QAPs) as a way of representing arithmetic circuits in a form amendable to highly efficient cryptographic protocols [11], particularly for verifiable computation and succinct non-interactive arguments [12] (and/or arguments of knowledge [7]).</p>

    <p class="text-gray-300">We recall their definition below, and then give a brief example of how to construct a QAP from an arithmetic circuit.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-0-0&quot;&gt;&lt;/span&gt;<strong>Definition 1 (Quadratic Arithmetic Program (QAP) [11])</strong> A QAP Q over field  <span class="math">\\mathbb{F}</span>  contains three sets of m+1 polynomials  <span class="math">\\mathcal{V} = \\{v_k(x)\\}, \\ \\mathcal{W} = \\{w_k(x)\\}, \\ \\mathcal{Y} = \\{y_k(x)\\}, \\ for \\ k \\in \\{0...m\\}, \\ and a target polynomial &lt;math&gt;t(x)</span> . Suppose F is a function that takes as input n elements of  <span class="math">\\mathbb{F}</span>  and outputs n' elements, for a total of N = n + n' I/O elements. Then we say that Q computes F if:  <span class="math">(c_1, \\ldots, c_N) \\in \\mathbb{F}^N</span>  is a valid assignment of</p>

    <p class="text-gray-300"><em>F's inputs and outputs,</em> if and only if there exist coefficients  <span class="math">(c_{N+1},...,c_m)</span>  such that t(x) divides p(x), where:</p>

    <p class="text-gray-300"><span class="math">$p(x) = \\left(v_0(x) + \\sum_{k=1}^m c_k \\cdot v_k(x)\\right) \\cdot \\left(w_0(x) + \\sum_{k=1}^m c_k \\cdot w_k(x)\\right)</span>$
<span class="math">$-\\left(y_0(x) + \\sum_{k=1}^m c_k \\cdot y_k(x)\\right).</span>$</p>

    <p class="text-gray-300">In other words, there must exist some polynomial h(x) such that  <span class="math">h(x) \\cdot t(x) = p(x)</span> . The size of Q is m, and the degree is the degree of t(x).</p>

    <p class="text-gray-300">We now walk through a brief example of how an arithmetic circuit can be converted into a QAP. Prior work provides more details of the general transformation [11, 13]. At a high-level, we choose a &quot;root&quot; value for each multiplication gate in the circuit. Thus, for the circuit in Figure 1, we choose three values  <span class="math">r_4, r_5, r_6 \\in \\mathbb{F}</span> . We then use the  <span class="math">\\mathcal{V}</span>  polynomials to represent &quot;left&quot; inputs into multiplications gates, the  <span class="math">\\mathcal{W}</span>  polynomials to represent &quot;right&quot; inputs, and the  <span class="math">\\mathcal{Y}</span>  polynomials to represent outputs. Thus, in our example, we say that  <span class="math">v_1(r_4) = v_1(r_5) = 1</span> , since wire  <span class="math">c_1</span>  is a left input to gates 4 and 5, while  <span class="math">v_1(r_6) = 0</span> , since  <span class="math">c_1</span>  is not a direct left input to gate 5. Similarly,  <span class="math">w_2(r_4) = w_3(r_5) = 1</span> , since wires  <span class="math">c_2</span>  and  <span class="math">c_3</span>  are right inputs to gates 4 and 5, respectively.</p>

    <p class="text-gray-300">To actually instantiate the various polynomials, let  <span class="math">\\mathcal{R}</span>  be the set of root values selected (e.g.,  <span class="math">\\mathcal{R} = \\{r_4, r_5, r_6\\}</span>  in our example). Let  <span class="math">L_i(x)</span>  be a Lagrange polynomial for  <span class="math">r_i</span>  over  <span class="math">\\mathcal{R}</span> , i.e.,  <span class="math">L_i(r_i) = 1</span>  and  <span class="math">\\forall j \\neq i : L_i(r_j) = 0</span> . We can now write each QAP polynomial as a simple summation of Lagrange polynomials. For example, in Figure 1,  <span class="math">v_1(x)</span>  is simply  <span class="math">L_4(x) + L_5(x)</span> .</p>

    <h2 id="sec-3" class="text-2xl font-bold"><strong>2</strong> Ensuring QAP Consistency</h2>

    <p class="text-gray-300">When using QAPs in cryptographic protocols, it is crucial to note that the standard QAP definition (Definition 1) only considers the case where the <em>same</em> set of coefficients, i.e., the  <span class="math">c_k</span> , are applied to all three sets of equations. The definition does not provide any guarantees if different coefficients are applied.</p>

    <p class="text-gray-300">In their work, GGPR ensure consistency by giving a generic procedure for &quot;strengthening&quot; a regular QAP into a strong QAP. Unfortunately, this procedure increases the QAP's degree to 3d+2N, more than tripling the original QAP. This significantly impacts the performance of cryptographic protocols employing the QAP. For example, in the verifiable computation setting, the cost of key generation and</p>

    <p class="text-gray-300">    <img src="_page_1_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;Figure 1: Arithmetic Circuit and Equivalent QAP. Each wire value comes from, and all operations are performed over, a field  <span class="math">\\mathbb{F}</span> . The polynomials in the QAP are defined in terms of their evaluations at the three roots,  <span class="math">r_4</span> ,  <span class="math">r_5</span> , and  <span class="math">r_6</span> . See text for details.</p>

    <p class="text-gray-300">the size of the evaluation key grow linearly in the degree, and the prover's effort grows as  <span class="math">O(d \\log d)</span> .</p>

    <p class="text-gray-300">In contrast, the Pinocchio verifiable computation protocol [13] solved the consistency problem at the cryptographic level, rather than changing the QAP itself. In other words, the protocol works for ordinary QAPs, and uses cryptographic techniques to check for consistency. We summarize the protocol in the left half of Figure 2. To simplify the presentation, we omit the extra terms and steps necessary to make the protocol zero knowledge. We also use a symmetric pairing group, although in practice [13], the protocol is typically implemented using an asymmetric group.</p>

    <p class="text-gray-300">The Pinocchio protocol is proven secure under the d-PKE, q-PDH and 2q-SDH assumptions [13].</p>

    <p class="text-gray-300">The Pinocchio protocol ensures the same coefficients are used for each set of coefficients in two ways. First, the protocol requires the prover to apply the &quot;internal&quot; variables (corresponding to the proof witness) to both the bare  <span class="math">g_v^{v_k(s)}, g_w^{w_k(s)},</span>  and  <span class="math">g_y^{v_k(s)}</span>  terms in the evaluation key, as well as the  <span class="math">\\beta</span>  terms, which combine each triplet of  <span class="math">v_k</span> ,  <span class="math">w_k</span> , and  <span class="math">y_k</span>  polynomials into a single term. If a malicious prover applies different coefficients to, say, the  <span class="math">w_k</span>  terms, this will be caught by the check in Equation 2. Second, to ensure the consistency of the terms corresponding to the IO (or equivalently to the proof statement), the verifier computes those terms herself. In other words, she takes the IO (or statement) from the prover and applies those terms to the corresponding  <span class="math">v_k</span> ,  <span class="math">w_k</span> , and  <span class="math">y_k</span>  terms herself before checking Equation 1.</p>

    <p class="text-gray-300">Ben-Sasson et al. [5] introduced a tweaked version of the Pinocchio protocol, as shown on the right-hand side of Figure 2. The primary change is that the <em>prover</em> calculates the IO terms for the  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{Y}</span>  polynomials, and the verifier only calculates the IO terms for the  <span class="math">\\mathcal{V}</span>  polynomials. In terms of memory, this shifts 2N terms from the verification key to the evaluation key. In terms of computation, this requires the prover to perform an additional 5N multi-exponentiations, but it saves the verifier 2N multi-exponentiations.</p>

    <p class="text-gray-300">To ensure consistency of the IO while checking only the  <span class="math">\\mathcal V</span>  polynomials, Ben-Sasson et al. [5, Lemma 2.4] claim that it suffices that the  <span class="math">\\mathcal V</span>  polynomials are non-zero and distinct. Note that this is not the case for the example in Figure 1.</p>

    <p class="text-gray-300">Therefore, Ben-Sasson et al. need a transformation to ensure this condition. Unfortunately, this transformation is not specified in their work. Looking at the code of their implementation, libsnark, the transformation appears to be as follows. They add one additional equation (or gate), which means increasing the QAP's degree by one, and they use this equation to ensure the  <span class="math">\\mathcal V</span>  polynomials are distinct. Concretely, the equation used is</p>

    <p class="text-gray-300"><span class="math">$\\left(1 + \\sum_{i=1}^{N} (i+1)c_i\\right) \\cdot (0) = 0.</span>$
(5)</p>

    <p class="text-gray-300">In our running example, this means adding an additional root value, say  <span class="math">r_7</span> , and setting</p>

    <p class="text-gray-300"><span class="math">$v_1(r_7) = 2</span>$
<span class="math">v_2(r_7) = 3</span>   <span class="math">v_3(r_7) = 4</span>   <span class="math">v_6(r_7) = 5</span>  (6)</p>

    <p class="text-gray-300">Unfortunately, the lemma justifying the security of Ben-Sasson et al.'s tweaked protocol is not accompanied by a proof, and it is, in fact, false; the conditions they give are insufficient to produce a secure SNARK, and indeed an adversary can succeed with probability one in producing a false statement with a proof that the verification algorithm will accept. Fundamentally, the protocol does not in fact ensure that the coefficients applied to the QAP polynomials are consistent across all three sets of polynomials.</p>

    <p class="text-gray-300">The key problem is that making the  <span class="math">\\mathcal V</span>  polynomials distinct is insufficient; they must instead be independent. As long as the polynomials are not independent, a malicious prover can take advantage of the dependencies to make false claims.</p>

    <p class="text-gray-300">Returning to our example, notice that even with Ben-Sasson et al.'s transformation, the polynomials  <span class="math">v_2(x)</span>  and  <span class="math">v_3(x)</span> , while distinct, are not independent. Concretely,  <span class="math">v_2(x) = 3L_7(x)</span>  and  <span class="math">v_3(x) = 4L_7(x)</span> , where  <span class="math">L_7(x)</span>  is the Lagrange polynomial corresponding to  <span class="math">r_7</span> .</p>

    <p class="text-gray-300">When calculating the term corresponding to the IO (or the proof statement), the verifier calculates  <span class="math">v_{io}(s) = \\sum_{i=1}^{N} c_k v_k(s)</span>  (in the exponent), using the  <span class="math">c_k</span>  values the prover supplies for the IO (or statement). If we focus on the portion of the sum that comes from inputs 2 and 3, we have  <span class="math">c_2v_2(s) + c_3v_3(s)</span> . In our example, this becomes  <span class="math">3c_2L_7(s) + 4c_3L_7(s) = (3c_2 + 4c_3)L_7(s)</span> . Thus, as long as  <span class="math">c_2</span>  and  <span class="math">c_3</span>  remain in the proper ratio,  <span class="math">v_{io}(s)</span>  will have the same value; hence any checks it participates in during verification will remain unchanged.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Protocol 1 (Pinocchio protocol from regular QAPs [13])</h4>

    <p class="text-gray-300">•  <span class="math">(EK_F, VK_F) \\leftarrow \\text{KeyGen}(F, 1^{\\lambda})</span> : Let F be a function with N input/output values from  <span class="math">\\mathbb{F}</span> . Convert F into an arithmetic circuit C; then build the corresponding QAP Q = <span class="math">(t(x), \\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span>  of size m and degree d. Let  <span class="math">I_{mid} = \\{N + 1\\}</span> 1, ..., m}, i.e., the non-IO-related indices.</p>

    <p class="text-gray-300">Let e be a non-trivial bilinear map [8]  <span class="math">e : \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , and let g be a generator of G.</p>

    <p class="text-gray-300">Choose  <span class="math">r_v, r_w, s, \\alpha_v, \\alpha_w, \\alpha_v, \\beta, \\gamma \\stackrel{R}{\\leftarrow} \\mathbb{F}</span>  and set  <span class="math">r_v = r_v \\cdot r_w</span> ,  <span class="math">g_{v} = g^{r_{v}}, g_{w} = g^{r_{w}} \\text{ and } g_{v} = g^{r_{y}}.</span></p>

    <p class="text-gray-300">Construct the public evaluation key  <span class="math">EK_F</span>  as:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} ( &amp; \\{g_{v}^{v_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{w}^{w_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{y}^{y_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ &amp; \\{g_{v}^{\\alpha_{v}v_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{w}^{\\alpha_{w}w_{k}(s)}\\}_{k \\in I_{mid}}, &amp; \\{g_{y}^{\\alpha_{v}y_{k}(s)}\\}_{k \\in I_{mid}}, \\\\ &amp; \\{g_{v}^{s^{i}}\\}_{i \\in [d]}, &amp; \\{g_{v}^{\\beta v_{k}(s)}g_{w}^{\\beta w_{k}(s)}g_{y}^{\\beta y_{k}(s)})\\}_{k \\in I_{mid}}, \\end{array}</span>$</p>

    <p class="text-gray-300">and the public verification key as:  <span class="math">VK_F = (g^1, g^{\\alpha_v}, g^{\\alpha_w})</span>  <span class="math">g^{\\alpha_{y}}, g^{\\gamma}, g^{\\beta\\gamma}, g^{t(s)}_{y}, \\{g^{\\nu_{k}(s)}_{y}, g^{w_{k}(s)}_{w}, g^{\\nu_{k}(s)}_{y}\\}_{k \\in \\{0\\} \\cup [N]} \\cdot</span></p>

    <p class="text-gray-300">•  <span class="math">(v, \\pi_v) \\leftarrow \\mathsf{Compute}(EK_F, u)</span> : On input u, the worker evaluates the circuit for F to obtain  <span class="math">y \\leftarrow F(u)</span> ; he also learns the values  <span class="math">\\{c_i\\}_{i\\in[m]}</span>  of the circuit's wires.</p>

    <p class="text-gray-300">He solves for h(x) (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> , and computes the proof  <span class="math">\\pi_y</span>  as:  <span class="math">\\begin{pmatrix} g_{v}^{v_{mid}(s)}, &amp; g_{w}^{w_{mid}(s)}, &amp; g_{y}^{v_{mid}(s)}, \\\\ g_{v}^{\\alpha_{w}v_{mid}(s)}, &amp; g_{w}^{\\alpha_{w}w_{mid}(s)}, &amp; g_{y}^{\\alpha_{y}v_{mid}(s)} \\\\ g_{v}^{\\beta_{v}v_{mid}(s)}g_{w}^{\\beta_{w}v_{mid}(s)}g_{y}^{\\beta_{y}v_{mid}(s)} \\end{pmatrix}</span></p>

    <p class="text-gray-300">where  <span class="math">v_{mid}(x) = \\sum_{k \\in I_{mid}} c_k \\cdot v_k(x)</span> , and similarly for  <span class="math">w_{mid}(s)</span>  and  <span class="math">y_{mid}(s)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\{0,1\\} \\leftarrow \\text{Verify}(VK_F, u, y, \\pi_v)</span> : The verification of an alleged proof with elements  <span class="math">g^{V_{mid}}</span> ,  <span class="math">g^{W_{mid}}</span> ,  <span class="math">g^{Y_{mid}}</span> ,  <span class="math">g^{H}</span> ,  <span class="math">g^{V&#x27;_{mid}}</span>  <span class="math">g^{W&#x27;_{mid}}</span> ,  <span class="math">g^{Y&#x27;_{mid}}</span> , and  <span class="math">g^Z</span>  uses the public verification key  <span class="math">VK_F</span> and the pairing function e for the following checks.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Divisibility check for the QAP: using elements from  <span class="math">VK_F</span>  compute  <span class="math">g_{\\nu}^{v_{io}(s)} = \\prod_{k \\in [N]} \\left(g_{\\nu}^{v_k(s)}\\right)^{c_k}</span>  (and similarly for  <span class="math">g_w^{w_{io}(s)}</span>  and  <span class="math">g_v^{y_{io}(s)}</span> ), and check:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$e(g_{v}^{v_{0}(s)}g_{v}^{v_{io}(s)}g_{v}^{V_{mid}},g_{w}^{w_{0}(s)}g_{w}^{w_{io}(s)}g_{w}^{W_{mid}}) = (1)</span>$</p>

    <p class="text-gray-300"><span class="math">$e(g_{y}^{t(s)},g_{v}^{H})e(g_{y}^{y_{0}(s)}g_{y}^{y_{io}(s)}g_{y}^{Y_{mid}},g).</span>$</p>

    <p class="text-gray-300">• Check that the linear combinations computed over V, W and Y are in their appropriate spans:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} e(g_v^{V&#x27;_{mid}},g) &amp;= e(g_v^{V_{mid}},g^{\\alpha_v}), \\quad e(g_w^{W&#x27;_{mid}},g) = e(g_w^{W_{mid}},g^{\\alpha_w}), \\\\ e(g_v^{Y&#x27;_{mid}},g) &amp;= e(g_v^{Y_{mid}},g^{\\alpha_y}). \\end{split}</span>$</p>

    <p class="text-gray-300">• Check that the same coefficients were used in each of the linear combinations over V, W and  <span class="math">\\gamma</span> :</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;
<span class="math">$e(g^{Z},g^{\\gamma}) = e(g_{v}^{V_{mid}}g_{w}^{W_{mid}}g_{y}^{Y_{mid}},g^{\\beta\\gamma}). \\tag{2}</span>$</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Protocol 2 (Optimization of Ben-Sasson et al. [5])</h4>

    <p class="text-gray-300">•  <span class="math">(EK_F, VK_F) \\leftarrow \\text{KeyGen}(F, 1^{\\lambda})</span> : Let F be a function with N input/output values from  <span class="math">\\mathbb{F}</span> . Convert F into an arithmetic circuit C; then build an augmented QAP Q' = <span class="math">(t(x), \\mathcal{V}, \\mathcal{W}, \\mathcal{Y})</span>  of size m and degree d. Let  <span class="math">I_{mid} = \\{N + 1\\}</span> 1,...,m, i.e., the non-IO-related indices.</p>

    <p class="text-gray-300">Let e be a non-trivial bilinear map [8]  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , and let g be a generator of G.</p>

    <p class="text-gray-300">Choose  <span class="math">r_v, r_w, s, \\alpha_v, \\alpha_w, \\alpha_v, \\beta, \\gamma \\stackrel{R}{\\leftarrow} \\mathbb{F}</span>  and set  <span class="math">r_v = r_v \\cdot r_w</span>  <span class="math">g_{v} = g^{r_{v}}, g_{w} = g^{r_{w}} \\text{ and } g_{v} = g^{r_{y}}.</span></p>

    <p class="text-gray-300">Construct the public evaluation key  <span class="math">EK_F</span>  as:</p>

    <p class="text-gray-300">Construct the public evaluation key
<span class="math">$EK_F</span>$
as:
<span class="math">$\\left( \\left\\{ g_{v}^{\\nu_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{w}^{w_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{v}^{y_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{w}^{\\alpha_{v}\\nu_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{w}^{\\alpha_{v}\\nu_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{v}^{\\alpha_{v}\\nu_{k}(s)} \\right\\}_{k \\in [m]}, \\left\\{ g_{v}^{\\beta_{v}(s)} g_{w}^{\\beta_{w}(s)} g_{y}^{\\beta_{v}(s)} \\right\\}_{k \\in [m]},</span>$</p>

    <p class="text-gray-300">and the public verification key as:  <span class="math">VK_F = (g^1, g^{\\alpha_v}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w}, g^{\\alpha_w</span>  <span class="math">g^{\\alpha_y}, g^{\\gamma}, g^{\\beta\\gamma}, g^{t(s)}_y, \\left\\{ g^{v_k(s)}_v \\right\\}_{k \\in \\{0\\} \\cup [N]}</span></p>

    <p class="text-gray-300">•  <span class="math">(y, \\pi_y) \\leftarrow \\mathsf{Compute}(EK_F, u)</span> : On input u, the worker evaluates the circuit for F to obtain  <span class="math">y \\leftarrow F(u)</span> ; he also learns the values  <span class="math">\\{c_i\\}_{i\\in[m]}</span>  of the circuit's wires.</p>

    <p class="text-gray-300">He solves for h(x) (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> , and computes the proof  <span class="math">\\pi_v</span>  as:</p>

    <p class="text-gray-300"><span class="math">$h(x) \\cdot t(x)</span>$
, and computes the proof  <span class="math">\\pi_y</span>
<span class="math">(g_v^{v_{mid}(s)}, g_w^{w(s)}, g_y^{y(s)}, g^{h(s)},</span>
<span class="math">g_v^{\\alpha_v v_{mid}(s)}, g_w^{w(s)}, g_y^{y(s)}</span>
<span class="math">g_v^{\\alpha_v v_{mid}(s)}, g_w^{w(s)}, g_y^{y(s)}</span>
<span class="math">g_v^{\\beta} v(s) \\beta w(s) \\beta y(s)</span>
<span class="math">g_v^{\\beta} g_w^{\\gamma} g_w^{\\gamma} g_y^{\\gamma}</span></p>

    <p class="text-gray-300">where  <span class="math">v_{mid}(x) = \\sum_{k \\in I_{mid}} c_k \\cdot v_k(x)</span> ,  <span class="math">w(s) = \\sum_{k \\in [m]} c_k \\cdot w_k(x)</span> and similarly for y(s).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\{0,1\\} \\leftarrow \\mathsf{Verify}(VK_F, u, y, \\pi_v)</span> : The verification of an alleged proof with elements  <span class="math">g^{V_{mid}}</span> ,  <span class="math">g^{W}</span> ,  <span class="math">g^{Y}</span> ,  <span class="math">g^{H}</span> ,  <span class="math">g^{V&#x27;_{mid}}</span> ,  <span class="math">g^{W&#x27;}</span> ,  <span class="math">g^{Y&#x27;}</span> , and  <span class="math">g^{Z}</span>  uses the public verification key  <span class="math">VK_F</span>  and the pairing function e for the following checks.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  Divisibility check for the QAP: using elements from  <span class="math">VK_F</span> compute only  <span class="math">g_v^{v_{io}(s)} = \\prod_{k \\in [N]} \\left(g_v^{v_k(s)}\\right)^{c_k}</span> , and then check that:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$e(g_{v}^{v_{0}(s)}g_{v}^{v_{io}(s)}g_{v}^{V_{mid}},g_{w}^{w_{0}(s)}g_{w}^{W}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$e(g_{y}^{t(s)},g^{H})e(g_{y}^{v_{0}(s)}g_{y}^{Y},g).</span>$
(3)</p>

    <p class="text-gray-300">• Check that the linear combinations computed over V, W and Y are in their appropriate spans:</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} e(g_{\\scriptscriptstyle V}^{V&#x27;_{mid}},g) &amp;= e(g_{\\scriptscriptstyle V}^{V_{mid}},g^{\\alpha_{\\scriptscriptstyle V}}), \\quad e(g_{\\scriptscriptstyle W}^{W&#x27;},g) = e(g_{\\scriptscriptstyle W}^{W},g^{\\alpha_{\\scriptscriptstyle W}}), \\ e(g_{\\scriptscriptstyle V}^{Y&#x27;},g) &amp;= e(g_{\\scriptscriptstyle V}^{Y},g^{\\alpha_{\\scriptscriptstyle Y}}). \\end{aligned}</span>$</p>

    <p class="text-gray-300">• Check that the same coefficients were used in each of the linear combinations over V, W and Y:</p>

    <p class="text-gray-300"><span class="math">$e(g^Z, g^{\\gamma}) = e(g_{\\nu}^{v_{io}(s)} g_{\\nu}^{V_{mid}} g_{\\nu}^W g_{\\nu}^Y, g^{\\beta \\gamma}). \\tag{4}</span>$</p>

    <p class="text-gray-300">Figure 2: The original Pinocchio protocol (left) and the modifications introduced by Ben-Sasson et al. (right), with changes highlighted.</p>

    <p class="text-gray-300">To exploit this, the malicious prover can first calculate a correct proof for a legitimate IO (or proof statement). In our example, he might choose inputs  <span class="math">c_1=1,\\,c_2=2,\\,</span>  and  <span class="math">c_3=10</span>  with a correct output of  <span class="math">c_6=20</span> . He then exploits the dependencies between  <span class="math">\\mathcal V</span>  polynomials to return a false statement with the proof he just calculated. For example, he might return  <span class="math">c_1=1,\\,c_2=10,\\,</span>  and  <span class="math">c_3=4</span>  with an <em>incorrect</em> output of  <span class="math">c_6=20</span>  (rather than a correct output of 40). In both cases  <span class="math">(3c_2+4c_3)=46</span> , so the value the verifier calculates for  <span class="math">g_{\\nu}^{\\nu_{io}(s)}</span>  remains unchanged, and hence the verification algorithm accepts, both with the correct IO and with the invalid IO.</p>

    <p class="text-gray-300">As further confirmation, we implemented the example in Figure 1, and confirmed that  <span class="math">\\mathtt{libsnark}^1</span>  accepts as valid the cheating IO  <span class="math">c_1=1</span> ,  <span class="math">c_2=10</span> ,  <span class="math">c_3=4</span> , and  <span class="math">c_6=20</span> . Note that as a performance optimization,  <span class="math">\\mathtt{libsnark}</span>  will dynamically decide to relabel the  <span class="math">\\mathcal V</span>  polynomials as  <span class="math">\\mathcal W</span>  polynomials, and vice versa, depending on the sparsity of the two sets of polynomials. In the example shown in Figure 1, it does make the swap. Hence, to see the unsoundness example above in action, we disabled the swap. Alternately, with the swap enabled, we can analyze the pre-swap  <span class="math">\\mathcal W</span>  polynomials and find that using invalid IO  <span class="math">c_1=6</span> ,  <span class="math">c_2=2</span> ,  <span class="math">c_3=10</span> , and  <span class="math">c_6=18</span>  also causes  <span class="math">\\mathtt{libsnark}</span>  to incorrectly accept.</p>

    <h2 id="sec-6" class="text-2xl font-bold">4 Remedies</h2>

    <p class="text-gray-300">One simple solution is to use the original Pinocchio protocol, which directly ensures consistency by having the verifier check the IO terms on all three sets of polynomials.</p>

    <p class="text-gray-300">Alternately, we can try to preserve the property that the verifier only checks the  <span class="math">\\mathcal{V}</span>  polynomials by adopting a strategy similar to GGPR's original strengthening step. Specifically, we can add one QAP equation per dependent IO term, and use that equation to ensure that  <span class="math">\\mathcal V</span>  constitutes a complete set of mutually independent polynomials. For example, if we add N additional roots  <span class="math">r_{d+1}, \\dots, r_{d+N}</span>  and set  <span class="math">v_i(r_{d+i}) = 1</span>  (and 0 for the rest of the new roots), this would ensure independence and remove the degree of freedom the adversary exploited above. The downside is that this technique potentially increases the QAP's degree and size by up to N. Hence, in the worst case, compared with the Pinocchio protocol, the cost of key generation increases by 8N exponentiations and the evaluation key grows by 8N. Similarly, the prover's work increases by 13N multi-exponentiations, and the field operations needed to solve for h(x), the only superlinear step, increase from  <span class="math">d \\log d</span> to  <span class="math">(d+N)\\log(d+N)</span> .</p>

    <p class="text-gray-300">Whether these costs are worth the 2N savings for the verifier is application dependent. Of course, in some applications, many of the  <span class="math">\\mathcal{V}</span>  polynomials will already be independent, and hence the costs described above will decrease accordingly.</p>

    <p class="text-gray-300">Adopting one of these remedies results in higher overhead for the verifier or for the key generator and prover, relative to using the unsound protocol. Hence, the absolute performance numbers reported in papers using Ben-Sasson et al.'s modified protocol [1–4, 6, 10, 14] underestimate the true costs.</p>

    <p class="text-gray-300">Relative performance measurements may still be valid.</p>

    <p class="text-gray-300">Based on this work, the libsnark authors are developing a patch that implements the new version of the protocol, as described above, with extra QAP equations added. Preliminary performance results suggest that for applications with small IO relative to the computation, the performance impact is quite small [9].</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>&lt;span id=&quot;page-3-7&quot;&gt;&lt;/span&gt;[1] M. Backes, D. Fiore, and R. M. Reischuk. Nearly practical and privacy-preserving proofs on authenticated data. In <em>Proc. of IEEE Symposium on Security and Privacy</em>, 2015.</li>
      <li>&lt;span id=&quot;page-3-4&quot;&gt;&lt;/span&gt;[2] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In <em>Proc. of the IEEE Symposium on Security and Privacy</em>, 2014.</li>
      <li>[3] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In <em>Proc. of the IEEE Symposium on Security and Privacy</em>, May 2015.</li>
      <li>&lt;span id=&quot;page-3-5&quot;&gt;&lt;/span&gt;[4] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In <em>Proc. of IACR CRYPTO</em>, 2014.</li>
      <li>&lt;span id=&quot;page-3-3&quot;&gt;&lt;/span&gt;[5] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. Cryptology ePrint Archive, Report 2013/879, Aug. 2014.</li>
      <li>&lt;span id=&quot;page-3-9&quot;&gt;&lt;/span&gt;[6] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In <em>Proc. of USENIX Security</em>, 2014.</li>
      <li>&lt;span id=&quot;page-3-10&quot;&gt;&lt;/span&gt;[7] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Innovations in Theoretical Computer Science (ITCS)</em>, 2012.</li>
      <li>&lt;span id=&quot;page-3-11&quot;&gt;&lt;/span&gt;[8] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. <em>Proceedings of IACR CRYPTO</em>, 2001.</li>
      <li>&lt;span id=&quot;page-3-13&quot;&gt;&lt;/span&gt;[9] A. Chiesa. Personal communication, May 2015.</li>
      <li>&lt;span id=&quot;page-3-6&quot;&gt;&lt;/span&gt;[10] A. Chiesa, E. Tromer, and M. Virza. Cluster computing in zero knowledge. In <em>Proceedings of IACR EuroCrypt</em>, Apr. 2015.</li>
      <li>&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;[11] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Proc. of IACR EUROCRYPT</em>, 2013.</li>
      <li>&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;[12] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>STOC</em>, 2011.</li>
      <li>&lt;span id=&quot;page-3-2&quot;&gt;&lt;/span&gt;[13] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In <em>Proc. of the IEEE Symposium on Security and Privacy</em>, May 2013.</li>
      <li>&lt;span id=&quot;page-3-8&quot;&gt;&lt;/span&gt;[14] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In <em>Proceedings of the ISOC Symposium on Network and Distributed Systems Security (NDSS)</em>, Feb. 2015.</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-3-12&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt; As of commit faf1ebbe961e51539122d471854b929fdca5864e.</p>

`;
---

<BaseLayout title="A Note on the Unsoundness of vnTinyRAM&#x27;s SNARK (2015/437)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/437
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-note-on-the-unsoundness-of-vntinyram-s-snark-2015" />
  </article>
</BaseLayout>
