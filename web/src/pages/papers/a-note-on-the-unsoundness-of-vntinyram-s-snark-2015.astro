---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/437';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Note on the Unsoundness of vnTinyRAM&#x27;s SNARK';
const AUTHORS_HTML = 'Bryan Parno';

const CONTENT = `    <p class="text-gray-300">Bryan Parno Microsoft Research</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Gennaro, Gentry, Parno, and Raykova (GGPR) introduced Quadratic Arithmetic Programs (QAPs) as a way of representing arithmetic circuits in a form amendable to highly efficient cryptographic protocols <em>[11]</em>, particularly for verifiable computation and succinct non-interactive arguments <em>[12]</em>. Subsequently, Parno, Gentry, Howell, and Raykova introduced an improved cryptographic protocol (and implementation), which they dubbed Pinocchio <em>[13]</em>.</p>

    <p class="text-gray-300">Ben-Sasson et al. <em>[5]</em> then introduced a lightly modified version of the Pinocchio protocol and implemented it as part of their libsnark distribution. Later work by the same authors employed this protocol <em>[2, 3, 4, 10]</em>, as did a few works by others <em>[1, 14]</em>. Many of these works cite the version of the paper which was published at USENIX Security <em>[6]</em>. However, the protocol does not appear in that peer-reviewed paper; instead, it appears only in a technical report <em>[5]</em>, where it is justified via a lemma that lacks a proof. Unfortunately, the lemma is incorrect, and the modified protocol is unsound. With probability one, an adversary can submit false statements and proofs that the verifier will accept. We demonstrate this theoretically, as well as with concrete examples in which the protocol’s implementation in libsnark accepts invalid statements.</p>

    <p class="text-gray-300">Fixing this problem requires different performance tradeoffs, indicating that the performance results reported by papers building on this protocol <em>[1, 2, 3, 4, 6, 10, 14]</em> are, to a greater or lesser extent, inaccurate.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Background: Quadratic Arithmetic Programs</h2>

    <p class="text-gray-300">Gennaro, Gentry, Parno, and Raykova (GGPR) introduced Quadratic Arithmetic Programs (QAPs) as a way of representing arithmetic circuits in a form amendable to highly efficient cryptographic protocols <em>[11]</em>, particularly for verifiable computation and succinct non-interactive arguments <em>[12]</em> (and/or arguments of knowledge <em>[7]</em>).</p>

    <p class="text-gray-300">We recall their definition below, and then give a brief example of how to construct a QAP from an arithmetic circuit.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1 (Quadratic Arithmetic Program (QAP) <em>[11]</em>)</h6>

    <p class="text-gray-300">A QAP <span class="math">Q</span> over field <span class="math">\\mathbb{F}</span> contains three sets of <span class="math">m+1</span> polynomials <span class="math">\\mathcal{V}=\\{v_{k}(x)\\}</span>, <span class="math">\\mathcal{W}=\\{w_{k}(x)\\}</span>,<span class="math">\\mathcal{Y}=\\{y_{k}(x)\\}</span>, for <span class="math">k\\in\\{0\\ldots m\\}</span>, and a target polynomial <span class="math">t(x)</span>. Suppose <span class="math">F</span> is a function that takes as input <span class="math">n</span> elements of <span class="math">\\mathbb{F}</span> and outputs <span class="math">n^{\\prime}</span> elements, for a total of <span class="math">N=n+n^{\\prime}</span> I/O elements. Then we say that <span class="math">Q</span> computes <span class="math">F</span> if: <span class="math">(c_{1},\\ldots,c_{N})\\in\\mathbb{F}^{N}</span> is a valid assignment of <span class="math">F</span>’s inputs and outputs, <em>if and only if</em> there exist coefficients <span class="math">(c_{N+1},\\ldots,c_{m})</span> such that <span class="math">t(x)</span> divides <span class="math">p(x)</span>, where:</p>

    <p class="text-gray-300"><span class="math">p(x)</span> <span class="math">=</span> <span class="math">\\left(v_{0}(x)+\\sum_{k=1}^{m}c_{k}\\cdot v_{k}(x)\\right)\\cdot\\left(w_{0}(x)+\\sum_{k=1}^{m}c_{k}\\cdot w_{k}(x)\\right)</span> <span class="math">-\\left(y_{0}(x)+\\sum_{k=1}^{m}c_{k}\\cdot y_{k}(x)\\right)\\ .</span></p>

    <p class="text-gray-300">In other words, there must exist some polynomial <span class="math">h(x)</span> such that <span class="math">h(x)\\cdot t(x)=p(x)</span>. The size of <span class="math">Q</span> is <span class="math">m</span>, and the degree is the degree of <span class="math">t(x)</span>.</p>

    <p class="text-gray-300">We now walk through a brief example of how an arithmetic circuit can be converted into a QAP. Prior work provides more details of the general transformation <em>[11, 13]</em>. At a high-level, we choose a “root” value for each multiplication gate in the circuit. Thus, for the circuit in Figure 1, we choose three values <span class="math">r_{4},r_{5},r_{6}\\in\\mathbb{F}</span>. We then use the <span class="math">\\mathcal{V}</span> polynomials to represent “left” inputs into multiplications gates, the <span class="math">\\mathcal{W}</span> polynomials to represent “right” inputs, and the <span class="math">\\mathcal{Y}</span> polynomials to represent outputs. Thus, in our example, we say that <span class="math">v_{1}(r_{4})=v_{1}(r_{5})=1</span>, since wire <span class="math">c_{1}</span> is a left input to gates 4 and 5, while <span class="math">v_{1}(r_{6})=0</span>, since <span class="math">c_{1}</span> is not a direct left input to gate 5. Similarly, <span class="math">w_{2}(r_{4})=w_{3}(r_{5})=1</span>, since wires <span class="math">c_{2}</span> and <span class="math">c_{3}</span> are right inputs to gates 4 and 5, respectively.</p>

    <p class="text-gray-300">To actually instantiate the various polynomials, let <span class="math">\\mathcal{R}</span> be the set of root values selected (e.g., <span class="math">\\mathcal{R}=\\{r_{4},r_{5},r_{6}\\}</span> in our example). Let <span class="math">L_{i}(x)</span> be a Lagrange polynomial for <span class="math">r_{i}</span> over <span class="math">\\mathcal{R}</span>, i.e., <span class="math">L_{i}(r_{i})=1</span> and <span class="math">\\forall j\\neq i:L_{i}(r_{j})=0</span>. We can now write each QAP polynomial as a simple summation of Lagrange polynomials. For example, in Figure 1, <span class="math">v_{1}(x)</span> is simply <span class="math">L_{4}(x)+L_{5}(x)</span>.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Ensuring QAP Consistency</h2>

    <p class="text-gray-300">When using QAPs in cryptographic protocols, it is crucial to note that the standard QAP definition (Definition 1) only considers the case where the <em>same</em> set of coefficients, i.e., the <span class="math">c_{k}</span>, are applied to all three sets of equations. The definition does not provide any guarantees if different coefficients are applied.</p>

    <p class="text-gray-300">In their work, GGPR ensure consistency by giving a generic procedure for “strengthening” a regular QAP into a strong QAP. Unfortunately, this procedure increases the QAP’s degree to <span class="math">3d+2N</span>, more than tripling the original QAP. This significantly impacts the performance of cryptographic protocols employing the QAP. For example, in the verifiable computation setting, the cost of key generation and</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Arithmetic Circuit and Equivalent QAP. Each wire value comes from, and all operations are performed over, a field  <span class="math">\\mathbb{F}</span> . The polynomials in the QAP are defined in terms of their evaluations at the three roots,  <span class="math">r_4</span> ,  <span class="math">r_5</span> , and  <span class="math">r_6</span> . See text for details.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">the size of the evaluation key grow linearly in the degree, and the prover's effort grows as  <span class="math">O(d \\log d)</span> .</p>

    <p class="text-gray-300">In contrast, the Pinocchio verifiable computation protocol [13] solved the consistency problem at the cryptographic level, rather than changing the QAP itself. In other words, the protocol works for ordinary QAPs, and uses cryptographic techniques to check for consistency. We summarize the protocol in the left half of Figure 2. To simplify the presentation, we omit the extra terms and steps necessary to make the protocol zero knowledge. We also use a symmetric pairing group, although in practice [13], the protocol is typically implemented using an asymmetric group.</p>

    <p class="text-gray-300">The Pinocchio protocol is proven secure under the  <span class="math">d</span> -PKE,  <span class="math">q</span> -PDH and  <span class="math">2q</span> -SDH assumptions [13].</p>

    <p class="text-gray-300">The Pinocchio protocol ensures the same coefficients are used for each set of coefficients in two ways. First, the protocol requires the prover to apply the "internal" variables (corresponding to the proof witness) to both the bare  <span class="math">g_{\\nu}^{y_k(s)}, g_w^{w_k(s)}</span> , and  <span class="math">g_y^{y_k(s)}</span>  terms in the evaluation key, as well as the  <span class="math">\\beta</span>  terms, which combine each triplet of  <span class="math">\\nu_k, w_k</span> , and  <span class="math">y_k</span>  polynomials into a single term. If a malicious prover applies different coefficients to, say, the  <span class="math">w_k</span>  terms, this will be caught by the check in Equation 2. Second, to ensure the consistency of the terms corresponding to the IO (or equivalently to the proof statement), the verifier computes those terms herself. In other words, she takes the IO (or statement) from the prover and applies those terms to the corresponding  <span class="math">\\nu_k, w_k</span> , and  <span class="math">y_k</span>  terms herself before checking Equation 1.</p>

    <p class="text-gray-300">Ben-Sasson et al. [5] introduced a tweaked version of the Pinocchio protocol, as shown on the right-hand side of Figure 2. The primary change is that the prover calculates the IO terms for the  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{V}</span>  polynomials, and the verifier only calculates the IO terms for the  <span class="math">\\mathcal{V}</span>  polynomials. In terms of memory, this shifts  <span class="math">2N</span>  terms from the verification key to the evaluation key. In terms of computation, this requires the prover to perform an additional  <span class="math">5N</span>  multi-exponentiations, but it saves the verifier  <span class="math">2N</span>  multi-exponentiations.</p>

    <p class="text-gray-300">To ensure consistency of the IO while checking only the  <span class="math">\\mathcal{V}</span>  polynomials, Ben-Sasson et al. [5, Lemma 2.4] claim that it suffices that the  <span class="math">\\mathcal{V}</span>  polynomials are non-zero and distinct. Note that this is not the case for the example in Figure 1.</p>

    <p class="text-gray-300">Therefore, Ben-Sasson et al. need a transformation to ensure this condition. Unfortunately, this transformation is not specified in their work. Looking at the code of their implementation, libsnark, the transformation appears to be as follows. They add one additional equation (or gate), which means increasing the QAP's degree by one, and they use this equation to ensure the  <span class="math">\\mathcal{V}</span>  polynomials are distinct. Concretely, the equation used is</p>

    <div class="my-4 text-center"><span class="math-block">\\left(1 + \\sum_ {i = 1} ^ {N} (i + 1) c _ {i}\\right) \\cdot (0) = 0. \\tag {5}</span></div>

    <p class="text-gray-300">In our running example, this means adding an additional root value, say  <span class="math">r_7</span> , and setting</p>

    <div class="my-4 text-center"><span class="math-block">v _ {1} \\left(r _ {7}\\right) = 2 \\quad v _ {2} \\left(r _ {7}\\right) = 3 \\quad v _ {3} \\left(r _ {7}\\right) = 4 \\quad v _ {6} \\left(r _ {7}\\right) = 5 \\tag {6}</span></div>

    <p class="text-gray-300">Unfortunately, the lemma justifying the security of Ben-Sasson et al.'s tweaked protocol is not accompanied by a proof, and it is, in fact, false; the conditions they give are insufficient to produce a secure SNARK, and indeed an adversary can succeed with probability one in producing a false statement with a proof that the verification algorithm will accept. Fundamentally, the protocol does not in fact ensure that the coefficients applied to the QAP polynomials are consistent across all three sets of polynomials.</p>

    <p class="text-gray-300">The key problem is that making the  <span class="math">\\mathcal{V}</span>  polynomials distinct is insufficient; they must instead be independent. As long as the polynomials are not independent, a malicious prover can take advantage of the dependencies to make false claims.</p>

    <p class="text-gray-300">Returning to our example, notice that even with Ben-Sasson et al.'s transformation, the polynomials  <span class="math">\\nu_{2}(x)</span>  and  <span class="math">\\nu_{3}(x)</span> , while distinct, are not independent. Concretely,  <span class="math">\\nu_{2}(x) = 3L_{7}(x)</span>  and  <span class="math">\\nu_{3}(x) = 4L_{7}(x)</span> , where  <span class="math">L_{7}(x)</span>  is the Lagrange polynomial corresponding to  <span class="math">r_7</span> .</p>

    <p class="text-gray-300">When calculating the term corresponding to the IO (or the proof statement), the verifier calculates  <span class="math">\\nu_{io}(s) = \\sum_{i=1}^{N} c_k \\nu_k(s)</span>  (in the exponent), using the  <span class="math">c_k</span>  values the prover supplies for the IO (or statement). If we focus on the portion of the sum that comes from inputs 2 and 3, we have  <span class="math">c_2 \\nu_2(s) + c_3 \\nu_3(s)</span> . In our example, this becomes  <span class="math">3c_2 L_7(s) + 4c_3 L_7(s) = (3c_2 + 4c_3)L_7(s)</span> . Thus, as long as  <span class="math">c_2</span>  and  <span class="math">c_3</span>  remain in the proper ratio,  <span class="math">\\nu_{io}(s)</span>  will have the same value; hence any checks it participates in during verification will remain unchanged.</p>

    <p class="text-gray-300">Protocol 1 (Pinocchio protocol from regular QAPs [13])</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(EK_{F},VK_{F})\\gets \\mathrm{KeyGen}(F,1^{\\lambda})</span>  : Let  <span class="math">F</span>  be a function with  <span class="math">N</span>  input/output values from  <span class="math">\\mathbb{F}</span> . Convert  <span class="math">F</span>  into an arithmetic circuit  <span class="math">C</span> ; then build the corresponding QAP  <span class="math">Q = (t(x),\\mathcal{V},\\mathcal{W},\\mathcal{Y})</span>  of size  <span class="math">m</span>  and degree  <span class="math">d</span> . Let  <span class="math">I_{mid} = \\{N + 1,\\dots,m\\}</span> , i.e., the non-IO-related indices.</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">e</span>  be a non-trivial bilinear map [8]  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , and let  <span class="math">g</span>  be a generator of  <span class="math">G</span> .</p>

    <p class="text-gray-300">Choose  <span class="math">r_v, r_w, s, \\alpha_v, \\alpha_w, \\alpha_y, \\beta, \\gamma \\stackrel{g}{\\leftarrow} \\mathbb{F}</span>  and set  <span class="math">r_y = r_v \\cdot r_w</span> ,  <span class="math">g_v = g^{r_v}</span> ,  <span class="math">g_w = g^{r_w}</span>  and  <span class="math">g_y = g^{r_y}</span> .</p>

    <p class="text-gray-300">Construct the public evaluation key  <span class="math">EK_{F}</span>  as:</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{rlr}{\\left\\{g_{v}^{\\gamma_{k}(s)}\\right\\}_{k\\in I_{mid}},}&amp;amp;{\\left\\{g_{w}^{w_{k}(s)}\\right\\}_{k\\in I_{mid}},}&amp;amp;{\\left\\{g_{y}^{\\gamma_{k}(s)}\\right\\}_{k\\in I_{mid}},\\\\ \\left\\{g_{v}^{\\alpha_{v}\\nu_{k}(s)}\\right\\}_{k\\in I_{mid}},}&amp;amp;{\\left\\{g_{w}^{\\alpha_{w}w_{k}(s)}\\right\\}_{k\\in I_{mid}},\\left\\{g_{y}^{\\alpha_{y}\\gamma_{k}(s)}\\right\\}_{k\\in I_{mid}},\\\\ \\left\\{g^{s^{\\prime}}\\right\\}_{i\\in [d]},}&amp;amp;{\\left\\{g_{v}^{\\beta \\nu_{k}(s)}\\right\\}_{w^{\\beta w_{k}(s)}}\\left\\{g_{y}^{\\beta \\gamma_{k}(s)}\\right\\}_{k\\in I_{mid}}\\end{array}</span>  ,</p>

    <p class="text-gray-300">and the public verification key as:  <span class="math">VK_{F} = (g^{1}, g^{\\alpha_{v}}, g^{\\alpha_{w}}, g^{\\alpha_{y}}, g^{\\gamma}, g^{\\beta \\gamma}, g_{y}^{r(s)}, \\{g_{v}^{\\nu_{k}(s)}, g_{w}^{w_{k}(s)}, g_{y}^{\\nu_{k}(s)}\\}_{k \\in \\{0\\} \\cup [N]}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(y, \\pi_y) \\gets \\text{Compute}(EK_F, u)</span> : On input  <span class="math">u</span> , the worker evaluates the circuit for  <span class="math">F</span>  to obtain  <span class="math">y \\gets F(u)</span> ; he also learns the values  <span class="math">\\{c_i\\}_{i \\in [m]}</span>  of the circuit's wires.</li>

    </ul>

    <p class="text-gray-300">He solves for  <span class="math">h(x)</span>  (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> ), and computes the proof  <span class="math">\\pi_y</span>  as:</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{rlr}{\\left(g_{v}^{v_{mid}(s)},g_{w}^{w_{mid}(s)},g_{y}^{v_{mid}(s)},g_{h(s)},g_{h(s)}\\right)}\\\\ {\\left(g_{v}^{v_{mid}(s)},g_{w}^{w_{mid}(s)},g_{y}^{v_{mid}(s)}\\right)}\\\\ {\\left(g_{v}^{v_{mid}(s)},g_{w}^{w_{mid}(s)},g_{y}^{v_{mid}(s)}\\right)} \\end{array}</span>  where  <span class="math">v_{mid}(x) = \\sum_{k\\in I_{mid}}c_k\\cdot v_k(x)</span>  , and similarly for  <span class="math">w_{mid}(s)</span>  and  <span class="math">y_{mid}(s)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{0,1\\} \\gets \\mathrm{Verify}(VK_F,u,y,\\pi_y)</span> : The verification of an alleged proof with elements  <span class="math">g^{V_{mid}}</span> ,  <span class="math">g^{W_{mid}}</span> ,  <span class="math">g^{Y_{mid}}</span> ,  <span class="math">g^H</span> ,  <span class="math">g^{V_{mid}&#x27;}</span> ,  <span class="math">g^{W_{mid}&#x27;}</span> ,  <span class="math">g^{Y_{mid}&#x27;}</span> , and  <span class="math">g^Z</span>  uses the public verification key  <span class="math">VK_F</span>  and the pairing function  <span class="math">e</span>  for the following checks.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Divisibility check for the QAP: using elements from  <span class="math">VK_{F}</span>  compute  <span class="math">g_{v}^{v_{iw}(s)} = \\prod_{k\\in [N]}\\left(g_{v}^{v_{k}(s)}\\right)^{c_{k}}</span>  (and similarly for  <span class="math">g_{w}^{w_{iw}(s)}</span>  and  <span class="math">g_{y}^{v_{iw}(s)}</span> ), and check:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(g _ {v} ^ {v _ {0} (s)} g _ {v} ^ {v _ {i n} (s)} g _ {v} ^ {Y _ {m i d}}, g _ {w} ^ {w _ {0} (s)} g _ {w} ^ {w _ {i n} (s)} g _ {w} ^ {W _ {m i d}}\\right) = \\tag {1} \\\\ e \\left(g _ {y} ^ {r (s)}, g ^ {H}\\right) e \\left(g _ {y} ^ {\\gamma_ {0} (s)} g _ {y} ^ {\\gamma_ {i n} (s)} g _ {y} ^ {Y _ {m i d}}, g\\right). \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the linear combinations computed over  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{Y}</span>  are in their appropriate spans:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(g _ {v} ^ {V _ {m i d} ^ {\\prime}}, g\\right) = e \\left(g _ {v} ^ {V _ {m i d}}, g ^ {\\alpha_ {v}}\\right), \\quad e \\left(g _ {w} ^ {W _ {m i d} ^ {\\prime}}, g\\right) = e \\left(g _ {w} ^ {W _ {m i d}}, g ^ {\\alpha_ {w}}\\right), \\\\ e \\left(g _ {y} ^ {V _ {m i d} ^ {\\prime}}, g\\right) = e \\left(g _ {y} ^ {Y _ {m i d}}, g ^ {\\alpha_ {y}}\\right). \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the same coefficients were used in each of the linear combinations over  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{Y}</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e \\left(g ^ {Z}, g ^ {\\gamma}\\right) = e \\left(g _ {v} ^ {V _ {m i d}} g _ {w} ^ {W _ {m i d}} g _ {y} ^ {Y _ {m i d}}, g ^ {\\beta \\gamma}\\right). \\tag {2}</span></div>

    <p class="text-gray-300">Protocol 2 (Optimization of Ben-Sasson et al. [5])</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(EK_{F},VK_{F})\\gets \\mathrm{KeyGen}(F,1^{\\lambda})</span>  : Let  <span class="math">F</span>  be a function with  <span class="math">N</span>  input/output values from  <span class="math">\\mathbb{F}</span> . Convert  <span class="math">F</span>  into an arithmetic circuit  <span class="math">C</span> ; then build an augmented QAP  <span class="math">Q^{\\prime} = (t(x),\\mathcal{V},\\mathcal{W},\\mathcal{Y})</span>  of size  <span class="math">m</span>  and degree  <span class="math">d</span> . Let  <span class="math">I_{mid} = \\{N + 1,\\dots,m\\}</span> , i.e., the non-IO-related indices.</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">e</span>  be a non-trivial bilinear map [8]  <span class="math">e: \\mathbb{G} \\times \\mathbb{G} \\to \\mathbb{G}_T</span> , and let  <span class="math">g</span>  be a generator of  <span class="math">G</span> .</p>

    <p class="text-gray-300">Choose  <span class="math">r_v, r_w, s, \\alpha_v, \\alpha_w, \\alpha_y, \\beta, \\gamma \\stackrel{g}{\\leftarrow} \\mathbb{F}</span>  and set  <span class="math">r_y = r_v \\cdot r_w</span> ,  <span class="math">g_v = g^{r_v}</span> ,  <span class="math">g_w = g^{r_w}</span>  and  <span class="math">g_y = g^{r_y}</span> .</p>

    <p class="text-gray-300">Construct the public evaluation key  <span class="math">EK_{F}</span>  as:</p>

    <p class="text-gray-300"><span class="math">\\left(\\left\\{g_{v}^{v_{k}(s)}\\right\\}_{k\\in [m]},\\left\\{g_{w}^{w_{k}(s)}\\right\\}_{k\\in [m]},\\left\\{g_{y}^{v_{k}(s)}\\right\\}_{k\\in [m]}\\right.</span> <span class="math">\\{g_v^{\\alpha_v\\nu_k(s)}\\}_{k\\in [m]},\\{g_w^{\\alpha_ww_k(s)}\\}_{k\\in [m]},\\{g_y^{\\alpha_y\\gamma_k(s)}\\}_{k\\in [m]},</span> <span class="math">\\{g^{s&#x27;}\\}_{i\\in [d]},\\qquad \\qquad \\{g_v^{\\beta v_k(s)}g_w^{\\beta w_k(s)}g_y^{\\beta y_k(s)}\\}_{k\\in [m]}</span></p>

    <p class="text-gray-300">and the public verification key as:  <span class="math">VK_{F} = (g^{1}, g^{\\alpha_{v}}, g^{\\alpha_{w}}, g^{\\alpha_{y}}, g^{\\gamma}, g^{\\beta \\gamma}, g_{y}^{t(s)}, \\{g_{v}^{\\nu_{k}(s)}\\}_{k \\in \\{0\\} \\cup [N]}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(y, \\pi_y) \\gets \\text{Compute}(EK_F, u)</span> : On input  <span class="math">u</span> , the worker evaluates the circuit for  <span class="math">F</span>  to obtain  <span class="math">y \\gets F(u)</span> ; he also learns the values  <span class="math">\\{c_i\\}_{i \\in [m]}</span>  of the circuit's wires.</li>

    </ul>

    <p class="text-gray-300">He solves for  <span class="math">h(x)</span>  (the polynomial such that  <span class="math">p(x) = h(x) \\cdot t(x)</span> ), and computes the proof  <span class="math">\\pi_y</span>  as:</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{rlr}{\\left(g_{v}^{v_{mid}(s)},g_{w}^{w(s)},g_{y}^{v_{mid}(s)},g_{y}^{w_{i}(s)}\\right),} &amp;amp; &amp;amp; {g^{h(s)},}\\\\ {\\left(g_{v}^{v_{mid}(s)},g_{w}^{w(s)},g_{y}^{v_{mid}(s)},g_{y}^{w_{i}(s)}\\right),} &amp;amp; &amp;amp; {g^{h(s)},}\\\\ {\\left(\\beta v(s),g_{v}^{v_{mid}(s)},g_{w}^{w(s)},g_{y}^{v_{mid}(s)},g_{y}^{w_{i}(s)}\\right),} &amp;amp; &amp;amp; {g^{h(s)},} \\end{array}</span></p>

    <p class="text-gray-300">where  <span class="math">v_{mid}(x) = \\sum_{k\\in I_{mid}}c_k\\cdot v_k(x),w(s) = \\sum_{k\\in [m]}c_k\\cdot w_k(x)</span>  and similarly for  <span class="math">y_{i}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{0,1\\} \\gets \\mathrm{Verify}(VK_F,u,y,\\pi_y)</span> : The verification of an alleged proof with elements  <span class="math">g^{V_{mid}}</span> ,  <span class="math">g^W</span> ,  <span class="math">g^Y</span> ,  <span class="math">g^H</span> ,  <span class="math">g^{V_{mid}&#x27;}</span> ,  <span class="math">g^{W&#x27;}</span> ,  <span class="math">g^{Y&#x27;}</span> , and  <span class="math">g^Z</span>  uses the public verification key  <span class="math">VK_F</span>  and the pairing function  <span class="math">e</span>  for the following checks.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Divisibility check for the QAP: using elements from  <span class="math">VK_{F}</span>  compute only  <span class="math">g_{v}^{v_{iw}(s)} = \\prod_{k\\in [N]}\\left(g_{v}^{r_{k}(s)}\\right)^{c_{k}}</span> , and then check that:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(g _ {v} ^ {v _ {0} (s)} g _ {v} ^ {v _ {i n} (s)} g _ {v} ^ {V _ {m i d}}, g _ {w} ^ {w _ {0} (s)} g _ {w} ^ {W}\\right) = \\tag {3} \\\\ e \\left(g _ {y} ^ {r (s)}, g ^ {H}\\right) e \\left(g _ {y} ^ {\\gamma_ {0} (s)} g _ {y} ^ {Y}, g\\right). \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the linear combinations computed over  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{Y}</span>  are in their appropriate spans:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e \\left(g _ {v} ^ {V _ {m i d} ^ {\\prime}}, g\\right) = e \\left(g _ {v} ^ {V _ {m i d}}, g ^ {\\alpha_ {v}}\\right), \\quad e \\left(g _ {w} ^ {W ^ {\\prime}}, g\\right) = e \\left(g _ {w} ^ {W}, g ^ {\\alpha_ {w}}\\right), \\\\ e \\left(g _ {y} ^ {Y ^ {\\prime}}, g\\right) = e \\left(g _ {y} ^ {Y}, g ^ {\\alpha_ {y}}\\right). \\\\ \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that the same coefficients were used in each of the linear combinations over  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{W}</span>  and  <span class="math">\\mathcal{Y}</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e \\left(g ^ {Z}, g ^ {\\gamma}\\right) = e \\left(g _ {v} ^ {v _ {i n} (s)} g _ {v} ^ {V _ {m i d}} g _ {w} ^ {W} g _ {y} ^ {Y}, g ^ {\\beta \\gamma}\\right). \\tag {4}</span></div>

    <p class="text-gray-300">Figure 2: The original Pinocchio protocol (left) and the modifications introduced by Ben-Sasson et al. (right), with changes highlighted.</p>

    <p class="text-gray-300">To exploit this, the malicious prover can first calculate a correct proof for a legitimate IO (or proof statement). In our example, he might choose inputs <span class="math">c_{1}=1</span>, <span class="math">c_{2}=2</span>, and <span class="math">c_{3}=10</span> with a correct output of <span class="math">c_{6}=20</span>. He then exploits the dependencies between <span class="math">\\mathcal{V}</span> polynomials to return a false statement with the proof he just calculated. For example, he might return <span class="math">c_{1}=1</span>, <span class="math">c_{2}=10</span>, and <span class="math">c_{3}=4</span> with an <em>incorrect</em> output of <span class="math">c_{6}=20</span> (rather than a correct output of <span class="math">40</span>). In both cases <span class="math">(3c_{2}+4c_{3})=46</span>, so the value the verifier calculates for <span class="math">g_{v}^{v_{in}(s)}</span> remains unchanged, and hence the verification algorithm accepts, both with the correct IO and with the invalid IO.</p>

    <p class="text-gray-300">As further confirmation, we implemented the example in Figure 1, and confirmed that libsnark accepts as valid the cheating IO <span class="math">c_{1}=1</span>, <span class="math">c_{2}=10</span>, <span class="math">c_{3}=4</span>, and <span class="math">c_{6}=20</span>. Note that as a performance optimization, libsnark will dynamically decide to relabel the <span class="math">\\mathcal{V}</span> polynomials as <span class="math">\\mathcal{W}</span> polynomials, and vice versa, depending on the sparsity of the two sets of polynomials. In the example shown in Figure 1, it does make the swap. Hence, to see the unsoundness example above in action, we disabled the swap. Alternately, with the swap enabled, we can analyze the pre-swap <span class="math">\\mathcal{W}</span> polynomials and find that using invalid IO <span class="math">c_{1}=6</span>, <span class="math">c_{2}=2</span>, <span class="math">c_{3}=10</span>, and <span class="math">c_{6}=18</span> also causes libsnark to incorrectly accept.</p>

    <h2 id="sec-7" class="text-2xl font-bold">4 Remedies</h2>

    <p class="text-gray-300">One simple solution is to use the original Pinocchio protocol, which directly ensures consistency by having the verifier check the IO terms on all three sets of polynomials.</p>

    <p class="text-gray-300">Alternately, we can try to preserve the property that the verifier only checks the <span class="math">\\mathcal{V}</span> polynomials by adopting a strategy similar to GGPR’s original strengthening step. Specifically, we can add one QAP equation per dependent IO term, and use that equation to ensure that <span class="math">\\mathcal{V}</span> constitutes a complete set of mutually independent polynomials. For example, if we add <span class="math">N</span> additional roots <span class="math">r_{d+1},\\ldots,r_{d+N}</span> and set <span class="math">v_{i}(r_{d+i})=1</span> (and <span class="math">0</span> for the rest of the new roots), this would ensure independence and remove the degree of freedom the adversary exploited above. The downside is that this technique potentially increases the QAP’s degree and size by up to <span class="math">N</span>. Hence, in the worst case, compared with the Pinocchio protocol, the cost of key generation increases by <span class="math">8N</span> exponentiations and the evaluation key grows by <span class="math">8N</span>. Similarly, the prover’s work increases by <span class="math">13N</span> multi-exponentiations, and the field operations needed to solve for <span class="math">h(x)</span>, the only superlinear step, increase from <span class="math">d\\log d</span> to <span class="math">(d+N)\\log(d+N)</span>.</p>

    <p class="text-gray-300">Whether these costs are worth the <span class="math">2N</span> savings for the verifier is application dependent. Of course, in some applications, many of the <span class="math">\\mathcal{V}</span> polynomials will already be independent, and hence the costs described above will decrease accordingly.</p>

    <p class="text-gray-300">Adopting one of these remedies results in higher overhead for the verifier or for the key generator and prover, relative to using the unsound protocol. Hence, the absolute performance numbers reported in papers using Ben-Sasson et al.’s modified protocol <em>[1, 2, 3, 4, 14, 6]</em> underestimate the true costs. Relative performance measurements may still be valid.</p>

    <p class="text-gray-300">Based on this work, the libsnark authors are developing a patch that implements the new version of the protocol, as described above, with extra QAP equations added. Preliminary performance results suggest that for applications with small IO relative to the computation, the performance impact is quite small <em>[9]</em>.</p>

    <h2 id="sec-8" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Backes, D. Fiore, and R. M. Reischuk. Nearly practical and privacy-preserving proofs on authenticated data. In Proc. of IEEE Symposium on Security and Privacy, 2015.</li>

      <li>[2] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from Bitcoin. In Proc. of the IEEE Symposium on Security and Privacy, 2014.</li>

      <li>[3] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza. Secure sampling of public parameters for succinct zero knowledge proofs. In Proc. of the IEEE Symposium on Security and Privacy, May 2015.</li>

      <li>[4] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Scalable zero knowledge via cycles of elliptic curves. In Proc. of IACR CRYPTO, 2014.</li>

      <li>[5] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. Cryptology ePrint Archive, Report 2013/879, Aug. 2014.</li>

      <li>[6] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Proc. of USENIX Security, 2014.</li>

      <li>[7] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Innovations in Theoretical Computer Science (ITCS), 2012.</li>

      <li>[8] D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. Proceedings of IACR CRYPTO, 2001.</li>

      <li>[9] A. Chiesa. Personal communication, May 2015.</li>

      <li>[10] A. Chiesa, E. Tromer, and M. Virza. Cluster computing in zero knowledge. In Proceedings of IACR EuroCrypt, Apr. 2015.</li>

      <li>[11] R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Proc. of IACR EUROCRYPT, 2013.</li>

      <li>[12] C. Gentry and D. Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In STOC, 2011.</li>

      <li>[13] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio: Nearly practical verifiable computation. In Proc. of the IEEE Symposium on Security and Privacy, May 2013.</li>

      <li>[14] R. S. Wahby, S. Setty, Z. Ren, A. J. Blumberg, and M. Walfish. Efficient RAM and control flow in verifiable outsourced computation. In Proceedings of the ISOC Symposium on Network and Distributed Systems Security (NDSS), Feb. 2015.</li>

    </ul>`;
---

<BaseLayout title="A Note on the Unsoundness of vnTinyRAM&#x27;s SNARK (2015/437)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/437
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
