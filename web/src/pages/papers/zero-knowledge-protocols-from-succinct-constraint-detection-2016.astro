---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/988';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zero Knowledge Protocols from Succinct Constraint Detection';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Michael A.  Forbes, Ariel Gabizon, Michael Riabzev, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Eli Ben-Sasson eli@cs.technion.ac.il Technion Ariesandro Chiesa alexch@berkeley.edu UC Berkeley Michael A. Forbes miforbes@illinois.edu UIUC* Ariel Gabizon ariel@z.cash ZcashCo† Michael Riabzev mriabzev@cs.technion.ac.il Technion Nicholas Spooner nick.spooner@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We study the problem of constructing proof systems that achieve both soundness and zero knowledge unconditionally (without relying on intractability assumptions). Known techniques for this goal are primarily <em>combinatorial</em>, despite the fact that constructions of interactive proofs (IPs) and probabilistically checkable proofs (PCPs) heavily rely on <em>algebraic</em> techniques to achieve their properties.</p>

    <p class="text-gray-300">We present simple and natural modifications of well-known ‘algebraic’ IP and PCP protocols that achieve unconditional (perfect) zero knowledge in recently introduced models, overcoming limitations of known techniques.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We modify the PCP of Ben-Sasson and Sudan [BS08] to obtain zero knowledge for <span class="math">\\mathbf{NEXP}</span> in the model of Interactive Oracle Proofs [BCS16, RRR16], where the verifier, in each round, receives a PCP from the prover.</li>

      <li>We modify the IP of Lund, Fortnow, Karloff, and Nisan [LFKN92] to obtain zero knowledge for <span class="math">\\#\\mathbf{P}</span> in the model of Interactive PCPs [KR08], where the verifier first receives a PCP from the prover and then interacts with him.</li>

    </ul>

    <p class="text-gray-300">The simulators in our zero knowledge protocols rely on solving a problem that lies at the intersection of coding theory, linear algebra, and computational complexity, which we call the <em>succinct constraint detection</em> problem, and consists of detecting dual constraints with polynomial support size for codes of exponential block length. Our two results rely on solutions to this problem for fundamental classes of linear codes:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An algorithm to detect constraints for Reed–Muller codes of exponential length. This algorithm exploits the Raz–Shpilka [RS05] deterministic polynomial identity testing algorithm, and shows, to our knowledge, a first connection of algebraic complexity theory with zero knowledge.</li>

      <li>An algorithm to detect constraints for PCPs of Proximity of Reed–Solomon codes [BS08] of exponential degree. This algorithm exploits the recursive structure of the PCPs of Proximity to show that small-support constraints are “locally” spanned by a small number of small-support constraints.</li>

    </ul>

    <p class="text-gray-300">Keywords: probabilistically checkable proofs, interactive proofs, sumcheck, zero knowledge, polynomial identity testing</p>

    <p class="text-gray-300">*Work conducted while at Stanford University.</p>

    <p class="text-gray-300">†Work conducted while at Technion.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Results  3</p>

    <p class="text-gray-300">2  Techniques  7 2.1  Detecting constraints for exponentially-large codes  7 2.2  From constraint detection to zero knowledge via masking  9 2.3  Achieving zero knowledge beyond NP  11 2.4  Roadmap  12</p>

    <p class="text-gray-300">3  Definitions  13 3.1  Basic notations  13 3.2  Single-prover proof systems  13 3.3  Zero knowledge  15 3.4  Codes  16</p>

    <p class="text-gray-300">4  Succinct constraint detection  18 4.1  Definition of succinct constraint detection  18 4.2  Partial sums of low-degree polynomials  20 4.3  Univariate polynomials with BS proximity proofs  22</p>

    <p class="text-gray-300">5  Sumcheck with perfect zero knowledge  28 5.1  Step 1  29 5.2  Step 2  32</p>

    <p class="text-gray-300">6  Perfect zero knowledge for counting problems  34</p>

    <p class="text-gray-300">7  Perfect zero knowledge from succinct constraint detection  35 7.1  A general transformation  35 7.2  Perfect zero knowledge IOPs of proximity for Reed–Solomon codes  38</p>

    <p class="text-gray-300">8  Perfect zero knowledge for nondeterministic time  40 8.1  Perfect zero knowledge IOPs of proximity for LACSPs  41 8.2  Perfect zero knowledge IOPs for RLACSPs  42 8.3  Putting things together  44</p>

    <p class="text-gray-300">A  Prior work on single-prover unconditional zero knowledge  45 B  Proof of Lemma 4.3  46 C  Proof of Lemma 4.6  47 D  Proof of Lemma 4.11  48 E  Proof of Claim 4.23  49 F  Definition of the linear code family BS-RS  50 G  Proof of Lemma 4.27  52 G.1  The recursive cover and its combinatorial properties  52 G.2  Computing spanning sets of dual codes in the recursive cover  54 G.3  Putting things together  55</p>

    <p class="text-gray-300">H  Folklore claim on interpolating sets  56</p>

    <p class="text-gray-300">Acknowledgements  57</p>

    <p class="text-gray-300">References  57</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The study of interactive proofs (IPs) <em>[x1, x10]</em> that unconditionally achieve zero knowledge <em>[x10]</em> has led to a rich theory, with connections well beyond zero knowledge. For example, the class of languages with statistical zero knowledge IPs, which we denote by <span class="math">\\mathbf{SZK\\text{-}IP}</span>, has complete problems that make no reference to either zero knowledge or interaction <em>[x31, x11]</em> and is closed under complement <em>[x23, x30]</em>. Despite the fact that all <span class="math">\\mathbf{PSPACE}</span> languages have IPs <em>[x28]</em>, <span class="math">\\mathbf{SZK\\text{-}IP}</span> is contained in <span class="math">\\mathbf{AM\\cap coAM}</span>, and thus <span class="math">\\mathbf{NP}</span> is not in <span class="math">\\mathbf{SZK\\text{-}IP}</span> unless the polynomial hierarchy collapses <em>[x5]</em>; one consequence is that Graph Non-Isomorphism is unlikely to be NP-complete. Moreover, constructing <span class="math">\\mathbf{SZK\\text{-}IP}</span> for a language is equivalent to constructing instance-dependent commitments for the language <em>[x16, x22]</em>, and has connections to other fundamental information-theoretic notions like randomized encodings <em>[x1, x33]</em> and secret-sharing schemes <em>[x34]</em>.</p>

    <p class="text-gray-300">Unconditional zero knowledge in other models behaves very differently. Ben-Or, Goldwasser, Kilian, and Wigderson <em>[x6]</em> introduced the model of multi-prover interactive proofs (MIPs) and showed that <em>all</em> such proofs can be made zero knowledge unconditionally. The analogous statement for IPs is equivalent to the existence of one-way functions, as shown by <em>[x10, x17, BGG^{+}88]</em> in one direction and by <em>[x24, x25]</em> in the other (unless <span class="math">\\mathbf{BPP}=\\mathbf{PSPACE}</span>, in which case the statement is trivial). Subsequent works not only established that all <span class="math">\\mathbf{NEXP}</span> languages have MIPs <em>[x3]</em>, but also led to formulating probabilistically checkable proofs (PCPs) and proving the celebrated PCP Theorem <em>[x15, x4, FGL^{+}96, x2, ALM^{+}98]</em>, as well as constructing statistical zero knowledge PCPs <em>[x29]</em> and applying them to black-box cryptography <em>[x18, x16]</em>.</p>

    <p class="text-gray-300">The theory of zero knowledge for these types of proofs, however, is not as rich as in the case of IPs. Most notably, known techniques to achieve zero knowledge MIPs or PCPs are limited, and come with caveats. Zero knowledge MIPs are obtained via complex generic transformations <em>[x6]</em>, assume the full power of the PCP Theorem <em>[DFK^{+}92]</em>, or support only languages in <span class="math">\\mathbf{NP}</span> <em>[x23]</em>. Zero knowledge PCPs are obtained via a construction that incurs polynomial blowups in proof length and requires the honest verifier to adaptively query the PCP <em>[x29]</em>. Alternative approaches are not known, despite attempts to find them. For example, <em>[x20]</em> apply PCPs to leakage-resilient circuits, obtaining PCPs for <span class="math">\\mathbf{NP}</span> that do have a non-adaptive honest verifier but are only witness indistinguishable.</p>

    <p class="text-gray-300">Even basic questions such as “are there zero-knowledge PCPs of quasilinear-size?” or “are there zero-knowledge PCPs with non-adaptive honest verifiers?” have remained frustratingly hard to answer, despite the fact the answers to these questions are well understood when removing the requirement of zero knowledge. This state of affairs begs the question of whether a richer theory about zero knowledge MIPs and PCPs could be established.</p>

    <p class="text-gray-300">The current situation is that known techniques to achieve zero knowledge MIPs and PCPs are combinatorial, namely they make black-box use of an underlying MIP or PCP, despite the fact that most MIP and PCP constructions have a rich algebraic structure arising from the use of error correcting codes based on evaluations of low-degree polynomials. This separation is certainly an attractive feature, and perhaps even unsurprising: while error-correcting codes are designed to help recover information, zero knowledge proofs are designed to hide it.</p>

    <p class="text-gray-300">Yet, a recent work by Ben-Sasson, Chiesa, Gabizon, and Virza <em>[x7]</em> brings together linear error correcting codes and zero knowledge using an algebraic technique that we refer to as ‘masking’. The paper introduces a “2-round PCP” for <span class="math">\\mathbf{NP}</span> that unconditionally achieves zero knowledge and, nevertheless, has both quasilinear size and a non-adaptive honest verifier. Their work can be viewed not only as partial progress towards some of the open questions above, but also as studying the power of zero knowledge for a natural extension of PCPs (“multi-round PCPs” as discussed below) with its own motivations and applications <em>[x2, x28, BCG^{+}17]</em>.</p>

    <p class="text-gray-300">The motivation of this work is to understand the power of algebraic tools, such as linear error correcting codes, for achieving zero knowledge unconditionally (without relying on intractability assumptions).</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Results</h3>

    <p class="text-gray-300">We present new protocols that unconditionally achieve soundness and zero knowledge in recently suggested models that combine features of PCPs and IPs <em>[x22, x3, x23]</em>. Our protocols consist of simple and natural modifications to well-known constructions: the PCP of Ben-Sasson and Sudan <em>[x11]</em> and the IP for polynomial summation of Lund, Fortnow, Karloff, and Nisan <em>[x14]</em>. By leveraging the linear codes used in these constructions, we reduce the problem of achieving zero knowledge to solving exponentially-large instances of a new linear-algebraic problem that we call <em>constraint detection</em>, which we believe to be of independent interest. We design efficient algorithms for solving</p>

    <p class="text-gray-300">this problem for notable linear code families, along the way exploiting connections to algebraic complexity theory and local views of linear codes. We now elaborate on the above by discussing each of our results.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.1.1 Zero knowledge for non-deterministic exponential time</h4>

    <p class="text-gray-300">Two recent works <em>[x1, x21]</em> independently introduce and study the notion of an <em>interactive oracle proof</em> (IOP), which can be viewed as a “multi-round PCP”. Informally, an IOP is an IP modified so that, whenever the prover sends to the verifier a message, the verifier does not have to read the message in full but may probabilistically query it. Namely, in every round, the verifier sends the prover a message, and the prover replies with a PCP. IOPs enjoy better efficiency compared to PCPs <em>[BCG^{+}17]</em>, and have applications to constructing argument systems <em>[x1]</em> and IPs <em>[x21]</em>.</p>

    <p class="text-gray-300">The aforementioned work of <em>[x1]</em> makes a simple modification to the PCP of Ben-Sasson and Sudan <em>[x5]</em> and obtains a <span class="math">2</span>-round IOP for <span class="math">\\mathbf{NP}</span> that is perfect zero knowledge, and yet has quasilinear size and a non-adaptive honest verifier. Our first result consists of extending this prior work to all languages in <span class="math">\\mathbf{NEXP}</span>, positively answering an open question raised there. We do so by constructing, for each time <span class="math">T</span> and query bound <span class="math">\\mathsf{b}</span>, a suitable IOP for <span class="math">\\mathbf{NTIME}(T)</span> that is zero knowledge against query bound <span class="math">\\mathsf{b}</span>; the result for <span class="math">\\mathbf{NEXP}</span> follows by setting <span class="math">\\mathsf{b}</span> to be super-polynomial.</p>

    <p class="text-gray-300">The foregoing notion of zero knowledge for IOPs directly extends that for PCPs, and requires showing the existence of an algorithm that simulates the view of any (malicious and adaptive) verifier interacting with the honest prover and making at most <span class="math">\\mathsf{b}</span> queries across all oracles; here, ‘view’ consists of the answers to queries across all oracles.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1.1 (informal statement of Thm. 8.1).</h6>

    <p class="text-gray-300">For every time bound <span class="math">T</span> and query bound <span class="math">\\mathsf{b}</span>, the complexity class <span class="math">\\mathbf{NTIME}(T)</span> has <span class="math">2</span>-round Interactive Oracle Proofs that are perfect zero knowledge against <span class="math">\\mathsf{b}</span> queries, and where the proof length is <span class="math">\\tilde{O}(T+\\mathsf{b})</span> and the (honest verifier’s) query complexity is <span class="math">\\mathrm{polylog}(T+\\mathsf{b})</span>.</p>

    <p class="text-gray-300">The prior work of <em>[x1]</em> was “stuck” at <span class="math">\\mathbf{NP}</span> because their simulator runs in <span class="math">\\mathrm{poly}(T+\\mathsf{b})</span> time so that <span class="math">T,\\mathsf{b}</span> must be polynomially-bounded. In contrast, we achieve all of <span class="math">\\mathbf{NEXP}</span> by constructing, for essentially the same simple 2-round IOP, a simulator that runs in time <span class="math">\\mathrm{poly}(\\tilde{q}+\\log T+\\log\\mathsf{b})</span>, where <span class="math">\\tilde{q}</span> is the <em>actual</em> number of queries made by the malicious verifier. This is an <em>exponential</em> improvement in simulation efficiency, and we obtain it by conceptualizing and solving a linear-algebraic problem about Reed–Solomon codes, and their proximity proofs, as discussed in Section 1.1.3.</p>

    <p class="text-gray-300">In sum, our theorem gives new tradeoffs compared to <em>[x17]</em>’s result, which gives statistical zero knowledge PCPs for <span class="math">\\mathbf{NTIME}(T)</span> with proof length <span class="math">\\mathrm{poly}(T,\\mathsf{b})</span> and an adaptive honest verifier. We obtain perfect zero knowledge for <span class="math">\\mathbf{NTIME}(T)</span>, with quasilinear proof length and a non-adaptive honest verifier, at the price of “<span class="math">2</span> rounds of PCPs”.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.1.2 Zero knowledge for counting problems</h4>

    <p class="text-gray-300">Kalai and Raz <em>[x16]</em> introduce and study the notion of <em>interactive PCPs</em> (IPCPs), which “sits in between” IPs and IOPs: the prover first sends the verifier a PCP, and then the prover and verifier engage in a standard IP. IPCPs also enjoy better efficiency compared to PCPs or IPs alone <em>[x16]</em>.</p>

    <p class="text-gray-300">We show how a natural and simple modification of the sumcheck protocol of Lund, Fortnow, Karloff, and Nisan <em>[x12]</em> achieves perfect zero knowledge in the IPCP model, even with a non-adaptive honest verifier. By running this protocol on the usual arithmetization of the counting problem associated to <span class="math">3\\mathrm{SAT}</span>, we obtain our second result, which is IPCPs for <span class="math">\\#\\mathbf{P}</span> that are <em>perfect zero knowledge against unbounded queries</em>. This means that there exists a polynomial-time algorithm that simulates the view of any (malicious and adaptive) verifier making any polynomial number of queries to the PCP oracle. Here, ‘view’ consists of answers to oracle queries and the transcript of interaction with the prover. (In particular, this notion of zero knowledge is a ‘hybrid’ of corresponding notions for PCPs and IPs.)</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 1.2 (informal statement of Thm. 6.2).</h6>

    <p class="text-gray-300">The complexity class <span class="math">\\#\\mathbf{P}</span> has Interactive PCPs that are perfect zero knowledge against unbounded queries. The PCP proof length is exponential, and the communication complexity of the interaction and the (honest verifier’s) query complexity are polynomial.</p>

    <p class="text-gray-300">Our construction relies on a random self-reducibility property of the sumcheck protocol (see Section 2.2.2 for a summary) and its completeness and soundness properties are straightforward to establish. As in our previous result, the</p>

    <p class="text-gray-300">“magic” lies in the construction of the simulator, which must solve the same type of exponentially-large linear-algebraic problem, except that this time it is about Reed–Muller codes rather than Reed–Solomon codes. The algorithm that we give to solve this task relies on connections to the problem of polynomial identity testing in the area of algebraic complexity theory, as we discuss further below.</p>

    <p class="text-gray-300">Goyal, Ishai, Mahmoody, and Sahai <em>[x10]</em> also study zero knowledge for IPCPs, and show how to obtain IPCPs for <span class="math">\\mathbf{NP}</span> that (i) are statistical zero knowledge against unbounded queries, and yet (ii) each location of the (necessarily) super-polynomial size PCP is polynomial-time computable given the NP witness. They further prove that these two properties are not attainable by zero knowledge PCPs. Their construction consists of replacing the commitment scheme in the zero knowledge IP for 3-colorability of <em>[x11]</em> with an information-theoretic analogue in the IPCP model. Our Theorem 1.2 also achieves zero knowledge against unbounded queries, but targets the complexity class <span class="math">\\#\\mathbf{P}</span> (rather than <span class="math">\\mathbf{NP}</span>), for which there is no clear analogue of property (ii) above.</p>

    <p class="text-gray-300">Information-theoretic commitments also underlie the construction of zero knowledge PCPs <em>[x22]</em>. One could apply the <em>[x22]</em> result for <span class="math">\\mathbf{NEXP}</span> to obtain zero knowledge PCPs (thus also IPCPs) for <span class="math">\\#\\mathbf{P}</span>, but this is an indirect and complex route (in particular, it relies on the PCP Theorem) that, moreover, yields an adaptive honest verifier. Our direct construction is simple and natural, and also yields a non-adaptive honest verifier.</p>

    <p class="text-gray-300">We now discuss the common algebraic structure that allowed us to obtain both of the above results. We believe that further progress in understanding these types of algebraic techniques will lead to further progress in understanding the power of unconditional zero knowledge for IOPs and IPCPs, and perhaps also for MIPs and PCPs.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.1.3 Succinct constraint detection for Reed–Muller and Reed–Solomon codes</h4>

    <p class="text-gray-300">The constructions underlying both of our theorems achieve zero knowledge by applying a simple modification to well-known protocols: the PCP of Ben-Sasson and Sudan <em>[x5]</em> underlies our result for <span class="math">\\mathbf{NEXP}</span> and the sumcheck protocol of Lund, Fortnow, Karloff, and Nisan <em>[x16]</em> underlies our result for <span class="math">\\#\\mathbf{P}</span>.</p>

    <p class="text-gray-300">In both of these protocols the verifier has access (either via a polynomial-size representation or via a PCP oracle) to an exponentially-large word that allegedly belongs to a certain linear code, and the prover ‘leaks’ hard-to-compute information in the process of convincing the verifier that this word belongs to the linear code. We achieve zero knowledge via a modification that we call <em>masking</em>: the prover sends to the verifier a PCP containing a random codeword in this code, and then convinces the verifier that the <em>sum</em> of these two (the original codeword and this random codeword) is close to the linear code. Intuitively, zero knowledge comes from the fact that the prover now argues about a random shift of the original word.</p>

    <p class="text-gray-300">However, this idea raises a problem: how does the simulator ‘sample’ an exponentially-large random codeword in order to answer the verifier’s queries to the PCP? Solving this problem crucially relies on solving a problem that lies at the intersection of coding theory, linear algebra, and computational complexity, which we call the <em>constraint detection problem</em>. We informally introduce it and state our results about it, and defer to Section 2.2 a more detailed discussion of its connection to zero knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Detecting constraints in codes. Constraint detection is the problem of determining which linear relations hold across all codewords of a linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span>, when considering only a given subdomain <span class="math">I\\subseteq D</span> of the code rather than all of the domain <span class="math">D</span>. This problem can always be solved in time that is polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (via Gaussian elimination); however, if there is an algorithm that solves this problem in time that is *polynomial in the subdomain’s size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">*, rather than the domain’s size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, then we say that the code has <em>succinct</em> constraint detection; in particular, the domain could have <em>exponential</em> size and the algorithm would still run in polynomial time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1.3 (informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> has <em>succinct constraint detection</em> if there exists an algorithm that, given a subset <span class="math">I\\subseteq D</span>, runs in time $\\operatorname{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and outputs </span>z\\in\\mathbb{F}^{I}<span class="math"> such that </span>\\sum_{i\\in I}z(i)w(i)=0<span class="math"> for all </span>w\\in C<span class="math">, or “no” if no such </span>z<span class="math"> exists. (In particular, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ may be exponential.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We further discuss the problem of constraint detection in Section 2.1, and provide a formal treatment of it in Section 4.1. Beyond this introduction, we shall use (and achieve) a stronger definition of constraint detection: the algorithm is required to output a basis for the space of dual codewords in <span class="math">C^{\\perp}</span> whose support lies in the subdomain <span class="math">I</span>, i.e., a basis for</p>

    <p class="text-gray-300">the space <span class="math">\\{z\\in D^{I}:\\ \\forall\\,w\\in C\\,,\\,\\sum_{i\\in I}z(i)w(i)=0\\}</span>. Note that in our discussion of succinct constraint detection we do not leverage the distance property of the code <span class="math">C</span>, but we do leverage it in our eventual applications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our zero knowledge simulators’ strategy includes sampling a “random PCP”: a random codeword <span class="math">w</span> in a linear code <span class="math">C</span> with exponentially large domain size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (see Section 2.2 for more on this). Explicitly sampling </span>w<span class="math"> requires time </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and so is inefficient. But a verifier makes only polynomially-many queries to </span>w<span class="math">, so the simulator has to only simulate </span>w<span class="math"> when restricted to polynomial-size sets </span>I\\subseteq D<span class="math">, leaving open the possibility of doing so in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Achieving such a simulation time is an instance of (efficiently and perfectly) “implementing a huge random object” <em>[x10]</em> via a <em>stateful</em> algorithm <em>[x11]</em>. We observe that if </span>C<span class="math"> has succinct constraint detection then this sampling problem for </span>C<span class="math"> has a solution: the simulator maintains the set </span>\\{(i,a_{i})\\}_{i\\in I}<span class="math"> of past query-answer pairs; then, on a new verifier query </span>j\\in D<span class="math">, the simulator uses constraint detection to determine if </span>w_{j}<span class="math"> is linearly dependent on </span>w_{I}$, and answers accordingly (such linear dependencies characterize the required probability distribution, see Lemma 4.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Overall, our paper thus provides an application (namely, obtaining zero knowledge simulators) where the problem of efficient implementation of huge random objects arises naturally.</p>

    <p class="text-gray-300">We now state our results about succinct constraint detection.</p>

    <p class="text-gray-300">(1) Reed–Muller codes, and their partial sums. We prove that the family of linear codes comprised of evaluations of low-degree multivariate polynomials, along with their partial sums, has succinct constraint detection. This family is closely related to the <em>sumcheck protocol</em> <em>[x20]</em>, and indeed we use this result to obtain a PZK analogue of the sumcheck protocol (see Section 2.2.2 and Section 5), which yields Theorem 1.2 (see Section 2.3.1 and Section 6).</p>

    <p class="text-gray-300">Recall that the family of Reed–Muller codes, denoted <span class="math">\\mathrm{RM}</span>, is indexed by tuples <span class="math">\\mathtt{n}=(\\mathbb{F},m,d)</span>, where <span class="math">\\mathbb{F}</span> is a finite field and <span class="math">m,d</span> are positive integers, and the <span class="math">\\mathtt{n}</span>-th code consists of codewords <span class="math">w\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> that are the evaluation of an <span class="math">m</span>-variate polynomial <span class="math">Q</span> of individual degree less than <span class="math">d</span> over <span class="math">\\mathbb{F}</span>. We denote by <span class="math">\\Sigma\\mathrm{RM}</span> the family that extends <span class="math">\\mathrm{RM}</span> with evaluations of all partial sums over certain subcubes of a hypercube:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 1.4 (informal).</h6>

    <p class="text-gray-300">We denote by <span class="math">\\Sigma\\mathrm{RM}</span> the linear code family that is indexed by tuples <span class="math">\\mathtt{n}=(\\mathbb{F},m,d,H)</span>, where <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>, and where the <span class="math">\\mathtt{n}</span>-th code consists of codewords <span class="math">(w_{0},\\ldots,w_{m})</span> such that there exists an <span class="math">m</span>-variate polynomial <span class="math">Q</span> of individual degree less than <span class="math">d</span> over <span class="math">\\mathbb{F}</span> for which <span class="math">w_{i}\\colon\\mathbb{F}^{m-i}\\to\\mathbb{F}</span> is the evaluation of the <span class="math">i</span>-th partial sum of <span class="math">Q</span> over <span class="math">H</span>, i.e, <span class="math">w_{i}(\\vec{\\alpha})=\\sum_{\\vec{\\gamma}\\in H^{i}}Q(\\vec{\\alpha},\\vec{\\gamma})</span> for every <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m-i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The domain size for codes in <span class="math">\\Sigma\\mathrm{RM}</span> is $\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m})$, but our detector’s running time is exponentially smaller.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.5 (informal statement of Thm. 4.9).</h6>

    <p class="text-gray-300">The family <span class="math">\\Sigma\\mathrm{RM}</span> has succinct constraint detection:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">there is a detector algorithm for <span class="math">\\Sigma\\mathrm{RM}</span> that runs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We provide intuition for the theorem’s proof in Section 2.1.1 and provide the proof’s details in Section 4.2; the proof leverages tools from algebraic complexity theory. (Our proof also shows that the family <span class="math">\\mathrm{RM}</span>, which is a restriction of <span class="math">\\Sigma\\mathrm{RM}</span>, has succinct constraint detection.) Our theorem implies perfect and stateful implementation of a random low-degree multivariate polynomial and its partial sums over any hypercube; our proof extends an algorithm of <em>[x11]</em>, which solves this problem in the case of parity queries to boolean functions on subcubes of the boolean hypercube.</p>

    <p class="text-gray-300">(2) Reed–Solomon codes, and their PCPPs. Second, we prove that the family of linear codes comprised of evaluations of low-degree univariate polynomials concatenated with corresponding BS proximity proofs <em>[x12]</em> has succinct constraint detection. This family is closely related to quasilinear-size PCPs for <span class="math">\\mathbf{NEXP}</span> <em>[x12]</em>, and indeed we use this result to obtain PZK proximity proofs for this family (see Section 2.2.3 and Section 7), from which we derive Theorem 1.1 (see Section 2.3.2 and Section 8).</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 1.6 (informal).</h6>

    <p class="text-gray-300">We denote by <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> the linear code family indexed by tuples <span class="math">\\mathtt{n}=(\\mathbb{F},L,d)</span>, where <span class="math">\\mathbb{F}</span> is an extension field of <span class="math">\\mathbb{F}_{2}</span>, <span class="math">L</span> is a linear subspace in <span class="math">\\mathbb{F}</span>, and <span class="math">d</span> is a positive integer; the <span class="math">\\mathtt{n}</span>-th code consists of evaluations on <span class="math">L</span> of univariate polynomials <span class="math">Q</span> of degree less than <span class="math">d</span>, concatenated with corresponding <em>[x12]</em> proximity proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The domain size for codes in <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> is $\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, but our detector’s running time is exponentially smaller.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 1.7 (informal statement of Thm. 4.12).</h6>

    <p class="text-gray-300">The family <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has succinct constraint detection:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">there is a detector algorithm for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> that runs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We provide intuition for the theorem’s proof in Section 2.1.2 and provide the proof’s details in Section 4.3; the proof leverages combinatorial properties of the recursive construction of BS proximity proofs.</p>

    <p class="text-gray-300">We informally discuss intuition behind our algorithms for detecting constraints (Section 2.1), their connection to zero knowledge (Section 2.2), and how we derive our results about #P and NEXP (Section 2.3). Throughout, we provide pointers to the technical sections that contain further details.</p>

    <p class="text-gray-300">As informally introduced in Section 1.1.3, the constraint detection problem corresponding to a linear code family  <span class="math">\\mathcal{C} = \\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span>  with domain  <span class="math">D(\\cdot)</span>  and alphabet  <span class="math">\\mathbb{F}(\\cdot)</span>  is the following: given an index  <span class="math">\\mathfrak{n}\\in \\{0,1\\}^*</span>  and subset  <span class="math">I\\subseteq D(\\mathfrak{n})</span> , output a basis for the space  <span class="math">\\{z\\in D(\\mathfrak{n})^I:\\forall w\\in C_{\\mathfrak{n}},\\sum_{i\\in I}z(i)w(i) = 0\\}</span> . In other words, for a given subdomain  <span class="math">I</span> , we wish to determine all linear relations that hold for codewords in  <span class="math">C_{\\mathfrak{n}}</span>  restricted to the subdomain  <span class="math">I</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If a generating matrix for  <span class="math">C_{\\mathfrak{n}}</span>  can be found in polynomial time, this problem can be solved in  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time via Gaussian elimination (such an approach was implicitly taken by [BCGV16] to construct a perfect zero knowledge simulator for an IOP for NP). However, in our setting  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is exponential in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , so the straightforward solution is inefficient. With this in mind, we say that  </span>\\mathcal{C}<span class="math">  has succinct constraint detection if there exists an algorithm that solves its constraint detection problem in  </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time, even if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is exponential in  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The formal definition of succinct constraint detection is in Section 4.1. In the rest of this section we provide intuition for two of our theorems: succinct constraint detection for the family  <span class="math">\\Sigma \\mathrm{RM}</span>  and for the family BS-RS. As will become evident, the techniques that we use to prove the two theorems differ significantly. Perhaps this is because the two codes are quite different:  <span class="math">\\Sigma \\mathrm{RM}</span>  has a simple and well-understood algebraic structure, whereas BS-RS is constructed recursively using proof composition.</p>

    <p class="text-gray-300">The purpose of this section is to provide intuition about the proof of Theorem 1.5, which states that the family  <span class="math">\\Sigma \\mathrm{RM}</span>  has succinct constraint detection. (Formal definitions, statements, and proofs are in Section 4.2.) We thus outline how to construct an algorithm that detects constraints for the family of linear codes comprised of evaluations of low-degree multivariate polynomials, along with their partial sums. Our construction generalizes the proof of [BW04], which solves the special case of parity queries to boolean functions on subcubes of the boolean hypercube by reducing this problem to a probabilistic identity testing problem that is solvable via an algorithm of [RS05].</p>

    <p class="text-gray-300">Below, we temporarily ignore the partial sums, and focus on constructing an algorithm that detects constraints for the family of Reed-Muller codes  <span class="math">\\mathrm{RM}</span> , and at the end of the section we indicate how we can also handle partial sums.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Step 1: phrase as linear algebra problem. Consider a codeword  <span class="math">w \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  that is the evaluation of an  <span class="math">m</span> -variate polynomial  <span class="math">Q</span>  of individual degree less than  <span class="math">d</span>  over  <span class="math">\\mathbb{F}</span> . Note that, for every  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> ,  <span class="math">w(\\vec{\\alpha})</span>  equals the inner product of  <span class="math">Q</span> 's coefficients with the vector  <span class="math">\\phi_{\\vec{\\alpha}}</span>  that consists of the evaluation of all  <span class="math">d^m</span>  monomials at  <span class="math">\\vec{\\alpha}</span> . One can argue that constraint detection for  <span class="math">\\mathrm{RM}</span>  is equivalent to finding the nullspace of  <span class="math">\\{\\phi_{\\vec{\\alpha}}\\}_{\\vec{\\alpha} \\in I}</span> . However, "writing out" this  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\times d^m$  matrix and performing Gaussian elimination is too expensive, so we must solve this linear algebra problem succinctly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Step 2: encode vectors as coefficients of polynomials. While each vector  <span class="math">\\phi_{\\vec{\\alpha}}</span>  is long, it has a succinct description; in fact, we can construct an  <span class="math">m</span> -variate polynomial  <span class="math">\\Phi_{\\vec{\\alpha}}</span>  whose coefficients (after expansion) are the entries of  <span class="math">\\phi_{\\vec{\\alpha}}</span> , but has an arithmetic circuit of only size  <span class="math">O(md)</span> : namely,  <span class="math">\\Phi_{\\vec{\\alpha}}(\\vec{X}) := \\prod_{i=1}^{m}(1 + \\alpha_i X_i + \\alpha_i^2 X_i^2 + \\dots + \\alpha_i^{d-1} X_i^{d-1})</span> . Computing the nullspace of  <span class="math">\\{\\Phi_{\\vec{\\alpha}}\\}_{\\vec{\\alpha} \\in I}</span>  is thus equivalent to computing the nullspace of  <span class="math">\\{\\phi_{\\vec{\\alpha}}\\}_{\\vec{\\alpha} \\in I}</span> .</p>

    <p class="text-gray-300">Step 3: computing the nullspace. Computing the nullspace of a set of polynomials is a problem in algebraic complexity theory, and is essentially equivalent to the Polynomial Identity Testing (PIT) problem, and so we leverage tools from that area. While there are simple randomized algorithms to solve this problem (see for example [Kay10, Lemma 8] and [BW04]), these algorithms, due to a nonzero probability of error, suffice to achieve statistical zero knowledge but do not suffice to achieve perfect zero knowledge. To obtain perfect zero knowledge, we need a solution that has no probability of error. Derandomizing PIT for arbitrary algebraic circuits seems to be beyond current</p>

    <p class="text-gray-300">techniques (as it implies circuit lower bounds <em>[x10]</em>), but derandomizations are currently known for some restricted circuit classes. The polynomials that we consider are special: they fall in the well-studied class of “sum of products of univariates”, and for this case we can invoke the deterministic algorithm of <em>[x15]</em> (see also <em>[x9]</em>). (It is interesting that derandomization techniques are ultimately used to obtain a qualitative improvement for an inherently probabilistic task, i.e., perfect sampling of verifier views.)</p>

    <p class="text-gray-300">The above provides an outline for how to detect constraints for <span class="math">\\mathrm{RM}</span>. The extension to <span class="math">\\Sigma\\mathrm{RM}</span>, which also includes partial sums, is achieved by considering a more general form of vectors <span class="math">\\phi_{\\vec{\\alpha}}</span> as well as corresponding polynomials <span class="math">\\Phi_{\\vec{\\alpha}}</span>. These polynomials also have the special form required for our derandomization. See Section 4.2 for details.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">2.1.2 From recursive code covers to detecting constraints for Reed–Solomon codes and their PCPPs</h4>

    <p class="text-gray-300">The purpose of this section is to provide intuition about the proof of Theorem 1.7, which states that the family <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has succinct constraint detection. (Formal definitions, statements, and proofs are in Section 4.3.) We thus outline how to construct an algorithm that detects constraints for the family of linear codes comprised of evaluations of low-degree univariate polynomials concatenated with corresponding BS proximity proofs <em>[x2]</em>.</p>

    <p class="text-gray-300">Our construction leverages the recursive structure of BS proximity proofs: we identify key combinatorial properties of the recursion that enable “local” constraint detection. To define and argue these properties, we introduce two notions that play a central role throughout the proof:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>A <em>(local) view</em> of a linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> is a pair <span class="math">(\\tilde{D},\\tilde{C})</span> such that <span class="math">\\tilde{D}\\subseteq D</span> and <span class="math">\\tilde{C}=C|_{\\tilde{D}}\\subseteq\\mathbb{F}^{\\tilde{D}}</span>.

A <em>cover</em> of <span class="math">C</span> is a set of local views <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> of <span class="math">C</span> such that <span class="math">D=\\cup_{j}\\tilde{D}_{j}</span>.</p>
    </blockquote>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Combinatorial properties of the recursive step.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a finite field <span class="math">\\mathbb{F}</span>, domain <span class="math">D\\subseteq\\mathbb{F}</span>, and degree <span class="math">d</span>, let <span class="math">C:=\\mathrm{RS}[\\mathbb{F},D,d]</span> be the Reed–Solomon code consisting of evaluations on <span class="math">D</span> of univariate polynomials of degree less than <span class="math">d</span> over <span class="math">\\mathbb{F}</span>; for concreteness, say that the domain size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{n}<span class="math"> and the degree is </span>d=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2=2^{n-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first level of <em>[x2]</em>’s recursion appends to each codeword <span class="math">f\\in C</span> an auxiliary function <span class="math">\\pi_{1}(f)\\colon D^{\\prime}\\to\\mathbb{F}</span> with domain <span class="math">D^{\\prime}</span> disjoint from <span class="math">D</span>. Moreover, the mapping from <span class="math">f</span> to <span class="math">\\pi_{1}(f)</span> is linear over <span class="math">\\mathbb{F}</span>, so the set $C^{1}:=\\{f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{1}(f)\\}_{f\\in C}<span class="math">, where </span>f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{1}(f)\\colon D\\cup D^{\\prime}\\to\\mathbb{F}<span class="math"> is the function that agrees with </span>f<span class="math"> on </span>D<span class="math"> and with </span>\\pi_{1}(f)<span class="math"> on </span>D^{\\prime}<span class="math">, is a linear code over </span>\\mathbb{F}<span class="math">. The code </span>C^{1}<span class="math"> is the “first-level” code of a BS proximity proof for </span>f$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The code <span class="math">C^{1}</span> has a naturally defined cover <span class="math">S^{1}=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> such that each <span class="math">\\tilde{C}_{j}</span> is a Reed–Solomon code <span class="math">\\mathrm{RS}[\\mathbb{F},\\tilde{D}_{j},d_{j}]</span> with $2d_{j}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\sqrt{d})<span class="math">, that is, with rate </span>1/2<span class="math"> and block length </span>O(\\sqrt{d})$. We prove several combinatorial properties of this cover:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">S^{1}</span> is <span class="math">1</span>-intersecting. For all distinct <span class="math">j,j^{\\prime}</span> in <span class="math">J</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{j}\\cap\\tilde{D}_{j^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1$ (namely, the subdomains are almost disjoint).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">S^{1}</span> is <span class="math">O(\\sqrt{d})</span>-independent. The ability to extend locally-consistent assignments to “globally-consistent” codewords of <span class="math">C^{1}</span> holds in a stronger sense: even when the aforementioned partial assignment <span class="math">h</span> is extended arbitrarily to <span class="math">\\kappa</span> additional point-value pairs, this new partial assignment still equals the restriction of some codeword $f\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\pi_{1}(f)<span class="math"> in </span>C^{1}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The locality property alone already suffices to imply that, given a subdomain <span class="math">I\\subseteq D\\cup D^{\\prime}</span> of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\sqrt{d}<span class="math">, we can solve the constraint detection problem on </span>I<span class="math"> by considering only those constraints that appear in views that intersect </span>I<span class="math"> (see Lemma 4.22). But </span>C$ has exponential block length so a “quadratic speedup” does not yet imply succinct constraint detection. To obtain it, we also leverage the intersection and independence properties to reduce “locality” as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Further recursive steps.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So far we have only considered the first recursive step of a BS proximity proof; we show how to obtain covers with smaller locality (and thereby detect constraints with more efficiency) by considering additional recursive steps. Each code <span class="math">\\tilde{C}_{j}</span> in the cover <span class="math">S^{1}</span> of <span class="math">C^{1}</span> is a Reed–Solomon code <span class="math">\\mathrm{RS}[\\mathbb{F},\\tilde{D}_{j},d_{j}]</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d_{j}=O(\\sqrt{d})<span class="math">, and the next recursive step appends to each codeword in </span>\\tilde{C}_{j}$ a corresponding auxiliary function, yielding a new code</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">C^{2}</span>. In turn, <span class="math">C^{2}</span> has a cover <span class="math">S^{2}</span>, and another recursive step yields a new code <span class="math">C^{3}</span>, which has its own cover <span class="math">S^{3}</span>, and so on. The crucial technical observation (Lemma 4.20) is that the intersection and independence properties, which hold recursively, enable us to deduce that <span class="math">C^{i}</span> is <span class="math">1</span>-intersecting, <span class="math">O(\\sqrt[i]{d})</span>-local, and <span class="math">O(\\sqrt[i]{d})</span>-independent; in particular, for <span class="math">r=\\log\\log d+O(1)</span>, <span class="math">S^{r}</span> is <span class="math">1</span>-intersecting, <span class="math">O(1)</span>-local, <span class="math">O(1)</span>-independent.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, recalling that detecting constraints for local codes requires only the views in the cover that intersect <span class="math">I</span> (Lemma 4.22), our constraint detector works by choosing <span class="math">i\\in\\{1,\\ldots,r\\}</span> such that the cover <span class="math">S^{i}</span> is $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-local, finding in this cover a </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-size set of </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-size views that intersect </span>I<span class="math">, and computing in </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time a basis for the dual of each of these views — thereby proving Theorem 1.7.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">For the sake of those familiar with <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> we remark that the domain <span class="math">D^{\\prime}</span> is the carefully chosen subset of <span class="math">\\mathbb{F}\\times\\mathbb{F}</span> designated by that construction, the code <span class="math">C^{1}</span> is the code that evaluates bivariate polynomials of degree <span class="math">O(\\sqrt{d})</span> on <span class="math">D\\cup D^{\\prime}</span> (along the way mapping <span class="math">D\\subseteq\\mathbb{F}</span> to a subset of <span class="math">\\mathbb{F}\\times\\mathbb{F}</span>), the subdomains <span class="math">\\tilde{D}_{j}</span> are the axis-parallel “rows” and “columns” used in that recursive construction, and the codes <span class="math">\\tilde{C}_{j}</span> are Reed–Solomon codes of block length <span class="math">O(\\sqrt{d})</span>. The <span class="math">O(\\sqrt{d})</span>-locality and independence follow from basic properties of bivariate Reed–Muller codes; see Example 4.14.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 2.2.</h6>

    <p class="text-gray-300">It is interesting to compare the above result with <em>linear lower bounds on query complexity</em> for testing proximity to random low density parity check (LDPC) codes <em>[x1, BGK^{+}10]</em>. Those results are proved by obtaining a basis for the dual code such that every small-support constraint is spanned by a small subset of that basis. The same can be observed to hold for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span>, even though this latter code is locally testable with <em>polylogarithmic query complexity</em> <em>[x2, Thm. 2.13]</em>. The difference between the two cases is due to the fact that, for a random LDPC code, an assignment that satisfies all but a single basis-constraint is (with high probability) far from the code, whereas the recursive and <span class="math">1</span>-intersecting structure of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> implies the existence of words that satisfy all but a single basis constraint, yet are negligibly close to being a codeword.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.2 From constraint detection to zero knowledge via masking</h3>

    <p class="text-gray-300">We provide intuition about the connection between constraint detection and zero knowledge (Section 2.2.1), and how we leverage this connection to achieve two intermediate results: (i) a sumcheck protocol that is zero knowledge in the Interactive PCP model (Section 2.2.2); and (ii) proximity proofs for Reed–Solomon codes that are zero knowledge in the Interactive Oracle Proof model (Section 2.2.3).</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">2.2.1 Local simulation of random codewords</h4>

    <p class="text-gray-300">Suppose that the prover and verifier both have oracle access to a codeword <span class="math">w\\in C</span>, for some linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> with exponential-size domain <span class="math">D</span>, and that they need to engage in some protocol that involves <span class="math">w</span>. During the protocol, the prover may leak information about <span class="math">w</span> that is hard to compute (e.g., requires exponentially-many queries to <span class="math">w</span>), and so would violate zero knowledge (as we see below, this is the case for protocols such as sumcheck).</p>

    <p class="text-gray-300">Rather than directly invoking the protocol, the prover first sends to the verifier a random codeword <span class="math">r\\in C</span> (as an oracle since <span class="math">r</span> has exponential size) and the verifier replies with a random field element <span class="math">\\rho\\in\\mathbb{F}</span>; then the prover and verifier invoke the protocol on the new codeword <span class="math">w^{\\prime}:=\\rho w+r\\in C</span> rather than <span class="math">w</span>. Intuitively, running the protocol on <span class="math">w^{\\prime}</span> now does not leak information about <span class="math">w</span>, because <span class="math">w^{\\prime}</span> is random in <span class="math">C</span> (up to resolvable technicalities). This <em>random self-reducibility</em> makes sense for only some protocols, e.g., those where completeness is preserved for any choice of <span class="math">\\rho</span> and soundness is broken for only a small fraction of <span class="math">\\rho</span>; but this will indeed be the case for the settings described below.</p>

    <p class="text-gray-300">The aforementioned <em>masking</em> technique was used by <em>[x5]</em> for codes with polynomial-size domains, but we use it for codes with exponential-size domains, which requires exponentially more efficient simulation techniques. Indeed, to prove (perfect) zero knowledge, a simulator must be able to reproduce, exactly, the view obtained by any malicious verifier that queries entries of <span class="math">w^{\\prime}</span>, a uniformly random codeword in <span class="math">C</span>; however, it is too expensive for the simulator to explicitly sample a random codeword and answer the verifier’s queries according to it. Instead, the simulator must sample the “local view” that the verifier sees while querying <span class="math">w^{\\prime}</span> at a <em>small</em> number of locations <span class="math">I\\subseteq D</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">But simulating local views of the form $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> is reducible to detecting <em>constraints</em>, i.e., codewords in the dual code </span>C^{\\perp}<span class="math"> whose support is contained in </span>I<span class="math">. Indeed, if no word in </span>C^{\\perp}<span class="math"> has support contained in </span>I<span class="math"> then </span>w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> is uniformly random; otherwise, each additional linearly independent constraint of </span>C^{\\perp}<span class="math"> with support contained in </span>I$ further reduces</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the entropy of $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> in a well-understood manner. (See Lemma 4.3 for a formal statement.) In sum, succinct constraint detection enables us to “implement” <em>[x10, x11]</em> random codewords of </span>C<span class="math"> despite </span>C$ having exponential size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that in the above discussion we implicitly assumed that the set <span class="math">I</span> is known in advance, i.e., that the verifier chooses its queries in advance. This, of course, need not be the case: a verifier may adaptively make queries based on answers to previous queries and, hence, the set <span class="math">I</span> need not be known a priori. This turns out to not be a problem because, given a constraint detector, it is straightforward to compute the conditional distribution of the view $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> given </span>w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{J}<span class="math"> for a subset </span>J<span class="math"> of </span>I$. This is expressed precisely in Lemma 4.3.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now discuss two concrete protocols for which the aforementioned random self-reducibility applies, and for which we also have constructed suitably-efficient constraint detectors.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">2.2.2 Zero knowledge sumchecks</h4>

    <p class="text-gray-300">The celebrated sumcheck protocol <em>[x24]</em> is <em>not</em> zero knowledge. In the sumcheck protocol, the prover and verifier have oracle access to a low-degree <span class="math">m</span>-variate polynomial <span class="math">F</span> over a field <span class="math">\\mathbb{F}</span>, and the prover wants to convince the verifier that <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span> for a given subset <span class="math">H</span> of <span class="math">\\mathbb{F}</span>. During the protocol, the prover communicates partial sums of <span class="math">F</span>, which are <span class="math">\\#\\mathbf{P}</span>-hard to compute and, as such, violate zero knowledge.</p>

    <p class="text-gray-300">We now explain how to use random self-reducibility to make the sumcheck protocol (<em>perfect</em>) <em>zero knowledge</em>, at the cost of moving from the Interactive Proof model to the Interactive PCP model.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">IPCP sumcheck.</h5>

    <p class="text-gray-300">Consider the following tweak to the classical sumcheck protocol: rather than invoking sumcheck on <span class="math">F</span> directly, the prover first sends to the verifier (the evaluation of) a random low-degree polynomial <span class="math">R</span> as an oracle; then, the prover sends the value <span class="math">z:=\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})</span> and the verifier replies with a random field element <span class="math">\\rho</span>; finally, the two invoke sumcheck on the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}Q(\\vec{\\alpha})=z</span>” where <span class="math">Q:=\\rho F+R</span>.</p>

    <p class="text-gray-300">Completeness is clear because if <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span> and <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=z</span> then <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}(\\rho F+R)(\\vec{\\alpha})=z</span>; soundness is also clear because if <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})\\neq 0</span> then <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}(\\rho F+R)(\\vec{\\alpha})\\neq z</span> with high probability over <span class="math">\\rho</span>, regardless of the choice of <span class="math">R</span>. (For simplicity, we ignore the fact that the verifier also needs to test that <span class="math">R</span> has low degree.) We are thus left to show (perfect) zero knowledge, which turns out to be a much less straightforward argument.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">The simulator.</h5>

    <p class="text-gray-300">Before we explain how to argue zero knowledge, we first clarify what we mean by it: since the verifier has oracle access to <span class="math">F</span> we cannot hope to ‘hide’ it; nevertheless, we can hope to argue that the verifier, by participating in the protocol, does not learn anything about <span class="math">F</span> beyond what the verifier can directly learn by querying <span class="math">F</span> (and the fact that <span class="math">F</span> sums to zero on <span class="math">H^{m}</span>). What we shall achieve is the following: an algorithm that simulates the verifier’s view by making as many queries to <span class="math">F</span> as the <em>total</em> number of verifier queries to either <span class="math">F</span> or <span class="math">R</span>.</p>

    <p class="text-gray-300">On the surface, zero knowledge seems easy to argue, because <span class="math">\\rho F+R</span> seems random among low-degree <span class="math">m</span>-variate polynomials. More precisely, consider the simulator that samples a random low-degree polynomial <span class="math">Q</span> and uses it instead of <span class="math">\\rho F+R</span> and answers the verifier queries as follows: (a) whenever the verifier queries <span class="math">F(\\vec{\\alpha})</span>, respond by querying <span class="math">F(\\vec{\\alpha})</span> and returning the true value; (b) whenever the verifier queries <span class="math">R(\\vec{\\alpha})</span>, respond by querying <span class="math">F(\\vec{\\alpha})</span> and returning <span class="math">Q(\\vec{\\alpha})-\\rho F(\\vec{\\alpha})</span>. Observe that the number of queries to <span class="math">F</span> made by the simulator equals the number of (mutually) distinct queries to <span class="math">F</span> and <span class="math">R</span> made by the verifier, as desired.</p>

    <p class="text-gray-300">However, the above reasoning, while compelling, is insufficient. First, <span class="math">\\rho F+R</span> is <em>not</em> random because a malicious verifier can choose <span class="math">\\rho</span> depending on queries to <span class="math">R</span>. Second, even if <span class="math">\\rho F+R</span> were random (e.g., the verifier does not query <span class="math">R</span> before choosing <span class="math">\\rho</span>), the simulator must run in polynomial time, both producing correctly-distributed ‘partial sums’ of <span class="math">\\rho F+R</span> and answering queries to <span class="math">R</span>, but sampling <span class="math">Q</span> alone requires exponential time. In this high level discussion we ignore the first problem (which nonetheless has to be tackled), and focus on the second.</p>

    <p class="text-gray-300">At this point it should be clear from the discussion in Section 2.2.1 that the simulator does not have to sample <span class="math">Q</span> explicitly, but only has to perfectly simulate local views of it by leveraging the fact that it can keep state across queries. And doing so requires solving the succinct constraint detection problem for a suitable code <span class="math">C</span>. In this case, it suffices to consider the code <span class="math">C=\\Sigma\\mathrm{RM}</span>, and our Theorem 1.5 guarantees the required constraint detector.</p>

    <p class="text-gray-300">The above discussion omits several details, so we refer the reader to Section 5 for further details.</p>

    <p class="text-gray-300">2.2.3 Zero knowledge proximity proofs for Reed–Solomon</p>

    <p class="text-gray-300">Testing proximity of a codeword <span class="math">w</span> to a given linear code <span class="math">C</span> can be aided by a <em>proximity proof</em> <em>[x10, BGH^{+}06]</em>, which is an auxiliary oracle <span class="math">\\pi</span> that facilitates testing (e.g., <span class="math">C</span> is not locally testable). For example, testing proximity to the Reed–Solomon code, a crucial step towards achieving short PCPs, is aided via suitable proximity proofs <em>[x11]</em>.</p>

    <p class="text-gray-300">From the perspective of zero knowledge, however, a proximity proof can be ‘dangerous’: a few locations of <span class="math">\\pi</span> can in principle leak a lot of information about the codeword <span class="math">w</span>, and a malicious verifier could potentially learn a lot about <span class="math">w</span> with only a few queries to <span class="math">w</span> and <span class="math">\\pi</span>. The notion of zero knowledge for proximity proofs requires that this cannot happen: it requires the existence of an algorithm that simulates the verifier’s view by making as many queries to <span class="math">w</span> as the <em>total</em> number of verifier queries to either <span class="math">w</span> or <span class="math">\\pi</span> <em>[x16]</em>; intuitively, this means that any bit of the proximity proof <span class="math">\\pi</span> reveals no more information than one bit of <span class="math">w</span>.</p>

    <p class="text-gray-300">We demonstrate again the use of random self-reducibility and show a general transformation that, under certain conditions, maps a PCP of proximity <span class="math">(P,V)</span> for a code <span class="math">C</span> to a corresponding <span class="math">2</span>-round Interactive Oracle Proof of Proximity (IOPP) for <span class="math">C</span> that is <em>(perfect) zero knowledge</em>.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">IOP of proximity for <span class="math">C</span>.</h4>

    <p class="text-gray-300">Consider the following IOP of Proximity: the prover and verifier have oracle access to a codeword <span class="math">w</span>, and the prover wants to convince the verifier that <span class="math">w</span> is close to <span class="math">C</span>; the prover first sends to the verifier a random codeword <span class="math">r</span> in <span class="math">C</span>, and the verifier replies with a random field element <span class="math">\\rho</span>; the prover then sends the proximity proof <span class="math">\\pi^{\\prime}:=P(w^{\\prime})</span> that attests that <span class="math">w^{\\prime}:=\\rho w+r</span> is close to <span class="math">C</span>. Note that this is a <span class="math">2</span>-round IOP of Proximity for <span class="math">C</span>, because completeness follows from the fact that <span class="math">C</span> is linear, while soundness follows because if <span class="math">w</span> is far from <span class="math">C</span>, then so is <span class="math">\\rho w+r</span> for every <span class="math">r</span> with high probability over <span class="math">\\rho</span>. But is the zero knowledge property satisfied?</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">The simulator.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Without going into details, analogously to Section 2.2.2, a simulator must be able to sample local views for random codewords from the code $L:=\\{\\,w\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(w)\\,\\}_{w\\in C}<span class="math">, so the simulator’s efficiency reduces to the efficiency of constraint detection for </span>L<span class="math">. We indeed prove that if </span>L$ has succinct constraint detection then the simulator works out. See Section 7.1 for further details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">The case of Reed–Solomon.</h4>

    <p class="text-gray-300">The above machinery allows us to derive a zero knowledge IOP of Proximity for Reed–Solomon codes, thanks to our Theorem 1.7, which states that the family of linear codes comprised of evaluations of low-degree univariate polynomials concatenated with corresponding BS proximity proofs <em>[x11]</em> has succinct constraint detection; see Section 7.2 for details. This is one of the building blocks of our construction of zero knowledge IOPs for <span class="math">\\mathbf{NEXP}</span>, as described below in Section 2.3.2.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">2.3 Achieving zero knowledge beyond <span class="math">\\mathbf{NP}</span></h3>

    <p class="text-gray-300">We outline how to derive our results about zero knowledge for <span class="math">\\#\\mathbf{P}</span> and <span class="math">\\mathbf{NEXP}</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">2.3.1 Zero knowledge for counting problems</h4>

    <p class="text-gray-300">We provide intuition for the proof of Theorem 1.2, which states that the complexity class <span class="math">\\#\\mathbf{P}</span> has Interactive PCPs that are perfect zero knowledge.</p>

    <p class="text-gray-300">We first recall the classical (non zero knowledge) Interactive Proof for <span class="math">\\#\\mathbf{P}</span> <em>[x22]</em>. The language <span class="math">\\mathscr{L}_{\\#3\\mathrm{SAT}}</span>, which consists of pairs <span class="math">(\\phi,N)</span> where <span class="math">\\phi</span> is a <span class="math">3</span>-CNF boolean formula and <span class="math">N</span> is the number of satisfying assignments of <span class="math">\\phi</span>, is <span class="math">\\#\\mathbf{P}</span>-complete, and thus it suffices to construct an IP for it. The IP for <span class="math">\\mathscr{L}_{\\#3\\mathrm{SAT}}</span> works as follows: the prover and verifier both <em>arithmetize</em> <span class="math">\\phi</span> to obtain a low-degree multivariate polynomial <span class="math">p_{\\phi}</span> and invoke the (non zero knowledge) sumcheck protocol on the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in\\{0,1\\}^{n}}p_{\\phi}(\\vec{\\alpha})=N</span>”, where arithmetic is over a large-enough prime field.</p>

    <p class="text-gray-300">Returning to our goal, we obtain a perfect zero knowledge Interactive PCP by simply replacing the (non zero knowledge) IP sumcheck mentioned above with our perfect zero knowledge IPCP sumcheck, described in Section 2.2.2. In Section 6 we provide further details, including proving that the zero knowledge guarantees of our sumcheck protocol suffice for this case.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">2.3.2 Zero knowledge for nondeterministic time</h4>

    <p class="text-gray-300">We provide intuition for the proof of Theorem 1.1, which implies that the complexity class <span class="math">\\mathbf{NEXP}</span> has Interactive Oracle Proofs that are perfect zero knowledge. Very informally, the proof consists of combining two building blocks:</p>

    <p class="text-gray-300">(i) [BCGV16]'s reduction from NEXP to randomizable linear algebraic constraint satisfaction problems, and (ii) our construction of perfect zero knowledge IOPs of Proximity for Reed-Solomon codes, described in Section 2.2.3. Besides extending [BCGV16]'s result from NP to NEXP, our proof provides a conceptual simplification over [BCGV16] by clarifying how the above two building blocks work together towards the final result. We now discuss this.</p>

    <p class="text-gray-300">Starting point: [BS08]. Many PCP constructions consist of two steps: (1) arithmetize the statement at hand (in our case, membership of an instance in some NEXP-complete language) by reducing it to a "PCP-friendly" problem that looks like a linear-algebraic constraint satisfaction problem (LACSP); (2) design a tester that probabilistically checks witnesses for this LACSP. In this paper, as in [BCGV16], we take [BS08]'s PCPs for NEXP as a starting point, where the first step reduces NEXP to a "univariate" LACSP whose witnesses are codewords in a Reed-Solomon code of exponential degree that satisfy certain properties, and whose second step relies on suitable proximity proofs [DR04,  <span class="math">\\mathrm{BGH}^{+}06]</span>  for that code. Thus, overall, the PCP consists of two oracles, one being the LACSP witness and the other being the corresponding BS proximity proof, and it is not hard to see that such a PCP is not zero knowledge, because both the LACSP witness and its proximity proof reveal hard-to-compute information.</p>

    <p class="text-gray-300">Step 1: sanitize the proximity proof. We first address the problem that the BS proximity proof "leaks", by simply replacing it with our own perfect zero knowledge analogue. Namely, we replace it with our perfect zero knowledge 2-round IOP of Proximity for Reed-Solomon codes, described in Section 2.2.3. This modification ensures that there exists an algorithm that perfectly simulates the verifier's view by making as many queries to the LACSP witness as the total number of verifier queries to either the LACSP witness or other oracles used to facilitate proximity testing. At this point we have obtained a perfect zero knowledge 2-round IOP of Proximity for NEXP (analogous to the notion of a zero knowledge PCP of Proximity [IW14]); this part is where, previously, [BCGV16] were restricted to NP because their simulator only handled Reed-Solomon codes with polynomial degree while our simulator is efficient even for such codes with exponential degree. But we are not done yet: to obtain our goal, we also need to address the problem that the LACSP witness itself "leaks" when the verifier queries it, which we discuss next.</p>

    <p class="text-gray-300">Step 2: sanitize the witness. Intuitively, we need to inject randomness in the reduction from NEXP to LACSP because the prover ultimately sends an LACSP witness to the verifier as an oracle, which the verifier can query. This is precisely what [BCGV16]'s reduction from NEXP to randomizable LACSPs enables, and we thus use their reduction to complete our proof. Informally, given an a-priori query bound  <span class="math">b</span>  on the verifier's queries, the reduction outputs a witness  <span class="math">w</span>  with the property that one can efficiently sample another witness  <span class="math">w&#x27;</span>  whose entries are  <span class="math">b</span> -wise independent. We can then simply use the IOP of Proximity from the previous step on this randomized witness. Moreover, since the efficiency of the verifier is polylogarithmic in  <span class="math">b</span> , we can set  <span class="math">b</span>  to be super-polynomial (e.g., exponential) to preserve zero knowledge against any polynomial number of verifier queries.</p>

    <p class="text-gray-300">The above discussion is only a sketch and we refer the reader to Section 8 for further details. One aspect that we did not discuss is that an LACSP witness actually consists of two sub-witnesses, where one is a "local" deterministic function of the other, which makes arguing zero knowledge somewhat more delicate.</p>

    <p class="text-gray-300">After providing formal definitions in Section 3.1, the rest of the paper is organized as summarized by the table below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">§4.2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1.5/4.9</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">detecting constraints for ΣRM</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">§4.3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1.7/4.12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">detecting constraints for BS-RS</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">§5</td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">PZK IPCP for sumcheck</td>

            <td class="px-3 py-2 border-b border-gray-700">§7</td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 7.3</td>

            <td class="px-3 py-2 border-b border-gray-700">PZK IOP of Proximity for RS codes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">§6</td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 1.2/6.2</td>

            <td class="px-3 py-2 border-b border-gray-700">PZK IPCP for #P</td>

            <td class="px-3 py-2 border-b border-gray-700">§8</td>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 1.1/8.1</td>

            <td class="px-3 py-2 border-b border-gray-700">PZK IOP for NEXP</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3 Definitions</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">3.1 Basic notations</h3>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Functions, distributions, fields.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use <span class="math">f\\colon D\\to R</span> to denote a function with domain <span class="math">D</span> and range <span class="math">R</span>; given a subset <span class="math">\\tilde{D}</span> of <span class="math">D</span>, we use $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}}<span class="math"> to denote the restriction of </span>f<span class="math"> to </span>\\tilde{D}<span class="math">. Given a distribution </span>\\mathcal{D}<span class="math">, we write </span>x\\leftarrow\\mathcal{D}<span class="math"> to denote that </span>x<span class="math"> is sampled according to </span>\\mathcal{D}<span class="math">. We denote by </span>\\mathbb{F}<span class="math"> a finite field and by </span>\\mathbb{F}_{q}<span class="math"> the field of size </span>q<span class="math">; we say </span>\\mathbb{F}<span class="math"> is a binary field if its characteristic is </span>2<span class="math">. Arithmetic operations over </span>\\mathbb{F}_{q}<span class="math"> cost </span>\\operatorname{polylog}q$ but we shall consider these to have unit cost (and inspection shows that accounting for their actual polylogarithmic cost does not change any of the stated results).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Distances.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A distance measure is a function <span class="math">\\Delta\\colon\\Sigma^{n}\\times\\Sigma^{n}\\to[0,1]</span> such that for all <span class="math">x,y,z\\in\\Sigma^{n}</span>: (i) <span class="math">\\Delta(x,x)=0</span>, (ii) <span class="math">\\Delta(x,y)=\\Delta(y,x)</span>, and (iii) <span class="math">\\Delta(x,y)\\leq\\Delta(x,z)+\\Delta(z,y)</span>. We extend <span class="math">\\Delta</span> to distances to sets: given <span class="math">x\\in\\Sigma^{n}</span> and <span class="math">S\\subseteq\\Sigma^{n}</span>, we define <span class="math">\\Delta(x,S):=\\min_{y\\in S}\\Delta(x,y)</span> (or <span class="math">1</span> if <span class="math">S</span> is empty). We say that a string <span class="math">x</span> is <span class="math">\\epsilon</span>-close to another string <span class="math">y</span> if <span class="math">\\Delta(x,y)\\leq\\epsilon</span>, and <span class="math">\\epsilon</span>-far from <span class="math">y</span> if <span class="math">\\Delta(x,y)&gt;\\epsilon</span>; similar terminology applies for a string <span class="math">x</span> and a set <span class="math">S</span>. Unless noted otherwise, we use the relative Hamming distance over alphabet <span class="math">\\Sigma</span> (typically implicit): $\\Delta(x,y):=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i\\,:\\,x_{i}\\neq y_{i}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Languages and relations.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote by <span class="math">\\mathscr{R}</span> a (binary ordered) relation consisting of pairs <span class="math">(\\mathtt{x},\\mathtt{w})</span>, where <span class="math">\\mathtt{x}</span> is the instance and <span class="math">\\mathtt{w}</span> is the witness. We denote by <span class="math">\\operatorname{Lan}(\\mathscr{R})</span> the language corresponding to <span class="math">\\mathscr{R}</span>, and by $\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}}<span class="math"> the set of witnesses in </span>\\mathscr{R}<span class="math"> for </span>\\mathtt{x}<span class="math"> (if </span>\\mathtt{x}\\not\\in\\operatorname{Lan}(\\mathscr{R})<span class="math"> then </span>\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}}:=\\emptyset<span class="math">). As always, we assume that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is bounded by some computable function of </span>n:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; in fact, we are mainly interested in relations arising from nondeterministic languages: </span>\\mathscr{R}\\in\\mathtt{NTIME}(T)<span class="math"> if there exists a </span>T(n)<span class="math">-time machine </span>M<span class="math"> such that </span>M(\\mathtt{x},\\mathtt{w})<span class="math"> outputs </span>1<span class="math"> if and only if </span>(\\mathtt{x},\\mathtt{w})\\in\\mathscr{R}<span class="math">. Throughout, we assume that </span>T(n)\\geq n<span class="math">. We say that </span>\\mathscr{R}<span class="math"> has relative distance </span>\\delta_{\\mathscr{R}}\\colon\\mathbb{N}\\to[0,1]<span class="math"> if </span>\\delta_{\\mathscr{R}}(n)<span class="math"> is the minimum relative distance among witnesses in </span>\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}}<span class="math"> for all </span>\\mathtt{x}<span class="math"> of size </span>n<span class="math">. Throughout, we assume that </span>\\delta_{\\mathscr{R}}$ is a constant.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-39" class="text-base font-semibold mt-4">Polynomials.</h5>

    <p class="text-gray-300">We denote by <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{m}]</span> the ring of polynomials in <span class="math">m</span> variables over <span class="math">\\mathbb{F}</span>. Given a polynomial <span class="math">P</span> in <span class="math">\\mathbb{F}[X_{1},\\ldots,X_{m}]</span>, <span class="math">\\operatorname{deg}_{X_{i}}(P)</span> is the degree of <span class="math">P</span> in the variable <span class="math">X_{i}</span>. We denote by <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> the subspace consisting of <span class="math">P\\in\\mathbb{F}[X_{1},\\ldots,X_{m}]</span> with <span class="math">\\operatorname{deg}_{X_{i}}(P)&lt;d</span> for every <span class="math">i\\in\\{1,\\ldots,m\\}</span>.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Random shifts.</h5>

    <p class="text-gray-300">We later use a folklore claim about distance preservation for random shifts in linear spaces.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Claim 3.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">n</span> be in <span class="math">\\mathbb{N}</span>, <span class="math">\\mathbb{F}</span> a finite field, <span class="math">S</span> an <span class="math">\\mathbb{F}</span>-linear space in <span class="math">\\mathbb{F}^{n}</span>, and <span class="math">x,y\\in\\mathbb{F}^{n}</span>. If <span class="math">x</span> is <span class="math">\\epsilon</span>-far from <span class="math">S</span>, then <span class="math">\\alpha x+y</span> is <span class="math">\\epsilon/2</span>-far from <span class="math">S</span>, with probability $1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}<span class="math"> over a random </span>\\alpha\\in\\mathbb{F}$. (Distances are relative Hamming distances.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">3.2 Single-prover proof systems</h3>

    <p class="text-gray-300">We use two types of proof systems that combine aspects of interactive proofs <em>[x1, x10]</em> and probabilistically checkable proofs <em>[x1, x1, ALM^{+}98]</em>: interactive PCPs (IPCPs) <em>[x16]</em> and interactive oracle proofs (IOPs) <em>[x5, x28]</em>. We first describe IPCPs (Section 3.2.1) and then IOPs (Section 3.2.2), which generalize the former.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">3.2.1 Interactive probabilistically checkable proofs</h4>

    <p class="text-gray-300">An IPCP <em>[x16]</em> is a PCP followed by an IP. Namely, the prover <span class="math">P</span> and verifier <span class="math">V</span> interact as follows: <span class="math">P</span> sends to <span class="math">V</span> a probabilistically checkable proof <span class="math">\\pi</span>; afterwards, <span class="math">P</span> and <span class="math">V^{\\pi}</span> engage in an interactive proof. Thus, <span class="math">V</span> may read a few bits of <span class="math">\\pi</span> but must read subsequent messages from <span class="math">P</span> in full. An IPCP system for a relation <span class="math">\\mathscr{R}</span> is thus a pair <span class="math">(P,V)</span>, where <span class="math">P,V</span> are probabilistic interactive algorithms working as described, that satisfies naturally-defined notions of perfect completeness and soundness with a given error <span class="math">\\varepsilon(\\cdot)</span>; see <em>[x16]</em> for details.</p>

    <p class="text-gray-300">We say that an IPCP has <span class="math">\\mathsf{k}</span> rounds if this “PCP round” is followed by a <span class="math">(\\mathsf{k}-1)</span>-round interactive proof. (That is, we count the PCP round towards round complexity, unlike <em>[x16]</em>.) Beyond round complexity, we also measure how many bits the prover sends and how many the verifier reads: the proof length <span class="math">\\mathsf{l}</span> is the length of <span class="math">\\pi</span> in bits plus the number of bits in all subsequent prover messages; the query complexity <span class="math">\\mathtt{q}</span> is the number of bits of <span class="math">\\pi</span> read by the verifier plus the number of bits in all subsequent prover messages (since the verifier must read all of those bits).</p>

    <p class="text-gray-300">In this work, we do not count the number of bits in the verifier messages, nor the number of random bits used by the verifier; both are bounded from above by the verifier’s running time, which we do consider. Overall, we say that a relation <span class="math">\\mathscr{R}</span> belongs to the complexity class <span class="math">\\mathtt{IPCP}[\\mathsf{k},\\mathsf{l},\\mathtt{q},\\varepsilon,\\mathtt{tp},\\mathtt{tv}]</span> if there is an IPCP system for <span class="math">\\mathscr{R}</span> in which: (1) the number of rounds is at most <span class="math">\\mathsf{k}(n)</span>; (2) the proof length is at most <span class="math">\\mathsf{l}(n)</span>; (3) the query complexity is at most <span class="math">\\mathtt{q}(n)</span>; (4) the soundness error is <span class="math">\\varepsilon(n)</span>; (5) the prover algorithm runs in time <span class="math">\\mathtt{tp}(n)</span>; (6) the verifier algorithm runs in time <span class="math">\\mathtt{tv}(n)</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">3.2.2 Interactive oracle proofs</p>

    <p class="text-gray-300">An IOP <em>[x1, x21]</em> is a “multi-round PCP”. That is, an IOP generalizes an interactive proof as follows: whenever the prover sends to the verifier a message, the verifier does not have to read the message in full but may probabilistically query it. In more detail, a <span class="math">k</span>-round IOP comprises <span class="math">k</span> rounds of interaction. In the <span class="math">i</span>-th round of interaction: the verifier sends a message <span class="math">m_{i}</span> to the prover; then the prover replies with a message <span class="math">\\pi_{i}</span> to the verifier, which the verifier can query in this and later rounds (via oracle queries). After the <span class="math">k</span> rounds of interaction, the verifier either accepts or rejects.</p>

    <p class="text-gray-300">An IOP system for a relation <span class="math">\\mathscr{R}</span> with soundness error <span class="math">\\varepsilon</span> is thus a pair <span class="math">(P,V)</span>, where <span class="math">P,V</span> are probabilistic interactive algorithms working as described, that satisfies the following properties. (See <em>[x1]</em> for more details.)</p>

    <p class="text-gray-300">Completeness: For every instance-witness pair <span class="math">(x,w)</span> in the relation <span class="math">\\mathscr{R}</span>, <span class="math">\\Pr[\\langle P(x,w),V(x)\\rangle=1]=1</span>.</p>

    <p class="text-gray-300">Soundness: For every instance <span class="math">x</span> not in <span class="math">\\mathscr{R}</span>’s language and unbounded malicious prover <span class="math">\\tilde{P}</span>, <span class="math">\\Pr[\\langle\\tilde{P},V(x)\\rangle=1]\\leq\\varepsilon(n)</span>.</p>

    <p class="text-gray-300">Beyond round complexity, we also measure how many bits the prover sends and how many the verifier reads: the proof length <span class="math">l</span> is the total number of bits in all of the prover’s messages, and the query complexity <span class="math">q</span> is the total number of bits read by the verifier across all of the prover’s messages. Considering all of these parameters, we say that a relation <span class="math">\\mathscr{R}</span> belongs to the complexity class <span class="math">\\mathbf{IOP}[k,l,q,\\varepsilon,tp,tv]</span> if there is an IOP system for <span class="math">\\mathscr{R}</span> in which: (1) the number of rounds is at most <span class="math">k(n)</span>; (2) the proof length is at most <span class="math">l(n)</span>; (3) the query complexity is at most <span class="math">q(n)</span>; (4) the soundness error is <span class="math">\\varepsilon(n)</span>; (5) the prover algorithm runs in time <span class="math">tp(n)</span>; (6) the verifier algorithm runs in time <span class="math">tv(n)</span>.</p>

    <p class="text-gray-300">IOP vs. IPCP. An IPCP (see Section 3.2.1) is a special case of an IOP because an IPCP verifier must read in full all of the prover’s messages except the first one (while an IOP verifier may query any part of any prover message). The above complexity measures are consistent with those defined for IPCPs.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">3.2.3 Restrictions and extensions</h4>

    <p class="text-gray-300">The definitions below are about IOPs, but IPCPs inherit all of these definitions because they are a special case of IOP.</p>

    <p class="text-gray-300">Adaptivity of queries. An IOP system is non-adaptive if the verifier queries are non-adaptive, i.e., the queried locations depend only on the verifier’s inputs.</p>

    <p class="text-gray-300">Public coins. An IOP system is public coin if each verifier message <span class="math">m_{i}</span> is chosen uniformly and independently at random, and all of the verifier queries happen after receiving the last prover message.</p>

    <p class="text-gray-300">Proximity. An IOP of proximity extends the definition of an IOP in the same way that a PCP of proximity extends that of a PCP <em>[x10, BGH^{+}06]</em>. An IOPP system for a relation <span class="math">\\mathscr{R}</span> with soundness error <span class="math">\\varepsilon</span> and proximity parameter <span class="math">\\delta</span> is a pair <span class="math">(P,V)</span> that satisfies the following properties.</p>

    <p class="text-gray-300">Completeness: For every instance-witness pair <span class="math">(x,w)</span> in the relation <span class="math">\\mathscr{R}</span>, <span class="math">\\Pr[\\langle P(x,w),V^{w}(x)\\rangle=1]=1</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness: For every instance-witness pair <span class="math">(x,w)</span> with $\\Delta(w,\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{x})\\geq\\delta(n)<span class="math"> and unbounded malicious prover </span>\\tilde{P}<span class="math">, </span>\\Pr[\\langle\\tilde{P},V^{w}(x)\\rangle=1]\\leq\\varepsilon(n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similarly to above, a relation <span class="math">\\mathscr{R}</span> belongs to the complexity class <span class="math">\\mathbf{IOPP}[k,l,q,\\varepsilon,\\delta,tp,tv]</span> if there is an IOPP system for <span class="math">\\mathscr{R}</span> with the corresponding parameters. Following <em>[x16]</em>, we call an IOPP exact if <span class="math">\\delta(n)=0</span>.</p>

    <p class="text-gray-300">Promise relations. A promise relation is a relation-language pair <span class="math">(\\mathscr{R}^{res},\\mathscr{L}^{no})</span> with <span class="math">\\mathrm{Lan}(\\mathscr{R}^{res})\\cap\\mathscr{L}^{no}=\\emptyset</span>. An IOP for a promise relation is the same as an IOP for the (standard) relation <span class="math">\\mathscr{R}^{res}</span>, except that soundness need only hold for <span class="math">x\\in\\mathscr{L}^{no}</span>. An IOPP for a promise relation is the same as an IOPP for the (standard) relation <span class="math">\\mathscr{R}^{res}</span>, except that soundness need only hold for <span class="math">x\\in\\mathrm{Lan}(\\mathscr{R}^{res})\\cup\\mathscr{L}^{no}</span>.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">3.2.4 Prior constructions</h4>

    <p class="text-gray-300">In this paper we give new IPCP and IOP constructions that achieve perfect zero knowledge for various settings. Below we summarize known constructions in these two models.</p>

    <p class="text-gray-300">IPCPs. Prior work obtains IPCPs with proof length that depends on the witness size rather than computation size <em>[x20, x13]</em>, and IPCPs with statistical zero knowledge <em>[x12]</em> (see Section 3.3 for more details).</p>

    <p class="text-gray-300">####</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">IOPs.</h4>

    <p class="text-gray-300">Prior work obtains IOPs with perfect zero knowledge for <span class="math">\\mathbf{NP}</span> <em>[x1]</em>, IOPs with small proof length and query complexity <em>[BCG^{+}17]</em>, and an amortization theorem for “unambiguous” IOPs <em>[x22]</em>. Also, <em>[x1]</em> show how to compile public-coin IOPs into non-interactive arguments in the random oracle model.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">3.3 Zero knowledge</h3>

    <p class="text-gray-300">We define the notion of zero knowledge for IOPs and IPCPs achieved by our constructions: <em>unconditional (perfect) zero knowledge via straightline simulators</em>. This notion is quite strong not only because it unconditionally guarantees simulation of the verifier’s view but also because straightline simulation implies desirable properties such as composability. We now provide some context and then give formal definitions.</p>

    <p class="text-gray-300">At a high level, zero knowledge requires that the verifier’s view can be efficiently simulated without the prover. Converting the informal statement into a mathematical one involves many choices, including choosing which verifier class to consider (e.g., the honest verifier? all polynomial-time verifiers?), the quality of the simulation (e.g., is it identically distributed to the view? statistically close to it? computationally close to it?), the simulator’s dependence on the verifier (e.g., is it non-uniform? or is the simulator universal?), and others. The definitions below consider two variants: perfect simulation via universal simulators against either unbounded-query or bounded-query verifiers.</p>

    <p class="text-gray-300">Moreover, in the case of universal simulators, one distinguishes between a non-blackbox use of the verifier, which means that the simulator takes the verifier’s code as input, and a blackbox use of it, which means that the simulator only accesses the verifier via a restricted interface; we consider this latter case. Different models of proof systems call for different interfaces, which grant carefully-chosen “extra powers” to the simulator (in comparison to the prover) so to ensure that efficiency of the simulation does not imply the ability to efficiently decide the language. For example: in ZK IPs, the simulator may rewind the verifier; in ZK PCPs, the simulator may adaptively answer oracle queries. In ZK IPCPs and ZK IOPs (our setting), the natural definition would allow a blackbox simulator to rewind the verifier <em>and also</em> to adaptively answer oracle queries. The definitions below, however, consider only simulators that are straightline <em>[x11, x10]</em>, that is they do not rewind the verifier, because our constructions achieve this stronger notion.</p>

    <p class="text-gray-300">We are now ready to define the notion of unconditional (perfect) zero knowledge via straightline simulators. We first discuss the notion for IOPs, then for IOPs of proximity, and finally for IPCPs.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">3.3.1 ZK for IOPs</h4>

    <p class="text-gray-300">We define zero knowledge (via straightline simulators) for IOPs. We begin by defining the view of an IOP verifier.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">Let <span class="math">A,B</span> be algorithms and <span class="math">x,y</span> strings. We denote by <span class="math">\\mathrm{View}\\ \\left\\langle B(y),A(x)\\right\\rangle</span> the view of <span class="math">A(x)</span> in an interactive oracle protocol with <span class="math">B(y)</span>, i.e., the random variable <span class="math">(x,r,a_{1},\\ldots,a_{n})</span> where <span class="math">x</span> is <span class="math">A</span>’s input, <span class="math">r</span> is <span class="math">A</span>’s randomness, and <span class="math">a_{1},\\ldots,a_{n}</span> are the answers to <span class="math">A</span>’s queries into <span class="math">B</span>’s messages.</p>

    <p class="text-gray-300">Straightline simulators in the context of IPs were used in <em>[x10]</em>, and later defined in <em>[x11]</em>. The definition below considers this notion in the context of IOPs, where the simulator also has to answer oracle queries by the verifier. Note that since we consider the notion of unconditional (perfect) zero knowledge, the definition of straightline simulation needs to allow the efficient simulator to work even with inefficient verifiers <em>[x12]</em>.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 3.3.</h6>

    <p class="text-gray-300">We say that an algorithm <span class="math">B</span> has straightline access to another algorithm <span class="math">A</span> if <span class="math">B</span> interacts with <span class="math">A</span>, without rewinding, by exchanging messages with <span class="math">A</span> and also answering any oracle queries along the way. We denote by <span class="math">B^{A}</span> the concatenation of <span class="math">A</span>’s random tape and <span class="math">B</span>’s output. (Since <span class="math">A</span>’s random tape could be super-polynomially large, <span class="math">B</span> cannot sample it for <span class="math">A</span> and then output it; instead, we restrict <span class="math">B</span> to not see it, and we prepend it to <span class="math">B</span>’s output.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that an algorithm <span class="math">A</span> is <span class="math">\\mathsf{b}</span>-query if, on input <span class="math">\\mathsf{x}</span>, it makes at most $\\mathsf{b}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ queries to any oracles it has access to. We are now ready to define zero knowledge IOPs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 3.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An IOP system <span class="math">(P,V)</span> for a relation <span class="math">\\mathscr{R}</span> is perfect zero knowledge (via straightline simulators) against unbounded queries (resp., against query bound <span class="math">\\mathsf{b}</span>) if there exists a simulator algorithm <span class="math">S</span> such that for every algorithm (resp., <span class="math">\\mathsf{b}</span>-query algorithm) <span class="math">\\tilde{V}</span> and instance-witness pair <span class="math">(\\mathsf{x},\\mathsf{w})\\in\\mathscr{R}</span>, <span class="math">S^{\\tilde{V}}(\\mathsf{x})</span> and <span class="math">\\mathrm{View}\\ \\left\\langle P(\\mathsf{x},\\mathsf{w}),\\tilde{V}(\\mathsf{x})\\right\\rangle</span> are identically distributed. Moreover, <span class="math">S</span> must run in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{q}_{\\tilde{V}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, where </span>\\mathsf{q}_{\\tilde{V}}(\\cdot)<span class="math"> is </span>\\tilde{V}$’s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For zero knowledge against arbitrary polynomial-time adversaries, it suffices for <span class="math">\\mathsf{b}</span> to be superpolynomial. Note that <span class="math">S</span>’s running time need not be polynomial in <span class="math">\\mathsf{b}</span> (in our constructions it is polylogarithmic in <span class="math">\\mathsf{b}</span>); rather its running time may be polynomial in the input size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the <em>actual</em> number of queries </span>\\tilde{V}$ makes (as a random variable).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that a relation <span class="math">\\mathscr{R}</span> belongs to the complexity class <span class="math">\\mathbf{PZK}\\text{-}\\mathbf{IOP}[\\mathsf{k},\\mathsf{l},\\mathsf{q},\\varepsilon,\\mathsf{tp},\\mathsf{tv},\\mathsf{b}]</span> if there is an IOP system for <span class="math">\\mathscr{R}</span>, with the corresponding parameters, that is perfect zero knowledge with query bound <span class="math">\\mathsf{b}</span>; also, it belongs to the complexity class <span class="math">\\mathbf{PZK}\\text{-}\\mathbf{IOP}[\\mathsf{k},\\mathsf{l},\\mathsf{q},\\varepsilon,\\mathsf{tp},\\mathsf{tv},*]</span> if the same is true with unbounded queries.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">3.3.2 ZK for IOPs of proximity</h4>

    <p class="text-gray-300">We define zero knowledge (via straightline simulators) for IOPs of proximity. It is a straightforward extension of the corresponding notion for PCPs of proximity, introduced in <em>[x10]</em>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 3.5.</h6>

    <p class="text-gray-300">An IOPP system <span class="math">(P,V)</span> for a relation <span class="math">\\mathscr{R}</span> is perfect zero knowledge (via straightline simulators) against unbounded queries (resp., against query bound <span class="math">\\mathsf{b}</span>) if there exists a simulator algorithm <span class="math">S</span> such that for every algorithm (resp., <span class="math">\\mathsf{b}</span>-query algorithm) <span class="math">\\tilde{V}</span> and instance-witness pair <span class="math">(\\mathbf{x},\\mathbf{w})\\in\\mathscr{R}</span>, the following two random variables are identically distributed:</p>

    <p class="text-gray-300"><span class="math">\\left(S^{\\tilde{V},\\mathbf{w}}(\\mathbf{x})~{},~{}q_{S}\\right)\\quad\\text{and}\\quad\\left(\\mathrm{View}~{}\\langle P(\\mathbf{x},\\mathbf{w}),\\tilde{V}^{\\mathbf{w}}(\\mathbf{x})\\rangle~{},~{}q_{\\tilde{V}}\\right)~{},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">q_{S}</span> is the number of queries to <span class="math">\\mathbf{w}</span> made by <span class="math">S</span>, and <span class="math">q_{\\tilde{V}}</span> is the number of queries to <span class="math">\\mathbf{w}</span> or to prover messages made by <span class="math">\\tilde{V}</span>. Moreover, <span class="math">S</span> must run in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{q}_{\\tilde{V}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">, where </span>\\mathsf{q}_{\\tilde{V}}(\\cdot)<span class="math"> is </span>\\tilde{V}$’s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that a relation <span class="math">\\mathscr{R}</span> belongs to the complexity class <span class="math">\\mathbf{PZK}\\text{-}\\mathbf{IOPP}[\\mathsf{k},\\mathsf{l},\\mathsf{q},\\varepsilon,\\delta,\\mathsf{tp},\\mathsf{tv},\\mathsf{b}]</span> if there is an IOPP system for <span class="math">\\mathscr{R}</span>, with the corresponding parameters, that is perfect zero knowledge with query bound <span class="math">\\mathsf{b}</span>; also, it belongs to the complexity class <span class="math">\\mathbf{PZK}\\text{-}\\mathbf{IOPP}[\\mathsf{k},\\mathsf{l},\\mathsf{q},\\varepsilon,\\delta,\\mathsf{tp},\\mathsf{tv},*]</span> if the same is true with unbounded queries.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 3.6.</h6>

    <p class="text-gray-300">Analogously to <em>[x10]</em>, our definition of zero knowledge for IOPs of proximity requires that the number of queries to <span class="math">\\mathbf{w}</span> by <span class="math">S</span> equals the total number of queries (to <span class="math">\\mathbf{w}</span> or prover messages) by <span class="math">\\tilde{V}</span>. Stronger notions are possible: “the number of queries to <span class="math">\\mathbf{w}</span> by <span class="math">S</span> equals the number of queries to <span class="math">\\mathbf{w}</span> by <span class="math">\\tilde{V}</span>”; or, even more, “<span class="math">S</span> and <span class="math">\\tilde{V}</span> read the same locations of <span class="math">\\mathbf{w}</span>”. The definition above is sufficient for the applications of IOPs of proximity that we consider.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">3.3.3 ZK for IPCPs</h4>

    <p class="text-gray-300">The definition of perfect zero knowledge (via straightline simulators) for IPCPs follows directly from Definition 3.4 in Section 3.3.1 because IPCPs are a special case of IOPs. Ditto for IPCPs of proximity, whose perfect zero knowledge definition follows directly from Definition 3.5 in Section 3.3.2. (For comparison, <em>[x11]</em> define statistical zero knowledge IPCPs, also with straightline simulators.)</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">3.4 Codes</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An error correcting code <span class="math">C</span> is a set of functions <span class="math">w\\colon D\\to\\Sigma</span>, where <span class="math">D,\\Sigma</span> are finite sets known as the domain and alphabet; we write <span class="math">C\\subseteq\\Sigma^{D}</span>. The message length of <span class="math">C</span> is $k:=\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, its block length is </span>\\ell:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, its rate is </span>\\rho:=k/\\ell<span class="math">, its (minimum) distance is </span>d:=\\min\\{\\Delta(w,z)~{}:~{}w,z\\in C~{},~{}w\\neq z\\}<span class="math"> when </span>\\Delta<span class="math"> is the (absolute) Hamming distance, and its (minimum) relative distance is </span>\\tau:=d/\\ell<span class="math">. At times we write </span>k(C),\\ell(C),\\rho(C),d(C),\\tau(C)$ to make the code under consideration explicit. All the codes we consider are linear codes, discussed next.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Linearity. A code <span class="math">C</span> is <em>linear</em> if <span class="math">\\Sigma</span> is a finite field and <span class="math">C</span> is a <span class="math">\\Sigma</span>-linear space in <span class="math">\\Sigma^{D}</span>. The dual code of <span class="math">C</span> is the set <span class="math">C^{\\perp}</span> of functions <span class="math">z\\colon D\\to\\Sigma</span> such that, for all <span class="math">w\\colon D\\to\\Sigma</span>, <span class="math">\\langle z,w\\rangle:=\\sum_{i\\in D}z(i)w(i)=0</span>. We denote by <span class="math">\\dim(C)</span> the dimension of <span class="math">C</span>; it holds that <span class="math">\\dim(C)+\\dim(C^{\\perp})=\\ell</span> and <span class="math">\\dim(C)=k</span> (dimension equals message length).</p>

    <p class="text-gray-300">Code families. A code family <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}\\in\\{0,1\\}}</span>. has domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span> if each code <span class="math">C_{\\mathfrak{n}}</span> has domain <span class="math">D(\\mathfrak{n})</span> and alphabet <span class="math">\\mathbb{F}(\\mathfrak{n})</span>. Similarly, <span class="math">\\mathscr{C}</span> has message length <span class="math">k(\\cdot)</span>, block length <span class="math">\\ell(\\cdot)</span>, rate <span class="math">\\rho(\\cdot)</span>, distance <span class="math">d(\\cdot)</span>, and relative distance <span class="math">\\tau(\\cdot)</span> if each code <span class="math">C_{\\mathfrak{n}}</span> has message length <span class="math">k(\\mathfrak{n})</span>, block length <span class="math">\\ell(\\mathfrak{n})</span>, rate <span class="math">\\rho(\\mathfrak{n})</span>, distance <span class="math">d(\\mathfrak{n})</span>, and relative distance <span class="math">\\tau(\\mathfrak{n})</span>. We also define <span class="math">\\rho(\\mathscr{C}):=\\inf_{\\mathfrak{n}\\in\\mathbb{N}}\\rho(\\mathfrak{n})</span> and <span class="math">\\tau(\\mathscr{C}):=\\inf_{\\mathfrak{n}\\in\\mathbb{N}}\\tau(\\mathfrak{n})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reed–Solomon codes. The Reed–Solomon (RS) code is the code consisting of evaluations of <em>univariate</em> low-degree polynomials: given a field <span class="math">\\mathbb{F}</span>, subset <span class="math">S</span> of <span class="math">\\mathbb{F}</span>, and positive integer <span class="math">d</span> with $d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we denote by </span>\\mathrm{RS}[\\mathbb{F},S,d]$ the linear</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">code consisting of evaluations <span class="math">w\\colon S\\to \\mathbb{F}</span> over <span class="math">S</span> of polynomials in <span class="math">\\mathbb{F}^{&amp;lt;d}[X]</span>. The code's message length is <span class="math">k = d</span>, block length is $\\ell =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, rate is </span>\\rho = \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and relative distance is </span>\\tau = 1 - \\frac{d - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Reed-Muller codes.</strong> The Reed-Muller (RM) code is the code consisting of evaluations of multivariate low-degree polynomials: given a field <span class="math">\\mathbb{F}</span>, subset <span class="math">S</span> of <span class="math">\\mathbb{F}</span>, and positive integers <span class="math">m, d</span> with $d \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we denote by </span>\\mathrm{RM}[\\mathbb{F}, S, m, d]<span class="math"> the linear code consisting of evaluations </span>w \\colon S^m \\to \\mathbb{F}<span class="math"> over </span>S^m<span class="math"> of polynomials in </span>\\mathbb{F}^{&lt;d}[X_1, \\ldots, X_m]<span class="math"> (i.e., we bound individual degrees rather than their sum). The code&#x27;s message length is </span>k = d^m<span class="math">, block length is </span>\\ell =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^m<span class="math">, rate is </span>\\rho = \\left(\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^m<span class="math">, and relative distance is </span>\\tau = (1 - \\frac{d - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">17</p>

    <p class="text-gray-300">4 Succinct constraint detection</p>

    <p class="text-gray-300">We introduce the notion of <em>succinct constraint detection</em> for linear codes. This notion plays a crucial role in constructing perfect zero knowledge simulators for super-polynomial complexity classes (such as <span class="math">\\#\\mathbf{P}</span> and <span class="math">\\mathbf{NEXP}</span>), but we believe that this naturally-defined notion is also of independent interest. Given a linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> we refer to its dual code <span class="math">C^{\\perp}\\subseteq\\mathbb{F}^{D}</span> as the <em>constraint space</em> of <span class="math">C</span>. The <em>constraint detection problem</em> corresponding to a family of linear codes <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span> is the following:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Given an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, output a basis for <span class="math">\\{z\\in D(\\mathfrak{n})^{I}:\\ \\forall\\,w\\in C_{\\mathfrak{n}}\\,,\\,\\sum_{i\\in I}z(i)w(i)=0\\}</span>.</p>
    </blockquote>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and a generating matrix for </span>C_{\\mathfrak{n}}<span class="math"> can be found in polynomial time, this problem can be solved in </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time via Gaussian elimination; such an approach was implicitly taken by <em>[x1]</em> to construct a perfect zero knowledge simulator for an IOP for </span>\\mathbf{NP}<span class="math">. However, in our setting, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is <em>exponential</em> in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and the aforementioned generic solution requires exponential time. With this in mind, we say </span>\\mathscr{C}<span class="math"> has <em>succinct constraint detection</em> if there exists an algorithm that solves the constraint detection problem in </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time when </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is <em>exponential</em> in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. After defining succinct constraint detection in Section 4.1, we proceed as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Section 4.2, we construct a succinct constraint detector for the family of linear codes comprised of evaluations of partial sums of low-degree polynomials. The construction of the detector exploits derandomization techniques from algebraic complexity theory. Later on (in Section 5), we leverage this result to construct a perfect zero knowledge simulator for an IPCP for <span class="math">\\#\\mathbf{P}</span>.</li>

      <li>In Section 4.3, we construct a succinct constraint detector for the family of evaluations of univariate polynomials concatenated with corresponding BS proximity proofs <em>[x10]</em>. The construction of the detector exploits the recursive structure of these proximity proofs. Later on (in Section 8), we leverage this result to construct a perfect zero knowledge simulator for an IOP for <span class="math">\\mathbf{NEXP}</span>; this simulator can be interpreted as an analogue of <em>[x1]</em>’s simulator that runs <em>exponentially faster</em> and thus enables us to “scale up” from <span class="math">\\mathbf{NP}</span> to <span class="math">\\mathbf{NEXP}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout this section we assume familiarity with terminology and notation about codes, introduced in Section 3.4. We assume for simplicity that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the number of bits used to represent </span>\\mathfrak{n}<span class="math">, is at least </span>\\log D(\\mathfrak{n})+\\log\\mathbb{F}(\\mathfrak{n})<span class="math">; if this does not hold, then one can replace </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log D(\\mathfrak{n})+\\log\\mathbb{F}(\\mathfrak{n})$ throughout the section.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 4.1 (sparse representation).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we make statements about vectors <span class="math">v</span> in <span class="math">\\mathbb{F}^{D}</span> where the cardinality of the domain <span class="math">D</span> may be super-polynomial. When such statements are computational in nature, we assume that <span class="math">v</span> is not represented as a list of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> field elements (which requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> bits) but, instead, assume that </span>v<span class="math"> is represented as a list of the elements in </span>\\mathrm{supp}(v)<span class="math"> (and each element comes with its index in </span>D<span class="math">); this <em>sparse</em> representation only requires </span>\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{supp}(v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">4.1 Definition of succinct constraint detection</h3>

    <p class="text-gray-300">Formally define the notion of a <em>constraint detector</em>, and the notion of <em>succinct constraint detection</em>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. A <em>constraint detector</em> for <span class="math">\\mathscr{C}</span> is an algorithm that, on input an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs a basis for the space</p>

    <p class="text-gray-300"><span class="math">\\left\\{z\\in D(\\mathfrak{n})^{I}:\\,\\forall\\,w\\in C_{\\mathfrak{n}}\\,,\\,\\sum_{i\\in I}z(i)w(i)\\right\\}\\ .</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">\\mathscr{C}</span> has <span class="math">T(\\cdot,\\cdot)</span>-time constraint detection if there exists a detector for <span class="math">\\mathscr{C}</span> running in time <span class="math">T(\\mathfrak{n},\\ell)</span>; we also say that <span class="math">\\mathscr{C}</span> has <em>succinct constraint detection</em> if it has $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)$-time constraint detection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A constraint detector induces a corresponding probabilistic algorithm for ‘simulating’ answers to queries to a random codeword; this is captured by the following lemma, the proof of which is in Appendix B. We shall use such probabilistic algorithms in the construction of perfect zero knowledge simulators (see Section 5 and Section 8).</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Lemma 4.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span> that has <span class="math">T(\\cdot,\\cdot)</span>-time constraint detection. Then there exists a probabilistic algorithm <span class="math">\\mathcal{A}</span> such that, for every index <span class="math">\\mathfrak{n}</span>, set of pairs <span class="math">S=\\{(\\alpha_{1},\\beta_{1}),\\ldots,(\\alpha_{\\ell},\\beta_{\\ell})\\}\\subseteq D(\\mathfrak{n})\\times\\mathbb{F}(\\mathfrak{n})</span>, and pair <span class="math">(\\alpha,\\beta)\\in D(\\mathfrak{n})\\times\\mathbb{F}(\\mathfrak{n})</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\mathcal{A}(\\mathfrak{n},S,\\alpha)=\\beta\\right]=\\Pr_{w\\leftarrow C_{\\mathfrak{n}}}\\left[w(\\alpha)=\\beta\\begin{array}[]{c}w(\\alpha_{1})=\\beta_{1}\\\\ \\vdots\\\\ w(\\alpha_{\\ell})=\\beta_{\\ell}\\end{array}\\right]\\enspace. \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover <span class="math">\\mathcal{A}</span> runs in time $T(\\mathfrak{n},\\ell)+\\operatorname{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the purposes of constructing a constraint detector, the sufficient condition given in Lemma 4.6 below is sometimes easier to work with. To state it we need to introduce two ways of restricting a code, and explain how these restrictions interact with taking duals; the interplay between these is delicate (see Remark 4.7).</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a linear code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> and a subset <span class="math">I\\subseteq D</span>, we denote by (i) <span class="math">C_{\\subseteq I}</span> the set consisting of the codewords <span class="math">w\\in C</span> for which <span class="math">\\operatorname{supp}(w)\\subseteq I</span>, and (ii) $C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> the restriction to </span>I<span class="math"> of codewords </span>w\\in C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">C_{\\subseteq I}</span> and $C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> are different notions. Consider for example the </span>1<span class="math">-dimensional linear code </span>C=\\{00,11\\}<span class="math"> in </span>\\mathbb{F}_{2}^{\\{1,2\\}}<span class="math"> and the subset </span>I=\\{1\\}<span class="math">: it holds that </span>C_{\\subseteq I}=\\{00\\}<span class="math"> and </span>C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}=\\{0,1\\}<span class="math">. In particular, codewords in </span>C_{\\subseteq I}<span class="math"> are defined over </span>D<span class="math">, while codewords in </span>C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> are defined over </span>I<span class="math">. Nevertheless, throughout this section, we sometimes compare vectors defined over different domains, with the implicit understanding that the comparison is conducted over the union of the relevant domains, by filling in zeros in the vectors’ undefined coordinates. For example, we may write </span>C_{\\subseteq I}\\subseteq C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> to mean that </span>\\{00\\}\\subseteq\\{00,10\\}<span class="math"> (the set obtained from </span>\\{0,1\\}$ after filling in the relevant zeros).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-62" class="text-base font-medium mt-4">Claim 4.5.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>. For every <span class="math">I\\subseteq D</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I})^{\\perp}=(C^{\\perp})_{\\subseteq I}\\enspace,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">that is,</p>

    <p class="text-gray-300"><span class="math">\\left\\{z\\in D(\\mathfrak{n})^{I}:\\,\\forall\\,w\\in C_{\\mathfrak{n}}\\,,\\sum_{i\\in I}z(i)w(i)\\right\\}=\\left\\{z\\in C_{\\mathfrak{n}}^{\\perp}:\\operatorname{supp}(z)\\subseteq I\\right\\}\\enspace.</span></p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the containment $(C^{\\perp})_{\\subseteq I}\\subseteq(C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I})^{\\perp}<span class="math">: if </span>z\\in C^{\\perp}<span class="math"> and </span>\\operatorname{supp}(z)\\subseteq I<span class="math"> then </span>z<span class="math"> lies in the dual of </span>C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math"> because it suffices to consider the subdomain </span>I<span class="math"> for determining duality. For the reverse containment </span>(C^{\\perp})_{\\subseteq I}\\supseteq(C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I})^{\\perp}<span class="math">: if </span>z\\in(C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I})^{\\perp}<span class="math"> then </span>\\operatorname{supp}(z)\\subseteq I<span class="math"> (by definition) so that </span>\\langle z,w\\rangle=\\langle z,w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}\\rangle<span class="math"> for every </span>w\\in C<span class="math">, and the latter inner product equals </span>0<span class="math"> because </span>z<span class="math"> is in the dual of </span>C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I}<span class="math">; in sum </span>z<span class="math"> is dual to (all codewords in) </span>C<span class="math"> and its support is contained in </span>I<span class="math">, so </span>z<span class="math"> belongs to </span>(C^{\\perp})_{\\subseteq I}$, as claimed. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that Claim 4.5 tells us the constraint detection is equivalent to determining a basis of $(C_{\\mathfrak{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I})^{\\perp}=(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}<span class="math">. The following lemma asserts that if, given a subset </span>I\\subseteq D<span class="math">, we can find a set of constraints </span>W<span class="math"> in </span>C^{\\perp}<span class="math"> that spans </span>(C^{\\perp})_{\\subseteq I}<span class="math"> then we can solve the constraint detection problem for </span>C$; we defer the proof of the lemma to Appendix C.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 4.6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. If there exists an algorithm that, on input an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs in $\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time a subset </span>W\\subseteq\\mathbb{F}(\\mathfrak{n})^{D(\\mathfrak{n})}<span class="math"> (in sparse representation) with </span>(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}\\subseteq\\operatorname{span}(W)\\subseteq C_{\\mathfrak{n}}^{\\perp}<span class="math">, then </span>\\mathscr{C}$ has succinct constraint detection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 4.7.</h6>

    <p class="text-gray-300">The following operations do not commute: (i) expanding the domain via zero padding (for the purpose of comparing vectors over different domains), and (ii) taking the dual of the code. Consider for example the code <span class="math">C=\\{0\\}\\subseteq\\mathbb{F}_{2}^{\\{1\\}}</span>: its dual code is <span class="math">C^{\\perp}=\\{0,1\\}</span> and, when expanded to <span class="math">\\mathbb{F}_{2}^{\\{1,2\\}}</span>, the dual code is expanded to <span class="math">\\{(0,0),(1,0)\\}</span>; yet, when <span class="math">C</span> is expanded to <span class="math">\\mathbb{F}_{2}^{\\{1,2\\}}</span> it produces the code <span class="math">\\{(0,0)\\}</span> and its dual code is <span class="math">\\{(0,0),(1,0),(0,1),(1,1)\\}</span>. To resolve ambiguities (when asserting an equality as in Claim 4.5), we adopt the convention that expansion is done always last (namely, as late as possible without having to compare vectors over different domains).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that evaluations of partial sums of low-degree polynomials have succinct constraint detection (see Definition 4.2). In the following,  <span class="math">\\mathbb{F}</span>  is a finite field,  <span class="math">m,d</span>  are positive integers, and  <span class="math">H</span>  is a subset of  <span class="math">\\mathbb{F}</span> ; also,  <span class="math">\\mathbb{F}^{&amp;lt;d}[X_1,\\ldots ,X_m]</span>  denotes the subspace of  <span class="math">\\mathbb{F}[X_1,\\ldots ,X_m]</span>  consisting of those polynomials with individual degrees less than  <span class="math">d</span> . Moreover, given  <span class="math">Q\\in \\mathbb{F}^{&amp;lt;d}[X_1,\\ldots ,X_m]</span>  and  <span class="math">\\vec{\\alpha}\\in \\mathbb{F}^{\\leq m}</span>  (vectors over  <span class="math">\\mathbb{F}</span>  of length at most  <span class="math">m</span> ), we define  $Q(\\vec{\\alpha}):= \\sum_{\\vec{\\gamma}\\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}Q(\\vec{\\alpha},\\vec{\\gamma})<span class="math"> , i.e., the answer to a query that specifies only a suffix of the variables is the sum of the values obtained by letting the remaining variables range over  </span>H$ . We begin by defining the code that we study, which extends the Reed-Muller code (see Section 3.4) with partial sums.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 4.8. We denote by  <span class="math">\\Sigma \\mathrm{RM}[\\mathbb{F},m,d,H]</span>  the linear code that comprises evaluations of partial sums of polynomials in  <span class="math">\\mathbb{F}^{&amp;lt; d}[X_1,\\ldots ,X_m]</span> ; more precisely,  <span class="math">\\Sigma \\mathrm{RM}[\\mathbb{F},m,d,H]:= \\{w_Q\\}_{Q\\in \\mathbb{F}^{&amp;lt; d}[X_1,\\ldots ,X_m]}</span>  where  <span class="math">w_{Q}\\colon \\mathbb{F}^{\\leq m}\\to \\mathbb{F}</span>  is the function defined by  $w_{Q}(\\vec{\\alpha}):= \\sum_{\\vec{\\gamma}\\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}Q(\\vec{\\alpha},\\vec{\\gamma})<span class="math">  for each  </span>\\vec{\\alpha}\\in \\mathbb{F}^{\\leq m}<span class="math"> . We denote by  </span>\\Sigma \\mathrm{RM}<span class="math">  the linear code family indexed by tuples  </span>\\mathfrak{n} = (\\mathbb{F},m,d,H)<span class="math">  and where the  </span>\\mathfrak{n}<span class="math"> -th code equals  </span>\\Sigma \\mathrm{RM}[\\mathbb{F},m,d,H]<span class="math"> . (We represent indices  </span>\\mathfrak{n}<span class="math">  so to ensure that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta (\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We prove that the linear code family  <span class="math">\\Sigma \\mathrm{RM}</span>  has succinct constraint detection:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 4.9 (formal statement of 1.5).  <span class="math">\\Sigma \\mathrm{RM}</span>  has  $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell)$ -time constraint detection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combined with Lemma 4.3, the theorem above implies that there exists a probabilistic polynomial-time algorithm for answering queries to a codeword sampled at random from  <span class="math">\\Sigma \\mathrm{RM}</span> , as captured by the following corollary.</p>

    <p class="text-gray-300">Corollary 4.10. There exists a probabilistic algorithm  <span class="math">\\mathcal{A}</span>  such that, for every finite field  <span class="math">\\mathbb{F}</span> , positive integers  <span class="math">m, d</span> , subset  <span class="math">H</span>  of  <span class="math">\\mathbb{F}</span> , subset  <span class="math">S = \\{(\\alpha_1, \\beta_1), \\ldots, (\\alpha_\\ell, \\beta_\\ell)\\} \\subseteq \\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span> , and  <span class="math">(\\alpha, \\beta) \\in \\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\mathcal {A} (\\mathbb {F}, m, d, H, S, \\alpha) = \\beta \\right] = \\operatorname * {P r} _ {R \\leftarrow \\mathbb {F} ^ {&amp;lt;   d} [ X _ {1}, \\ldots , X _ {m} ]} \\left[ \\begin{array}{c c} R (\\alpha) = \\beta &amp;amp; R (\\alpha_ {1}) = \\beta_ {1} \\\\ &amp;amp; \\vdots \\\\ &amp;amp; R (\\alpha_ {\\ell}) = \\beta_ {\\ell} \\end{array} \\right]  .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover  <span class="math">\\mathcal{A}</span>  runs in time  $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We sketch the proof of Theorem 4.9, for the simpler case where the code is  <span class="math">\\mathrm{RM}[\\mathbb{F},m,d,H]</span>  (i.e., without partial sums). We can view a polynomial  <span class="math">Q\\in \\mathbb{F}^{&amp;lt; d}[X_1,\\ldots ,X_m]</span>  as a vector over the monomial basis, with an entry for each possible monomial  <span class="math">X_{1}^{i_{1}}\\ldots X_{m}^{i_{m}}</span>  (with  <span class="math">0\\leq i_1,\\dots ,i_m &amp;lt; d</span> ) containing the corresponding coefficient. The evaluation of  <span class="math">Q</span>  at a point  <span class="math">\\vec{\\alpha}\\in \\mathbb{F}^m</span>  then equals the inner product of this vector with the vector  <span class="math">\\phi_{\\vec{\\alpha}}</span> , in the same basis, whose entry for  <span class="math">X_{1}^{i_{1}}\\ldots X_{m}^{i_{m}}</span>  is equal to  <span class="math">\\alpha_{1}^{i_{1}}\\ldots \\alpha_{m}^{i_{m}}</span> . Given  <span class="math">\\vec{\\alpha}_1,\\dots ,\\vec{\\alpha}_\\ell</span> , we could use Gaussian elimination on  <span class="math">\\phi_{\\vec{\\alpha}_1},\\dots ,\\phi_{\\vec{\\alpha}_\\ell}</span>  to check for linear dependencies, which would be equivalent to constraint detection for  <span class="math">\\mathrm{RM}[\\mathbb{F},m,d,H]</span> .</p>

    <p class="text-gray-300">However, we cannot afford to explicitly write down  <span class="math">\\phi_{\\vec{\\alpha}}</span> , because it has  <span class="math">d^{m}</span>  entries. Nevertheless, we can still implicitly check for linear dependencies, and we do so by reducing the problem, by building on and extending ideas of [BW04], to computing the nullspace of a certain set of polynomials, which can be solved via an algorithm of [RS05] (see also [Kay10]). The idea is to encode the entries of these vectors via a succinct description: a polynomial  <span class="math">\\Phi_{\\vec{\\alpha}}</span>  whose coefficients (after expansion) are the entries of  <span class="math">\\phi_{\\vec{\\alpha}}</span> . In our setting this polynomial has the particularly natural form:</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi_ {\\vec {\\alpha}} (\\vec {X}) := \\prod_ {i = 1} ^ {m} (1 + \\alpha_ {i} X _ {i} + \\alpha_ {i} ^ {2} X _ {i} ^ {2} + \\dots + \\alpha_ {i} ^ {d - 1} X _ {i} ^ {d - 1}) ;</span></div>

    <p class="text-gray-300">note that the coefficient of each monomial equals its corresponding entry in  <span class="math">\\phi_{\\vec{\\alpha}}</span> . Given this representation we can use standard polynomial identity testing techniques to find linear dependencies between these polynomials, which corresponds to linear dependencies between the original vectors. Crucially, we cannot afford any mistake, even with exponentially small probability, when looking for linear dependencies for otherwise we would not achieve perfect simulation; this is why the techniques we leverage rely on derandomization. We now proceed with the full proof.</p>

    <p class="text-gray-300">Proof of Theorem 4.9. We first introduce some notation. Define <span class="math">[&amp;lt;d]:=\\{0,\\ldots,d-1\\}</span>. For vectors <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> and <span class="math">\\vec{a} \\in [&amp;lt;d]^m</span>, we define <span class="math">\\vec{\\alpha}^\\vec{\\alpha} := \\prod_{i=1}^m \\alpha_i^{a_i}</span>; similarly, for variables <span class="math">\\vec{X} = (X_1,\\dots,X_m)</span>, we define <span class="math">\\vec{X}^\\vec{\\alpha} := \\prod_{i=1}^m X_i^{a_i}</span>.</p>

    <p class="text-gray-300">We identify <span class="math">\\Sigma \\mathrm{RM}[\\mathbb{F}, m, d, H]</span> with <span class="math">\\mathbb{F}^{[&lt;d]^m}</span>; a codeword <span class="math">w_Q</span> then corresponds to a vector <span class="math">\\vec{Q}</span> whose <span class="math">\\vec{a}</span>-th entry is the coefficient of the monomial <span class="math">\\vec{X}^{\\vec{a}}</span> in <span class="math">Q</span>. For <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^{\\leq m}</span>, let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\phi_{\\vec{\\alpha}} := \\left(\\vec{\\alpha}^{\\vec{a}} \\sum_{\\vec{\\gamma} \\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\vec{\\gamma}^{\\vec{b}}\\right)_{\\vec{a} \\in [&lt;d]^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\vec{b} \\in [&lt;d]^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We can also view <span class="math">\\phi_{\\vec{\\alpha}}</span> as a vector in <span class="math">\\mathbb{F}^{[&lt;d]^m}</span> by merging the indices, so that, for all <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^{\\leq m}</span> and <span class="math">w_Q \\in \\Sigma \\mathrm{RM}[\\mathbb{F}, m, d, H]</span>,</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_Q(\\vec{\\alpha}) &amp;= \\sum_{\\vec{\\gamma} \\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} Q(\\vec{\\alpha}, \\vec{\\gamma}) = \\sum_{\\vec{\\gamma} \\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\sum_{\\vec{a} \\in [&lt;d]^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\sum_{\\vec{b} \\in [&lt;d]^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\vec{Q}_{\\vec{a}, \\vec{b}} \\cdot \\vec{\\alpha}^{\\vec{\\alpha}} \\vec{\\gamma}^{\\vec{b}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">Hence for every <span class="math">\\vec{\\alpha}_1, \\ldots, \\vec{\\alpha}_\\ell, \\vec{\\alpha} \\in \\mathbb{F}^{\\leq m}</span> and <span class="math">a_1, \\ldots, a_\\ell \\in \\mathbb{F}</span>, the following statements are equivalent (i) <span class="math">w(\\vec{\\alpha}) = \\sum_{i=1}^\\ell a_i w(\\vec{\\alpha}_i)</span> for all <span class="math">w \\in \\Sigma \\mathrm{RM}[\\mathbb{F}, m, d, H]</span>; (ii) <span class="math">\\langle \\vec{f}, \\phi_{\\vec{\\alpha}} \\rangle = \\sum_{i=1}^\\ell a_i \\langle \\vec{f}, \\phi_{\\vec{\\alpha}_i} \\rangle</span> for all <span class="math">\\vec{f} \\in \\mathbb{F}^{[&lt;d]^m}</span> (iii) <span class="math">\\phi_{\\vec{\\alpha}} = \\sum_{i=1}^\\ell a_i \\phi_{\\vec{\\alpha}_i}</span>. We deduce that constraint detection for <span class="math">\\Sigma \\mathrm{RM}[\\mathbb{F}, m, d, H]</span> is equivalent to the problem of finding <span class="math">a_1, \\ldots, a_\\ell \\in \\mathbb{F}</span> such that <span class="math">\\phi_{\\vec{\\alpha}} = \\sum_{i=1}^\\ell a_i \\phi_{\\vec{\\alpha}_i}</span>, or returning 'independent' if no such <span class="math">a_1, \\ldots, a_\\ell</span> exist.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, the dimension of the latter vectors is <span class="math">d^m</span>, which may be much larger than $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell)<span class="math">, and so we cannot afford to &quot;explicitly&quot; solve the </span>\\ell \\times d^m<span class="math"> linear system. Instead, we &quot;succinctly&quot; solve it, by taking advantage of the special structure of the vectors, as we now describe. For </span>\\vec{\\alpha} \\in \\mathbb{F}^m$, define the polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Phi_{\\vec{\\alpha}}(\\vec{X}) := \\prod_{i=1}^m (1 + \\alpha_i X_i + \\alpha_i^2 X_i^2 + \\dots + \\alpha_i^{d-1} X_i^{d-1}).</span></div>

    <p class="text-gray-300">Note that, while the above polynomial is computable via a small arithmetic circuit, its coefficients (once expanded over the monomial basis) correspond to the entries of the vector <span class="math">\\phi_{\\vec{\\alpha}}</span>. More generally, for <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^{\\leq m}</span>, we define the polynomial</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\vec{\\alpha}}(\\vec{X}) := \\left(\\prod_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} (1 + \\alpha_i X_i + \\dots + \\alpha_i^{d-1} X_i^{d-1})\\right) \\left(\\prod_{i=1}^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{\\gamma \\in H} (1 + \\gamma X_{i+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\dots + \\gamma^{d-1} X_{i+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{d-1})\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that <span class="math">\\Phi_{\\vec{\\alpha}}</span> is a product of univariate polynomials. To see that the above does indeed represent <span class="math">\\phi_{\\vec{\\alpha}}</span>, we rearrange the expression as follows:</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{\\vec{\\alpha}}(\\vec{X}) &amp;= \\left(\\prod_{i=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} (1 + \\alpha_i X_i + \\dots + \\alpha_i^{d-1} X_i^{d-1})\\right) \\left(\\sum_{\\vec{\\gamma} \\in H^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\prod_{i=1}^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} (1 + \\gamma_i X_{i+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\dots + \\gamma_i^{d-1} X_{i+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{d-1})\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indeed, the coefficient of <span class="math">\\vec{X}^{\\vec{a},\\vec{b}}</span> for $\\vec{a} \\in [&lt;d]^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> and </span>\\vec{b} \\in [&lt;d]^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> is </span>\\vec{\\alpha}^{\\vec{a}} \\sum_{\\vec{\\gamma} \\in H^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}} \\vec{\\gamma}^{\\vec{b}}$, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, to determine whether <span class="math">\\phi_{\\alpha} \\in \\mathrm{span}(\\phi_{\\alpha_1}, \\ldots, \\phi_{\\alpha_\\ell})</span>, it suffices to determine whether <span class="math">\\Phi_{\\alpha} \\in \\mathrm{span}(\\Phi_{\\alpha_1}, \\ldots, \\Phi_{\\alpha_\\ell})</span>. In fact, the linear dependencies are in correspondence: for <span class="math">a_1, \\ldots, a_\\ell \\in \\mathbb{F}</span>, <span class="math">\\phi_{\\alpha} = \\sum_{i=1}^\\ell a_i \\phi_{\\alpha_i}</span> if and only if <span class="math">\\Phi_{\\alpha} = \\sum_{i=1}^\\ell a_i \\Phi_{\\alpha_i}</span>. Crucially, each <span class="math">\\Phi_{\\alpha_i}</span> is not only in <span class="math">\\mathbb{F}^{&lt;d}[x_1, \\ldots,=&quot;&quot; x_m]</span>="" but="" by="" can="" carthmetic="" circuit="" do="" each="" each}="" for="" however,="" is="" it="" knowledge,="" l^m)$,="" of="" only="" or="" poly(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d)<span class="math">.=&quot;&quot; polynomials=&quot;&quot; proved=&quot;&quot; related=&quot;&quot; relying=&quot;&quot; solve=&quot;&quot; the=&quot;&quot; this=&quot;&quot; to=&quot;&quot; we=&quot;&quot; with=&quot;&quot; }=&quot;&quot; })</span>="" })<span class="math">=&quot;&quot; })</span>;="">^7$ for completeness, we provide an elementary proof of the lemma in Appendix D.</d}[x_1,></d^m[{\\vec{\\alpha}}]^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 4.11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a deterministic algorithm <span class="math">\\mathcal{D}</span> such that, on input a vector of <span class="math">m</span>-variate polynomials <span class="math">\\vec{Q}=(Q_{1},\\ldots,Q_{\\ell})</span> over <span class="math">\\mathbb{F}</span> where each polynomial has the form <span class="math">Q_{k}(\\vec{X})=\\prod_{i=1}^{m}Q_{k,i}(X_{i})</span> and each <span class="math">Q_{k,i}</span> is univariate of degree less than <span class="math">d</span> with $d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and represented via an </span>\\mathbb{F}<span class="math">-arithmetic circuit of size </span>s<span class="math">, outputs a basis for the linear space </span>\\vec{Q}^{\\perp}:=\\{(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{F}^{\\ell}:\\sum_{k=1}^{\\ell}a_{k}Q_{k}\\equiv 0\\}<span class="math">. Moreover, </span>\\mathcal{D}<span class="math"> runs in </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+s+\\ell)$ time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above lemma immediately provides a way to construct a constraint detector for <span class="math">\\Sigma\\mathrm{RM}</span>: given as input an index <span class="math">\\mathfrak{n}=(\\mathbb{F},m,d,H)</span> and a subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, we construct the arithmetic circuit <span class="math">\\Phi_{\\alpha}</span> for each <span class="math">\\alpha\\in I</span>, and then run the algorithm <span class="math">\\mathcal{D}</span> on vector of circuits <span class="math">(\\Phi_{\\alpha})_{\\alpha\\in I}</span>, and directly output <span class="math">\\mathcal{D}</span>’s result. The lemma follows. ∎</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">4.3 Univariate polynomials with BS proximity proofs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that evaluations of univariate polynomials concatenated with corresponding BS proximity proofs <em>[x1]</em> have succinct constraint detection (see Definition 4.2). Recall that the Reed–Solomon code (see Section 3.4) is not locally testable, but one can test proximity to it with the aid of the quasilinear-size proximity proofs of Ben-Sasson and Sudan <em>[x1]</em>. These latter apply when low-degree univariate polynomials are evaluated over <em>linear spaces</em>, so from now on we restrict our attention to Reed–Solomon codes of this form. More precisely, we consider Reed–Solomon codes <span class="math">\\mathrm{RS}[\\mathbb{F},L,d]</span> where <span class="math">\\mathbb{F}</span> is an extension field of a base field <span class="math">\\mathbb{K}</span>, <span class="math">L</span> is a <span class="math">\\mathbb{K}</span>-linear subspace in <span class="math">\\mathbb{F}</span>, and $d=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu}<span class="math"> for some </span>\\mu\\in\\mathbb{N}^{+}<span class="math">. We then denote by </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]<span class="math"> the code obtained by concatenating codewords in </span>\\mathrm{RS}[\\mathbb{F},L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu}]<span class="math"> with corresponding BS proximity proofs whose recursion terminates at “base dimension” </span>k\\in\\{1,\\ldots,\\dim(L)\\}<span class="math"> (for completeness we include a formal definition of these in Appendix F); typically </span>\\mathbb{K},\\mu,k<span class="math"> are fixed to certain constants (e.g., <em>[x1]</em> fixes them to </span>\\mathbb{F}_{2},3,1<span class="math">, respectively) but below we state the cost of constraint detection in full generality. The linear code family </span>\\mathrm{BS}\\text{-}\\mathrm{RS}<span class="math"> is indexed by tuples </span>\\mathfrak{n}=(\\mathbb{K},\\mathbb{F},L,\\mu,k)<span class="math"> and the </span>\\mathfrak{n}<span class="math">-th code is </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]<span class="math">, and our result about </span>\\mathrm{BS}\\text{-}\\mathrm{RS}$ is the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 4.12 (formal statement of 1.7).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}+\\ell)$-time constraint detection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of the above theorem is technically involved, and we present it via several steps, as follows. (1) In Section 4.3.1 we introduce the notion of a <em>code cover</em> and two key combinatorial properties of these: <em><span class="math">\\kappa</span>-locality</em> and <em><span class="math">\\kappa</span>-independence</em>. (2) In Section 4.3.2 we introduce the notion of a <em>recursive</em> code cover and relate its combinatorial properties to those of (standard) code covers. (3) In Section 4.3.3 we show how to construct succinct constraint detectors starting from algorithms that detect constraints only ‘locally’ for code covers and recursive code covers. (4) In Section 4.3.4 we show that <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has a recursive code cover with the requisite properties and thus implies, via the results of prior steps, a succinct constraint detector, as claimed. Several sub-proofs are deferred to the appendices, and we provide pointers to these along the way.</p>

    <p class="text-gray-300">The role of code covers. We are interested in succinct constraint detection: solving the constraint detection problem for certain code families with exponentially-large domains (such as <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span>). We now build some intuition about how code covers can, in some cases, facilitate this.</p>

    <p class="text-gray-300">Consider the simple case where the code <span class="math">C\\subseteq\\mathbb{F}^{D}</span> is a direct sum of many small codes: there exists <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> such that <span class="math">D=\\cup_{j}\\tilde{D}_{j}</span> and <span class="math">C=\\oplus_{j}\\tilde{C}_{j}</span> where, for each <span class="math">j</span>, <span class="math">\\tilde{C}_{j}</span> is a linear code in <span class="math">\\mathbb{F}^{\\tilde{D}_{j}}</span> and the subdomain <span class="math">\\tilde{D}_{j}</span> is small and disjoint from other subdomains. The detection problem for this case can be solved efficiently: use the generic approach of Gaussian elimination independently on each subdomain <span class="math">\\tilde{D}_{j}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next consider a more general case where the subdomains are not necessarily disjoint: there exists <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> as above but we do not require that the <span class="math">\\tilde{D}_{j}</span> form a partition of <span class="math">D</span>; we say that each <span class="math">(\\tilde{D}_{j},\\tilde{C}_{j})</span> is a <em>local view</em> of <span class="math">C</span> because <span class="math">\\tilde{D}_{j}\\subseteq D</span> and $\\tilde{C}_{j}=C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{j}}<span class="math">, and we say that </span>S<span class="math"> is a <em>code cover</em> of </span>C<span class="math">. Now suppose that for each </span>j<span class="math"> there exists an efficient constraint detector for </span>\\tilde{C}_{j}<span class="math"> (which is defined on </span>\\tilde{D}_{j}<span class="math">); in this case, the detection problem can be solved efficiently at least for those subsets </span>I<span class="math"> that are contained in </span>\\tilde{D}_{j}<span class="math"> for some </span>j<span class="math">. Generalizing further, we see that we can efficiently solve constraint detection for a code </span>C<span class="math"> if there is a cover </span>S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}<span class="math"> such that, given a subset </span>I\\subseteq D<span class="math">, (i) </span>I<span class="math"> is contained in some subdomain </span>\\tilde{D}_{j}<span class="math">, and (ii) constraint detection for </span>\\tilde{C}_{j}$ can be solved efficiently.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We build on the above ideas to derive analogous statements for recursive code covers, which arise naturally in the case of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span>. But note that recursive constructions are common in the PCP literature, and we believe that our cover-based techniques are of independent interest as, e.g., they are applicable to <em>other</em> PCPs, including <em>[x2, x1]</em>.</p>

    <p class="text-gray-300">4.3.1 Covering codes with local views</p>

    <p class="text-gray-300">The purpose of this section is to formally define the notion of cover and certain combinatorial properties of these.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 4.13.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>. A (local) view of <span class="math">C</span> is a pair <span class="math">(\\tilde{D},\\tilde{C})</span> such that <span class="math">\\tilde{D}\\subseteq D</span> and $C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}}=\\tilde{C}<span class="math">. A cover of </span>C<span class="math"> is a set of local views </span>S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}<span class="math"> of </span>C<span class="math"> such that </span>D=\\cup_{j}\\tilde{D}_{j}<span class="math">. Also, we define a cover’s domain intersection as </span>\\mathrm{di}(S):=\\cup_{i\\neq j}(\\tilde{D}_{i}\\cap\\tilde{D}_{j})<span class="math"> and, given a set </span>J<span class="math">, we define </span>\\tilde{D}_{J}:=\\cup_{j\\in J}\\tilde{D}_{j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-71" class="text-base font-medium mt-4">Example 4.14 (line cover of <span class="math">\\mathrm{RM}</span>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose for instance that <span class="math">C</span> is the Reed–Muller code <span class="math">\\mathrm{RM}[\\mathbb{F},\\mathbb{F},m,d]</span>: <span class="math">C</span> consists of evaluations over <span class="math">D=\\mathbb{F}^{m}</span> of polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> (see Definition 3.4). A cover of <span class="math">C</span> that is extensively studied in the PCP and property-testing literature is the one given by (axis-parallel) <em>lines</em>. A line (in the <span class="math">i</span>-th direction) is a set of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> points that agree on all but one coordinate (the </span>i<span class="math">-th one); and the <em>line cover</em> of </span>C<span class="math"> is thus </span>S=\\{(\\tilde{D}_{\\ell},\\tilde{C}_{\\ell})\\}<span class="math"> where </span>\\ell<span class="math"> ranges over all (axis-parallel) lines and </span>\\tilde{C}_{\\ell}<span class="math"> is the Reed–Solomon code </span>\\mathrm{RS}[\\mathbb{F},\\mathbb{F},d]$ (see Definition 3.4).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that the domain intersection of the line cover equals <span class="math">\\mathbb{F}^{m}</span>, which is also the domain <span class="math">D</span> of the base code <span class="math">C</span>. However, for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span>, we consider a cover whose domain intersection is a strict subset of <span class="math">D</span> (see Appendix G).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we specify a notion of <em>locality</em> for covers. A partial assignment <span class="math">w^{\\prime}\\in\\mathbb{F}^{D^{\\prime}}</span> is <em>locally consistent</em> with a cover <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> if for every local view <span class="math">(\\tilde{D}_{j},\\tilde{C}_{j})</span> with <span class="math">\\tilde{D}_{j}\\subseteq D^{\\prime}</span> the restriction $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{j}}<span class="math"> is a codeword of </span>\\tilde{C}_{j}<span class="math">. Then we say that a cover is <em></span>\\kappa<span class="math">-local</em> if any locally consistent assignment </span>w^{\\prime}\\in\\mathbb{F}^{D^{\\prime}}<span class="math">, where </span>D^{\\prime}<span class="math"> is a union of at most </span>\\kappa<span class="math"> domains in the cover, can be extended to a “globally consistent” codeword </span>w<span class="math"> of </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Definition 4.15.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>. Given <span class="math">\\kappa\\in\\mathbb{N}</span>, a <span class="math">\\kappa</span>-<em>local cover</em> of <span class="math">C</span> is a cover <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> of <span class="math">C</span> such that: for every subset of view-indices <span class="math">J</span> of size at most <span class="math">\\kappa</span> and every word <span class="math">w^{\\prime}\\in\\mathbb{F}^{\\tilde{D}_{J}}</span> with $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{j}}\\in\\tilde{C}_{j}<span class="math"> (for every </span>j\\in J<span class="math">), the word </span>w^{\\prime}<span class="math"> can be extended to some word </span>w<span class="math"> in </span>C<span class="math">, i.e., </span>w<span class="math"> satisfies </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{J}}=w^{\\prime}<span class="math">). (The trivial cover </span>S=\\{(D,C)\\}<span class="math"> of </span>C<span class="math"> is </span>\\kappa<span class="math">-local for every </span>\\kappa$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following definition significantly strengthens the previous one. Informally, a cover is <em><span class="math">\\kappa</span>-independent</em> if every partial assignment over a subdomain <span class="math">D^{\\prime}</span> that is the union of <span class="math">\\kappa</span> subdomains from the cover <em>and</em> <span class="math">\\kappa</span> auxiliary locations can be extended to a “globally consistent” codeword. We use this stronger notion in our main Lemma 4.20.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition 4.16.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>. Given <span class="math">\\kappa\\in\\mathbb{N}</span>, a <span class="math">\\kappa</span>-<em>independent cover</em> of <span class="math">C</span> is a <span class="math">\\kappa</span>-local cover <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> such that for every set <span class="math">J</span> of size at most <span class="math">\\kappa</span>, subdomain <span class="math">D^{\\prime}\\subseteq\\mathrm{di}(S)</span> of size at most <span class="math">\\kappa</span>, and <span class="math">w^{\\prime}\\in\\mathbb{F}^{D^{\\prime}\\cup\\tilde{D}_{J}}</span> with $w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{j}}\\in\\tilde{C}_{j}<span class="math"> for every </span>j\\in J<span class="math">, there exists </span>w\\in C<span class="math"> such that </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D^{\\prime}\\cup\\tilde{D}_{J}}=w^{\\prime}<span class="math">. (The trivial cover </span>S=\\{(D,C)\\}<span class="math"> of </span>C<span class="math"> is </span>\\kappa<span class="math">-independent for every </span>\\kappa\\in\\mathbb{N}<span class="math"> because it is </span>\\kappa<span class="math">-local and has </span>\\mathrm{di}(S)=\\emptyset$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-74" class="text-base font-medium mt-4">Example 4.17.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The line cover from Example 4.14 is <span class="math">d</span>-local because any evaluation on at most <span class="math">d</span> (axis-parallel) lines <span class="math">\\ell_{1},\\ldots,\\ell_{d}</span> that is a polynomial of degree <span class="math">(d-1)</span> along each of <span class="math">\\ell_{1},\\ldots,\\ell_{d}</span> can be extended to a codeword of <span class="math">\\mathrm{RM}[\\mathbb{F},\\mathbb{F},m,d]</span>. Furthermore, it is <span class="math">d/2</span>-independent because any locally consistent assignment to <span class="math">d/2</span> such lines and <span class="math">d/2</span> points <span class="math">p_{1},\\ldots,p_{d/2}</span> can be extended to a valid Reed–Muller codeword. To see this, observe that there exists an interpolating set <span class="math">H_{1}\\times\\cdots\\times H_{m}</span> (with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d<span class="math">) that contains </span>p_{1},\\ldots,p_{d/2}<span class="math"> and intersects each line in </span>d<span class="math"> points; we shall later use this observation for the bivariate case (</span>m=2$), a proof for that case is provided at Claim H.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">4.3.2 Recursive covers and locality</h4>

    <p class="text-gray-300">Proximity proofs for codes such as the Reed–Solomon code and the Reed–Muller code are typically obtained via techniques of proof composition <em>[x1]</em>. Informally, a problem is reduced to a set of smaller sub-problems of the same kind (which are usually interconnected), and a sub-proof is constructed for each sub-problem. This process leads to a proof for the original problem that is “covered” by the sub-proofs for the sub-problems, and naturally imply a cover of the proof by these sub-proofs. This process is then repeated recursively until the sub-problems are small enough for the verifier to check directly — and in our case leads to the notion of <em>recursive covers</em>, which we define below.</p>

    <p class="text-gray-300">To support the definition of a recursive cover, we first introduce notation for rooted trees. Edges in a rooted tree <span class="math">T=(V,E)</span> are directed from the root <span class="math">r</span> towards the leaves; the edge directed from <span class="math">v</span> to <span class="math">u</span> is denoted <span class="math">(v,u)</span>; <span class="math">v</span> is the <em>predecessor</em> of <span class="math">u</span> and <span class="math">u</span> the <em>successor</em> of <span class="math">v</span>; if there is a path from <span class="math">v</span> to <span class="math">v^{\\prime}</span> we say that <span class="math">v</span> is an <em>ancestor</em> of <span class="math">v^{\\prime}</span>; if there is no directed path between <span class="math">v</span> and <span class="math">v^{\\prime}</span> (in either direction) we say that the two vertices are <em>disconnected</em>. The *set of success</p>

    <p class="text-gray-300">of <span class="math">v</span> is denoted <span class="math">\\mathrm{successors}(T,v)</span>. The <em>depth</em> of a vertex <span class="math">v</span> in <span class="math">T</span> is denoted <span class="math">\\mathrm{depth}(T,v)</span> and equals the number of edges on the path from <span class="math">r</span> to <span class="math">v</span>. The depth of <span class="math">T</span> is denoted <span class="math">\\mathrm{depth}(T)</span> and equals the maximum of <span class="math">\\mathrm{depth}(T,v)</span> as <span class="math">v</span> ranges in <span class="math">V</span>. The <span class="math">i</span>-th <em>layer</em> of <span class="math">T</span> is denoted <span class="math">\\mathrm{layer}(T,i)</span> and equals the set of <span class="math">v\\in V</span> such that <span class="math">\\mathrm{depth}(T,v)=i</span>. (Note that <span class="math">\\mathrm{depth}(T,r)=0</span> and <span class="math">\\mathrm{layer}(T,0)=\\{r\\}</span>.) An <em>equidepth</em> tree is a tree in which all leaves have equal depth.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 4.18.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>. A recursive cover of <span class="math">C</span> is a directed rooted equidepth tree <span class="math">T</span> of non-zero depth where each vertex <span class="math">v</span> is labeled by a view <span class="math">(\\tilde{C}_{v},\\tilde{D}_{v})</span> such that: (i) <span class="math">\\tilde{C}_{v}</span> is a linear code with domain <span class="math">\\tilde{D}_{v}</span> and alphabet <span class="math">\\mathbb{F}</span>; (ii) if <span class="math">v</span> is the root, then <span class="math">(\\tilde{C}_{v},\\tilde{D}_{v})=(C,D)</span>; and (iii) for every non-leaf <span class="math">v</span> the set <span class="math">T_{v}:=\\{(\\tilde{C}_{u},\\tilde{D}_{u})\\}_{u\\in\\mathrm{successors}(T,v)}</span> is a cover of <span class="math">\\tilde{C}_{v}</span>. Furthermore we define the following notions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Given <span class="math">d\\in\\{0,\\ldots,\\mathrm{depth}(T)\\}</span>, the <span class="math">d</span>-depth restriction of <span class="math">T</span> is $T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d}:=\\bigcup_{v\\in\\mathrm{layer}(T,d)}\\{(\\tilde{C}_{v},\\tilde{D}_{v})\\}<span class="math">. (Note that </span>T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{0}=\\{(C,D)\\}$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">\\kappa\\in\\mathbb{N}</span>, we say that <span class="math">T</span> is <span class="math">\\kappa</span>-independent if <span class="math">T_{v}</span> is a <span class="math">\\kappa</span>-independent cover of <span class="math">\\tilde{C}_{v}</span> for every non-leaf vertex <span class="math">v</span> in <span class="math">T</span>.</li>

    </ul>

    <h6 id="sec-77" class="text-base font-medium mt-4">Remark 4.19.</h6>

    <p class="text-gray-300">The above definition is restricted to equidepth trees, but can be extended to general trees as follows. Iteratively append to each leaf <span class="math">v</span> of non-maximal depth a single successor <span class="math">u</span> labeled by <span class="math">(\\tilde{C}_{u},\\tilde{D}_{u}):=(\\tilde{C}_{v},\\tilde{D}_{v})</span>; this leads to a cover of <span class="math">T_{v}</span> that is <span class="math">0</span>-intersecting and <span class="math">\\kappa</span>-doubly independent for <span class="math">\\kappa</span> that equals <span class="math">\\tilde{C}_{v}</span>’s dual distance.</p>

    <p class="text-gray-300">Below we state the main lemma of this section. This lemma says that (given certain restrictions) if a recursive cover has the <em>local</em> property of <em>independence</em> (of some degree) at each internal vertex, then each of its layers has the <em>global</em> property of <em>locality</em> (of some degree) as a cover of the root. Later on (in Section 4.3.3) we show how cover locality is used to construct constraint detectors.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 4.20 (main).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>, and let <span class="math">T</span> be a recursive cover of <span class="math">C</span> such that (i) <span class="math">T</span> is c-intersecting for <span class="math">c&gt;0</span>, and (ii) for every non-leaf vertex <span class="math">v</span> in <span class="math">T</span> it holds that <span class="math">T_{v}</span> is a <span class="math">\\kappa</span>-independent cover of <span class="math">\\tilde{C}_{v}</span>. Then, for every <span class="math">d\\in\\{0,\\ldots,\\mathrm{depth}(T)\\}</span>, $T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d}<span class="math"> is a </span>\\frac{\\kappa}{c}<span class="math">-local cover of </span>C$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove the statement by induction on the non-negative integer <span class="math">d</span>. The base case is when <span class="math">d=0</span>, and holds because $T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{0}=\\{(D,C)\\}<span class="math"> is the trivial cover, thus it is a </span>\\kappa^{\\prime}<span class="math">-local cover of </span>C<span class="math"> for any </span>\\kappa^{\\prime}\\geq 0<span class="math"> and, in particular, a </span>\\frac{\\kappa}{c}<span class="math">-local cover. We now assume the statement for </span>d<\\mathrm{depth}(T)<span class="math"> and prove it for depth </span>d+1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d}=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}<span class="math"> be the </span>d<span class="math">-depth cover of </span>C<span class="math">, and let </span>T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d+1}=\\{(\\tilde{D}_{i,j},\\tilde{C}_{i,j})\\}_{i,j}<span class="math"> be the </span>(d+1)<span class="math">-depth cover of </span>C<span class="math">, where, for every </span>i<span class="math">, </span>T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d+1}^{(i)}=\\{(\\tilde{D}_{i,j},\\tilde{C}_{i,j})\\}_{j}<span class="math"> is the cover of </span>\\tilde{C}_{i}<span class="math"> (this can be ensured via suitable indexing). Let </span>J<span class="math"> be a set of pairs </span>(i,j)<span class="math"> of size at most </span>\\frac{\\kappa}{c}<span class="math">, and let </span>w^{\\prime}\\in\\mathbb{F}^{\\tilde{D}_{J}}<span class="math"> be such that </span>w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i,j}}\\in\\tilde{C}_{i,j}<span class="math"> for every </span>(i,j)\\in J<span class="math">. We show that there exists </span>w\\in C<span class="math"> such that </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{J}}=w^{\\prime}<span class="math">. Define </span>I:=\\{i:\\exists\\,j\\ \\text{s.t.}\\ (i,j)\\in J\\}<span class="math"> and note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{\\kappa}{c}<span class="math">. By the inductive assumption, it suffices to show that there exists </span>w\\in\\mathbb{F}^{\\tilde{D}_{I}}<span class="math"> such that (a) </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i,j}}=w^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i,j}}<span class="math"> for every </span>(i,j)\\in J<span class="math">, and (b) </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i}}\\in\\tilde{C}_{i}<span class="math"> for every </span>i\\in I$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For simplicity assume $I=\\{1,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. We construct </span>w<span class="math"> incrementally and view </span>w<span class="math"> as belonging to </span>(\\mathbb{F}\\cup\\{\\emptyset\\})^{\\tilde{D}_{I}}<span class="math">, i.e., it is a partial mapping from </span>\\tilde{D}_{I}<span class="math"> to </span>\\mathbb{F}<span class="math">. Let </span>\\mathrm{def}(w):=\\{\\alpha\\in\\tilde{D}_{I}:w(\\alpha)\\neq\\emptyset\\}<span class="math"> denote the set of locations where </span>w<span class="math"> is defined. Initialize </span>\\mathrm{def}(w)=\\tilde{D}_{J}<span class="math"> and </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{J}}=w^{\\prime}<span class="math">; then, for increasing </span>i=1,\\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, iteratively extend </span>w<span class="math"> to be defined (also) over </span>\\tilde{D}_{i}<span class="math">, eventually obtaining </span>w\\in\\mathbb{F}^{\\tilde{D}_{I}}<span class="math">. In the </span>i<span class="math">-th iteration (that handles </span>\\tilde{D}_{i}<span class="math">), it is sufficient to prove the existence of a codeword </span>w_{i}\\in\\tilde{C}_{i}<span class="math"> such that </span>w_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i}\\cap\\mathrm{def}(w)}=w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i}\\cap\\mathrm{def}(w)}<span class="math">. If such a codeword exists then we shall define </span>w<span class="math"> on </span>\\tilde{D}_{i}<span class="math"> by </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_{i}}=w_{i}<span class="math">, thus eventually reaching </span>w$ that satisfies the stated requirements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show that during the <span class="math">i</span>-th iteration the desired <span class="math">w_{i}</span> exists, partition the elements of <span class="math">\\tilde{D}_{i}\\cap\\mathrm{def}(w)</span> into two sets: <span class="math">V:=\\cup_{j\\ \\text{s.t.}\\ (i,j)\\in J}\\tilde{D}_{i,j}</span> and <span class="math">W:=\\left(\\tilde{D}_{i}\\cap\\mathrm{def}(w)\\right)\\setminus V</span>. Note that <span class="math">W\\subseteq\\cup_{i^{\\prime}\\neq i}(\\tilde{D}_{i}\\cap\\tilde{D}_{i^{\\prime}})</span>, because defining <span class="math">w(\\alpha)</span> for any <span class="math">\\alpha\\in W</span> can be done only: (i) in the initialization phase, so that <span class="math">\\alpha\\in\\tilde{D}_{i^{\\prime},j^{\\prime}}\\subseteq\\tilde{D}_{i^{\\prime}}</span> for some <span class="math">(i^{\\prime},j^{\\prime})\\in J</span> with <span class="math">i^{\\prime}\\neq i</span> (as otherwise <span class="math">\\alpha\\in V</span>); or (ii) in a previous iteration, so that <span class="math">\\alpha\\in\\tilde{D}_{i^{\\prime}}</span> for some <span class="math">i^{\\prime}&lt;i</span> (as <span class="math">\\tilde{D}_{i^{\\prime}}</span> was already handled and <span class="math">w</span> is already defined on all of <span class="math">\\tilde{D}_{i^{\\prime}}</span>). The above implies that $W\\subseteq\\mathrm{di}(T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d+1}^{(i)})<span class="math"> and the assumption that </span>T<span class="math"> is </span>c$-intersecting implies</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sum_{i^{\\prime}\\neq i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{i}\\cap\\tilde{D}_{i^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq c\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq c\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, note that for every fixed <span class="math">i\\in I</span> the number of pairs <span class="math">(i,j)\\in J</span> is at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa<span class="math">. By assumption </span>\\tilde{C}_{i}<span class="math"> has a </span>\\kappa<span class="math">-independent cover and thus we conclude (via Definition 4.16) that the desired </span>w_{i}$ exists, as required. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-80" class="text-lg font-semibold mt-6">4.3.3 From recursive covers to succinct constraint detection</h4>

    <p class="text-gray-300">The purpose of this section is to establish sufficient conditions for succinct constraint detection by leveraging covers with small-enough views and large-enough locality. First, in Definition 4.21 and Lemma 4.22, we define <em>cover-based constraint detection</em> and prove that it implies succinct constraint detection; informally, we consider the case when a code has a sequence of covers where view size and locality reduce together, and prove that we can locally detect constraints in a number of views that is proportional to the constraint’s weight and each view’s size is proportional to the constraint’s weight, by choosing the right cover from the sequence. Then, in Definition 4.24 and Lemma 4.25, we extend our discussion to recursive code covers by defining <em>recursive-cover-based constraint detection</em> and establishing that it implies the previous notion. We conclude (in Corollary 4.26) that recursive-cover-based constraint detection implies succinct constraint detection.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Definition 4.21.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. We say that <span class="math">\\mathscr{C}</span> has <em>cover-based constraint detection</em> if there exists an algorithm that, given an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time a subset </span>W\\subseteq\\mathbb{F}(\\mathfrak{n})^{D(\\mathfrak{n})}<span class="math"> for which there exists a subset </span>S^{\\prime}<span class="math"> of some </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-local cover </span>S<span class="math"> of </span>C_{\\mathfrak{n}}<span class="math">, and the following holds: (i) </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; (ii) </span>I\\subseteq(\\cup_{(\\tilde{D},\\tilde{C})\\in S^{\\prime}}\\tilde{D})<span class="math">; (iii) </span>\\mathrm{span}(W)=\\mathrm{span}(\\cup_{(\\tilde{D},\\tilde{C})\\in S^{\\prime}}\\tilde{C}^{\\perp})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 4.22.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. If <span class="math">\\mathscr{C}</span> has cover-based constraint detection then <span class="math">\\mathscr{C}</span> has succinct constraint detection.</p>

    <p class="text-gray-300">To prove this lemma we require a technical claim, the proof of which is deferred to Appendix E.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Claim 4.23.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a linear code with domain <span class="math">D</span> and alphabet <span class="math">\\mathbb{F}</span>, let <span class="math">S=\\{(\\tilde{D}_{j},\\tilde{C}_{j})\\}_{j}</span> be a <span class="math">\\kappa</span>-local cover of <span class="math">C</span>. For any set <span class="math">J</span> of size at most <span class="math">\\kappa</span> it holds <span class="math">\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_{j}^{\\perp})=(C^{\\perp})_{\\subseteq\\left(\\cup_{j\\in J}\\tilde{D}_{j}\\right)}</span>.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof of Lemma 4.22.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 4.6, it suffices to show an algorithm that, on input an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs a subset <span class="math">W\\subseteq\\mathbb{F}(\\mathfrak{n})^{D(\\mathfrak{n})}</span> with <span class="math">(C^{\\perp}_{\\mathfrak{n}})^{\\leq I}\\subseteq\\mathrm{span}(W)\\subseteq C^{\\perp}_{\\mathfrak{n}}</span> in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. We take this algorithm to be the one guaranteed by Definition 4.21. To see correctness, let </span>\\tilde{D}_{S^{\\prime}}:=\\cup_{(\\tilde{D},\\tilde{C})\\in S^{\\prime}}\\tilde{D}<span class="math">, and note that Definition 4.21 and Claim 4.23 imply that </span>\\mathrm{span}(W)=(C^{\\perp}_{\\mathfrak{n}})^{\\leq}_{\\subseteq\\tilde{D}_{S^{\\prime}}}<span class="math"> and </span>(C^{\\perp}_{\\mathfrak{n}})^{\\leq I}\\subseteq(C^{\\perp}_{\\mathfrak{n}})^{\\leq}_{\\subseteq\\tilde{D}_{S^{\\prime}}}\\subseteq C^{\\perp}_{\\mathfrak{n}}$, as required. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next we show that, under certain conditions, code families with recursive covers imply a sequence of covers that we can use to construct cover-based constraint detectors. Combined with Lemma 4.22, this result is key for establishing a connection from certain proximity proof constructions to succinct constraint detectors.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Definition 4.24.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. We say that <span class="math">\\mathscr{C}</span> has <em>recursive-cover-based constraint detection</em> if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists <span class="math">c\\in\\mathbb{N}</span> such that, for every index <span class="math">\\mathfrak{n}</span>, <span class="math">C_{\\mathfrak{n}}</span> has a <span class="math">c</span>-intersecting recursive cover <span class="math">T_{\\mathfrak{n}}</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- there exists an algorithm that, given an index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time a subset </span>W\\subseteq\\mathbb{F}(\\mathfrak{n})^{D(\\mathfrak{n})}<span class="math"> for which there exist </span>d\\in\\{0,\\ldots,\\mathrm{depth}(T_{\\mathfrak{n}})\\}<span class="math"> and </span>U\\subseteq\\mathrm{layer}(T_{\\mathfrak{n}},d)<span class="math"> such that: (i) for every vertex </span>v<span class="math"> in </span>T_{\\mathfrak{n}}<span class="math"> with </span>\\mathrm{depth}(T_{\\mathfrak{n}},v)<d<span class="math">, the cover </span>T_{\\mathfrak{n},v}<span class="math"> is </span>c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-independent; (ii) </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; (iii) </span>I\\subseteq(\\cup_{u\\in U}\\tilde{D}_{u})<span class="math">; (iv) </span>\\mathrm{span}(W)=\\mathrm{span}(\\cup_{u\\in U}\\tilde{C}^{\\perp}_{u})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 4.25.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. If <span class="math">\\mathscr{C}</span> has recursive-cover-based constraint detection, then <span class="math">\\mathscr{C}</span> has cover-based constraint detection.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The definition of recursive-cover-based detection says that there exist (a) <span class="math">c\\in\\mathbb{N}</span> such that, for every index <span class="math">\\mathfrak{n}</span>, <span class="math">C_{\\mathfrak{n}}</span> has a <span class="math">c</span>-intersecting recursive cover <span class="math">T_{\\mathfrak{n}}</span>, and (b) an algorithm satisfying certain properties. We show that this algorithm meets the requirements for being a cover-based constraint detector (see Definition 4.21). Consider any index <span class="math">\\mathfrak{n}</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, and let <span class="math">W</span> be the output of the algorithm. Let <span class="math">d\\in\\{0,\\ldots,\\mathrm{depth}(T_{\\mathfrak{n}})\\}</span> and <span class="math">U\\subseteq\\mathrm{layer}(T_{\\mathfrak{n}},d)</span> be the objects associated to <span class="math">W</span> (guaranteed by the definition of recursive-cover-based constraint detection). Let $S:=T_{\\mathfrak{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i.e., <span class="math">S</span> is the <span class="math">d</span>-depth restriction of <span class="math">T_{\\mathfrak{n}}</span>) and <span class="math">S^{\\prime}:=\\{(\\tilde{D}_{u},\\tilde{C}_{u})\\}_{u\\in U}</span>; it suffices to show that <span class="math">S</span> is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-local. The claim follows directly by the assumption on </span>d<span class="math"> and Lemma 4.20, because </span>T_{\\mathfrak{n},v}<span class="math"> is </span>c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-independent for every vertex </span>v<span class="math"> in </span>T_{\\mathfrak{n}}<span class="math"> with </span>\\mathrm{depth}(T_{\\mathfrak{n}},v)<d<span class="math">, and thus </span>S=T_{\\mathfrak{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{d}<span class="math"> is indeed a </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">-local cover of </span>C$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-88" class="text-base font-medium mt-4">Corollary 4.26.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>. If <span class="math">\\mathscr{C}</span> has recursive-cover-based constraint detection, then <span class="math">\\mathscr{C}</span> has succinct constraint detection.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows directly from Lemma 4.25 (recursive-cover-based constraint detection implies cover-based constraint detection) and Lemma 4.22 (cover-based constraint detection implies succinct constraint detection). ∎</p>

    <h4 id="sec-90" class="text-lg font-semibold mt-6">4.3.4 Proof of Theorem 4.12</h4>

    <p class="text-gray-300">The purpose of this section is to prove Theorem 4.12. By Corollary 4.26, it suffices to argue that the linear code family <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has recursive-cover-based constraint detection (see Definition 4.24).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that we consider Reed–Solomon codes <span class="math">\\mathrm{RS}[\\mathbb{F},L,d]</span> where <span class="math">\\mathbb{F}</span> is an extension field of a base field <span class="math">\\mathbb{K}</span>, <span class="math">L</span> is a <span class="math">\\mathbb{K}</span>-linear subspace in <span class="math">\\mathbb{F}</span>, and $d=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu}<span class="math"> for some </span>\\mu\\in\\mathbb{N}<span class="math">; and we denote by </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]<span class="math"> the code obtained by concatenating codewords in </span>\\mathrm{RS}[\\mathbb{F},L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu}]<span class="math"> with corresponding <em>[x1]</em> proximity proofs with “base dimension” </span>k\\in\\{1,\\ldots,\\dim(L)\\}<span class="math"> (see Appendix F for details). The linear code family </span>\\mathrm{BS}\\text{-}\\mathrm{RS}<span class="math"> is indexed by tuples </span>\\mathfrak{n}=(\\mathbb{K},\\mathbb{F},L,\\mu,k)<span class="math"> and the </span>\\mathfrak{n}<span class="math">-th code is </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We represent indices <span class="math">\\mathfrak{n}</span> so that $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}\\leq\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The base field </span>\\mathbb{K}<span class="math"> and extension field </span>\\mathbb{F}<span class="math"> require </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> bits to represent; the subspace </span>L<span class="math"> requires </span>O(\\dim(L))<span class="math"> elements in </span>\\mathbb{F}<span class="math"> to represent; and the two integers </span>\\mu<span class="math"> and </span>k<span class="math"> require </span>O(\\log\\mu)<span class="math"> and </span>O(\\log k)<span class="math"> bits to represent. In addition, we add </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}<span class="math"> arbitrary bits of padding. Overall, we obtain that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\dim(L)+\\log\\mu+\\log k+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})=\\Theta(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main claim in this section is the following (and does not rely on fixing <span class="math">\\mathbb{K},\\mu</span>).</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Lemma 4.27.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define the depth function $d(\\mathbb{K},L,\\mu,a):=\\log_{2}\\dim(L)-\\log_{2}(\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}a+\\mu+2)-1<span class="math">. The linear code family </span>\\mathrm{BS}\\text{-}\\mathrm{RS}$ satisfies the following properties.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every index <span class="math">\\mathfrak{n}=(\\mathbb{K},\\mathbb{F},L,\\mu,k)</span>, <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> has a <span class="math">1</span>-intersecting recursive cover <span class="math">T_{\\mathfrak{n}}</span>. Also, for every positive integer <span class="math">m</span> and non-leaf vertex <span class="math">v</span> in <span class="math">T_{\\mathfrak{n}}</span> with <span class="math">\\mathrm{depth}(T_{\\mathfrak{n}},v)&lt;d(\\mathbb{K},L,\\mu,m)</span>, the cover <span class="math">T_{\\mathfrak{n},v}</span> is <span class="math">m</span>-independent.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- There exists an algorithm that, given an index <span class="math">\\mathfrak{n}=(\\mathbb{K},\\mathbb{F},L,\\mu,k)</span> and subset <span class="math">I\\subseteq D(\\mathfrak{n})</span>, outputs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> a subset </span>W\\subseteq\\mathbb{F}^{D(\\mathfrak{n})}<span class="math"> for which there exist </span>U\\subseteq\\mathrm{layer}(T_{\\mathfrak{n}},d(\\mathbb{K},L,\\mu,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> such that: (i) </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; (ii) </span>I\\subseteq(\\cup_{u\\in U}\\tilde{D}_{u})<span class="math">; (iii) </span>\\mathrm{span}(W)=\\mathrm{span}(\\cup_{u\\in U}\\tilde{C}_{u}^{\\perp})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given the above lemma, we can complete the proof of Theorem 4.12, as explained below. We defer the (long and technical) proof of the lemma to Appendix G, and instead end this section with an overview of that proof.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof of Theorem 4.12.</h6>

    <p class="text-gray-300">The proof follows from Lemma 4.27 above and from Corollary 4.26, as we now explain.</p>

    <p class="text-gray-300">Corollary 4.26 states that if a linear code family <span class="math">\\mathscr{C}</span> has recursive-cover-based constraint detection (see Definition 4.24), then <span class="math">\\mathscr{C}</span> has succinct constraint detection (see Definition 4.2). Also recall that the definition of recursive-cover-based detection requires having a <span class="math">c</span>-intersecting recursive cover for each code in the class, and an algorithm satisfying certain properties.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that Lemma 4.27 guarantees that every code in <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> has a <span class="math">1</span>-intersecting recursive code and, moreover, guarantees the existence of an algorithm whose output satisfies the required properties. We are left to argue that the algorithm runs in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. But this immediately follows from the running time stated in Lemma 4.27 and the fact that </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\dim(L)+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}\\leq\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-93" class="text-base font-semibold mt-4">Overview of Lemma 4.27’s proof.</h5>

    <p class="text-gray-300">We assume familiarity with the linear code family <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> from <em>[x1]</em>; for completeness, we provide formal definitions and notations in Appendix F. Recall that the Reed–Solomon code is not locally testable, but one can test proximity to it with the aid of BS proximity proofs <em>[x1]</em>; the linear code family <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> consists of the concatenation of Reed–Solomon codes with BS corresponding proximity proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The construction of the aforementioned proximity proofs is <em>recursive</em>, with each step in the recursion reducing both the evaluation domain size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the degree </span>d$ to (approximately) their square roots. Namely, testing proximity of a</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">codeword <span class="math">w</span> to <span class="math">\\mathrm{RS}[\\mathbb{F},L,d]</span> is reduced to testing proximity of $\\Theta(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> codewords </span>\\{w_{i}\\}_{i}<span class="math"> to </span>\\{\\mathrm{RS}[\\mathbb{F},L_{i},d_{i}]\\}_{i}<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d_{i}=\\Theta(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> for each </span>i<span class="math">. This step is then recursively applied (by way of proof composition <em>[x1]</em>) to each codeword </span>w_{i}$, until the domain size is “small enough”.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first part of the proof of Lemma 4.27 consists of various combinatorial claims (see Appendix G.1). First, we observe that the union of the domains of the codewords <span class="math">w_{i}</span> covers (and, actually, slightly expands) the domain of the original codeword <span class="math">w</span>; this holds recursively, and induces a recursive cover <span class="math">T</span> (see Definition G.3). We prove that <span class="math">T</span> is <span class="math">1</span>-intersecting (see Claim G.4) and that, for every vertex <span class="math">v</span> in <span class="math">T</span> of depth at most <span class="math">d</span>, the cover <span class="math">T_{v}</span> is $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2^{-d-1}}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu-2})<span class="math">-independent, which implies the stated independence property about </span>T_{v}<span class="math"> (see Claim G.5). The core of the argument for this second claim is to show that the code </span>\\hat{C}_{v}<span class="math"> equals </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{v},\\mu,k]<span class="math"> for some subspace </span>L_{v}<span class="math"> such that </span>\\dim(L)\\cdot 2^{-d}\\leq\\dim(\\hat{L})\\leq\\dim(L)\\cdot 2^{-d}+2\\mu$ (see Claim G.6).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The second part of the proof of Lemma 4.27 consists of establishing the computational efficiency of certain tasks related to the recursive cover (see Appendix G.2). Specifically, we bound the time required to compute a spanning set for covers in <span class="math">T</span> (see Claim G.8). After a few more observations, we are able to conclude the proof.</p>

    <p class="text-gray-300">5 Sumcheck with perfect zero knowledge</p>

    <p class="text-gray-300">We obtain an IPCPP for sumcheck that is perfect zero knowledge against unbounded queries. (Since the input <span class="math">F</span> is an oracle given to the verifier, the proof system is formally an <em>exact IPCP of proximity for a promise relation</em>.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sumcheck. The sumcheck protocol <em>[x14, x26]</em> is an IP for the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>”, where <span class="math">F</span> is a polynomial in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>. The prover and verifier have input <span class="math">(\\mathbb{F},m,d,H)</span> and oracle access to (the evaluation table on <span class="math">\\mathbb{F}^{m}</span> of) <span class="math">F</span>. The sumcheck protocol has soundness error $1-(1-\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{m}<span class="math">; the prover runs in space </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verifier in time </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; the number of rounds is </span>m<span class="math">; finally, the protocol is public coin and the verifier queries </span>F$ only at one random point.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Leakage. The sumcheck protocol is <em>not</em> zero knowledge: a verifier, by interacting with the honest prover, learns partial sums of <span class="math">F</span>, in addition to the fact that “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>” is true. Assuming one way functions, one <em>can</em> make any interactive proof, including the sumcheck protocol, to be (computational) zero knowledge <em>[x10, x21, BGG^{+}88]</em>; moreover, one-way functions are necessary for obtaining zero knowledge IPs for non-trivial languages <em>[x22]</em>. As we do not wish to make intractability assumptions, we now turn to a different proof system model.</p>

    <p class="text-gray-300">Perfect zero knowledge via IPCPPs. We obtain an IPCPP for sumcheck that is perfect zero knowledge against unbounded queries. Namely, a malicious verifier has oracle access to a proof string <span class="math">\\pi</span> and also interacts with the prover, but learns no information about <span class="math">F</span> beyond the fact that the statement about <span class="math">F</span> is true, in the following sense. There exists an algorithm that perfectly simulates the verifier’s view by making as many queries to <span class="math">F</span> as the <em>total</em> number of verifier queries to either <span class="math">F</span> or the oracle <span class="math">\\pi</span>. (Analogously to zero knowledge for proximity testers, a verifier may query <span class="math">F</span> at any time, so any such information comes “for free” and, also, any query to <span class="math">\\pi</span> ‘counts’ as a query to <span class="math">F</span>; see Section 3.3.)</p>

    <p class="text-gray-300">Our construction proceeds in two steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1. We modify the sumcheck protocol to make it perfect zero knowledge, but in a hybrid model where the prover and verifier have access to a random polynomial <span class="math">R\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>. Crucially, soundness relies only on the fact that <span class="math">R</span> is low-degree, but not the fact that it is random. Also, the modified protocol does <em>not</em> depend on a bound on the malicious verifier’s queries, and thus maintains zero knowledge even against unbounded queries.</li>

      <li>Step 2. We observe that in the IPCPP model the prover can send an oracle proof string <span class="math">\\pi</span> that represents the evaluation table of <span class="math">R</span>, and the verifier can test that <span class="math">\\pi</span> is close to low-degree, and then use self correction to query it. This extension preserves the zero knowledge properties of the previous step.</li>

    </ul>

    <p class="text-gray-300">The more interesting of the two steps is the first one, so we briefly discuss the intuition behind it. Our idea is that, rather than executing the sumcheck protocol on <span class="math">F</span> directly, the prover tells the verifier that <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=z</span>, then they engage in the sumcheck protocol on the claim <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}\\rho F(\\vec{\\alpha})+R(\\vec{\\alpha})=z</span>, where <span class="math">\\rho</span> is chosen at random by the verifier (after <span class="math">R</span> is sampled). Completeness is clear because if <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span> and <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=z</span> then <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}(\\rho F+R)(\\vec{\\alpha})=z</span>; soundness is also clear because if <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})\\neq 0</span> then <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}(\\rho F+R)(\\vec{\\alpha})\\neq z</span> with high probability over <span class="math">\\rho</span> (regardless of whether <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=z</span> or not). We are thus left to show perfect zero knowledge, which turns out to be a much less straightforward argument.</p>

    <p class="text-gray-300">On the surface, perfect zero knowledge appears easy to argue: simply note that <span class="math">\\rho F+R</span> is random among all polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>. However, this argument, while compelling, is not enough. First, <span class="math">\\rho F+R</span> is <em>not</em> random because a malicious verifier can choose <span class="math">\\rho</span> depending on queries to <span class="math">R</span>; we discuss this issue further down below. Second, even if <span class="math">\\rho F+R</span> were random (e.g., the verifier does not query <span class="math">R</span> before choosing <span class="math">\\rho</span>), the simulator must run in polynomial time but it is not clear how that is possible, as we now explain.</p>

    <p class="text-gray-300">Consider the following simulator: (1) sample a random polynomial <span class="math">Q_{\\mathrm{sim}}\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and use it to simulate <span class="math">\\rho F+R</span>; (2) whenever the verifier queries <span class="math">F(\\vec{\\alpha})</span>, respond by querying <span class="math">F(\\vec{\\alpha})</span> and returning the true value; (3) whenever the verifier queries <span class="math">R(\\vec{\\alpha})</span>, respond by querying <span class="math">F(\\vec{\\alpha})</span> and returning <span class="math">Q_{\\mathrm{sim}}(\\vec{\\alpha})-\\rho F(\\vec{\\alpha})</span>. One can argue that the simulator produces the correct distribution; moreover, the number of queries to <span class="math">F</span> made by the simulator equals the number of (mutually) distinct queries to <span class="math">F</span> and <span class="math">R</span> made by the verifier, as desired.</p>

    <p class="text-gray-300">But how does the simulator sample a random polynomial in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> in polynomial time? The size of the representation of such a polynomial is <span class="math">\\Omega(d^{m})</span>, which is exponential. We get around this problem by exploiting the fact that the number of queries the verifier can make is polynomially bounded, and the simulator can keep state about the answers to past queries and ‘make up’ on the fly the answer to a new query by resolving dependencies between queries.</p>

    <p class="text-gray-300">More precisely, we leverage our construction of a succinct constraint detector for evaluations of low-degree polynomials (see Section 4.2), which itself relies on tools borrowed from algebraic complexity theory. The same detector also allows to simulate partial sums, which the prover sends in the course of the sumcheck protocol itself.</p>

    <p class="text-gray-300">Finally, we explain how we address the issue that the verifier may choose to query <span class="math">R</span> before sending <span class="math">\\rho</span>. We handle this by first (implicitly) sampling a random polynomial <span class="math">R_{\\mathrm{sim}}</span>, and responding to each verifier query to <span class="math">R(\\vec{\\alpha})</span> with <span class="math">R_{\\mathrm{sim}}(\\vec{\\alpha})</span>. Then, when the verifier sends <span class="math">\\rho</span>, we draw <span class="math">Q_{\\mathrm{sim}}</span> conditioned on the already-queried values for <span class="math">R</span> being ‘correct’; i.e., for each point <span class="math">\\vec{\\alpha}</span> queried before <span class="math">\\rho</span> is sent, we add the condition that <span class="math">Q_{\\mathrm{sim}}(\\vec{\\alpha}) = \\rho F(\\vec{\\alpha}) + R_{\\mathrm{sim}}(\\vec{\\alpha})</span>. We then continue as described above, and it is not too difficult to argue that this strategy yields the correct distribution.</p>

    <p class="text-gray-300">We are now ready to turn the above discussions into formal definitions and proofs. First, we give the definition of the sumcheck relation and of a PZK IPCPP system for sumcheck; then we state and prove the PZK Sumcheck Theorem.</p>

    <p class="text-gray-300"><strong>Definition 5.1.</strong> The sumcheck relation and its promise variant are defined as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The sumcheck relation is the relation <span class="math">\\mathcal{R}_{\\mathrm{SC}}</span> of instance-witness pairs <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right)</span> such that (i) <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>, <span class="math">v</span> is an element of <span class="math">\\mathbb{F}</span>, and <span class="math">m, d</span> are positive integers with $\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &lt; \\frac{1}{2}<span class="math">; (ii) </span>F<span class="math"> is in </span>\\mathbb{F}^{&lt;d}[X_1, \\ldots, X_m]<span class="math"> and sums to </span>v<span class="math"> on </span>H^m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The sumcheck promise relation is the pair of relations <span class="math">(\\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}, \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{no}})</span> where <span class="math">\\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}} \\coloneqq \\mathcal{R}_{\\mathrm{SC}}</span> and <span class="math">\\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{no}}</span> are the pairs <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right)</span> such that <span class="math">(\\mathbb{F}, m, d, H, v)</span> is as above and <span class="math">F \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span> but does not sum to <span class="math">v</span> on <span class="math">H^m</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 5.2.</strong> A PZK exact IPCPP system for sumcheck with soundness error <span class="math">\\varepsilon</span> is a pair of interactive algorithms <span class="math">(P, V)</span> that satisfies the following properties.⁹</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span>, <span class="math">\\operatorname{Pr}\\left[\\langle P^{F}(\\mathbb{F}, m, d, H, v), V^{F}(\\mathbb{F}, m, d, H, v) \\rangle = 1\\right] = 1</span>.</li>

      <li><strong>Soundness.</strong> For every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{no}}</span> and malicious prover <span class="math">\\tilde{P}</span>, <span class="math">\\operatorname{Pr}\\left[\\langle \\tilde{P}, V^{F}(\\mathbb{F}, m, d, H, v) \\rangle = 1\\right] \\leq \\varepsilon</span>.</li>

      <li><strong>Perfect zero knowledge.</strong> There exists a straightline simulator <span class="math">S</span> such that, for every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span> and malicious verifier <span class="math">\\tilde{V}</span>, the following two random variables are identically distributed</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(S^{\\tilde{V}, F}(\\mathbb{F}, m, d, H, v), q_S\\right) \\quad \\text{and} \\quad \\left(\\operatorname{View} \\langle P^{F}(\\mathbb{F}, m, d, H, v), \\tilde{V}^{F} \\rangle, q_{\\tilde{V}}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">q_S</span> is the number of queries to <span class="math">F</span> made by <span class="math">S</span> and <span class="math">q_{\\tilde{V}}</span> is the number of queries to <span class="math">F</span> or the PCP oracle made by <span class="math">\\tilde{V}</span>. Moreover, <span class="math">S</span> runs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + \\mathfrak{q}_{\\tilde{V}})<span class="math">, where </span>\\mathfrak{q}_{\\tilde{V}}<span class="math"> is </span>\\tilde{V}$'s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 5.3 (PZK Sumcheck).</strong> There exists a PZK public-coin exact IPCPP system <span class="math">(P, V)</span> for the sumcheck promise relation <span class="math">(\\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}, \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{no}})</span> with soundness error $\\varepsilon = O\\left(\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$ and the following efficiency parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle round: <span class="math">P</span> sends an oracle proof string <span class="math">\\pi \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>.</li>

      <li>Interactive proof: after the oracle round, <span class="math">P</span> and <span class="math">V</span> engage in an <span class="math">(m + 1)</span>-round interactive proof; in total, the verifier sends to the prover <span class="math">O(m)</span> field elements, while the prover sends to the verifier <span class="math">O(md)</span> field elements.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Queries: after the interactive proof, <span class="math">V</span> non-adaptively queries <span class="math">\\pi</span> at $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d)$ locations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-94" class="text-2xl font-bold">5.1 Step 1</h2>

    <p class="text-gray-300">We construct a public-coin IP for sumcheck that is perfect zero knowledge, in the “<span class="math">R</span>-hybrid” model, where the prover and verifier have access to a uniformly random <span class="math">R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>.</p>

    <p class="text-gray-300"><strong>Construction 5.4.</strong> The IP system <span class="math">(P_{\\mathrm{IP}}, V_{\\mathrm{IP}})</span> is defined as follows. Both <span class="math">P_{\\mathrm{IP}}</span> and <span class="math">V_{\\mathrm{IP}}</span> receive a tuple <span class="math">(\\mathbb{F}, m, d, H, v)</span> as common input, and two polynomials <span class="math">F, R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span> as oracles. The interaction proceeds as follows:</p>

    <p class="text-gray-300">⁸This promise is not the same notion as in Section 3.2.3; there the promise is with respect to instances, whereas here it is with respect to witnesses.</p>

    <p class="text-gray-300">⁹This is exactly the standard definition of an IPCPP (Section 3.3.2), but with a soundness condition respecting our current notion of a promise.</p>

    <p class="text-gray-300">29</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\mathrm{IP}}</span> sends <span class="math">z := \\sum_{\\vec{\\alpha} \\in H^m} R(\\vec{\\alpha})</span> to <span class="math">V_{\\mathrm{IP}}</span>;</li>

      <li><span class="math">V_{\\mathrm{IP}}</span> draws a random element <span class="math">\\rho</span> in <span class="math">\\mathbb{F}</span>, and sends <span class="math">\\rho</span> to <span class="math">P_{\\mathrm{IP}}</span>;</li>

      <li><span class="math">P_{\\mathrm{IP}}</span> and <span class="math">V_{\\mathrm{IP}}</span> run the sumcheck IP [LFKN92, Sha92] on the statement “<span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha}) = \\rho v + z</span>” where <span class="math">Q := \\rho F + R</span> (with <span class="math">P_{\\mathrm{IP}}</span> playing the role of the prover and <span class="math">V_{\\mathrm{IP}}</span> that of the verifier).</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">(P_{\\mathrm{IP}}, V_{\\mathrm{IP}})</span> is public-coin, and satisfies the following efficiency properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Communication: The number of rounds is <span class="math">m + 1</span>. Across the interaction, <span class="math">V_{\\mathrm{IP}}</span> sends <span class="math">O(m)</span> field elements to <span class="math">P_{\\mathrm{IP}}</span>, while <span class="math">P_{\\mathrm{IP}}</span> sends <span class="math">O(md)</span> field elements to <span class="math">V_{\\mathrm{IP}}</span>.</li>

      <li>Queries: <span class="math">V_{\\mathrm{IP}}</span> queries <span class="math">F</span> and <span class="math">R</span> each at a single random point because, at the end of the sumcheck protocol, the verifier queries <span class="math">Q</span> at a random point <span class="math">\\vec{\\gamma}</span>, and such a query can be "simulated" by querying <span class="math">F</span> and <span class="math">R</span> at <span class="math">\\vec{\\gamma}</span> and then using these answers, along with <span class="math">\\rho</span>, to compute the necessary value for <span class="math">Q</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Space and time: <span class="math">P_{\\mathrm{IP}}</span> runs in space $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, while </span>V_{\\mathrm{IP}}<span class="math"> in time </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. (The prover's space complexity assumes that the randomness tape is two-way; see Remark 5.7 below.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now state and prove the completeness, soundness, and perfect zero knowledge properties.</p>

    <p class="text-gray-300"><strong>Lemma 5.5.</strong> The IP system <span class="math">(P_{\\mathrm{IP}}, V_{\\mathrm{IP}})</span> satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span> and <span class="math">R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span> with <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} R(\\vec{\\alpha}) = 0</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle P _ {\\mathrm {I P}} ^ {F, R} (\\mathbb {F}, m, d, H, v), V _ {\\mathrm {I P}} ^ {F, R} (\\mathbb {F}, m, d, H, v) \\rangle = 1 \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Soundness.</strong> For every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{no}}</span>, <span class="math">R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>, and malicious prover <span class="math">\\tilde{P}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\langle \\tilde {P}, V _ {\\mathrm {I P}} ^ {F, R} (\\mathbb {F}, m, d, H, v) \\rangle = 1 \\right] \\leq \\frac {m d + 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Perfect zero knowledge.</strong> There exists a straightline simulator <span class="math">S_{\\mathrm{IP}}</span> such that, for every <span class="math">\\left((\\mathbb{F}, m, d, H, v), F\\right) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span> and malicious verifier <span class="math">\\tilde{V}</span>, the following two random variables are identically distributed</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left(S _ {\\mathrm {I P}} ^ {\\tilde {V}, F} (\\mathbb {F}, m, d, H, v), q _ {S _ {\\mathrm {I P}}}\\right) \\quad \\text{and} \\quad \\left(\\operatorname {V i e w} \\langle P _ {\\mathrm {I P}} ^ {F, R} (\\mathbb {F}, m, d, H, v), \\tilde {V} ^ {F, R} \\rangle , q _ {\\tilde {V}}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">R</span> is uniformly random in <span class="math">\\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>, <span class="math">q_{S_{\\mathrm{IP}}}</span> is the number of queries to <span class="math">F</span> made by <span class="math">S_{\\mathrm{IP}}</span>, and <span class="math">q_{\\tilde{V}}</span> is the number of queries to <span class="math">F</span> or <span class="math">R</span> made by <span class="math">\\tilde{V}</span>. Moreover, <span class="math">S_{\\mathrm{IP}}</span> runs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathfrak{q}_{\\tilde{V}})<span class="math"> where </span>\\mathfrak{q}_{\\tilde{V}}<span class="math"> is </span>\\tilde{V}$'s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> We argue first completeness, then soundness, and, finally, perfect zero knowledge.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> If both <span class="math">F</span> sums to <span class="math">v</span> on <span class="math">H^m</span> and <span class="math">R</span> sums to <span class="math">z</span> on <span class="math">H^m</span>, then <span class="math">Q := \\rho F + R</span> sums to <span class="math">\\rho v + z</span> on <span class="math">H^m</span> for every choice of <span class="math">\\rho</span>. Then completeness follows from the completeness of standard sumcheck.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Soundness.</strong> For every <span class="math">F, R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span> with <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) \\neq v</span>, <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha})</span> equals <span class="math">\\rho v + z</span> for at most one choice of <span class="math">\\rho</span>, namely, <span class="math">(\\sum_{\\vec{\\alpha} \\in H^m} R(\\vec{\\alpha}) - z) / (v - \\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}))</span>. Thus, except with probability $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the sumcheck protocol is invoked on an incorrect claim, which incurs a soundness error of at most </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. The claimed soundness error follows by a union bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Perfect zero knowledge.</strong> We begin by proving perfect zero knowledge via a straightline simulator <span class="math">S_{\\mathrm{slow}}</span> whose number of queries to <span class="math">F</span> equals <span class="math">q_{\\tilde{V}}</span>, but runs in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^m + q_{\\tilde{V}})<span class="math">. After that, we explain how to modify </span>S_{\\mathrm{slow}}<span class="math"> into another simulator </span>S_{\\mathrm{IP}}$, with an identical output distribution, that runs in the faster time claimed in the lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">The simulator <span class="math">S_{\\mathrm{slow}}</span>, given straightline access to <span class="math">\\tilde{V}</span> and oracle access to <span class="math">F</span>, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Draw a uniformly random <span class="math">R_{\\mathrm{sim}}\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and send <span class="math">z_{\\mathrm{sim}}:=\\sum_{\\vec{\\alpha}\\in H^{m}}R_{\\mathrm{sim}}(\\vec{\\alpha})</span> to <span class="math">\\tilde{V}</span>.</li>

      <li>Whenever <span class="math">\\tilde{V}</span> queries <span class="math">F</span> at <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span>, return <span class="math">F(\\vec{\\gamma})</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">R</span> at <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span>, return <span class="math">R_{\\mathrm{sim}}(\\vec{\\gamma})</span>.</li>

      <li>Receive <span class="math">\\tilde{\\rho}</span> from <span class="math">\\tilde{V}</span>, and draw a uniformly random <span class="math">Q_{\\mathrm{sim}}\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> conditioned on <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}Q_{\\mathrm{sim}}(\\vec{\\alpha})=\\tilde{\\rho}v+z_{\\mathrm{sim}}</span> and <span class="math">Q_{\\mathrm{sim}}(\\vec{\\gamma})=\\tilde{\\rho}F(\\vec{\\gamma})+R_{\\mathrm{sim}}(\\vec{\\gamma})</span> for every coordinate <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span> queried in Step 2. (This latter condition requires querying <span class="math">F</span> at <span class="math">\\vec{\\gamma}</span> for every coordinate <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span> queried to <span class="math">R_{\\mathrm{sim}}</span> in Step 2.)</li>

      <li>Hereafter: whenever <span class="math">\\tilde{V}</span> queries <span class="math">F</span> at <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span>, return <span class="math">F(\\vec{\\gamma})</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">R</span> at <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span>, return <span class="math">Q_{\\mathrm{sim}}(\\vec{\\gamma})-\\tilde{\\rho}F(\\vec{\\gamma})</span>. (In either case, a query to <span class="math">F</span> is required.)</li>

      <li>Run the sumcheck protocol with <span class="math">\\tilde{V}</span> on <span class="math">Q_{\\mathrm{sim}}</span>. (Note that <span class="math">\\tilde{V}</span> may query <span class="math">F</span> or <span class="math">R</span> before, during, or after this protocol.)</li>

      <li>Output the view of the simulated <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">S_{\\mathrm{slow}}</span> runs in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m}+q_{\\tilde{V}})<span class="math">. Also, </span>S_{\\mathrm{slow}}<span class="math"> makes one query to </span>F<span class="math"> for every query to </span>F<span class="math"> or </span>R<span class="math"> by </span>\\tilde{V}<span class="math"> (at least provided that </span>\\tilde{V}<span class="math">’s queries have no duplicates, which we can assume without loss of generality). Thus, overall, the number of queries to </span>F<span class="math"> by </span>S_{\\mathrm{slow}}<span class="math"> is </span>q_{\\tilde{V}}<span class="math">. We now argue that </span>S_{\\mathrm{slow}}<span class="math">’s output is identically distributed to </span>\\tilde{V}<span class="math">’s view when interacting with the honest prover </span>P_{\\mathrm{IP}}<span class="math">, for </span>R<span class="math"> random in </span>\\mathbb{F}^{<d}[X_{1},\\ldots,X_{m}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-95" class="text-base font-medium mt-4">Claim.</h6>

    <p class="text-gray-300"><span class="math">S_{\\mathrm{slow}}^{\\tilde{V},F}\\equiv\\mathrm{View}\\;\\langle P_{\\mathrm{IP}}^{F,R},\\tilde{V}^{F,R}\\rangle</span>.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define the random variable <span class="math">Q:=\\tilde{\\rho}F+R</span>, where <span class="math">\\tilde{\\rho}</span> is chosen by <span class="math">\\tilde{V}</span>. Observe that there exists a (deterministic) function <span class="math">v(\\cdot)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathrm{View}\\;\\langle P_{\\mathrm{IP}}^{F,R},\\tilde{V}^{F,R}\\rangle=v(Q,F,r)\\quad\\text{and}\\quad S_{\\mathrm{slow}}^{\\tilde{V},F}=v(Q_{\\mathrm{sim}},F,r)\\enspace,</span></p>

    <p class="text-gray-300">where the random variable <span class="math">r</span> is <span class="math">\\tilde{V}</span>’s private randomness. Indeed, (i) the messages sent and received by <span class="math">\\tilde{V}</span> are identical to those when interacting with <span class="math">P_{\\mathrm{IP}}</span> on <span class="math">Q</span> and <span class="math">Q_{\\mathrm{sim}}</span>, respectively; (ii) <span class="math">\\tilde{V}</span>’s queries to <span class="math">F</span> are answered honestly; (iii) <span class="math">\\tilde{V}</span>’s queries to <span class="math">R</span> are answered by <span class="math">R=Q-\\tilde{\\rho}F</span> and <span class="math">R_{\\mathrm{sim}}=Q_{\\mathrm{sim}}-\\tilde{\\rho}F</span> respectively. We are only left to argue that, for any choice of <span class="math">r</span>, <span class="math">Q</span> and <span class="math">Q_{\\mathrm{sim}}</span> are identically distributed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q=\\tilde{\\rho}F+R</span> is uniformly random in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> conditioned on <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}Q(\\vec{\\alpha})=\\tilde{\\rho}v+z</span>, because <span class="math">R</span> is uniformly random in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and satisfies <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=z</span> (and <span class="math">F</span> is in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and satisfies <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=v</span>); and</li>

      <li><span class="math">Q_{\\mathrm{sim}}</span> is uniformly random in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> conditioned on <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}Q_{\\mathrm{sim}}(\\vec{\\alpha})=\\tilde{\\rho}v+z_{\\mathrm{sim}}</span>, because <span class="math">Q_{\\mathrm{sim}}</span> is sampled at random in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> conditioned on <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}Q_{\\mathrm{sim}}(\\vec{\\alpha})=\\tilde{\\rho}v+z_{\\mathrm{sim}}</span> and <span class="math">Q_{\\mathrm{sim}}(\\vec{\\gamma}_{i})=R_{\\mathrm{sim}}(\\vec{\\gamma}_{i})+\\tilde{\\rho}F(\\vec{\\gamma}_{i})</span> for some (adversarial) choice of <span class="math">\\vec{\\gamma}_{1},\\ldots,\\vec{\\gamma}_{k}</span>. But <span class="math">R_{\\mathrm{sim}}</span> is uniformly random in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>, so the latter condition says that <span class="math">Q_{\\mathrm{sim}}</span> matches a random polynomial on the set of points <span class="math">\\{\\vec{\\gamma}_{1},\\ldots,\\vec{\\gamma}_{k}\\}</span>, giving the claimed distribution for <span class="math">Q_{\\mathrm{sim}}</span>. ∎</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We explain how to modify <span class="math">S_{\\mathrm{slow}}</span> so as to reduce the running time to $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathfrak{q}_{\\tilde{V}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">S_{\\mathrm{slow}}</span>’s inefficiency arises from sampling two random polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>, namely <span class="math">R_{\\mathrm{sim}}</span> and <span class="math">Q_{\\mathrm{sim}}</span>, subject to certain constraints, and using them to answer <span class="math">\\tilde{V}</span>’s messages and queries. We observe (and carefully justify below) that all information about <span class="math">R_{\\mathrm{sim}}</span> and <span class="math">Q_{\\mathrm{sim}}</span> received by <span class="math">\\tilde{V}</span> is answers to queries of the form “given <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{\\leq m}</span>, return the value $A(\\vec{\\gamma}):=\\sum_{\\vec{\\alpha}\\in H^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\gamma}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}A(\\vec{\\gamma},\\vec{\\alpha})<span class="math">” for a random </span>A\\in\\mathbb{F}^{<d}[X_{1},\\ldots,X_{m}]<span class="math">, possibly conditioned on previous such queries; when </span>\\vec{\\gamma}<span class="math"> has length zero we use the symbol </span>\\bot<span class="math">, so that </span>A(\\bot)<span class="math"> denotes </span>\\sum_{\\vec{\\alpha}\\in H^{m}}A(\\vec{\\alpha})<span class="math">. The new simulator can use the algorithm </span>\\mathcal{A}$ from our Corollary 4.10 to adaptively answer such queries, without ever explicitly sampling the two polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now argue that all information about <span class="math">R_{\\mathrm{sim}}</span> and <span class="math">Q_{\\mathrm{sim}}</span> received by <span class="math">\\tilde{V}</span> from <span class="math">S_{\\mathrm{slow}}</span> can be viewed as queries of the above form, by discussing each step of <span class="math">S_{\\mathrm{slow}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Step 1, <span class="math">S_{\\mathrm{slow}}</span> draws a uniformly random <span class="math">R_{\\mathrm{sim}}\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> and sends <span class="math">z_{\\mathrm{sim}}=R_{\\mathrm{sim}}(\\bot)</span>.</li>

      <li>In Step 2, <span class="math">S_{\\mathrm{slow}}</span> answers any query <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span> to <span class="math">R</span> with <span class="math">R_{\\mathrm{sim}}(\\vec{\\gamma})</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Step 3,  <span class="math">S_{\\mathrm{slow}}</span>  draws a uniformly random  <span class="math">Q_{\\mathrm{sim}} \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>  conditioned on  <span class="math">Q_{\\mathrm{sim}}(\\bot) = \\tilde{\\rho} v + z_{\\mathrm{sim}}</span>  and also on  <span class="math">Q_{\\mathrm{sim}}(\\vec{\\gamma}) = R_{\\mathrm{sim}}(\\vec{\\gamma}) + \\tilde{\\rho} F(\\vec{\\gamma})</span>  for at most  <span class="math">q_{\\tilde{V}}</span>  points  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span>  (namely, the points corresponding to queries in Step 2).</li>

      <li>In Step 4,  <span class="math">S_{\\mathrm{slow}}</span>  replies any query  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span>  to  <span class="math">R</span>  with  <span class="math">Q_{\\mathrm{sim}}(\\vec{\\gamma}) - \\tilde{\\rho} F(\\vec{\\gamma})</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- In Step 5,  <span class="math">S_{\\mathrm{slow}}</span>  runs the sumcheck protocol with  <span class="math">\\tilde{V}</span>  on  <span class="math">Q_{\\mathrm{sim}}</span> , which requires computing univariate polynomials of the form  $\\sum_{\\vec{\\alpha} \\in H^{m -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\theta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}} Q_{\\mathrm{sim}}(\\vec{\\theta}, X, \\vec{\\alpha}) \\in \\mathbb{F}[X]<span class="math">  for various choices of  </span>\\vec{\\theta} \\in \\mathbb{F}^{&lt;m}<span class="math"> . Each of these polynomials has degree less than  </span>d<span class="math"> , and so can be obtained by interpolation from its evaluation at any  </span>d<span class="math">  distinct points; each of these is the answer of a query  </span>Q_{\\mathrm{sim}}(\\vec{\\gamma})<span class="math">  of the required form, with  </span>\\vec{\\gamma} = (\\vec{\\theta}, \\delta)<span class="math">  for some  </span>\\delta \\in \\mathbb{F}<span class="math"> . Overall, during the protocol,  </span>S_{\\mathrm{slow}}<span class="math">  only needs to query  </span>Q_{\\mathrm{sim}}<span class="math">  at  </span>md<span class="math">  points  </span>\\vec{\\gamma} \\in \\mathbb{F}^{\\leq m}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In sum, we can modify  <span class="math">S_{\\mathrm{slow}}</span>  so that instead of explicitly sampling  <span class="math">R_{\\mathrm{sim}}</span>  and  <span class="math">Q_{\\mathrm{sim}}</span> , it uses  <span class="math">\\mathcal{A}</span>  to sample the answer for each query to  <span class="math">Q_{\\mathrm{sim}}</span>  or  <span class="math">R_{\\mathrm{sim}}</span> , conditioning the uniform distribution on the answers to previous queries. Putting all of this together, we obtain the simulator  <span class="math">S_{\\mathrm{IP}}</span>  described below, whose output is identically distributed to the output of  <span class="math">S_{\\mathrm{slow}}</span> .</p>

    <p class="text-gray-300">The simulator  <span class="math">S_{\\mathrm{IP}}</span> , given straightline access to  <span class="math">\\tilde{V}</span>  and oracle access to  <span class="math">F</span> , works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\mathsf{ans}_{R_{\\mathrm{sim}}}</span>  be a subset of  <span class="math">\\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span>  that records query-value pairs for  <span class="math">R_{\\mathrm{sim}}</span> .</li>

      <li>Whenever  <span class="math">\\tilde{V}</span>  queries  <span class="math">F</span>  at  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> , return  <span class="math">F(\\vec{\\gamma})</span> ; whenever  <span class="math">\\tilde{V}</span>  queries  <span class="math">R</span>  at  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> , return  <span class="math">\\beta := \\mathcal{A}(\\mathbb{F}, m, d, H, \\mathsf{ans}_{R_{\\mathrm{sim}}}, \\vec{\\gamma})</span> . In the latter case, add  <span class="math">(\\vec{\\gamma}, \\beta)</span>  to  <span class="math">\\mathsf{ans}_{R_{\\mathrm{sim}}}</span> .</li>

      <li>Send  <span class="math">z_{\\mathrm{sim}} \\coloneqq \\mathcal{A}(\\mathbb{F}, m, d, H, \\mathsf{ans}_{R_{\\mathrm{sim}}}, \\bot)</span> , and add  <span class="math">(\\bot, z_{\\mathrm{sim}})</span>  to  <span class="math">\\mathsf{ans}_{R_{\\mathrm{sim}}}</span> .</li>

      <li>Receive  <span class="math">\\tilde{\\rho}</span>  from  <span class="math">\\tilde{V}</span> , and compute  <span class="math">\\mathsf{ans}_{Q_{\\mathrm{sim}}} := \\{(\\vec{\\gamma}, \\beta + \\tilde{\\rho} F(\\vec{\\gamma}))\\}_{(\\vec{\\gamma}, \\beta) \\in \\mathsf{ans}_{R_{\\mathrm{sim}}}}</span> ; this subset of  <span class="math">\\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span>  records query-value pairs for  <span class="math">Q_{\\mathrm{sim}}</span> . Note that  <span class="math">\\mathsf{ans}_{Q_{\\mathrm{sim}}}</span>  includes the pair  <span class="math">(\\bot, \\tilde{\\rho} v + z_{\\mathrm{sim}})</span>  because  <span class="math">F(\\bot) = v</span>  by assumption.</li>

      <li>Hereafter: whenever  <span class="math">\\tilde{V}</span>  queries  <span class="math">F</span>  at  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> , return  <span class="math">F(\\vec{\\gamma})</span> ; whenever  <span class="math">\\tilde{V}</span>  queries  <span class="math">R</span>  at  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> , return  <span class="math">\\beta&#x27; := \\beta - \\tilde{\\rho} F(\\vec{\\gamma})</span>  where  <span class="math">\\beta := \\mathcal{A}(\\mathbb{F}, m, d, H, \\mathsf{ans}_{Q_{\\mathrm{sim}}}, \\vec{\\gamma})</span> . In the latter case, add  <span class="math">(\\vec{\\gamma}, \\beta)</span>  to  <span class="math">\\mathsf{ans}_{Q_{\\mathrm{sim}}}</span> .</li>

      <li>Run the sumcheck protocol with  <span class="math">\\tilde{V}</span>  on  <span class="math">Q_{\\mathrm{sim}}</span> , by using the algorithm  <span class="math">\\mathcal{A}</span>  and updating  <span class="math">\\mathsf{ans}_{Q_{\\mathrm{sim}}}</span>  appropriately. (Note that  <span class="math">\\tilde{V}</span>  may query  <span class="math">F</span>  or  <span class="math">R</span>  before, during, or after this protocol.)</li>

      <li>Output the view of the simulated  <span class="math">\\tilde{V}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that  <span class="math">S_{\\mathrm{IP}}</span>  makes the same number of queries to  <span class="math">F</span>  as  <span class="math">S_{\\mathrm{slow}}</span>  does. Also, the number of pairs in  <span class="math">\\mathsf{ans}_{R_{\\mathrm{sim}}}</span>  is at most  <span class="math">q_{\\tilde{V}} + md + 1</span> ; ditto for  <span class="math">\\mathsf{ans}_{Q_{\\mathrm{sim}}}</span> . Since the algorithm  <span class="math">\\mathcal{A}</span>  is called at most  <span class="math">q_{\\tilde{V}} + md</span>  times, the running time of  <span class="math">S_{\\mathrm{IP}}</span>  is  $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathfrak{q}_{\\tilde{V}})$ , as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The IP described and analyzed in Section 5.1 is in the "  <span class="math">R</span> -hybrid" model. We now compile that IP into an IPCPP, by using proximity testing and self-correction, thereby concluding the proof of the PZK Sumcheck Theorem.</p>

    <p class="text-gray-300">Proof of Theorem 5.3. Construct an IPCPP system  <span class="math">(P,V)</span>  for sumcheck as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">P</span> , given input  <span class="math">(\\mathbb{F}, m, d, H, v)</span>  and oracle access to  <span class="math">F</span> , samples a uniformly random polynomial  <span class="math">R \\in \\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>  and sends its evaluation  <span class="math">\\pi \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  to the verifier  <span class="math">V</span> . Then  <span class="math">P</span>  simulates  <span class="math">P_{\\mathrm{IP}}^{F,R}(\\mathbb{F}, m, d, H, v)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier  <span class="math">V</span> , after receiving a proof string  <span class="math">\\pi \\colon \\mathbb{F}^m \\to \\mathbb{F}</span> , simulates  <span class="math">V_{\\mathrm{IP}}^{F,\\pi}(\\mathbb{F}, m, d, H, v)</span>  up to  <span class="math">V_{\\mathrm{IP}}</span> 's single query  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span>  to  <span class="math">\\pi</span>  (which occurs after the interaction), which  <span class="math">V</span>  does not answer directly but instead answers as follows. First,  <span class="math">V</span>  checks that  <span class="math">\\pi</span>  is  <span class="math">\\varrho</span> -close to the evaluation of a polynomial in  <span class="math">\\mathbb{F}^{&amp;lt;d}[X_1, \\ldots, X_m]</span>  by performing an individual-degree test with proximity parameter  <span class="math">\\varrho \\coloneqq \\frac{1}{8}</span>  and soundness error  $\\epsilon \\coloneqq \\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  [GS06, GR15]; then,  </span>V<span class="math">  computes  </span>\\pi(\\vec{\\alpha})<span class="math">  via self-correction with soundness error  </span>\\epsilon<span class="math">  [RS96, AS03], and replies with that value. Both procedures require  </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m + d)<span class="math">  queries and time. Finally,  </span>V<span class="math">  rejects if  </span>V_{\\mathrm{IP}}$  rejects or the individual degree test rejects.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness and perfect zero knowledge of  <span class="math">(P,V)</span>  are inherited, in a straightforward way, from those of  <span class="math">(P_{\\mathrm{IP}},V_{\\mathrm{IP}})</span> . We now argue soundness. So consider an instance-witness pair  <span class="math">\\left((\\mathbb{F},m,d,H,v),F\\right)\\in \\mathcal{R}_{\\mathrm{SC}}^{m}</span>  and a malicious prover  <span class="math">\\tilde{P}</span> , and denote by  <span class="math">\\tilde{\\pi}:\\mathbb{F}^m\\to \\mathbb{F}</span>  the proof string sent by  <span class="math">\\tilde{P}</span> . We distinguish between the following two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\tilde{\\pi}</span> is <span class="math">\\varrho</span>-far from evaluations of polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>.</li>

    </ul>

    <p class="text-gray-300">In this case, the low-degree test accepts with probability at most <span class="math">\\epsilon</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">\\tilde{\\pi}</span> is <span class="math">\\varrho</span>-close to evaluations of polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case, let <span class="math">\\tilde{R}</span> be the unique polynomial in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> whose evaluation is <span class="math">\\varrho</span>-close to <span class="math">\\tilde{\\pi}</span>; this polynomial exists because <span class="math">\\varrho</span> is less than the unique decoding radius (of the corresponding Reed–Muller code), which equals $\\frac{1}{2}(1-\\frac{d-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{m}<span class="math">, and is at least </span>\\frac{1}{4}<span class="math"> by the assumption that </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{1}{2}<span class="math">. By the soundness of </span>(P_{\\mathrm{IP}},V_{\\mathrm{IP}})<span class="math">, the probability that </span>V_{\\mathrm{IP}}^{F,\\tilde{R}}<span class="math"> accepts is at most </span>\\frac{md+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (see Lemma 5.5). However </span>V<span class="math"> only has access to </span>\\tilde{\\pi}<span class="math">, and uses self-correction on it to compute </span>\\tilde{R}<span class="math"> at the single location </span>\\vec{\\alpha}\\in\\mathbb{F}^{m}<span class="math"> required by </span>V_{\\mathrm{IP}}<span class="math">; the probability that the returned value is not correct is at most </span>\\epsilon<span class="math">. Hence, by a union bound, </span>V<span class="math"> accepts with probability at most </span>\\frac{md+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overall, we deduce that <span class="math">V</span> accepts with probability at most $\\max\\{\\epsilon\\,,\\,\\frac{md+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\epsilon\\}\\leq 3\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-98" class="text-base font-medium mt-4">Remark 5.6 (is interaction needed?).</h6>

    <p class="text-gray-300">One may be tempted to “flatten” the IPCPP used to prove Theorem 5.3, by sending a single PCP that already contains all possible transcripts, relative to all possible <span class="math">\\rho</span>’s. Such a modification does indeed preserve completeness and soundness. (In fact, even a small subset of <span class="math">\\rho</span>’s is enough for constant soundness error, because only one <span class="math">\\rho</span> in <span class="math">\\mathbb{F}</span> is “bad”.) However, this modification does not preserve zero knowledge: if a verifier learns, say, the partial sums <span class="math">\\alpha_{1}:=\\rho_{1}F(\\vec{\\gamma})+R(\\vec{\\gamma})</span> and <span class="math">\\alpha_{2}:=\\rho_{2}F(\\vec{\\gamma})+R(\\vec{\\gamma})</span> for <span class="math">\\rho_{1}\\neq\\rho_{2}</span> and some <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{\\leq m}</span> then he also learns <span class="math">F(\\vec{\\gamma})=\\frac{\\alpha_{1}-\\alpha_{2}}{\\rho_{1}-\\rho_{2}}</span>, violating zero knowledge. (Yet, the modification does preserve honest-verifier zero knowledge.)</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Remark 5.7 (space complexity of the prover).</h6>

    <p class="text-gray-300">The prover in a zero knowledge protocol is a probabilistic function, and hence reads bits from its randomness tape. In the case of the above protocol, the prover <span class="math">P</span> must sample the evaluation of a random polynomial <span class="math">R</span> in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>; the entropy of <span class="math">R</span> is exponential and thus requires reading an exponential number of random bits from the randomness tape. (Beyond this, <span class="math">P</span> requires no other randomness.)</p>

    <p class="text-gray-300">It is easy to see that <span class="math">P</span> can run in exponential time and space. However, if the prover has two-way access to its random tape, <span class="math">P</span> can run in exponential time and polynomial space: the prover treats the random tape as the coefficients of <span class="math">R</span>, computing an evaluation at a given point by reading the tape coefficient-by-coefficient and summing the contributions of each monomial.</p>

    <p class="text-gray-300">Two-way access to the randomness tape is a relaxation of the standard definition, which permits only one-way access to it <em>[x20]</em>; that is, random bits must be stored on the work tape in order to be accessed again. It is not known whether the relaxation makes polynomial-space machines more powerful for decision problems (the class is equivalent to “almost”-PSPACE <em>[x1]</em>), nor do we know how to obtain a polynomial-space prover with only one-way access. Nevertheless, we believe that polynomial space with two-way access to the random tape is still quite meaningful, e.g., it yields standard polynomial space relative to a random oracle.</p>

    <p class="text-gray-300">We prove that  <span class="math">\\# \\mathbf{P}</span>  has an IPCP that is perfect zero knowledge against unbounded queries. (Recall that  <span class="math">\\# \\mathbf{P}</span>  corresponds to all counting problems associated to decision problems in NP.) We do so by constructing a suitable protocol for the counting problem associated to 3SAT, which is  <span class="math">\\# \\mathbf{P}</span> -complete.</p>

    <p class="text-gray-300">Definition 6.1. Let  <span class="math">\\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  be the language of pairs  <span class="math">(\\phi, N)</span>  where  <span class="math">\\phi</span>  is a 3-CNF boolean formula and  <span class="math">N</span>  is the number of satisfying assignments of  <span class="math">\\phi</span> . We denote by  <span class="math">n</span>  the number of variables and by  <span class="math">c</span>  the number of clauses in  <span class="math">\\phi</span> .</p>

    <p class="text-gray-300">We construct a public-coin IPCP system for  <span class="math">\\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  that is perfect zero knowledge against unbounded queries, and has exponential proof length and polynomial query complexity. As in the non-ZK IP counterpart, the number of rounds is  <span class="math">O(n)</span> , the prover runs in space  <span class="math">\\mathrm{poly}(c)</span>  (with a caveat, see Remark 5.7), and the verifier in time  <span class="math">\\mathrm{poly}(c)</span> .</p>

    <p class="text-gray-300">Theorem 6.2 (formal statement of 1.2). There exists a IPCP system  <span class="math">(P,V)</span>  that puts  <span class="math">\\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK-IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(n)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">exp(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(c)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover space</td>

            <td class="px-3 py-2 border-b border-gray-700">sp</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(c)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(c)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the verifier  <span class="math">V</span>  is public-coin and non-adaptive.</p>

    <p class="text-gray-300">Proof. Let  <span class="math">(P_{\\mathrm{SC}}, V_{\\mathrm{SC}})</span>  be the PZK IPCPP system for sumcheck from Theorem 5.3, and let  <span class="math">S_{\\mathrm{SC}}</span>  be any simulator attesting to its perfect zero knowledge. We construct an IPCP system  <span class="math">(P, V)</span>  for  <span class="math">\\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">P</span> , given an instance  <span class="math">(\\phi, N)</span> , finds a prime  <span class="math">q \\in (2^n, 2^{2n}]</span> , computes the arithmetization  <span class="math">p_{\\phi} \\in \\mathbb{F}_q^{&amp;lt;3c}[X_1, \\ldots, X_n]</span>  of  <span class="math">\\phi</span>  and simulates  <span class="math">P_{\\mathrm{SC}}^F(\\mathbb{F}, m, d, H, v)</span>  with  <span class="math">\\mathbb{F} := \\mathbb{F}_q</span> ,  <span class="math">m := n</span> ,  <span class="math">d := 3c</span> ,  <span class="math">H := \\{0, 1\\}</span> ,  <span class="math">v := N</span> , and  <span class="math">F(X_1, \\ldots, X_n) := p_{\\phi}(X_1, \\ldots, X_n)</span> . (The prover  <span class="math">P</span>  also communicates the prime  <span class="math">q</span>  to the  <span class="math">V</span>  verifier.)</li>

      <li>The verifier  <span class="math">V</span> , given an instance  <span class="math">(\\phi, N)</span> , also computes  <span class="math">\\mathbb{F}, m, d, H, v, F</span> , and then simulates  <span class="math">V_{\\mathrm{SC}}^F(\\mathbb{F}, m, d, H, v)</span> , and accepts if and only if the simulation accepts.</li>

    </ul>

    <p class="text-gray-300">Note that the arithmetization of a 3-CNF formula  <span class="math">\\phi</span>  can be computed in time  <span class="math">\\mathrm{poly}(c)</span> , and the claimed given efficiency parameters follow from Theorem 5.3. We now argue completeness, then soundness, and finally perfect zero knowledge.</p>

    <p class="text-gray-300">Completeness. Completeness follows from the completeness of  <span class="math">(P_{\\mathrm{SC}}, V_{\\mathrm{SC}})</span>  and the fact that if  <span class="math">(\\phi, N) \\in \\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  then  <span class="math">((\\mathbb{F}, m, d, H, v), F) = ((\\mathbb{F}_q, n, 3c, \\{0, 1\\}^n, N), p_\\phi) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span> .</p>

    <p class="text-gray-300">Soundness. Soundness follows from the soundness of  <span class="math">(P_{\\mathrm{SC}}, V_{\\mathrm{SC}})</span>  and the fact that if  <span class="math">(\\phi, N) \\notin \\mathcal{L}_{\\#3\\mathrm{SAT}}</span>  then  <span class="math">((\\mathbb{F}, m, d, H, v), F) = ((\\mathbb{F}_q, n, 3c, \\{0, 1\\}^n, N), p_\\phi) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{res}}</span> .</p>

    <p class="text-gray-300">Perfect zero knowledge. We construct a simulator  <span class="math">S</span>  that provides perfect zero knowledge. Given an instance  <span class="math">(\\phi, N)</span>  and straightline access to a verifier  <span class="math">\\tilde{V}</span> , the simulator  <span class="math">S</span>  computes  <span class="math">\\mathbb{F}, m, d, H, v, F</span>  as above and simulates  <span class="math">S_{\\mathrm{SC}}^{\\tilde{V},F}(\\mathbb{F}, m, d, H, v)</span> . By the perfect zero knowledge property of  <span class="math">(P_{\\mathrm{SC}}, V_{\\mathrm{SC}})</span> , the simulator's output is identically distributed to View  <span class="math">\\langle P_{\\mathrm{SC}}^{F}(\\mathbb{F}, m, d, H, v), \\tilde{V}^{F} \\rangle</span> ; but note that  <span class="math">\\tilde{V}</span>  does not query any oracles outside of its interaction with  <span class="math">P_{\\mathrm{SC}}</span>  so that  <span class="math">\\tilde{V}^{F} = \\tilde{V}</span> . By the construction of  <span class="math">P</span>  above, this view equals View  <span class="math">\\langle P(\\phi, N), \\tilde{V} \\rangle</span> , as desired.</p>

    <p class="text-gray-300">7 Perfect zero knowledge from succinct constraint detection</p>

    <p class="text-gray-300">We show how to obtain perfect zero knowledge <span class="math">2</span>-round IOPs of Proximity for <em>any</em> linear code that has proximity proofs with succinct constraint detection (Section 7.1). Afterwards, we instantiate this general transformation for the case of Reed–Solomon codes (Section 7.2), whose proximity proofs we discussed in Section 4.3.</p>

    <h3 id="sec-101" class="text-xl font-semibold mt-8">7.1 A general transformation</h3>

    <h4 id="sec-102" class="text-lg font-semibold mt-6">PCPs of proximity for codes.</h4>

    <p class="text-gray-300">A <em>PCP of Proximity</em> <em>[x10, BGH^{+}06]</em> for a code family <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> is a pair <span class="math">(P_{\\mathscr{C}},V_{\\mathscr{C}})</span> where for every index <span class="math">\\mathfrak{n}</span> and <span class="math">w\\in\\mathbb{F}^{D(\\mathfrak{n})}</span>: if <span class="math">w\\in C_{\\mathfrak{n}}</span> then <span class="math">V_{\\mathscr{C}}^{w,\\pi}(\\mathfrak{n})</span> accepts with probability <span class="math">1</span> with <span class="math">\\pi:=P(\\mathfrak{n},w)</span>; if <span class="math">w</span> is ‘far’ from <span class="math">C_{\\mathfrak{n}}</span> then <span class="math">w\\in C_{\\mathfrak{n}}</span> rejects with high probability regardless of <span class="math">\\pi</span>. We do not formally define this notion because it is a special case of a <span class="math">1</span>-round IOP of Proximity (see Section 3.2.3) where the verifier message is empty; we use <span class="math">\\mathbf{PCPP}[l,\\mathfrak{q},\\varepsilon,\\delta,\\mathfrak{tp},\\mathfrak{tv}]</span> to denote the corresponding complexity class. Note that, since both <span class="math">\\pi</span> and <span class="math">w</span> are provided as oracles to <span class="math">V</span>, the query complexity of <span class="math">V</span> is the <em>total</em> number of queries across both oracles.</p>

    <h4 id="sec-103" class="text-lg font-semibold mt-6">Leakage from proximity proofs.</h4>

    <p class="text-gray-300">While proximity proofs facilitate local testing, they are a liability for zero knowledge: in principle even a single query to <span class="math">\\pi</span> may ‘summarize’ information that needs many queries to <span class="math">w</span> to simulate. (This holds for BS proximity proofs <em>[x1]</em>, for instance.) Our construction facilitates local testing while avoiding this leakage.</p>

    <h4 id="sec-104" class="text-lg font-semibold mt-6">Perfect zero knowledge IOPs of Proximity.</h4>

    <p class="text-gray-300">The notion of zero knowledge for IOPs of Proximity that we target is defined in Section 3.3.2 and is analogous to <em>[x22]</em>’s notion for PCPs of Proximity (a special case of our setting). Informally, it requiress an algorithm that simulates the verifier’s view by making as many queries to <span class="math">w</span> as the <em>total</em> number of verifier queries to either <span class="math">w</span> or any oracles sent by the prover; intuitively, this means that any bit of any message oracle reveals no more information than one bit of <span class="math">w</span>.</p>

    <h4 id="sec-105" class="text-lg font-semibold mt-6">A generic ‘masking’ construction.</h4>

    <p class="text-gray-300">Suppose that the linear code family <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> has a PCP of Proximity. Consider the <span class="math">2</span>-round IOP of Proximity that uses masking via random self-reducibility (similarly to <em>[x5]</em>) as follows. The prover and verifier have input <span class="math">\\mathfrak{n}</span> and oracle access to a codeword <span class="math">w</span>, and the prover wants to convince the verifier that <span class="math">w</span> is close to <span class="math">C_{\\mathfrak{n}}</span>. Rather than sending a proximity proof for <span class="math">w</span>, the prover samples a random codeword <span class="math">z\\in C_{\\mathfrak{n}}</span> and sends it to the verifier; the verifier replies with a random field element <span class="math">\\rho</span>; the prover sends a proximity proof for the new codeword <span class="math">\\rho w+z</span>. Completeness follows from linearity of <span class="math">C_{\\mathfrak{n}}</span>; soundness follows from the fact that if <span class="math">w</span> is far from <span class="math">C_{\\mathfrak{n}}</span> then so is the word <span class="math">\\rho w+z</span> for every <span class="math">z</span> with high probability over <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Perfect zero knowledge intuitively follows from the observation that <span class="math">\\rho w+z</span> is essentially a random codeword (up to malicious choice of <span class="math">\\rho</span>). We formally prove this for the case where <em>the linear code family consisting of the concatenation of codewords in <span class="math">\\mathscr{C}</span> with corresponding proximity proofs has succinct constraint detection</em>.</p>

    <p class="text-gray-300">We are now ready to turn the above discussions into formal definitions and proofs. Throughout, given a code family <span class="math">\\mathscr{C}</span>, we denote by <span class="math">\\mathrm{Rel}(\\mathscr{C})</span> the relation consisting of all pairs <span class="math">(\\mathfrak{n},w)</span> such that <span class="math">w\\in C_{\\mathfrak{n}}</span>.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Definition 7.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>, and let <span class="math">(P,V)</span> be a PCPP system for <span class="math">\\mathrm{Rel}(\\mathscr{C})</span>. We say that <span class="math">(P,V)</span> is <em>linear</em> if <span class="math">P</span> is deterministic and is linear in its input codeword: for every index <span class="math">\\mathfrak{n}</span> there exists a matrix <span class="math">A_{\\mathfrak{n}}</span> with entries in <span class="math">\\mathbb{F}(\\mathfrak{n})</span> such that <span class="math">P(\\mathfrak{n},w)=A_{\\mathfrak{n}}\\cdot w</span> for all <span class="math">w\\in C_{\\mathfrak{n}}</span> (equivalently, the set $\\{\\,w\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(\\mathfrak{n},w)\\,\\}_{w\\in C_{\\mathfrak{n}}}$ is a linear code).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-107" class="text-base font-medium mt-4">Definition 7.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span> and alphabet <span class="math">\\mathbb{F}(\\cdot)</span>, and let <span class="math">(P,V)</span> be a PCPP system for <span class="math">\\mathrm{Rel}(\\mathscr{C})</span>. We say that <span class="math">(P,V)</span> has <span class="math">T(\\cdot,\\cdot)</span>-time constraint detection if <span class="math">(P,V)</span> is linear and, moreover, the linear code family <span class="math">\\mathscr{L}=\\{L_{\\mathfrak{n}}\\}</span> has <span class="math">T(\\cdot,\\cdot)</span>-time constraint detection, where $L_{\\mathfrak{n}}:=\\{\\,w\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(\\mathfrak{n},w)\\,\\}_{w\\in C_{\\mathfrak{n}}}<span class="math">; we also say that </span>(P,V)<span class="math"> has succinct constraint detection if the same holds with </span>T(\\mathfrak{n},\\ell)=\\mathrm{poly}(\\mathfrak{n}+\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-108" class="text-base font-medium mt-4">Theorem 7.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathscr{C}=\\{C_{\\mathfrak{n}}\\}_{\\mathfrak{n}}</span> be a linear code family with domain <span class="math">D(\\cdot)</span>, alphabet <span class="math">\\mathbb{F}(\\cdot)</span>, block length <span class="math">\\ell(\\cdot)</span>, and a <span class="math">S(\\cdot)</span>-time sampler. Suppose that there exists a PCPP system <span class="math">(P_{\\mathscr{C}},V_{\\mathscr{C}})</span> for <span class="math">\\mathrm{Rel}(\\mathscr{C})</span> that (is linear and) has succinct</p>

    <p class="text-gray-300">constraint detection and puts  <span class="math">\\operatorname{Rel}(\\mathcal{C})</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PCPP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">lC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">εC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proximity parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">δC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tpC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tvC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">rvC(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then there exists an IOPP system  <span class="math">(P,V)</span>  that puts  <span class="math">\\operatorname{Rel}(\\mathcal{C})</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK-IOPP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= lC(n) + ℓ(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2qC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= εC(n) + 1/</td>

            <td class="px-3 py-2 border-b border-gray-700">F(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proximity parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">δ(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= 2δC(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= tpC(n) + S(n) + O(ℓ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= tvC(n) + O(qC(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier randomness</td>

            <td class="px-3 py-2 border-b border-gray-700">rv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= rvC(n) + log</td>

            <td class="px-3 py-2 border-b border-gray-700">F(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">= *</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 7.4 (the case of LTCs). It is tempting to apply Theorem 7.3 to the notable special case where the proximity proof is empty (e.g., when  <span class="math">\\mathcal{C}</span>  is locally testable so no proximity proofs are needed). However, in this case, the zero knowledge guarantee of our construction does not buy anything compared to when the verifier queries only the codeword (indeed, the verifier already learns precisely the value of codeword at those positions which it queries and nothing else).</p>

    <p class="text-gray-300"><strong>Construction 7.5.</strong> The IOPP system  <span class="math">(P, V)</span>  is defined as follows. The prover receives a pair  <span class="math">(\\mathfrak{n}, w)</span>  as input, while the verifier receives the index  <span class="math">\\mathfrak{n}</span>  as input and  <span class="math">w</span>  as an oracle. The interaction proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P</span>  samples a random codeword  <span class="math">z</span>  in  <span class="math">C_{\\mathfrak{n}}</span>  and sends  <span class="math">z</span>  to  <span class="math">V</span> ;</li>

      <li><span class="math">V</span>  samples a random element  <span class="math">\\rho</span>  in  <span class="math">\\mathbb{F}(\\mathfrak{n})</span>  and sends  <span class="math">\\rho</span>  to  <span class="math">P</span> ;</li>

      <li><span class="math">P</span>  computes the proof  <span class="math">\\pi \\coloneqq P_{\\mathcal{C}}(\\mathfrak{n},\\rho w + z)</span>  and sends  <span class="math">\\pi</span>  to  <span class="math">V</span> ;</li>

      <li><span class="math">V</span>  checks that  <span class="math">V_{\\mathcal{C}}^{w&#x27;, \\pi}(\\mathfrak{n})</span>  accepts, where  <span class="math">w&#x27; := \\rho w + z</span>  (any query  <span class="math">\\alpha</span>  to  <span class="math">w&#x27;</span>  is computed as  <span class="math">\\rho w(\\alpha) + z(\\alpha)</span> ).</li>

    </ol>

    <p class="text-gray-300">The round complexity, proof length, query complexity, and prover and verifier complexities claimed in Theorem 7.3 follow in a straightforward way from Construction 7.5. We now argue completeness and soundness (Claim 7.6) and perfect zero knowledge (Claim 7.7).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 7.6. The IOPP system  <span class="math">(P,V)</span>  has completeness 1 and soundness error  $\\varepsilon (\\mathfrak{n}) = \\varepsilon_{\\mathcal{C}}(\\mathfrak{n}) + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. First we argue completeness. Suppose that the instance-witness pair  <span class="math">(\\mathfrak{n}, w)</span>  is in the relation  <span class="math">\\operatorname{Rel}(\\mathcal{C})</span> , i.e., that the word  <span class="math">w</span>  is in the code  <span class="math">C_{\\mathfrak{n}}</span> . Then, the linearity of  <span class="math">C_{\\mathfrak{n}}</span>  implies that, for every word  <span class="math">z</span>  in  <span class="math">C_{\\mathfrak{n}}</span>  and element  <span class="math">\\rho</span>  in  <span class="math">\\mathbb{F}(\\mathfrak{n})</span> , the word  <span class="math">\\rho w + z</span>  is also in  <span class="math">C_{\\mathfrak{n}}</span> . Thus completeness of  <span class="math">(P, V)</span>  follows from the completeness of  <span class="math">(P_{\\mathcal{C}}, V_{\\mathcal{C}})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we argue soundness. Suppose that  <span class="math">w</span>  is  <span class="math">2\\delta_{\\mathcal{C}}(\\mathfrak{n})</span> -far from  <span class="math">C_{\\mathfrak{n}}</span> . For every word  <span class="math">z</span>  in  <span class="math">\\mathbb{F}(\\mathfrak{n})^{\\ell(\\mathfrak{n})}</span>  (not necessarily in  <span class="math">C_{\\mathfrak{n}}</span> ), there exists at most one  <span class="math">\\rho</span>  in  <span class="math">\\mathbb{F}(\\mathfrak{n})</span>  such that  <span class="math">\\rho w + z</span>  is  <span class="math">\\delta_{\\mathcal{C}}(\\mathfrak{n})</span> -close to  <span class="math">C_{\\mathfrak{n}}</span>  (see Claim 3.1). The soundness of  <span class="math">(P_{\\mathcal{C}}, V_{\\mathcal{C}})</span>  implies that  <span class="math">V_{\\mathcal{C}}</span>  accepts with probability at most  <span class="math">\\varepsilon_{\\mathcal{C}}(\\mathfrak{n})</span>  if  <span class="math">V_{\\mathcal{C}}</span>  is invoked on a word that is  <span class="math">\\delta_{\\mathcal{C}}(\\mathfrak{n})</span> -far from  <span class="math">C_{\\mathfrak{n}}</span> . Thus, since  <span class="math">V</span>  invokes  <span class="math">V_{\\mathcal{C}}</span>  on the word  <span class="math">\\rho w + z</span> , the probability that  <span class="math">V</span>  accepts is at most  $\\varepsilon_{\\mathcal{C}}(\\mathfrak{n}) + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim 7.7. There exists a straightline simulator  <span class="math">S</span>  such that, for every  <span class="math">(\\mathfrak{n}, w) \\in \\operatorname{Rel}(\\mathcal{C})</span>  and malicious verifier  <span class="math">\\tilde{V}</span> , the following two random variables are identically distributed</p>

    <div class="my-4 text-center"><span class="math-block">\\left(S ^ {\\tilde {V}, w} (\\mathfrak {n}), q _ {S}\\right) \\quad a n d \\quad \\left(\\operatorname {V i e w} \\langle P ^ {w} (\\mathfrak {n}), \\tilde {V} ^ {w} \\rangle , q _ {\\tilde {V}}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">q_{S}</span>  is the number of queries to  <span class="math">w</span>  made by  <span class="math">S</span>  and  <span class="math">q_{\\tilde{V}}</span>  is the number of queries to  <span class="math">w</span>  or to prover messages made by  <span class="math">\\tilde{V}</span> . Moreover,  <span class="math">S</span>  runs in time  <span class="math">\\mathrm{poly}(\\mathfrak{n} + \\mathfrak{q}_{\\tilde{V}})</span> , where  <span class="math">\\mathfrak{q}_{\\tilde{V}}</span>  is  <span class="math">\\tilde{V}</span> 's query complexity.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">We begin by proving perfect zero knowledge via a straightline simulator <span class="math">S_{\\text{slow}}</span> whose number of queries to <span class="math">w</span> equals <span class="math">q_{\\tilde{V}}</span>, but runs in time <span class="math">\\mathrm{poly}(\\mathsf{tp}(\\mathfrak{n})+q_{\\tilde{V}})</span>. After that, we explain how to modify <span class="math">S_{\\text{slow}}</span> into another simulator <span class="math">S</span>, with an identical output distribution, that runs in the faster time claimed in the lemma.</p>

    <p class="text-gray-300">The simulator <span class="math">S_{\\text{slow}}</span>, given straightline access to <span class="math">\\tilde{V}</span> and oracle access to <span class="math">w</span>, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Draw a uniformly random <span class="math">z_{\\text{sim}}\\in C_{\\mathfrak{n}}</span>.</li>

      <li>Whenever <span class="math">\\tilde{V}</span> queries <span class="math">w</span> at <span class="math">\\alpha\\in D(\\mathfrak{n})</span>, return <span class="math">w(\\alpha)</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">z</span> at <span class="math">\\alpha\\in D(\\mathfrak{n})</span>, return <span class="math">z_{\\text{sim}}(\\alpha)</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Receive <span class="math">\\tilde{\\rho}</span> from <span class="math">\\tilde{V}</span>, and draw a uniformly random $w_{\\text{sim}}^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\text{sim}}\\in L_{\\mathfrak{n}}<span class="math"> conditioned on </span>w_{\\text{sim}}^{\\prime}(\\alpha)=\\tilde{\\rho}w(\\alpha)+z_{\\text{sim}}(\\alpha)<span class="math"> for every coordinate </span>\\alpha\\in D(\\mathfrak{n})<span class="math"> queried in Step 2. (This latter condition requires querying </span>w<span class="math"> at </span>\\alpha<span class="math"> for every coordinate </span>\\alpha\\in D(\\mathfrak{n})<span class="math"> queried to </span>z_{\\text{sim}}$ in Step 2.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hereafter: whenever <span class="math">\\tilde{V}</span> queries <span class="math">w</span> at <span class="math">\\alpha\\in D(\\mathfrak{n})</span>, return <span class="math">w(\\alpha)</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">z</span> at <span class="math">\\alpha\\in D(\\mathfrak{n})</span>, return <span class="math">w_{\\text{sim}}^{\\prime}(\\alpha)-\\tilde{\\rho}w(\\alpha)</span>. (In either case, a query to <span class="math">w</span> is required.)</li>

      <li>Tell <span class="math">\\tilde{V}</span> that the oracle <span class="math">\\pi</span> has been ‘sent’; whenever <span class="math">\\tilde{V}</span> queries the <span class="math">i</span>-th entry of <span class="math">\\pi</span>, return the <span class="math">i</span>-th entry of <span class="math">\\pi_{\\text{sim}}</span>. (Note that <span class="math">\\tilde{V}</span> may query <span class="math">w</span> or <span class="math">z</span> before or after learning about <span class="math">\\pi</span>.)</li>

      <li>Output the view of the simulated <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">S_{\\text{slow}}</span> runs in time <span class="math">\\mathrm{poly}(\\mathsf{tp}(\\mathfrak{n})+q_{\\tilde{V}})</span>. Also, <span class="math">S_{\\text{slow}}</span> makes one query to <span class="math">w</span> for every query to <span class="math">w</span> or <span class="math">z</span> by <span class="math">\\tilde{V}</span> (at least provided that <span class="math">\\tilde{V}</span>’s queries have no duplicates, which we can assume without loss of generality), and zero queries to <span class="math">w</span> for every query to <span class="math">\\pi</span> by <span class="math">\\tilde{V}</span>. Thus, overall, the number of queries to <span class="math">w</span> by <span class="math">S_{\\text{slow}}</span> is at most <span class="math">q_{\\tilde{V}}</span>; clearly, this number of queries can be padded to be equal to <span class="math">q_{\\tilde{V}}</span>. We now argue that <span class="math">S_{\\text{slow}}</span>’s output is identically distributed to <span class="math">\\tilde{V}</span>’s view when interacting with the honest prover <span class="math">P</span>, for <span class="math">z</span> random in <span class="math">C_{\\mathfrak{n}}</span>.</p>

    <p class="text-gray-300">Claim. <span class="math">S_{\\text{slow}}^{\\tilde{V},w}\\equiv\\mathrm{View}\\;\\langle P^{w}(\\mathfrak{n}),\\tilde{V}^{w}\\rangle</span>.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Define the random variable <span class="math">w^{\\prime}:=\\tilde{\\rho}w+z</span>, where <span class="math">\\tilde{\\rho}</span> is chosen by <span class="math">\\tilde{V}</span>. Observe that there exists a (deterministic) function <span class="math">v(\\cdot)</span> such that</p>

    <p class="text-gray-300"><span class="math">\\mathrm{View}\\;\\langle P^{w,z},\\tilde{V}^{w,z}\\rangle=v(w^{\\prime},w,r)\\quad\\text{and}\\quad S_{\\text{slow}}^{\\tilde{V},w}=v(w_{\\text{sim}}^{\\prime},w,r)\\enspace,</span></p>

    <p class="text-gray-300">where the random variable <span class="math">r</span> is <span class="math">\\tilde{V}</span>’s private randomness. Indeed, (i) the messages sent and received by <span class="math">\\tilde{V}</span> are identical to those when interacting with <span class="math">P</span> on <span class="math">w^{\\prime}</span> and <span class="math">w_{\\text{sim}}^{\\prime}</span>, respectively; (ii) <span class="math">\\tilde{V}</span>’s queries to <span class="math">w</span> are answered honestly; (iii) <span class="math">\\tilde{V}</span>’s queries to <span class="math">z</span> are answered by <span class="math">z=w^{\\prime}-\\tilde{\\rho}w</span> and <span class="math">z_{\\text{sim}}=w_{\\text{sim}}^{\\prime}-\\tilde{\\rho}w</span> respectively; (iv) <span class="math">\\tilde{V}</span>’s queries to <span class="math">\\pi</span> are answered by <span class="math">P_{\\mathscr{C}}(\\mathfrak{n},w^{\\prime})</span> and <span class="math">P_{\\mathscr{C}}(\\mathfrak{n},w_{\\text{sim}}^{\\prime})</span> respectively. We are only left to argue that, for any choice of <span class="math">r</span>, <span class="math">w^{\\prime}</span> and <span class="math">w_{\\text{sim}}^{\\prime}</span> are identically distributed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">w^{\\prime}=\\tilde{\\rho}w+z</span> is uniformly random in <span class="math">C_{\\mathfrak{n}}</span>, because <span class="math">z</span> is uniformly random in <span class="math">C_{\\mathfrak{n}}</span>, <span class="math">w</span> is in <span class="math">C_{\\mathfrak{n}}</span>, and <span class="math">C_{\\mathfrak{n}}</span> is linear; and</li>

      <li><span class="math">w_{\\text{sim}}^{\\prime}</span> is uniformly random in <span class="math">C_{\\mathfrak{n}}</span>, because <span class="math">w_{\\text{sim}}^{\\prime}</span> is sampled at random in <span class="math">C_{\\mathfrak{n}}</span> conditioned on <span class="math">w_{\\text{sim}}^{\\prime}(\\alpha_{i})=z_{\\text{sim}}(\\alpha_{i})+\\tilde{\\rho}w(\\alpha_{i})</span> for some (adversarial) choice of <span class="math">\\alpha_{1},\\ldots,\\alpha_{k}</span>. But <span class="math">z_{\\text{sim}}</span> is uniformly random in <span class="math">C_{\\mathfrak{n}}</span>, so the latter condition says that <span class="math">w_{\\text{sim}}^{\\prime}</span> matches a random codeword on the set of points <span class="math">\\{\\alpha_{1},\\ldots,\\alpha_{k}\\}</span>, giving the claimed distribution for <span class="math">w_{\\text{sim}}^{\\prime}</span>. ∎</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We explain how to modify <span class="math">S_{\\text{slow}}</span> so as to reduce the running time to <span class="math">\\mathrm{poly}(\\mathfrak{n}+\\mathfrak{q}_{\\tilde{V}})</span>. The inefficiency of <span class="math">S_{\\text{slow}}</span> comes from sampling <span class="math">z_{\\text{sim}}\\in C_{\\mathfrak{n}}</span> and $w_{\\text{sim}}^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\text{sim}}\\in L_{\\mathfrak{n}}<span class="math">, which takes time </span>\\mathrm{poly}(S(\\mathfrak{n})+\\ell(\\mathfrak{n}))<span class="math"> and </span>\\mathrm{poly}(\\mathsf{tp}_{\\mathscr{C}}(\\mathfrak{n}))<span class="math"> respectively, which need not be polynomial in </span>\\mathfrak{n}$. In the following, we show how to not explicitly sample these codewords but, instead, adaptively sample them by relying on constraint detection.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First, note that if <span class="math">\\mathscr{L}</span> has constraint detection with a certain efficiency then so does <span class="math">\\mathscr{C}</span> with the same efficiency. The theorem’s hypothesis says that <span class="math">\\mathscr{L}</span> has succinct constraint detection; so both <span class="math">\\mathscr{C}</span> and <span class="math">\\mathscr{L}</span> have succinct constraint detection. We then invoke Lemma 4.3 to obtain probabilistic polynomial-time algorithms <span class="math">\\mathcal{A}_{\\mathscr{C}},\\mathcal{A}_{\\mathscr{L}}</span> for the code families <span class="math">\\mathscr{C},\\mathscr{L}</span> respectively. Using these algorithms, we write the more efficient simulator <span class="math">S</span>, as follows.</p>

    <p class="text-gray-300">Let <span class="math">D^{*}(\\mathfrak{n})</span> be the domain of <span class="math">L_{\\mathfrak{n}}</span>: this is the disjoint union of <span class="math">D(\\mathfrak{n})</span> (the domain of <span class="math">C_{\\mathfrak{n}}</span>) and <span class="math">[\\mathsf{l}_{\\mathcal{C}}(\\mathfrak{n})]</span> (the domain of <span class="math">P_{\\mathcal{C}}(\\mathfrak{n},C_{\\mathfrak{n}})</span>). The simulator <span class="math">S</span>, given straightline access to <span class="math">\\tilde{V}</span> and oracle access to <span class="math">w</span>, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{ans}_{z_{\\mathrm{sim}}}</span> be a subset of <span class="math">D(\\mathfrak{n})\\times \\mathbb{F}(\\mathfrak{n})</span> that records query-value pairs for <span class="math">z_{\\mathrm{sim}}</span>; initially, <span class="math">\\mathsf{ans}_{z_{\\mathrm{sim}}}</span> equals <span class="math">\\varnothing</span>.</li>

      <li>Whenever <span class="math">\\tilde{V}</span> queries <span class="math">w</span> at <span class="math">\\alpha \\in D(\\mathfrak{n})</span>, return <span class="math">w(\\alpha)</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">z</span> at <span class="math">\\alpha \\in D(\\mathfrak{n})</span>, return <span class="math">\\beta := \\mathcal{A}_{\\mathcal{C}}(\\mathfrak{n}, \\mathsf{ans}_{z_{\\mathrm{sim}}}, \\alpha)</span>. In the latter case, add <span class="math">(\\alpha, \\beta)</span> to <span class="math">\\mathsf{ans}_{z_{\\mathrm{sim}}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Receive <span class="math">\\tilde{\\rho}</span> from <span class="math">\\tilde{V}</span>, and compute <span class="math">\\mathsf{ans} := \\{(\\alpha, \\beta + \\tilde{\\rho} w(\\alpha))\\}_{(\\alpha, \\beta) \\in \\mathsf{ans}_{z_{\\mathrm{sim}}}}</span>; this subset of <span class="math">D^{*}(\\mathfrak{n}) \\times \\mathbb{F}(\\mathfrak{n})</span> records query-value pairs for $w_{\\mathrm{sim}}^{\\prime} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{sim}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hereafter: whenever <span class="math">\\tilde{V}</span> queries <span class="math">w</span> at <span class="math">\\alpha \\in D(\\mathfrak{n})</span>, return <span class="math">w(\\alpha)</span>; whenever <span class="math">\\tilde{V}</span> queries <span class="math">z</span> at <span class="math">\\alpha \\in D(\\mathfrak{n})</span>, return <span class="math">\\beta&#x27; := \\beta - \\tilde{\\rho} w(\\alpha)</span> where <span class="math">\\beta := \\mathcal{A}_{\\mathcal{L}}(\\mathfrak{n}, \\mathsf{ans}, \\alpha)</span> and add <span class="math">(\\alpha, \\beta)</span> to <span class="math">\\mathsf{ans}</span>.</li>

      <li>Tell <span class="math">\\tilde{V}</span> that the oracle <span class="math">\\pi</span> has been 'sent'; note that we do not yet commit to any entries in the proof, save for those which are implied by the verifier's previous queries to <span class="math">w</span>. Whenever <span class="math">\\tilde{V}</span> queries the <span class="math">i</span>-th location in <span class="math">\\pi</span>, return <span class="math">\\pi_i := \\mathcal{A}_{\\mathcal{L}}(\\mathfrak{n}, \\mathsf{ans}, i)</span> and add <span class="math">(i, \\pi_i)</span> to <span class="math">\\mathsf{ans}</span>. (Note that <span class="math">\\tilde{V}</span> may query <span class="math">w</span> or <span class="math">z</span> before or after learning about <span class="math">\\pi</span>.)</li>

      <li>Output the view of the simulated <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">S</span> makes the same number of queries to <span class="math">w</span> as <span class="math">S_{\\mathrm{slow}}</span> does. Also, the number of pairs in <span class="math">\\mathsf{ans}_{z_{\\mathrm{sim}}}</span> is at most <span class="math">q_{\\tilde{V}}</span>; ditto for <span class="math">\\mathsf{ans}</span>. Since the algorithm <span class="math">\\mathcal{A}</span> is called at most <span class="math">q_{\\tilde{V}}</span> times, the running time of <span class="math">S</span> is <span class="math">\\mathrm{poly}(\\mathfrak{n} + \\mathfrak{q}_{\\tilde{V}})</span>, as required.</p>

    <p class="text-gray-300">We conclude with a lemma that says that succinct constraint detection is in some sense inherent to the "masking" approach used in Construction 7.5.</p>

    <p class="text-gray-300"><strong>Lemma 7.8.</strong> If <span class="math">(P_{\\mathcal{C}}, V_{\\mathcal{C}})</span> is a linear PCPP such that Construction 7.5 yields <span class="math">(P, V)</span> with perfect zero knowledge, then <span class="math">(P_{\\mathcal{C}}, V_{\\mathcal{C}})</span> has a constraint detector that runs in probabilistic polynomial time. (In fact, the same statement holds even if the construction yields <span class="math">(P, V)</span> with only statistical zero knowledge.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> The linear code $L_{\\mathfrak{n}} \\coloneqq \\{w \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(\\mathfrak{n}, w)\\}_{w \\in C_{\\mathfrak{n}}}<span class="math"> has domain </span>D^{<em>}(\\mathfrak{n}) \\coloneqq D(\\mathfrak{n}) \\sqcup [\\mathsf{l}_{\\mathcal{C}}(\\mathfrak{n})]<span class="math">, which is the disjoint union of </span>D(\\mathfrak{n})<span class="math"> (the domain of </span>C_{\\mathfrak{n}}<span class="math">) and </span>[\\mathsf{l}_{\\mathcal{C}}(\\mathfrak{n})]<span class="math"> (the domain of </span>P(\\mathfrak{n}, C_{\\mathfrak{n}})<span class="math">); see Definition 7.2. Let </span>I \\subseteq D^{</em>}(\\mathfrak{n})<span class="math">. We need, in probabilistic polynomial time, to output a basis for </span>(L_{\\mathfrak{n}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_I)^\\perp<span class="math">. Construct a malicious verifier </span>\\tilde{V}$ that works as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive <span class="math">z \\in C_{\\mathfrak{n}}</span> from <span class="math">P</span>.</li>

      <li>Send <span class="math">\\rho = 0</span> to <span class="math">P</span>.</li>

      <li>Receive <span class="math">\\pi</span> from <span class="math">P</span>.</li>

      <li>For each <span class="math">i \\in I</span>: if <span class="math">i \\in D(\\mathfrak{n})</span> then query <span class="math">z</span> at <span class="math">i</span>, and if <span class="math">i \\in [\\mathsf{l}_{\\mathcal{C}}(\\mathfrak{n})]</span> then query <span class="math">\\pi</span> at <span class="math">i</span>; call the answer <span class="math">\\beta_{i}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By PZK, there is a probabilistic polynomial time algorithm <span class="math">S</span> such that the output of <span class="math">S^{\\tilde{V},w}(\\mathfrak{n})</span> is identically distributed to View <span class="math">\\langle P^w (\\mathfrak{n}),\\tilde{V}^w\\rangle</span>, for every <span class="math">w\\in C_{\\mathfrak{n}}</span>. Set <span class="math">w</span> to be the zero codeword, and suppose we run <span class="math">S^{\\tilde{V},w}(\\mathfrak{n})</span>; this invocation makes <span class="math">S</span> sample answers <span class="math">(\\beta_{i})_{i\\in I} = (z^{\\prime}(i))_{i\\in I}</span> for $z^{\\prime} = z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{\\mathcal{C}}(\\mathfrak{n},z)<span class="math"> uniformly random in </span>L_{\\mathfrak{n}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, to perform constraint detection in probabilistic polynomial time, we proceed as follows. We run <span class="math">S^{\\tilde{V},w}(\\mathfrak{n})</span> $k &gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times, recording a vector </span>\\vec{\\beta' = (\\beta_i)_{i\\in I}}<span class="math"> at the </span>j<span class="math">-th iteration. Let </span>B<span class="math"> be the </span>k\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> matrix with rows </span>\\vec{\\beta}^1,\\ldots ,\\vec{\\beta}^k<span class="math">. Output a basis for the nullspace of </span>B<span class="math">, which we can find in </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ k +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now argue correctness of the above approach. First, for every <span class="math">u \\in \\mathbb{F}^I</span> such that <span class="math">\\sum_{i \\in I} u(i) w&#x27;(i) = 0</span> for every <span class="math">w&#x27; \\in L_{\\mathfrak{n}}</span>, it holds that <span class="math">u</span> is in the nullspace of <span class="math">B</span>, because codewords used to generate <span class="math">B</span> satisfy the same relation. Next, the probability that there exists <span class="math">u \\in \\mathbb{F}^I</span> in the nullspace of <span class="math">B</span> such that <span class="math">\\sum_{i \\in I} u(i) w&#x27;(i) \\neq 0</span> for some <span class="math">w&#x27; \\in L_{\\mathfrak{n}}</span> is at most $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Indeed, for every such </span>u<span class="math">, </span>\\operatorname{Pr}_{z' \\leftarrow L_{\\mathfrak{n}}}[\\sum_{i \\in I} u(i) z'(i) = 0] \\leq 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (since </span>L_{\\mathfrak{n}}<span class="math"> is a linear code), so the probability that </span>u<span class="math"> is in the nullspace of </span>B<span class="math"> is at most </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k<span class="math">; we then obtain the claimed probability by a union bound. Overall, the probability that the algorithm answers incorrectly is at most </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-110" class="text-2xl font-bold">7.2 Perfect zero knowledge IOPs of proximity for Reed-Solomon codes</h2>

    <p class="text-gray-300">We have already proved that the linear code family BS-RS, which consists of low-degree univariate polynomials concatenated with corresponding BS proximity proofs [BS08], has succinct constraint detection. When combined with the results in Section 7.1, we obtain IOPs of Proximity for Reed-Solomon codes, as stated in the corollary below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 7.9.</strong> We denote by <span class="math">\\mathrm{RS}^+</span> the linear code family indexed by tuples <span class="math">\\mathfrak{n} = (\\mathbb{F}, L, d)</span>, where <span class="math">\\mathbb{F}</span> is an extension field of <span class="math">\\mathbb{F}_2</span> and <span class="math">L</span> is an <span class="math">\\mathbb{F}_2</span>-linear subspace of <span class="math">\\mathbb{F}</span> with $d \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/8<span class="math">, and the </span>\\mathfrak{n}<span class="math">-th code consists of the codewords from the Reed-Solomon code </span>\\mathrm{RS}[\\mathbb{F}, L, d]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">Theorem 7.10 ([BS08]). For every function  <span class="math">\\delta \\colon \\{0,1\\}^* \\to (0,1)</span> , the linear code family  <span class="math">\\mathrm{RS}^+</span>  has PCPs of Proximity with soundness error  <span class="math">1/2</span> , proximity parameter  <span class="math">\\delta</span> , prover running time (and thus proof length) that is quasilinear in the block length  <span class="math">\\ell(\\mathfrak{n})</span> , and verifier running time (and thus query complexity) that is polylogarithmic in  <span class="math">\\ell(\\mathfrak{n})/\\delta(\\mathfrak{n})</span> .</p>

    <p class="text-gray-300">Corollary 7.11. For every function  <span class="math">\\delta \\colon \\{0,1\\}^* \\to (0,1)</span> , there exists an IOPP system that puts  <span class="math">\\mathrm{Rel}(\\mathrm{RS}^{+})</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK·IOPP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(ℓ(n)/δ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proximity parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">δ(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(ℓ(n)/δ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Invoke Theorem 7.3 on the linear code family  <span class="math">\\mathrm{RS}^+</span>  with corresponding BS proximity proofs (Theorem 7.10). Indeed, the concatenation of codewords in  <span class="math">\\mathrm{RS}^+</span>  and proximity proofs yields the family BS-RS, which has succinct constraint detection by Theorem 4.12. (This last step omits a technical, but uninteresting, step: the proximity proofs from Theorem 4.12 consider the case where the degree  <span class="math">d</span>  equals the special value  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 8<span class="math"> , rather than being bounded by it; but proximity proofs for smaller degree  </span>d$  are easily obtained from these, as explained in [BS08].)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When constructing perfect zero knowledge IOPs for NEXP (Section 8) we shall need perfect zero knowledge IOPs of Proximity not quite for the family  <span class="math">\\mathrm{RS}^+</span>  but for an extension of it that we denote by  <span class="math">\\mathrm{ERS}^+</span> , and for which [BS08] also gives PCPs of proximity. The analogous perfect zero knowledge result follows in a similar way, as explained below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 7.12. Given a field  <span class="math">\\mathbb{F}</span>  of characteristic 2,  <span class="math">\\mathbb{F}_2</span> -linear subspaces  <span class="math">H, L \\subseteq \\mathbb{F}</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 8<span class="math"> , and  </span>d_0, d_1 \\in \\mathbb{N}<span class="math">  with  </span>d_0, d_1 \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ 8<span class="math"> , we denote by  </span>\\mathrm{ERS}^+[\\mathbb{F}, L, H, d_0, d_1]<span class="math">  the linear code consisting of all pairs  </span>(w_0, w_1)<span class="math">  where  </span>w_0 \\in \\mathrm{RS}[\\mathbb{F}, L, d_0]<span class="math"> ,  </span>w_1 \\in \\mathrm{RS}[\\mathbb{F}, L, d_1]<span class="math"> , and  </span>w_1(x) = 0<span class="math">  for all  </span>x \\in H<span class="math"> . We denote by  </span>\\mathrm{ERS}^+<span class="math">  the linear code family indexed by tuples  </span>\\mathfrak{n} = (\\mathbb{F}, L, d_0, d_1)<span class="math">  for which the  </span>\\mathfrak{n}<span class="math"> -th code is  </span>\\mathrm{ERS}^+[\\mathbb{F}, L, H, d_0, d_1]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 7.13 ([BS08]). For every function  <span class="math">\\delta \\colon \\{0,1\\}^* \\to (0,1)</span> , the linear code family  <span class="math">\\mathrm{ERS}^+</span>  has PCPs of Proximity with soundness error  <span class="math">1/2</span> , proximity parameter  <span class="math">\\delta</span> , prover running time (and thus proof length) that is quasilinear in the block length  <span class="math">\\ell(\\mathfrak{n})</span> , and verifier running time (and thus query complexity) that is polylogarithmic in  <span class="math">\\ell(\\mathfrak{n})/\\delta(\\mathfrak{n})</span> .</p>

    <p class="text-gray-300">Proof sketch. A PCP of proximity for a codeword  <span class="math">(w_0, w_1)</span>  to  <span class="math">\\mathrm{ERS}^+[\\mathbb{F}, L, H, d_0, d_1]</span>  consists of  <span class="math">(\\pi_0, w_1&#x27;, \\pi_1)</span> , where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_0</span>  is a PCP of proximity for  <span class="math">w_0</span>  to  <span class="math">\\mathrm{RS}[\\mathbb{F}, L, d_0]</span> ;</li>

      <li><span class="math">w_1&#x27;</span>  is the evaluation of the polynomial obtained by dividing (the polynomial of)  <span class="math">w_1</span>  by the zero polynomial of  <span class="math">H</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\pi_1</span>  is a PCP of proximity for  <span class="math">w_1&#x27;</span>  to  $\\mathrm{RS}[\\mathbb{F}, L, d_1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The verifier, which has oracle access to  <span class="math">(w_0, w_1)</span>  and  <span class="math">(\\pi_0, w_1&#x27;, \\pi_1)</span> , checks both PCPs or proximity and then performs a consistency check between  <span class="math">w_1</span>  and  <span class="math">w_1&#x27;</span> . See [BS08] for details.</p>

    <p class="text-gray-300">Corollary 7.14. For every function  <span class="math">\\delta \\colon \\{0,1\\}^* \\to (0,1)</span> , there exists an IOPP system that puts  <span class="math">\\mathrm{Rel}(\\mathrm{ERS}^{+})</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK·IOPP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(ℓ(n)/δ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proximity parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">δ(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(ℓ(n)/δ(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Invoke Theorem 7.3 on the linear code family  <span class="math">\\mathrm{ERS}^+</span>  with corresponding BS proximity proofs (Theorem 7.13), which has succinct constraint detection as we now clarify. A codeword  <span class="math">(w_0, w_1)</span>  has proximity proof  <span class="math">(\\pi_0, w_1&#x27;, \\pi_1)</span> , and Theorem 4.12 implies that  <span class="math">(w_0, \\pi_0)</span>  and  <span class="math">(w_1&#x27;, \\pi_1)</span>  have succinct constraint detection. But every coordinate of  <span class="math">w_1&#x27;</span>  is easy to compute from the same coordinate in  <span class="math">w_1</span> , and concatenating codewords preserves succinct constraint detection.</p>

    <p class="text-gray-300">We prove that NEXP has 2-round IOPs that are perfect zero knowledge against unbounded queries. We do so by constructing a suitable IOP system for  <span class="math">\\mathbf{NTIME}(T)</span>  against query bound  <span class="math">\\mathsf{b}</span> , for each time function  <span class="math">T</span>  and query bound function  <span class="math">\\mathsf{b}</span> , where the verifier runs in time polylogarithmic in both  <span class="math">T</span>  and  <span class="math">\\mathsf{b}</span> . Crucially, the simulator runs in time  <span class="math">\\mathrm{poly}(\\tilde{q} + \\log T + \\log \\mathsf{b})</span> , where  <span class="math">\\tilde{q}</span>  is the actual number of queries made by the malicious verifier; this exponential improvement over [BCGV16], where the simulator runs in time  <span class="math">\\mathrm{poly}(T + \\mathsf{b})</span> , enables us to "go up to NEXP".</p>

    <p class="text-gray-300">Theorem 8.1 (formal statement of Theorem 1.1). For every constant  <span class="math">d &amp;gt; 0</span> , time bound function  <span class="math">T\\colon \\mathbb{N}\\to \\mathbb{N}</span>  with  <span class="math">n\\leq T(n)\\leq 2^{n^d}</span> , and query bound function  <span class="math">\\mathsf{b}\\colon \\mathbb{N}\\to \\mathbb{N}</span>  with  <span class="math">\\mathsf{b}(n)\\leq 2^{n^d}</span> , there exists an IOP system  <span class="math">(P,V)</span>  that makes NTIME(T) a subset of the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK-IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T(n) + b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(T(n) + b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(n) · O(T(n) + b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(n + log(T(n) + b(n)))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, the verifier  <span class="math">V</span>  is public-coin and non-adaptive.</p>

    <p class="text-gray-300">Our proof is similar to that of [BCGV16], and the only major difference is that [BCGV16]'s simulator explicitly samples random codewords, while we rely on succinct constraint detection to do so implicitly. Indeed, the reduction from  <span class="math">\\mathbf{NTIME}(T)</span>  generates codewords of size  <span class="math">\\tilde{O}(T)</span> , which means that sampling random codewords of that size is infeasible when  <span class="math">T</span>  is super-polynomial. We structure our argument in three steps, highlighting the essential components that implicitly underlie [BCGV16]'s 'monolithic' argument; we view this as a conceptual contribution of our work.</p>

    <p class="text-gray-300">Step 1 (Section 8.1). We construct perfect zero knowledge IOPs of Proximity for linear algebraic constraint satisfaction problems (LACSPs) [BCGV16], a family of constraint satisfaction problems whose domain and range are linear codes. An instance  <span class="math">\\mathbf{x}</span>  of LACSP is specified by a function  <span class="math">g</span>  and a pair of codes  <span class="math">C_0, C_1</span> ; a witness  <span class="math">\\mathbf{w}</span>  for  <span class="math">\\mathbf{x}</span>  is a pair  <span class="math">(w_0, w_1)</span>  such that  <span class="math">w_0 \\in C_0</span> ,  <span class="math">w_1 \\in C_1</span> , and  <span class="math">g(w_0) = w_1</span> . A natural approach to construct a perfect zero knowledge IOPP for this relation is the following: if we are given a perfect zero knowledge IOP of Proximity for the relation  <span class="math">\\mathrm{Rel}(C_0 \\times C_1)</span> , then the verifier can test proximity of  <span class="math">\\mathbf{w} = (w_0, w_1)</span>  to  <span class="math">C_0 \\times C_1</span>  and then sample a random index  <span class="math">j</span>  and check that  <span class="math">g(w_0)[j] = w_1[j]</span> . In order for the verifier's strategy to make sense, we require  <span class="math">g</span>  to (i) satisfy a distance condition with respect to  <span class="math">C_0, C_1</span> , namely, that  <span class="math">C_1 \\cup g(C_0)</span>  has large relative distance; (ii) be 'local', which means that computing  <span class="math">g(w_0)[j]</span>  requires examining only a few indices of  <span class="math">w_0</span> ; and (iii) be 'evasive', which means that if  <span class="math">\\tilde{w}_0</span>  is close to some  <span class="math">w_0 \\in C_0</span> , then  <span class="math">g(\\tilde{w}_0)</span>  is close to  <span class="math">g(w_0)</span> . All of this implies that if  <span class="math">(\\tilde{w}_0, \\tilde{w}_1)</span>  is far from any valid witness but close to  <span class="math">C_0 \\times C_1</span> , we know that  <span class="math">g(\\tilde{w}_0)</span>  is far from  <span class="math">\\tilde{w}_1</span> , so that examining a random index  <span class="math">j</span>  gives good soundness.</p>

    <p class="text-gray-300">Step 2 (Section 8.2). We build on the above result to derive perfect zero knowledge IOPs for a subfamily of LACSPs called randomizable LACSPs (RLACSPs) [BCGV16]. The key difference between this protocol and the IOP of Proximity described above is that in the "proximity setting", the verifier, and thus also the simulator, has oracle access to the witness, while in the "non-proximity setting" the witness is sent to the verifier but the simulator must make do without it; in particular, merely sending the witness  <span class="math">(w_0, w_1)</span>  is not zero knowledge. We thus rely on the randomizability property of RLACSPs to generate witnesses from a  <span class="math">t</span> -wise independent distribution, where  <span class="math">t</span>  is larger than the query bound  <span class="math">\\mathsf{b}</span> . In particular, while the simulator runs in time polynomial in the actual number of queries made by a verifier, it runs in time polylogarithmic in  <span class="math">t</span> , and thus we can set  <span class="math">\\mathsf{b}</span>  to be super-polynomial in order to obtain unbounded-query zero knowledge against polynomial-time verifiers.</p>

    <p class="text-gray-300">Step 3 (Section 8.3). We derive Theorem 8.1 (perfect zero knowledge IOPs for  <span class="math">\\mathbf{NTIME}(T)</span> ) by combining: (1) the aforementioned result for RLACSPs; (2) [BCGV16]'s reduction from NTIME to RLACSPs; (3) a perfect zero knowledge IOP of Proximity for a suitable choice of  <span class="math">C_0 \\times C_1</span> , which we derived in Section 7.2. This last component is the one that makes use of succinct constraint detection, and relies on the technical innovations of our work.</p>

    <p class="text-gray-300">A constraint satisfaction problem asks whether, for a given "local" function  <span class="math">g</span> , there exists an input  <span class="math">w</span>  such that  <span class="math">g(w)</span>  is an accepting output. For example, in the case of 3SAT with  <span class="math">n</span>  variables and  <span class="math">m</span>  clauses, the function  <span class="math">g</span>  maps  <span class="math">\\{0,1\\}^n</span>  to  <span class="math">\\{0,1\\}^m</span> , and  <span class="math">g(w)</span>  indicates which clauses are satisfied by  <span class="math">w \\in \\{0,1\\}^n</span> ; hence  <span class="math">w</span>  yields an accepting output if (and only if)  <span class="math">g(w) = 1^m</span> . Below we introduce a family of constraint satisfaction problems whose domain and range are linear-algebraic objects, namely, linear codes.</p>

    <p class="text-gray-300">We begin by providing the notion of locality that we use for  <span class="math">g</span> , along with a measure of  <span class="math">g</span> 's "pseudorandomness".</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 8.2. Let  <span class="math">g \\colon \\Sigma^n \\to \\Sigma^m</span>  be a function. We say that  <span class="math">g</span>  is  <span class="math">q</span> -local if for every  <span class="math">j \\in [m]</span>  there exists  <span class="math">I_j \\subseteq [n]</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q<span class="math">  such that  </span>g(w)[j]<span class="math">  (the  </span>j<span class="math"> -th coordinate of  </span>g(w)<span class="math"> ) depends only on  </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I_j}<span class="math">  (the restriction of  </span>w<span class="math">  to  </span>I_j<span class="math"> ). Moreover, we say that  </span>g<span class="math">  is  </span>s<span class="math"> -evasive if for every  </span>I \\subseteq [n]<span class="math">  the probability that  </span>I_j<span class="math">  intersects  </span>I<span class="math">  for a uniform  </span>j \\in [m]<span class="math">  is at most  </span>s \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For example, if  <span class="math">g</span>  is a 3SAT formula then  <span class="math">g</span>  is 3-local because  <span class="math">I_{j}</span>  equals the variables appearing in clause  <span class="math">j</span> ; moreover,  <span class="math">g</span>  is  <span class="math">s</span> -evasive if and only if every variable  <span class="math">x_{i}</span>  appears in at most a fraction  <span class="math">s / n</span>  of the clauses (i.e., the evasiveness property corresponds to the fraction of clauses in which a variable appears). Also, a natural case where  <span class="math">g</span>  is  <span class="math">q</span> -evasive is when the elements of  <span class="math">I_{j}</span>  are individually uniform in  <span class="math">[n]</span>  when  <span class="math">j</span>  is uniform in  <span class="math">[m]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 8.3. Let  <span class="math">g \\colon \\Sigma^n \\to \\Sigma^m</span>  be a function. We say that  <span class="math">g</span>  is  <span class="math">c</span> -efficient if there is a  <span class="math">c</span> -time algorithm that, given  <span class="math">j</span>  and  $w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{I_j}<span class="math"> , computes the set  </span>I_j<span class="math">  and value  </span>g(w)[j]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above definition targets succinctly-described languages. For example, a succinct 3SAT instance is given by a circuit of size  <span class="math">S</span>  that, on input  <span class="math">j</span> , outputs a description of the  <span class="math">j</span> -th clause; the definition is then satisfied with  <span class="math">c = O(S)</span> .</p>

    <p class="text-gray-300">Definition 8.4 (LACSP). Let  <span class="math">C_0(n), C_1(n)</span>  be (descriptions of) linear codes over  <span class="math">\\mathbb{F}(n)</span>  with block length  <span class="math">\\ell(n)</span>  and relative distance  <span class="math">\\tau(n)</span> . The promise relation of linear algebraic CSPs (LACSPs)</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathcal {R} _ {\\text {L A C S P}} ^ {\\text {Y E S}}, \\mathcal {L} _ {\\text {L A C S P}} ^ {\\text {N O}}\\right) \\left[ \\mathbb {F} (n), C _ {0} (n), C _ {1} (n), \\ell (n), \\tau (n), q (n), c (n) \\right]</span></div>

    <p class="text-gray-300">considers instance-witness pairs  <span class="math">(\\mathbf{x},\\mathbf{w})</span>  of the following form.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An instance  <span class="math">\\mathbf{x}</span>  is a tuple  <span class="math">(1^n, g)</span>  where:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g\\colon \\mathbb{F}(n)^{\\ell (n)}\\to \\mathbb{F}(n)^{\\ell (n)}</span>  is  <span class="math">q(n)</span> -local,  <span class="math">q(n)</span> -evasive, and  <span class="math">c(n)</span> -efficient;</li>

      <li><span class="math">C_1(n) \\cup g(C_0(n))</span>  has relative distance at least  <span class="math">\\tau(n)</span>  (though may not be a linear space).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A witness  <span class="math">\\mathbf{w}</span>  is a tuple  <span class="math">(w_0, w_1)</span>  where  <span class="math">w_0, w_1 \\in \\mathbb{F}(n)^{\\ell(n)}</span> .</li>

    </ul>

    <p class="text-gray-300">The yes-relation  <span class="math">\\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}}</span>  consists of all pairs  <span class="math">(\\mathbf{x},\\mathbf{w})</span>  as above where the instance  <span class="math">\\mathbf{x}</span>  and witness  <span class="math">\\mathbf{w}</span>  jointly satisfy the following:  <span class="math">w_0\\in C_0(n)</span> ,  <span class="math">w_{1}\\in C_{1}(n)</span> , and  <span class="math">g(w_0) = w_1</span> . (In particular, a witness  <span class="math">\\mathbf{w} = (w_0,g(w_0))</span>  with  <span class="math">w_0\\in C_0(n)</span>  satisfies  <span class="math">\\mathbf{x}</span>  if and only if  <span class="math">g(w_0)\\in C_1(n)</span> .) The no-language consists of all instances  <span class="math">\\mathbf{x}</span>  as above where  <span class="math">\\mathbf{x}\\notin \\operatorname {Lan}(\\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}})</span> .</p>

    <p class="text-gray-300">Remark 8.5. In [BCGV16] the codes  <span class="math">C_0</span>  and  <span class="math">C_1</span>  are allowed to have distinct block lengths while, for simplicity, we assume that they have the same block length; this restriction does not change any of their, or our, results.</p>

    <p class="text-gray-300">We are now ready to give perfect zero knowledge IOPs of proximity for LACSPs.</p>

    <p class="text-gray-300">Theorem 8.6. Suppose that there exists an IOPP system  <span class="math">(\\hat{P},\\hat{V})</span>  that puts  <span class="math">\\operatorname{Rel}(C_0\\times C_1)</span>  in the complexity class</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {P Z K - I O P P} [ \\mathbb {F}, \\hat {\\mathbf {k}}, \\hat {\\mathbf {l}}, \\hat {\\mathbf {q}}, \\hat {\\delta}, \\hat {\\varepsilon}, \\hat {\\mathbf {t p}}, \\hat {\\mathbf {t v}}, * ]</span></div>

    <p class="text-gray-300">Then there exists an IOPP system  <span class="math">(P_{\\mathrm{LACSP}}, V_{\\mathrm{LACSP}})</span>  that puts  <span class="math">(\\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}}, \\mathcal{L}_{\\mathrm{LACSP}}^{\\mathrm{NO}})[\\mathbb{F}, C_0, C_1, \\ell, \\tau, q, c]</span>  in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK-IOPP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆk(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆl(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆq(n) + q(n) + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">max{ˆε(n), 1 - τ(n) + 2ˆδ(n) · (q(n) + 1)}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proximity parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">δ(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆδ(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆtp(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆtv(n) + c(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">*</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if <span class="math">(\\hat{P},\\hat{V})</span> is non-adaptive (respectively, public-coin) then so is <span class="math">(P_{\\textsc{lacsp}},V_{\\textsc{lacsp}})</span>.</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct the IOPP system <span class="math">(P_{\\textsc{lacsp}},V_{\\textsc{lacsp}})</span> for <span class="math">\\mathscr{R}</span>, where the prover receives <span class="math">(\\mathtt{x},\\mathtt{w})=\\big{(}(1^{n},g),(w_{0},w_{1})\\big{)}</span> as input while the verifier receives <span class="math">\\mathtt{x}</span> as input and <span class="math">\\mathtt{w}</span> as an oracle, as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\textsc{lacsp}}</span> and <span class="math">V_{\\textsc{lacsp}}</span> invoke the IOPP system <span class="math">(\\hat{P},\\hat{V})</span> to prove that <span class="math">(w_{0},w_{1})\\in C_{0}\\times C_{1}</span>;</li>

      <li><span class="math">V_{\\textsc{lacsp}}</span> chooses a random <span class="math">j\\in[\\ell]</span> and checks that <span class="math">g(w_{0})[j]=w_{1}[j]</span>;</li>

      <li><span class="math">V_{\\textsc{lacsp}}</span> rejects if and only if <span class="math">\\hat{V}</span> rejects or the above check fails.</li>

    </ol>

    <p class="text-gray-300">Completeness. If <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathscr{R}^{\\textsc{res}}_{\\textsc{lacsp}}</span>, then (i) <span class="math">w_{0}\\in C_{0},w_{1}\\in C_{1}</span>, so <span class="math">\\hat{V}</span> always accepts, and (ii) <span class="math">g(w_{0})=w_{1}</span> so the consistency check succeeds for every <span class="math">j\\in[\\ell]</span>. We deduce that <span class="math">V_{\\textsc{lacsp}}</span> always accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that <span class="math">\\mathtt{x}\\in\\mathrm{Lan}(\\mathscr{R}^{\\textsc{res}}_{\\textsc{lacsp}})\\cup\\mathscr{L}^{\\textsc{no}}_{\\textsc{lacsp}}</span> and <span class="math">\\hat{\\mathtt{w}}</span> are such that $\\Delta(\\hat{\\mathtt{w}},\\mathscr{R}^{\\textsc{res}}_{\\textsc{lacsp}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}})\\geq\\hat{\\delta}<span class="math">. Writing </span>\\tilde{\\mathtt{w}}=(\\tilde{w}_{0},\\tilde{w}_{1})$, we argue as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\Delta(\\tilde{\\mathtt{w}},C_{0}\\times C_{1})\\geq\\hat{\\delta}</span>. In this case <span class="math">\\hat{V}</span> rejects with probability at least <span class="math">1-\\hat{\\varepsilon}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Case 2: <span class="math">\\Delta(\\hat{\\mathtt{w}},C_{0}\\times C_{1})&lt;\\hat{\\delta}</span>. There exist codewords <span class="math">w_{0}\\in C_{0}</span> and <span class="math">w_{1}\\in C_{1}</span> such that <span class="math">(w_{0},w_{1})</span> is <span class="math">\\delta</span>-close to <span class="math">(\\tilde{w}_{0},\\tilde{w}_{1})</span> for <span class="math">\\delta&lt;\\hat{\\delta}</span>. By assumption, $\\Delta(\\hat{\\mathtt{w}},\\mathscr{R}^{\\textsc{res}}_{\\textsc{lacsp}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}})\\geq\\hat{\\delta}<span class="math">, so in particular </span>(w_{0},w_{1})<span class="math"> cannot be in </span>\\mathscr{R}^{\\textsc{res}}_{\\textsc{lacsp}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathtt{x}}<span class="math">, and </span>g(w_{0})\\neq w_{1}<span class="math">. Since </span>C_{1}\\cup g(C_{0})<span class="math"> has relative distance at least </span>\\tau<span class="math">, </span>\\Delta(g(w_{0}),w_{1})\\geq\\tau<span class="math">. Observe that since </span>C_{0}<span class="math"> and </span>C_{1}<span class="math"> have the same block length, </span>\\Delta(\\tilde{w}_{0},w_{0})\\leq 2\\hat{\\delta}<span class="math"> and </span>\\Delta(\\tilde{w}_{1},w_{1})\\leq 2\\hat{\\delta}<span class="math">. Thus since </span>g<span class="math"> is </span>q<span class="math">-evasive, the probability that the set of coordinates </span>I:=\\{i\\in[\\ell]:w_{0}[i]\\neq\\tilde{w}_{0}[i]\\}<span class="math"> intersects with </span>I_{j}<span class="math"> for random </span>j\\in[\\ell]<span class="math"> is at most </span>2\\hat{\\delta}q<span class="math">, so </span>\\Delta(g(w_{0}),g(\\tilde{w}_{0}))\\leq 2\\hat{\\delta}q$. Using the triangle inequality, we deduce that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Delta(g(\\tilde{w}_{0}),\\tilde{w}_{1})\\geq\\tau-2\\hat{\\delta}(q+1),</span></p>

    <p class="text-gray-300">which means the consistency check rejects with probability at least <span class="math">\\tau-2\\hat{\\delta}(q+1)</span>.</p>

    <p class="text-gray-300">It follows that <span class="math">V_{\\textsc{lacsp}}</span> accepts with probability at most <span class="math">\\max\\{\\hat{\\varepsilon},1-\\tau+2\\hat{\\delta}(q+1)\\}</span>.</p>

    <p class="text-gray-300">Perfect zero knowledge. We can choose the simulator <span class="math">S_{\\textsc{lacsp}}</span> for <span class="math">(P_{\\textsc{lacsp}},V_{\\textsc{lacsp}})</span> to equal any simulator <span class="math">\\hat{S}</span> that fulfills the perfect zero knowledge guarantee of <span class="math">(\\hat{P},\\hat{V})</span>. Indeed, the behavior of <span class="math">P_{\\textsc{lacsp}}</span> is the same as <span class="math">\\hat{P}</span>, and so the view of any malicious verifier <span class="math">\\hat{V}</span> when interacting with <span class="math">P_{\\textsc{lacsp}}</span> is identical to its view when interacting with <span class="math">\\hat{P}</span>. ∎</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">8.2 Perfect zero knowledge IOPs for RLACSPs</h3>

    <p class="text-gray-300">The above discussion achieves perfect zero knowledge for LACSPs, “up to queries to the witness”. We now explain how to simulate these queries as well, without any knowledge of the witness, for a special class of LACSPs called <em>randomizable LACSPs</em>. For these, the prover can randomize a given witness <span class="math">(w_{0},g(w_{0}))</span> by sampling a random <span class="math">u^{\\prime}</span> in a <span class="math">t</span>-wise independent subcode <span class="math">C^{\\prime}</span> of <span class="math">C_{0}</span>, and use the new ‘shifted’ witness <span class="math">(w_{0}+u^{\\prime},g(w_{0}+u^{\\prime}))</span> instead of the original one. We now define the notion of randomizable LACSPs, and then show how to construct perfect zero knowledge IOPs for these, against bounded-query verifiers and where the the query bound depends on <span class="math">t</span>.</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Definition 8.7 (randomizability).</h6>

    <p class="text-gray-300">An instance <span class="math">\\mathtt{x}=(1^{n},g)</span> is <span class="math">t(n)</span>-randomizable in time <span class="math">r(n)</span> (with respect to code families <span class="math">C_{0}(n),C_{1}(n)</span>) if: (i) there exists a <span class="math">t(n)</span>-wise independent subcode <span class="math">C^{\\prime}\\subseteq C_{0}(n)</span> such that if <span class="math">(w_{0},g(w_{0}))</span> satisfies <span class="math">\\mathtt{x}</span>, then, for every <span class="math">w_{0}^{\\prime}</span> in <span class="math">C^{\\prime}+w_{0}:=\\{w^{\\prime}+w_{0}\\mid w^{\\prime}\\in C^{\\prime}\\}</span>, the witness <span class="math">(w_{0}^{\\prime},g(w_{0}^{\\prime}))</span> also satisfies <span class="math">\\mathtt{x}</span>; and (ii) one can sample, in time <span class="math">r(n)</span>, three uniformly random elements in <span class="math">C^{\\prime},C_{0}(n),C_{1}(n)</span> respectively.</p>

    <h6 id="sec-116" class="text-base font-medium mt-4">Definition 8.8 (RLACSP).</h6>

    <p class="text-gray-300">The promise relation of <em>randomizable linear algebraic CSPs</em> (RLACSPs) is</p>

    <p class="text-gray-300"><span class="math">(\\mathscr{R}^{\\textsc{res}}_{\\textsc{rlacsp}},\\mathscr{L}^{\\textsc{no}}_{\\textsc{rlacsp}})[\\mathbb{F}(n),C_{0}(n),C_{1}(n),\\ell(n),\\tau(n),q(n),c(n),t(n),r(n)]</span></p>

    <p class="text-gray-300">where <span class="math">\\mathscr{R}^{\\textsc{res}}_{\\textsc{rlacsp}}</span> is obtained by restricting <span class="math">\\mathscr{R}_{\\textsc{lacsp}}</span> to instances that are <span class="math">t</span>-randomizable in time <span class="math">r</span>, and <span class="math">\\mathscr{L}^{\\textsc{no}}_{\\textsc{rlacsp}}:=\\mathscr{L}^{\\textsc{no}}_{\\textsc{lacsp}}</span>.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Theorem 8.9.</h6>

    <p class="text-gray-300">Suppose that there exists an IOPP system <span class="math">(\\hat{P},\\hat{V})</span> that puts <span class="math">\\mathrm{Rel}(C_{0}\\times C_{1})</span> in the complexity class</p>

    <p class="text-gray-300"><span class="math">\\mathbf{PZK}\\text{-}\\mathbf{IOPP}[\\mathbb{F},\\hat{\\mathsf{k}},\\hat{\\mathsf{l}},\\hat{\\mathsf{q}},\\hat{\\delta},\\hat{\\varepsilon},\\hat{\\mathsf{tp}},\\hat{\\mathsf{tv}},\\ast]\\enspace.</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Then there exists an IOP system  <span class="math">(P_{\\mathrm{RLACSP}}, V_{\\mathrm{RLACSP}})</span>  that puts  <span class="math">(\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}}, \\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}})[\\mathbb{F}, C_0, C_1, \\ell, \\tau, q, c, t, r]</span>  (with  <span class="math">c</span>  polynomially bounded) in the complexity class</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PZK-IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F(n)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700">k(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆk(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length</td>

            <td class="px-3 py-2 border-b border-gray-700">l(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆl(n) + ℓ(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆq(n) + q(n) + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700">ε(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">max{ˆε(n), 1 - τ(n) + 2 ·ˆδ(n) · (q(n) + 1)}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700">tp(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆtp(n) + c(n) · ℓ(n) + r(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700">tv(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆtv(n) + c(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">query bound</td>

            <td class="px-3 py-2 border-b border-gray-700">b(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">t(n)/q(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if  <span class="math">(\\hat{P},\\hat{V})</span>  is non-adaptive (respectively, public-coin) then so is  <span class="math">(P_{\\mathrm{RLACSP}},V_{\\mathrm{RLACSP}})</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">(P_{\\mathrm{LACSP}}, V_{\\mathrm{LACSP}})</span>  be the IOPP system for  <span class="math">\\mathcal{R}_{\\mathrm{LACSP}}</span>  guaranteed by Theorem 8.6. We construct the IOP system  <span class="math">(P_{\\mathrm{RLACSP}}, V_{\\mathrm{RLACSP}})</span>  for  <span class="math">(\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}}, \\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}})</span> , where the prover receives  <span class="math">(\\mathbf{x}, \\mathbf{w}) = ((1^n, g), (w_0, w_1))</span>  as input while the verifier receives  <span class="math">\\mathbf{x}</span>  as input, as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">P_{\\mathrm{RLACSP}}</span>  parses the witness  <span class="math">\\mathbf{w}</span>  as  <span class="math">(w_0, w_1) \\in C_0 \\times C_1</span> , samples a random  <span class="math">u&#x27; \\in C&#x27;</span>  (the subcode of  <span class="math">C_0</span>  for which  <span class="math">t</span> -randomizability holds), sets  <span class="math">w_0&#x27; := u&#x27; + w_0</span>  and  <span class="math">w_1&#x27; := g(w_0&#x27;)</span> , and sends  <span class="math">\\mathbf{w}&#x27; := (w_0&#x27;, w_1&#x27;)</span>  to  <span class="math">V_{\\mathrm{RLACSP}}</span> .</li>

      <li>In parallel to the above interaction, the prover  <span class="math">P_{\\mathrm{RLACSP}}</span>  and verifier  <span class="math">V_{\\mathrm{RLACSP}}</span>  invoke the IOPP system  <span class="math">(P_{\\mathrm{LACSP}}, V_{\\mathrm{LACSP}})</span>  on the input  <span class="math">\\mathbf{x}</span>  and new "prover-randomized" witness  <span class="math">\\mathbf{w}&#x27;</span> . The verifier  <span class="math">V_{\\mathrm{RLACSP}}</span>  accepts if and only if  <span class="math">V_{\\mathrm{LACSP}}</span>  does.</li>

    </ol>

    <p class="text-gray-300">The claimed efficiency parameters immediately follow by construction. We now show that  <span class="math">(P_{\\mathrm{RLACSP}}, V_{\\mathrm{RLACSP}})</span>  satisfies completeness, soundness, and perfect zero-knowledge.</p>

    <p class="text-gray-300">Completeness. Suppose that  <span class="math">(\\mathbf{x},\\mathbf{w}) = ((1^n,g),(w_0,w_1))</span>  is in the relation  <span class="math">\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}}</span> , so that  <span class="math">w_{0}\\in C_{0}</span> ,  <span class="math">w_{1}\\in C_{1}</span> , and  <span class="math">g(w_0) = w_1</span> . By randomizability (Definition 8.8), since  <span class="math">w_0^\\prime \\in C^\\prime +w_0</span> , we deduce that  <span class="math">\\mathbf{w}&#x27; = (w_0&#x27;,w_1&#x27;) = (w_0&#x27;,g(w_0&#x27;))</span>  satisfies  <span class="math">\\mathbf{x}</span> , and so  <span class="math">(\\mathbf{x},\\mathbf{w}&#x27;)\\in \\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}}</span> . Completeness then follows by the completeness of  <span class="math">(P_{\\mathrm{LACSP}},V_{\\mathrm{LACSP}})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Suppose that  <span class="math">\\mathbf{x} = (1^n, g)</span>  is in the language  <span class="math">\\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}} = \\mathcal{L}_{\\mathrm{LACSP}}^{\\mathrm{NO}}</span> , so that  $\\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbf{x}} = \\emptyset<span class="math"> . Regardless of what &#x27;witness&#x27;  </span>\\mathbf{w}'<span class="math">  is sent by  </span>P_{\\mathrm{RLACSP}}<span class="math"> , it holds that  </span>\\Delta(\\mathbf{w}', \\mathcal{R}_{\\mathrm{LACSP}}^{\\mathrm{YES}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbf{x}}) = \\Delta(\\mathbf{w}', \\emptyset) = 1 \\geq \\hat{\\delta}<span class="math"> , so that the soundness of  </span>(P_{\\mathrm{LACSP}}, V_{\\mathrm{LACSP}})<span class="math">  implies that  </span>V_{\\mathrm{LACSP}}<span class="math"> , and thus  </span>V_{\\mathrm{RLACSP}}<span class="math"> , accepts with probability at most  </span>\\max \\{\\hat{\\varepsilon}, 1 - \\tau + 2\\hat{\\delta} \\cdot (q + 1)\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Perfect zero knowledge. Let  <span class="math">\\tilde{V}</span>  be any verifier that makes at most  <span class="math">\\mathsf{b} := t / q</span>  queries, and let  <span class="math">S_{\\mathrm{LACSP}}</span>  be the perfect zero knowledge simulator for  <span class="math">(P_{\\mathrm{LACSP}}, V_{\\mathrm{LACSP}})</span> . We construct a simulator  <span class="math">S_{\\mathrm{RLACSP}}</span>  for  <span class="math">(P_{\\mathrm{RLACSP}}, V_{\\mathrm{RLACSP}})</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">S_{\\mathrm{RLACSP}}^{\\tilde{V}}(\\mathbf{x})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{\\mathrm{RLACSP}}</span>  initializes two empty strings  <span class="math">\\hat{w}_0</span>  and  <span class="math">\\hat{w}_1</span>  which will be partially filled during the simulation.</li>

      <li><span class="math">S_{\\mathrm{RLACSP}}</span>  invokes  <span class="math">S_{\\mathrm{LACSP}}^{\\tilde{V},(\\hat{w}_0,\\hat{w}_1)}</span> , and during the execution answers oracle queries to  <span class="math">(\\hat{w}_0,\\hat{w}_1)</span>  in the following way.</li>

    </ol>

    <p class="text-gray-300">(a) If  <span class="math">S_{\\mathrm{LACSP}}</span>  queries  <span class="math">\\hat{w}_0</span>  at a location  <span class="math">j \\in [\\ell]</span> : if  <span class="math">\\hat{w}_0[j]</span>  is already defined then return that value; otherwise sample a random  <span class="math">a \\in \\mathbb{F}(n)</span> , set  <span class="math">\\hat{w}_0[j] := a</span> , and reply with  <span class="math">\\hat{w}_0[j]</span> . (b) If  <span class="math">S_{\\mathrm{LACSP}}</span>  queries  <span class="math">\\hat{w}_1</span>  at a location  <span class="math">j \\in [\\ell]</span> : if  <span class="math">\\hat{w}_1[j]</span>  is already defined then return that value; otherwise compute the set of indices  <span class="math">I_j \\subseteq [\\ell]</span>  that  <span class="math">g(\\cdot)_j</span>  depends on; then 'query' the values of  <span class="math">\\hat{w}_0[i]</span>  for all  <span class="math">i \\in I_j</span>  as in the previous step; then update  <span class="math">\\hat{w}_1[j] := g(\\hat{w}_0)[j]</span>  and reply with  <span class="math">\\hat{w}_1[j]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that  <span class="math">S_{\\mathrm{RLACSP}}</span>  runs in time  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ q_{\\tilde{V}} + c)<span class="math"> , where  </span>q_{\\tilde{V}}<span class="math">  denotes the actual number of queries made by  </span>\\tilde{V}<span class="math">  and  </span>c<span class="math">  is  </span>g<span class="math"> &#x27;s efficiency (see Definition 8.3). Since  </span>c<span class="math">  is polynomially bounded,  </span>S_{\\mathrm{RLACSP}}<span class="math">  runs in time  </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathbf{q}_{\\tilde{V}})$ , as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We must show that View  <span class="math">\\langle P_{\\mathrm{RLACSP}}(\\mathbf{x},\\mathbf{w}),\\tilde{V} (\\mathbf{x})\\rangle</span>  and  <span class="math">S_{\\mathrm{RLACSP}}^{\\tilde{V}}(\\mathbf{x})</span>  are identically distributed. Recall that  <span class="math">P_{\\mathrm{RLACSP}}(\\mathbf{x},\\mathbf{w})</span>  samples  <span class="math">\\mathbf{w}&#x27;</span>  and then invokes  <span class="math">P_{\\mathrm{LACSP}}(\\mathbf{x},\\mathbf{w}&#x27;)</span> ; viewing  <span class="math">\\mathbf{w}&#x27;</span>  as a random variable, we get that View  <span class="math">\\langle P_{\\mathrm{RLACSP}}(\\mathbf{x},\\mathbf{w}),\\tilde{V} (\\mathbf{x})\\rangle \\equiv</span>  View  <span class="math">\\langle P_{\\mathrm{LACSP}}(\\mathbf{x},\\mathbf{w}&#x27;),\\tilde{V} (\\mathbf{x})\\rangle</span> . By  <span class="math">(P_{\\mathrm{LACSP}},V_{\\mathrm{LACSP}})</span> 's perfect zero knowledge guarantee, we also know that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\operatorname {V i e w} \\langle P _ {\\mathrm {L A C S P}} (\\mathbf {x}, \\mathbf {w} ^ {\\prime}), \\tilde {V} (\\mathbf {x}) \\rangle , q _ {\\tilde {V}}\\right) \\equiv \\left(S _ {\\mathrm {L A C S P}} ^ {\\tilde {V}, \\mathbf {w} ^ {\\prime}} (\\mathbf {x}), q _ {S _ {\\mathrm {L A C S P}}}\\right).</span></div>

    <p class="text-gray-300">We are left to show that  <span class="math">S_{\\mathrm{LACSP}}^{\\tilde{V},\\mathbf{w}&#x27;}(\\mathbf{x}) \\equiv S_{\\mathrm{RLACSP}}^{\\tilde{V}}(\\mathbf{x})</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the query bound, we know that  <span class="math">S_{\\mathrm{LACSP}}</span>  makes at most  <span class="math">t / q</span>  queries to  <span class="math">\\mathsf{w}&#x27;</span> . By construction of  <span class="math">S_{\\mathrm{RLACSP}}</span> , this causes at most  <span class="math">t</span>  entries in  <span class="math">\\tilde{w}_0</span>  to be 'defined', since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q<span class="math">  for all  </span>j \\in [\\ell]<span class="math">  (by  </span>g<span class="math"> &#x27;s locality); let  </span>E \\subseteq [\\ell]<span class="math">  be these entries. Since  </span>w_1 = g(w_0)<span class="math"> , all of the responses to  </span>S_{\\mathrm{LACSP}}<span class="math"> &#x27;s queries are determined by  </span>w_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_E<span class="math"> . While  </span>E<span class="math">  is itself dependent on  </span>w_0'<span class="math">  (as  </span>\\tilde{V}<span class="math"> &#x27;s queries may be adaptive), this does not affect the distribution of the string  </span>w_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_E<span class="math">  because  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq t<span class="math">  and  </span>w_0'<span class="math">  is drawn from a  </span>t<span class="math"> -wise independent distribution. We deduce that there exists a deterministic function  </span>v(\\cdot)<span class="math">  such that  </span>S_{\\mathrm{LACSP}}<span class="math"> &#x27;s queries to  </span>\\mathsf{w}'<span class="math">  are answered by  </span>v(w_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_E)<span class="math">  in the &#x27;real&#x27; execution, and  </span>S_{\\mathrm{RLACSP}}<span class="math">  answers the same queries with  </span>v(U)<span class="math">  where  </span>U<span class="math">  is uniformly random in  </span>\\mathbb{F}^E<span class="math"> . But  </span>w_0'<span class="math">  is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> -wise independent, so that  </span>w_0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_E \\equiv U<span class="math"> , and thus  </span>S_{\\mathrm{LACSP}}^{\\tilde{V},\\mathsf{w}'}(\\mathbf{x}) \\equiv S_{\\mathrm{RLACSP}}^{\\tilde{V}}(\\mathbf{x})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are almost ready to prove Theorem 8.1, the main theorem of this section. The last missing piece is a suitable reduction from  <span class="math">\\mathbf{NTIME}(T)</span>  to  <span class="math">\\mathcal{R}_{\\mathrm{RLACSP}}</span> , the promise relation of RLACSPs. Below, we state a special case of [BCGV16, Thm. 7.9], which provides the reduction that we need.</p>

    <p class="text-gray-300">Theorem 8.10 (NTIME  <span class="math">\\rightarrow</span> <span class="math">\\mathcal{R}_{\\mathrm{RLACSP}}</span> ). For every  <span class="math">T, t \\colon \\mathbb{N} \\to \\mathbb{N}</span> , constant  <span class="math">\\tau \\in (0,1)</span> , and  <span class="math">\\mathcal{R} \\in \\mathrm{NTIME}(T)</span>  there exist algorithms inst,  <span class="math">\\mathrm{wit}_1</span> ,  <span class="math">\\mathrm{wit}_2</span>  satisfying the following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EFFICIENT REDUCTION. For every instance  <span class="math">\\mathbf{x}</span> , letting  <span class="math">\\mathbf{x}&#x27; := \\mathrm{inst}(\\mathbf{x})</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if  <span class="math">\\mathbf{x} \\in \\operatorname{Lan}(\\mathcal{R})</span>  then  <span class="math">\\mathbf{x}&#x27; \\in \\operatorname{Lan}(\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}})</span> ;</li>

      <li>if  <span class="math">\\mathbf{x} \\notin \\operatorname{Lan}(\\mathcal{R})</span>  then  <span class="math">\\mathbf{x}&#x27; \\in \\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}}</span> ;</li>

      <li>for every witness  <span class="math">\\mathbf{w}</span> , if  <span class="math">(\\mathbf{x},\\mathbf{w})\\in \\mathcal{R}</span>  then  <span class="math">(\\mathbf{x}&#x27;,\\mathrm{wit}_1(\\mathbf{x},\\mathbf{w}))\\in \\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}}</span></li>

      <li>for every witness  <span class="math">\\mathbf{w}&#x27;</span> , if  <span class="math">(\\mathbf{x}&#x27;, \\mathbf{w}&#x27;) \\in \\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}}</span>  then  <span class="math">(\\mathbf{x}, \\mathrm{wit}_2(\\mathbf{x}, \\mathbf{w}&#x27;)) \\in \\mathcal{R}</span> .</li>

    </ul>

    <p class="text-gray-300">Moreover, inst runs in time  <span class="math">\\mathrm{poly}(n + \\log (T(n) + t(n)))</span>  and  <span class="math">\\mathrm{wit}_1,\\mathrm{wit}_2</span>  run in time  <span class="math">\\mathrm{poly}(n)\\cdot \\tilde{O} (T(n) + t(n))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RANDOMIZABLE LINEAR ALGEBRAIC CSP. The promise relation  <span class="math">(\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}},\\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}})</span>  has the parameters:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(RESRLACSP, LNORLACSP)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F2log(T+t)+O(log log(T+t))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">first code</td>

            <td class="px-3 py-2 border-b border-gray-700">C0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">second code</td>

            <td class="px-3 py-2 border-b border-gray-700">C1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">block length</td>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T+t)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">relative distance</td>

            <td class="px-3 py-2 border-b border-gray-700">τ</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">map locality</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">map efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(n+log T)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">randomizability</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">randomize time</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T+t)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(The hidden constants depend on the choice of  <span class="math">\\tau</span> ; see [BCGV16, Thm. 7.9] for the dependence on  <span class="math">\\tau</span> .)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ADDITIVE REED-SOLOMON CODES.  <span class="math">\\operatorname{Rel}(C_0 \\times C_1)</span>  is a subfamily of  <span class="math">\\mathrm{ERS}^+</span> .</li>

    </ul>

    <p class="text-gray-300">Proof of Theorem 8.1. The theorem directly follows by having the prover and verifier reduce the given relation in  <span class="math">\\mathbf{NTIME}(T)</span>  to  <span class="math">(\\mathcal{R}_{\\mathrm{RLACSP}}^{\\mathrm{YES}},\\mathcal{L}_{\\mathrm{RLACSP}}^{\\mathrm{NO}})</span> , following Theorem 8.10, and then invoking Theorem 8.9 with the perfect zero knowledge IOP of Proximity for  <span class="math">\\mathrm{ERS^{+}}</span>  from Corollary 7.14.</p>

    <p class="text-gray-300">A Prior work on single-prover unconditional zero knowledge</p>

    <p class="text-gray-300">We summarize prior work on single-prover proof systems that achieve zero knowledge unconditionally. First, the complexity classes of PZK IPs and SZK IPs are contained in <span class="math">\\mathbf{AM}\\cap\\mathbf{coAM}</span> <em>[x10, x2]</em>, so they do not contain <span class="math">\\mathbf{NP}</span> unless the polynomial hierarchy collapses <em>[x1]</em>; thus, IPs have strong limitations. Next, we discuss other single-prover proof systems: PCPs and IPCPs; all prior work for these is about statistical zero knowledge (SZK), via simulators that are straightline (which is needed in many of the cryptographic applications explored in these works).</p>

    <p class="text-gray-300">SZK PCP for <span class="math">\\mathbf{NEXP}</span>. <em>[x16]</em> obtain PCPs for <span class="math">\\mathbf{NEXP}</span> that are SZK against unbounded queries; the PCP has exponential length, the honest verifier makes a polynomial number of queries, and malicious verifiers can make any polynomial number of queries. Their construction has two steps: (1) transform a given PCP into a new one that is PZK against (several independent copies of) the honest verifier; (2) transform the latter PCP into a new one that is SZK against malicious verifiers. The first step uses secret sharing and builds on techniques of <em>[DFK^{+}92]</em>; the second uses locking schemes, which are information-theoretic PCP-analogues of commitment schemes. Subsequent work simplifies the steps: <em>[x17]</em> use MPC techniques to simplify the first step; and <em>[x15, x16]</em> give a simple construction of locking schemes, by obtaining a non-interactive PCP-analogue of <em>[x20]</em>’s commitment scheme.</p>

    <p class="text-gray-300">SZK PCP for <span class="math">\\mathbf{NP}</span> against unbounded queries. A PCP must have super-polynomial length if it ensures SZK against any polynomial number of malicious queries: if not, a malicious verifier could read the entire PCP, in which case zero knowledge is impossible for non-trivial languages <em>[x12]</em>. If one allows the prover to be inefficient, then invoking <em>[x16]</em>’s result for any language in <span class="math">\\mathbf{NEXP}</span>, including <span class="math">\\mathbf{NP}</span> languages, suffices. Yet, in the case of <span class="math">\\mathbf{NP}</span>, one can still aim for oracle efficiency: the prover outputs a succinct representation of the oracle, i.e., a polynomial-size circuit that, given an index, outputs the value at that index. However, <em>[x15, x21, x16]</em> show that languages with oracle-efficient PCPs that are SZK against unbounded queries are contained in the complexity class of SZP IPs, which is unlikely to contain <span class="math">\\mathbf{NP}</span>.</p>

    <p class="text-gray-300">SZK PCP for <span class="math">\\mathbf{NP}</span> against bounded queries. <em>[x16]</em> obtain PCPs for <span class="math">\\mathbf{NP}</span> that are SZK against b malicious queries, for a given polynomially-bounded function b. The construction is analogous to the one for <span class="math">\\mathbf{NEXP}</span>, but with different parameter choices. (The simplifications in <em>[x15, x16, x17]</em> also apply to this case.)</p>

    <p class="text-gray-300">Subsequently, <em>[x17]</em> consider the case of zero knowledge PCPs of proximity; they obtain PCPPs for <span class="math">\\mathbf{NP}</span> that are SZK against b malicious queries. Like <em>[x16]</em>, their construction has two steps: (1) use MPC techniques to transform a given PCPP into a new one that is PZK against (several independent copies of) the honest verifier; (2) use locking schemes to transform the latter PCPP into a new one that is SZK against malicious verifiers.</p>

    <p class="text-gray-300">SZK IPCP for <span class="math">\\mathbf{NP}</span> against unbounded queries. For an IPCP to ensure SZK against any polynomial number of queries, the prover must send a PCP with super-polynomial length: if not, a malicious verifier could read the entire PCP, forcing the IPCP model to “collapse” to IP (recall that the complexity class of SZK IPs is unlikely to contain <span class="math">\\mathbf{NP}</span>). As in the PCP model, one may still aim for oracle efficiency, and this time no limitations apply because a positive result is known: <em>[x13]</em> obtain oracle-efficient IPCPs for <span class="math">\\mathbf{NP}</span> that are SZK against unbounded queries. Their construction is analogous to <em>[x16]</em>’s, but relies on interactive locking schemes in the IPCP model, rather than non-interactive ones in the PCP model; this circumvents the impossibility result for oracle-efficient PCPs.</p>

    <p class="text-gray-300">The algorithm  <span class="math">\\mathcal{A}</span> , given  <span class="math">(\\mathfrak{n}, S, \\alpha)</span> , where  <span class="math">S = \\{(\\alpha_1, \\beta_1), \\ldots, (\\alpha_\\ell, \\beta_\\ell)\\} \\subseteq D(\\mathfrak{n}) \\times \\mathbb{F}(\\mathfrak{n})</span>  and  <span class="math">\\alpha \\in D(\\mathfrak{n})</span> , works as follows: (1) run  <span class="math">\\mathcal{C}</span> 's constraint detector on input  <span class="math">(\\mathfrak{n}, \\{\\alpha_1, \\ldots, \\alpha_\\ell, \\alpha\\})</span> ; (2) if the detector outputs an empty basis or a basis  <span class="math">z_1, \\ldots, z_d</span>  where  <span class="math">z_i(\\alpha) = 0</span>  for all  <span class="math">i</span> , then output a random element in  <span class="math">\\mathbb{F}(\\mathfrak{n})</span> ; (3) if the detector outputs some basis element  <span class="math">z_j</span>  where  <span class="math">z_j(\\alpha) \\neq 0</span> , then output  <span class="math">-\\sum_{i=1}^{\\ell} \\frac{z_j(\\alpha_i)}{z_j(\\alpha)} \\beta_i</span> . The stated time complexity of  <span class="math">\\mathcal{A}</span>  is clear from its construction. We now argue correctness. Define the probability</p>

    <div class="my-4 text-center"><span class="math-block">p := \\operatorname * {P r} _ {w \\leftarrow C _ {n}} \\left[ \\begin{array}{c c} w (\\alpha) = \\beta &amp;amp; w (\\alpha_ {1}) = \\beta_ {1} \\\\ &amp;amp; \\vdots \\\\ &amp;amp; w (\\alpha_ {\\ell}) = \\beta_ {\\ell} \\end{array} \\right]  .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim. (A) If there exist  <span class="math">a_1, \\ldots, a_\\ell \\in \\mathbb{F}(\\mathfrak{n})</span>  such that  <span class="math">w(\\alpha) = \\sum_{i=1}^\\ell a_i w(\\alpha_i)</span>  for all  <span class="math">w \\in C_n</span>  (Condition A), then  <span class="math">p = 1</span>  if  <span class="math">\\beta = \\sum_{i=1}^\\ell a_i \\beta_i</span>  and  <span class="math">p = 0</span>  otherwise. (B) If no such  <span class="math">a_1, \\ldots, a_\\ell</span>  exist, then  $p = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of claim. If Condition A holds, then, for any  <span class="math">w \\in C_n</span>  such that  <span class="math">w(\\alpha_1) = \\beta_1, \\ldots, w(\\alpha_\\ell) = \\beta_\\ell</span> , it holds that  <span class="math">w(\\alpha) = \\sum_{i=1}^\\ell a_i w(\\alpha_i) = \\sum_{i=1}^\\ell a_i \\beta_i</span> , which proves the first part of the claim.</p>

    <p class="text-gray-300">Next, let  <span class="math">d \\coloneqq \\dim(C_n)</span>  and let  <span class="math">w_1, \\ldots, w_d</span>  be a basis of  <span class="math">C_n</span> . Define  <span class="math">\\phi_\\alpha \\coloneqq (w_1(\\alpha), \\ldots, w_d(\\alpha))</span> . We argue that Condition A holds if and only if  <span class="math">\\phi_\\alpha \\in \\operatorname{span}(\\phi_{\\alpha_1}, \\ldots, \\phi_{\\alpha_\\ell})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that Condition A holds. Then  <span class="math">w_{j}(\\alpha) = \\sum_{i=1}^{\\ell} a_{i} w_{j}(\\alpha_{i})</span>  for every  <span class="math">j \\in \\{1, \\ldots, d\\}</span> . Since  <span class="math">w_{j}(\\alpha)</span>  is the  <span class="math">j</span> -th coordinate of  <span class="math">\\phi_{\\alpha}</span> , it also holds that  <span class="math">\\phi_{\\alpha} = \\sum_{i=1}^{\\ell} a_{i} \\phi_{\\alpha_{i}}</span> , so that  <span class="math">\\phi_{\\alpha} \\in \\operatorname{span}(\\phi_{\\alpha_{1}}, \\ldots, \\phi_{\\alpha_{\\ell}})</span> .</li>

      <li>Suppose that  <span class="math">\\phi_{\\alpha} \\in \\operatorname{span}(\\phi_{\\alpha_1}, \\ldots, \\phi_{\\alpha_\\ell})</span> . Then there exist  <span class="math">a_1, \\ldots, a_\\ell</span>  such that  <span class="math">\\phi_{\\alpha} = \\sum_{i=1}^{\\ell} a_i \\phi_{\\alpha_i}</span> . For any  <span class="math">w \\in C_n</span> , we can write  <span class="math">w = \\sum_{j=1}^{d} b_j w_j</span>  (for some  <span class="math">b_j</span> 's), so that  <span class="math">w(\\alpha) = \\sum_{j=1}^{d} b_j w_j(\\alpha) = \\langle w, \\phi_{\\alpha} \\rangle = \\sum_{i=1}^{\\ell} a_i \\langle w, \\phi_{\\alpha_i} \\rangle = \\sum_{i=1}^{\\ell} a_i w(\\alpha_i)</span> .</li>

    </ul>

    <p class="text-gray-300">Thus, the negation of Condition A is equivalent to  <span class="math">\\phi_{\\alpha} \\notin \\operatorname{span}(\\phi_{\\alpha_1}, \\ldots, \\phi_{\\alpha_\\ell})</span> , which we now assume to prove the second part of the claim, as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\Phi \\in \\mathbb{F}(\\mathfrak{n})^{\\ell \\times d}</span>  be the matrix whose rows are  <span class="math">\\phi_{\\alpha_1},\\ldots ,\\phi_{\\alpha_\\ell}</span> , and let  <span class="math">w_1^{\\prime},\\ldots ,w_k^{\\prime}</span>  be a basis for  <span class="math">\\Phi</span>  's nullspace. Let  <span class="math">\\Phi^\\prime</span>  be the matrix  <span class="math">\\Phi</span>  augmented with the row  <span class="math">\\phi_{\\alpha}</span> . Note that  <span class="math">\\mathrm{rank}(\\Phi &#x27;) = \\mathrm{rank}(\\Phi) + 1</span> , so the nullspace of  <span class="math">\\Phi^\\prime</span>  has dimension  <span class="math">k - 1</span> , which implies that there exists  <span class="math">j\\in \\{1,\\dots ,k\\}</span>  such that  <span class="math">\\langle w_j&#x27;,\\phi_\\alpha \\rangle \\neq 0</span> . Also note that, for every  <span class="math">w\\in C_n</span>  such that  <span class="math">w(\\alpha_{1}) = \\beta_{1},\\ldots ,w(\\alpha_{\\ell}) = \\beta_{\\ell}</span>  and  <span class="math">r\\in \\mathbb{F}(\\mathfrak{n})</span> , the codeword  <span class="math">w + rw_{j}^{\\prime}</span>  satisfies the same equations as  <span class="math">w</span>  does. Therefore, if  <span class="math">w</span>  is drawn uniformly randomly from  <span class="math">C_n</span>  such that  <span class="math">w(\\alpha_{1}) = \\beta_{1},\\ldots ,w(\\alpha_{\\ell}) = \\beta_{\\ell}</span> , then  <span class="math">w + rw_{j}^{\\prime}</span>  for  <span class="math">r</span>  uniformly random in  <span class="math">\\mathbb{F}(\\mathfrak{n})</span>  is identically distributed to  <span class="math">w</span> . We conclude that  $\\operatorname<em>{Pr}[w(\\alpha) = \\beta ] = \\operatorname</em>{Pr}[(w + rw_j')(\\alpha) = \\beta ] = \\operatorname*{Pr}[r = \\frac{\\beta - \\langle w,\\phi_\\alpha\\rangle}{\\langle w_j',\\phi_\\alpha\\rangle}] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}(\\mathfrak{n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , since  </span>\\langle w_j',\\phi_\\alpha \\rangle \\neq 0$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the definition of constraint detection,  <span class="math">a_1, \\ldots, a_\\ell</span>  as above exist if and only if there exists  <span class="math">z</span>  in the space output by the constraint detector such that  <span class="math">z(\\alpha) = 1</span> . If the constraint detector outputs  <span class="math">z_1, \\ldots, z_d</span>  such that  <span class="math">z_i(\\alpha) = 0</span>  for all  <span class="math">i</span> , then clearly the space contains no such vector. Otherwise, let  <span class="math">j</span>  be such that  <span class="math">z_j(\\alpha) \\neq 0</span> ; then  <span class="math">a_i = -z_j(\\alpha_i) / z_j(\\alpha)</span>  for  <span class="math">i = 1, \\ldots, \\ell</span>  is a solution. Hence this distribution equals that of  <span class="math">\\mathcal{A}</span> 's output, and moreover fully describes the probability distribution of  <span class="math">w(\\alpha)</span> . The lemma follows.</p>

    <p class="text-gray-300">C Proof of Lemma 4.6</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Claim 4.5, it suffices to show an algorithm that computes a basis of <span class="math">(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span> in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. So consider the algorithm that, on input an index </span>\\mathfrak{n}<span class="math"> and subset </span>I\\subseteq D(\\mathfrak{n})<span class="math">, works as follows. First, invoke the hypothesis to compute the set </span>W<span class="math">; since vectors are represented sparsely we conclude that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{supp}(W)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. (Recall that </span>\\mathrm{supp}(W):=\\cup_{z\\in W}\\mathrm{supp}(z)<span class="math">.) We may assume </span>W<span class="math"> is linearly independent; otherwise, make it thus via Gaussian elimination which runs in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{supp}(W)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Similarly, the bound on </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{supp}(W)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> implies that a basis </span>W^{\\prime}<span class="math"> for the subspace </span>W_{\\subseteq I}<span class="math"> can be found in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and we let </span>W^{\\prime}$ be the output of our algorithm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To argue correctness it suffices to show that <span class="math">\\mathrm{span}(W^{\\prime})=(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span>. We first argue <span class="math">\\mathrm{span}(W^{\\prime})\\subseteq(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span>, so let <span class="math">z^{\\prime}\\in\\mathrm{span}(W^{\\prime})</span>, which can be represented as <span class="math">z^{\\prime}=\\sum_{\\lambda\\in\\Lambda}a_{\\lambda}\\sum_{z\\in W}\\lambda(z)\\cdot z</span>; note that <span class="math">z^{\\prime}\\in\\mathrm{span}(W)\\subseteq C_{\\mathfrak{n}}^{\\perp}</span> and <span class="math">\\mathrm{supp}(z^{\\prime})\\subseteq\\mathrm{supp}(W)=I\\cup\\overline{I}</span>. Hence, it suffices to show that <span class="math">\\mathrm{supp}(z^{\\prime})\\cap\\overline{I}=\\emptyset</span>; but this is true by the choice of <span class="math">\\Lambda</span>, because <span class="math">M\\cdot\\lambda=0</span> for every <span class="math">\\lambda\\in\\Lambda</span>, so that <span class="math">\\sum_{z\\in W}\\lambda(w)\\cdot z(\\alpha)=0</span> for every <span class="math">\\alpha\\in\\overline{I}</span> (by <span class="math">M</span>’s definition), so that <span class="math">z^{\\prime}(\\alpha)=\\sum_{\\lambda\\in\\Lambda}a_{\\lambda}\\sum_{z\\in W}\\lambda(z)\\cdot z(\\alpha)=0</span> for every <span class="math">\\alpha\\in\\overline{I}</span>, as required.</p>

    <p class="text-gray-300">We next argue that <span class="math">\\mathrm{span}(W^{\\prime})\\supseteq(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span>, and for this it suffices to show that any <span class="math">w\\in\\mathrm{span}(W)</span> having representation <span class="math">w=\\sum_{z\\in W}a_{z}\\cdot z</span> such that <span class="math">\\vec{a}:=(a_{z})_{z\\in W}\\notin\\mathrm{span}(\\Lambda)</span> can not be in <span class="math">(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span>. This follows by the definition of <span class="math">\\Lambda</span>, because for any <span class="math">\\vec{a}\\notin\\mathrm{span}(\\Lambda)</span> there exists <span class="math">\\alpha\\in\\overline{I}</span> such that <span class="math">w(\\alpha)=\\sum_{z\\in W}a_{z}\\cdot z(\\alpha)\\neq 0</span>, so that <span class="math">w\\notin(C_{\\mathfrak{n}}^{\\perp})_{\\subseteq I}</span>.</p>

    <h2 id="sec-120" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">D Proof of Lemma 4.11</p>

    <p class="text-gray-300">For completeness, we give an elementary proof of Lemma 4.11, by simplifying the proof of <em>[x10, Thm. 10]</em> for polynomials of the form we require; note that <em>[x22]</em> and <em>[x3]</em> also use similar techniques. We first introduce some notation. We consider a polynomial <span class="math">Q\\in\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span> equivalently as a univariate polynomial of degree less than <span class="math">d</span> in <span class="math">X_{1}</span> with coefficients in <span class="math">\\mathbb{F}^{&lt;d}[X_{2},\\ldots,X_{m}]</span>, and let <span class="math">\\partial_{1}^{j}Q</span> be the coefficient of <span class="math">X_{1}^{j}</span> in this representation. Define <span class="math">\\partial_{1}^{j}\\vec{Q}:=(\\partial_{1}^{j}Q_{1},\\ldots,\\partial_{1}^{j}Q_{\\ell})</span>. In general, given an arbitrary arithmetic circuit representing a polynomial <span class="math">Q</span>, it is not clear how to efficiently compute a circuit representing <span class="math">\\partial_{1}^{j}Q</span>, because <span class="math">Q</span> may have exponentially many monomials. Nevertheless, for circuits of the required form, this computation is trivial.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim. Let <span class="math">\\vec{Q}:=(Q_{1},\\ldots,Q_{\\ell})</span> be a vector of polynomials in <span class="math">\\mathbb{F}^{&lt;d}[X_{1},\\ldots,X_{m}]</span>. If $d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> then </span>\\vec{Q}^{\\perp}=\\bigcap_{j=0}^{d-1}(\\partial_{1}^{j}\\vec{Q})^{\\perp}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-121" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When $d\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>Q\\in\\mathbb{F}^{<d}[X_{1},\\ldots,X_{m}]\\equiv 0<span class="math"> if and only if all of its coefficients are zero when written as a formal sum. Then one direction of the set equality follows straightforwardly from the linearity of </span>\\partial_{1}^{j}<span class="math">, namely, </span>\\vec{Q}^{\\perp}\\subseteq\\bigcap_{j=0}^{d-1}(\\partial_{1}^{j}\\vec{Q})^{\\perp}<span class="math">. For the other direction, we argue as follows. Fix some </span>(a_{1},\\ldots,a_{\\ell})\\in\\bigcap_{j=0}^{d-1}(\\partial_{1}^{j}\\vec{Q})^{\\perp}<span class="math"> and let </span>T:=\\sum_{k=1}^{\\ell}a_{k}Q_{k}<span class="math">; we have that </span>\\partial_{1}^{j}T\\equiv 0<span class="math"> for all </span>j\\in\\{0,\\ldots,d-1\\}<span class="math">, by linearity. But </span>T=\\sum_{j=0}^{d-1}(\\partial_{1}^{j}T)X_{1}^{j}<span class="math"> by definition, so </span>T\\equiv 0<span class="math">, and thus </span>(a_{1},\\ldots,a_{\\ell})\\in\\vec{Q}^{\\perp}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus to compute a basis of <span class="math">\\vec{Q}^{\\perp}</span> it suffices to compute the intersection of the bases of <span class="math">(\\partial_{1}^{j}\\vec{Q})^{\\perp}</span> for all <span class="math">j\\in\\{0,\\ldots,d-1\\}</span>. The naive approach yields an exponential-time algorithm since we reduce the problem to <span class="math">d</span> subproblems of roughly the same size. Observe, however, that for <span class="math">Q_{k}</span> of the specified form,</p>

    <p class="text-gray-300"><span class="math">\\partial_{1}^{j}Q_{k}=c_{k,j}T_{k}\\quad\\text{ where }T_{k}:=\\left(\\prod_{i=2}^{m}Q_{k,i}(X_{i})\\right)\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for constants <span class="math">c_{k,j}</span> computable in time <span class="math">\\mathrm{poly}(s)</span>. Let <span class="math">\\vec{T}:=(T_{1},\\ldots,T_{\\ell})</span> and let <span class="math">T^{\\perp}\\in\\mathbb{F}^{\\ell\\times b}</span> be a basis for <span class="math">\\vec{T}^{\\perp}</span>; note that <span class="math">b\\leq\\ell</span>. Let <span class="math">\\vec{a}:=(a_{1},\\ldots,a_{\\ell})\\in\\mathbb{F}^{\\ell}</span>, and observe that for each <span class="math">j</span>, <span class="math">\\sum_{k=1}^{\\ell}a_{k}\\partial_{1}^{j}Q_{k}\\equiv 0</span> if and only if <span class="math">\\sum_{k=1}^{\\ell}a_{k}c_{k,j}T_{k}\\equiv 0</span>, or equivalently, <span class="math">(a_{1}c_{1,j},\\ldots,a_{\\ell}c_{\\ell,j})\\in\\vec{T}^{\\perp}</span>. Hence <span class="math">(a_{1},\\ldots,a_{\\ell})\\in\\bigcap_{j=0}^{d}(\\partial_{1}^{j}\\vec{Q})^{\\perp}</span> if and only if for each <span class="math">j</span> there exists <span class="math">\\vec{v_{j}}\\in\\mathbb{F}^{b}</span> such that <span class="math">T^{\\perp}\\vec{v_{j}}=(a_{1}c_{1,j},\\ldots,a_{\\ell}c_{\\ell,j})</span>. This is a system of linear equations in <span class="math">\\vec{a},\\vec{v_{0}},\\ldots,v_{d-1}</span> of size <span class="math">\\mathrm{poly}(\\ell+d+b)</span>, and hence we can compute a basis for its solution space in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d+\\ell+b)<span class="math">. Restricting this basis to </span>\\vec{a}<span class="math"> yields a basis for </span>\\vec{Q}^{\\perp}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">Q_{1},\\ldots,Q_{n}</span> are univariate then we can easily determine a basis for <span class="math">\\vec{Q}^{\\perp}</span> in deterministic polynomial time (by Gaussian elimination). Otherwise, if the <span class="math">Q_{i}</span> are <span class="math">m</span>-variate, we use the procedure above to reduce computing <span class="math">\\vec{Q}^{\\perp}</span> to computing <span class="math">\\vec{T}^{\\perp}</span> for some <span class="math">\\vec{T}=(T_{1},\\ldots,T_{\\ell})</span> where the <span class="math">T_{i}</span> are <span class="math">(m-1)</span>-variate. This algorithm terminates in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+m+d+s+\\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-122" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">E Proof of Claim 4.23</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First we show that <span class="math">\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)\\subseteq (C^\\perp)_{\\subseteq (\\cup_{j\\in J}\\tilde{D}_j)}</span>. For every <span class="math">j\\in J</span> and <span class="math">z\\in \\tilde{C}_j^\\perp</span>, it holds that <span class="math">\\mathrm{supp}(z)\\subseteq \\tilde{D}_j</span>; therefore, for every <span class="math">z\\in \\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)</span>, it holds that <span class="math">\\mathrm{supp}(z)\\subseteq \\cup_{j\\in J}\\tilde{D}_j</span>; thus it is suffices to show that, for every <span class="math">z\\in \\cup_{j\\in J}\\tilde{C}_j^\\perp</span> and <span class="math">w\\in C</span>, it holds that <span class="math">\\langle w,z\\rangle = 0</span>. But this holds because for every <span class="math">z\\in \\cup_{j\\in J}\\tilde{C}_j^\\perp</span> there exists <span class="math">j\\in J</span> such that <span class="math">z\\in \\tilde{C}_j^\\perp</span> and $C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_j} = \\tilde{C}_j<span class="math"> so that </span>\\langle w,z\\rangle = \\langle w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_j},z\\rangle = 0$, as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next we show that <span class="math">\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)\\supseteq (C^\\perp)_{\\subseteq (\\cup_{j\\in J}\\tilde{D}_j)}</span>, which is equivalent to $\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)\\supseteq (C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\cup_{j\\in J}\\tilde{D}_j})^\\perp<span class="math"> by Claim 4.5. Recall that for any two linear spaces </span>U,V<span class="math"> it holds that </span>U\\subseteq V<span class="math"> if and only if </span>U^{\\perp}\\supseteq V^{\\perp}<span class="math">, thus it is sufficient to show that </span>\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)^\\perp \\subseteq C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\cup_{j\\in J}\\tilde{D}_j}<span class="math">, i.e., that every </span>w\\in \\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)^\\perp<span class="math"> can be extended to </span>w^{\\prime}\\in C<span class="math">. This latter statement holds because </span>\\mathrm{span}(\\cup_{j\\in J}\\tilde{C}_j^\\perp)^\\perp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_j}\\subseteq (\\tilde{C}_j^\\perp)^\\perp = \\tilde{C}_j<span class="math"> for every </span>j\\in J<span class="math">, and thus </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}_j}\\in \\tilde{C}_j<span class="math">. Recalling </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\kappa<span class="math"> implies, by Definition 4.15, that </span>w<span class="math"> can be extended to a codeword </span>w^{\\prime}\\in C$, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">F Definition of the linear code family BS-RS</p>

    <p class="text-gray-300">In this section we define the linear code family BS-RS, which consists of evaluations of univariate polynomials concatenated with corresponding BS proximity proofs [BS08]. The definition is quite technical, and we refer the interested reader to [BS08] for a discussion of why it enables proximity testing. We begin with notation used later.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Definition F.1.</h6>

    <p class="text-gray-300">Given a field <span class="math">\\mathbb{F}</span>, a subfield <span class="math">\\mathbb{K}\\subseteq\\mathbb{F}</span>, a <span class="math">\\mathbb{K}</span>-linear space <span class="math">L\\subseteq\\mathbb{F}</span> with a basis <span class="math">(b_{1},b_{2},\\ldots,b_{\\ell})</span>, a positive integer <span class="math">\\mu</span>, and a positive integer <span class="math">k&gt;2\\mu</span>, we make the following definitions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Four subspaces of <span class="math">L</span> and a subset of <span class="math">L</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">L_{0}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\mathrm{span}_{\\mathbb{K}}(b_{1},b_{2},\\ldots,b_{\\lfloor\\ell/2\\rfloor})</span> <span class="math">L_{0}^{\\prime}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\mathrm{span}_{\\mathbb{K}}(b_{1},b_{2},\\ldots,b_{\\lfloor\\ell/2\\rfloor+\\mu-1})</span> <span class="math">L_{1}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\mathrm{span}_{\\mathbb{K}}(b_{\\lfloor\\ell/2\\rfloor+1},\\ldots,b_{\\ell})</span> <span class="math">\\forall\\,\\beta\\in L_{1}[\\mathbb{K},\\mathbb{F},L,\\mu]\\,,\\ L_{\\beta}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\mathrm{span}_{\\mathbb{K}}(b_{1},b_{2},\\ldots,b_{\\lfloor\\ell/2\\rfloor+\\mu-1},\\beta^{\\prime})</span> <span class="math">\\forall\\,\\beta\\in L_{1}[\\mathbb{K},\\mathbb{F},L,\\mu]\\,,\\ R_{\\beta}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=L_{\\beta}\\setminus(L_{0}+\\beta)</span></p>

    <p class="text-gray-300">where <span class="math">\\beta^{\\prime}:=b_{\\lfloor\\ell/2\\rfloor+\\mu}</span> if <span class="math">\\beta\\in L_{0}^{\\prime}</span> and <span class="math">\\beta^{\\prime}:=\\beta</span> otherwise.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The vanishing polynomial of <span class="math">L_{0}</span>: <span class="math">Z_{L_{0}}<a href="X">\\mathbb{K},\\mathbb{F},L,\\mu</a>:=\\prod_{\\alpha\\in L_{0}}(X-\\alpha)</span>.</li>

      <li>The following domains:</li>

    </ul>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{bi}}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\{({\\alpha},Z_{L_{0}}(\\beta)):\\beta\\in L_{1},\\alpha\\in L_{\\beta}\\}</span> <span class="math">D_{\\mathrm{pf}}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=\\{({\\alpha},Z_{L_{0}}(\\beta)):\\beta\\in L_{1},\\alpha\\in R_{\\beta}\\}</span> <span class="math">D_{\\Box}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">:=(\\{\\mathrm{rs}\\}\\times L)\\sqcup(\\{\\mathrm{px}\\}\\times D_{\\mathrm{pf}})</span></p>

    <p class="text-gray-300">where we use the symbols ‘<span class="math">\\mathrm{rs}</span>’ and ‘<span class="math">\\mathrm{px}</span>’ to distinguish different parts of the disjoint union.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The bijection <span class="math">\\phi[\\mathbb{K},\\mathbb{F},L,\\mu]\\colon D_{\\mathrm{bi}}\\to D_{\\Box}</span> is defined by <span class="math">\\phi(\\alpha,\\beta):=\\begin{cases}(\\mathrm{px},(\\alpha,\\beta))&amp;(\\alpha,\\beta)\\in D_{\\mathrm{pf}}\\cr(\\mathrm{rs},\\alpha)&amp;\\text{otherwise}\\end{cases}</span>.</li>

      <li>Given <span class="math">w\\in\\mathbb{F}^{D_{\\Box}[\\mathbb{K},\\mathbb{F},L,\\mu]}</span>, the bivariate function <span class="math">f_{w}\\colon D_{\\mathrm{bi}}[\\mathbb{K},\\mathbb{F},L,\\mu]\\to\\mathbb{F}</span> is defined by <span class="math">f_{w}(\\alpha,\\beta):=w(\\phi(\\alpha,\\beta))</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The fractional degree $\\rho[\\mathbb{K},\\mathbb{F},\\mu]:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-\\mu}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The domain <span class="math">D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> implied by the recursion below:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\dim(L)\\leq k</span> then <span class="math">D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]:=D_{\\mathrm{pf}}[\\mathbb{K},\\mathbb{F},L,\\mu]</span>;</li>

      <li>if <span class="math">\\dim(L)&gt;k</span> then</li>

    </ul>

    <p class="text-gray-300"><span class="math">D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]:=D_{\\mathrm{pf}}[\\mathbb{K},\\mathbb{F},L,\\mu]</span> <span class="math">\\bigsqcup\\left(\\sqcup_{\\alpha\\in L_{0}^{\\prime}}\\{(\\mathrm{col},\\alpha)\\}\\times D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]\\right)</span> <span class="math">\\bigsqcup\\left(\\sqcup_{\\beta\\in L_{1}}\\{(\\mathrm{row},\\beta)\\}\\times D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]\\right)\\ .</span></p>

    <p class="text-gray-300">where we use the symbols ‘<span class="math">\\mathrm{col}</span>’ and ‘<span class="math">\\mathrm{row}</span>’ to distinguish different parts of the disjoint union.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The domain <span class="math">D^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]:=(\\{\\mathrm{rs}\\}\\times L)\\sqcup\\big{(}\\{\\mathrm{px}\\}\\times D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]\\big{)}</span>.</li>

      <li>Given <span class="math">\\alpha\\in L_{0}^{\\prime}</span>, the embedding <span class="math">\\phi_{\\mathrm{col},\\alpha}\\colon D^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]\\hookrightarrow D^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is defined by</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\phi_{\\mathrm{col},\\alpha}(x):=\\begin{cases}(\\mathrm{px},((\\mathrm{col},\\alpha),x))&amp;x\\in\\{\\mathrm{px}\\}\\times D_{\\mathrm{px}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]\\\\ \\phi(\\alpha,\\beta)&amp;x=(\\{\\mathrm{rs}\\},Z_{L_{0}}(\\beta))\\end{cases}</span></p>

    <p class="text-gray-300">We denote by <span class="math">D_{\\mathrm{col},\\alpha}</span> the image of <span class="math">\\phi_{\\mathrm{col},\\alpha}</span>.</p>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">\\beta \\in L_1</span>, the embedding <span class="math">\\phi_{\\mathrm{row},\\beta} \\colon D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu ,k] \\hookrightarrow D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> is defined by</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\phi_ {\\mathrm {r o w}, \\beta} (x) := \\left\\{ \\begin{array}{l l} (\\mathrm {p x}, ((\\mathrm {r o w}, \\beta), x)) &amp;amp; x \\in \\{\\mathrm {p x} \\} \\times D _ {\\mathrm {p x}} ^ {\\mathrm {B S - R S}} [ \\mathbb {K}, \\mathbb {F}, L _ {\\beta}, \\mu , k ] \\\\ \\phi (\\alpha , \\beta) &amp;amp; x = (\\{\\mathrm {r s} \\}, \\alpha) \\end{array} \\right.</span></div>

    <p class="text-gray-300">We denote by <span class="math">D_{\\mathrm{row},\\beta}</span> the image of <span class="math">\\phi_{\\mathrm{row},\\beta}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">\\alpha \\in L_0&#x27;</span>, <span class="math">\\psi_{\\mathrm{col},\\alpha} \\colon \\mathbb{F}^{D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]} \\to \\mathbb{F}^{D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu ,k]}</span> is the projection of <span class="math">D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> on <span class="math">D_{\\mathrm{col},\\alpha}</span> with indices renamed to elements of <span class="math">D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu ,k]</span>. Formally, <span class="math">\\psi_{\\mathrm{col},\\alpha}(w) = w&#x27;</span> if and only if <span class="math">w&#x27;(\\phi_{\\mathrm{col},\\alpha}(x)) = w(x)</span> for all <span class="math">x \\in D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu ,k]</span>.</li>

      <li>Given <span class="math">\\beta \\in L_1</span>, <span class="math">\\psi_{\\mathrm{row},\\beta} \\colon \\mathbb{F}^{D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]} \\to \\mathbb{F}^{D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu ,k]}</span> is the projection of <span class="math">D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> on <span class="math">D_{\\mathrm{row},\\beta}</span> with indices renamed to elements of <span class="math">D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu ,k]</span>. Formally, <span class="math">\\psi_{\\mathrm{row},\\beta}(w) = w&#x27;</span> if and only if <span class="math">w&#x27;(\\phi_{\\mathrm{row},\\beta}(x)) = w(x)</span> for all <span class="math">x \\in D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu ,k]</span>.</li>

    </ul>

    <p class="text-gray-300">The following definition considers a code that extends the evaluation of a univariate polynomial with a bivariate function that represents the polynomial over a specially-chosen set.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition F.2 (RS□).</strong> Given a field <span class="math">\\mathbb{F}</span>, a subfield <span class="math">\\mathbb{K} \\subseteq \\mathbb{F}</span>, a <span class="math">\\mathbb{K}</span>-linear space <span class="math">L \\subseteq \\mathbb{F}</span>, and a positive integer <span class="math">\\mu</span>, the code <span class="math">\\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]</span> consists of all <span class="math">w \\in \\mathbb{F}^{D_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]}</span> such that <span class="math">f_w \\colon D_{\\mathrm{bi}} \\to \\mathbb{F}</span> is an evaluation of a low degree polynomial: there exists a polynomial <span class="math">g \\in \\mathbb{F}[X, Y]</span> such that: (i) $\\deg_X(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, (ii) </span>\\deg_Y(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho[\\mathbb{K}, \\mathbb{F}, \\mu]<span class="math">, (iii) </span>g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D_{\\mathrm{bi}}} = f_w$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Ben-Sasson and Sudhan [BS08] show that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $v \\in \\mathrm{RS}[\\mathbb{F}, L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]<span class="math"> if and only if there exists </span>w \\in \\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]<span class="math"> such that </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\mathrm{rs}\\} \\times L} = v$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">w \\in \\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]</span> if and only if</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for every <span class="math">\\alpha \\in L_0&#x27;</span>, $f_w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\alpha\\} \\times Z_{L_0}(L_1)} \\in \\mathrm{RS}[\\mathbb{F}, Z_{L_0}(L_1),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]$ (with the standard mapping between domains) and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above equivalences illustrate the 'quadratic reduction' from testing that <span class="math">w \\in \\mathbb{F}^L</span> is a codeword of $\\mathrm{RS}[\\mathbb{F}, L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]<span class="math"> to a set of </span>\\Theta(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> problems of testing membership in codes of the form </span>\\mathrm{RS}[\\mathbb{F}, L', d']<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, d' = \\Theta(\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The code from Definition F.2 corresponds to one step of the recursive construction of [BS08]. We now build on that definition, and recursively define the linear code family BS-RS.</p>

    <p class="text-gray-300"><strong>Definition F.3 (BS-RS).</strong> Given a field <span class="math">\\mathbb{F}</span>, a subfield <span class="math">\\mathbb{K} \\subseteq \\mathbb{F}</span>, a <span class="math">\\mathbb{K}</span>-linear space <span class="math">L \\subseteq \\mathbb{F}</span>, a positive integer <span class="math">\\mu</span>, and a positive integer <span class="math">k &amp;gt; 2\\mu</span>, the code BS-RS[K, F, L, μ, k] consists of all words <span class="math">w \\in \\mathbb{F}^{D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]}</span> satisfying the following. If <span class="math">\\dim(L) \\leq k</span> then <span class="math">w \\in \\mathrm{RS}_{\\square}[\\mathbb{K},\\mathbb{F},L,\\mu]</span>. If <span class="math">\\dim(L) &amp;gt; k</span> the following holds: (1) for every <span class="math">\\alpha \\in L_0&#x27;</span> there exists <span class="math">w_{\\alpha} \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu,k]</span> such that <span class="math">w_{\\alpha}(\\phi_{\\mathrm{col},\\alpha}(x)) = w(x)</span> for every <span class="math">x \\in D[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu,k]</span>; (2) for every <span class="math">\\beta \\in L_1</span> there exists <span class="math">w_{\\beta} \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]</span> such that <span class="math">w_{\\beta}(\\phi_{\\mathrm{row},\\beta}(x)) = w(x)</span> for every <span class="math">x \\in D[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]</span>.</p>

    <p class="text-gray-300">We conclude this section with two claims about BS-RS that we use in later sections. We omit the proof of the first claim (and refer the interested reader to [BS08]), and prove the second claim based on the first one.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim F.4.</strong> For every codeword $w \\in \\mathrm{RS}[\\mathbb{F}, L,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]<span class="math">, positive integer </span>\\mu<span class="math">, and positive integer </span>k &gt; 2\\mu<span class="math">, there exists a unique </span>\\pi_w<span class="math"> such that </span>w \\circ \\pi_w \\in \\mathrm{BS - RS}[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Claim F.5.</strong> The following two statements hold for the code BS-RS[K, F, L, μ, k]:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\alpha \\in L_0&#x27;</span> and <span class="math">w&#x27; \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},Z_{L_0}(L_1),\\mu ,k]</span> there exists <span class="math">w \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> such that <span class="math">\\psi_{\\mathrm{col},\\alpha}(w) = w&#x27;</span>;</li>

      <li>for every <span class="math">\\beta \\in L_1</span> and <span class="math">w&#x27; \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu ,k]</span> there exists <span class="math">w \\in \\mathrm{BS - RS}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> such that <span class="math">\\psi_{\\mathrm{row},\\beta}(w) = w&#x27;</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> The proofs for the two statements are similar, so we only give the proof for the first statement. Let <span class="math">w&#x27; \\in \\mathrm{BS - RS}[\\mathbb{K}, \\mathbb{F}, Z_{L_0}(L_1), \\mu, k]</span>, and define $w_{\\mathrm{rs}} := w'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\mathrm{rs}\\} \\times Z_{L_0}(L_1)}<span class="math">; observe that </span>w_{\\mathrm{rs}}<span class="math"> in </span>\\mathrm{RS}[\\mathbb{F}, Z_{L_0}(L_1),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]<span class="math">. By Claim F.4, </span>w'<span class="math"> is uniquely determined by </span>w_{\\mathrm{rs}}<span class="math">, thus it suffices to show that there exists </span>w_{\\square} \\in \\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]<span class="math"> such that </span>f_{w_{\\square}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\alpha\\} \\times Z_{L_0}(L_1)} = w_{\\mathrm{rs}}<span class="math">. By definition of </span>\\mathrm{RS}_{\\square}<span class="math">, it suffices to show that there exists a bivariate polynomial </span>g \\in \\mathbb{F}[X, Y]<span class="math"> such that: (i) </span>\\deg_X(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, (ii) </span>\\deg_Y(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho<span class="math">, (iii) </span>g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\alpha\\} \\times Z_{L_0}(L_1)} = w_{\\mathrm{rs}} \\in \\mathrm{RS}[\\mathbb{F}, Z_{L_0}(L_1),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho]<span class="math">. The existence of such </span>g$ follows by considering a suitable interpolating set (see, e.g., Appendix H).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">G Proof of Lemma 4.27</p>

    <p class="text-gray-300">In this section we prove Lemma 4.27. In Appendix G.1 we define the recursive cover and prove its combinatorial properties; in Appendix G.2 we prove that a spanning set for the duals of codes in this cover can be computed efficiently; in Appendix G.3, we put these together to conclude the proof.</p>

    <h3 id="sec-124" class="text-xl font-semibold mt-8">G.1 The recursive cover and its combinatorial properties</h3>

    <p class="text-gray-300">We define a recursive cover for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> and then prove certain combinatorial properties for it. The definition relies on the definition of another cover, which we now introduce.</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Definition G.1.</h6>

    <p class="text-gray-300">The native cover <span class="math">S[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\dim(L)\\leq k</span> then the cover contains only the trivial view <span class="math">(D^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k],\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k])</span>;</li>

      <li>if <span class="math">\\dim(L)&gt;k</span> then the cover contains</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the view <span class="math">(\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k],D_{\\mathrm{col},\\alpha})</span> for every <span class="math">\\alpha\\in L^{\\prime}_{0}</span>, and</li>

      <li>the view <span class="math">(\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k],D_{\\mathrm{row},\\beta})</span> for every <span class="math">\\beta\\in L_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">We now prove that the native cover is indeed a cover.</p>

    <h6 id="sec-126" class="text-base font-medium mt-4">Claim G.2.</h6>

    <p class="text-gray-300">The native cover of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is a code cover (see Definition 4.13).</p>

    <h6 id="sec-127" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From Claim F.5 we know that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for every <span class="math">\\alpha\\in L^{\\prime}_{0}</span>, the restriction of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> to <span class="math">D_{\\mathrm{col},\\alpha}</span> equals <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]</span>;</li>

      <li>for every <span class="math">\\beta\\in L_{1}</span>, the restriction of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> to <span class="math">D_{\\mathrm{row},\\beta}</span> equals <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]</span>.</li>

    </ul>

    <p class="text-gray-300">Therefore, it suffices to show that <span class="math">D_{\\square}\\subseteq(\\cup_{\\alpha\\in L^{\\prime}_{0}}D_{\\mathrm{col},\\alpha})\\cup(\\cup_{\\beta\\in L_{1}}D_{\\mathrm{row},\\beta})</span>. So let <span class="math">x</span> be an index in <span class="math">D_{\\square}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If there exists <span class="math">\\alpha\\in L^{\\prime}_{0}</span> such that <span class="math">x\\in\\{\\mathrm{px}\\}\\times\\{(\\mathrm{col},\\alpha)\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]</span>, then <span class="math">x\\in D_{\\mathrm{col},\\alpha}</span>.</li>

      <li>If there exists <span class="math">\\beta\\in L_{1}</span> such that <span class="math">x\\in\\{\\mathrm{px}\\}\\times\\{(\\mathrm{row},\\beta)\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]</span>, then <span class="math">x\\in D_{\\mathrm{row},\\beta}</span>.</li>

      <li>If <span class="math">x\\in\\{\\mathrm{px}\\}\\times D_{\\mathrm{pf}}[\\mathbb{K},\\mathbb{F},L,\\mu]</span>, then there exist <span class="math">\\beta\\in L_{1}</span> and <span class="math">\\alpha\\in R_{\\beta}</span> such that <span class="math">x=(\\mathrm{px},(\\alpha,Z_{L_{0}}(\\beta)))</span>, so <span class="math">x\\in D_{\\mathrm{row},\\beta}</span>.</li>

      <li>If <span class="math">x\\in\\{\\mathrm{rs}\\}\\times L</span>, then there exist <span class="math">\\beta\\in L_{1}</span> and <span class="math">\\alpha\\in L_{\\beta}</span> such that <span class="math">\\phi<a href="\\alpha,Z_{L_{0}}(\\beta">\\mathbb{K},\\mathbb{F},L,\\mu</a>)=x</span>, so <span class="math">x\\in D_{\\mathrm{row},\\beta}</span>. ∎</li>

    </ul>

    <p class="text-gray-300">The recursive cover of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span> is recursively defined based on the native cover of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}</span>.</p>

    <h6 id="sec-128" class="text-base font-medium mt-4">Definition G.3.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The recursive cover <span class="math">T[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is the tree of depth <span class="math">\\lfloor\\log\\dim(L)-\\log(k)\\rfloor</span> where, for every non-leaf vertex <span class="math">v</span> labeled by <span class="math">(\\tilde{D},\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},\\tilde{L},\\mu,k])</span>, the vertex <span class="math">v</span> has $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S[\\mathbb{K},\\mathbb{F},\\tilde{L},\\mu,k]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> successors, all labeled by elements of </span>S[\\mathbb{K},\\mathbb{F},\\tilde{L},\\mu,k]<span class="math"> with the natural embedding of their domains into </span>\\tilde{D}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-129" class="text-base font-medium mt-4">Claim G.4.</h6>

    <p class="text-gray-300">The recursive cover of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is <span class="math">1</span>-intersecting (see Definition 4.18).</p>

    <h6 id="sec-130" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We must show that for every two disconnected vertices <span class="math">u,v</span> it holds that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{u}\\cap\\tilde{D}_{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math">. It suffices to do so for every two distinct siblings </span>u,v<span class="math">, because if </span>a<span class="math"> is an ancestor of </span>b<span class="math"> then </span>\\tilde{D}_{a}<span class="math"> contains </span>\\tilde{D}_{b}<span class="math">. Hence, we only need to show that for every two distinct views </span>(\\tilde{D},\\tilde{C}),(\\tilde{D}^{\\prime},\\tilde{C}^{\\prime})<span class="math"> in the native cover </span>S[\\mathbb{K},\\mathbb{F},L,\\mu,k]<span class="math">, it holds that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}\\cap\\tilde{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 1<span class="math">. First we observe that for every </span>\\alpha_{1}\\neq\\alpha_{2}\\in L^{\\prime}_{0}<span class="math"> and </span>\\beta_{1}\\neq\\beta_{2}\\in L_{1}$, the following sets are disjoint by definition:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{\\mathrm{px}\\}\\times\\{(\\mathrm{col},\\alpha_{1})\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]</span>,</li>

      <li><span class="math">\\{\\mathrm{px}\\}\\times\\{(\\mathrm{col},\\alpha_{2})\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]</span>,</li>

      <li><span class="math">\\{\\mathrm{px}\\}\\times\\{(\\mathrm{row},\\beta_{1})\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta_{1}},\\mu,k]</span>,</li>

      <li><span class="math">\\{\\mathrm{px}\\}\\times\\{(\\mathrm{row},\\beta_{2})\\}\\times D_{\\mathrm{pf}}^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L_{\\beta_{2}},\\mu,k]</span>.</li>

    </ul>

    <p class="text-gray-300">Thus it is enough to show that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any two columns are distinct: <span class="math">\\phi(\\alpha_{1},\\beta_{1})\\neq\\phi(\\alpha_{2},\\beta_{2})</span> for every <span class="math">\\alpha_{1}\\neq\\alpha_{2}\\in L^{\\prime}_{0}</span> and <span class="math">\\beta_{1},\\beta_{2}\\in Z_{L_{0}}(L_{1})</span>.</li>

      <li>Any two rows are distinct: <span class="math">\\phi(\\alpha_{1},\\beta_{1})\\neq\\phi(\\alpha_{2},\\beta_{2})</span> for every <span class="math">\\beta_{1}\\neq\\beta_{2}\\in Z_{L_{0}}(L_{1})</span>, <span class="math">\\alpha_{1}\\in L_{\\beta_{1}}</span>, and <span class="math">\\alpha_{2}\\in L_{\\beta_{2}}</span>.</li>

      <li>The intersection of any row and column has at most one element: <span class="math">\\phi(\\alpha,\\beta^{\\prime})\\neq\\phi(\\alpha^{\\prime},\\beta)</span> for every <span class="math">\\alpha,\\alpha^{\\prime}\\in L^{\\prime}_{0}</span> and <span class="math">\\beta,\\beta^{\\prime}\\in Z_{L_{0}}(L_{1})</span> with <span class="math">(\\alpha^{\\prime},\\beta^{\\prime})\\neq(\\alpha,\\beta)</span>.</li>

    </ul>

    <p class="text-gray-300">But all the above follow from the fact that <span class="math">\\phi[\\mathbb{K},\\mathbb{F},L,\\mu]</span> is a bijection and, thus, an injection. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The next claim establishes a connection between the depth of a vertex <span class="math">v</span> in the recursive cover and the independence of the cover <span class="math">T_v</span> of the code <span class="math">\\tilde{C}_v</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim G.5.</strong> For every vertex <span class="math">v</span> in <span class="math">\\mathrm{layer}(T, d)</span>, the cover <span class="math">T_v</span> is $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\dim(L) \\cdot 2^{-d-1} - \\mu - 2})<span class="math">-independent. In particular, by assignment, it holds that, for every positive integer </span>m<span class="math"> and every non-leaf vertex </span>v<span class="math"> in </span>T[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]<span class="math"> with depth less than </span>\\log_2 \\dim(L) - \\log_2(\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} m + \\mu + 2) - 1<span class="math">, the cover </span>T_v<span class="math"> is </span>m$-independent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of the above claim directly follows from Claim G.7 and Claim G.6, stated and proved below. The first of these two claims connects the depth of a vertex <span class="math">v</span> and the dimension of a space <span class="math">L_v</span> such that <span class="math">\\tilde{C}_v = \\mathrm{BS-RS}[\\mathbb{F}, \\mathbb{K}, L_v, \\mu, k]</span> (this claim is used separately also for establishing computational properties in Appendix G.2).</p>

    <p class="text-gray-300"><strong>Claim G.6.</strong> If <span class="math">v \\in \\mathrm{layer}(T[\\mathbb{K},\\mathbb{F},L,\\mu,k],d)</span> then <span class="math">\\tilde{C}_v = \\mathrm{BS-RS}[\\mathbb{K},\\mathbb{F},\\tilde{L},\\mu,k]</span> for some <span class="math">\\tilde{L}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\dim (L) \\cdot 2 ^ {- d} \\leq \\dim (\\tilde {L}) \\leq \\dim (L) \\cdot 2 ^ {- d} + 2 \\mu .</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is by induction on <span class="math">d</span>. The base case <span class="math">d = 0</span> follows directly from the definition; so we now assume the claim for <span class="math">d - 1</span> and prove it for <span class="math">d</span>. Let <span class="math">v \\in \\mathrm{layer}(T, d)</span> be a vertex of depth <span class="math">d</span>, and let <span class="math">u \\in \\mathrm{layer}(T, d - 1)</span> be <span class="math">v</span>'s predecessor. By the inductive assumption, <span class="math">\\tilde{C}_u = \\mathrm{BS-RS}[\\mathbb{K}, \\mathbb{F}, L_u, \\mu, k]</span> for some <span class="math">L_u</span> such that <span class="math">\\dim(L) \\cdot 2^{-(d-1)} \\leq \\dim(L_u) \\leq \\dim(L) \\cdot 2^{-(d-1)} + 2\\mu</span>.</p>

    <p class="text-gray-300">First we argue that <span class="math">T_{u}</span> is not the trivial (singleton) cover. For this, it suffices to show that <span class="math">\\dim(L_u) &amp;gt; k</span>. But this follows from the inductive assumption, since <span class="math">\\mathrm{depth}(T,u) &amp;lt; \\lfloor \\log \\dim(L) - \\log(k) \\rfloor</span>, so that <span class="math">\\dim(L_u) \\geq \\dim(L) \\cdot 2^{-(\\lfloor \\log \\dim(L) - \\log(k) \\rfloor - 1)} \\geq 2k</span>.</p>

    <p class="text-gray-300">Recall <span class="math">\\tilde{C}_v = \\mathrm{BS-RS}[\\mathbb{K},\\mathbb{F},L_v,\\mu ,k]</span> for some space <span class="math">L_{v}</span>; we are thus left to show that <span class="math">\\dim (L_u)\\cdot 2^{-1}\\leq \\dim (L_v)\\leq \\dim (L_u)\\cdot 2^{-1} + \\mu</span>. We do so by giving two cases, based on the form of <span class="math">L_{v}</span>: (a) if <span class="math">L_{v} = Z_{L_{0}[\\mathbb{K},\\mathbb{F},L_{u},\\mu ,k]}(L_{1}[\\mathbb{K},\\mathbb{F},L_{u},\\mu ,k])</span> then <span class="math">\\dim (L_v) = \\dim (L_1[\\mathbb{K},\\mathbb{F},L_u,\\mu ,k]) = \\lfloor \\frac{\\dim(L_u)}{2}\\rfloor</span>; (b) if there exists <span class="math">\\beta \\in L_1[\\mathbb{K},\\mathbb{F},L_u,\\mu ,k]</span> such that <span class="math">L_{v} = L_{\\beta}[\\mathbb{K},\\mathbb{F},L_{u},\\mu ,k]</span> then <span class="math">\\dim (L_v) = \\dim (L_0[\\mathbb{K},\\mathbb{F},L_u,\\mu ,k]) + \\mu = \\lfloor \\frac{\\dim(L_u)}{2}\\rfloor +\\mu</span>. In either case <span class="math">\\dim (L_u)\\cdot 2^{-1}\\leq \\dim (L_v)\\leq \\dim (L_u)\\cdot 2^{-1} + \\mu</span>, and the claim follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim G.7.</strong> The native cover <span class="math">S[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span> is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\frac{\\dim(L)}{2} -\\mu -2}$ independent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Recalling Definition 4.16, fix arbitrary subsets <span class="math">D&#x27; \\subseteq (\\{\\mathrm{col}\\} \\times L_0&#x27;) \\sqcup (\\{\\mathrm{row}\\} \\times L_1)</span> and <span class="math">D&#x27;&#x27; \\subseteq D_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]</span> both of size at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\frac{\\dim(L)}{2} - \\mu - 2}<span class="math">, and define </span>\\tilde{D} := D'' \\cup (\\cup_{(\\mathrm{col}, \\alpha) \\in D'} D_{\\mathrm{col}, \\alpha}) \\cup (\\cup_{(\\mathrm{row}, \\beta) \\in D'} D_{\\mathrm{row}, \\beta})<span class="math">. Let </span>w' \\in \\mathbb{F}^{D^{\\mathrm{BS-RS}}}<span class="math"> be such that: (i) for every </span>(\\mathrm{col}, \\alpha) \\in D'<span class="math"> it holds that </span>\\psi_{\\mathrm{col}, \\alpha}(w') \\in \\mathrm{BS-RS}[\\mathbb{K}, \\mathbb{F}, Z_{L_0}(L_1), \\mu, k]<span class="math">; and (ii) for every </span>(\\mathrm{row}, \\beta) \\in D'<span class="math"> it holds that </span>\\psi_{\\mathrm{row}, \\beta}(w') \\in \\mathrm{BS-RS}[\\mathbb{K}, \\mathbb{F}, L_\\beta, \\mu, k]<span class="math">. We need to show that there exists </span>w \\in \\mathrm{BS-RS}[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]<span class="math"> such that </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}} = w'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In fact, it suffices to show that there exists <span class="math">w_{\\square} \\in \\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]</span> such that $w_{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D} \\cap D_{\\square}} = w'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D} \\cap D_{\\square}}<span class="math">, because Claim F.4 implies there exists a unique codeword </span>w \\in \\mathrm{BS-RS}[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]<span class="math"> such that </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{D_{\\square}} = w_{\\square}<span class="math"> and </span>w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}} = w'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, we now argue that there exists <span class="math">w_{\\square} \\in \\mathrm{RS}_{\\square}[\\mathbb{K}, \\mathbb{F}, L, \\mu]</span> such that the following holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For every <span class="math">(\\mathrm{col},\\alpha)\\in D^{\\prime}</span> and <span class="math">\\beta \\in Z_{L_0}(L_1)</span>, it holds that <span class="math">f_{w_{\\square}}(\\alpha ,\\beta) = w^{\\prime}(\\phi (\\alpha ,\\beta)) = (\\psi_{\\mathrm{col},\\alpha}(w^{\\prime}))(\\mathrm{rs},\\beta)</span>. In particular, $f_{w_{\\square}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{\\alpha \\} \\times Z_{L_0}(L_1)}\\in \\mathrm{RS}[\\mathbb{F},Z_{L_0}(L_1),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho ]<span class="math">, and let </span>p_{\\mathrm{col},\\alpha}<span class="math"> be its univariate low degree extension to </span>\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">(\\alpha, \\beta) \\in D&#x27;&#x27;</span>, it holds that <span class="math">f_{w_{\\square}}(\\alpha, Z_{L_0}(\\beta)) = w&#x27;(\\phi(\\alpha, Z_{L_0}(\\beta)))</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Definition F.2 it suffices to show that there exists a bivariate polynomial <span class="math">g \\in \\mathbb{F}[X, Y]</span> such that: (i) $\\deg_X(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; (ii) </span>\\deg_Y(g) &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho<span class="math">; (iii) </span>g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{X = \\alpha} = p_{\\mathrm{col},\\alpha}<span class="math"> for every </span>(\\mathrm{col}, \\alpha) \\in D'<span class="math">; (iv) </span>g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{Y = Z_{L_0}(\\beta)} = p_{\\mathrm{row},\\beta}<span class="math"> for every </span>(\\mathrm{row}, \\beta) \\in D'<span class="math">; (v) </span>g(\\alpha, \\beta) = w'(\\phi(\\alpha, Z_{L_0}(\\beta)))<span class="math"> for every </span>(\\alpha, \\beta) \\in D''<span class="math">. But notice that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D''</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\frac{\\dim(L)}{2} - \\mu - 2} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\frac{\\dim(L)}{2} - \\mu - 1} &lt; \\min\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho\\}<span class="math">, because (a) </span>\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\dim(L_0) \\geq \\frac{\\dim(L)}{2} - 1<span class="math">, and (b) </span>\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\rho) = \\dim(L_1) - \\mu \\geq \\frac{\\dim(L)}{2} - \\mu$. The claim follows by considering a suitable interpolating set (see Section H).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">G.2 Computing spanning sets of dual codes in the recursive cover</p>

    <p class="text-gray-300">We prove that spanning sets for duals of codes in the recursive cover can be computed efficiently; this is the key fact that we later use to argue that the algorithm required by Lemma 4.27 satisfies the stated time complexity.</p>

    <h6 id="sec-131" class="text-base font-medium mt-4">Claim G.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every positive integer <span class="math">m</span> and vertex <span class="math">v</span> in <span class="math">T[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> of depth at least $\\log_{2}\\dim(L)-\\log_{2}\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}m<span class="math">, a spanning set of </span>\\tilde{C}_{v}^{\\perp}<span class="math"> can be computed in time </span>\\mathrm{poly}(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu}+m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above claim directly follows from Claim G.9 and Claim G.10, stated and proved below.</p>

    <h6 id="sec-132" class="text-base font-medium mt-4">Claim G.9.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every positive integer <span class="math">m</span> and vertex <span class="math">v</span> in <span class="math">T[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> of depth at least $\\log_{2}\\dim(L)-\\log_{2}\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}m<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{D}_{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathrm{poly}(m+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-133" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ben-Sasson and Sudan <em>[x1]</em> show that the block length of <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> is $\\tilde{O}_{\\mathbb{K},\\mu,k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for any fixed </span>\\mathbb{K},\\mu,k<span class="math">. One can verify that, if we do not fix these parameters, the block length is </span>\\tilde{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})<span class="math">. Next, observe that </span>\\tilde{C}_{v}=\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{v},\\mu,k]<span class="math"> for some </span>L_{v}<span class="math"> such that </span>\\dim(L_{v})\\leq\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}m+2\\mu<span class="math"> (Claim G.6); in this case, the aforementioned bound becomes </span>\\mathrm{poly}(m+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-134" class="text-base font-medium mt-4">Claim G.10.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A spanning set for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]^{\\perp}</span> can be found in time $\\mathrm{poly}\\left(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D^{\\mathrm{BS}\\text{-}\\mathrm{RS}}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-135" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show an algorithm that constructs the desired spanning set in the stated time complexity. First, a spanning set for <span class="math">\\mathrm{RS}[\\mathbb{F},S,d]^{\\perp}</span> can be found in time $\\mathrm{poly}(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, for any finite field </span>\\mathbb{F}<span class="math">, subset </span>S\\subseteq\\mathbb{F}<span class="math">, and degree bound </span>d<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence, a spanning set for </span>\\mathrm{RS}_{\\square}[\\mathbb{K},\\mathbb{F},L,\\mu]^{\\perp}<span class="math"> can be found in time </span>(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})^{c}<span class="math"> for some </span>c>0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We argue by induction on <span class="math">\\dim(L)</span> that a spanning set for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]^{\\perp}</span> can be found in time $(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})^{c}<span class="math">. We rely the property that the code </span>\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]$ is covered by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\{(\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k],D_{\\mathrm{col},\\alpha})\\}_{\\alpha\\in L_{0}^{\\prime}}\\cup\\{(\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k],D_{\\mathrm{row},\\beta})\\}_{\\beta\\in L_{1}}</span></p>

    <p class="text-gray-300">and the property that <span class="math">w\\in\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]</span> if an only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\psi_{\\mathrm{col},\\alpha}(w)\\in\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},Z_{L_{0}}(L_{1}),\\mu,k]</span> for every <span class="math">\\alpha\\in L_{0}^{\\prime}</span> and</li>

      <li><span class="math">\\psi_{\\mathrm{row},\\beta}(w)\\in\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L_{\\beta},\\mu,k]</span> for every <span class="math">\\beta\\in L_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Thus <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]^{\\perp}</span> is spanned by the duals of codes in its cover and, in particular, is spanned by their spanning sets; in sum, it suffices to construct a spanning set for its cover.</p>

    <p class="text-gray-300">In light of the above, we can bound the construction time of a spanning set for <span class="math">\\mathrm{BS}\\text{-}\\mathrm{RS}[\\mathbb{K},\\mathbb{F},L,\\mu,k]^{\\perp}</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\dim(L)\\leq k</span>, the claim follows as the code in this case simply equals <span class="math">\\mathrm{RS}_{\\square}[\\mathbb{K},\\mathbb{F},L,\\mu]</span>.</li>

      <li>If <span class="math">\\dim(L)&gt;k</span>, the time to construct a spanning set is at most the time to construct spanning sets for the cover:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu})^{c}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu+1})^{c}$ (1)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot(\\log_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu})^{c}\\cdot\\left(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu-1}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{1}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{c-1}+</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{c\\mu}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{0}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{c-1}\\right)$ (3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot(\\log_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu})^{c}\\cdot\\left(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu+c-2}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\frac{c-1}{2}}+</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{c\\mu}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\frac{c-1}{2}}\\right)$ (4)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$=</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\frac{c+1}{2}}\\cdot(\\log_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu})^{c}\\cdot\\left(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu+c-2}+</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{c\\mu}\\right)$ (5)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\leq(\\log_{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{F}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">L</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{K}</td>

            <td class="px-3 py-2 border-b border-gray-700">^{\\mu})^{c}\\enspace.$ (6)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above, (1) is by the inductive assumption, (2) is by definition of <span class="math">L_{0}^{\\prime}</span>, (3) is by the fact that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and (4) is by definition of </span>L_{0},L_{1}<span class="math">. We are left to show (6), and this follows from the fact that: (i) </span>\\dim(L)>k<span class="math">, (ii) </span>k>2\\mu<span class="math"> by definition, and (iii) we can choose </span>c<span class="math"> to be large enough (namely, so that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mu+c-2}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{c\\mu}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\frac{c-1}{2}}$ holds). ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">G.3 Putting things together</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Lemma 4.27. Define the depth function $d(\\mathbb{K}, L, \\mu, a) := \\log_2 \\dim(L) - \\log_2(\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} a + \\mu + 2) - 1<span class="math">. We argue the two conditions in the lemma. First, for every index </span>\\mathfrak{n} = (\\mathbb{K}, \\mathbb{F}, L, \\mu, k)<span class="math">, </span>T[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]<span class="math"> is a 1-intersecting recursive cover of BS-RS</span>[\\mathbb{K}, \\mathbb{F}, L, \\mu, k]<span class="math"> (by Claim G.4). Moreover, for every positive integer </span>m<span class="math"> and non-leaf vertex </span>v<span class="math"> in </span>T<span class="math"> with </span>\\mathrm{depth}(T, v) &lt; d(\\mathbb{K}, L, \\mu, m)<span class="math">, the cover </span>T_v<span class="math"> is </span>m$-independent (by Claim G.5).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, consider the algorithm that, given an index <span class="math">\\mathfrak{n} = (\\mathbb{K},\\mathbb{F},L,\\mu ,k)</span> and subset <span class="math">I\\subseteq D^{\\mathrm{BS - RS}}[\\mathbb{K},\\mathbb{F},L,\\mu ,k]</span>, works as follows: (1) for every <span class="math">\\alpha \\in I</span> choose an arbitrary vertex <span class="math">v_{\\alpha}</span> in layer $(T,d(\\mathbb{K},L,\\mu ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math"> such that </span>\\alpha \\in \\tilde{D}_{v_{\\alpha}}<span class="math">, and then set </span>U\\coloneqq \\{v_{\\alpha}\\}_{\\alpha \\in I}<span class="math">; (2) compute a spanning set </span>W_{v}<span class="math"> set for </span>\\tilde{C}_v^\\perp<span class="math">; (3) return </span>W\\coloneqq \\cup_{u\\in U}W_u<span class="math">. This algorithm satisfies the required properties. First, it runs in time </span>\\mathrm{poly}(\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\dim (L) +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^\\mu +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> because a spanning set set for </span>\\tilde{C}_u^\\perp<span class="math"> can be computed in time </span>\\mathrm{poly}(\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^\\mu +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (by Claim G.8). Next, its output </span>W$ meets the requirements:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $U \\subseteq \\operatorname{layer}(T[\\mathbb{K}, \\mathbb{F}, L, \\mu, k], d(\\mathbb{K}, L, \\mu,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">I \\subseteq (\\cup_{u \\in U} \\tilde{D}_u)</span>, by definition of <span class="math">U</span>;</li>

      <li><span class="math">\\operatorname{span}(W) = \\operatorname{span}(\\cup_{u \\in U} W_u) = \\operatorname{span}(\\cup_{u \\in U} \\tilde{C}_u^\\perp)</span>, by definition of <span class="math">W</span> and <span class="math">W_u</span>.</li>

    </ul>

    <p class="text-gray-300">This completes the proof of Lemma 4.27.</p>

    <p class="text-gray-300">55</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim H.1. Let  <span class="math">\\mathbb{F}</span>  be a field, let  <span class="math">d_{\\mathrm{cols}}, d_{\\mathrm{rows}} \\in \\mathbb{N}</span> , and consider three sets  <span class="math">S_{\\mathrm{cols}}, S_{\\mathrm{rows}} \\subseteq \\mathbb{F}</span>  and  <span class="math">S_{\\mathrm{pnts}} \\subseteq \\mathbb{F} \\times \\mathbb{F}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\mathrm{cols}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\mathrm{rows}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{\\mathrm{pnts}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\min \\{d_{\\mathrm{cols}}, d_{\\mathrm{rows}}\\}<span class="math"> . Let  </span>f: \\mathbb{F} \\times \\mathbb{F} \\to \\mathbb{F}$  be a function such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for every  <span class="math">\\alpha \\in S_{\\mathrm{cols}}</span>  there exists  <span class="math">g_{\\mathrm{col},\\alpha} \\in \\mathbb{F}^{&lt;d_{\\mathrm{rows}}} </span>g_{\\mathrm{col},\\alpha}="" <span class="math">f(\\alpha,=&quot;&quot; </span>f(\\alpha,="" <span class="math">g_{\\mathrm{col},\\alpha}(\\beta)</span>="" <span class="math">g_{\\mathrm{row},\\beta}=&quot;&quot; </span>f(\\alpha,="" <span class="math">f(\\alpha,=&quot;&quot; ,=&quot;&quot; .=&quot;&quot; \\beta)=&quot;&quot; \\in=&quot;&quot; \\mathbb{f}</span>="" \\mathbb{f}<span class="math">=&quot;&quot; \\mathbb{f}</span>="" for="" every="" for="" there="" such="" that="" that:="" there="" {<="" }="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{pnts}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{pnts}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rows}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rows}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{row}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rows}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{rms}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{r}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">="S_{\\mathrm{rows}}\\cup\\{\\beta:\\exists" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}(\\alpha,="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$="" }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\mathrm{s.t.}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">Work of E. Ben-Sasson, A. Gabizon, and M. Riabzev was supported by the Israel Science Foundation (grant 1501/14). Work of A. Chiesa and N. Spooner was partially supported in part by the UC Berkeley Center for Long-Term Cybersecurity. Work of M. A. Forbes was supported by the NSF, including NSF CCF-1617580, and the DARPA Safeware program; it was also partially completed when the author was at Princeton University, supported by the Princeton Center for Theoretical Computer Science.</p>

    <h2 id="sec-137" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AH91] William Aiello and Johan Håstad. Statistical zero-knowledge languages can be recognized in two rounds. Journal of Computer and System Sciences, 42(3):327–345, 1991. Preliminary version appeared in FOCS ’87.</li>

      <li>[ALM^{+}98] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. Proof verification and the hardness of approximation problems. Journal of the ACM, 45(3):501–555, 1998. Preliminary version in FOCS ’92.</li>

      <li>[AR16] Benny Applebaum and Pavel Raykov. On the relationship between statistical zero-knowledge and statistical randomized encodings. In Proceedings of the 36th Annual International Cryptology Conference, CRYPTO ’16, pages 449–477, 2016.</li>

      <li>[AS98] Sanjeev Arora and Shmuel Safra. Probabilistic checking of proofs: a new characterization of NP. Journal of the ACM, 45(1):70–122, 1998. Preliminary version in FOCS ’92.</li>

      <li>[AS03] Sanjeev Arora and Madhu Sudan. Improved low-degree testing and its applications. Combinatorica, 23(3):365–426, 2003. Preliminary version appeared in STOC ’97.</li>

      <li>[Bab85] László Babai. Trading group theory for randomness. In Proceedings of the 17th Annual ACM Symposium on Theory of Computing, STOC ’85, pages 421–429, 1985.</li>

      <li>[BCG^{+}17] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. Interactive oracle proofs with constant rate and query complexity. In Proceedings of the 44th International Colloquium on Automata, Languages and Programming, ICALP ’17, pages 40:1–40:15, 2017.</li>

      <li>[BCGV16] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, and Madars Virza. Quasilinear-size zero knowledge from linear-algebraic PCPs. In Proceedings of the 13th Theory of Cryptography Conference, TCC ’16-A, pages 33–64, 2016.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Proceedings of the 14th Theory of Cryptography Conference, TCC ’16-B, pages 31–60, 2016.</li>

      <li>[BFL91] László Babai, Lance Fortnow, and Carsten Lund. Non-deterministic exponential time has two-prover interactive protocols. Computational Complexity, 1:3–40, 1991. Preliminary version appeared in FOCS ’90.</li>

      <li>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, STOC ’91, pages 21–32, 1991.</li>

      <li>[BGG^{+}88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan Håstad, Joe Kilian, Silvio Micali, and Phillip Rogaway. Everything provable is provable in zero-knowledge. In Proceedings of the 8th Annual International Cryptology Conference, CRYPTO ’89, pages 37–56, 1988.</li>

      <li>[BGH^{+}06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM Journal on Computing, 36(4):889–974, 2006.</li>

      <li>[BGK^{+}10] Eli Ben-Sasson, Venkatesan Guruswami, Tali Kaufman, Madhu Sudan, and Michael Viderman. Locally testable codes require redundant testers. SIAM Journal on Computing, 39(7):3230–3247, 2010.</li>

      <li>[BGKW88] Michael Ben-Or, Shafi Goldwasser, Joe Kilian, and Avi Wigderson. Multi-prover interactive proofs: how to remove intractability assumptions. In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, STOC ’88, pages 113–131, 1988.</li>

      <li>[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In Proceedings of the 20th Annual ACM Symposium on Theory of Computing, STOC ’88, pages 1–10, 1988.</li>

      <li>[BHR05] Eli Ben-Sasson, Prahladh Harsha, and Sofya Raskhodnikova. Some 3CNF properties are hard to test. SIAM Journal on Computing, 35(1):1–21, 2005.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BHZ87] Ravi B. Boppana, Johan Håstad, and Stathis Zachos. Does co-NP have short interactive proofs? Information Processing Letters, 25(2):127–132, 1987.</p>

    <p class="text-gray-300">[BM88] László Babai and Shlomo Moran. Arthur-merlin games: A randomized proof system, and a hierarchy of complexity classes. Journal of Computer and System Sciences, 36(2):254–276, 1988.</p>

    <p class="text-gray-300">[BS08] Eli Ben-Sasson and Madhu Sudan. Short PCPs with polylog query complexity. SIAM Journal on Computing, 38(2):551–607, 2008. Preliminary version appeared in STOC '05.</p>

    <p class="text-gray-300">[BVW98] Ronald V. Book, Heribert Vollmer, and Klaus W. Wagner. Probabilistic type-2 operators and “almost”-classes. Computational Complexity, 7(3):265–289, 1998.</p>

    <p class="text-gray-300">[BW04] Andrej Bogdanov and Hoeteck Wee. A stateful implementation of a random function supporting parity queries over hypercubes. In Proceedings of the 7th International Workshop on Approximation Algorithms for Combinatorial Optimization Problems, and of the 8th International Workshop on Randomization and Computation, APPROX-RANDOM '04, pages 298–309, 2004.</p>

    <p class="text-gray-300">[CFS17] Alessandro Chiesa, Michael A. Forbes, and Nicholas Spooner. A zero knowledge sumcheck and its applications. Cryptology ePrint Archive, Report 2017/305, 2017.</p>

    <p class="text-gray-300">[DFK⁺92] Cynthia Dwork, Uriel Feige, Joe Kilian, Moni Naor, and Shmuel Safra. Low communication 2-prover zero-knowledge proofs for NP. In Proceedings of the 11th Annual International Cryptology Conference, CRYPTO '92, pages 215–227, 1992.</p>

    <p class="text-gray-300">[DR04] Irit Dinur and Omer Reingold. Assignment testers: Towards a combinatorial proof of the PCP theorem. In Proceedings of the 45th Annual IEEE Symposium on Foundations of Computer Science, FOCS '04, pages 155–164, 2004.</p>

    <p class="text-gray-300">[DS98] Cynthia Dwork and Amit Sahai. Concurrent zero-knowledge: Reducing the need for timing constraints. In Proceedings of the 18th Annual International Cryptology Conference, CRYPTO '98, pages 442–457, 1998.</p>

    <p class="text-gray-300">[FGL⁺96] Uriel Feige, Shafi Goldwasser, Laszlo Lovász, Shmuel Safra, and Mario Szegedy. Interactive proofs and the hardness of approximating cliques. Journal of the ACM, 43(2):268–292, 1996. Preliminary version in FOCS '91.</p>

    <p class="text-gray-300">[For87] Lance Fortnow. The complexity of perfect zero-knowledge (extended abstract). In Proceedings of the 19th Annual ACM Symposium on Theory of Computing, STOC '87, pages 204–209, 1987.</p>

    <p class="text-gray-300">[FRS88] Lance Fortnow, John Rompel, and Michael Sipser. On the power of multi-prover interactive protocols. In Theoretical Computer Science, pages 156–161, 1988.</p>

    <p class="text-gray-300">[FS89] Uriel Feige and Adi Shamir. Zero knowledge proofs of knowledge in two rounds. In Proceedings of the 9th Annual International Cryptology Conference, CRYPTO '89, pages 526–544, 1989.</p>

    <p class="text-gray-300">[GGN10] Oded Goldreich, Shafi Goldwasser, and Asaf Nussboim. On the implementation of huge random objects. SIAM Journal on Computing, 39(7):2761–2822, 2010. Preliminary version appeared in FOCS '03.</p>

    <p class="text-gray-300">[GIMS10] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. Interactive locking, zero-knowledge PCPs, and unconditional cryptography. In Proceedings of the 30th Annual Conference on Advances in Cryptology, CRYPTO'10, pages 173–190, 2010.</p>

    <p class="text-gray-300">[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for Muggles. In Proceedings of the 40th Annual ACM Symposium on Theory of Computing, STOC '08, pages 113–122, 2008.</p>

    <p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM Journal on Computing, 18(1):186–208, 1989. Preliminary version appeared in STOC '85.</p>

    <p class="text-gray-300">[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems. Journal of the ACM, 38(3):691–729, 1991. Preliminary version appeared in FOCS '86.</p>

    <p class="text-gray-300">[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. Journal of Cryptology, 7(1):1–32, December 1994.</p>

    <p class="text-gray-300">[GR15] Tom Gur and Ron D. Rothblum. Non-interactive proofs of proximity. In Proceedings of the 6th Innovations in Theoretical Computer Science Conference, ITCS '15, pages 133–142, 2015.</p>

    <p class="text-gray-300">[GS06] Oded Goldreich and Madhu Sudan. Locally testable codes and PCPs of almost-linear length. Journal of the ACM, 53:558–655, July 2006. Preliminary version in STOC '02.</p>

    <p class="text-gray-300">[GV99] Oded Goldreich and Salil P. Vadhan. Comparing entropies in statistical zero knowledge with applications to the structure of SZK. In Proceedings of the 14th Annual IEEE Conference on Computational Complexity, CCC '99, page 54, 1999.</p>

    <p class="text-gray-300">58</p>

    <p class="text-gray-300">[IMS12] Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. On efficient zero-knowledge PCPs. In Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography, TCC ’12, pages 151–168, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. On zero-knowledge PCPs: Limitations, simplifications, and applications, 2015. Available at http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf.</li>

      <li>[IOS97] Toshiya Itoh, Yuji Ohta, and Hiroki Shizuya. A language-dependent cryptographic primitive. Journal of Cryptology, 10(1):37–50, 1997.</li>

      <li>[IW14] Yuval Ishai and Mor Weiss. Probabilistically checkable proofs of proximity with zero-knowledge. In Proceedings of the 11th Theory of Cryptography Conference, TCC ’14, pages 121–145, 2014.</li>

      <li>[IWY16] Yuval Ishai, Mor Weiss, and Guang Yang. Making the best of a leaky situation: Zero-knowledge PCPs from leakage-resilient circuits. In Proceedings of the 13th Theory of Cryptography Conference, TCC ’16-A, pages 3–32, 2016.</li>

      <li>[IY87] Russell Impagliazzo and Moti Yung. Direct minimum-knowledge computations. In Proceedings of the 7th Annual International Cryptology Conference, CRYPTO ’87, pages 40–51, 1987.</li>

      <li>[Kay10] Neeraj Kayal. Algorithms for arithmetic circuits, 2010. ECCC TR10-073.</li>

      <li>[KI04] Valentine Kabanets and Russell Impagliazzo. Derandomizing polynomial identity tests means proving circuit lower bounds. Computational Complexity, 13(1-2):1–46, 2004.</li>

      <li>[KPT97] Joe Kilian, Erez Petrank, and Gábor Tardos. Probabilistically checkable proofs with zero knowledge. In Proceedings of the 29th Annual ACM Symposium on Theory of Computing, STOC ’97, pages 496–505, 1997.</li>

      <li>[KR08] Yael Kalai and Ran Raz. Interactive PCP. In Proceedings of the 35th International Colloquium on Automata, Languages and Programming, ICALP ’08, pages 536–547, 2008.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. Journal of the ACM, 39(4):859–868, 1992.</li>

      <li>[LS95] Dror Lapidot and Adi Shamir. A one-round, two-prover, zero-knowledge protocol for NP. Combinatorica, 15(2):204–214, 1995.</li>

      <li>[MX13] Mohammad Mahmoody and David Xiao. Languages with efficient zero-knowledge PCPs are in SZK. In Proceedings of the 10th Theory of Cryptography Conference, TCC ’13, pages 297–314, 2013.</li>

      <li>[Nao91] Moni Naor. Bit commitment using pseudorandomness. Journal of Cryptology, 4(2):151–158, 1991. Preliminary version appeared in CRYPTO ’89.</li>

      <li>[Nis93] Noam Nisan. On read-once vs. multiple access to randomness in logspace. Theoretical Computer Science, 107(1):135–144, 1993.</li>

      <li>[Oka00] Tatsuaki Okamoto. On relationships between statistical zero-knowledge proofs. Journal of Computer and System Sciences, 60(1):47–108, 2000.</li>

      <li>[Ost91] Rafail Ostrovsky. One-way functions, hard on average problems, and statistical zero-knowledge proofs. In Proceedings of the 6th Annual Structure in Complexity Theory Conference, CoCo ’91, pages 133–138, 1991.</li>

      <li>[OV08] Shien Jin Ong and Salil P. Vadhan. An equivalence between zero knowledge and commitments. In Proceedings of the 5th Theory of Cryptography Conference, TCC ’08, pages 482–500, 2008.</li>

      <li>[OW93] Rafail Ostrovsky and Avi Wigderson. One-way functions are essential for non-trivial zero-knowledge. In Proceedings of the 2nd Israel Symposium on Theory of Computing Systems, ISTCS ’93, pages 3–17, 1993.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. Constant-round interactive proofs for delegating computation. In Proceedings of the 48th ACM Symposium on the Theory of Computing, STOC ’16, pages 49–62, 2016.</li>

      <li>[RS96] Ronitt Rubinfeld and Madhu Sudan. Robust characterizations of polynomials with applications to program testing. SIAM Journal on Computing, 25(2):252–271, 1996.</li>

      <li>[RS05] Ran Raz and Amir Shpilka. Deterministic polynomial identity testing in non-commutative models. Computational Complexity, 14(1):1–19, 2005. Preliminary version appeared in CCC ’04.</li>

      <li>[Sch80] Jacob T. Schwartz. Fast probabilistic algorithms for verification of polynomial identities. Journal of the ACM, 27(4):701–717, 1980.</li>

      <li>[Sha92] Adi Shamir. IP = PSPACE. Journal of the ACM, 39(4):869–877, 1992.</li>

      <li>[SV03] Amit Sahai and Salil P. Vadhan. A complete problem for statistical zero knowledge. Journal of the ACM, 50(2):196–249, 2003.</li>

    </ul>

    <p class="text-gray-300">[SY10] Amir Shpilka and Amir Yehudayoff. Arithmetic circuits: A survey of recent results and open questions. Foundations and Trends in Theoretical Computer Science, 5(3-4):207–388, 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Vad99] Salil P. Vadhan. A Study of Statistical Zero-Knowledge Proofs. PhD thesis, MIT, August 1999.</li>

      <li>[VV15] Vinod Vaikuntanathan and Prashant Nalini Vasudevan. Secret sharing and statistical zero knowledge. In Proceedings of the 21st International Conference on the Theory and Application of Cryptology and Information Security, ASIACRYPT ’15, pages 656–680, 2015.</li>

      <li>[Zip79] Richard Zippel. Probabilistic algorithms for sparse polynomials. In Proceedings of the 1979 International Symposium on Symbolic and Algebraic Computation, EUROSAM ’79, pages 216–226, 1979.</li>

    </ul>`;
---

<BaseLayout title="Zero Knowledge Protocols from Succinct Constraint Detection (2016/988)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/988
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
