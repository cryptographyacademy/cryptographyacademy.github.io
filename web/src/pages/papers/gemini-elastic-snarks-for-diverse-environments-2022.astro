---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/420';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Gemini: Elastic SNARKs for Diverse Environments';
const AUTHORS_HTML = 'Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, Michele Orrù';

const CONTENT = `    <p class="text-gray-300">Gemini: Elastic SNARKs for Diverse Environments</p>

    <p class="text-gray-300">Jonathan Bootle jbt@zurich.ibm.com IBM Research Alessandro Chiesa alessandro.chiesa@epfl.ch EPFL Yuncong Hu yuncong_hu@berkeley.edu UC Berkeley Michele Orrù michele.orru@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We introduce and study elastic SNARKs, a class of succinct arguments where the prover has multiple configurations with different time and memory tradeoffs, which can be selected depending on the execution environment and the proved statement. The output proof is independent of the chosen configuration.</p>

    <p class="text-gray-300">We construct an elastic SNARK for rank-1 constraint satisfiability (R1CS). In a time-efficient configuration, the prover uses a linear number of cryptographic operations and a linear amount of memory. In a space-efficient configuration, the prover uses a quasilinear number of cryptographic operations and a logarithmic amount of memory. A key component of our construction is an elastic probabilistic proof. Along the way, we also formulate a streaming framework for R1CS that we deem of independent interest.</p>

    <p class="text-gray-300">We additionally contribute Gemini, a Rust implementation of our protocol. Our benchmarks show that Gemini, on a single machine, supports R1CS instances with tens of billions of constraints.</p>

    <p class="text-gray-300">Keywords: interactive oracle proofs; SNARKs; streaming algorithms</p>

    <p class="text-gray-300">1</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Our results  3</p>

    <p class="text-gray-300">2  Techniques  5 2.1  Elasticity and a streaming model  5 2.2  A modular construction of elastic SNARKs  6 2.3  An elastic realization of the KZG polynomial commitment scheme  7 2.4  An elastic scalar-product protocol  8 2.5  Warm-up: an elastic non-holographic PIOP for R1CS  12 2.6  Elastic holographic PIOP for R1CS  15 2.7  Implementation and optimizations  19 2.8  Evaluation  20</p>

    <p class="text-gray-300">3  Preliminaries  23 3.1  Notation  23 3.2  Polynomial IOPs  23</p>

    <p class="text-gray-300">4  Streaming model  25 4.1  Streaming algorithms  25 4.2  Streaming R1CS  26</p>

    <p class="text-gray-300">5  Tensor-product protocol  27 5.1  Basic tensor-product protocol  27 5.2  Batched tensor-product protocol  29</p>

    <p class="text-gray-300">6  Elastic protocols for scalar products  31 6.1  Elastic scalar-product protocol (special case)  31 6.2  Proof of Theorem 6.2  32 6.3  Space efficient realization of Construction 3  33 6.4  Elastic scalar-product protocol (general case)  35 6.5  Hadamard-product protocol  36</p>

    <p class="text-gray-300">7  A non-holographic protocol for R1CS  37 7.1  Proof of Theorem 7.1  38</p>

    <p class="text-gray-300">8  Achieving holography  40 8.1  Proof of Theorem 8.1  40 8.2  Lookup protocol  41 8.3  Entry product  46</p>

    <p class="text-gray-300">9  Polynomial commitment schemes  48 9.1  Definition  48 9.2  An elastic polynomial commitment scheme  49</p>

    <p class="text-gray-300">10 Elastic argument systems  51 10.1  Preprocessing arguments with universal SRS  52 10.2  Elastic PIOP to argument compiler  52 10.3  Proof of Theorem 10.1  53</p>

    <p class="text-gray-300">Acknowledgements  54</p>

    <p class="text-gray-300">References  54</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Succinct non-interactive arguments of knowledge (SNARKs) allow for efficient verification of NP statements. Recent years have seen a surge of interest in SNARKs, catalyzed by several real-world applications. While reducing argument size and verification time were an initial focus, the cost of running the prover algorithm has now emerged as a critical bottleneck. This is particularly important as the size of proved computations increases, and recent applications demand proving large computations.</p>

    <p class="text-gray-300">For example, popular scaling solutions for blockchains (roll-up architectures) require regularly producing SNARKs attesting to the validity of large batches of transactions, which translates to proving the correctness of billions of gates. As another example, the Filecoin network generates proofs for about 930 billion constraints every day. In both cases, efficiently producing SNARKs attesting to the correctness of large computations is critical, yet many SNARK implementations today do not scale to large computations because of the prohibitive memory requirements of the proving algorithm. Indeed, research that focuses on the time complexity of the prover algorithm has achieved notable theoretical and practical improvements <em>[BCGGHJ17, BCGJM18, XZZPS19, Set20, BCG20, Lee20, KMP20, Zha+21, BCL22, GLSTW21, RR22]</em>, but with linear space complexity. These constructions rely on, among other things, a component that achieves linear-time proving via dynamic programming techniques <em>[x29]</em>, which demands storing in memory the proved computation.</p>

    <p class="text-gray-300">The notion of complexity-preserving SNARKs introduced in <em>[x1]</em> aims to simultaneously optimize time and space: it requires that the prover’s time and space complexity are at most polylogarithmic factors away from those of the proved computation. Complexity-preserving SNARKs were subsequently studied (and improved) in a line of works <em>[BCCT13, x11, BHRRS20, BHRRS21]</em>. The holy grail would be to preserve time and space complexity up to constant factors, but known constructions are far from this goal, and achieve improved space complexity at the expense of time complexity.</p>

    <p class="text-gray-300">In sum, a line of works achieves excellent time complexity at the expense of space complexity, and a different line of works achieves excellent space complexity at the expense of time complexity. It remains a challenging open question to construct SNARKs that simultaneously do well in both parameters. In this paper we do not answer this question, but instead introduce and achieve a notion that meaningfully relaxes this goal: a single SNARK that can be configured to optimize for time complexity or optimize for space complexity.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">(1) Elastic SNARKs.</h4>

    <p class="text-gray-300">We advocate the study of SNARKs whose prover admits two different realizations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a time-efficient prover that receives as input instance and witness;</li>

      <li>a space-efficient prover with streaming access to these same inputs.</li>

    </ul>

    <p class="text-gray-300">These elastic provers can choose which realization to use, and allocate resources depending on the execution environment and the instance size. In addition, the two algorithms are compatible in such a way that during the execution of the protocol the space-efficient prover can pause and transcribe a prover state, and then the protocol can continue with the time-efficient prover (thereafter enjoying the benefits of the faster prover).</p>

    <p class="text-gray-300">We build on the notion of streams in <em>[BHRRS20]</em> to study the above goal. We study stream composition, and propose a definitional framework for streaming instances of Rank-1 Constraint Satisfiability (R1CS). Within this framework we contribute an elastic SNARK for R1CS that we describe next.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">(2) An elastic SNARK for R1CS.</h4>

    <p class="text-gray-300">We realize the above notion by constructing an elastic (preprocessing) SNARK for R1CS, that we name Gemini. In time-efficient mode the prover uses a linear number of</p>

    <p class="text-gray-300">cryptographic operations and linear space, and in space-efficient mode the prover uses a quasilinear number of cryptographic operations and logarithmic space. When referring to time efficiency, we use the asymptotic notation <span class="math">O_{\\lambda}</span> to denote cryptographic operations, so to distinguish them from (less expensive) field operations for which we use the asymptotic notation <span class="math">O</span>. Our main result is the (informally stated) theorem below.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">The R1CS problem asks: given a finite field <span class="math">\\mathbb{F}</span>, coefficient matrices <span class="math">A,B,C\\in\\mathbb{F}^{N\\times N}</span> each containing at most <span class="math">M=\\Omega(N)</span> non-zero entries, and an instance vector <span class="math">\\mathbf{x}</span> over <span class="math">\\mathbb{F}</span>, is there a witness vector <span class="math">\\mathbf{w}</span> such that <span class="math">A\\mathbf{z}\\circ B\\mathbf{z}=C\\mathbf{z}</span> for <span class="math">\\mathbf{z}\\coloneqq(\\mathbf{x},\\mathbf{w})\\in\\mathbb{F}^{N}</span>? (Here, “<span class="math">\\circ</span>” denotes the entry-wise product.)</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">There exists an elastic SNARK for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> whose prover admits two realizations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a time-efficient prover that runs in <span class="math">O_{\\lambda}(M)</span> time and <span class="math">O(M)</span> space;</li>

      <li>a space-efficient prover that runs in <span class="math">O_{\\lambda}(M\\log^{2}M)</span> time and <span class="math">O(\\log M)</span> space.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verification time is $O_{\\lambda}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log M)<span class="math"> time and proof size is </span>O(\\log M)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above SNARK is obtained via a popular paradigm that combines a polynomial IOP and a polynomial commitment scheme in order to obtain an interactive argument, and then relies on the Fiat–Shamir paradigm to make the protocol non-interactive. The (omitted) cryptographic assumptions in the informal statement are inherited from those for the underlying polynomial commitment scheme, which in our case is <em>[x11]</em>.</p>

    <p class="text-gray-300">Briefly, after observing that the polynomial commitment scheme in <em>[x11]</em> can be realized elastically, our main contribution is achieving an elastic polynomial IOP. A key component of this latter is an elastic scalar product protocol, which runs in linear-time and linear-space or quasilinear-time and log-space. Our scalar product argument is based on the sumcheck protocol, which, thanks to its recursive nature, facilitates migrating from a space-efficient instance to a time-efficient one.</p>

    <p class="text-gray-300">(3) Implementation. We implement the construction of Theorem 1 in Rust using the arkworks ecosystem <em>[x3]</em>, replicating the modularity of the IOP construction. In particular, we develop new streaming-friendly primitives that we believe could be of independent interest for future projects realizing space-efficient cryptographic proofs. Our implementation additionally includes a simpler SNARK that is not preprocessing (the verification procedure reads R1CS instances without providing succinct verification). In Section 2.7, we summarize our design choices and algorithmic optimizations for the implementation.</p>

    <p class="text-gray-300">(4) Evaluation. Most benchmarks for time-efficient SNARKs in the literature do not consider large circuits, due to prohibitive memory usage. Our benchmarks, discussed further in Section 2.8, show the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gemini is able to prove instances of arbitrary size. On a single machine with a memory budget of around <span class="math">1</span> GB, we ran the prover of the preprocessing SNARK for instances of size <span class="math">2^{32}</span> and the prover of the non-preprocessing SNARK (where the verifier reads the R1CS instance in full) for instances of size <span class="math">2^{35}</span>. We “stopped” at these sizes only due to time constraints.</li>

    </ul>

    <p class="text-gray-300">In contrast, the largest instance size reported in the literature is in DIZK <em>[x23]</em>, where a distributed realization of the preprocessing SNARK (with circuit-specific setup) of <em>[x10]</em> is run for an R1CS instance of size <span class="math">2^{31}</span> over a cluster of 20 machines with 256 executors.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gemini is concretely and economically efficient. The preprocessing SNARK can prove instances of size <span class="math">2^{31}</span> in two days and costs about <span class="math">82\\%</span> (about <span class="math">400</span> USD) less than DIZK on Amazon EC2.</li>

      <li>Gemini provides succinct proofs and verification. For instances of size <span class="math">2^{35}</span>, the proof size is about <span class="math">27</span> KB and the verification time is below <span class="math">30</span> ms.</li>

    </ul>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We summarize the main ideas behind our results. In Section 2.1 we outline the streaming model that we use to express space-efficient algorithms. In Section 2.2 we describe how to construct elastic SNARKs from elastic polynomial commitment schemes and elastic probabilistic proofs. We describe an example of an elastic polynomial commitment scheme in Section 2.3. Then, in Sections 2.4 to 2.6 we sketch our elastic probabilistic proof. We conclude in Section 2.7 and Section 2.8 by discussing our implementation and evaluation.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Elasticity and a streaming model</h3>

    <p class="text-gray-300">The notion of elasticity refers to having multiple realizations of the same algorithm (more precisely, function) for use in different situations. Specifically in this work:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Elasticity means that we aim for two realizations: a time-efficient realization for a setting where time complexity is most important, possibly at the expense of space complexity; and a space-efficient realization for a setting where space complexity (i.e., memory consumption) is most important, possibly at the expense of time complexity.</p>
    </blockquote>

    <p class="text-gray-300">This means that in theorem statements, and in their proofs, we will consider two realizations with different complexities for the same function (e.g., the SNARK prover).</p>

    <p class="text-gray-300">Time-efficient algorithms are a familiar concept. Space-efficient algorithms in this paper are streaming algorithms: algorithms that receive their inputs in streams (small pieces at a time) so that they can use less memory than the size of their inputs. Below we elaborate on: (i) streams; and (ii) streaming algorithms.</p>

    <p class="text-gray-300">Streams and streaming oracles. A stream is a sequence <span class="math">K\\in\\Sigma^{I}</span>, where <span class="math">\\Sigma</span> is an alphabet and <span class="math">I</span> is a well-ordered countable set. Streams are accessed via oracles: if <span class="math">K</span> is a sequence, the streaming oracle <span class="math">\\mathcal{S}(K)</span> of <span class="math">K</span> takes two input commands, start and next; the oracle responds to the <span class="math">i</span>-th next command with the <span class="math">i</span>-th element of <span class="math">K</span>; in case earlier elements of the stream need to be read again, the start command resets the oracle to the first element in the sequence. The oracle does not allow random access to elements of <span class="math">K</span>.</p>

    <p class="text-gray-300">Streaming algorithms. A streaming algorithm is an algorithm that has access to its inputs via streaming oracles and produces a stream as its output, by outputting the next element upon receiving the next command. The complexity of a streaming algorithm is measured in terms of its time complexity, space complexity, and the number of passes that it makes over each input stream (via the start command).</p>

    <p class="text-gray-300">Any binary operation over an alphabet can be viewed as a streaming algorithm which takes as input two sequences <span class="math">K</span> and <span class="math">K^{\\prime}</span> over the same alphabet <span class="math">\\Sigma</span> that are indexed by the same set <span class="math">I</span>. The binary operation acts on successive pairs of elements of <span class="math">K</span> and <span class="math">K^{\\prime}</span>, to produce a new stream on the fly. For instance, let <span class="math">\\mathbf{f},\\mathbf{g}</span> be two vectors over a finite field <span class="math">\\mathbb{F}</span>, and <span class="math">\\mathcal{S}(\\mathbf{f})</span>, <span class="math">\\mathcal{S}(\\mathbf{g})</span> their canonical streams. (The canonical stream of a vector is the sequence of its entries, from last to first.) For a scalar <span class="math">\\rho\\in\\mathbb{F}</span>, the stream <span class="math">\\mathcal{S}(\\mathbf{f}+\\rho\\mathbf{g})</span> can be evaluated as a new stream using <span class="math">\\mathcal{S}(\\mathbf{f})</span> and <span class="math">\\mathcal{S}(\\mathbf{g})</span>, by responding to each next query in the following way: first query <span class="math">\\mathcal{S}(\\mathbf{f})</span> to obtain the <span class="math">i</span>-th entry <span class="math">f_{i}</span> of <span class="math">\\mathbf{f}</span>; then query <span class="math">\\mathcal{S}(\\mathbf{g})</span> to obtain the <span class="math">i</span>-th entry <span class="math">g_{i}</span> of <span class="math">\\mathbf{g}</span>; and finally respond with <span class="math">f_{i}+\\rho g_{i}</span>.</p>

    <p class="text-gray-300">Since a streaming algorithm produces a stream as output, multiple streaming algorithms can be composed so that the output stream produced by one algorithm is the input stream for the next algorithm. The time and space complexity and number of input passes of streaming algorithms behave predictably under composition. If <span class="math">\\mathcal{A}</span> is a streaming algorithm with time complexity <span class="math">t_{\\mathcal{A}}</span>, space complexity <span class="math">s_{\\mathcal{A}}</span>, and <span class="math">k_{\\mathcal{A}}</span> input passes, and <span class="math">\\mathcal{B}</span> is a streaming algorithm with time complexity <span class="math">t_{\\mathcal{B}}</span>, space complexity <span class="math">s_{\\mathcal{B}}</span>, and <span class="math">k_{\\mathcal{B}}</span> input passes, then <span class="math">\\mathcal{A}</span> composed with <span class="math">\\mathcal{B}</span> has time complexity <span class="math">t_{\\mathcal{A}}+k_{\\mathcal{A}}t_{\\mathcal{B}}</span>, space complexity <span class="math">s_{\\mathcal{A}}+s_{\\mathcal{B}}</span>, and <span class="math">k_{\\mathcal{A}}k_{\\mathcal{B}}</span> input passes.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">6</p>

    <h2 id="sec-8" class="text-2xl font-bold">2.2 A modular construction of elastic SNARKs</h2>

    <p class="text-gray-300">Many succinct arguments are built in two steps. First, construct an information-theoretic probabilistic proof in a model where the verifier has a certain type of query access to the prover's messages. Second, compile the probabilistic proof into an interactive succinct argument, via a cryptographic commitment scheme that “supports” this query access.³ Finally, if non-interactivity is desired, apply the Fiat–Shamir transformation [FS86]. This modular approach has enabled researchers to study the efficiency and security of simpler components, which has facilitated much progress in succinct arguments.</p>

    <p class="text-gray-300">We observe that the approach used in [CHMMVW20; BFS20] to construct SNARKs preserves elasticity: if the ingredients to the approach are elastic then the resulting SNARK is elastic. There are two ingredients.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial IOPs. A probabilistic proof in which the prover sends polynomial oracles to the verifier, who accesses them via polynomial evaluation queries. This is an interactive oracle proof [BCS16; RRR16] where query access to prover messages is changed from “point queries” to “polynomial evaluation queries”.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polynomial commitments. A cryptographic primitive that enables a sender to commit to a polynomial <span class="math">\\mathbf{f} \\in \\mathbb{F}[X]</span> of bounded degree, and later prove that <span class="math">\\mathbf{f}(z) = v</span> for given <span class="math">z, v \\in \\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">If the polynomial IOP is additionally holographic then the resulting succinct argument is a preprocessing argument, which means that it is possible, in an offline phase, to perform a public computation that enables sub-linear verification in a later online phase. The lemma below summarizes how elasticity is preserved. The formal statement (and its proof) are relative to the formalism for streaming algorithms outlined in Section 2.1.</p>

    <p class="text-gray-300"><strong>Theorem 2 (informal).</strong> Suppose that we are given the following ingredients.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A public-coin polynomial IOP for a relation <span class="math">\\mathcal{R}</span> with: (i) time-efficient prover time <span class="math">t_{\\mathcal{P}}</span>; (ii) space-efficient prover space <span class="math">s_{\\mathcal{P}}</span> with <span class="math">k_{\\mathcal{P}}</span> passes; (iii) <span class="math">O</span> oracles; (iv) query complexity <span class="math">q</span>; (v) verifier complexity <span class="math">t_{\\mathcal{V}}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A polynomial commitment scheme with: (i) time-efficient commit (and open) time <span class="math">t_{\\mathsf{PC.Com}}</span>; (ii) space-efficient commit (and open) space <span class="math">s_{\\mathsf{PC.Com}}</span> with <span class="math">k_{\\mathsf{PC.Com}}</span> passes; (iii) checking time <span class="math">t_{\\mathsf{PC.Check}}</span>.</li>

    </ul>

    <p class="text-gray-300">Then there exists an interactive argument system for the relation <span class="math">\\mathcal{R}</span> with: (i) time-efficient prover time <span class="math">t_{\\mathcal{P}} + O \\cdot t_{\\mathsf{PC.Com}} + q \\cdot t_{\\mathsf{PC.Com}}</span>; (ii) space-efficient prover space <span class="math">s_{\\mathcal{P}} + O \\cdot s_{\\mathsf{PC.Com}}</span> with <span class="math">q \\cdot k_{\\mathcal{P}} \\cdot k_{\\mathsf{PC.Com}}</span> passes; (iii) verifier complexity <span class="math">t_{\\mathcal{V}} + q \\cdot t_{\\mathsf{PC.Check}}</span>. Moreover, the argument system is preprocessing if the given polynomial IOP is holographic (with time and space properties similarly preserved by the transformation).</p>

    <p class="text-gray-300">Informally, the argument prover commits to each polynomial oracle via the polynomial commitment scheme, and answers polynomial evaluation queries by sending the requested evaluation along with a proof that it is consistent with the corresponding polynomial commitment. The security and most efficiency measures are studied in [CHMMVW20; BFS20]. Less obvious is how space complexity is affected.</p>

    <p class="text-gray-300">A streaming implementation of the PIOP prover does not necessarily produce all of its output polynomial streams one by one, and therefore the space complexity of the resulting argument prover is not, e.g., just the sum <span class="math">s_{\\mathcal{P}} + s_{\\mathsf{PC.Com}}</span> of the PIOP prover space and the PC commitment algorithm space. When two (or more) of the PIOP prover's message polynomials all depend on the same input stream, the prover may avoid extra passes over the input stream by producing both of them at the same time which would require space <span class="math">s_{\\mathcal{P}} + 2s_{\\mathsf{PC.Com}}</span>.⁴ Furthermore, the commitment algorithm requires several passes over a single input</p>

    <p class="text-gray-300">³The argument prover and argument verifier emulate the underlying probabilistic proof, with the argument prover sending commitments to proof messages and sending answers to queries together with commitment openings to authenticate those answers.</p>

    <p class="text-gray-300">⁴For example, if one polynomial consists of all of the even coefficients of another, one can produce streams of the coefficients of both polynomials simultaneously, in half the number of passes required to compute streams of each polynomial one at a time.</p>

    <p class="text-gray-300">polynomial, so that the argument prover must run the PIOP prover several times in order to complete the commitment to each polynomial, keeping partially computed commitments to each polynomial in memory. Such considerations lead to the space-efficient argument prover having space complexity <span class="math">s_{\\mathcal{P}}+O\\cdot s_{\\text{PC.Com}}</span> with <span class="math">q\\cdot k_{\\mathcal{P}}\\cdot k_{\\text{PC.Com}}</span> passes. Fortunately, the PIOP constructions in this paper actually satisfy the strong property that each polynomial can be produced independently without rerunning the entire prover algorithm, which reduces the space complexity to <span class="math">s_{\\mathcal{P}}+s_{\\text{PC.Com}}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Remark 2.1 (types of polynomials).</h6>

    <p class="text-gray-300">The above discussion is deliberately ambiguous about certain aspects: are the polynomials univariate or multivariate? are the polynomials represented as vectors of coefficients or as vectors of evaluations (or vectors in some other basis)? These details do not matter for Theorem 2 as long as the two ingredients “match up”: if the PIOP outputs polynomials represented in a way that is compatible with how the PC scheme expects inputs. Nevertheless, in this paper we focus on the case of univariate polynomials represented as vectors of coefficients, because our construction and implementation are in this setting.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Remark 2.2 (multilinear vs. univariate).</h6>

    <p class="text-gray-300">The fact that the approach in <em>[CHMMV+20, BFS+20]</em> preserves space efficiency in the case of multilinear polynomials represented over the boolean hypercube was used in <em>[BHR+20, BHR+21]</em>. Theorem 2 is a straightforward observation about <em>[CHMMV+20, BFS+20]</em> that additionally preserves elasticity. In particular, we believe that the constructions in <em>[BHR+20, BHR+21]</em> could be shown to have elastic realizations, by showing that the underlying multilinear PIOP and multilinear PC schemes have elastic realizations. We choose to work with univariate polynomials, instead of multilinear polynomials, because they have received more interest by practitioners, and thus focus our investigation on the concrete efficiency of elastic SNARKs based on univariate polynomials. We leave the study of concrete efficiency of elastic SNARKs based on multilinear polynomials to future work.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Remark 2.3 (elastic setup and indexer).</h6>

    <p class="text-gray-300">For any succinct argument, elasticity is a desirable property as the size of the statement to be proven increases. In this paper we focus on elasticity of the prover, which is the main bottleneck for proving large instances. We briefly comment on elasticity for other algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Setup.</em> The setup algorithm samples the public parameters of the argument system. While the complexity of the setup algorithm can be linear (or more!) in the statement size, we do not discuss setup algorithms in this paper for two reasons: (i) known setup algorithms have straightforward realizations that are simultaneously efficient in time and space (there is less of a tension between optimizing for time or for space as there is for the prover); (ii) public parameters are typically sampled via “cryptographic ceremonies” that realize the setup functionality via secure multi-party protocols <em>[BGM+17]</em>, and so it is more relevant to discuss the time and space efficiency of the protocols that realize these ceremonies.</li>

      <li><em>Indexer.</em> In the case of preprocessing arguments, an indexer algorithm produces the <em>proving key</em> and <em>verification key</em>. The indexer in our construction and implementation is elastic, but we do not discuss it since all ideas relevant for the indexer can be straightforwardly inferred from those relevant for the prover.</li>

    </ul>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 An elastic realization of the KZG polynomial commitment scheme</h3>

    <p class="text-gray-300">We use a univariate polynomial commitment scheme from <em>[KZG+10]</em> to construct our SNARK (see Section 2.2). Below we review this scheme and explain how to realize it elastically.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Review: a polynomial commitment from <em>[KZG+10]</em>.</h5>

    <p class="text-gray-300">The setup algorithm samples and outputs public parameters for the scheme to support polynomials of degree at most <span class="math">D\\in\\mathbb{N}</span>: the description of a bilinear group <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},q,G,H,e)</span>; the commitment key <span class="math">\\mathsf{ck}\\coloneqq(G,\\tau G,\\ldots,\\tau^{D}G)\\in\\mathbb{G}_{1}^{D+1}</span> for a random field</p>

    <p class="text-gray-300">element <span class="math">\\tau\\in\\mathbb{F}_{q}</span>; and the receiver key <span class="math">\\mathsf{rk}\\coloneqq(G,H,\\tau H)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}^{2}</span>. The commitment to a polynomial <span class="math">\\mathbf{p}\\in\\mathbb{F}_{q}[X]</span> of degree <span class="math">d\\leq D</span> is computed as <span class="math">C\\coloneqq\\langle\\mathbf{p},\\mathsf{ck}\\rangle=\\mathbf{p}(\\tau)G\\in\\mathbb{G}_{1}</span>. Subsequently, to prove that the committed polynomial <span class="math">\\mathbf{p}</span> evaluates to <span class="math">v</span> at <span class="math">z\\in\\mathbb{F}_{q}</span>, the committer computes the witness polynomial <span class="math">\\mathbf{w}(X)\\coloneqq(\\mathbf{p}(X)-\\mathbf{p}(z))/(X-z)</span>, and outputs the evaluation proof <span class="math">\\pi\\coloneqq\\langle\\mathbf{w},\\mathsf{ck}\\rangle=\\mathbf{w}(\\tau)G\\in\\mathbb{G}_{1}</span>. Finally, to verify the evaluation proof, the receiver checks that <span class="math">e(C-vG,H)=e(\\pi,\\tau H-zH)</span>.</p>

    <p class="text-gray-300">Elastic realization. An elastic realization of the above scheme requires a time-efficient realization and a space-efficient realization for each relevant algorithm of the scheme. Here we do not discuss the setup algorithm, as it has a natural time-and-space-efficient realization (see Remark 2.3). We do not discuss the verification algorithm either, because it only involves a constant number of scalar multiplications and pairings. Our focus is thus on the commitment and opening algorithm.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commitment algorithm. For <span class="math">d\\leq D</span>, we are given streams of the commitment key elements <span class="math">(G,\\tau G,\\ldots,\\tau^{d}G)</span> and of the coefficients <span class="math">(p_{i})_{i=0}^{d}</span> of the polynomial <span class="math">\\mathbf{p}(X)=\\sum_{i=0}^{d}p_{i}X^{i}</span> to be committed. We compute the commitment <span class="math">C=\\sum_{i=0}^{d}p_{i}\\tau^{i}G</span> by multiplying each coefficient-key pair <span class="math">(p_{i},\\tau^{i}G)</span> together and adding them to a running total. Each scalar-multiplication of <span class="math">p_{i}\\cdot\\tau^{i}G</span> is performed in linear time and constant space.</li>

      <li>Opening algorithm. We are given the same streams as above, and an opening location <span class="math">z</span>. By rearranging the expression for the witness polynomial <span class="math">\\mathbf{w}(X)=(\\mathbf{p}(X)-\\mathbf{p}(z))/(X-z)</span>, we stream the coefficients <span class="math">(w_{i})_{i=0}^{d-1}</span> of <span class="math">\\mathbf{w}(X)</span> via Ruffini’s rule: <span class="math">w_{i}\\coloneqq p_{i+1}+w_{i+1}z</span>. The evaluation proof <span class="math">\\pi=\\sum_{i=0}^{d-1}w_{i}\\tau^{i}G</span> is computed in the same way as the commitment algorithm.</li>

    </ul>

    <p class="text-gray-300">We discuss optimizations on the above streaming approach in Section 2.7.2.</p>

    <p class="text-gray-300">Note that the recurrence relation in the opening algorithm uses <span class="math">w_{j+1}</span> to compute <span class="math">w_{j}</span>, which means that <span class="math">\\mathbf{w}(X)</span> is computed from its highest-degree coefficient to its lowest-degree coefficient. In turn, this means that the commitment key <span class="math">\\mathsf{ck}</span> and the polynomial <span class="math">\\mathbf{p}(X)</span> are streamed from highest-degree to lowest-degree coefficient. The setup and commitment algorithms are agnostic to the streaming order.</p>

    <p class="text-gray-300">The above discussion implies the following (informal) lemma.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 2.4 (informal).</h6>

    <p class="text-gray-300">The polynomial commitment scheme of <em>[x13]</em> has an elastic realization.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.4 An elastic scalar-product protocol</h3>

    <p class="text-gray-300">A scalar-product protocol enables the prover to convince the verifier that the scalar product of two committed vectors equals a certain target value. Many constructions of succinct arguments for NP crucially rely on scalar-product protocols <em>[x1, x21, x12]</em>. The PIOP for R1CS that we construct in Sections 2.5 and 2.6 relies on a PIOP for scalar products where the prover has two realizations: (i) one that runs in linear-time and linear-space; and (ii) one that runs in quasilinear-time and logarithmic-space.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A PIOP for scalar products is a PIOP where the verifier receives as input <span class="math">(\\mathbb{F},N,u)</span> and has (polynomial evaluation) query access to <span class="math">\\mathbf{f},\\mathbf{g}\\in\\mathbb{F}^{N}</span>, and checks with the help of the prover that <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=u</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 2.5 (informal).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span>, there is a PIOP for scalar products over <span class="math">\\mathbb{F}</span> with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(\\log N)</span>;</li>

      <li>proof length <span class="math">O(N)</span> and query complexity <span class="math">O(\\log N)</span>;</li>

      <li>a time-efficient prover that runs in time <span class="math">O(N)</span> and space <span class="math">O(N)</span>;</li>

      <li>a space-efficient prover that runs in time <span class="math">O(N\\log N)</span> and space <span class="math">O(\\log N)</span> (with <span class="math">O(\\log N)</span> input passes);</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a verifier that runs in time <span class="math">O(\\log N)</span> and space <span class="math">O(\\log N)</span>.</li>

    </ul>

    <p class="text-gray-300">Below we outline the scalar-product protocol, deferring to Section 6 security proofs and a more in-depth discussion of the protocol. We also note that our PIOP uses two slightly different protocols: one for twisted scalar-products <span class="math">\\langle\\mathbf{f}\\circ\\mathbf{y},\\mathbf{g}\\rangle=u</span> for a vector <span class="math">\\mathbf{y}</span> of the form <span class="math">(1,\\rho_{0})\\otimes(1,\\rho_{1})\\otimes\\cdots\\otimes(1,\\rho_{n-1})</span> where <span class="math">n\\coloneqq\\log N</span> (by <span class="math">\\log</span> we denote the ceiling of the logarithm base 2); and one for Hadamard products <span class="math">\\mathbf{f}\\circ\\mathbf{g}=\\mathbf{h}</span>. These follow from simple modifications to the scalar-product protocol.</p>

    <p class="text-gray-300">We proceed in three steps. In Section 2.4.1 we describe how to reduce checking a scalar product to checking tensor products of univariate polynomials. In Section 2.4.2 we describe a tensor product protocol. In Section 2.4.3 we describe how to realize this latter protocol in an elastic way.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">2.4.1 Verifying scalar products using the sumcheck protocol</h4>

    <p class="text-gray-300">Consider two vectors <span class="math">\\mathbf{f}</span>, <span class="math">\\mathbf{g}\\in\\mathbb{F}^{N}</span> with <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=u</span> as in Definition 2. The verifier has polynomial evaluation query access to <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span> (the verifier can obtain any evaluations of the polynomials <span class="math">\\mathbf{f}(X)=\\sum_{i=0}^{N-1}f_{i}X^{i}</span> and <span class="math">\\mathbf{g}(X)=\\sum_{i=0}^{N-1}g_{i}X^{i}</span>). The product polynomial <span class="math">\\mathbf{h}(X)\\coloneqq\\mathbf{f}(X)\\cdot\\mathbf{g}(X^{-1})</span> has <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=\\sum_{i=0}^{N-1}f_{i}g_{i}</span> as the coefficient of <span class="math">X^{0}</span>, because for every <span class="math">i,j\\in[N]</span> the powers of <span class="math">X</span> associated with <span class="math">f_{i}</span> and <span class="math">g_{j}</span> multiply together to give <span class="math">X^{0}</span> if and only if <span class="math">i=j</span>. Therefore, to check the scalar-product <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=u</span>, it suffices to check that the coefficient of <span class="math">X^{0}</span> in the product polynomial <span class="math">\\mathbf{h}(X)</span> equals <span class="math">u</span>.</p>

    <p class="text-gray-300">However, this check must somehow be performed without the prover actually computing <span class="math">\\mathbf{h}(X)</span>. This is because the fastest algorithm for computing <span class="math">\\mathbf{h}(X)</span> requires <span class="math">O(N\\log N)</span> time and <span class="math">O(N)</span> space (via FFTs), which is neither time-efficient nor space-efficient. On the other hand, the scalar product <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=u</span> can be checked (directly) in time <span class="math">O(N)</span> and space <span class="math">O(1)</span>, which leaves open the possibility of a scalar-product protocol where the prover does better than computing <span class="math">\\mathbf{h}(X)</span> explicitly (and then running some protocol).</p>

    <p class="text-gray-300">This issue is addressed in prior work, if the verifier can query the multilinear polynomials <span class="math">\\widehat{\\mathbf{f}}(\\mathbf{X})</span> and <span class="math">\\widehat{\\mathbf{g}}(\\mathbf{X})</span> associated to the vectors <span class="math">\\mathbf{f},\\mathbf{g}\\in\\mathbb{F}^{N}</span>: we index the entries of <span class="math">\\mathbf{f}</span> using binary vectors, and <span class="math">f_{i}=f_{b_{0},\\ldots,b_{n-1}}</span> is the coefficient of <span class="math">X_{0}^{b_{0}}\\cdots X_{n-1}^{b_{n-1}}</span>, where <span class="math">(b_{0},\\ldots,b_{n-1})</span> is the binary decomposition of <span class="math">i</span>. Prior work <em>[x14, x21, x1]</em> yields the following lemma.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 2.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">N</span> be a positive integer; set <span class="math">n\\coloneqq\\log N</span>. Let <span class="math">\\widehat{\\mathbf{f}}(X_{0},\\ldots,X_{n-1})</span> and <span class="math">\\widehat{\\mathbf{g}}(X_{0},\\ldots,X_{n-1})</span> be multilinear polynomials. The sumcheck protocol (as a reduction to claims about polynomial evaluations) for the claim</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2^{n}}\\sum_{\\bm{\\omega}\\in\\{-1,1\\}^{n}}(\\widehat{\\mathbf{f}}\\cdot\\widehat{\\mathbf{g}})(\\bm{\\omega})=u</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">has the following properties: soundness error is $O(\\log N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; round complexity is </span>O(\\log N)<span class="math">; prover time </span>O(N)<span class="math">; and verifier time </span>O(\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One can use the (multivariate) sumcheck protocol of <em>[x12]</em> to reduce <span class="math">\\langle\\mathbf{f},\\mathbf{g}\\rangle=u</span> to two evaluation queries <span class="math">\\widehat{\\mathbf{f}}(\\bm{\\rho})</span> and <span class="math">\\widehat{\\mathbf{g}}(\\bm{\\rho})</span>, where <span class="math">\\bm{\\rho}\\coloneqq(\\rho_{0},\\ldots,\\rho_{n-1})\\in\\mathbb{F}^{n}</span> are the random verifier challenges used in the sumcheck protocol. Crucially, the prover algorithm in the sumcheck protocol applied to the product of two multilinear polynomials also has a space-efficient realization which runs in time <span class="math">O(N\\log N)</span> and space <span class="math">O(\\log N)</span> <em>[x6]</em>, which would provide an elastic solution in this multilinear regime.</p>

    <p class="text-gray-300">In our setting the verifier can only query the univariate polynomials <span class="math">\\mathbf{f}(X)</span> and <span class="math">\\mathbf{g}(X)</span> associated with the vectors <span class="math">\\mathbf{f},\\mathbf{g}\\in\\mathbb{F}^{N}</span>. Nevertheless, we follow a similar approach, by running the sumcheck protocol on the multivariate polynomials <span class="math">\\widehat{\\mathbf{f}}(\\mathbf{X})</span> and <span class="math">\\widehat{\\mathbf{g}}(\\mathbf{X})</span>, producing two claimed evaluations <span class="math">\\widehat{\\mathbf{f}}(\\bm{\\rho})=u</span> and <span class="math">\\widehat{\\mathbf{g}}(\\bm{\\rho})=u^{\\prime}</span>.</p>

    <p class="text-gray-300">e check that these claimed evaluations are consistent with <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span> using evaluations of the univariate polynomials <span class="math">\\mathbf{f}(X)</span> and <span class="math">\\mathbf{g}(X)</span> in the tensor product protocol of the following section.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Remark 2.7 (unstructured fields).</h6>

    <p class="text-gray-300">Many probabilistic proofs using univariate polynomials (e.g., the low-degree test in <em>[x1]</em>) require the size (of the multiplicative group) of the field <span class="math">\\mathbb{F}</span> to be smooth, so that the field contains high-degree roots of unity. In contrast, the scalar-product protocol in this paper (indeed, all the PIOPs in this paper) work with univariate polynomials over any field <span class="math">\\mathbb{F}</span> that is sufficiently large.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">2.4.2 A tensor-product protocol</h4>

    <p class="text-gray-300">We seek a protocol for checking the multilinear evaluation <span class="math">\\widehat{\\mathbf{f}}(\\bm{\\rho})=v</span> while having access to <span class="math">\\mathbf{f}(X)</span> (and possibly other polynomials sent by the prover) via univariate polynomial evaluations. Observe that <span class="math">\\widehat{\\mathbf{f}}(\\mathbf{X})</span> and <span class="math">\\mathbf{f}(X)</span> have the same coefficients, and moreover the polynomial <span class="math">\\widehat{\\mathbf{f}}(\\rho_{0},X_{1},\\ldots,X_{\\log N-1})</span> (partially evaluating <span class="math">\\widehat{\\mathbf{f}}(\\mathbf{X})</span> by setting <span class="math">X_{0}</span> equal to <span class="math">\\rho_{0}</span>) has the same coefficients as the polynomial <span class="math">\\mathbf{f}^{\\prime}(X)\\coloneqq\\mathbf{f}_{e}(X)+\\rho_{0}\\cdot\\mathbf{f}_{o}(X)</span>. Here, <span class="math">\\mathbf{f}_{e}(X)</span> and <span class="math">\\mathbf{f}_{o}(X)</span> are the odd and even parts defined by <span class="math">\\mathbf{f}(X)=\\mathbf{f}_{e}(X^{2})+X\\mathbf{f}_{o}(X^{2})</span>.</p>

    <p class="text-gray-300">This suggests a protocol where the prover sends <span class="math">\\mathbf{f}^{\\prime}(X)</span> to the verifier. If the verifier can check that <span class="math">\\mathbf{f}^{\\prime}(X)</span> was correctly computed from <span class="math">\\mathbf{f}(X)</span>, then checking consistency between <span class="math">\\mathbf{f}(X)</span> and an evaluation of <span class="math">\\widehat{\\mathbf{f}}(X_{0},\\ldots,X_{\\log N-1})</span> is reduced to checking consistency between <span class="math">\\mathbf{f}^{\\prime}(X)</span> and an evaluation of <span class="math">\\widehat{\\mathbf{f}}(\\rho_{0},X_{1},\\ldots,X_{\\log N-1})</span>. Repeating this reduction with every value <span class="math">\\rho_{j}</span>, the prover and verifier arrive at a claim about constant-degree polynomials, which the prover can send to the verifier and the verifier directly checks.</p>

    <p class="text-gray-300">To check that <span class="math">\\mathbf{f}^{\\prime}(X)</span> is consistent with <span class="math">\\mathbf{f}(X)</span>, the verifier samples a random challenge point <span class="math">\\beta\\in\\mathbb{F}^{\\times}</span> (where <span class="math">\\mathbb{F}^{\\times}</span> denotes the multiplicative group of <span class="math">\\mathbb{F}</span>), and makes polynomial evaluation queries in order to check the following equations:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{f}^{\\prime}(\\beta^{2})=\\mathbf{f}_{e}(\\beta)+\\rho_{0}\\cdot\\mathbf{f}_{o}(\\beta)=\\frac{\\mathbf{f}(\\beta)+\\mathbf{f}(-\\beta)}{2}+\\rho_{0}\\cdot\\frac{\\mathbf{f}(\\beta)-\\mathbf{f}(-\\beta)}{2\\beta}\\enspace.</span> (1)</p>

    <p class="text-gray-300">This is reminiscent of a reduction in <em>[x1]</em> used to construct a low-degree test for univariate polynomials. By the Schwartz–Zippel lemma, the check passes with small probability unless <span class="math">\\mathbf{f}^{\\prime}(X)</span> was computed correctly. Noting that <span class="math">\\widehat{\\mathbf{f}}(\\bm{\\rho})=\\langle\\mathbf{f},\\otimes_{j=0}^{n-1}(1,\\rho_{j})\\rangle</span>, this procedure gives a (univariate) polynomial IOP for this relation.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">The tensor-product relation <span class="math">\\mathcal{R}_{\\mathrm{TC}}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{\\hat{s}},\\mathbf{x},\\mathbf{w})=(\\bot,(\\mathbb{F},N,\\rho_{0},\\ldots,\\rho_{n-1},u),\\mathbf{f})</span></p>

    <p class="text-gray-300">where <span class="math">n=\\log N</span>, <span class="math">\\mathbf{f}\\in\\mathbb{F}^{N}</span>, <span class="math">u\\in\\mathbb{F}</span>, and <span class="math">\\langle\\mathbf{f},\\otimes_{j}(1,\\rho_{j})\\rangle=u</span>.</p>

    <p class="text-gray-300">We provide details of the tensor-product protocol in Section 5. In fact, the tensor check will be useful not only as part of our scalar-product protocol, but also more generally as part of simple checks that take place as part of our R1CS protocols (as described in Sections 2.5 and 2.6).</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">2.4.3 Elastic realization of the prover algorithm</h4>

    <p class="text-gray-300">Most complexity measures claimed in Theorem 2.5 follow straightforwardly from the sumcheck protocol described in Lemma 2.6. We are left to describe an elastic realization of the prover algorithm for the tensor-product protocol.</p>

    <p class="text-gray-300">The prover’s task is to compute the polynomials <span class="math">\\mathbf{f}^{(j)}</span> for each round <span class="math">j\\in[n]</span>. Given <span class="math">\\mathbf{f}^{(j-1)}</span>, which has degree <span class="math">O(N/2^{j})</span>, the prover can compute <span class="math">\\mathbf{f}^{(j)}</span> in <span class="math">O(N/2^{j})</span> operations via Equation 1. Summing up the</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: A streaming algorithm for computing the coefficients of  <span class="math">\\mathbf{f}^{(j)}</span>  from  <span class="math">\\mathbf{f}^{(0)}\\coloneqq \\mathbf{f}</span> . Nodes in blue denote the coefficients that are stored in memory at any moment.</p>

    <p class="text-gray-300">prover costs for  <span class="math">j \\in [n]</span>  gives  <span class="math">O(N)</span>  operations. Hence a linear-time prover realization for the tensor-product protocol is straightforward. Next, we give a space-efficient prover realization that uses logarithmic space.</p>

    <p class="text-gray-300">Logarithmic space. We want the prover to run in logarithmic space, given streaming access to  <span class="math">\\mathbf{f}</span>  and  <span class="math">\\mathbf{g}</span> . This is different from the time-efficient case, as the prover cannot store  <span class="math">\\mathbf{f}^{(j-1)}</span>  to help it compute  <span class="math">\\mathbf{f}^{(j)}</span> , as this requires linear space (for small  <span class="math">j</span> ). Instead, the prover computes each  <span class="math">\\mathbf{f}^{(j)}</span>  from scratch using streams of  <span class="math">\\mathbf{f}</span> .</p>

    <p class="text-gray-300">First we explain how the prover can produce a stream of  <span class="math">\\mathbf{f}^{(j)}</span>  efficiently, given streaming access to  <span class="math">\\mathbf{f}</span> , in a similar way to streaming evaluations of multivariate polynomials and low-degree extensions [CMT12; BHRRS20; BHRRS21]. Our contribution is to show that  <span class="math">\\mathbf{f}^{(j)}</span>  can be evaluated in  <span class="math">O(N)</span>  time and  <span class="math">O(\\log N)</span>  space, saving a logarithmic factor over prior work. Then, we explain how to perform the consistency checks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Streaming  <span class="math">\\mathbf{f}^{(j)}</span> . Let  <span class="math">\\mathbf{f} = \\sum_{i=0}^{N-1} f_i X^i</span> . We can compute  <span class="math">\\mathbf{f}&#x27; = \\sum_{i=0}^{N/2-1} (f_{2i} + \\rho f_{2i+1}) X^i</span>  from a stream of coefficients of  <span class="math">\\mathbf{f}</span>  by reading each pair of coefficients  <span class="math">f_{2i}, f_{2i+1}</span>  from the stream, and computing the next coefficient as  <span class="math">f_i&#x27; := f_{2i} + \\rho f_{2i+1}</span>  of  <span class="math">\\mathbf{f}&#x27;</span> . This uses a constant amount of space: store  <span class="math">f_{2i}</span>  and  <span class="math">f_{2i+1}</span> , and delete them right after computing  <span class="math">f_i&#x27;</span> . Each coefficient of  <span class="math">\\mathbf{f}&#x27;</span>  costs two arithmetic operations to compute.</li>

    </ul>

    <p class="text-gray-300">The prover can produce the stream  <span class="math">S(\\mathbf{f}^{(j)})</span>  for  <span class="math">\\mathbf{f}^{(j)}</span>  by applying the same idea recursively as follows. Initialize a stack Stack consisting of pairs  <span class="math">(j, x) \\in [\\log N] \\times \\mathbb{F}</span> , and a list of challenges  <span class="math">\\rho_0, \\ldots, \\rho_j</span> . To generate  <span class="math">S(\\mathbf{f}^{(j)})</span> , the prover proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the top element in the stack is of the form  <span class="math">(j, y)</span>  for some  <span class="math">y \\in \\mathbb{F}</span> , pop it and return  <span class="math">y</span> .</li>

      <li>If the top two elements in the stack are of the form  <span class="math">(k&#x27;, x&#x27;)</span>  and  <span class="math">(k, x)</span>  with  <span class="math">k = k&#x27;</span>  (and  <span class="math">k &amp;lt; j</span> ), then pop them and push  <span class="math">(k + 1, x + \\rho_k x&#x27;)</span> , where  <span class="math">x + \\rho_k x&#x27;</span>  is equal to  <span class="math">f_{k + 1}^{(j)}</span>  (recall that the values are streamed from last to first index);</li>

      <li>Otherwise, query the stream  <span class="math">S(\\mathbf{f})</span>  for the next element  <span class="math">x \\in \\mathbb{F}</span>  and add  <span class="math">(0, x)</span>  to the stack.</li>

    </ul>

    <p class="text-gray-300">The stack Stack must be initialized with some zero-entries if  <span class="math">N \\neq 2^n</span>  (for instance, where  <span class="math">N</span>  is odd) for correctness, but we avoid discussing this case here for simplicity. A visual representation of this process is displayed in Figure 1. This procedure produces a stream of  <span class="math">\\mathbf{f}^{(j)}</span>  from a stream of  <span class="math">\\mathbf{f}</span>  in  <span class="math">O(N)</span>  and using  <span class="math">\\log N</span>  memory space (since the stack Stack holds at most  <span class="math">\\log N</span>  elements at any time).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Space-efficient tensor check. The verifier must perform consistency checks to make sure that each polynomial  <span class="math">\\mathbf{f}^{(j)}</span>  was correctly computed from  <span class="math">\\mathbf{f}^{(j - 1)}</span> , and similarly for  <span class="math">\\mathbf{g}^{(j)}</span> . This check requires the computation of  <span class="math">\\mathbf{f}^{(0)},\\ldots ,\\mathbf{f}^{(n - 1)}</span> . We compute them in parallel with a minor modification to the algorithm illustrated in Figure 1. Instead of returning only when the top of the stack has a particular index, we always output the top element in the stack. We thus construct a streaming algorithm  <span class="math">S(\\mathbf{f}^{(0)},\\dots,\\mathbf{f}^{(n - 1)})</span>  that returns elements</li>

    </ul>

    <p class="text-gray-300">of the form <span class="math">(j,x)\\in[n]\\times\\mathbb{F}</span> where <span class="math">x</span> is the next coefficient of the polynomial <span class="math">\\mathbf{f}^{(j)}</span>. With the above stream, it is possible to produce all streams <span class="math">\\mathcal{S}(\\mathbf{f}^{(j)})</span> and evaluations <span class="math">\\mathbf{f}^{(j)}(\\beta^{2})</span>, <span class="math">\\mathbf{f}^{(j)}(+\\beta)</span>, <span class="math">\\mathbf{f}^{(j)}(-\\beta)</span>, for each <span class="math">j\\in[n]</span> with a single pass over <span class="math">\\mathcal{S}(\\mathbf{f})</span>. In particular computing each evaluation requires storing a single <span class="math">\\mathbb{F}</span>-element; therefore, the total consistency check uses <span class="math">n=\\log N</span> memory and <span class="math">N</span> time. This allows to check Equation 1, substituting <span class="math">\\mathbf{f}^{\\prime}=\\mathbf{f}^{(j)},\\mathbf{f}=\\mathbf{f}^{(j-1)}</span> for <span class="math">j\\in[n]</span>.</p>

    <p class="text-gray-300">Based on the costs of maintaining the stacks for <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span>, and computing the coefficients of <span class="math">\\mathbf{q}^{(j)}</span> incrementally, it follows that each round takes time <span class="math">O(N)</span> and space <span class="math">O(\\log N)</span>. Therefore, summing over the <span class="math">O(\\log N)</span> rounds, the protocol requires time <span class="math">O(N\\log N)</span> and space <span class="math">O(\\log N)</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 2.8.</h6>

    <p class="text-gray-300">Based on the tensor product protocol in Section 2.4.2, one can construct a linear-time univariate sumcheck protocol with proof length <span class="math">O(N)</span> and query complexity <span class="math">O(\\log N)</span>, which we believe could be of independent interest for future research. There are other univariate sumcheck protocols in the literature, however these protocols cannot be used in our setting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The univariate sumcheck protocol in <em>[x1]</em> is a 1-message PIOP with proof length <span class="math">O(N)</span> and query complexity <span class="math">O(1)</span>. That protocol does not seem useful here, because the prover requires <span class="math">O(N\\log N)</span> time and <span class="math">O(N)</span> space due to the use of FFTs. In contrast, our protocol achieves elasticity, at the cost of logarithmic round complexity and logarithmic query complexity.</li>

      <li>Drake <em>[x10]</em> sketches a Hadamard product protocol based on univariate polynomials that does not use FFTs. That protocol, also inspired by the low-degree test in <em>[x2]</em>, may conceivably lead to a univariate sumcheck protocol that is elastic. No details (or implementations) of the protocol are available.</li>

    </ul>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">2.5 Warm-up: an elastic non-holographic PIOP for R1CS</h3>

    <p class="text-gray-300">We describe an elastic PIOP for R1CS (Definition 1) based on the elastic scalar-product protocol in Section 2.4. While not sublinear here, the verifier can be made elastic via similar techniques to the elastic prover. We build on this construction later in Section 2.6, and construct a holographic PIOP with logarithmic verifier time.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 2.9 (informal).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span>, there is a PIOP for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}</span> with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(\\log N)</span>;</li>

      <li>proof length <span class="math">O(N)</span> and query complexity <span class="math">O(\\log N)</span>;</li>

      <li>a time-efficient prover that runs in time <span class="math">O(M)</span> and space <span class="math">O(M)</span>;</li>

      <li>a space-efficient prover that runs in time <span class="math">O(M\\log^{2}N)</span> and space <span class="math">O(\\log N)</span> (with <span class="math">O(\\log N)</span> input passes);</li>

      <li>a time-efficient verifier that runs in time <span class="math">O(M)</span> and space <span class="math">O(M)</span>; and</li>

      <li>a space-efficient verifier that runs in time <span class="math">O(M\\log N)</span> and space <span class="math">O(\\log N)</span> (with <span class="math">O(\\log N)</span> input passes).</li>

    </ul>

    <p class="text-gray-300">Above, <span class="math">N</span> is dimension of R1CS matrices and <span class="math">M</span> the number of non-zero entries in the R1CS matrices.</p>

    <p class="text-gray-300">The theorem holds for any finite field <span class="math">\\mathbb{F}</span>, and in particular does not require any smoothness properties for <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">In order for the space-efficient realization of the prover to be well-defined, we must adopt a streaming model for R1CS instances. Below we describe a choice that: (i) suffices for the theorem; (ii) is realistic (as we elaborate shortly). After that we outline the PIOP for R1CS (and postpone details to Section 7).</p>

    <p class="text-gray-300">Streaming R1CS. The R1CS problem is captured using the following indexed relation:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 2.10.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of all triples <span class="math">(\\mathfrak{i},\\mathbf{x},\\mathbf{w})=\\left((\\mathbb{F},N,M,A,B,C),\\mathbf{x},\\mathbf{w}\\right)</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">A,B,C</span> are matrices in <span class="math">\\mathbb{F}^{N\\times N}</span> each having at most <span class="math">M</span> non-zero entries, and <span class="math">\\mathbf{z}\\coloneqq\\left(\\mathbf{x},\\mathbf{w}\\right)</span> is a vector in <span class="math">\\mathbb{F}^{N}</span> such that <span class="math">A\\mathbf{z}\\circ B\\mathbf{z}=C\\mathbf{z}</span>.</p>

    <p class="text-gray-300">We define streams for each of <span class="math">\\mathfrak{i},\\mathbf{x},\\mathbf{w}</span>, with <span class="math">A,B,C</span> in sparse representation.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 2.11.</h6>

    <p class="text-gray-300">The stream of <span class="math">U</span> is a pair <span class="math">\\left(\\mathcal{S}_{\\mathrm{rmaj}}(U),\\mathcal{S}_{\\mathrm{cmaj}}(U)\\right)</span>, where <span class="math">\\mathcal{S}_{\\mathrm{rmaj}}(U)</span> denotes the sequence of elements in the support (row, column, value) ordered in in row major (that is, lexicographic order with row), and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(U)</span> denotes the ordering of the ordering of the same sequence in column major.</p>

    <p class="text-gray-300">In our definition of streams for R1CS, we allow the <em>computation trace</em> <span class="math">(A\\mathbf{z},B\\mathbf{z},C\\mathbf{z})</span> of an R1CS instance to be streamed as part of the witness.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 2.12 (streaming R1CS).</h6>

    <p class="text-gray-300">The streams associated with <span class="math">((\\mathbb{F},N,M,A,B,C),\\mathbf{x},\\mathbf{w})</span> consist of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>index streams: streams of the R1CS matrices, in row-major and column-major: <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(A),\\mathcal{S}_{\\mathrm{cmaj}}(A))</span>, <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(B),\\mathcal{S}_{\\mathrm{cmaj}}(B))</span>, <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(C),\\mathcal{S}_{\\mathrm{cmaj}}(C))</span>;</li>

      <li>instance stream: stream of the instance vector <span class="math">\\mathcal{S}(\\mathbf{x})</span>;</li>

      <li>witness streams: stream of the witness <span class="math">\\mathcal{S}(\\mathbf{w})</span> and of the computation trace vectors <span class="math">\\mathcal{S}(A\\mathbf{z}),\\mathcal{S}(B\\mathbf{z}),\\mathcal{S}(C\\mathbf{z})</span>. The field description <span class="math">\\mathbb{F}</span>, instance size <span class="math">N</span>, and maximum number <span class="math">M</span> of non-zero entries are explicit inputs.</li>

    </ul>

    <p class="text-gray-300">Including steams for the computation trace <span class="math">(A\\mathbf{z},B\\mathbf{z},C\\mathbf{z})</span> makes the PIOP for R1CS space efficient even when matrix multiplication by <span class="math">A,B,C</span> requires a large amount of memory and the computation trace cannot be computed element by element on the fly given streaming access to <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{w}</span>. On the other hand, for R1CS instances defined by many natural computations, such as a machine computation which repeatedly applies a transition function to a small state, the matrices <span class="math">A,B,C</span> are such that their non-zero entries all lie in a thin, central diagonal band (that is, they are <em>banded</em>). In this case, one can generate a stream of <span class="math">\\mathcal{S}(A\\mathbf{z})</span> using the streams <span class="math">\\mathcal{S}(\\mathbf{x})</span>, <span class="math">\\mathcal{S}(\\mathbf{w})</span>, and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(A)</span>. (And similarly for <span class="math">B</span> and <span class="math">C</span>.)</p>

    <p class="text-gray-300">The PIOP construction. We outline the PIOP construction underlying Theorem 2.9. The protocol adopts standard ideas from <em>[x1]</em> and an optimization from <em>[x10]</em> for concrete efficiency. In the time-efficient realization, the prover receives <span class="math">(\\mathfrak{i},\\mathbf{x},\\mathbf{w})</span> as input and the verifier receives <span class="math">(\\mathfrak{i},\\mathbf{x})</span> as input. In the space-efficient realization, these inputs are provided as streams according to Definition 4.9.</p>

    <p class="text-gray-300">In the first step of the protocol, the prover sends <span class="math">\\mathbf{z}</span> to the verifier. To check that <span class="math">A\\mathbf{z}\\circ B\\mathbf{z}=C\\mathbf{z}</span>, the verifier replies by sending a random challenge <span class="math">\\upsilon\\in\\mathbb{F}^{\\times}</span> to the prover, which the prover expands into a vector <span class="math">\\mathbf{y}_{C}\\coloneqq(1,\\upsilon,\\upsilon^{2},\\ldots,\\upsilon^{N-1})</span>. Multiplying each side of the equation <span class="math">A\\mathbf{z}\\circ B\\mathbf{z}=C\\mathbf{z}</span> on the left by <span class="math">\\mathbf{y}_{C}^{\\intercal}</span>, the prover is left to convince the verifier that</p>

    <p class="text-gray-300"><span class="math">\\langle A\\mathbf{z}\\circ\\mathbf{y}_{C},\\ B\\mathbf{z}\\rangle=\\langle C\\mathbf{z},\\mathbf{y}_{C}\\rangle\\enspace.</span> (2)</p>

    <p class="text-gray-300">The prover sends the value <span class="math">u_{C}\\coloneqq\\langle C\\mathbf{z},\\mathbf{y}_{C}\\rangle\\in\\mathbb{F}</span> to the verifier. The prover will convince the verifier that Equation 2 holds by reducing the two claims <span class="math">\\langle A\\mathbf{z}\\circ\\mathbf{y}_{C},\\ B\\mathbf{z}\\rangle=u_{C}</span> and <span class="math">\\langle C\\mathbf{z},\\mathbf{y}_{C}\\rangle=u_{C}</span> to <em>tensor consistency checks</em> on <span class="math">\\mathbf{z}</span>, for which we can apply the tensor-product protocol in Section 2.4.</p>

    <p class="text-gray-300">As a subprotocol for the first claim, the prover and verifier run a twisted scalar product protocol, as described in Section 2.4. This generates two new claims, one about each of <span class="math">A\\mathbf{z}</span> and <span class="math">B\\mathbf{z}</span>, leaving us with a total of three claims:</p>

    <p class="text-gray-300"><span class="math">\\langle A\\mathbf{z},\\mathbf{y}_{B}\\circ\\mathbf{y}_{C}\\rangle</span> <span class="math">=u_{A}\\enspace,</span> (3) <span class="math">\\langle B\\mathbf{z},\\mathbf{y}_{B}\\rangle</span> <span class="math">=u_{B}\\enspace,</span> <span class="math">\\langle C\\mathbf{z},\\mathbf{y}_{C}\\rangle</span> <span class="math">=u_{C}\\enspace.</span></p>

    <p class="text-gray-300">The</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}_{B}\\coloneqq\\otimes_{j}(1,\\rho_{j})</span>, where <span class="math">\\rho_{0},\\rho_{1},\\ldots,\\rho_{n-1}\\in\\mathbb{F}^{\\times}</span> are the random challenges sent by the verifier during the scalar-product protocol. Setting <span class="math">\\mathbf{y}_{A}\\coloneqq\\mathbf{y}_{B}\\circ\\mathbf{y}_{C}</span>, and moving the matrices <span class="math">A,B,C</span> into the right input argument of the scalar-product relation, we have</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{z},\\mathbf{a}^{<em>}\\rangle</span> <span class="math">=u_{A}\\quad\\text{where}\\quad\\mathbf{a}^{</em>}\\coloneqq\\mathbf{y}_{A}^{\\intercal}A\\enspace,</span> (4) <span class="math">\\langle\\mathbf{z},\\mathbf{b}^{<em>}\\rangle</span> <span class="math">=u_{B}\\quad\\text{where}\\quad\\mathbf{b}^{</em>}\\coloneqq\\mathbf{y}_{B}^{\\intercal}B\\enspace,</span> <span class="math">\\langle\\mathbf{z},\\mathbf{c}^{<em>}\\rangle</span> <span class="math">=u_{C}\\quad\\text{where}\\quad\\mathbf{c}^{</em>}\\coloneqq\\mathbf{y}_{C}^{\\intercal}C\\enspace.</span></p>

    <p class="text-gray-300">Although <span class="math">\\mathbf{y}_{B},\\mathbf{y}_{C},\\mathbf{y}_{A}</span> all have a tensor structure, <span class="math">\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{*}</span> will not generally have the same structure, which means that Equation 4 cannot be checked directly using the tensor-product protocol. Thus, the verifier sends another random challenge <span class="math">\\eta\\in\\mathbb{F}^{\\times}</span> to the prover. Taking linear combinations of the three claims in Equation 4 using powers of <span class="math">\\eta</span> yields a single scalar-product claim</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{z},\\;\\mathbf{a}^{<em>}+\\eta\\cdot\\mathbf{b}^{</em>}+\\eta^{2}\\cdot\\mathbf{c}^{*}\\rangle=u_{A}+\\eta\\cdot u_{B}+\\eta^{2}\\cdot u_{C}\\enspace.</span> (5)</p>

    <p class="text-gray-300">The prover and verifier run a second twisted scalar-product protocol for Equation 5. This produces two new claims</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{z},\\mathbf{y}\\rangle</span> <span class="math">=u_{D}\\enspace,</span> (6) <span class="math">\\langle\\mathbf{a}^{<em>}+\\eta\\cdot\\mathbf{b}^{</em>}+\\eta^{2}\\cdot\\mathbf{c}^{*},\\mathbf{y}\\rangle</span> <span class="math">=u_{E}\\enspace,</span> (7)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{y}</span> is a vector with the same tensor structure as described in Section 2.4, generated using random challenges produced by the verifier.</p>

    <p class="text-gray-300">Finally, the prover and the verifier engage in a tensor-product protocol to check Equation 6. The verifier can check Equation 7 directly, since <span class="math">\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{*}</span> can be computed directly from the R1CS matrices <span class="math">A,B,C</span>, along with the random challenges used throughout the R1CS protocol.</p>

    <p class="text-gray-300">Time-efficient prover. The prover runs in linear time if the prover algorithms for the underlying scalar-product and tensor-product subprotocols are realized in linear time. Note that the cost of computing <span class="math">\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{*}</span> is linear in the number of non-zero entries in <span class="math">A,B,C</span>. As a result, the verifier also runs in linear time.</p>

    <p class="text-gray-300">Space-efficient prover. The scalar-product and tensor-product subprotocols used in the construction have a space-efficient prover that runs in time <span class="math">O(N\\log N)</span> and space <span class="math">O(\\log N)</span>, given <span class="math">O(\\log N)</span> passes over streams of the subprotocol inputs. Therefore, to give a space-efficient protocol for the entire R1CS protocol, it suffices to explain how to produce a stream for each subprotocol input.</p>

    <p class="text-gray-300">The first twisted scalar-product protocol for <span class="math">\\langle A\\mathbf{z}\\circ\\mathbf{y}_{C},\\;B\\mathbf{z}\\rangle=u_{C}</span> requires streaming access to <span class="math">A\\mathbf{z},B\\mathbf{z},\\mathbf{y}_{C}</span>. The prover has streaming access to <span class="math">A\\mathbf{z}</span> and <span class="math">B\\mathbf{z}</span> as part of the streams of the R1CS instance, so we explain how to generate a stream for the vector <span class="math">\\mathbf{y}_{C}=\\otimes_{j}(1,v^{2^{j}})\\in\\mathbb{F}^{N}</span>. This stream can be generated in <span class="math">O(N)</span> field operations. Let <span class="math">v_{j}:=v^{2^{j}}</span> for <span class="math">j\\in[0,\\ldots,n-1]</span>. The <span class="math">i</span>-th entry of <span class="math">\\mathbf{y}_{C}</span> is <span class="math">\\prod_{j}v_{j}^{b_{j}}</span>, where <span class="math">(b_{0},\\ldots,b_{n-1})</span> is the binary representation of <span class="math">i</span>. Consider how the binary representation of <span class="math">i</span> changes when we subtract <span class="math">1</span> from <span class="math">i</span>. If <span class="math">b_{0}=1</span> then it simply changes to <span class="math">0</span>. If <span class="math">i</span> ends with binary digits <span class="math">(b_{0},\\ldots,b_{k-1},b_{k})=(0,\\ldots,0,1)</span> then these digits change to <span class="math">(1,\\ldots,1,0)</span>. This means that we can get from the <span class="math">i</span>-th entry of <span class="math">\\mathbf{y}_{C}</span> to the <span class="math">(i-1)</span>-th by multiplying by either <span class="math">v_{0}^{-1}</span> or <span class="math">v_{k}^{-1}v_{k-1}\\cdots v_{0}</span> for some <span class="math">k\\in[n]</span>. To generate the stream of <span class="math">\\mathbf{y}_{C}</span>, the prover computes <span class="math">v_{j}:=v^{2^{j}}</span> for <span class="math">j\\in[0,\\ldots,n-1]</span> via repeated squaring, which uses <span class="math">O(\\log N)</span> operations and <span class="math">O(\\log N)</span> space. Then, the prover can generate each element of <span class="math">\\mathbf{y}_{C}</span> in <span class="math">O(N)</span> operations by multiplying by the correct quotient.</p>

    <p class="text-gray-300">The second scalar product protocol for Equation 5 requires streaming access to <span class="math">\\mathbf{z}</span>, <span class="math">\\mathbf{a}^{<em>}=\\mathbf{y}_{A}^{\\intercal}A</span>, <span class="math">\\mathbf{b}^{</em>}=\\mathbf{y}_{B}^{\\intercal}B</span> and <span class="math">\\mathbf{c}^{*}=\\mathbf{y}_{C}^{\\intercal}C</span>. The prover has access to <span class="math">\\mathcal{S}(\\mathbf{z})</span> by concatenating the witness stream <span class="math">\\mathcal{S}(\\mathbf{w})</span> to the instance</p>

    <p class="text-gray-300">stream <span class="math">\\mathcal{S}(\\mathbf{x})</span>. To generate the stream of <span class="math">\\mathbf{a}^{<em>}\\coloneqq\\mathbf{y}_{A}^{\\intercal}A</span>, the prover computes the <span class="math">i</span>-th element of <span class="math">\\mathbf{a}^{</em>}</span> by multiplying each element of <span class="math">\\mathbf{y}_{A}</span> by each element of the <span class="math">i</span>-th column of <span class="math">\\mathbf{a}^{<em>}</span>, and adding the result to a running total. The stream <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(A)</span> from the R1CS instance gives access to the non-zero entries of <span class="math">A</span>, column by column. For <span class="math">\\mathbf{y}_{A}</span>, instead of generating the entire stream of <span class="math">\\mathbf{y}_{A}</span> for each <span class="math">i</span>, which would cost <span class="math">O(N^{2})</span> field operations in total, the prover generates elements of <span class="math">\\mathbf{y}_{A}</span> on the fly, at a cost <span class="math">O(\\log N)</span> operations per element. Since <span class="math">A</span> has <span class="math">M</span> non-zero entries, the stream of <span class="math">\\mathbf{a}^{</em>}</span> costs <span class="math">O(M\\log N)</span> operations to compute. The scalar product protocol requires <span class="math">O(\\log N)</span> passes over the stream, and the prover runs in <span class="math">O(M\\log^{2}N)</span> time.</p>

    <p class="text-gray-300">Combining this with the space-efficient realizations of the scalar-product and tensor-product subprotocols, which require <span class="math">O(\\log N)</span> passes over their inputs, we obtain a space-efficient prover algorithm which runs in <span class="math">O(M\\log^{2}N)</span> time and <span class="math">O(\\log N)</span> space.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">2.6 Elastic holographic PIOP for R1CS</h3>

    <p class="text-gray-300">The verifier complexity in the non-holographic PIOP for R1CS described in Section 2.5 is linear in the size of the R1CS instance. To run a scalar-product protocol to check Equation 5, the verifier must compute <span class="math">\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{*}</span> via expensive matrix-vector multiplications involving all of the non-zero entries of the matrices <span class="math">A,B,C</span>.</p>

    <p class="text-gray-300">Below we describe how to construct a holographic PIOP for R1CS, in which the verifier’s direct access to <span class="math">A,B,C</span> is replaced by query access. In this PIOP, the prover can either run in linear-time and linear-space or quasilinear-time and log-space, while the verifier runs in logarithmic time (and thus logarithmic space).</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem 3 (informal).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span>, there exists an holographic PIOP for <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}</span> with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(M/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(\\log M)</span>;</li>

      <li>proof length <span class="math">O(M)</span> and query complexity <span class="math">O(\\log M)</span>;</li>

      <li>an indexer that runs in time <span class="math">O(M)</span> and space <span class="math">O(M)</span>;</li>

      <li>a time-efficient prover that runs in time <span class="math">O(M)</span> and space <span class="math">O(M)</span>;</li>

      <li>a space-efficient prover that runs in time <span class="math">O(M\\log^{2}M)</span> and space <span class="math">O(\\log M)</span> with <span class="math">O(\\log M)</span> input passes.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- a verifier that runs in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log M)<span class="math"> (and thus space </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log M)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, <span class="math">M</span> is the number of non-zero entries in the R1CS matrices.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">High-level overview.</h4>

    <p class="text-gray-300">Our protocol follows the strategy in <em>[x1]</em>. The main difference between the holographic PIOP here and the non-holographic PIOP in Section 2.5 is that the prover and verifier use an alternative strategy to check Equation 4. The verifier does not compute <span class="math">\\mathbf{a}^{<em>}</span> (respectively, <span class="math">\\mathbf{b}^{</em>},\\mathbf{c}^{<em>}</span>) to check that <span class="math">\\langle\\mathbf{z},\\mathbf{a}^{</em>}\\rangle=u_{A}</span> (same for <span class="math">B,C</span>, cf. Equation 4). Instead, the prover sends additional oracle messages to the verifier, which correspond to partial computations of the scalar product; the verifier checks these via multiple auxiliary subprotocols. The key subprotocols are a look-up protocol and an entry-product protocol.</p>

    <p class="text-gray-300">Our main contribution is a space-efficient realization of these subprotocols, which leads to a space-efficient holographic R1CS protocol. The main challenge is to show that it is possible to generate the prover’s extra messages in a space-efficient manner from R1CS streams (Definition 4.9). This places particular restrictions on the design of a space-efficient look-up protocol, which we explain how to deal with in Section 2.6.1. We explain how to construct a space-efficient entry-product protocol in Section 2.6.2.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Achieving holography.</h4>

    <p class="text-gray-300">For a matrix <span class="math">U\\in\\{A,B,C\\}</span>, consider the vectors <span class="math">\\mathsf{row}_{U}</span>, <span class="math">\\mathsf{col}_{U}</span>, <span class="math">\\mathsf{val}_{U}\\in\\mathbb{F}^{M}</span> such that, for every <span class="math">i\\in[M]</span>, <span class="math">\\mathsf{val}_{U,i}\\in\\mathbb{F}</span> is the <span class="math">(\\mathsf{row}_{U,i},\\mathsf{col}_{U,i})</span>-entry of <span class="math">U</span>, ordered column-major. We assume that the matrices <span class="math">A,B,C</span> have the same support, which means that <span class="math">\\mathsf{row}\\coloneqq\\mathsf{row}_{A}=\\mathsf{row}_{B}=\\mathsf{row}_{C}</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{col}\\coloneqq\\mathsf{col}_{A}=\\mathsf{col}_{B}=\\mathsf{col}_{C}</span>. This can be achieved by suitably padding <span class="math">\\mathsf{val}_{A},\\mathsf{val}_{B},\\mathsf{val}_{C}</span> with zeroes, and increases the length of <span class="math">\\mathsf{row},\\mathsf{col},\\mathsf{val}</span> by at most a factor of <span class="math">3</span>.</p>

    <p class="text-gray-300">The prover constructs the following vectors and sends them to the verifier as oracle messages:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathbf{r}_{A}^{*}\\coloneqq\\mathbf{y}_{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{row}}\\enspace,\\qquad\\mathbf{r}_{B}^{*}\\coloneqq\\mathbf{y}_{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{row}}\\enspace,\\qquad\\mathbf{r}_{C}^{*}\\coloneqq\\mathbf{y}_{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{row}}\\enspace,\\qquad\\mathbf{z}^{*}\\coloneqq\\mathbf{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{col}}\\enspace,$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbf{r}_{A}^{<em>}</span> is the vector whose <span class="math">i</span>-th element is the <span class="math">\\mathsf{row}_{i}</span>-th element of <span class="math">\\mathbf{a}^{</em>}</span>, and similarly for <span class="math">\\mathbf{r}_{B}^{<em>},\\mathbf{r}_{C}^{</em>},\\mathbf{z}^{*}</span>. That is, $\\mathbf{y}_{A}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{row}}\\coloneqq(\\mathbf{y}_{A,i})_{i\\in\\mathsf{row}}<span class="math">. One proceeds similarly for </span>\\mathbf{r}_{B}^{<em>},\\mathbf{r}_{C}^{</em>}$. Using Equation 8, Equation 3 can be reformulated as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{r}_{A}^{<em>}\\circ\\mathsf{val}_{A},\\ \\mathbf{z}^{</em>}\\rangle</span> <span class="math">=u_{A}\\enspace,</span> (9) <span class="math">\\langle\\mathbf{r}_{B}^{<em>}\\circ\\mathsf{val}_{B},\\ \\mathbf{z}^{</em>}\\rangle</span> <span class="math">=u_{B}\\enspace,</span> <span class="math">\\langle\\mathbf{r}_{C}^{<em>}\\circ\\mathsf{val}_{C},\\ \\mathbf{z}^{</em>}\\rangle</span> <span class="math">=u_{C}\\enspace.</span></p>

    <p class="text-gray-300">Then, the verifier must check the three claims of Equation 9, and that <span class="math">\\mathbf{r}_{A}^{<em>},\\mathbf{r}_{B}^{</em>},\\mathbf{r}_{C}^{<em>},\\mathbf{z}^{</em>}</span> were correctly computed. The prover and verifier run a twisted scalar-product protocol for the three claims. To check that <span class="math">\\mathbf{r}_{A}^{<em>}</span>, <span class="math">\\mathbf{r}_{B}^{</em>}</span>, <span class="math">\\mathbf{r}_{C}^{<em>}</span> and <span class="math">\\mathbf{z}^{</em>}</span> were correctly computed, the prover and verifier run a look-up protocol, which we describe in more detail in Section 2.6.1.</p>

    <p class="text-gray-300">Elastic realization. The twisted scalar-product protocol and look-up protocol are elastic protocols with both time and space-efficient prover realization, and a succinct verifier. Our holographic PIOP for R1CS inherits a time-efficient prover and succinct verifier from these subprotocols. However, to give a space-efficient prover realization, we must show that the prover can produce streams of <span class="math">\\mathbf{r}_{A}^{<em>}</span>, <span class="math">\\mathbf{r}_{B}^{</em>}</span>, <span class="math">\\mathbf{r}_{C}^{*}</span>, using input R1CS streams and the verifier challenges. The R1CS streams <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(A)</span>, <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(B)</span> and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(C)</span> of the matrices <span class="math">A,B</span> and <span class="math">C</span> produce elements of the form <span class="math">(i,j,e)\\in[N]\\times[N]\\times\\mathbb{F}</span>. Streaming only the first element of the triple produces the stream <span class="math">\\mathcal{S}_{\\mathrm{cmaj.row}}(A)=\\mathcal{S}_{\\mathrm{cmaj.row}}(B)=\\mathcal{S}_{\\mathrm{cmaj.row}}(C)</span> of the vector <span class="math">\\mathsf{row}</span> (we recall that we assumed the support of <span class="math">A,B,C</span> to be the same, and that <span class="math">\\mathsf{row}</span> is ordered column-major).</p>

    <p class="text-gray-300">Similarly, the second element of the triple induces a stream <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(A)</span> of the vector <span class="math">\\mathsf{col}</span>, which is also equal to <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(B)</span> and <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(C)</span>, again since the support is the same. Additionally, <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(A)</span> is non-increasing: the column indices, in the dense representation of the matrix, are sorted in decreasing order when streamed column-major. As a result, the entries of <span class="math">\\mathbf{z}^{*}</span> can be produced one by one in <span class="math">O(1)</span> space from streams <span class="math">\\mathcal{S}(\\mathbf{z})</span> and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(A)</span>: examine each entry of <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(A)</span>, advance forwards <span class="math">\\mathbf{z}</span> if the column changed, and output that same entry as long as the next element of <span class="math">\\mathcal{S}_{\\mathrm{cmaj.col}}(A)</span> stays unchanged.</p>

    <p class="text-gray-300">The streams <span class="math">\\mathcal{S}_{\\mathrm{cmaj.val}}(A)</span> (respectively, <span class="math">\\mathcal{S}_{\\mathrm{cmaj.val}}(B)</span> and <span class="math">\\mathcal{S}_{\\mathrm{cmaj.val}}(C)</span>) are defined by projecting onto the third element of the streams <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(A)</span> (respectively, <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(B)</span> and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(C)</span>), and produce the streams for the vectors <span class="math">\\mathsf{val}_{A}</span>, <span class="math">\\mathsf{val}_{B}</span>, and <span class="math">\\mathsf{val}_{C}</span> in column-major order.</p>

    <p class="text-gray-300">For <span class="math">\\mathbf{r}_{A}^{<em>}</span>, <span class="math">\\mathbf{r}_{B}^{</em>}</span> and <span class="math">\\mathbf{r}_{C}^{<em>}</span>, recall that <span class="math">\\mathbf{y}_{B}=\\otimes_{j}(1,\\rho_{j})</span>, <span class="math">\\mathbf{y}_{C}=\\otimes_{j}(1,\\upsilon^{\\mathsf{\\mathfrak{a}}^{j}})</span>, and <span class="math">\\mathbf{y}_{A}=\\mathbf{y}_{B}\\circ\\mathbf{y}_{C}=\\otimes_{j}(1,\\rho_{j}\\upsilon^{\\mathsf{\\mathfrak{a}}^{j}})</span>. Thus, any entry of <span class="math">\\mathbf{r}_{B}^{</em>}</span> or <span class="math">\\mathbf{r}_{C}^{<em>}</span> (and hence <span class="math">\\mathbf{r}_{A}^{</em>}</span>) can be computed in <span class="math">O(\\log N)</span> operations from <span class="math">\\upsilon\\in\\mathbb{F}^{\\times}</span> and <span class="math">\\rho_{0},\\ldots,\\rho_{n-1}\\in\\mathbb{F}^{\\times}</span>.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">2.6.1 Lookup protocol</h4>

    <p class="text-gray-300">Lookup protocols enable the prover to convince the verifier that all of the entries in a vector <span class="math">\\mathbf{g}^{<em>}\\in\\mathbb{F}^{M}</span> appear as entries of another vector <span class="math">\\mathbf{g}\\in\\mathbb{F}^{N}</span> according to the data stored in the </em>address vector* <span class="math">\\mathsf{addr}\\in[N]^{M}</span>, i.e.:</p>

    <p class="text-gray-300"><span class="math">\\{(\\mathbf{g}_{i}^{*},\\mathsf{addr}_{i})\\}_{i\\in[M]}\\subseteq\\{(\\mathbf{g}_{j},j)\\}_{j\\in[N]}\\enspace.</span></p>

    <p class="text-gray-300">We denote this condition by “<span class="math">(\\mathbf{g}^{<em>},\\mathsf{addr})\\subseteq(\\mathbf{g},[N])</span>”. In order to verify that <span class="math">\\mathbf{r}_{U}^{</em>}</span> and <span class="math">\\mathbf{z}^{*}</span> were correctly computed, the verifier must check four lookup relations:</p>

    <p class="text-gray-300"><span class="math">(\\mathbf{r}_{A}^{<em>},\\mathsf{row})\\subseteq(\\mathbf{y}_{A},[N])</span> , (10) <span class="math">(\\mathbf{r}_{B}^{</em>},\\mathsf{row})\\subseteq(\\mathbf{y}_{B},[N])</span> , <span class="math">(\\mathbf{r}_{C}^{<em>},\\mathsf{row})\\subseteq(\\mathbf{y}_{C},[N])</span> , <span class="math">(\\mathbf{z}^{</em>},\\mathsf{col})\\subseteq(\\mathbf{z},[N])</span> .</p>

    <p class="text-gray-300">Note that <span class="math">\\mathbf{y}_{A}=\\mathbf{y}_{B}\\circ\\mathbf{y}_{C}</span>, and <span class="math">\\mathbf{r}_{A}^{<em>}</span>, <span class="math">\\mathbf{r}_{B}^{</em>}</span>, <span class="math">\\mathbf{r}_{C}^{<em>}</span> come from looking up the entries of <span class="math">\\mathbf{y}_{A}</span>, <span class="math">\\mathbf{y}_{B}</span> and <span class="math">\\mathbf{y}_{C}</span> at the indices specified by row. Therefore, instead of checking that <span class="math">(\\mathbf{r}_{A}^{</em>},\\mathsf{row})\\subseteq(\\mathbf{y}_{A},[N])</span>, it suffices to check the Hadamard product relation <span class="math">\\mathbf{y}_{A}=\\mathbf{y}_{B}\\circ\\mathbf{y}_{C}</span>. This can be done using an extension of the twisted scalar product protocol. This leaves four look-up relations to check.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Polynomial identities for look-up relations.</h4>

    <p class="text-gray-300">To verify look-up relations, we use the polynomial identity from <em>[x10]</em> and construct a PIOP to verify it via an approach similar to <em>[x3]</em>.</p>

    <p class="text-gray-300">We reduce the lookup conditions <span class="math">(\\mathbf{r}_{U}^{<em>},\\mathsf{row})\\subseteq(\\mathbf{y}_{U},[N])</span> and <span class="math">(\\mathbf{z}^{</em>},\\mathsf{col})\\subseteq(\\mathbf{z},[N])</span> to simpler inclusion conditions such as <span class="math">\\mathbf{f}^{<em>}\\subseteq\\mathbf{f}</span>, where each entry in the vector <span class="math">\\mathbf{f}^{</em>}</span> equals some entry in the vector <span class="math">\\mathbf{f}</span>. To do so, for each matrix <span class="math">U\\in\\{A,B,C\\}</span>, we <em>algebraically hash</em> the pairs <span class="math">(\\mathbf{z}^{<em>},\\mathsf{col}),(\\mathbf{z},[N]),(\\mathbf{r}_{U}^{</em>},\\mathsf{row}),(\\mathbf{y}_{U},[N])</span> into vectors <span class="math">\\mathbf{z}^{*}+\\eta\\cdot\\mathsf{col}</span> (and similarly for the other pairs) in parallel, by taking a random linear combination of each pair using the same random challenge <span class="math">\\eta\\in\\mathbb{F}^{\\times}</span> from the verifier. Let <span class="math">\\mathsf{sort}(\\mathbf{g},\\mathbf{f})</span> denote the function that sorts the entries of <span class="math">\\mathbf{g}\\parallel\\mathbf{f}</span> according to order of appearance in <span class="math">\\mathbf{f}</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Lemma 2.13 (<em>[x10, Claim 3.1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{f}^{<em>}\\in\\mathbb{F}^{M}</span> and <span class="math">\\mathbf{f}\\in\\mathbb{F}^{N}</span>. Then <span class="math">\\mathbf{f}^{</em>}\\subseteq\\mathbf{f}</span> if and only if there exists a witness <span class="math">\\mathbf{w}\\in\\mathbb{F}^{M+N}</span> such that the equation below in <span class="math">\\mathbb{F}[Y,Z]</span> is satisfied:</p>

    <p class="text-gray-300"><span class="math">\\prod_{j=0}^{M+N-1}\\left(Y(1+Z)+w_{j+1}+w_{j}\\cdot Z\\right)=\\left(1+Z\\right)^{M}\\prod_{j=0}^{M-1}\\left(Y+f_{j}\\right)\\prod_{j=0}^{N-1}\\left(Y(1+Z)+f_{j+1}+f_{j}\\cdot Z\\right)</span> (11)</p>

    <p class="text-gray-300">where indices are taken (respectively) modulo <span class="math">M+N</span>, <span class="math">N</span>. If <span class="math">\\mathbf{f}^{<em>}\\subseteq\\mathbf{f}</span> then <span class="math">\\mathbf{w}\\coloneqq\\mathsf{sort}(\\mathbf{f}^{</em>},\\mathbf{f})</span> is a valid witness.</p>

    <p class="text-gray-300">The strategy in the look-up protocol is for the prover to compute <span class="math">\\mathbf{w}</span> and prove that Equation 11 is satisfied, for every look-up relation that needs to be checked. The prover computes <span class="math">\\mathbf{w}</span> and sends it to the verifier. Then, the verifier sends random challenges <span class="math">\\upsilon,\\zeta\\in\\mathbb{F}^{\\times}</span> to the prover, who computes each of the three product expressions in Equation 11, evaluated at <span class="math">\\upsilon</span> and <span class="math">\\zeta</span>:</p>

    <p class="text-gray-300"><span class="math">e_{0}=\\prod_{i=0}^{M+N-1}\\left(\\upsilon(1+\\zeta)+w_{i+1\\bmod M+N}+w_{i}\\cdot\\zeta\\right),</span> (12) <span class="math">e_{1}=\\prod_{i=0}^{M-1}(\\upsilon+f_{i}^{*}),</span> <span class="math">e_{2}=\\prod_{i=0}^{N-1}\\left(\\upsilon(1+\\zeta)+f_{i+1\\bmod N}+f_{i}\\cdot\\zeta\\right)\\ .</span></p>

    <p class="text-gray-300">The prover then sends the three product values <span class="math">e_{0},e_{1},e_{2}</span> to the verifier. The verifier checks that Equation 11 holds at <span class="math">\\upsilon</span> and <span class="math">\\zeta</span> by checking that <span class="math">e_{0}=(1+\\zeta)^{M}e_{1}e_{2}</span>, and uses three <em>entry-product</em> subprotocols, which we describe in Section 2.6.2, to check that <span class="math">e_{0},e_{1},e_{2}</span> were correctly computed from <span class="math">\\mathbf{f}^{*}</span>, <span class="math">\\mathbf{f}</span>, and <span class="math">\\mathbf{w}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">This approach requires polynomial query access to  <span class="math">\\mathbf{f}_{\\odot}^{<em>}</span> , the cyclic right-shift of  <span class="math">\\mathbf{f}^{</em>}</span> , since the inputs to the entry product protocols depend on  <span class="math">\\mathbf{f}_{\\odot}^{<em>}</span> . The look-up protocol in [BCG20] uses a shift subprotocol to check this condition. By contrast, we avoid this additional step by considering instead the lookup protocol over vectors with a leading zero coefficient. Queries on the right-shift  <span class="math">\\mathbf{f}_{\\odot}^{</em>}</span>  can be related to queries on  <span class="math">\\mathbf{f}^{*}</span>  with a single evaluation query, since the leading coefficient is known in advance. We explain this optimization in Section 8.</p>

    <p class="text-gray-300">Elastic realization. As shown in prior work [BCG20], if the underlying entry product protocols have a linear-time prover realization and succinct verifier, then the same is true for the look-up protocol. We focus on explaining a space-efficient prover realization of the look-up protocol. Assuming that the entry-product protocol has a suitable space-efficient realization, it suffices to explain how to realize streaming access to look-up protocol vectors  <span class="math">\\mathbf{f}^*, \\mathbf{f}, \\mathbf{w}</span>  using previously derived streams.</p>

    <p class="text-gray-300">First we consider  <span class="math">(\\mathbf{z}^{<em>},\\mathsf{col})</span>  and  <span class="math">(\\mathbf{z},[N])</span> . Each pair is algebraically hashed into vectors  <span class="math">\\mathbf{f}^</em></span>  and  <span class="math">\\mathbf{f}</span> . One can produce the streams  <span class="math">S(\\mathbf{f}^{<em>})</span>  and  <span class="math">S(\\mathbf{f})</span>  from the streams  <span class="math">S(\\mathbf{z}^{</em>}), S_{\\mathrm{cmaj.col}}(A), S(\\mathbf{z}), S([N])</span> , by applying the same algebraic hash function to pairs of entries on-the-fly. The same applies to input pairs  <span class="math">(\\mathbf{r}_U^*,\\mathsf{row})</span>  and  <span class="math">(\\mathbf{y}_U,[N])</span> .</p>

    <p class="text-gray-300">Next we explain how to generate a stream of  <span class="math">\\mathbf{w} = \\mathrm{sort}(\\mathbf{f}^<em>,\\mathbf{f})</span>  using small space. This is more challenging because storing the entire vectors  <span class="math">\\mathbf{f}^</em></span>  and  <span class="math">\\mathbf{f}</span>  and sorting them requires space  <span class="math">O(M + N)</span> . In the case of inputs  <span class="math">(\\mathbf{z}^<em>,\\mathsf{col})</span>  and  <span class="math">(\\mathbf{z},[N])</span> , as  <span class="math">\\mathsf{col}</span>  is a non-decreasing sequence, it turns out that  <span class="math">S_{\\mathrm{cmaj.col}}(A)</span>  is already sorted into a suitable order, and it suffices to merge the streams of  <span class="math">\\mathbf{f}^</em></span>  and  <span class="math">\\mathbf{f}</span>  together to produce a stream for  <span class="math">\\mathbf{w}</span> . The same is not true for row, which is not necessarily ordered. However, the vector row in non-decreasing form is already available from the inputs: it can be constructed from  <span class="math">S_{\\mathrm{rmaj}}(A)</span> , the sparse representation of the matrix in row-major order. To apply the same idea to input pairs  <span class="math">\\mathbf{r}_U^*</span>  and row, we build  <span class="math">S_{\\mathrm{rmaj.row}}(A)</span> , which is non-decreasing, and use it to produce the stream of the sorted vector for the lookup protocol. We describe our look-up protocol in more detail in Section 8.2.1.</p>

    <p class="text-gray-300">On alternative proof techniques for look-up relations. Prior work such as [Set20] checks look-up relations using an offline memory-checking [BEGKN91; CDDGS03] abstraction in which the prover shows that  <span class="math">\\mathbf{g}^<em></span>  was correctly constructed entry by entry from  <span class="math">\\mathbf{g}</span>  using read and write operations. This leads to an alternative polynomial identity replacing Equation 25, which uses a list of timestamps recording when a particular element of  <span class="math">\\mathbf{g}^</em></span>  is read from  <span class="math">\\mathbf{g}</span> . In this case though, it is unclear how to generate the timestamps required by this method without storing linear memory. While in [GW20] the polynomial relation is independent from the ordering of the matrix (row-major or column-major), the memory-checking approach requires random access to the vector row in order to access the last visited timestamps, which cannot be done in small space.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{f} = (f_0, \\ldots, f_{N-1}) \\in \\mathbb{F}^N</span>  such that  <span class="math">e = f_0 \\cdots f_{N-1}</span> . We describe an entry-product protocol, building on [BCG20, Sec. 6.4], that reduces an entry product statement  <span class="math">\\prod_i f_i = e</span>  to a single scalar-product relation, using polynomial evaluation query access to  <span class="math">\\mathbf{f}</span> .</p>

    <p class="text-gray-300">Compared with the prior work, our work exploits the structure of univariate polynomials to simplify the scheme and remove the need for cyclic-shift tests [BCG20, Sec. 6.3]. We propose additional optimizations in Section 2.7 which improve the concrete efficiency of our protocol.</p>

    <p class="text-gray-300">High-level overview. Let  <span class="math">\\mathbf{f}</span>  be as above, with  <span class="math">f_{N - 1} = 1</span> . Let  <span class="math">\\psi \\in \\mathbb{F}^{\\times}</span>  and let  <span class="math">\\mathbf{y}&#x27; = (1,\\psi ,\\dots ,\\psi^{N - 1})</span> . Let</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}</span> be the vector of partial products of the entries of <span class="math">\\mathbf{f}</span>, that is:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{g}\\coloneqq(\\prod_{i\\geq 0}f_{i},\\ \\ \\prod_{i\\geq 1}f_{i},\\ \\ \\ldots,\\ \\ f_{N-2}f_{N-1},\\ \\ f_{N-1})</span> (13)</p>

    <p class="text-gray-300">Then, observe that:</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{g}\\circ\\mathbf{y}^{\\prime},\\mathbf{f}_{\\circlearrowright}\\rangle</span> <span class="math">=\\sum_{i=1}^{N-1}g_{i}f_{i-1}\\psi^{i}+g_{0}f_{N-1}</span> (14) <span class="math">=\\sum_{i=1}^{N-1}g_{i-1}\\psi^{i}+e+g_{N-1}\\psi^{N}-g_{N-1}\\psi^{N}</span> <span class="math">=\\psi\\mathbf{g}(\\psi)+e-\\psi^{N}\\enspace.</span></p>

    <p class="text-gray-300">In the entry product protocol, the prover sends the oracle <span class="math">\\mathbf{g}</span> to the verifier, and the verifier replies with the random challenge <span class="math">\\psi\\in\\mathbb{F}^{\\times}</span>, and makes a polynomial evaluation query <span class="math">\\mathbf{g}(\\psi)=v</span>. Then, both parties engage in a twisted scalar product protocol to verify Equation 14. Polynomial evaluation queries <span class="math">\\mathbf{f}_{\\circlearrowright}(x)</span> for <span class="math">x\\in\\mathbb{F}</span> made as part of the twisted scalar-product protocol can be computed using evaluation queries <span class="math">\\mathbf{f}(x)</span>. To do this, note that <span class="math">\\mathbf{f}_{\\circlearrowright}(x)=x\\mathbf{f}(x)-x^{N}+1</span> since <span class="math">f_{N-1}=1</span>; thus the verifier can compute <span class="math">\\mathbf{f}_{\\circlearrowright}(x)</span> from <span class="math">\\mathbf{f}(x)</span> in <span class="math">O(\\log N)</span> operations. We give a formal description of the entry product protocol in Section 8.3.</p>

    <p class="text-gray-300">Elastic realization. As with other subprotocols, the entry-product protocol inherits a linear-time prover realization and succinct verifier from the underlying twisted scalar-product protocol.</p>

    <p class="text-gray-300">To give a space-efficient realization, it suffices to show that <span class="math">\\mathbf{g}</span> can be generated element-by-element given access to the stream <span class="math">\\mathcal{S}(\\mathbf{f})</span>: the partial products of elements of <span class="math">\\mathbf{f}</span> can be produced by streaming each successive element of <span class="math">\\mathcal{S}(\\mathbf{f})</span> and multiplying it into a running product. Note that the partial products in <span class="math">\\mathbf{g}</span> are computed from the last entry to the first, starting with <span class="math">f_{N-1}</span>. This is because streams of polynomials move from the highest-order coefficient to the lowest to be compatible with space-efficient commitment algorithms, as explained in Section 2.3.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">2.7 Implementation and optimizations</h3>

    <p class="text-gray-300">We implemented the elastic SNARKs from Sections 2.5 and 2.6 by leveraging and extending arkworks [ark], a Rust ecosystem for developing and programming with zk-SNARKs. Our implementation is called ark-gemini, and is open-sourced as part of arkworks. The code structure follows the modular design of our construction, which involves combining an elastic polynomial commitment scheme and an elastic PIOP. We deem each of the components of our implementation (the streaming infrastructure, the commitment scheme, and the subprotocols for sumcheck, tensor check, entry product, and lookup) to be of independent interest for future work on space-efficient SNARKs. Below, we provide an overview of the streaming infrastructure and the algorithmic optimizations that we adopted in the implementation.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">2.7.1 Streaming infrastructure</h4>

    <p class="text-gray-300">We extend the arkworks framework with support for streams in order to express space-efficient protocols. A stream is a wrapper over iter::Iterator, the Rust interface for iterators. Streams can be restarted and iterated over multiple times. We use Rust’s borrow abstractions to produce streams that avoid copying elements whenever possible: a stream either returns a field element, or a reference to a field element. In other words, we have a zero-copy interface where data structures do not require to be copied from memory, unless really needed. In practice, input streams can be instantiated with arrays (e.g., memory-mapped files) or a</p>

    <p class="text-gray-300">concurrent data stream downloaded from the web, but could be potentially extended to new inputs. Streams can be composed.</p>

    <p class="text-gray-300">Baum, Malozemoff, Rosen, and Scholl <em>[x1]</em> also study streaming provers, and provide a Rust implementation relying on asynchronous programming features of Rust. Rust’s asynchronous streams are also iterators, and thus our approach can be seen as a generalization of their framework.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">2.7.2 Optimizations</h4>

    <p class="text-gray-300">We leverage several algorithmic optimizations that improve the concrete performance of our scheme.</p>

    <p class="text-gray-300">Elastic provers. Our elastic SNARK allows switching from the space-efficient implementation to the time-efficient implementation with specified memory threshold. For example, in the scalar product, if the prover has enough memory, then it can transcribe the intermediate prover state and proceed with the time-efficient implementation of the prover function. This allows for a more fine-grained control of the space complexity of the prover, and to benefit from the speed-up of the time-efficient prover for the last few rounds of the protocol. Since the prover’s messages are the same in both modes, this switch does not affect the end result.</p>

    <p class="text-gray-300">Batch tensor-product protocols. As discussed in Section 2.4.2, we use a tensor product protocol to check the multivariate evaluation claims resulting from the sumcheck protocol. In our holographic PIOP, we batch multiple tensor product claims in parallel using the same randomness. Moreover, the polynomials in each round can be batched into a single polynomial commitment per round of the tensor product protocol.</p>

    <p class="text-gray-300">Batch <em>[x12]</em> for multiple points and polynomials. Boneh et al. <em>[x2]</em> proposed an optimization of <em>[x12]</em> to batch evaluation proofs for a set of evaluation points over different polynomials, exploiting the structure of univariate polynomials. We adapt and implement these optimizations to our elastic polynomial commitment scheme. In particular, while our tensor product protocol requires the verifier to query different polynomials at different evaluation points, evaluation proofs are batched into a single group element. This makes the concrete size of the evaluation proof smaller than for multi-linear approaches such as <em>[x17, x18]</em>, which require a logarithmic-size evaluation proof. We elaborate on this in Section 9.</p>

    <p class="text-gray-300">Offline memory-checking. As discussed in Section 2.6.1, the offline memory-checking protocol is not compatible with space efficiency, because the computation of timestamps (in general) requires random-access over the sparse representation of the R1CS matrices <span class="math">A,B,C</span>. Nevertheless, we observe that in the particular implementation of our protocol, the offline memory checking can be used to prove the lookup for <span class="math">(\\mathbf{z}_{U}^{\\star},\\mathsf{col}_{U})\\subseteq(\\mathbf{z},[N])</span>. We view the offline memory-checking as an optimization because it is concretely more efficient than the plookup protocol. That is because the sender in the plookup protocol must send additional commitments to the verifier; whereas, the commitments in the offline memory-checking can be precomputed by the indexer. We elaborate on this in Section 8.2.2.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">2.8 Evaluation</h3>

    <p class="text-gray-300">We run extensive benchmarks for Gemini (both preprocessing and non-preprocessing SNARKs), over an Amazon AWS EC2 <code>c5.9xlarge</code> instance, with 36 cores. We use the Rust library <code>rayon</code> for multi-threading, and use parallelism for multi-scalar multiplications and for the batched sumcheck in the preprocessing SNARK (multiple sumcheck instances are run in parallel). We select BLS12-381 as the underlying pairing-friendly elliptic curve, but note that we do not rely on the smoothness of this curve’s prime field (see Remark 2.7).</p>

    <p class="text-gray-300">We benchmark instance sizes <span class="math">N</span> from <span class="math">2^{18}</span> to <span class="math">2^{35}</span> (with <span class="math">M=N</span>). These sizes are much larger than what is commonly reported in the literature, and showcase the behavior of our SNARK over very large instances.</p>

    <p class="text-gray-300">Proving space. Gemini supports proving instances of arbitrary sizes. Figure 2 shows that memory usage remains constant as instance size increases: it is below 1GB memory for the non-preprocessing SNARK, and slightly more than 1GB for the preprocessing SNARK. Two main parameters affect memory usage.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The memory budget allocated for multi-scalar multiplication (MSM). Algorithms for MSM (e.g., Pippenger’s algorithm) achieve improved time efficiency at the expense of large space usage (linear in the number of scalar multiplications), which precludes an elastic implementation. In practice, to maintain space efficiency, it is useful to allocate a constant-size buffer, and apply the MSM algorithm over chunks of the inputs, accumulating the final result. We set the buffer to be of size <span class="math">2^{20}</span>.</li>

      <li>The sumcheck round threshold, after which the elastic prover transcribes the sumcheck intermediate state and proceeds with the time-efficient algorithm. We set the threshold to <span class="math">22</span>: the last 22 rounds of the sumcheck protocol are performed with the time-efficient prover.</li>

    </ul>

    <p class="text-gray-300">The memory usage is obtained reading the value of resident data and stack memory at regular intervals of 10 seconds on /proc/[pid]/statm.</p>

    <p class="text-gray-300">The overall memory consumption appears constant, suggesting that the above parameters dominate the logarithmic factor in space complexity. The difference in memory consumption between the two SNARKs is explained by the batch sumcheck (used solely in the preprocessing SNARK), where multiple instances are transcribed in memory at the same time.</p>

    <p class="text-gray-300">Our benchmarks stop at <span class="math">2^{35}</span> for the non-preprocessing SNARK and the <span class="math">2^{32}</span> for the preprocessing one, but the upper limit in our benchmarks is arbitrary: as long as it is possible to generate the input streams for the time prover, then prover can terminate while keeping memory usage small. Prior work on preprocessing SNARKs for R1CS provide benchmarks for sizes up to <span class="math">2^{20}</span>. When running benchmarks ourselves to compare our work with previous literature such as Marlin, we were unable to proceed beyond size <span class="math">2^{24}</span> due to out of memory crashes. This is due to the kernel’s OOM (Out Of Memory) Killer process that intervenes forbidding new allocations and terminating the prover before the end of its execution.</p>

    <p class="text-gray-300">Proving time. The elastic prover switches to the time-efficient mode if the intermediate state fits within the memory budget. In particular, when the instance size is small enough, the elastic prover runs in the time-efficient mode only. The most time expensive operations in the protocol are the cryptographic operations, namely the multi-scalar multiplications. For this reason, in Figure 2, where we show the running times for for different values of <span class="math">N</span>, with <span class="math">M=N</span>, it is possible to observe a graph that evolves almost linearly. The squared logarithmic factor does not influence noticeably the overall runtime (as far as we were able to measure within the window of instance sizes of our benchmarks).</p>

    <p class="text-gray-300">Proving cost in dollars. The preprocessing SNARK prover spends about <span class="math">7.6\\times 10^{-5}</span> seconds per gate. Using the AWS estimator (on-demand hourly cost <span class="math">1.836</span> USD obtained from https://calculator.aws), we conclude that the cost for the preprocessing SNARK is about <span class="math">2.30\\times 10^{-5}</span> USD per gate. In particular, the estimated cost for instance size <span class="math">2^{31}</span> is <span class="math">89</span> USD. In contrast, for this instance size, DIZK [WZCPS18] incurs a much higher cost at around <span class="math">500</span> USD; this is because DIZK runs the prover on 20 more powerful and expensive machines (r3.8xlarge EC2 instances with on-demand hourly cost <span class="math">2.656</span> USD) for about 10 hours. In the case of non-preprocessing SNARK, the cost is lower and around <span class="math">40</span> USD for the size <span class="math">2^{35}</span>.</p>

    <p class="text-gray-300">Proof size and verification time. We measure the proof size and verification time for the preprocessing SNARK. The verifier can cheaply verify proofs for large instances since it does not read the instance (instead,</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: Running time (above) and memory usage (below) for the elastic prover in the preprocessing protocol (blue) and the non-preprocessing protocol (red), for different R1CS sizes with  <span class="math">N = M</span> . The black squares indicate the size for which the time-efficient prover triggers an out-of-memory crash (it uses too much memory).</p>

    <p class="text-gray-300">it uses a short verification key derived from the instance). For instance sizes ranging from  <span class="math">2^{12}</span>  to  <span class="math">2^{35}</span> , the proof size is about  <span class="math">13 - 27\\mathrm{KB}</span>  and the verification time is about  <span class="math">16 - 30\\mathrm{ms}</span> .</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">3.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For integers <span class="math">a</span>, <span class="math">b</span> with <span class="math">a&lt;b</span> integers, let <span class="math">[a,b]</span> denote the set <span class="math">\\{a,\\ldots,b-1\\}</span>; <span class="math">[b]</span> will be used as a shorthand for [0, b]. Let <span class="math">\\log\\colon\\mathbb{N}\\to\\mathbb{Z}</span> denote the base-2 logarithm function, rounded up to the nearest integer. Let <span class="math">\\mathbb{F}</span> be a field; and let <span class="math">\\mathbb{F}^{\\times}</span> denote its invertible elements. For a vector <span class="math">\\mathbf{a}</span> over <span class="math">\\mathbb{F}</span> of length <span class="math">N</span>, let <span class="math">a_{i}</span> denote its <span class="math">i</span>-th entry. Let <span class="math">\\mathbf{a}\\circ\\mathbf{b}</span> denote the Hadamard product of vectors <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span>; <span class="math">\\mathbf{a}\\cdot\\mathbf{b}</span> their dot product and <span class="math">\\mathbf{a}\\otimes\\mathbf{b}</span> their tensor product. We view vectors both as an element of <span class="math">\\mathbb{F}^{N}</span> as well as a polynomial in <span class="math">\\mathbb{F}[X]</span> of degree at most <span class="math">N</span>. Given a vector <span class="math">\\mathbf{a}\\in\\mathbb{F}^{N}</span> and an indexing vector <span class="math">\\operatorname{idx}\\in[N]^{M}</span>, let $\\mathbf{a}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\operatorname{idx}}\\in\\mathbb{F}^{M}<span class="math"> be the vector whose </span>i<span class="math">-th element is </span>a_{\\operatorname{idx}_{i}}<span class="math">. We will occasionally explicitly refer to the polynomial associated with a vector </span>\\mathbf{a}\\in\\mathbb{F}^{N}<span class="math"> using the notation </span>\\mathbf{a}(X)\\in\\mathbb{F}[X]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithms are written in calligraphic math font. We use standard big O notation for asymptotic operations over field elements. We use <span class="math">\\operatorname{negl}(\\lambda)</span> as a shorthand for <span class="math">\\operatorname{negl}(\\lambda)=\\lambda^{-\\omega(1)}</span>. We use <span class="math">O_{\\lambda}</span> to describe big O notation in which <span class="math">\\lambda</span> is considered a constant. This will be useful when describing the cost of cryptographic operations, which depend on a security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">We use <span class="math">\\mathcal{S}(a)</span> to denote the stream of <span class="math">a</span>. This is defined in Page 5 for vectors and matrices, and in Definition 4.9 for R1CS instances.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{v}\\in\\mathbb{F}^{N}</span>. We denote with <span class="math">\\mathbf{v}_{\\odot}\\in\\mathbb{F}^{N}</span> the right rotation, i.e <span class="math">\\mathbf{v}_{\\odot}\\coloneqq(v_{N},v_{1},\\ldots,v_{N-1})</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 3.2 (multilinear polynomials).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{f}\\in\\mathbb{F}^{N}</span>, with <span class="math">N=2^{n}</span>. Write <span class="math">\\widehat{\\mathbf{f}}(X_{0},\\ldots,X_{n-1})</span> for the multilinear polynomial whose coefficients are the entries of <span class="math">\\mathbf{f}</span>, ordered so that <span class="math">\\mathbf{f}_{i_{0}\\ldots i_{n-1}}</span> is the coefficient of <span class="math">X_{0}^{i_{0}}\\cdots X_{n-1}^{i_{n-1}}</span>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 3.3 (odd and even parts).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbf{f}(X)\\in\\mathbb{F}[X]</span>. Let <span class="math">\\mathbf{f}_{e}(X),\\mathbf{f}_{o}(X)\\in\\mathbb{F}[X]</span> be the even and odd parts of <span class="math">\\mathbf{f}(X)</span> i.e. the unique polynomials such that <span class="math">\\mathbf{f}(X)=\\mathbf{f}_{e}(X^{2})+X\\mathbf{f}_{o}(X^{2})</span>.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">3.2 Polynomial IOPs</h3>

    <p class="text-gray-300">A polynomial IOP <em>[x1, x10]</em> over a field family <span class="math">\\mathcal{F}</span> for an indexed relation <span class="math">\\mathcal{R}</span> is specified by a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathsf{IOP}=(\\mathsf{k},o,\\mathsf{d},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{k},o,\\mathsf{d}\\colon\\{0,1\\}^{<em>}\\to\\mathbb{N}</span> are polynomial-time computable functions and <span class="math">\\mathcal{I},\\mathcal{P},\\mathcal{V}</span> are three algorithms known as the </em>indexer<em>, </em>prover<em>, and </em>verifier*. The parameter <span class="math">\\mathsf{k}</span> specifies the number of interaction rounds, <span class="math">o</span> specifies the number of polynomials in each round, and <span class="math">\\mathsf{d}</span> specifies degree bounds on these polynomials.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the offline phase (“0-th round”), the indexer <span class="math">\\mathcal{I}</span> receives as input a field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and an index <span class="math">\\mathfrak{i}</span> for <span class="math">\\mathcal{R}</span>, and outputs <span class="math">o(0)</span> polynomials <span class="math">\\mathbf{p}_{0}^{(0)},\\ldots,\\mathbf{p}_{o(0)-1}^{(0)}\\in\\mathbb{F}[X]</span> of degrees at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,1),\\ldots,\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,0,o(0))<span class="math"> respectively. Note that the offline phase does not depend on any particular instance or witness, and merely considers the task of encoding the given index </span>\\mathfrak{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the online phase, given an instance <span class="math">\\mathbf{x}</span> and witness <span class="math">\\mathbf{w}</span> such that <span class="math">(\\mathfrak{i},\\mathbf{x},\\mathbf{w})\\in\\mathcal{R}</span>, the prover <span class="math">\\mathcal{P}</span> receives <span class="math">(\\mathbb{F},\\mathfrak{i},\\mathbf{x},\\mathbf{w})</span> and the verifier <span class="math">\\mathcal{V}</span> receives <span class="math">(\\mathbb{F},\\mathbf{x})</span> and oracle access to the polynomials output by <span class="math">\\mathcal{I}(\\mathbb{F},\\mathfrak{i})</span>. The prover <span class="math">\\mathcal{P}</span> and the verifier <span class="math">\\mathcal{V}</span> interact over $\\mathsf{k}=\\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathfrak{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">j\\in[\\mathsf{k}]</span>, in the <span class="math">j</span>-th round of interaction, the verifier <span class="math">\\mathcal{V}</span> sends a message <span class="math">\\rho_{j}\\in\\mathbb{F}^{\\times}</span> to the prover <span class="math">\\mathcal{P}</span>; then the prover <span class="math">\\mathcal{P}</span> replies with <span class="math">o(i)</span> oracle polynomials <span class="math">\\mathbf{p}_{0}^{(j)},\\ldots,\\mathbf{p}_{o(j)-1}^{(j)}\\in\\mathbb{F}[X]</span>. The verifier may query any of the polynomials it has received any number of times. A query consists of a location <span class="math">z\\in\\mathbb{F}</span> for an</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">oracle <span class="math">\\mathbf{p}_{i}^{(j)}</span>, and its corresponding answer is <span class="math">\\mathbf{p}_{i}^{(j)}(z)\\in\\mathbb{F}</span>. After the interaction, the verifier accepts or rejects. The function <span class="math">\\mathsf{d}</span> determines which provers to consider for the completeness and soundness properties of the proof system. In more detail, we say that a (possibly malicious) prover <span class="math">\\tilde{\\mathcal{P}}</span> is admissible for <span class="math">\\mathsf{IOP}</span> if, on every interaction with the verifier <span class="math">\\mathcal{V}</span>, it holds that for every round <span class="math">j\\in[\\mathsf{k}]</span> and oracle index <span class="math">i\\in[o(j)]</span> we have $\\deg(\\mathbf{p}_{i}^{(j)})\\leq\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,j,i)<span class="math">. The honest prover </span>\\mathcal{P}$ is required to be admissible under this definition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 3.4 (non-oracle messages).</h6>

    <p class="text-gray-300">We also allow the prover in an IOP to arbitrary messages that the verifier will simply read in full (without making any queries), at any point in the interaction, as in a typical interactive proof. We refer to such messages as <em>non-oracle messages</em>, to differentiate them from the <em>oracle messages</em> to which the verifier has query access. These non-oracle messages can typically be viewed as degenerate cases of oracle messages, and we use them in protocol descriptions for ease of exposition.</p>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{IOP}</span> has perfect completeness and soundness error <span class="math">\\epsilon</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and index-instance-witness tuple <span class="math">(\\dot{\\mathsf{s}},\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}</span>, the probability that <span class="math">\\mathcal{P}(\\mathbb{F},\\dot{\\mathsf{s}},\\mathtt{x},\\mathtt{w})</span> convinces <span class="math">\\mathcal{V}^{\\mathcal{I}(\\mathbb{F},\\dot{\\mathsf{s}})}(\\mathbb{F},\\mathtt{x})</span> to accept in the interactive oracle protocol is <span class="math">1</span>.</li>

      <li>Soundness. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index-instance pair <span class="math">(\\dot{\\mathsf{s}},\\mathtt{x})\\notin\\mathcal{L}(\\mathcal{R})</span>, and admissible prover <span class="math">\\tilde{\\mathcal{P}}</span>, the probability that <span class="math">\\tilde{\\mathcal{P}}</span> convinces <span class="math">\\mathcal{V}^{\\mathcal{I}(\\mathbb{F},\\dot{\\mathsf{s}})}(\\mathbb{F},\\mathtt{x})</span> to accept in the interactive oracle protocol is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The <em>proof length</em> <span class="math">\\mathsf{l}</span> is the sum of all degree bounds in the offline and online phases, $\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\coloneqq\\sum_{j=0}^{\\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-1}\\sum_{i=0}^{o(i)-1}\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,j,i)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <em>query complexity</em> <span class="math">q</span> is the total number of queries made by the verifier to the polynomials. This includes queries to the polynomials output by the indexer and those sent by the prover.</p>

    <p class="text-gray-300">All PIOPs that we construct achieve the stronger property of <em>knowledge soundness</em> (against admissible provers). We define both of these properties below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Knowledge soundness. We say that <span class="math">\\mathsf{IOP}</span> has knowledge error <span class="math">\\epsilon</span> if there exists a probabilistic polynomial-time extractor <span class="math">\\mathbf{E}</span> for which the following holds. For every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, index <span class="math">\\dot{\\mathsf{s}}</span>, instance <span class="math">\\mathtt{x}</span>, and admissible prover <span class="math">\\tilde{\\mathcal{P}}</span>, the probability that $\\mathbf{E}^{\\tilde{\\mathcal{P}}}(\\mathbb{F},\\dot{\\mathsf{s}},\\mathtt{x},1^{\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)})<span class="math"> outputs </span>\\mathtt{w}<span class="math"> such that </span>(\\dot{\\mathsf{s}},\\mathtt{x},\\mathtt{w})\\in\\mathcal{R}<span class="math"> is at least the probability that </span>\\tilde{\\mathcal{P}}<span class="math"> convinces </span>\\mathcal{V}^{\\mathcal{I}(\\mathbb{F},\\dot{\\mathsf{s}})}(\\mathbb{F},\\mathtt{x})<span class="math"> to accept minus </span>\\epsilon<span class="math">. Here the notation </span>\\mathbf{E}^{\\tilde{\\mathcal{P}}}<span class="math"> means that the extractor </span>\\mathbf{E}<span class="math"> has black-box access to each of the next-message functions that define the interactive algorithm </span>\\tilde{\\mathcal{P}}<span class="math">. (In particular, the extractor </span>\\mathbf{E}<span class="math"> can “rewind” the prover </span>\\tilde{\\mathcal{P}}<span class="math">.) Note that since </span>\\mathbf{E}<span class="math"> receives the proof length </span>\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathsf{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in unary, </span>\\mathbf{E}<span class="math"> has enough time to receive, and perform efficient computations on, polynomials output by </span>\\tilde{\\mathcal{P}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Additional properties. All of our PIOP protocols will satisfy the following additional properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li><em>Public coins:</em> <span class="math">\\mathsf{IOP}</span> is <em>public-coin</em> if each verifier message to the prover is a uniformly random string of some prescribed length (or an empty string). Hence the verifier’s randomness is its messages <span class="math">\\rho_{0},\\ldots,\\rho_{\\mathsf{k}-1}\\in\\mathbb{F}^{\\times}</span> and possibly additional randomness <span class="math">\\rho_{\\mathsf{k}}\\in\\mathbb{F}^{\\times}</span> used after the interaction. All verifier queries can be postponed, without loss of generality, to a query phase that occurs after the interactive phase with the prover.</li>

      <li><em>Non-adaptive queries:</em> <span class="math">\\mathsf{IOP}</span> is <em>non-adaptive</em> if all of the verifier’s query locations are solely determined by the verifier’s randomness and inputs (the field <span class="math">\\mathbb{F}</span> and the instance <span class="math">\\mathtt{x}</span>).</li>

    </ul>

    <p class="text-gray-300">Polynomial IOPs of proximity. An <em>polynomial IOP of proximity</em> is similar to a PIOP, with the difference that the verifier <span class="math">\\mathcal{V}</span> has query access to the candidate witness <span class="math">\\mathtt{w}</span> (we assume that <span class="math">\\mathtt{w}</span> can be parsed as a polynomial or polynomials) as well as <span class="math">(\\mathcal{I}(\\mathbb{F},\\dot{\\mathsf{s}}),\\mathbf{p}_{0}^{(0)},\\ldots,\\mathbf{p}_{o(\\mathsf{k})-1}^{(\\mathsf{k}-1)})</span>. Completeness and soundness properties of PIOPPs are defined similarly to those of PIOPs, except that <span class="math">\\mathcal{V}</span> has query access to the polynomials in the witness <span class="math">\\mathtt{w}</span>.</p>

    <p class="text-gray-300">4 Streaming model</p>

    <p class="text-gray-300">We provide a formal model of streams and streaming algorithms.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">A <em>stream</em> is a sequence <span class="math">K\\in\\Sigma^{I}</span>, where <span class="math">\\Sigma</span> is a finite alphabet, and <span class="math">I</span> is a well-ordered set.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Definition 4.2 (streaming oracle).</h6>

    <p class="text-gray-300">Let <span class="math">K</span> be a stream over the alphabet <span class="math">\\Sigma</span> and index <span class="math">I</span>. The <em>streaming oracle</em> <span class="math">\\mathcal{S}(K)</span> of <span class="math">K</span> behaves as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On inputs <span class="math">\\mathsf{start}</span> and a session number <span class="math">L\\in\\mathbb{N}</span>, the oracle creates or resets a counter <span class="math">i_{L}\\in I\\cup\\{\\bot\\}</span> which is initially set to the first element of <span class="math">I</span>.</li>

      <li>On inputs <span class="math">\\mathsf{next}</span> and a session number <span class="math">L\\in\\mathbb{N}</span>, if <span class="math">i_{L}\\in I</span>, then the oracle returns <span class="math">k_{i_{L}}\\in U</span>, and updates <span class="math">i_{L}</span> to the next element of <span class="math">I</span> (or to <span class="math">\\bot</span> if <span class="math">i_{L}</span> is equal to the last element of <span class="math">I</span>). If <span class="math">i_{L}=\\bot</span> then the oracle returns <span class="math">\\bot</span>.</li>

    </ul>

    <h6 id="sec-50" class="text-base font-medium mt-4">Remark 4.3.</h6>

    <p class="text-gray-300">The use of session numbers <span class="math">L</span> allows the same stream to be accessed in different positions by multiple algorithms simultaneously. However, to avoid an unrealistic streaming model in which algorithms have arbitrary random access to streamed data, in this work, no stream will be accessed through more than a logarithmic number of sessions simultaneously.</p>

    <p class="text-gray-300">If <span class="math">v</span> is an array whose elements have a clear ordering in context, then we simply say that <span class="math">A</span> has streaming oracle access to <span class="math">v</span>. We now introduce the streaming algorithm, which has access to streaming oracles in a specific order and produce an output stream.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">4.1 Streaming algorithms</h3>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 4.4 (streaming algorithm).</h6>

    <p class="text-gray-300">We say that <span class="math">A</span> is a streaming algorithm over <span class="math">\\Sigma</span> if <span class="math">A</span> receives no inputs, but has access to various streaming oracles <span class="math">\\mathcal{S}(K_{1}),\\ldots,\\mathcal{S}(K_{l})</span> over some alphabet <span class="math">\\Sigma</span> through <span class="math">\\mathsf{start}</span> and <span class="math">\\mathsf{next}</span> commands. In addition, <span class="math">A</span> produces output upon receiving the command <span class="math">\\mathsf{next}</span>, which takes one element of <span class="math">\\Sigma</span> as input. We write <span class="math">O=A(\\mathcal{S}(K_{1}),\\ldots,\\mathcal{S}(K_{l}))</span> to show that <span class="math">O</span> is the entire output stream of <span class="math">A</span>.</p>

    <p class="text-gray-300">It is possible to compose streaming algorithms so that one stream algorithm has streaming access to the output of another stream algorithm.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 4.5 (composing streaming algorithms).</h6>

    <p class="text-gray-300">Let <span class="math">A</span> and <span class="math">B</span> be streaming algorithms. Suppose that <span class="math">B</span> takes inputs <span class="math">\\mathcal{S}(K_{1}),\\ldots,\\mathcal{S}(K_{l})</span>. We write <span class="math">A(B)</span> when <span class="math">A</span> interacts with <span class="math">B</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>when <span class="math">A</span> sends a <span class="math">\\mathsf{start}</span> command to <span class="math">B</span>, the execution of <span class="math">B</span> is reset, and <span class="math">A</span> also sends <span class="math">\\mathsf{start}</span> commands to each of <span class="math">\\mathcal{S}(K_{1}),\\ldots,\\mathcal{S}(K_{l})</span>;</li>

      <li><span class="math">A</span> forwards any <span class="math">\\mathsf{start}</span> or <span class="math">\\mathsf{next}</span> command from <span class="math">B</span> to the correct streaming oracle, and returns the output to <span class="math">B</span>;</li>

      <li>on input <span class="math">\\mathsf{next}</span>, the execution of <span class="math">B</span> yields the next outputs and returns it to <span class="math">A</span>.</li>

    </ul>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 4.6.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{A}</span> is a streaming algorithm with time complexity <span class="math">t_{\\mathcal{A}}</span>, space complexity <span class="math">s_{\\mathcal{A}}</span>, and <span class="math">k_{\\mathcal{A}}</span> input passes, and <span class="math">\\mathcal{B}</span> is a streaming algorithm with time complexity <span class="math">t_{\\mathcal{B}}</span>, space complexity <span class="math">s_{\\mathcal{B}}</span>, and <span class="math">k_{\\mathcal{B}}</span> input passes, then <span class="math">\\mathcal{A}</span> composed with <span class="math">\\mathcal{B}</span> has time complexity <span class="math">t_{\\mathcal{A}}+k_{\\mathcal{A}}t_{\\mathcal{B}}</span>, space complexity <span class="math">s_{\\mathcal{A}}+s_{\\mathcal{B}}</span>, and <span class="math">k_{\\mathcal{A}}k_{\\mathcal{B}}</span> input passes.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">4.2 Streaming R1CS</p>

    <p class="text-gray-300">We introduce the streaming R1CS model. We begin by recalling the indexed R1CS relation.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 4.7.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> is the set of all triples <span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})=((\\mathbb{F},N,M,A,B,C),\\mathbf{x},\\mathbf{w})</span> where <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">A,B,C</span> are matrices in <span class="math">\\mathbb{F}^{N\\times N}</span> each having at most <span class="math">M</span> non-zero entries, and <span class="math">\\mathbf{z}\\coloneqq(\\mathbf{x},\\mathbf{w})</span> is a vector in <span class="math">\\mathbb{F}^{N}</span> such that <span class="math">A\\mathbf{z}\\circ B\\mathbf{z}=C\\mathbf{z}</span>.</p>

    <p class="text-gray-300">We define a streaming R1CS instance in the terms of the sparse representation of the R1CS matrices <span class="math">A,B</span> and <span class="math">C</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 4.8.</h6>

    <p class="text-gray-300">The stream of <span class="math">U</span> is a pair <span class="math">\\big{(}\\mathcal{S}_{\\mathrm{rmaj}}(U),\\mathcal{S}_{\\mathrm{cmaj}}(U)\\big{)}</span>, where <span class="math">\\mathcal{S}_{\\mathrm{rmaj}}(U)</span> denotes the sequence of elements in the support (row, column, value) ordered in in row major (that is, lexicographic order with row), and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(U)</span> denotes the ordering of the ordering of the same sequence in column major.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 4.9 (streaming R1CS).</h6>

    <p class="text-gray-300">The streams associated with <span class="math">((\\mathbb{F},N,M,A,B,C),\\mathbf{x},\\mathbf{w})</span> consist of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>index streams: streams of the R1CS matrices, in row-major and column-major: <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(A),\\mathcal{S}_{\\mathrm{cmaj}}(A))</span>, <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(B),\\mathcal{S}_{\\mathrm{cmaj}}(B))</span>, <span class="math">(\\mathcal{S}_{\\mathrm{rmaj}}(C),\\mathcal{S}_{\\mathrm{cmaj}}(C))</span>;</li>

      <li>instance stream: stream of the instance vector <span class="math">\\mathcal{S}(\\mathbf{x})</span>;</li>

      <li>witness streams: stream of the witness <span class="math">\\mathcal{S}(\\mathbf{w})</span> and of the computation trace vectors <span class="math">\\mathcal{S}(A\\mathbf{z}),\\mathcal{S}(B\\mathbf{z}),\\mathcal{S}(C\\mathbf{z})</span>. The field description <span class="math">\\mathbb{F}</span>, instance size <span class="math">N</span>, and maximum number <span class="math">M</span> of non-zero entries are explicit inputs.</li>

    </ul>

    <p class="text-gray-300">The streaming R1CS relation naturally captures other models of computation, such as <em>R1CS automata</em>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 4.10 (R1CS automata).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">T\\in\\mathbb{N}</span> be a computation time, and <span class="math">k\\in\\mathbb{N}</span> a computation width. We consider execution traces <span class="math">f\\in(\\mathbb{F}^{k})^{T}</span>. Each state <span class="math">f[t]\\in\\mathbb{F}^{k}</span> represents the state of the computation at time <span class="math">t\\in[T]</span>.</p>

    <p class="text-gray-300">An R1CS automaton is specified by matrices <span class="math">A,B,C\\in\\mathbb{F}^{k\\times 2k}</span> that define constraints between different time steps, and a set of boundary constraints <span class="math">\\mathcal{B}\\subseteq[T]\\times[k]\\times\\mathbb{F}</span>.</p>

    <p class="text-gray-300">An execution trace <span class="math">f</span> is accepted by the automaton if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f</span> satisfies the R1CS time constraints i.e. <span class="math">\\forall t\\in[T]</span>, it holds that <span class="math">Af[t,t+1]\\circ Bf[t,t+1]=Af[t,t+1]</span>;</li>

      <li><span class="math">f</span> satisfies the R1CS boundary conditions i.e. <span class="math">\\forall(t,j,\\alpha)\\in\\mathcal{B}</span> it holds that <span class="math">f[t]_{j}=\\alpha</span>.</li>

    </ul>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 4.11 (automata to streaming R1CS).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathbb{F},k,T,A,B,C,\\mathcal{B})</span> be an R1CS automata instance. Then there is an R1CS instance which verifies the same computation as <span class="math">(\\mathbb{F},k,T,A,B,C,\\mathcal{B})</span>, and whose streams, for the streaming R1CS model, can be produced in time <span class="math">O(k^{2}\\log k)</span> and space <span class="math">O(k^{2})</span>.</p>

    <p class="text-gray-300">Further, the witness streams can be produced from <span class="math">f</span> in <span class="math">O(k^{2})</span> operations per element of <span class="math">\\mathbb{F}^{k}</span>, and using space <span class="math">O(k^{2})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We introduce a tensor-product checking protocol which is used in our constructions. Then we show how to batch multiple tensor-product checks, which leads to better performance than running the basic protocol multiple times.</p>

    <p class="text-gray-300">The tensor-product protocol checks the following relation.</p>

    <p class="text-gray-300">Definition 5.1. The tensor-product relation  <span class="math">\\mathcal{R}_{\\mathrm{TC}}</span>  is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot {\\mathrm {i}}, \\mathrm {x}, \\mathrm {w}) = (\\perp , (\\mathrm {F}, N, \\rho_ {0}, \\dots , \\rho_ {n - 1}, u), \\mathbf {f})</span></div>

    <p class="text-gray-300">where  <span class="math">n = \\log N</span> ,  <span class="math">\\mathbf{f} \\in \\mathbb{F}^N</span> ,  <span class="math">u \\in \\mathbb{F}</span> , and  <span class="math">\\langle \\mathbf{f}, \\otimes_j(1, \\rho_j) \\rangle = u</span> .</p>

    <p class="text-gray-300">Theorem 5.2. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{TC}}</span>  that supports instances over  <span class="math">\\mathbb{F}</span> , with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(1) passes |  |  |  |  |   |</p>

    <p class="text-gray-300">We prove Theorem 5.2 with the following construction.</p>

    <p class="text-gray-300"><strong>Construction 1.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{TC}}</span> . The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\dot{\\mathbf{i}} = \\bot</span> , instance  <span class="math">\\mathbf{x} = (\\mathbb{F}, N, \\rho_0, \\dots, \\rho_{n-1}, u)</span> , and witness  <span class="math">\\mathbf{w} = \\mathbf{f}</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\dot{\\mathbf{i}}</span>  and the instance  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">Write  <span class="math">\\mathbf{f}^{(0)}(X) = \\mathbf{f}(X)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">j \\in [n]</span> , the prover  <span class="math">\\mathcal{P}</span>  computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {f} ^ {(j)} (X) := \\mathbf {f} _ {e} ^ {(j - 1)} (X) + \\rho_ {j - 1} \\cdot \\mathbf {f} _ {e} ^ {(j - 1)} (X).</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{f}^{(j)}(X) = \\mathbf{f}_e^{(j - 1)}(X^2) + X\\mathbf{f}^{(j)}(X^2)_o</span> . The prover sends the oracle messages  <span class="math">\\mathbf{f}^{(1)},\\ldots ,\\mathbf{f}^{(n - 1)}</span>  to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\mathcal{V}</span>  samples a challenge  <span class="math">\\beta \\gets \\mathbb{F}^{\\times}</span>  uniformly at random and makes the following evaluation queries for  <span class="math">j \\in [n]</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e ^ {(j)} := \\mathbf {f} ^ {(j)} (\\beta), \\quad \\check {e} ^ {(j)} := \\mathbf {f} ^ {(j)} (- \\beta), \\quad \\hat {e} ^ {(j)} := \\mathbf {f} ^ {(j + 1)} \\left(\\beta^ {2}\\right), \\tag {15}</span></div>

    <p class="text-gray-300">Skip  <span class="math">\\hat{e}^{(n)}</span>  and artificially set  <span class="math">\\hat{e}^{(n)}\\coloneqq u</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>check that, for all  <span class="math">j \\in [n]</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\hat {e} ^ {(j)} = \\frac {e ^ {(j)} + \\check {e} ^ {(j)}}{2} + \\rho_ {j} \\cdot \\frac {e ^ {(j)} - \\check {e} ^ {(j)}}{2 \\beta}, \\tag {16}</span></div>

    <p class="text-gray-300">Lemma 5.3. Construction 1 has perfect completeness.</p>

    <p class="text-gray-300">Proof. Suppose that <span class="math">\\langle \\mathbf{f},\\otimes_j(1,\\rho_j)\\rangle = u</span>. We argue that the verifier's consistency checks of Equation 16 are satisfied. Firstly, indexing <span class="math">\\mathbf{f}\\in \\mathbb{F}^N</span> by <span class="math">i_0,\\ldots ,i_{n - 1}\\in \\{0,1\\}</span>, one can prove by induction on <span class="math">j</span> that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {f} ^ {(j)} (X) = \\sum_ {i _ {0}, \\dots , i _ {n - 1} \\in \\{0, 1 \\}} \\mathbf {f} ^ {(i _ {0}, \\dots , i _ {n - 1}) _ {2}} \\rho_ {0} ^ {i _ {0}} \\dots \\rho_ {j - 1} ^ {i _ {j - 1}} X ^ {i _ {j} + 2 i _ {j + 1} + \\dots + 2 ^ {n - 1 - j}} i _ {n - 1}</span></div>

    <p class="text-gray-300">for <span class="math">j \\in [n]</span>. This shows that <span class="math">\\mathbf{f}^{(n)}(\\beta) = \\mathbf{f}^{(n)}(-\\beta) = u</span>. By definition of <span class="math">\\mathbf{f}_e^{(j-1)}</span> and <span class="math">\\mathbf{f}_o^{(j-1)}</span> (Definition 3.3), we have <span class="math">\\mathbf{f}^{(j-1)}(X) = \\mathbf{f}_e^{(j-1)}(X^2) + X \\cdot \\mathbf{f}_o^{(j-1)}(X^2)</span> and <span class="math">\\mathbf{f}^{(j)}(X) \\coloneqq \\mathbf{f}_o^{(j-1)}(X) + \\rho_{j-1} \\cdot \\mathbf{f}_e^{(j-1)}(X)</span>. Thus <span class="math">\\mathbf{f}^{(j-1)}(X) + \\mathbf{f}^{(j-1)}(-X) = 2\\mathbf{f}_e^{(j-1)}(X^2)</span> and <span class="math">\\mathbf{f}^{(j-1)}(X) - \\mathbf{f}^{(j-1)}(-X) = 2X\\mathbf{f}_o^{(j-1)}(X^2)</span>. Evaluation at <span class="math">\\beta</span> and taking linear combinations of the last two equations shows that the consistency checks are satisfied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 5.4. Construction 1 has soundness error $\\frac{N - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^{\\times}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Suppose that <span class="math">\\langle \\mathbf{f},\\otimes_j(1,\\rho_j)\\rangle \\neq u</span>. Fix a malicious prover, which determines certain next-message functions <span class="math">\\tilde{\\mathbf{f}}^{(1)}(X),\\ldots ,\\tilde{\\mathbf{f}}^{(n - 1)}(X)</span>, <span class="math">e^{(0)}</span> and <span class="math">\\bar{e}^{(0)}</span>. Set <span class="math">\\tilde{\\mathbf{f}}^{(n)} = e^{(n)} = \\bar{e}^{(n)} = u</span>, noting that <span class="math">\\tilde{\\mathbf{f}}^{(j)}</span> has degree at most <span class="math">N / 2^j</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\langle \\mathbf{f},\\otimes_j(1,\\rho_j)\\rangle \\neq u</span> we must have <span class="math">\\mathbf{f}^{(j)}(X)\\neq \\mathbf{f}_e^{(j - 1)}(X) + \\rho_{j - 1}\\cdot \\mathbf{f}_o^{(j - 1)}(X)</span>, for some <span class="math">j\\in [n]</span>. Let <span class="math">j^{*}</span> be the largest value of <span class="math">j</span> for which this happens. This implies that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {p} (X) := \\mathbf {f} ^ {(j ^ {*})} (X ^ {2}) - \\frac {\\mathbf {f} ^ {(j ^ {*} - 1)} (X) + \\mathbf {f} ^ {(j ^ {*} - 1)} (- X)}{2} - \\rho_ {j ^ {*} - 1} \\frac {\\mathbf {f} ^ {(j - 1)} (X) - \\mathbf {f} ^ {(j ^ {*} - 1)} (- X)}{2 \\beta}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a non-zero polynomial of degree at most <span class="math">2^{n - (j^{<em>} - 1)} - 1</span>. Setting <span class="math">X = Y^{2^{j^{</em>} - 1}}</span>, and evaluating at <span class="math">Y = \\beta</span>, the probability that <span class="math">\\mathbf{p}</span> evaluates to 0 is at most $\\frac{2^n - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. This implies that the verifier check in Equation 16 is satisfied with probability at most </span>\\frac{N - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 5.5. The prover for Construction 1 can be implemented in <span class="math">O(N)</span> operations in <span class="math">\\mathbb{F}</span>, and space complexity <span class="math">O(N)</span>.</p>

    <p class="text-gray-300">Proof. The prover requires <span class="math">O(N / 2^j)</span> space to store <span class="math">\\mathbf{f}^{(j)}(X)</span>, and <span class="math">N / 2^j</span> operations to compute <span class="math">\\mathbf{f}^{(j + 1)}(X)</span> from <span class="math">\\mathbf{f}^{(j)}(X)</span>. Summing up the prover's time complexity at each step gives <span class="math">O(N)</span> operations.</p>

    <p class="text-gray-300">Lemma 5.6. The prover for Construction 1 can be implemented in <span class="math">O(N \\log N)</span> operations in <span class="math">\\mathbb{F}</span>, and space complexity <span class="math">O(\\log N)</span> with <span class="math">O(1)</span> passes over <span class="math">\\mathbf{f}</span>.</p>

    <p class="text-gray-300">Evaluation queries also evaluated simultaneously by the prover after compilation, but we don't see this at our current level of abstraction</p>

    <p class="text-gray-300">Proof. Figure 3 gives an algorithm <span class="math">S_{\\mathrm{fold}}(S(\\mathbf{f}), j, \\rho_0, \\ldots, \\rho_{j-1})</span> for producing streams of <span class="math">S(\\mathbf{f}^{(0)}), \\ldots, S(\\mathbf{f}^{(j)})</span> simultaneously. The indices <span class="math">k</span> of items <span class="math">(k, x)</span> in Stack form an ascending sequence with <span class="math">k \\leq j</span>. Whenever two items <span class="math">(k, x)</span> and <span class="math">(k, x&#x27;)</span> are next to each other at the beginning of the sequence, they are merged using <span class="math">O(1)</span> field operations. The algorithm never adds an item with <span class="math">k = j</span> to the stack, so the stack never contains more than <span class="math">j \\leq \\log N</span> elements. To produce an item with <span class="math">k = j</span> requires passing through and merging together exactly <span class="math">2^j</span> elements of the stream of <span class="math">\\mathbf{f}</span>, and uses <span class="math">2^j</span> operations. Producing all <span class="math">N/2^j</span> elements of <span class="math">S(\\mathbf{f}^{(j)})</span> costs <span class="math">N/2^j \\cdot 2^j = N</span> operations.</p>

    <p class="text-gray-300">To produce the streams <span class="math">S(\\mathbf{f}^{(0)}),\\ldots ,S(\\mathbf{f}^{(n)})</span> requires a single pass over <span class="math">S(\\mathbf{f})</span> and uses <span class="math">O(N)</span> operations.</p>

    <p class="text-gray-300">28</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3: On the left-hand side, the stream for generating the coefficients of all all folded polynomials  <span class="math">\\mathbf{f}^{(0)},\\ldots ,\\mathbf{f}^{(n)}</span>  as a pair composed of the current round number, and the next coefficient. On the right, the stream for generating coefficients of the vector  <span class="math">\\mathbf{f}^{(j)}</span> , given  <span class="math">S(\\mathbf{f})</span>  and  <span class="math">\\rho = (\\rho_0,\\dots ,\\rho_{n - 1})</span>  with  <span class="math">n\\geq j</span> .</p>

    <p class="text-gray-300">We present a protocol for checking  <span class="math">m</span>  instances of  <span class="math">\\mathcal{R}_{\\mathrm{TC}}</span>  at the same time. The new protocol gives a query complexity which depends additively on  <span class="math">m</span>  instead of multiplicatively.</p>

    <p class="text-gray-300">Definition 5.7. The batched tensor-product relation  <span class="math">\\mathcal{R}_{\\mathrm{BTC}}</span>  is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb {i}, \\mathbb {x}, \\mathbb {w}) = \\left(\\perp , (\\mathbb {F}, N, \\rho_ {0}, \\dots , \\rho_ {n - 1}, \\{u _ {i} \\} _ {i = 0} ^ {m - 1}), (\\mathbf {f} _ {0}, \\dots , \\mathbf {f} _ {m - 1})\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">N = 2^n</span> ,  <span class="math">\\mathbf{f}_0, \\ldots, \\mathbf{f}_{m-1} \\in \\mathbb{F}^N</span> ,  <span class="math">u_0, \\ldots, u_{m-1} \\in \\mathbb{F}</span> , and  <span class="math">\\langle \\mathbf{f}_i, \\otimes_j(1, \\rho_j) \\rangle = u_i</span>  for each  <span class="math">i \\in [m]</span> .</p>

    <p class="text-gray-300">Theorem 5.8. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{BTC}}</span>  that supports instances over  <span class="math">\\mathbb{F}</span> , with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(mN) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N(log N+m)) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(mN) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+N/</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log N) passes |  |  |  |  |   |</p>

    <p class="text-gray-300"><strong>Construction 2.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{BTC}}</span> . The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\mathbb{i} = \\bot</span> , instance  <span class="math">\\mathbb{x} = (\\mathbb{F}, N, \\rho_0, \\ldots, \\rho_{n-1}, \\{u_i\\}_{i=0}^{m-1})</span> , and witness  <span class="math">\\mathbb{w} = (\\mathbf{f}_0, \\ldots, \\mathbf{f}_{m-1})</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\mathbb{i}</span>  and the instance  <span class="math">\\mathbb{x}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples random challenge <span class="math">\\zeta \\in \\mathbb{F}^{\\times}</span>.</li>

      <li>The prover <span class="math">\\mathcal{P}</span> computes the polynomial <span class="math">\\mathbf{f}(X) = \\sum_{i=0}^{m-1} \\zeta^i \\mathbf{f}_i(X)</span> and sends it to the verifier.</li>

      <li>The prover and verifier run the tensor-product check with <span class="math">(\\dot{\\mathbf{i}}, \\mathbf{x}, \\mathbf{w}) = \\left( \\bot, (\\mathbb{F}, N, \\rho_0, \\dots, \\rho_{n-1}, \\sum_i u_i \\zeta^i), \\mathbf{f} \\right)</span> and randomness <span class="math">\\beta_0</span> to check that <span class="math">\\langle \\mathbf{f}, \\otimes_j (1, \\rho_j) \\rangle = \\sum_i u_i \\zeta^i</span>.</li>

      <li>The verifier samples randomness <span class="math">\\beta</span> and makes an oracle query to learn <span class="math">\\mathbf{f}(\\beta)</span>. For <span class="math">i = 0, \\dots, m - 1</span>, the verifier makes oracle queries to learn <span class="math">\\mathbf{f}_i(\\beta)</span>. The verifier checks whether <span class="math">\\mathbf{f}(\\beta) = \\sum_{i=0}^{m-1} \\mathbf{f}_i(\\beta) \\zeta^i</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 5.9.</strong> Since the simple tensor-product check requires an evaluation of <span class="math">\\mathbf{f}</span> at a random point, Construction 2 can be optimized so that Construction 1 uses the same randomness <span class="math">\\beta</span> as Construction 2, which saves one evaluation query.</p>

    <p class="text-gray-300"><strong>Lemma 5.10.</strong> Construction 2 has perfect completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Suppose that <span class="math">\\langle \\mathbf{f}_i, \\otimes_j(1, \\rho_j) \\rangle = u_i</span> for each <span class="math">i</span>. By definition, <span class="math">\\mathbf{f} = \\sum_{i=0}^{m-1} \\zeta^i \\mathbf{f}_i</span>. Querying each polynomial in this expression at <span class="math">\\beta</span>, it is clear that the verifier's check is satisfied.</p>

    <p class="text-gray-300">Next, since <span class="math">\\langle \\mathbf{f}_i, \\otimes_j(1, \\rho_j) \\rangle = u_i</span> for each <span class="math">i</span>, taking a linear combination of these expressions using powers of <span class="math">\\zeta</span>, it is clear that <span class="math">\\langle \\mathbf{f}, \\otimes_j(1, \\rho_j) \\rangle = \\sum_i u_i \\zeta^i</span>, so the basic tensor-product protocol accepts.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5.11.</strong> Construction 2 has soundness error $\\frac{m + N - 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^{\\times}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Suppose that there is some <span class="math">i</span> for which <span class="math">\\langle \\mathbf{f}_i, \\otimes_j(1, \\rho_j) \\rangle \\neq u_i</span>. Fix a malicious prover, which determines next-message function <span class="math">\\tilde{\\mathbf{f}}(X)</span>. Let <span class="math">\\mathbf{f}(X) = \\sum_{i=0}^{m-1} \\zeta^i \\mathbf{f}_i(X)</span>. By the Schwartz-Zippel lemma, <span class="math">\\langle \\mathbf{f}, \\otimes_j(1, \\rho_j) \\rangle \\neq \\sum_{i=0}^{m-1} \\zeta^i u_i</span>, except with probability at most $(m-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the random choice of </span>\\zeta<span class="math">. If </span>\\tilde{\\mathbf{f}}(X) = \\mathbf{f}(X)<span class="math">, then by the soundness of the basic tensor-product protocol, the verifier accepts with probability at most </span>(N-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. If </span>\\tilde{\\mathbf{f}}(X) \\neq \\mathbf{f}(X)<span class="math">, then by the Schwartz-Zippel lemma, </span>\\mathbf{f}(\\beta) \\neq \\sum_{i=0}^{m-1} \\zeta^i \\mathbf{f}_i(\\beta)<span class="math">, except with probability at most </span>(N-1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\times</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the random choice of </span>\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Lemma 5.12.</strong> Construction 2 can be implemented in <span class="math">O(N(\\log N + m))</span> operations in <span class="math">\\mathbb{F}</span>, and space complexity <span class="math">O(m + \\log N)</span> with <span class="math">O(\\log N)</span> passes over each <span class="math">\\mathbf{f}_i</span> for <span class="math">i \\in [m]</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By Lemma 5.6, the basic tensor-product check requires <span class="math">O(\\log N)</span> passes over <span class="math">S(\\mathbf{f})</span> and uses <span class="math">O(\\log N)</span> memory. Since <span class="math">\\mathbf{f}(X) = \\sum_{i=0}^{m-1} \\zeta^i \\mathbf{f}_i(X)</span>, the stream <span class="math">S(\\mathbf{f})</span> can be computed by a streaming algorithm that uses <span class="math">O(mN)</span> operations, <span class="math">O(1)</span> space (never storing more than a single coefficient of one <span class="math">\\mathbf{f}_i</span> polynomial and the partial computation of a coefficient of <span class="math">\\mathbf{f}</span>), and a single pass over each of its <span class="math">m</span> inputs. Composing the two streaming algorithms and using Lemma 4.6 gives the result.</p>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">We describe elastic PIOP protocols which reduce checking twisted scalar product relations to consistency checks of the type described in Section 5.</p>

    <p class="text-gray-300">Definition 6.1. The twisted scalar product relation  <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span>  is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\dot {\\mathbf {i}}, \\mathbf {x}, \\mathbf {w}) = (\\perp , (\\mathbb {F}, N, u), (\\mathbf {f}, \\mathbf {y}, \\mathbf {g}))</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{f},\\mathbf{y},\\mathbf{g}\\in \\mathbb{F}^N</span> <span class="math">u\\in \\mathbb{F}</span>  , and  <span class="math">\\langle \\mathbf{f}\\circ \\mathbf{y},\\mathbf{g}\\rangle = u</span></p>

    <p class="text-gray-300">Standard scalar products are the special case where every entry of  <span class="math">\\mathbf{y}</span>  is equal to 1.</p>

    <p class="text-gray-300">We give two elastic PIOPs for  <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span> . The first, in Section 6.1, is a protocol for the special case where  <span class="math">\\mathbf{y} := \\otimes_{j=0}^{n-1}(1, v_j)</span>  for public  <span class="math">v_0, \\ldots, v_{n-1}</span> .</p>

    <p class="text-gray-300">Theorem 6.2. For every finite field  <span class="math">\\mathbb{F}</span> , every  <span class="math">N \\in \\mathbb{N}</span>  with  <span class="math">n = \\log N</span> , there is a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span>  with  <span class="math">\\mathbf{y} := \\otimes_{j=0}^{n-1}(1, v_j)</span>  for public  <span class="math">v_0, \\ldots, v_{n-1} \\in \\mathbb{F}</span> , with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log N) passes |  |  |  |  |   |</p>

    <p class="text-gray-300">The second protocol, in Section 6.4, reduces the general case to the special case. Finally, in Section 6.5, we give a PIOP for Hadamard products of vectors, which also follows from the special case of twisted scalar products.</p>

    <p class="text-gray-300">Definition 6.3. The Hadamard product relation  <span class="math">\\mathcal{R}_{\\mathrm{HP}}</span>  is the set of tuples  <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x},\\mathbf{w}) = (\\perp ,(\\mathbb{F},N),(\\mathbf{f},\\mathbf{g},\\mathbf{h}))</span>  where  <span class="math">\\mathbf{f},\\mathbf{g},\\mathbf{h}\\in \\mathbb{F}^N</span>  and  <span class="math">\\mathbf{f}\\circ \\mathbf{g} = \\mathbf{h}</span></p>

    <p class="text-gray-300">Theorem 6.4. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{HP}}</span>  that supports instances over  <span class="math">\\mathbb{F}</span> , with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log N) passes |  |  |  |  |   |</p>

    <p class="text-gray-300"><strong>Construction 3.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span> . The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\dot{\\mathbf{i}} = \\bot</span> , instance  <span class="math">\\mathbf{x} = (\\mathbb{F}, v_0, v_1, \\ldots, v_{n-1}, u)</span> , and witness  <span class="math">\\mathbf{w} = (\\mathbf{f}, \\mathbf{g})</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\dot{\\mathbf{i}}</span>  and the instance  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">Interactive phase. Let  <span class="math">\\mathcal{H} \\coloneqq \\{-1, 1\\}</span> . The prover and verifier run a multivariate sumcheck protocol on the multivariate polynomials  <span class="math">\\widetilde{\\mathbf{f}}, \\widetilde{\\mathbf{g}}</span>  associated with  <span class="math">\\mathbf{f}, \\mathbf{g} \\in \\mathbb{F}^N</span>  to show that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {1}{2 ^ {n}} \\sum_ {\\omega \\in \\mathcal {H} ^ {n}} (\\widehat {\\mathbf {f} \\circ \\mathbf {y}} \\cdot \\widehat {\\mathbf {g}}) (\\omega) = u. \\tag {17}</span></div>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> for the multivariate sumcheck protocol outputs a claim that <span class="math">\\left(\\widehat{\\mathbf{f} \\circ \\mathbf{y}} \\cdot \\widehat{\\mathbf{g}}\\right) (\\rho_0, \\ldots, \\rho_{n-1}) = u</span>, where <span class="math">\\rho_0, \\ldots, \\rho_{n-1}</span> is the verifier randomness used in the sumcheck protocol.</p>

    <p class="text-gray-300">The prover sends claimed evaluations <span class="math">u_A, u_B \\in \\mathbb{F}</span> to the verifier, corresponding to the claims that <span class="math">\\widehat{\\mathbf{f} \\circ \\mathbf{y}}(\\rho_0, \\ldots, \\rho_{n-1}) = u_A</span> and <span class="math">\\widehat{\\mathbf{g}}(\\rho_0, \\ldots, \\rho_{n-1}) = u_B</span>. The verifier checks whether <span class="math">u_A \\cdot u_B = u_C</span>.</p>

    <p class="text-gray-300">Rewriting the first evaluation claim, the output of the interactive phase consists of the two claims:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\mathbf {f}} \\left(v _ {0} \\rho_ {0}, \\dots , v _ {n - 1} \\rho_ {n - 1}\\right) = u _ {A}, \\quad \\widehat {\\mathbf {g}} \\left(\\rho_ {0}, \\dots , \\rho_ {n - 1}\\right) = u _ {B}. \\tag {18}</span></div>

    <p class="text-gray-300"><strong>Query phase.</strong> The prover and the verifier run the univariate PIOP for tensor products from Construction 1 to check that the two claims from Equation 18 are true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>one execution with <span class="math">\\mathbf{z} = (\\mathbb{F}, N, v_0 \\rho_0, \\ldots, v_{n-1} \\rho_{n-1}, u_A)</span> and <span class="math">\\mathbf{w} = \\mathbf{f}</span>; and</li>

      <li>one execution with <span class="math">\\mathbf{z} = (\\mathbb{F}, N, \\rho_0, \\ldots, \\rho_{n-1}, u_B)</span> and <span class="math">\\mathbf{w} = \\mathbf{g}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 6.5.</strong> The message complexity of the sumcheck protocol can be reduced from <span class="math">3\\log N</span> to <span class="math">2\\log N</span> field elements. In each round of the sumcheck protocol, the prover sends the coefficients of the polynomial <span class="math">\\mathbf{q}^{(j)}</span>, and the verifier checks whether <span class="math">\\mathbf{q}^{(j)}(1) + \\mathbf{q}^{(j)}(-1) = 2\\cdot \\mathbf{q}^{(j - 1)}(\\rho_{j - 1})</span>. Since <span class="math">\\mathbf{q}^{(j)}(X) = q_{j,0} + q_{j,1}X + q_{j,2}X^2</span> is quadratic, <span class="math">\\mathbf{q}^{(j)}(1) + \\mathbf{q}^{(j)}(-1) = 2q_{j,0} + 2q_{j,2}</span>, and the verification checks amount to checking whether <span class="math">2q_{j,0} + 2q_{j,2} = \\mathbf{q}^{(j - 1)}(\\rho_{j - 1})</span>. Thus, instead of having the prover send <span class="math">q_{j,1}</span> in each round, and asking the verifier to perform the aforementioned checks, the verifier can simply use <span class="math">\\mathbf{q}^{(j - 1)}(\\rho_{j - 1})</span> (which is known from the previous round, or equal to <span class="math">u</span> when <span class="math">j = 0</span>) as the definition of the value of <span class="math">q_{j,1}</span>.</p>

    <p class="text-gray-300"><strong>Remark 6.6.</strong> Construction 3 is a univariate PIOP and uses Construction 1 to reduce claims about multivariate polynomial evaluations, which can be rewritten as tensor products, to claims about univariate polynomial evaluations. However, one can convert Construction 3 into a multivariate PIOP by concluding the protocol using a multivariate evaluation query rather than invoking Construction 1. This means that one can compile our PIOPs into succinct arguments using either multivariate or univariate polynomial commitment schemes.</p>

    <h2 id="sec-65" class="text-2xl font-bold">6.2 Proof of Theorem 6.2</h2>

    <p class="text-gray-300">We prove completeness in Lemma 6.9. We prove soundness in Lemma 6.10. We analyse the complexity of the time-efficient prover and the verifier in Lemma 6.11. We analyse the complexity of the space-efficient prover in Lemma 6.12.</p>

    <p class="text-gray-300">In our analysis, we rely on results from prior work, stated in two lemmas. The first relates polynomial coefficients to sums of evaluations.</p>

    <p class="text-gray-300"><strong>Lemma 6.7</strong> ([BCG20, Lemma 5.7]). Let <span class="math">\\mathcal{H}</span> be a multiplicative subgroup of a finite field <span class="math">\\mathbb{F}</span> and let <span class="math">\\mathbf{p}(X_0,\\ldots ,X_{n - 1})\\in \\mathbb{F}[X_0,\\ldots ,X_{n - 1}]</span>. If we denote by <span class="math">p_{i_0,\\dots ,i_{n - 1}}\\in \\mathbb{F}</span> the coefficient of <span class="math">X_0^{i_0}\\dots X_{n - 1}^{i_{n - 1}}</span> in the polynomial <span class="math">\\mathbf{p}(X_0,\\ldots ,X_{n - 1})</span>, then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {\\omega \\in \\mathcal {H} ^ {n}} \\mathbf {p} (\\omega) = \\left(\\sum_ {\\mathbf {i} \\equiv \\mathbf {0} \\bmod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} p _ {\\mathbf {i}}\\right) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {n}. \\tag {19}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The second describes the properties of sumcheck protocol for products of multilinear polynomials, as studied in [Tha13; XZZPS19; BCG20].</p>

    <p class="text-gray-300">32</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Lemma 6.8.</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span> and every <span class="math">N\\in\\mathbb{N}</span> with <span class="math">n=\\log N</span>, the sumcheck protocol for</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{2^{n}}\\sum_{\\bm{\\omega}\\in\\mathcal{H}^{n}}(\\widehat{\\mathbf{f}}\\cdot\\widehat{\\mathbf{g}})(\\bm{\\omega})=u\\enspace.</span> (20)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for <span class="math">\\mathcal{H}=\\{-1,1\\}</span> and the multilinear polynomials <span class="math">\\widehat{\\mathbf{f}}(X_{0},\\ldots,X_{n-1})</span> and <span class="math">\\widehat{\\mathbf{g}}(X_{0},\\ldots,X_{n-1})</span> associated with <span class="math">\\mathbf{f},\\mathbf{g}\\in\\mathbb{F}^{N}</span> has the following properties: soundness error is $O(n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (as a reduction to claims about polynomial evaluations); round complexity is </span>O(n)<span class="math">; the prover uses </span>O(N)<span class="math"> field operations; and the verifier uses </span>O(n)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-67" class="text-base font-medium mt-4">Lemma 6.9.</h6>

    <p class="text-gray-300">Construction 3 has perfect completeness.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\langle\\mathbf{f}\\circ\\mathbf{y},\\mathbf{g}\\rangle=u</span>. By Lemma 6.7, <span class="math">\\frac{1}{2^{n}}\\sum_{\\omega\\in\\mathcal{H}^{n}}(\\widehat{\\mathbf{f}\\circ\\mathbf{y}}\\cdot\\widehat{\\mathbf{g}})(\\omega)=\\left(\\sum_{\\mathbf{i}\\equiv\\mathbf{0}\\bmod 2}(\\widehat{\\mathbf{f}\\circ\\mathbf{y}}\\cdot\\widehat{\\mathbf{g}})_{\\mathbf{i}}\\right)</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\widehat{\\mathbf{f}\\circ\\mathbf{y}}</span> and <span class="math">\\widehat{\\mathbf{g}}</span> are multilinear polynomials, the contributions to the coefficients of <span class="math">\\widehat{\\mathbf{f}\\circ\\mathbf{y}}\\cdot\\widehat{\\mathbf{g}}</span> with <span class="math">\\mathbf{i}\\equiv 0\\bmod 2</span> are exactly the terms <span class="math">\\widehat{\\mathbf{f}\\circ\\mathbf{y}_{\\mathbf{j}}}\\cdot\\widehat{\\mathbf{g}}_{\\mathbf{j}}</span> where <span class="math">\\mathbf{j}\\in\\{0,1\\}^{n}</span> is the unique vector such that <span class="math">\\mathbf{i}=2\\mathbf{j}</span>. Hence, <span class="math">\\frac{1}{2^{n}}\\sum_{\\omega\\in\\mathcal{H}^{n}}(\\widehat{\\mathbf{f}\\circ\\mathbf{y}}\\cdot\\widehat{\\mathbf{g}})(\\omega)=\\langle\\mathbf{f}\\circ\\mathbf{y},\\mathbf{g}\\rangle=u</span>.</p>

    <p class="text-gray-300">By the completeness property of the sumcheck protocol (Lemma 6.8), the claims <span class="math">\\widehat{\\mathbf{f}}(\\upsilon_{0}\\rho_{0},\\ldots,\\upsilon_{n-1}\\rho_{n-1})=u_{A}</span> and <span class="math">\\widehat{\\mathbf{g}}(\\rho_{0},\\ldots,\\rho_{n-1})=u_{B}</span> are true.</p>

    <p class="text-gray-300">By completeness of the PIOP for tensor products, Construction 1, the verifier accepts. ∎</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Lemma 6.10.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction 3 has soundness error $\\epsilon_{\\mathrm{SP}}\\coloneqq O(N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">\\langle\\mathbf{f}\\circ\\mathbf{y},\\mathbf{g}\\rangle\\neq u</span>. By the soundness of the sumcheck protocol, the probability that the sumcheck verifier accepts and the output claims are both true is at most $\\frac{2n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. If the claims produced by the sumcheck protocol are not true, then by the soundness of the tensor-product protocol (Construction 1), the probability that the verifier for the tensor-product protocol accepts is at most </span>\\frac{N}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. The result follows by a union bound. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 6.11.</h6>

    <p class="text-gray-300">The prover in Construction 3 has arithmetic complexity <span class="math">O(N)</span>. The verifier in Construction 3 has arithmetic complexity <span class="math">O(\\log N)</span>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows from the arithmetic complexities of the prover and the verifier in the sumcheck protocol given in Lemma 6.8, and those of the tensor-product protocol given in Theorem 5.2. ∎</p>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">6.3 Space efficient realization of Construction 3</h3>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 6.12.</h6>

    <p class="text-gray-300">The prover for Construction 3 can be implemented using a streaming algorithm with arithmetic complexity <span class="math">O(N\\log N)</span> that makes <span class="math">O(\\log N)</span> passes over the streams <span class="math">\\mathcal{S}(\\mathbf{f})</span> and <span class="math">\\mathcal{S}(\\mathbf{g})</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Remark 6.13.</h6>

    <p class="text-gray-300">Lemma 6.12 follows directly from <em>[x10, x11]</em>, which proves results about streaming provers for interactive proofs for uniform circuits. We provide a direct proof below for the special case of twisted scalar products.</p>

    <p class="text-gray-300">The techniques used to prove Lemma 6.12 are related to those in <em>[x5]</em>, used for messages for a split-and-fold protocol that was shown to be closely related to the sumcheck protocol in <em>[x6]</em>. Our algorithm has a prover arithmetic complexity of <span class="math">O(N\\log N)</span>, which is more efficient than the <span class="math">O(N\\log^{2}N)</span> algorithm given in <em>[x5]</em> and has a significant impact on concrete efficiency. We must also carefully modify our protocol to account for the vector <span class="math">\\mathbf{y}</span> to reason about a twisted scalar-product relation, which requires extra thought.</p>

    <p class="text-gray-300">Proof. We show how to implement the space-efficient prover for Construction 3 using streaming access to the inputs <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span>. By Lemma 5.6, the tensor product protocol can be implemented in space <span class="math">O(\\log N)</span> using <span class="math">O(1)</span> passes. It remains to show how to compute the next-message function for the sumcheck protocol in small space. Define partially evaluated polynomials in <span class="math">\\mathbb{F}[X_j, X_{j+1}, \\ldots, X_n]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{f}^{(j)}(X_j, \\ldots, X_{n-1}) := \\widehat{\\mathbf{f} \\circ \\mathbf{y}}(\\rho_0, \\ldots, \\rho_{j-1}, X_j, \\ldots, X_{n-1}) = \\sum_{i_j, \\ldots, i_{n-1} \\in \\{0,1\\}} \\mathbf{f}_{i_j, \\ldots, i_{n-1}}^{(j)} X_j^{i_j} \\cdots X_{n-1}^{i_{n-1}} \\ ,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{g}^{(j)}(X_j, \\ldots, X_{n-1}) := \\widehat{\\mathbf{g}}(\\rho_0, \\ldots, \\rho_{j-1}, X_j, \\ldots, X_{n-1}) = \\sum_{i_j, \\ldots, i_{n-1} \\in \\{0,1\\}} \\mathbf{g}_{i_j, \\ldots, i_{n-1}}^{(j)} X_j^{i_j} \\cdots X_{n-1}^{i_{n-1}} \\ .</span></div>

    <p class="text-gray-300">In the <span class="math">(j+1)</span>-th round of the sumcheck protocol, the prover <span class="math">\\mathcal{P}</span> sends the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbf{q}^{(j)}(X) &amp;amp;:= \\frac{1}{2^{n-(j+1)}} \\sum_{\\omega_{j+1}, \\ldots, \\omega_{n-1} \\in \\mathcal{H}} (\\widehat{\\mathbf{f} \\circ \\mathbf{y}} \\cdot \\widehat{\\mathbf{g}})(\\rho_0, \\ldots, \\rho_{j-1}, X_j, \\omega_{j+1}, \\ldots, \\omega_{n-1}) \\\\ &amp;amp;= \\frac{1}{2^{n-(j+1)}} \\sum_{\\omega_{j+1}, \\ldots, \\omega_{n-1} \\in \\mathcal{H}} (\\mathbf{f}^{(j)} \\cdot \\mathbf{g}^{(j)})(X_j, \\omega_{j+1}, \\ldots, \\omega_{n-1}) \\ . \\end{aligned}</span></div>

    <p class="text-gray-300">By Lemma 6.7, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{q}^{(j)}(X) = \\sum_{i_j, k_j \\in \\{0,1\\}} \\sum_{i_{j+1} \\in \\{0,1\\}} \\cdots \\sum_{i_{n-1} \\in \\{0,1\\}} \\mathbf{f}_{i_j, i_{j+1}, \\ldots, i_{n-1}}^{(j)} \\cdot \\mathbf{g}_{k_j, i_{j+1}, \\ldots, i_{n-1}}^{(j)} X_j^{i_j + k_j} \\ .</span></div>

    <p class="text-gray-300">This implies that</p>

    <div class="my-4 text-center"><span class="math-block">q_{j,0} = \\left(\\sum_{i_{j+1} \\in \\{0,1\\}} \\cdots \\sum_{i_{n-1} \\in \\{0,1\\}} \\mathbf{f}_{0, i_{j+1}, \\ldots, i_{n-1}}^{(j)} \\cdot \\mathbf{g}_{0, i_{j+1}, \\ldots, i_{n-1}}^{(j)}\\right) \\ ,</span></div>

    <div class="my-4 text-center"><span class="math-block">q_{j,1} = \\left(\\sum_{i_j \\in \\{0,1\\}} \\cdots \\sum_{i_{n-1} \\in \\{0,1\\}} \\mathbf{f}_{i_j, i_{j+1}, \\ldots, i_{n-1}}^{(j)} \\cdot \\mathbf{g}_{1 - i_j, i_{j+1}, \\ldots, i_{n-1}}^{(j)}\\right) \\text{, and}</span></div>

    <div class="my-4 text-center"><span class="math-block">q_{j,2} = \\left(\\sum_{i_{j+1} \\in \\{0,1\\}} \\cdots \\sum_{i_{n-1} \\in \\{0,1\\}} \\mathbf{f}_{1, i_{j+1}, \\ldots, i_{n-1}}^{(j)} \\cdot \\mathbf{g}_{1, i_{j+1}, \\ldots, i_{n-1}}^{(j)}\\right) \\ .</span></div>

    <p class="text-gray-300">From these formulae, it is clear that <span class="math">q_{j,0}</span>, <span class="math">q_{j,1}</span> and <span class="math">q_{j,2}</span>, can be computed simultaneously in <span class="math">O(1)</span> memory using streams for <span class="math">\\mathbf{f}^{(j)}</span> and <span class="math">\\mathbf{g}^{(j)}</span>.</p>

    <p class="text-gray-300">Next, we show that streams of <span class="math">\\mathbf{f}^{(j)}</span> and <span class="math">\\mathbf{g}^{(j)}</span> can be generated in <span class="math">O(\\log N)</span> memory and <span class="math">O(N)</span> operations using a single pass over the streams of <span class="math">\\mathbf{f}</span> or <span class="math">\\mathbf{g}</span>. The algorithm <span class="math">\\mathcal{S}_{\\mathrm{fold}}(\\cdot)</span> described in Figure 3 and analysed in Lemma 5.6 generates the stream of <span class="math">\\mathbf{g}^{(j)}</span> from the stream of <span class="math">\\mathbf{g}</span> for any <span class="math">j</span> with the required complexity parameters. Similarly, <span class="math">\\mathcal{S}_{\\mathrm{fold}}(\\cdot)</span> generates <span class="math">\\mathbf{f}^{(j)}</span> from the stream of <span class="math">\\mathbf{f} \\circ \\mathbf{y}</span> for any <span class="math">j</span>. To complete the proof, we explain how to generate the stream of <span class="math">\\mathbf{f} \\circ \\mathbf{y}</span> using a single pass over the stream of <span class="math">\\mathbf{f}</span>, and <span class="math">v_0, \\ldots, v_{n-1}</span>, using <span class="math">O(\\log N)</span> space.</p>

    <p class="text-gray-300">The entries of <span class="math">\\mathbf{f} \\circ \\mathbf{y}</span> are given by <span class="math">(\\mathbf{f}_{i_0, \\ldots, i_{n-1}} v_0^{i_0} \\cdots v_{n-1}^{i_{n-1}})_{i_0, \\ldots, i_{n-1} \\in \\{0,1\\}}</span>. To generate the stream of <span class="math">\\mathbf{f} \\circ \\mathbf{y}</span> in a single pass over the stream of <span class="math">\\mathbf{f}</span>, begin by computing the sequence <span class="math">v_0, v_0 v_1, \\ldots, v_0 \\cdots v_{n-1}</span>. Then, compute the sequence <span class="math">d_0 := v_0 v_1^{-1}</span>, <span class="math">d_1 := v_0 v_1 v_2^{-1}, \\ldots, d_{n-1} := v_0 \\cdots v_{n-1} v_n^{-1}</span>. Next, define <span class="math">\\mathcal{S}^{(n)}</span> as follows. Let <span class="math">\\mathcal{S}^{(0)} := (v_0)</span>, and define <span class="math">\\mathcal{S}^{(j+1)}</span> recursively as the concatenation <span class="math">\\mathcal{S}^{(j)} \\parallel (d_j) \\parallel \\mathcal{S}^{(j)}</span>. Now, the</p>

    <p class="text-gray-300">sequence <span class="math">(\\mathbf{y}_{i_0,\\dots,i_{n-1}})_{i_0,\\dots,i_{n-1}}</span> can be computed by starting with <span class="math">z = v_0v_1\\cdots v_{n-1}</span> (which is equal to <span class="math">\\mathbf{y}_{1,\\dots,1}</span>), and multiplying <span class="math">z</span> by each element of the palindromic sequence <span class="math">\\mathcal{S}^{(n)} \\in \\mathbb{F}^{N-1}</span> in turn.</p>

    <p class="text-gray-300">This method generates the stream of <span class="math">\\mathbf{y}</span> in <span class="math">O(\\log N)</span> space using <span class="math">O(N)</span> operations, and multiplying this stream by the stream of <span class="math">\\mathbf{f}</span> gives the stream of <span class="math">\\mathbf{f} \\circ \\mathbf{y}</span> with the stated time and memory complexity.</p>

    <h2 id="sec-76" class="text-2xl font-bold">6.4 Elastic scalar-product protocol (general case)</h2>

    <p class="text-gray-300">To verify <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span>, the prover and verifier begin by running one scalar-product subprotocol on <span class="math">\\mathbf{f} \\circ \\mathbf{g}</span> and <span class="math">\\mathbf{h}</span>. This reduces the claim that <span class="math">\\langle \\mathbf{f} \\circ \\mathbf{g}, \\mathbf{h} \\rangle = u</span> to claims about <span class="math">\\mathbf{f} \\circ \\mathbf{g}</span> and <span class="math">\\mathbf{h}</span>. Then, the claim about <span class="math">\\mathbf{f} \\circ \\mathbf{g}</span> can be rewritten as claim about scalar-product between <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span>. Finally, the prover and verifier run a second scalar-product subprotocol to reduce this to claims about <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{g}</span>. The end result is a claim about each of <span class="math">\\mathbf{f}</span>, <span class="math">\\mathbf{g}</span> and <span class="math">\\mathbf{h}</span>.</p>

    <p class="text-gray-300"><strong>Construction 4.</strong> We construct a PIOP for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{TSP}}</span>. The prover <span class="math">\\mathcal{P}</span> takes as input an index <span class="math">\\mathbf{i} = \\bot</span>, instance <span class="math">\\mathbf{x} = (\\mathbb{F}, N, u)</span>, and witness <span class="math">\\mathbf{w} = (\\mathbf{f}, \\mathbf{g}, \\mathbf{h})</span>; the verifier <span class="math">\\mathcal{V}</span> takes as input the index <span class="math">\\mathbf{i}</span> and the instance <span class="math">\\mathbf{x}</span>.</p>

    <p class="text-gray-300"><strong>Interactive phase.</strong> Letting <span class="math">\\mathbf{f}^{(0)}(X) \\coloneqq \\mathbf{f} \\circ \\mathbf{g}(X), \\mathbf{g}^{(0)}(X) \\coloneqq \\mathbf{h}(X)</span>, <span class="math">\\mathbf{h}^{(0)}(X) \\coloneqq \\mathbf{f}(X)</span>, and <span class="math">\\mathbf{k}^{(0)}(X) \\coloneqq \\mathbf{g}(X)</span> the protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover and verifier run the interactive phase of the scalar-product protocol (Construction 3) with index <span class="math">\\mathbf{i} = \\bot</span>, instance <span class="math">\\mathbf{x} = (\\mathbb{F}, N, u)</span>, and witness <span class="math">\\mathbf{w} = (\\mathbf{f} \\circ \\mathbf{g}, \\mathbf{h})</span> to check that <span class="math">\\langle \\mathbf{f} \\circ \\mathbf{g}, \\mathbf{h} \\rangle = u</span>. The protocol outputs claims that <span class="math">u_A = \\langle \\mathbf{f} \\circ \\mathbf{g}, \\otimes_j(1, \\rho_j) \\rangle</span> and <span class="math">u_B = \\langle \\mathbf{h}, \\otimes_j(1, \\rho_j) \\rangle</span>, where <span class="math">\\rho_0, \\ldots, \\rho_{n-1}</span> is the verifier randomness used in the subprotocol.</li>

      <li>The prover and verifier run the interactive phase of the scalar-product protocol (Construction 3) with index <span class="math">\\mathbf{i} = \\bot</span>, instance <span class="math">\\mathbf{x} = (\\mathbb{F}, N, \\rho_0, \\ldots, \\rho_{n-1}, u_A)</span>, and witness <span class="math">\\mathbf{w} = (\\mathbf{f} \\circ \\otimes_j(1, \\rho_j), \\mathbf{g})</span> to check that <span class="math">\\langle \\mathbf{f} \\circ \\otimes_j(1, \\rho_j), \\mathbf{g} \\rangle = u_A</span>. The protocol outputs claims that <span class="math">u_C = \\langle \\mathbf{f}, \\otimes_j(1, \\rho_j r_j) \\rangle</span> and <span class="math">u_D = \\langle \\mathbf{g}, \\otimes_j(1, r_j) \\rangle</span>, where <span class="math">r_0, \\ldots, r_{n-1}</span> is the verifier randomness used in the subprotocol.</li>

      <li>The output of the interactive phase consists of the three claims:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u_C = \\langle \\mathbf{f}, \\otimes_j(1, \\rho_j r_j) \\rangle \\quad , \\quad u_D = \\langle \\mathbf{g}, \\otimes_j(1, r_j) \\rangle \\quad , \\quad u_B = \\langle \\mathbf{h}, \\otimes_j(1, \\rho_j) \\rangle \\quad . \\tag{21}</span></div>

    <p class="text-gray-300"><strong>Query phase.</strong> The prover and the verifier run the univariate PIOP for tensor products from Construction 1 to check that the three claims from Equation 21 are true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>one execution with <span class="math">\\mathbf{x} = (\\mathbb{F}, N, \\rho_0 r_0, \\ldots, \\rho_{n-1} r_{n-1}, u_C)</span> and <span class="math">\\mathbf{w} = \\mathbf{f}</span>;</li>

      <li>one execution with <span class="math">\\mathbf{x} = (\\mathbb{F}, N, r_0, \\ldots, r_{n-1}, u_D)</span> and <span class="math">\\mathbf{w} = \\mathbf{g}</span>; and</li>

      <li>one execution with <span class="math">\\mathbf{x} = (\\mathbb{F}, N, \\rho_0, \\ldots, \\rho_{n-1}, u_B)</span> and <span class="math">\\mathbf{w} = \\mathbf{h}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 6.14.</strong> Construction 4 has perfect completeness.</p>

    <p class="text-gray-300"><strong>Sketch.</strong> Suppose that <span class="math">\\langle \\mathbf{f} \\circ \\mathbf{g}, \\mathbf{h} \\rangle = u</span>. By Lemma 6.9 (completeness of Construction 3), the verifier for the first scalar-product subprotocol will accept, and the subprotocol produces correct claims about <span class="math">u_A</span> and <span class="math">u_B</span>. Writing <span class="math">u_A = \\langle \\mathbf{f} \\circ \\mathbf{g}, \\otimes_j(1, \\rho_j) \\rangle = \\langle \\mathbf{f} \\circ \\otimes_j(1, \\rho_j), \\mathbf{g} \\rangle</span> and applying similar reasoning to the second scalar-product subprotocol completes the proof.</p>

    <p class="text-gray-300"><strong>Lemma 6.15.</strong> Construction 4 has soundness error <span class="math">2\\epsilon_{\\mathrm{SP}}</span>.</p>

    <p class="text-gray-300">35</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\langle\\mathbf{f}\\circ\\mathbf{g},\\mathbf{h}\\rangle\\neq u</span>. By Lemma 6.10 (soundness of Construction 3), the probability that the verifier for the first scalar-product subprotocol accepts and that the claims about <span class="math">u_{A}</span> and <span class="math">u_{B}</span> are true is at most <span class="math">\\epsilon_{\\mathrm{SP}}</span>. If the claim about <span class="math">u_{A}</span> is false, then by Lemma 6.10, the probability that the verifier for the second scalar-product subprotocol accepts and that the claims about <span class="math">u_{C}</span> and <span class="math">u_{D}</span> are true is at most <span class="math">\\epsilon_{\\mathrm{SP}}</span>.</p>

    <p class="text-gray-300">Therefore, by a union bound, except with probability at most <span class="math">2\\epsilon_{\\mathrm{SP}}</span>, at least one of the claims about <span class="math">u_{B}</span>, <span class="math">u_{C}</span> or <span class="math">u_{D}</span> is false, or the verifier rejects. ∎</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 6.16.</h6>

    <p class="text-gray-300">The prover in Construction 4 has arithmetic complexity <span class="math">O(N)</span>, and the verifier has arithmetic complexity <span class="math">O(\\log N)</span>.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Sketch.</h6>

    <p class="text-gray-300">By Lemma 6.11, the prover in Construction 3 has arithmetic complexity <span class="math">O(N)</span> and the verifier in Construction 3 has arithmetic complexity <span class="math">O(\\log N)</span>. Construction 4 consists of two executions of Construction 3, so the result follows. ∎</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 6.17.</h6>

    <p class="text-gray-300">Construction 4 has an implementation with a streaming prover that uses <span class="math">O(N\\log N)</span> arithmetic operations over <span class="math">\\mathbb{F}</span>, <span class="math">O(\\log N)</span> space, and <span class="math">O(\\log N)</span> passes over <span class="math">\\mathcal{S}(\\mathbf{f})</span>, <span class="math">\\mathcal{S}(\\mathbf{g})</span> and <span class="math">\\mathcal{S}(\\mathbf{h})</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows immediately from the space-efficient implementation of Construction 3 and its analysis in Lemma 6.12. ∎</p>

    <h3 id="sec-82" class="text-xl font-semibold mt-8">6.5 Hadamard-product protocol</h3>

    <p class="text-gray-300">We describe a Hadamard product protocol.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Construction 5.</h6>

    <p class="text-gray-300">We construct a PIOP for the indexed relation <span class="math">\\mathcal{R}_{\\mathrm{HP}}</span>. The prover <span class="math">\\mathcal{P}</span> takes as input an index <span class="math">\\mathbbm{i}=\\bot</span>, instance <span class="math">\\mathbbm{x}=(\\mathbb{F},N)</span>, and witness <span class="math">\\mathbbm{w}=(\\mathbf{f},\\mathbf{g},\\mathbf{h})</span>; the verifier <span class="math">\\mathcal{V}</span> takes as input the index <span class="math">\\mathbbm{i}</span> and the instance <span class="math">\\mathbbm{x}</span>.</p>

    <p class="text-gray-300">Interactive phase. The protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathcal{V}</span> sends uniformly random challenge <span class="math">\\upsilon\\in\\mathbb{F}^{\\times}</span>.</li>

      <li>The prover <span class="math">\\mathcal{P}</span> computes <span class="math">u=\\langle\\mathbf{h},\\mathbf{y}\\rangle</span>, where <span class="math">\\mathbf{y}\\coloneqq(1,\\upsilon,\\ldots,\\upsilon^{N-1})</span>, and sends the non-oracle message <span class="math">u\\in\\mathbb{F}</span>. Note that in the space-efficient variant, the prover need not compute <span class="math">\\mathbf{y}</span> from <span class="math">\\upsilon</span> explicitly.</li>

      <li>The prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span> engage in a twisted scalar-product protocol with <span class="math">\\mathbbm{w}\\coloneqq(\\mathbf{f},\\mathbf{g})</span> and <span class="math">\\mathbbm{x}\\coloneqq(\\mathbb{F},N,\\upsilon,u)</span> to show that <span class="math">\\langle\\mathbf{f}\\circ\\mathbf{y},\\mathbf{g}\\rangle=u</span>. The twisted scalar product protocol outputs claims <span class="math">u_{A}=\\langle\\mathbf{f},\\mathbf{y}\\circ\\otimes_{j}(1,\\rho_{j})\\rangle</span> and <span class="math">u_{B}=\\langle\\mathbf{g},\\otimes_{j}(1,\\rho_{j})\\rangle</span>.</li>

    </ul>

    <p class="text-gray-300">The output of the interactive phase consists of three claims</p>

    <p class="text-gray-300"><span class="math">u_{A}=\\langle\\mathbf{f},\\mathbf{y}\\circ\\otimes_{j}(1,\\rho_{j})\\rangle\\enspace,\\qquad u_{B}=\\langle\\mathbf{g},\\otimes_{j}(1,\\rho_{j})\\rangle\\enspace,\\qquad u=\\langle\\mathbf{h},\\mathbf{y}\\rangle\\enspace.</span></p>

    <p class="text-gray-300">Query phase. The prover and the verifier run the univariate PIOP for tensor products from Construction 1 to check that the three claims from Equation 21 are true:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>one execution with <span class="math">\\mathbbm{x}=(\\mathbb{F},N,\\upsilon^{2^{0}}\\rho_{0},\\ldots,\\upsilon^{2^{n-1}}\\rho_{n-1},u_{A})</span> and <span class="math">\\mathbbm{w}=\\mathbf{f}</span>;</li>

      <li>one execution with <span class="math">\\mathbbm{x}=(\\mathbb{F},N,\\rho_{0},\\ldots,\\rho_{n-1},u_{B})</span> and <span class="math">\\mathbbm{w}=\\mathbf{g}</span>; and</li>

      <li>one execution with <span class="math">\\mathbbm{x}=(\\mathbb{F},N,\\upsilon^{2^{0}},\\ldots,\\upsilon^{2^{n-1}},u)</span> and <span class="math">\\mathbbm{w}=\\mathbf{h}</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 6.4 follows in a straightforward manner from Theorem 6.2, with soundness using the Schwartz–Zippel lemma.</p>

    <p class="text-gray-300">We present a non-holographic protocol for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span></p>

    <p class="text-gray-300">Theorem 7.1. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  for instances with  <span class="math">N \\times N</span>  matrices with  <span class="math">M</span>  non-zero entries, with the following complexity parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log2N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) passes</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) passes</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that Theorem 7.1 features an elastic verifier as well as an elastic prover.</p>

    <p class="text-gray-300"><strong>Construction 6.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> . The indexer algorithm is trivial. The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\mathbb{i} = (\\mathbb{F}, N, M, A, B, C)</span> , instance  <span class="math">\\mathbb{x} = \\mathbf{x}</span> , and witness  <span class="math">\\mathbb{w} = \\mathbf{w}</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\mathbb{i}</span>  and the instance  <span class="math">\\mathbb{x}</span> . The protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">\\mathcal{P}</span>  sets  <span class="math">\\mathbf{z} \\coloneqq (\\mathbf{x}, \\mathbf{w}) \\in \\mathbb{F}^N</span>  and sends the oracle message  <span class="math">\\mathbf{w}</span>  to the verifier. The prover computes  <span class="math">A\\mathbf{z}, B\\mathbf{z}, C\\mathbf{z} \\in \\mathbb{F}^N</span> .</li>

      <li>The prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  run the interactive phase of the Hadamard-product protocol (Construction 5) with  <span class="math">\\mathbb{x} := (\\mathbb{F}, N)</span>  and  <span class="math">\\mathbb{w} := (A\\mathbf{z}, B\\mathbf{z}, C\\mathbf{z})</span>  to show that  <span class="math">A\\mathbf{z} \\circ B\\mathbf{z} = C\\mathbf{z}</span> . This generates claims that  <span class="math">u_A = \\langle A\\mathbf{z}, \\mathbf{y} \\circ \\otimes_j(1, \\rho_j) \\rangle</span> ,  <span class="math">u_B = \\langle B\\mathbf{z}, \\otimes_j(1, \\rho_j) \\rangle</span>  and  <span class="math">u_C = \\langle C\\mathbf{z}, \\mathbf{y} \\rangle</span>  for verifier randomness  <span class="math">\\rho_0, \\ldots, \\rho_{n-1}, v \\in \\mathbb{F}</span>  and  <span class="math">\\mathbf{y} := (1, v, \\ldots, v^{N-1})</span> . Rewrite these claims as</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u _ {A} = \\left\\langle \\mathbf {z}, \\mathbf {a} ^ {*} \\right\\rangle , \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {B} = \\left\\langle \\mathbf {z}, \\mathbf {b} ^ {*} \\right\\rangle , \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {C} = \\left\\langle \\mathbf {z}, \\mathbf {c} ^ {*} \\right\\rangle , \\tag {24}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{a}^{<em>}\\coloneqq \\mathbf{y}^{\\top}\\circ \\otimes_{j}(1,\\rho_{j})^{\\top}A</span> <span class="math">\\mathbf{b}^{</em>}\\coloneqq \\otimes_{j}(1,\\rho_{j})^{\\top}B</span>  and  <span class="math">\\mathbf{c}^{*}\\coloneqq \\mathbf{y}^{\\top}C</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Note that to run the holographic protocol, the prover and verifier use Construction 7 instead of what follows from this point.</li>

    </ul>

    <p class="text-gray-300">The verifier  <span class="math">\\mathcal{V}</span>  samples random challenge  <span class="math">\\eta \\gets \\mathbb{F}^{\\times}</span>  and sends  <span class="math">\\eta</span>  to the prover  <span class="math">\\mathcal{P}</span> . The challenge is used to bundle the three claims into one:</p>

    <div class="my-4 text-center"><span class="math-block">u _ {A} + \\eta \\cdot u _ {B} + \\eta^ {2} \\cdot u _ {C} = \\left\\langle \\mathbf {z}, \\mathbf {a} ^ {*} + \\eta \\cdot \\mathbf {b} ^ {*} + \\eta^ {2} \\cdot \\mathbf {c} ^ {*} \\right\\rangle .</span></div>

    <p class="text-gray-300">The prover and verifier run the interactive phase of the scalar-product protocol (Construction 3) to check this claim. This produces two claims:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a claim</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u _ {D} = \\left\\langle \\mathbf {z}, \\otimes_ {j} \\left(1, \\rho_ {j} ^ {\\prime}\\right) \\right\\rangle</span></div>

    <p class="text-gray-300">about  <span class="math">\\mathbf{z}</span>  which the verifier can check using the tensor product protocol (Construction 1) with  <span class="math">\\mathbb{x} = (\\mathbb{F}, N, \\rho_0&#x27;, \\ldots, \\rho_{n-1}&#x27;, u_D)</span>  and  <span class="math">\\mathbb{w} = \\mathbf{z}</span> ;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a claim</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">u _ {E} = \\left\\langle \\mathbf {a} ^ {*} + \\eta \\cdot \\mathbf {b} ^ {*} + \\eta^ {2} \\cdot \\mathbf {c} ^ {*}, \\otimes_ {j} (1, \\rho_ {j} ^ {\\prime}) \\right\\rangle</span></div>

    <p class="text-gray-300">which the verifier can check for themselves. Here,  <span class="math">\\rho_0&#x27;,\\ldots ,\\rho_{n - 1}&#x27;\\in \\mathbb{F}</span>  is the verifier randomness used in the scalar-product protocol.</p>

    <p class="text-gray-300">7.1 Proof of Theorem 7.1</p>

    <p class="text-gray-300">Completeness follows from the completeness of each subprotocol and Equations 22 to 24. The soundness error of the protocol and query complexity follow from those of the scalar-product protocol, Hadamard product protocol and consistency-check protocol. We analyse the complexity of the time-efficient prover in Lemma 7.2. We analyse the complexity of the space-efficient prover in Lemma 7.3. We analyse the complexity of the time-efficient prover in Lemma 7.4. We analyse the complexity of the space-efficient prover in Lemma 7.5.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Lemma 7.2.</h6>

    <p class="text-gray-300">The prover in Construction 6 can be implemented with arithmetic complexity <span class="math">O(M)</span> and <span class="math">O(M)</span> memory.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">The prover <span class="math">\\mathcal{P}</span> computes <span class="math">A\\mathbf{z}</span>, <span class="math">B\\mathbf{z}</span> and <span class="math">C\\mathbf{z}</span>, which uses <span class="math">O(M)</span> arithmetic operations and <span class="math">O(M)</span> space. The prover <span class="math">\\mathcal{P}</span> uses the Hadamard-product protocol, scalar-product protocol and consistency-check protocol as subroutines, running the protocols on vectors of length <span class="math">N</span>. This uses <span class="math">O(N)</span> arithmetic operations and <span class="math">O(N)</span> memory. ∎</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 7.3.</h6>

    <p class="text-gray-300">The prover in Construction 6 can be implemented with arithmetic complexity <span class="math">O(M\\log^{2}N)</span>, <span class="math">O(\\log N)</span> memory, and <span class="math">O(\\log N)</span> passes over the streams <span class="math">\\mathcal{S}(\\mathbf{z})</span>, <span class="math">\\mathcal{S}(A\\mathbf{z})</span>, <span class="math">\\mathcal{S}(B\\mathbf{z})</span> and <span class="math">\\mathcal{S}(C\\mathbf{z})</span>, and <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(U)</span> for <span class="math">U\\in\\{A,B,C\\}</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">We explain how to implement the space-efficient prover for Construction 6. Recall that <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(U)</span> provides streaming access to the vectors <span class="math">\\mathsf{row}_{U}</span>, <span class="math">\\mathsf{col}_{U}</span> and <span class="math">\\mathsf{val}_{U}\\in\\mathbb{F}^{M}</span> of row indices, column indices and non-zero entries of <span class="math">U\\in\\{A,B,C\\}</span> in column major order.</p>

    <p class="text-gray-300">The prover <span class="math">\\mathcal{P}</span> uses the Hadamard-product protocol, scalar-product protocol and tensor-product protocol as subroutines, running the protocols on vectors of length <span class="math">N</span>. These protocols use <span class="math">O(N\\log N)</span> arithmetic operations, <span class="math">O(\\log N)</span> memory and <span class="math">O(\\log N)</span> passes over the witnesses for the protocols.</p>

    <p class="text-gray-300">The prover has direct access to streams for the witnesses for the Hadamard-product protocol and the consistency check. However, one of the witnesses for the scalar-product protocol is the vector <span class="math">\\mathbf{a}^{<em>}+\\eta\\cdot\\mathbf{b}^{</em>}+\\eta^{2}\\mathbf{c}^{<em>}</span> where <span class="math">\\mathbf{a}^{</em>}=\\mathbf{y}^{\\intercal}\\circ\\otimes_{j}(1,\\rho_{j})^{\\intercal}A</span>, <span class="math">\\mathbf{b}^{<em>}=\\otimes_{j}(1,\\rho_{j})^{\\intercal}B</span> and <span class="math">\\mathbf{c}^{</em>}=\\mathbf{y}^{\\intercal}C</span>.</p>

    <p class="text-gray-300">The prover can generate the streams of <span class="math">\\mathbf{a}^{<em>}</span>, <span class="math">\\mathbf{b}^{</em>}</span> and <span class="math">\\mathbf{c}^{*}</span> using the algorithm in Figure 4. The prover multiplies each of the <span class="math">M</span> non-zero elements of <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> by <span class="math">O(\\log N)</span> field elements (the seeds used to generate vectors such as <span class="math">\\otimes_{j}(1,\\rho_{j})</span>). Since the Hadamard-product prover makes <span class="math">O(\\log N)</span> passes over streams of the witness (e.g. <span class="math">\\mathbf{z}_{A}</span>), the prover uses <span class="math">O(M\\log^{2}N)</span> arithmetic operations. ∎</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Lemma 7.4.</h6>

    <p class="text-gray-300">The verifier in Construction 6 can be implemented with <span class="math">O(M)</span> field operations.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> uses the scalar-product protocol and consistency-check protocol as subroutines. The dominant cost for the verifier is the computation of the claim</p>

    <p class="text-gray-300"><span class="math">u_{E}=\\langle\\mathbf{a}^{<em>}+\\eta\\cdot\\mathbf{b}^{</em>}+\\eta^{2}\\mathbf{c}^{*},\\otimes_{j}(1,\\rho_{j}^{\\prime})\\rangle=\\langle\\left(\\mathbf{y}^{\\intercal}\\circ\\otimes_{j}(1,\\rho_{j})^{\\intercal}\\right)\\cdot A+\\eta\\otimes_{j}(1,\\rho_{j})^{\\intercal}B+\\eta^{2}\\mathbf{y}^{\\intercal}C,\\otimes_{j}(1,\\rho_{j}^{\\prime})\\rangle\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This requires <span class="math">O(M)</span> field operations, because it costs <span class="math">O(N)</span> to calculate all entries of the vectors <span class="math">\\otimes_{j}(1,\\rho_{j})</span>, <span class="math">\\upsilon</span> and <span class="math">\\otimes_{j}(1,\\rho_{j}^{\\prime})</span>, and <span class="math">\\mathbf{y}\\circ\\otimes_{j}(1,\\rho_{j})</span>, <span class="math">O(M)</span> entries to perform multiplications by <span class="math">A</span>, <span class="math">B</span> and <span class="math">C</span> and then <span class="math">O(N)</span> to evaluate the scalar product. Note that <span class="math">\\mathcal{V}</span> can evaluate <span class="math">\\mathbf{z}(X)</span> at any point <span class="math">\\gamma</span> with $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations by querying </span>\\mathbf{w}<span class="math"> at </span>\\gamma<span class="math"> and computing the expression </span>\\mathbf{x}(X)+X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathbf{w}(X)<span class="math"> by using </span>\\mathbf{x}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-91" class="text-base font-medium mt-4">Lemma 7.5.</h6>

    <p class="text-gray-300">The verifier in Construction 6 can be implemented with arithmetic complexity <span class="math">O(M\\log N)</span>, <span class="math">O(\\log N)</span> memory, and <span class="math">O(1)</span> passes over the streams <span class="math">\\mathcal{S}_{\\mathrm{cmaj}}(U)</span> for <span class="math">U\\in\\{A,B,C\\}</span>.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 4: Streams  <span class="math">S(\\mathbf{a}^<em>)</span> ,  <span class="math">S(\\mathbf{b}^</em>)</span> ,  <span class="math">S(\\mathbf{c}^*)</span> , and  <span class="math">S(\\mathbf{y})</span> .</p>

    <p class="text-gray-300">Proof sketch. As in Lemma 7.4, the main cost for the verifier in this protocol is the cost of checking the claim</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">We extend the non-holographic elastic PIOP of the previous section to additionally achieve holography.</p>

    <p class="text-gray-300">Theorem 8.1. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integers  <span class="math">N, M</span> , there is a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span>  for instances with  <span class="math">N \\times N</span>  matrices with  <span class="math">M</span>  non-zero entries and public input  <span class="math">\\mathbf{x}</span> , with the following complexity parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log2N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log M) passes |  |  |  |  |   |</p>

    <p class="text-gray-300">Part of Construction 6 (the non-holographic R1CS protocol) generates the claims that</p>

    <div class="my-4 text-center"><span class="math-block">u _ {A} = \\left\\langle \\mathbf {z}, \\mathbf {y} ^ {\\intercal} \\circ \\otimes_ {j} (1, \\rho_ {j}) ^ {\\intercal} \\cdot A \\right\\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {B} = \\left\\langle \\mathbf {z}, \\otimes_ {j} (1, \\rho_ {j}) ^ {\\intercal} B \\right\\rangle ,</span></div>

    <div class="my-4 text-center"><span class="math-block">u _ {C} = \\left\\langle \\mathbf {z}, \\mathbf {y} ^ {\\intercal} C \\right\\rangle ,</span></div>

    <p class="text-gray-300">and then checks these claims using a scalar-product protocol. The holographic protocol checks the claims using the alternative construction following the strategy in [BCG20]. The key subprotocols are a look-up protocol in Section 8.2 and an entry-product protocol in Section 8.3. As discussed in Section 2, we leverages plookup in Section 8.2.1 and offline-memory checking in Section 8.2.2 to build the look-up protocol.</p>

    <p class="text-gray-300">Remark 8.2. In the construction, we will assume that the matrices  <span class="math">A</span> ,  <span class="math">B</span>  and  <span class="math">C</span>  have the same support, which means that  <span class="math">\\mathsf{row} \\coloneqq \\mathsf{row}_A = \\mathsf{row}_B = \\mathsf{row}_C</span>  and  <span class="math">\\mathsf{col} \\coloneqq \\mathsf{col}_A = \\mathsf{col}_B = \\mathsf{col}_C</span> . This can be achieved by padding  <span class="math">\\mathsf{val}_A</span> ,  <span class="math">\\mathsf{val}_B</span>  and  <span class="math">\\mathsf{val}_C</span>  with zeroes as required, and increases the length of the sparse representations of  <span class="math">A</span> ,  <span class="math">B</span>  and  <span class="math">C</span>  by at most a factor of 3.</p>

    <p class="text-gray-300"><strong>Construction 7.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{R1CS}}</span> . The indexer algorithm takes as input an index  <span class="math">(\\mathbb{F}, N, M, A, B, C)</span> , outputs the oracle messages  <span class="math">\\mathsf{val}_U</span>  for  <span class="math">U \\in \\{A, B, C\\}</span> , and runs the indexer algorithm of Construction 8 on row and col. The prover  <span class="math">\\mathcal{P}</span>  takes as input the index  <span class="math">\\mathbb{i} = (\\mathbb{F}, N, M, A, B, C)</span> , instance  <span class="math">\\mathbb{z} = \\mathbf{x}</span> , and witness  <span class="math">\\mathbb{w} = \\mathbf{w}</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the instance  <span class="math">\\mathbb{z}</span>  and has query access to the indexer's oracle messages. The protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The protocol begins by running the first two steps of Construction 6.</li>

      <li>The prover  <span class="math">\\mathcal{P}</span>  constructs the vectors</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {z} ^ {\\star} := \\mathbf {z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {c o l}}, \\quad \\mathbf {r} _ {A} ^ {\\star} := (\\mathbf {y} \\circ \\otimes_ {j} (1, \\rho_ {j}))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {r o w}},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {r} _ {B} ^ {\\star} := \\left(\\otimes_ {j} (1, \\rho_ {j})\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\text {r o w}} ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {r} _ {C} ^ {\\star} := \\mathbf {y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\text {r o w}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">It sends  <span class="math">\\mathbf{z}^{\\star},\\mathbf{r}_A^{\\star},\\mathbf{r}_B^{\\star},\\mathbf{r}_C^{\\star}\\in \\mathbb{F}^{M}</span>  as oracle messages to the verifier.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 5: Stream of the vectors  <span class="math">\\mathbf{z}^{\\star},\\mathbf{r}_A^{\\star},\\mathbf{r}_B^{\\star},\\mathbf{r}_C^{\\star}</span> .  <span class="math">S_{\\mathrm{cmaj}}(U)</span>  produces the sparse representation triplets (row, col, value) in column-major; we use pattern-matching with “_” to assign the value we are interested in.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  engage in the following scalar product subprotocols in parallel using the same verifier randomness for each subprotocol:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>one with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, u_A)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_A^\\star, \\mathsf{val}_A, \\mathbf{z}^\\star)</span> ;</li>

      <li>one with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, u_B)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_B^\\star, \\mathsf{val}_B, \\mathbf{z}^\\star)</span> ; and</li>

      <li>one with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, u_C)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_C^\\star, \\mathsf{val}_C, \\mathbf{z}^\\star)</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\mathbf{r}_B \\coloneqq \\otimes_j(1, \\rho_j)</span> ,  <span class="math">\\mathbf{r}_C \\coloneqq \\mathbf{y}</span>  and  <span class="math">\\mathbf{r}_A \\coloneqq \\mathbf{y} \\circ \\otimes_j(1, \\rho_j)</span> . The prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  engage (in parallel) the following subprotocols:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{z}^{\\star} \\subseteq \\mathbf{z}</span> : invoke lookup with index  <span class="math">\\mathfrak{i} = \\operatorname{col}</span>  with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, N)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{z}^{\\star}, \\mathbf{z})</span></li>

      <li><span class="math">\\mathbf{r}_A^\\star = \\mathbf{r}_B^\\star \\circ \\mathbf{r}_C^\\star</span> : invoke Hadamard protocol protocol with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_B^\\star, \\mathbf{r}_C^\\star, \\mathbf{r}_A^\\star)</span></li>

      <li><span class="math">\\mathbf{r}_B^\\star \\subseteq \\mathbf{r}_B</span> : invoke lookup with index  <span class="math">\\mathfrak{i} = \\text{row}</span>  with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, N)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_B^\\star, \\mathbf{r}_B)</span></li>

      <li><span class="math">\\mathbf{r}_C^\\star \\subseteq \\mathbf{r}_C</span> : invoke lookup with index  <span class="math">\\mathfrak{i} = \\text{row}</span> , statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, N)</span>  and witness  <span class="math">\\mathbf{w} = (\\mathbf{r}_C^\\star, \\mathbf{r}_B)</span></li>

    </ul>

    <p class="text-gray-300">Definition 8.3. The lookup relation  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span>  is the set of tuples  <span class="math">(\\mathfrak{i},\\mathfrak{x},\\mathfrak{w}) = (\\mathrm{addr},(\\mathbb{F},M,N),(\\mathbf{f}^{\\star},\\mathbf{f}))</span>  where  <span class="math">\\mathbf{f}^{\\star}\\in \\mathbb{F}^{M}</span> <span class="math">\\mathbf{f}\\in \\mathbb{F}^{N}</span>  ,  <span class="math">\\mathrm{addr}\\in [N]^M</span>  such that  <span class="math">\\mathbf{f}_i^\\star = \\mathbf{f}_{\\mathrm{addr}_i}</span></p>

    <p class="text-gray-300">We can transform the relations in Construction 7 into the above lookup relations. For example, for the relation  <span class="math">\\mathbf{z}^{\\star} \\subseteq \\mathbf{z}</span> , we consider representing  <span class="math">\\mathbf{z}^{\\star}</span>  as  <span class="math">\\mathbf{f}^{\\star}</span> ,  <span class="math">\\mathbf{z}</span>  as  <span class="math">\\mathbf{f}</span> , and  <span class="math">\\operatorname{col}</span>  as  <span class="math">\\operatorname{addr}</span> . It is non-trivial to construct this protocol for this relation in the streaming model. At first glance, it would appear that random access to the vector  <span class="math">\\mathbf{f}</span>  is necessary, since  <span class="math">\\mathbf{f}^{\\star}</span>  is indexed both by  <span class="math">i \\in [N]</span>  and by  <span class="math">\\operatorname{addr}_i</span> . To overcome these issues, we require the stream of the index  <span class="math">\\operatorname{addr}</span>  to be implemented as two different streaming oracles.</p>

    <p class="text-gray-300">(i)  <span class="math">S(\\mathrm{addr})</span> , the stream of the vector addr; (ii)  <span class="math">S_{\\mathrm{sort}}(\\mathrm{addr})</span> , the stream of the vector addr, sorted in decreasing order.</p>

    <p class="text-gray-300">The previous literature studying PIOPs for  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span>  essentially follows two different approaches: the plookup protocol and the offline-memory checking protocol. Only the plookup protocol is compatible with our elastic model. In the following sections, we discuss both of these two lookup protocols and their limitations.</p>

    <p class="text-gray-300">Theorem 8.4. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span>  with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M log M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log M)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log M) passes |  |  |  |  |   |</p>

    <p class="text-gray-300">Remark 8.5. In the lookup protocol, the verifier needs to query the polynomial  <span class="math">\\mathbf{f}(x) = \\sum_{i=0}^{d} i \\cdot x^i</span>  at a random point  <span class="math">\\alpha</span> . This can be computed in time  <span class="math">O(\\log d)</span>  with  <span class="math">\\mathbf{f}(\\alpha) = \\frac{\\alpha(1 - \\alpha^d)}{(1 - \\alpha)^2} - \\frac{d\\alpha^{d+1}}{1 - \\alpha}</span> , by differentiating the geometric series formula. If  <span class="math">\\alpha = 1</span> , we obtain the well-known formula  <span class="math">\\mathbf{f}(1) = d(d + 1)/2</span> .</p>

    <p class="text-gray-300">This technique was previously employed in [GW20; BCG20]. It expresses the lookup as a polynomial relation of this form:</p>

    <p class="text-gray-300">Lemma 8.6 ([GW20, Claim 3.1]). Let  <span class="math">\\mathbf{f}^{<em>}\\in \\mathbb{F}^{M}</span>  and  <span class="math">\\mathbf{f}\\in \\mathbb{F}^N</span> . Then  <span class="math">\\mathbf{f}^{</em>}\\subseteq \\mathbf{f}</span>  if and only if there exists  <span class="math">\\mathbf{w}\\in \\mathbb{F}^{M + N}</span>  such that the equation below in  <span class="math">\\mathbb{F}[Y,Z]</span>  is satisfied:</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {j = 0} ^ {M + N - 1} \\left(Y (1 + Z) + w _ {j + 1} + w _ {j} \\cdot Z\\right) = (1 + Z) ^ {M} \\prod_ {j = 0} ^ {M - 1} \\left(Y + f _ {j}\\right) \\prod_ {j = 0} ^ {N - 1} \\left(Y (1 + Z) + f _ {j + 1} + f _ {j} \\cdot Z\\right) \\tag {25}</span></div>

    <p class="text-gray-300">where indices are taken (respectively) modulo  <span class="math">M + N</span> ,  <span class="math">N</span> . If  <span class="math">\\mathbf{f}^<em> \\subseteq \\mathbf{f}</span> , then  <span class="math">\\mathbf{w} := \\operatorname{sort}(\\mathbf{f}^</em>, \\mathbf{f})</span>  satisfies Equation 25.</p>

    <p class="text-gray-300">In the above equation, we consider the subset relation  <span class="math">\\mathbf{a} \\subseteq \\mathbf{d}</span> , and use  <span class="math">\\mathbf{a}_{\\odot}</span>  to denote the rotation of the vector  <span class="math">\\mathbf{a}</span> . Therefore, it is sufficient to test the above polynomial equality over two random points in the field.</p>

    <p class="text-gray-300">As the above equation will prove a simpler subset statement that  <span class="math">\\mathbf{a} \\subseteq \\mathbf{d}</span> , we will hash the values with their indices to prove the lookup relation  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span> : the verifier sends  <span class="math">\\eta \\in \\mathbb{F}</span>  sampled uniformly ar random and then, the prover defines:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {a} := \\mathbf {z} ^ {*} + \\eta \\cdot \\operatorname {c o l} \\tag {26}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {d} := \\mathbf {z} + \\eta \\cdot [ N ]</span></div>

    <p class="text-gray-300">We proceed similarly for  <span class="math">\\mathbf{r}_U^*</span> , and  <span class="math">\\mathbf{r}_U</span> . We note that there is no need to send these oracles to the verifier: the verifier simply needs to substitute Equation 26 and ask for an evaluation in the vectors composing it.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Remark 8.7.</h6>

    <p class="text-gray-300">Note that the verifier does not have the oracle access to the shift vectors <span class="math">\\mathbf{d}_{\\circ}</span> and <span class="math">\\mathbf{w}_{\\circ}</span>. To avoid having the prover send the shifted oracles and having the verifier check consistency between them, the prover can add a leading zero to <span class="math">\\mathbf{d}</span> and <span class="math">\\mathbf{w}</span>. The plookup relation Equation 25 still holds as long as there is no zero entry in the set, which is guaranteed by the algebraic hash. As a result, the verifier can obtain the evaluation of the shifted oracles as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{d}_{\\circ}(x)=x^{N}\\mathbf{d}(x)\\qquad\\mathbf{w}_{\\circ}(x)=x^{N+M}\\mathbf{w}(x)\\enspace.</span> (27)</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Construction 8.</h6>

    <p class="text-gray-300">We construct a PIOP for the indexed relation <span class="math">\\mathcal{R}_{\\text{LU}}</span>. Given <span class="math">\\mathfrak{i}=\\mathsf{addr}</span> as input, the indexer algorithm outputs <span class="math">\\mathsf{addr}</span> as an oracle message. The prover <span class="math">\\mathcal{P}</span> takes as input an index <span class="math">\\mathfrak{i}=\\mathsf{addr}</span>, instance <span class="math">\\mathbbm{x}=(\\mathbb{F},M,N)</span>, and witness <span class="math">\\mathbbm{w}=(\\mathbf{f}^{*},\\mathbf{f})</span>; the verifier <span class="math">\\mathcal{V}</span> has query access to the index <span class="math">\\mathfrak{i}</span> and the witness <span class="math">\\mathbbm{w}</span> and takes as input the instance <span class="math">\\mathbbm{z}</span>. The protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathcal{P}</span> constructs and sends the oracle message <span class="math">\\mathbf{w}</span> to the verifier <span class="math">\\mathcal{V}</span>.</li>

      <li>The verifier <span class="math">\\mathcal{V}</span> samples random elements <span class="math">\\upsilon,\\zeta\\leftarrow\\mathbb{F}^{\\times}</span> and sends them to <span class="math">\\mathcal{P}</span>.</li>

      <li>The prover <span class="math">\\mathcal{P}</span> computes:</li>

    </ul>

    <p class="text-gray-300"><span class="math">e_{a}</span> <span class="math">\\coloneqq\\prod_{j=0}^{M-1}(a_{j}+\\zeta)</span> <span class="math">e_{d}</span> <span class="math">\\coloneqq\\prod_{j=0}^{N-1}((1+\\zeta)\\upsilon+d_{\\circ_{j}}+\\zeta d_{j})</span> <span class="math">e_{w}</span> <span class="math">\\coloneqq\\prod_{j=0}^{M+N-1}((1+\\zeta)\\upsilon+w_{\\circ_{j}}+\\zeta w_{j})</span></p>

    <p class="text-gray-300">and sends them to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathcal{V}</span> checks that <span class="math">(1+\\upsilon)^{M}e_{a}e_{d}=e_{w}</span></li>

      <li>The prover <span class="math">\\mathcal{P}</span> and the verifier <span class="math">\\mathcal{V}</span> engage (in parallel) the entry-product subprotocol with the following statements and witnesses:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>entry product with statement <span class="math">\\mathbbm{z}=(\\mathbb{F},M,e_{a})</span> and witness <span class="math">\\mathbbm{w}=(\\mathbf{a}+\\upsilon)</span>;</li>

      <li>entry product with statement <span class="math">\\mathbbm{z}=(\\mathbb{F},N,e_{d})</span> and witness <span class="math">\\mathbbm{w}=((1+\\zeta)\\upsilon+\\mathbf{d}_{\\circ}+\\zeta\\mathbf{d})</span>;</li>

      <li>entry product with statement <span class="math">\\mathbbm{z}=(\\mathbb{F},N+M,e_{w})</span> and witness <span class="math">\\mathbbm{w}=((1+\\zeta)\\upsilon+\\mathbf{w}_{\\circ}+\\zeta\\mathbf{w})</span>.</li>

    </ul>

    <p class="text-gray-300">In order to achieve space-efficiency, we design the algorithm in Figure 6 to realize the stream of the vectors in Construction 8. For example, we can use <span class="math">\\mathcal{S}_{\\text{set}}(\\mathcal{S}_{\\text{merge}}(\\mathbf{z}_{U}^{*},\\mathbf{z}))</span> to construct the stream of the sorted vector <span class="math">\\mathbf{w}</span>.</p>

    <h4 id="sec-99" class="text-lg font-semibold mt-6">8.2.2 Memory checking</h4>

    <p class="text-gray-300">The offline memory-checking technique originated in <em>[x1]</em> and was used in prior argument systems <em>[x24, x25]</em>. It can be used to prove claims of the form <span class="math">\\mathbf{f}^{*}\\subset\\mathbf{f}</span>, but and unlike the plookup protocol some</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 6: Stream of the vectors for the lookup protocol.</p>

    <p class="text-gray-300">oracles can be computed by the indexer. The indexer, for the specific relation  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span> , computes three oracles from the index addr: the read timestamp read-ts, the write timestamp write-ts, and the audit timestamp audit-ts as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\text {r e a d - t s} := \\left(\\max  j \\in [ M ]: \\operatorname {a d d r} _ {j} = \\operatorname {a d d r} _ {i}\\right) _ {i \\in \\operatorname {a d d r}}, \\tag {28}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text {w r i t e - t s} := [ N ], \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text {a u d i t - t s} := \\left(\\max  j &amp;lt;   i: \\operatorname {a d d r} _ {j} = \\operatorname {a d d r} _ {i}\\right) _ {i \\in \\operatorname {a d d r}}. \\tag {30}</span></div>

    <p class="text-gray-300">If, at the  <span class="math">i</span> -th position, no such maximum exists, the element is set to zero. At the core of the memory-checking protocol there is the following polynomial relation.</p>

    <p class="text-gray-300">Theorem 8.8. Let  <span class="math">\\mathbf{f}^{<em>}\\in \\mathbb{F}^{M}</span> ,  <span class="math">\\mathbf{f}\\in \\mathbb{F}^N</span> , and  <span class="math">\\mathrm{addr}\\in [N]^M</span> . We have  <span class="math">\\mathbf{f}_i^</em> = \\mathbf{f}_{\\mathrm{addr}_i}</span>  for all  <span class="math">i\\in [M]</span>  if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_ {j = 1} ^ {N} \\left(X - \\mathrm {H} _ {Y} (j, \\mathbf {f} _ {j})\\right) \\cdot \\prod_ {j = 1} ^ {M} \\left(X - \\mathrm {H} _ {Y} \\left(\\operatorname {a d d r} _ {j}, \\mathbf {f} _ {j} ^ {*}, \\text {w r i t e - t s} _ {j}\\right)\\right) \\tag {31} \\\\ = \\prod_ {j = 1} ^ {M} \\left(X - \\mathrm {H} _ {Y} \\left(\\operatorname {a d d r} _ {j}, \\mathbf {f} _ {j} ^ {*}, \\text {r e a d - t s} _ {j}\\right)\\right) \\cdot \\prod_ {j = 1} ^ {N} \\left(X - \\mathrm {H} _ {Y} (j, \\mathbf {f} _ {j}, \\text {a u d i t - t s} _ {j})\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathrm{H}_Y(a,b,c) = a + Y\\cdot b + Y^2\\cdot c</span> , and read-ts, write-ts and audit-ts are vectors produced by the offline memory-checking procedure described in [Set20].</p>

    <p class="text-gray-300">The prior work [Set20] expresses Equation 31 in the circuit, and leverages an external proof system to generate the proof. In contrast, we reduce the Equation 31 into four entry product arguments. The verifier samples random challenges  <span class="math">\\beta, \\sigma \\in \\mathbb{F}^{\\times}</span> , and both parties engage in the entry product protocols for  <span class="math">X = \\beta</span>  and  <span class="math">Y = \\sigma</span> . As discussed in Section 2.7.2, the offline-memory checking is only compatible with the lookup claim  <span class="math">(\\mathbf{z}^{*}, \\mathrm{col}) \\subseteq (\\mathbf{z}, [N])</span> .</p>

    <p class="text-gray-300">The timestamp oracles read-ts, write-ts, and audit-ts can be computed in linear-time by the indexer, as shown in Fig. 7. Then if the underlying entry product protocol is linear-time, the overall offline memory-checking protocol is also linear-time. We now consider the space-efficient realization. The biggest challenge</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 7: Linear-time algorithm for generating the timestamp vectors in Construction 9 [BEGKN91; Set20].</p>

    <p class="text-gray-300">is to produce the streams of timestamp oracles read-ts, write-ts, and audit-ts. However, we observe that because we organize the non-zero entries in the column-major order, the elements in the stream of  <span class="math">\\mathsf{col}_U</span>  are in non-descending order. As a result, the streams of read-ts, write-ts, and audit-ts can be computed by a single pass of  <span class="math">\\mathsf{col}_U</span> .</p>

    <p class="text-gray-300"><strong>Construction 9.</strong> We construct a holographic PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{LU}}</span> . On input addr, the indexer produces the oracle messages read-ts, audit-ts. The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\mathbf{i} = \\mathbf{addr}</span> , instance  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, N)</span> , and witness  <span class="math">\\mathbf{w} = (\\mathbf{f}^*, \\mathbf{f})</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\mathbf{i}</span>  and the instance  <span class="math">\\mathbf{x}</span> . The prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\mathcal{V}</span>  samples random elements  <span class="math">\\beta, \\sigma \\gets \\mathbb{F}^{\\times}</span>  and sends them to  <span class="math">\\mathcal{P}</span> .</li>

      <li>The prover  <span class="math">\\mathcal{P}</span>  computes:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e _ {\\text {i n i t}} = \\prod_ {j = 1} ^ {N} (\\beta - \\mathrm {H} _ {\\sigma} (j, f _ {j})),</span></div>

    <div class="my-4 text-center"><span class="math-block">e _ {\\mathrm {w s}} = \\prod_ {j = 1} ^ {M} (\\beta - \\mathrm {H} _ {\\sigma} (\\mathsf {a d d r} _ {j}, f _ {j} ^ {*}, \\mathsf {w r i t e - t s} _ {j})),</span></div>

    <div class="my-4 text-center"><span class="math-block">e _ {\\mathrm {r s}} = \\prod_ {j = 1} ^ {M} (\\beta - \\mathrm {H} _ {\\sigma} (\\mathsf {a d d r} _ {j}, f _ {j} ^ {*}, \\mathsf {r e a d - t s} _ {j})),</span></div>

    <div class="my-4 text-center"><span class="math-block">e _ {\\mathrm {a s}} = \\prod_ {j = 1} ^ {N} (\\beta - \\mathrm {H} _ {\\sigma} (j, f _ {j}, \\mathsf {a u d i t - t s} _ {j}))</span></div>

    <p class="text-gray-300">and sends them to the verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\mathcal{V}</span>  checks that  <span class="math">e_{\\mathrm{init}} \\cdot e_{\\mathrm{ws}} = e_{\\mathrm{rs}} \\cdot e_{\\mathrm{as}}</span></li>

      <li>Let init, as  <span class="math">\\in \\mathbb{F}^N</span>  and ws, rs  <span class="math">\\in \\mathbb{F}^M</span>  denote the vectors involved in each entry product. The prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  engage entry-product subprotocols with the following statements and witnesses:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>entry product with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, e_{\\mathrm{init}})</span>  and witness  <span class="math">\\mathbf{w} = \\mathbf{init}</span> ;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>entry product with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, e_{\\mathrm{ws}})</span>  and witness  <span class="math">\\mathbf{w} = \\mathbf{ws}</span> ;</li>

      <li>entry product with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, M, e_{\\mathrm{rs}})</span>  and witness  <span class="math">\\mathbf{w} = \\mathbf{rs}</span> ;</li>

      <li>entry product with statement  <span class="math">\\mathbf{x} = (\\mathbb{F}, N, e_{\\mathrm{as}})</span>  and witness  <span class="math">\\mathbf{w} = \\mathbf{as}</span> .</li>

    </ul>

    <p class="text-gray-300">An oracle query to e.g. init in a subprotocol is made by taking the appropriate linear combination of queries to  <span class="math">(0, \\dots, N - 1)</span> ,  <span class="math">\\mathbf{f}</span>  and  <span class="math">0^N</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{f}</span>  be a monic polynomial whose product of coefficients is  <span class="math">e</span> . We design a proof system for proving that  <span class="math">e = \\prod_{i} f_{i}</span> . More formally:</p>

    <p class="text-gray-300">Definition 8.9. The entry product relation  <span class="math">\\mathcal{R}_{\\mathrm{EP}}</span>  is the set of tuples  <span class="math">(\\mathbf{i},\\mathbf{x},\\mathbf{w}) = (\\perp,(\\mathbb{F},N,e),\\mathbf{f})</span>  where  <span class="math">\\mathbf{f}\\in \\mathbb{F}^N</span>  and  <span class="math">\\prod_{i = 0}^{N - 1}f_i = e</span> .</p>

    <p class="text-gray-300">Theorem 8.10. For every finite field  <span class="math">\\mathbb{F}</span>  and positive integer  <span class="math">N</span> , there is a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{EP}}</span>  with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(log N) passes |  |  |  |  |   |</p>

    <p class="text-gray-300">We can evaluate Equation 32 at a random point  <span class="math">\\alpha</span>  and check it using a scalar-product protocol. This requires one scalar-product protocol and two evaluation queries.</p>

    <p class="text-gray-300"><strong>Construction 10.</strong> We construct a PIOP for the indexed relation  <span class="math">\\mathcal{R}_{\\mathrm{EP}}</span> . The prover  <span class="math">\\mathcal{P}</span>  takes as input an index  <span class="math">\\mathbf{i} = \\bot</span> , instance  <span class="math">\\mathbf{x} = (\\mathbb{F}, N, e)</span> , and witness  <span class="math">\\mathbf{w} = \\mathbf{f}</span> ; the verifier  <span class="math">\\mathcal{V}</span>  takes as input the index  <span class="math">\\mathbf{i}</span>  and the instance  <span class="math">\\mathbf{x}</span> . The prover  <span class="math">\\mathcal{P}</span>  and the verifier  <span class="math">\\mathcal{V}</span>  proceed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover  <span class="math">\\mathcal{P}</span>  constructs  <span class="math">\\mathbf{g} \\coloneqq (\\prod_{i \\geq 0} f_i, \\prod_{i \\geq 1} f_i, \\ldots, f_{N-2} f_{N-1}, f_{N-1})</span> , and sends the field element  <span class="math">f_{N-1}</span>  and the oracle message  <span class="math">\\mathbf{g}</span>  to the verifier.</li>

      <li>The verifier samples a random  <span class="math">\\alpha \\gets \\mathbb{F}^{\\times}</span>  and sends it to the prover.</li>

      <li>The verifier queries the oracle for  <span class="math">\\mathbf{g}</span>  to learn  <span class="math">\\mathbf{g}(\\alpha)</span> , and the prover and verifier compute  <span class="math">u := \\mathbf{g}(Y)Y + f_{N - 1}(e - Y^N)</span> .</li>

    </ul>

    <p class="text-gray-300">The prover  <span class="math">\\mathcal{P}</span>  and verifier  <span class="math">\\mathcal{V}</span>  engage in a twisted scalar-product protocol (Construction 3) with index  <span class="math">\\mathbf{i} = \\bot</span> , instance  <span class="math">\\mathbf{x} = (\\mathbb{F}, N, \\mathbf{y}, u)</span> , and witness  <span class="math">\\mathbf{w} = (\\mathbf{g} \\circ \\mathbf{y}, \\mathbf{f}_{\\odot})</span>  and produces claims that  <span class="math">A = \\langle \\mathbf{g}, \\otimes_{j}(1, v_{j} \\rho_{j}) \\rangle</span>  and  <span class="math">C = \\langle \\mathbf{f}_{\\odot}, \\otimes_{j}(1, \\rho_{j}) \\rangle</span> . where  <span class="math">\\mathbf{y} = (\\alpha^{0}, \\ldots, \\alpha^{N-1}) = \\otimes_{j}(1, v_{j})</span>  and  <span class="math">(\\rho_{0}, \\ldots, \\rho_{n-1})</span>  are the verifier randomnesses in the scalar product protocol. They check these claims using the tensor product protocol (Construction 1).</p>

    <p class="text-gray-300">Lemma 8.11. Let  <span class="math">\\mathbf{f},\\mathbf{g}\\in \\mathbb{F}^N</span>  , with  <span class="math">f_{N - 1}\\neq 0</span>  . Let  <span class="math">e\\in \\mathbb{F}</span>  . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf {g} \\circ \\mathbf {Y}, \\mathbf {f} _ {\\odot} \\rangle = \\mathbf {g} (Y) Y + f _ {N - 1} \\left(e - Y ^ {N}\\right) \\tag {32}</span></div>

    <p class="text-gray-300">if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} := \\left(\\prod_ {i \\geq 0} f _ {i}, \\prod_ {i \\geq 1} f _ {i}, \\dots , f _ {N - 2} f _ {N - 1}, f _ {N - 1}\\right).</span></div>

    <p class="text-gray-300">and  <span class="math">\\prod_{i\\geq 0}f_i = e</span></p>

    <p class="text-gray-300">Proof. If  <span class="math">\\mathbf{f} = (f_0, f_1, f_2, \\ldots, f_{N-1})</span> , then  <span class="math">\\mathbf{f}_{\\odot} = (f_{N-1}, f_0, f_1, \\ldots, f_{N-2})</span> , so</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf {g} \\circ \\mathbf {Y}, \\mathbf {f} _ {\\odot} \\rangle = g _ {0} f _ {N - 1} + g _ {1} f _ {0} Y + \\dots + g _ {N - 2} f _ {N - 3} Y ^ {N - 2} + g _ {N - 1} f _ {N - 2} Y ^ {N - 1}. \\tag {33}</span></div>

    <p class="text-gray-300">We also have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {g} (Y) Y + f _ {N - 1} \\left(e - Y ^ {N}\\right) = \\sum_ {i = 1} ^ {N - 1} g _ {i - 1} Y ^ {i} + f _ {N - 1} e + g _ {N - 1} Y ^ {N} - f _ {N - 1} Y ^ {N}. \\tag {34}</span></div>

    <p class="text-gray-300">Comparing coefficients shows that the polynomials in Equation 33 and Equation 34 are equal if and only if  <span class="math">g_{i} = g_{i + 1}f_{i}</span>  for  <span class="math">i\\in [N - 1]</span> , with  <span class="math">g_{N - 1} = f_{N - 1}</span>  and  <span class="math">g_0f_{N - 1} = ef_{N - 1}</span> . Since  <span class="math">f_{N - 1}\\neq 0</span> , the claim follows.</p>

    <p class="text-gray-300">Remark 8.12. Construction 10 requires  <span class="math">\\mathbf{f}</span>  to be a monic polynomial, however, the polynomial  <span class="math">\\mathbf{f}&#x27;</span>  in the lookup protocol does not satisfy this condition. To solve that, the prover and the verifier run the entry product for  <span class="math">\\mathbf{f}(x) = \\mathbf{f}&#x27;(x) + x^n</span> . Note that the claim of the entry product remains the same. Moreover, the verifier can easily query the shifted oracle as follows:  <span class="math">\\mathbf{f}_{\\odot}(x) = 1 + x\\mathbf{f}&#x27;(x)</span> .</p>

    <p class="text-gray-300">47</p>

    <p class="text-gray-300">We use polynomial commitment schemes to compile our PIOPs into cryptographic arguments. We require elastic polynomial commitment schemes to compile elastic PIOPs into elastic argument systems. We will use the same polynomial commitment scheme as [CHMMVW20], which is a variant of the construction in [KZG10]. Our contribution is to show that this scheme has elastic commitment and opening algorithms.</p>

    <p class="text-gray-300">Theorem 9.1. The commitment scheme of [CHMMVW20] is elastic, with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">check time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commitment and opening sizes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MSM(D) ops</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(D) ops</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(D) ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D) SM ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D) SM ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) SM + O(1) PA</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) GE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(D) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) SM memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) SM memory</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) passes</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) passes</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the above theorem, we let MSM denote multi-scalar exponentiation, SM denotes exponentiation, PA denotes pairing, GE denotes a group element, and  <span class="math">D</span>  denotes the maximum degree of the polynomials. In the rest of this section, we give formal definitions for an elastic polynomial commitment scheme and show how to construct it.</p>

    <p class="text-gray-300">A polynomial commitment scheme over a field family  <span class="math">\\mathcal{F}</span>  is a tuple of algorithms  <span class="math">\\mathrm{PC} = (\\mathrm{Setup},\\mathrm{Com},\\mathrm{Open},\\mathrm{Check})</span>  with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup PC.Setup  <span class="math">(1^{\\lambda}, D) \\to (\\mathrm{ck}, \\mathrm{rk})</span> . On input a security parameter  <span class="math">\\lambda</span>  (in unary), and a maximum degree bound  <span class="math">D \\in \\mathbb{N}</span> , PC.Setup samples a commitment key ck and verification key rk, which contain the description of a finite field  <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> .</li>

      <li>Commit PC.Com(ck, p)  <span class="math">\\rightarrow</span> <span class="math">C</span> . On input ck and a univariate polynomial  <span class="math">\\mathbf{p}</span>  of degree at most  <span class="math">D</span>  over the field  <span class="math">\\mathbb{F}</span> , PC.Com outputs commitment  <span class="math">C</span>  to the polynomial  <span class="math">\\mathbf{p}</span> .</li>

      <li>Open PC.Open(ck, p, z)  <span class="math">\\rightarrow</span> <span class="math">\\pi</span> . On input ck, a univariate polynomial  <span class="math">\\mathbf{p}</span> , degree bounds  <span class="math">D</span> , and a query point  <span class="math">z \\in \\mathbb{F}</span> , PC.Open outputs an evaluation proof  <span class="math">\\pi</span> .</li>

      <li>Check PC.Check(rk,  <span class="math">C, z, v, \\pi) \\in \\{0, 1\\}</span> . On input rk, the commitment  <span class="math">C</span> , query point  <span class="math">z \\in \\mathbb{F}</span> , alleged evaluation  <span class="math">v</span> , and an evaluation proof  <span class="math">\\pi</span> , PC.Check outputs 1 if  <span class="math">\\pi</span>  attests that the polynomial  <span class="math">\\mathbf{p}</span>  committed in  <span class="math">C</span>  has degree at most  <span class="math">D</span>  and evaluates to  <span class="math">v</span>  at  <span class="math">z</span> .</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme PC must satisfy completeness and extractability.</p>

    <p class="text-gray-300">Definition 9.2 (Completeness). For every degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} &amp;amp; (\\mathrm {c k}, \\mathrm {r k}) \\leftarrow \\mathrm {P C . S e t u p} (1 ^ {\\lambda}, D) \\\\ \\deg (\\mathbf {p}) \\leq D &amp;amp; (\\mathbf {p}, z) \\leftarrow \\mathcal {A} (\\mathrm {c k}, \\mathrm {r k}) \\\\ \\Downarrow &amp;amp; C \\leftarrow \\mathrm {P C . C o m} (\\mathrm {c k}, \\mathbf {p}) \\\\ \\mathrm {P C . C h e c k} (\\mathrm {r k}, C, z, v, \\pi , \\xi) = 1 &amp;amp; v = \\mathbf {p} (z) \\\\ &amp;amp; \\pi \\leftarrow \\mathrm {P C . O p e n} (\\mathrm {c k}, \\mathbf {p}, z) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition 9.3 (Extractability). For every degree bound  <span class="math">D \\in \\mathbb{N}</span>  and efficient adversary  <span class="math">\\mathcal{A}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for every round bound  <span class="math">r \\in \\mathbb{N}</span> , efficient query sampler  <span class="math">\\mathcal{Q}</span> , and efficient adversary  <span class="math">\\mathcal{B}</span>  the probability below is negligibly close to 1 (as a function of  <span class="math">\\lambda</span> ):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PC.Check(rk, C, z, v, π) = 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(ck, rk) ← PC.Setup(1λ, D)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">C ← A(ck, rk)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |   |  p ← E(ck, rk)  |</p>

    <p class="text-gray-300">|   |   |  z ← Q(ck, rk)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg(p) ≤ D and v = p(z)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(π, v, st) ← B(ck, rkz)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(The above definition captures the case where  <span class="math">\\mathcal{A},\\mathcal{Q},\\mathcal{B}</span>  share the same random string to win the game.)</p>

    <p class="text-gray-300">The polynomial commitment scheme of [KZG10] consists of the following algorithms.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup PC.Setup  <span class="math">(1^{\\lambda},D)\\to \\mathsf{ck}</span> . First, PC.Setup samples a bilinear group  <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,G,H,e)\\gets</span>  SampleGrp  <span class="math">(1^{\\lambda})</span> . Next, PC.Setup samples  <span class="math">\\beta \\in \\mathbb{F}</span> , computes  <span class="math">\\beta H</span>  and computes the vector</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {\\Sigma} = \\left(G _ {D}, G _ {D - 1}, \\dots , G _ {1}, G _ {0}\\right) := \\left( \\begin{array}{c c c c} \\beta^ {D} G &amp;amp; \\beta^ {D - 1} G &amp;amp; \\dots &amp;amp; \\beta G &amp;amp; G \\end{array} \\right) \\in \\mathbb {G} _ {1} ^ {D + 1}.</span></div>

    <p class="text-gray-300">Finally, PC.Setup outputs  <span class="math">\\mathsf{ck} \\coloneqq ((\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, G, H, e), \\Sigma)</span>  and  <span class="math">\\mathsf{rk} \\coloneqq (G, H, \\beta H)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Commit PC.Com(ck, p)  <span class="math">\\rightarrow</span> <span class="math">C</span> . The commitment algorithm PC.Com parses  <span class="math">\\mathbf{p}(X) \\in \\mathbb{F}[X]</span>  of degree  <span class="math">d \\leq D</span>  as  <span class="math">\\sum_{j=0}^{d} p_j X^j</span>  and outputs  <span class="math">C := \\sum_{j=0}^{d} p_j \\cdot G_j \\in \\mathbb{G}_1</span> .</li>

      <li>Open PC.Open(ck, p, z)  <span class="math">\\rightarrow</span> <span class="math">\\pi</span> . The opening algorithm PC.Open computes witness polynomial  <span class="math">\\mathbf{w}(X) := \\frac{\\mathbf{p}(X) - \\mathbf{p}(z)}{X - z}</span> , parses  <span class="math">\\mathbf{w}(X)</span>  as  <span class="math">\\sum_{j=0}^{d-1} w_j X^j</span>  and outputs the evaluation proof  <span class="math">\\pi := \\sum_{j=0}^{d-1} w_j G_j \\in \\mathbb{G}_1</span> .</li>

      <li>Check PC.Check(rk, C, z, v, π) ∈ {0, 1}. The check algorithm PC.Check outputs 1 if and only if  <span class="math">e(C - vG, H) = e(\\pi, \\beta H - zH)</span> .</li>

    </ul>

    <p class="text-gray-300">Below we explain how to implement this scheme in small space using streaming algorithms. We only need to consider the Com and Open algorithms, since the Check algorithm is succinct and the setup algorithm has natural time-and-space-efficient realizations.</p>

    <p class="text-gray-300">The stream  <span class="math">S(\\Sigma)</span>  of the vector  <span class="math">\\Sigma</span>  is simply the sequence  <span class="math">(G_D, \\ldots, G_0)</span> . The stream  <span class="math">S(\\mathbf{p})</span>  associated with the polynomial  <span class="math">\\mathbf{p} = \\sum_{j=0}^{D} p_j X^j</span>  is the sequence  <span class="math">(p_d, \\ldots, p_0)</span> . Note that it is important that  <span class="math">S(\\Sigma)</span>  and  <span class="math">S(\\mathbf{p})</span>  are ordered from highest powers of  <span class="math">\\beta</span>  and  <span class="math">X</span>  to lowest in order to support an efficient PC.Open algorithm.</p>

    <p class="text-gray-300">Commit. On input  <span class="math">((\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,G,H,e),\\mathcal{S}(\\Sigma),\\mathcal{S}(\\mathbf{p}))</span> <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span>  .Com sets  <span class="math">C = 0\\in \\mathbb{G}_1</span>  . Then, for  <span class="math">j = d,d - 1,\\ldots ,0</span> <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span>  .Com uses the streaming oracles to get  <span class="math">p_j = S(\\mathbf{p}).\\mathrm{next}()</span>  and  <span class="math">G_{j} = S(\\Sigma).\\mathrm{next}()</span>  and computes  <span class="math">C\\coloneqq C + p_jG_j</span>  . Otherwise,  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span>  .Com outputs  <span class="math">C\\in \\mathbb{G}_1</span></p>

    <p class="text-gray-300">Note that  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span> . Com only needs to store the value of  <span class="math">C</span>  throughout the entire loop.</p>

    <p class="text-gray-300">Open. On input  <span class="math">((\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,q,G,H,e),\\mathcal{S}(\\Sigma),\\mathcal{S}(\\mathbf{p}))</span> , evaluation point  <span class="math">z\\in \\mathbb{F}</span> , opening challenge  <span class="math">\\xi \\in \\mathbb{F}</span> ,  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span> . Open sets  <span class="math">\\pi = 0\\in \\mathbb{G}_1</span>  and  <span class="math">w_{d}\\coloneqq 0\\in \\mathbb{F}</span> , and consumes the first element of the stream  <span class="math">\\mathcal{S}(\\Sigma)</span>  by fetching  <span class="math">G_{d} = \\mathcal{S}(\\Sigma)</span> . next().</p>

    <p class="text-gray-300">Then, for  <span class="math">j = d - 1, \\ldots, 0</span> ,  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span> . Open uses the streaming oracles to get  <span class="math">p_{j + 1} = S(\\mathbf{p})</span> . next() and  <span class="math">G_{j} = S(\\boldsymbol{\\Sigma})</span> . next(), and computes  <span class="math">w_{j} := p_{j + 1} + w_{j + 1}z</span>  and  <span class="math">\\pi := \\pi + w_{j}G_{j}</span> .</p>

    <p class="text-gray-300">Finally,  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span>  .Com outputs  <span class="math">\\pi \\in \\mathbb{G}_1</span></p>

    <p class="text-gray-300">Note that  <span class="math">\\mathsf{PC}_{\\mathbf{s}}</span> . Com only needs to store the values of  <span class="math">\\pi</span> ,  <span class="math">w_{j+1}</span>  for the next iteration of the loop.</p>

    <p class="text-gray-300">Remark 9.4. The Open and Check algorithms (as well as the completeness and extractability properties) can be generalized as in [CHMMVW20; BDFG20] to allow batched opening and evaluation checking. Given polynomials  <span class="math">\\mathbf{p}_0, \\ldots, \\mathbf{p}_{m-1}</span>  and claimed evaluations  <span class="math">v_0, \\ldots, v_{m-1}</span>  at a point  <span class="math">z</span> , the party verifying the commitment and openings selects a random opening challenge  <span class="math">\\xi \\in \\mathbb{F}</span> , and the PC.Open and PC.Check algorithms are run on polynomial  <span class="math">\\mathbf{p} := \\sum_{i=0}^{m-1} \\xi^i \\mathbf{p}_i</span>  and claimed evaluation  <span class="math">v := \\sum_{i=0}^{m-1} \\xi^i v_i</span> . Given points  <span class="math">z_0, \\ldots, z_\\ell</span>  and claimed evaluations  <span class="math">v_0, \\ldots, v_\\ell</span> , the evaluation proof defines  <span class="math">\\mathbf{Z}(X) := \\prod_i (X - z_i)</span> . Let  <span class="math">\\mathbf{q}(X)</span>  and  <span class="math">\\mathbf{r}(X)</span>  be respectively quotient and reminder of the Euclidean division between  <span class="math">\\mathbf{p}(X)</span>  and  <span class="math">\\mathbf{Z}(X)</span> . Let  <span class="math">R, Z \\in \\mathbb{G}</span>  be the group elements associated to  <span class="math">\\mathbf{r}(X)</span>  and  <span class="math">\\mathbf{Z}(X)</span> . The evaluation proof is  <span class="math">\\pi := \\langle \\mathbf{q}(X), \\mathrm{ck} \\rangle</span>  while the evaluations are obtained as  <span class="math">v_i := \\mathbf{r}(z_i)</span> . The PC.Check algorithm reconstructs  <span class="math">\\mathbf{r}(X)</span>  from the claimed evaluations via polynomial interpolation and checks that  <span class="math">e(C - R, H) = e(\\pi, Z)</span> .</p>

    <p class="text-gray-300">We briefly describe how the PC.Open algorithm can be implemented in small space. The stream  <span class="math">S(\\mathbf{p})</span>  can be computed by a streaming algorithm that uses  <span class="math">O(m\\ell D)</span>  operations,  <span class="math">O(\\ell)</span>  space (never storing more than  <span class="math">\\mathbf{p}_i, \\ldots, \\mathbf{p}_{i - \\ell + 1}</span>  coefficients for the partial computation of the opening), and a single pass over each of the  <span class="math">m</span>  polynomials  <span class="math">\\mathbf{p}_i</span> . Composing this streaming algorithm with the opening algorithm using Lemma 4.6 gives a batched opening algorithm.</p>

    <p class="text-gray-300">The complexity of batched operations for PC is given in the following table.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">check time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">opening size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(D) SM + O(mℓD) F ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D) SM + O(mℓD) F ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m+ℓ) SM + O(1) PA</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) GE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">O(mD + mℓ) memory</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ) SM memory</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | O(1) passes  |   |   |</p>

    <p class="text-gray-300">We note that, in Construction 1,  <span class="math">\\ell = 3</span>  as we demand evaluations for  <span class="math">\\beta, -\\beta, \\beta^2</span>  as displayed in Eq. 15.</p>

    <p class="text-gray-300">We describe a compiler that uses elastic polynomial commitment schemes and elastic PIOPs to construct elastic cryptographic arguments.</p>

    <p class="text-gray-300">Theorem 10.1. Consider the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A holographic PIOP over a field family  <span class="math">\\mathcal{F}</span> , for an indexed relation  <span class="math">\\mathcal{R}</span> , with:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indexer time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">message complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tI</td>

            <td class="px-3 py-2 border-b border-gray-700">tPtime sPmemory</td>

            <td class="px-3 py-2 border-b border-gray-700">t'Ptime s'Pmemory kPpasses</td>

            <td class="px-3 py-2 border-b border-gray-700">tVtime</td>

            <td class="px-3 py-2 border-b border-gray-700">ε</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">l</td>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">cc</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a public-coin verifier and non-adaptive queries; and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- message schedule specified by  <span class="math">o</span>  and  <span class="math">d</span>  with output stream ordering  $\\{(a, b, c) : a \\in [k], b \\in [o(a)], c \\in d(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{z}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, a, b)\\}<span class="math">  ordered first in ascending order by round number  </span>a<span class="math"> , then ascending order by oracle number  </span>b<span class="math"> , then descending order by polynomial coefficient  </span>c$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A polynomial commitment scheme PC over a field family  <span class="math">\\mathcal{F}</span> , with</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">setup time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient commitment</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient opening</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">check time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">commitment and opening sizes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tPC.G</td>

            <td class="px-3 py-2 border-b border-gray-700">tPC.Com time sPC.Com space</td>

            <td class="px-3 py-2 border-b border-gray-700">tO time sO memory</td>

            <td class="px-3 py-2 border-b border-gray-700">t'PC.Com time s'PC.Com memory kPC.Com passes</td>

            <td class="px-3 py-2 border-b border-gray-700">t'O time s'O memory po passes</td>

            <td class="px-3 py-2 border-b border-gray-700">tPC.Check</td>

            <td class="px-3 py-2 border-b border-gray-700">PC.Com</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and input ordering  <span class="math">\\{p_d, p_{d-1}, \\ldots, p_0\\}</span>  for all streams of input polynomials  <span class="math">\\mathbf{p}(X) = \\sum_{i=0}^{d} p_i X^i</span> , for the PC.Com and PC.Open algorithms.</p>

    <p class="text-gray-300">Then there is a preprocessing argument for  <span class="math">\\mathcal{R}</span>  with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">generator time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">indexer time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">round complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">communication complexity</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tPC.G</td>

            <td class="px-3 py-2 border-b border-gray-700">tI + o(0) · tPC.Com</td>

            <td class="px-3 py-2 border-b border-gray-700">tV + qtPC.Check</td>

            <td class="px-3 py-2 border-b border-gray-700">ε + negl(λ)</td>

            <td class="px-3 py-2 border-b border-gray-700">k + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">cc + ∑i=1k o(i) ·</td>

            <td class="px-3 py-2 border-b border-gray-700">PC.Com</td>

            <td class="px-3 py-2 border-b border-gray-700">+ q ·</td>

            <td class="px-3 py-2 border-b border-gray-700">PC.Open</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and prover complexity</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time-efficient prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">space-efficient prover</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">tP + ∑i=0k-1o(i) · tPC.Com + q(tO + te) time sP + sPC.Com + sO memory</td>

            <td class="px-3 py-2 border-b border-gray-700">(kPC.Com + po)t'P + ∑i=0k-1o(i) · t'PC.Com + q · (t'O + te) time s'P + ∑i=0k-1o(i) · s'PC.Com + q · s'O + O(q) memory (kPC.Com + po) · kP passes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 10.1 we give formal definitions for preprocessing arguments with a universal structured reference string. In Section 10.2 we present a compiler and prove Theorem 10.1.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">Following [CHMMVW20, Section 7], a preprocessing argument ARG with universal SRS for an indexed relation <span class="math">\\mathcal{R}</span> is a tuple of probabilistic polynomial-time algorithms <span class="math">(\\mathcal{G}_{\\mathrm{ARG}},\\mathcal{I}_{\\mathrm{ARG}},\\mathcal{P}_{\\mathrm{ARG}},\\mathcal{V}_{\\mathrm{ARG}})</span> consisting of a generator <span class="math">\\mathcal{G}_{\\mathrm{ARG}}</span>, an indexer <span class="math">\\mathcal{I}_{\\mathrm{ARG}}</span>, a prover <span class="math">\\mathcal{P}_{\\mathrm{ARG}}</span> and a verifier <span class="math">\\mathcal{V}_{\\mathrm{ARG}}</span> such that the following properties hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For all size bounds <span class="math">\\mathsf{N} \\in \\mathbb{N}</span> and efficient <span class="math">\\mathcal{A}</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{w}) \\notin \\mathcal{R}_{\\mathsf{N}} &amp;amp; \\operatorname{srs} \\leftarrow \\mathcal{G}_{\\mathrm{ARG}}(1^{\\lambda}, \\mathsf{N}) \\\\ \\vee &amp;amp; (\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{w}) \\leftarrow \\mathcal{A}(\\operatorname{srs}) \\\\ \\langle \\mathcal{P}_{\\mathrm{ARG}}(\\mathrm{ipk}, \\mathfrak{z}, \\mathfrak{w}), \\mathcal{V}_{\\mathrm{ARG}}(\\mathrm{ivk}, \\mathfrak{z}) \\rangle = 1 &amp;amp; (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}_{\\mathrm{ARG}}^{\\mathrm{srs}}(\\dot{\\mathfrak{s}}) \\end{array} \\right] = 1.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Soundness.</strong> For all size bounds <span class="math">\\mathsf{N} \\in \\mathbb{N}</span> and efficient <span class="math">\\tilde{\\mathcal{P}} = (\\tilde{\\mathcal{P}}_1, \\tilde{\\mathcal{P}}_2)</span>,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c} (\\dot{\\mathfrak{s}}, \\mathfrak{z}) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathsf{N}}) &amp;amp; \\operatorname{srs} \\leftarrow \\mathcal{G}_{\\mathrm{ARG}}(1^{\\lambda}, \\mathsf{N}) \\\\ \\wedge &amp;amp; (\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{st}) \\leftarrow \\tilde{\\mathcal{P}}_{1}(\\operatorname{srs}) \\\\ \\langle \\tilde{\\mathcal{P}}_{2}(\\mathfrak{st}), \\mathcal{V}_{\\mathrm{ARG}}(\\mathrm{ivk}, \\mathfrak{z}) \\rangle = 1 &amp;amp; (\\mathrm{ipk}, \\mathrm{ivk}) \\leftarrow \\mathcal{I}_{\\mathrm{ARG}}^{\\mathrm{srs}}(\\dot{\\mathfrak{s}}) \\end{array} \\right] = \\operatorname{negl}(\\lambda).</span></div>

    <p class="text-gray-300">All of the constructions in this paper achieve the stronger property of <em>knowledge soundness</em> as defined in [CHMMVW20, Section 7], using the same proof as in [CHMMVW20].</p>

    <p class="text-gray-300">We show how to compile our elastic PIOPs into an elastic argument systems elastic commitment schemes. We follow the compiler construction analysed in [CHMMVW20, Theorem 8.1].</p>

    <p class="text-gray-300"><strong>Construction 11.</strong> As the input PIOP has a public-coin verifier and non-adaptive queries, we assume that all of the verifier queries in the PIOP take place at the end.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Setup.</strong> <span class="math">\\mathsf{srs} \\leftarrow \\mathcal{G}_{\\mathrm{ARG}}(1^{\\lambda}, \\mathsf{N})</span>: Let $D := \\max_{i \\in [k]} \\max_{j \\in [o(i)]} \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, j)<span class="math">. The generator </span>\\mathcal{G}_{\\mathrm{ARG}}<span class="math"> runs PC.Setup</span>(1^{\\lambda}, D)<span class="math"> to get output ck, which contains the description of a finite field </span>\\mathbb{F} \\in \\mathcal{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Offline phase.</strong> In the offline phase ("0-th round"), the indexer <span class="math">\\mathcal{I}_{\\mathrm{ARG}}</span> receives as input a commitment key ck, a field <span class="math">\\mathbb{F} \\in \\mathcal{F}</span> and an index <span class="math">\\dot{\\mathfrak{s}}</span> for <span class="math">\\mathcal{R}</span>. Then <span class="math">\\mathcal{I}_{\\mathrm{ARG}}</span> runs the IOP indexer <span class="math">\\mathcal{I}</span>, which outputs <span class="math">o(0)</span> polynomials <span class="math">\\mathbf{p}_{0,1}, \\ldots, \\mathbf{p}_{0,o(0)} \\in \\mathbb{F}[X]</span> of degrees at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 0, 1), \\ldots, \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, 0, o(0))<span class="math"> respectively. For each polynomial </span>\\mathbf{p}_{0,i}<span class="math">, the indexer </span>\\mathcal{I}_{\\mathrm{ARG}}<span class="math"> computes </span>C_{0,i} = \\mathsf{PC}_s \\cdot \\mathsf{Com}(\\mathsf{ck}, \\mathbf{p}_{0,i}, \\bot)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Online phase.</strong> In the online phase, given the commitment key ck, an instance <span class="math">\\mathfrak{z}</span> and witness <span class="math">\\mathfrak{w}</span> such that <span class="math">(\\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{w}) \\in \\mathcal{R}</span>, the prover <span class="math">\\mathcal{P}_{\\mathrm{ARG}}</span> receives <span class="math">(\\mathbb{F}, \\mathrm{ck}, \\dot{\\mathfrak{s}}, \\mathfrak{z}, \\mathfrak{w})</span> and the verifier <span class="math">\\mathcal{V}</span> receives <span class="math">(\\mathbb{F}, \\mathfrak{z}, \\mathrm{ck})</span> and the commitments produced by <span class="math">\\mathcal{I}_{\\mathrm{ARG}}(\\mathbb{F}, \\dot{\\mathfrak{s}}, \\mathrm{ck})</span>. The prover <span class="math">\\mathcal{P}_{\\mathrm{ARG}}</span> and the verifier <span class="math">\\mathcal{V}_{\\mathrm{ARG}}</span> interact over $\\mathsf{k} + 2 = \\mathsf{k}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 2$ rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For <span class="math">i \\in [\\mathsf{k}]</span>, in the <span class="math">i</span>-th round of interaction, the verifier <span class="math">\\mathcal{V}_{\\mathrm{ARG}}</span> runs <span class="math">\\mathcal{V}</span> and forwards its message <span class="math">\\rho_i \\in \\mathbb{F}^\\times</span> to the prover <span class="math">\\mathcal{P}_{\\mathrm{ARG}}</span>. The prover <span class="math">\\mathcal{P}_{\\mathrm{ARG}}</span> forwards this message to <span class="math">\\mathcal{P}</span> which replies with <span class="math">o(i)</span> oracle polynomials <span class="math">\\mathbf{p}_{i,1}, \\ldots, \\mathbf{p}_{i,o(i)} \\in \\mathbb{F}[X]</span> of degrees at most $\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, 1), \\ldots, \\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{\\mathfrak{s}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, i, o(i))<span class="math"> respectively. For each polynomial </span>\\mathbf{p}_{i,j}<span class="math">, the prover </span>\\mathcal{P}_{\\mathrm{ARG}}<span class="math"> computes the commitment </span>C_{i,j} := \\mathsf{PC.Com}(\\mathsf{ck}, \\mathbf{p}_{i,j}, \\bot)<span class="math"> and sends </span>C_{i,j}<span class="math"> to the verifier </span>\\mathcal{V}_{\\mathrm{ARG}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathcal{V}_{\\mathrm{ARG}}</span> runs <span class="math">\\mathcal{V}</span> to obtain opening queries, each consisting of an evaluation point <span class="math">z \\in \\mathbb{F}</span>, and a pair of indices <span class="math">(i,j)</span> which specify an oracle <span class="math">\\mathbf{p}_{i,j}</span>. The verifier <span class="math">\\mathcal{V}_{\\mathrm{ARG}}</span> forwards all of the queries to</li>

    </ul>

    <p class="text-gray-300">the prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span>. Then, for each query <span class="math">(z,i,j)</span>, the prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> computes <span class="math">v\\coloneqq \\mathbf{p}_{i,j}(z)\\in \\mathbb{F}</span>, computes <span class="math">\\pi \\coloneqq \\mathsf{PC.Open}(\\mathsf{ck},\\mathbf{p}_{i,j},z)</span>, and sends <span class="math">v</span> and <span class="math">\\pi</span> to <span class="math">\\mathcal{V}_{\\mathsf{ARG}}</span>. The verifier <span class="math">\\mathcal{V}_{\\mathsf{ARG}}</span> forwards the evaluation point <span class="math">v</span> to <span class="math">\\mathcal{V}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathcal{V}_{\\mathsf{ARG}}</span> computes <span class="math">b \\gets \\mathsf{PC.Check}(\\mathsf{ck}, C, z, v, \\mathsf{w})</span> for each opening query. If <span class="math">b = 1</span> for every execution of PC.Check, and <span class="math">\\mathcal{V}</span> accepts, then <span class="math">\\mathcal{V}_{\\mathsf{ARG}}</span> accepts. Otherwise, <span class="math">\\mathcal{V}_{\\mathsf{ARG}}</span> rejects.</li>

    </ul>

    <h2 id="sec-107" class="text-2xl font-bold">10.3 Proof of Theorem 10.1</h2>

    <p class="text-gray-300">The completeness and soundness properties, and indexer, prover and verifier efficiency for the time-efficient argument produced by the compiler follow from the proof of [CHMMVW20, Theorem 8.1].</p>

    <p class="text-gray-300">To prove Theorem 10.1, it remains to describe a space-efficient implementation of the prover algorithm Construction 11.</p>

    <p class="text-gray-300"><strong>Construction 12 (space-efficient prover).</strong> We describe a space-efficient prover algorithm for the online phase of ARG.</p>

    <p class="text-gray-300">For <span class="math">i \\in [\\mathsf{k}]</span>, in the <span class="math">i</span>-th round of interaction, <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> initializes <span class="math">o(i)</span> different sessions with the space efficient commitment algorithm <span class="math">\\mathsf{PC.Com}</span>, using <span class="math">o(i)</span> different sessions for the streaming oracle <span class="math">\\mathcal{S}(\\mathsf{ck})</span>, and runs the space-efficient implementation of the prover algorithm <span class="math">\\mathcal{P}</span> (for the <span class="math">i</span>-th round) <span class="math">k_{\\mathsf{PC.Com}}</span> times, forwarding each coefficient of each polynomial <span class="math">\\mathbf{p}_{i,j}(X)</span> to the correct session for <span class="math">\\mathsf{PC.Com}</span>.</p>

    <p class="text-gray-300">To answer the verifier's queries, <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> initializes <span class="math">q</span> different sessions with the <span class="math">\\mathsf{PC.Open}</span> algorithm, using <span class="math">q</span> different sessions for the streaming oracle <span class="math">\\mathcal{S}(\\mathsf{ck})</span>. For each <span class="math">i \\in [\\mathsf{k}]</span>, consider the evaluation queries <span class="math">(z_1, i, j_1), \\ldots, (z_t, i, j_t)</span> made during the <span class="math">i</span>-th round. The prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> executes <span class="math">\\mathcal{P}</span>, <span class="math">\\mathsf{po}</span> times, to produce <span class="math">\\mathsf{po}</span> passes over the coefficients of the polynomials <span class="math">\\mathbf{p}_{i,0}(X), \\ldots, \\mathbf{p}_{i,o(i)}(X)</span>. The prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> forwards the coefficients produced during each pass to the correct session for the <span class="math">\\mathsf{PC.Open}</span> algorithm. During the first pass over each of the polynomials <span class="math">\\mathbf{p}_{i,j_r}(X)</span>, <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> computes <span class="math">\\mathbf{p}_{i,j_r}(z_r)</span> using Horner's rule.</p>

    <p class="text-gray-300">Note that input/output orderings of the <span class="math">\\mathcal{P}</span> algorithm and the <span class="math">\\mathsf{PC.Com}</span> and <span class="math">\\mathsf{PC.Open}</span> algorithms ensure that the polynomials produced by <span class="math">\\mathcal{P}</span> are fed to <span class="math">\\mathsf{PC.Com}</span> and <span class="math">\\mathsf{PC.Open}</span> in the correct order.</p>

    <p class="text-gray-300">We justify each of the complexity parameters of Construction 12 in turn.</p>

    <p class="text-gray-300"><strong>Prover time.</strong> For each round <span class="math">i \\in [\\mathsf{k}]</span>, the prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> runs the prover algorithm <span class="math">\\mathcal{P}</span> for the <span class="math">i</span>-th round a total of <span class="math">k_{\\mathsf{PC.Com}} + \\mathsf{po}</span> times. In total, this incurs a time cost of <span class="math">k_{\\mathsf{PC.Com}} + \\mathsf{po}</span> complete executions of <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300">In addition, <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> commits to <span class="math">\\sum_{i=0}^{\\mathsf{k}-1} o(i)</span> polynomials using <span class="math">\\mathsf{PC.Com}</span>, and for <span class="math">q</span> queries, evaluates a polynomial of degree <span class="math">D</span> and runs <span class="math">\\mathsf{PC.Open}</span>.</p>

    <p class="text-gray-300">This gives a total prover time of <span class="math">(k_{\\mathsf{PC.Com}} + \\mathsf{po})t_{\\mathcal{P}}&#x27; + s u m_{i=0}^{k-1} o(i) \\cdot t_{\\mathsf{PC.Com}}&#x27; + q \\cdot (t_{\\mathsf{O}}&#x27; + \\mathsf{te})</span>.</p>

    <p class="text-gray-300"><strong>Prover space.</strong> For each round <span class="math">i \\in [\\mathsf{k}]</span>, the prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> runs the prover algorithm <span class="math">\\mathcal{P}</span> for the <span class="math">i</span>-th round, while running <span class="math">o(i)</span> executions of <span class="math">\\mathsf{PC.Com}</span> in parallel. This gives space costs of <span class="math">s_{\\mathcal{P}}&#x27; + o(i)s_{\\mathsf{PC.Com}}&#x27;</span>.</p>

    <p class="text-gray-300">Subsequently, <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> runs <span class="math">\\mathcal{P}</span> again to answer evaluation queries, running <span class="math">q</span> executions of <span class="math">\\mathsf{PC.Open}</span> and computing evaluations of at most <span class="math">q</span> polynomials in parallel at any time. This gives space costs of <span class="math">q \\cdot s_{\\mathsf{O}}&#x27; + O(q)</span>.</p>

    <p class="text-gray-300"><strong>Number of passes.</strong> The prover <span class="math">\\mathcal{P}_{\\mathsf{ARG}}</span> runs <span class="math">\\mathcal{P}</span> a total of <span class="math">k_{\\mathsf{PC.Com}} + \\mathsf{po}</span> times in order to provide enough passes for <span class="math">\\mathsf{PC.Com}</span> and <span class="math">\\mathsf{PC.Open}</span>. Each execution of <span class="math">\\mathcal{P}</span> uses at most <span class="math">k_{\\mathcal{P}}</span>, giving a total of <span class="math">(k_{\\mathsf{PC.Com}} + \\mathsf{po}) \\cdot k_{\\mathcal{P}}</span>.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">Acknowledgements</p>

    <p class="text-gray-300">This research was supported in part by: a donation from the Ethereum Foundation; a grant from the Sloan Foundation.</p>

    <p class="text-gray-300">Jonathan Bootle was partially supported by the SNSF ERC Transfer Grant CRETP2-166734 – FELICITY and partially supported by the EU H2020 ERC Project 101002845 – PLAZA.</p>

    <p class="text-gray-300">Yuncong Hu was supported by NSF CISE Expeditions Award CCF-1730628, NSF CAREER 1943347, and gifts from the Sloan Foundation, Alibaba, Amazon Web Services, Ant Group, Ericsson, Facebook, Futurewei, Google, Intel, Microsoft, Nvidia, Scotiabank, Splunk, and VMware.</p>

    <h2 id="sec-108" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ark] arkworks. <em>arkworks: an ecosystem for developing and programming with zkSNARKs</em>. URL: https://github.com/arkworks-rs.</li>

      <li>[BBHR18] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: <em>Proceedings of the 45th International Colloquium on Automata, Languages and Programming</em>. ICALP ’18. 2018, 14:1–14:17.</li>

      <li>[BC12] N. Bitansky and A. Chiesa. “Succinct Arguments from Multi-Prover Interactive Proofs and their Efficiency Benefits”. In: <em>Proceedings of the 32nd Annual International Cryptology Conference</em>. CRYPTO ’12. 2012, pp. 255–272.</li>

      <li>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. “Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting”. In: <em>Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’16. 2016, pp. 327–357.</li>

      <li>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data”. In: <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>. STOC ’13. 2013, pp. 111–120.</li>

      <li>[BCG20] J. Bootle, A. Chiesa, and J. Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: <em>Proceedings of the 18th Theory of Cryptography Conference</em>. TCC ’20. 2020, pp. 19–46.</li>

      <li>[BCGGHJ17] J. Bootle, A. Cerulli, E. Ghadafi, J. Groth, M. Hajiabadi, and S. K. Jakobsen. “Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability”. In: <em>Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security</em>. ASIACRYPT ’17. 2017, pp. 336–365.</li>

      <li>[BCGJM18] J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen, and M. Maller. “Arya: Nearly Linear-Time Zero-Knowledge Proofs for Correct Program Execution”. In: <em>Proceedings of the 24th International Conference on the Theory and Application of Cryptology and Information Security</em>. ASIACRYPT ’18. 2018, pp. 595–626.</li>

      <li>[BCL22] J. Bootle, A. Chiesa, and S. Liu. “Zero-Knowledge Succinct Arguments with a Linear-Time Prover”. In: <em>Proceedings of the 42nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>. EUROCRYPT ’22. 2022.</li>

      <li>[BCRSVW19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: <em>Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques</em>. EUROCRYPT ’19. 2019, pp. 103–128.</li>

      <li>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. “Interactive Oracle Proofs”. In: <em>Proceedings of the 14th Theory of Cryptography Conference</em>. TCC ’16-B. 2016, pp. 31–60.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BCS21] J. Bootle, A. Chiesa, and K. Sotiraki. “Sumcheck Arguments and Their Applications”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’15. 2021, pp. 742–773.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BDFG20] D. Boneh, J. Drake, B. Fisch, and A. Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081. 2020.</li>

      <li>[BEGKN91] M. Blum, W. Evans, P. Gemmell, S. Kannan, and M. Naor. “Checking the correctness of memories”. In: Proceedings of the 32nd Annual Symposium on Foundations of Computer Science. FOCS ’91. 1991, pp. 90–99.</li>

      <li>[BFS20] B. Bünz, B. Fisch, and A. Szepieniec. “Transparent SNARKs from DARK Compilers”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 677–706.</li>

      <li>[BGM17] S. Bowe, A. Gabizon, and I. Miers. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model. Cryptology ePrint Archive, Report 2017/1050. 2017.</li>

      <li>[BHRRS20] A. R. Block, J. Holmgren, A. Rosen, R. D. Rothblum, and P. Soni. “Public-Coin Zero-Knowledge Arguments with (almost) Minimal Time and Space Overheads”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020, pp. 168–197.</li>

      <li>[BHRRS21] A. R. Block, J. Holmgren, A. Rosen, R. D. Rothblum, and P. Soni. “Time- and Space-Efficient Arguments from Groups of Unknown Order”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021, pp. 123–152.</li>

      <li>[BMRS21] C. Baum, A. J. Malozemoff, M. B. Rosen, and P. Scholl. “Mac’n’Cheese: Zero-Knowledge Proofs for Boolean and Arithmetic Circuits with Nested Disjunctions”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021, pp. 92–122.</li>

      <li>[CDDGS03] D. Clarke, S. Devadas, M. v. Dijk, B. Gassend, and G. E. Suh. “Incremental multiset hash functions and their application to memory integrity checking”. In: International conference on the theory and application of cryptology and information security. Springer. 2003, pp. 188–207.</li>

      <li>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. “Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS”. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’20. 2020, pp. 738–768.</li>

      <li>[CMT12] G. Cormode, M. Mitzenmacher, and J. Thaler. “Practical Verified Computation with Streaming Interactive Proofs”. In: Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science. ITCS ’12. 2012, pp. 90–112.</li>

      <li>[CTY11] G. Cormode, J. Thaler, and K. Yi. “Verifying computations with streaming interactive proofs”. In: Proceedings of the VLDB Endowment 5.1 (2011), pp. 25–36.</li>

      <li>[Dra20] J. Drake. PLONK without FFTs. 2020. url: https://www.youtube.com/watch?v=ffXgxvlCBvo.</li>

      <li>[FS86] A. Fiat and A. Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: Proceedings of the 6th Annual International Cryptology Conference. CRYPTO ’86. 1986, pp. 186–194.</li>

      <li>[Gab20] A. Gabizon. Lineval Protocol. Available at https://hackmd.io/aWXth2dASPaGVrXiGg1Cmg?view. 2020.</li>

      <li>[GLSTW21] A. Golovnev, J. Lee, S. T. V. Setty, J. Thaler, and R. S. Wahby. Brakedown: Linear-time and post-quantum SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/1043. 2021.</li>

      <li>[Gro16] J. Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[GW20] A. Gabizon and Z. J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315. 2020.</li>

    </ul>

    <p class="text-gray-300">[HR18] J. Holmgren and R. Rothblum. “Delegating Computations with (Almost) Minimal Time and Space Overhead”. In: Proceedings of the 59th Annual IEEE Symposium on Foundations of Computer Science. FOCS '18. 2018, pp. 124–135.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KMP20] A. Kothapalli, E. Masserova, and B. Parno. A Direct Construction for Asymptotically Optimal zkSNARKs. Cryptology ePrint Archive, Report 2020/1318. 2020.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT '10. 2010, pp. 177–194.</li>

      <li>[Lee20] J. Lee. Dory: Efficient, Transparent arguments for Generalised Inner Products and Polynomial Commitments. Cryptology ePrint Archive, Report 2020/1274. 2020.</li>

      <li>[LFKN92] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</li>

      <li>[PLS19] R. d. Pino, V. Lyubashevsky, and G. Seiler. “Short Discrete Log Proofs for FHE and Ring-LWE Ciphertexts”. In: Proceedings of the 22nd International Conference on Practice and Theory of Public-Key Cryptography. PKC '19. 2019, pp. 344–373.</li>

      <li>[RR22] N. Ron-Zewi and R. D. Rothblum. “Proving as Fast as Computing: Succinct Arguments with Constant Prover Overhead”. In: Proceedings of the 54th Annual ACM Symposium on Theory of Computing. STOC '22. 2022.</li>

      <li>[RRR16] O. Reingold, R. Rothblum, and G. Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC '16. 2016, pp. 49–62.</li>

      <li>[SATJ18] S. T. V. Setty, S. Angel, G. Trinabh, and L. Jonathan. “Proving the correct execution of concurrent services in zero-knowledge”. In: Proceedings of the 13th USENIX Symposium on Operating Systems Design and Implementation. OSDI '18. 2018, pp. 339–356.</li>

      <li>[Set20] S. T. V. Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: 40th Annual International Cryptology Conference. CRYPTO '20. 2020, pp. 704–737.</li>

      <li>[Tha13] J. Thaler. “Time-Optimal Interactive Proofs for Circuit Evaluation”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO '13. 2013, pp. 71–89.</li>

      <li>[WZCPS18] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica. “DIZK: A Distributed Zero Knowledge Proof System”. In: Proceedings of the 27th USENIX Security Symposium. USENIX Security '18. 2018, pp. 675–692.</li>

      <li>[XZZPS19] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO '19. 2019, pp. 733–764.</li>

      <li>[ZGKPP17] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. “vSQL: Verifying Arbitrary SQL Queries over Dynamic Outsourced Databases”. In: Proceedings of the 38th IEEE Symposium on Security and Privacy. S&amp;P '17. 2017, pp. 863–880.</li>

      <li>[ZGKPP18] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou. “vRAM: Faster Verifiable RAM with Program-Independent Preprocessing”. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. S&amp;P '18. 2018, pp. 908–925.</li>

      <li>[Zha+21] J. Zhang et al. “Doubly Efficient Interactive Proofs for General Arithmetic Circuits with Linear Prover Time”. In: Proceedings of the 28th ACM Conference on Computer and Communications Security. CCS '21. 2021, pp. 159–177.</li>

    </ul>`;
---

<BaseLayout title="Gemini: Elastic SNARKs for Diverse Environments (2022/420)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/420
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
