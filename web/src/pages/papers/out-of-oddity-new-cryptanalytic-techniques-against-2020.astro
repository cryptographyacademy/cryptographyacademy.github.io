---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/188';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Out of Oddity -- New Cryptanalytic Techniques against Symmetric Primitives Optimized for Integrity Proof Systems';
const AUTHORS_HTML = 'Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Ga&euml;tan Leurent, Mar&iacute;a Naya-Plasencia, L&eacute;o Perrin, Yu Sasaki, Yosuke Todo, Friedrich Wiemer';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The security and performance of many integrity proof systems like SNARKs, STARKs and Bulletproofs highly depend on the underlying hash function. For this reason several new proposals have recently been developed. These primitives obviously require an in-depth security evaluation, especially since their implementation constraints have led to less standard design approaches. This work compares the security levels offered by two recent families of such primitives, namely GMiMC and HadesMiMC. We exhibit low-complexity distinguishers against the GMiMC and HadesMiMC permutations for most parameters proposed in recently launched public challenges for STARK-friendly hash functions. In the more concrete setting of the sponge construction corresponding to the practical use in the ZK-STARK protocol, we present a practical collision attack on a round-reduced version of GMiMC and a preimage attack on some instances of HadesMiMC. To achieve those results, we adapt and generalize several cryptographic techniques to fields of odd characteristic.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Hash functions &middot; integrity proof systems &middot; GMiMC &middot; HadesMiMC &middot; Integral attacks</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 STARK-friendly primitives</h2>

    <p class="text-gray-300">This paper focuses on two families of primitives, which are recent evolutions of the block cipher MIMC designed by Albrecht <em>et al.</em> in 2016 [6], and offer much more flexibility than the original construction:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>GMiMC</strong>, designed by Albrecht <em>et al.</em> [4,5]</li>
    </ul>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Primitive (security)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Type</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Cost</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMIMC<br>(128 bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">101</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">permutation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">integral distinguisher ZS distinguisher</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70<br><b>102</b></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 <sup>61</sup> 2 <sup>48</sup> 2 <sup>122</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1<br>4.3<br>4.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ZS distinguisher<br>diff. distinguisher<br>diff. distinguisher</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128<br>64<br>66</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{123}</span> practical</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.2<br>5.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">hash function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">collisions<br>collisions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40<br>42<br>52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">practical 2 <sup>92</sup> 2 <sup>83</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5.4<br>5.4<br>5.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon<br>(128 bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8+40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">permutation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ZS distinguisher</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6+45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GMIMC<br>(256 bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">186</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">permutation hash function</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">integral distinguisher ZS distinguisher ZS distinguisher collisions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">116<br><b>206</b><br><b>218</b><br>50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125}</span> <span class="math">2^{125}</span> <span class="math">2^{250}</span> <span class="math">2^{187}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1<br>4.2<br>4.2<br>5.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Poseidon<br>(256 bits)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8+83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">permutation<br>hash function*</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ZS distinguisher preimages</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6+87<br><b>8+any</b></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125}</span> <span class="math">2^{236}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1<br><b>6.2</b></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Distinguishers on the GMIMC and HADESMIMC permutations and attacks breaking the corresponding sponge hash functions. The variants aiming at 128-bit security operate on t=12 elements in  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q=2^{61}+20\\times 2^{32}+1</span> . The variants aiming at 256-bit security operate on t=14 elements in  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q=2^{125}+266\\times 2^{64}+1</span> . The last attack (*) only applies when the linear layer has a low multiplicative order. Attacks on full versions are typeset in bold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>HadesMiMC</strong>, proposed by Grassi <em>et al.</em> [28,29], for which two versions are distinguished depending on the characteristic of the underlying field: Starkad over a field of characteristic 2, and Poseidon over a prime field.</li>
    </ul>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Expected security level</h3>

    <p class="text-gray-300">GMIMC and HADESMIMC are two block ciphers but both of them can be turned into permutations by replacing the round-keys by fixed independent and randomly chosen round-constants. Based on these primitives, hash functions are obtained by applying the sponge construction [16,17] depicted in Figure 1 and using the primitive as an inner permutation.</p>

    <p class="text-gray-300">In the following, we extensively use the following notation: the sponge operates on a state composed of t elements in a finite field  <span class="math">\\mathbb{F}_q</span> . The main parameters which determine the security level of the sponge construction with respect to generic attacks are its <em>capacity</em> c and the size of the underlying alphabet  <span class="math">\\mathbb{F}_q</span> . Namely, a random sponge whose capacity consists of c elements in  <span class="math">\\mathbb{F}_q</span>  provides</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Sponge construction with inner permutation &pi;, internal state with t = 12 words and capacity c = 4.</p>

    <p class="text-gray-300">a generic security level corresponding to <sup>c</sup> 2 log<sup>2</sup> q queries both for collision and (second)-preimage resistance <a href="#page-32-7">[16]</a>.</p>

    <p class="text-gray-300">The primary cryptanalytic goal is to exhibit collision or preimage attacks on some weakened variants of the hash functions. However, the existence of a property which distinguishes a given cryptographic function from an ideal function of the same size is also commonly considered as a weakness (see e.g. <a href="#page-32-9">[12,</a> Page 19] for a discussion). In our context, since our attacks do not make any assumptions about the round-constants in the inner permutations, our <em>distinguishers</em> are related to the known-key model for block ciphers <a href="#page-33-6">[32]</a>.</p>

    <p class="text-gray-300">While a distinguisher on &pi; cannot always be turned into a distinguisher for the hash function, it invalidates the security arguments provided by the indifferentiability proof of the sponge construction <a href="#page-32-8">[17]</a>. For this reason, the authors of Keccak advocate following the so-called <em>hermetic sponge strategy</em> <a href="#page-32-10">[18,</a> Page 13], i.e. using the sponge construction with an inner permutation that should not have any structural distinguisher (other than the existence of a compact description).</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8"><strong>2.2 Concrete instances</strong></h3>

    <p class="text-gray-300">The different members in each of these families are determined by the triple (c, t, q) representing respectively the number of words in the capacity, the number of words in the state and the field size. In the following, when referring to practical examples, we will focus on the values (c, t, q) considered in the Stark-Ware challenges given in Table <a href="#page-5-0">2.</a> To each triple (c, t, q) correspond two variants: over a prime field and over a binary field, and the exact values of q are detailed in Table <a href="#page-5-0">2.</a> Performance in terms of trace size, proving time, and verification cost, are essential criteria for choosing a STARK-friendly hash function. Implementation results show that, for each family of hash functions, the variant 128-d (for the target 128-bit security) is by far the most efficient <a href="#page-34-1">[41]</a>. For this reason, some attacks in the paper focus more specifically on this member in the three families, i.e., on sponges whose internal state consists of t = 12 words in a finite field F<sup>q</sup></p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security level</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\log_2 q</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">q (prime)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">q (binary)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">c</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">t</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Variant</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61} + 20 \\times 2^{32} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128-d</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">128 	 2^{125} +</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125} + 266 \\times 2^{64} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4<br>12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128-a<br>128-c</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{253} + 2^{199} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{255}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1<br>1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3<br>11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128-b<br>128-e</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125} + 266 \\times 2^{64} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{125}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8<br>14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256-a<br>256-b</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Parameters proposed for the permutation and sponge construction.</p>

    <p class="text-gray-300">of order close to  <span class="math">2^{64}</span>  and with capacity c=4. It is also worth noticing that, in terms of performance and suitability, odd prime fields are more STARK-friendly than binary fields for a given size.</p>

    <p class="text-gray-300"><strong>GMiMC</strong> is a family of block ciphers designed by Albrecht <em>et al.</em> in 2019 [4] based on different types of Feistel networks using  <span class="math">x \\mapsto x^3</span>  over the field corresponding to the branch alphabet as the round function. Among the variants proposed by the designers, we focus on the one chosen in the StarkWare challenges and depicted in Figure 2, namely the variant using an unbalanced Feistel network with an expanding round function, named  <span class="math">\\mathsf{GMiMC}_{\\mathsf{erf}}</span> . In the whole paper, the rounds (and round constants) are numbered starting from 1, and the branches are numbered from 1 to t where Branch 1 is the leftmost branch. For the sake of simplicity, this particular variant will be called  <span class="math">\\mathsf{GMiMC}</span> . A specificity of  <span class="math">\\mathsf{GMiMC}</span>  is that the designers' security claims concern the primitive instantiated over a prime field. They mention that &quot;even if  <span class="math">\\mathsf{GMiMC}</span>  can be instantiated over  <span class="math">\\mathbb{F}_{2^n}</span> , [they] do not provide the number of rounds to guarantee security in this scenario&quot;.</p>

    <p class="text-gray-300">In the block cipher setting with a key size equal to  <span class="math">n = \\log_2 q</span>  bits, the key schedule is trivial, i.e. the master key is added to the input of the cube function at every round. This very simple key schedule is a major weakness [19]. However, it seems difficult to leverage the underlying property in the hash function setting we are focusing on.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Specifications of HadesMiMC</h3>

    <p class="text-gray-300"><strong>HadesMiMC</strong> is a family of permutations described by Grassi <em>et al.</em> in [29] which follows a new design strategy for block ciphers called HADES. The HADES construction aims to decrease the number of Sboxes relative to a traditional Substitution-Permutation Network, while guaranteeing that the cipher still resists all known attacks, including differential and linear cryptanalysis and algebraic attacks. Reducing the number of Sboxes is especially important in many</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: One round of the GMiMC permutation with t = 12.</p>

    <p class="text-gray-300">applications and this was traditionally achieved by using a partial substitutionlayer, i.e., an Sbox layer which does not operate on the whole internal state. However, several attacks on this type of constructions, e.g. <a href="#page-32-12">[13,</a><a href="#page-32-6">22,</a><a href="#page-33-3">24,</a><a href="#page-33-4">38]</a> show that it is much more difficult to estimate the security level of these constructions than that of classical SPNs. The basic principle of the HADES construction is then to combine both aspects: the inner rounds in the cipher have a partial Sbox layer to increase the resistance to algebraic attacks at a reduced implementation cost, whereas the outer rounds consist of traditional SPN rounds, with a full Sbox layer. The resistance against statistical attacks is analyzed by removing the inner rounds, while the resistance to algebraic attacks, e.g. the evolution of the algebraic degree over the cipher, involves the inner rounds.</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: The HadesMiMC construction with t = 6.</p>

    <p class="text-gray-300">HadesMiMC <a href="#page-33-5">[29,</a> Section 3] is then a keyed permutation following the HADES construction dedicated to MPC applications or to STARK proof systems, where the Sbox is defined by the cube mapping over a finite field and the linear layer L corresponds to a (t &times; t)-MDS matrix. Two concrete instantiations of HadesMiMC are then detailed by Grassi <em>et al.</em> in <a href="#page-33-2">[28]</a>, namely:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>&ndash;</strong> Starkad operates on t elements in a binary field of odd absolute degree (which guarantees that the cube mapping is bijective);</li>
      <li><strong>&ndash;</strong> Poseidon operates on t elements in a prime field F<sup>p</sup> with p mod 3 6= 1.</li>
    </ul>

    <p class="text-gray-300">In both cases the partial rounds consist of a single Sbox operating on the last coordinate of the state. For all parameters we consider, the number of full rounds is equal to 8 and the number of partial rounds varies between 40 and 88.</p>

    <p class="text-gray-300">The notion of <em>integral attacks</em> has been introduced by Knudsen and Wagner [33] and captures several variants including saturation attacks and higher-order differential attacks. These attacks have been used for cryptanalyzing many ciphers, but to our best knowledge, all of them operate on a binary field. Indeed, the main property behind these attacks is that, for any  <span class="math">F: \\mathbb{F}_2^m \\to \\mathbb{F}_2^m</span>  and for any affine subspace  <span class="math">V \\subset \\mathbb{F}_2^m</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in V} F(x) = 0</span>$</p>

    <p class="text-gray-300">when  <span class="math">\\deg F &lt; \\dim V</span> . This comes from the fact that the sum of the images by F of all inputs in V corresponds to a value of a derivative of F of order  <span class="math">(\\dim V)</span>  [34]. It follows that this derivative has degree at most  <span class="math">(\\deg(F) - \\dim V)</span>  and thus vanishes when  <span class="math">\\deg F &lt; \\dim V</span> . It is then possible to <em>saturate</em> some input bits of F and to use as a distinguishing property the fact that the output bits are balanced, i.e. they sum to zero. The fact that the sum over all  <span class="math">x \\in V</span>  of F(x) corresponds to the value of a higher-order derivative does not hold anymore in odd characteristic, and the same technique cannot be applied directly.</p>

    <p class="text-gray-300">Higher-order differentials over  <span class="math">\\mathbb{F}_q</span>  then need to use a generalized notion of differentiation as analyzed in [40] (see also [2]). However, we can show that for the particular case of saturation attacks, the same technique can be used in the general case of a field  <span class="math">\\mathbb{F}_q</span>  &ndash; even in odd characteristic. Indeed, we can exploit the following result.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> For any  <span class="math">F : \\mathbb{F}_q \\to \\mathbb{F}_q</span>  with  <span class="math">\\deg(F) &lt; q - 1</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\mathbb{F}_q} F(x) = 0 .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The result is due to following well-known property: for any exponent k with  <span class="math">1 \\le k \\le q-2</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\mathbb{F}_q} x^k = 0 .</span>$</p>

    <p class="text-gray-300">Moreover, when k = 0, we have  <span class="math">\\sum_{x \\in \\mathbb{F}_q} x^0 = q = 0</span> .</p>

    <p class="text-gray-300">Proposition 1 can be generalized to the multivariate case, i.e. to functions from  <span class="math">\\mathbb{F}_q^k</span>  to  <span class="math">\\mathbb{F}_q</span> , which can be expressed as polynomials in the ring</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}_q[x_1,\\ldots,x_k]/\\left(x_1^q-x_1,\\ldots,x_k^q-x_k\\right).</span>$</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> For any  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q</span>  with  <span class="math">\\deg(F) &lt; k(q-1)</span>  and any affine subspace  <span class="math">V \\subseteq \\mathbb{F}_q^t</span>  of dimension at least k,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in V} F(x) = 0 .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let V be an affine space of dimension  <span class="math">\\kappa \\geq k</span>  and A an affine permutation over  <span class="math">\\mathbb{F}_q^t</span>  such that  <span class="math">A(V) = \\{(y, 0, \\dots, 0) \\mid y \\in \\mathbb{F}_q^{\\kappa}\\}</span> . Then,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in V} F(x) = \\sum_{x \\in V} (F \\circ A^{-1})(A(x)) = \\sum_{y_1, \\dots, y_{\\kappa} \\in \\mathbb{F}_q} (F \\circ A^{-1})(y_1, \\dots, y_{\\kappa}, 0, \\dots, 0).</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\deg(F \\circ A^{-1}) = \\deg F &lt; k(q-1), \\ (F \\circ A^{-1})</span>  consists of monomials of the form  <span class="math">y_1^{i_1}y_2^{i_2}\\dots y_\\kappa^{i_\\kappa}</span>  with at least one exponent  <span class="math">i_j &lt; q-1</span> . Then,  <span class="math">\\sum_{y_j \\in \\mathbb{F}_q} y_j^{i_j} = 0</span> , implying that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{y_1,\\dots,y_\\kappa\\in\\mathbb{F}_q}y_1^{i_1}y_2^{i_2}\\dots y_\\kappa^{i_\\kappa}=0,</span>$</p>

    <p class="text-gray-300">which leads to  <span class="math">\\sum_{x \\in V} F(x) = 0</span> .</p>

    <p class="text-gray-300">Based on this observation, a saturation attack with data complexity  <span class="math">q^k</span>  can be mounted whenever the degree of F as a polynomial over  <span class="math">\\mathbb{F}_q</span>  is strictly less than k(q-1), even if  <span class="math">\\mathbb{F}_q</span>  is a field of odd characteristic.</p>

    <p class="text-gray-300">Now, we generalize the notion of integral distinguishers to multiplicative subgroups using the following property.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> Let  <span class="math">\\mathbb{G}</span>  be a multiplicative subgroup of  <span class="math">\\mathbb{F}_q^{\\times}</span> . For any  <span class="math">F: \\mathbb{F}_q \\to \\mathbb{F}_q</span>  such that  <span class="math">\\deg(F) &lt; |\\mathbb{G}|</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\mathbb{G}} F(x) - F(0) \\cdot |\\mathbb{G}| = 0.</span>$</p>

    <p class="text-gray-300">This is a strict generalization of Proposition 1, for which  <span class="math">|\\mathbb{G}| = q - 1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The result is a direct consequence of the following well-known property: for any exponent k with  <span class="math">1 \\le k \\le |\\mathbb{G}| - 1</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x \\in \\mathbb{G}} x^k = 0 .</span>$</p>

    <p class="text-gray-300">Moreover, when k = 0, we have  <span class="math">\\sum_{x \\in \\mathbb{G}} x^0 = |\\mathbb{G}|</span> .</p>

    <p class="text-gray-300">We also note that Corollary 1 can be straightforwardly adapted to multiplicative subgroups. The power of summing over multiplicative subgroups (rather than over the entire field  <span class="math">\\mathbb{F}_q</span> ) comes from the fact that if  <span class="math">\\mathbb{F}_q</span>  contains small multiplicative subgroups (as for the fields used for the concrete instances specified in Table 2), the complexity of the attacks may be fine-tuned and significantly reduced. In the next sections, such attacks will be applied to both GMIMC and HADESMIMC.</p>

    <p class="text-gray-300">Using Corollary 1, we can exhibit a distinguisher for  <span class="math">(3t-4+\\lfloor\\log_3(q-2)\\rfloor)</span>  rounds of GMIMC. A remarkable property is that this distinguisher holds for any finite field. It is obtained by saturating a single branch of the Feistel network and consequently has data complexity q. Indeed, we choose a set of inputs where the (t-2) leftmost branches are inactive, while the rightmost branch is determined by the value of Branch (t-1). More precisely, we consider a set of inputs of the form</p>

    <p class="text-gray-300">
<span class="math">$\\mathcal{X} = \\{ (\\alpha_1, \\dots, \\alpha_{t-2}, x, f(x)) \\mid x \\in \\mathbb{F}_q \\}</span>$
(1)</p>

    <p class="text-gray-300">where the  <span class="math">\\alpha_i</span>  are arbitrary constants in  <span class="math">\\mathbb{F}_q</span>  and f is defined by</p>

    <p class="text-gray-300"><span class="math">$f(x) = -\\left(x + \\sum_{i=1}^{t-2} \\beta_i + \\mathsf{RC}_{t-1}\\right)^3 - x - 2\\sum_{i=1}^{t-2} \\beta_i - \\mathsf{RC}_{t-1} - \\mathsf{RC}_t</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\beta_1, \\ldots, \\beta_{t-2}</span>  are constant values derived from  <span class="math">\\alpha_1, \\ldots, \\alpha_{t-2}</span>  by</p>

    <p class="text-gray-300"><span class="math">$\\beta_1 = (\\alpha_1 + \\mathsf{RC}_1)^3 \\text{ and } \\beta_{i+1} = \\left(\\alpha_{i+1} + \\sum_{j=1}^i \\beta_j + \\mathsf{RC}_{i+1}\\right)^3.</span>$</p>

    <p class="text-gray-300">Let us first consider the first (t-2) rounds. We observe that, at Round i,  <span class="math">1 \\le i \\le t-2</span> , the output of the Sbox corresponds to  <span class="math">\\beta_i</span>  and is added to all branches except the leftmost branch of the input. It follows that the output of Round (t-2) corresponds to</p>

    <p class="text-gray-300"><span class="math">$(x + \\sum_{i=1}^{t-2} \\beta_i, f(x) + \\sum_{i=1}^{t-2} \\beta_i, \\gamma_1, \\dots, \\gamma_{t-2})</span>$</p>

    <p class="text-gray-300">where  <span class="math">(\\gamma_1, \\ldots, \\gamma_{t-2})</span>  are constants (see Figure 4).</p>

    <p class="text-gray-300">Therefore, if x' denotes the value of Branch 1, i.e.,  <span class="math">x&#x27; = x + \\sum_{i=1}^{t-2} \\beta_i</span> , we have that Branch 2 corresponds to</p>

    <p class="text-gray-300"><span class="math">$f\\left(x&#x27; - \\sum_{i=1}^{t-2} \\beta_i\\right) + \\sum_{i=1}^{t-2} \\beta_i = -\\left(x&#x27; + \\mathsf{RC}_{t-1}\\right)^3 - x&#x27; - \\mathsf{RC}_{t-1} - \\mathsf{RC}_t \\; .</span>$</p>

    <p class="text-gray-300">The inputs of Round t are then</p>

    <p class="text-gray-300"><span class="math">$\\{(-x&#x27; - \\mathsf{RC}_t - \\mathsf{RC}_{t-1}, \\gamma_1 + (x&#x27; + \\mathsf{RC}_{t-1})^3, \\dots, \\gamma_{t-2} + (x&#x27; + \\mathsf{RC}_{t-1})^3, x&#x27;) \\mid x&#x27; \\in \\mathbb{F}_q\\}</span>$</p>

    <p class="text-gray-300">and the inputs of Round (t+1) are</p>

    <p class="text-gray-300"><span class="math">$\\{(\\gamma_1,\\dots,\\gamma_{t-2},x&#x27;-(x&#x27;+\\mathsf{RC}_{t-1})^3,-x&#x27;-\\mathsf{RC}_t-\\mathsf{RC}_{t-1})\\mid x&#x27;\\in\\mathbb{F}_q\\}\\;.</span>$</p>

    <p class="text-gray-300">The following (t-2) rounds do not activate the Sbox, implying that the input set at Round (2t-1) has the form</p>

    <p class="text-gray-300">
<span class="math">$\\{(x&#x27; - (x&#x27; + \\mathsf{RC}_{t-1})^3 + \\delta_1, -x&#x27; + \\delta_2, \\delta_3, \\dots, \\delta_t) \\mid x&#x27; \\in \\mathbb{F}_q\\}</span>$
(2)</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: First rounds of the integral distinguisher on GMiMC (with t = 4).</p>

    <p class="text-gray-300">for some fixed values &delta;1, . . . , &delta;<sup>t</sup> determined by the constants. Each coordinate of this input word can then be seen as a q-ary polynomial in x <sup>0</sup> of degree at most three. It follows that, after r additional rounds, the set <a href="#page-9-2">(2)</a> is transformed into a set of elements (z1, . . . , zt), whose coordinates have degree at most 3 <sup>r</sup>+1. Prop. <a href="#page-7-1">1</a> then implies that all z<sup>i</sup> are balanced if 3 <sup>r</sup>+1 &le; q &minus; 2, i.e., if r &le; blog<sup>3</sup> (q &minus; 2)c &minus; 1. Adding (t-1) rounds. We can add some more rounds by using the following relation over (t-1) rounds of GMIMC.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let  <span class="math">(x_1, \\ldots, x_t)</span>  and  <span class="math">(y_1, \\ldots, y_t)</span>  denote the input and output of (t-1) rounds of GMIMC.</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{i=2}^{t} y_i - (t-2)y_1 = \\sum_{i=1}^{t-1} x_i - (t-2)x_t.</span>$
(3)</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">(x_1^{\\ell}, \\dots, x_t^{\\ell})</span>  denote the input of Round  <span class="math">\\ell</span> . It can be observed that, for any  <span class="math">i, j \\in \\{1, \\dots, t-1\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$x_i^{\\ell} = x_{i+1}^{\\ell-1} + (x_j^{\\ell} - x_{j+1}^{\\ell-1})</span>$
and  <span class="math">x_t^{\\ell} = x_1^{\\ell-1}</span> .</p>

    <p class="text-gray-300">It follows that, for any j,  <span class="math">1 \\le j \\le (t-1)</span> .</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{t} x_i^{\\ell} - (t-1)x_j^{\\ell} = \\sum_{i=1}^{t} x_i^{\\ell-1} - (t-1)x_{j+1}^{\\ell-1}.</span>$</p>

    <p class="text-gray-300">By applying this equality (t-1) times, we deduce (3).</p>

    <p class="text-gray-300">From the previous proposition, we deduce that after a total of</p>

    <p class="text-gray-300"><span class="math">$R = 3t - 4 + \\lfloor \\log_3(q - 2) \\rfloor</span>$
rounds,</p>

    <p class="text-gray-300">the output  <span class="math">(v_1, \\ldots, v_t)</span>  of GMIMC satisfies  <span class="math">\\sum_{i=2}^t v_i - (t-2)v_1 = \\sum_{i=1}^{t-1} z_i - (t-2)z_t</span> , which is a polynomial in x of degree at most (q-2). This leads to a distinguisher with complexity q on R rounds, i.e., 70 rounds for the parameters we focus on.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Zero-sum distinguishers on the full permutation</h3>

    <p class="text-gray-300"><strong>Saturating a single branch.</strong> Since we are analyzing a permutation (or a family of permutations parameterized by the round-constants), there is no secret material involved in the computation, implying that a distinguisher can be built from some internal states in the middle of the primitive, not only from inputs and outputs, exactly as in the <em>known-key setting</em> for block ciphers [32]. This leads to <em>zero-sum distinguishers</em>, which were introduced by Aumasson and Meier [11] and exhibited for several hash functions, including SHA-3 [10,20].</p>

    <p class="text-gray-300">The previously described distinguisher can be extended by  <span class="math">(t-2+\\lfloor \\log_3(q-2)\\rfloor)</span>  rounds backwards. This is realized by choosing the internal states after  <span class="math">(t-2+\\lfloor \\log_3(q-2)\\rfloor)</span>  rounds in  <span class="math">\\mathcal{X}</span> , as defined by (1). The inverse of one round of GMIMC is still a round of a Feistel network of the same form and it has degree three over  <span class="math">\\mathbb{F}_q</span> . Then, the coordinates  <span class="math">(y_1,\\ldots,y_t)</span>  of the images of the elements in  <span class="math">\\mathcal{X}</span>  by r backward rounds can be seen as univariate polynomials in x with degree at most  <span class="math">3^{r+1}</span> . Exactly as in the forward direction, after  <span class="math">(\\lfloor \\log_3(q-2)\\rfloor - 1)</span>  rounds, the degree of these polynomials cannot exceed (q-2).</p>

    <p class="text-gray-300">Based on Prop. 3, we can then add (t-1) rounds backwards. Indeed, the input of the first round of the permutation  <span class="math">(u_1, \\ldots, u_t)</span>  is related to the output of Round (t-1), i.e.  <span class="math">(y_1, \\ldots, y_t)</span> , by</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=2}^{t} y_i - (t-2)y_1 = \\sum_{i=1}^{t-1} u_i - (t-2)u_t ,</span>$</p>

    <p class="text-gray-300">and the left-hand term of this equation is a polynomial in x of degree at most (q-2), implying that  <span class="math">\\left(\\sum_{i=1}^{t-1} u_i - (t-2)u_t\\right)</span>  sum to zero.</p>

    <p class="text-gray-300">Similarly, we can apply the previously described distinguisher in the forward direction, and deduce that the outputs  <span class="math">(v_1, \\ldots, v_t)</span>  of the permutation after  <span class="math">(3t-4+\\lfloor \\log_3(q-2)\\rfloor)</span>  additional rounds are such that  <span class="math">(\\sum_{i=2}^t v_i-(t-2)v_1)</span>  sum to zero. This leads to a distinguisher with complexity q for a total of</p>

    <p class="text-gray-300"><span class="math">$4t - 6 + 2|\\log_3(q - 2)|</span>$
rounds,</p>

    <p class="text-gray-300">which is higher than the number of rounds proposed in all StarkWare challenges, except in the case where q exceeds the claimed security level (see Table 3).</p>

    <p class="text-gray-300"><strong>Saturating two branches.</strong> When  <span class="math">t \\geq 4</span> , it is possible to exhibit a similar distinguisher on more rounds with complexity  <span class="math">q^2</span>  by saturating two branches. In this case, we start from Round m in the middle with a set of internal states</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{Y} = \\{(\\alpha_1, \\dots, \\alpha_{t-4}, x, f(x), g(y), y) \\mid x, y \\in \\mathbb{F}_q\\}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} f(x) &amp;= - \\Big( x + \\sum_{i=1}^{t-4} \\beta_i + \\mathsf{RC}_{m+t-4} \\Big)^3 - x - 2 \\sum_{i=1}^{t-4} \\beta_i - \\mathsf{RC}_{m+t-4} - \\mathsf{RC}_{m+t-3} \\\\ g(y) &amp;= (y + \\mathsf{RC}_{m-1})^3 - y - \\mathsf{RC}_{m-1} - \\mathsf{RC}_{m-2} \\end{split}</span>$</p>

    <p class="text-gray-300">and  <span class="math">\\beta_1, \\ldots, \\beta_{t-4}</span>  are defined as before by replacing  <span class="math">RC_i</span>  by  <span class="math">RC_{m+i-1}</span> .</p>

    <p class="text-gray-300">Computing forwards. As depicted on Figure 5, the corresponding set at the input of Round (m+t-4) is then of the form</p>

    <p class="text-gray-300"><span class="math">$\\{\\left(x&#x27;, -\\left(x&#x27; + \\mathsf{RC}_{m+t-4}\\right)^3 - x&#x27; - \\mathsf{RC}_{m+t-4} - \\mathsf{RC}_{m+t-3}, \\gamma_1(y), \\dots, \\gamma_{t-2}(y)\\right) \\mid x&#x27;, y \\in \\mathbb{F}_q\\}</span>$</p>

    <p class="text-gray-300">where  <span class="math">(\\gamma_1, \\ldots, \\gamma_{t-2})</span>  are some values which depend on y only. After two more rounds, we then get some internal states whose (t-2) leftmost branches do not depend on x'. It follows that each coordinate of the input of Round (m+2t-4) is a polynomial in x' and y of degree at most three in x'. After  <span class="math">(\\lfloor \\log_3(q-2)\\rfloor - 1)</span>  rounds, we get that each coordinate is a polynomial of degree at most (q-2) in x'. Then, with the same technique as before, we can add (t-1) rounds and show that the output of the permutation  <span class="math">(v_1, \\ldots, v_t)</span>  is such that the linear combination  <span class="math">(\\sum_{i=1}^{t-1} v_i - (t-2)v_t)</span>  sums to zero after  <span class="math">(3t-6+\\lfloor \\log_3(q-2)\\rfloor)</span>  rounds.</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: Middle rounds of the zero-sum distinguisher on GMiMC (with t = 5).</p>

    <p class="text-gray-300"><em>Computing backwards.</em> Starting from Round m and computing backwards, we get that the input of Round (m &minus; 1) is of the form</p>

    <p class="text-gray-300"><span class="math">$(y, \\alpha_1 - (y + \\mathsf{RC}_{m-1})^3, \\dots, x - (y + \\mathsf{RC}_{m-1})^3, f(x) - (y + \\mathsf{RC}_{m-1})^3, -y - \\mathsf{RC}_{m-1} - \\mathsf{RC}_{m-2})</span>$</p>

    <p class="text-gray-300">and the input of Round (m-2) equals</p>

    <p class="text-gray-300"><span class="math">$(-y - \\mathsf{RC}_{m-1} - \\mathsf{RC}_{m-2}, y + (y + \\mathsf{RC}_{m-1})^3, \\alpha_1, \\dots, x, f(x))</span>$
.</p>

    <p class="text-gray-300">Then, the following (t-2) rounds do not activate the Sbox, implying that all the coordinates of the input of Round (m-t) are polynomials in x and y of degree at most three in y. We deduce that the input  <span class="math">(u_1, \\ldots, u_t)</span>  of Round  <span class="math">(m-2t+2-\\lfloor \\log_3(q-2)\\rfloor)</span>  is such that the linear combination  <span class="math">(\\sum_{i=1}^{t-1}u_i-(t-2)u_t)</span>  sums to zero. This zero-sum distinguisher then covers a total of</p>

    <p class="text-gray-300"><span class="math">$5t - 8 + 2\\lfloor \\log_3(q-2) \\rfloor</span>$
rounds,</p>

    <p class="text-gray-300">which is detailed in Table 3 for the relevant parameters.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Security</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Param</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">eters</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number of rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">log_2 q</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Full</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ZS with complexity <span class="math">q</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ZS with complexity of</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">101</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">118</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">166</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">166</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">182</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">198</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">326</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">342</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OFC hita</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">174</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">182</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">188</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">186</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">206</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">218</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Number of rounds of GMIMC covered by the zero-sum distinguishers of complexity q and  <span class="math">q^2</span> .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Exploiting integral distinguishers over multiplicative subgroups</h3>

    <p class="text-gray-300">A noticeable shortcoming of the integral attacks over  <span class="math">\\mathbb{F}_q</span> , as demonstrated by Table 3, is that they do not give any result for primitives over large fields  <span class="math">\\mathbb{F}_q</span>  (for which  <span class="math">\\log_2 q \\approx 256</span> ). However, by exploiting integral distinguishers over multiplicative subgroups of  <span class="math">\\mathbb{F}_q</span>  (e.g., for the specific choice of  <span class="math">q = 2^{253} + 2^{199} + 1</span> ), we obtain essentially the same results for GMIMC instances with large q as we obtain for instances with small q. For example, in Section 4.1 we derived an integral distinguisher on</p>

    <p class="text-gray-300"><span class="math">$R = 3t - 4 + \\lfloor \\log_3(q - 2) \\rfloor</span>$
rounds,</p>

    <p class="text-gray-300">with complexity q. By exploiting any multiplicative subgroup of size  <span class="math">|\\mathbb{G}| = 2^s</span>  for  <span class="math">s \\leq 199</span>  when  <span class="math">q = 2^{253} + 2^{199} + 1</span> , we obtain an integral distinguisher on</p>

    <p class="text-gray-300"><span class="math">$R = 3t - 4 + |\\log_3(|\\mathbb{G}| - 1)|</span>$
rounds,</p>

    <p class="text-gray-300">with complexity |G| + 1.</p>

    <p class="text-gray-300">Moreover, even for smaller fields, we can fine-tune the size of G to reduce the complexity of the attack. This is relevant especially for cases where an attack with complexity q can reach more rounds than the ones used by the primitive (which is indeed the case, as shown in Table <a href="#page-14-1">3)</a>. For example, as derived in Section <a href="#page-11-0">4.2,</a> we have a zero-sum property for</p>

    <p class="text-gray-300"><span class="math">$4t - 6 + 2\\lfloor \\log_3(q-2) \\rfloor</span>$
rounds,</p>

    <p class="text-gray-300">with complexity q. For the GMiMC variant with q = 2<sup>61</sup> + 20 &times; 2 <sup>32</sup> + 1 and t = 12, we use a subgroup of size 2 33 &middot; 167 &middot; 211 &asymp; 2 <sup>48</sup> (which divides q &minus; 1), and obtain a zero-sum property for</p>

    <p class="text-gray-300"><span class="math">$4t - 6 + 2\\lfloor \\log_3(2^{48} - 1) \\rfloor = 102</span>$
rounds,</p>

    <p class="text-gray-300">with complexity of about 2 <sup>48</sup> (which covers the full permutation).</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8"><strong>5.1 Impossible differential attacks</strong></h3>

    <p class="text-gray-300">We present a new impossible differential for (3t &minus; 4) rounds, which improves the previous one for (2t &minus; 2) rounds presented by the designers <a href="#page-31-3">[5,</a> Page 46].</p>

    <p class="text-gray-300">The previous impossible differential exploits the following probability one propagation for (t &minus; 1) rounds: (0, . . . , 0, &alpha;) &rarr; (&alpha;, 0, . . . , 0) where &alpha; is a nonzero difference. Hence, (0, . . . , 0, &alpha;) never propagates to (&beta;, 0, . . . , 0) after 2t &minus; 2 rounds for any &beta;. The designers concluded that <em>conservatively</em> 2t <em>rounds are secure when the security level corresponds to the block size</em> n<em>.</em></p>

    <p class="text-gray-300">We show that (0, . . . , 0, &alpha;1) R3t&minus;<sup>4</sup> 9 (&beta;1, 0, . . . , 0) is an impossible propagation, where &alpha;1, &beta;<sup>1</sup> are non-zero differences satisfying &alpha;<sup>1</sup> 6= &beta;1. That is, we include t&minus;2 more rounds in the middle compared to the property presented by the designers.</p>

    <p class="text-gray-300">The intuition for why the above differential is impossible is as follows. When (0, . . . , 0, &alpha;1) is propagated, the output difference of the cube mapping is 0 for the first t&minus;1 rounds and is unpredictable for the next t/2&minus;1 rounds. We denote them by &alpha;2, &alpha;3, . . . , &alpha;t/2. Similarly, we extend (0, . . . , 0, &beta;1) by t/2 &minus; 1 rounds backwards, using the notation &beta;2, &beta;3, . . . , &beta;t/2. Here, to be a valid propagation, those differences must be equal in all the branches, which yields a system of t linear equations with 2(t/2 &minus; 1) = t &minus; 2 variables. By solving the system, we obtain that &alpha;<sup>1</sup> = &beta;<sup>1</sup> is a necessary condition to obtain a valid differential propagation. In other words, for any &alpha;1, &beta;<sup>1</sup> with &alpha;<sup>1</sup> 6= &beta;1, the propagation is impossible. A detailed analysis of this property is provided in Appendix <a href="#page-35-0">A.</a></p>

    <p class="text-gray-300">The original paper <a href="#page-31-3">[5,</a> Appendix D] analyzes the resistance of GMiMC against differential attacks. Most notably, the designers exhibit a differential characteristic over (t+ 1) rounds with two active Sboxes, with probability 2 <sup>&minus;</sup>(2n+2) where n = log<sup>2</sup> q and they conjecture that the corresponding differential is optimal. They deduce that</p>

    <p class="text-gray-300"><span class="math">$R = 2 + (t+1) \\left\\lceil \\frac{tn}{2(n-1)} \\right\\rceil</span>$
rounds</p>

    <p class="text-gray-300">are sufficient to resist differential cryptanalysis in the sense that the data complexity of the attack exceeds the size of the full codebook. For instance, when t = 12 and n = 61, this corresponds to 93 rounds out of 101.</p>

    <p class="text-gray-300"><em>A better differential.</em> We exhibit another differential, over t rounds, which leads to a much more efficient attack. Let &alpha; and &alpha; <sup>0</sup> be two differences in Fq. Then, the difference (0, . . . , 0, &alpha;, &alpha;<sup>0</sup> ) propagates through t rounds of the permutation as</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, \\alpha, \\alpha&#x27;) \\xrightarrow{\\mathcal{R}^{t-2}} (\\alpha, \\alpha&#x27;, 0 \\dots, 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\alpha&#x27; + \\beta, \\beta, \\dots, \\beta, \\alpha)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\beta + \\beta&#x27;, \\dots, \\beta + \\beta&#x27;, \\alpha + \\beta&#x27;, \\alpha&#x27; + \\beta),</span>$</p>

    <p class="text-gray-300">where &alpha; S &rarr; &beta; denotes the Sbox transition occurring at Round (t&minus;1) and &alpha; <sup>0</sup>+&beta; S &rarr; &beta; 0 the Sbox transition occurring at Round t.</p>

    <p class="text-gray-300">It follows that, for any possible value of &beta;, we obtain the following t-round differential as soon as &beta; <sup>0</sup> = &minus;&beta;, which occurs with probability 2 <sup>&minus;</sup><sup>n</sup> on average:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha,\\alpha&#x27;) \\xrightarrow{\\mathcal{R}^t} (0,\\ldots,0,\\alpha-\\beta,\\alpha&#x27;+\\beta)</span>$
.</p>

    <p class="text-gray-300">Since this probability does not depend on the choice of &alpha; and &alpha; 0 , this differential can be iterated several times to cover more rounds.</p>

    <p class="text-gray-300">For instance, when t = 12 and n = 61, the 101 rounds of GMiMC can be decomposed into 8 blocks of t = 12 rounds, followed by 5 rounds. We then get a differential of the form</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, \\alpha, \\alpha&#x27;) \\longrightarrow (0, 0, 0, 0, 0, \\gamma, \\gamma&#x27;, 0, 0, 0, 0, 0)</span>$</p>

    <p class="text-gray-300">over the full cipher for some unknown &gamma;, &gamma;<sup>0</sup> with probability at least</p>

    <p class="text-gray-300"><span class="math">$P = (2^{-61})^8 = 2^{-488}</span>$</p>

    <p class="text-gray-300">since the characteristic over the last 5 rounds has probability one. This leads to a differential distinguisher over the full permutation with complexity P <sup>&minus;</sup><sup>1</sup> = 2<sup>488</sup> which is much lower than the size of the full codebook (2 <sup>732</sup>).</p>

    <p class="text-gray-300">It is worth noticing that P is a lower bound on the probability of the 101 round differential since we considered pairs following some specific characteristics by fixing the forms of some differences at intermediate rounds. Some additional input pairs may lead to an output difference of the same form but not to these specific intermediate differences.</p>

    <p class="text-gray-300">Improving the complexity of the distinguisher with structures. The data complexity of the previous distinguisher can be improved by using structures of inputs. Here, a structure is a set of  <span class="math">2^{2n}</span>  inputs of the form  <span class="math">S_c = \\{(c_1, \\ldots, c_{t-2}, x, y) \\mid x, y \\in \\mathbb{F}_p\\}</span> . The difference between any two elements in the same structure has the form  <span class="math">(0, \\ldots, 0, \\alpha, \\alpha&#x27;)</span> . It follows that, from any structure, we can construct  <span class="math">2^{4n-1}</span>  pairs of inputs whose difference conforms with the differential. Then, the number of structures required to obtain  <span class="math">P^{-1} = 2^{8n}</span>  pairs with an appropriate difference is</p>

    <p class="text-gray-300"><span class="math">$2^{8n-4n+1} = 2^{4n+1},</span>$</p>

    <p class="text-gray-300">leading to an overall data complexity of  <span class="math">2^{6n+1} = 2^{367}</span> . The time complexity is equal to the data complexity here since the distinguisher consists in identifying the output pairs which coincide on all output words except the two in the middle. This does not require computing all pairs of elements in each structure, but only to store the values  <span class="math">\\pi(x), x \\in \\mathcal{S}_c</span>  according to their first coordinates.</p>

    <p class="text-gray-300">This differential distinguisher does not lead to an attack with complexity below the target security level. However, this must be considered as an unsuitable property since its complexity is much lower than what we expect for a randomly chosen permutation on a set of size  <span class="math">2^{732}</span> .</p>

    <p class="text-gray-300">It is worth noticing that, if we restrict ourselves to distinguishers with complexity below the target security level of 128 bits, then we can use at most  <span class="math">2^{128}/2^{2n}=2^6</span>  structures. Therefore, we can derive from these structures  <span class="math">2^{6+4n-1}</span>  i.e.  <span class="math">2^{249}</span>  pairs of inputs conforming with the differential. These pairs be can used to distinguish 4 blocks of t rounds since the differential has probability at least  <span class="math">2^{-244}</span> . Moreover, a valid pair propagates to a differential of the form  <span class="math">(\\gamma, \\gamma&#x27;, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</span>  with probability one over (t-2) rounds, and we can extend it by a few more rounds by considering the number of state words that have the same difference. After another 6 rounds, the pair has a differential of the form</p>

    <p class="text-gray-300"><span class="math">$(\\Delta, \\Delta, \\Delta, \\Delta, \\Delta, \\Delta, *, *, *, *, *, *),</span>$</p>

    <p class="text-gray-300">with probability one, where * is an unknown difference that we do not care about. This differential form has a constraint of the size 5n: the left-most six state words have an identical difference. The number of queries to satisfy the same property for a randomly chosen permutation is lower bounded by  <span class="math">2^{5n/2} \\approx 2^{152.5}</span> . This implies that we can distinguish 4t + (t-2) + (t-6) = 64 rounds of GMIMC from a randomly chosen permutation with complexity less than  <span class="math">2^{128}</span> .</p>

    <p class="text-gray-300">Improved distinguisher using three active words. If we consider a differential with only two active words, the biggest structure we can build is of size  <span class="math">2^{2n}</span> , which limits the advantage of using structures in reducing the cost of the distinguishers.</p>

    <p class="text-gray-300">Let us now consider the following differential:</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, \\alpha, \\alpha&#x27;, \\alpha&#x27;&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{\\mathcal{R}^{t-3}}{\\longrightarrow} (\\alpha, \\alpha&#x27;, \\alpha&#x27;&#x27;, 0 \\dots, 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{\\mathcal{R}}{\\longrightarrow} (\\alpha&#x27;&#x27; + \\beta, \\alpha&#x27;&#x27; + \\beta, \\beta, \\dots, \\beta, \\alpha)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{\\mathcal{R}}{\\longrightarrow} (\\alpha&#x27;&#x27; + \\beta + \\beta&#x27;, \\beta + \\beta&#x27;, \\beta + \\beta&#x27;, \\dots, \\beta + \\beta&#x27;, \\alpha + \\beta&#x27;, \\alpha&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\stackrel{\\mathcal{R}}{\\longrightarrow} (\\beta + \\beta&#x27; + \\beta&#x27;&#x27;, \\dots, \\beta + \\beta&#x27; + \\beta&#x27;&#x27;, \\alpha + \\beta&#x27; + \\beta&#x27;&#x27;, \\alpha&#x27; + \\beta + \\beta&#x27;&#x27;, \\alpha&#x27;&#x27; + \\beta + \\beta&#x27;),</span>$</p>

    <p class="text-gray-300">where &alpha; S &rarr; &beta;, &alpha; <sup>0</sup> + &beta; S &rarr; &beta; <sup>0</sup> and &alpha; <sup>00</sup> + &beta; + &beta; 0 S &rarr; &beta; <sup>00</sup> denote the Sbox transitions occurring at Round (t &minus; 2), at Round (t &minus; 1) and at Round t.</p>

    <p class="text-gray-300">As with the previous differential, if &beta; + &beta; <sup>0</sup> + &beta; <sup>00</sup> = 0, which occurs with probability 2 <sup>&minus;</sup><sup>n</sup> on average, we have:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha,\\alpha&#x27;,\\alpha&#x27;&#x27;) \\xrightarrow{\\mathcal{R}^t} (0,\\ldots,0,\\alpha-\\beta,\\alpha&#x27;+\\beta+\\beta&#x27;&#x27;,\\alpha&#x27;&#x27;-\\beta&#x27;&#x27;).</span>$</p>

    <p class="text-gray-300">Again, the probability of this transition is independent of the values of &alpha;, &alpha; <sup>0</sup> and &alpha; <sup>00</sup>, so it can be iterated with probability 2 <sup>&minus;</sup>n.</p>

    <p class="text-gray-300">For this differential, we can build structures of size 2 <sup>3</sup><sup>n</sup>. This will allow us to consider around 2 <sup>6</sup><sup>n</sup> pairs with the required input differential, so we can expect to be able to iterate the characteristic for 6t rounds. The total distinguisher will cover 6t + (t &minus; 3) rounds. As for the previous one, we can add 4 more rounds, generating an output state with 8 words having the same difference with a cost of 2 <sup>3</sup>n, compared to a cost of 2 7n/2 for a random permutation. For GMiMC with t = 12, this allows to distinguish 85 rounds with a cost of 2 <sup>3</sup><sup>n</sup>. By repeating this procedure 2 <sup>n</sup> times, we can expect t more round to be covered, and distinguish the whole permutation with 101 rounds with a complexity of 2 <sup>5</sup><sup>n</sup> = 2<sup>320</sup> and having 9 words with a zero difference (as we do not need to add the final four rounds).</p>

    <p class="text-gray-300">Let us point out that using four instead of three words would not improve the number of rounds attacked on GMiMC-128-d, as the cost of one structure is already the same as the cost of obtaining the 8 non-zero differences in the output for a random permutation. Nevertheless, in the case of the GMiMC variant 256-b with t = 14, if we use a similar differential with four active words, we can distinguish up to 8t + (t &minus; 4) = 122 rounds while finding 10 words with no difference and with a complexity of about 2 <sup>4</sup><sup>n</sup> = 2<sup>500</sup> .</p>

    <p class="text-gray-300">To determine whether further improvements of these differentials are possible, we have searched for other differential characteristics with a Mixed-Integer Linear Programming (MILP) model. We conclude that the previously described characteristics are essentially optimal for the defined search space, and refer Appendix <a href="#page-36-0">B</a> for details.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8"><strong>5.3 Algebraically controlled differential attacks</strong></h3>

    <p class="text-gray-300">In this section, we show how to use algebraic techniques to efficiently find inputs that satisfy a given differential characteristic. The basic idea is to represent the initial state of the permutation symbolically by assigning variables to some of its branches, while the remaining branches are assigned constant values. We then compute the permutation symbolically for several rounds. Namely, for each round, we derive a polynomial expression for each branch of the internal state in terms of the allocated variables.</p>

    <p class="text-gray-300">We repeat this process starting from two initial states (representing two inputs to the permutation), perhaps assigning them different variables. We can now represent the difference between the internal states at each round in these two computations using polynomial expressions in the allocated variables. In particular, each differential transition of the given differential characteristic (whose probability is smaller than one) is expressed as a polynomial equation in the variables. Collecting the equations for all differential transitions, we obtain a system of polynomial equations, whose solution immediately gives two inputs to the permutation that satisfy the differential characteristic. For this approach to be useful, the equation system has to be efficiently solvable, which generally implies that we cannot allocate too many variables and need to minimize the algebraic degree of the polynomial equations.</p>

    <p class="text-gray-300">Next, we discuss the complexity of solving equation systems of a specific form that we encounter in the remainder of this section. We then demonstrate the basic attack approach with an example and continue with more involved attacks.</p>

    <p class="text-gray-300"><em>Solving polynomial equation systems with few variables.</em> Some of our attacks in the remainder of this section reduce to solving equation systems over Fq. When possible, we solved the systems in practice using the MAGMA software. However, it is also important to understand the complexity of our attacks on stronger variants of the cryptosystem, where they become impractical. In this section, we will only consider systems with one or two variables and estimate the complexity of solving such systems below. We note that in Section <a href="#page-27-0">6.2</a> we encounter equation systems with more variables. Solving such equations is more involved and we will have to use a different estimation, which is heuristic (but standard).</p>

    <p class="text-gray-300">Solving a univariate polynomial equation over F<sup>q</sup> of degree d is done by factoring the polynomial. Asymptotically, the best known algorithm for this problem was published in <a href="#page-33-10">[31]</a> and has complexity of about d <sup>1</sup>.5+o(1) bits operations. We note, however, that the o(1) expression in the exponent hides a non-negligible term. Solving two bivariate polynomial equations P1(x, y) = 0 and P2(x, y) = 0 of total degrees d<sup>1</sup> and d<sup>2</sup> (respectively) can be done by computing the <em>resultant</em><a href="#page-19-0">9</a> of the two polynomials, which is a univariate polynomial in x of degree d<sup>1</sup> &middot; d2. We then compute the roots of the resultant (by factoring it) and for each such root x&macr;, we compute the common roots of P1(&macr;x, y) and P2(&macr;x, y) (using a GCD algorithm). In general, the heaviest step in this process is factoring the resultant.</p>

    <p class="text-gray-300"><sup>9</sup> The resultant of two polynomials is itself a polynomial in their coefficients, whose zeroes coincide with the common roots of the two polynomials.</p>

    <p class="text-gray-300">Satisfying 3t-2 rounds. We show how to efficiently satisfy 3t-2 rounds of the iterative differential characteristic of Section 5,</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\mu_0,\\mu&#x27;_0) \\xrightarrow{\\mathcal{R}^{t-2}} (\\mu_0,\\mu&#x27;_0,0\\ldots,0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu&#x27;_0+\\mu_1,\\mu_1,\\ldots,\\mu_1,\\mu_0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu_1+\\mu&#x27;_1,\\ldots,\\mu_1+\\mu&#x27;_1,\\mu_0+\\mu&#x27;_1,\\mu&#x27;_0+\\mu_1),</span>$</p>

    <p class="text-gray-300">where we require that  <span class="math">\\mu_1 + \\mu&#x27;_1 = 0</span> .</p>

    <p class="text-gray-300">Consider an initial state of the permutation of the form</p>

    <p class="text-gray-300"><span class="math">$X_0 = (\\alpha_1, \\dots, \\alpha_{t-2}, x, f(x)),</span>$</p>

    <p class="text-gray-300">where the  <span class="math">\\alpha_i</span>  are constants in  <span class="math">\\mathbb{F}_q</span> , x is a variable and the function f(x) is described in Section 4 (see (1)). Then, as described in Section 4, the internal state at Round (t-2) is described as</p>

    <p class="text-gray-300"><span class="math">$X_{t-2} = (x + \\sum_{i=1}^{t-2} \\beta_i, f(x) + \\sum_{i=1}^{t-2} \\beta_i, \\gamma_1, \\dots, \\gamma_{t-2}),</span>$</p>

    <p class="text-gray-300">while the state at Round (2t-2) is described as</p>

    <p class="text-gray-300"><span class="math">$X_{2t-2} = (x&#x27; - (x&#x27; + \\mathsf{RC}_{t-1})^3 + \\delta_1, -x&#x27; + \\delta_1, \\delta_2, \\dots, \\delta_t),</span>$</p>

    <p class="text-gray-300">where  <span class="math">x&#x27; = x + \\sum_{i=1}^{t-2} \\beta_i</span> . Starting from Round (2t-2), the algebraic degree of the branches generally grows by a multiplicative factor of 3 per round, namely, the algebraic degree of Round (2t-2+r) is at most  <span class="math">3^{r+1}</span> .</p>

    <p class="text-gray-300">Next, consider another initial state of the permutation of the form</p>

    <p class="text-gray-300"><span class="math">$Y_0 = (\\alpha_1, \\dots, \\alpha_{t-2}, y, f(y)),</span>$</p>

    <p class="text-gray-300">where the initial constants  <span class="math">\\alpha_i</span>  are identical to those of  <span class="math">X_0</span> . Note that the initial difference between the states is of the form</p>

    <p class="text-gray-300"><span class="math">$\\Delta_0 = X_0 - Y_0 = (0, \\dots, 0, \\mu_0(x, y), \\mu&#x27;_0(x, y)).</span>$</p>

    <p class="text-gray-300">Then, the state  <span class="math">Y_{2t-2}</span>  after Round (2t-2) is described as</p>

    <p class="text-gray-300"><span class="math">$Y_{2t-2} = (y&#x27; - (y&#x27; + \\mathsf{RC}_{t-1})^3 + \\delta_1, -y&#x27; + \\delta_2, \\delta_3, \\dots, \\delta_t).</span>$</p>

    <p class="text-gray-300">Therefore, the choice of the initial states of the two inputs, assures that (2t-2) rounds of the differential characteristic are satisfied with probability one. At round 2t, we have</p>

    <p class="text-gray-300"><span class="math">$\\Delta_{2t} = X_{2t} - Y_{2t} =</span>$</p>

    <p class="text-gray-300"><span class="math">$(\\mu_2(x,y)+\\mu_2&#x27;(x,y),\\ldots,\\mu_2(x,y)+\\mu_2&#x27;(x,y),\\mu_1(x,y)+\\mu_2&#x27;(x,y),\\mu_1&#x27;(x,y)+\\mu_2(x,y)).</span>$</p>

    <p class="text-gray-300">and we require  <span class="math">\\mu_2(x,y) + \\mu_2&#x27;(x,y) = 0</span> , which is a polynomial equation of degree  <span class="math">3^{2+1} = 27</span>  in the variables x,y. Since we have 2 variables and only one equation in  <span class="math">\\mathbb{F}_q</span> , we can set one of the variables to an arbitrary constant and solve a univariate polynomial equation in the other variable. We expect one solution on average, which gives an input pair that satisfies the differential characteristic for 2t rounds. Since the next (t-2) rounds are satisfied with probability one, we can satisfy 3t-2 rounds at the cost of solving a univariate polynomial equation over  <span class="math">\\mathbb{F}_q</span>  of degree 27 (which has very low complexity).</p>

    <p class="text-gray-300"><em>Satisfying</em> 4t &minus; 2 <em>rounds in an inside-out setting.</em> In an inside-out setting, the differential characteristic can be extended from (3t&minus;2) rounds to (4t&minus;2) rounds algebraically, by adding t rounds before the initial state. Indeed, since the initial state is described by polynomials of degree 3, the state at round (&minus;2) can be described by polynomials of degree 27:</p>

    <p class="text-gray-300"><span class="math">$\\Delta_{-2} = X_{-2} - Y_{-2} = (\\mu_{-1}(x, y) + \\mu&#x27;_{-1}(x, y), \\dots, \\mu_{-1}(x, y) + \\mu&#x27;_{-1}(x, y), \\lambda_1(x, y) + \\mu&#x27;_{-1}(x, y), \\lambda&#x27;_1(x, y) + \\mu_{-1}(x, y)).</span>$</p>

    <p class="text-gray-300">Thus, we require &micro;<sup>&minus;</sup>1(x, y)+&micro; 0 &minus;1 (x, y) = 0 in addition to &micro;2(x, y)+&micro; 0 2 (x, y) = 0. This defines a system of two equations of degree 27 in two variables. Any solution with x 6= y defines a pair of states that satisfies a differential characteristic from round (&minus;t) to round (3t &minus; 2), because rounds (&minus;t) to (&minus;2) are satisfied with probability 1.</p>

    <p class="text-gray-300">To solve the system, we first divide each equation by (y &minus; x) to eliminate trivial solutions with x = y. Then we compute a Gr&ouml;bner basis of the resulting system. Using the MAGMA software, this can be done in less than one minute on a standard PC (solving the system also has very low complexity by our theoretical estimate). Moreover, this can be extended to a distinguisher on 66 rounds by considering a truncated difference in the input and output. We give an example in Figure <a href="#page-21-0">6.</a></p>

    <pre><code class="language-text">load(&#x27;GMiMC_erf.sage&#x27;) # https://starkware.co/hash-challenge/
S128d_40 = GMiMCParams(field=F61, r=8, c=4, num_rounds=66)
x = vector(F61, [
    2136504846259473744, 1283314153929910666, 1750372136437271205,
    1867169825994287512, 821961362109051955, 1707450857617152361,
    552784820823413051, 484096115705447781, 887825053625051502,
    527122293700370254, 925898050459212322, 1348485354687005037])
y = vector(F61, [
    605957700298844821, 2195497570512456035, 1242887650166759306,
    1453303426557585887, 2164561375454964764, 333859287618218787,
    1549736142184771152, 1358466196860349803, 121930483920884288,
    647266587342612993, 425900737534652142, 848488041762444857])
print (&quot;Input diff : &quot;+&quot; &quot;.join([&quot;{:20}&quot;.format(u.lift()) for u in y-x]))
x = erf_feistel_permutation(x, S128d_40)
y = erf_feistel_permutation(y, S128d_40)
print (&quot;Output diff: &quot;+&quot; &quot;.join([&quot;{:20}&quot;.format(u.lift()) for u in y-x]))
</code></pre>

    <p class="text-gray-300">Figure 6: Sagemath code verifying a pair of inputs with a distinguishing property on 66 rounds of GMiMC-128-d: &#8710;0[10] = &#8710;0[11] and &#8710;65[0] = &#8710;65[1]</p>

    <p class="text-gray-300">Satisfying 4t-4 rounds. If we want to use the differential in a collision attack, we must preserve the value of some initial state words, and we cannot use the inside-out technique. We describe an alternative technique, using a modified differential with four active state words:</p>

    <p class="text-gray-300"><span class="math">$(0, \\dots, 0, \\mu_0, \\mu&#x27;_0, \\mu&#x27;&#x27;_0, \\mu&#x27;&#x27;&#x27;_0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}^{t-4}} (\\mu_0, \\mu&#x27;_0, \\mu&#x27;&#x27;_0, \\mu&#x27;&#x27;&#x27;_0, 0 \\dots, 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu&#x27;_0 + \\mu_1, \\mu&#x27;&#x27;_0 + \\mu_1, \\mu&#x27;&#x27;&#x27;_0 + \\mu_1, \\mu_1, \\dots, \\mu_1, \\mu_0)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;_1, \\mu&#x27;&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;_1, \\mu_1 + \\mu&#x27;_1, \\dots, \\mu_1 + \\mu&#x27;_1, \\mu_0 + \\mu&#x27;_1, \\mu&#x27;_0 + \\mu_1)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu&#x27;&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;_1 + \\mu&#x27;&#x27;_1, \\mu_1 + \\mu&#x27;_1 + \\mu&#x27;&#x27;_1, \\dots, \\mu_1 + \\mu&#x27;_1 + \\mu&#x27;&#x27;_1, \\mu_0 + \\mu&#x27;_1 + \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 + \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 - \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 - \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;&#x27;_0 + \\mu_1 - \\mu&#x27;&#x27;&#x27;_1)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\xrightarrow{\\mathcal{R}} (\\mu_1, \\dots, \\mu_1, \\mu_0 + \\mu_1 - \\mu_1, \\mu&#x27;_0 + \\mu_1 - \\mu&#x27;_1, \\mu&#x27;&#x27;_0 + \\mu_1 - \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;&#x27;_0 + \\mu_1 - \\mu&#x27;&#x27;&#x27;_1)</span>$
with  <span class="math">\\mu_1 = \\mu_1 + \\mu&#x27;_1 + \\mu&#x27;&#x27;_1 + \\mu&#x27;&#x27;&#x27;_1</span> .</p>

    <p class="text-gray-300">As in Section 5.2, we require that  <span class="math">\\mu_1 = 0</span> . This happens with probability  <span class="math">2^{-n}</span> , and results in an iterative truncated characteristic  <span class="math">(0, \\ldots, 0, *, *, *, *)</span> .</p>

    <p class="text-gray-300">As in the previous attack, we build an initial state with special relations to control the first t rounds with probability one:</p>

    <p class="text-gray-300"><span class="math">$X_0 = (\\alpha_1, \\dots, \\alpha_{t-4}, x, f(x), y, f(y)).</span>$</p>

    <p class="text-gray-300">This ensures that the state at Round (2t-4) is of the form:</p>

    <p class="text-gray-300"><span class="math">$X_{2t-4} = (x&#x27; - (x&#x27; + \\mathsf{RC}_{t-1})^3 + \\delta_1, -x&#x27; + \\delta_2, y&#x27; - (y&#x27; + \\mathsf{RC}_{t-1})^3 + \\delta_3, -y&#x27; + \\delta_4, \\delta_5, \\dots, \\delta_t).</span>$</p>

    <p class="text-gray-300">Instead of considering two different states with this shape (with four unknown in total), we will consider one variable state and one fixed state with (x, y) = (0, 0). When we consider the state at Round (2t), we have</p>

    <p class="text-gray-300"><span class="math">$\\Delta_{2t} = X_{2t} - X_{2t}(0,0) = (\\boldsymbol{\\mu}_2, \\dots, \\boldsymbol{\\mu}_2, \\boldsymbol{\\mu}_1 + \\boldsymbol{\\mu}_2 - \\boldsymbol{\\mu}_2, \\boldsymbol{\\mu}_1&#x27; + \\boldsymbol{\\mu}_2 - \\boldsymbol{\\mu}_2&#x27;, \\boldsymbol{\\mu}_1&#x27;&#x27; + \\boldsymbol{\\mu}_2 - \\boldsymbol{\\mu}_2&#x27;&#x27;, \\boldsymbol{\\mu}_1&#x27;&#x27;&#x27; + \\boldsymbol{\\mu}_2 - \\boldsymbol{\\mu}_2&#x27;&#x27;)</span>$</p>

    <p class="text-gray-300">Where  <span class="math">(\\mu_1, \\mu&#x27;_1, \\mu&#x27;&#x27;_1, \\mu&#x27;&#x27;&#x27;_1)</span>  are polynomials of degree 3, 1, 3, and 1 respectively (as seen in  <span class="math">X_{2t-4}</span> ), and  <span class="math">(\\mu_2, \\mu&#x27;_2, \\mu&#x27;&#x27;_2, \\mu&#x27;&#x27;&#x27;_2)</span>  are polynomials of degree 9, 27, 81, and 243, with  <span class="math">\\mu_2 = \\mu_2 + \\mu&#x27;_2 + \\mu&#x27;&#x27;_2 + \\mu&#x27;&#x27;&#x27;_2</span> . All polynomials have variables x and x', and  <span class="math">X_{2t}(0,0)</span>  is a vector of constants. We now require  <span class="math">\\mu_2(x,x&#x27;) = 0</span> , and we can simplify the state using this assumption:</p>

    <p class="text-gray-300"><span class="math">$X_{2t} = X_{2t}(0,0) + (0,\\ldots,0,\\mu_1 - \\mu_2,\\mu_1&#x27; - \\mu_2&#x27;,\\mu_1&#x27;&#x27; - \\mu_2&#x27;&#x27;,\\mu_1&#x27;&#x27;&#x27; + \\mu_2 + \\mu_2&#x27; + \\mu_2&#x27;&#x27;).</span>$</p>

    <p class="text-gray-300">We obtain an expression of degree  <span class="math">(0, \\ldots, 0, 9, 27, 81, 81)</span> .</p>

    <p class="text-gray-300">When we focus on Round (3t), we can now express the condition of the differential as a polynomial of degree 729. Therefore, we have a system of two</p>

    <p class="text-gray-300">equations of degree 243 and 729 in two variables. To estimate the complexity of solving the system, recall that we factor the resultant of these polynomials in time  <span class="math">d^{1.5+o(1)}</span>  bit operations. In our case,  <span class="math">d=243\\cdot729=177,147</span> .</p>

    <p class="text-gray-300">Any solution with  <span class="math">(x, y) \\neq (0, 0)</span>  defines a state such that (X(x, y), X(0, 0)) satisfies the differential characteristic up to round (4t - 4), because rounds (4t) to (4t - 4) are satisfied with probability one.</p>

    <p class="text-gray-300">Extending the differentials. All these attacks can be extended probabilistically by finding about q different input pairs that satisfy the differential characteristic (each pair is found by choosing different constants  <span class="math">\\alpha_i</span>  in the initial state). With high probability, one of these input pairs will also satisfy the next differential transitions, and follow the characteristic for t more rounds.</p>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Reduced-round collision attacks</h3>

    <p class="text-gray-300">We can build collisions on a reduced number of rounds by using the same ideas as for the previous structural or algebraic differential distinguishers. The additional constraint that we have now compared to distinguishers is that any values that need to be chosen must be assigned to the rate part, <em>i.e.</em> the 8 left-most words in GMIMC-128-d, and the capacity part, <em>i.e.</em> the 4 right-most words in GMIMC-128-d, will be fixed to a known value we cannot choose.</p>

    <p class="text-gray-300">Building collisions with structures. We won't use the 3-word differential but the 2-word one, as using the full 2n structure from the 2-word one already implies a complexity equivalent to that of a generic collision attack. Instead of having t=12 free rounds at the beginning, we will have only 8, due to the 4 words reserved for the capacity. With a cost of  <span class="math">2^{r\\cdot n}</span>  we can then go through  <span class="math">r\\cdot t</span>  rounds maintaining the same differential. Finally, we can freely add (t-2) rounds that preserve the differences in the rate part and, consequently, can finally be cancelled:</p>

    <p class="text-gray-300"><span class="math">$(0,\\ldots,0,\\alpha,\\alpha&#x27;,0,0,0,0) \\xrightarrow{\\mathcal{R}^{t-6}} (\\alpha,\\alpha&#x27;,0\\ldots,0) \\xrightarrow{\\mathcal{R}^{r\\cdot t}} (\\beta,\\beta&#x27;,0\\ldots,0),</span>$</p>

    <p class="text-gray-300">This differential has a probability of  <span class="math">2^{-r \\cdot t}</span> , and would allow to build collisions up to 3t-6 rounds, so for 30 rounds for GMIMC-128-d. If we use structures we can improve this: if we build a structure of size  <span class="math">2^x</span> , with the cost of the structure we can verify a probability up to  <span class="math">2^{-2x}</span> . If we choose structures of size  <span class="math">2^{3n/2}</span> , we can consider r=3. This would provide collisions for 4t-6 rounds. For GMIMC-128-d this implies collisions on 42 rounds with a cost of  <span class="math">2^{92}</span> , and for GMIMC-256 it implies collisions on 50 rounds with a complexity of  <span class="math">2^{187}</span> .</p>

    <p class="text-gray-300">Building collisions with algebraically controlled techniques. To use the algebraically controlled techniques in a collision attack, we must not use any difference in the inner part of the sponge. As noted, in the case of GMIMC-128-d, we have c=4, therefore, we start from a state</p>

    <p class="text-gray-300"><span class="math">$X_0 = (\\alpha_1, \\dots, \\alpha_4, x, f(x), y, f(y), \\alpha_9, \\dots, \\alpha_{12})</span>$</p>

    <p class="text-gray-300">and we have a characteristic over 4t-4-c=40 rounds. In MAGMA, this takes a few minutes using less than 3GB of RAM. We give an example of a conforming pair in Figure 7, where all the  <span class="math">\\alpha</span>  constants have been set to zero. This attack can be extended to t more rounds probabilistically, with (asymptotic) complexity of  <span class="math">q \\cdot d^{1.5+o(1)}</span>  bit operations. In our case, d=177,147 and we obtain an estimate of about  <span class="math">2^{90}</span>  if we ignore the o(1) term.</p>

    <pre><code class="language-text">load(&#x27;GMiMC_erf.sage&#x27;) # https://starkware.co/hash-challenge/
S128d_40 = GMiMCParams(field=F61, r=8, c=4, num_rounds=40)

x = vector(F61, [0, 0, 0, 0, 0, 1265014881285225376, 0, 1323963633845726391, 0, 0, 0, 0])
y = vector(F61, [0, 0, 0, 0, 1687869230625042828, 1678073603247747657, 1246244071391540901, 1919915214622971772, 0, 0, 0, 0])

print (&quot;Input diff: &quot;+&quot; &quot;.join([&quot;{:20}&quot;.format(u.lift()) for u in y-x]))
x = erf_feistel_permutation(x, S128d_40)
y = erf_feistel_permutation(y, S128d_40)
print (&quot;Output diff: &quot;+&quot; &quot;.join([&quot;{:20}&quot;.format(u.lift()) for u in y-x]))
</code></pre>

    <p class="text-gray-300">Figure 7: Sagemath code verifying a pair of inputs following the characteristic for a 40-rounds collision attack of GMIMC-128-d.</p>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Attacks on HadesMiMC</h2>

    <p class="text-gray-300">This section describes two types of attacks against HadesMiMC, which both exploit the propagation of affine subspaces over the partial rounds. The first one is an integral distinguisher covering all rounds except the first two rounds for most sets of parameters. The second one is a preimage attack on the full function which applies when the MDS matrix defining the linear layer has, up to multiplication by a scalar, a low multiplicative order. It is worth noticing that, while the designers of HadesMiMC do not mention any requirements on this MDS matrix, they provide several suggestions. For Starkad and Poseidon, Cauchy matrices are used [28]. In Appendix C , we identify weak instances from this class of matrices. Alternatively, the HadesMiMC authors propose [29, Appendix B] the use of a matrix of the form  <span class="math">A \\times B^{-1}</span>  where both A and B are Vandermonde matrices with generating elements  <span class="math">a_i</span>  and  <span class="math">b_i</span> . In this case, if  <span class="math">a_i = b_i + r</span>  for some  <span class="math">r \\in \\mathbb{F}_q</span> , then the resulting MDS matrix will be an involution for  <span class="math">\\mathbb{F}_q</span>  of characteristic two [39]. Similarly, in characteristic  <span class="math">p \\neq 2</span> , one obtains an involution whenever  <span class="math">a_i = -b_i</span> .</p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8">6.1 Integral distinguishers</h3>

    <p class="text-gray-300">In HadesMiMC, the number of rounds has been chosen by the designers in such a way that, when each coordinate of the output is expressed as a polynomial in t variables over  <span class="math">\\mathbb{F}_q</span> , then the degree of this polynomial in each input is close to (q-1), which is the behaviour expected for a randomly chosen permutation. Assuming that the degree grows as  <span class="math">3^r</span>  for r rounds (which is an upper bound),  <span class="math">\\lceil \\log_3(t(q-1)) \\rceil</span>  rounds are enough to get a polynomial of total degree (q-1)t. For the concrete parameters, i.e. t=12 and  <span class="math">q=2^{61}+20\\times 2^{32}+1</span>  for Poseidon, we get that 41 rounds (out of 48 in total) are necessary to achieve maximal degree. For Starkad with t=12 and  <span class="math">q=2^{63}</span> , 43 rounds (out of 51 in total) are necessary.</p>

    <p class="text-gray-300">An integral property. Our idea to improve upon the trivial bound above by a few partial rounds is to choose a specific subspace of inputs. Indeed, we are going to construct a one-dimensional subspace V such that t-1 partial rounds will map any coset  <span class="math">V+v_0</span>  onto a coset of another one-dimensional subspace W. Adding at most  <span class="math">\\lfloor \\log_3(q-2) \\rfloor</span>  rounds (either full or partial), ensures that the conditions of Corollary 1 are satisfied and thus the outputs sum to zero.</p>

    <p class="text-gray-300"><span class="math">$V + v_0 \\xrightarrow{\\mathcal{R}_p^{t-1}} W + w_0 \\xrightarrow{\\deg &lt; q-1} \\text{zero sum.}</span>$</p>

    <p class="text-gray-300">Let us denote by V a linear subspace of internal states after the Sbox layer of the last of the first  <span class="math">R_f/2</span>  full rounds (see Figure 8). Then, this subspace leads to an affine subspace at the input of the first partial round, which is a coset of L(V). The following lemma guarantees the existence of a nontrivial vector space L(V) such that any coset of L(V) is mapped to a coset of  <span class="math">V = L^t(V)</span>  after t-1 partial rounds.</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong> Let  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  denote a permutation obtained from  <span class="math">r \\geq 1</span>  partial HADESMIMC rounds instantiated with linear layer L. If L has multiplicative order h up to multiplication by a scaler, then there exists a vector space V with  <span class="math">\\dim V \\geq t - \\min\\{h, r\\}</span>  such that  <span class="math">F(x + V) \\subseteq F(x) + L^r(V)</span>  for all  <span class="math">x \\in \\mathbb{F}_q^t</span> .</p>

    <p class="text-gray-300">Proof. Let  <span class="math">V = \\langle \\delta_t, L^T(\\delta_t), \\dots, (L^T)^{r-1}(\\delta_t) \\rangle^{\\perp}</span>  where  <span class="math">\\delta_t = (0, \\dots, 0, 1)</span> . Clearly, dim V satisfies the desired lower bound. It suffices to show that for all  <span class="math">x \\in \\mathbb{F}_q^t</span>  and  <span class="math">v \\in V</span> ,  <span class="math">F(x+v) = F(x) + L^T(v)</span> . Let  <span class="math">F = R_r \\circ \\dots \\circ R_1</span> . Since the last coordinate of any v in V is zero, i.e.  <span class="math">v \\perp \\delta_t</span> , the image of x + V by the partial Sbox layer is a coset of V. It follows that  <span class="math">R_1(x+v) = R_1(x) + L(v)</span> . Similarly, for Round  <span class="math">i = 2, \\dots, r</span> , it holds that  <span class="math">R_i(x_i + L^{i-1}(v)) = R_i(x_i) + L^i(v)</span>  if  <span class="math">L^{i-1}(v) \\perp \\delta_t</span>  or equivalently  <span class="math">v \\perp (L^T)^{i-1}(\\delta_t)</span> .</p>

    <p class="text-gray-300">Let us consider any coordinate y of the output of the permutation after adding r additional (partial or full) rounds. When  <span class="math">z_0</span>  varies in V, these output words correspond to the images by the additional rounds of the elements  <span class="math">z_1</span>  in a coset of  <span class="math">W = L^t(V)</span> , which we denote by  <span class="math">\\gamma + W</span>  (see Figure 8). As the polynomial</p>

    <p class="text-gray-300">corresponding to the r additional rounds has degree at most  <span class="math">3^r</span> , it then follows using Corollary 1 that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z_0 \\in V} y(z_0) = \\sum_{z_1 \\in \\gamma + W} y(z_1) = \\sum_{x \\in \\mathbb{F}_q} P(x) = 0 ,</span>$</p>

    <p class="text-gray-300">as long as r is at most  <span class="math">\\lfloor \\log_3(q-2) \\rfloor</span> .</p>

    <p class="text-gray-300">Thus, in total this covers  <span class="math">(t-1) + \\lfloor \\log_3(q-2) \\rfloor</span>  rounds, starting after the first full rounds. For most sets of concrete parameters, this actually exceeds the recommended number of rounds in the forward direction for both Poseidon and Starkad. Furthermore, Lemma 1 implies that if the linear layer L has multiplicative order less than t-1, then the distinguisher covers an arbitrary number of partial rounds.</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 8: Zero-sum distinguisher against Poseidon and Starkad covering (2+4) full rounds and all partial rounds.</p>

    <p class="text-gray-300">Zero-sum distinguishers over  <span class="math">\\mathbb{F}_q</span> . By extending the above-mentioned approach in the backwards direction, we can construct a zero-sum distinguisher with a (slightly) extended number of rounds as depicted on Figure 8. The problem is that contrary to the case of GMIMC, the inverse round function in HADESMIMC is very different from the round function itself, and it has a much higher degree. Indeed, the inverse of the cube mapping over  <span class="math">\\mathbb{F}_q</span>  is the power function  <span class="math">x \\mapsto x^{(2q-1)/3}</span> . By using classical bounds on the degree, we cannot guarantee a degree lower than (q-2) for more than a single round backwards.</p>

    <p class="text-gray-300">However, V being one dimensional allows to overcome one additional layer of Sboxes, and thus one additional round. Namely, as V is a one-dimensional space there exists a vector  <span class="math">v=(v_1,\\ldots,v_t)\\in\\mathbb{F}_q^t</span>  such that</p>

    <p class="text-gray-300"><span class="math">$V = \\{(x v_1, x v_2, \\dots, x v_t) \\mid x \\in \\mathbb{F}_q\\}.</span>$</p>

    <p class="text-gray-300">The image of V under the inverse of the full Sbox layer consists of all the vectors in  <span class="math">\\mathbb{F}_q^t</span>  of the form</p>

    <p class="text-gray-300"><span class="math">$((x v_1)^{1/3}, \\dots, (x v_t)^{1/3}) = x^{1/3} (v_1^{1/3}, \\dots, v_t^{1/3}).</span>$</p>

    <p class="text-gray-300">As a consequence, this image is again a one-dimensional vector space having the same form, namely  <span class="math">U = \\{x&#x27;(u_1, \\ldots, u_t) \\mid x&#x27; \\in \\mathbb{F}_q\\}</span>  where  <span class="math">u_i = v_i^{1/3}</span>  for all  <span class="math">0 \\le i &lt; t</span> . It is worth noticing that this particular structure does not propagate over more rounds because of the addition of a round constant. Then, any coordinate at the input of the previous round y' is the image of an element  <span class="math">z&#x27;_0 = x&#x27;u</span>  in U by an affine layer, followed by the inverse of Sbox, i.e., by  <span class="math">x \\mapsto x^{1/3}</span>  (see Figure 8). We can then consider this mapping as a function of  <span class="math">x&#x27; \\in \\mathbb{F}_q</span> , and express it as a polynomial Q with coefficients in  <span class="math">\\mathbb{F}_q</span> . Since the degree of this polynomial is the degree of the inverse Sbox, it does not exceed (q-2). Using the notion from Figure 8, we then have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{z_0 \\in V} y&#x27;(z_0) = \\sum_{z_0&#x27; \\in U} y&#x27;(z_0&#x27;) = \\sum_{x&#x27; \\in \\mathbb{F}_q} Q(x) = 0.</span>$</p>

    <p class="text-gray-300">For most sets of proposed parameters, this provides a zero-sum distinguisher with data complexity q on HadesMIMC for all but the two initial rounds, i.e. for 2+4 full rounds (2 at the beginning and 4 at the end), and all partial rounds, as detailed in Table 4. Again, for instantiations of HadesMIMC with a linear layer of multiplicative order less than t-1, the distinguisher covers an arbitrary number of partial rounds.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Poseii</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">OON</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Starkad</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">security</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">t</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\log_2 q</span> proposed</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nb of rounds <span class="math">\\log_2 q</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">proposed</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">nb of rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">level</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R_f, R_P</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of the ZS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">R_f, R_P</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of the ZS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 77</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4,77</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4,85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">253</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 157</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 158</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">253</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 85</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 165</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">255</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 88</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 166</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256 bits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 82</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 86</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 81</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8, 83</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2+4, 87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Number of rounds of HadesMIMC covered by the zero-sum distinguisher of complexity q.</p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8">6.2 Finding preimages by linearization of the partial rounds</h3>

    <p class="text-gray-300">This section shows that, when the linear layer in HadesMiMC has a low multiplicative order, the propagation of linear subspaces through all partial rounds leads to a much more powerful attack. Indeed, we now show that the existence of perfect linear approximations over the partial rounds of HadesMiMC, as detailed in Lemma 2, can be used to setup a simplified system of equations for finding preimages, leading to a full-round preimage attack.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  denote a permutation obtained from  <span class="math">r \\geq 1</span>  partial HadesMiMC rounds instantiated with linear layer L and round constants  <span class="math">c_1, \\ldots, c_r</span> . Let  <span class="math">V \\subset \\mathbb{F}_q^t</span>  be the vector space  <span class="math">V = \\langle L(\\delta_t), L^2(\\delta_t), \\ldots, L^r(\\delta_t) \\rangle^{\\perp}</span> , where  <span class="math">\\delta_t = (0, \\ldots, 0, 1)</span> . Then, for all  <span class="math">x \\in \\mathbb{F}_q^t</span>  and  <span class="math">v \\in V</span> ,</p>

    <p class="text-gray-300"><span class="math">$v \\cdot F(x) = v \\cdot L^{r}(x) + \\sum_{i=1}^{r} v \\cdot L^{r+1-i}(c_i),</span>$</p>

    <p class="text-gray-300">where  <span class="math">u \\cdot v</span>  denotes the usual scalar product in  <span class="math">\\mathbb{F}_q^t</span> . Furthermore, if L has multiplicative order h, then dim  <span class="math">V \\geq t - \\min\\{h, r\\}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">F_r = R_r \\circ R_{r-1} \\circ \\cdots \\circ R_1</span> , where  <span class="math">R_i</span>  denotes the <em>i</em>th partial round of HADESMIMC, namely  <span class="math">R_i(x) = L \\circ S(x+c_i)</span> . We proceed by induction on r. For r=1, we have, for any v and x,</p>

    <p class="text-gray-300"><span class="math">$v \\cdot R_1(x) = L^T(v) \\cdot S(x + c_1) = L^T(v) \\cdot (x + c_1) = v \\cdot L(x) + v \\cdot L(c_1)</span>$</p>

    <p class="text-gray-300">if the last coordinate of  <span class="math">L^T(v)</span>  is zero, or equivalently  <span class="math">L^T(v) \\cdot \\delta_t = v \\cdot L(\\delta_t) = 0</span> . Let us now consider Round r and  <span class="math">v \\in \\langle L(\\delta_t), L^2(\\delta_t), \\dots, L^r(\\delta_t) \\rangle^{\\perp}</span> . For any  <span class="math">y \\in \\mathbb{F}_q^t</span> , we have</p>

    <p class="text-gray-300"><span class="math">$v \\cdot R_r(y) = L^T(v) \\cdot S(y + c_r) = L^T(v) \\cdot (y + c_r)</span>$</p>

    <p class="text-gray-300">since  <span class="math">L^T(v) \\cdot \\delta_t = v \\cdot L(\\delta_t) = 0</span> . Letting  <span class="math">y = F_{r-1}(x)</span> , it follows that</p>

    <p class="text-gray-300"><span class="math">$v \\cdot F_r(x) = L^T(v) \\cdot F_{r-1}(x) + L^T(v) \\cdot c_r = L^T(v) \\cdot L^{r-1}(x) + \\sum_{i=1}^{r-1} L^T(v) \\cdot L^{r-i}(c_i) + L^T(v) \\cdot c_r</span>$</p>

    <p class="text-gray-300">where the last equality is deduced from the induction hypothesis using that  <span class="math">L^T(v)</span>  belongs to  <span class="math">\\langle L(\\delta_t), \\ldots, L^{r-1}(\\delta_t) \\rangle^{\\perp}</span> . Finally, it is easy to see that the dimension of  <span class="math">V^{\\perp}</span>  can be upper bounded as  <span class="math">\\dim V^{\\perp} \\leq \\min\\{h, r, t\\}</span> . Hence,  <span class="math">\\dim V \\geq t - \\min\\{h, r\\}</span> .</p>

    <p class="text-gray-300">Suppose that L is such that the vector space V from Lemma 2 is of dimension d. It will be shown that, if d is sufficiently large, such an instantiation of HADESMIMC is vulnerable to preimage attacks for some choices of the rate and capacity parameters of the sponge construction. In particular, when the MDS matrix L is an involution, we obtain d=t-2.</p>

    <p class="text-gray-300">By Lemma 2, there exists a matrix  <span class="math">U_1 \\in \\mathbb{F}_q^{d \\times t}</span>  such that  <span class="math">U_1 F(x) = U_1(L^r(x) + a)</span>  for a known constant a. Indeed, let the rows of  <span class="math">U_1</span>  be a basis for V. Furthermore, let  <span class="math">U_2 \\in \\mathbb{F}_q^{(t-d) \\times t}</span>  be a matrix with row space complementary to the row space of  <span class="math">U_1</span> . For each x, it holds that</p>

    <p class="text-gray-300">
<span class="math">$U_1 y = U_1 (L^r(x) + \\sum_{i=1}^r L^{r+1-i}(c_i))</span>$</p>

    <p class="text-gray-300"><span class="math">$U_2 y = U_2 F(x).</span>$
(4)</p>

    <p class="text-gray-300">Consider a HADESMIMC permutation in a sponge construction with rate k and capacity c=t-k. Computing preimages of a one-block message  <span class="math">(y_1,\\ldots,y_k)\\in\\mathbb{F}_q^k</span></p>

    <p class="text-gray-300">then corresponds to solving the system of equations [F(xkIV)]<sup>i</sup> = y<sup>i</sup> , i = 1, . . . , k in the unknowns x1, . . . , xk.</p>

    <p class="text-gray-300">The idea of the attack is simple: for each guess of U2F(x) &isin; F t&minus;d q , replace the equations for the partial rounds by the affine relations <a href="#page-28-0">(4)</a> and solve the resulting system of equations. In order to ensure that the ideal generated by these equations is zero-dimensional, we should have k &le; d, which always holds when L is an involution unless c = 1. Note that we focus on the case where the number of output elements is equal to the rate. This is the most challenging setting. Indeed, if the output size is smaller than the rate &ndash; as in some of the StarkWare challenges &ndash; then the preimage problem will typically have many solutions. This allows the attacker to partially or completely avoid the guessing phase. If further degrees of freedom remain after fixing U2F(x) completely, one or more input elements may be fixed to an arbitrary value.</p>

    <p class="text-gray-300">In Appendix <a href="#page-37-1">D,</a> we show that the total time cost of the attack can be estimated as</p>

    <p class="text-gray-300"><span class="math">$2\\gamma (2\\pi)^{-\\omega/2} k^{2-\\omega/2} e^{\\omega k} 3^{(\\omega k+1)(R_F-1)} q^{t-d}</span>$</p>

    <p class="text-gray-300">where &omega; is the asymptotic exponent of the time complexity of matrix multiplication and &gamma; is such that the cost of computing the row-reduced echelon form of an m &times; n matrix is &gamma;mn<sup>&omega;</sup>.</p>

    <p class="text-gray-300">For example, for an involutive L, R<sup>F</sup> = 8 and an arbitrary number of partial rounds, Figure <a href="#page-30-0">9a</a> shows for which choices of q and t an improvement over the generic security of the sponge construction is obtained. The insecure instances are shaded in grey. Note that this domain corresponds to a conservative estimate for the cost of row-echelon reduction, i.e. &omega; = 3 and &gamma; = 3/2. The cost itself is shown in Figure <a href="#page-30-0">9b.</a> We stress that these figures correspond to the most challenging case, i.e. assuming that the hash output is of length k and no shorter.</p>

    <p class="text-gray-300">For the concrete Starkad and Poseidon instances specified in Table <a href="#page-5-0">2,</a> we obtain better-than-generic attacks on some variants assuming that the hash output has length c &le; k. Indeed, provided that c &le; d/2 = t/2 &minus; 1, a sufficiently large number of preimages is likely to exist so that it is no longer necessary to guess U2F(x). In addition, input variables may be fixed until only c + t &minus; d free variables remain. This leads to a computational cost of 2&gamma; (2&pi;) &minus;&omega;/2 (c+2)<sup>2</sup>&minus;&omega;/<sup>2</sup> e <sup>&omega;</sup>(c+2) 3 (&omega;(c+2)+1)(R<sup>F</sup> <sup>&minus;</sup>1). Note that, for these instances, we do not obtain relevant preimage attacks when the output size exceeds t/2&minus;1.</p>

    <p class="text-gray-300">    <img src="_page_30_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_30_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Minimum t such that the cost is better than generic for some choice of k.</li>
      <li>(b) Cost for different values of the rate k with t = 12 and &omega; = 3.</li>
    </ul>

    <p class="text-gray-300">Figure 9: Cost analysis of the preimage attack on HadesMiMC with an involutive linear layer and R<sup>F</sup> = 8. The shaded areas correspond to parameters for which the attack improves over the q min{k,c/2} security level.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Variant</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">c</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Computational cost</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&omega; &asymp; 2.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&omega; = 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128-e</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">114.9<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">122.3<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256-b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">221.1<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">235.7<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Overview of the computational cost (measured in F<sup>q</sup> operations) of the preimage attack on different instances of Poseidon and Starkad, assuming an involutive linear layer. These estimates assume that the hash output has length c. For the variants 128-a, 128-b, 128-c, 128-d and 256-a, the attack does not improve over the generic security level of the sponge.</p>

    <p class="text-gray-300">Our analysis of STARK-friendly primitives clearly shows that the concrete instances of GMiMC and HadesMiMC proposed in the StarkWare challenges present several major weaknesses, independently from the choice of the underlying finite field. At a first glance, the third contender involved in the challenges, namely Vision for the binary field and Rescue for the prime fields <a href="#page-32-2">[8]</a>, seems more resistant to the cryptanalytic techniques we have used against the other two primitives. This seems rather expected since Vision and Rescue follow a more classical SPN construction with full Sbox layers; for similar parameters, they include a larger number of Sboxes which may prevent them from the unsuitable behaviours we have exhibited on the other primitives.</p>

    <p class="text-gray-300">Another important aspect of our work is the extension of higher-order differential and integral attacks to primitives operating on any finite field, even with odd characteristic, while these attacks were previously defined over binary fields only. This points out that the notion of symmetric primitives over a prime field, which has been introduced very recently, needs to be further analyzed in order to get a rigorous assessment on its security. While decades of research have produced efficient cryptanalytic tools and security criteria for primitives defined over F2, establishing the right tools to analyze primitives over F<sup>q</sup> for odd q raises many new and interesting open questions.</p>

    <p class="text-gray-300"><em>Acknowledgements.</em> We thank Nathan Keller for pointing out an error in Section <a href="#page-27-0">6.2</a> of an earlier version of this paper. This research has received funding from StarkWare Industries and the Ethereum Foundation, as part of the process of selecting a STARK-friendly hash function. Tim Beyne is supported by a PhD Fellowship from the Research Foundation &ndash; Flanders (FWO). Itai Dinur is supported by the Israeli Science Foundation through grant no. 573/16. Part of this project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreements no. 714294 &quot;QUASYModo&quot;, no. 757731 &quot;LightCrypt&quot;, and no. 681402 &quot;SOPHIA&quot;). This work was partially supported by the German Federal Ministry of Education and Research (BMBF, project iBlockchain 16KIS0901K) and by DFG under Germanys Excellence Strategy &ndash; EXC 2092 CASA &ndash; 390781972.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. Abdelkhalek, A., Sasaki, Y., Todo, Y., Tolba, M., Youssef, A.M.: MILP modeling for (large) s-boxes to optimize probability of differential characteristics. IACR Transactions on Symmetric Cryptology 2017(4), 99&ndash;129 (2017)</p></li>
      <li><p class="text-gray-300">2. Agnesse, A., Pedicini, M.: Cube attack in finite fields of higher order. In: Boyd, C., Pieprzyk, J. (eds.) AISC 20111. CRPIT, vol. 116, pp. 9&ndash;14. Australian Computer Society (2011)</p></li>
      <li><p class="text-gray-300">3. Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., L&uuml;ftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of STARK-friendly designs: Application to MARVELlous and MiMC. In: Galbraith, S.D., Moriai, S. (eds.) ASI-ACRYPT 2019, Part III. LNCS, vol. 11923, pp. 371&ndash;397. Springer, Heidelberg (Dec 2019)</p></li>
      <li><p class="text-gray-300">4. Albrecht, M.R., Grassi, L., Perrin, L., Ramacher, S., Rechberger, C., Rotaru, D., Roy, A., Schofnegger, M.: Feistel structures for MPC, and more. In: Sako, K., Schneider, S., Ryan, P.Y.A. (eds.) ESORICS 2019, Part II. LNCS, vol. 11736, pp. 151&ndash;171. Springer, Heidelberg (Sep 2019)</p></li>
      <li><p class="text-gray-300">5. Albrecht, M.R., Grassi, L., Perrin, L., Ramacher, S., Rechberger, C., Rotaru, D., Roy, A., Schofnegger, M.: Feistel structures for MPC, and more. Cryptology ePrint Archive, Report 2019/397 (2019), <a href="https://eprint.iacr.org/2019/397" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/397</a></p></li>
      <li><p class="text-gray-300">6. Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: Cheon, J.H., Takagi, T. (eds.) ASIACRYPT 2016, Part I. LNCS, vol. 10031, pp. 191&ndash;219. Springer, Heidelberg (Dec 2016)</p></li>
      <li><p class="text-gray-300">7. Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for MPC and FHE. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015, Part I. LNCS, vol. 9056, pp. 430&ndash;454. Springer, Heidelberg (Apr 2015)</p></li>
      <li><p class="text-gray-300">8. Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. Cryptology ePrint Archive, Report 2019/426 (2019), <a href="https://eprint.iacr.org/2019/426" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/426</a></p></li>
      <li><p class="text-gray-300">9. Ashur, T., Dhooghe, S.: MARVELlous: a STARK-friendly family of cryptographic primitives. Cryptology ePrint Archive, Report 2018/1098 (2018), <a href="https://eprint.iacr.org/2018/1098" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2018/1098" target="_blank" rel="noopener noreferrer">iacr.org/2018/1098</a></p></li>
      <li><p class="text-gray-300">10. Aumasson, J.P., K&auml;sper, E., Knudsen, L.R., Matusiewicz, K., &Oslash;deg&aring;rd, R.S., Peyrin, T., Schl&auml;ffer, M.: Distinguishers for the compression function and output transformation of Hamsi-256. In: Steinfeld, R., Hawkes, P. (eds.) ACISP 10. LNCS, vol. 6168, pp. 87&ndash;103. Springer, Heidelberg (Jul 2010)</p></li>
      <li><p class="text-gray-300">11. Aumasson, J.P., Meier, W.: Zero-sum distinguishers for reduced Keccak-f and for the core functions of Luffa and Hamsi. Presented at the rump session of Cryptographic Hardware and Embedded Systems &ndash; CHES 2009 (2009), <a href="https://131002.net/data/papers/AM09.pdf" target="_blank" rel="noopener noreferrer">https:</a> <a href="https://131002.net/data/papers/AM09.pdf" target="_blank" rel="noopener noreferrer">//131002.net/data/papers/AM09.pdf</a></p></li>
      <li><p class="text-gray-300">12. Aumasson, J., Meier, W., Phan, R.C., Henzen, L.: The Hash Function BLAKE. Information Security and Cryptography, Springer (2014)</p></li>
      <li><p class="text-gray-300">13. Bar-On, A., Dinur, I., Dunkelman, O., Lallemand, V., Keller, N., Tsaban, B.: Cryptanalysis of SP networks with partial non-linear layers. In: Oswald, E., Fischlin, M. (eds.) EUROCRYPT 2015, Part I. LNCS, vol. 9056, pp. 315&ndash;342. Springer, Heidelberg (Apr 2015)</p></li>
      <li><p class="text-gray-300">14. Bardet, M., Faug&egrave;re, J.C., Salvy, B.: On the complexity of the F5 gr&ouml;bner basis algorithm. Journal of Symbolic Computation 70, 49&ndash;70 (2015)</p></li>
      <li><p class="text-gray-300">15. Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046 (2018), <a href="https://eprint.iacr.org/2018/046" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2018/046</a></p></li>
      <li><p class="text-gray-300">16. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Sponge functions. In: ECRYPT Hash Workshop (2007), <a href="https://keccak.team/files/SpongeFunctions.pdf" target="_blank" rel="noopener noreferrer">https://keccak.team/files/</a> <a href="https://keccak.team/files/SpongeFunctions.pdf" target="_blank" rel="noopener noreferrer">SpongeFunctions.pdf</a></p></li>
      <li><p class="text-gray-300">17. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: On the indifferentiability of the sponge construction. In: Smart, N.P. (ed.) EUROCRYPT 2008. LNCS, vol. 4965, pp. 181&ndash;197. Springer, Heidelberg (Apr 2008)</p></li>
      <li><p class="text-gray-300">18. Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Keccak sponge function family - main document. Submission to NIST (2009), <a href="https://keccak.team/obsolete/Keccak-main-2.0.pdf" target="_blank" rel="noopener noreferrer">https://keccak.team/</a> <a href="https://keccak.team/obsolete/Keccak-main-2.0.pdf" target="_blank" rel="noopener noreferrer">obsolete/Keccak-main-2.0.pdf</a></p></li>
      <li><p class="text-gray-300">19. Bonnetain, X.: Collisions on Feistel-MiMC and univariate GMiMC. Cryptology ePrint Archive, Report 2019/951 (2019), <a href="https://eprint.iacr.org/2019/951" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2019/951</a></p></li>
      <li><p class="text-gray-300">20. Boura, C., Canteaut, A., De Canni&egrave;re, C.: Higher-order differential properties of Keccak and Luffa. In: Joux, A. (ed.) FSE 2011. LNCS, vol. 6733, pp. 252&ndash;269. Springer, Heidelberg (Feb 2011)</p></li>
      <li><p class="text-gray-300">21. Canteaut, A., Carpov, S., Fontaine, C., Lepoint, T., Naya-Plasencia, M., Paillier, P., Sirdey, R.: Stream ciphers: A practical solution for efficient homomorphicciphertext compression. Journal of Cryptology 31(3), 885&ndash;916 (Jul 2018)</p></li>
      <li><p class="text-gray-300">22. Dinur, I., Liu, Y., Meier, W., Wang, Q.: Optimized interpolation attacks on LowMC. In: Iwata, T., Cheon, J.H. (eds.) ASIACRYPT 2015, Part II. LNCS, vol. 9453, pp. 535&ndash;560. Springer, Heidelberg (Nov / Dec 2015)</p></li>
      <li><p class="text-gray-300">23. Dobraunig, C., Eichlseder, M., Grassi, L., Lallemand, V., Leander, G., List, E., Mendel, F., Rechberger, C.: Rasta: A cipher with low ANDdepth and few ANDs</p></li>
      <li><p class="text-gray-300">per bit. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018, Part I. LNCS, vol. 10991, pp. 662&ndash;692. Springer, Heidelberg (Aug 2018)</p></li>
      <li><p class="text-gray-300">24. Dobraunig, C., Eichlseder, M., Mendel, F.: Higher-order cryptanalysis of LowMC. In: Kwon, S., Yun, A. (eds.) ICISC 15. LNCS, vol. 9558, pp. 87&ndash;101. Springer, Heidelberg (Nov 2016)</p></li>
      <li><p class="text-gray-300">25. Faug&egrave;re, J.C., Gianni, P., Lazard, D., Mora, T.: Efficient computation of zerodimensional Gr&ouml;bner bases by change of ordering. Journal of Symbolic Computation 16(4), 329&ndash;344 (1993)</p></li>
      <li><p class="text-gray-300">26. Faug&egrave;re, J.C., Mou, C.: Fast algorithm for change of ordering of zero-dimensional gr&ouml;bner bases with sparse multiplication matrices. In: Proceedings of the 36th international symposium on Symbolic and algebraic computation. pp. 115&ndash;122 (2011)</p></li>
      <li><p class="text-gray-300">27. Faug&egrave;re, J.C., Perret, L.: Algebraic attacks against STARK-Friendly Ciphers. Personal communication (2019)</p></li>
      <li><p class="text-gray-300">28. Grassi, L., Kales, D., Khovratovich, D., Roy, A., Rechberger, C., Schofnegger, M.: Starkad and Poseidon: New hash functions for zero knowledge proof systems. Cryptology ePrint Archive, Report 2019/458 (2019), <a href="https://eprint.iacr.org/2019/458" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2019/458" target="_blank" rel="noopener noreferrer">2019/458</a></p></li>
      <li><p class="text-gray-300">29. Grassi, L., L&uuml;ftenegger, R., Rechberger, C., Rotaru, D., Schofnegger, M.: On a generalization of substitution-permutation networks: The HADES design strategy. Cryptology ePrint Archive, Report 2019/1107 (2019), <a href="https://eprint.iacr.org/2019/1107" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2019/1107" target="_blank" rel="noopener noreferrer">2019/1107</a></p></li>
      <li><p class="text-gray-300">30. Katz, J.: Secure computation: When theory meets... Invited talk at CRYPTO 2019 (2019)</p></li>
      <li><p class="text-gray-300">31. Kedlaya, K.S., Umans, C.: Fast modular composition in any characteristic. In: 49th FOCS. pp. 146&ndash;155. IEEE Computer Society Press (Oct 2008)</p></li>
      <li><p class="text-gray-300">32. Knudsen, L.R., Rijmen, V.: Known-key distinguishers for some block ciphers. In: Kurosawa, K. (ed.) ASIACRYPT 2007. LNCS, vol. 4833, pp. 315&ndash;324. Springer, Heidelberg (Dec 2007)</p></li>
      <li><p class="text-gray-300">33. Knudsen, L.R., Wagner, D.: Integral cryptanalysis. In: Daemen, J., Rijmen, V. (eds.) FSE 2002. LNCS, vol. 2365, pp. 112&ndash;127. Springer, Heidelberg (Feb 2002)</p></li>
      <li><p class="text-gray-300">34. Lai, X.: Higher order derivatives and differential cryptanalysis. In: Proc. &quot;Symposium on Communication, Coding and Cryptography&quot;, in honor of J. L. Massey on the occasion of his 60th birthday. Kluwer Academic Publishers (1994)</p></li>
      <li><p class="text-gray-300">35. Macaulay, F.S.: Some formulae in elimination. Proceedings of the London Mathematical Society 1(1), 3&ndash;27 (1902)</p></li>
      <li><p class="text-gray-300">36. M&eacute;aux, P., Journault, A., Standaert, F.X., Carlet, C.: Towards stream ciphers for efficient FHE with low-noise ciphertexts. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016, Part I. LNCS, vol. 9665, pp. 311&ndash;343. Springer, Heidelberg (May 2016)</p></li>
      <li><p class="text-gray-300">37. Mouha, N., Wang, Q., Gu, D., Preneel, B.: Differential and linear cryptanalysis using mixed-integer linear programming. In: Wu, C., Yung, M., Lin, D. (eds.) Information Security and Cryptology - Inscrypt 2011. LNCS, vol. 7537, pp. 57&ndash;76. Springer (2011)</p></li>
      <li><p class="text-gray-300">38. Rechberger, C., Soleimany, H., Tiessen, T.: Cryptanalysis of low-data instances of full LowMCv2. IACR Trans. Symm. Cryptol. 2018(3), 163&ndash;181 (2018)</p></li>
      <li><p class="text-gray-300">39. Sajadieh, M., Dakhilalian, M., Mala, H., Omoomi, B.: On construction of involutory MDS matrices from Vandermonde matrices in GF(2<sup>q</sup> ). Designs, Codes and Cryptography 64(3), 287&ndash;308 (Sep 2012)</p></li>
      <li><p class="text-gray-300">40. S&#259;l&#259;gean, A., Winter, R., Mandache-S&#259;l&#259;gean, M., Phan, R.C.W.: Higher order differentiation over finite fields with applications to generalising the cube attack. Designs, Codes and Cryptography 84(3), 425&ndash;449 (2017)</p></li>
      <li><p class="text-gray-300">41. StarkWare Industries: Personal communication (2019)</p></li>
      <li><p class="text-gray-300">42. Stevens, M., Bursztein, E., Karpman, P., Albertini, A., Markov, Y.: The first collision for full SHA-1. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017, Part I. LNCS, vol. 10401, pp. 570&ndash;596. Springer, Heidelberg (Aug 2017)</p></li>
      <li><p class="text-gray-300">43. Youssef, A., Mister, S., Tavares, S.: On the design of linear transformations for substitution permutation encryption networks. In: Workshop on Selected Areas of Cryptography (SAC96). pp. 40&ndash;48 (1997)</p></li>
    </ul>

    <p class="text-gray-300">This section contains the technical details related to the impossible differential attack on GMiMC from Section <a href="#page-15-2">5.1.</a></p>

    <p class="text-gray-300">Table <a href="#page-35-1">6</a> shows the differential propagation in the middle t &minus; 2 rounds for t = 12. It is valid only when the linear system of equations <a href="#page-35-2">(5)</a> has a nontrivial solution.</p>

    <p class="text-gray-300">Table 6: Middle t&minus;2 rounds of the new impossible differentials for 3t&minus;4 rounds (t = 12). The first and last 11 rounds are trivial, thus omitted. The notation '&alpha;ijk&middot;&middot;&middot;' denotes &alpha;<sup>i</sup> + &alpha;<sup>j</sup> + &alpha;<sup>k</sup> + &middot; &middot; &middot; . '&beta;ijk&middot;&middot;&middot;' is similarly defined, but because it is for the inverse direction, the sign of the term b<sup>i</sup> is plus for i = 1 and minus for other i. For example, &beta;<sup>13456</sup> denotes +&beta;<sup>1</sup> &minus; &beta;<sup>3</sup> &minus; &beta;<sup>4</sup> &minus; &beta;<sup>5</sup> &minus; &beta;6.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">r</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S3</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S4</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S5</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S6</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S7</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S9</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S10</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S11</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&#8710;S12</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;134</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15 &alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;1345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;245</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;234</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 &alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;13456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2356</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2346</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&alpha;2345</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16 &beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2346</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2356</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;13456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23456</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;235</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;245</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;1345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2345</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;134</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;234</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;23</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&beta;1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">
<span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = \\beta_{1} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{1} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{5} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{6} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\alpha_{2} + \\alpha_{3} + \\alpha_{4} + \\alpha_{5} = -\\beta_{2} - \\beta_{3} - \\beta_{4} - \\beta_{5} - \\beta_{6}</span>$</p>

    <p class="text-gray-300">From the 1st and 2nd equations, we get &beta;<sup>5</sup> = &beta;5. Similarly, from the 2nd and 3rd, 3rd and 4th, and 5th and 6th equations, we get &beta;<sup>4</sup> = &beta;5, &beta;<sup>3</sup> = &beta;4, and &beta;<sup>1</sup> = &minus;&beta;2, respectively. From the 4th and 5th equations, we get &beta;<sup>1</sup> + &beta;<sup>2</sup> &minus; &beta;<sup>3</sup> = 0, which implies &beta;<sup>3</sup> = 0. Similarly, we obtain &alpha;<sup>5</sup> = &alpha;6, &alpha;<sup>4</sup> = &alpha;5, &alpha;<sup>3</sup> = &alpha;4, &alpha;<sup>1</sup> = &alpha;2, &alpha;<sup>1</sup> &minus; &alpha;<sup>2</sup> + &alpha;<sup>3</sup> = 0 by comparing two of the last 6 equations. Finally, by injecting those to the fifth equation, we get &alpha;<sup>1</sup> = &beta;1, hence the differential is impossible when &alpha;<sup>1</sup> 6= &beta;1.</p>

    <p class="text-gray-300">To determine whether further improvements are possible compared to the differential characteristics we proposed in Section <a href="#page-15-1">5.2,</a> we have searched for other differential characteristics with a Mixed-Integer Linear Programming (MILP) model. Note that our model only lower-bounds the probability of a fixed differential as done for the previously described characteristics and does not take the details of the initial structure or truncation of the output difference into account.</p>

    <p class="text-gray-300">Previously proposed models for differential characteristics usually represent either each state word <a href="#page-33-12">[37]</a> or each bit <a href="#page-31-5">[1]</a> with a binary decision variable. Neither is well-suited for GMiMC over prime fields: with a word-wise model, we cannot identify whether two differences are identical and will thus find many invalid characteristics; with a bit-wise model, the model would be unpractically large due to the large state size and number of rounds. We thus model each state word with an integer variable x &isin; [&minus;<code>, </code>], and addition modulo q simply as x + y = z. The variable x in this relation does not define the value of the difference (except for x = 0), but only captures properties such as equality and additive relations. The bound <code> limits the number of distinct difference values that can be modelled and also defines the helper constant M = 2</code>.</p>

    <p class="text-gray-300">If x and y are the input and output of an S-box, we only require that x = 0 &hArr; y = 0. One direction x = 0 &rArr; y = 0 of this implication can be encoded using binary helper variables &pi;<sup>i</sup> :</p>

    <p class="text-gray-300"><span class="math">$1 - \\pi_1 M \\le x \\le -1 + \\pi_2 M</span>$
,  <span class="math">0 - \\pi_3 M \\le y \\le 0 + \\pi_4 M</span> ,  <span class="math">\\sum_{i=1}^4 \\pi_i \\le 2</span> .</p>

    <p class="text-gray-300">Each Sbox is associated with a cost c &isin; {0, 1} (x 6= 0 &rArr; c = 1) as well as a gain g &isin; {0, 1}, where g = 1 means the output difference y 6= 0 is arbitrary and thus the transition does not reduce the success probability. We identify these cases by requiring that |y| is larger than any possible sum of defined differences z, bounded by 2 z (with helper variable gz), including the permutation's input, output, and S-box outputs in the previous r rounds:</p>

    <p class="text-gray-300"><span class="math">$-cM \\le x \\le cM, \\ y \\ge 2z - (1-g_z)M, \\ y \\ge -2z - (1-g_z)M, \\ \\sum_z g_z \\ge g(2t+r).</span>$</p>

    <p class="text-gray-300">Finally, we require nontriviality, with helper variables &pi;x, &pi;<sup>0</sup> x for each input x:</p>

    <p class="text-gray-300"><span class="math">$1 - \\pi_x M \\le x \\le -1 + \\pi&#x27;_x M,</span>$
<span class="math">\\sum_x \\pi_x + \\pi&#x27;_x \\le 2t - 1.</span></p>

    <p class="text-gray-300">The minimization objective is the sum of the cost minus the gain of each Sbox. This corresponds to &minus; log<sup>q</sup> P, where P is the approximate probability of the differential with fixed input and output difference.</p>

    <p class="text-gray-300">The structured characteristics we describe above yield a cost of k+1 when the number of rounds is between kt-1 and (k+1)t-2. We used the MILP model to look at all possible characteristics for up to 3t rounds. The obtained bounds match our solutions except for kt-1 and kt rounds, where a small and general modification improves the cost to k instead of k+1. We conclude that the previously described characteristic is essentially optimal with respect to the defined search space.</p>

    <p class="text-gray-300">The linear layers of STARKAD and POSEIDON are chosen such that  <span class="math">L_{i,j} = 1/(x_i + x_j + a)</span>  where  <span class="math">x_1, \\ldots, x_t</span>  are distinct elements of  <span class="math">\\mathbb{F}_q</span>  [28]. The following result shows that, for STARKAD instances with t a power of two, there exist weak choices of  <span class="math">x_1, \\ldots, x_t</span>  that enable the preimage attack from Section 6.2.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let  <span class="math">G = \\{x_1, \\ldots, x_t\\}</span>  be an additive subgroup of  <span class="math">\\mathbb{F}_{2^n}</span>  of order t and let  <span class="math">a \\in \\mathbb{F}_{2^n} \\setminus G</span> . For the Cauchy matrix  <span class="math">L \\in \\mathbb{F}_{2^n}^{t \\times t}</span>  defined by  <span class="math">L_{i,j} = 1/(x_i + x_j + a)</span> , it holds that  <span class="math">L^2 = b^2 I</span>  with  <span class="math">b = \\sum_{i=1}^t 1/(x_i + a)</span> .</p>

    <p class="text-gray-300">Proof. Observe that</p>

    <p class="text-gray-300"><span class="math">$(L^2)_{i,j} = \\sum_{k=1}^t \\frac{1}{x_i + x_k + a} \\times \\frac{1}{x_j + x_k + a} = \\sum_{x \\in a + G} \\frac{1}{x(x + x_i + x_j)}.</span>$</p>

    <p class="text-gray-300">For i = j, the result is clear. It suffices to prove that  <span class="math">(L^2)_{i,j} = 0</span>  for  <span class="math">i \\neq j</span> . Since  <span class="math">x_i \\neq x_j</span>  for  <span class="math">i \\neq j</span> , we have  <span class="math">g = x_i + x_j \\in G \\setminus \\{0\\}</span> . Finally, it holds that</p>

    <p class="text-gray-300"><span class="math">$(L^2)_{i,j} = \\sum_{x \\in a+G} \\frac{1}{x(x+g)} = \\frac{1}{g} \\sum_{x \\in a+G} \\left(\\frac{1}{x} + \\frac{1}{x+g}\\right) = 0.</span>$</p>

    <p class="text-gray-300">A special case of Theorem 1 is discussed by Youssef <em>et al.</em> [43, &sect;3.2]. For an extension  <span class="math">\\mathbb{F}_2(\\zeta) \\supset \\mathbb{F}_2</span>  of degree n, they show that the choice  <span class="math">x_i = \\sum_{j=1}^{\\log_2 t} \\mathsf{d}_j \\zeta^{j-1}</span>  with  <span class="math">\\mathsf{d}_1, \\ldots, \\mathsf{d}_{\\log_2 t}</span>  the binary digits of i-1 results in a Cauchy matrix L such that  <span class="math">L^2 = b^2 I</span>  for some  <span class="math">b \\in \\mathbb{F}_2(\\zeta)</span> .</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Cost of the preimage attack from Section 6.2</h2>

    <p class="text-gray-300">This section provides the details of the computational cost analysis of the preimage attack on HadesMiMC from Section 6.2. In addition, the set of vulnerable parameters is determined.</p>

    <p class="text-gray-300">Recall that the cost of solving the system of equations using Gr&ouml;bner basis techniques is dominated by two steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Computing a Gr&ouml;bner basis with respect to a total degree term order such as the degree reverse lexicographic (degrevlex) order. For standard reduction algorithms such as Faug&egrave;re's F4 and F5, the time required for this step can be upper bounded by [14]</li>
    </ol>

    <p class="text-gray-300"><span class="math">$T_{\\mathrm{gb}} = \\mathcal{O}\\left( \\begin{pmatrix} D+k \\\\ D \\end{pmatrix}^{\\omega} \\right),</span>$</p>

    <p class="text-gray-300">for k variables and with D an upper bound on the degree of the Gr&ouml;bner basis elements. Here,  <span class="math">\\omega</span>  is the asymptotic exponent of the time complexity of matrix multiplication.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Converting the degrevlex Gr&ouml;bner basis to a Gr&ouml;bner basis with respect to a lexicographic order. For the FGLM algorithm, the cost of this step can be estimated as [25]</li>
    </ol>

    <p class="text-gray-300"><span class="math">$T_{\\text{fglm}} = \\mathcal{O}(k \\dim(\\mathbb{F}_q[x_1, \\dots, x_k]/\\mathcal{I})^{\\omega}),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathcal{I}</span>  is the ideal corresponding the equations.</p>

    <p class="text-gray-300">The time required to factor the univariate polynomials in the lexicographic Gr&ouml;bner basis can be assumed to be negligible. Hence, the time cost of the attack is dominated by  <span class="math">q^{t-d}</span>  ( <span class="math">T_{\\rm gb} + T_{\\rm fglm}</span> ).</p>

    <p class="text-gray-300">To set up a system of preimage equations for HadesMimC, two diametrical approaches may be considered. In the first strategy, one attempts to minimize the number of variables by setting up a system of high-degree polynomials relating the input and output of the permutation. In the second approach, intermediate variables are introduced at every round, leading to a system of many low-degree equations. The latter strategy is usually preferred, as it leads to a lower degree D. However, a routine calculation shows that reducing the number of variables is more important for the present attack. Hence, we opt for the former approach.</p>

    <p class="text-gray-300">Clearly, the Sbox layer of the first round may be ignored in the analysis. Furthermore, since the HadesMiMC design strategy states that the last linear layer can be omitted, the last round could also be ignored. Nevertheless, this is not the case for Starkad and Poseidon, so we do not take this into account in the analysis in Appendix D.</p>

    <p class="text-gray-300">For each guess of  <span class="math">U_2F(x)</span> , the outputs  <span class="math">y_1, \\ldots y_k</span>  may be expressed directly as a polynomial in the input (after the first Sbox layer) of degree  <span class="math">3^{R_F-1}</span> . In general, bounding D is highly nontrivial. However, for regular systems, Macaulay's bound [14,35] yields</p>

    <p class="text-gray-300"><span class="math">$D \\le (3^{R_F - 1} - 1)k + 1.</span>$</p>

    <p class="text-gray-300">Furthermore, small-scale experiments suggest that this bound is tight for this particular system of equations. It is hard to obtain theoretical estimates of  <span class="math">\\dim(\\mathbb{F}_q[x_1,\\ldots,x_k]/\\mathcal{I})</span> , but small-scale experiments suggest that it scales as  <span class="math">\\sim 3^{k(R_F-1)}</span> , which is consistent with recent results obtained by Faug&egrave;re and Perret [27]. Since the FGLM algorithm is able to exploit sparse linear algebra methods [26], it is reasonable to assume that  <span class="math">T_{\\text{fglm}} \\lesssim T_{\\text{gb}}</span> .</p>

    <p class="text-gray-300">Suppose that 3 <sup>R</sup><sup>F</sup> <sup>&minus;</sup><sup>1</sup> k. Following the reasoning in <a href="#page-32-16">[14,</a> &sect;1.3], it holds that</p>

    <p class="text-gray-300"><span class="math">$T_{\\mathrm{gb}} \\leq \\gamma \\, k \\, (D - 3^{R_F - 1} + 1) \\, \\binom{k + D - 1}{D}^{\\omega} \\lessapprox \\gamma \\, k^2 \\, 3^{R_F - 1} \\, \\binom{k + D - 1}{D}^{\\omega}.</span>$</p>

    <p class="text-gray-300">In the above, the parameters &gamma; and &omega; are such that the computational cost of computing the row-reduced echelon form of an m &times; n matrix is &gamma;mn<sup>&omega;</sup>. Stirling's approximation yields the estimate</p>

    <p class="text-gray-300"><span class="math">$\\log \\binom{k+D-1}{D} = \\log \\binom{k3^{R_F-1}}{k} \\approx k + k(R_F-1)\\log 3 - \\log \\sqrt{2\\pi k}.</span>$</p>

    <p class="text-gray-300">It follows that</p>

    <p class="text-gray-300"><span class="math">$T_{\\rm gb} \\lesssim \\gamma (2\\pi)^{-\\omega/2} k^{2-\\omega/2} e^{\\omega k} 3^{(\\omega k+1)(R_F-1)},</span>$</p>

    <p class="text-gray-300">assuming that computing the reduced row-echelon form of an m&times;n matrix takes time &gamma;mn<sup>&omega;</sup>. As discussed above, the total computational cost of the attack is then at most</p>

    <p class="text-gray-300">
<span class="math">$2\\gamma (2\\pi)^{-\\omega/2} k^{2-\\omega/2} e^{\\omega k} 3^{(\\omega k+1)(R_F-1)} q^{t-d}.</span>$
(6)</p>

    <p class="text-gray-300">Suppose that 2&gamma;(2&pi;) <sup>&minus;</sup>&omega;/2k <sup>2</sup>&minus;&omega;/<sup>2</sup> &lt; 3C for some absolute constant C. For the total cost <a href="#page-39-0">(6)</a> to be below the security level q min{k,c/2} , it suffices that</p>

    <p class="text-gray-300"><span class="math">$\\log_3 C + R_F + \\omega k (\\log_3 e + R_F - 1) + (t - d) \\log_3 q \\le \\min\\{k, c/2\\} \\log_3 q.</span>$</p>

    <p class="text-gray-300">Assuming q &ge; 3 &omega;R<sup>F</sup> we deduce the following lower bound for k:</p>

    <p class="text-gray-300"><span class="math">$k \\ge \\frac{(t-d)\\log_3 q + R_F + \\log_3 C}{\\log_3 q - \\omega (R_F + \\log_3 e - 1)}.</span>$</p>

    <p class="text-gray-300">Since c = t &minus; k we also obtain</p>

    <p class="text-gray-300"><span class="math">$\\log_3 C + R_F + k[\\omega(\\log_3 e + R_F - 1) + (\\log_3 q)/2] \\le (d - t/2)\\log_3 q.</span>$</p>

    <p class="text-gray-300">From this, we deduce the upper bound</p>

    <p class="text-gray-300"><span class="math">$k \\le \\frac{(d - t/2)\\log_3 q - R_F - \\log_3 C}{1/2\\log_3 q + \\omega(R_F + \\log_3 e - 1)}.</span>$</p>

    <p class="text-gray-300">We conclude that the preimage attack improves over the q min{c/2,k} security level whenever</p>

    <p class="text-gray-300"><span class="math">$\\frac{(t-d)\\log_3 q + R_F + \\log_3 C}{\\log_3 q - \\omega \\left(R_F + \\log_3 e - 1\\right)} \\le k \\le \\frac{(d-t/2)\\log_3 q - R_F - \\log_3 C}{1/2\\log_3 q + \\omega (R_F + \\log_3 e - 1)},</span>$</p>

    <p class="text-gray-300">where C is a constant close to one. If k &le; 20, one can take C = 3.</p>

    </section>
`;
---

<BaseLayout title="Out of Oddity -- New Cryptanalytic Techniques against Symmet... (2020/188)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/188
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">STARK-friendly primitives</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Expected security level</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Concrete instances</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Specifications of GMiMC</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Specifications of HadesMiMC</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Integral attacks over fields of any characteristic</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Integral distinguishers on the full GMiMC</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Integral distinguisher on GMiMC</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Zero-sum distinguishers on the full permutation</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Exploiting integral distinguishers over multiplicative subgroups</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Differential attacks on round-reduced GMiMC</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Impossible differential attacks</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">A differential distinguisher</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Algebraically controlled differential attacks</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Reduced-round collision attacks</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-6" class="hover:text-white">Attacks on HadesMiMC</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Integral distinguishers</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Finding preimages by linearization of the partial rounds</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Conclusions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Impossible differential attack on GMiMC</a></li>
        <li><a href="#app-b" class="hover:text-white">Optimality of the differential characteristics for GMiMC</a></li>
        <li><a href="#app-c" class="hover:text-white">Weak Cauchy matrices</a></li>
        <li><a href="#app-d" class="hover:text-white">Cost of the preimage attack from Section 6.2</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="out-of-oddity-new-cryptanalytic-techniques-against-2020" />
  </article>
</BaseLayout>
