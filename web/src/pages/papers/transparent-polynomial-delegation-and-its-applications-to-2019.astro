---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1482';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Transparent Polynomial Delegation and Its Applications to Zero Knowledge Proof';
const AUTHORS_HTML = 'Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, Dawn Song';

const CONTENT = `    <p class="text-gray-300">Jiaheng Zhang^{†} Tiancheng Xie^{†} Yupeng Zhang^{‡} Dawn Song^{†}</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We present a new succinct zero knowledge argument scheme for layered arithmetic circuits without trusted setup. The prover time is <span class="math">O(C+n\\log n)</span> and the proof size is <span class="math">O(D\\log C+\\log^{2}n)</span> for a <span class="math">D</span>-depth circuit with <span class="math">n</span> inputs and <span class="math">C</span> gates. The verification time is also succinct, <span class="math">O(D\\log C+\\log^{2}n)</span>, if the circuit is structured. Our scheme only uses lightweight cryptographic primitives such as collision-resistant hash functions and is plausibly post-quantum secure. We implement a zero knowledge argument system, Virgo, based on our new scheme and compare its performance to existing schemes. Experiments show that it only takes 53 seconds to generate a proof for a circuit computing a Merkle tree with 256 leaves, at least an order of magnitude faster than all other succinct zero knowledge argument schemes. The verification time is 50ms, and the proof size is 253KB, both competitive to existing systems.</p>

    <p class="text-gray-300">Underlying Virgo is a new transparent zero knowledge verifiable polynomial delegation scheme with logarithmic proof size and verification time. The scheme is in the interactive oracle proof model and may be of independent interest.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Zero knowledge proof (ZKP) allows a powerful prover to convince a weak verifier that a statement is true, without leaking any extra information about the statement beyond its validity. In recent years, significant progress has been made to bring ZKP protocols from purely theoretical interest to practical implementations, leading to its numerous applications in delegation of computations, anonymous credentials, privacy-preserving cryptocurrencies and smart contracts.</p>

    <p class="text-gray-300">Despite of these great success, there are still some limitations of existing ZKP systems. In SNARK <em>[60]</em>, the most commonly adopted ZKP protocol in practice, though the proof sizes are of just hundreds of bytes and the verification times are of several milliseconds regardless of the size of the statements, it requires a trusted setup phase to generate structured reference string (SRS) and the security will be broken if the trapdoor is leaked.</p>

    <p class="text-gray-300">To address this problem, many ZKP protocols based on different techniques have been proposed recently to remove the trusted setup, which are referred as <em>transparent</em> ZKP protocols. Among these techniques, ZKP schemes based on the doubly efficient interactive proof proposed by Goldwasser et al. in <em>[42]</em> (referred as <em>GKR</em> protocol in this paper) are particularly interesting due to their efficient prover time and sublinear verification time for statements represented as structured arithmetic</p>

    <p class="text-gray-300">circuits, making it promising to scale to large statements. Unfortunately, as of today we are yet to construct an efficient transparent ZKP system based on the GKR protocol with succinct proof size and verification time. The transparent scheme in <em>[69]</em> has square-root proof size and verification time, while the succinct scheme in <em>[70]</em> requires a one-time trusted setup. See Section 1.2 for more details.</p>

    <p class="text-gray-300">Our contributions. In this paper, we advance this line of research by proposing a transparent ZKP protocol based on GKR with succinct proof size and verification time, when the arithmetic circuit representing the statement is structured. The prover time of our scheme is particularly efficient, at least an order of magnitude faster than existing ZKP systems, and the verification time is merely tens of milliseconds. Our concrete contributions are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Transparent zero knowledge verifiable polynomial delegation. We propose a new zero knowledge verifiable polynomial delegation (zkVPD) scheme without trusted setup. Compared to existing pairing-based zkVPD schemes <em>[59, 72, 73]</em>, our new scheme does not require a trap-door and linear-size public keys, and eliminates heavy cryptographic operations such as modular exponentiation and bilinear pairing. Our scheme may be of independent interest, as polynomial delegation/commitment has various applications in areas such as verifiable secret sharing <em>[6]</em>, proof of retrievability <em>[71]</em> and other constructions of ZKP <em>[55]</em>.</li>

      <li>Transparent zero knowledge argument. Following the framework proposed in <em>[73]</em>, we combine our new zkVPD protocol with the GKR protocol efficiently to get a transparent ZKP scheme. Our scheme only uses light-weight cryptographic primitives such as collision-resistant hash functions and is plausibly post-quantum secure.</li>

      <li>Implementation and evaluation. We implement a ZKP system, Virgo, based on our new scheme. We develop optimizations such that our system can take arithmetic circuits on the field generated by Mersenne primes, the operations on which can be implemented efficiently using integer additions, multiplications and bit operations in C++. We plan to open source our system.</li>

    </ul>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Techniques</h3>

    <p class="text-gray-300">Our main technical contribution in this paper is a new transparent zkVPD scheme with <span class="math">O(N\\log N)</span> prover time, <span class="math">O(\\log^{2}N)</span> proof size and verification time, where <span class="math">N</span> is the size of the polynomial. We summarize the key ideas behind our construction. We first model the polynomial evaluation as the inner product between two vectors of size <span class="math">N</span>: one defined by the coefficients of the polynomial and the other defined by the evaluation point computed on each monomial of the polynomial. The former is committed by the prover (or delegated to the prover after preprocessing in the case of delegation of computation), and the later is publicly known to both the verifier and the prover. We then develop a protocol that allows the prover to convince the verifier the correctness of the inner product between a committed vector and a public vector with proof size <span class="math">O(\\log^{2}N)</span>, based on the univariate sumcheck protocol recently proposed by Ben-Sasson et al. in <em>[14]</em> (See Section 2.4). To ensure security, the verifier needs to access the two vectors at some locations randomly chosen by the verifier during the protocol. For the first vector, the prover opens it at these locations using standard commitment schemes such as Merkle hash tree. For the second vector, however,</p>

    <p class="text-gray-300">takes <span class="math">O(N)</span> time for the verifier to compute its values at these locations locally. In order to improve the verification time, we observe that the second vector is defined by the evaluation point of size only <span class="math">\\ell</span> for a <span class="math">\\ell</span>-variate polynomial, which is <span class="math">O(\\log N)</span> if the polynomial is dense. Therefore, this computation can be viewed as a function that takes <span class="math">\\ell</span> inputs, expands them to a vector of <span class="math">N</span> monomials and outputs some locations of the vector. It is a perfect case for the verifier to use the GKR protocol to delegate the computation to the prover and validate the output, instead of computing locally. With proper design of the GKR protocol, the verification time is reduced to <span class="math">O(\\log^{2}N)</span> and the total prover time is <span class="math">O(N\\log N)</span>. We then turn the basic protocol into zero knowledge using similar techniques proposed in <em>[5, 14]</em>. The detailed protocols are presented in Section 3.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">Zero knowledge proof. Zero knowledge proof was introduced by Goldwasser et al. in <em>[43]</em> and generic constructions based on probabilistically checkable proofs (PCPs) were proposed in the seminal work of Kilian <em>[51]</em> and Micali <em>[58]</em> in the early days. In recent years there has been significant progress in efficient ZKP protocols and systems. Following earlier work of Ishai <em>[48]</em>, Groth <em>[45]</em> and Lipmaa <em>[53]</em>, Gennaro et al. <em>[40]</em> introduced quadratic arithmetic programs (QAPs), which leads to efficient implementations of SNARKs <em>[12, 17, 24, 35, 38, 60, 68]</em>. The proof size and verification time of SNARK are constant, which is particularly useful for real-world applications such as cryptocurrencies <em>[11]</em> and smart contract <em>[23, 52]</em>. However, SNARKs require a per-statement trusted setup, and incurs a high overhead in the prover running time and memory consumption, making it hard to scale to large statements. There has been great research for generating the SRS through multi-parity secure computations <em>[13]</em> and making the SRS universal and updatable <em>[46, 55]</em>.</p>

    <p class="text-gray-300">Many recent works attempt to remove the trusted setup and construct transparent ZKP schemes. Based on “(MPC)-in-the-head” introduced in <em>[31, 41, 49]</em>, Ames et al. <em>[5]</em> proposed a ZKP scheme called Ligero. It only uses symmetric key operations and the prover time is fast in practice, but the proof size is <span class="math">O(\\sqrt{C})</span> and the verification time is quasi-linear to the size of the circuit. Later, it is categorized as interactive oracle proofs (IOPs), and in the same model Ben-Sasson et al. built Stark <em>[9]</em>, transparent ZKP in the RAM model of computation. Their verification time is only linear to the description of the RAM program, and succinct (logarithmic) in the time required for program execution. Recently, Ben-Sasson et al. <em>[14]</em> proposed Aurora, a new ZKP system in the IOP model with the proof size of <span class="math">O(\\log^{2}C)</span>. Our new zkVPD and ZKP schemes fall in the IOP model.</p>

    <p class="text-gray-300">In the seminal work of <em>[42]</em>, Goldwasser et al. proposed an efficient interactive proof for layered arithmetic circuits, which was extended to an arugment system by Zhang et al. in <em>[74]</em> using a protocol for verifiable polynomial delegation. Later, Zhang et al. <em>[75]</em>, Wahby et al. <em>[69]</em> and Xie et al. <em>[70]</em> made the argument system zero knowledge by Cramer and Damgard transformation <em>[36]</em> and random masking polynomials <em>[32]</em>. The scheme of <em>[69]</em>, Hyrax, is transparent, yet the proof size and verification time are <span class="math">O(\\sqrt{n})</span> where <span class="math">n</span> is the input size of the circuit; the schemes of <em>[72]</em> and <em>[70]</em> are succinct for structured circuits, but require one-time trusted setup. The prover time of the GKR protocol is substantially improved in <em>[34, 64, 67, 69, 75]</em>, and recently Xie et al. <em>[70]</em> proposed a variant with <span class="math">O(C)</span> prover time for arbitrary circuits.</p>

    <p class="text-gray-300">Other transparent ZKP schemes based on different techniques include discrete-log-based schemes <em>[8, 21, 28, 44]</em>, hash-based schemes <em>[22]</em> and lattice-based schemes <em>[7]</em>. See Section 5.3 for detailed asymptotic complexity and practical performance of state-of-the-art systems with implementations.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Verifiable polynomial delegation. Verifiable polynomial delegation (VPD) allows a verifier to delegate the computation of polynomial evaluations to a powerful prover, and validates the result in time that is constant or logarithmic to the size of the polynomial. Earlier works in the literature include <em>[18, 39, 50]</em>. Based on <em>[50]</em>, Papamanthou et al. <em>[59]</em> propose a protocol for multivariate polynomials. Later in <em>[73]</em>, Zhang et al. extend the scheme to an argument of knowledge using powers of exponent assumptions, allowing a prover to commit to a multivariate polynomial, and open to evaluations at points queried by the verifier. In <em>[72]</em>, Zhang et al. further make the scheme zero knowledge. These schemes are based on bilinear maps and require a trusted setup phase that generates linear-size public keys with a trapdoor.</p>

    <p class="text-gray-300">In a concurrent work, Bünz et al. <em>[26]</em> propose another transparent polynomial commitment scheme without trusted setup. The scheme utilizes groups of unknown order and the techniques are different from our construction. The prover and verifier time are <span class="math">O(N)</span> and <span class="math">O(\\log N)</span> modulo exponentiation in the group and the proof size is <span class="math">O(\\log N)</span> group elements. Concretely, the proof size is 10-20KB for a circuit with <span class="math">2^{20}</span> gates when compiled to different ZKP systems <em>[26, Section 6]</em>, and the prover time and the verification time are not reported. Comparing to our scheme, we expect the prover and verifier time in our scheme are faster, while our proof size is larger, which gives an interesting trade-off.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">We use <span class="math">\\lambda</span> to denote the security parameter, and <span class="math">\\mathsf{negl}(\\lambda)</span> to denote the negligible function in <span class="math">\\lambda</span>. “PPT” stands for probabilistic polynomial time. For a multivariate polynomial <span class="math">f</span>, its ”variable-degree” is the maximum degree of <span class="math">f</span> in any of its variables. We often rely on polynomial arithmetic, which can be efficiently performed via fast Fourier tranforms and their inverses. In particular, polynomial evaluation and interpolation over a multiplicative coset of size <span class="math">n</span> of a finite field can be performed in <span class="math">O(n\\log n)</span> field operations via the standard FFT protocol, which is based on the divide-and-conquer algorthim.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Interactive Proofs and Zero-knowledge Arguments</h3>

    <p class="text-gray-300">Interactive proofs. An interactive proof allows a prover <span class="math">\\mathcal{P}</span> to convince a verifier <span class="math">\\mathcal{V}</span> the validity of some statement through several rounds of interaction. We say that an interactive proof is public coin if <span class="math">\\mathcal{V}</span>’s challenge in each round is independent of <span class="math">\\mathcal{P}</span>’s messages in previous rounds. The proof system is interesting when the running time of <span class="math">\\mathcal{V}</span> is less than the time of directly computing the function <span class="math">f</span>. We formalize interactive proofs in the following:</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Let <span class="math">f</span> be a Boolean function. A pair of interactive machines <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> is an interactive proof for <span class="math">f</span> with soundness <span class="math">\\epsilon</span> if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every <span class="math">x</span> such that <span class="math">f(x)=1</span> it holds that <span class="math">\\Pr[\\langle\\mathcal{P},\\mathcal{V}\\rangle(x)=\\mathtt{1}]=1</span>.</li>

      <li><span class="math">\\epsilon</span>-Soundness. For any <span class="math">x</span> with <span class="math">f(x)\\neq 1</span> and any <span class="math">\\mathcal{P}^{<em>}</span> it holds that <span class="math">\\Pr[\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle=\\mathtt{1}]\\leq\\epsilon</span></li>

    </ul>

    <p class="text-gray-300">Zero-knowledge arguments. An argument system for an NP relationship <span class="math">\\mathcal{R}</span> is a protocol between a computationally-bounded prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>. At the end of the protocol, <span class="math">\\mathcal{V}</span> is convinced by <span class="math">\\mathcal{P}</span> that there exists a witness <span class="math">w</span> such that <span class="math">(x;w)\\in R</span> for some input <span class="math">x</span>. We focus on arguments of knowledge which have the stronger property that if the prover convinces the verifier</p>

    <p class="text-gray-300">of the statement validity, then the prover must know <span class="math">w</span>. We use <span class="math">\\mathcal{G}</span> to represent the generation phase of the public parameters <span class="math">\\mathsf{pp}</span>. Formally, consider the definition below, where we assume <span class="math">R</span> is known to <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be an NP relation. A tuple of algorithm <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a zero-knowledge argument of knowledge for <span class="math">\\mathcal{R}</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness. For every <span class="math">\\mathsf{pp}</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span> and <span class="math">(x,w)\\in R</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle\\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}(\\mathsf{pp})\\rangle(x)=\\mathtt{1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For any PPT prover <span class="math">\\mathcal{P}</span>, there exists a PPT extractor <span class="math">\\varepsilon</span> such that for every <span class="math">\\mathsf{pp}</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span> and any <span class="math">x</span>, the following probability is <span class="math">\\mathsf{negl}(\\lambda)</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\langle\\mathcal{P}(\\mathsf{pp}),\\mathcal{V}(\\mathsf{pp})\\rangle(x)=\\mathtt{1}\\wedge(x,w)\\notin\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w\\leftarrow\\varepsilon(\\mathsf{pp},x)]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero knowledge. There exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for any PPT algorithm <span class="math">\\mathcal{V}^{<em>}</span>, auxiliary input <span class="math">z\\in\\{0,1\\}^{</em>}</span>, <span class="math">(x;w)\\in\\mathcal{R}</span>, <span class="math">\\mathsf{pp}</span> output by <span class="math">\\mathcal{G}(1^{\\lambda})</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{View}(\\langle\\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}^{<em>}(z,\\mathsf{pp})\\rangle(x))\\approx\\mathcal{S}^{\\mathcal{V}^{</em>}}(x,z)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is a succinct argument system if the running time of <span class="math">\\mathcal{V}</span> and the total communication between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> (proof size) are $\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the definition of zero knowledge, <span class="math">\\mathcal{S}^{\\mathcal{V}^{<em>}}</span> denotes that the simulator <span class="math">\\mathcal{S}</span> is given the randomness of <span class="math">\\mathcal{V}^{</em>}</span> sampled from polynomial-size space. This definition is commonly used in existing transparent zero knowledge proof schemes <em>[5, 14, 28, 69]</em>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Zero-Knowledge Verifiable Polynomial Delegation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">\\mathcal{F}</span> be a family of <span class="math">\\ell</span>-variate polynomial over <span class="math">\\mathbb{F}</span>, and <span class="math">d</span> be a variable-degree parameter. We use <span class="math">\\mathcal{W}_{\\ell,d}</span> to denote the collection of all monomials in <span class="math">\\mathcal{F}</span> and $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}_{\\ell,d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(d+1)^{\\ell}<span class="math">. A zero-knowledge verifiable polynomial delegation scheme (zkVPD) for </span>f\\in\\mathcal{F}<span class="math"> and </span>t\\in\\mathbb{F}^{\\ell}$ consists of the following algorithms:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span>,</li>

      <li><span class="math">\\mathsf{com}\\leftarrow\\mathsf{zkVPD.Commit}(f,r_{f},\\mathsf{pp})</span>,</li>

      <li><span class="math">((y,\\pi);\\{0,1\\})\\leftarrow\\langle\\mathsf{zkVPD.Open}(f,r_{f}),\\mathsf{zkVPD.Verify}(\\mathsf{com})\\rangle(t,\\mathsf{pp})</span></li>

    </ul>

    <p class="text-gray-300">Note that unlike the zkVPD in <em>[59, 72, 73]</em>, our definition is transparent and does not have a trapdoor in <span class="math">\\mathsf{zkVPD.KeyGen}</span>. <span class="math">\\pi</span> denotes the transcript seen by the verifier during the interaction with <span class="math">\\mathsf{zkVPD.Open}</span>, which is similar to the proof in non-interactive schemes in <em>[59, 72, 73]</em>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300">A zkVPD scheme satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any polynomial <span class="math">f\\in\\mathcal{F}</span> and value <span class="math">t\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span>, <span class="math">\\mathsf{com}\\leftarrow\\mathsf{zkVPD.Commit}(f,r_{f}\\mathsf{pp})</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathsf{zkVPD.Open}(f,r_{f}),\\mathsf{zkVPD.Verify}(\\mathsf{com})\\rangle(t,\\mathsf{pp})=\\mathtt{1}\\right]=1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For any PPT adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{pp} \\gets \\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span> , the following probability is negligible of  <span class="math">\\lambda</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l} (f ^ {*}, \\mathsf {c o m} ^ {*}, t) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\mathsf {p p}) \\\\ ((y ^ {*}, \\pi^ {*}); 1) \\leftarrow \\langle \\mathcal {A} (), \\mathsf {z k V P D . V e r i f y} (\\mathsf {c o m} ^ {*}) \\rangle (t, \\mathsf {p p}) \\\\ \\mathsf {c o m} ^ {*} = \\mathsf {z k V P D . C o m m i t} (f ^ {*}, \\mathsf {p p}) \\\\ f ^ {*} (t) \\neq y ^ {*} \\end{array} \\right]</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero Knowledge. For security parameter  <span class="math">\\lambda</span> , polynomial  <span class="math">f \\in \\mathcal{F}</span> ,  <span class="math">\\mathsf{pp} \\gets \\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span> , PPT algorithm  <span class="math">\\mathcal{A}</span> , and simulator  <span class="math">\\mathcal{S} = (\\mathcal{S}_1, \\mathcal{S}_2)</span> , consider the following two experiments:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RealA,f(pp):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IdealA,SA(pp):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1. com ← zkVPD.Commit(f,rf,pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">1. com ← S1(1λ,pp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2. t ← A(com,pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">2. t ← A(com,pp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. (y,π) ← ⟨zkVPD.Open(f,rf),A⟩(t,pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">3. (y,π) ← ⟨S2,A⟩(ti,pp), given oracle access to y = f(t).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. b ← A(com,y,π,pp)</td>

            <td class="px-3 py-2 border-b border-gray-700">4. b ← A(com,y,π,pp)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. Output b</td>

            <td class="px-3 py-2 border-b border-gray-700">5. Output b</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any PPT algorithm  <span class="math">\\mathcal{A}</span>  and all polynomial  <span class="math">f\\in \\mathbb{F}</span> , there exists simulator  <span class="math">\\mathcal{S}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\operatorname {R e a l} _ {\\mathcal {A}, f} (\\mathrm {p p}) = 1 ] - \\Pr [ \\operatorname {I d e a l} _ {\\mathcal {A}, \\mathcal {S} ^ {\\mathcal {A}}} (\\mathrm {p p}) = 1 ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In [70], Xie et al. proposed an efficient zero knowledge argument scheme named Libra. The scheme extends the interactive proof protocol for layered arithmetic circuits proposed by Goldwasser et al. [42] (referred as the  <span class="math">GKR</span>  protocol) to a zero knowledge argument using multiple instances of zkVPD schemes. Our scheme follows this framework and we review the detailed protocols here.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sumcheck protocol. The sumcheck protocol is a fundamental protocol in the literature of interactive proof that has various applications. The problem is to sum a polynomial  <span class="math">f: \\mathbb{F}^{\\ell} \\to \\mathbb{F}</span>  on the binary hypercube  <span class="math">\\sum_{b_1, b_2, \\ldots, b_\\ell \\in \\{0, 1\\}} f(b_1, b_2, \\ldots, b_\\ell)</span> . Directly computing the sum requires exponential time in  <span class="math">\\ell</span> , as there are  <span class="math">2^\\ell</span>  combinations of  <span class="math">b_1, \\ldots, b_\\ell</span> . Lund et al. [54] proposed a sumcheck protocol that allows a verifier  <span class="math">\\mathcal{V}</span>  to delegate the computation to a computationally unbounded prover  <span class="math">\\mathcal{P}</span> , who can convince  <span class="math">\\mathcal{V}</span>  the correctness of the sum. At the end of the sumcheck protocol,  <span class="math">\\mathcal{V}</span>  needs an oracle access to the evaluation of  <span class="math">f</span>  at a random point  <span class="math">r \\in \\mathbb{F}^\\ell</span>  chosen by  <span class="math">\\mathcal{V}</span> . The proof size of the sumcheck protocol is  <span class="math">O(d\\ell)</span> , where  <span class="math">d</span>  is the variable-degree of  <span class="math">f</span> , and the verification time of the protocol is  <span class="math">O(d\\ell)</span> . The sumcheck protocol is complete and sound with  $\\epsilon = \\frac{d\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">GKR protocol. Let  <span class="math">C</span>  be a layered arithmetic circuit with depth  <span class="math">D</span>  over a finite field  <span class="math">\\mathbb{F}</span> . Each gate in the  <span class="math">i</span> -th layer takes inputs from two gates in the  <span class="math">(i + 1)</span> -th layer; layer 0 is the output layer and layer  <span class="math">D</span>  is the input layer. The GKR protocol proceeds layer by layer. Upon receiving the claimed output from  <span class="math">\\mathcal{P}</span> , in the first round,  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  run a sumcheck protocol to reduce the claim about the output to a claim about the values in the layer above. In the  <span class="math">i</span> -th round, both parties reduce a claim about layer  <span class="math">i - 1</span>  to a claim about layer  <span class="math">i</span>  through sumcheck. Finally, the protocol terminates with a claim about the input layer  <span class="math">D</span> , which can be checked directly by  <span class="math">\\mathcal{V}</span> . If the check passes,  <span class="math">\\mathcal{V}</span>  accepts the claimed output.</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">Formally speaking, we denote the number of gates in the <span class="math">i</span>-th layer as <span class="math">S_{i}</span> and let <span class="math">s_i = \\lceil \\log S_i \\rceil</span>. We then define a function <span class="math">V_{i}:\\{0,1\\}^{s_{i}}\\to \\mathbb{F}</span> that takes a binary string <span class="math">b\\in \\{0,1\\}^{s_i}</span> and returns the output of gate <span class="math">b</span> in layer <span class="math">i</span>, where <span class="math">b</span> is called the gate label. With this definition, <span class="math">V_{0}</span> corresponds to the output of the circuit, and <span class="math">V_{D}</span> corresponds to the input. As the sumcheck protocol works on <span class="math">\\mathbb{F}</span>, we then extend <span class="math">V_{i}</span> to its multilinear extension, the unique polynomial <span class="math">\\tilde{V}_i:\\mathbb{F}^{s_i}\\to \\mathbb{F}</span> such that <span class="math">\\tilde{V}_i(x_1,x_2,\\dots,x_{s_i}) = V_i(x_1,x_2,\\dots,x_{s_i})</span> for all <span class="math">x_{1},x_{2},\\ldots ,x_{s_{i}}\\in \\{0,1\\}^{s_{i}}</span>. As shown in prior work [34], the closed form of <span class="math">\\tilde{V}_i</span> can be computed as:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {V} _ {i} \\left(x _ {1}, x _ {2}, \\dots , x _ {s _ {i}}\\right) = \\sum_ {b \\in \\{0, 1 \\} ^ {s _ {i}}} \\prod_ {i = 1} ^ {s _ {i}} \\left[ \\left((1 - x _ {i}) (1 - b _ {i}) + x _ {i} b _ {i}\\right) \\cdot V _ {i} (b) \\right], \\tag {1}</span></div>

    <p class="text-gray-300">where <span class="math">b_{i}</span> is <span class="math">i</span>-th bit of <span class="math">\\mathbf{b}</span>.</p>

    <p class="text-gray-300">With these definitions, we can express the evaluations of <span class="math">\\tilde{V}_i</span> as a summation of evaluations of <span class="math">\\tilde{V}_{i+1}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_ {i} \\tilde {V} _ {i} \\left(u ^ {(i)}\\right) + \\beta_ {i} \\tilde {V} _ {i} \\left(v ^ {(i)}\\right) = \\sum_ {x, y \\in \\{0, 1 \\} ^ {s _ {i + 1}}} f _ {i} \\left(\\tilde {V} _ {i + 1} (x), \\tilde {V} _ {i + 1} (y)\\right), \\tag {2}</span></div>

    <p class="text-gray-300">where <span class="math">u^{(i)}, v^{(i)} \\in \\mathbb{F}^{s_i}</span> are random vectors and <span class="math">\\alpha_i, \\beta_i \\in \\mathbb{F}</span> are random values. Note here that <span class="math">f_i</span> depends on <span class="math">\\alpha_i, \\beta_i, u^{(i)}, v^{(i)}</span> and we omit the subscripts for easy interpretation.</p>

    <p class="text-gray-300">With Equation 2, the GKR protocol proceeds as follows. The prover <span class="math">\\mathcal{P}</span> first sends the claimed output of the circuit to <span class="math">\\mathcal{V}</span>. From the claimed output, <span class="math">\\mathcal{V}</span> defines polynomial <span class="math">\\tilde{V}_0</span> and computes <span class="math">\\tilde{V}_0(u^{(0)})</span> and <span class="math">\\tilde{V}_0(v^{(0)})</span> for random <span class="math">u^{(0)}, v^{(0)} \\in \\mathbb{F}^{s_0}</span>. <span class="math">\\mathcal{V}</span> then picks two random values <span class="math">\\alpha_0, \\beta_0</span> and invokes a sumcheck protocol on Equation 2 with <span class="math">\\mathcal{P}</span> for <span class="math">i = 0</span>. As described before, at the end of the sumcheck, <span class="math">\\mathcal{V}</span> needs an oracle access to the evaluation of <span class="math">f_0</span> at <span class="math">u^{(1)}, v^{(1)}</span> randomly selected in <span class="math">\\mathbb{F}^{s_1}</span>. To compute this value, <span class="math">\\mathcal{V}</span> asks <span class="math">\\mathcal{P}</span> to send <span class="math">\\tilde{V}_1(u^{(1)})</span> and <span class="math">\\tilde{V}_1(v^{(1)})</span>. Other than these two values, <span class="math">f_0</span> only depends on <span class="math">\\alpha_0, \\beta_0, u^{(0)}, v^{(0)}</span> and the gates and wiring in layer 0, which are all known to <span class="math">\\mathcal{V}</span> and can be computed by <span class="math">\\mathcal{V}</span> directly. In this way, <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> reduces two evaluations of <span class="math">\\tilde{V}_0</span> to two evaluations of <span class="math">\\tilde{V}_1</span> in layer 1. <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> then repeat the protocol recursively layer by layer. Eventually, <span class="math">\\mathcal{V}</span> receives two claimed evaluations <span class="math">\\tilde{V}_D(u^{(D)})</span> and <span class="math">\\tilde{V}_D(v^{(D)})</span>. <span class="math">\\mathcal{V}</span> then checks the correctness of these two claims directly by evaluating <span class="math">\\tilde{V}_D</span>, which is defined by the input of the circuit. Let <span class="math">\\mathsf{GKR}.\\mathcal{P}</span> and <span class="math">\\mathsf{GKR}.\\mathcal{V}</span> be the algorithms for the GKR prover and verifier, we have the following theorem:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1.</strong> [34, 42, 64, 70]. Let <span class="math">C: \\mathbb{F}^n \\to \\mathbb{F}</span> be a layered arithmetic circuit with depth of <span class="math">D</span>. <span class="math">\\langle \\mathsf{GKR}. \\mathcal{P}, \\mathsf{GKR}. \\mathcal{V} \\rangle(C, x)</span> is an interactive proof per Definition 1 for the function computed by <span class="math">C</span> on input <span class="math">x</span> with soundness $O(D \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The total communication is </span>O(D \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the running time of the prover </span>\\mathcal{P}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. When </span>C<span class="math"> has regular wiring pattern², the running time of the verifier </span>\\mathcal{V}<span class="math"> is </span>O(n + D \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Extending GKR to Zero Knowledge Argument.</strong> There are two limitations of the GKR protocol: (1) It is not an argument system supporting witness from <span class="math">\\mathcal{P}</span>, as <span class="math">\\mathcal{V}</span> needs to evaluate <span class="math">\\tilde{V}_D</span> locally in the last round; (2) It is not zero knowledge, as in each round, both the sumcheck protocol and the two evaluations of <span class="math">\\tilde{V}_i</span> leak information about the values in layer <span class="math">i</span>.</p>

    <p class="text-gray-300">To extend the GKR protocol to a zero knowledge argument, Xie et al. [70] address both of the problems using zero knowledge polynomial delegation. Following the approach of [69, 72, 73], to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">²“Regular” circuits is defined in [34, Theorem A.1]. Roughly speaking, it means the mutilinear extension of its wiring predicates can be evaluated at a random point in time $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol 1 (Zero Knowledge Argument in <em>[70]</em>). Let <span class="math">\\lambda</span> be the security parameter, <span class="math">\\mathbb{F}</span> be a prime field. Let <span class="math">C:\\mathbb{F}^{n}\\to\\mathbb{F}</span> be a layered arithmetic circuit over <span class="math">\\mathbb{F}</span> with <span class="math">D</span> layers, input <span class="math">\\mathsf{in}</span> and witness <span class="math">w</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n<span class="math"> and </span>1=C(\\mathsf{in};w)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})</span>: set <span class="math">\\mathsf{pp}</span> as <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span>.</li>

      <li><span class="math">\\langle\\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}(\\mathsf{pp})\\rangle(\\mathsf{in})</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> selects a random bivariate polynomial <span class="math">R_{D}</span>. <span class="math">\\mathcal{P}</span> commits to the witness of <span class="math">C</span> by sending <span class="math">\\mathsf{com}_{D}\\leftarrow\\mathsf{zkVPD.Commit}(\\dot{V}_{D},r_{V_{D}},\\mathsf{pp})</span> to <span class="math">\\mathcal{V}</span>, where <span class="math">\\dot{V}_{D}</span> is defined by Equation 3.</li>

      <li><span class="math">\\mathcal{P}</span> randomly selects polynomials <span class="math">R_{i}:\\mathbb{F}^{2}\\to\\mathbb{F}</span> and <span class="math">\\delta_{i}:\\mathbb{F}^{2s_{i+1}+1}\\to\\mathbb{F}</span> for <span class="math">i=0,\\ldots,D-1</span>. <span class="math">\\mathcal{P}</span> commits to these polynomials by sending <span class="math">\\mathsf{com}_{i,1}\\leftarrow\\mathsf{zkVPD.Commit}(R_{i},r_{R_{i}},\\mathsf{pp})</span> and <span class="math">\\mathsf{com}_{i,2}\\leftarrow\\mathsf{zkVPD.Commit}(\\delta_{i},r_{\\delta_{i}},\\mathsf{pp})</span> to <span class="math">\\mathcal{V}</span>. <span class="math">\\mathcal{P}</span> also reveals <span class="math">R_{0}</span> to <span class="math">\\mathcal{V}</span>, as <span class="math">V_{0}</span> is known to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> evaluates <span class="math">\\dot{V}_{0}(u^{(0)})</span> and <span class="math">\\dot{V}_{0}(v^{(0)})</span> for randomly chosen <span class="math">u^{(0)},v^{(0)}\\in\\mathbb{F}^{s_{0}}</span>.</li>

      <li>For <span class="math">i=0,\\ldots,D-1</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> sends <span class="math">H_{i}=\\sum_{x,y\\in\\{0,1\\}^{s_{i+1}},z\\in\\{0,1\\}}\\delta_{i}(x,y,z)</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> picks <span class="math">\\alpha_{i},\\beta_{i},\\gamma_{i}</span> randomly in <span class="math">\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> execute a sumcheck protocol on Equation 4. At the end of the sumcheck, <span class="math">\\mathcal{V}</span> receives a claim of <span class="math">f_{i}^{\\prime}</span> at point <span class="math">u^{(i+1)},v^{(i+1)}\\in\\mathbb{F}^{s_{i+1}},g_{i}\\in\\mathbb{F}</span> selected randomly by <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{P}</span> opens <span class="math">R_{i}(u^{(i)},g_{i})</span>, <span class="math">R_{i}(v^{(i)},g_{i})</span> and <span class="math">\\delta_{i}(u^{(i+1)},v^{(i+1)},g_{i})</span> using <span class="math">\\mathsf{zkVPD.Open}</span>. <span class="math">\\mathcal{P}</span> sends <span class="math">\\dot{V}_{0}(u^{(i+1)})</span> and <span class="math">\\dot{V}_{0}(v^{(i+1)})</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> validates <span class="math">R_{i}(u^{(i)},g_{i})</span>, <span class="math">R_{i}(v^{(i)},g_{i})</span> and <span class="math">\\delta_{i}(u^{(i+1)},v^{(i+1)},g_{i})</span> using <span class="math">\\mathsf{zkVPD.Verify}</span>. If any of them outputs 0, abort and output 0.</li>

      <li><span class="math">\\mathcal{P}</span> checks the claim of <span class="math">f_{i}^{\\prime}</span> using <span class="math">R_{i}(u^{(i)},g_{i})</span>, <span class="math">R_{i}(v^{(i)},g_{i})</span>, <span class="math">\\delta_{i}(u^{(i+1)},v^{(i+1)},g_{i})</span>, <span class="math">\\dot{V}_{0}(u^{(i+1)})</span> and <span class="math">\\dot{V}_{0}(v^{(i+1)})</span>. If it fails, output 0.</li>

      <li><span class="math">\\mathcal{P}</span> runs <span class="math">(y_{1},\\pi_{1})\\leftarrow\\mathsf{zkVPD.Open}(\\dot{V}_{D},r_{V_{D}},u^{(D)},\\mathsf{pp})</span>, <span class="math">(y_{2},\\pi_{2})\\leftarrow\\mathsf{zkVPD.Open}(\\dot{V}_{D},r_{V_{D}},v^{(D)},\\mathsf{pp})</span> and sends <span class="math">y_{1},\\pi_{1},y_{2},\\pi_{2}</span> to <span class="math">\\mathcal{V}</span>.</li>

      <li><span class="math">\\mathcal{V}</span> runs <span class="math">\\mathsf{Verify}(\\pi_{1},y_{1},\\mathsf{com}_{D},u^{(D)},\\mathsf{pp})</span> and <span class="math">\\mathsf{Verify}(\\pi_{2},y_{2},\\mathsf{com}_{D},v^{(D)},\\mathsf{pp})</span> and output 0 if either check fails. Otherwise, <span class="math">\\mathcal{V}</span> checks <span class="math">\\dot{V}_{D}(u^{(D)})=y_{1}</span> and <span class="math">\\dot{V}_{D}(v^{(D)})=y_{2}</span>, and rejects if either fails. If all checks above pass, <span class="math">\\mathcal{V}</span> output 1.</li>

    </ol>

    <p class="text-gray-300">support witness <span class="math">w</span> as the input to the circuit, <span class="math">\\mathcal{P}</span> commits to <span class="math">\\tilde{V}_{D}</span> using zkVPD before running the GKR protocol. In the last round of GKR, instead of evaluating <span class="math">\\tilde{V}_{D}</span> locally, <span class="math">\\mathcal{V}</span> asks <span class="math">\\mathcal{P}</span> to open <span class="math">\\tilde{V}_{D}</span> at two random points <span class="math">u^{(D)},v^{(D)}</span> selected by <span class="math">\\mathcal{V}</span> and validates them using zkVPD.Verify. In this way, <span class="math">\\mathcal{V}</span> does not need to access <span class="math">w</span> directly and the soundness still holds because of the soundness guarantee of zkVPD.</p>

    <p class="text-gray-300">To ensure zero knowledge, using the techniques proposed by Chiesa et al. in <em>[32]</em>, the prover <span class="math">\\mathcal{P}</span> masks the polynomial <span class="math">\\tilde{V}_{i}</span> and the sumcheck protocol by random polynomials so that the proof does not leak information. For correctness and soundness purposes, these random polynomials are committed using the zkVPD protocol and opened at random points chosen by <span class="math">\\mathcal{V}</span>. In particular, for layer <span class="math">i</span>, the prover selects a random bivariate polynomial <span class="math">R_{i}(x_{1},z)</span> and defines</p>

    <p class="text-gray-300"><span class="math">\\dot{V}_{i}(x_{1},\\ldots,x_{s_{i}})\\stackrel{{\\scriptstyle def}}{{=}}\\tilde{V}_{i}(x_{1},\\ldots,x_{s_{i}})+Z_{i}(x_{1},\\ldots,x_{s_{i}})\\sum_{z\\in\\{0,1\\}}R_{i}(x_{1},z),</span> (3)</p>

    <p class="text-gray-300">where <span class="math">Z_{i}(x)=\\prod_{i=1}^{s_{i}}x_{i}(1-x_{i})</span>, i.e., <span class="math">Z_{i}(x)=0</span> for all <span class="math">x\\in\\{0,1\\}^{s_{i}}</span>. <span class="math">\\dot{V}_{i}</span> is known as the <em>low degree extension</em> of <span class="math">V_{i}</span>, as <span class="math">\\dot{V}_{i}(x)=\\dot{V}_{i}(x)=V_{i}(x)</span> for all <span class="math">x\\in\\{0,1\\}^{s_{i}}</span>. As <span class="math">R_{i}</span> is randomly selected by</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>, revealing evaluations of <span class="math">\\dot{V}_i</span> does not leak information about <span class="math">V_i</span>, thus the values in the circuit. Additionally, <span class="math">\\mathcal{P}</span> selects another random polynomial <span class="math">\\delta_i(x_1,\\ldots,x_{s_{i+1}},y_1,\\ldots,y_{s_{i+1}},z)</span> to mask the sumcheck protocol. Let <span class="math">H_i = \\sum_{x,y\\in \\{0,1\\}^{s_{i+1}},z\\in \\{0,1\\}}\\delta_i(x_1,\\ldots,x_{s_{i+1}},y_1,\\ldots,y_{s_{i+1}},z)</span>, Equation 2 to run sumcheck on becomes</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\alpha_i \\dot{V}_i(u^{(i)}) + \\beta_i \\dot{V}_i(v^{(i)}) + \\gamma_i H_i \\\\ = \\sum_{x,y \\in \\{0,1\\}^{s_{i+1}}, z \\in \\{0,1\\}} f_i&#x27;(\\dot{V}_{i+1}(x), \\dot{V}_{i+1}(y), R_i(u_1^{(i)}, z), R_i(v_1^{(i)}, z), \\delta_i(x, y, z)), \\end{array} \\tag{4}</span></div>

    <p class="text-gray-300">where <span class="math">\\gamma_i \\in \\mathbb{F}</span> is randomly selected by <span class="math">\\mathcal{V}</span>, and <span class="math">f_i&#x27;</span> is defined by <span class="math">\\alpha_i, \\beta_i, \\gamma_i, u^{(i)}, v^{(i)}, Z_i(u^{(i)}), Z_i(v^{(i)})</span>. Now <span class="math">\\mathcal{V}</span> and <span class="math">\\mathcal{P}</span> can execute the sumcheck and GKR protocol on Equation 4. In each round, <span class="math">\\mathcal{P}</span> additionally opens <span class="math">R_i</span> and <span class="math">\\delta_i</span> at <span class="math">R_i(u_1^{(i)}, g^{(i)}), R_i(v_1^{(i)}, g^{(i)}), \\delta_i(u^{(i+1)}, v^{(i+1)}, g^{(i)})</span> for <span class="math">g^{(i)} \\in \\mathbb{F}</span> randomly selected by <span class="math">\\mathcal{V}</span>. With these values, <span class="math">\\mathcal{V}</span> reduces the correctness of two evaluations <span class="math">\\dot{V}_i(u^{(i)}), \\dot{V}_i(v^{(i)})</span> to two evaluations <span class="math">\\dot{V}_i(u^{(i+1)}), \\dot{V}_i(v^{(i+1)})</span> on one layer above like before. In addition, as <span class="math">f_i</span> is masked by <span class="math">\\delta_i</span>, the sumcheck protocol is zero knowledge; as <span class="math">\\tilde{V}_i</span> is masked by <span class="math">R_i</span>, the two evaluations of <span class="math">\\dot{V}_i</span> do not leak information. The full zero knowledge argument protocol in [70] is given in Protocol 1. We have the following theorem:</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> [70]. Let <span class="math">C: \\mathbb{F}^n \\to \\mathbb{F}</span> be a layered arithmetic circuit with <span class="math">D</span> layers, input <span class="math">\\mathfrak{in}</span> and witness <span class="math">w</span>. Protocol 1 is a zero knowledge argument of knowledge under Definition 2 for the relation defined by <span class="math">1 = C(\\mathfrak{in}; w)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The variable degree of <span class="math">R_i</span> is <span class="math">O(1)</span>. <span class="math">\\delta_i(x,y,z) = \\delta_{i,1}(x_1) + \\ldots + \\delta_{i,s_{i+1}}(x_{s_{i+1}}) + \\delta_{i,s_{i+1}+1}(y_1) + \\ldots + \\delta_{i,2s_{i+1}}(y_{s_{i+1}}) + \\delta_{i,2s_{i+1}+1}(z)</span> is the summation of <span class="math">2s_{i+1} + 1</span> univariate polynomials of degree <span class="math">O(1)</span>. Other than the zkVPD instantiations, the proof size is $O(D\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the prover time is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. When </span>C<span class="math"> is regular, the verification time is </span>O(n + D\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-13" class="text-2xl font-bold">2.4 Univariate Sumcheck</h2>

    <p class="text-gray-300">Our transparent zkVPD protocol is inspired by the univariate sumcheck protocol recently proposed by Ben-Sasson et al. in [14]. As the name indicates, the univariate sumcheck protocol allows the verifier to validate the result of the sum of a univariate polynomial on a subset <span class="math">\\mathbb{H}</span> of the field <span class="math">\\mathbb{F}</span>: <span class="math">\\mu = \\sum_{a\\in \\mathbb{H}}f(a)</span>. The key idea of the protocol relies on the following lemma:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 3.</strong> [27]. Let <span class="math">\\mathbb{H}</span> be a multiplicative coset of <span class="math">\\mathbb{F}</span>, and let <span class="math">g(x)</span> be a univariate polynomial over <span class="math">\\mathbb{F}</span> of degree strictly less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then </span>\\sum_{a\\in \\mathbb{H}}g(a) = g(0)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Because of Lemma 3, to test the result of <span class="math">\\sum_{a\\in \\mathbb{H}}f(a)</span> for <span class="math">f</span> with degree less than <span class="math">k</span>, we can decompose <span class="math">f</span> into two parts <span class="math">f(x) = g(x) + Z_{\\mathbb{H}}(x)\\cdot h(x)</span>, where <span class="math">Z_{\\mathbb{H}}(x) = \\prod_{a\\in \\mathbb{H}}(x - a)</span> (i.e., <span class="math">Z_{\\mathbb{H}}(a) = 0</span> for all <span class="math">a\\in \\mathbb{H}</span>), and the degrees of <span class="math">g</span> and <span class="math">h</span> are strictly less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>k -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This decomposition is unique for every </span>f<span class="math">. As </span>Z_{\\mathbb{H}}(a)<span class="math"> is always 0 for </span>a\\in \\mathbb{H}<span class="math">, </span>\\mu = \\sum_{a\\in \\mathbb{H}}f(a) = \\sum_{a\\in \\mathbb{H}}g(a) = g(0)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by Lemma 3. Therefore, if the claimed sum </span>\\mu<span class="math"> sent by the prover is correct, </span>f(x) - Z_{\\mathbb{H}}(x)\\cdot h(x) - \\mu /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> must be a polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ with constant term 0, or equivalently polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p(x) = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f(x) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot Z_{\\mathbb{H}}(x) \\cdot h(x) - \\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot x}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\tag{5} $$</p>

    <p class="text-gray-300">3Formally, <span class="math">f_i&#x27;</span> is <span class="math">I(0,z)f_i(\\dot{V}_{i+1}(x),\\dot{V}_{i+1}(y)) + I((x,y),0)(\\alpha_iZ_i(u^{(i)})R(u_1^{(i)},z) + \\beta_iZ_i(v^{(i)})R(v_1^{(i)},z)) + \\gamma_i\\delta_i(x,y,z)</span>, where <span class="math">I(a,b)</span> is an identity polynomial <span class="math">I(a,b) = 0</span> iff <span class="math">a = b</span>. We will not use <span class="math">f_i&#x27;</span> explicitly in our constructions later.</p>

    <p class="text-gray-300">4In [14], the protocols are mainly using additive cosets. We require <span class="math">\\mathbb{H}</span> to be a multiplicative coset for our constructions over prime fields and extensions. The univariate sumsheck on multiplicative cosets is also stated in [14].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">must be a polynomial of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$. To test this, the univariate sumcheck uses a low degree test (LDT) protocol on Reed-Solomon (RS) code, which we define below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reed-Solomon Code. Let <span class="math">\\mathbb{L}</span> be a subset of <span class="math">\\mathbb{F}</span>, an RS code is the evaluations of a polynomial <span class="math">\\rho(x)</span> of degree less than <span class="math">m</span> (<span class="math">m&lt;\\mathbb{L}</span>) on <span class="math">\\mathbb{L}</span>. We use the notation $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> to denote the vector of the evaluations </span>(\\rho(a))_{a\\in\\mathbb{L}}<span class="math">, and use </span>RS[\\mathbb{L},m]<span class="math"> to denote the set of all such vectors generated by polynomials of degree less than </span>m<span class="math">. Note that any vector of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can be viewed as some univariate polynomial of degree less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> evaluated on </span>\\mathbb{L}$, thus we use vector and polynomial interchangeably.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Low Degree Test and Rational Constraints. Low degree test allows a verifier to test whether a polynomial/vector belongs to an RS code, i.e., the vector is the evaluations of some polynomial of degree less than <span class="math">m</span> on <span class="math">\\mathbb{L}</span>.</p>

    <p class="text-gray-300">In our constructions, we use the LDT protocol in <em>[14, Protocol 8.2]</em>, which was used to transform an RS-encoded IOP to a regular IOP. It applies the LDT protocol proposed in <em>[10]</em> protocol to a sequence of polynomials <span class="math">\\vec{\\rho}</span> and their <em>rational constraint</em> <span class="math">p</span>, which is a polynomial that can be computed as the division of the polynomials in <span class="math">\\vec{\\rho}</span>. In the case of univariate sumcheck, the sequence of polynomials is <span class="math">\\vec{\\rho}=(f,h)</span> and the rational constraint is given by Equation 5.</p>

    <p class="text-gray-300">The high level idea is as follows. First, the verifier multiplies each polynomial in <span class="math">\\vec{\\rho}</span> and the rational constraint <span class="math">p</span> with an appropriate monomial such that they have the same degree <span class="math">\\mathsf{max}</span>, and takes their random linear combination. Then the verifier tests that the resulting polynomial is in <span class="math">RS[\\mathbb{L},\\mathsf{max}+1]</span>. At the end of the protocol, the verifier needs oracle access to <span class="math">\\kappa</span> evaluations of each polynomial in <span class="math">\\vec{\\rho}</span> and the rational constraint <span class="math">p</span> at points in <span class="math">\\mathbb{L}</span> indexed by <span class="math">\\mathcal{I}</span>, and checks that each evaluation of <span class="math">p</span> is consistent with the evaluations of the polynomials in <span class="math">\\vec{\\rho}</span>. We denote the protocol as <span class="math">\\langle\\mathsf{LDT}.\\mathcal{P}(\\vec{\\rho},p),\\mathsf{LDT}.\\mathcal{V}(\\vec{m},\\deg(p))\\rangle(\\mathbb{L})</span>, where <span class="math">\\vec{\\rho}</span> is a sequence of polynomials over <span class="math">\\mathbb{F}</span>, <span class="math">p(x)</span> is their rational constraint, <span class="math">\\vec{m},\\deg(p)</span> is the degrees of the polynomials and the rational constraint to test, and <span class="math">\\mathbb{L}</span> is a multiplicative coset of <span class="math">\\mathbb{F}</span>. We state the properties of the protocol in the following lemma:</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Lemma 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exist an LDT protocol <span class="math">\\langle\\mathsf{LDT}.\\mathcal{P}(\\vec{\\rho},p),\\mathsf{LDT}.\\mathcal{V}(\\vec{m},\\deg(p))\\rangle(\\mathbb{L})</span> that is complete and sound with soundness error $O(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})+\\mathsf{negl}(\\kappa)<span class="math">, given oracle access to evaluations of each polynomial in </span>\\vec{\\rho}<span class="math"> at </span>\\kappa<span class="math"> points indexed by </span>\\mathcal{I}<span class="math"> in </span>\\mathbb{L}<span class="math">. The proof size and the verification time are </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> other than the oracle access, and the prover time is </span>O(\\mathbb{L})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The LDT protocol can be made zero knowledge in a straight-forward way by adding a random polynomial of degree <span class="math">\\mathsf{max}</span> in <span class="math">\\vec{\\rho}</span>. That is, there exists a simulator <span class="math">\\mathcal{S}</span> such that given the random challenges of <span class="math">\\mathcal{I}</span> of any PPT algorithm <span class="math">\\mathcal{V}^{<em>}</span>, it can simulate the view of <span class="math">\\mathcal{V}^{</em>}</span> such that <span class="math">\\mathsf{View}(\\langle\\mathsf{LDT}.\\mathcal{P}(\\vec{\\rho},p),\\mathcal{V}^{<em>}(\\vec{m},\\deg(p))\\rangle(\\mathbb{L}))\\approx\\mathcal{S}^{\\mathcal{V}^{</em>}}(\\deg(p))</span>. In particular, <span class="math">\\mathcal{S}</span> generates <span class="math">p^{<em>}\\in RS[\\mathbb{L},\\deg(p)]</span> and can simulate the view of any sequence of random polynomials <span class="math">\\vec{\\rho}^{</em>}</span> subject to the constraint that their evaluations at points indexed by <span class="math">\\mathcal{I}</span> are consistent with the oracle access of <span class="math">p^{*}</span>.</p>

    <p class="text-gray-300">Merkle Tree. Merkle hash tree proposed by Ralph Merkle in <em>[57]</em> is a common primitive to commit a vector and open it at an index with logarithmic proof size and verification time. It consists of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{root}_{c}\\leftarrow\\mathsf{MT.Commit}(c)</span></li>

      <li><span class="math">(c_{idx},\\pi_{idx})\\leftarrow\\mathsf{MT.Open}(idx,c)</span></li>

      <li><span class="math">(1,0)\\leftarrow\\mathsf{MT.Verify}(\\mathsf{root}_{c},idx,c_{idx},\\pi_{idx})</span></li>

    </ul>

    <p class="text-gray-300">The security follows the collision-resistant property of the hash function used to construct the Merkle tree.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With these tools, the univariate sumcheck protocol works as follows. To prove <span class="math">\\mu=\\sum_{a\\in\\mathbb{H}}f(a)</span>, the verifier and the prover picks <span class="math">\\mathbb{L}</span>, a multiplicative coset of <span class="math">\\mathbb{F}</span> and a superset of <span class="math">\\mathbb{H}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>k<span class="math">. </span>\\mathcal{P}<span class="math"> decompose </span>f(x)=g(x)+Z_{\\mathbb{H}}(x)\\cdot h(x)<span class="math"> as defined above, and computes the vectors </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> and </span>h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math">. </span>\\mathcal{P}<span class="math"> then commits to these two vectors using Merkle trees. </span>\\mathcal{P}<span class="math"> then defines a polynomial </span>p(x)=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f(x)-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot Z_{\\mathbb{H}}(x)\\cdot h(x)-\\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot x}<span class="math">, which is a rational constraint of </span>f<span class="math"> and </span>h<span class="math">. As explained above, in order to ensure the correctness of </span>\\mu<span class="math">, it suffices to test that the degree of </span>(f,h),p<span class="math"> is less than </span>(k,k-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">, which is done through the low degree test. At the end of the LDT, </span>\\mathcal{V}<span class="math"> needs oracle access to </span>\\kappa<span class="math"> points of </span>f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> and </span>h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math">. </span>\\mathcal{P}<span class="math"> sends these points with their Merkle tree proofs, and </span>\\mathcal{V}<span class="math"> validates their correctness. The formal protocol and the lemma is presented in Appendix A. As shown in <em>[14]</em>, it suffices to set </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-15" class="text-2xl font-bold">3 Transparent Zero Knowledge Polynomial Delegation</h2>

    <p class="text-gray-300">In this section, we present our main construction, a zero knowledge verifiable polynomial delegation scheme without trusted setup. We first construct a VPD scheme that is correct and sound, then extend it to be zero knowledge. Our construction is inspired by the univariate sumcheck <em>[14]</em> described in Section 2.4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our main idea is as follows. To evaluate an <span class="math">\\ell</span>-variate polynomial <span class="math">f</span> with variable degree <span class="math">d</span> at point <span class="math">t=(t_{1},\\ldots,t_{\\ell})</span>, we model the evaluation as the inner product between the vector of coefficients in <span class="math">f</span> and the vector of all monomials in <span class="math">f</span> evaluated at <span class="math">t</span>. Formally speaking, let $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}_{\\ell,d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(d+1)^{\\ell}<span class="math"> be the number of possible monomials in an </span>\\ell<span class="math">-variate polynomial with variable degree </span>d<span class="math">, and let </span>c=(c_{1},\\ldots,c_{N})<span class="math"> be the coefficients of </span>f<span class="math"> in the order defined by </span>\\mathcal{W}_{\\ell,d}<span class="math"> such that </span>f(x_{1},\\ldots,x_{\\ell})=\\sum_{i=1}^{N}c_{i}W_{i}(x)<span class="math">, where </span>W_{i}(x)<span class="math"> is the </span>i<span class="math">-th monomial in </span>\\mathcal{W}_{\\ell,d}<span class="math">. Define the vector </span>T=(W_{1}(t),\\ldots,W_{N}(t))<span class="math">, then naturally the evaluation equals </span>f(t)=\\sum_{i=1}^{N}c_{i}\\cdot T_{i}<span class="math">, the inner product of the two vectors. We then select a multiplicative coset </span>\\mathbb{H}<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math">, and interpolate vectors </span>c<span class="math"> and </span>T<span class="math"> to find the unique univariate polynomials that evaluate to </span>c<span class="math"> and </span>T<span class="math"> on </span>\\mathbb{H}<span class="math">. We denote the polynomials as </span>l(x)<span class="math"> and </span>q(x)<span class="math"> such that </span>l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}=c<span class="math"> and </span>q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}=T<span class="math">. With these definitions, </span>f(t)=\\sum_{i=1}^{N}c_{i}\\cdot T_{i}=\\sum_{a\\in\\mathbb{H}}l(a)\\cdot q(a)<span class="math">, which is the sum of the polynomial </span>l(x)\\cdot q(x)<span class="math"> on </span>\\mathbb{H}$. The verifier can check the evaluation through a univariate sumcheck protocol with the prover. The detailed protocol is presented in step 1-4 of Protocol 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Up to this point, the construction for validating the inner product between a vector committed by <span class="math">\\mathcal{P}</span> and a public vector is similar to and simpler than the protocols to check linear constraints proposed in <em>[5, 14]</em>. However, naively applying the univariate sumcheck protocol incurs a linear overhead for the verifier. This is because as described in Section 2.4, at the end of the univariate sumcheck, due to the low degree test, the verifier needs oracle access to the evaluations of <span class="math">l(x)\\cdot q(x)</span> at <span class="math">\\kappa</span> points on <span class="math">\\mathbb{L}</span>, a superset of <span class="math">\\mathbb{H}</span>. As <span class="math">l(x)</span> is defined by <span class="math">c</span>, i.e. the coefficients of <span class="math">f</span>, the prover can commit to $l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> at the beginning of the protocol, and opens to points the verifier queries with their Merkle tree proofs. </span>q(x)<span class="math">, however, is defined by the public vector </span>T$, and the verifier has to evaluate it locally, which takes linear time. This is the major reason why the verification time in the zero knowledge proof schemes for generic arithmetic circuits in <em>[5, 14]</em> is linear in the size of the circuits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 2 (Verifiable Polynomial Delegation). Let <span class="math">\\mathcal{F}</span> be a family of <span class="math">\\ell</span>-variate polynomial over <span class="math">\\mathbb{F}</span> with variable-degree <span class="math">d</span> and <span class="math">N=(d+1)^{\\ell}</span>. We use <span class="math">\\mathcal{W}_{\\ell,d}=\\{W_{i}(x_{1},\\ldots,x_{\\ell})\\}_{i=1}^{N}</span> to denote the collection of all monomials in <span class="math">\\mathcal{F}</span>. <span class="math">r_{f}=\\bot</span> and we omit if in the algorithms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{KeyGen}(1^{\\lambda})</span>: Pick a hash function from the collision-resistant hash function family for Merkle tree. Find a multiplicative coset <span class="math">\\mathbb{H}</span> of <span class="math">\\mathbb{F}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=(d+1)^{\\ell}<span class="math">. Find a multiplicative coset </span>\\mathbb{L}<span class="math"> of </span>\\mathbb{F}<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\mathbb{H}\\subset\\mathbb{L}\\subset\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mu,\\pi);\\{0,1\\})\\leftarrow\\langle\\mathsf{Open}(f),\\mathsf{Verify}(\\mathsf{com})\\rangle(t,\\mathsf{pp})</span>: This is an interactive protocol between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> computes <span class="math">\\mu=f(t)</span> and sends it to <span class="math">\\mathcal{V}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\mathcal{P}</span> evaluates <span class="math">T=(W_{1}(t),\\ldots,W_{N}(t))</span>. <span class="math">\\mathcal{P}</span> finds the unique univariate polynomial <span class="math">q(x):\\mathbb{F}\\rightarrow\\mathbb{F}</span> such that $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}=T$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4. Let $p(x)=\\frac{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">{\\cdot}l(x)\\cdot q(x)-\\mu-</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">{\\cdot}\\mathbb{Z}_{\\mathbb{H}}(x)h(x)}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">{\\cdot}x}<span class="math">. </span>\\mathcal{P}<span class="math"> and </span>\\mathcal{V}<span class="math"> invoke a low degree test: </span>\\langle\\mathsf{LDT.}\\mathcal{P}((l\\cdot q,h),p),\\mathsf{LDT.}\\mathcal{V}((2</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">-1,</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">-1),</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{H}</td>

            <td class="px-3 py-2 border-b border-gray-700">-1)\\rangle(\\mathbb{L})<span class="math">. If the test fails, </span>\\mathcal{V}<span class="math"> aborts and output 0. Otherwise, at then end of the test, </span>\\mathcal{V}<span class="math"> needs oracle access to </span>\\kappa<span class="math"> points of </span>l(x)\\cdot q(x),h(x)<span class="math"> and </span>p(x)<span class="math"> at indices </span>\\mathcal{I}$.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5. For each index <span class="math">i\\in\\mathcal{I}</span>, let <span class="math">a_{i}</span> be the corresponding point in <span class="math">\\mathbb{L}</span>. <span class="math">\\mathcal{P}</span> opens $(l(a_{i}),\\pi_{i}^{l})\\leftarrow\\mathsf{MT.Open}(i,l</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\mathbb{L}})<span class="math"> and </span>(h(a_{i}),\\pi_{i}^{h})\\leftarrow\\mathsf{MT.Open}(i,h</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\mathbb{L}})$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> executes <span class="math">\\mathsf{MT.Verify}(\\mathsf{root}_{l},i,l(a_{i}),\\pi_{i}^{l})</span> and <span class="math">\\mathsf{MT.Verify}(\\mathsf{root}_{h},i,h(a_{i}),\\pi_{i}^{h})</span> for all points opened by <span class="math">\\mathcal{P}</span>. If any verification fails, abort and output <span class="math">0</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. To complete the low degree test, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> runs <span class="math">\\langle\\mathsf{GKR.}\\mathcal{P},\\mathsf{GKR.}\\mathcal{V}\\rangle(C,t)</span>, where circuit <span class="math">C</span> computes the evaluations of $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> and outputs the elements </span>q(a_{i})<span class="math"> for </span>i\\in\\mathcal{I}<span class="math"> (see Figure 1). If any of the checks in GKR fails, </span>\\mathcal{V}$ aborts and outputs 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in\\mathcal{I}</span>, <span class="math">\\mathcal{V}</span> computes <span class="math">l(a_{i})\\cdot q(a_{i})</span>. Together with <span class="math">h(a_{i})</span>, <span class="math">\\mathcal{V}</span> completes the low degree test. If all checks above pass, <span class="math">\\mathcal{V}</span> outputs 1.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reducing the verification time. In this paper, we propose an approach to reduce the cost of the verifier to poly-logarithmic for VPD. We observe that in our construction, though the size of <span class="math">T</span> and <span class="math">q(x)</span> is linear in <span class="math">N</span>, it is defined by only <span class="math">\\ell=O(\\log N)</span> values of the evaluation point <span class="math">t</span>. This means that the oracle access of <span class="math">\\kappa</span> points of <span class="math">q(x)</span> can be modeled as a function that: (1) Takes <span class="math">t</span> as input, evaluates all monomials <span class="math">W_{i}(t)</span> for all <span class="math">W_{i}\\in\\mathcal{W}_{\\ell,d}</span> as a vector <span class="math">T</span>; (2) Extrapolates the vector <span class="math">T</span> to find polynomial <span class="math">q(x)</span>, and evaluates <span class="math">q(x)</span> on <span class="math">\\mathbb{L}</span>; (3) Outputs <span class="math">\\kappa</span> points of $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> chosen by the verifier. Although the size of the function modeled as an arithmetic circuit is </span>\\Omega(N)<span class="math"> with </span>O(\\log N)<span class="math"> depth, and the size of its input and output is only </span>O(\\log N+\\kappa)$. Therefore, instead of evaluating the function locally, the verifier can delegate this computation to the prover, and validate the result using the GKR protocol, as presented in Section 2.3. In this way, we eliminate the linear overhead to evaluate these points locally, making the verification time of the overall VPD protocol poly-logarithmic. The formal protocol is presented in Protocol 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To avoid any asymptotic overhead for the prover, we also design an efficient layered arithmetic</p>

    <p class="text-gray-300">Input:  <span class="math">t = (t_1,\\dots ,t_\\ell)</span></p>

    <p class="text-gray-300">Output:  <span class="math">q()</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Computing vector  <span class="math">T = (W_{1}(t),\\ldots ,W_{N}(t))</span>  ..</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(t_i^0, t_i^1, \\ldots, t_i^d)</span>  for  <span class="math">i = 1, \\ldots, \\ell</span> .</li>

      <li>Initialize vector  <span class="math">T_0 = (1)</span> .</li>

      <li>For  <span class="math">i = 1, \\dots, \\ell</span> :  <span class="math">T_{i} = (t_{i}^{0} \\cdot T_{i - 1}, \\dots, t_{i}^{d} \\cdot T_{i - 1})</span> , where “.” here is scalar multiplication between a number and a vector and “,” means concatenation. Set  <span class="math">T = T_{\\ell}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Computing  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputting evaluations indexed by  <span class="math">I_{q}</span> :</li>

    </ol>

    <p class="text-gray-300">Figure 1: Arithmetic circuit  <span class="math">C</span>  computing evaluations of  <span class="math">q(x)</span>  at  <span class="math">\\kappa</span>  points in  <span class="math">\\mathbb{L}</span>  indexed by  <span class="math">\\mathcal{I}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">circuit for the function mentioned above. The details of the circuit are presented in Figure 1. In particular, in the first part, each value  <span class="math">t_i</span>  in the input  <span class="math">t</span>  is raised to powers of  <span class="math">0, 1, \\ldots, d</span> . Then they are expanded to  <span class="math">T</span> , the evaluations of all monomials in  <span class="math">\\mathcal{W}_{\\ell, d}</span> , by multiplying one  <span class="math">t_i</span>  at a time through a  <span class="math">(d + 1)</span> -ary tree. The size of this part is  <span class="math">O(N) = O((d + 1)^{\\ell})</span>  and the depth is  <span class="math">O(\\log d + \\ell)</span> . In the second part, the polynomial  <span class="math">q(x)</span>  and the vector  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math">  is computed from  </span>T<span class="math">  directly using FFTs. We first construct a circuit for an inverse FFT to compute the coefficients of polynomial  </span>q(x)<span class="math">  from its evaluations  </span>T<span class="math"> . Then we run an FFT to evaluate  </span>q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math">  from the coefficients of  </span>q(x)<span class="math"> . We implement FFT and IFFT using the Butterfly circuit [33]. The size of the circuit is  </span>O(N \\log N)<span class="math">  and the depth is  </span>O(\\log N)<span class="math"> . Finally,  </span>\\kappa<span class="math">  points are selected from  </span>q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> . As the whole delegation of the GKR protocol is executed at the end in Protocol 2 after these points being fixed by the verifier, the points to output are directly hard-coded into the circuit with size  </span>O(\\kappa)<span class="math">  and depth 1. No heavy techniques for random accesses in the circuit is needed. Therefore, the whole circuit is of size  </span>O(N \\log N)<span class="math">  and depth  </span>O(\\log N)<span class="math"> , with  </span>\\ell<span class="math">  inputs and  </span>\\kappa$  outputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 1. Protocol 2 is a verifiable polynomial delegation protocol that is complete and sound under Definition 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Completeness. By the definition of  <span class="math">l(x)</span>  and  <span class="math">q(x)</span> , if  <span class="math">\\mu = f(t)</span> , then  $\\mu = \\sum_{a \\in H} l(a) \\cdot q(a) = \\sum_{a \\in H} g(a) = g(0) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  by Lemma 3. Thus,  </span>p(x) = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot l(x) \\cdot q(x) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathbb{Z}_{\\mathbb{H}}(x) h(x) - \\mu}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot x} = \\frac{g(x) - g(0)}{x}<span class="math"> , which is in  </span>RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1]$ . The rest follows the completeness of the LDT protocol and the GKR protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness. Let  <span class="math">\\varepsilon_{\\mathsf{LDT}}, \\varepsilon_{\\mathsf{MT}}, \\varepsilon_{\\mathsf{GKR}}</span>  be the soundness error of the LDT, Merkle tree and GKR protocols. There are two cases for a malicious prover  <span class="math">\\mathcal{P}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 1:  $\\nexists l^{*}\\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1]<span class="math">  such that  </span>\\mathsf{com} = \\mathsf{MT}. \\mathsf{Commit}(l^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}})<span class="math"> , i.e.  </span>\\mathsf{com}$  is not a valid commitment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By the check in step 6, if  <span class="math">\\mathsf{com}</span>  is not a valid Merkle tree root, the verification passes with probability less than  <span class="math">\\varepsilon_{\\mathsf{MT}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If  $\\exists l^{**} \\notin RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1]<span class="math">  such that  </span>\\mathsf{com} \\gets \\mathsf{MT}. \\mathsf{Commit}(l^{**}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}})<span class="math"> , if the points  </span>v_i^<em><span class="math">  opened by  </span>\\mathcal{P}<span class="math">  in step 5  </span>v_i^</em> \\neq l^{**}(a_i)<span class="math">  for some  </span>i<span class="math"> , the verification passes with probability no more than  </span>\\varepsilon_{\\mathsf{MT}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the output  <span class="math">q_{i}^{<em>}</span>  returned by  <span class="math">\\mathcal{P}</span>  in step 7 is  <span class="math">q_{i}^{</em>} \\neq q(a_{i})</span>  for some  <span class="math">i</span> , the verification passes with probability less than  <span class="math">\\varepsilon_{\\mathsf{GKR}}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Otherwise, as $l^{**}(x)\\cdot q(x)\\notin RS[\\mathbb{L},2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1]<span class="math">, by the checks of LDT in step 4, the verification passes with probability no more than </span>\\varepsilon_{\\mathsf{LDT}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2: $\\exists l^{*}\\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1]<span class="math"> such that </span>\\mathsf{com}=\\mathsf{MT.Commit}(l^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}})<span class="math">. Let </span>c^{<em>}=l^{</em>}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}<span class="math"> and </span>f^{<em>}(x)=\\sum_{i=1}^{N}c_{i}^{</em>}W_{i}(x)<span class="math">, then </span>\\mathsf{com}=\\mathsf{Commit}(f^{<em>},\\mathsf{pp})<span class="math">. Suppose </span>\\mu^{</em>}\\neq f^{<em>}(t)<span class="math">, then </span>\\mu^{</em>}\\neq\\sum_{a\\in\\mathbb{H}}l^{*}(a)q(a)<span class="math">. Then by Lemma 3, for all </span>h\\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1]<span class="math">, </span>p^{*}\\notin RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1]<span class="math">, as </span>\\sum_{a\\in\\mathbb{H}}(p^{*}(a)\\cdot a)=\\sum_{a\\in\\mathbb{H}}\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot l^{<em>}(a)\\cdot q(a)-\\mu^{</em>}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\sum_{a\\in\\mathbb{H}}(l^{<em>}(a)\\cdot q(a))-\\mu^{</em>}\\neq 0$. Therefore,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Similar to case 1, if the commitment in step 3 is not a valid Merkle tree root, or the points opened by <span class="math">\\mathcal{P}</span> in step 5 are inconsistent with <span class="math">h</span> or <span class="math">l^{*}</span>, the verification passes with probability no more than <span class="math">\\varepsilon_{\\mathsf{MT}}</span>.</li>

      <li>If the output <span class="math">q_{i}^{<em>}</span> returned by <span class="math">\\mathcal{P}</span> in step 7 <span class="math">q_{i}^{</em>}\\neq q(a_{i})</span> for some <span class="math">i</span>, the verification passes with probability no more than <span class="math">\\varepsilon_{\\mathsf{GKR}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Otherwise, as $l^{*}\\cdot q\\in RS[\\mathbb{L},2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1]<span class="math">, either </span>h\\notin RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1]<span class="math"> or </span>p\\notin RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1]<span class="math"> as explained above. By the check in step 4, the verification passes with probability no more than </span>\\varepsilon_{\\mathsf{LDT}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the union bound, the probability of the event of a malicious prover is no more than <span class="math">O(\\varepsilon_{\\mathsf{LDT}}+\\varepsilon_{\\mathsf{MT}}+\\varepsilon_{\\mathsf{GKR}})</span>. As stated in Section 2, $\\varepsilon_{\\mathsf{LDT}}=O(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})+\\mathsf{negl}(\\kappa)<span class="math">, </span>\\varepsilon_{\\mathsf{GKR}}=O(\\frac{\\log^{2}N}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> and </span>\\varepsilon_{\\mathsf{MT}}=\\mathsf{negl}(\\lambda)<span class="math">. Therefore, with proper choice of parameters, the probability is </span>\\leq\\mathsf{negl}(\\lambda)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">The running time of <span class="math">\\mathsf{Commit}</span> is <span class="math">O(N\\log N)</span>. <span class="math">C</span> in step 7 is a regular circuit with size <span class="math">O(N\\log N)</span>, depth <span class="math">O(\\ell+\\log d)</span> and size of input and output <span class="math">O(\\ell+\\kappa)</span>. By Lemma 1 and 5, the prover time is <span class="math">O(N\\log N)</span>, the proof size and the verification time are <span class="math">(\\log^{2}N)</span>.</p>

    <p class="text-gray-300">Extending to other ZKP schemes. We notice that our technique can be potentially applied to generic zero knowledge proof schemes in <em>[5, 14]</em> to improve the verification time for circuits/constraint systems with succinct representation. As mentioned previously, the key step that introduces linear verification time in these schemes is to check a linear constraint system, i.e., <span class="math">y=\\mathbf{A}w</span>, where <span class="math">w</span> is a vector of all values on the wires of the circuit committed by the prover, and <span class="math">\\mathbf{A}</span> is a public matrix derived from the circuit such that <span class="math">\\mathbf{A}w</span> gives a vector of left inputs to all multiplication gates in the circuit. (This check is executed 2 more times to also give right inputs and outputs.) To check the relationship, it is turned into a vector inner product <span class="math">\\mu=ry=r\\mathbf{A}\\cdot w</span> by multiplying both sides by a random vector <span class="math">r</span>. Similar to our naive protocol to check inner product, the verification time is linear in order to evaluate the polynomial defined by <span class="math">r\\mathbf{A}</span> at <span class="math">\\kappa</span> points. With our new protocol, if the circuit can be represented succinctly in sublinear or logarithmic space, <span class="math">\\mathbf{A}</span> can be computed by a function with sublinear or logarithmic number of inputs. We can use the GKR protocol to delegate the computation of <span class="math">r\\mathbf{A}</span> and the subsequent evaluations to the prover in a similar way as in our construction, and the verification time will only depend on the space to represent the circuit, but not on the total size of the circuit. This is left as a future work.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.1 Achieving Zero Knowledge</h3>

    <p class="text-gray-300">Our VPD protocol in Protocol 2 is not zero knowledge. Intuitively, there are two places that leak information about the polynomial <span class="math">f</span>: (1) In step 6 of Protocol 2, <span class="math">\\mathcal{P}</span> opens evaluations of <span class="math">l(x)</span>, which is defined by the coefficients of <span class="math">f</span>; (2) In step 4, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> execute low degree tests on</p>

    <p class="text-gray-300">Protocol 3 (Zero Knowledge Verifiable Polynomial Delegation). Let  <span class="math">\\mathcal{F}</span>  be a family of  <span class="math">\\ell</span> -variate polynomial over  <span class="math">\\mathbb{F}</span>  with variable-degree  <span class="math">d</span>  and  <span class="math">N = (d + 1)^{\\ell}</span> . We use  <span class="math">\\mathcal{W}_{\\ell, d} = \\{W_i(x_1, \\ldots, x_\\ell)\\}_{i=1}^N</span>  to denote the collection of all monomials in  <span class="math">\\mathcal{F}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pp  <span class="math">\\leftarrow</span>  zkVPD.KeyGen(1 <span class="math">\\lambda</span> ): Same as KeyGen in Procotol 2. Define  <span class="math">\\mathbb{U} = \\mathbb{L} - \\mathbb{H}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- com  <span class="math">\\leftarrow</span>  Commit(f,  <span class="math">r_f</span> , pp): For a polynomial  <span class="math">f \\in \\mathcal{F}</span>  of the form  <span class="math">f(x) = \\sum_{i=1}^{N} c_i W_i(x)</span> , find the unique univariate polynomial  <span class="math">l(x): \\mathbb{F} \\to \\mathbb{F}</span>  such that  $l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}} = (c_1, \\ldots, c_N)<span class="math"> .  </span>\\mathcal{P}<span class="math">  samples a polynomial  </span>r(x)<span class="math">  with degree  </span>\\kappa<span class="math">  randomly and sets  </span>l'(x) = l(x) + Z_{\\mathbb{H}}(x) \\cdot r(x)<span class="math"> , where  </span>Z_{\\mathbb{H}}(x) = \\prod_{a \\in \\mathbb{H}} (x - a)<span class="math"> .  </span>\\mathcal{P}<span class="math">  evaluates  </span>l'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">  and runs root </span>_{l'} \\leftarrow \\text{MT.Commit}(l'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})<span class="math"> . Output com = root </span>_{l'}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">((\\mu, \\pi); \\{0, 1\\}) \\gets \\langle \\mathsf{Open}(f, r_f), \\mathsf{Verify}(\\mathsf{com}) \\rangle(t, \\mathsf{pp})</span> : This is an interactive protocol between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> . It replaces the univariate sumscheck on  <span class="math">l(x) \\cdot q(x)</span>  by  <span class="math">l&#x27;(x) \\cdot q(x) + \\alpha s(x)</span>  and  <span class="math">\\mathbb{L}</span>  by  <span class="math">\\mathbb{U}</span>  in Protocol 2.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes  <span class="math">\\mu = f(t)</span>  and sends it to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.  <span class="math">\\mathcal{P}</span>  evaluates  <span class="math">T = (W_{1}(t),\\ldots ,W_{N}(t))</span>  .  <span class="math">\\mathcal{P}</span>  finds the unique univariate polynomial  <span class="math">q(x):\\mathbb{F}\\to \\mathbb{F}</span>  such that  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}} = T$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  picks  <span class="math">\\alpha \\in \\mathbb{F}</span>  randomly and sends it to  <span class="math">\\mathcal{P}</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5.  <span class="math">\\mathcal{P}</span>  computes  <span class="math">\\alpha l&#x27;(x) \\cdot q(x) + s(x)</span> .  <span class="math">\\mathcal{P}</span>  uniquely decomposes it as  <span class="math">g(x) + Z_{\\mathbb{H}}(x) \\cdot h(x)</span> , where the degrees of  <span class="math">g</span>  and  <span class="math">h</span>  are strictly less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\kappa<span class="math"> .  </span>\\mathcal{P}<span class="math">  evaluates  </span>h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">  and sends  </span>\\operatorname{root}_h \\gets \\mathsf{MT}.\\mathsf{Commit}((h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})<span class="math">  to  </span>\\mathcal{V}$ .</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7. For each index  <span class="math">i \\in \\mathcal{I}</span> , let  <span class="math">a_i</span>  be the corresponding point in  <span class="math">\\mathbb{U}</span> .  <span class="math">\\mathcal{P}</span>  opens  $(l'(a_i), \\pi_i^{l'}) \\gets \\mathsf{MT.Open}(i, l'</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\mathbb{U}})<span class="math"> ,  </span>(h(a_i), \\pi_i^h) \\gets \\mathsf{MT.Open}(i, h</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\mathbb{U}})<span class="math">  and  </span>(s(a_i), \\pi_i^s) \\gets \\mathsf{MT.Open}(i, s</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\mathbb{U}})$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  executes MT.Verify(rootl', i, l'(ai), πi l'), MT.Verify(rooth, i, h(ai), πi) and MT.Verify(roots, i, s(ai), πi) for all points opened by P. If any verification fails, abort and output 0.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9. To complete the low degree test,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  runs  <span class="math">\\langle \\mathsf{GKR}.\\mathcal{P},\\mathsf{GKR}.\\mathcal{V}\\rangle (C,t)</span> , where circuit  <span class="math">C</span>  computes the evaluations of  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">  and outputs the elements  </span>q(a_{i})<span class="math">  for  </span>i\\in \\mathcal{I}<span class="math"> . If any of the checks in GKR fails,  </span>\\mathcal{V}$  aborts and outputs 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in \\mathcal{I}</span> ,  <span class="math">\\mathcal{V}</span>  computes  <span class="math">l&#x27;(a_i) \\cdot q(a_i)</span> . Together with  <span class="math">h(a_i)</span>  and  <span class="math">s(a_i)</span> ,  <span class="math">\\mathcal{V}</span>  completes the low degree test. If all checks above pass,  <span class="math">\\mathcal{V}</span>  outputs 1.</li>

    </ol>

    <p class="text-gray-300"><span class="math">(l(x)\\cdot q(x),h(x)),p(x)</span>  and the proofs of LDT reveal information about the polynomials, which are related to  <span class="math">f</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To make the protocol zero knowledge, we take the standard approaches proposed in [5, 14]. To eliminate the former leakage of queries on  <span class="math">l(x)</span> , the prover picks a random degree  <span class="math">\\kappa</span>  polynomial  <span class="math">r(x)</span>  and masks it as  <span class="math">l&#x27;(x) = l(x) + Z_{\\mathbb{H}}(x) \\cdot r(x)</span> , where as before,  <span class="math">Z_{\\mathbb{H}}(x) = \\prod_{a \\in \\mathbb{H}} (x - a)</span> . Note here that  <span class="math">l&#x27;(a) = l(a)</span>  for  <span class="math">a \\in \\mathbb{H}</span> , yet any  <span class="math">\\kappa</span>  evaluations of  <span class="math">l&#x27;(x)</span>  outside  <span class="math">\\mathbb{H}</span>  do not reveal any information about  <span class="math">l(x)</span>  because of the masking polynomial  <span class="math">r(x)</span> . The degree of  <span class="math">l&#x27;(x)</span>  is  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\kappa<span class="math"> , and we denote domain  </span>\\mathbb{U} = \\mathbb{L} - \\mathbb{H}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To eliminate the latter leakage,  <span class="math">\\mathcal{P}</span>  samples a random polynomial  <span class="math">s(x)</span>  of the same degree as</p>

    <p class="text-gray-300"><span class="math">l^{\\prime}(x)\\cdot q(x)</span>, sends <span class="math">S=\\sum_{a\\in\\mathbb{H}}s(a)</span> to <span class="math">\\mathcal{V}</span> and runs the univariate sumcheck protocol on their random linear combination: <span class="math">\\alpha\\mu+S=\\sum_{a\\in\\mathbb{H}}(\\alpha l^{\\prime}(x)\\cdot q(x)+s(x))</span> for a random <span class="math">\\alpha\\in\\mathbb{F}</span> chosen by <span class="math">\\mathcal{V}</span>. This ensures that both <span class="math">\\mu</span> and <span class="math">S</span> are correctly computed because of the random linear combination and the linearity of the univariate sumcheck, while leaking no information about <span class="math">l^{\\prime}(x)\\cdot q(x)</span> during the protocol, as it is masked by <span class="math">s(x)</span>.</p>

    <p class="text-gray-300">One advantage of our construction is that the GKR protocol used to compute evaluations of <span class="math">q(x)</span> in step 7 of Protocol 2 remains unchanged in the zero knowledge version of the VPD. This is because <span class="math">q(x)</span> and its evaluations are independent of the polynomial <span class="math">f</span> or any prover’s secret input. Therefore, it suffices to apply the plain version of GKR without zero knowledge, avoiding any expensive cryptographic primitives.</p>

    <p class="text-gray-300">The full protocol for our zkVPD is presented in Protocol 3. Note that all the evaluations are on <span class="math">\\mathbb{U}=\\mathbb{L}-\\mathbb{H}</span> instead of <span class="math">\\mathbb{L}</span>, as evaluations on <span class="math">\\mathbb{H}</span> leaks information about the original <span class="math">l(x)</span>. <span class="math">s(x)</span> is also committed and opened using Merkle tree for the purpose of correctness and soundness. The efficiency of our zkVPD protocol is asymptotically the same as our VPD protocol in Protocol 2, and the concrete overhead in practice is also small. We have the following theorem:</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Protocol 3 is a zero knowledge verifiable polynomial delegation scheme by Definition 3.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. It follows the completeness of Protocol 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. It follows the soundness of Protocol 2 and the random linear combination. In particular, in Case 2 of the proof of Theorem 1, if $\\exists l^{\\prime*}\\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\kappa+1]<span class="math">, it can always be uniquely decomposed as </span>l^{<em>}(x)=l^{\\prime</em>}(x)-Z_{\\mathbb{H}}(x)r^{<em>}(x)<span class="math"> such that </span>\\sum_{a\\in\\mathbb{H}}l^{\\prime</em>}(a)=\\sum_{a\\in\\mathbb{H}}l^{<em>}(a)<span class="math"> and the degree of </span>l^{</em>}(x)<span class="math"> is </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the degree of </span>r(x)<span class="math"> is </span>\\kappa<span class="math">. If </span>\\mu^{<em>}\\neq\\mu=\\sum_{a\\in\\mathbb{H}}(l^{</em>}(a)\\cdot q(a))=\\sum_{a\\in\\mathbb{H}}(l^{\\prime<em>}(a)\\cdot q(a))<span class="math">, let </span>S^{</em>}=\\sum_{a\\in\\mathbb{H}}s^{<em>}(a)<span class="math"> where </span>s^{</em>}(x)<span class="math"> is committed by </span>\\mathcal{P}<span class="math"> in step 5, then </span>\\sum_{a\\in\\mathbb{H}}(\\alpha l^{\\prime<em>}(a)\\cdot q(a)+s^{</em>}(a))=\\alpha\\mu^{<em>}+S^{</em>}=\\alpha\\mu+S<span class="math"> if and only if </span>\\alpha=\\frac{S-S^{<em>}}{\\mu^{</em>}-\\mu}<span class="math">, which happens with probability </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. The probability of other cases are the same as the proof of Theorem 1, and we omit the details here.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge. The simulator is given in Figure 2.</p>

    <p class="text-gray-300">To prove zero knowledge, <span class="math">l^{\\prime}_{\\textsf{sim}}</span> in <span class="math">\\mathcal{S}_{1}</span> and <span class="math">l^{\\prime}</span> in zkVPD.Commit are both uniformly distributed. In <span class="math">\\mathcal{S}_{2}</span>, steps 1, 2 and 9 are the same as the real world in Protocol 3. No message is sent in steps 4, 8 and 10.</p>

    <p class="text-gray-300">In step 3 and 7, <span class="math">s_{\\textsf{sim}}</span> and <span class="math">s</span> are both randomly selected and their commitments and evaluations are indistinguishable. As <span class="math">r(x)</span> is a degree-<span class="math">\\kappa</span> random polynomial in the real world in Protocol 3, <span class="math">\\kappa</span> evaluations of <span class="math">l^{\\prime}(x)</span> opened in step 7 are independent and randomly distributed, which is indistinguishable from step 7 of <span class="math">\\mathcal{S}_{2}</span> in the ideal world. Finally, in step 7 of the ideal world, <span class="math">\\mathcal{V}^{*}</span> receives <span class="math">\\kappa</span> evaluations of <span class="math">h_{\\textsf{sim}}</span> at point indexed by <span class="math">\\mathcal{I}</span>. Together with <span class="math">l^{\\prime}_{\\textsf{sim}}\\cdot q</span> and <span class="math">s_{\\textsf{sim}}</span>, by Lemma 4, the view of steps 5-7 simulated by LDT.<span class="math">\\mathcal{S}</span> is indistinguishable from the real world with <span class="math">h,l^{\\prime}\\cdot q</span> and <span class="math">s</span>, which completes the proof. ∎</p>

    <p class="text-gray-300">Our zkVPD protocol is also a proof of knowledge. Here we give the formal definition of knowledge soundness of a zkVPD protocol in addition to Definition 3 and prove that our protocol has knowledge soundness.</p>

    <p class="text-gray-300">Knowledge Soundness. For any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> such that given access to the random tape of <span class="math">\\mathcal{A}</span>, for every <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{zkVPD.KeyGen}(1^{\\lambda})</span>, the following probability</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathsf{com} \\gets S_1(1^\\lambda, \\mathsf{pp})</span> : Pick a random polynomial  $l_{\\mathsf{sim}}'(x) \\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\kappa + 1]<span class="math"> . Evaluate  </span>l_{\\mathsf{sim}}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">  and output  </span>\\mathsf{root}_{l_{\\mathsf{sim}}'}' \\gets \\mathsf{MT.Commit}(l_{\\mathsf{sim}}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{2}(t, \\mathsf{pp})</span> :</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given oracle access to  <span class="math">\\mu = f(t)</span> , send it to  <span class="math">\\mathcal{V}^*</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Evaluate  <span class="math">T = (W_{1}(t), \\ldots, W_{N}(t))</span> . Find the unique univariate polynomial  <span class="math">q(x): \\mathbb{F} \\to \\mathbb{F}</span>  such that  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}} = T$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive  <span class="math">\\alpha \\in \\mathbb{F}</span>  from  <span class="math">\\nu</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. Let LDT.S be the simulator the LDT protocol described in Section 2.4. Given the random challenges  <span class="math">\\mathcal{I}</span>  of  <span class="math">\\nu^{<em>}</span> , call LDT.S to generate  $p^{</em>}(x)\\in RS[\\mathbb{L},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1]<span class="math"> . For each point  </span>a_{i}<span class="math">  in  </span>\\mathcal{I}<span class="math"> , compute  </span>h_i<span class="math">  such that  </span>p^{*}(a_{i}) = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(\\alpha l_{\\mathrm{sim}}'(a_{i})\\cdot q(a_{i}) + s_{\\mathrm{sim}}(a_{i})) - (\\alpha\\mu + S_{\\mathrm{sim}}) -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\mathbb{Z}_{\\mathbb{H}}(a_{i})h_{i}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot a_{i}}<span class="math"> . Interpolate  </span>h_i<span class="math">  to get polynomial  </span>h_{\\mathrm{sim}}<span class="math">  and sends root  </span>h_{\\mathrm{sim}}\\gets \\mathsf{MT.Commit}((h_{\\mathrm{sim}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})<span class="math">  to  </span>\\nu^{*}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Call LDT.S to simulate the view of the low degree test LDT.SV*.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7. For each index  <span class="math">i \\in \\mathcal{I}</span> , let  <span class="math">a_i</span>  be the corresponding point in  <span class="math">\\mathbb{U}</span> .  <span class="math">\\mathcal{P}</span>  opens  $(l_{\\mathrm{sim}}'(a_i), \\pi_i^{l_{\\mathrm{sim}}'}) \\gets \\mathsf{MT.Open}(i, l_{\\mathrm{sim}}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})<span class="math"> ,  </span>(h_i, \\pi_i^{h_{\\mathrm{sim}}}) \\gets \\mathsf{MT.Open}(i, h_{\\mathrm{sim}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})<span class="math">  and  </span>(s_{\\mathrm{sim}}(a_i), \\pi_i^{s_{\\mathrm{sim}}}) \\gets \\mathsf{MT.Open}(i, s_{\\mathrm{sim}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wait  <span class="math">\\mathcal{V}^*</span>  to validate the points.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9. Run  <span class="math">\\langle \\mathsf{GKR},\\mathcal{P},\\mathsf{GKR},\\mathcal{V}\\rangle (C,t)</span>  with  <span class="math">\\nu^{*}</span> , where circuit  <span class="math">C</span>  computes the evaluations of  $q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">  and outputs the elements  </span>q(a_{i})<span class="math">  for  </span>i\\in \\mathcal{I}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Wait  <span class="math">\\mathcal{V}^*</span>  for validation.</li>

    </ol>

    <p class="text-gray-300">Figure 2: Simulator  <span class="math">S</span>  of the zkVPD protocol.</p>

    <p class="text-gray-300">is  <span class="math">\\mathrm{negl}(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{l} (\\mathsf {c o m} ^ {*}, t) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\mathsf {p p}), \\\\ ((y ^ {*}, \\pi^ {*}); 1) \\leftarrow \\langle \\mathcal {A} (), \\mathsf {z k V P D . V e r i f y} (\\mathsf {c o m} ^ {*}) \\rangle (t, \\mathsf {p p}), \\\\ (f, r _ {f}) \\leftarrow \\mathcal {E} (1 ^ {\\lambda}, \\mathsf {p p}): \\\\ \\mathsf {c o m} ^ {*} \\neq \\mathsf {z k V P D . C o m m i t} (f, r _ {f}, \\mathsf {p p}) \\vee f (t) \\neq y ^ {*} \\end{array} \\right]</span></div>

    <p class="text-gray-300">Our zkVPD protocol is a proof of knowledge in the random oracle model because of the extractability of Merkle tree, as proven in [15, 66]. Informally speaking, given the root and sufficiently many authentication paths, there exists a PPT extractor that reconstructs the leaves with high probability. Additionally, in our protocol the leaves are RS encoding of the witness, which can be efficiently decoded by the extractor. We give a proof similar to [15, 66] below.</p>

    <p class="text-gray-300">Proof. Suppose the Merkle tree in our protocol is based on a random oracle  <span class="math">\\mathcal{R}:\\{0,1\\}^{2\\lambda}\\to \\{0,1\\}^{\\lambda}</span> . We could construct a polynomial extractor  <span class="math">\\mathcal{E}</span>  with the same random type of  <span class="math">\\mathcal{A}</span>  working as follows:</p>

    <p class="text-gray-300">Simulate  <span class="math">\\mathcal{A}^{\\mathcal{R}}</span> , and let  <span class="math">q_{1}, q_{2}, \\dots, q_{t}</span>  be the queries made by  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{R}</span>  in the order they are made where duplicates omitted. Define  <span class="math">q_{i} \\in \\mathcal{R}(q_{j})</span>  if the first  <span class="math">\\lambda</span>  bits or the last  <span class="math">\\lambda</span>  bits of  <span class="math">q_{i}</span>  is  <span class="math">\\mathcal{R}(q_{j})</span> . If there exist some  <span class="math">i \\neq j</span> ,  <span class="math">\\mathcal{R}(q_{i}) = \\mathcal{R}(q_{j})</span> , or some  <span class="math">i \\leq j</span> <span class="math">q_{i} \\in R(q_{j})</span> ,  <span class="math">\\mathcal{E}</span>  aborts and outputs a random string as  <span class="math">(f, r_{f})</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> constructs an acyclic directed graph <span class="math">G</span> according to the query set <span class="math">Q=\\{q_{1},q_{2},\\cdots,q_{t}\\}</span>. There is an edge from <span class="math">q_{i}</span> to <span class="math">q_{j}</span> in <span class="math">G</span> if and only if <span class="math">q_{i}\\in R(q_{j})</span>. The outdegree of each node is at most <span class="math">2</span>. When <span class="math">\\mathcal{A}</span> generates <span class="math">\\mathsf{root}_{l^{\\prime}}</span> in step <span class="math">2</span> of Protocol 3, if <span class="math">\\mathsf{root}_{l^{\\prime}}</span> does not equal <span class="math">\\mathcal{R}(q)</span> for some <span class="math">q\\in Q</span>, <span class="math">\\mathcal{E}</span> aborts and outputs a random string as <span class="math">(f,r_{f})</span>, otherwise we suppose <span class="math">\\mathcal{R}(q_{r})=\\mathsf{root}_{l^{\\prime}}</span>. If a verification path of <span class="math">\\pi^{*}</span> is not valid, <span class="math">\\mathcal{E}</span> aborts and outputs a random string as <span class="math">(f,r_{f})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\mathcal{E}</span> knows the correct depth of the Merkle tree, it could read off all leaf strings with this depth from the binary tree rooted at <span class="math">q_{r}</span>. If there exists missing leaf, <span class="math">\\mathcal{E}</span> aborts and outputs a random string as <span class="math">(f,r_{f})</span>, otherwise, it concatenates these leaf strings as $w^{\\prime}=l^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{U}}<span class="math">, and decodes </span>w=l^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{H}}<span class="math"> using an efficient Reed–Solomon decoding algorithm (such as Berlekamp–Welch). </span>\\mathcal{E}<span class="math"> could easily output </span>(f,r_{f})<span class="math"> according to </span>w$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">E_{1}</span> denote the event <span class="math">((y^{<em>},\\pi^{</em>});\\mathtt{1})\\leftarrow\\langle\\mathcal{A}(),\\mathtt{zkVPD.Verify}(\\mathsf{com}^{<em>})\\rangle(t,\\mathsf{pp})</span> and <span class="math">E_{2}</span> denote the event <span class="math">\\mathsf{com}^{</em>}\\neq\\mathtt{zkVPD.Commit}(f,r_{f},\\mathsf{pp})\\vee f(t)\\neq y^{*}</span>, next we show <span class="math">\\Pr[E_{1}\\wedge E_{2}]\\leq\\mathsf{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability that <span class="math">\\mathcal{E}</span> aborts before constructing the graph <span class="math">G</span> is <span class="math">\\mathsf{negl}(\\lambda)</span> because of the collision-resistant property of the random oracle. If some node on a verification path(possibly including the root) of the proof <span class="math">\\pi^{*}</span> does not lie in the graph <span class="math">G</span>, <span class="math">\\mathcal{A}</span> has to guess the value to construct a valid verification path, which propability is also <span class="math">\\mathsf{negl}(\\lambda)</span> since <span class="math">\\mathcal{R}</span> is noninvertible. Additionally, if one leaf of the tree is missing, then <span class="math">\\mathcal{V}</span> will be convinced with probability <span class="math">\\mathsf{negl}(\\lambda)</span> once it queries this leaf. And the probability this leaf is not be queried by <span class="math">\\mathcal{V}</span> is at most $(1-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{U}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{\\kappa}=\\mathsf{negl}(\\lambda)<span class="math"> as </span>\\kappa=O(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\mathcal{E}</span> does not abort, it could always extract some <span class="math">(f,r_{f})</span> satisfying <span class="math">\\mathsf{com}^{<em>}=\\mathtt{zkVPD.Commit}(f,r_{f},\\mathsf{pp})</span>. In this case, <span class="math">\\mathcal{V}</span> accepts the statement with probability <span class="math">\\mathsf{negl}(\\lambda)</span> if <span class="math">f(t)\\neq y^{</em>}</span> according to the soundness of zkVPD.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, $\\Pr[E_{1}\\wedge E_{2}]=\\Pr[E_{1}\\wedge E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}\\text{ aborts}]+\\Pr[E_{1}\\wedge E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}\\text{ does not abort}]\\leq\\Pr[E_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}\\text{ aborts}]+\\Pr[E_{1}\\wedge E_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{E}\\text{ does not abort}]\\leq\\mathsf{negl}(\\lambda)+\\mathsf{negl}(\\lambda)=\\mathsf{negl}(\\lambda)$ ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-20" class="text-2xl font-bold">4 Zero Knowledge Argument</h2>

    <p class="text-gray-300">Following the framework of <em>[70]</em>, we can instantiate the zkVPD in Protocol 1 with our new construction of transparent zkVPD in Protocol 3 to obtain a zero knowledge argument of knowledge scheme for layered arithmetic circuits without trusted setup. In this section, we present two optimizations to improve the asymptotic performance, followed by the formal description of the scheme.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.1 zkVPD for Input Layer</h3>

    <p class="text-gray-300">As presented in Section 2.3, to extend the GKR protocol to a zero knowledge argument, we need a zkVPD protocol for the low degree extension <span class="math">\\dot{V}_{D}</span> of polynomial <span class="math">V_{D}</span> defined by Equation 3. The variable degree of <span class="math">\\dot{V}_{D}</span> for <span class="math">x_{2},\\ldots,x_{s_{D}}</span> is <span class="math">2</span>, and the variable degree for <span class="math">x_{1}</span> is <span class="math">3</span>. Naively applying our zkVPD protocol in Section 3.1 would incur a prover time of <span class="math">O(s_{D}3^{s_{D}})</span>, superlinear in the size of the input <span class="math">n=O(2^{s_{D}})</span>.</p>

    <p class="text-gray-300">Instead, we observe that the low degree extension in Equation 3 is of a special form: it is the sum of the multilinear extension <span class="math">\\ddot{V}_{D}</span> defined by Equation 1 and <span class="math">Z_{D}(x)\\sum_{z\\in\\{0,1\\}}R_{D}(x_{1},z)</span>, where <span class="math">Z_{D}</span> is publicly known and <span class="math">\\sum_{z\\in\\{0,1\\}}R_{D}(x_{1},z)</span> is a degree-<span class="math">1</span> univariate polynomial, i.e. <span class="math">\\sum_{z\\in\\{0,1\\}}R_{D}(x_{1},z)=a_{0}+a_{1}x_{1}</span>. Therefore, the evaluation of <span class="math">\\dot{V}_{D}</span> at point <span class="math">t\\in\\mathbb{F}^{s_{D}}</span> can be modeled as the inner product between two vectors <span class="math">T</span> and <span class="math">c</span> of length <span class="math">n+2</span>. The first <span class="math">n</span> elements in <span class="math">T</span> are <span class="math">\\prod_{i=1}^{s_{D}}((1-t_{i})(1-b_{i})+t_{i}b_{i})</span> for all <span class="math">b\\in\\{0,1\\}^{s_{D}}</span>, concatenated by two more elements <span class="math">Z_{D}(t),Z_{D}(t)\\cdot t_{1}</span>. Similarly, the first <span class="math">n</span> elements of <span class="math">c</span> are <span class="math">V_{D}(b)</span> for all <span class="math">b\\in\\{0,1\\}^{s_{D}}</span>, concatenated by <span class="math">a_{0},a_{1}</span>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol 4 (Our Zero Knowledge Argument). Let  <span class="math">\\lambda</span>  be the security parameter,  <span class="math">\\mathbb{F}</span>  be a prime field. Let  <span class="math">C:\\mathbb{F}^n\\to \\mathbb{F}</span>  be a layered arithmetic circuit over  <span class="math">\\mathbb{F}</span>  with  <span class="math">D</span>  layers, input  <span class="math">x</span>  and witness  <span class="math">w</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n<span class="math">  and  </span>1 = C(x;w)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})</span> : set  <span class="math">\\mathfrak{pp}</span>  as  <span class="math">\\mathfrak{pp} \\gets \\mathsf{zkVPD}</span> . KeyGen  <span class="math">(1^{\\lambda})</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\langle \\mathcal{P}(\\mathsf{pp},w),\\mathcal{V}(\\mathsf{pp})\\rangle (\\mathsf{in})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  selects a random bivariate polynomial  <span class="math">R_{D}</span> .  <span class="math">\\mathcal{P}</span>  commits to the witness of  <span class="math">C</span>  by sending  <span class="math">\\mathsf{com}_D\\gets</span>  zkVPD.Commit  <span class="math">(\\dot{V}_D,\\mathsf{pp})</span>  to  <span class="math">\\mathcal{V}</span> , where  <span class="math">\\dot{V}_D</span>  is defined by Equation 3.</li>

      <li><span class="math">\\mathcal{P}</span>  randomly selects polynomials  <span class="math">R_{i}:\\mathbb{F}^{2}\\to \\mathbb{F}</span>  and  <span class="math">\\delta_i:\\mathbb{F}^{2s_{i + 1} + 1}\\to \\mathbb{F}</span>  for  <span class="math">i = 0,\\ldots ,D - 1</span> .  <span class="math">\\mathcal{P}</span>  commits to these polynomials by sending  <span class="math">\\mathsf{com}_{i,1}\\gets \\mathsf{zkVPD}.Commit(R_i,\\mathsf{pp})</span>  and  <span class="math">\\mathsf{com}_{i,2}\\gets \\mathsf{zkVPD}.Commit(\\delta_i,\\mathsf{pp})</span>  to  <span class="math">\\mathcal{V}</span> .  <span class="math">\\mathcal{P}</span>  also reveals  <span class="math">R_0</span>  to  <span class="math">\\mathcal{V}</span> , as  <span class="math">\\dot{V}_0</span>  is defined by out and is known to  <span class="math">\\mathcal{V}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  evaluates  <span class="math">\\dot{V}_0(u^{(0)})</span>  and  <span class="math">\\dot{V}_0(v^{(0)})</span>  for randomly chosen  <span class="math">u^{(0)},v^{(0)}\\in \\mathbb{F}^{s_0}</span></li>

      <li>For  <span class="math">i = 0,\\dots ,D - 1</span></li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathcal{P}</span>  sends  <span class="math">H_{i} = \\sum_{x,y\\in \\{0,1\\}^{s_{i + 1}},z\\in \\{0,1\\}}\\delta_{i}(x,y,z)</span>  to  <span class="math">\\mathcal{V}</span> (b)  <span class="math">\\mathcal{V}</span>  picks  <span class="math">\\alpha_{i},\\beta_{i},\\gamma_{i}</span>  randomly in  <span class="math">\\mathbb{F}</span> (c)  <span class="math">\\mathcal{V}</span>  and  <span class="math">\\mathcal{P}</span>  execute a sumcheck protocol on Equation 4. At the end of the sumcheck,  <span class="math">\\mathcal{V}</span>  receives a claim of  <span class="math">f_{i}^{\\prime}</span>  at point  <span class="math">u^{(i + 1)},v^{(i + 1)}\\in \\mathbb{F}^{s_{i + 1}},g_i\\in \\mathbb{F}</span>  selected randomly by  <span class="math">\\mathcal{V}</span> . (d)  <span class="math">\\mathcal{P}</span>  opens  <span class="math">R_{i}(u^{(i)},g_{i})</span> ,  <span class="math">R_{i}(v^{(i)},g_{i})</span>  and  <span class="math">\\delta_i(u^{(i + 1)},v^{(i + 1)},g_i)</span>  using zkVPD.Open.  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\dot{V}_0(u^{(i + 1)})</span>  and  <span class="math">\\dot{V}_0(v^{(i + 1)})</span>  to  <span class="math">\\mathcal{V}</span> . (e)  <span class="math">\\mathcal{V}</span>  validates  <span class="math">R_{i}(u^{(i)},g_{i})</span> ,  <span class="math">R_{i}(v^{(i)},g_{i})</span>  and  <span class="math">\\delta_i(u^{(i + 1)},v^{(i + 1)},g_i)</span>  using zkVPD.Verify. If any of them outputs 0, abort and output 0. (f)  <span class="math">\\mathcal{V}</span>  checks the claim of  <span class="math">f_{i}^{\\prime}</span>  using  <span class="math">R_{i}(u^{(i)},g_{i})</span> ,  <span class="math">R_{i}(v^{(i)},g_{i})</span> ,  <span class="math">\\delta_{i}(u^{(i + 1)},v^{(i + 1)},g_{i})</span> ,  <span class="math">\\dot{V}_0(u^{(i + 1)})</span>  and  <span class="math">\\dot{V}_0(v^{(i + 1)})</span> . If it fails, output 0.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  runs  <span class="math">(y_{1},\\pi_{1})\\gets \\mathsf{zkVPD}.Open(\\dot{V}_{D},u^{(D)},\\mathsf{pp})</span> <span class="math">(y_{2},\\pi_{2})\\gets \\mathsf{zkVPD}.Open(\\dot{V}_{D},v^{(D)},\\mathsf{pp})</span>  and sends  <span class="math">y_{1},\\pi_{1},y_{2},\\pi_{2}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  runs  <span class="math">\\mathrm{Verify}(\\pi_1, y_1, \\mathrm{com}_D, u^{(D)}, \\mathrm{pp})</span>  and  <span class="math">\\mathrm{Verify}(\\pi_2, y_2, \\mathrm{com}_D, v^{(D)}, \\mathrm{pp})</span>  and output 0 if either check fails. Otherwise,  <span class="math">\\mathcal{V}</span>  checks  <span class="math">\\dot{V}_D(u^{(D)}) = y_1</span>  and  <span class="math">\\dot{V}_D(v^{(D)}) = y_2</span> , and rejects if either fails. If all checks above pass,  <span class="math">\\mathcal{V}</span>  output 1.</li>

    </ol>

    <p class="text-gray-300">Therefore,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  replace vectors  <span class="math">T</span>  and  <span class="math">c</span>  in Protocol 3 by ones described above. In addition, the first part of the GKR circuit shown in Figure 1 to compute  <span class="math">T</span>  from  <span class="math">t_1, \\ldots, t_{s_D}</span>  is also changed according to the definition of  <span class="math">T</span>  above. The rest of the protocol remains the same and it is straight forward to prove that the modified protocol is still correct, sound and zero knowledge. In this way, the prover time is  <span class="math">O(n \\log n)</span> , the proof size is  <span class="math">O(\\log^2 n)</span>  and the verification time is  <span class="math">O(\\log^2 n)</span> .</p>

    <p class="text-gray-300">The second place that uses zkVPD in Protocol 1 is on the masking polynomials  <span class="math">R_{i}</span>  and  <span class="math">\\delta_{i}</span>  in each layer. By Theorem 2,  <span class="math">\\delta_{i}:\\mathbb{F}^{2s_{i + 1} + 1}\\to \\mathbb{F}</span>  is a sparse polynomial that can be expressed as the sum of  <span class="math">2s_{i + 1} + 1</span>  univariate polynomials of degree  <span class="math">\\deg (\\delta_i) = O(1)</span>  on each variable. Therefore, instead of using the generic zkVPD in Protocol 3 with  <span class="math">d = \\deg (\\delta_i)</span> , we model the evaluation of  <span class="math">\\delta_{i}</span>  as a vector inner product between two dense vectors of size  <span class="math">(\\deg (\\delta_i) + 1)\\cdot (2s_{i + 1} + 1)</span> . The vector committed by  <span class="math">\\mathcal{P}</span>  consists of all coefficients in  <span class="math">\\delta_{i}</span> , and the one known to  <span class="math">\\mathcal{V}</span>  consists of the value of each variable</p>

    <p class="text-gray-300">raised to degree <span class="math">0,1,\\ldots,\\deg(\\delta_{i})</span>. In addition, as the size of the vector is asymptotically the same as the number of variables, in step 9-10 of Protocol 3, <span class="math">\\mathcal{V}</span> can compute the evaluations of <span class="math">q(x)</span> directly in time <span class="math">O(s_{i+1})</span> and it is not necessary to delegate the computation to <span class="math">\\mathcal{P}</span> using GKR anymore. With this approach, the prover time for evaluating the masking polynomials <span class="math">R_{i}</span> and <span class="math">\\delta_{i}</span> of all layers is <span class="math">O(D\\log C\\log\\log C)</span>, the proof size is <span class="math">O(D\\log\\log^{2}C)</span> and the verification time is <span class="math">O(D\\log C)</span>. As shown in Lemma 2, this does not introduce any asymptotic overhead for the zero knowledge argument scheme.</p>

    <p class="text-gray-300">To further improve the efficiency in practice, we can also combine all the evaluations of <span class="math">R_{i}</span> and <span class="math">\\delta_{i}</span> into one big vector inner product using random linear combinations.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">4.3 Putting Everything Together</h3>

    <p class="text-gray-300">With the optimizations above, the full protocol of our transparent zero knowledge argument scheme is presented in Protocol 4. Consider the following theorem:</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">For a finite field <span class="math">\\mathbb{F}</span> and a family of layered arithmetic circuit <span class="math">\\mathcal{C}_{\\mathbb{F}}</span> over <span class="math">\\mathbb{F}</span>, Protocol 4 is a zero knowledge argument of knowledge for the relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}=\\{(C,x;w):C\\in\\mathcal{C}_{\\mathbb{F}}\\wedge C(x;w)=1\\},</span></p>

    <p class="text-gray-300">as defined in Definition 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, for every <span class="math">(C,x;w)\\in\\mathcal{R}</span>, the running time of <span class="math">\\mathcal{P}</span> is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+n\\log n)<span class="math"> field operations, where </span>n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The running time of </span>\\mathcal{V}<span class="math"> is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+D\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log^{2}n)<span class="math"> if </span>C<span class="math"> is regular with </span>D<span class="math"> layers. </span>\\mathcal{P}<span class="math"> and </span>\\mathcal{V}<span class="math"> interact </span>O(D\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds and the total communication (proof size) is </span>O(D\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log^{2}n)<span class="math">. In case </span>D<span class="math"> is </span>\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, the protocol is a succinct argument.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness follows the knowledge soundness of our zkVPD protocol (Protocol 3) and Lemma 1. To prove zero knowledge, we present the simulator in Figure 3. The efficiency follows Lemma 2 and the efficiency of our instantiations of the zkVPD protocol with optimizations described above.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness. It follows the completeness of Protocol 3 and the completeness of the GKR protocol in <em>[70]</em>.</p>

    <p class="text-gray-300">Soundness. It follows the soundness of Protocol 3 and the soundness of the GKR protocol with masking polynomials as proven in <em>[32, 70]</em>. The proof of knowledge property follows the knowledge soundness of our zkVPD protocol. In particular, the witness can be extracted using the extractor presented in Section 3. More formally speaking, our construction is an interactive oracle proof (IOP) as defined in <em>[15]</em>. Applying the transformation from IOP to an argument system using Merkle tree preserves the proof of knowledge property. Our underlying IOP is proof of knowledge as the proofs are RS codes and the witness can be efficiently extracted through decoding.</p>

    <p class="text-gray-300">Zero knowledge. The simulator is given in Figure 3. <span class="math">\\mathcal{V}^{*}</span> can behave arbitrarily in Step 3, 4(b), 4(e), 4(f) and 6. We include these steps as place holders to compare to Protocol 4.</p>

    <p class="text-gray-300">To prove zero-knowledge, Step 1, 2, 4(d) and 5 of both worlds are indistinguishable because of the zero knowledge property of the zkVPD protocol in Protocol 3. As the commitments and proofs are simulated in step 2 and 4(d) by <span class="math">\\mathcal{S}_{vpd}</span> without knowing the polynomials, Step 4(c) of both worlds are indistinguishable as shown in <em>[70, Theorem 3]</em>. Step 4(a) in both worlds are indistinguishable as <span class="math">\\delta</span> are randomly selected in both worlds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\lambda</span>  be the security parameter,  <span class="math">\\mathbb{F}</span>  be a prime field. Let  <span class="math">C:\\mathbb{F}^n\\to \\mathbb{F}</span>  be a layered arithmetic circuit over  <span class="math">\\mathbb{F}</span>  with  <span class="math">D</span>  layers, input  <span class="math">x</span>  and witness  <span class="math">w</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n<span class="math">  and out  </span>= C(x;w)<span class="math"> . We construct the simulator  </span>\\mathcal{S}<span class="math">  given the circuit  </span>C<span class="math"> , the output out and input size  </span>n<span class="math"> . Let  </span>\\mathcal{S}_{vpd},\\mathcal{S}_{vpd,R_i}<span class="math">  and  </span>\\mathcal{S}_{vpd,\\delta_i}<span class="math">  be simulators of zkVPD for the witness and masking polynomials. Let  </span>\\mathcal{S}_{sc}$  be the simulator of the sumcheck protocol on Equation 4, given by [70, Theorem 3].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda})</span> : set  <span class="math">\\mathfrak{pp}</span>  as  <span class="math">\\mathfrak{pp} \\gets \\mathsf{zkVPD}</span> . KeyGen  <span class="math">(1^{\\lambda})</span> .</li>

      <li><span class="math">(\\mathcal{S}(\\mathfrak{pp}, C, \\mathrm{out}, 1^n), \\mathcal{V}^*(C, \\mathfrak{pp}))</span> :</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S</span>  invokes  <span class="math">S_{vpd}</span>  to generate  <span class="math">\\mathsf{com} \\gets S_{vpd}(1^{\\lambda}, \\mathsf{pp})</span>  and sends  <span class="math">\\mathsf{com}</span>  to  <span class="math">\\mathcal{V}^{*}</span> .</li>

      <li><span class="math">\\mathcal{S}</span>  randomly selects polynomials  <span class="math">R_{sim,i}:\\mathbb{F}^2\\to \\mathbb{F}</span>  and  <span class="math">\\delta_{sim,i}:\\mathbb{F}^{2s_{i + 1} + 1}\\to \\mathbb{F}</span>  for  <span class="math">i = 0,\\ldots ,D - 1</span>  that have the same monomials as  <span class="math">R_{i}</span>  and  <span class="math">\\delta_{i}</span>  in step 2 of Protocol 4.  <span class="math">\\mathcal{S}</span>  invokes  <span class="math">\\mathcal{S}_{vpd,R_i}</span>  and  <span class="math">\\mathcal{S}_{vpd,\\delta_i}</span>  to generate  <span class="math">\\mathsf{com}_{i,1}\\gets \\mathcal{S}_{vpd,R_i}(1^\\lambda ,\\mathsf{pp}_{R_i})</span>  and  <span class="math">\\mathsf{com}_{i,2}\\gets \\mathcal{S}_{vpd,\\delta_i}(1^\\lambda ,\\mathsf{pp}_{\\delta_i})</span>  and send them to  <span class="math">\\nu^{<em>}</span> , where  <span class="math">\\mathsf{pp}_{R_i}</span>  and  <span class="math">\\mathsf{pp}_{\\delta_i}</span>  are corresponding public parameters.  <span class="math">\\mathcal{S}</span>  also reveals  <span class="math">R_{sim,0}</span>  to  <span class="math">\\nu</span> , as  <span class="math">V_{0}</span>  is defined by out and is known to  <span class="math">\\nu^{</em>}</span> .</li>

      <li>Wait  <span class="math">\\mathcal{V}^*</span>  to evaluate  <span class="math">\\dot{V}_0(u^{(0)})</span>  and  <span class="math">\\dot{V}_0(v^{(0)})</span>  for randomly chosen  <span class="math">u^{(0)}, v^{(0)} \\in \\mathbb{F}^{s_0}</span> .</li>

      <li>For  <span class="math">i = 0,\\dots ,D - 1</span>  ..</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">\\mathcal{S}</span>  sends  <span class="math">H_{i} = \\sum_{x,y\\in \\{0,1\\}^{s_{i + 1}},z\\in \\{0,1\\}}\\delta_{sim,i}(x,y,z)</span>  to  <span class="math">\\nu^{<em>}</span> (b) Receive  <span class="math">\\alpha_{i},\\beta_{i},\\gamma_{i}</span>  from  <span class="math">\\nu^{</em>}</span> (c)  <span class="math">\\mathcal{S}</span>  simulates the sumcheck protocol on Equation 4 using  <span class="math">\\mathcal{S}_{sc}</span> . At the end of the sumcheck,  <span class="math">\\mathcal{S}</span>  receives queries of  <span class="math">\\delta_{sim,i}</span>  and  <span class="math">R_{sim,i}</span>  at point  <span class="math">u^{(i + 1)},v^{(i + 1)}\\in \\mathbb{F}^{s_{i + 1}},g_i\\in \\mathbb{F}</span>  selected by  <span class="math">\\nu^{<em>}</span> .  <span class="math">\\mathcal{S}</span>  randomly computes  <span class="math">\\dot{V}_{i + 1}(u^{(i + 1)}),\\dot{V}_{i + 1}(v^{(i + 1)})</span>  satisfying Equation 4 at point  <span class="math">u^{(i + 1)},v^{(i + 1)},g_i</span>  and send them to  <span class="math">\\nu^{</em>}</span> . (d)  <span class="math">\\mathcal{S}</span>  computes  <span class="math">R_{sim,i}(u^{(i)},g_i)</span> ,  <span class="math">R_{sim,i}(v^{(i)},g_i)</span>  and  <span class="math">\\delta_{sim,i}(u^{(i + 1)},v^{(i + 1)},g_i)</span>  and invokes  <span class="math">\\mathcal{S}_{vpd,R_i}</span>  and  <span class="math">\\mathcal{S}_{vpd,\\delta_i}</span>  to generate the proofs of these evaluations. (e) Wait for  <span class="math">\\mathcal{V}^<em></span>  to validate  <span class="math">R_{sim,i}(u^{(i)},g_i)</span> ,  <span class="math">R_{sim,i}(v^{(i)},g_i)</span>  and  <span class="math">\\delta_{sim,i}(u^{(i + 1)},v^{(i + 1)},g_i)</span> . (f) Wait for  <span class="math">\\mathcal{V}^</em></span>  to check the last claim of the sumcheck about  <span class="math">f_i&#x27;</span>  using  <span class="math">R_{sim,i}(u^{(i)},g_i)</span> ,  <span class="math">R_{sim,i}(v^{(i)},g_i)</span> ,  <span class="math">\\delta_{sim,i}(u^{(i + 1)},v^{(i + 1)},g_i)</span> ,  <span class="math">\\dot{V}_{i + 1}(u^{(i + 1)})</span>  and  <span class="math">\\dot{V}_{i + 1}(v^{(i + 1)})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In last part of the protocol,  <span class="math">\\mathcal{S}</span>  needs to prove to  <span class="math">\\nu^{<em>}</span>  the values of  <span class="math">\\dot{V}_D(u^{(D)})</span>  and  <span class="math">\\dot{V}_D(v^{(D)})</span> , where  <span class="math">u^{(D)} \\in \\mathbb{F}^n</span>  and  <span class="math">v^{(D)} \\in \\mathbb{F}^n</span>  are chosen by  <span class="math">\\nu^{</em>}</span> .  <span class="math">\\mathcal{S}</span>  gives  <span class="math">u^{(D)}</span> ,  <span class="math">\\dot{V}_D(u^{(D)})</span>  to  <span class="math">\\mathcal{S}_{vpd}</span>  and invokes  <span class="math">\\mathcal{S}_2</span>  of  <span class="math">\\mathcal{S}_{vpd}</span>  in Figure 2 to simulate this process. Do the same process again for  <span class="math">v^{(D)}</span> ,  <span class="math">\\dot{V}_D(v^{(D)})</span> .</li>

      <li>Wait for  <span class="math">\\mathcal{V}</span>  to run zkVPD.Verify to validate the value of  <span class="math">\\dot{V}_D(u^{(D)})</span>  and  <span class="math">\\dot{V}_D(v^{(D)})</span> .</li>

    </ol>

    <p class="text-gray-300">Figure 3: Simulator  <span class="math">S</span>  of Virgo.</p>

    <p class="text-gray-300">Removing interactions. Similar to [70], our construction can be made non-interactive in the random oracle model using Fiat-Shamir heuristic [37]. As shown in recent work [15, 30], applying Fiat-Shamir on the GKR protocol only incurs a polynomial soundness loss in the number of rounds.</p>

    <p class="text-gray-300">Regular circuits and log-space uniform. In our scheme, the verification time is succinct only when the circuit is regular. This is the best that can be achieved for transparent ZKP, as in the worst case, the verifier must read the entire circuit, which takes linear time. In fact, as shown in [42], the verification time is succinct for all log-space uniform circuits. However, it introduces an extra overhead on the prover time, thus we state all of our results on regular circuits.</p>

    <p class="text-gray-300">In practice, with the help of auxiliary input and circuit squashing, most computations can be expressed as regular circuits with low depth, such as matrix multiplication, image scaling and</p>

    <p class="text-gray-300">Merkle hash tree in Section 5. Asymptotically, as shown in [9, 16, 75], all random memory access (RAM) programs can be validated by circuits that are regular with log-depth in the running time of the programs (but linear in the size of the programs) by RAM-to-circuit reduction, which justifies the expressiveness of such circuits.</p>

    <p class="text-gray-300">We implement Virgo, a zero knowledge proof system based on our construction in Section 4. The system is implemented in  <span class="math">\\mathrm{C}++</span> . There are around 700 lines of code for our transparent zkVPD protocol and 2000 lines for the GKR part.</p>

    <p class="text-gray-300">Hardware. We run all of the experiments on AMD Ryzen™ 3800X Processor with 64GB RAM. Our current implementation is not parallelized and we only use a single CPU core in the experiments. We report the average running time of 10 executions, unless specified otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One important optimization we developed during the implementation is on the choice of the underlying field. Our scheme is transparent and does not use any discrete log or bilinear pairing as in [69, 70, 72, 73]. However, there is one requirement on the finite field: in order to run the low degree test protocol in [10], either the field is an extension of  <span class="math">\\mathbb{F}_2</span> , or there exists a multiplicative subgroup of order  <span class="math">2^k</span>  in the field for large enough  <span class="math">k</span>  (one can think of  $2^k \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O(n)<span class="math"> ). Existing zero knowledge proof systems that use the LDT protocol as a building block such as Stark [9] and Aurora [14] run on the extension fields  </span>\\mathbb{F}_{2^{64}}<span class="math">  and  </span>\\mathbb{F}_{2^{192}}<span class="math"> . Modern CPUs (e.g., AMD Ryzen™ 3800X Processor) have built-in instructions for field arithmetics on these extension fields, which improves the performance of these systems significantly. However, the drawback is that the arithmetic circuits representing the statement of ZKP must also operate on the same field, and the additions (multiplications) are different from integer or modular additions (multiplications) that are commonly used in the literature. Because of this, Stark [9] has to design a special SHA-256 circuit on  </span>\\mathbb{F}_{2^{64}}$ , and Aurora [14] only reports the performance versus circuit size (number of constraints), but not on any commonly used functions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One could also use a prime field  <span class="math">p</span>  with an order-  <span class="math">2^k</span>  multiplicative subgroup. Equivalently, this requires that  <span class="math">2^k</span>  is a factor of  <span class="math">p - 1</span> . In fact, there exist many such primes and Aurora [14] also supports prime fields. However, the speed of field arithmetic is much slower than extension fields of  <span class="math">\\mathbb{F}_2</span>  (see Table 1).</p>

    <p class="text-gray-300">In this paper, we provide an alternative to achieve the best of both cases. A first attempt is to use Mersenne primes, primes that can be expressed as  <span class="math">p = 2^m - 1</span>  for integers  <span class="math">m</span> . As shown in [34, 64], multiplications modulo Mersenne primes is known to be very efficient. However, Mersenne primes do not satisfy the requirement of the LDT, as  <span class="math">p - 1 = 2^m - 2 = 2 \\cdot (2^{m-1} - 1)</span>  only has a factor  <span class="math">2^1</span> . Instead, we propose to use the extension field of a Mersenne prime  <span class="math">\\mathbb{F}_{p^2}</span> . The multiplicative</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">128-bit prime</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F264</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F2192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our field</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+</td>

            <td class="px-3 py-2 border-b border-gray-700">6.29ns</td>

            <td class="px-3 py-2 border-b border-gray-700">2.16ns</td>

            <td class="px-3 py-2 border-b border-gray-700">4.75ns</td>

            <td class="px-3 py-2 border-b border-gray-700">1.23ns</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">30.2ns</td>

            <td class="px-3 py-2 border-b border-gray-700">7.29ns</td>

            <td class="px-3 py-2 border-b border-gray-700">15.8ns</td>

            <td class="px-3 py-2 border-b border-gray-700">8.27ns</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Speed of basic arithmetic on different fields. The time is averaged over 100 million runs and is in nanosecond.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a)  <span class="math">\\mathcal{P}</span>  time</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b)  <span class="math">\\mathcal{V}</span>  time Figure 4: Comparison of our zkVPD and the pairing-based zkVPD in [72].</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (c) Proof size</p>

    <p class="text-gray-300">group of  <span class="math">\\mathbb{F}_{p^2}</span>  is a cyclic group of order  <span class="math">p^2 - 1 = (2^m - 1)^2 - 1 = 2^{2m} - 2^{m+1} = 2^{m+1}(2^{m-1} - 1)</span> , thus it has a multiplicative subgroup of order  <span class="math">2^{m+1}</span> , satisfying the requirement of LDT when  <span class="math">m</span>  is reasonably large. Meanwhile, to construct an arithmetic circuit representing the statement of the ZKP, we still encode all the values in the first slot of the polynomial ring defined by  <span class="math">\\mathbb{F}_{p^2}</span> . In this way, the additions and multiplications in the circuit are on  <span class="math">\\mathbb{F}_p</span>  and our system can take the same arithmetic circuits over prime fields in prior work. Meanwhile, the LDT, zkVPD and GKR protocol are executed on  <span class="math">\\mathbb{F}_{p^2}</span> , preserving the soundness over the whole field.</p>

    <p class="text-gray-300">With this alternative approach, we can implement modular multiplications on  <span class="math">\\mathbb{F}_{p^2}</span>  using 3 modular multiplications on  <span class="math">\\mathbb{F}_p</span> . (The modular multiplication is analogous to multiplications of complex numbers.) In our implementation, we choose Mersenne prime  <span class="math">p = 2^{61} - 1</span> , thus our system provides  <span class="math">100+</span>  bits of security. We implement modular multiplications on  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p = 2^{61} - 1</span>  with only one integer multiplication in  <span class="math">\\mathrm{C}++</span>  (two 64-bit integers to one 128-bit integer) and some bit operations. As shown in Table 1, the field arithmetic on  <span class="math">\\mathbb{F}_{p^2}</span>  is comparable to  <span class="math">\\mathbb{F}_{2^{64}}</span> ,  <span class="math">2\\times</span>  faster than  <span class="math">\\mathbb{F}_{2^{192}}</span>  and  <span class="math">4\\times</span>  faster than a 128-bit prime field. Encoding numbers in  <span class="math">\\mathbb{F}_p</span>  for  <span class="math">p = 2^{61} - 1</span>  is enough to avoid overflow for all computations used in our experiments in Section 5.2. For other computations requiring larger field, one can set  <span class="math">p</span>  as  <span class="math">2^{89} - 1, 2^{107} - 1</span>  or  <span class="math">2^{127} - 1</span> , which incurs a moderate slow down. For example, the multiplication over  <span class="math">\\mathbb{F}_{p^2}</span>  for  <span class="math">p = 2^{89} - 1</span>  is  <span class="math">2.7\\times</span>  slower than  <span class="math">p = 2^{61} - 1</span> .</p>

    <p class="text-gray-300">This optimization can also be applied to Stark [9] and Aurora [14], which use the same LDT in [10]. Currently they run on  <span class="math">\\mathbb{F}_{2^{64}}</span>  and  <span class="math">\\mathbb{F}_{2^{192}}</span>  and their performances are reported in Section 5.3. With our optimization, they can run on  <span class="math">\\mathbb{F}_{p^2}</span>  with similar efficiency while taking arithmetic circuits in  <span class="math">\\mathbb{F}_p</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we present the performance of our new transparent zkVPD protocol, and compare it with the existing approach based on bilinear maps. We use the open-source code of [70], which implements the zkVPD scheme presented in [72]. For our new zkVPD protocol, we implement the univariate sumcheck and the low degree test described in Section 2.4. We set the repetition parameter  <span class="math">\\kappa</span>  in Lemma 4 as 33, and the rate of the RS code as 32 (i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ). These parameters provide  </span>100+<span class="math">  bits of security, based on Theorem 1.2 and Conjecture 1.5 in [10], and are consistent with the implementation of Aurora [14]. In addition, we use the field  </span>\\mathbb{F}_{p^2}<span class="math">  with  </span>p = 2^{61} - 1<span class="math"> , which has a multiplicative subgroup of order  </span>2^{m + 1}<span class="math"> . Thus  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  can be as big as  </span>2^{60}<span class="math">  and the size of the witness  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is up to  </span>2^{55}<span class="math"> . We pad the size of the witness to a power of 2, which introduces an overhead of at most  </span>2\\times$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4 shows the prover time, verification time and proof size of the two schemes. We fix the variable degree of the polynomial as 1 and vary the number of variables from 12 to 20. The</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size of the multilinear polynomial is <span class="math">2^{12}</span> to <span class="math">2^{20}</span>. As shown in the figure, the prover time of our new zkVPD scheme is 8-10<span class="math">\\times</span> faster than the pairing-based one. It only takes 11.7s to generate the proof for a polynomial of size <span class="math">2^{20}</span>. This is because our new scheme does not use any heavy cryptographic operations, while the scheme in <em>[72]</em> uses modular exponentiations on the base group of a bilinear map. In terms of the asymptotic complexity, though the prover time is claimed to be linear in <em>[72]</em>, there is a hidden factor of $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> because of the exponentiations. The prover complexity of our scheme is </span>O(n\\log n)<span class="math">, which is strictly better than </span>O(n\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations. Additionally, as explained in Section 5.1, our scheme is on the extension field of a Mersenne prime, while the scheme in <em>[72]</em> is on a 254-bit prime field with bilinear maps, the basic arithmetic of which is slower.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The verification time of our zkVPD scheme is also comparable to that of <em>[72]</em>. For <span class="math">n=2^{20}</span>, it takes 12.4ms to validate the proof in our scheme, and 20.9ms in <em>[72]</em>.</p>

    <p class="text-gray-300">The drawback of our scheme is the proof size. As shown in Figure 4(c), the proof size of our scheme is 30-40<span class="math">\\times</span> larger than that of <em>[72]</em>. This is due to the opening of the commitments using Merkle tree, which is a common disadvantage of all IOP-based schemes <em>[5, 9, 14]</em>. The proof size of our scheme can be improved by a factor of <span class="math">\\log n</span> using the vector commitment scheme with constant-size proofs in <em>[20]</em>, with a compromise on the prover time. This is left as a future work.</p>

    <p class="text-gray-300">Finally, the scheme in <em>[72]</em> requires a trusted setup phase, which takes 12.6s for <span class="math">n=2^{20}</span>. We remove the trusted setup completely in our new scheme.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 Performance of Virgo</h3>

    <p class="text-gray-300">In this section, we present the performance of our ZKP scheme, Virgo, and compare it with existing ZKP systems.</p>

    <p class="text-gray-300">Methodology. We first compare with Libra <em>[70]</em>, as our scheme follows the same framework and replaces the zkVPD with our new transparent one. We use the open-source implementation and the layered arithmetic circuits at <em>[4]</em> for all the benchmarks. The circuits are generated using <em>[63]</em>.</p>

    <p class="text-gray-300">We then compare the performance of Virgo to state-of-the-art transparent ZKP systems: Ligero <em>[5]</em>, Bulletproofs <em>[28]</em>, Hyrax <em>[69]</em>, Stark <em>[9]</em> and Aurora <em>[14]</em>. We use the open-source implementations of Hyrax, Bulletproofs and Aurora at <em>[2]</em> and <em>[3]</em>. As the implementation of Aurora runs on <span class="math">\\mathbb{F}_{2^{192}}</span>, we execute the system on a random circuit with the same number of constraints. For Ligero, as the system is not open-source, we use the same number reported in <em>[5]</em> on computing hashes. For Stark, after communicating with the authors, we obtain numbers for proving the same number of hashes in the 3rd benchmark. The experiments were executed on a server with 512GB of DDR3 RAM (1.6GHz) and 16 cores (2 threads per core) at speed of 3.2GHz.</p>

    <p class="text-gray-300">Benchmarks. We evaluate the systems on three benchmarks: matrix multiplication, image scaling and Merkle tree, which are used in <em>[69, 70]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Matrix multiplication: <span class="math">\\mathcal{P}</span> proves to <span class="math">\\mathcal{V}</span> that it knows two matrices whose product equals a public matrix. We evaluate on different dimensions from <span class="math">4\\times 4</span> to <span class="math">256\\times 256</span>, and the size of the circuit is <span class="math">n^{3}</span>.</li>

      <li>Image scaling: It computes a low-resolution image by scaling from a high-resolution image. We use the classic Lanczos re-sampling <em>[65]</em> method. It computes each pixel of the output as the convolution of the input with a sliding window and a kernel function defined as: <span class="math">k(x)=\\operatorname{sinc}(x)/\\operatorname{sinc}(ax),\\operatorname{if}-a&lt;x&lt;a;k(x)=0,\\text{otherwise}</span>, where <span class="math">a</span> is the scaling parameter and</li>

    </ul>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a)  <span class="math">\\mathcal{P}</span>  time: MatMul.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b)  <span class="math">\\mathcal{P}</span>  time: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (c)  <span class="math">\\mathcal{P}</span>  time: Merkle tree</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (d)  <span class="math">\\mathcal{V}</span>  time: MatMul.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (e)  <span class="math">\\mathcal{V}</span>  time: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (f)  <span class="math">\\mathcal{V}</span>  time: Merkle tree</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (g) Proof size: MatMul.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> (h) Proof size: 16x Lanczos</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> (i) Proof size: Merkle tree Figure 5: Comparisons of prover time, proof size and verification time between Virgo and existing ZKP systems.</p>

    <p class="text-gray-300"><span class="math">\\operatorname{sinc}(x) = \\sin(x)/x</span> . We evaluate by fixing the window size as  <span class="math">16 \\times 16</span>  and increase the image size from  <span class="math">112 \\times 112</span>  to  <span class="math">1072 \\times 1072</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Merkle tree:  <span class="math">\\mathcal{P}</span>  proves to  <span class="math">\\nu</span>  that it knows the value of the leaves of a Merkle tree that computes to a public root value [19]. We use SHA-256 for the hash function. We implement it with a flat circuit where each sub-computation is one instance of the hash function. The consistency of the input and output of corresponding hashes are then checked by the circuit. There are  <span class="math">2M - 1</span>  SHA256 invocations for a Merkle tree with  <span class="math">M</span>  leaves. We increase the number of leaves from 16 to 256. The circuit size of each SHA256 is roughly  <span class="math">2^{18}</span>  gates and the size of the largest Merkle tree instance is around  <span class="math">2^{26}</span>  gates.</li>

    </ul>

    <p class="text-gray-300">Comparing to Libra. Figure 5 shows the prover time, verification time and proof size of our ZKP system, Virgo, and compares it with Libra. The prover time of Virgo is  <span class="math">7 - 10 \\times</span>  faster than Libra on the first two benchmarks, and  <span class="math">3 - 5 \\times</span>  faster on the third benchmark. The speedup comes from our new efficient zkVPD. As shown in Section 5.2, the prover time of our zkVPD is already an order of magnitude faster. Moreover, the GKR protocol for the whole arithmetic circuit must operate on the same field of the zkVPD. In Libra, it runs on a 254-bit prime field matching the base group of the bilinear map, though the GKR protocol itself is information-theoretic secure and can execute on smaller fields. This overhead is eliminated in Virgo, and both zkVPD and GKR</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ligero [5]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bulletproofs [28]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hyrax6 [69]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Stark [9]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aurora [14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Virgo</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">P time</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C + n log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">V time</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D log C + √n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D log C + log2n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D log C + √n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2C)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(D log C + log2n)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Performance of transparent ZKP systems.  <span class="math">C</span>  is the size of the regular circuit with depth  <span class="math">D</span> , and  <span class="math">n</span>  is witness size.</p>

    <p class="text-gray-300">run on our efficient extension field of Mersenne prime, resulting in an order of magnitude speedup for the whole scheme. It only takes 53.40s to generate the proof for a circuit of  <span class="math">2^{26}</span>  gates. Our improvement on the third benchmark is slightly less, as most input and values in the circuit are binary for SHA-256, which is more friendly to exponentiation used in Libra.</p>

    <p class="text-gray-300">The verification time of Virgo is also significantly improved upon Libra, leading to a speedup of  <span class="math">10 - 30 \\times</span>  in the benchmarks. This is because in Libra, the verification time of the zkVPD for the input layer is similar to that for the masking polynomials in each layer, both taking  <span class="math">O(\\log C)</span>  bilinear pairings. Thus the overall verification time is roughly  <span class="math">D</span>  times one instance of zkVPD verification. This is not the case in Virgo. As explained in the optimization in Section 4.2, we combine all the evaluations into one inner product through random linear combinations. Therefore, the verification time in Virgo is only around twice of the zkVPD verification time, ranging from 7ms to 50ms in all the benchmarks.</p>

    <p class="text-gray-300">Because of the zkVPD, the proof size of Virgo is larger than Libra. For example, Virgo generates a proof of 253KB for Merkle tree with 256 leaves, while the proof size of Libra is only 90KB. However, the gap is not as big as the zkVPD schemes themselves in Section 5.2, as the proof size of Libra is dominated by the GKR protocol of the circuit, which is actually improved by  <span class="math">2 \\times</span>  in Virgo because of the smaller field. Finally, Libra requires a one-time trusted setup for the pairing-based zkVPD, while Virgo is transparent.</p>

    <p class="text-gray-300">Comparing to other transparent ZKP Systems. Table 2 and Figure 5 show the comparison between Virgo and state-of-the-art transparent ZKP systems. As shown in Figure 5, Virgo is the best among all systems in terms of practical prover time, which is faster than others by at least an order of magnitude. The verification time of Virgo is also one of the best thanks to the succinctness of our scheme. It only takes 50ms to verify the proof of constructing a Merkle tree with 256 leaves, a circuit of size  <span class="math">2^{26}</span>  gates. The verification time is competitive to Stark, and faster than all other systems by 2 orders of magnitude. The proof size of Virgo is also competitive to other systems. It is larger than Bulletproofs [28] and is similar to Hyrax, Stark and Aurora.</p>

    <p class="text-gray-300">In particular, our scheme builds on the univariate sumcheck proposed in [14]. Compared to the system Aurora, Virgo significantly improves the prover time due to our efficient field and the fact that the univariate sumcheck is only on the witness, but not on the whole circuit. For the computation in Figure 5, the witness size is  <span class="math">16 \\times</span>  smaller than the circuit size. E.g., the witness size for one hash is around  <span class="math">2^{14}</span>  while the circuit size is  <span class="math">2^{18}</span> . In the largest instance in the figure, the witness size is  <span class="math">2^{22}</span>  while the circuit size is  <span class="math">2^{26}</span> . The verification time is also much faster as we reduce the complexity from linear to logarithmic. The proof size is similar to Aurora. Essentially the proof size is the same as that in Aurora on the same number of constraint as the witness size, plus the size of the GKR proofs in the zkVPD and for the whole circuit.</p>

    <p class="text-gray-300">6 Applications</p>

    <p class="text-gray-300">In this section, we discuss several applications of our new zkVPD and ZKP schemes.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">6.1 Verifiable Secret Sharing</h3>

    <p class="text-gray-300">Verifiable polynomial delegations (or polynomial commitments) are widely used in secret sharing to achieve malicious security. In Shamir’s secret sharing <em>[62]</em>, the secret is embedded as the constant term of a univariate polynomial <span class="math">f(x)</span>, and the shares hold by party <span class="math">i</span> is the evaluation of the polynomial <span class="math">f(i)</span>. To update the shares, in proactive secret sharing <em>[47]</em>, each party generates a random polynomial <span class="math">\\delta(x)</span> with constant term <span class="math">0</span>, and sends the evaluation of the polynomial <span class="math">\\delta(i)</span> to party <span class="math">i</span>. To prevent adversaries from changing the secret or sending inconsistent shares, the random polynomial is committed using a polynomial commitment scheme together with a proof that <span class="math">\\delta(0)=0</span>, and each evaluation to party <span class="math">i</span> comes with a proof of the polynomial evaluation. Similar mechanism is used in mobile secret sharing <em>[61]</em> to change the parties.</p>

    <p class="text-gray-300">Existing schemes mainly apply the VPD scheme in <em>[50]</em>, which requires a trusted setup phase to generate the structured reference string. In addition, the computation time to generate the proofs are high because of the use of modular exponentiation. For example, in a recent paper, Maram et al. <em>[56]</em> proposed a mobile and proactive secret sharing scheme on blockchain. As it is using the pairing-based VPD, the SRS has to be generated by a trusted party, posted on the blockchain while the trapdoor must be destroyed after the setup. Moreover, as shown in <em>[56, Figure 5]</em>, it takes 185s for each party to generate the proofs of the polynomial evaluations in each phase of the scheme for a committee of 1000 parties, which is the bottleneck of the system.</p>

    <p class="text-gray-300">Using our new VPD scheme in Protocol 2, we can completely remove the trusted setup phase of these secret sharing schemes for the first time, while maintaining the succinct proof size and verification time. Additionally, the proof generation time is significantly improved. Based on Figure 4, it will take around 11s to generate the proofs for 1000 parties. The proof size will definitely increase. However, as the proofs are sent offline among the parties in <em>[56]</em>, the overall throughput will be improved by at least an order of magnitude with reasonable bandwidth between parties.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">6.2 Privacy on Blockchain</h3>

    <p class="text-gray-300">Zero knowledge proof is widely used in blockchain systems to provide privacy for cryptocurrencies (e.g., Zcash <em>[11]</em>), smart contracts (e.g., Hawk <em>[52]</em>) and zero knowledge contingent payment <em>[29]</em>. As mentioned in the introduction, the most commonly deployed ZKP scheme, SNARK <em>[16]</em>, requires a trusted setup phase. A trusted party is usually absent in the setting of blockchains and an expensive “ceremony” <em>[13]</em> among multiple parties is usually deployed to generate the SRS. To address this issue, there are recent attempts to use transparent ZKP schemes. For example, in <em>[25]</em>, Bünz et at. proposed Zether, which uses a variant of Bulletproofs <em>[28]</em> to hide account balances and provide confidentiality for applications such as auction. However, due to the high prover time and verification time of Bulletproofs for general computations, providing full anonimity still remain impractical.</p>

    <p class="text-gray-300">As shown in Section 5.3, among all transparent ZKP schemes, Virgo achieves the best prover time and one of the best verification time, which are critical for applications of ZKP on blockchains. Compared to existing GKR-based ZKP scheme, Virgo removes the trusted setup of Libra <em>[70]</em>, and</p>

    <p class="text-gray-300">improves the verification time of both Libra and Hyrax <em>[69]</em> by 1-2 orders of magnitude. These make Virgo a good candidate to build privacy-preserving cryptocurrencies and smart contract without trusted setup. The overhead on the proof size is comparable to schemes based on IOPs, which is acceptable in scenarios such as permissioned blockchain and can be potentially reduced through proof composition <em>[17]</em>.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.3 Large Scale Zero Knowledge Proof</h3>

    <p class="text-gray-300">Other than blockchain, there are many other applications of ZKP that require proving large statements. For example, defense advanced research project agency (DARPA) recently intended to use ZKP to prove the behavior of complicated programs without leaking sensitive information <em>[1]</em>. Such applications require scaling ZKP schemes to circuits with billions of gates. The obstacles in all existing ZKP schemes are the high overhead of running time and memory consumption on the prover. In our new scheme, we completely removes the operations of modular exponentiation in Hyrax <em>[69]</em> and Libra <em>[70]</em>, which is the bottleneck of both the prover time and memory usage. Our implementation, Virgo, is purely based on symmetric-key operations, which are fast and memory friendly. As shown in the experiments, Virgo is promising to scale to large circuits and enable applications such as proving program behavior on secret data or states.</p>

    <h2 id="sec-33" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">This material is in part based upon work supported by the National Science Foundation(NSF) under Grant No. TWC-1518899, DARPA under Grant No. N66001-15-C-4066 and Center for Long-Term Cybersecurity (CLTC). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of NSF, DARPA or CLTC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Darpa sieve program. https://www.darpa.mil/news-events/2019-07-18</li>

      <li>[2] Hyrax reference implementation. https://github.com/hyraxZK/hyraxZK</li>

      <li>[3] libiop. https://github.com/scipr-lab/libiop</li>

      <li>[4] Libra implementation. https://github.com/sunblaze-ucb/fastZKP/tree/Libra</li>

      <li>[5] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2017)</li>

      <li>[6] Backes, M., Kate, A., Patra, A.: Computational verifiable secret sharing revisited. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 590–609. Springer (2011)</li>

      <li>[7] Baum, C., Bootle, J., Cerulli, A., Del Pino, R., Groth, J., Lyubashevsky, V.: Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In: Annual International Cryptology Conference. pp. 669–699. Springer (2018)</li>

      <li>[8] Bayer, S., Groth, J.: Efficient zero-knowledge argument for correctness of a shuffle. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 263–280. Springer (2012)</li>

      <li>[9] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint, 2018</li>

      <li>[10] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Fast reed-solomon interactive oracle proofs of proximity. In: 45th International Colloquium on Automata, Languages, and Programming (ICALP 2018). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik (2018)</li>

      <li>[11] Ben-Sasson, E., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zero-cash: Decentralized anonymous payments from bitcoin. In: Proceedings of the Symposium on Security and Privacy SP, 2014 (2014)</li>

      <li>[12] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: Verifying program executions succinctly and in zero knowledge. In: CRYPTO 2013</li>

      <li>[13] Ben-Sasson, E., Chiesa, A., Green, M., Tromer, E., Virza, M.: Secure sampling of public parameters for succinct zero knowledge proofs. In: 2015 IEEE Symposium on Security and Privacy. pp. 287–304. IEEE (2015)</li>

      <li>[14] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent Succinct Arguments for R1CS. Cryptology ePrint, 2018</li>

      <li>[15] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: Theory of Cryptography Conference. pp. 31–60. Springer (2016)</li>

      <li>[16] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Succinct Non-Interactive Zero Knowledge for a von Neumann Architecture. In: Proceedings of the USENIX Security Symposium, 2014</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[17] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO 2014, pp. 276–294 (2014)</li>

      <li>[18] Benabbas, S., Gennaro, R., Vahlis, Y.: Verifiable delegation of computation over large datasets. In: CRYPTO 2011. pp. 111–131</li>

      <li>[19] Blum, M., Evans, W., Gemmell, P., Kannan, S., Naor, M.: Checking the correctness of memories. Algorithmica 12(2-3), 225–244 (1994)</li>

      <li>[20] Boneh, D., Bünz, B., Fisch, B.: Batching techniques for accumulators with applications to iops and stateless blockchains. Tech. rep., Cryptology ePrint Archive, Report 2018/1188, Tech. Rep (2018)</li>

      <li>[21] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: International Conference on the Theory and Applications of Cryptographic Techniques (2016)</li>

      <li>[22] Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajjabadi, M., Jakobsen, S.K.: Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 336–365. Springer (2017)</li>

      <li>[23] Bowe, S., Chiesa, A., Green, M., Miers, I., Mishra, P., Wu, H.: Zexe: Enabling decentralized private computation. Cryptology ePrint Archive, Report 2018/962 (2018), https://eprint.iacr.org/2018/962</li>

      <li>[24] Braun, B., Feldman, A.J., Ren, Z., Setty, S.T.V., Blumberg, A.J., Walfish, M.: Verifying computations with state. In: ACM SIGOPS 24th Symposium on Operating Systems Principles, SOSP, 2013</li>

      <li>[25] Bünz, B., Agrawal, S., Zamani, M., Boneh, D.: Zether: Towards privacy in a smart contract world. IACR Cryptology ePrint Archive 2019, 191 (2019)</li>

      <li>[26] Bünz, B., Fisch, B., Szepieniec, A.: Transparent snarks from dark compilers. Cryptology ePrint Archive, Report 2019/1229 (2019), https://eprint.iacr.org/2019/1229</li>

      <li>[27] Byott, N.P., Chapman, R.J.: Power sums over finite subspaces of a field. Finite Fields and Their Applications 5(3), 254–265 (1999)</li>

      <li>[28] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: Proceedings of the Symposium on Security and Privacy (SP), 2018. vol. 00, pp. 319–338</li>

      <li>[29] Campanelli, M., Gennaro, R., Goldfeder, S., Nizzardo, L.: Zero-knowledge contingent payments revisited: Attacks and payments for services. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. pp. 229–243. ACM (2017)</li>

      <li>[30] Canetti, R., Chen, Y., Holmgren, J., Lombardi, A., Rothblum, G.N., Rothblum, R.D.: Fiatshamir from simpler assumptions. Cryptology ePrint Archive, Report 2018/1004 (2018)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[31] Chase, M., Derler, D., Goldfeder, S., Orlandi, C., Ramacher, S., Rechberger, C., Slamanig, D., Zaverucha, G.: Post-quantum zero-knowledge and signatures from symmetric-key primitives. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. pp. 1825–1842. ACM (2017)</li>

      <li>[32] Chiesa, A., Forbes, M.A., Spooner, N.: A Zero Knowledge Sumcheck and its Applications. CoRR abs/1704.02086 (2017), http://arxiv.org/abs/1704.02086</li>

      <li>[33] Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C.: Introduction to Algorithms, Third Edition. The MIT Press, 3rd edn. (2009)</li>

      <li>[34] Cormode, G., Mitzenmacher, M., Thaler, J.: Practical Verified Computation with Streaming Interactive Proofs. In: Proceedings of the 3rd Innovations in Theoretical Computer Science Conference. ITCS ’12</li>

      <li>[35] Costello, C., Fournet, C., Howell, J., Kohlweiss, M., Kreuter, B., Naehrig, M., Parno, B., Zahur, S.: Geppetto: Versatile verifiable computation. In: S&P 2015</li>

      <li>[36] Cramer, R., Damgård, I.: Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In: Annual International Cryptology Conference, 1998</li>

      <li>[37] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: Crypto 1986</li>

      <li>[38] Fiore, D., Fournet, C., Ghosh, E., Kohlweiss, M., Ohrimenko, O., Parno, B.: Hash first, argue later: Adaptive verifiable computations on outsourced data. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2016)</li>

      <li>[39] Fiore, D., Gennaro, R.: Publicly verifiable delegation of large polynomials and matrix computations, with applications. In: CCS 2012. pp. 501–512</li>

      <li>[40] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT 2013. pp. 626–645 (2013)</li>

      <li>[41] Giacomelli, I., Madsen, J., Orlandi, C.: Zkboo: Faster zero-knowledge for boolean circuits. In: USENIX Security Symposium. pp. 1069–1083 (2016)</li>

      <li>[42] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating Computation: Interactive Proofs for Muggles. J. ACM 62(4), 27:1–27:64 (Sep 2015)</li>

      <li>[43] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on computing 18(1), 186–208 (1989)</li>

      <li>[44] Groth, J.: Linear algebra with sub-linear zero-knowledge arguments. In: Advances in Cryptology-CRYPTO 2009, pp. 192–208. Springer (2009)</li>

      <li>[45] Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: International Conference on the Theory and Application of Cryptology and Information Security. pp. 321–340. Springer (2010)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[46] Groth, J., Kohlweiss, M., Maller, M., Meiklejohn, S., Miers, I.: Updatable and universal common reference strings with applications to zk-snarks. In: Annual International Cryptology Conference. pp. 698–728. Springer (2018)</li>

      <li>[47] Herzberg, A., Jarecki, S., Krawczyk, H., Yung, M.: Proactive secret sharing or: How to cope with perpetual leakage. In: Annual International Cryptology Conference. pp. 339–352. Springer (1995)</li>

      <li>[48] Ishai, Y., Kushilevitz, E., Ostrovsky, R.: Efficient arguments without short pcps. In: 22nd Annual IEEE Conference on Computational Complexity (CCC 2007)</li>

      <li>[49] Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure multiparty computation. In: Proceedings of the annual ACM symposium on Theory of computing. pp. 21–30. ACM (2007)</li>

      <li>[50] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: ASIACRYPT 2010. pp. 177–194</li>

      <li>[51] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: Proceedings of the ACM Symposium on Theory of Computing (1992)</li>

      <li>[52] Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In: Proceedings of Symposium on security and privacy (SP), 2016</li>

      <li>[53] Lipmaa, H.: Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In: Theory of Cryptography Conference (2012)</li>

      <li>[54] Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic Methods for Interactive Proof Systems. J. ACM 39(4), 859–868 (Oct 1992)</li>

      <li>[55] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge snarks from linear-size universal and updateable structured reference strings. Cryptology ePrint Archive, Report 2019/099 (2019), https://eprint.iacr.org/2019/099</li>

      <li>[56] Maram, S.K.D., Zhang, F., Wang, L., Low, A., Zhang, Y., Juels, A., Song, D.: Churp: Dynamic-committee proactive secret sharing. Cryptology ePrint Archive, Report 2019/017 (2019), https://eprint.iacr.org/2019/017</li>

      <li>[57] Merkle, R.C.: A certified digital signature. In: CRYPTO 1989. pp. 218–238</li>

      <li>[58] Micali, S.: Computationally sound proofs. SIAM J. Comput. (2000)</li>

      <li>[59] Papamanthou, C., Shi, E., Tamassia, R.: Signatures of correct computation. In: TCC 2013. pp. 222–242 (2013)</li>

      <li>[60] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: S&P 2013. pp. 238–252 (2013)</li>

      <li>[61] Schultz, D.A., Liskov, B., Liskov, M.: Mobile proactive secret sharing. In: Proceedings of the twenty-seventh ACM symposium on Principles of distributed computing. pp. 458–458. ACM (2008)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[62] Shamir, A.: How to share a secret. Communications of the ACM 22(11), 612–613 (1979)</li>

      <li>[63] Tange, O.: Gnu parallel - the command-line power tool. The USENIX Magazine 36(1), 42–47 (Feb 2011), http://www.gnu.org/s/parallel</li>

      <li>[64] Thaler, J.: Time-Optimal Interactive Proofs for Circuit Evaluation. In: Canetti, R., Garay, J.A. (eds.) Advances in Cryptology – CRYPTO 2013 (2013)</li>

      <li>[65] Turkowski, K.: Filters for common resampling tasks. In: Graphics gems. pp. 147–165. Academic Press Professional, Inc. (1990)</li>

      <li>[66] Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: Theory of Cryptography Conference. pp. 1–18. Springer (2008)</li>

      <li>[67] Wahby, R.S., Ji, Y., Blumberg, A.J., Shelat, A., Thaler, J., Walfish, M., Wies, T.: Full accounting for verifiable outsourcing. In: Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM (2017)</li>

      <li>[68] Wahby, R.S., Setty, S.T., Ren, Z., Blumberg, A.J., Walfish, M.: Efficient ram and control flow in verifiable outsourced computation. In: NDSS (2015)</li>

      <li>[69] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy (SP). pp. 926–943. IEEE (2018)</li>

      <li>[70] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Advances in Cryptology (CRYPTO) (2019)</li>

      <li>[71] Yuan, J., Yu, S.: Proofs of retrievability with public verifiability and constant communication cost in cloud. In: Proceedings of the 2013 international workshop on Security in cloud computing. pp. 19–26. ACM (2013)</li>

      <li>[72] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A Zero-Knowledge version of vSQL. Cryptology ePrint, 2017</li>

      <li>[73] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: IEEE Symposium on Security and Privacy (S&P) 2017 (2017)</li>

      <li>[74] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: Security and Privacy (SP), 2017 IEEE Symposium on. pp. 863–880. IEEE (2017)</li>

      <li>[75] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vRAM: Faster verifiable RAM with program-independent preprocessing. In: Proceeding of IEEE Symposium on Security and Privacy (S&P) (2018)</li>

    </ul>

    <p class="text-gray-300">34</p>

    <p class="text-gray-300">The protocol of the univariate sumcheck in [14] is in Protocol 5. We have the following lemma:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5.</strong> Let <span class="math">f: \\mathbb{F} \\to \\mathbb{F}</span> be a univariate polynomial with degree less than <span class="math">k</span> and <span class="math">\\mathbb{H} \\subseteq \\mathbb{L} \\subseteq \\mathbb{F}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; k<span class="math">. Protocol 5 is an interactive proof to prove </span>\\mu = \\sum_{a \\in \\mathbb{H}} f(a)<span class="math"> with soundness </span>O\\left(\\frac{\\mathbb{L}}{\\mathbb{F}} + \\mathrm{negl}(\\kappa)\\right)<span class="math">. The proof size and the verification time are </span>O\\left(\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)<span class="math"> and the prover time is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Protocol 5 (Univariate Sumcheck).</strong> Let <span class="math">f</span> be a degree <span class="math">k</span> univariate polynomial on <span class="math">\\mathbb{F}</span> with degree less than <span class="math">k</span> and <span class="math">\\mathbb{H}, \\mathbb{L}</span> be a multiplicative coset of <span class="math">\\mathbb{F}</span> such that <span class="math">\\mathbb{H} \\subset \\mathbb{L} \\subset \\mathbb{F}</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; k<span class="math">. To prove </span>\\mu = \\sum_{a \\in \\mathbb{H}} f(a)$, a univariate sumcheck protocol has the following algorithms.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SC.com <span class="math">\\leftarrow</span> SC.Commit(f):</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\mathcal{P}</span> computes polynomial <span class="math">h</span> such that <span class="math">f(x) = g(x) + Z_{\\mathbb{H}}(x) \\cdot h(x)</span>. <span class="math">\\mathcal{P}</span> evaluates of $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}<span class="math"> and </span>h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbb{L}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\langle \\mathrm{SC.Prove}(f), \\mathrm{SC.Verify}(\\mathrm{com}, \\mu) \\rangle</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Let $p(x) = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f(x) - \\mu -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathbb{Z}_{\\mathbb{H}}(x)h(x)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot x}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. For each index <span class="math">i \\in \\mathcal{I}</span>, <span class="math">\\mathcal{P}</span> opens MT.Open(i, f</td>

            <td class="px-3 py-2 border-b border-gray-700">_L) and MT.Open(i, h</td>

            <td class="px-3 py-2 border-b border-gray-700">_L).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span> executes MT.Verify for all points opened by <span class="math">\\mathcal{P}</span>. If any verification fails, abort and output 0.</li>

      <li><span class="math">\\mathcal{V}</span> completes the low degree test with these points. If all checks above pass, <span class="math">\\mathcal{V}</span> outputs 1.</li>

    </ol>`;
---

<BaseLayout title="Transparent Polynomial Delegation and Its Applications to Ze... (2019/1482)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1482
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
