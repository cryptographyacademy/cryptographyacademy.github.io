---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/419';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Adapting Coppersmith&#x27;s &quot;Factorization Factory&quot; to the Function Field Sieve';
const AUTHORS_HTML = 'Jérémie Detrey';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold">FFS Factory:</h2>

    <p class="text-gray-300">Jérémie Detrey</p>

    <p class="text-gray-300">CARAMEL project-team, LORIA, INRIA / CNRS / Université de Lorraine, Campus Scientifique, BP 239, 54506 Vandœuvre-lès-Nancy Cedex, France <a href="mailto:Jeremie.Detrey@loria.fr">Jeremie.Detrey@loria.fr</a></p>

    <p class="text-gray-300">Abstract. In 1993, Coppersmith introduced the &quot;factorization factory&quot; approach as a means to speed up the Number Field Sieve algorithm (NFS) when factoring batches of integers of similar size: at the expense of a large precomputation whose cost is amortized when considering sufficiently many integers to factor, the complexity of each individual factorization can then be lowered.</p>

    <p class="text-gray-300">We suggest here to extend this idea to the computation of discrete logarithms in finite fields of small characteristic using the Function Field Sieve (FFS), thus referring to this approach as the &quot;FFS factory&quot;. In this paper, the benefits of the proposed technique are established thanks to both a theoretical complexity analysis along with a practical experiment in which we solved the discrete logarithm problem in fifty different binary fields of sizes ranging from 601 to 699 bits.</p>

    <p class="text-gray-300">Keywords: Discrete logarithm, Function field sieve, Cryptanalysis</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Initially introduced in 1994 by Adleman <a href="#page-14-0">[2]</a>, the Function Field Sieve (FFS) has been for almost twenty years the most efficient algorithm known for computing discrete logarithms in the multiplicative subgroup of finite fields F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; , with a subexponential asymptotic complexity of L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, p3 32/9)1+o(1), where the notation Lq &lt;sup&gt;k&lt;/sup&gt; designates the usual function</p>

    <p class="text-gray-300"><span class="math">$L_N(\\alpha,c) = \\exp\\left(c(\\log N)^\\alpha(\\log\\log N)^{1-\\alpha}\\right), \\quad \\text{with } 0 \\le \\alpha \\le 1 \\text{ and } c &gt; 0.</span>$</p>

    <p class="text-gray-300">However, the year 2013 was marked by several successive major theoretical improvements on this algorithm by Göloğlu et al. <a href="#page-15-0">[14]</a>, Joux <a href="#page-15-1">[23]</a>, and finally Barbulescu et al. <a href="#page-14-1">[8]</a>, which eventually brought the asymptotic complexity of solving the discrete logarithm problem over fields of small characteristic down to quasi-polynomial time. These breakthroughs were accompanied by many computations of discrete logarithms in record-sized binary and ternary fields <a href="#page-15-2">[20,</a><a href="#page-15-0">14</a><a href="#page-15-3">,21,</a><a href="#page-15-4">15,</a><a href="#page-15-5">22,</a><a href="#page-15-6">16,</a><a href="#page-14-2">1]</a>. Nevertheless, finding the exact crossing point between FFS and these recent algorithms, especially when it comes to fields of prime extension degrees, is still an active research topic <a href="#page-14-3">[5]</a>.</p>

    <p class="text-gray-300">Furthermore, software implementations of FFS (or at least of the descent step) are now publicly available, either as standalone software packages such as in the cado-nfs distribution <a href="#page-14-4">[4]</a>, or as part of computer algebra systems such as Magma <a href="#page-14-5">[10]</a>. Therefore, providing such software with the precomputed discrete logarithms of factor bases for various finite fields should definitely make their job easier when computing individual logarithms in these fields. For instance, the release notes of Magma V2.20 state that &quot;The database of logarithms is continually being extended and now includes data for larger fields. In particular, the fields GF(2&lt;sup&gt;d&lt;/sup&gt; ) are now covered for all prime degree d ≤ 509 and most degrees up to 500&quot; <a href="#page-14-6">[9]</a>.</p>

    <p class="text-gray-300">Bearing in mind this motivation of computing discrete logarithms in several finite fields, we propose in this paper the so-called &quot;FFS factory&quot;, whose key idea is to share as much of the computation as possible amongst the considered finite fields in order to decrease the overall computation cost when compared to running as many independent instances of FFS.</p>

    <p class="text-gray-300">This approach is directly inspired from Coppersmith's &quot;factorization factory&quot; <a href="#page-14-7">[12]</a>, which can be used to accelerate the factorization of many integers of the same size using the Number Field Sieve (NFS), thus bringing the original complexity of NFS from L&lt;sup&gt;N&lt;/sup&gt; (1/3, 1.923)1+o(1) down to L&lt;sup&gt;N&lt;/sup&gt; (1/3, 1.639)1+o(1) for each integer N to be factored. A similar modification of NFS, known as the &quot;discrete logarithm factory&quot;, was later presented by Barbulescu in order to batch discrete logarithm computations over finite fields of large characteristic <a href="#page-14-8">[6,</a> Section 7.2].</p>

    <p class="text-gray-300">However, since both of the above cases are based on NFS, they can only share the computations on the so-called rational side of the algorithm. What we propose here is to leverage the fact that the polynomial selection is far less constrained in the FFS setting in order to share the computations on the algebraic side instead. It is to be noted that this idea was first suggested by Kleinjung in the context of factoring using the Special Number Field Sieve (SNFS) <a href="#page-15-7">[24]</a>, which is in many ways quite similar to FFS.</p>

    <p class="text-gray-300">Roadmap. This paper is organized as follows. After a presentation on the Function Field Sieve in Section <a href="#page-2-0">2,</a> with a special emphasis on its complexity analysis, Section <a href="#page-7-0">3</a> details the algorithmic and complexity aspects of the proposed FFS factory approach before discussing its applicability. A practical experiment, involving the computation of discrete logarithms in 50 binary finite fields of size between 601 and 699 bits, is then presented in Section <a href="#page-11-0">4,</a> before some concluding remarks in Section <a href="#page-13-0">5.</a></p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;2 Remainder on the Function Field Sieve</h4>

    <p class="text-gray-300">In the following, we let q be a prime power and k a positive integer, and assume that we want to compute discrete logarithms in the multiplicative subgroup of the finite field  <span class="math">\\mathbb{F}_{q^k}</span> . In other words, for any two elements g and  <span class="math">h \\in \\mathbb{F}_{q^k}^{\\times}</span> , with g primitive, we want to find the integer  <span class="math">\\lambda \\in \\mathbb{Z}/(q^k-1)\\mathbb{Z}</span>  such that  <span class="math">h=g^{\\lambda}</span> .</p>

    <p class="text-gray-300">Note that, in order to fall into the domain of applicability of FFS, we further require that  <span class="math">q = L_{q^k}(\\alpha, c)</span>  with  <span class="math">0 \\le \\alpha &lt; 1/3</span>  and c &gt; 0. In practice, q will usually be a small prime (such as 2) or a small power thereof.</p>

    <p class="text-gray-300">As the Function Field Sieve belongs to the family of <em>index calculus</em> algorithms for computing discrete logarithms, it follows the same basic three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The relation collection step, whose goal is to find many multiplicative equalities, or relations, involving only elements from a predefined subset of  <span class="math">\\mathbb{F}_{q^k}</span> , called the factor base. Taking the logarithm, each such relation becomes a linear equation modulo  <span class="math">q^k-1</span> , whose unknowns are the discrete logarithms of the factor base elements.</li>
      <li>The linear algebra step, which solves the linear system once enough such relations have been found, and therefore recovers the value of the discrete logarithms of the factor base elements.</li>
      <li>The individual logarithm step, which computes the discrete logarithm of an arbitrary element  <span class="math">h \\in \\mathbb{F}_{q^k}^{\\times}</span>  by finding a multiplicative relation involving only h and factor base elements.</li>
    </ul>

    <p class="text-gray-300">Further details on how these three tasks are achieved in FFS are given in the following paragraphs, before a careful complexity analysis in Section 2.4. However, we do not claim here to give an exhaustive nor comprehensive description of FFS, but rather to focus on a few key points which will prove useful in the rest of this paper. For more information on this topic, we refer the interested reader to the original theoretical foundations of FFS by Adleman and Adleman &amp; Huang [2,3] along with the later improvements by Matsumoto and Joux &amp; Lercier [26,19].</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 Relation collection</h4>

    <p class="text-gray-300">commutative:</p>

    <p class="text-gray-300">Let d &gt; 1 be an integer, and let  <span class="math">f(x,t) \\in \\mathbb{F}_q[t][x]</span>  be a monic, bivariate polynomial of degree d in x. Note that, for our purposes, the degree in t of f can be made as small as possible&lt;sup&gt;1&lt;/sup&gt;. Let now  <span class="math">g(x,t) \\in \\mathbb{F}_q[t][x]</span>  be a linear polynomial such that its resultant in x with f has an irreducible factor  <span class="math">\\varphi(t)</span>  of degree k. Since, by construction, f has coefficients of small degree in t, this implies that  <span class="math">\\deg_t g \\approx k/d</span> .</p>

    <p class="text-gray-300">In the following, we denote by  <span class="math">F(X,Y,t) = Y^d \\cdot f(X/Y,t)</span>  and  <span class="math">G(X,Y,t) = Y \\cdot g(X/Y,t)</span>  the homogenizations in x of the polynomials f and g, respectively. Given the above choice of polynomials, the target finite field  <span class="math">\\mathbb{F}_{q^k}</span>  is therefore isomorphic to the extension field  <span class="math">\\mathbb{F}_q[t]/(\\varphi(t))</span> , and the following diagram is</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt; Selecting good polynomials for FFS is a non-trivial task, but it does not fall into the scope of this paper. For more details about this point, please refer to [7].</p>

    <p class="text-gray-300">    <img src="_page_3_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">The core idea behind the relation collection step in FFS, also known as the sieving step, is to consider elements of Fq[t][x] and to map them down to F&lt;sup&gt;q&lt;/sup&gt; k through both sides of the diagram, factoring the corresponding principal ideals in the ring of integers of the function fields Fq(t)[x]/(f(x, t)) and Fq(t)[x]/(g(x, t)) along the way.</p>

    <p class="text-gray-300">In this sieving step, we then consider all the pairs of polynomials (r(t), s(t)) ∈ (Fq[t])&lt;sup&gt;2&lt;/sup&gt; where r is monic and both are of degree at most e, where e is a parameter called the sieving bound. Given a second parameter b, referred to as the smoothness bound, we then push each polynomial r(t) − s(t)x ∈ Fq[t][x] through the above diagram, and try to factor the corresponding principal ideals in the ring of integers of the function fields Fq(t)[x]/(f(x, t)) and Fq(t)[x]/(g(x, t)) as products of prime ideals whose norms are of degree at most b. If such a factorization succeeds on both sides, then the pair (r, s) is called doubly-b-smooth. Mapping both factorizations to F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; thanks to the two lower maps of the diagram then yields a relation, that is a multiplicative equality between elements of the factor base, which is defined as the set of those elements of F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; that correspond to prime ideals whose norms have degree at most b in the function fields above.</p>

    <p class="text-gray-300">On the left-hand side of the diagram (also known as the algebraic side), the principal ideal corresponding to an element r(t) − s(t)x factors as a product of prime ideals whose norms have degree at most b in the ring of integers of the function field Fq(t)[x]/(f(x, t)) if and only if the norm of this principal ideal itself factors as a product of irreducible polynomials of degree at most b. The same obviously holds for the right-hand side as well (also known as the rational side). Therefore, checking if a pair (r, s) from the sieving domain if doubly-b-smooth is tantamount to checking if the norms of the corresponding principal ideals, namely the polynomials F(r, s, t) and G(r, s, t) ∈ Fq[t], both factor as products of irreducible polynomials of degree at most b.</p>

    <p class="text-gray-300">Therefore, collecting relations in FFS is just a matter of enumerating all pairs (r, s) in the sieving domain, computing their norms F(r, s, t) and G(r, s, t), and marking each of them as a valid relation if both norms are indeed b-smooth. Of course, the parameters d, e and b should be carefully chosen so that this step finds enough relations in order to solve the corresponding linear system.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Linear algebra</h3>

    <p class="text-gray-300">All the relations collected in the previous step form a large linear system modulo q &lt;sup&gt;k&lt;/sup&gt; − 1, the order of the multiplicative subgroup of F&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; . However, this linear system is very sparse, thus allowing for efficient methods such as Lanczos' or Wiedemann's algorithms [25]: given a sparse matrix of N rows and columns, with an average of  <span class="math">\\omega</span>  non-zero coefficients per row, such algorithms can indeed solve the corresponding linear system in time  <span class="math">O(\\omega N^2)</span> , which is more efficient than classical Gaussian elimination algorithms running in  <span class="math">O(N^3)</span> .</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">2.3 Individual logarithms</h4>

    <p class="text-gray-300">Let h be an arbitrary element of  <span class="math">\\mathbb{F}_{q^k}^{\\times}</span> . Since  <span class="math">\\mathbb{F}_{q^k} \\cong \\mathbb{F}_q[t]/(\\varphi(t))</span> , h can be seen as a polynomial in t of degree less than k. The discrete logarithm of h then can be computed in two main steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The <em>smoothing</em> step, in which one tries to find an element of the factor base, whose norm we denote as  <span class="math">\\theta(t)</span> , along with an exponent m such that the polynomial  <span class="math">\\theta(t)^m h(t) \\mod \\varphi(t)</span>  is  <span class="math">b_0</span> -smooth, with  <span class="math">b_0 = \\sqrt{kb}</span> .</li>
      <li>The special-q descent: given a prime ideal  <span class="math">\\mathfrak{q}</span>  (on either the algebraic or the rational side of the diagram) whose norm is of degree  <span class="math">d_{\\mathfrak{q}}</span> , with  <span class="math">b &lt; d_{\\mathfrak{q}} \\leq b_0</span> , we denote by  <span class="math">\\Lambda_{\\mathfrak{q}}</span>  the set of (r,s) pairs in  <span class="math">(\\mathbb{F}_q[t])^2</span>  such that the principal ideal corresponding to r(t) s(t)x (on the same side of the diagram) is divisible by  <span class="math">\\mathfrak{q}</span> . It can be remarked that  <span class="math">\\Lambda_{\\mathfrak{q}}</span>  forms an  <span class="math">\\mathbb{F}_q[t]</span> -lattice of dimension 2. A basis of  <span class="math">\\Lambda_{\\mathfrak{q}}</span>  is then obtained thanks to Gaussian lattice reduction, which yields two vectors  <span class="math">(r_1(t), s_1(t))</span>  and  <span class="math">(r_2(t), s_2(t))</span> , the degree of whose coefficients  <span class="math">r_1, s_1, r_2</span>  and  <span class="math">s_2</span>  is approximately  <span class="math">d_{\\mathfrak{q}}/2</span> .</li>
    </ul>

    <p class="text-gray-300">Similarly to the sieving phase, we fix a parameter e' and enumerate all pairs of polynomials  <span class="math">(i(t),j(t))\\in (\\mathbb{F}_q[t])^2</span>  where i is monic and both are of degree at most e'. For each such pair, we then consider the element  <span class="math">(ir_1+jr_2,is_1+js_2)\\in A_{\\mathfrak{q}}</span>  and try to factor the corresponding norms  <span class="math">F(ir_1+jr_2,is_1+js_2,t)</span>  and  <span class="math">G(ir_1+jr_2,is_1+js_2,t)</span>  as products of irreducible polynomials of degree at most b', with the smoothness bound  <span class="math">b&#x27;=\\lambda d_{\\mathfrak{q}}</span>  and the descent parameter  <span class="math">\\lambda&lt;1</span> . One such doubly-b'-smooth pair will then give us a linear relation between the discrete logarithm of  <span class="math">\\mathfrak{q}</span>  and that of several prime ideals whose norms have degree at most b'.</p>

    <p class="text-gray-300">We finally iterate the process recursively until we end up considering only prime ideals whose norms have degree at most b, that is, elements of the factor base, whose discrete logarithms were already computed in the linear algebra step.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;2.4 Complexity analysis</h4>

    <p class="text-gray-300">In order to lay the groundwork for the study of the proposed FFS factory algorithm in Section 3.2, we recall here the complexity analysis of the Function Field Sieve presented in the previous subsections, following the notations of Barbulescu [6, Section 7.5], which are also that of Coppersmith [12] in the case of the Number Field Sieve.</p>

    <p class="text-gray-300">To that intent, let us first introduce the positive constants  <span class="math">\\delta</span> ,  <span class="math">\\varepsilon</span> , and  <span class="math">\\beta</span>  so as to define the degree d of f(x,t), the sieving bound e, and the smoothness bound</p>

    <p class="text-gray-300">b as follows:</p>

    <p class="text-gray-300"><span class="math">$d = \\delta \\left( \\frac{k \\log q}{\\log k} \\right)^{1/3}, \\quad e = \\varepsilon \\frac{k^{1/3} (\\log k)^{2/3}}{(\\log q)^{2/3}}, \\quad \\text{and} \\quad b = \\beta \\frac{k^{1/3} (\\log k)^{2/3}}{(\\log q)^{2/3}}.</span>$</p>

    <p class="text-gray-300">Sieving and linear algebra. Given a pair (r, s) of polynomials in the sieving range (i.e., both of degree at most e and r monic), we then denote by P&lt;sup&gt;f&lt;/sup&gt; and P&lt;sup&gt;g&lt;/sup&gt; the probabilities that the corresponding norms F(r, s, t) and G(r, s, t) are b-smooth, respectively. The degrees of these norms can be bounded by</p>

    <p class="text-gray-300"><span class="math">$\\deg F(r,s,t) \\leq \\deg_t f + de \\approx de = \\delta \\varepsilon \\frac{k^{2/3} (\\log k)^{1/3}}{(\\log q)^{1/3}} \\qquad \\qquad (\\text{since } f \\text{ has small coefficients}) \\text{ and } \\deg G(r,s,t) \\leq \\deg_t g + e \\approx k/d = \\frac{1}{\\delta} \\frac{k^{2/3} (\\log k)^{1/3}}{(\\log q)^{1/3}} \\qquad (\\text{since } \\deg_t g \\approx k/d \\text{ dominates } e).</span>$</p>

    <p class="text-gray-300">Assuming that these norms behave like random polynomials of the same degree, following <a href="#page-15-11">[27]</a>, we then estimate the probabilities that they are b-smooth as</p>

    <p class="text-gray-300"><span class="math">$P_f = u^{-u(1+o(1))} \\quad \\text{where } u = \\frac{\\deg F(r,s,t)}{b} \\approx de/b = \\frac{\\delta \\varepsilon}{\\beta} \\left(\\frac{k \\log q}{\\log k}\\right)^{1/3} \\text{ and }</span>$</p>

    <p class="text-gray-300"><span class="math">$P_g = v^{-v(1+o(1))} \\quad \\text{where } v = \\frac{\\deg G(r,s,t)}{b} \\approx k/db = \\frac{1}{\\delta \\beta} \\left(\\frac{k \\log q}{\\log k}\\right)^{1/3},</span>$</p>

    <p class="text-gray-300">which we rewrite as
<span class="math">$P_f = L_{q^k}(1/3, \\frac{\\delta \\varepsilon}{3\\beta})^{-1+o(1)}</span>$
and  <span class="math">P_g = L_{q^k}(1/3, \\frac{1}{3\\delta\\beta})^{-1+o(1)}</span> .</p>

    <p class="text-gray-300">Since the sieving domain comprises q &lt;sup&gt;2&lt;/sup&gt;e+1 = L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, 2ε) 1+o(1) such pairs (r, s), the expected total number of relations collected by the sieving step is therefore q &lt;sup&gt;2&lt;/sup&gt;e+1PfPg. However, in order to be able to solve the corresponding linear system, we require at least as many relations as there are elements in the factor base, whose cardinality is less than 2q &lt;sup&gt;b&lt;/sup&gt; = L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, β) 1+o(1). Consequently, we impose that</p>

    <p class="text-gray-300"><span class="math">$q^{2e+1}P_fP_g \\ge (2q^b)^{1+o(1)}</span>$
or, equivalently, that  <span class="math">2\\varepsilon - \\frac{\\delta\\varepsilon}{3\\beta} - \\frac{1}{3\\delta\\beta} = \\beta</span> .</p>

    <p class="text-gray-300">Solving in ε, and additionally requiring that δ &lt; 6β, we finally obtain the following constraint on the sieving bound:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\varepsilon \\ge \\frac{3\\delta\\beta^2 + 1}{\\delta(6\\beta - \\delta)}.\\tag{1}</span>$</p>

    <p class="text-gray-300">Furthermore, since the degrees of the norms F(r, s, t) and G(r, s, t) are polynomial in log(q k ), checking if they are b-smooth can be done in polynomial time, and the number of non-zero coefficients in the corresponding row of the matrix in the linear algebra step will also be polynomial in log(q k ). Therefore, as FFS falls into the L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, ·) sub-exponential complexity range, we can ignore these polynomial terms and obtain the following time complexities:</p>

    <p class="text-gray-300"><span class="math">$T_{\\text{sieving}} = (q^{2e+1})^{1+o(1)} = L_{q^k}(1/3, 2\\varepsilon)^{1+o(1)}</span>$
and  <span class="math">T_{\\text{lin.algebra}} = (2q^b)^{2+o(1)} = L_{q^k}(1/3, 2\\beta)^{1+o(1)}</span> .</p>

    <p class="text-gray-300">These two steps being the most expensive ones in FFS, balancing their computational cost is key to minimize the overall complexity of the algorithm. We therefore impose the further constraint that e = b or, equivalently, that  <span class="math">\\varepsilon = \\beta</span> . Under that condition, (1) can be rewritten as a quadratic inequation in  <span class="math">\\delta</span> , namely  <span class="math">\\varepsilon \\delta^2 - 3\\varepsilon^2 \\delta + 1 \\leq 0</span> , which admits a positive solution  <span class="math">\\delta</span>  if and only if  <span class="math">\\varepsilon \\geq \\sqrt[3]{4/9}</span> .</p>

    <p class="text-gray-300">Consequently, setting the constants  <span class="math">\\varepsilon = \\beta = \\sqrt[3]{4/9}</span> , we obtain  <span class="math">\\delta = \\sqrt[3]{3/2}</span>  and, finally, the overall complexity of FFS as</p>

    <p class="text-gray-300"><span class="math">$T_{\\mathrm{FFS}} = L_{q^k}(1/3, 2\\varepsilon)^{1+o(1)} = L_{q^k}(1/3, \\sqrt[3]{32/9})^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Individual logarithms. We follow here the reasoning of [6, Section 7.3] and adapt it to the FFS setting. It can be shown that the most expensive step in the computation of individual logarithms is the special- <span class="math">\\mathfrak q</span>  descent when the degree  <span class="math">d_{\\mathfrak q}</span>  of the norm of the prime ideal  <span class="math">\\mathfrak q</span>  is closest to b. In order to evaluate the complexity of this step, we consider here an ideal  <span class="math">\\mathfrak q</span>  whose norm has degree  <span class="math">d_{\\mathfrak q}</span>  of the form</p>

    <p class="text-gray-300"><span class="math">$d_{\\mathfrak{q}} = \\gamma \\frac{k^{1/3} (\\log k)^{2/3}}{(\\log q)^{2/3}}, \\text{ with } \\gamma &gt; \\beta.</span>$</p>

    <p class="text-gray-300">Recall that, in that case, we consider the norms corresponding to pairs of polynomials of the form  <span class="math">(ir_1+jr_2,is_1+js_2)\\in \\Lambda_{\\mathfrak{q}}\\subset (\\mathbb{F}_q[t])^2</span> , with the polynomials i and j of degree at most e', i monic, and where the coefficients  <span class="math">r_1</span> ,  <span class="math">r_2</span> ,  <span class="math">s_1</span> , and  <span class="math">s_2</span>  of the basis vectors all have degree around  <span class="math">d_{\\mathfrak{q}}/2</span> . The degrees of these norms can therefore be bounded by</p>

    <p class="text-gray-300"><span class="math">$\\deg F(ir_1 + jr_2, is_1 + js_2, t) \\lesssim \\deg_t f + d(e&#x27; + d_{\\mathfrak{q}}/2) \\approx d(e&#x27; + d_{\\mathfrak{q}}/2) \\quad \\text{and} \\quad \\deg G(ir_1 + jr_2, is_1 + js_2, t) \\lesssim \\deg_t g + (e&#x27; + d_{\\mathfrak{q}}/2) \\approx k/d.</span>$</p>

    <p class="text-gray-300">Denoting by  <span class="math">\\varepsilon&#x27;</span>  the positive parameter such that  <span class="math">e&#x27;=\\varepsilon&#x27;\\frac{k^{1/3}(\\log k)^{2/3}}{(\\log q)^{2/3}}</span> , the probabilities that these two norms are b'-smooth, for  <span class="math">b&#x27;=\\lambda d_{\\mathfrak{q}}</span> , are then given by  <span class="math">P&#x27;_f=L_{q^k}(1/3,\\frac{\\delta\\varepsilon&#x27;}{3\\lambda\\gamma}+\\frac{\\delta}{6\\lambda})^{-1+o(1)}</span>  and  <span class="math">P&#x27;_g=L_{q^k}(1/3,\\frac{1}{3\\delta\\lambda\\gamma})^{-1+o(1)}</span> , respectively. Furthermore, since there is no point in taking a smoothness bound b' for the descent lower than the sieving smoothness bound b, we can assume that  <span class="math">b&#x27;=\\lambda d_{\\mathfrak{q}}\\geq b</span> , whence  <span class="math">\\lambda\\gamma\\geq\\beta</span> .</p>

    <p class="text-gray-300">Consequently, the overall probability to find one doubly-b'-smooth relation in this descent step when considering all (i, j) pairs can be bounded by</p>

    <p class="text-gray-300"><span class="math">$q^{2e&#x27;+1}P_f&#x27;P_g&#x27; \\geq L_{q^k} \\left(1/3, 2\\varepsilon&#x27; - \\frac{\\delta\\varepsilon&#x27;}{3\\beta} - \\frac{\\delta}{6\\lambda} - \\frac{1}{3\\delta\\beta}\\right)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Since we require this probability to be non-negligible so that at least one such relation can actually be found, we end up with the following condition on  <span class="math">\\varepsilon&#x27;</span> :</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\varepsilon&#x27; \\ge \\frac{\\delta^2 \\beta / (2\\lambda) + 1}{\\delta(6\\beta - \\delta)}.\\tag{2}</span>$</p>

    <p class="text-gray-300">8</p>

    <p class="text-gray-300">Plugging in the values for  <span class="math">\\beta</span>  and  <span class="math">\\delta</span>  found previously and, following [6], taking for  <span class="math">\\lambda</span>  a constant close but not equal to 1, such as 0.999, allows us to choose  <span class="math">\\varepsilon&#x27; = \\sqrt[3]{1/18}</span> . The cost for this special- <span class="math">\\mathfrak{q}</span>  descent step is then</p>

    <p class="text-gray-300"><span class="math">$(q^{2e&#x27;+1})^{1+o(1)} = L_{q^k}(1/3, 2\\varepsilon&#x27;)^{1+o(1)} = L_{q^k}(1/3, \\sqrt[3]{4/9})^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Finally, considering the tree formed by the recursive calls in the descent process, one can check that the arity of each node is less than 2k (since special- <span class="math">\\mathfrak{q}</span>  descent will produce less than 2k new prime ideals), while the total depth of the tree is given by  <span class="math">w = \\log_{\\lambda}(b/b_0) = O(\\log k)</span> . Therefore, the total number of nodes in the tree is in  <span class="math">O(\\exp((\\log k)^2))</span> , which is polynomial in  <span class="math">\\log(q^k)</span> . Consequently, ignoring the polynomial terms, the overall time complexity for computing an individual logarithm is the same as the complexity of a single special- <span class="math">\\mathfrak{q}</span>  descent step, namely</p>

    <p class="text-gray-300"><span class="math">T_{\\text{indiv.log.}} = L_{q^k} (1/3, \\sqrt[3]{4/9})^{1+o(1)}.</span></p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;3 The FFS factory</h4>

    <p class="text-gray-300">The main contribution of this paper is based on the observation that, in the Function Field Sieve, a same polynomial  <span class="math">f(x,t) \\in \\mathbb{F}_q[t][x]</span>  can be used to compute discrete logarithms in several finite fields of approximately the same size. Therefore, in a setting where one wants to compute discrete logarithms in many different finite fields of close enough sizes, it is possible to use a single polynomial f for all these fields and share the computations on the algebraic side of the FFS algorithm.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3.1 Batching FFS computations</h4>

    <p class="text-gray-300">Let us now assume that we want to compute discrete logarithms in several finite fields  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span> , with  <span class="math">k&#x27; \\leq k</span>  and q a prime power such that  <span class="math">q = L_{q^k}(\\alpha, c)</span>  with  <span class="math">0 \\leq \\alpha &lt; 1/3</span>  and c &gt; 0.</p>

    <p class="text-gray-300">The idea here is to split the relation collection step into two parts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An precomputation step, which is performed only once, and which exclusively focuses on the algebraic (i.e., left-hand) side of the FFS commutative diagram. In this step, we select a good polynomial  <span class="math">f(x,t) \\in \\mathbb{F}_q[t][x]</span>  of degree d, and find all pairs (r,s) in the sieving domain which are b-smooth on the algebraic side. These pairs are then stored into a large file, where they can be reused later.</li>
      <li>An individual sieving step, which is performed for each target field  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span> . Here, a linear polynomial g(x,t) is first chosen so that its resultant in x with f has an irreducible factor of degree k'. The previously computed file is then read, and each pair (r,s) in this file is checked for b-smoothness on the rational (i.e. right-hand) side.</li>
    </ul>

    <p class="text-gray-300">Once the individual sieving step is completed for a given finite field  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span> , the remaining linear algebra and individual logarithm steps can be performed for this field just as in the original FFS algorithm.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;3.2 Complexity analysis</h4>

    <p class="text-gray-300">Since the first part of the relation collection step is now shared between several discrete logarithm computations, the optimal values for the parameters b, d, and e will differ from the ones in the original FFS. In order to find these new values, we build upon the complexity analysis of FFS detailed in Section <a href="#page-4-0">2.4.</a></p>

    <p class="text-gray-300">Relation collection and linear algebra. First of all, one has to remark that, with respect to the parameters b, d, and e, the degrees of the polynomials f and g, the sieving domain and the factor base are the same as in the original FFS. In other words, the sieving domain still comprises q &lt;sup&gt;2&lt;/sup&gt;e+1 = L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, 2ε) 1+o(1) pairs of polynomials (r, s), the cardinality of the factor base is still less that 2q &lt;sup&gt;b&lt;/sup&gt; = L&lt;sup&gt;q&lt;/sup&gt; &lt;sup&gt;k&lt;/sup&gt; (1/3, β) 1+o(1), and the degrees of the norms F(r, s, t) and G(r, s, t) are still bounded by de and k/d, respectively.</p>

    <p class="text-gray-300">Consequently, the condition q &lt;sup&gt;2&lt;/sup&gt;e+1PfP&lt;sup&gt;g&lt;/sup&gt; = (2q b ) 1+o(1) which ensures that enough relations are collected in order to solve the corresponding linear system imposes the exact same constraint on ε:</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\ge \\frac{3\\delta\\beta^2 + 1}{\\delta(6\\beta - \\delta)}, \\text{ with } \\delta &lt; 6\\beta.</span>$
(1)</p>

    <p class="text-gray-300">We now consider the costs of the various steps involved in the FFS factory. Note however that the actual values of the constants β, δ, and ε will be determined later.</p>

    <p class="text-gray-300">First of all, as the precomputation step requires to enumerate all pairs (r, s) of the sieving domain, its complexity is</p>

    <p class="text-gray-300"><span class="math">$T_{\\text{precomp.}} = (q^{2e+1})^{1+o(1)} = L_{q^k}(1/3, 2\\varepsilon)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Furthermore, since each pair (r, s) has probability P&lt;sup&gt;f&lt;/sup&gt; to be b-smooth on the algebraic side, the number of such b-smooth pairs written to the file in this precomputation step is then</p>

    <p class="text-gray-300"><span class="math">$N_{\\rm precomp.} = q^{2e+1} P_f = L_{q^k} \\left( 1/3, 2\\varepsilon - \\frac{\\delta \\varepsilon}{3\\beta} \\right)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Then, for each target field, we need to perform the corresponding individual sieving step, which entails going through all the precomputed pair (r, s) and checking whether each of them is b-smooth on the rational side. Since this check can be done in polynomial time, the actual complexity of this step is then Tindiv.sieving = Nprecomp..</p>

    <p class="text-gray-300">The linear algebra step, which also has to be performed for each target field, still has complexity quadratic in the size of the factor base, as in the original FFS:</p>

    <p class="text-gray-300"><span class="math">$T_{\\text{lin.algebra}} = (2q^b)^{2+o(1)} = L_{q^k}(1/3, 2\\beta)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Finally, we denote by Tindiv.FFS = Tindiv.sieving + Tlin.algebra the overall time complexity of the specific computations required for each target field.</p>

    <p class="text-gray-300">Individual logarithms. In a similar way as for the sieving constraint on  <span class="math">\\varepsilon</span> , one can easily see that computing a special- <span class="math">\\mathfrak{q}</span>  descent step in a target field  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span>  entails exactly the same constraint on the parameter  <span class="math">\\varepsilon&#x27;</span>  of the sieving region as in the case of the original FFS:</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon&#x27; \\ge \\frac{\\delta^2 \\beta / (2\\lambda) + 1}{\\delta(6\\beta - \\delta)}.\\tag{2}</span>$</p>

    <p class="text-gray-300">Furthermore, the cost of an individual logarithm in this field will also be</p>

    <p class="text-gray-300"><span class="math">$T_{\\text{indiv.log.}} = L_{q^k} (1/3, 2\\varepsilon&#x27;)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Balancing the complexities. Assuming that the precomputation step is done once and for all, we only need to balance the cost of the individual sieving and linear algebra steps for each target field. Setting  <span class="math">q^{2e+1}P_f = (2q^b)^{2+o(1)}</span>  and using the constraint (1) on  <span class="math">\\varepsilon</span> , we obtain the condition  <span class="math">\\delta \\geq 1/(3\\beta^2)</span> , which in turn imposes that  <span class="math">\\beta &gt; \\sqrt[3]{1/18}</span> , since (1) also requires that  <span class="math">\\delta &lt; 6\\beta</span> .</p>

    <p class="text-gray-300">In fact, it can be shown that, for any  <span class="math">\\lambda &lt; 1</span> , the quantity</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon&#x27; - \\beta \\ge \\frac{\\delta^2 \\beta / (2\\lambda) + 1}{\\delta(6\\beta - \\delta)} - \\beta \\ge \\frac{3\\beta \\delta^2 - 12\\beta^2 \\delta + 2}{2\\delta(6\\beta - \\delta)}</span>$</p>

    <p class="text-gray-300">is always positive when  <span class="math">\\sqrt[3]{1/18} &lt; \\beta &lt; \\sqrt[3]{1/6}</span> . Consequently, if one takes  <span class="math">\\beta</span>  in that interval, then the cost of computing an individual logarithm in a target field  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span>  will dominate that of the linear algebra step in the same field. The intuitive explanation is that, in such a case, the factor base is too small and the descent is thus much harder. It is therefore useless to consider values of  <span class="math">\\beta</span>  below  <span class="math">\\sqrt[3]{1/6}</span> . Similarly, considering values of  <span class="math">\\beta</span>  larger that  <span class="math">\\sqrt[3]{4/9}</span>  is also useless, as such values will yield complexities larger than that of the original FFS algorithm, thus defeating the purpose of the FFS factory approach.</p>

    <p class="text-gray-300">In the following, we denote by  <span class="math">\\varepsilon_0</span>  the lower bound on  <span class="math">\\varepsilon</span>  given by (1):</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon_0(\\beta, \\delta) = \\frac{3\\delta\\beta^2 + 1}{\\delta(6\\beta - \\delta)}.</span>$</p>

    <p class="text-gray-300">We first study the behavior of  <span class="math">\\varepsilon_0</span>  with respect to  <span class="math">\\delta</span> , in the range  <span class="math">1/(3\\beta^2) \\leq \\delta &lt; 6\\beta</span> , for a fixed value of  <span class="math">\\sqrt[3]{1/6} &lt; \\beta \\leq \\sqrt[3]{4/9}</span> . Taking the partial derivative of  <span class="math">\\varepsilon_0</span>  with respect to  <span class="math">\\delta</span>  then gives</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial \\varepsilon_0}{\\partial \\delta}(\\beta,\\delta) = \\frac{3\\beta^2\\delta^2 + 2\\delta - 6\\beta}{\\delta^2(6\\beta - \\delta)^2},</span>$</p>

    <p class="text-gray-300">which is negative when  <span class="math">1/(3\\beta^2) \\leq \\delta &lt; \\delta_0(\\beta)</span>  and positive when  <span class="math">\\delta_0(\\beta) &lt; \\delta &lt; 6\\beta</span> , with  <span class="math">\\delta_0(\\beta) = (\\xi(\\beta) - 1)/(3\\beta^2)</span>  and  <span class="math">\\xi(\\beta) = \\sqrt{18\\beta^3 + 1}</span> . Hence, in order to minimize  <span class="math">\\varepsilon_0</span> , we define  <span class="math">\\tilde{\\varepsilon}_0(\\beta) = \\varepsilon_0(\\beta, \\delta_0(\\beta))</span> . This function and its derivative with respect to  <span class="math">\\beta</span>  are then given by</p>

    <p class="text-gray-300"><span class="math">$\\tilde{\\varepsilon}_0(\\beta) = \\varepsilon_0(\\beta, \\delta_0(\\beta)) = \\left(\\frac{3\\beta^2}{\\xi(\\beta) - 1}\\right)^2 \\quad \\text{and} \\quad \\frac{d\\tilde{\\varepsilon}_0}{d\\beta}(\\beta) = \\frac{9\\beta^3 \\left(\\xi(\\beta)^2 - 4\\xi(\\beta) + 3\\right)}{\\xi(\\beta)(\\xi(\\beta) - 1)^3},</span>$</p>

    <p class="text-gray-300">respectively. The latter shows that  <span class="math">\\tilde{\\varepsilon}_0</span>  is a strictly decreasing function of  <span class="math">\\beta</span>  on the whole interval  <span class="math">\\sqrt[3]{1/6} &lt; \\beta &lt; \\sqrt[3]{4/9}</span> , its derivative vanishing at  <span class="math">\\beta = \\sqrt[3]{4/9}</span> .</p>

    <p class="text-gray-300">Similarly, fixing  <span class="math">\\delta = \\delta_0(\\beta)</span>  in constraint (2) for individual logarithms gives the following lower bound on the parameter  <span class="math">\\varepsilon&#x27;</span> :</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon&#x27; \\ge \\frac{\\beta}{2\\xi(\\beta)} \\left( \\frac{1}{\\lambda} + \\frac{\\xi(\\beta) + 1}{\\xi(\\beta) - 1} \\right),</span>$</p>

    <p class="text-gray-300">which becomes  <span class="math">\\varepsilon&#x27; \\geq \\beta/(\\xi(\\beta) - 1)</span>  when  <span class="math">\\lambda</span>  is chosen to be almost equal to 1.</p>

    <p class="text-gray-300">One can remark that, when taking  <span class="math">\\beta = \\sqrt[3]{4/9}</span> , we end up with the exact same complexity as the original FFS algorithm:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T_{\\text{precomp.}} &amp;= T_{\\text{indiv.FFS}} = L_{q^k} (1/3, \\sqrt[3]{32/9})^{1+o(1)} \\quad \\text{and} \\\\ &amp;T_{\\text{indiv.log.}} = L_{q^k} (1/3, \\sqrt[3]{4/9})^{1+o(1)}. \\end{split}</span>$</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.3 Discussion</h4>

    <p class="text-gray-300">From the previous analysis, taking the parameters  <span class="math">\\varepsilon = \\tilde{\\varepsilon}_0(\\beta)</span>  and  <span class="math">\\varepsilon&#x27; = \\beta/(\\xi(\\beta) - 1)</span> , one can use  <span class="math">\\beta</span>  in order to adjust the tradeoff between the cost of the precomputation step and that of the individual sieving/linear algebra steps, depending on how many target fields  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span>  are considered.</p>

    <p class="text-gray-300">Indeed, if one wants to compute discrete logarithms in many different finite fields, taking a lower value for  <span class="math">\\beta</span>  will increase the precomputation time, while decreasing the individual cost for each target field. This can be seen in Figure 1, in which the costs  <span class="math">T_{\\rm precomp.}</span> ,  <span class="math">T_{\\rm indiv.FFS}</span> , and  <span class="math">T_{\\rm indiv.log.}</span>  are given as functions of  <span class="math">\\beta</span> .</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_11.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>Fig. 1.</strong> Costs of the various steps in the FFS factory, as functions of  <span class="math">\\beta</span> , and expressed as the parameter c which appears in their complexity when written as  <span class="math">L_{q^k}(1/3,c)</span> .</p>

    <p class="text-gray-300">Of course, mitigating the extra cost of the precomputation step requires that enough target fields are considered. In fact, the number N of distinct finite fields in which to compute discrete logarithms should be of the form  <span class="math">N=L_{q^k}(1/3,\\nu)^{1+o(1)}</span> , with  <span class="math">\\nu&gt;0</span> , in order to be able to amortize the precomputation cost. For instance, while  <span class="math">\\beta=\\sqrt[3]{4/9}</span>  corresponds to the original FFS algorithm and can therefore be used even for a single target field, on the other hand, setting  <span class="math">\\beta=\\sqrt[3]{1/6}</span>  requires that  <span class="math">N\\geq T_{\\rm FFS}/T_{\\rm precomp.}</span>  or, in other words, that  <span class="math">\\nu\\geq\\sqrt[3]{9/2}-\\sqrt[3]{32/9}\\approx0.125</span> . In that case, we have the following complexity estimates:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} T_{\\text{precomp.}} &amp;= L_{q^k} (1/3, \\sqrt[3]{9/2})^{1+o(1)} \\quad \\text{and} \\\\ T_{\\text{indiv.FFS}} &amp;= T_{\\text{indiv.log}} = L_{q^k} (1/3, \\sqrt[3]{4/3})^{1+o(1)}. \\end{split}</span>$</p>

    <p class="text-gray-300">However, since the finite fields of a given size  <span class="math">q^{k&#x27;}</span>  are all isomorphic, and that this isomorphism is computable in polynomial time, there is absolutely no point in applying the FFS factory to more than one field of each size. As there are only a polynomial number of distinct finite fields  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span>  with  <span class="math">k&#x27; \\leq k</span> , there is no way for N to be in the  <span class="math">L_{q^k}(1/3,\\cdot)</span>  complexity range as k grows. On first sight, this renders the whole FFS factory approach useless, at least asymptotically.</p>

    <p class="text-gray-300">However, this criticism might be mitigated as, since 2013, it is known that FFS, asymptotically speaking, is no longer the most efficient algorithm known for computing discrete logarithms in finite fields of small characteristic [23,14,8]. Even though the exact crossing point between FFS and these asymptotically faster algorithms is not known yet, recent experiments show that computing discrete logarithms using FFS still makes sense for finite fields  <span class="math">\\mathbb{F}_{q^k}</span>  of size  <span class="math">\\log_2(q^k)</span>  up to around 1000 bits [5]. It turns out that, for fields of that size, the quantity  <span class="math">L_{q^k}(1/3,\\nu)</span>  amounts to at most a few dozens when  <span class="math">\\nu \\leq \\sqrt[3]{9/2} - \\sqrt[3]{32/9}</span> . Therefore, in this case, the number N of finite fields to consider for the FFS factory to be better than N independent instances of the original FFS is roughly of the same order of magnitude and is thus totally manageable in practice, as shown by the experiment presented in Section 4.</p>

    <h2 id="sec-12" class="text-2xl font-bold">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;4 Practical experiment</h2>

    <p class="text-gray-300">In order to assess the applicability and the impact of the proposed FFS factory approach, we have implemented this algorithm and used it to compute discrete logarithms in the 50 binary finite fields  <span class="math">\\mathbb{F}_{2^{k&#x27;}}</span>  for all odd values of k' between 601 and 699 (inclusive), which fall slightly below the current size records for FFS [17,5].</p>

    <p class="text-gray-300">Software implementation. Our implementation of the FFS factory is based on the C implementation of FFS which is freely available as part of the cado-nfs software suite [4]. Since some of the steps in the FFS factory are identical to those of the original FFS, we were able to directly reuse various part of cado-nfs for our computation, such as the polynomial selection [7], the filtering utilities</p>

    <p class="text-gray-300">(which prepare the matrix before the linear algebra) [11], or the GPU-based linear algebra implementation [18].</p>

    <p class="text-gray-300">However, the relation collection step had to be modified so as to match the FFS factory algorithm. In the cado-nfs implementation of FFS, this step is directly based on the implementation described by Detrey <em>et al.</em> in [13] which, among other techniques, uses</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>special- <span class="math">\\mathfrak{q}</span>  sieving, which ensure that large prime ideals  <span class="math">\\mathfrak{q}</span>  (on either the algebraic or the rational side) appear in the relations, thus increasing the smoothness probabilities; and</li>
      <li>lattice sieving, which, in a somewhat similar way to the sieve of Eratosthenes, allows one to quickly find all pairs (r, s) which are divisible by small prime ideals (on both sides), and to actually check for smoothness only those pairs which are divisible by sufficiently many of these small prime ideals, since they will then have higher chances of being b-smooth.</li>
    </ul>

    <p class="text-gray-300">In order for this program to follow the FFS factory approach, we have modified it to support several polynomials (and therefore several target fields) on the rational side at the same time, thus sharing the (pre)computations for the algebraic side amongst all target fields. We have also disabled both the special- <span class="math">\\mathfrak q</span>  sieving and the lattice sieving on the rational side, but kept these techniques for the algebraic side so as to maintain the running time of the precomputation step as low as possible.</p>

    <p class="text-gray-300">All in all, adding support for the FFS factory mostly entailed minute changes in the cado-nfs software. It is therefore planned that these changes eventually make their way into the official code base of cado-nfs, and that the FFS factory becomes available in future releases.</p>

    <p class="text-gray-300"><strong>Experimental setup and results.</strong> In order to compute discrete logarithms in all finite fields  <span class="math">\\mathbb{F}_{2^{k&#x27;}}</span> , with k' odd and between 601 and 699, using the proposed FFS factory, we used the same degree-6 polynomial f(x,t) for the algebraic side that was used for the discrete logarithm computation in  <span class="math">\\mathbb{F}_{2809}^{\\times}</span>  [5]:</p>

    <p class="text-gray-300"><span class="math">$f(x,t) = x^6 + 0x7x^5 + 0x6bx^3 + 0x1abx^2 + 0x326x + 0x19b3.</span>$</p>

    <p class="text-gray-300">Note that we also considered using a degree-5 polynomial, but none were found in the polynomial selection step that were as good as the one above for the considered finite fields.</p>

    <p class="text-gray-300">Sieving was performed using the implementation described above on Intel Xeon E5-2650 CPUs running at 2.0 GHz. The smoothness bound was fixed to b=26, and we lattice-sieved on the algebraic side all prime ideals whose norm had degree at most 20. We sieved for special- <span class="math">\\mathfrak{q}</span> 's of norm starting at degree 21 and increasing until enough relations were found. As soon as sufficiently many relations were collected for a given target field, we stopped sieving for this field. Sieving timings and the number of collected relations for each target field are reported in Figure 2 (left).</p>

    <p class="text-gray-300">It is to be noted that the precomputation step required 38.2 core-days, and that the 50 individual sieving steps took a total of 1788.6 core-days. If we had used the original FFS instead, we estimate that this computation would have required about 2991.3 core-days to produce a similar set of relations. Therefore, the FFS factory induced a speedup of 39 % on the overall computation time, that is, a saving of almost 3.2 core-years on an 8.2-core-year computation.</p>

    <p class="text-gray-300">    <img src="_page_13_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;<strong>Fig. 2.</strong> Timings for the relation collection step on each target field  <span class="math">\\mathbb{F}_{q^{k&#x27;}}</span> , for both the original FFS (estimated) and the FFS factory, along with the number of collected relations (left). Timings for the linear algebra step on each target field, along with the number of rows and columns of the corresponding matrix (right).</p>

    <p class="text-gray-300">As mentioned previously, we used Jeljeli's GPU implementation of the block Wiedemann algorithm for the linear algebra step [18]. Timings on Nvidia GTX 680 graphics cards, along with the dimension of the corresponding matrices (whose density was set to an average of 100 non-zero coefficients per row), are given in Figure 2 (right). This computation represents a total running time of 83.8 GPU-days.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;5 Conclusion</h4>

    <p class="text-gray-300">In this paper, we have presented an adaptation of Coppersmith's &quot;factorization factory&quot; idea to the case of the Function Field Sieve for batching discrete logarithm computations in several finite fields of small characteristic. Along with a careful complexity analysis showing that this approach can be leveraged in practice to decrease the total computation time when enough target fields are considered, we also presented a working implementation of this algorithm based on the FFS implementation of cado-nfs. This implementation was used in a full-scale experiment in order to validate our analysis, thus solving the discrete logarithm problem in all the binary finite fields  <span class="math">\\mathbb{F}_{2^{k&#x27;}}</span>  of odd extension degree k' and of size from 601 to 699 bits. For this experiment, the observed speedup against the original FFS algorithm was 39 %.</p>

    <p class="text-gray-300">Even though the days of FFS are now numbered, it is far from obsolete yet, especially for finite fields of (almost) prime extension degrees and of size around or below 1000 bits. Future works include polishing the FFS factory implementation so that it can be published as part of the cado-nfs suite and, more importantly, using this approach to (pre)compute discrete logarithms in as many binary (or ternary) finite fields as possible so as to complete the database of factor bases in computer algebra systems such as Magma or Sage. Even though such computations need to be done only once, they still represent a huge endeavor when large field sizes are targeted.</p>

    <h2 id="sec-14" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-2&quot;&gt;&lt;/span&gt;1. Adj, G., Menezes, A., Oliveira, T., Rodríguez-Henríquez, F.: Computing discrete logarithms in F36·&lt;sup&gt;137&lt;/sup&gt; and F36·&lt;sup&gt;163&lt;/sup&gt; using Magma (2014), Cryptology ePrint Archive, report 2014/057</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;2. Adleman, L.M.: The function field sieve. In: Adleman, L.M., Huang, M.D.A. (eds.) Algorithmic Number Theory – ANTS-I. Lecture Notes in Computer Science, vol. 877, pp. 108–121. Springer–Verlag (1994)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-9&quot;&gt;&lt;/span&gt;3. Adleman, L.M., Huang, M.D.A.: Function field sieve method for discrete logarithms over finite fields. Information and Computation 151(1–2), 5–16 (1999)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-4&quot;&gt;&lt;/span&gt;4. Bai, S., Bouvier, C., Filbois, A., Gaudry, P., Imbert, L., Kruppa, A., Morain, F., Thomé, E., Zimmermann, P.: cado-nfs, an implementation of the Number Field Sieve algorithm, release 2.0, available from <a href="http://cado-nfs.gforge.inria.fr/">http://cado-nfs.gforge.inria.fr/</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-3&quot;&gt;&lt;/span&gt;5. Barbulescu, R., Bouvier, C., Detrey, J., Gaudry, P., Jeljeli, H., Thomé, E., Videau, M., Zimmermann, P.: Discrete logarithm in GF(2&lt;sup&gt;809&lt;/sup&gt;) with FFS. In: Krawczyk, H. (ed.) Public-Key Cryptography – PKC 2014. Lecture Notes in Computer Science, vol. 8383, pp. 221–238. Springer–Verlag (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-8&quot;&gt;&lt;/span&gt;6. Barbulescu, R.: Algorithms of discrete logarithm in finite fields. Ph.D. thesis, Université de Lorraine (2013), available at <a href="http://tel.archives-ouvertes.fr/tel-00925228">http://tel.archives-ouvertes.fr/</a> <a href="http://tel.archives-ouvertes.fr/tel-00925228">tel-00925228</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-10&quot;&gt;&lt;/span&gt;7. Barbulescu, R.: Selecting polynomials for the Function Field Sieve (2013), preprint, 23 pages, available at <a href="http://hal.inria.fr/hal-00798386">http://hal.inria.fr/hal-00798386</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;8. Barbulescu, R., Gaudry, P., Joux, A., Thomé, E.: A quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In: Nguyen, P.Q., Oswald, E. (eds.) Advances in Cryptology – EUROCRYPT 2014. Lecture Notes in Computer Science, vol. 8441, pp. 1–16. Springer–Verlag (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-6&quot;&gt;&lt;/span&gt;9. Bosma, W., Cannon, J.J., Fieker, C., Steel, A.: Summary of new features in Magma V2.20. Available at <a href="http://magma.maths.usyd.edu.au/magma/releasenotes/2/20/">http://magma.maths.usyd.edu.au/magma/releasenotes/2/</a> <a href="http://magma.maths.usyd.edu.au/magma/releasenotes/2/20/">20/</a> (Dec 2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-5&quot;&gt;&lt;/span&gt;10. Bosma, W., Cannon, J.J., Playoust, C.: The Magma algebra system. I. The user language. Journal of Symbolic Computation 24(3-4), 235–265 (1997)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-11&quot;&gt;&lt;/span&gt;11. Bouvier, C.: The filtering step of discrete logarithm and integer factorization algorithms (2013), preprint, 22 pages, available at <a href="http://hal.inria.fr/hal-00734654">http://hal.inria.fr/</a> <a href="http://hal.inria.fr/hal-00734654">hal-00734654</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-7&quot;&gt;&lt;/span&gt;12. Coppersmith, D.: Modifications to the Number Field Sieve. Journal of Cryptology 6(3), 169–180 (1993)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-14-12&quot;&gt;&lt;/span&gt;13. Detrey, J., Gaudry, P., Videau, M.: Relation collection for the Function Field Sieve. In: Nannarelli, A., Seidel, P.M., Tang, P.T.P. (eds.) IEEE Symposium on Computer Arithmetic – ARITH-21. pp. 201–210. IEEE (2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;14. Göloğlu, F., Granger, R., McGuire, G., Zumbrägel, J.: On the function field sieve and the impact of higher splitting probabilities. In: Canetti, R., Garay, J.A. (eds.) Advances in Cryptology – CRYPTO 2013. Lecture Notes in Computer Science, vol. 8043, pp. 109–128. Springer–Verlag (2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-4&quot;&gt;&lt;/span&gt;15. Göloğlu, F., Granger, R., McGuire, G., Zumbrägel, J.: Solving a 6120-bit DLP on a desktop computer. In: Lange, T., Lauter, K., Lisoněk, P. (eds.) Selected Areas in Cryptography – SAC 2013. Lecture Notes in Computer Science, vol. 8282, pp. 136–152. Springer–Verlag (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-6&quot;&gt;&lt;/span&gt;16. Granger, R., Kleinjung, T., Zumbrägel, J.: Discrete logarithms in GF(2&lt;sup&gt;9234&lt;/sup&gt;). Email to the NMBRTHRY mailing list, <a href="http://listserv.nodak.edu/archives/nmbrthry.html">http://listserv.nodak.edu/archives/</a> <a href="http://listserv.nodak.edu/archives/nmbrthry.html">nmbrthry.html</a> (Jan 2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-12&quot;&gt;&lt;/span&gt;17. Hayashi, T., Shimoyama, T., Shinohara, N., Takagi, T.: Breaking pairing-based cryptosystems using η&lt;sup&gt;T&lt;/sup&gt; pairing over GF(3&lt;sup&gt;97&lt;/sup&gt;). In: Wang, X., Sako, K. (eds.) Advances in Cryptology – ASIACRYPT 2012. Lecture Notes in Computer Science, vol. 7658, pp. 43–60. Springer–Verlag (2012)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-13&quot;&gt;&lt;/span&gt;18. Jeljeli, H.: Accelerating iterative SpMV for Discrete Logarithm Problem using GPUs (2013), preprint, 11 pages, available at <a href="http://hal.inria.fr/hal-00734975">http://hal.inria.fr/</a> <a href="http://hal.inria.fr/hal-00734975">hal-00734975</a></p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-9&quot;&gt;&lt;/span&gt;19. Joux, A., Lercier, R.: The function field sieve is quite special. In: Fieker, C., Kohel, D.R. (eds.) Algorithmic Number Theory – ANTS-V. Lecture Notes in Computer Science, vol. 2369, pp. 431–445. Springer–Verlag (2002)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;20. Joux, A.: Discrete logarithms in GF(2&lt;sup&gt;1778&lt;/sup&gt;). E-mail to the NMBRTHRY mailing list, <a href="http://listserv.nodak.edu/archives/nmbrthry.html">http://listserv.nodak.edu/archives/nmbrthry.html</a> (Feb 2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-3&quot;&gt;&lt;/span&gt;21. Joux, A.: Discrete logarithms in GF(2&lt;sup&gt;4080&lt;/sup&gt;). E-mail to the NMBRTHRY mailing list, <a href="http://listserv.nodak.edu/archives/nmbrthry.html">http://listserv.nodak.edu/archives/nmbrthry.html</a> (Mar 2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-5&quot;&gt;&lt;/span&gt;22. Joux, A.: Discrete logarithms in GF(2&lt;sup&gt;6168&lt;/sup&gt;) [= GF((2&lt;sup&gt;257&lt;/sup&gt;) &lt;sup&gt;24&lt;/sup&gt;)]. E-mail to the NM-BRTHRY mailing list, <a href="http://listserv.nodak.edu/archives/nmbrthry.html">http://listserv.nodak.edu/archives/nmbrthry.html</a> (May 2013)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;23. Joux, A.: A new index calculus algorithm with complexity L(1/4 + o(1)) in very small characteristic. In: Lange, T., Lauter, K., Lisoněk, P. (eds.) Selected Areas in Cryptography – SAC 2013. Lecture Notes in Computer Science, vol. 8282, pp. 355–379. Springer–Verlag (2014)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-7&quot;&gt;&lt;/span&gt;24. Kleinjung, T.: private communication (2012)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-10&quot;&gt;&lt;/span&gt;25. LaMacchia, B.A., Odlyzko, A.M.: Solving large sparse linear systems over finite fields. In: Menezes, A.J., Vanstone, S.A. (eds.) Advances in Cryptology – CRYPTO '90. Lecture Notes in Computer Science, vol. 537, pp. 109–133. Springer–Verlag (1990)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-8&quot;&gt;&lt;/span&gt;26. Matsumoto, R.: Using Cab curves in the function field sieve. IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences E82-A(3), 551–552 (1999)</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-15-11&quot;&gt;&lt;/span&gt;27. Panario, D., Gourdon, X., Flajolet, P.: An analytic approach to smooth polynomials over finite fields. In: Buhler, J.P. (ed.) Algorithmic Number Theory – ANTS-III. Lecture Notes in Computer Science, vol. 1423, pp. 226–236. Springer–Verlag (1998)</p></li>
    </ul>

`;
---

<BaseLayout title="Adapting Coppersmith&#x27;s &quot;Factorization Factory&quot; to the Functi... (2014/419)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/419
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="adapting-coppersmith-s-factorization-factory-to-the-2014" />
  </article>
</BaseLayout>
