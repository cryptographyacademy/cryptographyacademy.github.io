---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/123';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Zendoo: a zk-SNARK Verifiable Cross-Chain Transfer Protocol Enabling Decoupled and Decentralized Sidechains';
const AUTHORS_HTML = 'Alberto Garoffolo, Dmytro Kaidalov, Roman Oliynykov';

const CONTENT = `    <p class="text-gray-300">Alberto Garoffolo alberto@horizen.global Horizen Dmytro Kaidalov dmytro.kaidalov@iohk.io IOHK Research Roman Oliynykov roman.oliynykov@iohk.io IOHK Research V.N.Karazin Kharkiv National University</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Sidechains are an appealing innovation devised to enable blockchain scalability and extensibility. The basic idea is simple yet powerful: construct a parallel chain – sidechain – with desired features, and provide a way to transfer coins between the mainchain and the sidechain.</p>

    <p class="text-gray-300">In this paper, we introduce Zendoo, a construction for Bitcoin-like blockchain systems that allows the creation and communication with sidechains of different types without knowing their internal structure. We consider a parent-child relationship between the mainchain and sidechains, where sidechain nodes directly observe the mainchain while mainchain nodes only observe cryptographically authenticated certificates from sidechain maintainers. We use zk-SNARKs to construct a universal verifiable transfer mechanism that is used by sidechains.</p>

    <p class="text-gray-300">Moreover, we propose a specific sidechain construction, named Latus, that can be built on top of this infrastructure, and realizes a decentralized verifiable blockchain system for payments. We leverage the use of recursive composition of zk-SNARKs to generate succinct proofs of sidechain state progression that are used to generate certificates’ validity proofs. This allows the mainchain to efficiently verify all operations performed in the sidechain without knowing any details about those operations.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Related Work  4</p>

    <p class="text-gray-300">2  Preliminaries  5 2.1  Cryptographic Definitions  5 2.2  Recursive SNARKs Composition for State Transitions  6</p>

    <p class="text-gray-300">3  General Overview  7 3.1  Main Components of a Sidechain Design  8</p>

    <p class="text-gray-300">4  Zendoo: a Cross-Chain Transfer Protocol for Sidechains  9 4.1  Cross-Chain Transfer Protocol  10 4.1.1  Forward Transfers  10 4.1.2  Backward Transfers  11 4.1.2.1  Mainchain Managed Withdrawals  14 4.1.2.2  Withdrawal Safeguard  16 4.1.3  Sidechain Transactions Commitment  16 4.2  Bootstrapping Sidechains  17</p>

    <p class="text-gray-300">5  The Latus Sidechain  18 5.1  Consensus Protocol  18 5.1.1  Withdrawal Epochs  21 5.2  Accounting Model and System State  22 5.2.1  System State  22 5.3  Transactional Model  23 5.3.1  Payment Transaction  23 5.3.2  Forward Transfers Transaction  24 5.3.3  Backward Transfer Transaction  25 5.3.4  Backward Transfer Requests Transaction  26 5.4  State Transition Proof  27 5.4.1  Performance and Incentives  29 5.5  Cross-Chain Transfer Protocol  29 5.5.1  Mainchain Block Reference  29 5.5.2  Forward Transfers  31 5.5.3  Backward Transfers  31 5.5.3.1  Withdrawal Certificate  32 5.5.3.2  Backward Transfer Request  34 5.5.3.3  Ceased Sidechain Withdrawal  35</p>

    <p class="text-gray-300">6  Conclusions  36</p>

    <p class="text-gray-300">7  Acknowledgments  36</p>

    <p class="text-gray-300">Appendix A  MST Delta  38</p>

    <p class="text-gray-300">Since the inception of the Bitcoin cryptocurrency in 2008 [20], the topic of decentralized ledger technology has received significant attention among experts from various areas. Bitcoin became the first decentralized payment system based on peer-to-peer networking. Its key feature - the absence of centralized control - is claimed to be the disruptive innovation that will help build more robust, fair, and transparent financial systems. Bitcoin inspired the appearance of many other systems based on the same principle of decentralization with a variety of different features.</p>

    <p class="text-gray-300">With the increasing use of Bitcoin and similar blockchain systems, their inherent limitations became apparent: limited throughput, increased latency, reduced ability to scale and expand functionality, etc. [10]. Even more important is that such decentralized systems are challenging to update since there is no single decision-making entity. Even a small protocol change requires a cumbersome process of community agreement, which makes the introduction of new features difficult.</p>

    <p class="text-gray-300">Sidechains, proposed by A. Back et.al. in 2014 [5], is an appealing concept that allows one to work around the constraints of a single decentralized blockchain. The basic idea is simple: to create a separate blockchain with whatever functionality is needed and provide a way to communicate with the main blockchain (Fig. 1). Communication means the ability to transfer a mainchain native asset (e.g. bitcoins) to and from a sidechain.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Sidechains. The main blockchain provides basic cryptocurrency functionality while sidechains implement specific functions.</p>

    <p class="text-gray-300">This way, for instance, a blockchain system, like Bitcoin, can be extended with additional functionalities (such as smart contracts [3]) implemented in a separate sidechain, which uses the same native asset, hence remaining in the Bitcoin ecosystem.</p>

    <p class="text-gray-300">In this paper, we propose Zendoo, a universal construction for Bitcoin-like blockchain systems that allows the creation and communication with sidechains of different types without knowing their internal structure (e.g. what consensus protocol is used, what types of transactions are supported, etc.). In fact, the sidechain may not even be a blockchain but can be any system that uses the standardized method to communicate with the mainchain.</p>

    <p class="text-gray-300">Specifically, we consider a parent-child relationship between the mainchain and sidechains, where sidechain nodes directly observe the mainchain while mainchain nodes only observe cryptographically authenticated certificates from sidechain maintainers. Among other things, such certificates authorize transfers coming from sidechains. Certificate authentication and validation are achieved by using zk-SNARKs [6], which enable constant-sized proofs of arbitrary computations. The main feature of our construction is that sidechains are allowed to define their own zk-SNARKs, thus establishing their own rules for authentication and validation. The fact that all zk-SNARK proofs comply with the same verification interface used by the mainchain enables great universality as the sidechain can use an arbitrary protocol for authenticating its certificates. E.g., the sidechain may adopt a centralized solution where the zk-SNARK just verifies</p>

    <p class="text-gray-300">that a certificate is signed by an authorized entity (like in <em>[5]</em>) or, for instance, a decentralized chain-of-trust model as in <em>[13]</em>.</p>

    <p class="text-gray-300">Moreover, we propose a specific sidechain construction, named <em>Latus</em>, that can be built on top of this infrastructure, and realizes a decentralized verifiable blockchain system. We leverage the use of recursive composition of zk-SNARKs to generate succinct proofs of sidechain state progression (as in <em>[19]</em>) that are used to generate certificate proofs for the mainchain. This allows the mainchain to efficiently verify all operations performed in the sidechain without knowing any details about those operations.</p>

    <p class="text-gray-300">The paper is structured in the following way: section <em>[2]</em> provides basic definitions that are used throughout the paper; section <em>[3]</em> provides a general overview of the sidechain concept; section <em>[4]</em> provides details about the proposed cross-chain communication protocol Zendoo and introduces basic interfaces imposed by the mainchain side; section <em>[5]</em> provides details of the Latus sidechain construction.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <p class="text-gray-300">The concept of sidechains was first introduced by A. Back et.al. in 2014 <em>[5]</em>. They introduced a general notion of a 2-way peg and described two operational modes – synchronous and asynchronous – to implement interactions between pegged chains. The synchronous mode implies that both main and side chains are aware of each other and can verify transfer transactions directly, while the asynchronous mode relies on validators to process transfers.</p>

    <p class="text-gray-300">Notable construction of sidechains was presented in <em>[25, 18]</em> and called Drivechains. It aims to deploy sidechains on top of the Bitcoin network. While forward transfers (from the mainchain to a sidechain) are processed by providing SPV proofs (like the synchronous mode in <em>[5]</em>), backward transfers rely upon validators. Validators in Drivechains are mainchain miners who observe sidechains and endorse transfers.</p>

    <p class="text-gray-300">The first formal treatment of sidechains was proposed by P. Gaži, A. Kiayias, and D. Zindros in <em>[13]</em>. In addition, they presented a sidechain construction for proof-of-stake blockchains where sidechain nodes directly observe and confirm forward transfers while backward transfers are confirmed by certifiers chosen among sidechain block forgers.</p>

    <p class="text-gray-300">Our previous proposal on sidechains <em>[12]</em> presents a flexible model which allows the construction of different types of sidechains whose internal structures are unknown to the mainchain. It relies on certifiers to confirm backward transfers in the mainchain. Though, in this model certifiers are chosen randomly from a pool of certifiers registered directly in the mainchain.</p>

    <p class="text-gray-300">Mentioned constructions differ from our current proposal in various aspects, most notably because they either assume that the mainchain observes sidechains directly or relies on some intermediary to confirm transfers. In addition, they do not provide flexibility (except <em>[12]</em>), which means that a sidechain construction (e.g. consensus protocol) cannot be chosen freely.</p>

    <p class="text-gray-300">In <em>[16]</em>, A. Kiayias and D. Zindros proposed implementation of the sidechain protocol for the proof-of-work blockchains based on smart contracts. Another notable sidechain construction that relies on smart contracts is called Plasma and was presented in <em>[22]</em> by J. Poon and V. Buterin. On the contrary, our construction does not rely on smart contracts.</p>

    <p class="text-gray-300">One of the main features of the construction presented in this paper is the usage of zk-SNARKs for enabling verifiable cross-chain communication. zk-SNARK has initially been proposed as a zero-knowledge protocol which allows proving possession of some information without revealing it <em>[6]</em>. However, this technique is suited for more than simply securing information but also for solving scalability issues: it enables succinct constant size proofs of almost arbitrary computations. For instance, using the recursive composition of zk-SNARKs <em>[19, 8]</em> it is possible</p>

    <p class="text-gray-300">to construct a succinct proof of state transition virtually for any number of transactions. We were inspired by these techniques while designing our sidechain construction.</p>

    <p class="text-gray-300">A notable sidechain construction that also relies on zk-SNARKs is ZK Rollup [14]. It is a layer 2 solution based on smart contracts for scaling transaction throughput in Ethereum [2]. The basic idea is that transactions are carried out off-chain while the information about entailed state transitions together with a zk-SNARK proof of their validity is submitted to the contract. It still requires submission of some limited information about each transaction on-chain to prevent data availability attacks thus limiting scalability. Our construction differs from ZK Rollup in many aspects, most notably because we do not push sidechain transaction data to the mainchain.</p>

    <p class="text-gray-300">There are many other attempts to construct cross-chain transfer mechanisms including the Liquid project [9], Polkadot [30], Interledger [27], Cosmos [1], and many others. They propose various solutions that are different from our construction.</p>

    <p class="text-gray-300">In this section, we introduce definitions of several cryptographic constructions that are used throughout the paper. We defer formal descriptions (especially of the recursive SNARKs composition) for a separate paper and define here only basic notations needed to describe the proposed sidechain construction.</p>

    <p class="text-gray-300">Definition 2.1. Collision-Resistant Hash Function (CRH). A hash function  <span class="math">H</span>  is collision-resistant if the probability of finding two different input strings  <span class="math">a</span>  and  <span class="math">b</span>  such that  <span class="math">H(a) = H(b)</span>  is negligible (more formal definition can be found, e.g., in [15]).</p>

    <p class="text-gray-300">Whenever we refer to a hash function, we suppose it is collision-resistant.</p>

    <p class="text-gray-300">Definition 2.2. Merkle Hash Tree (MHT). The Merkle Hash Tree, or simply Merkle Tree (MT), is a binary tree data structure where the value of an internal node is computed as the hash of values of its children, and the value of a leaf node is the direct hash of a data block represented by this leaf (see Fig. 2) [23, 21].</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Merkle Hash Tree.</p>

    <p class="text-gray-300">We call the top-level node ( <span class="math">h_1</span>  in Fig. 2) the root hash of the MHT. Given that a collision-resistant hash function is used to calculate tree nodes, we can consider root hash as a tree</p>

    <p class="text-gray-300">authenticator: it is impossible to tamper even a single bit of data in the tree without also changing the root hash.</p>

    <p class="text-gray-300">An important feature of the Merkle tree structure is that it produces a concise proof of a particular data block’s membership in a tree with the particular root hash. E.g., if one wants to prove that <span class="math">data_{4}</span> (Fig. 2) is included in the MHT tree with the root hash <span class="math">h_{1}</span>, they just need to provide a verifier with the data block along with a tuple of internal nodes <span class="math">(h_{43},h_{31},h_{22})</span> that will allow recalculating the tree root and comparing it to the provided root <span class="math">h_{1}</span>. We call it Merkle proof.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.3.</h6>

    <p class="text-gray-300">Succinct Non-Interactive Argument of Knowledge (SNARK). A SNARK is a proving system consisting of a triplet of algorithms (Setup, Prove, Verify) that allows proving satisfiability of a set of inputs to an arithmetic constraint system (see, e.g., <em>[6, 7]</em> for more formal definition and properties analysis).</p>

    <p class="text-gray-300">We define an arithmetic constraint system as a set of polynomials over a finite field <span class="math">F</span> in variables <span class="math">(x_{1},...,x_{r},y_{1},...,y_{s})</span>. A satisfying assignment for the given constraint system <span class="math">C</span> is an assignment of <span class="math">F</span> elements to <span class="math">x_{i}</span> and <span class="math">y_{j}</span> such that all polynomials evaluate to zero. We indicate a satisfying assignment as <span class="math">C(a,w)</span>, where <span class="math">a=(a_{1},...,a_{r})</span>, <span class="math">a_{i}\\in F</span> and <span class="math">w=(w_{1},...,w_{s})</span>, <span class="math">w_{j}\\in F</span>. We refer to <span class="math">a</span> as public input and <span class="math">w</span> as witness.</p>

    <p class="text-gray-300">Then, the algorithms <span class="math">(Setup,Prove,Verify)</span> are defined such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk,vk)\\leftarrow Setup(C,1^{\\lambda})</span> bootstraps SNARK for a constraint system <span class="math">C</span> under security parameter <span class="math">\\lambda</span>. The bootstrapped SNARK is specified by a pair of keys <span class="math">(pk,vk)</span> which are a proving key and a verification key correspondingly.</li>

      <li><span class="math">\\pi\\leftarrow Prove(pk,a,w)</span> evaluates a proof <span class="math">\\pi</span>, which confirms that <span class="math">(a,w)</span> is a satisfying assignment for <span class="math">C</span>.</li>

      <li><span class="math">true/false\\leftarrow Verify(vk,a,\\pi)</span> verifies that <span class="math">\\pi</span> is a valid proof attesting to the satisfying assignment <span class="math">(a,w)</span> for the constraint system <span class="math">C</span>.</li>

    </ol>

    <p class="text-gray-300">Algorithms <span class="math">(Setup,Prove,Verify)</span> satisfy the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any constraint system <span class="math">C</span> and <span class="math">(a,w)</span>, if <span class="math">\\pi\\leftarrow Prove(pk,a,w)</span> is a valid proof, then <span class="math">Verify(vk,a,\\pi)</span> is always true.</li>

      <li>Knowledge soundness. If a pair <span class="math">(a,w)</span> is not a satisfying assignment for <span class="math">C</span>, then the probability of obtaining <span class="math">\\pi</span> such that <span class="math">Verify(vk,a,\\pi)=true</span> is negligible.</li>

      <li>Succinctness. For every constraint system <span class="math">C</span> bootstrapped with <span class="math">(pk,vk)</span> and every <span class="math">a\\in F^{r}</span>, the size of a proof and verification time is polynomial in <span class="math">\\lambda</span>.</li>

    </ol>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Recursive SNARKs Composition for State Transitions</h3>

    <p class="text-gray-300">Here, we provide a high-level definition of the recursive proof composition technique that is used in our sidechain model to construct succinct proofs of state transitions. The idea of recursive proofs has been discussed, e.g., in <em>[6, 19, 8]</em>. What follows is based principally on the construction described in <em>[19]</em>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.4.</h6>

    <p class="text-gray-300">State Transition System. A state transition system is defined by a set of all possible states <span class="math">S</span>, a set of all possible transitions <span class="math">T</span>, and a transition function <span class="math">update(t_{i},s_{i})</span>, where <span class="math">s_{i}\\in S</span> and <span class="math">t_{i}\\in T</span>, which returns a new state <span class="math">s_{i+1}</span> or <span class="math">\\bot</span> in case <span class="math">(t_{i},s_{i})</span> does not constitute a valid input for the <span class="math">update</span> function.</p>

    <p class="text-gray-300">Speaking informally, we would like to define a SNARK that attests to many iterative state transitions. E.g., if we have transitions <span class="math">(t_{1},t_{2},...,t_{n})</span> that are applied sequentially to state <span class="math">s_{1}</span> to</p>

    <p class="text-gray-300">produce state <span class="math">s_{n+1}</span>, we would like to have a succinct proof of the following statement: “there exist such <span class="math">(t_{1},...,t_{n})</span> so that <span class="math">update(t_{n},update(t_{n-1},update(...,update(t_{1},s_{1}))))=s_{n+1}</span>”.</p>

    <p class="text-gray-300">By applying this to blockchain, we will be able to provide succinct proofs of transition between some states <span class="math">s_{i}</span> and <span class="math">s_{j}</span> (<span class="math">i&lt;j</span>). The state can be represented, for instance, as a list of unspent transaction outputs <em>[29]</em>, while transitions are regular blockchain transactions that spend some outputs and create new ones. This construction is of great value for verifiable sidechains.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.5.</h6>

    <p class="text-gray-300">Recursive SNARKs for state transition systems. We define recursive SNARKs composition as a tuple of SNARKs <span class="math">(Base,Merge)</span> such that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Base is a SNARK for a single transition that proves the existence of such <span class="math">t</span> so that <span class="math">s_{i+1}=update(t,s_{i})</span>. It is defined by a triplet (Setup, Prove, Verify) such that:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk^{Base},vk^{Base})\\leftarrow Setup(1^{\\lambda})</span> bootstraps Base SNARK;</li>

      <li><span class="math">\\pi^{Base}\\leftarrow Prove(pk^{Base},(s_{i},s_{i+1}),(t_{i}))</span> evaluates a proof <span class="math">\\pi^{Base}</span> that confirms <span class="math">s_{i+1}=update(t_{i},s_{i})</span>;</li>

      <li><span class="math">true/false\\leftarrow Verify(vk^{Base},(s_{i},s_{i+1}),\\pi^{Base})</span> verifies that <span class="math">\\pi^{Base}</span> is a valid proof attesting state transition from <span class="math">s_{i}</span> to <span class="math">s_{i+1}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Merge is a SNARK that merges two other SNARKs (either Base or Merge) proving the validity of transition between states <span class="math">s_{i}</span> and <span class="math">s_{j}</span> (<span class="math">i+1&lt;j</span>). It is defined by a triplet (Setup, Prove, Verify) such that:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk^{Merge},vk^{Merge})\\leftarrow Setup(1^{\\lambda})</span> bootstraps Merge SNARK;</li>

      <li><span class="math">\\pi^{Merge}\\leftarrow Prove(pk^{Merge},(s_{i},s_{j}),(s_{k},\\pi_{1}^{a},\\pi_{2}^{a}))</span> evaluates a proof <span class="math">\\pi^{Merge}</span> that confirms <span class="math">\\pi_{1}^{a}</span>, <span class="math">\\pi_{2}^{a}</span> are valid SNARKs (<span class="math">a\\in\\{Base,Merge\\}</span>), which attest state transitions from <span class="math">s_{i}</span> to <span class="math">s_{k}</span> and from <span class="math">s_{k}</span> to <span class="math">s_{j}</span> correspondingly. Altogether, it proves a valid transition from <span class="math">s_{i}</span> to <span class="math">s_{j}</span> (<span class="math">i&lt;k&lt;j</span>);</li>

      <li><span class="math">true/false\\leftarrow Verify(vk^{Merge},(s_{i},s_{j}),\\pi^{Merge})</span> verifies that <span class="math">\\pi^{Merge}</span> is a valid proof attesting state transition from <span class="math">s_{i}</span> to <span class="math">s_{j},i&lt;j</span>.</li>

    </ul>

    <p class="text-gray-300">We intentionally omit specifics of the recursive SNARKs composition, which in reality is more sophisticated. More details on the topic can be found, for instance, in <em>[19, 8]</em>. We defer the details of our construction for a separate paper. At this point, we provided only basic definitions, which allow us to describe the sidechain protocol while abstracting away the details of the SNARKs construction.</p>

    <h2 id="sec-12" class="text-2xl font-bold">3 General Overview</h2>

    <p class="text-gray-300">This section gives an overview of the sidechain concept in general and the main components of any sidechain design. We also briefly discuss our proposed solutions.</p>

    <p class="text-gray-300">Before going any further, we want to introduce abstract definitions of the terms mainchain and sidechain that are used throughout this paper.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">Mainchain (MC). The mainchain is a blockchain system based on the Bitcoin backbone protocol model <em>[11]</em>, which maintains a public ledger of asset-transfer transactions. Additionally, the mainchain supports a standardized mechanism to register and interact with separate sidechain systems. By interaction, we mean the cross-chain transfer protocol, which enables sending a native asset to a sidechain and receiving it back in a secure and verifiable way without the need to know anything about the internal sidechain construction or operations.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">Sidechain (SC). The sidechain is a separate system attached to the mainchain by means of a cross-chain transfer protocol.</p>

    <p class="text-gray-300">Speaking informally, we consider the mainchain to be a blockchain platform that supports basic payment functionality with some native asset <em>Coin</em> (e.g. Bitcoin <em>[20]</em>, Horizen <em>[26]</em>, etc.). Then, the sidechain is an attached domain-specific platform that also uses the <em>Coin</em> asset (but not limited to it). In our model, we consider a single mainchain with many sidechains attached to it.</p>

    <p class="text-gray-300">The definition of a sidechain (as in Def. 3.2) does not imply the usage of any particular data structure or consensus algorithm. The mainchain is totally agnostic to the sidechain construction. It can be another decentralized blockchain, some centralized database maintained by the predefined authority, or more generally, an arbitrary application.</p>

    <p class="text-gray-300">The need to introduce sidechains in a general payment-based blockchain system comes from the need to allow the creation of different blockchain applications that use the same mainchain asset. Creation of such applications directly on the mainchain is not always possible due to inherent technological limitations, such as restricted throughput, expensive storage, etc. Sidechains effectively solve these problems.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 Main Components of a Sidechain Design</h3>

    <p class="text-gray-300">Analyzing existing attempts to design sidechains <em>[12, 5, 25, 18, 16, 13, 14]</em>, we may outline three basic components that underlie any sidechain architecture:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mainchain consensus protocol (MCP).</li>

      <li>Cross-chain transfer protocol (CCTP).</li>

      <li>Sidechain consensus protocol (SCP).</li>

    </ol>

    <p class="text-gray-300">Depending on a specific design, these components can be highly coupled with each other or decoupled so that the mainchain is almost independent from any particular sidechain implementation.</p>

    <p class="text-gray-300">In our construction, we aspire to multipurposeness and, thus, designing a system so that the MCP and SCP are completely decoupled. The CCTP is naturally a bridge between them and is unified and fixed by the mainchain consensus protocol. On the other end, the SCP can be freely defined by a sidechain developer. This allows a variety of different sidechains with different purposes to thrive while not requiring any changes to the mainchain.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Cross-chain transfer protocol.</h5>

    <p class="text-gray-300">The CCTP protocol defines the communication between the mainchain and sidechain(s). Basically, it is a 2-way peg protocol that allows sending coins back and forth. At a high level, it defines two basic operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Forward Transfer, and</li>

      <li>Backward Transfer.</li>

    </ul>

    <p class="text-gray-300">A forward transfer sends coins from the mainchain to a sidechain. A backward transfer, correspondingly, moves coins back from the sidechain to the mainchain. These operations are the cornerstone of overall sidechain construction. The backward transfer is of particular importance since we do not want to oblige the mainchain to track sidechains and, thus, it cannot directly verify the validity of withdrawals coming from them. That is why most of the focus in developing sidechains is directed toward constructing secure and reliable backward transfers.</p>

    <p class="text-gray-300">In our approach, Zendoo, we consider a forward transfer as a special transaction on the mainchain that destroys coins and provides sidechain-specific metadata allowing a user to receive</p>

    <p class="text-gray-300">coins in the sidechain. Implementation of forward transfers is straightforward as it does not require the mainchain to know anything about the sidechain state for validation.</p>

    <p class="text-gray-300">A more complex procedure is required for backward transfers. They are initiated in the sidechain as special transactions, batched in a <em>withdrawal certificate</em>, and propagated to the mainchain for processing. Since we do not want the MC to follow the SC state – as this would impose enormous computational and storage burden on the MC and, thus, undermine the whole point of having sidechains – the question arises how to implement validation of backward transfers in the most efficient and secure way.</p>

    <p class="text-gray-300">In our previous paper <em>[12]</em>, this problem has been addressed by introducing into the system a special type of decentralized actors – <em>certifiers</em> – that were registering themselves in the MC and were responsible for signing withdrawal certificates. Although the safety of this approach has been shown, it requires certain assumptions about an honest majority of certifiers, which, in some scenarios, may not be the case.</p>

    <p class="text-gray-300">In Zendoo, we avoid direct reliance on certifiers or any other special type of actors assigned to validate withdrawal certificates. Instead, we are going to leverage SNARKs <em>[6, 7, 19]</em> to provide means for the mainchain to effectively validate withdrawals.</p>

    <p class="text-gray-300">Sidechain consensus protocol. We consider the SCP as a generalized notion that encompasses all the details about a particular sidechain construction such as consensus algorithm, accounting system, types of supported transactions, incentives mechanism, a protocol for withdrawal certificate generation, etc. Also, importantly, each sidechain defines its own SNARK that is used to validate withdrawal certificates. This provides flexibility to define its own rules for backward transfers. For instance, a sidechain can adopt a chain-of-trust model <em>[13]</em> or even the certifiers model <em>[12]</em>. It is completely decoupled from the mainchain consensus protocol, which will just invoke a unified verifier to validate a proof.</p>

    <p class="text-gray-300">Even though the SCP can be designed in different ways, we propose one specific construction of a decentralized verifiable sidechain based on the Ouroboros protocol <em>[17]</em>. We will call this construction Latus. In short, we are going to use recursive composition of SNARKs to generate succinct proofs of sidechain state transitions. Each withdrawal certificate commits to the SC state whereas the SNARK proof validates transition between states committed by successive withdrawal certificates. Since backward transfers are a part of the sidechain state transition, they are also validated by the proof.</p>

    <p class="text-gray-300">The following section <em>[4]</em> introduces Zendoo, a cross-chain communication protocol for sidechains which is principally about the definition of the transfer protocol and how a new sidechain can be registered in the mainchain. It defines the sidechains design from the mainchain point of view. Then, in section <em>[5]</em>, we describe in detail the proposed sidechain construction Latus.</p>

    <h2 id="sec-17" class="text-2xl font-bold">4 Zendoo: a Cross-Chain Transfer Protocol for Sidechains</h2>

    <p class="text-gray-300">The following section provides details about the communication protocol between the mainchain and sidechains, which is primarily represented by the cross-chain transfer protocol. We show how the CCTP protocol is integrated in the mainchain, what interfaces are provided, and how a new sidechain can be created.</p>

    <p class="text-gray-300">4.1 Cross-Chain Transfer Protocol</p>

    <p class="text-gray-300">The cross-chain transfer protocol is the cornerstone of our sidechain design as it connects the mainchain with all sidechains spawned from it. Its main function is to allow sending coins to sidechains and receiving them back in a secure and reliable way. This section provides a high-level specification of forward and backward transfers and how they are integrated into the mainchain.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">4.1.1 Forward Transfers</h4>

    <p class="text-gray-300">The design of forward transfers is straightforward and similar to many existing proposals for sidechains <em>[5, 25, 18, 16, 13]</em> as well as to our original proposal <em>[12]</em>.</p>

    <p class="text-gray-300">On the mainchain side, it is implemented as a special type of operation (we will call it Forward Transfer) that destroys coins and provides metadata for withdrawing coins in a sidechain. Then, it is the responsibility of the sidechain to sync forward transfers from the MC and issue the corresponding amount of coins.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">Forward Transfer (FT). Forward Transfer is an operation that moves coins from the original blockchain A (the mainchain) to the destination sidechain B. It is represented by a tuple of the form:</p>

    <p class="text-gray-300"><span class="math">FT\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receiveMetadata,\\ amount),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{lcl}ledgerId&-\\ \\text{a unique identifier of a previously created and active sidechain to}\\\\ &which\\ coins\\ are\\ transferred;\\\\ amount&-\\ \\text{a number of coins to transfer;}\\\\ receiveMetadata&-\\ \\text{some metadata for receiving sidechain}\\ B\\ \\text{(e.g., a receiver's address); its}\\\\ &structure\\ \\text{is not fixed in the mainchain and can consist of different}\\\\ &variables\\ \\text{of predefined types depending on a sidechain's construction;}\\\\ &its\\ \\text{semantic meaning is not known to the mainchain.}\\end{array} \\]</p>

    <p class="text-gray-300">There can be several approaches to integrate forward transfers on the mainchain side depending on its details. For instance, forward transfer can be a separate transaction type which destroys coins in the mainchain, or, in the case of a UTXO-based blockchain system (e.g. Bitcoin or Horizen), we can consider FT as a special unspendable transaction output in a regular multi-input multi-output transaction <em>[29, 4]</em>.</p>

    <p class="text-gray-300">To be more specific and facilitate further reading, we assume that the mainchain has a UTXO-based accounting model. Then, a regular transaction with forward transfers may have the following structure:</p>

    <pre><code class="language-txt">type Transaction {
Inputs: {
Input(addr: 0x013A.., amount: 5, signature: 0x034B..),
Input(addr: 0x0930.., amount: 3, signature: 0x1AA1..),
...
}
Outputs: {
Output(addr: 0x023B.., amount: 1),
Output(addr: 0x0732.., amount: 2),
ForwardTransfer(ledgerId: 0x300C.., receiverInfo: 0x139D.., amount: 2),
ForwardTransfer(ledgerId: 0x300C.., receiverInfo: 0x893D.., amount: 3),
...
}</code></pre>

    <p class="text-gray-300">Given that an FT is a non-spendable output, it basically destroys coins in the mainchain, and the amount of transferred coins is verified by the mainchain as part of the overall transaction verification.</p>

    <p class="text-gray-300">The backward transfer protocol allows coins to move from a sidechain to the mainchain, and, as in [12] and [13], it relies on the idea of batched transfers. This means that all requested backward transfers submitted to the sidechain during a certain period - called the "withdrawal epoch" - are collected in a special withdrawal certificate and pushed to the mainchain for processing.</p>

    <p class="text-gray-300">Withdrawal certificates are more than just a container for backward transfers, they are a kind of sidechain heartbeat that is periodically submitted to the mainchain even though there might be no backward transfers <span class="math">^3</span> .</p>

    <p class="text-gray-300">A withdrawal epoch is defined by a range of MC blocks. Withdrawal epochs for different sidechains are not aligned and may have a different length (epoch_len parameter is set upon sidechain creation), and, therefore, the entire system runs asynchronously.</p>

    <p class="text-gray-300">Let us define an MC block  <span class="math">B</span>  that belongs to a specific epoch as  <span class="math">B_{j}^{ep\\_id}</span> , where  <span class="math">ep\\_id</span>  is the epoch number and  <span class="math">j \\in [0, epoch\\_len)</span>  is the serial number of the block within the epoch (Fig. 3).</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Withdrawal epochs in the mainchain. Note that withdrawal epochs for different sidechains may not overlap. It depends on parameters that have been set upon sidechain creation.</p>

    <p class="text-gray-300">The sidechain is obliged to submit a withdrawal certificate for epoch  <span class="math">i</span>  during the first submit_len blocks of the epoch  <span class="math">i + 1</span>  (submit_len is a system parameter). If a withdrawal</p>

    <p class="text-gray-300">certificate has not been submitted during this time, the sidechain is considered ceased (see Def. 4.2) and no more withdrawal certificates for this sidechain will be accepted by the mainchain (however, the funds can still be withdrawn with a ceased sidechain withdrawal <em>[4.1.2.1]</em>).</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Ceased Sidechain. A sidechain is deemed ceased by the mainchain if a withdrawal certificate for that sidechain has not been submitted on time, i.e. a certificate for withdrawal epoch <span class="math">i</span> has not been submitted during the first <span class="math">submit\\_len</span> blocks of the epoch <span class="math">i+1</span>.</p>

    <p class="text-gray-300">Note that the mainchain consensus protocol does not impose any rules on how exactly a withdrawal certificate should be generated and by whom it should be submitted. It is up to the sidechain to define corresponding procedures. We only assume that it is submitted by means of a special transaction in the mainchain.</p>

    <p class="text-gray-300">As it has been mentioned, a withdrawal certificate contains backward transfers. We may consider them as requests that are fulfilled once included in the withdrawal certificate and propagated to the mainchain. There are no restrictions for how backward transfers should be submitted and collected (e.g. it can be a separate transaction on the SC side).</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">Backward Transfer (BT). Backward Transfer is an operation that moves coins from the sidechain <span class="math">B</span> to the original mainchain <span class="math">A.</span> It is represented by a tuple of the form:</p>

    <p class="text-gray-300"><span class="math">BT\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (receiverAddr,\\ amount),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">receiverAddr</span> <span class="math">-</span> an address in the mainchain where transferred coins should be credited; <span class="math">amount</span> <span class="math">-</span> the number of transferred coins.</p>

    <p class="text-gray-300">There can be different approaches to integrate backward transfers in the mainchain. Following the assumption of a UTXO-based mainchain, a BT can be represented by a special output in a transaction with a withdrawal certificate.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <p class="text-gray-300">Withdrawal Certificate (WCert). Withdrawal certificate is a standardized posting that allows sidechains to communicate with the mainchain. Its main functions are:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>delivering backward transfers to the MC; and</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>serving as a heartbeat message enabling the MC to identify SC status.</li>

    </ol>

    <p class="text-gray-300">It is represented by a tuple of the form:</p>

    <p class="text-gray-300"><span class="math">WCert\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ epochId,\\ quality,\\ BTList,\\ proofdata,\\ proof),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300">ledgerId <span class="math">-</span> an identifier of the sidechain for which WCert is created; epochId <span class="math">-</span> a number of a withdrawal epoch; quality <span class="math">-</span> an integer value that indicates the quality of this withdrawal certificate (explained later); BTList <span class="math">-</span> a list of backward transfers included in this withdrawal certificate; proofdata <span class="math">-</span> input data to a SNARK verifier; proof <span class="math">-</span> a SNARK proof.</p>

    <p class="text-gray-300">Now, we discuss in more detail the substance of certificate parameters as it is one of the most important parts of the sidechain design.</p>

    <p class="text-gray-300">As it has been briefly outlined, the basis of the proposed construction is that there are no special entities that authorize withdrawal certificates (e.g., like certifiers in <em>[12]</em> or slot leaders in <em>[13]</em>). Instead, the certificate authorization and validation rely completely on the included SNARK proof, and the SNARK itself is defined by the sidechain. The mainchain knows only the verification key – which is registered upon sidechain creation – and the interface of the verifier, which is unified for all sidechains. If the SNARK proof and public parameters are valid, then the certificate gets included and processed in the mainchain.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Withdrawal certificate quality.</h5>

    <p class="text-gray-300">It might happen that several withdrawal certificates appear for the same sidechain in the same withdrawal epoch. Since only one WCert should be selected among them and given that the mainchain does not know about the sidechain consensus protocol and does not track its state, there should be a mechanism for the mainchain to decide which certificate is the best one. Such a mechanism is realized through the <em>quality</em> parameter: the mainchain adopts a certificate with the highest quality or the one that was submitted first in case there are several certificates with equal qualities. The validity of the quality parameter is enforced by the SNARK proof.</p>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Withdrawal certificate verification.</h5>

    <p class="text-gray-300">Verification of a newly submitted WCert on the mainchain is performed using the following basic rules:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>ledgerId</em> should be an identifier of a currently active sidechain;</li>

      <li><em>epochId</em> should be a valid withdrawal epoch number for the <span class="math">ledgerId</span> (remember that the certificate should be submitted during the first <span class="math">submit\\_len</span> blocks of the epoch following the one, for which such certificate was created);</li>

      <li><em>quality</em> should be higher than the quality of the previously submitted withdrawal certificate for this epoch; if it is the first WCert for this epoch - any quality is accepted;</li>

      <li><em>proof</em> should be a valid SNARK proof whose verification key <span class="math">vk_{WCert}</span> is set upon sidechain registration;</li>

    </ol>

    <p class="text-gray-300">SNARK verification is the most essential part of the verification procedure as it encapsulates verification of backward transfers and other parameters provided within the certificate. The basic SNARK verifier interface is the following:</p>

    <p class="text-gray-300"><span class="math">true/false\\leftarrow Verify(vk_{WCert},\\ public\\_input,\\ proof),</span> <span class="math">public\\_input\\ \\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\ (wcert\\_sysdata,\\ MH(proofdata)),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">vk_{WCert}</span> – a SNARK verification key registered upon the sidechain creation; <span class="math">wcert\\_sysdata</span> – a part of the public input, which is unified for all sidechains and enforced by the mainchain (explained further); <span class="math">proofdata</span> – a part of the input data that is defined by the sidechain and passed along the withdrawal certificate; it is basically a list of variables of predefined types whose semantics are not known to the mainchain; <span class="math">MH(proofdata)</span> – a root hash of a Merkle tree where leaves are variables from proofdata; it is essential for the SNARK to keep a list of public inputs short, thus we combine them in a tree and pass the root hash only; <span class="math">proof</span> – a SNARK proof itself submitted as a part of the certificate.</p>

    <p class="text-gray-300">wcert_sysdata parameter plays an important role from the security standpoint. The idea is to allow the mainchain to verify the proof against some public input parameters that are defined by the protocol. For instance, the BTList and quality parameters that are part of the certificate must be verified before being used by the mainchain. Another example is the mainchain block hashes of the epoch boundaries that must be verified to guarantee that the proof refers to the current epoch and the active chain.</p>

    <p class="text-gray-300">wcert_sysdata is represented by the tuple of the following form:</p>

    <p class="text-gray-300"><span class="math">wcert\\_sysdata\\ \\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\ (quality,\\ MH(BTList)),\\ H(B_{last}^{i-1}),\\ B_{(last}^{i})),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">quality</span> – the quality parameter from the withdrawal certificate; <span class="math">MH(BTList)</span> – a root hash of a Merkle tree where leaves are backward transfers from the BTList provided within the certificate; <span class="math">H(B_{last}^{i-1})</span> – a block hash of the last mainchain block in the withdrawal epoch <span class="math">i-1</span> (given that the certificate is for the epoch <span class="math">i</span>); <span class="math">H(B_{last}^{i})</span> – a block hash of the last mainchain block in the withdrawal epoch <span class="math">i</span>.</p>

    <p class="text-gray-300">The generalized SNARK verifier provides flexibility to implement different SNARKs for different sidechain models. For instance, one may want to implement the sidechain with a centralized cross-chain transfer protocol where withdrawal certificates are verified by a signature from an authorized entity. Or, conversely, a completely decentralized verifiable sidechain can be constructed as will be discussed in <em>[5 The Latus Sidechain]</em>).</p>

    <p class="text-gray-300">Succinct proofs and constant time verification make the overall sidechain design particularly appealing as it does not impose a significant burden for the mainchain.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">4.1.2.1 Mainchain Managed Withdrawals</h5>

    <p class="text-gray-300">There might be cases when a user would want to request a backward transfer directly from the mainchain rather than creating a BT in the SC. For instance, it would allow users to withdraw funds in case of a misbehaving (e.g., maliciously controlled sidechain that censors submission of backward transfers) or ceased sidechain.</p>

    <p class="text-gray-300">Hence, we introduced two additional mechanisms that allow users to make withdrawals directly in the mainchain:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Backward transfer request (BTR), and</li>

      <li>Ceased sidechain withdrawal (CSW).</li>

    </ol>

    <p class="text-gray-300">We consider each of them as a special type of transaction. Similar to withdrawal certificates, such operations are secured by SNARK proofs.</p>

    <p class="text-gray-300">The BTR is used to withdraw funds from an active sidechain if for some reason a user cannot create a backward transfer inside the sidechain. The idea is that all BTRs submitted to the mainchain will be synchronized to the sidechain and processed there to verify their legitimacy and include the corresponding backward transfers in the next WCert using the standard flow. Such processing can be enforced by the withdrawal certificate SNARK to force a maliciously controlled sidechain to process user’s withdrawals. Importantly, the BTR does not lead to a direct coin transfer in the mainchain.</p>

    <p class="text-gray-300">The CSW is used to withdraw funds from ceased sidechains. Since withdrawal certificates are not allowed for ceased sidechains, it becomes the only way to retrieve funds. A valid CSW makes direct payment to the submitter.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Definition 4.5.</h6>

    <p class="text-gray-300">Backward transfer request (BTR). The BTR is a generic request for a backward transfer that is submitted on the mainchain. It is represented by the following tuple:</p>

    <p class="text-gray-300"><span class="math">BTR\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receiver,\\ amount,\\ nullifier,\\ proofdata,\\ proof),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">ledgerId</span> <span class="math">-</span> an identifier of the sidechain, for which BTR is created; <span class="math">receiver</span> <span class="math">-</span> an address of the receiver on the mainchain; <span class="math">amount</span> <span class="math">-</span> the number of coins to be transferred; <span class="math">nullifier</span> <span class="math">-</span> a unique identifier of claimed coins; <span class="math">proofdata</span> <span class="math">-</span> input data to a SNARK verifier; <span class="math">proof</span> <span class="math">-</span> a SNARK proof.</p>

    <p class="text-gray-300">As in the case with a withdrawal certificate, the SNARK for the BTR is defined by the sidechain and represented by the verification key <span class="math">vk_{BTR}</span>, which is set upon sidechain registration.</p>

    <p class="text-gray-300">The syntax of the <span class="math">proofdata</span> and <span class="math">proof</span> are the same as for the withdrawal certificate. The basic interface of the SNARK verifier is the following:</p>

    <p class="text-gray-300"><span class="math">true/false\\leftarrow Verify(vk_{BTR},\\ public\\_input,\\ proof),</span> <span class="math">public\\_input\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (btr\\_sysdata,\\ MH(proofdata)),</span></p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">vk_{BTR}</span> is a SNARK verification key for the BTR registered upon the sidechain creation;</p>

    <p class="text-gray-300"><span class="math">btr\\_sysdata,\\ proofdata,\\ MH(\\cdot)</span>, and <span class="math">proof</span> have the same meaning as similar parameters in the withdrawal certificate.</p>

    <p class="text-gray-300"><span class="math">btr\\_sysdata</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">btr\\_sysdata\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (H(B_{w}),\\ nullifier,\\ receiver,\\ amount),</span></p>

    <p class="text-gray-300">where <span class="math">H(B_{w})</span> is a block hash of the mainchain block where the latest withdrawal certificate for this sidechain has been submitted.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Definition 4.6.</h6>

    <p class="text-gray-300">Ceased Sidechain Withdrawal (CSW). The CSW is an operation that allows the movement of coins from the ceased sidechain B to the original mainchain A. It is represented by a tuple of the following form:</p>

    <p class="text-gray-300"><span class="math">CSW\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receiver,\\ amount,\\ nullifier,\\ proofdata,\\ proof),</span></p>

    <p class="text-gray-300">where all parameters have the same meaning as in the case of the BTR.</p>

    <p class="text-gray-300">As it can be seen, BTR and CSW have the same structure, though conceptually they are different because CSW performs direct payment while BTR does not. The interface of the SNARK verifier for the CSW is completely the same as for the BTR.</p>

    <p class="text-gray-300">Additionally, we discuss the role of nullifiers in both BTR and CSW. In the mainchain, a nullifier is an abstract identifier of claimed coins. The mainchain will not allow the submission of two transactions with the same nullifier. The main reason for having the nullifier is to prevent repeated submission of BTRs or CSWs that try to withdraw the same coins (thus, essentially doing double spend). Since the mainchain does not maintain the sidechain state, at the very least, for ceased sidechains, it requires some abstract double-spend prevention mechanism, which is exactly what is provided by nullifiers.</p>

    <p class="text-gray-300">Note that both BTR and CSW are just complementary operations to allow more flexibility in some subtle use cases or in the case of a malfunctioning sidechain. It is up to the sidechain to define how they are used. For instance, one can omit defining these operations at all (e.g., by setting <span class="math">vk_{BTR}</span> and <span class="math">vk_{CSW}</span> to NULL), thus completely relying on the normal withdrawal procedure through withdrawal certificates.</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">4.1.2.2 Withdrawal Safeguard</h5>

    <p class="text-gray-300">The safeguard is a special feature introduced to prevent unlimited withdrawals from a sidechain to the mainchain in the case of the malicious sidechain. The essence of the safeguard function is to maintain the balance of each created sidechain and to prevent withdrawing an amount larger than what was previously transferred to that sidechain. A similar idea was introduced in <em>[13]</em> and <em>[12]</em>.</p>

    <p class="text-gray-300">Implementation of the safeguard feature is simple: for each created sidechain, a special balance variable is maintained by the mainchain. Each forward transfer increases the balance by the transferred number of coins, and each withdrawal certificate, or ceased sidechain withdrawal reduces the balance by the withdrawn amount. The WCert and CSW cannot withdraw more coins than are stored in the sidechain balance.</p>

    <p class="text-gray-300">This feature prevents possible implications of sidechain corruption. It guarantees that only the transferred number of coins can be withdrawn back to the mainchain. Even in the case of total corruption or a maliciously constructed sidechain, an adversary cannot mint coins out of thin air.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">4.1.3 Sidechain Transactions Commitment</h4>

    <p class="text-gray-300">So far, we defined 4 types of actions (that are either separate transactions or outputs in a regular transaction) that determine cross-chain communication from the mainchain point of view:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Forward Transfer (FT).</li>

      <li>Withdrawal Certificate (WCert).</li>

      <li>Backward Transfer Request (BTR).</li>

      <li>Ceased sidechain withdrawal (CSW).</li>

    </ol>

    <p class="text-gray-300">To facilitate efficient implementation of the synchronization between the mainchain and sidechains, we modify the structure of a mainchain block header to include an additional value that commits to all sidechain-related actions in the MC block (except the CSW because it is used only when the SC is ceased). This value is a root hash of a Merkle tree that contains</p>

    <p class="text-gray-300">all transactions or outputs related to any sidechain (see Fig. 4). We call it the Sidechain Transactions Commitment (SCTxsCommitment).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Sidechain transactions commitment tree. The root hash  <span class="math">h_1</span>  commits to all sidechain related transactions (for all sidechains) included in the MC block. All SCXHash, where  <span class="math">X</span>  is a sidechain identifier, are ordered by the id and commit to all transactions related to the sidechain  <span class="math">X</span> . WCertHash commits to the WCert for the sidechain  <span class="math">X</span>  (if present); only one WCert is allowed for each sidechain.  <span class="math">TxsHash</span>  commits to FTs and BTRs.</p>

    <p class="text-gray-300">Having  <span class="math">SCTxsCommitment</span>  in the MC block header allows SC nodes to synchronize and verify SC-related transactions without the need to transmit the entire MC block. Also, it allows the construction of a SNARK proving that all SC-related transactions of the specific MC block have been processed correctly.</p>

    <p class="text-gray-300">We assume that the mainchain implements a special transaction that allows one to create a sidechain. Such a transaction can be submitted by anyone, and it registers the SC in the mainchain and sets its unique identifier and some system parameters. Once the sidechain is created, a schedule of withdrawal epochs is defined deterministically, and forward/backward transfers must be processed in the mainchain.</p>

    <p class="text-gray-300">The following set of SC parameters are set upon creation:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ledgerId</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- a unique identifier of the sidechain that has not been used;</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">start_block</td>

            <td class="px-3 py-2 border-b border-gray-700">- the block number in the mainchain, from which the first withdrawal epoch begins; this parameter defines when the sidechain becomes active;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">epoch_len</td>

            <td class="px-3 py-2 border-b border-gray-700">- the length of a withdrawal epoch (in MC blocks);</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">submit_len</td>

            <td class="px-3 py-2 border-b border-gray-700">- the period length - starting from the first block of the withdrawal epoch - when a withdrawal certificate for the previous epoch must be submitted to the mainchain;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">wcert_vk</td>

            <td class="px-3 py-2 border-b border-gray-700">- a SNARK verification key vkWCert for WCert proofs;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">btr_vk</td>

            <td class="px-3 py-2 border-b border-gray-700">- a SNARK verification key vkBTR for BTR proofs;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">csw_vk</td>

            <td class="px-3 py-2 border-b border-gray-700">- a SNARK verification key vkCSW for CSW proofs;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">wcert_proofdata</td>

            <td class="px-3 py-2 border-b border-gray-700">- the definition of the proofdata structure for the withdrawal certificate; it defines the number and types of included data elements;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">btr_proofdata</td>

            <td class="px-3 py-2 border-b border-gray-700">- the definition of the proofdata structure for the BTR;</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">csw_proofdata</td>

            <td class="px-3 py-2 border-b border-gray-700">- the definition of the proofdata structure for the CSW.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Customizable parameters give flexibility in choosing those, which are suitable for a particular sidechain. The triplet  <span class="math">(cer\\_ vk, btr\\_ vk, csw\\_ vk)</span>  is especially important as it defines how the mainchain verifies backward communication from the sidechain. These keys define SNARKs for corresponding operations eventually enabling different designs for sidechains.</p>

    <p class="text-gray-300">In the previous section, we described the general sidechain design. Mostly, it was about defining the cross-chain transfer protocol, which provides a communication interface with the mainchain. In this section, we focus on a specific sidechain construction. We give an example of how a decentralized verifiable sidechain can be built on top of the given CCTP.</p>

    <p class="text-gray-300">The general idea is to utilize a recursive composition of SNARKs to construct a succinct proof of the sidechain state progression for the period of a withdrawal epoch. Then, a SNARK for a withdrawal certificate is constructed so that it proves correct sidechain state transition for the whole epoch and validates backward transfers. This allows the mainchain to efficiently verify the sidechain without having to rely on any intermediary - such as certifiers [12] - and still be oblivious to the sidechain construction and interactions within.</p>

    <p class="text-gray-300">In this section, we provide details of the proposed Latus sidechain that implements decentralized permissionless blockchain  <span class="math">\\mathcal{B}_{\\mathcal{SC}}</span>  with a proof-of-stake based consensus protocol. We consider  <span class="math">\\mathcal{B}_{\\mathcal{SC}}</span>  as a simple ledger of payment transactions. We assume that  <span class="math">\\mathcal{B}_{\\mathcal{SC}}</span>  does not possess its own native asset and, instead, uses only Coin asset transferred from the mainchain by means of the CCTP. Additionally, we assume that the mainchain is a classical proof-of-work based blockchain system with Nakamoto consensus [20] (e.g., Horizen [26]).</p>

    <p class="text-gray-300">We use a similar consensus protocol as in our previous proposal [12] with some minor adjustments. It is based on a modified version of the Ouroboros proof-of-stake consensus protocol [17].</p>

    <p class="text-gray-300">In Ouroboros, time is divided into epochs with a predefined number of slots. Each slot is assigned with a slot leader who is authorized to generate a block during this slot. Slot leaders of a particular epoch are chosen randomly before the epoch begins from the set of all sidechain stakeholders (Fig. 5). The protocol operates in a synchronous environment where each slot takes a specific amount of time (e.g., 20 seconds).</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 5: A general scheme of an epoch. Note that even though there is an assigned slot leader for each slot, the leader may skip block generation, and in this case, the slot remains empty.</p>

    <p class="text-gray-300">Epoch. An epoch is a sequence of the  <span class="math">k</span>  successive slots  <span class="math">E p_{i} = (s l_{i}^{0}, s l_{i}^{1}, \\dots, s l_{i}^{k-1})</span> , where  <span class="math">k</span>  is the predefined length of the epoch and  <span class="math">i</span>  is the epoch sequence number.</p>

    <p class="text-gray-300">Slot. A slot is a specific period in time during which a slot leader is authorized to issue a block. Each slot has the corresponding slot leader who is chosen randomly before the epoch begins. A slot leader may skip generating a block, in this case, the following block will refer to the latest generated block.</p>

    <p class="text-gray-300">Slot Leader. The slot leader of the slot  <span class="math">sl_i^j</span>  is a stakeholder who was authorized by the Slot Leader Selection Procedure to forge a block at slot  <span class="math">sl_i^j</span> .</p>

    <p class="text-gray-300">Slot Leader Selection Procedure. The slot leader selection procedure  <span class="math">Select(SD_{Ep_i}, rand)</span>  is a procedure that selects all slot leaders of the epoch  <span class="math">Ep_i</span>  according to the fixed stake distribution  <span class="math">SD_{Ep_i}</span>  and some random value  <span class="math">rand</span> . The stake distribution  <span class="math">SD_{Ep_i}</span>  is fixed before the epoch  <span class="math">Ep_i</span>  begins. The randomness  <span class="math">rand</span>  is revealed only after the stake distribution is fixed.</p>

    <p class="text-gray-300">In our construction, we additionally introduce binding with the mainchain. This implies that sidechain blocks contain references to mainchain blocks so that their history is preserved in the sidechain. The chain resolution algorithm is altered to enforce that the sidechain follows the longest mainchain branch.</p>

    <p class="text-gray-300">As a "mainchain block reference", we consider a whole mainchain block header together with transactions related to the referencing sidechain.</p>

    <p class="text-gray-300">Sidechain block forgers are obliged to keep mainchain references consistent and ordered when included in SC blocks. A sidechain block  <span class="math">SB_{j}</span>  can contain a reference to the mainchain block  <span class="math">B_{i}</span>  if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the block  <span class="math">B_{i}</span>  is a valid mainchain block, and</li>

      <li>references to all previous mainchain blocks  <span class="math">B_{k}</span> ,  <span class="math">k \\in \\{\\eta, \\eta + 1, \\dots, i - 1\\}</span>  have been already included in sidechain blocks (also considering the current one, as a sidechain block may contain more than one reference), where  <span class="math">\\eta</span>  is the genesis reference (Fig. 6).</li>

    </ol>

    <p class="text-gray-300">Even though it is not mandatory for the block forgers to include mainchain references, we assume that honest block forgers will do this to support the cross-chain transfer protocol between chains. It is also possible to construct an incentive mechanism for block forgers who include references. For instance, users who initiate forward/backward transfers may pay some fee from</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 6: An example of the sidechain binding to the mainchain.</p>

    <p class="text-gray-300">each transaction. The incentive mechanism is beyond the scope of the current paper as we only provide an example of a sidechain consensus protocol.</p>

    <p class="text-gray-300">The binding to the mainchain provides two important properties of our sidechain construction:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Deterministic synchronization between the MC and the SC. When the sidechain block  <span class="math">SB_{i}</span>  refers to the mainchain block  <span class="math">B_{j}</span> , it explicitly acknowledges all transactions included in the block  <span class="math">B_{j}</span> . It means that if  <span class="math">B_{j}</span>  contains any transactions related to this sidechain (by transactions, we mean forward transfers and backward transfer requests), such transactions are immediately included in the sidechain (see Fig. 7).</li>

    </ol>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 7: An example of transaction synchronization between the mainchain and the sidechain: MC block  <span class="math">B_{i}</span>  contains one SC-related transaction  <span class="math">mc\\_tx_{MC\\rightarrow SC}^{1}</span> , which is also included in the SC block  <span class="math">SB_{j}</span>  because it refers to  <span class="math">B_{i}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Mainchain forks resolution. It is known that Nakamoto consensus does not provide finality on a chain of blocks [24]. It means that there is always a non-zero probability that some sub-chain of MC blocks will be reverted and substituted by another sub-chain with the more cumulative work. Such behaviour is normally handled by the mainchain but may be disastrous for the sidechain because  <span class="math">MC \\to SC</span>  transactions that are already confirmed in the sidechain may be reverted in the mainchain. The binding eliminates such situations because in the case of a fork in the MC, SC blocks that refer to forked blocks in the MC would also be reverted.</li>

    </ol>

    <p class="text-gray-300">Security. The standard procedure for proving blockchain consensus protocol security requires demonstrating the ability of the protocol to satisfy two fundamental properties of a distributed ledger: liveness and persistence [11]. Liveness ensures that transactions broadcasted by honest parties will be eventually included in the ledger, and persistence ensures that once a transaction is confirmed by one honest node, it will also be confirmed by all other honest</p>

    <p class="text-gray-300">nodes (so that eventually it becomes final and immutable). Such properties are usually proven under certain assumptions, such as honest majority among protocol participants, etc. We refer the interested readers to the original Ouroboros paper [17] for an exhaustive list of assumptions and properties analysis.</p>

    <p class="text-gray-300">Since the proposed consensus protocol also incorporates binding with the mainchain, it implies an additional assumption of the honest hashing power majority in the mainchain.</p>

    <p class="text-gray-300">We suppose that under these assumptions the proposed protocol derives security guarantees provided by original Ouroboros and Nakamoto consensus protocols.</p>

    <p class="text-gray-300">We want to emphasize that different types of sidechains may adopt different consensus protocols that better suit specific use cases (e.g., fast coin transferring support). A sidechain consensus protocol (including the one described in this section) is not the focus of this research and needs further analysis.</p>

    <p class="text-gray-300">As it has been described in section [4.1.2 Backward Transfers], the Cross-Chain Transfer Protocol introduces the notion of a withdrawal epoch <span class="math">^8</span>  (WE), which is defined as a fixed-length range of MC blocks (length is set upon SC creation). The concept of withdrawal epochs is essential for commanding backward transfers.</p>

    <p class="text-gray-300">Following this design, we also introduce withdrawal epochs in a sidechain which coincide with the mainchain withdrawal epochs. A WE is defined as a range of SC blocks where the first and last blocks of the range are determined by references to the first and last MC blocks in the corresponding withdrawal epoch in the MC (see Fig. 8).</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 8: An example of a withdrawal epoch in the sidechain.</p>

    <p class="text-gray-300">Even though a withdrawal epoch in the SC may have variable length (as it depends on when corresponding MC blocks will be referenced), the binding between chains allows to deterministically define the boundaries of the WE in the sidechain.</p>

    <p class="text-gray-300">More formally, if the withdrawal epoch  <span class="math">WE_{i}^{MC}</span>  of size  <span class="math">len</span>  in the MC is defined by a sequence of blocks  <span class="math">WE_{i}^{MC} = (B_{i}^{0}, B_{i}^{1}, \\dots, B_{i}^{len-1})</span> , then the corresponding withdrawal epoch in the SC can be determined as:</p>

    <div class="my-4 text-center"><span class="math-block">W E _ {i} ^ {S C} = (S B _ {i} ^ {0}, S B _ {i} ^ {1}, \\dots , S B _ {i} ^ {k}),</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">SB_{i}^{0}</span>  is an immediate descendant of the block  <span class="math">SB_{i - 1}^{n}</span>  which refers to the MC block  <span class="math">B_{i - 1}^{len - 1}</span>  (the last one in the withdrawal epoch  <span class="math">WE_{i - 1}^{MC}</span> ); and</li>

      <li><span class="math">SB_{i}^{k}</span>  is the block that refers to  <span class="math">B_{i}^{len - 1}</span> .</li>

    </ul>

    <p class="text-gray-300">Note that to simplify implementation, it might be needed to restrict SC blocks to not refer to several MC blocks on the boundaries of the withdrawal epoch (i.e., if the SC block refers to  <span class="math">B_{i}^{len-1}</span>  it cannot also refer to the next MC block  <span class="math">B_{i+1}^{0}</span> ).</p>

    <p class="text-gray-300">It is important to restate that the notion of the withdrawal epoch is independent from epochs in the Ouroboros consensus protocol.</p>

    <p class="text-gray-300">The Latus blockchain adopts the UTXO-based accounting model [21] where the state is represented by a set of unspent outputs combined into a fixed-size Merkle tree (see Fig. 9). We call such a tree a Merkle State Tree (MST). Lowercase  <span class="math">mst_{t}</span>  stands to denote the root hash of the  <span class="math">MST_{t}</span>  tree at the moment  <span class="math">t</span> .</p>

    <p class="text-gray-300">The depth  <span class="math">D_{MST}</span>  of the MST tree is a fixed system parameter that also constrains the total number of UTXOs that can exist in the system to be at most  <span class="math">2^{D_{MST}}</span>  (see Fig. 9).</p>

    <p class="text-gray-300">We consider each leaf of the MST as a UTXO slot that can be "occupied" or "empty" at a given moment. We introduce the deterministic function  <span class="math">MST\\_Position(utxo_{i})</span>  that returns the position of some unspent output  <span class="math">utxo_{i}</span>  if it is included in the tree. Note that the  <span class="math">utxo</span>  position does not depend on the current state of the MST.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Figure 9: An example of the Merkle State Tree with  <span class="math">D_{MST} = 3</span> . A leaf of the tree is either an unspent output or Null value. The tree contains 3 occupied and 5 empty slots. The function  <span class="math">MST\\_Position</span>  returns the position of a given utxo in the tree, e.g.,  <span class="math">MST\\_Position(utxo_2) = 4</span> .</p>

    <p class="text-gray-300">The unspent transaction output (UTXO) is defined as a tuple (addr, amount, nonce) where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>addr is an address of the UTXO owner who possesses the corresponding private key that allows to spent it;</li>

      <li>amount is the number of coins secured by the UTXO; and</li>

      <li>nonce is a unique identifier of the UTXO.</li>

    </ul>

    <p class="text-gray-300">Provided with the MST structure, which is the core of a sidechain state, we define an overall SC system state at the moment  <span class="math">t</span>  as a tuple:</p>

    <p class="text-gray-300">state  <span class="math">t\\stackrel {\\mathrm{def}}{=}(MST_{t},backward\\_transfers_{t}),</span></p>

    <p class="text-gray-300">where backward_transfers is a list of backward transfers initiated in the current withdrawal epoch. backward_transfers is transient and reset every new withdrawal epoch.</p>

    <p class="text-gray-300">5.3 Transactional Model</p>

    <p class="text-gray-300">There are 4 types of transactions defined in the Latus sidechain that realize basic payment functionality and cross-chain transfer protocol. To simplify the model, we consider them as logical transactions, though we stress that a real-world implementation can be optimized so that a single transaction on the blockchain may combine several logical transactions (even with different types).</p>

    <p class="text-gray-300">The transactions are the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Payment (PTx) – transfers coins within the sidechain.</li>

      <li>Backward Transfer (BTTx) – initiates transfer of coins from the SC to the MC.</li>

      <li>Forward Transfers (FTTx) - receives coins transferred from the mainchain.</li>

      <li>Backward Transfer Requests (BTRTx) - initiates coin transfer from the SC to the MC. In contrast to <em>BTTx</em>, <em>BTRTx</em> contains BTRs initially submitted in the mainchain and then synchronized to the SC.</li>

    </ol>

    <p class="text-gray-300">Whereas <em>PTx</em> and <em>BTTx</em> are inherently SC-defined transactions (thus, submitted and processed in the sidechain), <em>FTTx</em> and <em>BTRTx</em> are MC-defined transactions (they encapsulate FTs and BTRs that are initially submitted to the MC). We describe each type in detail in the following sections.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">5.3.1 Payment Transaction</h4>

    <p class="text-gray-300">We define a regular payment as a multi-input multi-output transaction <em>[29]</em>:</p>

    <p class="text-gray-300">type PaymentTx { inputs: List [UTXO]; signatures: List [Signature]; outputs: List [UTXO]; }</p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>inputs</em> are some unspent outputs from previous transactions, spending of which are authorized by <em>signatures</em>, and</li>

      <li>the total coin’s value of <em>inputs</em> is equal or greater than the total coin’s value of <em>outputs</em>.</li>

    </ol>

    <p class="text-gray-300">The state transition function <span class="math">update</span> for the payment transaction is defined in the following way:</p>

    <p class="text-gray-300"><span class="math">state_{i+1}=update(tx_{pay},state_{i}),</span></p>

    <p class="text-gray-300">where <span class="math">state_{i+1}[backward\\_transfers]</span> is unchanged and <span class="math">state_{i+1}[MST]</span> is derived from <span class="math">state_{i}[MST]</span> by</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>removing all UTXOs that are inputs in <span class="math">tx_{pay}</span> and substituting them with <span class="math">Null</span> to produce <span class="math">MST_{i}^{-}</span>; and</li>

      <li>sequentially adding to <span class="math">MST_{i}^{-}</span> all UTXOs that are outputs in <span class="math">tx_{pay}</span> according to <span class="math">MST\\_Position(utxo_{j})</span>.</li>

    </ol>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.3.2 Forward Transfers Transaction</p>

    <p class="text-gray-300">Forward transfers allow one to send coins from the mainchain to a sidechain. As such, FTs are first submitted to the MC and processed there (destroying coins) and then, by means of deterministic synchronization, are included and processed in the sidechain. Recall from <em>[4.1.1 Forward Transfers]</em> the basic structure of a forward transfer on the mainchain side:</p>

    <p class="text-gray-300"><span class="math">FT\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receivevMetadata,\\ amount).</span></p>

    <p class="text-gray-300"><span class="math">receivevMetadata</span> is defined by the sidechain construction and in Latus it is just a receiver address and a payback address on the MC needed in case of transfer failure:</p>

    <p class="text-gray-300"><span class="math">receiversMetadata\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (receivevAddr,\\ paybackAddr).</span></p>

    <p class="text-gray-300">A single MC block may contain several forward transfers related to different sidechains. The sidechain will synchronize FTs present in the referenced MC block by including a special <span class="math">ForwardTransfers</span> transaction (FTTx) in the SC block. Such FTTx specifies all forward transfers from the referenced MC block that are related to this specific sidechain. From the sidechain perspective, we can consider FTTx as a coinbase transaction (the one that creates new coins <em>[28]</em>) that is authorized by the mainchain.</p>

    <p class="text-gray-300">We assume that a particular forward transfer may fail so that coins cannot be received by the sidechain. In this case, coins are sent back to the mainchain by creating a corresponding backward transfer. It is done automatically upon FTTx execution in the sidechain.</p>

    <p class="text-gray-300">The reasons for FT failure can be different. For instance, FT’s <span class="math">receivevMetadata</span> may be malformed (recall that the MC does not validate semantics of FT’s <span class="math">receivevMetadata</span>) or some other sidechain-specific failures occur (e.g., it may happen that <span class="math">MST\\_Position(output_{new})</span> maps newly created output to an already occupied slot in <span class="math">MST_{i}</span>, thus causing a collision).</p>

    <p class="text-gray-300">The basic structure of the ForwardTransfers transaction is the following:</p>

    <p class="text-gray-300">type ForwardTransfersTx (mcid: BlockID, ft: List[FT]) {outputs: List [UTXO];rejectedTransfers : List [BackwardTransfer]}where:</p>

    <p class="text-gray-300">mcid - an identifier of the MC block whose forward transfers are synchronized;ft - a list of forward transfers from the MC block <span class="math">mcid</span> related to the sidechain where FTTx occurs;outputs - outputs created for the transferred coins; each valid forward transfer spawns a corresponding output with the same amount of coins;rejectedTransfers - a list of backward transfers for failed forward transfers; each failed forward transfer spawns a corresponding backward transfer with the same amount of coins.</p>

    <p class="text-gray-300">The state transition function update for the FTTx is defined in the following way:</p>

    <p class="text-gray-300"><span class="math">state_{i+1}=update(tx_{FT},state_{i}),</span></p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">state_{i+1}[MST]</span> is derived from <span class="math">state_{i}[MST]</span> by sequentially adding all UTXOs that are outputs in <span class="math">tx_{FT}</span> according to <span class="math">MST\\_Position(utxo_{j})</span>;</li>

      <li><span class="math">state_{i+1}[backward\\_transfers]</span> is derived from <span class="math">state_{i}[backward\\_transfers]</span> by appending <span class="math">rejectedTransfers</span> from <span class="math">tx_{FT}</span>.</li>

    </ol>

    <p class="text-gray-300">Note that failed forward transfers are recovered with the backward transfer mechanism through a withdrawal certificate at the end of the epoch. Recall that the MC knows nothing about the SC state and cannot know that an FT is failed; thus, we use the standard mechanism to reclaim coins in the MC.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">5.3.3 Backward Transfer Transaction</h4>

    <p class="text-gray-300">A backward transfer transaction (BTTx) allows one to create a request for a backward transfer in the sidechain that will be included in the next withdrawal certificate and then passed and processed in the mainchain.</p>

    <p class="text-gray-300">type BackwardTransferTx { inputs: List [UTXO]; signatures: List [Signature]; backwardTransfers: List[BackwardTransfer]; }</p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>inputs are some unspent outputs from previous transactions (spending of which is authorized by signatures);</li>

      <li>backwardTransfers are data about receivers of coins on the mainchain side; recall from [4.1.2 Backward Transfers] that the basic structure of a backward transfer is <span class="math">BT\\stackrel{{\\scriptstyle\\text{def}}}{{=}}(receiverAddr,\\ amount)</span>;</li>

      <li>the total coin value of inputs is equal or greater to the total coin value of backwardTransfers.</li>

    </ol>

    <p class="text-gray-300">The state transition function <span class="math">update</span> for a backward transfer transaction is defined as:</p>

    <p class="text-gray-300"><span class="math">state_{i+1}=update(tx_{BT},state_{i}),</span></p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">state_{i+1}[MST]</span> is derived from <span class="math">state_{i}[MST]</span> by removing all UTXOs that are inputs in <span class="math">tx_{BT}</span>; and</li>

      <li><span class="math">state_{i+1}[backward\\_transfers]</span> is derived from <span class="math">state_{i}[backward\\_transfers]</span> by appending <span class="math">backwardTransfers</span> from <span class="math">tx_{BT}</span>.</li>

    </ol>

    <p class="text-gray-300">Essentially, we can consider <span class="math">backwardTransfers</span> in <span class="math">tx_{BT}</span> as specialized outputs that are unspendable on the sidechain but used to reclaim coins in the mainchain (when transferred by means of a withdrawal certificate). In this respect, BTTx transaction is a special case of regular payment transaction where all outputs are backward transfers.</p>

    <p class="text-gray-300">More details about the entire backward transfer flow can be found in [5.5.3 Backward Transfers].</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.3.4 Backward Transfer Requests Transaction</p>

    <p class="text-gray-300">The <em>Backward Transfer Request</em> (BTR), which is submitted to the MC, is similar to BTTx in the sense that it allows one to create a request that will result in a backward transfer in the next withdrawal certificate if the request is legitimate (e.g., claimed coins were present at the moment of BTR inclusion in the SC block). The difference from BTTx is that BTR is submitted in the mainchain and is used in situations when BTTx cannot be used for some reason. Recall from <em>[4.1.2.1 Mainchain Managed Withdrawals]</em> the basic structure of the BTR on the mainchain side:</p>

    <p class="text-gray-300"><span class="math">BTR\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receive,\\ amount,\\ proofdata,\\ proof).</span></p>

    <p class="text-gray-300"><em>proofdata</em> and SNARK <em>proof</em> are defined by sidechain construction. In Latus, <em>proofdata</em> contains an unspent output that should be consumed in the SC to provide coins for transferring:</p>

    <p class="text-gray-300"><span class="math">proofdata\\ =\\ \\{utxo\\}.</span></p>

    <p class="text-gray-300">The spending right for the <em>utxo</em> should be enforced by the <em>proof</em> which is validated upon submission in the MC.</p>

    <p class="text-gray-300">Similar to forward transfers, a single MC block may contain several BTRs. The sidechain synchronizes BTRs by including in the SC block a special <em>BackwardTransferRequests</em> transaction (BTRTx) that contains all BTRs relevant to this sidechain from the referenced MC block. From a sidechain perspective, we can consider BTRTx as an aggregated transaction where each BTR represents a separate backward transfer.</p>

    <p class="text-gray-300">Some BTRs from BTRTx may be invalid when they are synced to the sidechain (e.g., a malicious user may try to spend the same utxo directly in the sidechain before BTR is synced (double-spend problem). Such BTRs are rejected by the sidechain (rejection means that they do not spawn corresponding backward transfers and do not affect the state).</p>

    <p class="text-gray-300">The basic BTRTx structure on the SC side is the following:</p>

    <p class="text-gray-300">type BackwardTransferRequestsTx (mcid: BlockId, btr: List[BTR]) { inputs: List [UTXO]; backwardTransfers: List[BackwardTransfer]; }</p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300"><span class="math">mcid</span> <span class="math">-</span> an identifier of the MC block whose BTRs are synchronized; <span class="math">btr</span> <span class="math">-</span> a list of backward transfer requests from the MC block <span class="math">mcid</span> related to this sidechain; <span class="math">inputs</span> <span class="math">-</span> a combined list of UTXOs derived from <span class="math">btr.proofdata</span> of each valid BTR; <span class="math">backwardTransfers</span> <span class="math">-</span> a list of backward transfers for valid BTRs.</p>

    <p class="text-gray-300">The state transition function update for a BTRTx transaction is:</p>

    <p class="text-gray-300"><span class="math">state_{i+1}=update(tx_{BTR},state_{i}),</span></p>

    <p class="text-gray-300">where:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">state_{i+1}[MST]</span> is derived from <span class="math">state_{i}[MST]</span> by removing all UTXOs that are inputs in <span class="math">tx_{BTR}</span>;</li>

      <li><span class="math">state_{i+1}[backward\\_transfers]</span> is derived from <span class="math">state_{i}[backward\\_transfers]</span> by appending <span class="math">backwardTransfers</span> from <span class="math">tx_{BTR}</span>.</li>

    </ol>

    <p class="text-gray-300">Note that correct processing of BTRs in the sidechain is to be enforced by a withdrawal certificate SNARK proof.</p>

    <p class="text-gray-300">5.4 State Transition Proof</p>

    <p class="text-gray-300">In <em>[5.3 Transactional Model]</em>, we defined four types of transactions that represent basic state transitions in our sidechain system. Given that all transactions are applied sequentially in an order defined by blocks containing them, we can consider a merged state transition for a sequence of transactions from several blocks:</p>

    <p class="text-gray-300"><span class="math">state_{i+k}=update([tx_{1},...,tx_{k}],state_{i})=update(tx_{k},update(tx_{k-1},.....update(tx_{1},state_{i})).</span></p>

    <p class="text-gray-300">In particular, we are interested in merging transitions for the whole withdrawal epoch and proving that the top-level merged transition is correct. It can be accomplished using the recursive SNARKs composition for state transitions defined in <em>[Def. 2.5]</em>.</p>

    <p class="text-gray-300">The main idea is to construct a single SNARK proof of transition for the whole withdrawal epoch which then can be attached to a withdrawal certificate proving to the mainchain the validity of everything that has happened in the sidechain – including certificate backward transfers – without actually revealing any details except state snapshots (in a form of simple hashes) before and after transition.</p>

    <p class="text-gray-300">We do not go deeply into the details of the SNARKs architecture which is quite sophisticated in this case and requires separate writing to be properly explained; instead, we are going to provide the basic idea of constructing such proof and how it is going to be used.</p>

    <p class="text-gray-300">Let us denote by <span class="math">s_{i}=H(state_{i})</span> the hash value that represents <span class="math">state_{i}</span>. Note that it must be an efficient hashing procedure as it should be implemented for a SNARK arithmetic constraint system. For instance, we can consider <span class="math">H(\\cdot)</span> as a root hash of a Merkle tree that contains all the data from <span class="math">state_{i}</span>.</p>

    <p class="text-gray-300">Let us assume that for each basic state transition (represented by <span class="math">tx_{pay}</span>, <span class="math">tx_{FT}</span>, <span class="math">tx_{BT}</span>, and <span class="math">tx_{BTR}</span>) we have a corresponding Base SNARK <em>[Def. 2.5]</em> which proves the correct state transition for a single <span class="math">tx_{a},\\ a\\in\\{pay,FT,BT,BTR\\}</span>:</p>

    <p class="text-gray-300"><span class="math">\\pi_{a}^{Base}</span> <span class="math">\\leftarrow Prove(pk_{a}^{Base},(s_{i},s_{i+1}),(tx_{a})),</span> <span class="math">true/false</span> <span class="math">\\leftarrow Verify(vk_{a}^{Base},(s_{i},s_{i+1}),\\pi_{a}^{Base}).</span></p>

    <p class="text-gray-300">Also, let us assume that we have a Merge SNARK which takes two proofs of adjacent state transitions (Base or Merge) and combines them into a single proof:</p>

    <p class="text-gray-300"><span class="math">\\pi^{Merge}</span> <span class="math">\\leftarrow Prove(pk^{Merge},(s_{i},s_{i+k}),(s_{i+j},\\pi_{1}^{b},\\pi_{2}^{c})),</span> <span class="math">true/false</span> <span class="math">\\leftarrow Verify(vk^{Merge},(s_{i},s_{i+k}),\\pi^{Merge}).</span></p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b,c\\in\\{Base,Merge\\}</span>;</li>

      <li><span class="math">\\pi_{1}^{b}</span> proves that there exist such <span class="math">tx_{1},...,tx_{j}</span> so that <span class="math">state_{i+j}=update([tx_{1},...,tx_{j}],state_{i})</span>;</li>

      <li><span class="math">\\pi_{2}^{c}</span> proves that there exist such <span class="math">tx_{j+1},...,tx_{k}</span> so that <span class="math">state_{i+k}=update([tx_{j+1},...,tx_{k}],state_{i+j})</span>.</li>

    </ul>

    <p class="text-gray-300">Provided with this construction, we can recursively build a single SNARK proof of state transition for a whole withdrawal epoch from the sequence of basic transitions. This process is visualized in figures 10 and 11.</p>

    <p class="text-gray-300">Figure 10 demonstrates the recursive construction of a state transition proof for a single sidechain block. Note that the scheme is simplified; in reality, the SNARKs composition is more sophisticated and the proof itself attests not only for the correctness of basic transitions but also for the validity of the SC block, the validity of included MC block references, their contiguity, etc.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Figure 10: Recursive composition of state transition proofs for the whole SC block. At the bottom level, there are proofs for basic transitions (represented by transactions included in the block) which are then recursively merged into a single proof.</p>

    <p class="text-gray-300">Figure 11 demonstrates the recursive construction of a state transition proof for an entire withdrawal epoch. Provided with the proofs of state transitions for blocks from the previous step, now they are merged to generate a single proof for the whole epoch which is used to construct a final proof for a withdrawal certificate.</p>

    <p class="text-gray-300">In a nutshell, each withdrawal certificate  <span class="math">WCert_{i}</span>  for epoch  <span class="math">i</span>  commits to the new state  <span class="math">state_{len}^{i}</span>  produced by applying all blocks belonging to epoch  <span class="math">i</span>  and proves correct transition from the  <span class="math">state_{len}^{i-1}</span>  committed by the previous withdrawal certificate. This also involves proving that all MC blocks belonging to the withdrawal epoch are referenced and all MC transactions related to this sidechain are processed. As forward and backward transfers are among basic transitions they will also be proven.</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Figure 11: Recursive composition of state transition proofs for the whole withdrawal epoch. State transitions for SC blocks are considered as base transitions though they themselves are recursively constructed from basic transitions (see Fig. 10).</p>

    <p class="text-gray-300">Again, we stress that this description is greatly simplified just to show the basic idea of recursive SNARKs composition for state transitions.</p>

    <p class="text-gray-300">5.4.1 Performance and Incentives</p>

    <p class="text-gray-300">Generating a SNARK proof for each basic transition and then merging them together requires a significant amount of computation. This task cannot be solely levied upon forgers or WCert issuers. Currently, we are investigating different approaches.</p>

    <p class="text-gray-300">One of the possible solutions is to introduce a special dispatching scheme that assigns generation of proofs randomly to interested parties who then do these tasks in parallel and submit generated proofs to the blockchain. An incentive scheme provides a reward for each valid submission.</p>

    <p class="text-gray-300">We consider this as a separate topic of research which we do not elaborate in this paper.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">5.5 Cross-Chain Transfer Protocol</h3>

    <p class="text-gray-300">In the previous sections, we described the consensus protocol, accounting model, and transactional model of the proposed sidechain construction. In this section, we will focus on the structure of the cross-chain transfer protocol on the sidechain side which is based on those components.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">5.5.1 Mainchain Block Reference</h4>

    <p class="text-gray-300">In <em>[5.1 Consensus Protocol]</em>, we briefly described the synchronization procedure between the mainchain and sidechain, which relies on MC block referencing. Here, we describe the reference structure in a more detailed way.</p>

    <p class="text-gray-300">Recall that an MC block header contains the SCTxsCommitment <em>[4.1.3 Sidechain Transactions Commitment]</em> field that commits to all SC-related transactions/outputs in that block:</p>

    <p class="text-gray-300">⬇ type MCBlockHeader { prevBlock: BlockId height: Int ... scTxsCommitment: Hash ... }</p>

    <p class="text-gray-300">ScTxsCommitment is a root hash of a Merkle tree where one of the subtrees is the Merkle tree of transactions related to the sidechain that referenced the block (see Fig. 12).</p>

    <p class="text-gray-300">The structure of the mainchain block reference is the following:</p>

    <p class="text-gray-300">⬇ type MCBlockReference { header: MCBlockHeader mproof: Option[MerkleProof] proofOfNoData: Option[MerkleProof[]] forwardTransfers: Option[FTTx] btRequests: Option[BTRTx] wcert: Option[WCert] }</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Figure 12: An example of the sidechain transactions commitment tree. One of the intermediate nodes (SC1Hash) is a root hash of the subtree that commits to all transactions related to the sidechain  <span class="math">SC1</span> .</p>

    <p class="text-gray-300">where:</p>

    <p class="text-gray-300">header - a header of the MC block that is referenced;</p>

    <p class="text-gray-300">mproof - optional field: in case the MC block includes at least one transaction related to this SC, mproof will contain a Merkle proof [Def. 2.2] for the intermediate node in the sidechain transactions commitment tree that is a root of a subtree of transactions related to this sidechain (by the example in Fig. 12: the subtree root for the sidechain  <span class="math">SC1</span>  is  <span class="math">h_{31}</span>  and the corresponding Merkle proof is the tuple of nodes  <span class="math">\\{h_{32}, h_{22}\\}</span> ); in case the MC block has no transactions related to this SC, the mproof must be Null;</p>

    <p class="text-gray-300">proofOfNoData - optional field: in case the MC block has no transactions related to this SC, proofOfNoData contains the Merkle proof(s) necessary to prove that this ledgerId was not part of the SCTxsCommitment tree;</p>

    <p class="text-gray-300">forwardTransfers - optional field: it is either a ForwardTransfers transaction [5.3.2 Forward Transfers Transaction] (if the MC block contains at least one forward transfer to this sidechain) or otherwise Null;</p>

    <p class="text-gray-300">btRequests - optional field: it is either a BackwardTransferRequests transaction [5.3.4 Backward Transfer Requests Transaction] (in case the MC block contains at least one backward transfer request to this sidechain) or otherwise Null;</p>

    <p class="text-gray-300">wcert - optional field: it is either a withdrawal certificate (in case the MC block contains the withdrawal certificate related to this sidechain) or otherwise Null.</p>

    <p class="text-gray-300">Provided with mproof, forwardTransfers, btRequests, and wcert fields, the SCTxsCommitment can be reconstructed and verified against the scTxsCommitment field included in the MC block</p>

    <p class="text-gray-300">header. It allows to verify that all SC-related transactions were correctly synchronized from the MC block without the need to download and verify its body. Moreover, we can construct a SNARK proving that the MC block reference has been correctly processed and that all SC-related transactions have been applied - it is an essential part of constructing a state transition proof for a withdrawal epoch [5.4 State Transition Proof].</p>

    <p class="text-gray-300">In [4.1.1 Forward Transfers] and [5.3.2 Forward Transfers Transaction], we have already discussed most of the details related to the forward transfer design both on the mainchain and sidechain sides. Here we combine everything.</p>

    <p class="text-gray-300">In general, it looks as follows: an MC to SC transfer is represented by a pair of transactions which we can consider as "sending" and "receiving". "Sending" is done on the mainchain side by means of the forward transfer defined in [4.1.1 Forward Transfers] and "receiving" is done on the sidechain side by means of aggregated ForwardTransfers transaction defined in [5.3.2 Forward Transfers Transaction]. While "sending" destroys coins in the mainchain, "receiving" creates the corresponding number of coins in the sidechain.</p>

    <p class="text-gray-300">Forward transfers submitted to the mainchain become available in the sidechain at the moment the MC block containing them is referenced in the sidechain (see Fig. 13). With the MC block reference [5.5.1 Mainchain Block Reference], a ForwardTransfers transaction (FTTx) is included in the SC block (if there are any FTs).</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> Figure 13: Forward transfersSyncing from the mainchain to the sidechain.</p>

    <p class="text-gray-300">The consistency of forward transfers included in a sidechain FTTx is verified by recalculating the FTHash (Fig. 12) and checking the SCTxsCommitment following the procedure described in [5.5.1 Mainchain Block Reference].</p>

    <p class="text-gray-300">In general, backward transfer is a transfer of coins in the opposite direction: from the sidechain to the mainchain. This operation is more sophisticated and thus requires several sub-protocols to provide sufficient security and reliability.</p>

    <p class="text-gray-300">There are three ways to withdraw coins from the sidechain to the mainchain:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Regular withdrawal is a standard mechanism that is used under normal conditions. It implies the usage of a backward transfer transaction [5.3.3 Backward Transfer Transaction] and a withdrawal certificate to transfer coins to the mainchain.</li>

      <li>Backward transfer request is similar to the regular withdrawal with that difference that it is initially submitted to the mainchain [4.1.2.1 Mainchain Managed Withdrawals] and then synchronized to the sidechain by means of [5.3.4 Backward Transfer Requests Transaction]. The coins are transferred to the mainchain with a withdrawal certificate.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Ceased sidechain withdrawal is a mechanism that is used when the sidechain is no longer operating. This type of withdrawal does not use withdrawal certificates and supposes direct handling by the mainchain.</li>

    </ol>

    <p class="text-gray-300">The first two types of withdrawals (regular and BTR) use the standard mechanism for backward transfers - withdrawal certificate. Most of the details related to their submission and processing have already been discussed in [4.1.2.1 Mainchain Managed Withdrawals], [5.3.3 Backward Transfer Transaction], and [5.3.4 Backward Transfer Requests Transaction]. The basic principle is summarized in figure 14.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a> Figure 14: Withdrawing coins with BT and BTR transactions.</p>

    <p class="text-gray-300">Regular withdrawal. A special BackwardTransfer transaction is submitted to the sidechain by a user who wants to transfer coins. This transaction destroys coins in the sidechain. At the end of the withdrawal epoch, all backward transfers are collected in a withdrawal certificate which is submitted to the mainchain where it is processed, and the corresponding number of coins is created in the mainchain.</p>

    <p class="text-gray-300">Backward transfer request. BTRs are submitted to the mainchain and synchronized to the sidechain by means of a BackwardTransferRequests transaction (analogously to forward transfers). The consistency of BTRs included in the sidechain is verified by recalculating the BTRHash (Fig. 12) and checking its presence in the SCTxsCommitment tree following the procedure described in [5.5.1 Mainchain Block Reference]. After the BTR is synchronized to the sidechain, it is processed as regular withdrawal through a withdrawal certificate.</p>

    <p class="text-gray-300">In the following sections, we will discuss more deeply the structure and generation of a withdrawal certificate and BTR. We will also separately discuss CSW as it is conceptually different from the first two withdrawal methods.</p>

    <p class="text-gray-300">Withdrawal certificate is a pivotal component of the backward transfer flow. Recall the basic structure of a withdrawal certificate that is defined by the mainchain [4.1.2 Backward Transfers]:</p>

    <p class="text-gray-300"><span class="math">WCert \\stackrel{\\text{def}}{=} (\\text{ledgerId}, \\text{epochId}, \\text{quality}, \\text{BTList}, \\text{proofdata}, \\text{proof}).</span></p>

    <p class="text-gray-300">While ledgerId and epochId are global parameters known to the mainchain, the semantics of quality, proofdata, and proof are defined by the sidechain. The withdrawal certificate is created once per a withdrawal epoch and includes all backward transfers that have been submitted during the epoch.</p>

    <p class="text-gray-300">Quality. The quality parameter is used by the mainchain to determine what WCert should be</p>

    <p class="text-gray-300">adopted in case several have been submitted for the same epoch. From the MC side, this is just an integer value which can be compared with quantities from other certificates. In the Latus sidechain, we define the quality to be the height of the blockchain up until which the WCert proves state transition.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">Backward Transfers List.</h4>

    <p class="text-gray-300">BTList is a list of backward transfers collected during a withdrawal epoch for which the certificate is created:</p>

    <p class="text-gray-300"><span class="math">BTList=state_{i}[backward\\_transfers],</span></p>

    <p class="text-gray-300">where <span class="math">state_{i}</span> is the state of the sidechain after applying the last block in the withdrawal epoch.</p>

    <p class="text-gray-300">Withdrawal certificate proof</p>

    <p class="text-gray-300">Withdrawal certificate proof is a SNARK proof that validates compliance of the certificate with a set of predefined rules.</p>

    <p class="text-gray-300">As it is defined in <em>[x10, 2.3]</em>, a SNARK is a proving system. Its particular instantiation is specified by a set of arithmetic constraints defining the verification rules. Each sidechain specifies its own set of constraints for the withdrawal certificate SNARK, thus establishing its own rules.</p>

    <p class="text-gray-300">The basic interface for the SNARK prover and verifier is the following:</p>

    <p class="text-gray-300"><span class="math">proof\\leftarrow Prove(pk_{WCert},\\ public\\_input,\\ witness),</span> <span class="math">true/false\\leftarrow Verify(vk_{WCert},\\ public\\_input,\\ proof).</span></p>

    <p class="text-gray-300">A particular instantiation of the SNARK proving system is determined by a pair of keys – proving key <span class="math">pk_{WCert}</span> and verifying key <span class="math">vk_{WCert}</span>. Verifying key is registered upon sidechain creation and cannot be changed during the SC lifetime. It completely defines the rules of the withdrawal certificate validation (including the semantics of the public input and witness for the prover and verifier).</p>

    <p class="text-gray-300">Recall from <em>[x10]</em> that <span class="math">public\\_input</span> for the WCert SNARK is comprised of two parts:</p>

    <p class="text-gray-300"><span class="math">public\\_input\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (wcert\\_sysdata,\\ MH(proofdata)),</span></p>

    <p class="text-gray-300">where <span class="math">wcert\\_sysdata</span> is a set of arguments enforced directly by the mainchain:</p>

    <p class="text-gray-300"><span class="math">wcert\\_sysdata\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (quality,MTHash(BTList),H(B_{len}^{i-1}),H(B_{len}^{i}));</span></p>

    <p class="text-gray-300">and <span class="math">proofdata</span> is a set of arguments defined by the sidechain construction and passed along the withdrawal certificate. In the Latus sidechain, it is defined as follows:</p>

    <p class="text-gray-300"><span class="math">proofdata\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (H(SB_{last}^{i}),H(state_{SB_{last}^{i}}[MST]),mst\\_delta),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">H(SB_{last}^{i})</span> <span class="math">-\\text{a hash of the last sidechain block in the epoch </span>i<span class="math"> for which the certificate is created;}</span> <span class="math">H(state_{SB_{last}^{i}}[MST])</span> <span class="math">-\\text{a root hash of the MST tree derived after applying </span>SB_{last}^{i}<span class="math">; note that by including </span>H(state_{SB_{last}^{i}}[MST])<span class="math"> in </span>proofdata<span class="math">, the withdrawal certificate commits to the updated sidechain state;}</span> <span class="math">mst\\_delta</span> <span class="math">-\\text{a bit vector of MST modifications; given that the MST is a fixed size Merkle tree, </span>mst\\_delta$ is also a fixed-size bit vector where each bit represents a particular leaf in the tree; the bit is set to “1” if the MST leaf has been modified at least once during the epoch, otherwise it is “0” (see example in <em>[Appendix A]</em>).</p>

    <p class="text-gray-300">mst_delta is used for proving that some utxo has not been spent since some moment in the past (this is particularly useful for preventing data availability attacks as it allows creating mainchain managed withdrawals without knowing the current sidechain state). E.g., to prove this, one would need to provide a utxo together with a Merkle proof of its inclusion in some <span class="math">state_{SB^{b}_{last}}[MST]</span> committed in one of the previous certificates and a list of mst_delta’s from the following certificates where the corresponding bit has not been triggered to “1”.</p>

    <p class="text-gray-300">In the Latus sidechain construction, a withdrawal certificate proof enforces the following rules:</p>

    <p class="text-gray-300">WCert SNARK Statement</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">SB^{i}_{last}</span> is the last block of the withdrawal epoch <span class="math">i</span> for which the certificate is created.</li>

      <li><span class="math">SB^{i}_{last}</span> is connected to the <span class="math">SB^{i-1}_{last}</span> from the previous withdrawal certificate by a valid chain of blocks.</li>

      <li><span class="math">H(state_{SB^{i}_{last}}[MST])</span> is a valid root of the MST for <span class="math">state_{SB^{i}_{last}}</span>.</li>

      <li>Assuming that after applying the block <span class="math">SB^{i-1}_{last}</span> the sidechain state is <span class="math">state_{SB^{i-1}_{last}}</span> and after the block <span class="math">SB^{i}_{last}</span> the state is <span class="math">state_{SB^{i}_{last}}</span> , the proof verifies correct transition from <span class="math">state_{SB^{i-1}_{last}}</span> to <span class="math">state_{SB^{i}_{last}}</span> which means that all transactions from the subchain <span class="math">[SB^{i}_{0},...,SB^{i}_{last}]</span> are correctly processed according to the rules from <em>[5.3 Transactional Model]</em>.</li>

      <li>MC blocks from range <span class="math">[B^{i}_{0},...,B^{i}_{last}]</span> are referenced from the sidechain blocks <span class="math">[SB^{i}_{0},...,SB^{i}_{last}]</span> (this also implies that all SC-related transactions from these blocks have been processed).</li>

      <li><span class="math">BTList</span> is a valid list of backward transfers that corresponds to <span class="math">state_{SB^{i}_{last}}[backward\\_transfers]</span>.</li>

      <li><span class="math">quality</span> parameter is the height of the block <span class="math">SB^{i}_{last}</span>.</li>

      <li><span class="math">mst\\_delta</span> is a bit vector that reflects changes in MST between <span class="math">state_{SB^{i-1}_{last}}[MST]</span> and <span class="math">state_{SB^{i}_{last}}[MST]</span>.</li>

    </ul>

    <p class="text-gray-300">In general, a withdrawal certificate proof validates correct transition for a range of blocks that belongs to the withdrawal epoch and that this range is adjacent to the range committed in the previous withdrawal certificate. This includes proving the correctness of backward transfers.</p>

    <p class="text-gray-300">Given that all state transitions are proved, it becomes infeasible to create a malicious backward transfer (without creating a corresponding transaction in the sidechain), and it is infeasible to create new coins on the sidechains without real forward transfers.</p>

    <h5 id="sec-46" class="text-base font-semibold mt-4">5.5.3.2 Backward Transfer Request</h5>

    <p class="text-gray-300">In <em>[5.3.4 Backward Transfer Requests Transaction]</em>, we have already discussed how BTRs are submitted and processed in the sidechain. Here, we only provide details about the SNARK proof included in a BTR.</p>

    <p class="text-gray-300">Recall that the BTR structure has been defined as follows <em>[Def. 4.5]</em>:</p>

    <p class="text-gray-300"><span class="math">BTR\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receive,\\ amount,\\ nullifier,\\ proofdata,\\ proof).</span></p>

    <p class="text-gray-300"><span class="math">proofdata</span> is defined by the Latus construction as:</p>

    <p class="text-gray-300"><span class="math">proofdata=\\{utxo\\},</span></p>

    <p class="text-gray-300">where <span class="math">utxo</span> is an unspent output that holds coins that a user wants to withdraw. The basic idea is that the <span class="math">proof</span> should validate the user’s right to withdraw this <span class="math">utxo</span> and that this <span class="math">utxo</span> is present in the sidechain state MST committed by the last withdrawal certificate included in the mainchain.</p>

    <p class="text-gray-300">Note that the BTR SNARK <span class="math">proof</span> is validated by the mainchain upon BTR submission. Even though it verifies that the withdrawn <span class="math">utxo</span> has been present in the last committed SC state, it cannot guarantee that it will remain valid at the moment BTR will be synchronized to the sidechain. This proof serves more like a pre-validation for the BTR in the mainchain to impede submission of wittingly invalid requests.</p>

    <p class="text-gray-300">The basic interface for the SNARK prover and verifier is the following [Def. 4.5]:</p>

    <p class="text-gray-300"><span class="math">proof\\leftarrow Prove(pk_{BTR},\\ public\\_input,\\ witness),</span> <span class="math">true/false\\leftarrow Verify(vk_{BTR},\\ public\\_input,\\ proof).</span></p>

    <p class="text-gray-300">The verifying key <span class="math">vk_{BTR}</span> is registered upon sidechain creation. It defines the rules of the BTR validation (including the semantics of the public input and witness for the prover and verifier).</p>

    <p class="text-gray-300">The <span class="math">public\\_input</span> comprises two parts [Def. 4.5]:</p>

    <p class="text-gray-300"><span class="math">public\\_input\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (btr\\_sysdata,\\ MH(proofdata)),</span> <span class="math">btr\\_sysdata\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (H(B_{w}),\\ nullifier,\\ receiver,\\ amount)),</span></p>

    <p class="text-gray-300">where <span class="math">H(B_{w})</span> is the hash of the MC block with the latest withdrawal certificate (at the moment when BTR is included in the mainchain), <span class="math">receiver</span>, <span class="math">amount</span>, and <span class="math">nullifier</span> are taken from the BTR itself. Note that <span class="math">btr\\_sysdata</span> is enforced by the mainchain so its parameters cannot be manipulated by the BTR issuer.</p>

    <p class="text-gray-300">A BTR proof enforces the following rules:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H(B_{w})</span> is the hash of the mainchain block where the last certificate <span class="math">WCert_{w}</span> has been submitted for this sidechain.</li>

      <li><span class="math">utxo\\in state_{w}[MST]</span>, where <span class="math">state_{w}[MST]</span> has been committed in <span class="math">WCert_{w}</span>.</li>

      <li>The BTR issuer has rights to spend this <span class="math">utxo</span> (i.e., possesses the corresponding private key).</li>

      <li><span class="math">amount</span> is equal to the <span class="math">utxo.amount</span>.</li>

      <li><span class="math">nullifier</span> is the hash of the <span class="math">utxo</span>.</li>

      <li><span class="math">receiver</span> is the address of the receiver in the mainchain.</li>

    </ul>

    <h5 id="sec-47" class="text-base font-semibold mt-4">5.5.3.3 Ceased Sidechain Withdrawal</h5>

    <p class="text-gray-300">CSWs are used to allow sidechain stakeholders to withdraw coins from a ceased sidechain.</p>

    <p class="text-gray-300">As it has been defined in <em>[Def. 4.6]</em>, a ceased sidechain withdrawal is submitted to the mainchain as a special transaction and performs a direct payment in the mainchain. Recall the basic structure of the ceased sidechain withdrawal that is defined by the mainchain <em>[Def. 4.6]</em>:</p>

    <p class="text-gray-300"><span class="math">CSW\\ \\stackrel{{\\scriptstyle\\rm def}}{{=}}\\ (ledgerId,\\ receiver,\\ amount,\\ nullifier,\\ proofdata,\\ proof).</span></p>

    <p class="text-gray-300">The main prerequisite for CSW validity is the existence of the claimed coins in the sidechain state committed by the last withdrawal certificate. A sidechain user should point to the specific unspent output from <span class="math">state_{SB^{i}_{last}}[MST]</span> and authorize its spending. Basically, it is the same SNARK that is used for the BTR <em>[5.5.3.2 Backward Transfer Request]</em>; the difference is that now it authorizes direct payment in the mainchain, whereas in the BTR, it is essentially a pre-validation.</p>

    <p class="text-gray-300">We will not dive deeply into the SNARK construction for the CSW as technically it is completely the same as for the BTR.</p>

    <p class="text-gray-300">In general, the CSW proof validates that a submitter owns the utxo with a particular amount of coins at the moment of the sidechain halt. Also, it enforces a nullifier which is a unique identifier of the withdrawn utxo. Nullifiers are tracked by the mainchain to prevent withdrawal of the same coins twice.</p>

    <h2 id="sec-48" class="text-2xl font-bold">6 Conclusions</h2>

    <p class="text-gray-300">The concept of sidechains has been acknowledged as an appealing solution for enhancing existing blockchain systems. It allows creating platforms and applications that are bound to the mainchain without imposing significant burden. Yet, we have not seen wide adoption of this concept. We believe that the value of sidechains as a scalability solution is underestimated and seek to develop this area.</p>

    <p class="text-gray-300">In this paper, we introduced Zendoo, a universal construction for blockchain systems that enables the creation and communication with different sidechains without knowing their internal structure. We also provided a specific sidechain construction, Latus, that leverages zk-SNARK techniques to establish decentralized and verifiable cross-chain transfers.</p>

    <p class="text-gray-300">We consider this as a research paper whose subject is still under ongoing research. In future publications, we plan to uncover more details about specific components and properties of the proposed sidechain construction.</p>

    <h2 id="sec-49" class="text-2xl font-bold">7 Acknowledgments</h2>

    <p class="text-gray-300">We would like to express great appreciation to Maurizio Binello and Andrey Sobol for participating in technical discussions.</p>

    <p class="text-gray-300">We would also like to thank Rob Viglione, Daniele Di Benedetto, Marcelo Kaihara, Luca Cermelli, and Lyudmila Kovalchuk for reviewing and providing valuable comments.</p>

    <h2 id="sec-50" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Cosmos network, 2018. https://cosmos.network/docs/.</li>

      <li>[2] Ethereum. a next-generation smart contract and decentralized application platform., 2018. https://github.com/ethereum/wiki/wiki/White-Paper.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[3] Rootstock: smart contracts on bitcoin network, 2018. https://www.rsk.co/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[4] Andreas M. Antonopoulos. Mastering bitcoin (second edition). O’Reilly Media, Inc., 2017.</li>

      <li>[5] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Timón, and P. Wuille. Enabling blockchain innovations with pegged sidechains, 2014. https://blockstream.com/sidechains.pdf.</li>

      <li>[6] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. Cryptology ePrint Archive, Report 2013/879, 2013.</li>

      <li>[7] Sean Bowe and Ariel Gabizon. Making groth’s zk-snark simulation extractable in the random oracle model. IACR Cryptology ePrint Archive, 2018:187, 2018.</li>

      <li>[8] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://eprint.iacr.org/2019/1021.</li>

      <li>[9] J. Dilley, A. Poelstra, and J. Wilkins. Strong federations: An interoperable blockchain solution to centralized third party risks. arXiv:1612.05491, 2016. https://arxiv.org/abs/1612.05491.</li>

      <li>[10] Croman K. et al., editor. On Scaling Decentralized Blockchains, volume 9604 of Financial Cryptography and Data Security, Lecture Notes in Computer Science. Springer, 07 2016.</li>

      <li>[11] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. Advances in Cryptology - EUROCRYPT 2015. Lecture Notes in Computer Science, vol 9057. Springer, Berlin, Heidelberg, 2015.</li>

      <li>[12] Alberto Garoffolo and Robert Viglione. Sidechains: Decoupled consensus between chains. arXiv:1812.05441, 2018. https://arxiv.org/abs/1812.05441.</li>

      <li>[13] P. Gazi, A. Kiayias, and D. Zindros. Proof-of-stake sidechains. Proceedings of the IEEE Symposium on Security & Privacy. IEEE Computer Society Press, 2019.</li>

      <li>[14] Alex Gluchowski. Zk rollup: scaling with zero-knowledge proofs. Matter Labs, 2019. https://pandax-statics.oss-cn-shenzhen.aliyuncs.com/statics/1221233526992813.pdf.</li>

      <li>[15] Oded Goldreich. The foundations of cryptography - volume 1, basic techniques. Cambridge University Press, 2001.</li>

      <li>[16] A. Kiayias and D. Zindros. Proof-of-work sidechains. Cryptology ePrint Archive, Report 2018/1048, 2018. https://eprint.iacr.org/2018/1048.</li>

      <li>[17] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. CRYPTO 2017, Part I, volume 10401 of LNCS, pages 357–388. Springer, Heidelberg, 2017.</li>

      <li>[18] S. Lerner. Drivechains, sidechains and hybrid 2-way peg designs., 2016. https://docs.rsk.co/Drivechains_Sidechains_and_Hybrid_2-way_peg_Designs_R9.pdf.</li>

      <li>[19] Izaak Meckler and Evan Shapiro. Coda : Decentralized cryptocurrency at scale, 2018. https://cdn.codaprotocol.com/v2/static/coda-whitepaper-05-10-2018-0.pdf.</li>

    </ul>

    <p class="text-gray-300">[20] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008. https://bitcoin.org/bitcoin.pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[21] Arvind Narayanan, Joseph Bonneau, Edward Felten, Andrew Miller, and Steven Goldfeder. Bitcoin and cryptocurrency technologies: A comprehensive introduction. Princeton University Press, Princeton, NJ, USA, 2016.</li>

      <li>[22] J. Poon and V. Buterin. Plasma: Scalable autonomous smart contracts. http://plasma.io/.</li>

      <li>[23] Merkle R.C. A digital signature based on a conventional encryption function. Advances in Cryptology — CRYPTO 1987. Lecture Notes in Computer Science, vol 293. Springer, Berlin, Heidelberg, 1988.</li>

      <li>[24] Nicholas Stifter, Aljosha Judmayer, Philipp Schindler, Alexei Zamyatin, and Edgar Weippl. Agreement with satoshi – on the formalization of nakamoto consensus. Cryptology ePrint Archive, Report 2018/400, 2018. https://eprint.iacr.org/2018/400.</li>

      <li>[25] P. Sztorc. Drivechain - the simple two way peg, november 2015., 2015. http://www.truthcoin.info/blog/drivechain/.</li>

      <li>[26] The Horizen Team and Community. Horizen: A blockchain platform for fully customizable decentralized applications, 2019. https://www.horizen.global/assets/files/Horizen-White-Paper.pdf.</li>

      <li>[27] S. Thomas and E. Schwartz. A protocol for interledger payments, 2016. https://interledger.org/interledger.pdf.</li>

      <li>[28] Bitcoin Wiki. Coinbase. https://en.bitcoin.it/wiki/Coinbase.</li>

      <li>[29] Bitcoin Wiki. Transaction. https://en.bitcoin.it/wiki/Transaction.</li>

      <li>[30] Gavin Wood. Polkadot:vision for a heterogeneous multi-chain framework, 2016. https://polkadot.network/Polkadot-lightpaper.pdf.</li>

    </ul>

    <h2 id="sec-51" class="text-2xl font-bold">Appendix A MST Delta</h2>

    <p class="text-gray-300">Here, we provide an example of how the <span class="math">mst\\_delta</span> value from a withdrawal certificate [5.5.3.1 Withdrawal Certificate] is calculated and give some explanations on why it is needed. Note that this relates only to the Latus sidechain construction.</p>

    <p class="text-gray-300">In general, <span class="math">mst\\_delta</span> shows which leaves have been changed between two Merkle state trees [5.2 Accounting Model and System State] <span class="math">MST_{i}</span> and <span class="math">MST_{j}</span>, <span class="math">i&lt;j</span> (e.g., in case of a withdrawal certificate, these are MSTs committed by the previous certificate and the current one which shows how the system state changed during the epoch). <span class="math">mst\\_delta</span> is a bit vector that shows what leaves of the <span class="math">MST_{i}</span> have been changed in <span class="math">MST_{j}</span>.</p>

    <p class="text-gray-300">Let us consider the MST of depth <span class="math">D_{MST}=3</span> which has an initial state <span class="math">MST_{0}</span> (see Fig. 15).</p>

    <p class="text-gray-300">The MST can contain up to eight unspent outputs (equal to the number of leaves). At the moment <span class="math">MST_{0}</span>, the tree contains three UTXOs <span class="math">\\{utxo_{1},utxo_{2},utxo_{3}\\}</span> which are assigned to leaf nodes 0, 4, 6 correspondingly.</p>

    <p class="text-gray-300">!<a href="img-14.jpeg">img-14.jpeg</a> Figure 15: Merkle state tree  <span class="math">MST_{0}</span> .</p>

    <p class="text-gray-300">Let us assume that we have two transactions  <span class="math">tx_{1}</span>  and  <span class="math">tx_{2}</span>  such that:</p>

    <pre><code class="language-latex">$\\mathrm{tx1} = \\{$  inputs: {utxo1} outputs: {utxo4(val=2), utxo5(val=3)}  $\\}$ $\\mathrm{tx2} = \\{$  inputs: {utxo4} outputs: {utxo6(val=2)}  $\\}$</code></pre>

    <p class="text-gray-300">Assuming that  <span class="math">MST\\_Position(utxo_4) = 1</span> ,  <span class="math">MST\\_Position(utxo_5) = 2</span> , and  <span class="math">MST\\_Position(utxo_6) = 7</span> , applying transactions  <span class="math">tx_1</span>  and  <span class="math">tx_2</span>  to the state  <span class="math">MST_0</span>  will provide the following  <span class="math">MST_1</span> :</p>

    <p class="text-gray-300">!<a href="img-15.jpeg">img-15.jpeg</a> Figure 16: Merkle state tree  <span class="math">MST_{1}</span> .</p>

    <p class="text-gray-300">It can be seen that during the transition from  <span class="math">MST_{0}</span>  to  <span class="math">MST_{1}</span> , the leaves 0, 1, 2, 7 have been modified. Thus, the msd delta reflects these modifications in the bit vector:</p>

    <pre><code class="language-txt">mst delta  $=$  (11100001),</code></pre>

    <p class="text-gray-300">where each bit represents whether a corresponding leaf node has been modified.</p>

    <p class="text-gray-300">Having  <span class="math">mst\\_delta</span>  in each withdrawal certificate allows to prove that some  <span class="math">utxo_{a}</span>  is contained in  <span class="math">MST_{k}</span>  committed by the latest certificate, by providing proof of inclusion in some  <span class="math">MST_{t}</span> ,  <span class="math">t &amp;lt; k</span> ,</p>

    <p class="text-gray-300">committed by the certificate in the past, and verifying that the bit <span class="math">MST\\_Position(utxo_{a})</span> is zero for all <span class="math">mst\\_delta</span>’s on the way from <span class="math">MST_{t}</span> to <span class="math">MST_{k}</span>.</p>

    <p class="text-gray-300">This feature is of great value for circumventing data availability attacks, e.g., when a compromised sidechain (where the majority of stakeholders is adversarial) submits a withdrawal certificate to the mainchain that commits to some <span class="math">MST_{k}</span> while not revealing to the public the <span class="math">MST_{k}</span> tree itself. Having <span class="math">mst\\_delta</span> in place, a user will be able to create proof of utxo ownership by using some previous <span class="math">MST_{k}</span>. This mechanism is used for proving utxo ownership in mainchain managed withdrawals in the Latus sidechain construction (<em>[5.5.3.2 Backward Transfer Request]</em>, <em>[5.5.3.3 Ceased Sidechain Withdrawal]</em>).</p>`;
---

<BaseLayout title="Zendoo: a zk-SNARK Verifiable Cross-Chain Transfer Protocol ... (2020/123)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/123
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
