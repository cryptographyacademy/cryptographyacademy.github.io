---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/303';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = '6. Algorithms without inverse Frobenius operations for polynomial basis arithmetic in $\\mathbb{F}_{2^m}$ and $\\mathbb{F}_{3^m}$';
const AUTHORS_HTML = 'Many computational evidence [8,20] imply that a more efficient field arithmetic can be obtained for low characteristic finite fields by using a polynomial basis than a normal basis, especially for software purposes. Though a Gaussian normal basis of low complexity [26] is a good choice for a fast arithmetic, such basis does not appear quite frequently when compared with a polynomial basis of low hamming weight (like trinomial or pentanomial). In the case of the Tate pairing computation, the same phenomenon that a polynomial basis wins over a normal basis has been observed by Granger, Page, and Stam [8]. Granger et al. [8] showed that, even though a cube root operation (inverse Frobenius operation for characteristic three) in a polynomial basis is quite costly, an algorithm for the Tate pairing computation with a';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold">Efficient Tate Pairing Computation for Supersingular Elliptic Curves over Binary Fields</h2>

    <p class="text-gray-300">Soonhak Kwon
Department of Mathematics, Sungkyunkwan University, Korea shkwon@skku.edu</p>

    <p class="text-gray-300">Abstract: After Miller's original algorithm for the Tate pairing computation, many improved algorithms have been suggested, to name just a few, by Galbraith et al. and Barreto et al., especially for the fields with characteristic three. Also Duursma and Lee found a closed formula of the Tate pairing computation for the fields with characteristic three. In this paper, we show that a similar argument is also possible for the finite fields with characteristic two. That is, we present a closed formula for the Tate pairing computation for supersingular elliptic curves defined over the binary field  <span class="math">\\mathbb{F}_{2^m}</span>  of odd dimension. There are exactly three isomorphism classes of supersingular elliptic curves over  <span class="math">\\mathbb{F}_{2^m}</span>  for odd m and our result is applicable to all these curves. Moreover we show that our algorithm and also the Duursma-Lee algorithm can be modified to another algorithm which does not need any inverse Frobenius operation (square root or cube root extractions) without sacrificing any of the computational merits of the original algorithm. Since the computation of the inverse Frobenius map is not at all trivial in a polynomial basis and since a polynomial basis is still a preferred choice for the Tate pairing computation in many situations, this new algorithm avoiding the inverse Frobenius operation has some advantage over the existing algorithms.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> supersingular elliptic curve, Tate pairing, divisor, automorphism, roots of unity.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1. Introduction</h4>

    <p class="text-gray-300">With increasing use of the Tate pairing in cryptographic areas, a study of efficient computation of the Tate pairing becomes the subject of active research these days. Many cryptographic schemes are based on the bilinear pairings arising from the rank two abelian group structure of the points of prescribed order of the given elliptic curve. Examples of such cryptographic protocols are, to name just a few, identity based encryption scheme by Boneh and Franklin [10], short signature scheme by Boneh et al. [11], tripartite Diffie-Hellman key agreement protocol by Joux [12], identity based authenticated key agreement protocol by Smart [25], and identity based signature schemes by Hess [7], Sakai et al. [24]. In most of these applications, the Weil pairing or Tate pairing of supersingular elliptic curves (or curves of small embedding degrees) are essential tools. Therefore efficient computation of the Weil or Tate pairings is a crucial factor for practical applications of the above mentioned cryptographic protocols. The Weil pairing for a given elliptic curve is a symmetric bilinear pairing which can be thought of two applications of the Tate pairing. Thus the Weil pairing is more slow to compute than the Tate pairing, and consequently, it is desirable to replace the Weil pairing as the Tate pairing whenever it is possible in many cryptographic schemes.</p>

    <p class="text-gray-300">Recently many progresses have been made on the computation of the Tate pairing. Galbraith et al. [4,5] suggested a few refined techniques and ideas to speed up the computation</p>

    <p class="text-gray-300">of the Tate pairing. Eisentr√§ger et al. [13] introduced the notion of the squared Tate pairing. Scott and Barreto [2] and Granger et al. [9] discussed properties of compressed pairings. Barreto et al. [1] showed that the standard algorithm of Miller [19] can be modified to so called the BKLS algorithm where division in a finite field can be omitted since the denominator becomes one after final powering. Also Duursma and Lee [3] presented a closed formula for the computation of the Tate pairing for a finite field with characteristic <em>three</em>, which significantly reduces the cost of computing and is flexible for both of software and hardware applications.</p>

    <p class="text-gray-300">In this paper we show that an efficient closed formula can also be obtained for the computation of the Tate pairing for supersingular elliptic curves over a binary field  <span class="math">\\mathbb{F}_{2^m}</span>  with odd dimension m. There are exactly three isomorphism classes of supersingular elliptic curves over  <span class="math">\\mathbb{F}_{2^m}</span>  with m odd [15] and our method is applicable to all these curves, of which two are the most commonly used curves with embedding degree 4. Also we present a method of avoiding inverse Frobenius operations in our and Duursma-Lee's algorithms. When one wants to use a polynomial basis, inverse Frobenius operation is not at all trivial unlike the case of a normal basis and this inverse operation deteriorates the performance of the algorithms of Duursma-Lee and ours, which need two inverse Frobenius operations in each step of the algorithms. We propose new modified algorithms which avoid the inverse Frobenius map without affecting the computational merits of the original algorithms.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">2. Elliptic curves and Miller's algorithm</h4>

    <p class="text-gray-300">Let E be an elliptic curve over a finite field  <span class="math">\\mathbb{F}_q</span>  where q is a power of a prime. We may express E as the following standard Weierstrass form</p>

    <p class="text-gray-300"><span class="math">$E: Y^2 + a_1XY + a_3Y = X^3 + a_2X^2 + a_4X + a_6,</span>$</p>

    <p class="text-gray-300">where the coefficients  <span class="math">a_1, a_2, a_3, a_4, a_6</span>  are in  <span class="math">\\mathbb{F}_q</span> . Let  <span class="math">E(\\mathbb{F}_q)</span>  be the set of all points  <span class="math">P = (x, y), x, y \\in \\mathbb{F}_q</span> , on the curve with the point at infinity O (which is (0, 1, 0) on the corresponding homogeneous equation of degree 3 over a projective plane).  <span class="math">E(\\mathbb{F}_q)</span>  has a structure of an abelian group and the order  <span class="math">|E(\\mathbb{F}_q)|</span>  is bounded by the following well known relation due to Hasse [14],</p>

    <p class="text-gray-300"><span class="math">$|E(\\mathbb{F}_q)| = q + 1 - Tr(\\varphi), \\quad |Tr(\\varphi)| \\le 2\\sqrt{q},\\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">Tr(\\varphi) \\in \\mathbb{Z}</span>  is the trace of the Frobenius map  <span class="math">\\varphi : E \\longrightarrow E</span> , with  <span class="math">\\varphi(x,y) = (x^q,y^q)</span> , and  <span class="math">\\varphi</span>  is a zero of the characteristic polynomial  <span class="math">h(X) = X^2 - Tr(\\varphi)X + q</span> . Let l be a positive integer and let E[l] (resp.  <span class="math">E[l](\\mathbb{F}_q)</span> ) be the set of points  <span class="math">P \\in E(\\overline{\\mathbb{F}}_q)</span>  (resp.  <span class="math">P \\in E(\\mathbb{F}_q)</span> ) satisfying lP = O, where  <span class="math">\\overline{\\mathbb{F}}_q</span>  is an algebraic closure of  <span class="math">\\mathbb{F}_q</span> . Let k be the minimal degree of the extension satisfying  <span class="math">E[l] \\subset E(\\mathbb{F}_{q^k})</span> . Such k is called the embedding degree (or the security multiplier) of E[l] [1,15] and is dependent on E and l. If l is prime to q, then it is well known [14,15] that  <span class="math">E[l] \\cong \\mathbb{Z}/l \\oplus \\mathbb{Z}/l</span> .</p>

    <p class="text-gray-300">A divisor D on E is a formal (finite) sum of the points P on the curve</p>

    <p class="text-gray-300"><span class="math">$D = \\sum n_p(P), \\quad n_p \\in \\mathbb{Z}. \\tag{2}</span>$</p>

    <p class="text-gray-300">We call D a zero divisor if  <span class="math">\\sum n_p = 0</span> . A principal divisor is a divisor of the form  <span class="math">(f) = \\sum n_p(P)</span> , where f is a rational function on E and P is a point of E with  <span class="math">n_P</span>  the order of multiplicity of f at P, i.e.  <span class="math">n_P &gt; 0</span>  if f has a zero at P and  <span class="math">n_P &lt; 0</span>  if f has a pole at P. We say two divisors P and P' are equivalent if P and P is a principal divisor. It is well known [14,15] that</p>

    <p class="text-gray-300">a principal divisor (f) is a zero divisor, and a divisor  <span class="math">D = \\sum n_p(P)</span>  is a principal divisor if D is a zero divisor and  <span class="math">\\sum n_p P = O</span>  in the abelian group  <span class="math">E(\\overline{\\mathbb{F}}_q)</span> . More precisely, there is an isomorphism [15]</p>

    <p class="text-gray-300"><span class="math">$Div_0/Div_{prin} \\longrightarrow E</span>$
, with  <span class="math">D = \\sum n_p(P) \\longmapsto \\sum n_p P</span> , (3)</p>

    <p class="text-gray-300">where the summation in the right side is the addition of points on the elliptic curve E and  <span class="math">Div_0</span>  (resp.  <span class="math">Div_{prin}</span> ) is a free abelian group generated by the zero divisors (resp. principal divisors). Now suppose that  <span class="math">P \\in E[l]</span> . Then the divisor l(P) - l(O) is a principal divisor so that there is a rational function  <span class="math">f_P</span>  such that  <span class="math">(f_P) = l(P) - l(O)</span> . For any rational function f and any divisor  <span class="math">D = \\sum n_p(P)</span>  having disjoint supports, one naturally define  <span class="math">f(D) = \\prod f(P)^{n_p}</span> . The Tate pairing  <span class="math">\\tau_l</span>  on the set E[l] is defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Let  <span class="math">P \\in E[l](\\mathbb{F}_q)</span>  and  <span class="math">Q \\in E[l](\\mathbb{F}_{q^k})</span> . The Tate pairing is a map</p>

    <p class="text-gray-300"><span class="math">$\\tau_l : E[l](\\mathbb{F}_q) \\times E[l](\\mathbb{F}_{q^k}) \\longrightarrow \\{\\zeta_l\\}, \\text{ with } \\tau_l(P,Q) = f_P(D_Q)^{\\frac{q^k-1}{l}},</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_P</span>  is a rational function satisfying  <span class="math">(f_P) = l(P) - l(O)</span>  and  <span class="math">D_Q</span>  is a zero divisor equivalent to (Q) - (O) such that  <span class="math">D_Q</span>  and  <span class="math">(f_P)</span>  have disjoint supports. Also  <span class="math">\\{\\zeta_l\\}</span>  is the group of l-th roots of unity in  <span class="math">\\mathbb{F}_{a^k}^{\\times}</span> .</p>

    <p class="text-gray-300">It is well known that  <span class="math">\\tau_l</span>  is a non-degenerate bilinear pairing. That is, for any  <span class="math">P \\neq O \\in \\mathbb{E}[l](\\mathbb{F}_q)</span> , there exists a point  <span class="math">Q \\in E[l](\\mathbb{F}_{q^k})</span>  such that  <span class="math">\\tau_l(P,Q) \\neq 1</span> . Also we have  <span class="math">\\tau_l(P_1 + P_2, Q) = \\tau_l(P_1, Q)\\tau_l(P_2, Q)</span>  and  <span class="math">\\tau_l(P, Q_1 + Q_2) = \\tau_l(P, Q_1)\\tau_l(P, Q_2)</span> . Non-degeneracy is not a trivial result and a proof can be found in [6,17]. It is also easy to verify  <span class="math">\\tau_{ld}(P,Q) = \\tau_l(P,Q)</span>  for  <span class="math">P,Q \\in E[l]</span>  and d &gt; 0 with ld dividing  <span class="math">|E(\\mathbb{F}_q)|</span> .</p>

    <p class="text-gray-300">An effective algorithm for finding a rational function  <span class="math">f_P</span>  satisfying  <span class="math">(f_P) = l(P) - l(O)</span>  with  <span class="math">P \\in E[l]</span>  is found by Miller [15,19]. Let us briefly explain the idea of Miller. For any zero divisor D and D', the isomorphism in (3) implies that there exist points P and P' such that</p>

    <p class="text-gray-300"><span class="math">$D = (P) - (O) + (f), \\quad D&#x27; = (P&#x27;) - (O) + (f&#x27;),</span>$</p>

    <p class="text-gray-300">for some rational functions f and f'. Then one easily checks that</p>

    <p class="text-gray-300"><span class="math">$D + D&#x27; = (P + P&#x27;) - (O) + (ff&#x27; \\frac{\\ell_{P,P&#x27;}}{\\ell_{P+P&#x27;}}), \\tag{4}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\ell_{P,P&#x27;}</span>  is an equation of a line intersecting P and P', and  <span class="math">\\ell_P</span>  is an equation of a vertical line intersecting P and -P. This can be verified using the relation</p>

    <p class="text-gray-300">$$\\left(\\frac{\\ell_{P,P'}}{\\ell_{P+P'}}\\right) = (\\ell_{P,P'}) - (\\ell_{P+P'})
= (P) + (P') + (-P - P') - 3(O) - {(P + P') + (-P - P') - 2(O)}
= (P) + (P') - (P + P') - (O).$$
(5)</p>

    <p class="text-gray-300">Thus the right side of (4) is</p>

    <p class="text-gray-300"><span class="math">$(P+P&#x27;)-(O)+(ff&#x27;\\frac{\\ell_{P,P&#x27;}}{\\ell_{P+P&#x27;}})=(P+P&#x27;)-(O)+(ff&#x27;)+(P)+(P&#x27;)-(P+P&#x27;)-(O)</span>$
<span class="math">$=(P)+(P&#x27;)-2(O)+(ff&#x27;)=D+D&#x27;.</span>$</p>

    <p class="text-gray-300">An elliptic curve E over  <span class="math">\\mathbb{F}_q</span>  is called supersingular if  <span class="math">Tr(\\varphi) \\equiv 0 \\pmod{p}</span>  where  <span class="math">\\varphi</span>  is the Frobenius map and p is the characteristic of  <span class="math">\\mathbb{F}_q</span> . If an elliptic curve E over  <span class="math">\\mathbb{F}_q</span>  is supersingular, then it is well known [15] that for any l dividing  <span class="math">|E(\\mathbb{F}_q)|</span> , the embedding degree k is bounded by 6. More precisely, we have  <span class="math">E[l] \\subset E(\\mathbb{F}_{q^k})</span>  with k=2,3,4,6. It is also well known [15] that the embedding degree k=6 is attained when the characteristic of  <span class="math">\\mathbb{F}_q</span>  is three and the embedding degree k=4 is attained when the characteristic of  <span class="math">\\mathbb{F}_q</span>  is two.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3. BKLS algorithm and the algorithm of Duursma and Lee</h2>

    <p class="text-gray-300">Barreto, Kim, Lynn, and Scott [1] showed that, for some supersingular curves with embedding degree k=2,4,6, one can speed up the computation of the Tate pairing by observing that the denominators  <span class="math">\\ell_Q</span>  appearing in the Miller's algorithm can be omitted using the idea of the distortion map  <span class="math">\\phi</span>  introduced in [18], where  <span class="math">\\phi</span>  is a suitably chosen nontrivial automorphism of the given supersingular elliptic curve. That is, since the line  <span class="math">X-\\alpha</span>  intersecting  <span class="math">Q=(\\alpha,\\beta)\\in\\mathbb{F}_q</span>  and -Q has only X-coordinate and since this X-coordinate has the value in  <span class="math">\\mathbb{F}_{q^{k/2}}</span>  after applying  <span class="math">\\phi</span>  to Q, it becomes one after taking the final power by  <span class="math">\\frac{q^k-1}{l}</span>  because  <span class="math">l|q^{k/2}+1</span>  and  <span class="math">q^k-1=(q^{k/2}-1)(q^{k/2}+1)</span> . Therefore omitting  <span class="math">\\ell_Q</span>  does not affect the final pairing value and this greatly simplifies the Miller's algorithm since the costly operation of division is not necessary. By the similar reasoning, Barreto et al. [1] also showed that it is not necessary to evaluate the Tate pairing at Q, the point at infinity, since the image of Q is already in the field  <span class="math">\\mathbb{F}_q</span>  before taking the final power by  <span class="math">\\frac{q^k-1}{l}</span> . To summarize, the BKLS algorithm can be explained as follows.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> (Barreto et al. [1]) Let E be a supersingular elliptic curve over  <span class="math">\\mathbb{F}_q</span>  with embedding degree k = 2, 4, 6 and suppose that there is a suitable distortion map  <span class="math">\\phi</span>  for E. Let l be a positive integer dividing  <span class="math">|E(\\mathbb{F}_q)|</span>  with gcd(l,q) = 1 and let  <span class="math">\\{\\zeta_l\\}</span>  be the group of l-th roots of unity in  <span class="math">\\mathbb{F}_{q^k}^{\\times}</span> . Then the modified Tate pairing</p>

    <p class="text-gray-300"><span class="math">$\\tau_l : E[l](\\mathbb{F}_q) \\times E[l](\\mathbb{F}_q) \\longrightarrow \\{\\zeta_l\\}, \\text{ with } \\tau_l(P,Q) = f_P(\\phi(Q))^{\\frac{q^k-1}{l}},</span>$</p>

    <p class="text-gray-300">is a non-degenerate bilinear pairing, where  <span class="math">f_P</span>  is a rational function with denominator one, i.e. a polynomial, satisfying  <span class="math">(f_P) = l(P) - l(O)</span> .</p>

    <p class="text-gray-300">The crucial difference between the above pairing with a distortion map  <span class="math">\\phi</span>  and the conventional Tate pairing is that this new pairing is symmetric as long as  <span class="math">E[l](\\mathbb{F}_q)</span>  is a cyclic group, while the original Tate pairing is not. The reason is that, in this new pairing, both of the points P and Q are in the same cyclic group  <span class="math">E[l](\\mathbb{F}_q)</span>  generated by a point R of order l. Thus there are integers a and b satisfying P = aR and Q = bR so that we have</p>

    <p class="text-gray-300"><span class="math">$\\tau_l(P,Q) = \\tau_l(aR,bR) = \\tau_l(R,R)^{ab} = \\tau_l(bR,aR) = \\tau_l(Q,P).</span>$
(6)</p>

    <p class="text-gray-300">Efficient computation of the Tate pairing is closely related with efficient computation of the scalar multiplication lP of a given point P since one has to find a rational function  <span class="math">f_P</span>  satisfying  <span class="math">(f_P) = l(P) - l(O)</span> . Usually a binary representation of l is used for the field  <span class="math">\\mathbb{F}_{2^m}</span>  or the field  <span class="math">\\mathbb{F}_p</span>  with p a prime. A (balanced) ternary representation of l is an optimal choice for  <span class="math">\\mathbb{F}_{3^m}</span>  and both of the algorithms of BKLS [1] and Duursma-Lee [3] made careful studies for this case.</p>

    <p class="text-gray-300">For a field with characteristic three,  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q = 3^m</span> , Duursma and Lee [3] noticed that one can obtain a faster Tate pairing computation if one use  <span class="math">q^3 + 1 = 3^{3m} + 1</span>  instead of using</p>

    <p class="text-gray-300">l dividing  <span class="math">q^3 + 1</span> , since the ternary expansion of  <span class="math">q^3 + 1</span>  is trivial. That is, if one write  <span class="math">g_Q</span>  as a rational function satisfying</p>

    <p class="text-gray-300"><span class="math">$3(Q) - 3(O) = (3Q) - (O) + (g_O),</span>$</p>

    <p class="text-gray-300">then, by repeated applications of the above equation, one has</p>

    <p class="text-gray-300"><span class="math">$3^{3m}(P) - 3^{3m}(O) = (3^{3m}P) - (O) + (g_P^{3^{3m-1}}g_{3P}^{3^{3m-2}} \\cdots g_{3^{3m-2}P}^{3_{3m-2}}g_{3^{3m-1}P}^{3^{3m-1}}).</span>$</p>

    <p class="text-gray-300">It is shown [3] that the rational function</p>

    <p class="text-gray-300"><span class="math">$f = \\prod_{i=1}^{3m} g_{3^{i-1}P}^{3^{3m-i}} = g_P^{3^{3m-1}} g_{3P}^{3^{3m-2}} \\cdots g_{3^{3m-2}P}^{3^{3m-1}P}</span>$
(7)</p>

    <p class="text-gray-300">can be used for a computation of the Tate pairing as</p>

    <p class="text-gray-300"><span class="math">$\\tau_l(P,Q) = f(\\phi(Q))^{3^{3m}-1}.</span>$
(8)</p>

    <p class="text-gray-300">Duursma and Lee showed that the value  <span class="math">f(\\phi(Q)) = \\prod_{i=1}^{3m} \\{g_{3^{i-1}P}(\\phi(Q))\\}^{3^{3m-i}}</span>  has certain cyclic property with regard to the polynomials  <span class="math">g_{3^{i-1}P}^{3^{3m-i}}</span>  so that they found a nice closed formula [3] for f as a product of m (not 3m) polynomials.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">4. Tate pairing computation for binary fields with closed formulas</h3>

    <h2 id="sec-6" class="text-2xl font-bold">4.1. Supersingular elliptic curves over binary fields</h2>

    <p class="text-gray-300">For cryptographic purposes, it is natural to think of elliptic curves defined over  <span class="math">\\mathbb{F}_{2^m}</span>  with m odd or more strongly a prime. There are exactly three isomorphism classes of supersingular elliptic curves over  <span class="math">\\mathbb{F}_{2^m}</span>  when m is odd [15]. Namely they are</p>

    <p class="text-gray-300"><span class="math">$Y^2 + Y = X^3, Y^2 + Y = X^3 + X, Y^2 + Y = X^3 + X + 1.</span>$
(9)</p>

    <p class="text-gray-300">Among them, the curves</p>

    <p class="text-gray-300"><span class="math">$E_b: Y^2 + Y = X^3 + X + b, \\quad b = 0, 1</span>$
(10)</p>

    <p class="text-gray-300">have the embedding degree (or security multiplier) k=4 while the curve  <span class="math">Y^2+Y=X^3</span>  has k=2. Thus we are mainly interested in the curves  <span class="math">E_b</span>  though our method is also applicable to the curve  <span class="math">Y^2+Y=X^3</span> . The Frobenius map  <span class="math">\\varphi:E_b\\longrightarrow E_b</span>  with  <span class="math">\\varphi(x,y)=(x^2,y^2)</span>  is a root of the characteristic polynomial</p>

    <p class="text-gray-300"><span class="math">$h(X) = X^2 \\pm 2X + 2 = (X - \\varphi)(X - \\bar{\\varphi}).</span>$</p>

    <p class="text-gray-300">We also have the order  <span class="math">|E_b(\\mathbb{F}_{2^m})|</span>  of the group of rational points  <span class="math">E_b(\\mathbb{F}_{2^m})</span>  as</p>

    <p class="text-gray-300"><span class="math">$|E_b(\\mathbb{F}_{2^m})| = 2^m + 1 - Tr(\\varphi^m),</span>$</p>

    <p class="text-gray-300">where  <span class="math">Tr(\\varphi^m) = \\varphi^m + \\bar{\\varphi}^m</span>  and  <span class="math">\\varphi^m(x,y) = (x^{2^m}, y^{2^m})</span> . Letting  <span class="math">c_j = Tr(\\varphi^j)</span> , one can find the values of  <span class="math">c_j</span>  using the following second order liner recurrence relations (or Lucas type sequences) arising from the characteristic polynomial h(X),</p>

    <p class="text-gray-300"><span class="math">$c_j = 2(\\mp c_{j-1} - c_{j-2}), \\quad j \\ge 0,</span>$
(11)</p>

    <p class="text-gray-300">with  <span class="math">c_0 = 2</span>  and  <span class="math">c_1 = \\pm 2</span> . From the above relations, it is straightforward to see [15] that  <span class="math">E_b(\\mathbb{F}_{2^m})</span>  is a cyclic group of order</p>

    <p class="text-gray-300"><span class="math">$|E_b(\\mathbb{F}_{2^m})| = 2^m + 1 + (-1)^b \\sqrt{2 \\cdot 2^m}, \\quad \\text{if} \\quad m \\equiv 1, 7 \\pmod{8}</span>$</p>

    <p class="text-gray-300">=  <span class="math">2^m + 1 - (-1)^b \\sqrt{2 \\cdot 2^m}, \\quad \\text{if} \\quad m \\equiv 3, 5 \\pmod{8}.</span>  (12)</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">4.2. Closed formula of the Tate pairing for <span class="math">\\mathbb{F}_{2^m}</span></h3>

    <p class="text-gray-300">As in the characteristic three case of Duursma and Lee [3], we want to derive a closed formula for the Tate pairing computation using the simple equality for our binary case,</p>

    <p class="text-gray-300"><span class="math">$2^{2m} + 1 = \\left(2^m + 1 + 2^{\\frac{m+1}{2}}\\right)\\left(2^m + 1 - 2^{\\frac{m+1}{2}}\\right).</span>$</p>

    <p class="text-gray-300">Let  <span class="math">P = (\\alpha, \\beta)</span>  be a point on the curve  <span class="math">E_b : Y^2 + Y = X^3 + X + b</span> , b = 0, 1. Then one has  <span class="math">-P = (\\alpha, \\beta + 1)</span>  and  <span class="math">2P = (\\alpha^4 + 1, \\alpha^4 + \\beta^4)</span> . Thus we get</p>

    <p class="text-gray-300"><span class="math">$2^{2}P = (\\alpha^{2^{4}}, \\beta^{2^{4}} + 1) = -\\varphi^{4}(P), \\ 2^{3}P = (\\alpha^{2^{6}} + 1, \\alpha^{2^{6}} + \\beta^{2^{6}} + 1), \\ 2^{4}P = (\\alpha^{2^{8}}, \\beta^{2^{8}}),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\varphi^4 + 4 = 0</span> , i.e.  <span class="math">h(X) = X^2 \\pm 2X + 2</span>  divides  <span class="math">X^4 + 4</span> . Using this cyclic property, one finds easily</p>

    <p class="text-gray-300"><span class="math">$2^{i-1}P = (\\alpha^{2^{2i-2}} + i - 1, \\beta^{2^{2i-2}} + (i-1)\\alpha^{2^{2i-2}} + \\epsilon_i)</span>$</p>

    <p class="text-gray-300">=  <span class="math">(\\alpha^{(2i-2)} + i - 1, \\beta^{(2i-2)} + (i-1)\\alpha^{(2i-2)} + \\epsilon_i),</span>  (13)</p>

    <p class="text-gray-300">where  <span class="math">\\alpha^{(j)}</span>  (resp.  <span class="math">\\beta^{(j)}</span> ) is defined as  <span class="math">\\alpha^{(j)} = \\alpha^{2^j}</span>  (resp.  <span class="math">\\beta^{(j)} = \\beta^{2^j}</span> ) and  <span class="math">\\epsilon_i</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$\\epsilon_i = 0</span>$
if  <span class="math">i \\equiv 1, 2 \\pmod{4}</span>  and  <span class="math">\\epsilon_i = 1</span>  if  <span class="math">i \\equiv 3, 4 \\pmod{4}</span> . (14)</p>

    <p class="text-gray-300">For an effective Tate pairing computation, the following distortion map (nontrivial automorphism) is chosen [1] for  <span class="math">E_b</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\phi: E_b \\longrightarrow E_b, \\text{ with } \\phi(x,y) = (x+s^2, y+sx+t),</span>$
(15)</p>

    <p class="text-gray-300">where  <span class="math">s^{2} + s + 1 = 0</span>  and  <span class="math">t^{2} + t + s = 0</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}_2(s) = \\mathbb{F}_{2^2}, \\quad \\mathbb{F}_2(t) = \\mathbb{F}_{2^4}, \\quad s = t^5, \\quad t^4 + t + 1 = 0,</span>$
(16)</p>

    <p class="text-gray-300">and t is a generator of the cyclic group  <span class="math">\\mathbb{F}_{2^4}^{\\times}</span>  of order 15. Therefore if P is a point of order l in  <span class="math">\\mathbb{F}_{2^m}</span>  with m odd, then  <span class="math">\\phi(P) \\in E(\\mathbb{F}_{2^{4m}})</span>  but  <span class="math">\\phi(P) \\notin E(\\mathbb{F}_{2^{2m}})</span> , and the two points P and  <span class="math">\\phi(P)</span>  generate all points of order l as a  <span class="math">\\mathbb{Z}/l</span>  module.</p>

    <p class="text-gray-300">For any point Q on the curve  <span class="math">E_b</span> , let us write  <span class="math">g_Q</span>  as a rational function satisfying</p>

    <p class="text-gray-300"><span class="math">$2(Q) - 2(O) = (2Q) - (O) + (g_Q).</span>$</p>

    <p class="text-gray-300">By the Miller's formula in (4), we have  <span class="math">g_Q = \\ell_{Q,Q}/\\ell_{2Q}</span>  and the denominator  <span class="math">\\ell_{2Q}</span>  can be omitted by the result of Barreto et al. [1]. Now for a given point  <span class="math">P \\in E_b(\\mathbb{F}_{2^m})</span> , one repeatedly has</p>

    <p class="text-gray-300"><span class="math">$2(P) - 2(O) = (2P) - (O) + (g_P),</span>$</p>

    <p class="text-gray-300"><span class="math">$2^2(P) - 2^2(O) = 2\\{(2P) - (O)\\} + (g_P^2) = (2^2P) - (O) + (g_P^2g_{2P}),</span>$</p>

    <p class="text-gray-300"><span class="math">$2^3(P) - 2^3(O) = 2\\{(2^2P) - (O)\\} + (g_P^{2^2}g_{2P}^2) = (2^3P) - (O) + (g_P^{2^2}g_{2P}^2g_{2P}^2),</span>$</p>

    <p class="text-gray-300"><span class="math">$2^{2m}(P) - 2^{2m}(O) = (2^{2m}P) - (O) + (g_P^{2^{2m-1}}g_{2P}^{2^{2m-2}} \\cdots g_{2^{2m-2}P}^2g_{2^{2m-1}P}).</span>$</p>

    <p class="text-gray-300">Letting</p>

    <p class="text-gray-300"><span class="math">$f_P = \\prod_{i=1}^{2m} g_{2i-1P}^{2^{2m-i}} = g_P^{2^{2m-1}} g_{2P}^{2^{2m-2}} \\cdots g_{2^{2m-2}P}^{2^{2m-1}P}, \\tag{17}</span>$</p>

    <p class="text-gray-300">we have</p>

    <p class="text-gray-300"><span class="math">$2^{2m}(P) - 2^{2m}(O) = (2^{2m}P) - (O) + (f_P)</span>$
and  <span class="math">(P) - (O) = (P) - (O) + (1)</span> .</p>

    <p class="text-gray-300">Thus the equation (4) of the Miller's formula again says</p>

    <p class="text-gray-300"><span class="math">$(2^{2m} + 1)\\{(P) - (O)\\} = (f_P \\ell_P), \\tag{18}</span>$</p>

    <p class="text-gray-300">because  <span class="math">2^{2m}P = -P</span> . Note that the line  <span class="math">\\ell_P</span>  can also be omitted in the actual computation by the BKLS algorithm. Therefore after adjusting the irrelevant factors, we can say that</p>

    <p class="text-gray-300"><span class="math">$(f_P) = (2^{2m} + 1)\\{(P) - (O)\\} = \\frac{2^{2m} + 1}{l} \\cdot \\{l(P) - l(O)\\} = \\frac{2^{2m} + 1}{l}(f_P&#x27;), \\tag{19}</span>$</p>

    <p class="text-gray-300">where  <span class="math">f_P&#x27;</span>  is a rational function satisfying  <span class="math">l(P) - l(O) = (f_P&#x27;)</span> . Thus we have the Tate pairing</p>

    <p class="text-gray-300"><span class="math">$\\tau_l(P,Q) = f_P&#x27;(\\phi(Q))^{\\frac{2^{4m}-1}{l}} = f_P&#x27;(\\phi(Q))^{\\frac{2^{2m}+1}{l}(2^{2m}-1)} = f_P(\\phi(Q))^{2^{2m}-1}.</span>$
(20)</p>

    <p class="text-gray-300">From the equation (17), the rational function  <span class="math">f_P</span>  is just a product of the functions of the form  <span class="math">g_{2^{i-1}P}</span>  and, in view of the BKLS algorithm, the rational function  <span class="math">g_{2^{i-1}P}</span>  can be regarded as the tangent line at the point  <span class="math">2^{i-1}P</span> . Thus all we have to do is to find an explicit expression of  <span class="math">f_P = \\prod_{i=1}^{2m} g_{2^{i-1}P}^{2^{2m-i}}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let  <span class="math">P = (\\alpha, \\beta), Q = (x, y)</span>  be points in  <span class="math">E_b(\\mathbb{F}_{2^m})</span> . Then one has the value of  <span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} = \\{g_{2^{i-1}P}(x+s^2, y+sx+t)\\}^{2^{2m-i}}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} = \\alpha^{(i-1)}x^{(-i)} + \\beta^{(i-1)} + y^{(-i)} + s(\\alpha^{(i-1)} + x^{(-i)}) + t + b,</span>$</p>

    <p class="text-gray-300">where  <span class="math">g_R(X,Y) = \\ell_{R,R}</span>  is an equation of the tangent line at R.</p>

    <p class="text-gray-300"><em>Proof.</em> The tangent line at  <span class="math">P=(\\alpha,\\beta)</span>  on the curve  <span class="math">E_b:Y^2+Y=X^3+X+b</span>  is  <span class="math">Y=(\\alpha^2+1)X+\\beta^2+b</span> . Thus we have  <span class="math">2(P)-2(O)=(2P)-(O)+(\\frac{g_P}{\\ell_{2P}})</span>  where</p>

    <p class="text-gray-300"><span class="math">$g_P(x,y) = (\\alpha^2 + 1)x + \\beta^2 + b - y,</span>$
(21)</p>

    <p class="text-gray-300">and  <span class="math">\\ell_{2P}</span>  is the vertical line intersecting 2P and -2P. Since  <span class="math">\\ell_{2P}</span>  can be removed in view of the BKLS algorithm [1], we are mainly interested in the computations of the lines  <span class="math">g_{2^{i-1}P}</span> . Using the equation (13), one has</p>

    <p class="text-gray-300"><span class="math">$g_{2^{i-1}P}(x,y) = (\\alpha^{(2i-1)} + i)x + \\beta^{(2i-1)} + (i-1)\\alpha^{(2i-1)} + \\epsilon_i + b - y.</span>$</p>

    <p class="text-gray-300">Therefore, by applying the distortion map  <span class="math">\\phi</span>  to the point Q=(x,y), we get</p>

    <p class="text-gray-300"><span class="math">$g_{2^{i-1}P}(x+s^2,y+sx+t) = (\\alpha^{(2i-1)}+i)(x+s^2) + \\beta^{(2i-1)}+(i-1)\\alpha^{(2i-1)} + \\epsilon_i + b - (y+sx+t).</span>$
(22)</p>

    <p class="text-gray-300">Taking  <span class="math">2^{2m-i}</span> -th power of both sides of the above equality,</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= (\\alpha^{(i-1)} + i)(x^{(2m-i)} + s^{(2m-i+1)}) + \\beta^{(i-1)} + (i-1)\\alpha^{(i-1)} + \\epsilon_i + b</span>$</p>

    <p class="text-gray-300"><span class="math">$- (y^{(2m-i)} + s^{(2m-i)}x^{(2m-i)} + t^{(2m-i)})</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\alpha^{(i-1)}x^{(2m-i)} + \\{i - s^{(2m-i)}\\}x^{(2m-i)} + \\{s^{(2m-i+1)} + i - 1\\}\\alpha^{(i-1)}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ \\beta^{(i-1)} + b - y^{(2m-i)} + \\{is^{(2m-i+1)} + \\epsilon_i - t^{(2m-i)}\\}.</span>$
(23)</p>

    <p class="text-gray-300">From  <span class="math">s^2 + s + 1 = 0</span> , we have  <span class="math">s^{(2)} = s^4 = s</span> ,  <span class="math">s^{(3)} = s^2 = s + 1</span> ,  <span class="math">s^{(4)} = s</span> ,  <span class="math">\\cdots</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$s^{(j)} = s + 1</span>$
if  <span class="math">j = odd</span>  and  <span class="math">s^{(j)} = s</span>  if  <span class="math">j = even</span> . (24)</p>

    <p class="text-gray-300">The coefficients  <span class="math">i-s^{(2m-i)}</span>  (resp.  <span class="math">i-1+s^{(2m-i+1)}</span> ) of  <span class="math">x^{(2m-i)}</span>  (resp.  <span class="math">\\alpha^{(i-1)}</span> ) in the equation (23) have a unique value equal to s independent of the choices of i because i and 2m-i always have the same parity. For example, when i is odd,  <span class="math">i-s^{(2m-i)}=1+s+1=s</span>  and also when i is even,  <span class="math">i-s^{(2m-i)}=0+s=s</span> . That is, for any i, we get</p>

    <p class="text-gray-300"><span class="math">$i - s^{(2m-i)} = s = i - 1 + s^{(2m-i+1)}. (25)</span>$</p>

    <p class="text-gray-300">From  <span class="math">t^2 = t + s</span> , we have  <span class="math">t^{(2)} = t^{2^2} = t + s + s^2 = t + 1</span> ,  <span class="math">t^{(3)} = t^{2^3} = t + s + 1</span> ,  <span class="math">t^{(4)} = t + s + s^2 + 1 = t</span> ,  <span class="math">t^{(5)} = t^2 = t + s</span> ,  <span class="math">\\cdots</span> . Therefore, for any  <span class="math">j \\ge 0</span> , we have</p>

    <p class="text-gray-300"><span class="math">$t^{(4j)} = t</span>$
,  <span class="math">t^{(4j+1)} = t + s</span> ,  <span class="math">t^{(4j+2)} = t + 1</span> ,  <span class="math">t^{(4j+3)} = t + s + 1</span> . (26)</p>

    <p class="text-gray-300">Now using the equations (14),(24),(26), it is trivial to show that the last term of the equation (23) has the value</p>

    <p class="text-gray-300"><span class="math">$is^{(2m-i+1)} + \\epsilon_i - t^{(2m-i)} = t</span>$
(27)</p>

    <p class="text-gray-300">independent of the choices of <em>i</em>. This can be proved as follows. Since the extension degree m is odd, we have  <span class="math">m \\equiv 1 \\pmod{4}</span>  or  <span class="math">m \\equiv 3 \\pmod{4}</span> . In any case, we get  <span class="math">2m \\equiv 2 \\pmod{4}</span>  and letting 2m = 4j + 2 for some j,</p>

    <p class="text-gray-300"><span class="math">$is^{(2m-i+1)} + \\epsilon_i - t^{(2m-i)} = is^{(4j+3-i)} + \\epsilon_i - t^{(4j+2-i)}.</span>$
(28)</p>

    <p class="text-gray-300">By taking  <span class="math">i \\pmod 4</span>  and noticing that our field has characteristic two, we easily get the equation (27). Since  <span class="math">x, y, \\alpha, \\beta</span>  are all in  <span class="math">\\mathbb{F}_{2^m}</span> , the values  <span class="math">x^{(j)}, y^{(j)}, \\alpha^{(j)}, \\beta^{(j)}</span>  are determined up to the residue classes of  <span class="math">j \\pmod m</span>  and  <span class="math">x^{(j)}</span>  with  <span class="math">j \\in \\mathbb{Z}</span>  (resp.  <span class="math">y^{(j)}, \\alpha^{(j)}, \\beta^{(j)}</span> ) is understood as  <span class="math">x^{(j)} = x^{2^{j&#x27;}}</span>  where j',  <span class="math">0 \\le j&#x27; \\le m-1</span> , is a unique integer satisfying  <span class="math">j&#x27; \\equiv j \\pmod m</span> . Therefore we get</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} = \\alpha^{(i-1)}x^{(-i)} + sx^{(-i)} + s\\alpha^{(i-1)} + \\beta^{(i-1)} + y^{(-i)} + t + b</span>$
<span class="math">$= \\alpha^{(i-1)}x^{(-i)} + \\beta^{(i-1)} + y^{(-i)} + s(\\alpha^{(i-1)} + x^{(-i)}) + t + b.</span>$</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> One has the Tate pairing  <span class="math">\\tau_l(P,Q) = f_P(\\phi(Q))^{2^{2m}-1}</span>  where</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^m \\{\\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b\\}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By the equation (17) and (20), we have  <span class="math">f_P(\\phi(Q)) = \\prod_{i=1}^{2m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}}</span>  and since all  <span class="math">x^{(j)}, y^{(j)}, \\alpha^{(j)}, \\beta^{(j)}</span>  are determined up to the residue classes of  <span class="math">j \\pmod{m}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} f_P(\\phi(Q)) &amp;= \\prod_{i=1}^m \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\prod_{i=m+1}^{2m} \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\\\ &amp;= \\prod_{i=1}^m \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\prod_{i=1}^m \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{2m-i}} \\\\ &amp;= \\prod_{i=1}^m \\{\\alpha^{(i-1)}x^{(-i)} + \\beta^{(i-1)} + y^{(-i)} + s(\\alpha^{(i-1)} + x^{(-i)}) + t + b\\}^2 \\\\ &amp;= \\prod_{i=1}^m \\{\\alpha^{(i)}x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b\\}. \\end{split}</span>$</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">5. Efficient field arithmetic for the computation of <span class="math">f_P(\\phi(Q))</span></h3>

    <p class="text-gray-300">The computation of  <span class="math">f_P(\\phi(Q))</span>  involves multiplications in  <span class="math">\\mathbb{F}_{2^{4m}}</span> . A natural way to do this is to use a basis for  <span class="math">\\mathbb{F}_{2^{4m}}</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  and transforms a multiplication in  <span class="math">\\mathbb{F}_{2^{4m}}</span>  into several multiplications in  <span class="math">\\mathbb{F}_{2^m}</span> . Since the extension degree is 4, we may use an optimal normal basis of type I but we will stick to the polynomial basis  <span class="math">\\{1, t, t^2, t^3\\}</span>  for  <span class="math">\\mathbb{F}_{2^{4m}}</span>  with the minimal polynomial of t as  <span class="math">X^4 + X + 1</span>  over  <span class="math">\\mathbb{F}_{2^m}</span> . Using  <span class="math">s^2 = t^2 + t + 1</span> , we may express the element  <span class="math">\\alpha^{(i)}x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\alpha^{(i)}x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b = w + zt + (z+1)t^2</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$z = \\alpha^{(i)} + x^{(-i+1)}, \\quad w = z + \\alpha^{(i)}x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + b.</span>$
(29)</p>

    <p class="text-gray-300">Letting  <span class="math">C = c_0 + c_1 t + c_2 t^2 + c_3 t^3</span> ,  <span class="math">c_i \\in \\mathbb{F}_{2^m}</span> , be the partial product in the computation of  <span class="math">f_P(\\phi(Q))</span> , we have</p>

    <p class="text-gray-300"><span class="math">$C \\cdot (w + zt + (z+1)t^{2}) = (c_{0} + c_{1}t + c_{2}t^{2} + c_{3}t^{3})(w + zt + (z+1)t^{2})</span>$
<span class="math">$= c&#x27;_{0} + c&#x27;_{1}t + c&#x27;_{2}t^{2} + c&#x27;_{3}t^{3},</span>$
(30)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{0} = c_{0}w + (c_{2} + c_{3})(z+1) + c_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{1} = c_{0}w + (c_{1} + c_{2} + c_{3})w + (c_{0} + c_{2} + c_{3})(w+z+1) + c_{3}(z+1) + c_{0} + c_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{2} = c_{0}w + (c_{1} + c_{2} + c_{3})w + (c_{0} + c_{2} + c_{3})(w+z+1) + (c_{1} + c_{2})(w+z+1) + c_{1}</span>$</p>

    <p class="text-gray-300"><span class="math">$c&#x27;_{3} = (c_{1} + c_{2} + c_{3})w + (c_{1} + c_{2})(w+z+1) + c_{2}.</span>$
(31)</p>

    <p class="text-gray-300">Therefore one needs only 6 multiplications for the computation of  <span class="math">C \\cdot (w + zt + (z + 1)t^2)</span> .</p>

    <p class="text-gray-300"><strong>Table 1.</strong> An algorithm for computing  <span class="math">f_P(\\phi(Q))</span></p>

    <p class="text-gray-300">Input:  <span class="math">P = (\\alpha, \\beta), Q = (x, y)</span> Output:  <span class="math">C = f_P(\\phi(Q))</span></p>

    <pre><code class="language-text">\\begin{array}{l} C \\leftarrow 1 \\\\ \\text{for } (i=1 \\text{ to } m \\text{ ; } i++) \\\\ \\alpha \\leftarrow \\alpha^2, \\quad \\beta \\leftarrow \\beta^2 \\\\ z \\leftarrow \\alpha + x, \\quad w \\leftarrow z + \\alpha x + \\beta + y + b \\\\ C \\leftarrow C \\cdot (w + zt + (z+1)t^2) \\\\ x \\leftarrow x^{2^{m-1}}, \\quad y \\leftarrow y^{2^{m-1}} \\\\ \\text{end for} \\end{array}
</code></pre>

    <p class="text-gray-300">Assuming that we are using a normal basis for  <span class="math">\\mathbb{F}_{2^m}</span>  over  <span class="math">\\mathbb{F}_2</span> , the Frobenius maps in Table 1 contribute a negligible cost. Moreover the map  <span class="math">x \\leftarrow x^{2^{m-1}}</span>  is just a left cyclic shifting by one position of the vector x with respect to a normal basis while  <span class="math">x \\leftarrow x^2</span>  is a right cyclic shifting by one position. All these Frobenius maps are especially useful if one wants an efficient hardware implementation. If we ignore the costs of Frobenius maps and  <span class="math">\\mathbb{F}_{2^m}</span> -additions, we find that exactly  <span class="math">7 \\mathbb{F}_{2^m}</span> -multiplications are needed in each round of the for-loop, where the computation of w needs one multiplication in  <span class="math">\\mathbb{F}_{2^m}</span>  and the computation of C needs 6 multiplications in  <span class="math">\\mathbb{F}_{2^m}</span>  by the equation (31). Compare our result with the similar result in  <span class="math">\\mathbb{F}_{3^m}</span>  case of Duursma and Lee where each step of the algorithm in [3] requires 17  <span class="math">\\mathbb{F}_{3^m}</span> -multiplications with trace computation technique [2] and can be reduced to  <span class="math">14 \\mathbb{F}_{3^m}</span> -multiplications [8] with loop unfolding technique.</p>

    <p class="text-gray-300">It should be mentioned that one can also use a normal basis for  <span class="math">\\mathbb{F}_{2^{4m}}</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  instead of using  <span class="math">\\{1, t, t^2, t^3\\}</span>  with  <span class="math">t^4 + t + 1 = 0</span> . Letting  <span class="math">t^3 = \\gamma</span> , one has  <span class="math">\\gamma^5 = 1</span>  and the minimal polynomial of  <span class="math">\\gamma</span>  over  <span class="math">\\mathbb{F}_{2^m}</span>  is  <span class="math">X^4 + X^3 + X^2 + X + 1</span> . Therefore we have a normal basis  <span class="math">\\{\\gamma, \\gamma^2, \\gamma^{2^2}, \\gamma^{2^3}\\} = \\{\\gamma, \\gamma^2, \\gamma^3, \\gamma^4\\}</span>  of type I over  <span class="math">\\mathbb{F}_{2^m}</span> . Using the relation  <span class="math">t = \\frac{1}{t^3+1} = \\frac{1}{\\gamma+1} = \\gamma^3 + \\gamma</span> , one may reformulate the equations (30) and (31) with respect to the basis  <span class="math">\\{\\gamma, \\gamma^2, \\gamma^3, \\gamma^4\\}</span> . In this case, the number of necessary additions in  <span class="math">\\mathbb{F}_{2^m}</span>  slightly increases, however the expressions of the coefficients of C in (31) have more regular patterns which are particularly useful for a hardware implementation.</p>

    <p class="text-gray-300">Computing the final powering by  <span class="math">2^{2m}-1</span>  is a formidable task. However in some situations like a signature verification, one only needs to determine whether  <span class="math">\\tau_l(P,Q) = \\tau_l(P&#x27;,Q&#x27;)</span>  without having to know the exact value of  <span class="math">\\tau_l(P,Q) = f_P(\\phi(Q))^{2^{2m}-1}</span> . In this case, it suffices to check whether  <span class="math">f_P(\\phi(Q))^{2^{2m}} f_{P&#x27;}(\\phi(Q&#x27;)) = f_P(\\phi(Q)) f_{P&#x27;}(\\phi(Q&#x27;))^{2^{2m}}</span>  and the cost of this operation is much cheaper than the cost of the exponentiation by  <span class="math">2^{2m}-1</span> . Replacing  <span class="math">2^{2m}</span>  by  <span class="math">3^{3m}</span> , the same technique is also applicable to the Duursma-Lee algorithm [3].</p>

    <p class="text-gray-300">Many computational evidence [8,20] imply that a more efficient field arithmetic can be obtained for low characteristic finite fields by using a polynomial basis than a normal basis, especially for software purposes. Though a Gaussian normal basis of low complexity [26] is a good choice for a fast arithmetic, such basis does not appear quite frequently when compared with a polynomial basis of low hamming weight (like trinomial or pentanomial). In the case of the Tate pairing computation, the same phenomenon that a polynomial basis wins over a normal basis has been observed by Granger, Page, and Stam [8]. Granger et al. [8] showed that, even though a cube root operation (inverse Frobenius operation for characteristic three) in a polynomial basis is quite costly, an algorithm for the Tate pairing computation with a</p>

    <p class="text-gray-300">polynomial basis outperforms a method with a normal basis since one needs many operations of multiplication while only two cube root operations are needed in each step of the Duursma-Lee algorithm [3,8] and since the cost of a multiplication with a normal basis is quite expensive than that of a polynomial basis in general situations. With a small amount of precomputation, Granger et al. [8] showed that a cube root operation in  <span class="math">\\mathbb{F}_{3^m}</span>  has roughly the same cost as 2/3 multiplication in  <span class="math">\\mathbb{F}_{3^m}</span> . The same method in [8] can be applied to our characteristic two case so that we can show that the cost of one square root operation is roughly equal to the cost of 1/2 multiplication with a precomputation. It should be mentioned that a general case without a precomputation is not so simple and one needs at least  <span class="math">O(m^2 \\log_2 m)</span>  additions in  <span class="math">\\mathbb{F}_2</span>  to find a square root in  <span class="math">\\mathbb{F}_{2^m}</span>  as is observed by Barreto et al. [2], though the complexity can be reduced to  <span class="math">O(m^2)</span>  additions in  <span class="math">\\mathbb{F}_2</span>  if we use a low weight polynomial like a trinomial or a pentanomial.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">6.1. Avoiding square root extraction</h4>

    <p class="text-gray-300">In this section, we briefly remark that a close examination of the algorithm in Table 1 reveals that one may derive a new algorithm for the Tate pairing computation which does not need any inverse Frobenius operation (like square root or cube root extractions). Our method is also applicable to the characteristic <em>three</em> case of Duursma an Lee [3] and will be explained later. Let us first study the binary case here. From Theorem 4, we know that</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^{m} \\{\\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2(\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b\\}.</span>$
(32)</p>

    <p class="text-gray-300">We define  <span class="math">A_i</span>  as the conjugates of the terms in the product of the above formula by</p>

    <p class="text-gray-300"><span class="math">$A_i^{(m-i)} = A_i^{2^{m-i}} = \\alpha^{(i)} x^{(-i+1)} + \\beta^{(i)} + y^{(-i+1)} + s^2 (\\alpha^{(i)} + x^{(-i+1)}) + t^2 + b</span>$</p>

    <p class="text-gray-300">so that</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^m A_i^{2^{m-i}} = A_1^{2^{m-1}} A_2^{2^{m-2}} \\cdots A_m = (\\cdots (((A_1)^2 A_2)^2 A_3)^2 \\cdots)^2 A_m.</span>$
(33)</p>

    <p class="text-gray-300">Since  <span class="math">A_i</span>  is in  <span class="math">\\mathbb{F}_{2^{4m}}</span> , we get  <span class="math">A_i^{(4m)} = A_i</span> . Therefore, using the fact  <span class="math">\\alpha, \\beta, x, y \\in \\mathbb{F}_{2^m}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$A_{i} = (A_{i}^{(m-i)})^{2^{3m+i}} = \\alpha^{(2i)}x^{(1)} + \\beta^{(2i)} + y^{(1)} + s^{(3m+1+i)}(\\alpha^{(2i)} + x^{(1)}) + t^{(3m+1+i)} + b</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\alpha^{(2i)}x^{2} + \\beta^{(2i)} + y^{2} + s^{(i)}(\\alpha^{(2i)} + x^{2}) + t^{(m-1+i)} + b.</span>$
(34)</p>

    <p class="text-gray-300">because  <span class="math">s^{(j)}</span>  is determined up to  <span class="math">j \\pmod 2</span>  with  <span class="math">3m+1 \\equiv 0 \\pmod 2</span>  and  <span class="math">t^{(j)}</span>  is determined up to  <span class="math">j \\pmod 4</span>  with  <span class="math">3m+1 \\equiv m-1 \\pmod 4</span>  as is clear from the equations (24) and (26). Using the cyclic property of  <span class="math">t^{(j)}</span>  in the equation (26), it is not difficult to see that, for all indices  <span class="math">1 \\le i \\le m</span> ,  <span class="math">A_i</span>  can be written as  <span class="math">A_i = A_i(t) = w + zt + (z+1)t^2</span>  for some z and w in  <span class="math">\\mathbb{F}_{2^m}</span> . Thus, similarly as in the equations (30) and (31), one needs  <span class="math">6 \\mathbb{F}_{2^m}</span> -multiplications for computing  <span class="math">C \\cdot A_i(t)</span>  with respect to the basis  <span class="math">\\{1, t, t^2, t^3\\}</span>  for any  <span class="math">C \\in \\mathbb{F}_{2^{4m}}</span> . We now have the following algorithm for computing  <span class="math">f_P(\\phi(Q))</span>  which avoids inverse Frobenius operations.</p>

    <p class="text-gray-300"><strong>Table 2.</strong> An algorithm for computing  <span class="math">f_P(\\phi(Q))</span>  avoiding inverse Frobenius operation</p>

    <pre><code class="language-text">Input: P = (\\alpha, \\beta), Q = (x, y)

Output: C = f_P(\\phi(Q))

C \\leftarrow 1

u \\leftarrow x^2, \\quad v \\leftarrow x^2, \\quad y \\leftarrow y^2

for (i = 1 \\text{ to } m \\text{ ; } i + +)

\\alpha \\leftarrow \\alpha^4, \\quad \\beta \\leftarrow \\beta^4

A(t) \\leftarrow \\alpha(v+1) + u + \\beta + y + b + \\frac{m-1}{2} + (\\alpha+v)t + (\\alpha+v+1)t^2

C \\leftarrow C^2 \\cdot A(t)

u \\leftarrow u + v + 1, \\quad v \\leftarrow v + 1
\\nend for
</code></pre>

    <p class="text-gray-300">Note that the coefficients of  <span class="math">A_i(t)</span>  depend on the values of  <span class="math">s^{(i)}</span>  and  <span class="math">t^{(m-1+i)}</span>  and they are recursively computed by the relation (24) and (26). We have the initial values  <span class="math">s^{(1)} = s^2 = t^2 + t + 1</span>  and  <span class="math">t^{(m)} = t^2 + \\frac{m-1}{2}</span>  and thus we get</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} A_1(t) &amp;= \\alpha x + \\beta + y + (t^2 + t + 1)(\\alpha + x) + t^2 + \\frac{m-1}{2} + b \\\\ &amp;= \\alpha(x+1) + x + \\beta + y + b + \\frac{m-1}{2} + (\\alpha + x)t + (\\alpha + x + 1)t^2, \\\\ A_2(t) &amp;= \\alpha x + \\beta + y + (t^2 + t)(\\alpha + x) + t + 1 + \\frac{m-1}{2} + b \\\\ &amp;= \\alpha x + 1 + \\beta + y + b + \\frac{m-1}{2} + (\\alpha + x + 1)t + (\\alpha + x)t^2, \\\\ A_3(t) &amp;= \\alpha(x+1) + (x+1) + \\beta + y + b + \\frac{m-1}{2} + (\\alpha + x)t + (\\alpha + x + 1)t^2, \\\\ A_4(t) &amp;= \\alpha x + \\beta + y + b + \\frac{m-1}{2} + (\\alpha + x + 1)t + (\\alpha + x)t^2. \\end{split}</span>$</p>

    <p class="text-gray-300">Using the intermediate values u, v with the relations  <span class="math">u \\leftarrow u + v + 1</span> ,  <span class="math">v \\leftarrow v + 1</span> , the pair covers all the possible values (u, v) = (x, x), (1, x + 1), (x + 1, x), (0, x + 1) and the algorithm in Table 2 is justified. In each step of the above algorithm, one needs  <span class="math">7 \\mathbb{F}_{2^m}</span> -multiplications which is same to the algorithm in Table 1. Since the operation  <span class="math">C \\leftarrow C^2</span>  needs 4 squaring operations in  <span class="math">\\mathbb{F}_{2^m}</span>  and since the operations  <span class="math">\\alpha \\leftarrow \\alpha^4, \\beta \\leftarrow \\beta^4</span>  need the same 4 squaring operations, the total number of necessary squaring is 8 in this new algorithm. On the other hand, the algorithm in Table 1 needs 2 squaring and 2 square root operations. Therefore our new algorithm in Table 2 is a more optimal choice if one is interested in the implementation with a polynomial basis since this new algorithm uses 6 Frobenius operations instead of using 2 inverse Frobenius operations.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">6.2. Avoiding cube root extraction from the algorithm of Duursma and Lee</h4>

    <p class="text-gray-300">Duursma and Lee [3] found a close formula for the following supersingular elliptic curves defined over  <span class="math">\\mathbb{F}_{3^m}</span>  with m prime to 6,</p>

    <p class="text-gray-300"><span class="math">$E_b: Y^2 = X^3 - X + b, \\quad b = \\pm 1.</span>$
(35)</p>

    <p class="text-gray-300">For the above mentioned curves, the following distortion map (nontrivial automorphism) is used,</p>

    <p class="text-gray-300"><span class="math">$\\phi: E_b \\longrightarrow E_b, \\quad \\text{with} \\quad \\phi(x, y) = (\\rho - x, \\sigma y),</span>$
(36)</p>

    <p class="text-gray-300">where  <span class="math">\\sigma^2 + 1 = 0</span>  and  <span class="math">\\rho^3 - \\rho - b = 0</span> . That is,  <span class="math">\\mathbb{F}_3(\\sigma) = \\mathbb{F}_{3^2}</span>  and  <span class="math">\\mathbb{F}_3(\\rho) = \\mathbb{F}_{3^3}</span> . A closed formula of Duursma and Lee says that, for  <span class="math">P = (\\alpha, \\beta)</span>  and Q = (x, y) in  <span class="math">E[l](\\mathbb{F}_{3^m})</span> , the Tate pairing</p>

    <p class="text-gray-300">can be written as  <span class="math">\\tau_l(P,Q) = f_P(\\phi(Q))^{3^{3m}-1}</span>  where</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^m \\{ -\\sigma\\beta^{(i)}y^{(-i+1)} - (\\alpha^{(i)} + x^{(-i+1)} - \\rho + b)^2 \\}, \\tag{37}</span>$</p>

    <p class="text-gray-300">and  <span class="math">f_P</span>  is a rational function satisfying  <span class="math">(f_P) = (3^{3m} + 1)\\{(P) - (O)\\}</span> . Now define the intermediate values  <span class="math">\\mu</span>  and  <span class="math">\\lambda</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\mu = \\alpha^{(i)} + x^{(-i+1)} + b \\in \\mathbb{F}_{3^m}</span>$
and  <span class="math">\\lambda = -\\sigma \\beta^{(i)} y^{(-i+1)} - \\mu^2 \\in \\mathbb{F}_{3^{2m}}</span> .</p>

    <p class="text-gray-300">Then the formula (37) to compute  <span class="math">f_P(\\phi(Q))</span>  is realized by the following algorithm [2,3,8].</p>

    <p class="text-gray-300"><strong>Table 3.</strong> Duursma-Lee algorithm for computing  <span class="math">f_P(\\phi(Q))</span></p>

    <pre><code class="language-text">Input: P = (\\alpha, \\beta), Q = (x, y)

Output: C = f_P(\\phi(Q))

C \\leftarrow 1

for (i = 1 \\text{ to } m \\text{ ; } i + +)

\\alpha \\leftarrow \\alpha^3, \\quad \\beta \\leftarrow \\beta^3

\\mu = \\alpha + x + b, \\quad \\lambda = -\\sigma\\beta y - \\mu^2

C \\leftarrow C \\cdot (\\lambda - \\mu\\rho - \\rho^2)

x \\leftarrow x^{1/3}, \\quad y \\leftarrow y^{1/3}
\\nend for
</code></pre>

    <p class="text-gray-300">One needs 2 cube root operations in each step of the above algorithm. However it is not so difficult, by using the same technique of the previous section, to show that one can have a new algorithm where 2 cube root operations (inverse Frobenius) are replaced by 8 cube operations (Frobenius) without affecting the number of multiplications in  <span class="math">\\mathbb{F}_{3^m}</span> , which are quite useful in polynomial basis arithmetic. Let us define  <span class="math">A_i \\in \\mathbb{F}_{3^{6m}}</span>  as the conjugates of the terms in the product formula (37) by</p>

    <p class="text-gray-300"><span class="math">$A_i^{(m-i)} = A_i^{3^{m-i}} = -\\sigma \\beta^{(i)} y^{(-i+1)} - (\\alpha^{(i)} + x^{(-i+1)} - \\rho + b)^2</span>$
(38)</p>

    <p class="text-gray-300">so that</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^m A_i^{3^{m-i}} = A_1^{3^{m-1}} A_2^{3^{m-2}} \\cdots A_m = (\\cdots (((A_1)^3 A_2)^3 A_3)^3 \\cdots)^3 A_m.</span>$
(39)</p>

    <p class="text-gray-300">Since  <span class="math">A_i</span>  is in  <span class="math">\\mathbb{F}_{3^{6m}}</span> , we get  <span class="math">A_i^{(6m)} = A_i</span> . From the equation (38), using the fact  <span class="math">\\alpha, \\beta, x, y \\in \\mathbb{F}_{3^m}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$A_{i} = (A_{i}^{(m-i)})^{3^{5m+i}} = -\\sigma^{(5m+i)}\\beta^{(2i)}y^{(1)} - (\\alpha^{(2i)} + x^{(1)} - \\rho^{(5m+i)} + b)^{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$= (-1)^{i+1}\\sigma\\beta^{(2i)}y^{(1)} - (\\alpha^{(2i)} + x^{(1)} - \\rho + (m+1-i)b)^{2},</span>$
(40)</p>

    <p class="text-gray-300">because the relations  <span class="math">\\sigma^2 + 1 = 0</span> ,  <span class="math">\\rho^3 - \\rho - b = 0</span>  imply</p>

    <p class="text-gray-300"><span class="math">$\\sigma^{(j)} = (-1)^j \\sigma \\quad \\text{and} \\quad \\rho^{(j)} = \\rho + jb. \\tag{41}</span>$</p>

    <p class="text-gray-300">Letting  <span class="math">\\mu = \\alpha^{(2i)} + x^{(1)} + (m+1-i)b \\in \\mathbb{F}_{3^m}</span>  and  <span class="math">\\lambda = (-1)^{i+1}\\sigma\\beta^{(2i)}y^{(1)} - \\mu^2 \\in \\mathbb{F}_{3^{2m}}</span>  from the equation (40), one finds that</p>

    <p class="text-gray-300"><span class="math">$A_i = \\lambda - \\mu \\rho - \\rho^2. \\tag{42}</span>$</p>

    <p class="text-gray-300">Therefore the modified algorithm is given as follows.</p>

    <p class="text-gray-300"><strong>Table 4.</strong> A modified Duursma-Lee algorithm without cube root operations</p>

    <pre><code class="language-text">Input: P = (\\alpha, \\beta), Q = (x, y)

Output: C = f_P(\\phi(Q))

C \\leftarrow 1

x \\leftarrow x^3, \\quad y \\leftarrow y^3, \\quad d \\leftarrow mb

for (i = 1 \\text{ to } m \\text{ ; } i + +)

\\alpha \\leftarrow \\alpha^9, \\quad \\beta \\leftarrow \\beta^9

\\mu = \\alpha + x + d, \\quad \\lambda = \\sigma \\beta y - \\mu^2

C \\leftarrow C^3 \\cdot (\\lambda - \\mu \\rho - \\rho^2)

y \\leftarrow -y, \\quad d \\leftarrow d - b
\\nend for
</code></pre>

    <p class="text-gray-300">In each step of the above algorithm, the number of necessary multiplications in  <span class="math">\\mathbb{F}_{3^m}</span>  is same to that of the algorithm in Table 3. Since the cube operation  <span class="math">C \\leftarrow C^3</span>  with respect to the basis  <span class="math">\\{1, \\rho, \\rho^2\\}</span>  over  <span class="math">\\mathbb{F}_{3^{2m}}</span>  costs 6 cube operations in  <span class="math">\\mathbb{F}_{3^m}</span>  and since the operations  <span class="math">\\alpha \\leftarrow \\alpha^9</span> ,  <span class="math">\\beta \\leftarrow \\beta^9</span>  cost 4 cube operations in  <span class="math">\\mathbb{F}_{3^m}</span> , the total number of necessary Frobenius operations in each step of the above algorithm is 10. Note that the Duursma-Lee algorithm in Table 3 needs 2 Frobenius operations plus 2 inverse Frobenius operations. Therefore our modified algorithm uses 8 Frobenius operations instead of using 2 inverse Frobenius operations. In a polynomial basis, it is safe to believe [8] that the cost of 4 cube operations is cheaper than the cost of one cube root operation.</p>

    <p class="text-gray-300">It should be mentioned that our technique of avoiding inverse Frobenius operations can also be applied to the refined algorithm of Granger et al. [9], where the for-loop in Table 3 is unrolled so that it has  <span class="math">\\frac{m-1}{2}</span>  steps and a multiplication of two  <span class="math">\\lambda - \\mu \\rho - \\rho^2</span>  is executed before being multiplied to the partial product C. The only thing we have to do is to redefine  <span class="math">A_i</span>  in the equation (39) appropriately so that the multiplication  <span class="math">A_i A_{i+1}</span>  is performed before being multiplied to C.</p>

    <p class="text-gray-300">Among the three isomorphism classes of supersingular elliptic curves over a binary field  <span class="math">\\mathbb{F}_{2^m}</span>  with m = odd,  <span class="math">E_b: Y^2 + Y = X^3 + X + b</span> , b = 0,1 and  <span class="math">E: Y^2 + Y = X^3</span> , the curve  <span class="math">Y^2 + Y = X^3</span>  has the embedding degree k = 2. Though the curve  <span class="math">Y^2 + Y = X^3</span>  is not so interesting in terms of the bandwidth, i.e. the imbedding degree k = 2, we will discuss a method of efficient Tate pairing computation with a closed formula. Note that a similar formula (like the cases of characteristic two and three) is not available for a prime field  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">p \\neq 2,3</span>  and one has the same embedding degree k = 2 for this prime field case. Although the curve  <span class="math">E: Y^2 + Y = X^3</span>  is not discussed by Barreto et al. in the BKLS algorithm [1], we will show that a similar technique about the irrelevant denominators is also applicable for this curve. It seems that this technique is applicable to quite a many class of elliptic curves with nontrivial automorphisms over low characteristic finite fields.</p>

    <p class="text-gray-300">Let  <span class="math">P=(\\alpha,\\beta)</span>  be a point on the curve  <span class="math">E:Y^2+Y=X^3</span> . Then one has  <span class="math">-P=(\\alpha,\\beta+1)</span>  and  <span class="math">2P=(\\alpha^4,\\beta^4+1)=-\\varphi^2(P)</span> . Thus we get</p>

    <p class="text-gray-300"><span class="math">$2^{2}P = (\\alpha^{2^{4}}, \\beta^{2^{4}}) = \\varphi^{4}(P),</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\varphi^4 - 4 = 0</span> , i.e.  <span class="math">h(X) = X^2 + 2</span>  divides  <span class="math">X^4 - 4</span> . Using this property, it is easy to show inductively</p>

    <p class="text-gray-300"><span class="math">$2^{i-1}P = (\\alpha^{2^{2i-2}}, \\beta^{2^{2i-2}} + i - 1) = (\\alpha^{(2i-2)}, \\beta^{(2i-2)} + i - 1). \\tag{43}</span>$</p>

    <p class="text-gray-300">For an effective Tate pairing computation, we will use the following distortion map (nontrivial automorphism) for E,</p>

    <p class="text-gray-300"><span class="math">$\\phi: E \\longrightarrow E</span>$
, with  <span class="math">\\phi(x,y) = (x+1, y+x+t)</span> , (44)</p>

    <p class="text-gray-300">where  <span class="math">t \\in \\mathbb{F}_{2^2}</span>  with  <span class="math">t^2 + t + 1 = 0</span> . It is clear that the proposed map  <span class="math">\\phi</span>  is an automorphism since the following equality can be easily checked,</p>

    <p class="text-gray-300"><span class="math">$(y+x+t)^{2} + (y+x+t) = (x+1)^{3}.</span>$
(45)</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong> With the above distortion map, the line X - u intersecting R = (u, v) and -R = (u, v + 1) with  <span class="math">R \\in E(\\mathbb{F}_{2^m})</span>  can be omitted without altering the pairing value.</p>

    <p class="text-gray-300">Proof. The line X-u evaluated at the point  <span class="math">\\phi(Q)</span>  with  <span class="math">Q=(x,y)\\in E(\\mathbb{F}_{2^m})</span>  is x+1-u. By applying the final powering by  <span class="math">\\frac{2^{2m}-1}{l}=(2^m-1)\\frac{(2^m+1)}{l}</span> , one has  <span class="math">(x+1-u)^{\\frac{2^{2m}-1}{l}}=1</span>  because  <span class="math">x,u\\in\\mathbb{F}_{2^m}</span>  and l divides  <span class="math">|E(\\mathbb{F}_{2^m})|=2^m+1</span> .</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> Let  <span class="math">P = (\\alpha, \\beta), Q = (x, y)</span>  be points in  <span class="math">E(\\mathbb{F}_{2^m})</span>  with  <span class="math">E: Y^2 + Y = X^3</span> . Then one has the value of  <span class="math">\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}} = \\{g_{2^{i-1}P}(x+1, y+x+t)\\}^{2^{m-i}}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(x+1,y+x+t)\\}^{2^{m-i}} = \\alpha^{(i-1)}x^{(-i)} + (\\alpha+\\beta)^{(i-1)} + (x+y)^{(-i)} + t.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The tangent line at  <span class="math">P = (\\alpha, \\beta)</span>  on the curve  <span class="math">E : Y^2 + Y = X^3</span>  is  <span class="math">Y = \\alpha^2 X + \\beta^2</span> . Thus we have  <span class="math">g_P(x, y) = \\alpha^2 x + \\beta^2 - y</span>  and using the equation (43), we get</p>

    <p class="text-gray-300"><span class="math">$g_{2^{i-1}P}(x+1,y+x+t) = \\alpha^{(2i-1)}(x+1) + \\beta^{(2i-1)} + i - 1 - (y+x+t). \\tag{46}</span>$</p>

    <p class="text-gray-300">Taking  <span class="math">2^{m-i}</span> -th power of the both sides of the above equality,</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(x+1,y+x+t)\\}^{2^{m-i}} = \\alpha^{(i-1)}(x^{(-i)}+1) + \\beta^{(i-1)} + i - 1 - (y^{(-i)} + x^{(-i)} + t^{(m-i)}). \\tag{47}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">t^{(1)} = t^2 = t + 1</span> , one has  <span class="math">t^{(2)} = t^4 = t</span> ,  <span class="math">t^{(3)} = t + 1</span> ,  <span class="math">t^{(4)} = t</span> ,  <span class="math">\\cdots</span> . That is,</p>

    <p class="text-gray-300"><span class="math">$t^{(j)} = t + j, (48)</span>$</p>

    <p class="text-gray-300">for any j because we are in the field with characteristic two. Thus we have  <span class="math">t^{(m-i)} = t + m - i</span>  in the equation (47) and therefore</p>

    <p class="text-gray-300"><span class="math">$\\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}} = \\alpha^{(i-1)}(x^{(-i)}+1) + \\beta^{(i-1)}+i-1 - (y^{(-i)}+x^{(-i)}+t+m-i)</span>$
<span class="math">$= \\alpha^{(i-1)}x^{(-i)} + (\\alpha+\\beta)^{(i-1)} + (x+y)^{(-i)} + t.</span>$</p>

    <p class="text-gray-300"><strong>Theorem 7.</strong> One has the Tate pairing  <span class="math">\\tau_l(P,Q) = f_P(\\phi(Q))^{2^m-1}</span>  where</p>

    <p class="text-gray-300"><span class="math">$f_P(\\phi(Q)) = \\prod_{i=1}^m \\{g_{2^{i-1}P}(\\phi(Q))\\}^{2^{m-i}} = \\prod_{i=1}^m \\{\\alpha^{(i-1)}x^{(-i)} + (\\alpha+\\beta)^{(i-1)} + (x+y)^{(-i)} + t\\},</span>$</p>

    <p class="text-gray-300">and  <span class="math">f_P</span>  is a rational function satisfying  <span class="math">(2^m + 1)\\{(P) - (O)\\}</span> .</p>

    <p class="text-gray-300">One may derive the same algorithms as in Table 1 and 2 for this case also but we omit them here since the method is pretty straightforward.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">8. Conclusions</h4>

    <p class="text-gray-300">In this paper we showed that an efficient closed formula can be derived for the Tate pairing computation for supersingular elliptic curves over a binary field  <span class="math">\\mathbb{F}_{2^m}</span>  of odd dimension. There are exactly three isomorphism classes of supersingular elliptic curves over  <span class="math">\\mathbb{F}_{2^m}</span>  with m odd and our method is applicable to all these curves. Each step of our algorithm requires two inverse Frobenius operations like the characteristic three case of Duursma and Lee. To overcome the computational complexity of the inverse Frobenius operation in a polynomial basis, we modified our algorithm and the algorithm of Duursma and Lee, and presented another closed formula which does not need any inverse Frobenius operation, which is especially useful for polynomial basis arithmetic.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">References</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] P. Barreto, H. Kim, B. Lynn, and M. Scott, &quot;Efficient algorithms for pairing based cryptosystems,&quot; Crypto 2002, Lecture Notes in Computer Science, vol. 2442, pp. 354‚Äì368, 2002.</p></li>
      <li><p class="text-gray-300">[2] M. Scott and P. Barreto, &quot;Compressed pairings,&quot; Crypto 2004, Lecture Notes in Computer Science, to appear, 2004.</p></li>
      <li><p class="text-gray-300">[3] I. Duursma and H. Lee, &quot;Tate pairing implementation for hyperelliptic curves  <span class="math">y^2 = x^p x + d</span> ,&quot; Asiacrypt 2003, Lecture Notes in Computer Science, vol. 2894, pp. 111‚Äì123, 2003.</p></li>
      <li><p class="text-gray-300">[4] S. Galbraith, &quot;Supersingular curves in cryptography,&quot; Asiacrypt 2001, Lecture Notes in Computer Science, vol. 2248, pp. 495‚Äì513, 2001.</p></li>
      <li><p class="text-gray-300">[5] S. Galbraith, K. Harrison, and D. Soldera, &quot;Implementing the Tate pairing,&quot; ANTS 2002, Lecture Notes in Computer Science, vol. 2369, pp. 324‚Äì337, 2002.</p></li>
      <li><p class="text-gray-300">[6] F. Hess, &quot;A Note on the Tate pairing of curves over finite fields,&quot; <em>Arch. Math.</em> vol. 82, pp. 28‚Äì32, 2004.</p></li>
      <li><p class="text-gray-300">[7] F. Hess, &quot;Efficient identity based signature schemes based on pairings,&quot; SAC 2002, Lecture Notes in Computer Science, vol. 2595, 310-324, 2003.</p></li>
      <li><p class="text-gray-300">[8] R. Granger, D. Page, and M. Stam, &quot;Hardware and software normal basis arithmetic for pairing based cryptography in characteristic three,&quot; preprint, available at http://eprint.iacr. org/2004/157.pdf, 2004.</p></li>
      <li><p class="text-gray-300">[9] R. Granger, D. Page, and M. Stam, &quot;On small characteristic algebraic tori in pairing based cryptography,&quot; preprint available at http://eprint.iacr.org/2004/132.pdf, 2004.</p></li>
      <li><p class="text-gray-300">[10] D. Boneh and M. Franklin, &quot;Identity based encryption from the Weil pairing,&quot; <em>Crypto</em> 2001, <em>Lecture Notes in Computer Science</em>, vol. 2139, pp. 213‚Äì229, 2001.</p></li>
      <li><p class="text-gray-300">[11] D. Boneh, B. Lynn, and H. Shacham, &quot;Short signatures from the Weil pairing,&quot; Asiacrypt 2001, Lecture Notes in Computer Science, vol. 2248, pp. 514‚Äì532, 2002.</p></li>
      <li><p class="text-gray-300">[12] A. Joux, &quot;A one round protocol for tripartite Diffie-Hellman,&quot; ANTS 2000, Lecture Notes in Computer Science, vol. 1838, pp. 385‚Äì394, 2000.</p></li>
      <li><p class="text-gray-300">[13] K. Eisentr¬®ager, K. Lauter, and P.L. Montgomery, &quot;Improved Weil and Tate pairing for elliptic and hyperelliptic curves,&quot; preprint, 2004.</p></li>
      <li><p class="text-gray-300">[14] J.H. Silverman, The Arithmetic of Elliptic Curves, Springer-Verlag, 1985.</p></li>
      <li><p class="text-gray-300">[15] A.J. Menezes, Elliptic Curve Public Key Cryptosystems, Kluwer Academic Publisher, 1993.</p></li>
      <li><p class="text-gray-300">[16] A.J. Menezes, T. Okamoto, and S.A. Vanstone, &quot;Reducing elliptic curve logarithms to logarithms in a finite field,&quot; IEEE Trans. Information Theory, vol. 39, pp. 1639‚Äì1646, 1993.</p></li>
      <li><p class="text-gray-300">[17] G. Frey and H. Ruc¬® k, &quot;A remark concerning m-divisibility and the discrete logarithm in the divisor class groups of curves,&quot; Math. Comp., vol. 62, pp. 865‚Äì874, 1994.</p></li>
      <li><p class="text-gray-300">[18] E.R. Verheul, &quot;Evidence that XTR is more secure than supersingular elliptic curve cryptosystems,&quot; Eurocrypt 2001, Lecture Notes in Computer Science, vol. 2045, pp. 195‚Äì210, 2001.</p></li>
      <li><p class="text-gray-300">[19] V. Miller, &quot;Short programs for functions on curves,&quot; unpublished manuscript, 1986.</p></li>
      <li><p class="text-gray-300">[20] D. Hankerson, J.L. Hernandez, and A.J. Menezes, &quot;Software implementation of elliptic curve cryptography over binary fields,&quot; CHES 2000, Lecture Notes in Computer Science, vol. 1965, pp. 1‚Äì24 , 2000.</p></li>
      <li><p class="text-gray-300">[21] N. Koblitz, A. Menezes, and S. Vanstone, &quot;The state of elliptic curve cryptography,&quot; Design, Codes and Cryptography, vol. 19, pp. 173‚Äì193, 2000.</p></li>
      <li><p class="text-gray-300">[22] P. Gaudry, F. Hess, and N.P. Smart, &quot;Constructive and destructive facets of Weil descent on elliptic curves,&quot; J. of Cryptology, vol. 15, pp. 19‚Äì46, 2002.</p></li>
      <li><p class="text-gray-300">[23] A. Miyaji, M. Nakabayashi, and S. Takano, &quot;New explicit conditions of elliptic curve trace for FR-reduction,&quot; IEICE Trans. Fundamentals, vol. E84 A, pp. 1‚Äì10, 2001.</p></li>
      <li><p class="text-gray-300">[24] R. Sakai, K. Ohgishi, and M. Kasahara, &quot;Cryptosystems based on pairing,&quot; SICS 2000, Symposium on Cryptography and Information Security, pp. 26‚Äì28, 2000.</p></li>
      <li><p class="text-gray-300">[25] N.P. Smart, &quot;An identity based authentication key agreement protocol based on pairing,&quot; Electronics Letters, vol. 38, pp. 630‚Äì632, 2002.</p></li>
      <li><p class="text-gray-300">[26] S. Gao, J. von zur Gathen, and D. Panario, &quot;Gauss periods and fast exponentiation in finite fields,&quot; Latin 1995, Lecture Notes in Computer Science, vol. 911, pp. 311‚Äì322, 1995.</p></li>
      <li><p class="text-gray-300">[27] K. Rubin and A. Silverberg &quot;Torus based cryptography,&quot; Crypto 2003, Lecture Notes in Computer Science, vol. 2729, pp. 349‚Äì365, 2003.</p></li>
    </ul>

`;
---

<BaseLayout title="6. Algorithms without inverse Frobenius operations for polyn... (2004/303)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/303
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="6-algorithms-without-inverse-frobenius-operations-for-2004" />
  </article>
</BaseLayout>
