---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/573';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'HyperNova: Recursive arguments for customizable constraint systems';
const AUTHORS_HTML = 'Abhiram Kothapalli, Srinath Setty';

const CONTENT = `    <p class="text-gray-300">Abhiram Kothapalli Srinath Setty Carnegie Mellon University Microsoft Research</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We introduce <em>HyperNova</em>, a new recursive argument for proving incremental computations whose steps are expressed with CCS <em>(Setty et al. ePrint 2023/552)</em>, a customizable constraint system that simultaneously generalizes Plonkish, R1CS, and AIR without overheads. HyperNova makes four contributions, each resolving a major problem in the area of recursive arguments.</p>

    <p class="text-gray-300">First, it provides a folding scheme for CCS where the prover’s cryptographic cost is a <em>single</em> multi-scalar multiplication (MSM) of size equal to the number of variables in the constraint system, which is optimal when using an MSM-based commitment scheme. The folding scheme can fold multiple instances at once, making it easier to build generalizations of IVC such as PCD. Second, when proving program executions on stateful machines (e.g., EVM, RISC-V), the cost of proving a step of a program is proportional only to the size of the circuit representing the instruction invoked by the program step (“a la carte” cost profile). Third, we show how to achieve zero-knowledge for “free” and <em>without</em> the need to employ <em>zero-knowledge</em> SNARKs: we use a folding scheme to “randomize” IVC proofs. This highlights a new application of folding schemes. Fourth, we show how to efficiently instantiate HyperNova over a cycle of elliptic curves. For this, we provide a general technique, which we refer to as CycleFold, that applies to all modern folding-scheme-based recursive arguments.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Incrementally verifiable computation (IVC) <em>[66]</em> is a powerful cryptographic primitive that allows a prover to produce a proof of the correct execution of a “long running” computation in an incremental fashion. For example, it enables the following workflow: The prover takes as input a proof <span class="math">\\pi_{i}</span> proving the the first <span class="math">i</span> steps of its computation and then update it to produce a proof <span class="math">\\pi_{i+1}</span> proving the correct execution of the first <span class="math">i+1</span> steps. Crucially, the prover’s work to update the proof does not depend on the number of steps executed thus far, and the verifier’s work to verify a proof does not grow with the number of steps executed thus far. IVC has received recent, renewed interest as it enables a wide variety of applications in decentralized settings including verifiable delay functions <em>[9, 70]</em>, succinct blockchains <em>[44]</em>, rollups <em>[71, 45, 53]</em>, verifiable state machines <em>[58]</em>, and proofs of machine executions (e.g., EVM, RISC-V)</p>

    <p class="text-gray-300">This is an extended version of a paper from CRYPTO 2024 [42]. Compared to an initial version, this version of the paper incorporates material from prior preprints [40,41]. Additionally, this version provides an approach to achieve zero-knowledge in folding-scheme-based recursive arguments without needing to use zkSNARKs.</p>

    <p class="text-gray-300">Early realizations of IVC <em>[66, 4]</em> rely on succinct non-interactive arguments of knowledge (SNARKs) <em>[37, 50, 32, 6]</em>. At step <span class="math">i</span>, the prover produces a SNARK proving that it has correctly applied a step of the specified computation using the output of step <span class="math">i-1</span> and that the SNARK verifier <em>represented as a circuit</em> has accepted a SNARK from step <span class="math">i-1</span> <em>[7, 4]</em>. These works require representing the SNARK verifier as a circuit. To reduce the size of the SNARK verifier when encoded as a circuit, prior work <em>[4]</em> uses a <em>two-cycle of elliptic curves</em>.</p>

    <p class="text-gray-300">A flurry of works <em>[13, 19, 10, 18, 43, 40]</em> reduce reliance on SNARKs to construct IVC, culminating in <em>folding schemes</em> <em>[43]</em>, a primitive that simply reduces the task of checking two NP instances with the same “structure” (e.g., circuit description) into the task of checking a single NP instance. This primitive is sufficient to construct IVC, and is simpler and far more efficient than a SNARK.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 An overview of the prior state-of-the-art: Nova</h3>

    <p class="text-gray-300">We first focus on prior work at the time this paper was written. We discuss additional related work in Appendix C. Following a preprint of this work, there are several follow-up works. Section 1.4 describes subsequent work.</p>

    <p class="text-gray-300">Nova’s computational model proves incremental computations where each step executes a non-deterministic circuit. To prove such computations, Nova uses a folding scheme for an NP-complete language to (recursively) transform the task of proving <span class="math">N</span> steps of a computation into the task of proving a single step of the computation. It then applies a general-purpose zkSNARK (e.g., Spartan <em>[57]</em>) to prove that single step, obtaining zero-knowledge and additional succinctness.</p>

    <p class="text-gray-300">Compared to employing a general-purpose zkSNARK, built from from polynomial IOPs and polynomial commitment schemes (e.g., Spartan <em>[57]</em>, Plonk <em>[30]</em>, Marlin <em>[21]</em>, HyperPlonk <em>[20]</em>), to prove the entire incremental computation, Nova’s approach is substantially cheaper (as long as each step is sufficiently large, to offset recursion overheads). Specifically, at each incremental step, Nova’s prover incurs only <em>two</em> MSMs of size proportional to the size of the circuit proven. Whereas, general-purpose zkSNARKs need many more MSMs. For example, Marlin <em>[21, Figure 1]</em> reports 22 MSMs and many more FFTs of size proportional to the circuit size. In addition, by design, Nova’s proof generation is incremental (i.e., it produces a proof for each step and then uses its recursion capabilities to produce a single proof), so it can be more easily distributed and parallelized than with a non-recursive zkSNARK where one must unroll program executions into monolithic circuits. The latter rules out applications where one cannot statically unroll program executions (e.g., VDF) or makes it inconvenient (e.g., program executions on machines such as EVM or RISC-V). As presented, Nova does not immediately support parallel proof generation, but there exists a generic compiler <em>[7]</em> to transform constructions such as Nova to support parallel proving.</p>

    <p class="text-gray-300">1.2 Open problems addressed by this work</p>

    <p class="text-gray-300">Our work addresses several open problems in the prior state-of-the-art. We first discuss these problems and provide sufficient context about each of these.</p>

    <p class="text-gray-300">(1) The need to fold customizable, high-degree constraint systems. In Nova, each step of an incremental computation is expressed with R1CS, an NP-complete problem that generalizes arithmetic circuit satisfiability <em>[31, 59, 3]</em>. In practice, when zkSNARKs (e.g., Plonk) are applied to prove program executions, practitioners use custom constraint systems (e.g., Plonkish) that are tailored to a particular classes of applications. Specifically, Plonkish constraints are multivariate high-degree polynomials. Whereas, R1CS is restricted to checking quadratic constraints in a specific form. These customizable, high-degree constraint systems are often more compact than equivalent R1CS. As a concrete example, a single iteration of MinRoot <em>[36]</em> can be represented with <span class="math">one</span> degree-5 constraint in Plonkish <em>[74]</em>. Whereas, R1CS needs three constraints.</p>

    <p class="text-gray-300">Sangria <em>[51]</em> shows that Nova can be adapted to handle Plonkish. However, the number of cross-terms that the prover must commit to increases linearly with the degree of the constraints <span class="math">d</span>: The prover must incur <span class="math">O(n\\cdot d)</span> cryptographic operations to commit to <span class="math">O(d)</span> cross-terms, where <span class="math">n</span> is the number of constraints. As a result, in general, there are not significant benefits to employing high-degree constraints and use Sangria than use Nova with R1CS. Concretely, Sangria’s prover applied to MinRoot with degree-5 constraints requires 5 scalar multiplications (and additional field work to compute cross-terms) per MinRoot iteration whereas Nova applied to MinRoot in R1CS requires 6 scalar multiplications.</p>

    <p class="text-gray-300">A key question is whether one can build a recursive argument for Plonkish, with Nova-like performance characteristics. In particular, our goal is to prove CCS <em>[60]</em>, a customizable constraint system that simultaneously generalizes Plonkish, R1CS, and AIR without overheads (<em>[60]</em> provides context on CCS, Plonkish, and AIR). Additionally, for any solution that handles high-degree constraints, we require the prover’s cryptographic work to be independent of the degree of constraints supported. That is, the number of MSMs (or their sizes) performed by the prover must not depend on the degree of the supported constraints.</p>

    <p class="text-gray-300">(2) The need to achieve an “a la carte” cost profile for proving machine executions. A classic approach to prove machine executions (e.g., program executions on EVM) is to employ a <em>universal circuit</em> (e.g., <em>[2, 5, 55, 33, 47]</em>) that can execute any instruction supported by the machine. To prove the correct execution of programs on the corresponding machine, it suffices to recursively prove, with an IVC scheme, repeated invocations of this circuit on an input program and memory state <em>[4]</em>. Unfortunately, the cost of proving a program’s step is proportional to the size of the universal circuit (i.e., sum of sizes of circuits of all instructions supported by the machine)—even though the step invokes only one of the instructions.</p>

    <p class="text-gray-300">Given the high costs imposed by universal circuits, designers of these machines aim to employ a minimal instruction set, to keep the size of the universal circuit</p>

    <p class="text-gray-300">and thereby the cost of proving a program step minimal <em>[5, 3, 33]</em>. However, this is a not a panacea: for real applications, one needs to execute an enormous number of iterations of the minimal circuit (e.g., billions of iterations), making the prover’s work largely untenable. This also means that emulating real programs that target <em>existing</em> virtual machines with rich instruction sets (e.g., EVM, RISC-V, Wasm) via a machine with a minimal instruction set would incur enormous costs.</p>

    <p class="text-gray-300">An open question is whether one can achieve an <em>“a la carte” cost profile</em>, where the cost of proving a step of a program execution is proportional only to the size of the circuit representing the instruction invoked by the program step and independent of the circuit sizes of the uninvoked instructions.</p>

    <p class="text-gray-300">(3) The need for providing zero-knowledge without needing zkSNARKs. Nova <em>[43]</em> shows how to efficiently achieve zero-knowledge for its IVC proofs by producing a zkSNARK proving the knowledge of valid IVC proofs. The zkSNARK scheme that is natively compatible with Nova is Spartan <em>[57]</em>, which internally uses the sum-check protocol <em>[46]</em>. The most efficient way to achieve zero-knowledge in Spartan is to use the Cramer-Damgard transformation <em>[25, 69]</em>, where sum-check messages are committed with homomorphic commitments (e.g., Pedersen) and the sum-check verifier’s checks are proven in zero-knowledge using Schnorr-type proofs. This means that the Spartan verifier must perform public key operations (e.g., group scalar multiplications), which are far too expensive especially in blockchain settings where the verifier is deployed on-chain.</p>

    <p class="text-gray-300">An open question is whether one can leverage folding schemes to “blind” the IVC proof such that one can use a non-zk Spartan, where the verifier verifies the sum-check messages in plaintext (which are orders of magnitude more efficient).</p>

    <p class="text-gray-300">(4) The need for an efficient instantiation over a cycle of elliptic curves. Folding schemes leverage additively homomorphic commitments, which are typically instantiated with elliptic curve groups. To realize IVC, the folding scheme’s verifier must be represented as a circuit. The best known approach for this is the blueprint of <em>[4]</em>, which leverages a cycle of elliptic curves. Nova’s implementation <em>[1]</em> adapts BCTV’s approach <em>[4]</em> to the context of folding-scheme-based recursive arguments and was recently proven secure <em>[52]</em>.</p>

    <p class="text-gray-300">Unfortunately, Nova’s approach, like in <em>[4]</em>, still requires representing a verifier (which happens to be the the non-interactive folding scheme verifier) as a circuit on <em>both</em> curves in the cycle of curves. For Nova <em>[43]</em>, which is the only <em>fully</em> implemented folding-scheme-based approach to date, the circuit defined over the second curve in the cycle is <span class="math">\\approx</span>10,000 multiplication gates (and more than 100,000 non-zero entries in R1CS matrices).</p>

    <p class="text-gray-300">In practice, one often wants to use a “half”-pairing cycle <span class="math">E_{1}/E_{2}</span> (e.g., BN254 and Grumpkin, where only BN254 is pairing-friendly). The BN254/Grumpkin cycle is as efficient as non-pairing-friendly cycle of curves (e.g., Pasta) and also compatible with Ethereum for proof verification. In this setting, the part of the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IVC proof defined over <span class="math">E_{1}</span> can be compressed easily into a succinct proof with Spartan <em>[57]</em> using KZG-based commitment scheme <em>[72, 12]</em>; the compressed proof can be verified with a logarithmic number of group scalar multiplications and two pairings. However, for <span class="math">E_{2}</span>, the corresponding IVC proof must be verified with a circuit <span class="math">\\mathcal{C}</span> defined over <span class="math">E_{1}</span> and then proven with a SNARK defined over <span class="math">E_{1}</span>. Unfortunately, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>70\\cdot 10^{6}$ gates (far too expensive to prove).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">An open question is whether one can substantially reduce the size of the circuit defined over the second curve in the cycle, which in turn reduces the size of <span class="math">\\mathcal{C}</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.3 A technical overview of results in this work</h3>

    <p class="text-gray-300">This subsection provides an overview of HyperNova, which resolves all the four open problems listed in the prior section.</p>

    <p class="text-gray-300">(1) Multi-folding schemes and a multi-folding scheme for CCS. As noted earlier, HyperNova’s target is to prove incremental computations where each step of the incremental computation is expressed with CCS <em>[60]</em>. However, if we naively build a folding scheme for CCS, perhaps for a “relaxed” variant of CCS (analogous to relaxed R1CS in Nova <em>[43]</em>), it will have the efficiency issues noted above for Sangria. To avoid those issues, HyperNova takes a different approach that involves leveraging the power of the sum-check protocol <em>[46]</em>.</p>

    <p class="text-gray-300">To construct HyperNova, we introduce a generalization of folding schemes, and we refer to it as <em>multi-folding schemes</em>. Recall that a folding scheme for a relation <span class="math">\\mathcal{R}</span> is a protocol between a <em>prover</em> and <em>verifier</em> in which the prover and the verifier reduce the task of checking two instances in <span class="math">\\mathcal{R}</span> with the same structure <span class="math">\\mathsf{s}</span> into the task of checking a single instance in <span class="math">\\mathcal{R}</span> with structure <span class="math">\\mathsf{s}</span>. A multi-folding scheme is defined with respect to a pair of relations <span class="math">(\\mathcal{R}_{1},\\mathcal{R}_{2})</span> and constants <span class="math">(\\mu,\\nu)</span>, and it is an interactive protocol in which the prover and the verifier reduce the task of checking <span class="math">\\mu</span> instances in <span class="math">\\mathcal{R}_{1}</span> with structure <span class="math">\\mathsf{s}_{1}</span> and <span class="math">\\nu</span> instances in <span class="math">\\mathcal{R}_{2}</span> with structure <span class="math">\\mathsf{s}_{2}</span> into the task of checking a single instance in <span class="math">\\mathcal{R}_{1}</span> with structure <span class="math">\\mathsf{s}_{1}</span>—as long as <span class="math">(\\mathsf{s}_{1},\\mathsf{s}_{2})</span> satisfy a pre-defined predicate (e.g., that the two structures are equal). Below, we clarify how this generalization unlocks additional power for constructing IVC.</p>

    <p class="text-gray-300">We also construct a multi-folding scheme for CCS. Our starting point is the observation that Spartan <em>[57]</em> (more specifically its generalization to handle CCS called SuperSpartan <em>[60]</em>) transforms the task of checking the satisfiability of a CCS instance into the task of checking if a multivariate polynomial <span class="math">g</span> of total degree <span class="math">d+1</span>, where <span class="math">d</span> is the degree of the CCS constraints, sums to zero over a suitable Boolean hypercube. Spartan then invokes the sum-check protocol <em>[46]</em> to prove that claim about <span class="math">g</span>. At the end of the sum-check invocation, the prover and the verifier are left with checking certain claims. Fortunately, these claims concern a restricted form of CCS (we formalize this and refer to it as *linearized</p>

    <p class="text-gray-300">CCS). Note that Spartan proves those claims about the restricted form of CCS with an additional invocation of the sum-check protocol, followed by evaluations proofs of committed sparse multilinear polynomials.</p>

    <p class="text-gray-300">While an “early stopping” version of Spartan (the one with a single invocation of the sum-check protocol) provides a reduction of knowledge <em>[39]</em> from CCS to linearized CCS, it is not a folding (or a multi-folding) scheme. So, our second idea is to redefine the polynomial <span class="math">g</span> to additionally include claims from a running linearized CCS instance using a random challenge from the verifier. This is possible as long as the running instance and the CCS instance that is being folded share a <em>compatible</em> structure (e.g., the same CCS matrices).</p>

    <p class="text-gray-300">The following theorem summarizes our result about the multi-folding scheme. Notably, our multi-folding scheme avoids commitments to cross-terms <em>altogether</em>.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (A multi-folding scheme for CCS)</h6>

    <p class="text-gray-300">Construction 1 is a public-coin, multi-folding scheme that reduces the task of checking an arbitrary number of CCS instances and linearized CCS instances with the same structure into the task of checking a single linearized CCS instance with the same structure. For a single CCS instance with <span class="math">m</span> constraints of degree <span class="math">d</span> and <span class="math">q</span> monomials, <span class="math">n</span> witness variables, <span class="math">t</span> CCS matrices, and <span class="math">N</span> non-zero entries in CCS matrices, and a single linearized CCS instance, the efficiency characteristics are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover time is <span class="math">O(N+t\\cdot m+q\\cdot m\\cdot d\\cdot\\log^{2}d)</span> finite field operations and O(1) group operations;</li>

      <li>The verifier time is <span class="math">O(d\\cdot\\log m)</span> finite field operations and O(1) group operations; and</li>

      <li>The communication complexity is <span class="math">O(d\\cdot\\log m)</span> finite field elements.</li>

    </ul>

    <p class="text-gray-300">Since the multi-folding scheme is public coin, we make it non-interactive in the random oracle model using the Fiat-Shamir transform <em>[28]</em> and heuristically instantiate it in the plain model using a concrete cryptographic hash function.</p>

    <p class="text-gray-300">(2) Achieving “a la carte” costs with non-uniform IVC. We first introduce a generalization of IVC <em>[66]</em> to formally capture an “a la carte” cost profile. Consider a collection of <span class="math">\\ell+1</span> non-deterministic, polynomial-time computable functions <span class="math">((F_{1},\\ldots,F_{\\ell}),\\varphi)</span>, where <span class="math">\\ell\\geq 1</span>. Suppose that each function <span class="math">F_{j}</span> (<span class="math">1\\leq j\\leq\\ell</span>) takes <span class="math">s</span> inputs and produces <span class="math">s</span> outputs, where <span class="math">s&gt;0</span>; <span class="math">F_{j}</span> can additionally take an arbitrary non-deterministic input. Furthermore, <span class="math">\\varphi</span> is a function that takes <span class="math">s</span> inputs and an arbitrary non-deterministic input, and produces an element of <span class="math">\\mathbb{Z}_{\\ell+1}^{\\star}</span> (i.e., the set <span class="math">\\{1,\\ldots,\\ell\\}</span>).</p>

    <p class="text-gray-300">A non-uniform IVC (NIVC) scheme enables a prover to incrementally prove that it has performed an <span class="math">n</span>-step computation with an initial input <span class="math">z_{0}</span> to produce an output <span class="math">z_{n}</span>. In particular, at step <span class="math">i</span>, the prover proves that it has applied <span class="math">F_{j}</span> on input <span class="math">(z_{i-1},\\omega_{i-1})</span> to produce an output <span class="math">z_{i}</span>, where <span class="math">z_{i-1}</span> is output of step <span class="math">i-1</span>, <span class="math">\\omega_{i-1}</span> is a (potentially secret) non-deterministic input from the prover for step <span class="math">i</span>, and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">j=\\varphi(z_{i-1},\\omega_{i-1})</span>. That is, <span class="math">\\varphi</span> selects one of the possible <span class="math">\\ell</span> functions to apply at step <span class="math">i</span> using inputs to step <span class="math">i</span>. A bit more concisely, for a specified <span class="math">((F_{1},\\ldots,F_{\\ell}),\\varphi)</span> and <span class="math">(n,z_{0},z_{n})</span>, the prover proves the knowledge of a set of non-deterministic values <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> and <span class="math">(z_{1},\\ldots,z_{n-1})</span> such that for all <span class="math">i\\in\\{0,\\ldots,n-1\\}</span>, we have that <span class="math">z_{i+1}=F_{\\varphi(z_{i},\\omega_{i})}(z_{i},\\omega_{i})</span>. Crucially, the prover’s work at step <span class="math">i</span> is proportional only to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>j=\\varphi(z_{i},\\omega_{i})<span class="math">, rather than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ldots+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We then provide a generic compiler to construct a non-uniform IVC scheme from non-interactive multi-folding schemes such as the multi-folding scheme for CCS discussed above. The compiler requires the multi-folding scheme to satisfy certain requirements, which we formalize as <em>NIVC-compatibility</em>.</p>

    <p class="text-gray-300">In more detail, suppose that the prover is provided with an NIVC proof <span class="math">\\pi_{i}</span> of <span class="math">i</span> steps, which consists of a “fresh” instance <span class="math">\\mathsf{u}_{i}</span> claiming the correct execution of step <span class="math">i</span>, a collection of “running” instances (one for each function/instruction supported in NIVC) <span class="math">\\mathsf{U}_{i}</span> claiming the correct execution of all prior <span class="math">i-1</span> steps, and the corresponding witnesses <span class="math">\\mathsf{w}_{i}</span> and <span class="math">\\mathsf{W}_{i}</span>. That is, <span class="math">\\pi_{i}=(\\mathsf{U}_{i},\\mathsf{u}_{i},\\mathsf{W}_{i},\\mathsf{w}_{i})</span>.</p>

    <p class="text-gray-300">Then, the prover runs an augmented function, which, in addition to running a step of the incremental computation, runs a <em>verifier circuit</em>. The verifier circuit implements the verifier of the multi-folding scheme to fold <span class="math">\\mathsf{u}_{i}</span> into an appropriate running instance in <span class="math">\\mathsf{U}_{i}</span> to produce new running instances <span class="math">\\mathsf{U}_{i+1}</span> that claims the correct execution of <span class="math">i</span> steps. Alongside, the prover computes the corresponding folded witnesses <span class="math">\\mathsf{W}_{i+1}</span>. The prover then produces a corresponding fresh instance <span class="math">\\mathsf{u}_{i+1}</span> (and the corresponding witness <span class="math">\\mathsf{w}_{i+1}</span>) that claims the correct execution of this augmented function; this fresh instance claims the correctness of the latest step of the incremental computation and that <span class="math">\\mathsf{U}_{i+1}</span> was produced honestly. Together, <span class="math">\\pi_{i+1}=(\\mathsf{U}_{i+1},\\mathsf{u}_{i+1},\\mathsf{W}_{i+1},\\mathsf{w}_{i+1})</span> represents an NIVC proof of <span class="math">i+1</span> steps.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">Because a multi-folding scheme folds an arbitrary number of running instances incoming instances into a single running instance, it affords a natural generalization of IVC <em>[66]</em> called proof-carrying data <em>[7]</em> using the approach of Bünz et al. <em>[18]</em>. We focus on IVC for its conceptual simplicity.</p>

    <p class="text-gray-300">(3) Achieving zero-knowledge without zkSNARKs. To achieve a zero-knowledge argument of a valid NIVC proof without relying on zkSNARKs, we provide a new approach of <em>rerandomizing</em> the NIVC proof using folding schemes. In particular, given an NIVC proof <span class="math">\\pi_{i}=(\\mathsf{U}_{i},\\mathsf{u}_{i},\\mathsf{W}_{i},\\mathsf{w}_{i})</span>, the prover first folds the fresh instance <span class="math">\\mathsf{u}_{i}</span> into an appropriate running instance. Next, the prover uses a folding scheme to fold in a random instance-witness pairs into <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span>, effectively rerandomizing them. The prover then produces a randomized proof which consists of the rerandomized instance-witness pairs and the prover’s messages in the folding scheme. A central challenge with this strategy is that the prover must prove that folding is done correctly without revealing the input random instances (and witnesses) used to randomize. To solve this, we have the prover execute the verifier’s checks for the folding scheme inside a circuit and prove in zero-knowledge once again using a randomizing folding scheme.</p>

    <p class="text-gray-300">The verifier at this point can directly check the randomized instances, or use a non-zero-knowledge SNARK if further succinctness is needed.</p>

    <p class="text-gray-300">This approach highlights a new application of folding schemes. Until now, folding schemes were used to construct IVC <em>[43]</em>. Whereas, this result shows that folding schemes can be used to randomize folding-scheme-based IVC proofs (and NP instances!) prior to proving them with a non-zero-knowledge SNARK. Thus, we introduce a simpler, more efficient methodology (as opposed to that in <em>[25]</em>) for achieving zero-knowledge.</p>

    <p class="text-gray-300">(4) Efficient instantiation over a two-cycle of elliptic curves. We provide a new approach, which we refer to as CycleFold, to efficiently instantiate HyperNova over a two-cycle of elliptic curves. In particular, we provide security proofs for this instantiation of HyperNova, but the approach and proofs generalize to other folding-scheme-based (N)IVC schemes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CycleFold’s starting point is the observation that folding-scheme-based recursive arguments can be efficiently instantiated <em>without</em> a cycle of elliptic curves—except for a few scalar multiplications in their verifiers (2 in Nova and 1 in HyperNova). Accordingly, CycleFold uses the second curve in the cycle to merely represent a <em>single</em> scalar multiplication (<span class="math">\\approx</span>1,000 multiplication gates and <span class="math">\\approx</span>4,000 non-zero entries in R1CS matrices). CycleFold then folds invocations of this tiny circuit on the first curve in the cycle. This is more than an order of magnitude improvement over the prior state-of-the-art in terms of circuit sizes on the second curve. Furthermore, to achieve full succinctness for verification of proofs on a blockchain, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is similarly more than 10</span>\\times$ smaller, and is now within the feasible range for proving with a SNARK defined over a pairing-friendly curve (§1.2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 2 (HyperNova with CycleFold).</h6>

    <p class="text-gray-300">Given the multi-folding scheme for CCS (Construction 7) instantiated with the Pedersen commitment scheme, HyperNova (Construction 2) produces an NIVC scheme such that for step functions <span class="math">F_{j}</span> for <span class="math">j\\in[\\ell]</span> that can be expressed in CCS with <span class="math">m_{j}</span> constraints of degree <span class="math">d</span> and <span class="math">q_{j}</span> monomials, <span class="math">n_{j}</span> witness variables, <span class="math">t_{j}</span> CCS matrices, and <span class="math">N_{j}</span> non-zero entries in CCS matrices, and control function <span class="math">\\varphi</span> that can be expressed in CCS with <span class="math">m</span> constraints of degree <span class="math">d</span> and <span class="math">q_{\\varphi}</span> monomials, <span class="math">n_{\\varphi}</span> witness variables, <span class="math">t_{\\varphi}</span> CCS matrices, and <span class="math">N_{\\varphi}</span> non-zero entries in the CCS matrices, the efficiency characteristics are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The NIVC prover time for each step is a single MSM of size <span class="math">O(n_{\\varphi}+n_{j})</span> and <span class="math">O((N_{\\varphi}+N_{j})+(t_{\\varphi}+t_{j})\\cdot(m_{\\varphi}+m_{j})+(q_{\\varphi}+q_{j})\\cdot(m_{\\varphi}+m_{j})\\cdot d\\cdot\\log^{2}d)</span> finite field operations</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier circuit size is $o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\cdot\\mathsf{G}+(d\\cdot\\log m_{j})\\cdot\\mathsf{F}+\\log m_{j}\\cdot\\mathsf{R}_{d}+2\\cdot\\mathsf{H}_{\\ell,t_{j}}+2\\cdot\\mathsf{M})<span class="math"> on the first curve and </span>\\mathsf{G}$ on the second curve in a cycle of elliptic curves.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{G}</span> is the number of constraints required to encode a group scalar multiplication natively (i.e., without field emulation), <span class="math">\\mathsf{H}</span> is the number of constraints required to encode a hash function, <span class="math">\\mathsf{F}</span> is the number of constraints to encode field operations, <span class="math">\\mathsf{R}</span> is the number of constraints to encode a cryptographic hash function</p>

    <p class="text-gray-300">used for randomness, and <span class="math">\\mathsf{M}</span> is the number of constraints to encode to memory read/write over a memory of size <span class="math">O(\\ell)</span>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.4 Subsequent works</h3>

    <p class="text-gray-300">We now discuss subsequent works that follow a preprint of this work.</p>

    <p class="text-gray-300">(1) PCD. Zhou et al. <em>[76]</em> show that HyperNova naturally extends to provide a generalization of IVC called PCD <em>[7, 19, 18]</em>.</p>

    <p class="text-gray-300">(2) Protostar and ProtoGalaxy. Like HyperNova, Protostar <em>[17]</em> provides a folding scheme for high-degree constraints. Protostar achieves a similar prover efficiency as HyperNova. Although Protostar does not explicitly invoke the sum-check protocol, its folding procedure performs the same amount of commitment work and finite field operations, so it implicitly invokes a sum-check-like procedure.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When folding two instances, Protostar’s verifier circuit performs <em>three</em> group scalar multiplications whereas HyperNova does only <em>one</em>. On the other hand, HyperNova performs <span class="math">O(d\\cdot\\log m)</span> hashes where <span class="math">d</span> is the degree of constraints and <span class="math">m</span> is the number of constraints folded, and Protostar performs <span class="math">O(d)</span> hashes. When using SNARK-friendly hash functions (e.g., Poseidon), the hashing cost difference between HyperNova and Protostar is concretely small.</li>

      <li>HyperNova can fold <span class="math">k&gt;2</span> instances at once, which makes it easy to realize PCD <em>[76]</em>. On the other hand, Protostar folds only <em>two</em> instances at once. Extending it fold <span class="math">k&gt;2</span> instances at once blows up the degree of the polynomial involved exponentially in <span class="math">k</span> <em>[27, §1.2]</em>. ProtoGalaxy <em>[27]</em> provides details of this, and avoids avoids this issue by essentially leveraging the sum-check protocol in a different way than in HyperNova. However, like HyperNova, it requires a logarithmic number of hashes in the verifier circuit <em>[27, Table 1]</em>.</li>

      <li>Protostar does not describe how to instantiate it on a cycle of elliptic curves nor provide a zero-knowledge layer, whereas HyperNova includes both.</li>

      <li>Protostar describes how to integrate the logUp lookup argument <em>[35]</em> into IVC. One can easily integrate HyperNova with logUp as well as more recent lookup arguments (e.g., Lasso <em>[61]</em>). Since Lasso encodes lookups as sum-check instances, HyperNova can integrate with Lasso by including the lookup sum-check instances alongside HyperNova’s sum-check instances for CCS.</li>

      <li>Protostar designs its folding scheme for special-sound protocols whereas HyperNova targets CCS. Both are equivalent as one can represent the verifier of the special-sound protocol as a CCS instance with standard transformations, for instance after making the special-sound protocol non-interactive with Fiat-Shamir transformation <em>[65, §6]</em>. Once that is done, a folding scheme for CCS can be applied. Note that Protostar too turns its special-sound protocols non-interactive protocols.</li>

    </ul>

    <p class="text-gray-300">(3) KiloNova. KiloNova <em>[75]</em> extends HyperNova to achieve non-uniform PCD (a generalization of non-uniform IVC introduced in this paper). But, there are</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">fundamental problems. Its folding verifier’s runtime is <em>linear</em> in the size of the NP instance (step-13 of Construction-1 folds CCS matrices), which makes it unsuitable for IVC, let alone PCD. In IVC, the folding-scheme verifier’s runtime is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span>F^{\\prime}<span class="math"> is an augmented circuit. This causes a well-known sizing issue because </span>F^{\\prime}$ must include the folding verifier as a sub-circuit. KiloNova does separately suggest an optimization that may (inadvertently) resolve this issue. It is neither specified nor proven. Their scheme fundamentally relies on the ability to efficiently fold commitments to sparse CCS matrices, which is necessary for IVC/PCD. Unfortunately, the “natural” fix of committing to sparse CCS matrices such that they can be folded is an open problem: existing sparse polynomial commitments do <em>not</em> provide homomorphic commitments, or require (impractical) quadratic-sized parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use <span class="math">\\lambda</span> to denote the security parameter and <span class="math">\\mathbb{F}</span> to denote a finite field (e.g., the prime field <span class="math">\\mathbb{F}_{p}</span> for a large prime <span class="math">p</span>). We use <span class="math">\\mathsf{negl}(\\lambda)</span> to denote a negligible function in <span class="math">\\lambda</span>. We write <span class="math">\\Pr[X]\\approx\\epsilon</span> to mean that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X]-\\epsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathsf{negl}(\\lambda)<span class="math">. Throughout the paper, the depicted asymptotics depend on </span>\\lambda<span class="math">, but we elide this for brevity. We write PPT to refer to probabilistic polynomial time algorithms. For relations </span>\\mathcal{R}_{1}<span class="math"> and </span>\\mathcal{R}_{2}<span class="math"> we let </span>\\mathcal{R}_{1}\\times\\mathcal{R}_{2}<span class="math"> denote a new relation such that </span>((u_{1},u_{2}),(w_{1},w_{2}))\\in\\mathcal{R}_{1}\\times\\mathcal{R}_{2}<span class="math"> if and only if </span>(u_{1},w_{1})\\in\\mathcal{R}_{1}<span class="math"> and </span>(u_{2},w_{2})\\in\\mathcal{R}_{2}<span class="math">. We write </span>\\mathbb{F}^{d}[X_{1},\\ldots,X_{n}]<span class="math"> to denote multivariate polynomials over field </span>\\mathbb{F}<span class="math"> in the variables </span>X_{1},\\ldots,X_{n}<span class="math"> with degree bound </span>d$ for each variable. We omit the superscript if there is no bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Appendix A provides additional preliminaries on multilinear polynomials, the sum-check protocol, commitment schemes, arguments of knowledge, and IVC.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Customizable constraint systems (CCS).</h5>

    <p class="text-gray-300">CCS simultaneously generalizes R1CS, Plonkish, and AIR without overheads. We first provide an arithmetized variant of the original formulation. The definitions below are characterized by a finite field <span class="math">\\mathbb{F}</span>, but we leave this implicit.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 1 (CCS <em>[60]</em>).</h6>

    <p class="text-gray-300">Consider size bounds <span class="math">m,n,N,\\ell,t,q,d\\in\\mathbb{N}</span> where <span class="math">n&gt;\\ell</span>. Let <span class="math">s=\\log m</span> and <span class="math">s^{\\prime}=\\log n</span>. We define the customizable constraint system (CCS) relation, <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span>, over structure, instance, witness tuples as follows.</p>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> structure <span class="math">\\mathsf{s}</span> consists of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a sequence of sparse multilinear polynomials in <span class="math">s+s^{\\prime}</span> variables <span class="math">\\widetilde{M}_{1},\\ldots,\\widetilde{M}_{t}</span> such that they evaluate to a non-zero value in at most <span class="math">N=\\Omega(m)</span> locations over the Boolean hypercube <span class="math">\\{0,1\\}^{s}\\times\\{0,1\\}^{s^{\\prime}}</span>;</li>

      <li>a sequence of <span class="math">q</span> multisets <span class="math">[S_{1},\\ldots,S_{q}]</span>, where an element in each multiset is from the domain <span class="math">\\{1,\\ldots,t\\}</span> and the cardinality of each multiset is at most <span class="math">d</span>.</li>

      <li>a sequence of <span class="math">q</span> constants <span class="math">[c_{1},\\ldots,c_{q}]</span>, where each constant is from <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> instance consists of public input and output vector <span class="math">\\mathsf{x}\\in\\mathbb{F}^{\\ell}</span>. An <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> witness consists of a multilinear polynomial <span class="math">\\widetilde{w}</span> in <span class="math">s^{\\prime}-1</span> variables. We have that</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{s},\\mathsf{x},\\widetilde{w})\\in\\mathcal{R}_{\\mathsf{CCS}}</span> if and only if for all <span class="math">x\\in\\{0,1\\}^{s}</span>,</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{q}c_{i}\\cdot\\left(\\prod_{j\\in S_{i}}\\left(\\sum_{y\\in\\{0,1\\}^{\\log m}}\\widetilde{M}_{j}(x,y)\\cdot\\widetilde{z}(y)\\right)\\right)=0,</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{z}</span> is an <span class="math">s^{\\prime}</span>-variate multilinear polynomial such that <span class="math">\\widetilde{z}(x)=(\\widetilde{w,1,\\mathsf{x}})(x)</span> for all <span class="math">x\\in\\{0,1\\}^{s^{\\prime}}</span>.</p>

    <p class="text-gray-300">In this work, we introduce linearized CCS, a variant of CCS that only contains the linear checks of CCS. We later show that we can fold a CCS instance into a linearized CCS instance to produce a new linearized CCS instance.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2 (Linearized CCS).</h6>

    <p class="text-gray-300">Consider size bounds <span class="math">m,n,N,\\ell,t,q,d\\in\\mathbb{N}</span> where <span class="math">n=2\\cdot(\\ell+1)</span>. Let <span class="math">s=\\log m</span> and <span class="math">s^{\\prime}=\\log n</span>. We define the linearized committed customizable constraint system (LCCS) relation, <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span>, over structure, instance, witness tuples as follows.</p>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span> structure <span class="math">\\mathsf{s}</span> consists of</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a sequence of sparse multilinear polynomials in <span class="math">s+s^{\\prime}</span> variables <span class="math">\\widetilde{M}_{1},\\ldots,\\widetilde{M}_{t}</span> such that they evaluate to a non-zero value in at most <span class="math">N=\\Omega(m)</span> locations over the Boolean hypercube <span class="math">\\{0,1\\}^{s}\\times\\{0,1\\}^{s^{\\prime}}</span>;</li>

      <li>a sequence of <span class="math">q</span> multisets <span class="math">[S_{1},\\ldots,S_{q}]</span>, where an element in each multiset is from the domain <span class="math">\\{1,\\ldots,t\\}</span> and the cardinality of each multiset is at most <span class="math">d</span>.</li>

      <li>a sequence of <span class="math">q</span> constants <span class="math">[c_{1},\\ldots,c_{q}]</span>, where each constant is from <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">An <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span> instance is a tuple <span class="math">(u,\\mathsf{x},r,v_{1},\\ldots,v_{t})\\in(\\mathbb{F},\\mathbb{F}^{\\ell},\\mathbb{F},\\mathbb{F}^{t})</span>. An <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span> witness consists of a multilinear polynomial <span class="math">\\widetilde{w}</span> in <span class="math">s^{\\prime}-1</span> variables. We have that <span class="math">(\\mathsf{s},(u,\\mathsf{x},r,v_{1},\\ldots,v_{t}),\\widetilde{w})\\in\\mathcal{R}_{\\mathsf{LCCS}}</span> if and only if for all <span class="math">i\\in[t]</span></p>

    <p class="text-gray-300"><span class="math">v_{i}=\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{i}(r,y)\\cdot\\widetilde{z}(y)</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{z}</span> is an <span class="math">s^{\\prime}</span>-variate multilinear polynomial such that <span class="math">z(x)=(\\widetilde{w,u,\\mathsf{x}})(x)</span> for all <span class="math">x\\in\\{0,1\\}^{s^{\\prime}}</span>.</p>

    <p class="text-gray-300">R1CS is an NP-complete problem implicit in QAPs <em>[31]</em>. For completeness, we formally define R1CS in Appendix A.4. Below, we recall its folding-friendly variant, relaxed R1CS <em>[43]</em>. We utilize relaxed R1CS for our zero-knowledge layer and our instantiation of HyperNova over a cycle of curves.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 3 (Relaxed R1CS).</h6>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span> and a commitment scheme Commit over vectors over <span class="math">\\mathbb{F}</span>. Consider size bounds <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where</p>

    <p class="text-gray-300"><span class="math">m &amp;gt; \\ell</span>. We define the relaxed R1CS relation, <span class="math">\\mathcal{R}_{\\mathsf{RR1CS}}</span>, over structure, instance, witness tuples as follows.</p>

    <p class="text-gray-300">A <span class="math">\\mathcal{R}_{\\mathsf{RR1CS}}</span> structure consists of matrices <span class="math">A, B, C \\in \\mathbb{F}^{m \\times m}</span> with at most <span class="math">n = \\Omega(m)</span> non-zero entries in each matrix. A <span class="math">\\mathcal{R}_{\\mathsf{RR1CS}}</span> instance is a tuple <span class="math">(u, \\mathbf{x}) \\in (\\mathbb{F}, \\mathbb{F}^{\\ell})</span>. A <span class="math">\\mathcal{R}_{\\mathsf{RR1CS}}</span> witness is a tuple <span class="math">(E, W) \\in (\\mathbb{F}^m, \\mathbb{F}^{m - \\ell - 1})</span>. We have that <span class="math">((A, B, C), (u, \\mathbf{x}), (E, W)) \\in \\mathcal{R}_{\\mathsf{RR1CS}}</span> iff for <span class="math">Z = (W, \\mathbf{x}, u)</span>, <span class="math">AZ \\circ BZ = u \\cdot CZ + E</span>.</p>

    <p class="text-gray-300">Instead of directly working with all of the above relations, we consider variants where a commitment to the witness is additionally presented in the instance. We generically refer to such relations as committed relations.</p>

    <p class="text-gray-300"><strong>Definition 4 (Committed relation).</strong> Consider a relation <span class="math">\\mathcal{R}</span> over structure, instance, witness tuples where witnesses are in some space <span class="math">W</span>. Consider a commitment scheme <span class="math">\\mathsf{com} = (\\mathsf{Gen}, \\mathsf{Commit})</span> over message space <span class="math">W</span>. We define the corresponding committed relation over public parameter, structure, instance, witness tuples characterized by <span class="math">\\mathsf{com}</span> as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}(\\mathsf{com}) = \\left\\{ \\begin{array}{l} (\\mathsf{pp}_{\\mathsf{com}}, \\mathsf{s}, (C, u), (w, r)) \\Bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf{s}, u, w) \\in \\mathcal{R}, \\\\ C = \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}}, w, r) \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We say relation <span class="math">\\mathcal{R}</span> is the underlying relation for committed relation <span class="math">\\mathcal{R}(\\mathsf{com})</span>.</p>

    <p class="text-gray-300"><strong>Definition 5 ((Linearized) Committed CCS).</strong> Consider an additively homomorphic polynomial commitment scheme, <span class="math">PC</span>, for multilinear polynomials over a finite field <span class="math">\\mathbb{F}</span>. We define the committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> as <span class="math">\\mathcal{R}_{\\mathsf{CCS}}(PC)</span> and the linearized committed CCS relation <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span> as <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}(PC)</span>.</p>

    <p class="text-gray-300"><strong>Definition 6 (Committed relaxed R1CS).</strong> Consider a commitment scheme <span class="math">\\mathcal{VC}</span> over vectors over field <span class="math">\\mathbb{F}</span>. We define the committed relaxed R1CS relation <span class="math">\\mathcal{R}_{\\mathsf{CRR1CS}}</span> as <span class="math">\\mathcal{R}_{\\mathsf{RR1CS}}(\\mathcal{VC}&#x27;)</span> where <span class="math">\\mathcal{VC}&#x27;</span> commits to pairs of vectors by applying <span class="math">\\mathcal{VC}</span> to each vector.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Multi-folding schemes</h2>

    <p class="text-gray-300">Recall that a folding scheme [43] for a relation <span class="math">\\mathcal{R}</span> is a protocol between a <em>prover</em> and <em>verifier</em> in which the prover and the verifier reduce the task of checking two instances in <span class="math">\\mathcal{R}</span> with the same structure <span class="math">\\mathsf{s}</span> into the task of checking a single instance in <span class="math">\\mathcal{R}</span> with structure <span class="math">\\mathsf{s}</span>.</p>

    <p class="text-gray-300">We introduce a generalization of folding schemes, which we refer to as multi-folding schemes. A multi-folding scheme is defined with respect to a pair of relations <span class="math">(\\mathcal{R}_1,\\mathcal{R}_2)</span>, a predicate <span class="math">\\mathsf{compat}</span>, and size parameters <span class="math">\\mu</span> and <span class="math">\\nu</span>. It is an interactive protocol between a prover and a verifier in which the prover and the</p>

    <p class="text-gray-300">4 As formulated, any relaxed R1CS is naturally satisfiable by setting <span class="math">E</span> appropriately. As shown by Kothapalli et al. [43] relaxed R1CS is augmented with honestly generated commitments to <span class="math">E</span>, which sufficiently restricts the prover's choice of <span class="math">E</span>.</p>

    <p class="text-gray-300">verifier reduce the task of checking  <span class="math">\\mu</span>  instances in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">\\mathsf{s}_1</span>  and  <span class="math">\\nu</span>  instances in  <span class="math">\\mathcal{R}_2</span>  with structure  <span class="math">\\mathsf{s}_2</span>  into the task of checking a single instance in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">\\mathsf{s}_1</span>  as long as  <span class="math">\\mathsf{s}_1</span>  and  <span class="math">\\mathsf{s}_2</span>  satisfy a predicate compat (e.g., compat might require that  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2</span> ). Below, we formally define multi-folding schemes.</p>

    <p class="text-gray-300">Definition 7 (Multi-folding schemes). Consider relations  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span>  over public parameters, structure, instance, and witness tuples, a predicate compat that structures for instances in  <span class="math">\\mathcal{R}_1</span>  and  <span class="math">\\mathcal{R}_2</span>  must satisfy, and size parameters  <span class="math">\\mu, \\nu \\in \\mathbb{N}</span> . A multi-folding scheme for  <span class="math">(\\mathcal{R}_1, \\mathcal{R}_2, \\mathrm{compat}, \\mu, \\nu)</span>  is defined by PPT algorithms  <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span>  and deterministic  <span class="math">\\mathcal{K}</span>  denoted the generator, prover, verifier and encoder respectively with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}, N) \\to \\mathbb{pp}</span> : on input security parameter  <span class="math">\\lambda</span>  and size bounds  <span class="math">N</span> , samples public parameters  <span class="math">\\mathbb{pp}</span> .</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},(\\mathsf{s}_1,\\mathsf{s}_2))\\to (\\mathsf{pk},\\mathsf{vk})</span>  : on input pp, and structures  <span class="math">\\mathsf{s}_1</span>  and  <span class="math">\\mathsf{s}_2</span>  among the instances to be folded, outputs a prover key pk and a verifier key vk.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},(\\vec{u}_1,\\vec{w}_1),(\\vec{u}_2,\\vec{w}_2))\\to (\\mathsf{u},\\mathsf{w})</span>  : on input a vector of instances  <span class="math">\\vec{u}_1</span>  in  <span class="math">\\mathcal{R}_1</span>  of size  <span class="math">\\mu</span>  with structure  <span class="math">\\mathsf{s}_1</span>  and a vector of instances  <span class="math">\\vec{u}_2</span>  in  <span class="math">\\mathcal{R}_2</span>  of size  <span class="math">\\nu</span>  with structure  <span class="math">\\mathsf{s}_2</span> , and corresponding witness vectors  <span class="math">\\vec{w}_1</span>  and  <span class="math">\\vec{w}_2</span>  outputs a folded instance-witness pair  <span class="math">(\\mathsf{u},\\mathsf{w})</span>  in  <span class="math">\\mathcal{R}_1</span>  with structure  <span class="math">\\mathsf{s}_1</span> .</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk}, (\\vec{u}_1, \\vec{u}_2)) \\to \\mathsf{u}</span> : on input a vector of instances  <span class="math">\\vec{u}_1</span>  and a vector of instances  <span class="math">\\vec{u}_2</span>  outputs a new instance  <span class="math">\\mathsf{u}</span> .</li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span>  denote the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> . We treat  <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span>  as a function that takes as input  <span class="math">((\\mathsf{pk},\\mathsf{vk}),(\\vec{u}_1,\\vec{w}_1),(\\vec{u}_2,\\vec{w}_2))</span>  and runs the interaction on prover input  <span class="math">(\\mathsf{pk},(\\vec{u}_1,\\vec{w}_1),(\\vec{u}_2,\\vec{w}_2))</span>  and verifier input  <span class="math">(\\mathsf{vk},(\\vec{u}_1,\\vec{u}_2))</span> . At the end of interaction  <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span>  outputs  <span class="math">(u,w)</span>  where  <span class="math">u</span>  is the verifier's output folded instance, and  <span class="math">w</span>  is the prover's output folded witness.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}^{(n)}</span>  be the relation such that  <span class="math">(\\mathsf{pp},\\mathsf{s},\\vec{\\mathsf{u}},\\vec{\\mathsf{w}})\\in \\mathcal{R}^{(n)}</span>  if and only if  <span class="math">(\\mathsf{pp},\\mathsf{s},\\vec{\\mathsf{u}}_i,\\vec{\\mathsf{w}}_i)\\in \\mathcal{R}</span>  for all  <span class="math">i\\in [n]</span> . A multi-folding scheme for  <span class="math">(\\mathcal{R}_1,\\mathcal{R}_2,\\mathrm{compat},\\mu ,\\nu)</span>  satisfies the following requirements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: For all PPT adversaries  <span class="math">\\mathcal{A}</span> , we have that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname * {P r} \\left[ \\begin{array}{c} (\\mathsf {p p}, \\mathsf {s} _ {1}, \\mathsf {u}, \\mathsf {w}) \\in \\mathcal {R} _ {1} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ ((\\mathsf {s} _ {1}, \\mathsf {s} _ {2}), (\\vec {\\mathsf {u}} _ {1}, \\vec {\\mathsf {u}} _ {2}), (\\vec {\\mathsf {w}} _ {1}, \\vec {\\mathsf {w}} _ {2})) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ \\mathsf {c o m p a t} (\\mathsf {s} _ {1}, \\mathsf {s} _ {2}) = \\mathsf {t r u e}, \\\\ (\\mathsf {p p}, \\mathsf {s} _ {1}, \\vec {\\mathsf {u}} _ {1}, \\vec {\\mathsf {w}} _ {1}) \\in \\mathcal {R} _ {1} ^ {(\\mu)}, (\\mathsf {p p}, \\mathsf {s} _ {2}, \\vec {\\mathsf {u}} _ {2}, \\vec {\\mathsf {w}} _ {2}) \\in \\mathcal {R} _ {2} ^ {(\\nu)}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, \\mathsf {s} _ {1}, \\mathsf {s} _ {2}), \\\\ (u, w) \\leftarrow \\langle \\mathcal {P}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), (\\vec {\\mathsf {u}} _ {1}, \\vec {\\mathsf {u}} _ {2}), (\\vec {\\mathsf {w}} _ {1}, \\vec {\\mathsf {w}} _ {2})) \\end{array} \\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: For any expected polynomial-time adversaries  <span class="math">\\mathcal{A}</span>  and  <span class="math">\\mathcal{P}^*</span>  there is an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_ {\\mathbf {r}} \\left[ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s} _ {1}, \\vec {u} _ {1}, \\vec {w} _ {1}) \\in \\mathcal {R} _ {1} ^ {(\\mu)}, \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ ((\\mathsf {s} _ {1}, \\mathsf {s} _ {2}), (\\vec {u} _ {1}, \\vec {u} _ {2}), \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}, \\mathsf {r}), \\\\ (\\mathsf {p p}, \\mathsf {s} _ {2}, \\vec {u} _ {2}, \\vec {w} _ {2}) \\in \\mathcal {R} _ {2} ^ {(\\nu)} \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\text {c o m p a t} (\\mathsf {s} _ {1}, \\mathsf {s} _ {2}) = \\text {t r u e}, \\\\ (\\vec {w} _ {1}, \\vec {w} _ {2}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {r}) \\end{array} \\right] \\approx \\\\ \\Pr_ {\\mathbf {r}} \\left[ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s} _ {1}, u, w) \\in \\mathcal {R} _ {1} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ ((\\mathsf {s} _ {1}, \\mathsf {s} _ {2}), (\\vec {u} _ {1}, \\vec {u} _ {2}), \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}, \\mathsf {r}), \\\\ \\mathsf {c o m p a t} (\\mathsf {s} _ {1}, \\mathsf {s} _ {2}) = \\mathsf {t r u e}, \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, (\\mathsf {s} _ {1}, \\mathsf {s} _ {2})), \\\\ (u, w) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), (\\vec {u} _ {1}, \\vec {u} _ {2}), \\mathsf {s t}) \\end{array} \\right. \\end{array} \\right. \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{r}</span>  denotes an arbitrarily long random tape.</p>

    <p class="text-gray-300">A multi-folding scheme is secure in the random oracle model if the above requirements hold when all parties are provided access to a random oracle.</p>

    <p class="text-gray-300">Definition 8 (Succinct). A multi-folding scheme is succinct if the communication complexity and verifier time complexity is at most poly-logarithmic in the size of the structures and witnesses.</p>

    <p class="text-gray-300">Definition 9 (Non-interactive). A multi-folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is noninteractive if the interaction between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  consists of a single message from  <span class="math">\\mathcal{P}</span>  to  <span class="math">\\mathcal{V}</span> . This single message is denoted as  <span class="math">\\mathcal{P}</span> 's output and as  <span class="math">\\mathcal{V}</span> 's input.</p>

    <p class="text-gray-300">Definition 10 (Public-coin). A multi-folding scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is called public-coin if all the messages sent from  <span class="math">\\mathcal{V}</span>  to  <span class="math">\\mathcal{P}</span>  are sampled uniformly.</p>

    <p class="text-gray-300">By applying the Fiat-Shamir transformation [28] we can transform a public-coin multi-folding scheme into a non-interactive multi-folding scheme in the random oracle model. We formally describe this transformation in Appendix B.</p>

    <p class="text-gray-300">Lemma 1 (Fiat-Shamir transformation for multi-folding schemes). Construction 3 transforms a public-coin multi-folding scheme for</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathcal {R} _ {1}, \\mathcal {R} _ {2}, \\operatorname {c o m p a t}, \\mu , \\nu\\right)</span></div>

    <p class="text-gray-300">into a non-interactive multi-folding scheme for  <span class="math">(\\mathcal{R}_1, \\mathcal{R}_2, \\mathrm{compat}, \\mu, \\nu)</span>  in the random oracle model.</p>

    <p class="text-gray-300">This section describes a multi-folding scheme for CCS. Specifically, we provide a multi-folding scheme for  <span class="math">\\mathcal{R}_1 = \\mathcal{R}_{\\mathrm{LCCCS}}</span>  and  <span class="math">\\mathcal{R}_2 = \\mathcal{R}_{\\mathrm{CCCS}}</span> , with  <span class="math">\\mathrm{compat}(\\mathsf{s}_1,\\mathsf{s}_2)</span>  requiring  <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2</span> . Our multi-folding scheme supports arbitrary values of  <span class="math">\\mu</span>  and  <span class="math">\\nu</span> .</p>

    <p class="text-gray-300">Overview. To introduce core ideas, we focus on the case of <span class="math">\\mu=\\nu=1</span>. Construction 1 formally describes the general case.</p>

    <p class="text-gray-300">Consider structure <span class="math">\\mathsf{s}_{1}=\\mathsf{s}_{2}=([\\widetilde{M}_{1},\\ldots,\\widetilde{M}_{t}],[S_{1},\\ldots,S_{q}],[c_{1},\\ldots,c_{q}])</span>, and let <span class="math">s=\\log m</span>, and <span class="math">s^{\\prime}=\\log n</span>. We design a multi-folding scheme that reduces the verifier’s task of checking a linearized committed CCS instance <span class="math">(C_{1},u,\\mathsf{x}_{1},r_{x},v_{1},\\ldots,v_{t})</span> and a committed CCS instance <span class="math">(C_{2},\\mathsf{x}_{2})</span> to the task of checking a new linearized committed CCS instance. In particular, the verifier’s goal is to reduce the task of checking that a prover knows satisfying witnesses <span class="math">\\widetilde{w_{1}}</span> and <span class="math">\\widetilde{w_{2}}</span> such that for <span class="math">\\widetilde{z_{1}}=\\widetilde{(w_{1},u,\\mathsf{x}_{1})}</span> and <span class="math">\\widetilde{z_{2}}=\\widetilde{(w_{2},1,\\mathsf{x}_{2})}</span> we have that</p>

    <p class="text-gray-300"><span class="math">v_{j}=\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{j}(r_{x},y)\\cdot\\widetilde{z_{1}}(y)</span> (1)</p>

    <p class="text-gray-300">for all <span class="math">j\\in[t]</span> and</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{q}c_{i}\\cdot\\prod_{j\\in S_{i}}\\left(\\sum_{y\\in\\{0,1\\}^{s}}\\widetilde{M}_{j}(x,y)\\cdot\\widetilde{z_{2}}(y)\\right)=0</span> (2)</p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{s}</span>.</p>

    <p class="text-gray-300">The high-level strategy of the prover and verifier is to first encode the above claims as a claim about the evaluations of polynomials and then reduce this claim using the sum-check protocol. The resulting reduced claim is equivalent to checking two <em>compatible</em> linearized committed CCS instances. The compatibility ensures that we can reduce the task of checking both instances into the task of checking a single linearized CCS instance using a random linear combination.</p>

    <p class="text-gray-300">In more detail, consider polynomials</p>

    <p class="text-gray-300"><span class="math">H_{j}(x)\\coloneqq\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{j}(x,y)\\cdot\\widetilde{z}_{1}(y)</span> (3)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">G(x)\\coloneqq\\sum_{i=1}^{q}c_{i}\\cdot\\prod_{j\\in S_{i}}\\left(\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{j}(x,y)\\cdot\\widetilde{z}_{2}(y)\\right).</span> (4)</p>

    <p class="text-gray-300">Then, checking <span class="math">H_{j}(r_{x})=v_{j}</span> for all <span class="math">j\\in[t]</span> implies checking Equation 1. Then, by Lemma 6, for <span class="math">L_{j}(x)=\\widetilde{eq}(r_{x},x)\\cdot H_{j}(x)</span>, this is equivalent to checking</p>

    <p class="text-gray-300"><span class="math">v_{j}=\\sum_{x\\in\\{0,1\\}^{s}}L_{j}(x)</span> (5)</p>

    <p class="text-gray-300">for all <span class="math">j\\in[t]</span>.</p>

    <p class="text-gray-300">Similarly, checking <span class="math">G(x)=0</span> for all <span class="math">x\\in\\{0,1\\}^{s}</span> implies checking Equation 2. We define a corresponding Lagrange polynomial, <span class="math">\\sum_{x\\in\\{0,1\\}^{s}}\\widetilde{eq}(X,x)\\cdot G(x)</span>, which</p>

    <p class="text-gray-300">encodes each evaluation of <span class="math">G</span> into its coefficients. Then checking that this Lagrange polynomial is the zero polynomial implies checking that <span class="math">G(x)=0</span> for all <span class="math">x\\in\\{0,1\\}^{s}</span>. Then, for a random challenge <span class="math">\\beta\\in\\mathbb{F}</span>, by the Schwartz-Zippel lemma (Lemma 7), for <span class="math">Q(x)=\\widetilde{eq}(\\beta,x)\\cdot G(x)</span>, checking</p>

    <p class="text-gray-300"><span class="math">0=\\sum_{x\\in\\{0,1\\}^{s}}Q(x)</span> (6)</p>

    <p class="text-gray-300">implies checking Equation 2 with high probability.</p>

    <p class="text-gray-300">Equations 5 and 6 can be checked simultaneously with high probability by setting</p>

    <p class="text-gray-300"><span class="math">g(x)</span> <span class="math">\\coloneqq\\left(\\sum_{j\\in[t]}\\gamma^{j}\\cdot L_{j}(x)\\right)+\\gamma^{t+1}\\cdot Q(x)</span> <span class="math">T</span> <span class="math">\\coloneqq\\left(\\sum_{j\\in T}\\gamma^{j}\\cdot v_{j}\\right)+\\gamma^{t+1}\\cdot 0</span></p>

    <p class="text-gray-300">for some random challenge <span class="math">\\gamma\\in\\mathbb{F}</span> and checking if</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x\\in\\{0,1\\}^{s}}g(x).</span> (7)</p>

    <p class="text-gray-300">Then, the prover and verifier run the sum-check protocol to reduce the task of checking Equation 7 to the task of checking</p>

    <p class="text-gray-300"><span class="math">c=g(r^{\\prime}_{x})</span> (8)</p>

    <p class="text-gray-300">for some random point <span class="math">r^{\\prime}_{x}\\in\\mathbb{F}^{s}</span> chosen over the course of the sum-check protocol and a claimed evaluation <span class="math">c\\in\\mathbb{F}</span>.</p>

    <p class="text-gray-300">To assist the verifier in checking Equation 8, the prover computes claimed values for sums internal to polynomial <span class="math">g</span>,</p>

    <p class="text-gray-300"><span class="math">\\sigma_{i}</span> <span class="math">\\leftarrow\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{i}(r^{\\prime}_{x},y)\\cdot\\widetilde{z}_{1}(y)</span> (9) <span class="math">\\theta_{i}</span> <span class="math">\\leftarrow\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{i}(r^{\\prime}_{x},y)\\cdot\\widetilde{z}_{2}(y),</span> (10)</p>

    <p class="text-gray-300">for all <span class="math">i\\in[t]</span>, and sends them to the verifier.</p>

    <p class="text-gray-300">Using these values, the verifier can check Equation 8. However, it must still check Equations 9 and 10, that is, that <span class="math">\\sigma_{i}</span> and <span class="math">\\theta_{i}</span> were computed correctly for all <span class="math">i\\in[t]</span>.</p>

    <p class="text-gray-300">We observe that because both of these equations are defined with respect to the same randomness <span class="math">r^{\\prime}_{x}</span>. So, by linearity, the verifier can sample a random challenge <span class="math">\\rho</span>, and reduce the task of checking Equations 9 and 10 to the task of checking</p>

    <p class="text-gray-300"><span class="math">\\sigma_{i}+\\rho\\cdot\\theta_{i}=\\sum_{y\\in\\{0,1\\}^{s^{\\prime}}}\\widetilde{M}_{i}(r^{\\prime}_{x},y)\\cdot(\\widetilde{z}_{1}(y)+\\rho\\cdot\\widetilde{z}_{2}(y))</span> (11)</p>

    <p class="text-gray-300">for</p>

    <p class="text-gray-300">for all <span class="math">i \\in [t]</span>.</p>

    <p class="text-gray-300">Conveniently, letting <span class="math">C&#x27; \\gets C_1 + \\rho \\cdot C_2</span>, <span class="math">u&#x27; \\gets u + \\rho \\cdot 1</span>, <span class="math">x&#x27; \\gets x_1 + \\rho \\cdot x_2</span>, and <span class="math">v_i&#x27; \\gets \\sigma_i + \\rho \\cdot \\theta_i</span> for all <span class="math">i \\in [t]</span>, checking Equation 11, is equivalent to checking that the prover knows a witness for the following linearized committed CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C&#x27;, u&#x27;, x&#x27;, r_x&#x27;, v_1&#x27;, \\dots, v_t&#x27;),</span></div>

    <p class="text-gray-300">thus completing the reduction. We formally describe our folding scheme below.</p>

    <p class="text-gray-300"><strong>Construction 1 (A multi-folding scheme for CCS).</strong> Let <span class="math">\\mathsf{PC} = (\\mathsf{Gen},\\mathsf{Commit})</span> denote an additively-homomorphic commitment scheme for multilinear polynomials. We construct a multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCS}},\\mathcal{R}_{\\mathsf{CCS}},\\mathsf{compat},\\mu ,\\nu)</span>, where <span class="math">\\mathsf{compat}</span> is defined as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{compat}(s_1,s_2)\\to \\{\\mathsf{true},\\mathsf{false}\\}</span>: If <span class="math">s_1.\\widetilde{M}_i = s_2.\\widetilde{M}_i</span> for <span class="math">i\\in [t]</span>, then return true, otherwise return false.</p>

    <p class="text-gray-300">Let <span class="math">s_1 = s_2 = ([\\widetilde{M}_1, \\ldots, \\widetilde{M}_t], [S_1, \\ldots, S_q], [c_1, \\ldots, c_q])</span>.</p>

    <p class="text-gray-300">We define the generator and the encoder as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda},(m,N,\\ell ,t,q,d\\in \\mathbb{N}))\\to \\mathsf{pp}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">n = 2\\cdot (\\ell +1)</span></li>

      <li><span class="math">\\mathsf{pp}_{\\mathsf{PC}}\\gets \\mathsf{Gen}(1^{\\lambda},\\log n - 1)</span></li>

      <li>Output <span class="math">(m,n,N,\\ell ,t,q,d,\\mathsf{pp}_{\\mathsf{PC}})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},(\\mathsf{s}_1,\\mathsf{s}_2))\\to (\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{pk} \\gets (\\mathsf{pp}, \\mathsf{s}_1)</span> and <span class="math">\\mathsf{vk} \\gets \\mathsf{pp}</span></li>

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})</span></li>

    </ol>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> takes <span class="math">\\mu</span> linearized committed CCS instances <span class="math">\\vec{u}_1</span> and <span class="math">\\nu</span> committed CCS instances <span class="math">\\vec{u}_2</span>. The prover in addition to these instances takes witnesses to all instances <span class="math">\\vec{w}_1</span> and <span class="math">\\vec{w}_2</span>. We denote <span class="math">\\mu</span> linearized committed CCS instance-witness pairs with <span class="math">\\mathcal{L}</span> and use <span class="math">\\mathcal{L}_k</span> (for <span class="math">k\\in [\\mu ]</span>) to index into the <span class="math">k</span>th linearized committed CCS instance-witness pair. Similarly, we denote <span class="math">\\nu</span> committed CCS instance-witness pairs <span class="math">\\mathcal{C}</span> and use <span class="math">\\mathcal{C}_k</span> (for <span class="math">k\\in [\\nu ]</span>) to index into the <span class="math">k</span>th committed CCS instance-witness pair. Inside an instance-witness pair, we use <span class="math">\\phi</span> to index into the instance and <span class="math">w</span> to index into the witness.</p>

    <p class="text-gray-300">Let <span class="math">s = \\log m</span> and <span class="math">s&#x27; = \\log n</span>. Let <span class="math">\\widetilde{z}_{1,k} = (\\widetilde{w,u,x})</span>, where <span class="math">w = \\mathcal{L}_k.w</span>, <span class="math">u = \\mathcal{L}_k.\\phi .u</span>, and <span class="math">x = \\mathcal{L}_k.\\phi .x</span>. Similarly, let <span class="math">\\widetilde{z}_{2,k} = (\\widetilde{w,1,x})</span>, where <span class="math">w = \\mathcal{C}_k.w</span> and <span class="math">x = \\mathcal{C}_k.\\phi .x</span>.</p>

    <p class="text-gray-300">The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\gamma \\stackrel {\\S}{\\leftarrow} \\mathbb{F}, \\beta \\stackrel {\\S}{\\leftarrow} \\mathbb{F}^s</span>, and sends them to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Sample <span class="math">r_x&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{F}^s</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span>: Run the sum-check protocol <span class="math">c \\gets \\langle \\mathcal{P}, \\mathcal{V}(r_x&#x27;) \\rangle (g, s, d + 1, T)</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g(x) := \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot L_{j,k}(x)\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot Q_k(x)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">L_{j,k}(x) := \\widetilde{eq}(r_x, x) \\cdot \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{1,k}(y)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">Q_k(x) := \\widetilde{eq}(\\beta, x) \\cdot \\left(\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">T := \\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot \\mathcal{L}_k \\cdot \\phi \\cdot v_j</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">\\{\\sigma_{j,k}\\}</span>, where for all <span class="math">j \\in [t]</span>, <span class="math">k \\in [\\mu]</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{j,k} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z}_{1,k}(y)</span></div>

    <p class="text-gray-300">Similarly, <span class="math">\\{\\theta_{j,k}\\}</span>, where for all <span class="math">j \\in [t]</span> and <span class="math">k \\in [\\nu]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\theta_{j,k} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z}_{2,k}(y)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">e_1 \\gets \\widetilde{eq}(r_x, r_x&#x27;)</span> and <span class="math">e_2 \\gets \\widetilde{eq}(\\beta, r_x&#x27;)</span>, and check that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c = \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot e_1 \\cdot \\sigma_{j,k}\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot e_2 \\cdot \\left(\\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\theta_{j,k}\\right)\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\rho \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math"> and sends it to </span>\\mathcal{P}$.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}, \\mathcal{P}</span>: Output the folded linearized committed CCS instance <span class="math">(C, u, \\mathsf{x}, r_x&#x27;, v_1, \\ldots, v_t)</span>, where for all <span class="math">j \\in [t]</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">C \\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k \\cdot \\phi \\cdot C + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k \\cdot \\phi \\cdot C</span></div>

    <div class="my-4 text-center"><span class="math-block">u \\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k \\cdot \\phi \\cdot u + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\times \\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k \\cdot \\phi \\cdot \\times + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k \\cdot \\phi \\cdot \\times</span></div>

    <div class="my-4 text-center"><span class="math-block">v_j \\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\sigma_{j,k} + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\theta_{j,k}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Output the folded witness <span class="math">\\widetilde{w} \\gets \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k \\cdot w + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k \\cdot w</span>.</li>

    </ol>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">Below, we adapt the proof of Kothapalli et al. <em>[43]</em> to prove the correctness of our multifolding scheme for CCS (Theorem 1).</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof (intuition).</h6>

    <p class="text-gray-300">We provide a formal proof in Appendix H.1. Our multi-folding scheme is an “early stopping” version of SuperSpartan <em>[60]</em> and the claimed efficiency follows from the analysis of costs for the first sum-check invocation in SuperSpartan <em>[60, Theorem 1]</em>. To prove knowledge soundness, we show there exists an expected polynomial-time extractor that can rewind the interaction between a verifier and a malicious prover to interpolate for witnesses <span class="math">\\vec{\\mathbf{w}}_{1}</span> and <span class="math">\\vec{\\mathbf{w}}_{2}</span>. So long as the verifier does not abort, we have that <span class="math">g(r^{\\prime}_{x})=c</span>. Then, by the soundness of the sum-check protocol, we have that <span class="math">\\sum_{j\\in[t],k\\in[\\mu]}\\gamma^{(k-1)\\cdot t+j}\\cdot v_{j,k}+\\sum_{k\\in[\\nu]}\\gamma^{\\mu\\cdot t+k}\\cdot 0=\\sum_{x\\in\\{0,1\\}^{s}}g(x)</span>. By the Schwartz-Zippel lemma, we have that <span class="math">v_{j,k}=\\sum_{x\\in\\{0,1\\}^{s}}L_{j,k}(x)</span> for all <span class="math">j\\in[t]</span> and <span class="math">k\\in[\\mu]</span> and <span class="math">0=\\sum_{x\\in\\{0,1\\}^{s}}Q_{k}(x)</span> for <span class="math">k\\in[\\nu]</span>. This in turn implies that <span class="math">\\widetilde{w_{1}}</span> and <span class="math">\\widetilde{w_{2}}</span> are satisfying. ∎</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 2 (Efficiency).</h6>

    <p class="text-gray-300">Construction 1 is succinct.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Step 1 and Step 2, the verifier begins by sampling and sending random challenges, which takes work <span class="math">O(\\log m)</span> work, where <span class="math">m</span> is the number of CCS constraints. Next, in Step 3, the verifier verifies sum-check messages which requires <span class="math">O(d\\log m)</span> work, where <span class="math">d</span> is the degree of CCS constraints. In Step 5, the verifier computes <span class="math">\\widetilde{eq}(r_{x},r^{\\prime}_{x})</span> and <span class="math">\\widetilde{eq}(\\beta,r^{\\prime}_{x})</span>, which requires <span class="math">O(\\log m)</span> field operations, and performs <span class="math">O(t\\cdot\\mu+\\nu)</span> field operations where <span class="math">t</span>, <span class="math">\\mu</span>, and <span class="math">\\nu</span> are constants. Finally, in Step 7, the verifier computes <span class="math">O(\\mu+\\nu)</span> group scalar multiplication operations and $O((\\mu+\\nu)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations. Combining all these, the verifier’s work and the space requirements are logarithmic in the number of constraints and linear in the degree of CCS constraints. Hence, the verifier’s work is succinct. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By applying the Fiat-Shamir transformation (Construction 3), and instantiating the random oracle with a hash function, we have the following.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Assumption 1 (Non-interactivity).</h6>

    <p class="text-gray-300">There exists a non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCCS}},\\mathcal{R}_{\\mathsf{CCCS}},\\mathsf{compat},\\mu,\\nu)</span> in the plain model.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Non-uniform incrementally verifiable computation</h2>

    <p class="text-gray-300">This section introduces non-uniform IVC (NIVC), a generalization of IVC, where at each step of an incremental computation, the prover proves the satisfiability of a relation chosen from a set of possible relations (the choice of which relation to use is made by an additional designated relation), whereas in the standard IVC, there is only one possible relation. As a result of this generalization, the overall relation proven by non-uniform IVC can be a non-uniform circuit (i.e., circuits without repeating structure), which motivates its name.</p>

    <p class="text-gray-300">As detailed in the introduction, non-uniform IVC implies proofs of program executions on machines with a pre-defined custom instruction set. In Section 6, we construct HyperNova, an efficient NIVC scheme.</p>

    <p class="text-gray-300">In IVC, for a polynomial-time function  <span class="math">F</span> , the prover takes as input a claim  <span class="math">(i, z_0, z)</span>  and a corresponding proof  <span class="math">\\Pi_i</span>  that proves the knowledge of witnesses  <span class="math">(\\omega_0, \\ldots, \\omega_{i-1})</span>  such that by computing  <span class="math">z_{j+1} \\gets F(z_j, \\omega_j)</span>  for all  <span class="math">j \\in \\{0, \\ldots, i-1\\}</span>  we have that  <span class="math">z = z_i</span> . Given a new witness  <span class="math">\\omega_i</span> , the prover computes a new proof  <span class="math">\\Pi_{i+1}</span>  of the same size, which proves the statement  <span class="math">(i+1, z_0, z_{i+1})</span>  for  <span class="math">z_{i+1} = F(z_i, \\omega_i)</span> .</p>

    <p class="text-gray-300">In NIVC, we extend IVC to handle a number of arbitrary polynomial-time functions  <span class="math">(F_{1},\\ldots ,F_{\\ell})</span> . The choice of which function  <span class="math">F_{j}</span>  for  <span class="math">j\\in [\\ell ]</span>  is executed at a particular step in the incremental computation is handled by an additional polynomial-time function  <span class="math">\\varphi</span> . More specifically, NIVC captures an incremental proof system for the following augmented statement: There exists  <span class="math">(\\omega_0,\\dots ,\\omega_{i - 1})</span>  such that on initial input  <span class="math">z_{0}</span>  and claimed output  <span class="math">z</span> , by computing  <span class="math">z_{j + 1}\\gets F_{\\varphi (z_j,\\omega_j)}(z_j,\\omega_j)</span>  for all  <span class="math">j\\in \\{0,\\dots ,i - 1\\}</span> , we have that  <span class="math">z = z_{i}</span> .</p>

    <p class="text-gray-300">Observe that if we fix  <span class="math">\\ell = 1</span>  and that  <span class="math">\\varphi</span>  outputs 1, we recovers the definition of IVC [66]. This means that any NIVC scheme is also an IVC scheme.</p>

    <p class="text-gray-300">Definition 11 (Non-uniform IVC). A non-uniform incrementally verifiable computation (NIVC) scheme is defined by PPT algorithms  <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span>  and a deterministic  <span class="math">\\kappa</span>  denoting the generator, the prover, the verifier, and the encoder respectively, with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}, N) \\to \\mathfrak{pp}</span> : on input security parameter  <span class="math">\\lambda</span>  and size bounds  <span class="math">N</span> , samples public parameters  <span class="math">\\mathfrak{pp}</span> .</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},((F_1,\\ldots ,F_\\ell),\\varphi))\\to (\\mathsf{pk},\\mathsf{vk})</span>  : on input public parameters  <span class="math">\\mathsf{pp}</span> , a control function  <span class="math">\\varphi</span> , and functions  <span class="math">F_{1},\\ldots ,F_{\\ell}</span>  deterministically produces a prover key  <span class="math">\\mathsf{pk}</span>  and a verifier key  <span class="math">\\mathsf{vk}</span> .</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk}, (i, z_0, z_i), \\omega_i, \\Pi_i) \\to \\Pi_{i+1}</span> : on input a prover key  <span class="math">\\mathsf{pk}</span> , a counter  <span class="math">i</span> , initial input  <span class="math">z_0</span> , claimed output after  <span class="math">i</span>  applications  <span class="math">z_i</span> , a non-deterministic advice  <span class="math">\\omega_i</span> , and an NIVC proof  <span class="math">\\Pi_i</span>  attesting to  <span class="math">z_i</span> , produces a new proof  <span class="math">\\Pi_{i+1}</span>  attesting to  <span class="math">z_{i+1} = F_{\\varphi(z_i, \\omega_i)}(z_i, \\omega_i)</span> .</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk}, (i, z_0, z_i), \\Pi_i) \\to \\{0, 1\\}</span> : on input a verifier key  <span class="math">\\mathsf{vk}</span> , a counter  <span class="math">i</span> , an initial input  <span class="math">z_0</span> , a claimed output after  <span class="math">i</span>  applications  <span class="math">z_i</span> , and an NIVC proof  <span class="math">\\Pi_i</span>  attesting to  <span class="math">z_i</span> , outputs 1 if  <span class="math">\\Pi_i</span>  is accepting, 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">An NIVC scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  satisfies following requirements.</p>

    <p class="text-gray-300">(i) Completeness: For any PPT adversary  <span class="math">\\mathcal{A}</span>  we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ \\left(\\left(\\left(F _ {1}, \\ldots , F _ {\\ell}\\right), \\varphi\\right), (i, z _ {0}, z _ {i}), (\\omega_ {i}, \\Pi_ {i})\\right) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, ((F _ {1}, \\ldots , F _ {\\ell}), \\varphi)), \\\\ \\mathcal {V} (\\mathsf {v k}, (i, z _ {0}, z _ {i}), \\Pi_ {i}) = 1, \\\\ z _ {i + 1} \\leftarrow F _ {\\varphi (z _ {i}, \\omega_ {i})} (z _ {i}, \\omega_ {i}), \\\\ \\Pi_ {i + 1} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\Pi_ {i}), \\\\ b \\leftarrow \\mathcal {V} (\\mathsf {v k}, (i + 1, z _ {0}, z _ {i + 1}), \\Pi_ {i + 1}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">where <span class="math">\\ell \\geq 1</span> and <span class="math">\\varphi</span> produces an element in <span class="math">\\mathbb{Z}_{\\ell +1}^{*}</span>. Moreover, <span class="math">\\varphi</span> and each <span class="math">F_{j}</span> for <span class="math">j\\in \\{1,\\ldots ,\\ell \\}</span> are a polynomial-time computable function represented as arithmetic circuits.</p>

    <p class="text-gray-300">(ii) Knowledge Soundness: Consider constant <span class="math">n \\in \\mathbb{N}</span>. For all expected polynomial-time adversaries <span class="math">\\mathcal{P}^*</span> there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\mathsf{r}} \\left[ \\begin{array}{l} z_{n} = z \\text{ where} \\\\ z_{i + 1} \\leftarrow F_{\\varphi (z_{i}, \\omega_{i})} (z_{i}, \\omega_{i}) \\\\ \\forall i \\in \\{0, \\ldots , n - 1 \\} \\end{array} \\right] \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G} (1^{\\lambda}, N), \\\\ (((F_{1}, \\ldots , F_{\\ell}), \\varphi), (z_{0}, z), \\Pi) \\leftarrow \\mathcal{P}^{*}(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\omega_{0}, \\ldots , \\omega_{n - 1}) \\leftarrow \\mathcal{E}(\\mathsf{pp}, \\mathsf{r}) \\end{array} \\right] \\approx</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\mathsf{r}} \\left[ \\begin{array}{l} \\mathcal{V}(\\mathsf{vk}, (n, z_{0}, z), \\Pi) = 1 \\\\ \\text{succinctness: The NIVC proof size is independent of the iteration count.} \\end{array} \\right] \\begin{array}{l} \\mathsf{pp} \\leftarrow \\mathcal{G} (1^{\\lambda}, N), \\\\ (((F_{1}, \\ldots , F_{\\ell}), \\varphi), (z_{0}, z), \\Pi) \\leftarrow \\mathcal{P}^{*}(\\mathsf{pp}, \\mathsf{r}), \\\\ (\\mathsf{pk}, \\mathsf{vk}) \\leftarrow \\mathcal{K}(\\mathsf{pp}, ((F_{1}, \\ldots , F_{\\ell}), \\varphi)) \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{r}</span> denotes an arbitrarily long random tape.</p>

    <p class="text-gray-300">(iii) Succinctness: The NIVC proof size is independent of the iteration count.</p>

    <p class="text-gray-300">(iv) Efficiency: The prover's time complexity at any step <span class="math">i</span> is linear in the size of the function applied at step <span class="math">i</span> and the total number of functions <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">We now describe HyperNova, a general compiler that takes a multi-folding scheme for an NP-complete relation with mild requirements and produces an NIVC scheme. For simplicity, we focus on constructing NIVC, but our construction extends naturally to provide a generalization of IVC to distributed computations called proof-carrying data (PCD) [22,7].</p>

    <p class="text-gray-300">In Section 6.1, we provide an informal overview of HyperNova, instantiated with the multi-folding scheme for CCCS from Section 4. Next, in Section 6.2 we isolate the necessary properties for a general multi-folding scheme to be used to construct NIVC. We refer to multi-folding schemes that satisfy these properties as NIVC-compatible. We then prove that the folding scheme for CCCS is NIVC-compatible. In Section 6.3 we provide a formal construction of HyperNova.</p>

    <p class="text-gray-300">We intentionally overlook certain minor complications. We then address these complications before providing a formal construction. For concreteness, we fix CCCS as the NP-complete relation.</p>

    <p class="text-gray-300">Consider efficient functions <span class="math">\\{F_1, \\ldots, F_\\ell\\}</span> and <span class="math">\\varphi</span>. Recall that the NIVC statement <span class="math">(i, z_0, z_i)</span> claims the knowledge of <span class="math">(\\omega_0, \\ldots, \\omega_{i-1})</span> such that by computing <span class="math">z_{k+1}&#x27; \\gets F_{\\varphi(z_k&#x27;, \\omega_k)}(z_k&#x27;, \\omega_k)</span> for all <span class="math">k \\in \\{0, \\ldots, i-1\\}</span> for <span class="math">z_0&#x27; = z_0</span> we have that <span class="math">z_i&#x27; = z_i</span>.</p>

    <p class="text-gray-300">We now describe a single iterative step of the prover's work. That is, we explain how the prover can take a proof <span class="math">\\varPi_{i}</span> for the NIVC statement <span class="math">(i,z_0,z_i)</span> and efficiently produce an updated proof <span class="math">\\varPi_{i+1}</span> for the NIVC statement <span class="math">(i+1,z_0,z_{i+1})</span>. At a high level, instead of directly proving the knowledge of a satisfying witness to some</p>

    <p class="text-gray-300">prescribed <span class="math">F_{j}</span> for <span class="math">j\\in\\{1,\\ldots,\\ell\\}</span> in each step, the prover proves the knowledge of a satisfying witness to an augmented function <span class="math">F_{j}^{\\prime}</span>. The augmented function <span class="math">F_{j}^{\\prime}</span>, in addition to running <span class="math">F_{j}</span>, performs additional bookkeeping using a folding scheme to help verifiably update the NIVC proof.</p>

    <p class="text-gray-300">At first glance, a straw-man approach is to have each <span class="math">F_{j}^{\\prime}</span> take as input a CCCS instance that claims the correct execution of the latest iteration and then fold that instance into a running LCCCS instance using the folding scheme in Section 4 (this is the approach taken by Nova <em>[43]</em>). However, the folding scheme for CCCS requires that both instances have compatible structure (which requires that they represent the same computation in their matrices). In the case of standard IVC, as there is only one function that can be applied at each iterative step, this holds naturally. However, this is not the case for non-uniform IVC.</p>

    <p class="text-gray-300">To address this, <span class="math">F_{j}^{\\prime}</span> instead takes a list <span class="math">\\mathsf{U}_{i}</span> of running instances, where <span class="math">\\mathsf{U}_{i}[j]</span> attests to all prior iterations of <span class="math">F_{j}^{\\prime}</span> up to <span class="math">i-1</span> steps. As such, checking all of <span class="math">\\mathsf{U}_{i}</span> is equivalent to checking <span class="math">i-1</span> steps. In addition, <span class="math">F_{j}^{\\prime}</span> takes as input a new instance <span class="math">\\mathsf{u}_{i}</span>, which claims the correctness of the <span class="math">i</span>’th step. Instead of directly checking this instance (which would be concretely expensive), <span class="math">F_{j}^{\\prime}</span> folds <span class="math">\\mathsf{u}_{i}</span> into the appropriate instance in <span class="math">\\mathsf{U}_{i}</span> according to <span class="math">\\varphi</span> to produce a new list of running instances <span class="math">\\mathsf{U}_{i+1}</span>. To claim the correctness of <span class="math">F_{j}^{\\prime}</span> itself, the prover produces a new instance <span class="math">\\mathsf{u}_{i+1}</span>.</p>

    <p class="text-gray-300">We let the NIVC proof <span class="math">\\Pi_{i}</span> contain the list <span class="math">\\mathsf{U}_{i}</span>, the fresh instance <span class="math">\\mathsf{u}_{i}</span>, and the corresponding witnesses. Thus, the prover can use parts of <span class="math">\\Pi_{i}</span> as input to the appropriate function <span class="math">F_{j}^{\\prime}</span> to produce <span class="math">\\mathsf{U}_{i+1}</span> and <span class="math">\\mathsf{u}_{i+1}</span>, and separately compute the corresponding witnesses. These terms together define <span class="math">\\Pi_{i+1}</span>. At the end of the iterative computation (or at any intermediate step, if necessary), the verifier can check <span class="math">i</span> steps by checking proof <span class="math">\\Pi_{i}</span> directly.</p>

    <p class="text-gray-300">The prior description overlooks the following minor issues. Prior work <em>[43]</em> addresses these (except for the first one), and we now provide an overview of these in light of the above overview.</p>

    <p class="text-gray-300">First, we describe how to update a proof <span class="math">\\Pi_{i}</span> to produce a proof <span class="math">\\Pi_{i+1}</span>. However, we did not define a base case proof <span class="math">\\Pi_{0}</span> and how the prover, the verifier, and each function <span class="math">F_{j}^{\\prime}</span> handles the base case. At a high level, we have <span class="math">F_{j}^{\\prime}</span> populate <span class="math">\\mathsf{U}</span> with satisfying running instances in the base case.</p>

    <p class="text-gray-300">Second, the non-interactive folding scheme’s verifier run by <span class="math">F_{j}^{\\prime}</span> needs additional advice generated by the non-interactive folding scheme’s prover. To address this, the prover provides additional non-deterministic input to <span class="math">F_{j}^{\\prime}</span>.</p>

    <p class="text-gray-300">Finally, there is a subtle sizing issue in the above description: in each step, because <span class="math">\\mathsf{U}_{i+1}</span> is produced as the public IO of <span class="math">F_{\\mathsf{pc}_{i+1}}^{\\prime}</span>, it must be contained in the public IO of instance <span class="math">\\mathsf{u}_{i+1}</span>. In the next iteration, because <span class="math">\\mathsf{u}_{i+1}</span> is folded into <span class="math">\\mathsf{U}_{i+1}[\\mathsf{pc}_{i+1}]</span>, this means that <span class="math">\\mathsf{U}_{i+1}[\\mathsf{pc}_{i+1}]</span> is at least as large as <span class="math">\\mathsf{U}_{i}</span> by the properties of the folding scheme. This means that the list of running instances grows in each step. To alleviate this issue, we have each <span class="math">F_{j}^{\\prime}</span> only produce a hash of its outputs as</p>

    <p class="text-gray-300">public output. In the subsequent step, the next augmented function takes as non-deterministic input a preimage to this hash.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">6.2 NIVC-Compatible multi-folding schemes</h3>

    <p class="text-gray-300">Generalizing the above discussion, a multi-folding scheme for an arbitrary committed relation <span class="math">\\mathcal{R}_{2}</span> can be used for NIVC if it satisfies the following properties: First, statements about the correct execution of an efficient function <span class="math">F</span> can be encoded (and decoded) as statements in the underlying relation of <span class="math">\\mathcal{R}_{2}</span>. We refer to this property as <em>NP-completeness</em>. Second, structures and instances can be encoded (and decoded) independently of witnesses. We refer to this property as <em>partial functions</em>. Third, we must have that any efficient function <span class="math">F</span> can be encoded as an <span class="math">\\mathcal{R}_{2}</span> structure in a way that preserves the size of <span class="math">F</span>. We refer to this property as <em>monotonicity</em>. Fourth, we must have that there exists a default satisfying instance-witness pair in <span class="math">\\mathcal{R}_{1}</span> (this is required for the base case of our NIVC construction). We refer to this property as <em>default instances</em>. We formally define NIVC-compatibility as follows.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 12 (NIVC-compatible multi-folding scheme).</h6>

    <p class="text-gray-300">Consider a relation <span class="math">\\mathcal{R}_{1}</span>, and a committed relation <span class="math">\\mathcal{R}_{2}</span> over an underlying relation <span class="math">\\mathcal{R}_{2}^{\\prime}</span>. A succinct, non-interactive multi-folding scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> with deterministic <span class="math">\\mathcal{V}</span> for <span class="math">(\\mathcal{R}_{1},\\mathcal{R}_{2},\\mathsf{compat},1,1)</span> is NIVC-compatible if it satisfies the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>NP-completeness: There exists a deterministic polynomial-time efficiently invertible function <span class="math">\\mathsf{enc}</span> such that for any arithmetic circuit <span class="math">F</span>, input <span class="math">x</span>, non-deterministic input <span class="math">w</span>, and output <span class="math">y</span>, for structure-instance-witness tuple <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})\\leftarrow\\mathsf{enc}(F,(x,y),w)</span> we have that <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})\\in\\mathcal{R}_{2}^{\\prime}</span> iff <span class="math">F(x,w)=y</span>.</li>

      <li>Partial functions: There exists deterministic, efficiently-invertible polynomial-time functions <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span> and <span class="math">\\mathsf{enc}_{\\mathsf{inst}}</span> such that for any arithmetic circuit <span class="math">F</span>, input <span class="math">x</span>, non-deterministic input <span class="math">w</span>, and output <span class="math">y</span>, for <span class="math">\\mathcal{R}_{1}^{\\prime}</span> and <span class="math">\\mathcal{R}_{2}^{\\prime}</span> structures <span class="math">(\\mathsf{s}_{1},\\mathsf{s}_{2})\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(F)</span> and <span class="math">\\mathcal{R}_{2}^{\\prime}</span> instance <span class="math">\\mathsf{u}\\leftarrow\\mathsf{enc}_{\\mathsf{inst}}((x,y))</span> we have that <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})=\\mathsf{enc}(F,(x,y),w)</span> for some <span class="math">\\mathcal{R}_{2}^{\\prime}</span> witness <span class="math">\\mathsf{w}</span> and that <span class="math">\\mathsf{compat}(\\mathsf{s}_{1},\\mathsf{s}_{2})=1</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Monotonicity: For arithmetic circuits <span class="math">F</span> and <span class="math">G</span>, given $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{enc}_{\\mathsf{str}}(F)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{enc}_{\\mathsf{str}}(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The term </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the total number of gates in </span>F<span class="math"> and the term </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{enc}_{\\mathsf{str}}(F)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the total number of constraints in </span>\\mathsf{enc}_{\\mathsf{str}}(F)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Default instances: There exists <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})</span> such that for any public parameters <span class="math">\\mathsf{pp}</span> and structure <span class="math">\\mathsf{s}</span>, we have that <span class="math">(\\mathsf{pp},\\mathsf{s},\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})\\in\\mathcal{R}_{1}</span>.</li>

    </ol>

    <p class="text-gray-300">Our multi-folding scheme for CCS (Construction 1) is NIVC-compatible.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Lemma 3 (NIVC-compatibility).</h6>

    <p class="text-gray-300">Construction 1 is NIVC-compatible.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">NP-completeness of <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> follows from <em>[60, Lemma 1]</em>, which reduces an NP-complete relation, R1CS, to <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span>. Moreover, a structure, instance, and witness tuple in <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> has enough information to reconstruct the original function <span class="math">F</span> and its inputs and outputs. This implies invertibility of enc. Since CCS generalizes R1CS, we have that that the <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> structure (i.e., constraint matrices) depends only on the function <span class="math">F</span> (and not inputs) and in turn can be used to reconstruct <span class="math">F</span> and that the <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> instance depends only on the public inputs and outputs and can be used to reconstruct these values. This implies the partial function requirement. Moreover, monotonicity holds from the reasoning in <em>Setty et al. [60]</em>. Finally, we have that <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span> has default instances because for any public parameters and structure, we have that <span class="math">(u=0,\\mathsf{x}=\\vec{0},r=0,v_{1}=0,\\ldots,v_{t}=0)</span> and <span class="math">\\widetilde{w}=0</span> is a satisfying instance-witness pair. We provide a formal proof in Appendix H.2. ∎</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">6.3 A compiler from NIVC-compatible folding schemes to NIVC</h3>

    <h6 id="sec-29" class="text-base font-medium mt-4">Construction 2 (NIVC from multi-folding schemes).</h6>

    <p class="text-gray-300">Consider a relation <span class="math">\\mathcal{R}_{1}</span> and a committed relation <span class="math">\\mathcal{R}_{2}</span> for a commitment scheme (Commit, Gen). Let NIFS be an NIVC-compatible non-interactive multi-folding scheme for a single instance of <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span>. Let <span class="math">(\\mathsf{u}_{\\perp},\\mathsf{w}_{\\perp})</span> be a default instance-witness pair for <span class="math">\\mathcal{R}_{1}</span> that satisfies any structure and public parameters. We construct an NIVC scheme as follows.</p>

    <p class="text-gray-300">Consider a deterministic polynomial-time function <span class="math">\\varphi</span> and <span class="math">\\ell</span> polynomial-time functions <span class="math">(F_{1},\\ldots,F_{\\ell})</span> that take non-deterministic input and a cryptographic hash function hash. We first define augmented functions <span class="math">F^{\\prime}_{j}</span> for <span class="math">j\\in[\\ell]</span>, where all input arguments are taken as non-deterministic advice, as follows.</p>

    <p class="text-gray-300"><span class="math">F^{\\prime}_{j}(\\mathsf{vk}_{\\mathsf{fs}},\\mathsf{U}_{i},\\mathsf{u}_{i},\\mathsf{pc}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi)\\to\\mathsf{x}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the next program counter <span class="math">\\mathsf{pc}_{i+1}\\in[\\ell]\\leftarrow\\varphi(z_{i},\\omega_{i})</span>.</li>

      <li>Compute the next output <span class="math">z_{i+1}\\leftarrow F_{j}(z_{i},\\omega_{i})</span>.</li>

      <li>If <span class="math">i=0</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">z_{0}=z_{i}</span> to ensure that the statement holds in the base case.</li>

      <li>Set <span class="math">\\mathsf{U}_{i+1}\\leftarrow(\\mathsf{u}_{\\perp},\\ldots,\\mathsf{u}_{\\perp})</span>.</li>

      <li>Otherwise:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{u}_{i}</span> as <span class="math">(C,\\mathsf{u}^{\\prime}_{i})</span>, a commitment to the witness and the remainder.</li>

      <li>Check that <span class="math">\\mathsf{u}^{\\prime}_{i}</span> references <span class="math">\\mathsf{U}_{i}</span> in the output of the prior iteration:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{u}^{\\prime}_{i}\\stackrel{{\\scriptstyle?}}{{=}}\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{fs}},i,z_{0},z_{i},\\mathsf{U}_{i},\\mathsf{pc}_{i})).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">1\\leq\\mathsf{pc}_{i}\\leq\\ell</span></li>

    </ol>

    <p class="text-gray-300">(d) Copy <span class="math">\\mathsf{U}_{i+1} \\leftarrow \\mathsf{U}_i</span> and update <span class="math">\\mathsf{U}_{i+1}[\\mathsf{pc}_i] \\leftarrow \\mathsf{NIFS}.\\mathcal{V}(\\mathsf{vk}_{\\mathsf{fs}}[\\mathsf{pc}_i], \\mathsf{U}_i[\\mathsf{pc}_i], \\mathsf{u}_i, \\pi)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">x \\gets \\text{hash}(\\mathsf{vk}_{\\mathsf{fs}}, i + 1, z_0, z_{i+1}, \\mathsf{U}_{i+1}, \\mathsf{pc}_{i+1})</span>.</li>

    </ol>

    <p class="text-gray-300">Next, we define the NIVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda},N)\\to \\mathsf{pp}</span>: Output <span class="math">\\mathsf{NIFS}.\\mathcal{G}(1^{\\lambda},N)</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},(\\varphi ,(F_1,\\ldots ,F_\\ell)))\\to (\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{s}_{1,j},\\mathsf{s}_{2,j})\\gets \\mathsf{enc}_{\\mathsf{str}}(F_j^{\\prime})</span> for all <span class="math">j\\in [\\ell]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{fs},j},\\mathsf{vk}_{\\mathsf{fs},j})\\gets \\mathsf{NIFS}.\\mathcal{K}(\\mathsf{pp},\\mathsf{s}_{1,j},\\mathsf{s}_{2,j})</span> for all <span class="math">j\\in [\\ell]</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute and output the prover and verifier keys.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{vk} \\leftarrow (\\mathsf{pp}, (\\mathsf{vk}_{\\mathsf{fs},1}, \\dots, \\mathsf{vk}_{\\mathsf{fs},\\ell}), (\\mathsf{s}_{1,1}, \\dots, \\mathsf{s}_{1,\\ell}), (\\mathsf{s}_{2,1}, \\dots, \\mathsf{s}_{2,\\ell})) \\\\ \\mathsf{pk} \\leftarrow ((\\varphi , (F_1, \\dots , F_\\ell)), (\\mathsf{pk}_{\\mathsf{fs},1}, \\dots, \\mathsf{pk}_{\\mathsf{fs},\\ell}), \\mathsf{vk}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_0,z_i),\\omega_i,\\Pi_i)\\to \\Pi_{i + 1}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_i,\\mathsf{W}_i),(u_i,w_i),\\mathsf{pc}_i)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the next program counter <span class="math">\\mathsf{pc}_{i + 1}\\in [\\ell ]\\gets \\varphi (z_i,\\omega_i)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i = 0</span>: Let <span class="math">(\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1},\\pi)\\gets ((\\mathsf{u}_{\\perp},\\ldots ,\\mathsf{u}_{\\perp}),(\\mathsf{w}_{\\perp},\\ldots ,\\mathsf{w}_{\\perp}),\\bot)</span></li>

    </ol>

    <p class="text-gray-300">Otherwise: Copy <span class="math">\\mathsf{U}_{i + 1}\\gets \\mathsf{U}_i</span> and <span class="math">\\mathsf{W}_{i + 1}\\gets \\mathsf{W}_i</span>, and update</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathrm {U} _ {i + 1} \\left[ \\mathrm {p c} _ {i} \\right], \\mathrm {W} _ {i + 1} \\left[ \\mathrm {p c} _ {i} \\right], \\pi\\right) \\leftarrow \\text {N I F S}. \\mathcal {P} \\left(\\mathrm {p k} \\left[ \\mathrm {p c} _ {i} \\right], \\left(\\mathrm {U} _ {i} \\left[ \\mathrm {p c} _ {i} \\right], \\mathrm {W} _ {i} \\left[ \\mathrm {p c} _ {i} \\right]\\right), \\left(\\mathrm {u} _ {i}, \\mathrm {w} _ {i}\\right)\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the output <span class="math">y \\gets F_{\\mathsf{pc}_{i + 1}}^{\\prime}(\\mathsf{vk}_{\\mathsf{fs}}, \\mathsf{U}_i, \\mathsf{u}_i, \\mathsf{pc}_i, (i, z_0, z_i), \\omega_i, \\pi)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute an instance-witness pair encoding the valid execution of <span class="math">F_{\\mathsf{pc}_{i + 1}}^{\\prime}</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(., u _ {i + 1} ^ {\\prime}, w _ {i + 1}\\right) \\leftarrow \\operatorname {e n c} \\left(F _ {\\mathrm {p c} _ {i + 1}} ^ {\\prime}, (\\bot , y), \\left(v k _ {\\mathrm {f s}}, U _ {i}, u _ {i}, p c _ {i}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\pi\\right)\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the committed instance: <span class="math">\\mathsf{u}_{i + 1}\\gets (\\mathsf{Commit}(\\mathsf{pp},\\mathsf{w}_{i + 1}),\\mathsf{u}_{i + 1}^{\\prime})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\Pi_{i + 1}\\gets ((\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1}),(\\mathsf{u}_{i + 1},\\mathsf{w}_{i + 1}),\\mathsf{pc}_{i + 1})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_0,z_i),\\Pi_i)\\to \\{0,1\\}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i = 0</span>, output 1 if <span class="math">z_{i} = z_{0}</span> and 0 otherwise.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_i,\\mathsf{W}_i),(u_i,w_i),\\mathsf{pc}_i)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{u}_i</span> as <span class="math">(C,\\mathsf{u}_i^{\\prime})</span>. Check that <span class="math">\\mathsf{u}_i^{\\prime} = \\mathsf{enc}_{\\mathrm{inst}}(\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{fs}},i,z_0,z_i,\\mathsf{U}_i,\\mathsf{pc}_i))</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">1 \\leq \\mathsf{pc}_i \\leq \\ell</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check <span class="math">(\\mathsf{pp}, \\mathsf{s}_{1,j}, \\mathsf{U}_i[j], \\mathsf{W}_i[j]) \\in \\mathcal{R}_1</span> for <span class="math">j \\in [\\ell]</span> and <span class="math">(\\mathsf{pp}, \\mathsf{s}_{2,\\mathsf{pc}_i}, \\mathsf{u}_i, \\mathsf{w}_i) \\in \\mathcal{R}_2</span>.</li>

    </ol>

    <p class="text-gray-300">We formally prove the following lemma in Appendix H.3.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Lemma 4 (NIVC from multi-folding schemes).</h6>

    <p class="text-gray-300">Construction 2 takes a NIVC-compatible multi-folding scheme and produces an NIVC scheme.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">To prove knowledge soundness, suppose that we have a malicious prover <span class="math">\\mathcal{P}_{i}^{<em>}</span> that successfully produces a convincing NIVC proof <span class="math">\\Pi_{i}</span> of <span class="math">i</span> iterations with non-negligible probability. Using <span class="math">\\mathcal{P}_{i}^{</em>}</span>, we construct a corresponding extractor <span class="math">\\mathcal{E}_{i-1}</span> which can use this prover to extract a proof <span class="math">\\Pi_{i-1}</span> and the witness <span class="math">\\omega_{i-1}</span> by the knowledge soundness of the underlying multi-folding scheme. This extractor then implies a corresponding prover <span class="math">\\mathcal{P}_{i-1}^{*}</span> which can use this extractor to produce a successful proof <span class="math">\\Pi_{i-1}</span> with non-negligible property. Then, recursively repeating this process, we can derive the full list of witnesses. ∎</p>

    <p class="text-gray-300">Below, we state the concrete efficiency characteristics of HyperNova instantiated with our multi-folding scheme for CCS (Construction 1), which is in turn is instantiated with the Pedersen commitment scheme.</p>

    <p class="text-gray-300">Optimization. As an immediate optimization, we have the verifier circuit inside <span class="math">F_{j}^{\\prime}</span> for <span class="math">j\\in[\\ell]</span> use standard memory checking techniques to verifiably read and write the appropriate running instance into externalized memory rather than directly passing all running instances through each step of <span class="math">F_{j}^{\\prime}</span>. This provides asymptotic improvements: For instance the verifier circuits work is <span class="math">O(\\log\\ell)</span> hashes when using Merkle trees <em>[49, 16]</em>, and <span class="math">O(1)</span> hashes and elliptic curve hash-to-curve and point additions when using a multiset-CRHF-based memory <em>[8, 23, 58]</em>. Then, we have an NIVC scheme with an a-la-carte cost profile, where the cost of each recursive step only scales with the particular function executed at that step.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 3 (HyperNova).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given the multi-folding scheme in Construction 1 instantiated with the Pedersen commitment scheme, Construction 2 produces an NIVC scheme such that for step functions <span class="math">F_{j}</span> for <span class="math">j\\in[\\ell]</span> that can be expressed in CCS with <span class="math">m_{j}</span> constraints of degree <span class="math">d</span> and <span class="math">q_{j}</span> monomials, <span class="math">n_{j}</span> witness variables, <span class="math">t_{j}</span> CCS matrices, and <span class="math">N_{j}</span> non-zero entries in the CCS matrices, and control function <span class="math">\\varphi</span> that can be expressed in CCS with <span class="math">m</span> constraints of degree d and <span class="math">q_{\\varphi}</span> monomials, <span class="math">n_{\\varphi}</span> witness variables, <span class="math">t_{\\varphi}</span> CCS matrices, and <span class="math">N_{\\varphi}</span> non-zero entries in the CCS matrices, the efficiency characteristics are as follows: The NIVC prover time for a step proving the correct execution of <span class="math">F_{j}</span> is a single MSM of size <span class="math">O(n_{\\varphi}+n_{j})</span> and <span class="math">O((N_{\\varphi}+N_{j})+(t_{\\varphi}+t_{j})\\cdot(m_{\\varphi}+m_{j})+(q_{\\varphi}+q_{j})\\cdot(m_{\\varphi}+m_{j})\\cdot d\\cdot\\log^{2}d)</span> finite field operations. The verifier circuit size is $o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1\\cdot\\mathsf{G}+2\\cdot\\mathsf{H}_{\\ell,t_{j}}+d\\cdot\\log m_{j}\\cdot\\mathsf{F}+\\log m_{j}\\cdot\\mathsf{R}_{d}+2\\cdot\\mathsf{M})<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the size of the constraint system for encoding </span>\\varphi<span class="math"> in the verifier circuit, </span>\\mathsf{G}<span class="math"> is the number of constraints required to encode a group scalar multiplication, </span>\\mathsf{H}_{\\ell,t_{j}}<span class="math"> is the number of constraints required to encode </span>\\mathsf{hash}<span class="math"> (which depends on </span>\\ell<span class="math"> and </span>t_{j}<span class="math">), </span>\\mathsf{F}<span class="math"> is the number of constraints to encode field operations, </span>\\mathsf{R}_{d}<span class="math"> is the number of constraints to encode the RO </span>\\rho<span class="math">, and </span>\\mathsf{M}<span class="math"> is the number of constraints to encode to memory read/write over </span>O(\\ell)$ elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The prover time complexity follows from Theorem 1. As for the verifier circuit size, on input instances <span class="math">\\mathsf{U}</span> and <span class="math">\\mathsf{u}</span>, <span class="math">\\mathsf{NIFS.V}</span> computes <span class="math">\\mathsf{U}.C\\leftarrow\\mathsf{U}.C+\\rho\\cdot u.C</span></p>

    <p class="text-gray-300">which costs a single group scalar multiplication. Verifying the non-interactive sum-check proof in the non-interactive multi-folding scheme proof requires the verifier to perform <span class="math">O(d\\cdot\\log m_{\\varphi}+m_{j})</span> finite field operations and <span class="math">O(\\log m_{\\varphi}+m_{j})</span> calls to the RO to obtain challenges in the sum-check protocol. By construction, the verifier circuit calls <span class="math">\\varphi</span> once and makes two additional calls to hash. Finally, two memory operations are required to read and write a running instance. ∎</p>

    <h2 id="sec-34" class="text-2xl font-bold">7 HyperNova’s zero-knowledge and succinctness layer</h2>

    <p class="text-gray-300">In HyperNova, NIVC proofs are linear in the sizes of circuits for each supported function and may reveal information about the secret witnesses in each step of execution. This section describes how to provide a zero-knowledge argument of a valid NIVC proof. Formally, our goal is to design a zero-knowledge argument (Definition 23) for the following relation. We achieve this without employing zkSNARKs (solving the problem motivated earlier in Section 1.2). For additional succinctness, one can employ a non-zk SNARK.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 13 (Proof of Valid NIVC Proof)</h6>

    <p class="text-gray-300">Let NIVC denote the NIVC scheme described in Construction 2. We define the relation <span class="math">\\mathcal{R}_{\\mathsf{VNIVC}}</span> over public parameter, structure, instance, and witness tuples as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{VNIVC}}=\\left\\{\\left.\\left(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi),(i,z_{0},z_{i}),\\Pi\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{l}\\mathsf{vk}\\leftarrow\\mathsf{NIVC}.\\mathcal{K}(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi)),\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{NIVC}.\\mathcal{V}(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi)=1\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Recall that an NIVC proof consists of running instances <span class="math">\\mathsf{U}</span> and the corresponding witnesses <span class="math">\\mathsf{W}</span>, the latest instance <span class="math">\\mathsf{u}</span> and the corresponding witness <span class="math">\\mathsf{w}</span>, and the latest index <span class="math">\\mathsf{pc}</span>. To check a statement <span class="math">(i,z_{0},z_{i})</span>, the NIVC verifier checks the list of running instances <span class="math">\\mathsf{U}</span> against witnesses <span class="math">\\mathsf{W}</span>, checks the latest instance <span class="math">\\mathsf{u}</span> against witness <span class="math">\\mathsf{w}</span> with respect to <span class="math">F^{\\prime}_{\\mathsf{pc}}</span>, and checks that <span class="math">\\mathsf{u}</span> references <span class="math">(i,z_{0},z_{i})</span> and <span class="math">\\mathsf{U}</span>.</p>

    <p class="text-gray-300">A straw-man solution is to simply run a zkSNARK proving that the NIVC verifier accepts some proof <span class="math">\\Pi</span> with respect to a prescribed verifier key <span class="math">\\mathsf{vk}</span>. However, this is prohibitively expensive, as it would involve a universal circuit that checks all running instance-witness pairs internally (including the task of checking if the provided witnesses are valid openings of commitments in the instances). Also, as noted in Section 1.2, this entails significant verifier costs in some settings.</p>

    <p class="text-gray-300">Achieving zero-knowledge. To avoid zkSNARKs, our central idea is to instead <em>rerandomize</em> an NIVC proof using a much more efficient folding scheme.</p>

    <p class="text-gray-300">We formalize this construction and prove its properties in Appendix D (Construction 6). Here, we provide an overview.</p>

    <p class="text-gray-300">To ensure that an NIVC proof <span class="math">\\Pi</span> does not reveal any secret information, the prover does the following: First, to hide the last instruction <span class="math">\\mathsf{pc}</span>, the prover verifiably folds <span class="math">(\\mathsf{u},\\mathsf{w})</span> into <span class="math">(\\mathsf{U}[\\mathsf{pc}],\\mathsf{W}[\\mathsf{pc}])</span> without revealing any of the involved terms. Next, the prover verifiably folds in randomized instances <span class="math">(\\mathsf{U}_{\\mathsf{r}},\\mathsf{W}_{\\mathsf{r}})</span> into <span class="math">(\\mathsf{U},\\mathsf{W})</span> to produce a new set of randomized running instances <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span>, that reveal</p>

    <p class="text-gray-300">no information about <span class="math">(\\mathsf{U},\\mathsf{W})</span> or <span class="math">(\\mathsf{U}_{\\mathsf{r}},\\mathsf{W}_{\\mathsf{r}})</span>, but can be checked in place of the original instance-witness pairs. Finally, the prover produces a randomized proof, which consists of <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span> along with proofs of correct folding.</p>

    <p class="text-gray-300">The central challenge with the above strategy is that the prover must verifiably fold the instance-witness pairs in the first two steps without revealing any information about the randomizing instances (and corresponding witnesses) to the verifier. Due to this constraint, the prover cannot directly engage in a folding scheme with the verifier. Instead, the prover executes the verifier’s end of the folding scheme in an auxiliary circuit <span class="math">\\mathsf{blind}</span> which takes as secret input <span class="math">(\\mathsf{u},\\mathsf{U},\\mathsf{pc})</span> and randomized instances <span class="math">\\mathsf{U}_{\\mathsf{r}}</span>. <span class="math">\\mathsf{blind}</span> performs the standard checks on <span class="math">\\mathsf{u}</span> before folding in <span class="math">\\mathsf{u}</span> into <span class="math">\\mathsf{U}[\\mathsf{pc}]</span> and then folds each of the randomized instances <span class="math">\\mathsf{U}_{\\mathsf{r}}</span> into <span class="math">\\mathsf{U}</span> to produce and output the randomized running instances <span class="math">\\mathsf{U}^{\\prime}</span>. The prover then produces a corresponding instance-witness pair <span class="math">(\\mathsf{u}_{\\mathsf{blind}},\\mathsf{w}_{\\mathsf{blind}})</span> that attests to the correct execution of the blind circuit itself.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">If we are interested in randomizing an IVC proof, specifically Nova’s IVC proof, as opposed to an NIVC proof, then the blind circuit can be avoided as there is no need to hide <span class="math">\\mathsf{pc}</span>. We describe this idea further in Appendix D.4.</p>

    <p class="text-gray-300">Several problems remain. First, we must ensure that there actually exists a method to sample <span class="math">(\\mathsf{U}_{\\mathsf{r}},\\mathsf{W}_{\\mathsf{r}})</span>. Moreover, we must ensure that the folding scheme used to randomize <span class="math">(\\mathsf{U},\\mathsf{W})</span> satisfies the following property: Given one of the input instance-witness pairs is randomly sampled, we must have that the output folded instance-witness pair is indistinguishable from random. We refer to a folding scheme that satisfies this property as a <em>randomizing folding scheme</em> (Definition 28) and argue that the folding scheme for committed CCS is randomizing (Lemma 8). Then, we can ensure that <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span> reveals no information.</p>

    <p class="text-gray-300">Second, the prover cannot directly reveal the instance-witness pair <span class="math">(\\mathsf{u}_{\\mathsf{blind}},\\mathsf{w}_{\\mathsf{blind}})</span> attesting to the correct execution of <span class="math">\\mathsf{blind}</span> as <span class="math">\\mathsf{w}_{\\mathsf{blind}}</span> will implicitly contain <span class="math">\\mathsf{pc}</span> and several other sensitive terms. Seemingly, we can use a randomizing folding scheme again, where the prover samples <span class="math">(\\mathsf{u}_{\\mathsf{rb}},\\mathsf{w}_{\\mathsf{rb}})</span> folds it into <span class="math">(\\mathsf{u}_{\\mathsf{blind}},\\mathsf{w}_{\\mathsf{blind}})</span> and only reveals the randomized instance-witness pair <span class="math">(\\mathsf{u}^{\\prime}_{\\mathsf{blind}},\\mathsf{w}^{\\prime}_{\\mathsf{blind}})</span> as well as an (interactive) proof of correct folding <span class="math">\\pi_{\\mathsf{blind}}</span>. However, this may not be sufficient because <span class="math">\\pi_{\\mathsf{blind}}</span> may itself reveal information about <span class="math">\\mathsf{w}_{\\mathsf{blind}}</span> even if <span class="math">(\\mathsf{u}^{\\prime}_{\\mathsf{blind}},\\mathsf{w}^{\\prime}_{\\mathsf{blind}})</span> does not. To account for this, we require a folding scheme with a slightly stronger property, in which the transcript (and output) can be simulated so long as one of the inputs is random. We refer to a folding scheme that satisfies this stronger property as a <em>hiding folding scheme</em>. Unfortunately, the folding scheme for committed CCS, as presented, is not a hiding folding scheme as the interaction may reveal information about the witness. To remedy this, we instead use the folding scheme underlying Nova, which we demonstrate satisfies the required hiding property. Then, we can ensure that <span class="math">(\\mathsf{u}^{\\prime}_{\\mathsf{blind}},\\mathsf{w}^{\\prime}_{\\mathsf{blind}})</span> and <span class="math">\\pi_{\\mathsf{blind}}</span> reveal no information about <span class="math">\\mathsf{w}_{\\mathsf{blind}}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The use of Nova’s folding scheme rather than HyperNova’s in the zero-knowledge layer does not pose efficiency problems: the zero-knowledge layer is applied only once in the “end” before externalizing NIVC proofs. Furthermore, the work performed inside blind consists only of the folding scheme verifier (which is quite efficient to represent in R1CS, the computational model of Nova’s folding scheme).</p>

    <p class="text-gray-300">Altogether, the prover’s final blinded proof consists of the blinded running instance-witness pairs <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span>, an instance <span class="math">\\mathsf{u}_{\\mathsf{blind}}</span> attesting to the correct execution of <span class="math">\\mathsf{blind}</span>, a randomized instance-witness pair <span class="math">(\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\mathsf{w}_{\\mathsf{blind}}^{\\prime})</span>, and an (interactive) proof <span class="math">\\pi_{\\mathsf{blind}}</span> attesting that checking <span class="math">(\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\mathsf{w}_{\\mathsf{blind}}^{\\prime})</span> implies checking <span class="math">\\mathsf{u}_{\\mathsf{blind}}</span>.</p>

    <p class="text-gray-300">Achieving non-interactivity and succinctness. Appendix D demonstrates that the above construction is <em>honest-verifier</em> zero-knowledge (i.e., zero-knowledge only if the verifier behaves honestly in the interaction). One can heuristically make it zero-knowledge and non-interactive by employing the Fiat-Shamir transformation in a standard manner.</p>

    <p class="text-gray-300">For some applications, further succinctness may be required. In such a situation, the prover can succinctly prove the knowledge of a randomized proof <span class="math">((\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime}),\\mathsf{u}_{\\mathsf{blind}},(\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\mathsf{w}_{\\mathsf{blind}}^{\\prime}),\\pi_{\\mathsf{blind}})</span> by using a SNARK to prove each instance in <span class="math">\\mathsf{U}^{\\prime}</span> and <span class="math">\\mathsf{u}_{\\mathsf{blind}}^{\\prime}</span>. This is sufficient as the remainder of the blinded proof is constant-sized. This approach of randomizing first, then adding a succinctness layer affords two benefits. First, there is no need to use a <em>zero-knowledge</em> SNARK as the randomizing step ensures that the randomized proof reveals no sensitive information. Second, this SNARK can be independently used on each of the instances in the randomized proof, as opposed to a universal circuit. This avoids having to simulate the SNARK verifier inside a circuit.</p>

    <h2 id="sec-37" class="text-2xl font-bold">8 HyperNova over a two-cycle of curves with CycleFold</h2>

    <p class="text-gray-300">This section describes how to instantiate HyperNova over a cycle of elliptic curves, which unlocks a concretely-efficient construction that can be implemented. We motivate a cycle of elliptic curves below, but we refer to prior works <em>[4, 52]</em> for more details. We focus on HyperNova, but our approach is generic and applies to other folding-scheme-based IVC schemes. It also improves upon prior approach that was proposed in the context of SNARK-based IVC <em>[4]</em>.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">8.1 Prior approaches and downsides of using them for HyperNova</h3>

    <p class="text-gray-300">We first recall the 2-cycle approach to instantiate SNARK-based recursive arguments in <em>[4]</em>. We then describe how an implementation of Nova <em>[1, 52]</em> adapts this approach to the context of folding-scheme-based recursive arguments.</p>

    <p class="text-gray-300">The 2-cycle approach in <em>[4]</em>. The starting point for <em>[4]</em> is a pairing-based SNARK (e.g., <em>[54, 5]</em>) instantiated over a pairing-friendly elliptic curve <span class="math">E</span>. The proof system can prove constraint systems defined over <span class="math">E</span>’s scalar field. Furthermore, verifying a proof requires a handful of pairing operations, which are naturally represented as operations over <span class="math">E</span>’s base field.</p>

    <p class="text-gray-300">Let <span class="math">(\\varPi_1,\\varPi_2)</span> denote two SNARK schemes (such as [54,5]) defined respectively over <span class="math">(E_1,E_2)</span>. In particular, <span class="math">\\varPi_1</span> can "natively" (i.e., without field emulation) prove constraint systems (e.g., R1CS) defined over the scalar field of <span class="math">E_{1}</span> and <span class="math">\\varPi_{2}</span> can prove constraint systems defined over the scalar field of <span class="math">E_{2}</span>. Naturally, proofs produced by <span class="math">\\varPi_{1}</span> can be efficiently verified by a constraint system supported by <span class="math">\\varPi_{2}</span> and vice versa. This is because the algorithm to verify proofs produced by <span class="math">\\varPi_{1}</span> involves operations over <span class="math">E_{1}</span>'s base field, which, by design, equals the scalar field of <span class="math">E_{2}</span>. (When the fields do not match, one would need to emulate arithmetic of the desired field using another field, which entails significant costs in terms of the number of gates necessary to perform basic operations such as additions and multiplications over the desired field.) In other words, the constraint system supported by <span class="math">\\varPi_{2}</span> can efficiently encode the SNARK verifier of <span class="math">\\varPi_{1}</span>.</p>

    <p class="text-gray-300">To realize IVC, at step <span class="math">i</span>, in [4], the prover proceeds as follows (for ease of exposition, we ignore the base case of <span class="math">i = 0</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Using <span class="math">\\varPi_{1}</span>, the prover produces a SNARK <span class="math">\\pi_i^{(1)}</span> that proves that it has executed the step <span class="math">i</span> of the desired computation and has successfully verified a SNARK <span class="math">\\pi_{i-1}^{(2)}</span> from step <span class="math">i - 1</span>.</li>

      <li>Using <span class="math">\\varPi_{2}</span>, the prover produces a SNARK <span class="math">\\pi_i^{(2)}</span> that it knows a SNARK <span class="math">\\pi_i^{(1)}</span> and has successfully verified it.</li>

    </ol>

    <p class="text-gray-300">Note that <span class="math">\\pi_i^{(2)}</span> is the IVC proof at the end of step <span class="math">i</span>. At step <span class="math">i + 1</span>, the prover starts with <span class="math">\\pi_i^{(2)}</span> and repeats the above procedure for the <span class="math">(i + 1)</span>th step of the computation. A key take-away is that this approach requires representing the SNARK verifier as a circuit on both curves in the cycle.</p>

    <p class="text-gray-300">Nova's instantiation over a 2-cycle of elliptic curves. The Nova library [1] adapts [4]'s blueprint to the context of folding schemes, and obtains a concretely-efficient implementation of Nova [43]. Its approach is to essentially replace "SNARK verifier" with a "non-interactive folding scheme verifier". Specifically, an NP instance defined over the scalar field of the first curve can be efficiently folded using a circuit defined over the scalar field of the second curve and vice versa. Different from [4], Nova's IVC proof is a set of instances and witnesses defined over both curves in the cycle rather than a single SNARK. Nova additionally uses the public IO of circuits to track folded NP instances. A recent work [52] provides a detailed description of Nova's instantiation on a 2-cycle of elliptic curves and proves its security. This work also exposes a vulnerability in the original implementation (which is now fixed). Overall, Nova's approach, like in [4], still requires representing a verifier (which happens to be the non-interactive folding scheme verifier) as a circuit on both curves in the cycle of curves. For Nova [43],</p>

    <p class="text-gray-300">6 [4] uses cycles of elliptic curves where both curves are pairing-friendly as they use pairing-based SNARKs to realize IVC. Unfortunately, such cycles of pairing-friendly elliptic curves require field sizes to be much larger than ordinary elliptic curves to achieve a "standard" 128 bits of security.</p>

    <p class="text-gray-300">which provides the most efficient folding scheme verifier in the literature, the circuit defined over the second curve in the cycle is <span class="math">\\approx</span>10,000 multiplication gates.</p>

    <p class="text-gray-300">Additional downsides in the context of HyperNova. If the approach in Nova’s implementation <em>[1, 52]</em> is applied to HyperNova to instantiate HyperNova over a 2-cycle of elliptic curves, it requires significant non-native arithmetic. In particular, HyperNova’s verifier circuit on the scalar field of <span class="math">E_{2}</span> must verify a sum-check proof produced on the scalar field of <span class="math">E_{1}</span>. This involves representing operations over the scalar field of <span class="math">E_{1}</span> in a circuit defined over the scalar field of <span class="math">E_{2}</span>. Since the two scalar fields are different, this would require field emulation, which is concretely expensive (e.g., thousands of constraints for each field multiplication and verifying a sum-check proof requires <span class="math">O(d\\cdot\\log m)</span> field operations).</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">8.2 CycleFold’s approach</h3>

    <p class="text-gray-300">CycleFold’s starting point is the observation that folding-scheme-based recursive arguments (e.g., Nova, HyperNova) can be efficiently instantiated <em>without</em> a cycle of elliptic curves—except for a few elliptic scalar multiplication operations (2 in Nova, 1 in HyperNova) in their verifier circuits that must be handled with “wrong” field arithmetic (or non-native arithmetic). We further observe that this scalar multiplication operation can be <em>verifiably delegated</em> to the second curve with the following approach. We first represent the desired scalar multiplication operation as a circuit over the scalar field of the second curve. Crucially, this avoids non-native arithmetic for computing the scalar multiplication operation (as there is no need for field emulation). Then, by employing Nova’s folding scheme verifier on the first curve, we fold that scalar multiplication circuit satisfiability instance into a running instance. Figure 1 depicts CycleFold’s approach.</p>

    <p class="text-gray-300">Note that CycleFold can be viewed as employing a cycle of elliptic curves at a <em>different</em> level of abstraction than <em>[4]</em> or its adaptation in Nova <em>[43, 1, 52]</em>. Specifically, with CycleFold, the cycle of elliptic curves is used at the level of a folding scheme. In particular, the specific way the cycle of elliptic curves is used ensures that the folding scheme verifier <em>can</em> be efficiently represented as a circuit with a <em>single</em> curve in the cycle. Accordingly, the resulting IVC scheme nor its proof of security has to reason about the cycle of elliptic curves. Indeed, when we apply CycleFold to HyperNova, we apply it at the level of a folding scheme.</p>

    <p class="text-gray-300">A preliminary design. CycleFold employs a 2-cycle of curves <span class="math">(E_{1},E_{2})</span>, but it instantiates a folding-scheme-based recursive argument as if there is only a <em>single</em> elliptic curve <span class="math">E_{1}</span>. This means that the folding-scheme verifier is represented as a circuit, say <span class="math">C_{\\mathsf{V}}</span>, on the scalar field of <span class="math">E_{1}</span>. For the case of HyperNova, <span class="math">C_{\\mathsf{V}}</span> performs finite field and hash operations, and a <em>single</em> scalar multiplication (more precisely, a scalar multiplication followed by a point addition). The finite field and hashing operations in <span class="math">C_{\\mathsf{V}}</span> are over <span class="math">E_{1}</span>’s scalar field so they are represented efficiently in <span class="math">E_{1}</span>’s scalar field. However, the scalar multiplication and point addition operations require arithmetic over <span class="math">E_{1}</span>’s base field. Naively, one can perform those operations with non-native arithmetic inside <span class="math">C_{\\mathsf{V}}</span>. Unfortunately, this strategy will result in <span class="math">C_{\\mathsf{V}}</span> containing a million multiplication gates or more.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Two incremental steps in HyperNova's recursive argument instantiated with CycleFold.  <span class="math">\\mathsf{u}_i</span>  attests to the computation at step  <span class="math">i</span>  and  <span class="math">\\mathsf{U}_i</span>  attests to all prior steps of the computation.  <span class="math">\\mathsf{U}_{\\mathsf{EC},i}</span>  attests to all prior steps of the outsourced elliptic curve operations.  <span class="math">C_{\\mathsf{EC}}</span>  is a circuit which computes the outsourced elliptic curve operations on  <span class="math">E_2</span> .  <span class="math">\\mathsf{u}_i</span>  and  <span class="math">\\mathsf{U}_i</span>  are parsed to retrieve inputs for circuit  <span class="math">C_{\\mathsf{EC}}</span>  (represented with a dotted line).  <span class="math">\\mathsf{u}_{\\mathsf{EC},i}</span>  represents the correct execution of  <span class="math">C_{\\mathsf{EC}}</span> . The main computation on each step additionally runs the HyperNova folding scheme verifier (which folds claims regarding the main computation) by taking as auxiliary advice the result of the elliptic curve operation (read from  <span class="math">\\mathsf{u}_{\\mathsf{EC},i}</span> ). The main computation additionally runs the Nova folding scheme verifier which folds claims about the outsourced elliptic curve operation.  <span class="math">\\mathsf{u}_{i+1}</span>  represents the correctness of the latest step and  <span class="math">(\\mathsf{U}_i, \\mathsf{U}_{\\mathsf{EC},i})</span>  represents the correctness of all prior steps and outsourced computations.</p>

    <p class="text-gray-300">We now discuss how CycleFold avoids the non-native arithmetic to compute a scalar multiplication and a point addition—without using the 2-cycle approach of [4] or its adaptation in Nova [43,1,52].</p>

    <p class="text-gray-300">A "co-processor" circuit over the scalar field of  <span class="math">\\mathbf{E}_2</span> . CycleFold creates a circuit  <span class="math">C_{\\mathsf{EC}}</span>  defined over the scalar field of the second curve in the cycle  <span class="math">E_2</span>  (e.g., on Grumpkin).  <span class="math">C_{\\mathsf{EC}}</span>  performs the desired scalar multiplication and a point addition operation. Furthermore, the public IO of  <span class="math">C_{\\mathsf{EC}}</span>  contains the inputs and outputs of the scalar multiplication and point addition operation. Since  <span class="math">C_{\\mathsf{EC}}</span>  is defined over the scalar field of  <span class="math">E_2</span> , which is the base field of  <span class="math">E_1</span>  since  <span class="math">(E_1,E_2)</span>  is a 2-cycle of elliptic curves. As a result,  <span class="math">C_{\\mathsf{EC}}</span>  does not require non-native arithmetic to compute the desired scalar multiplication and point addition. In particular, the size  <span class="math">C_{\\mathsf{EC}}</span>  is concretely small (e.g., with  <span class="math">\\approx 1,000 - 1,500</span>  multiplication gates).</p>

    <p class="text-gray-300">Closing the loop. Instead of performing a scalar multiplication and a point addition with non-native arithmetic (which as noted above is untenable), the verifier circuit  <span class="math">C_{\\mathbf{V}}</span>  takes as non-deterministic input, among other things, a circuit</p>

    <p class="text-gray-300">satisfiability instance <span class="math">u_{\\mathsf{EC}}</span> (i.e., the public IO and a commitment to a purported satisfying witness to an instance of <span class="math">C_{\\mathsf{EC}}</span>). In addition to performing the rest of folding scheme verifier’s work, <span class="math">C_{\\mathsf{V}}</span> consumes the claimed output from the public IO of <span class="math">u_{\\mathsf{EC}}</span> after checking that inputs to <span class="math">C_{\\mathsf{EC}}</span> match its desired inputs. <span class="math">C_{\\mathsf{V}}</span> then folds <span class="math">u_{\\mathsf{EC}}</span> into a running instance, using Nova’s folding scheme.</p>

    <p class="text-gray-300">Appendix E provides a formal construction of HyperNova over a cycle of elliptic curves and proves its correctness. We summarize our result with the following theorem. For simplicity, we formalize the case folding a single fresh instance into a single running instance. However, our construction naturally generalizes to an arbitrary number of instances, as in Construction 1.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 4 (A multi-folding scheme for CCS over cycles).</h6>

    <p class="text-gray-300">Construction 7 is a public-coin multi-folding scheme for <span class="math">(\\mathcal{R}_{1}=\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{2}=\\mathcal{R}_{\\mathsf{CCCS}},\\mathsf{compat},\\mu=1,\\nu=1)</span> with perfect completeness and knowledge soundness. For a CCS instance with <span class="math">m</span> constraints of degree <span class="math">d</span> and <span class="math">q</span> monomials, <span class="math">n</span> witness variables, <span class="math">t</span> CCS matrices, and <span class="math">N</span> non-zero entries in CCS matrices, and a linearized CCS instance with the same structure, the efficiency characteristics are as follows: The prover time is <span class="math">O(N+t\\cdot m+q\\cdot m\\cdot d\\cdot\\log^{2}d)</span> finite field operations and <span class="math">O(1)</span> group operations. The verifier time is <span class="math">O(d\\cdot\\log m)</span> finite field operations and <span class="math">O(1)</span> group operations. The communication complexity is <span class="math">O(d\\cdot\\log m)</span> finite field elements.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">Completeness, knowledge-soundness, and efficiency hold by similar reasoning as the proof of Theorem 1 and the properties of the folding scheme for relaxed R1CS <em>[43]</em>. We provide a formal proof in Appendix H.4 ∎</p>

    <p class="text-gray-300">By leveraging Construction 7 made non-interactive in the plain model via the Fiat-Shamir transformation (Construction 3), we get Theorem 2, which follows from <em>[43, Lemma 4]</em> and Theorem 4.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">Acknowledgments</h3>

    <p class="text-gray-300">We thank Justin Drake, Ariel Gabizon, Bryan Parno, Carlos Pérez, Drew Stone, Justin Thaler, Ioanna Tzialla, and the anonymous CRYPTO and Eurocrypt reviewers for helpful conversations and comments on a prior version of this paper. We thank Tohru Kohrita for pointing out a discrepancy in an earlier version of the knowledge soundness definition for NIVC. We thank Binyi Chen for noticing an unnecessary step in the knowledge soundness proof of our multi-folding scheme. We thank Wilson Nguyen for pointing out an issue with the simulator’s description in an earlier version of the proof of Lemma 9. While at Carnegie Mellon University, Abhiram Kothapalli was supported by a fellowship from Protocol Labs, NSF Grant No. 1801369 and 190099, and by the CONIX Research Center, one of six centers in JUMP, a Semiconductor Research Corporation (SRC) program sponsored by DARPA.</p>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Nova: Recursive SNARKs without trusted setup. https://github.com/Microsoft/Nova</li>

      <li>[2] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E.: Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: Extended abstract. In: ITCS (2013)</li>

      <li>[3] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: Verifying program executions succinctly and in zero knowledge. In: CRYPTO (Aug 2013)</li>

      <li>[4] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. In: CRYPTO (2014)</li>

      <li>[5] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Succinct non-interactive zero knowledge for a von Neumann architecture. In: USENIX Security (2014)</li>

      <li>[6] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: ITCS (2012)</li>

      <li>[7] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for SNARKs and proof-carrying data. In: STOC (2013)</li>

      <li>[8] Blum, M., Evans, W., Gemmell, P., Kannan, S., Naor, M.: Checking the correctness of memories. In: FOCS (1991)</li>

      <li>[9] Boneh, D., Bünz, B., Fisch, B.: A survey of two verifiable delay functions. Cryptology ePrint Archive, Report 2018/712 (2018)</li>

      <li>[10] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Halo Infinite: Recursive zk-SNARKs from any Additive Polynomial Commitment Scheme. In: CRYPTO (2021)</li>

      <li>[11] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: EUROCRYPT (2016)</li>

      <li>[12] Bootle, J., Chiesa, A., Hu, Y., Orrú, M.: Gemini: Elastic snarks for diverse environments. In: Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 427–457 (2022)</li>

      <li>[13] Bowe, S., Grigg, J., Hopwood, D.: Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021 (2019)</li>

      <li>[14] Bowe, S., Grigg, J., Hopwood, D.: Halo2 (2020), https://github.com/zcash/halo2</li>

      <li>[15] Braun, B.: Compiling computations to constraints for verified computation. Tech. rep., UT Austin Honors thesis HR-12-10 (Dec 2012)</li>

      <li>[16] Braun, B., Feldman, A.J., Ren, Z., Setty, S., Blumberg, A.J., Walfish, M.: Verifying computations with state. In: SOSP (2013)</li>

      <li>[17] Bünz, B., Chen, B.: Protostar: Generic efficient accumulation/folding for special sound protocols. Cryptology ePrint Archive, Paper 2023/620 (2023)</li>

      <li>[18] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: CRYPTO (2021)</li>

      <li>[19] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Proof-carrying data from accumulation schemes. In: TCC (2020)</li>

      <li>[20] Chen, B., Bünz, B., Boneh, D., Zhang, Z.: Hyperplonk: Plonk with linear-time prover and high-degree custom gates. In: EUROCRYPT (2023)</li>

      <li>[21] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In: EUROCRYPT (2020)</li>

      <li>[22] Chiesa, A., Tromer, E.: Proof-carrying data and hearsay arguments from signature cards. In: Innovations in Computer Science (ICS) (2010)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Clarke, D., Devadas, S., Dijk, M.V., Gassend, B., Edward, G., Mit, S.: Incremental multiset hash functions and their application to memory integrity checking. In: ASIACRYPT (2003)</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>24. Cormode, G., Mitzenmacher, M., Thaler, J.: Practical verified computation with streaming interactive proofs. In: ITCS (2012)</li>

      <li>25. Cramer, R., Damgård, I.: Zero-knowledge proofs for finite field arithmetic, or: Can zero-knowledge be for free? In: CRYPTO. pp. 424–441 (1998)</li>

      <li>26. Eagen, L., Fiore, D., Gabizon, A.: cq: Cached quotients for fast lookups. Cryptology ePrint Archive (2022)</li>

      <li>27. Eagen, L., Gabizon, A.: Protogalaxy: Efficient protostar-style folding of multiple instances. Cryptology ePrint Archive, Paper 2023/1106 (2023)</li>

      <li>28. Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: CRYPTO. pp. 186–194 (1986)</li>

      <li>29. Gabizon, A., Williamson, Z.J.: plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive (2020)</li>

      <li>30. Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. ePrint Report 2019/953 (2019)</li>

      <li>31. Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: EUROCRYPT (2013)</li>

      <li>32. Gentry, C., Wichs, D.: Separating succinct non-interactive arguments from all falsifiable assumptions. In: STOC. pp. 99–108 (2011)</li>

      <li>33. Goldberg, L., Papini, S., Riabzev, M.: Cairo – a Turing-complete STARK-friendly CPU architecture. Cryptology ePrint Archive (2021)</li>

      <li>34. Groth, J.: On the size of pairing-based non-interactive arguments. In: EUROCRYPT (2016)</li>

      <li>35. Haböck, U.: Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive (2022)</li>

      <li>36. Khovratovich, D., Maller, M., Tiwari, P.R.: MinRoot: candidate sequential function for Ethereum VDF. Cryptology ePrint Archive, Paper 2022/1626 (2022)</li>

      <li>37. Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: STOC (1992)</li>

      <li>38. Kosba, A., Papadopoulos, D., Papamanthou, C., Song, D.: MIRAGE: succinct arguments for randomized algorithms with applications to universal zk-SNARKs. In: USENIX Security (2020)</li>

      <li>39. Kothapalli, A., Parno, B.: Algebraic reductions of knowledge. In: CRYPTO (2023)</li>

      <li>40. Kothapalli, A., Setty, S.: SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive (2022)</li>

      <li>41. Kothapalli, A., Setty, S.: CycleFold: CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Paper 2023/1192 (2023)</li>

      <li>42. Kothapalli, A., Setty, S.: HyperNova: Recursive arguments for customizable constraint systems. In: CRYPTO (2024)</li>

      <li>43. Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive Zero-Knowledge Arguments from Folding Schemes. In: CRYPTO (2022)</li>

      <li>44. Labs, O.: Mina cryptocurrency (2020), https://minaprotocol.com</li>

      <li>45. Lee, J., Nikitin, K., Setty, S.: Replicated state machines without replicated execution. In: S&P (2020)</li>

      <li>46. Lund, C., Fortnow, L., Karloff, H., Nisan, N.: Algebraic methods for interactive proof systems. In: FOCS (Oct 1990)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lurk: https://github.com/lurk-lang</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>48. Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge SNARKs from linear-size universal and updateable structured reference strings. In: CCS (2019)</li>

      <li>49. Merkle, R.C.: A digital signature based on a conventional encryption function. In: CRYPTO (1988)</li>

      <li>50. Micali, S.: CS proofs. In: FOCS (1994)</li>

      <li>51. Mohnblatt, N.: Sangria: a folding scheme for PLONK. https://geometry.xyz/notebook/sangria-a-folding-scheme-for-plonk (2023)</li>

      <li>52. Nguyen, W., Boneh, D., Setty, S.: Revisiting the Nova proof system on a cycle of curves. Cryptology ePrint Archive, Paper 2023/969 (2023)</li>

      <li>53. Ozdemir, A., Wahby, R.S., Boneh, D.: Scaling verifiable computation using efficient set accumulators. In: USENIX Security (2020)</li>

      <li>54. Parno, B., Gentry, C., Howell, J., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: S&P (May 2013)</li>

      <li>55. RISC ZERO: https://www.risczero.com/</li>

      <li>56. Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. J. ACM 27(4) (1980)</li>

      <li>57. Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: CRYPTO (2020)</li>

      <li>58. Setty, S., Angel, S., Gupta, T., Lee, J.: Proving the correct execution of concurrent services in zero-knowledge. In: OSDI (Oct 2018)</li>

      <li>59. Setty, S., Braun, B., Vu, V., Blumberg, A.J., Parno, B., Walfish, M.: Resolving the conflict between generality and plausibility in verified computation. In: EuroSys (Apr 2013)</li>

      <li>60. Setty, S., Thaler, J., Wahby, R.: Customizable constraint systems for succinct arguments. Cryptology ePrint Archive (2023)</li>

      <li>61. Setty, S., Thaler, J., Wahby, R.: Unlocking the lookup singularity with lasso. In: EUROCRYPT (2024)</li>

      <li>62. Setty, S., Vu, V., Panpalia, N., Braun, B., Blumberg, A.J., Walfish, M.: Taking proof-based verified computation a few steps closer to practicality. In: USENIX Security (Aug 2012)</li>

      <li>63. Solberg, T.: A brief history of lookup arguments. https://github.com/ingonyama-zk/papers/blob/main/lookups.pdf (2023)</li>

      <li>64. Thaler, J.: Time-optimal interactive proofs for circuit evaluation. In: CRYPTO (2013)</li>

      <li>65. Thaler, J.: Proofs, arguments, and zero-knowledge. http://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.html (2020)</li>

      <li>66. Valiant, P.: Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In: TCC. pp. 552–576 (2008)</li>

      <li>67. Vu, V., Setty, S., Blumberg, A.J., Walfish, M.: A hybrid architecture for verifiable computation. In: S&P (2013)</li>

      <li>68. Wahby, R.S., Setty, S., Ren, Z., Blumberg, A.J., Walfish, M.: Efficient RAM and control flow in verifiable outsourced computation. In: NDSS (2015)</li>

      <li>69. Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: S&P (2018)</li>

      <li>70. Wesolowski, B.: Efficient verifiable delay functions. In: EUROCRYPT. pp. 379–407 (2019)</li>

      <li>71. WhiteHat, B., Gluchowski, A., HarryR, Fu, Y., Castonguay, P.: Roll_up / roll_back snark side chain ~17000 tps. https://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675 (Oct 2018)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[72] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: S&P (2017)</li>

      <li>[73] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vRAM: Faster verifiable RAM with program-independent preprocessing. In: S&P (2018)</li>

      <li>[74] Zhang, Z.: Origami: Fold a Plonk for Ethereum’s VDF. Cryptology ePrint Archive (2023)</li>

      <li>[75] Zheng, T., Gao, S., Guo, Y., Xiao, B.: Kilonova: Non-uniform pcd with zero-knowledge property from generic folding schemes. Cryptology ePrint Archive, Paper 2023/1579 (2023)</li>

      <li>[76] Zhou, Z., Zhang, Z., Dong, J.: Proof-carrying data from multi-folding schemes. Cryptology ePrint Archive, Paper 2023/1282 (2023)</li>

    </ul>

    <p class="text-gray-300">A Additional Preliminaries</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">A.1 Polynomials and low-degree extensions</h3>

    <p class="text-gray-300">We adapt this subsection from prior work <em>[57]</em>. We start by recalling several facts about polynomials.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 14 (Multilinear polynomial)</h6>

    <p class="text-gray-300">A multivariate polynomial is called a multilinear polynomial if the degree of the polynomial in each variable is at most one.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Definition 15 (Low-degree polynomial)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A multivariate polynomial <span class="math">g</span> over a finite field <span class="math">\\mathbb{F}</span> is called low-degree polynomial if the degree <span class="math">d</span> of <span class="math">g</span> in each variable is exponentially smaller than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (i.e., </span>d=O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Low-degree extensions (LDEs). Suppose <span class="math">g:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span> is a function that maps <span class="math">\\ell</span>-bit elements into an element of <span class="math">\\mathbb{F}</span>. A <em>polynomial extension</em> of <span class="math">g</span> is a low-degree <span class="math">\\ell</span>-variate polynomial, denoted <span class="math">\\widetilde{g}</span>, such that <span class="math">\\widetilde{g}(x)=g(x)</span> for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">A <em>multilinear</em> polynomial extension (or simply, a multilinear extension, or MLE) is a low-degree polynomial extension where the extension is a multilinear polynomial (i.e., the degree of each variable in <span class="math">\\widetilde{g}</span> is at most one). Given a function <span class="math">Z:\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>, the multilinear extension of <span class="math">Z</span> is the unique multilinear polynomial <span class="math">\\widetilde{Z}:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>. It can be computed as follows.</p>

    <p class="text-gray-300"><span class="math">\\widetilde{Z}(x_{1},\\ldots,x_{\\ell})</span> <span class="math">=\\sum_{e\\in\\{0,1\\}^{\\ell}}Z(e)\\cdot\\prod_{i=1}^{\\ell}(x_{i}\\cdot e_{i}+(1-x_{i})\\cdot(1-e_{i}))</span> <span class="math">=\\sum_{e\\in\\{0,1\\}^{\\ell}}Z(e)\\cdot\\widetilde{eq}(x,e)</span> <span class="math">=\\langle(Z(0),\\ldots,Z(2^{\\ell}-1)),(\\widetilde{eq}(x,0),\\ldots,\\widetilde{eq}(x,2^{\\ell}-1)\\rangle</span></p>

    <p class="text-gray-300">Note that <span class="math">\\widetilde{eq}(x,e)=\\prod_{i=1}^{\\ell}(e_{i}\\cdot x_{i}+(1-e_{i})\\cdot(1-x_{i}))</span>, which is the MLE of the following function:</p>

    <p class="text-gray-300">\\[ eq(x,e)=\\begin{cases}1&\\text{if }x=e\\\\ 0&\\text{otherwise}\\end{cases} \\]</p>

    <p class="text-gray-300">For any <span class="math">r\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\widetilde{Z}(r)</span> can be computed in <span class="math">O(2^{\\ell})</span> operations in <span class="math">\\mathbb{F}</span> <em>[67, 64]</em>.</p>

    <p class="text-gray-300">Dense representation for multilinear polynomials. Since the MLE of a function is unique, it offers the following method to represent any multilinear polynomial. Given a multilinear polynomial <span class="math">g:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span>, it can be represented uniquely by the list of tuples <span class="math">L</span> such that for all <span class="math">i\\in\\{0,1\\}^{\\ell}</span>, <span class="math">(\\textsf{to-field}(i),g(i))\\in L</span> if and only if <span class="math">g(i)\\neq 0</span>, where to-field is the canonical injection from <span class="math">\\{0,1\\}^{\\ell}</span> to <span class="math">\\mathbb{F}</span>. We denote such a representation of <span class="math">g</span> as <span class="math">\\textsf{DenseRepr}(g)</span>.</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 16.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A multilinear polynomial <span class="math">g</span> in <span class="math">\\ell</span> variables is a sparse multilinear polynomial if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{DenseRepr}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is sub-linear in </span>2^{\\ell}$. Otherwise, it is a dense multilinear polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As an example, suppose <span class="math">g:\\mathbb{F}^{2s}\\to\\mathbb{F}</span>. Suppose $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{DenseRepr}(g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(2^{s})<span class="math">, then </span>g<span class="math"> is a sparse multilinear polynomial because </span>2^{s}<span class="math"> is sublinear in </span>2^{2s}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">A.2 The sum-check protocol</h3>

    <p class="text-gray-300">Suppose there is an <span class="math">\\ell</span>-variate low-degree polynomial, <span class="math">g</span>, where the degree of each variable in <span class="math">g</span> is at most <span class="math">d</span>. Suppose that a verifier <span class="math">\\mathcal{V}</span> is interested in checking a claim of the following form by an untrusted prover <span class="math">\\mathcal{P}</span>:</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{x_{1}\\in\\{0,1\\}}\\sum_{x_{2}\\in\\{0,1\\}}\\cdots\\sum_{x_{\\ell}\\in\\{0,1\\}}g(x_{1},x_{2},\\ldots,x_{\\ell})</span></p>

    <p class="text-gray-300">Of course, given <span class="math">g</span>, <span class="math">\\mathcal{V}</span> can deterministically evaluate the above sum and verify whether the sum is <span class="math">T</span>. But, this computation takes time exponential in <span class="math">\\ell</span>. Lund et al. <em>[46]</em> describe the sum-check protocol that requires far less computation on <span class="math">\\mathcal{V}</span>’s behalf, but provides a probabilistic guarantee. In the protocol, <span class="math">\\mathcal{V}</span> takes as input randomness <span class="math">r\\in\\mathbb{F}^{\\ell}</span> and interacts with <span class="math">\\mathcal{P}</span> over a sequence of <span class="math">\\ell</span> rounds. At the end of this interaction, <span class="math">\\mathcal{V}</span> outputs a claim about the evaluation <span class="math">g(r)</span>. Let <span class="math">\\langle\\mathcal{P},\\mathcal{V}(r)\\rangle</span> denote the interaction between the prover and verifier with verifier randomness <span class="math">r</span>. We treat <span class="math">\\langle\\mathcal{P},\\mathcal{V}(r)\\rangle</span> as a function that takes prover and verifier input <span class="math">(g,\\ell,d,T)</span> and outputs the claimed evaluation to be checked.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 5 (The sum-check protocol <em>[46]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">g</span> be an <span class="math">\\ell</span>-variate polynomial with degree at most <span class="math">d</span> in each variable. Then, the sumcheck protocol satisfies the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: If <span class="math">T=\\sum_{x\\in\\{0,1\\}^{\\ell}}g(x)</span>, then for all <span class="math">r\\in\\mathbb{F}^{\\ell}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\langle\\mathcal{P},\\mathcal{V}(r)\\rangle(g,\\ell,d,T)=g(r)\\,\\big{]}=1.</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness: If <span class="math">T\\neq\\sum_{x\\in\\{0,1\\}^{\\ell}}g(x)</span>, then for any <span class="math">\\mathcal{P}^{\\star}</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{r}\\big{[}\\langle\\mathcal{P}^{\\star},\\mathcal{V}(r)\\rangle(g,\\ell,d,T)=g(r)\\,\\big{]}\\leq\\ell\\cdot d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: The communication cost is <span class="math">O(\\ell\\cdot d)</span> elements of <span class="math">\\mathbb{F}</span>.</li>

    </ol>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 6 (Sums over evaluations).</h6>

    <p class="text-gray-300">Consider size <span class="math">\\ell\\in\\mathbb{N}</span>. For multilinear polynomial <span class="math">P\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}]</span> we have that</p>

    <p class="text-gray-300"><span class="math">P(X)=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{eq}(X,x)\\cdot P(x).</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{eq}</span> is a multilinear extension of <span class="math">eq</span>, which takes as inputs two values in <span class="math">\\{0,1\\}^{\\ell}</span> returns <span class="math">1</span> if its inputs are equal and <span class="math">0</span> otherwise.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Let <span class="math">Q(X)=\\sum_{x\\in\\{0,1\\}^{\\ell}}\\widetilde{eq}(X,x)\\cdot P(x)</span> By the definition of <span class="math">\\widetilde{eq}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">P(x)=Q(x)</span></p>

    <p class="text-gray-300">for all <span class="math">x\\in\\{0,1\\}^{\\ell}</span>. However, because <span class="math">P\\in\\mathbb{F}[X_{1},\\ldots,X_{\\ell}]</span> is multilinear it is completely determined by <span class="math">2^{\\ell}</span> evaluation points. The same holds for <span class="math">Q</span>. Because <span class="math">P</span> and <span class="math">Q</span> agree on <span class="math">2^{\\ell}</span> points, they must be the same polynomial. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Lemma 7 (Schwartz-Zippel <em>[56]</em>).</h6>

    <p class="text-gray-300">let <span class="math">g:\\mathbb{F}^{\\ell}\\to\\mathbb{F}</span> be an <span class="math">\\ell</span>-variate polynomial of total degree at most <span class="math">d</span>. Then, on any finite set <span class="math">S\\subseteq\\mathbb{F}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{x\\leftarrow S^{\\ell}}[g(x)=0]\\leq d/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">A.3 Commitment Schemes</h3>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 17 (Commitment Scheme).</h6>

    <p class="text-gray-300">A commitment scheme is defined by polynomial-time algorithm <span class="math">\\textsf{Gen}:\\mathbb{N}^{2}\\to P</span> that produces public parameters given the security parameter and size parameter, a deterministic polynomial-time algorithm <span class="math">\\textsf{Commit}:P\\times M\\times R\\to C</span> that produces a commitment in <span class="math">C</span> given a public parameters, message, and randomness tuple such that binding holds. That is, for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\textsf{Gen}(\\lambda,n)</span>, and given <span class="math">((m_{1},r_{1}),(m_{2},r_{2}))\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[(m_{1},r_{1})\\neq(m_{2},r_{2})\\land\\textsf{Commit}(\\mathsf{pp},m_{1},r_{1})=\\textsf{Commit}(\\mathsf{pp},m_{2},r_{2})]\\approx 0.</span></p>

    <p class="text-gray-300">The commitment scheme is deterministic if Commit does not use its randomness.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 18 (Hiding).</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">(\\textsf{Gen},\\textsf{Commit})</span> is hiding if for any <span class="math">\\mathsf{PPT}</span> adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp}\\leftarrow\\textsf{Gen}(\\lambda,n)</span>, <span class="math">((m_{1},r_{1}),(m_{2},r_{2}))\\leftarrow\\mathcal{A}(\\mathsf{pp})</span>, and <span class="math">C_{i}\\leftarrow\\textsf{Commit}(\\mathsf{pp},m_{i},r_{i})</span> for <span class="math">i\\in\\{1,2\\}</span> we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathcal{A}(\\mathsf{pp},C_{1})=1]\\approx\\Pr[\\mathcal{A}(\\mathsf{pp},C_{2})=1].</span></p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 19 (Homomorphic).</h6>

    <p class="text-gray-300">The commitment scheme <span class="math">(\\textsf{Gen},\\textsf{Commit})</span> is homomorphic if the message space <span class="math">M</span>, randomness space <span class="math">R</span>, and commitment space <span class="math">C</span> are groups and for all <span class="math">n\\in\\mathbb{N}</span>, and <span class="math">\\mathsf{pp}\\leftarrow\\textsf{Gen}(\\lambda,n)</span>, we have that for any <span class="math">m_{1},m_{2}\\in M</span> and <span class="math">r_{1},r_{2}\\in R</span></p>

    <p class="text-gray-300"><span class="math">\\textsf{Commit}(\\mathsf{pp},m_{1},r_{1})+\\textsf{Commit}(\\mathsf{pp},m_{2},r_{2})=\\textsf{Commit}(\\mathsf{pp},m_{1}+m_{2},r_{1}+r_{2}).</span></p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 20 (Succinct Commitments).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A commitment scheme <span class="math">(\\textsf{Gen},\\textsf{Commit})</span>, over message space <span class="math">M</span> and commitment space <span class="math">R</span>, provides succinct commitments if for all <span class="math">\\mathsf{pp}\\leftarrow\\textsf{Gen}(1^{\\lambda})</span>, and any <span class="math">m\\in M</span> and <span class="math">r\\in R</span>, we have that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{Commit}(\\mathsf{pp},m,r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O_{\\lambda}(\\mathsf{polylog}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 21 (Multilinear Polynomial Commitment Scheme).</h6>

    <p class="text-gray-300">A multilinear polynomial commitment scheme over polynomial ring <span class="math">\\mathbb{F}^{1}[X_{1},\\ldots,X_{n}]</span> is a</p>

    <p class="text-gray-300">commitment scheme (Gen, Commit) over message space <span class="math">\\mathbb{F}^1[X_1,\\ldots ,X_n]</span>, equipped with an argument of knowledge (Definition 23) for relation <span class="math">\\mathcal{R}_{\\mathrm{polyeval}}</span> defined as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {p o l y e v a l}} = \\left\\{(\\mathsf {p p}, (C, x, y), (P, r)) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} P \\in \\mathbb {F} ^ {1} [ X _ {1}, \\ldots , X _ {n} ], \\\\ P (x) = y, \\\\ C = \\text {C o m m i t} (\\mathsf {p p}, P, r) \\end{array} \\right. \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-58" class="text-2xl font-bold">A.4 Rank-1 constraint satisfiability (R1CS)</h2>

    <p class="text-gray-300">R1CS is an NP-complete problem implicit in the work of GGPR [31]. Below, we recall its definition.</p>

    <p class="text-gray-300"><strong>Definition 22 (R1CS).</strong> Consider a finite field <span class="math">\\mathbb{F}</span>. Let the public parameters consist of size bounds <span class="math">m, n, \\ell \\in \\mathbb{N}</span> where <span class="math">m &amp;gt; \\ell</span>. The R1CS structure consists of sparse matrices <span class="math">A, B, C \\in \\mathbb{F}^{m \\times m}</span> with at most <span class="math">n = \\Omega(m)</span> non-zero entries in each matrix. An instance <span class="math">x \\in \\mathbb{F}^{\\ell}</span> consists of public inputs and outputs and is satisfied by a witness <span class="math">W \\in \\mathbb{F}^{m - \\ell - 1}</span> if <span class="math">(A \\cdot Z) \\circ (B \\cdot Z) = C \\cdot Z</span>, where <span class="math">Z = (W, x, 1)</span>.</p>

    <h2 id="sec-59" class="text-2xl font-bold">A.5 Arguments of Knowledge</h2>

    <p class="text-gray-300"><strong>Definition 23 (Argument of Knowledge).</strong> Consider relation <span class="math">\\mathcal{R}</span> over public parameters, structure, instance, and witness tuples. A reduction of knowledge for <span class="math">\\mathcal{R}</span> is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic algorithm <span class="math">\\mathcal{K}</span>, denoting the generator, the prover, the verifier and the encoder respectively with the following interface.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(\\lambda, N) \\to \\mathsf{pp}</span>: Takes as input security parameter <span class="math">\\lambda</span> and size parameters <span class="math">N</span>. Outputs public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},\\mathsf{s}) \\to (\\mathsf{pk},\\mathsf{vk})</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span> and structure <span class="math">\\mathsf{s}</span>. Outputs prover key <span class="math">\\mathsf{pk}</span> and verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},\\mathsf{u},\\mathsf{w}) \\to \\bot</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, and an instance-witness pair <span class="math">(\\mathsf{u},\\mathsf{w})</span>. Interactively proves that <span class="math">(\\mathsf{pp},\\mathsf{s},\\mathsf{u},\\mathsf{w}) \\in \\mathcal{R}</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pk},\\mathsf{u}) \\to \\{0,1\\}</span>: Takes as input public parameters <span class="math">\\mathsf{pp}</span>, and an instance <span class="math">\\mathsf{u}</span>. Interactively checks <span class="math">\\mathsf{u}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> denote the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. We treat <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> as a function that takes as input <span class="math">((\\mathsf{pk},\\mathsf{vk}),\\mathsf{u},\\mathsf{w})</span> and runs the interaction on prover input <span class="math">(\\mathsf{pk},\\mathsf{u},\\mathsf{w})</span> and verifier input <span class="math">(\\mathsf{pp},\\mathsf{u})</span>. At the end of the interaction, <span class="math">\\langle \\mathcal{P},\\mathcal{V}\\rangle</span> outputs the verifier's decision. An argument of knowledge <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> satisfies the following conditions.</p>

    <p class="text-gray-300">(i) Completeness: For any PPT adversary <span class="math">\\mathcal{A}</span>, given <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(\\lambda, N)</span>, <span class="math">(\\mathsf{s}, \\mathsf{u}, \\mathsf{w}) \\gets \\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp}, \\mathsf{s}, \\mathsf{u}, \\mathsf{w}) \\in \\mathcal{R}</span> and <span class="math">(\\mathsf{pk}, \\mathsf{vk}) \\gets \\mathcal{K}(\\mathsf{pp}, \\mathsf{s})</span> we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathcal {P}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), \\mathsf {u}, \\mathsf {w}) = 1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: For any expected polynomial-time adversaries <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{P}^{*}</span>, there exists an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,N)</span>, <span class="math">(\\mathsf{s},\\mathsf{u},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span>, we have that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[(\\mathsf{pp},\\mathsf{s},\\mathsf{u},\\mathcal{E}(\\mathsf{pp},\\mathsf{u},\\mathsf{st}))\\in\\mathcal{R}_{1}]\\approx\\Pr[\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\mathsf{u},\\mathsf{st})=1].</span></p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 24 (Succinctness).</h6>

    <p class="text-gray-300">An argument of knowledge is succinct if the communication complexity and the verifier time complexity is at most polylogarithmic in the size of the structure and witness.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 25 (Non-Interactivity).</h6>

    <p class="text-gray-300">An argument of knowledge is non-interactive if the interaction consists of a single message from the prover to the verifier. In this case, we denote this single message as the output of the prover, and as an input to the verifier.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 26 (Zero-knowledge).</h6>

    <p class="text-gray-300">An argument of knowledge <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">\\mathcal{R}</span> satisfies zero-knowledge if for any PPT adversary <span class="math">\\mathcal{V}^{*}</span> there exists an EPT simulator <span class="math">\\mathcal{S}</span> such that for any PPT adversary <span class="math">\\mathcal{A}</span> for <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span>, <span class="math">(\\mathsf{s},(u,w),\\mathsf{st}_{1})\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp},\\mathsf{s},u,w)\\in\\mathcal{R}</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{\\{}\\,\\mathsf{st}_{2}\\,\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,\\mathsf{st}_{2}\\leftarrow\\langle\\mathcal{P},\\mathcal{V}^{*}(\\mathsf{st}_{1})\\rangle((\\mathsf{pk},\\mathsf{vk}),u,w)\\,\\big{\\}}\\cong\\big{\\{}\\,\\mathsf{st}_{2}\\,\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\,\\mathsf{st}_{2}\\leftarrow\\mathcal{S}(\\mathsf{pp},\\mathsf{s},u,\\mathsf{st}_{1})\\,\\big{\\}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{st}_{2}</span> denotes the output of <span class="math">\\mathcal{V}^{*}</span> after interaction. An argument of knowledge satisfies honest-verifier zero-knowledge (HVZK) if it satisifes zero-knowledge under an honest (but curious) verifier that behaves according to the interactive protocol but produces arbitrary output on the side.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">A.6 Incrementally Verifiable Computation</h3>

    <h6 id="sec-64" class="text-base font-medium mt-4">Definition 27 (Incrementally verifiable computation (IVC)).</h6>

    <p class="text-gray-300">An incrementally verifiable computation (IVC) scheme is defined by PPT algorithms <span class="math">(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> and deterministic <span class="math">\\mathcal{K}</span> denoting the generator, the prover, the verifier, and the encoder respectively, with the following interface</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},N)\\rightarrow\\mathsf{pp}</span>: on input security parameter <span class="math">\\lambda</span> and size bounds <span class="math">N</span>, samples public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li><span class="math">\\mathcal{K}(\\mathsf{pp},F)\\rightarrow(\\mathsf{pk},\\mathsf{vk})</span>: on input public parameters <span class="math">\\mathsf{pp}</span>, and polynomial-time function <span class="math">F</span>, deterministically produces a prover key <span class="math">\\mathsf{pk}</span> and a verifier key <span class="math">\\mathsf{vk}</span>.</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i})\\rightarrow\\Pi_{i+1}</span>: on input a prover key <span class="math">\\mathsf{pk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_{0}</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_{i}</span>, a non-deterministic advice <span class="math">\\omega_{i}</span>, and an IVC proof <span class="math">\\Pi_{i}</span> attesting to <span class="math">z_{i}</span>, produces a new proof <span class="math">\\Pi_{i+1}</span> attesting to <span class="math">z_{i+1}=F(z_{i},\\omega_{i})</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi_{i})\\rightarrow\\{0,1\\}</span>: on input a verifier key <span class="math">\\mathsf{vk}</span>, a counter <span class="math">i</span>, an initial input <span class="math">z_{0}</span>, a claimed output after <span class="math">i</span> iterations <span class="math">z_{i}</span>, and an IVC proof <span class="math">\\Pi_{i}</span> attesting to <span class="math">z_{i}</span>, outputs <span class="math">1</span> if <span class="math">\\Pi_{i}</span> is accepting, and <span class="math">0</span> otherwise.</li>

    </ul>

    <p class="text-gray-300">An IVC scheme  <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  satisfies the following requirements.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness: For any PPT adversary  <span class="math">\\mathcal{A}</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {V} (\\mathsf {v k}, (i + 1, z _ {0}, z _ {i + 1}), \\Pi_ {i + 1}) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}, N), \\\\ F, (i, z _ {0}, z _ {i}, \\Pi_ {i}) \\leftarrow \\mathcal {A} (\\mathsf {p p}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F), \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}), \\\\ \\mathcal {V} (\\mathsf {v k}, i, z _ {0}, z _ {i}, \\Pi_ {i}) = 1, \\\\ \\Pi_ {i + 1} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\omega_ {i}, \\Pi_ {i}) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">F</span>  is a polynomial-time computable function represented as an arithmetic circuit.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge Soundness: For any constant  <span class="math">n \\in \\mathbb{N}</span> , and for all expected polynomial time adversaries  <span class="math">\\mathcal{P}^*</span> , there exists an expected polynomial-time extractor  <span class="math">\\mathcal{E}</span>  such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\Pr_ {\\mathbf {r}} \\left[ \\begin{array}{l} z _ {n} = z \\text {w h e r e} \\\\ z _ {i + 1} \\leftarrow F (z _ {i}, \\omega_ {i}) \\\\ \\forall i \\in \\{0, \\ldots , n - 1 \\} \\end{array} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (F, (z _ {0}, z), \\varPi) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}, \\mathsf {r}), \\\\ (\\omega_ {0}, \\ldots , \\omega_ {n - 1}) \\leftarrow \\mathcal {E} (\\mathsf {p p}, \\mathsf {r}) \\end{array} \\right. \\right] \\approx \\right. \\\\ \\Pr_ {\\mathbf {r}} \\left[ \\mathcal {V} (\\mathsf {v k}, (n, z _ {0}, z), \\varPi) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {p p} \\leftarrow \\mathcal {G} (1 ^ {\\lambda}), \\\\ (F, (z _ {0}, z), \\varPi) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}, \\mathsf {r}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, F) \\end{array} \\right. \\right] \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{r}</span>  denotes an arbitrarily long random tape.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Succinctness: The size of an IVC proof  <span class="math">\\Pi</span>  is independent of the number of iterations  <span class="math">n</span> .</li>

    </ol>

    <p class="text-gray-300">Construction 3 (Fiat-Shamir transformation for multi-folding schemes). Consider a public-coin multi-folding scheme  <span class="math">\\varPi=(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  for  <span class="math">(\\mathcal{R}_1,\\mathcal{R}_2,\\mathrm{compat},\\mu,\\nu)</span>  with  <span class="math">\\ell</span>  rounds. Let  <span class="math">\\rho</span>  denote a random oracle. We construct a non-interactive multi-folding scheme  <span class="math">\\varPi&#x27;=(\\mathcal{G}&#x27;,\\mathcal{K}&#x27;,\\mathcal{P}&#x27;,\\mathcal{V}&#x27;)</span>  for  <span class="math">(\\mathcal{R}_1,\\mathcal{R}_2,\\mathrm{compat},\\mu,\\nu)</span>  in the random oracle model as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}&#x27;(1^{\\lambda}, N) \\to \\mathsf{pp}</span> : Compute and output  <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda}, N)</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{K}&#x27;(\\mathsf{pp},\\mathsf{s})\\to \\mathsf{pp}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></li>

      <li>Compute  <span class="math">\\mathsf{hs}\\gets \\rho (\\mathsf{pp},\\mathsf{s})</span></li>

      <li>Output  <span class="math">(\\mathsf{pk}&#x27;,\\mathsf{vk}&#x27;)\\gets ((\\mathsf{pk},\\mathsf{hs}),(\\mathsf{vk},\\mathsf{hs}))</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}&#x27;(\\mathsf{pk}&#x27;, (\\vec{u}_1, \\vec{u}_2), (\\vec{w}_1, \\vec{w}_2))</span> :</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\mathsf{pk}&#x27;</span>  as  <span class="math">(\\mathsf{pk},\\mathsf{hs})</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathcal{P}(\\mathsf{pk},(\\vec{u}_{1},\\vec{u}_{2}),(\\vec{w}_{1},\\vec{w}_{2}))</span>. On the <span class="math">i</span>th message <span class="math">m_{i}</span>, respond with verifier randomness <span class="math">r_{i+1}\\leftarrow\\rho(m_{i},r_{i})</span> where <span class="math">r_{1}=\\mathsf{hs}</span>. Let <span class="math">(u,w)</span> be the output of <span class="math">\\mathcal{P}</span> and let <span class="math">\\pi=(m_{1},\\ldots,m_{\\ell})</span> consist of messages from <span class="math">\\mathcal{P}</span>.</li>

      <li>Send <span class="math">\\pi</span> to the verifier.</li>

      <li>Output <span class="math">(u,w)</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}^{\\prime}(\\mathsf{vk}^{\\prime},(\\vec{u}_{1},\\vec{u}_{2}))</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{vk}^{\\prime}</span> as <span class="math">(\\mathsf{vk},\\mathsf{hs})</span></li>

      <li>Receive <span class="math">\\pi=(m_{1},\\ldots,m_{\\ell})</span> from the prover. Compute <span class="math">r_{i+1}\\leftarrow\\rho(m_{i},r_{i})</span> for <span class="math">r_{1}=\\mathsf{hs}</span>.</li>

      <li>Run <span class="math">\\mathcal{V}(\\mathsf{vk},(\\vec{u}_{1},\\vec{u}_{2}))</span> with randomness <span class="math">(r_{1},\\ldots,r_{\\ell+1})</span>. In round <span class="math">i</span>, send the prover message <span class="math">m_{i}</span>. Let <span class="math">u</span> be the output of <span class="math">\\mathcal{V}</span>.</li>

      <li>Output <span class="math">u</span>.</li>

    </ol>

    <p class="text-gray-300">The Fiat-Shamir transformation affords Lemma 1.</p>

    <h2 id="sec-66" class="text-2xl font-bold">Appendix C Additional related work</h2>

    <p class="text-gray-300">Halo <em>[13]</em> and its generalization in <em>[19]</em> propose a way to realize IVC (and proof-carrying data <em>[22, 7]</em>) using SNARKs whose verifiers support the so-called accumulation schemes. Halo2 <em>[14]</em> switches the polynomial IOP in Halo <em>[13]</em> from Sonic <em>[48]</em> to Plonk <em>[30]</em>. Unfortunately, it incurs substantial prover costs as the prover must produce a SNARK using Plonk at each step of the program execution. Furthermore, the prover incurs <span class="math">O(n\\cdot d)</span> cryptographic operations, where <span class="math">n</span> is the size of the circuit at each step and <span class="math">d</span> is the maximum degree of constraints proven. Switching from Plonk to HyperPlonk <em>[20]</em> would reduce the cryptographic operations to <span class="math">O(n)</span>, but it does not avoid the need to produce a SNARK. Split accumulation <em>[18]</em> avoids succinct arguments (e.g., SNARKs) to construct IVC or PCD. Unfortunately, their construction targets R1CS. It is not clear how to extend it to handle Plonkish without making the prover incur <span class="math">O(n\\cdot d)</span> cryptographic operations, which, as noted above, is undesirable.</p>

    <p class="text-gray-300">Buffet <em>[68]</em>, building on Pantry <em>[16]</em> and Ben-Sasson et al. <em>[5]</em>, avoids the high cost of universal circuits yet supports a general class of programs. For example, Buffet supports any program in the C programming language as long as it neither invokes goto statements nor uses function pointers. Furthermore, Buffet provides an “a la carte” cost profile where the prover’s proof generation costs are proportional only to the sum of sizes of circuits of the operations invoked by the program execution. However, Buffet adopts a “line-by-line compilation” approach <em>[62, 15, 54, 16]</em>, where it unrolls programs into non-uniform circuits by translating each program statement into a concise set of constraints. Unfortunately, this approach requires static bounds on program execution lengths. More importantly, it is unclear how to prove the satisfiability of unrolled non-uniform circuits in an incremental fashion. Furthermore, although general, it is unclear how to use Buffet’s approach to prove program executions on a stateful machine</p>

    <p class="text-gray-300">without* producing a non-uniform circuit for each program. Having a separate circuit for each program is undesirable in practice as it is not clear how in that model one program can invoke another program (a la “composability”).</p>

    <p class="text-gray-300">A work that follows Buffet, called vRAM <em>[73]</em>, achieves Buffet-like costs for program executions on vnTinyRAM <em>[4]</em>, a RAM machine with a minimal instruction set. In particular, during program execution, at the granularity of a processor cycle, vRAM uses a “trimmed” version of the vnTinyRAM universal circuit where the trimmed version eliminates circuit elements corresponding to instructions that were not invoked. Unfortunately, like Buffet, this approach is not incremental. Specifically, it requires proving that certain global invariants hold over the entire trace of program execution (e.g., to prove that the trimmed version of the circuit is correct), using randomized fingerprinting techniques. As with Buffet, it is unclear how to prove these global invariants hold in an incremental fashion. Furthermore, this approach reveals, for each program execution, the number of invocations of each instruction supported by the machine to the verifier, so vRAM’s approach does not ensure zero-knowledge.</p>

    <p class="text-gray-300">MIRAGE <em>[38]</em> adapts vRAM’s techniques in the context of Groth’s SNARK <em>[34]</em> (vRAM uses a CMT-based argument <em>[24]</em>). Like vRAM, MIRAGE still relies on proving invariants over the entire execution trace via fingerprinting techniques, making its techniques incompatible with incremental proof systems.</p>

    <h2 id="sec-67" class="text-2xl font-bold">Appendix D Details of the zero-knowledge and succinctness layer</h2>

    <p class="text-gray-300">In this section, we formally construct and prove HyperNova’s zero-knowledge and succinctness layer. Recall that our goal is to design a zero-knowledge argument for the following relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{R}_{\\mathsf{vNIVC}}=\\left\\{\\left.\\left(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi),(i,z_{0},z_{i}),\\Pi\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}\\mathsf{vk}\\leftarrow\\mathsf{NIVC}.\\mathcal{K}(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi)),\\cr\\mathsf{NIVC}.\\mathcal{V}(\\mathsf{vk},(i,z_{0},z_{i}),\\Pi)=1\\end{matrix}\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">D.1 Building blocks: randomizing and hiding folding schemes</h3>

    <p class="text-gray-300">We begin by defining randomizing folding schemes, a central building block for our zero-knowledge layer. We then demonstrate that the Nova folding scheme for relaxed R1CS features a stronger hiding property, which we will additionally leverage in our construction.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 28 (Randomizing).</h6>

    <p class="text-gray-300">A multi-folding scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for <span class="math">(\\mathcal{R}_{1},\\mathcal{R}_{2},\\mathsf{compat},\\mu,\\nu)</span> is randomizing if there exists a sampling algorithm <span class="math">\\mathsf{sample}_{\\mathcal{R}_{1}}</span> for instance-witness pairs in <span class="math">\\mathcal{R}_{1}</span> such that for any expected polynomial-time adversary <span class="math">\\mathcal{A}</span> given <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(\\lambda,N)</span> and <span class="math">((\\mathsf{s}_{1},\\mathsf{s}_{2}),(\\vec{u}_{1},\\vec{w}_{1}),(\\vec{u}_{2},\\vec{w}_{2}))\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">\\mathsf{compat}(\\mathsf{s}_{1},\\mathsf{s}_{2})=1</span>, <span class="math">(\\mathsf{pp},\\mathsf{s}_{1},\\vec{u}_{1},\\vec{w}_{1})\\in\\mathcal{R}_{1}^{\\mu-1}</span>, and <span class="math">(\\mathsf{pp},\\mathsf{s}_{2},\\vec{u}_{2},\\vec{w}_{2})\\in\\mathcal{R}_{2}^{\\nu}</span></p>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} \\left(\\mathsf {p p}, \\mathsf {s} _ {1}, u, w\\right) \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(u, w) \\stackrel {\\S} {\\leftarrow} \\mathsf {s a m p l e} _ {\\mathcal {R} _ {1}} (\\mathsf {p p}, \\mathsf {s} _ {1}) \\end{array} \\right\\} \\cong</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} (\\mathsf {p p}, \\mathsf {s} _ {1}, u, w) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (u _ {\\mathsf {r}}, w _ {\\mathsf {r}}) \\stackrel {{\\S}} {{\\leftarrow}} \\mathsf {s a m p l e} _ {\\mathcal {R} _ {1}} (\\mathsf {p p}, \\mathsf {s} _ {1}), \\\\ (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathcal {K} (\\mathsf {p p}, (\\mathsf {s} _ {1}, \\mathsf {s} _ {2})), \\\\ (u, w) \\leftarrow \\langle \\mathcal {P}, \\mathcal {V} \\rangle ((\\mathsf {p k}, \\mathsf {v k}), ((u _ {\\mathsf {r}}, \\vec {u} _ {1}), \\vec {u} _ {2}), ((w _ {\\mathsf {r}}, \\vec {w} _ {1}), \\vec {w} _ {2})) \\end{array} \\right. \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Lemma 8 (Folding CCS is randomizing). Construction 1 is randomizing.</p>

    <p class="text-gray-300">Proof. We begin by describing a sampling algorithm for linearized committed CCS.</p>

    <p class="text-gray-300">sample <span class="math">_{\\text{LCCCS}}(\\mathsf{pp}, \\mathsf{s}) \\to (\\mathsf{u}, \\mathsf{w})</span> :</p>

    <p class="text-gray-300">(1) Parse size bounds <span class="math">t, \\ell, s&#x27; \\in \\mathbb{N}</span> from <span class="math">\\mathfrak{s}</span>. (2) Parse matrices <span class="math">\\widetilde{M}_1, \\ldots, \\widetilde{M}_t</span> from the LCCCS structure <span class="math">\\mathfrak{s}</span>. (3) Randomly sample partial instance <span class="math">(u, \\mathsf{x}, r) \\in (\\mathbb{F}, \\mathbb{F}^{\\ell}, \\mathbb{F})</span> and witness <span class="math">\\widetilde{w} \\in \\mathbb{F}^{2^{s&#x27; - i}}</span>. (4) For <span class="math">i \\in [t]</span>, compute</p>

    <div class="my-4 text-center"><span class="math-block">v _ {i} \\leftarrow \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {i} (r, y) \\cdot \\widetilde {z} (y)</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{z}</span> is an <span class="math">s^{\\prime}</span>-variate multilinear polynomial such that <span class="math">z(x) = (\\widetilde{w,u,\\mathsf{x}})(x)</span> for all <span class="math">x\\in \\{0,1\\}^{s&#x27;}</span>.</p>

    <p class="text-gray-300">(5) Sample <span class="math">r_{\\widetilde{w}} \\gets \\mathbb{F}</span> and compute <span class="math">C \\gets \\mathrm{Commit}(\\mathsf{pp}, \\widetilde{w}, r_{\\widetilde{w}})</span> (6) Compute and output <span class="math">\\mathsf{u} \\gets (C, (u, \\mathsf{x}, r, v_1, \\ldots, v_t))</span> and <span class="math">\\mathsf{w} \\gets (\\widetilde{w}, r_{\\widetilde{w}})</span>.</p>

    <p class="text-gray-300">Now, consider a linearized committed CCS instance-witness pair <span class="math">(C,(u,\\mathsf{x},r,v_{1},\\ldots ,v_{t}))</span> and <span class="math">(\\widetilde{w},r_{\\widetilde{w}})</span> that is folded into an arbitrarily chosen instance-witness pair.</p>

    <p class="text-gray-300">By Step 7 of the multi-folding scheme for CCS, we have that the folded linearized committed CCS instance is computed by taking a random linear combination of all incoming linearized CCS instances (and CCS instances reduced to linearized CCS instances by the sum-check protocol). Thus, we have that the folded terms <span class="math">C</span>, <span class="math">u</span>, and <span class="math">x</span> are indistinguishable from random. Similarly, we have that the folded witness <span class="math">\\widetilde{w}</span> is indistinguishable from random. Moreover, by construction of the sum-check protocol, we have the updated random value <span class="math">r_x&#x27;</span> is also indistinguishable from random. Finally, we have that the terms <span class="math">v_j</span> for <span class="math">j \\in [t]</span> are completely determined by the prior values. Therefore, we have that the folded instance-witness pair is indistinguishable from one sampled randomly.</p>

    <p class="text-gray-300">47</p>

    <p class="text-gray-300">Consider a finite field <span class="math">\\mathbb{F}</span> and a succinct, hiding, and homomorphic commitment scheme <span class="math">\\mathsf{Commit}</span> over <span class="math">\\mathbb{F}</span>. We define the generator and the encoder as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda}, (m, n, \\ell \\in \\mathbb{N})) \\to \\mathfrak{pp}</span>: output commitment parameters <span class="math">\\mathfrak{pp}_W</span> and <span class="math">\\mathfrak{pp}_E</span> for vectors of size <span class="math">m</span> and <span class="math">m - \\ell - 1</span> respectively.</li>

      <li><span class="math">\\mathcal{K}(\\mathfrak{pp}, (A, B, C)) \\to (\\mathfrak{pk}, \\mathsf{vk})</span>: output <span class="math">\\mathfrak{pk} \\gets (\\mathfrak{pp}, (A, B, C))</span> and <span class="math">\\mathsf{vk} \\gets \\bot</span>.</li>

    </ul>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> takes two committed relaxed R1CS instances <span class="math">(\\overline{E}_1, u_1, \\overline{W}_1, \\mathsf{x}_1)</span> and <span class="math">(\\overline{E}_2, u_2, \\overline{W}_2, \\mathsf{x}_2)</span>. The prover <span class="math">\\mathcal{P}</span>, in addition to the two instances, takes witnesses to both instances, <span class="math">(E_1, r_{E_1}, W_1, r_{W_1})</span> and <span class="math">(E_2, r_{E_2}, W_2, r_{W_2})</span>. Let <span class="math">Z_1 = (W_1, \\mathsf{x}_1, u_1)</span> and <span class="math">Z_2 = (W_2, \\mathsf{x}_2, u_2)</span>. The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Send <span class="math">\\overline{T} \\coloneqq \\mathsf{Commit}(\\mathsf{pp}_E, T, r_T)</span>, where <span class="math">r_T \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span> and</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">T = A Z _ {1} \\circ B Z _ {2} + A Z _ {2} \\circ B Z _ {1} - u _ {1} \\cdot C Z _ {2} - u _ {2} \\cdot C Z _ {1}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Sample and send a challenge <span class="math">r \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span>.</li>

      <li><span class="math">\\mathcal{V}, \\mathcal{P}</span>: Output the folded instance <span class="math">(\\overline{E}, u, \\overline{W}, \\mathsf{x})</span>, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\overline{E} \\leftarrow \\overline{E}_1 + r \\cdot \\overline{T} \\quad + r^2 \\cdot \\overline{E}_2 \\\\ u \\leftarrow u_1 + r \\cdot u_2 \\\\ \\overline{W} \\leftarrow \\overline{W}_1 + r \\cdot \\overline{W}_2 \\\\ x \\leftarrow x_1 + r \\cdot x_2 \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Output the folded witness <span class="math">(E, r_E, W, r_W)</span>, where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E \\leftarrow E_1 + r \\cdot T + r^2 \\cdot E_2 \\\\ r_E \\leftarrow r_{E_1} + r \\cdot r_T + r^2 \\cdot r_{E_2} \\\\ W \\leftarrow W_1 + r \\cdot W_2 \\\\ r_W \\leftarrow r_{W_1} + r \\cdot r_{W_2} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We now provide an algorithm to sample a randomized relaxed R1CS instance-witness pairs.</p>

    <div class="my-4 text-center"><span class="math-block">\\text{sample}_{\\text{R1CS}}(\\mathfrak{pp}, \\mathfrak{s}) \\rightarrow (\\mathfrak{u}, \\mathfrak{w}):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathfrak{s}</span> as matrices <span class="math">(A, B, C)</span>.</li>

      <li>Sample a random <span class="math">(W, \\mathsf{x}, u, r_E, r_W)</span>;</li>

      <li>Compute <span class="math">E \\gets AZ \\circ BZ - u \\cdot CZ</span>, where <span class="math">Z = (W, \\mathsf{x}, u)</span>;</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\overline{E},\\overline{W})\\gets (\\mathsf{Commit}(\\mathsf{pp},E,r_{E}),\\mathsf{Commit}(\\mathsf{pp},W,r_{W}))</span>, where <span class="math">r_E</span> and <span class="math">r_W</span> are sampled randomly; and</li>

      <li>Output the instance <span class="math">(\\overline{E},u,\\overline{W},\\mathsf{x})</span> and witness <span class="math">(E,r_{E},W,r_{W})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Lemma 9 (Folding R1CS is hiding).</strong> Consider the folding scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for relaxed R1CS from Construction 4. Then, for any honest-but-curious deterministic <span class="math">\\mathcal{V}^*</span>, there exists an EPT simulator <span class="math">\\mathcal{S}</span> such that for all PPT adversary <span class="math">\\mathcal{A}</span> for <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda},N)</span>, <span class="math">(\\mathsf{s},\\mathsf{u}_1,\\mathsf{w}_1) \\gets \\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">(\\mathsf{pp},\\mathsf{s},\\mathsf{u}_1,\\mathsf{w}_1) \\in \\mathcal{R}_{\\mathsf{RR1CS}}</span>, and <span class="math">(\\mathsf{pk},\\mathsf{vk}) \\gets \\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} (\\mathsf{st}_2, \\mathsf{w}_2) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf{u}_{\\mathsf{rb}}, \\mathsf{w}_{\\mathsf{rb}}) \\xleftarrow{\\S} \\mathsf{sample}_{\\mathsf{RR1CS}}(\\mathsf{pp}, \\mathsf{s}) \\\\ (\\mathsf{st}_2, \\mathsf{w}_2) \\leftarrow \\langle \\mathcal{P}, \\mathcal{V}^* \\rangle \\big((\\mathsf{pk}, \\mathsf{vk}), (\\mathsf{u}_1, \\mathsf{u}_{\\mathsf{rb}}), (\\mathsf{w}_1, \\mathsf{w}_{\\mathsf{rb}}) \\big) \\end{array} \\right. \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\cong \\\\ \\left\\{ (\\mathsf{st}_2, \\mathsf{w}_2) \\mid (\\mathsf{st}_2, \\mathsf{w}_2) \\leftarrow \\mathcal{S}(\\mathsf{pp}, \\mathsf{s}, \\mathsf{u}_1) \\right\\}. \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{st}_2</span> represents the (arbitrary) output of <span class="math">\\mathcal{V}^*</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider an honest-but-curious PPT adversary <span class="math">\\mathcal{V}^*</span>. To prove hiding, we construct an EPT simulator <span class="math">\\mathcal{S}</span> that simulates the joint distribution of the verifier's output and the prover's output witness as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{S}(\\mathsf{pp}, (A, B, C), (\\overline{E}, u, \\overline{W}, \\mathsf{x})) \\rightarrow ((\\overline{E}&#x27;, u&#x27;, \\overline{W}&#x27;, \\mathsf{x}&#x27;), (E&#x27;, r_{E&#x27;}, W&#x27;, r_{W&#x27;}), \\pi):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample the folded instance-witness pair <span class="math">((\\overline{E}&#x27;, u&#x27;, \\overline{W}&#x27;, \\mathsf{x}&#x27;), (E&#x27;, r_{E&#x27;}, W&#x27;, r_{W&#x27;}))</span>.</li>

      <li>Sample the verifier's challenge <span class="math">r \\stackrel{\\S}{\\leftarrow} \\mathbb{F}</span></li>

      <li>Sample a uniformly random <span class="math">\\overline{T}</span>.</li>

      <li>Solve for the prover's first message <span class="math">u_{\\mathrm{blind}} = (\\overline{E}_{\\mathrm{blind}}, u_{\\mathrm{blind}}, \\overline{W}_{\\mathrm{blind}}, \\mathsf{x}_{\\mathrm{blind}})</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\overline{E}_{\\mathrm{blind}} \\gets r^{-2} \\cdot (\\overline{E}&#x27; - r \\cdot \\overline{T} - \\overline{W})</span></li>

      <li><span class="math">u_{\\mathrm{blind}} \\gets r^{-1} \\cdot (u&#x27; - u)</span></li>

      <li><span class="math">\\overline{W}_{\\mathrm{blind}} \\gets r^{-1} \\cdot (\\overline{W}&#x27; - \\overline{W})</span></li>

      <li><span class="math">\\mathsf{x}_{\\mathrm{blind}} \\gets r^{-1} \\cdot (\\mathsf{x}&#x27; - \\mathsf{x})</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the verifier <span class="math">\\mathcal{V}^<em></span> on input <span class="math">\\mathsf{vk}</span>, and instances <span class="math">(\\overline{E}, u, \\overline{W}, \\mathsf{x})</span> and <span class="math">(\\overline{E}_{\\mathrm{blind}}, u_{\\mathrm{blind}}, \\overline{W}_{\\mathrm{blind}}, \\mathsf{x}_{\\mathrm{blind}})</span>. Let <span class="math">\\mathsf{st}&#x27;</span> be the output of <span class="math">\\mathcal{V}^</em></span>. Instantiate the verifier randomness to <span class="math">r</span> and send the first message <span class="math">\\overline{T}</span>.</li>

      <li>Output <span class="math">\\mathsf{st}&#x27;</span> and <span class="math">(E&#x27;, r_{E&#x27;}, W&#x27;, r_{W&#x27;})</span></li>

    </ol>

    <p class="text-gray-300">We now argue that the simulator (i.e. the ideal setting) produces an output that is indistinguishable from the prover and the verifier output (i.e. the real setting).</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">Indeed, consider an arbitrary adversary <span class="math">\\mathcal{A}</span>. Suppose that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pp}</span> <span class="math">\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span> <span class="math">((A,B,C),(\\overline{E},u,\\overline{W},\\mathsf{x}),(E,r_{E},W,r_{W}))</span> <span class="math">\\leftarrow\\mathcal{A}(\\mathsf{pp})</span> <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> <span class="math">\\leftarrow\\mathcal{K}(\\mathsf{pp},(A,B,C))</span></p>

    <p class="text-gray-300">In both the real and ideal settings, because the verifier <span class="math">\\mathcal{V}^{<em>}</span> interacts honestly with the prover, the challenge <span class="math">r</span> sampled by <span class="math">\\mathcal{V}^{</em>}</span> in the real setting is indistinguishable from the challenge <span class="math">r</span> sampled by <span class="math">\\mathcal{S}</span> in the ideal setting.</p>

    <p class="text-gray-300">Moreover, in both the real and ideal settings, <span class="math">\\overline{T}</span> is a hiding commitment, so <span class="math">\\overline{T}</span> is indistinguishable in the real and ideal settings.</p>

    <p class="text-gray-300">In the real setting, <span class="math">(\\overline{E}_{\\mathsf{blind}},u_{\\mathsf{blind}},\\overline{W}_{\\mathsf{blind}},\\mathsf{x}_{\\mathsf{blind}})</span> is randomly sampled from the blinding distribution. And, in the ideal setting, <span class="math">(\\overline{E}_{\\mathsf{blind}},u_{\\mathsf{blind}},\\overline{W}_{\\mathsf{blind}},\\mathsf{x}_{\\mathsf{blind}})</span> is indistinguishable from random as it is computed from the randomly sampled <span class="math">(\\overline{E}^{\\prime},u^{\\prime},\\overline{W}^{\\prime},\\mathsf{x}^{\\prime})</span>, <span class="math">\\overline{T}</span>, and <span class="math">r</span>. So, they are indistinguishable.</p>

    <p class="text-gray-300">In the honest setting, by construction, we have that</p>

    <p class="text-gray-300"><span class="math">W^{\\prime}</span> <span class="math">\\leftarrow W+r\\cdot W_{\\mathsf{blind}}</span> <span class="math">\\mathsf{x}^{\\prime}</span> <span class="math">\\leftarrow\\mathsf{x}+r\\cdot\\mathsf{x}_{\\mathsf{blind}}</span> <span class="math">u^{\\prime}</span> <span class="math">\\leftarrow u+r\\cdot u_{\\mathsf{blind}}</span></p>

    <p class="text-gray-300">Because <span class="math">W_{\\mathsf{blind}}</span>, <span class="math">\\mathsf{x}_{\\mathsf{blind}}</span>, and <span class="math">u_{\\mathsf{blind}}</span> are uniformly random, we have that <span class="math">W^{\\prime}</span>, <span class="math">\\mathsf{x}^{\\prime}</span>, and <span class="math">u^{\\prime}</span> are uniformly random. Moreover, <span class="math">r_{E}^{\\prime}</span> and <span class="math">r_{W}^{\\prime}</span> are computed as follows.</p>

    <p class="text-gray-300"><span class="math">r_{E}^{\\prime}</span> <span class="math">\\leftarrow r_{E}+r\\cdot r_{T}+r^{2}\\cdot r_{E_{\\mathsf{blind}}}</span> <span class="math">r_{W}^{\\prime}</span> <span class="math">\\leftarrow r_{W}+r\\cdot r_{W_{\\mathsf{blind}}}</span></p>

    <p class="text-gray-300">By the same argument as above, we have that <span class="math">r_{E}^{\\prime}</span> and <span class="math">r_{W}^{\\prime}</span> are uniformly random.</p>

    <p class="text-gray-300">Then, we have that <span class="math">E^{\\prime}</span>, <span class="math">\\overline{E}^{\\prime}</span>, and <span class="math">\\overline{W}^{\\prime}</span> are completely determined by the prior values. Therefore, because <span class="math">W^{\\prime}</span>, <span class="math">\\mathsf{x}^{\\prime}</span>, <span class="math">u^{\\prime}</span>, <span class="math">r_{E}^{\\prime}</span> and <span class="math">r_{W}^{\\prime}</span> are also randomly sampled in the ideal setting, we have that the folded instance <span class="math">(\\overline{E}^{\\prime},u^{\\prime},\\overline{W}^{\\prime},\\mathsf{x}^{\\prime})</span> and the corresponding witness <span class="math">(E^{\\prime},r_{E^{\\prime}},W^{\\prime},r_{W^{\\prime}})</span> are indistinguishable in the real and ideal settings.</p>

    <p class="text-gray-300">This implies that the view of the verifier <span class="math">\\mathcal{V}^{*}</span> is indistinguishable in both the real and ideal setting. Therefore, the output <span class="math">\\mathsf{st}^{\\prime}</span> is indistinguishable in both the real and ideal setting.</p>

    <p class="text-gray-300">Putting everything together, we have that the simulator’s output is indistinguishable from that of the interaction between an honest prover and <span class="math">\\mathcal{V}^{*}</span>. ∎</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">D.2 Core construction</h3>

    <p class="text-gray-300">We now formally define a zero-knowledge argument for <span class="math">\\mathcal{R}_{\\mathsf{VNIVC}}</span></p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Construction 6 (A zero-knowledge argument for <span class="math">\\mathcal{R}_{\\mathsf{VNIVC}}</span>).</h6>

    <p class="text-gray-300">We construct a zero-knowledge argument of a valid HyperNova proof. Let <span class="math">\\mathsf{NIFS}</span> be the non-interactive multi-folding scheme underlying HyperNova for <span class="math">(\\mathcal{R}_{1},\\mathcal{R}_{2},\\mathsf{compat},\\nu,\\mu)</span> that satisfies randomization and where <span class="math">\\mathcal{R}_{2}</span> is a committed relation with respect to a hiding commitment scheme. Let <span class="math">\\mathsf{sample}_{\\mathcal{R}_{1}}</span> be the corresponding sampling algorithm for <span class="math">\\mathsf{NIFS}</span> guaranteed by the randomization property. Let <span class="math">\\mathsf{sample}_{\\mathsf{RR1CS}}</span> be the sampling algorithm corresponding to relaxed R1CS (Construction 5). Let <span class="math">\\mathsf{NovaFS}</span> be the zero-knowledge non-interactive folding scheme for relaxed R1CS.</p>

    <p class="text-gray-300">We first construct a blinding circuit <span class="math">\\mathsf{blind}</span> that takes as input the non-interactive folding scheme’s verifier key <span class="math">\\mathsf{vk}_{\\mathsf{NIFS}}</span>, the NIVC statement <span class="math">(i,z_{0},z_{i})</span>, and as non-deterministic input a list of running instances <span class="math">\\mathsf{U}</span>, an instance <span class="math">\\mathsf{u}</span>, an index <span class="math">\\mathsf{pc}</span>, a folding proof <span class="math">\\pi</span> for <span class="math">\\mathsf{u}</span>, random instances <span class="math">\\mathsf{U}_{r}</span>, and the corresponding folding proofs <span class="math">(\\pi_{1},\\ldots,\\pi_{\\ell})</span>. It outputs an updated list of running instances <span class="math">\\mathsf{U}^{\\prime}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{blind}((\\mathsf{vk}_{\\mathsf{NIFS}},(i,z_{0},z_{i}));(\\mathsf{U},\\mathsf{u},\\mathsf{pc},\\pi),\\mathsf{U}_{r},(\\pi_{1},\\ldots,\\pi_{\\ell}))\\to\\mathsf{U}^{\\prime}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{u}</span> as <span class="math">(C,\\mathsf{u}^{\\prime})</span>, i.e., the part that commits to the witness and the remainder.</li>

      <li>Check that <span class="math">\\mathsf{u}^{\\prime}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk}_{\\mathsf{NIFS}},i,z_{0},z_{i},\\mathsf{U},\\mathsf{pc}))</span>.</li>

      <li>Check that <span class="math">1\\leq\\mathsf{pc}\\leq\\ell</span>.</li>

      <li>Fold in the fresh instance: <span class="math">\\mathsf{U}[\\mathsf{pc}]\\leftarrow\\mathsf{NIFS}.\\mathcal{V}(\\mathsf{vk}_{\\mathsf{NIFS}}[\\mathsf{pc}],\\mathsf{U}[\\mathsf{pc}],\\mathsf{u},\\pi)</span>.</li>

      <li>For <span class="math">j\\in[\\ell]</span>, compute <span class="math">\\mathsf{U}^{\\prime}[j]\\leftarrow\\mathsf{NIFS}.\\mathcal{V}(\\mathsf{vk}_{\\mathsf{NIFS}}[j],\\mathsf{U}[j],\\mathsf{U}_{r}[j],\\pi_{j})</span></li>

      <li>Output <span class="math">\\mathsf{U}^{\\prime}</span>.</li>

    </ol>

    <p class="text-gray-300">We define a zero-knowledge argument of knowledge <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda},N)\\to\\mathsf{pp}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\mathsf{pp}_{\\mathsf{NIVC}},\\mathsf{pp}_{\\mathsf{NovaFS}})\\leftarrow(\\mathsf{NIFS}.\\mathcal{G}(1^{\\lambda},N),\\mathsf{NovaFS}.\\mathcal{G}(1^{\\lambda},N))</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{K}(\\mathsf{pp},(\\varphi,(F_{1},\\ldots,F_{\\ell})))\\to(\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{NIFS}})\\leftarrow\\mathsf{NIFS}.\\mathcal{K}(\\mathsf{pp}_{\\mathsf{NIFS}},(\\varphi,(F_{1},\\ldots,F_{\\ell})))</span>.</li>

      <li>Compute <span class="math">\\mathsf{s}_{\\mathsf{blind}}\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(\\mathsf{blind})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{NovaFS}},\\mathsf{vk}_{\\mathsf{NovaFS}})\\leftarrow\\mathsf{NovaFS}.\\mathcal{K}(\\mathsf{pp}_{\\mathsf{NovaFS}},\\mathsf{s}_{\\mathsf{blind}})</span></li>

      <li>Compute and output</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}\\leftarrow(\\mathsf{pp},(\\mathsf{pk}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{NIFS}}),(\\mathsf{pk}_{\\mathsf{NovaFS}},\\mathsf{vk}_{\\mathsf{NovaFS}}))</span> <span class="math">\\mathsf{pk}\\leftarrow\\mathsf{vk}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\varPi)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=0</span>: Output <span class="math">\\bot</span>.</li>

      <li>Parse <span class="math">\\varPi</span> as <span class="math">((\\mathsf{U},\\mathsf{W}),(\\mathsf{u},\\mathsf{w}),\\mathsf{pc})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Update <span class="math">(\\mathsf{U}[\\mathsf{pc}],\\mathsf{W}[\\mathsf{pc}],\\pi)\\gets \\mathsf{NIFS}.\\mathcal{P}(\\mathsf{pk}_{\\mathsf{NIFS}}[\\mathsf{pc}],(\\mathsf{U}[\\mathsf{pc}],\\mathsf{W}[\\mathsf{pc}]),(\\mathsf{u},\\mathsf{w}))</span></li>

      <li>Sample <span class="math">\\ell</span> randomized running instance-witness pairs <span class="math">(\\mathsf{U}_{\\mathsf{r}},\\mathsf{W}_{\\mathsf{r}})</span> in <span class="math">\\mathcal{R}_1</span> with respect to the structures corresponding to <span class="math">F_1^{\\prime},\\ldots ,F_\\ell^{\\prime}</span>.</li>

      <li>For <span class="math">j\\in [\\ell ]</span>, compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathsf {U} ^ {\\prime} [ j ], \\mathsf {W} ^ {\\prime} [ j ]\\right), \\pi_ {j} \\leftarrow \\mathsf {N I F S}. \\mathcal {P} \\left(\\mathsf {p k} _ {\\mathsf {N I F S}} [ j ], \\left(\\mathsf {U} [ j ], \\mathsf {U} _ {\\mathsf {r}} [ j ]\\right), \\left(\\mathsf {W} [ j ], \\mathsf {W} _ {\\mathsf {r}} [ j ]\\right)\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a relaxed R1CS instance-witness pair corresponding to the execution of blind</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(u _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}}, w _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}}) \\leftarrow \\operatorname {e n c} (\\text {b l i n d}, ((\\mathsf {v k} _ {\\mathsf {N I F S}}, (i, z _ {0}, z _ {i})), \\mathsf {U} ^ {\\prime}), (\\mathsf {v k} _ {\\mathsf {N I F S}}, (i, z _ {0}, z _ {i}), (\\mathsf {U}, \\mathsf {u}, \\mathsf {p c}, \\pi), \\mathsf {U} _ {\\mathsf {r}}, (\\pi_ {1}, \\ldots , \\pi_ {\\ell})))</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample randomness <span class="math">r</span> and let <span class="math">\\mathsf{w}_{\\mathrm{blind}} \\gets (\\mathsf{w}_{\\mathrm{blind}}^{\\mathrm{partial}}, r)</span> compute the committed instance</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {u} _ {\\text {b l i n d}} \\leftarrow (\\mathsf {C o m m i t} (\\mathsf {p p}, \\mathsf {w} _ {\\text {b l i n d}}), \\mathsf {u} _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a randomized committed relaxed R1CS instance-witness pair <span class="math">(\\mathsf{u}_{\\mathsf{rb}},\\mathsf{w}_{\\mathsf{rb}})</span> with respect to the structure corresponding to blind.</li>

      <li>Send <span class="math">\\mathsf{u}_{\\mathrm{blind}}</span> and <span class="math">\\mathsf{u}_{\\mathrm{rb}}</span> to the verifier.</li>

      <li>Interactively randomize the instance-witness pair corresponding to the execution of blind</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(u _ {\\text {b l i n d}} ^ {\\prime}, w _ {\\text {b l i n d}} ^ {\\prime}\\right) \\leftarrow \\text {N o v a F S}. \\mathcal {P} \\left(\\mathrm {p k} _ {\\text {N o v a F S}}, \\left(u _ {\\text {b l i n d}}, w _ {\\text {b l i n d}}\\right), \\left(u _ {\\mathrm {r b}}, w _ {\\mathrm {r b}}\\right)\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">(\\mathsf{w}_{\\mathrm{blind}}^{\\prime},\\mathsf{W}^{\\prime})</span> to the verifier.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_0,z_i))\\to \\{0,1\\}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i = 0</span>: Output 1 if <span class="math">z_0 = z_i</span> and 0 otherwise.</li>

      <li>Receive <span class="math">\\mathsf{u}_{\\mathrm{blind}}</span> and <span class="math">\\mathsf{u}_{\\mathrm{rb}}</span> from the prover.</li>

      <li>Check that <span class="math">\\mathsf{enc}_{\\mathsf{inst}}^{-1}(\\mathsf{u}_{\\mathsf{blind}})</span> references <span class="math">\\mathsf{vk}_{\\mathsf{NIFS}}</span> and <span class="math">(i,z_0,z_i)</span>.</li>

      <li>Parse <span class="math">\\mathsf{U}&#x27;</span> from <span class="math">\\mathsf{enc}_{\\mathsf{inst}}^{-1}(\\mathsf{u}_{\\mathsf{blind}})</span>.</li>

      <li>Interactively randomize <span class="math">\\mathsf{u}_{\\mathrm{blind}}</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">u _ {\\text {b l i n d}} ^ {\\prime} \\leftarrow \\text {N o v a F S}. \\mathcal {V} \\left(v k _ {\\text {N o v a F S}}, u _ {\\text {b l i n d}}, u _ {\\text {r b}}\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive <span class="math">(\\mathsf{w}_{\\mathrm{blind}}^{\\prime},\\mathsf{W}^{\\prime})</span> from the prover.</li>

      <li>Check the randomized instance attests to the correct execution of blind</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf {p p}, \\mathsf {s} _ {\\text {b l i n d}}, u _ {\\text {b l i n d}} ^ {\\prime}, w _ {\\text {b l i n d}} ^ {\\prime}) \\in \\mathcal {R} _ {\\text {R R 1 C S}}</span></div>

    <p class="text-gray-300">where <span class="math">s_{\\mathrm{blind}}</span> is the structure corresponding to blind.</p>

    <p class="text-gray-300">51</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j\\in\\ell</span>, check that</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathsf{s}_{F^{\\prime}_{j}},\\mathsf{U}^{\\prime}[j],\\mathsf{W}^{\\prime}[j])\\in\\mathcal{R}_{1}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{s}_{F^{\\prime}_{j}}</span> is the structure corresponding to <span class="math">F^{\\prime}_{j}</span>.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">D.3 Proof of properties</h3>

    <p class="text-gray-300">We now prove that Construction 6 is a zero-knowledge argument of knowledge. In particular, we prove the following theorem.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Theorem 5 (A zero-knowledge argument for <span class="math">\\mathcal{R}_{\\mathsf{VNIVC}}</span>).</h6>

    <p class="text-gray-300">Construction 6 is an honest-verifier zero-knowledge argument of knowledge for <span class="math">\\mathcal{R}_{\\mathsf{VNIVC}}</span>.</p>

    <p class="text-gray-300">The proof of Theorem 5 can be decomposed into the following lemmas. We sketch the proof for completeness and knowledge soundness, and give a full proof for honest-verifier zero-knowledge.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">Construction 6 satisfies completeness and knowledge soundness.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Proof (Sketch).</h6>

    <p class="text-gray-300">The completeness and knowledge soundness of Construction 6 follows from the completeness and knowledge soundness of the underlying folding schemes. In particular, the proof proceeds similarly to that of Theorem 4 which also has the prover demonstrate the correct execution of the folding verifier, by demonstrating the knowledge of a valid instance-witness pair for a circuit containing the folding verifier (albeit recursively). ∎</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 11 (Zero-Knowledge).</h6>

    <p class="text-gray-300">Construction 6 satisfies honest-verifier zero-knowledge.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To prove honest-verifier zero-knowledge, we must construct a simulator (without access to the witness) that can produce a computationally equivalent transcript to that of an honest prover and a verifier. At a high-level, we observe that all running instances are randomized by <span class="math">\\mathsf{blind}</span> and thus can be simulated. The instance <span class="math">\\mathsf{u}_{\\mathsf{blind}}</span> attesting to the execution of <span class="math">\\mathsf{blind}</span> is itself randomized by <span class="math">\\mathsf{NovaFS}</span>, and thus the corresponding proof of valid randomization and randomized witness can be simulated due to the hiding property of the Nova folding scheme.</p>

    <p class="text-gray-300">Indeed, consider an honest-but-curious PPT adversary <span class="math">\\mathcal{V}^{<em>}</span>. We begin by constructing an honest-but-curious PPT adversary <span class="math">\\mathcal{V}^{</em>}_{\\mathsf{NovaFS}}</span> for the underlying Nova folding scheme.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}^{*}_{\\mathsf{NovaFS}}(\\mathsf{vk}_{\\mathsf{NovaFS}},\\mathsf{u}_{\\mathsf{blind}},\\mathsf{u}_{\\mathsf{rb}})\\to\\mathsf{st}_{2}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{u}^{\\prime}_{\\mathsf{blind}}\\leftarrow\\mathsf{NovaFS}.\\mathcal{V}(\\mathsf{vk}_{\\mathsf{NovaFS}},\\mathsf{u}_{\\mathsf{blind}},\\mathsf{u}_{\\mathsf{rb}})</span></p>

    <p class="text-gray-300">and record the transcript as <span class="math">\\pi_{\\mathsf{blind}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\mathsf{vk},\\mathsf{u}_{\\mathsf{blind}},\\mathsf{u}_{\\mathsf{rb}},\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\pi_{\\mathsf{blind}})</span>.</li>

    </ol>

    <p class="text-gray-300">Given <span class="math">\\mathcal{V}_{n\\text{ovafold}}^{*}</span>, let <span class="math">\\mathcal{S}_{\\text{NovaFS}}</span> be the corresponding hiding simulator for NovaFS guaranteed by Lemma 9. We construct the desired simulator as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi),(i,z_{0},z_{i}))\\to\\pi</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the prover and verifier keys</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},(F_{1},\\ldots,F_{\\ell},\\varphi))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the structure corresponding to the blind circuit:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{s}_{\\mathsf{blind}}\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(\\mathsf{blind}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the running instance-witness pairs <span class="math">(\\mathsf{U}^{\\prime},\\mathsf{W}^{\\prime})</span> with respect to the structures corresponding to <span class="math">F_{1}^{\\prime},\\ldots,F_{\\ell}^{\\prime}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{U}^{\\prime}[j],\\mathsf{W}^{\\prime}[j])\\leftarrow\\mathsf{sample}_{\\mathcal{R}_{1}}(\\mathsf{pp},\\mathsf{enc}_{\\mathsf{str}}(F_{j}^{\\prime})).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate a relaxed R1CS instance corresponding to the blinding step that outputs the randomized running instances <span class="math">\\mathsf{U}^{\\prime}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{\\mathsf{blind}}^{\\mathsf{partial}}\\leftarrow\\mathsf{enc}_{\\mathsf{inst}}(((v\\mathsf{k}_{\\mathsf{NIFS}},(i,z_{0},z_{i})),\\mathsf{U}^{\\prime})).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample commitment randomness <span class="math">r</span> and simulate the full instance:</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{u}_{\\mathsf{blind}}\\leftarrow(\\mathsf{Commit}(\\mathsf{pp},\\bot,r),\\mathsf{u}_{\\mathsf{blind}}^{\\mathsf{partial}}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Simulate the randomized instance-witness pair attesting to the correct execution of blind and the corresponding proof of correct randomization:</li>

    </ol>

    <p class="text-gray-300"><span class="math">((\\mathsf{u}_{\\mathsf{rb}},\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\pi_{\\mathsf{blind}}),\\mathsf{w}_{\\mathsf{blind}}^{\\prime})\\leftarrow\\mathcal{S}_{\\text{NovaFS}}(\\mathsf{pp},\\mathsf{s}_{\\mathsf{blind}},\\mathsf{u}_{\\mathsf{blind}}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run the <span class="math">\\mathcal{V}^{*}(\\mathsf{vk},(i,z_{0},z_{i}))</span> with randomness instantiated to the randomness found in the verifier’s message in <span class="math">\\pi_{\\mathsf{blind}}</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Send <span class="math">(\\mathsf{u}_{\\mathsf{blind}},\\mathsf{u}_{\\mathsf{rb}})</span> as the first message to <span class="math">\\mathcal{V}^{*}</span>.</li>

      <li>Send prover’s message in <span class="math">\\pi_{\\mathsf{blind}}</span> as the second message to <span class="math">\\mathcal{V}^{*}</span>.</li>

      <li>Send <span class="math">\\mathsf{w}_{\\mathsf{blind}}^{\\prime}</span> and <span class="math">\\mathsf{W}^{\\prime}</span> as the third message to <span class="math">\\mathcal{V}^{*}</span>.</li>

      <li>Let <span class="math">\\mathsf{st}_{2}</span> be the output of <span class="math">\\mathcal{V}^{*}</span>.</li>

      <li>Output <span class="math">\\mathsf{st}_{2}</span></li>

    </ol>

    <p class="text-gray-300">We now demonstrate that the simulated proof is computationally equivalent to that of an honest interaction. Consider an arbitrary PPT adversary  <span class="math">\\mathcal{A}</span> . Consider public parameters  <span class="math">\\mathsf{pp} \\gets \\mathcal{G}(1^{\\lambda}, N)</span>  and consider the following adversarially chosen structure, instance, and witness pair:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(F _ {1}, \\dots , F _ {\\ell}, \\varphi\\right), \\left(i, z _ {0}, z _ {i}\\right), \\Pi\\right) \\leftarrow \\mathcal {A} (\\mathrm {p p})</span></div>

    <p class="text-gray-300">Consider the prover and verifier keys  <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathsf{NIVC}.\\mathcal{K}(\\mathsf{pp},(F_1,\\ldots ,F_\\ell ,\\varphi))</span>  Suppose that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {N I V C}. \\mathcal {V} (\\mathrm {v k}, (i, z _ {0}, z _ {i}), \\Pi) = 1.</span></div>

    <p class="text-gray-300">Now, consider the following distribution, which represents the result of an honest interaction.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} \\mathsf {s t} _ {2} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (u _ {\\text {b l i n d}}, u _ {\\text {r b}}) \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\varPi), \\\\ r \\leftarrow \\mathcal {V} ^ {<em>} (\\mathsf {v k}, (i, z _ {0}, z _ {i}), (u _ {\\text {b l i n d}}, u _ {\\text {r b}})) \\\\ \\overline {{T}}, (w _ {\\text {b l i n d}} ^ {\\prime}, W ^ {\\prime}) \\leftarrow \\mathcal {P} (r) \\\\ \\mathsf {s t} _ {2} \\leftarrow \\mathcal {V} ^ {</em>} (\\overline {{T}}, (w _ {\\text {b l i n d}} ^ {\\prime}, W ^ {\\prime})) \\end{array} \\right. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By construction, we have that  <span class="math">\\mathcal{P}</span>  first randomly samples  <span class="math">(\\mathsf{u}_{\\mathsf{rb}},\\mathsf{w}_{\\mathsf{rb}})</span>  and then folds it into  <span class="math">(\\mathsf{u}_{\\mathsf{blind}},\\mathsf{w}_{\\mathsf{blind}})</span>  to produce the randomized instance-witness pair  <span class="math">(\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\mathsf{w}_{\\mathsf{blind}}^{\\prime})</span>  and the corresponding interactive proof  <span class="math">\\pi_{\\mathsf{blind}} = (r,\\overline{T})</span> . Moreover, by construction of NovaFS, The terms  <span class="math">\\mathsf{u}_{\\mathsf{rb}}</span> ,  <span class="math">\\mathsf{u}_{\\mathsf{blind}}^{\\prime}</span> ,  <span class="math">\\pi_{\\mathsf{blind}}</span> , and  <span class="math">\\mathsf{w}_{\\mathsf{blind}}^{\\prime}</span>  are uncorrelated with  <span class="math">\\mathsf{U}^{\\prime}</span>  and  <span class="math">\\mathsf{W}^{\\prime}</span> . Then, by the hiding property of the Nova folding scheme (Lemma 9) and by the construction of  <span class="math">\\mathcal{V}_{\\mathsf{NovaFS}}^{*}</span> , we have that  <span class="math">S_{\\mathsf{NovaFS}}</span>  can simulate  <span class="math">((\\mathsf{u}_{\\mathsf{rb}},\\mathsf{u}_{\\mathsf{blind}}^{\\prime},\\pi_{\\mathsf{blind}}),\\mathsf{w}_{\\mathsf{blind}}^{\\prime})</span>  with respect to the same verifier key  <span class="math">\\mathsf{vk}_{\\mathsf{NovaFS}}</span>  and instance  <span class="math">\\mathsf{u}_{\\mathsf{blind}}</span> . Therefore, the prior distribution is computationally equivalent to the following distribution.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} \\mathsf {s t} _ {2} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathsf {u} _ {\\text {b l i n d}} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\varPi), \\\\ \\mathsf {s} _ {\\text {b l i n d}} \\leftarrow \\mathsf {e n c} _ {\\mathsf {s t r}} (\\mathsf {b l i n d}), \\\\ (\\mathsf {u} _ {\\mathsf {r b}}, (r, \\overline {{T}}), \\mathsf {w} _ {\\mathsf {b l i n d}} ^ {\\prime}) \\leftarrow \\mathcal {S} _ {\\mathsf {N o v a F S}} (\\mathsf {p p}, \\mathsf {s} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {b l i n d}}), \\\\ r \\leftarrow \\mathcal {V} ^ {<em>} (\\mathsf {v k}, (i, z _ {0}, z _ {i}), (\\mathsf {u} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {r b}})) \\\\ \\mathsf {W} ^ {\\prime} \\leftarrow \\mathcal {P} (r) \\\\ \\mathsf {s t} _ {2} \\leftarrow \\mathcal {V} ^ {</em>} (\\overline {{T}}, (\\mathsf {w} _ {\\mathsf {b l i n d}} ^ {\\prime}, \\mathsf {W} ^ {\\prime})) \\end{array} \\right. \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, we have that  <span class="math">\\mathsf{u}_{\\text{blind}}^{\\text{partial}}</span>  is completely determined by  <span class="math">\\mathsf{vk}_{\\mathsf{NIFS}}</span> ,  <span class="math">(i, z_0, z_i)</span> , and  <span class="math">\\mathsf{U}&#x27;</span> . Then, because  <span class="math">\\mathsf{u}_{\\text{blind}}</span>  only additionally contains a hiding commitment, we have that it can be simulated by randomly sampling a commitment. Crucially, even though  <span class="math">\\mathsf{u}_{\\text{blind}}</span>  is no longer guaranteed to be satisfying, we have that  <span class="math">S_{\\text{NovaFS}}</span>  cannot distinguish this fact, and thus performs as if  <span class="math">\\mathsf{u}_{\\text{blind}}</span>  is satisfying. In particular, letting  <span class="math">\\mathsf{U}&#x27;</span>  be the result of parsing the internal state of  <span class="math">\\mathcal{P}</span> , we have that the</p>

    <p class="text-gray-300">following distribution is computationally equivalent to the former distribution.</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\mathsf {U} ^ {\\prime} \\leftarrow \\mathcal {P} (\\mathsf {p k}, (i, z _ {0}, z _ {i}), \\varPi), \\\\ \\mathsf {u} _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}} \\leftarrow \\mathsf {e n c} _ {\\text {i n s t}} (((\\mathsf {v k} _ {\\mathsf {N I F S}}, (i, z _ {0}, z _ {i})), \\mathsf {U} ^ {\\prime})), \\\\ \\mathsf {u} _ {\\text {b l i n d}} \\leftarrow (\\mathsf {C o m m i t} (\\mathsf {p p}, \\bot , r), \\mathsf {u} _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}}), \\\\ \\mathsf {s} _ {\\text {b l i n d}} \\leftarrow \\mathsf {e n c} _ {\\mathsf {s t r}} (\\mathsf {b l i n d}), \\\\ (\\mathsf {u} _ {\\mathsf {r b}}, (r, \\overline {{T}}), \\mathsf {w} _ {\\text {b l i n d}} ^ {\\prime}) \\leftarrow \\mathcal {S} _ {\\mathsf {N o v a F S}} (\\mathsf {p p}, \\mathsf {s} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {b l i n d}}), \\\\ r \\leftarrow \\mathcal {V} ^ {*} (\\mathsf {v k}, (i, z _ {0}, z _ {i}), (\\mathsf {u} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {r b}})) \\\\ \\mathsf {W} ^ {\\prime} \\leftarrow \\mathcal {P} (r) \\\\ \\mathsf {s t} _ {2} \\leftarrow \\mathcal {V} ^ {*} (\\overline {{T}}, (\\mathsf {w} _ {\\mathsf {b l i n d}} ^ {\\prime}, \\mathsf {W} ^ {\\prime})) \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Moreover, by the randomization property of the underlying multi-folding scheme, we have that  <span class="math">(\\mathsf{U}&#x27;,\\mathsf{W}&#x27;)</span>  produced by the prover is indistinguishable from one an instance-witness pair sampled randomly. Therefore, we have that the prior distribution is equivalent to the following distribution.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{ \\begin{array}{l} \\mathsf {s t} _ {2} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {U} ^ {\\prime}, \\mathsf {W} ^ {\\prime}) \\text {s a m p l e d r a n d o m l y ,} \\\\ \\mathsf {u} _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}} \\leftarrow \\mathsf {e n c} _ {\\text {i n s t}} (((\\mathsf {v k} _ {\\mathsf {N I F S}}, (i, z _ {0}, z _ {i})), \\mathsf {U} ^ {\\prime})), \\\\ \\mathsf {u} _ {\\text {b l i n d}} \\leftarrow (\\mathsf {C o m m i t} (\\mathsf {p p}, \\bot , r), \\mathsf {u} _ {\\text {b l i n d}} ^ {\\text {p a r t i a l}}), \\\\ \\mathsf {s} _ {\\text {b l i n d}} \\leftarrow \\mathsf {e n c} _ {\\mathsf {s t r}} (\\mathsf {b l i n d}), \\\\ (\\mathsf {u} _ {\\mathsf {r b}}, (r, \\overline {{T}}), \\mathsf {w} _ {\\text {b l i n d}} ^ {\\prime}) \\leftarrow \\mathcal {S} _ {\\mathsf {N o v a F S}} (\\mathsf {p p}, \\mathsf {s} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {b l i n d}}), \\\\ r \\leftarrow \\mathcal {V} ^ {<em>} (\\mathsf {v k}, (i, z _ {0}, z _ {i}), (\\mathsf {u} _ {\\mathsf {b l i n d}}, \\mathsf {u} _ {\\mathsf {r b}})) \\\\ \\mathsf {s t} _ {2} \\leftarrow \\mathcal {V} ^ {</em>} (\\overline {{T}}, (\\mathsf {w} _ {\\mathsf {b l i n d}} ^ {\\prime}, \\mathsf {W} ^ {\\prime})) \\end{array} \\right\\}. \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">However, the above distribution precisely follows the construction of the simulator. Therefore, we have that the above distribution is computationally equivalent to the following distribution.</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\mathsf {s t} _ {2} \\mid \\mathsf {s t} _ {2} \\leftarrow \\mathcal {S} (\\mathsf {p p}, (F _ {1}, \\ldots , F _ {\\ell}, \\varphi), (i, z _ {0}, z _ {i})) \\right\\}.</span></div>

    <p class="text-gray-300">Thus, we have demonstrated that the output of the simulator is computationally equivalent to that of an honest (but curious) interaction.</p>

    <h2 id="sec-80" class="text-2xl font-bold">D.4 Specializing the zero-knowledge layer for Nova's IVC proofs</h2>

    <p class="text-gray-300">Suppose that we are interested in randomizing Nova's IVC proof as opposed to an NIVC proof, we can substantially simplify the zero-knowledge layer. In particular, we can avoid the blind circuit as there is no need to hide  <span class="math">\\mathsf{pc}</span>  in the case of Nova's IVC proofs. We now provide a sketch of this simplification.</p>

    <p class="text-gray-300">The folding scheme used below is NovaFS (Construction 4), which provides the required hiding property (Lemma 9). Given a Nova IVC proof  <span class="math">\\varPi=(\\mathsf{U}_i,\\mathsf{u}_i,\\mathsf{W}_i,\\mathsf{w}_i,r_i)</span>  proving a statement  <span class="math">(i,z_0,z_i)</span>  with a verifier key of  <span class="math">\\mathsf{vk}</span> , the prover produces a randomized IVC proof  <span class="math">\\varPi&#x27;</span>  with the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold the instance-witness pairs  <span class="math">(\\mathsf{U}_i, \\mathsf{W}_i)</span>  with  <span class="math">(\\mathsf{u}_i, \\mathsf{w}_i)</span>  to get a folded instance-witness pair  <span class="math">(\\mathsf{U}_f, \\mathsf{W}_f)</span>  and a folding proof, which is a commitment to a cross-term,  <span class="math">\\overline{T}</span> .</li>

    </ol>

    <p class="text-gray-300">55</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Randomly sample a satisfying relaxed R1CS instance-witness pair <span class="math">(\\mathsf{U}_{r},\\mathsf{W}_{r})</span>.</li>

      <li>Fold the instance-witness pairs <span class="math">(\\mathsf{U}_{f},\\mathsf{W}_{f})</span> with <span class="math">(\\mathsf{U}_{r},\\mathsf{W}_{r})</span> to get a folded instance-witness pair <span class="math">(\\mathsf{U}_{i}^{\\prime},\\mathsf{W}_{i}^{\\prime})</span> and a folding proof, which is a commitment to a cross-term, <span class="math">\\overline{T}^{\\prime}</span>.</li>

      <li>Output the randomized IVC proof as <span class="math">\\Pi^{\\prime}=(\\mathsf{U}_{i},\\mathsf{u}_{i},r_{i},\\mathsf{U}_{r},\\overline{T},\\overline{T}^{\\prime},\\mathsf{W}_{i}^{\\prime})</span>.</li>

    </ol>

    <p class="text-gray-300">Given a randomized Nova IVC proof <span class="math">\\Pi^{\\prime}=(\\mathsf{U}_{i},\\mathsf{u}_{i},r_{i},\\mathsf{U}_{r},\\overline{T},\\overline{T}^{\\prime},\\mathsf{W}_{i}^{\\prime})</span>, for an IVC statement <span class="math">(i,z_{0},z_{i})</span> with a verifier key of <span class="math">\\mathsf{vk}</span>, the verifier proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">i=0</span>, check that <span class="math">z_{0}=z_{i}</span>.</li>

      <li>Otherwise:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">\\mathsf{u}_{i}.\\mathsf{x}=\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},r_{i})</span>.</li>

      <li>Check that <span class="math">(\\mathsf{u}_{i}.\\overline{E},\\mathsf{u}_{i}.u)=(\\mathsf{u}_{\\bot}.\\overline{E},1)</span>.</li>

      <li>Fold the instance <span class="math">\\mathsf{U}_{i}</span> with <span class="math">\\mathsf{u}_{i}</span> using <span class="math">\\overline{T}</span> to get a folded instance <span class="math">\\mathsf{U}_{f}</span>.</li>

      <li>Fold the instance <span class="math">\\mathsf{U}_{f}</span> with <span class="math">\\mathsf{U}_{r}</span> using <span class="math">\\overline{T}^{\\prime}</span> to get a folded instance <span class="math">\\mathsf{U}_{i}^{\\prime}</span>.</li>

      <li>Check that <span class="math">\\mathsf{W}_{i}^{\\prime}</span> is a satisfying witness to <span class="math">\\mathsf{U}_{i}^{\\prime}</span>.</li>

    </ul>

    <h2 id="sec-81" class="text-2xl font-bold">Appendix E Details of HyperNova over a cycle of elliptic curves</h2>

    <p class="text-gray-300">Let <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span> denote a 2-cycle of elliptic curves, where each curve in the cycle can be used as cryptographic group (i.e. the discrete logarithm problem is hard). Let <span class="math">\\mathbb{F}_{p}</span> and <span class="math">\\mathbb{F}_{q}</span> respectively denote the scalar field and the base field of <span class="math">\\mathbb{G}_{1}</span>. Naturally, <span class="math">\\mathbb{F}_{q}</span> and <span class="math">\\mathbb{F}_{p}</span> respectively denote the scalar field and the base field of <span class="math">\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> are both defined over <span class="math">\\mathbb{F}_{p}</span> (i.e., the scalar field of <span class="math">\\mathbb{G}_{1}</span>) and <span class="math">\\mathcal{R}_{\\mathsf{CRR1CS}}</span> is defined over <span class="math">\\mathbb{F}_{q}</span> (i.e., the scalar field of <span class="math">\\mathbb{G}_{2}</span>). We provide a multi-folding scheme for</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{R}_{1}=\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{2}=\\mathcal{R}_{\\mathsf{CCCS}},\\mathsf{compat},\\mu=1,\\nu=1)</span></p>

    <p class="text-gray-300">where the <span class="math">\\mathsf{compat}</span> predicate is defined below.</p>

    <p class="text-gray-300">Overview. Our goal is to modify the folding scheme for CCS (Construction 1) such that it can be efficiently instantiated on a cycle of elliptic curves. For simplicity, we describe and prove the case of <span class="math">\\mu=\\nu=1</span>. However, both the construction and proofs naturally generalize to the case of arbitrary values of <span class="math">\\mu</span> and <span class="math">\\nu</span>. In particular, the generalized version simply uses additional powers of a random challenge when combining claims (as in Construction 1).</p>

    <p class="text-gray-300">Suppose that the prover and the verifier are given as input a tuple consisting of a linearized committed CCS instance and a committed relaxed R1CS instance <span class="math">(\\mathsf{U}_{\\mathsf{LCCCS}},\\mathsf{U}_{\\mathsf{CRR1CS}})</span>, and a committed CCS instance <span class="math">\\mathsf{u}_{\\mathsf{CCCS}}</span>. The prover additionally takes as input witnesses <span class="math">(\\mathsf{W}_{\\mathsf{LCCCS}},\\mathsf{W}_{\\mathsf{CRR1CS}})</span> and <span class="math">\\mathsf{w}_{\\mathsf{CCCS}}</span>.</p>

    <p class="text-gray-300">The original folding scheme verifier folds the committed CCS instance <span class="math">\\mathsf{u}_{\\mathsf{CCCS}}</span> into the the linearized committed CCS instance <span class="math">\\mathsf{U}_{\\mathsf{LCCCS}}</span> to produce a new linearized committed CCS instance <span class="math">\\mathsf{U}_{\\mathsf{LCCCS}}^{\\prime}</span>. Internally, this involves finite field and hash</p>

    <p class="text-gray-300">operations. In addition, it involves one scalar multiplication and point addition. In particular, provided commitment <span class="math">C_{1}</span> in the linearized committed CCS instance <span class="math">\\mathsf{U_{LCCCS}}</span> and commitment <span class="math">C_{2}</span> in the committed CCS instance <span class="math">\\mathsf{u_{CCCS}}</span>, the HyperNova verifier, picks a random challenge <span class="math">\\rho</span>, and computes in Step 7</p>

    <p class="text-gray-300"><span class="math">C^{\\prime}\\leftarrow C_{1}+\\rho\\cdot C_{2}.</span></p>

    <p class="text-gray-300">Unfortunately, this computation makes it inefficient to represent the original verifier over the same curve that represents the computations that it verifies. To address this, we modify the original verifier to take the resulting value <span class="math">C^{\\prime}</span> as non-deterministic advice. Of course, this advice must be verified.</p>

    <p class="text-gray-300">To do so, the prover generates a relaxed R1CS instance that represents the random linear combination during the original folding protocol. In more detail, let <span class="math">\\mathsf{s_{EC}}=(A,B,C)</span> denote a committed relaxed R1CS structure defined over <span class="math">F_{q}</span>. Its public IO consists of <span class="math">(\\rho,C_{1},C_{2},C^{\\prime})</span>, where <span class="math">\\rho\\in\\mathbb{F}_{p},C_{1}\\in\\mathbb{G}_{1},C_{2}\\in\\mathbb{G}_{1},C^{\\prime}\\in\\mathbb{G}_{1}</span>. This constraint system enforces that <span class="math">C^{\\prime}=C_{1}+\\rho\\cdot C_{2}</span>, where <span class="math">+</span> is the elliptic curve point addition and <span class="math">\\cdot</span> is the elliptic curve scalar multiplication operation in <span class="math">\\mathbb{G}_{1}</span>. Since <span class="math">F_{q}</span> is the base field of <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathsf{s_{EC}}</span> computes the required point addition and scalar multiplication operations “natively” with a concise set of constraints (i.e., without the “wrong field” arithmetic).</p>

    <p class="text-gray-300">We modify the original verifier to read the inputs and outputs of this relaxed R1CS instance (rather than computing the random linear combination itself). Instead of directly checking this instance, it is folded into a running relaxed R1CS instance using the folding scheme underlying Nova <em>[43]</em>. Note that this auxiliary computation is represented on the second curve in the cycle. Thus, the Nova verifier can be natively represented over the first curve alongside the rest of the original verifier.</p>

    <p class="text-gray-300">Putting everything together, we achieve a folding scheme that takes a committed CCS instance and folds it into a linearized CCS instance and a relaxed R1CS instance to produce a new linearized CCS instance and a relaxed R1CS instance.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Construction 7 (A multi-folding scheme for CCS over cycles).</h6>

    <p class="text-gray-300">We construct a multi-folding scheme for <span class="math">(\\mathcal{R}_{1}=\\mathcal{R_{LCCCS}}\\times\\mathcal{R_{CRR1CS}},\\mathcal{R}_{2}=\\mathcal{R_{CCCS}},\\mathsf{compat},\\mu=1,\\nu=1)</span>, where <span class="math">\\mathsf{compat}</span> is defined as follows.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{compat}(\\mathsf{s}_{1},\\mathsf{s}_{2})\\to\\{\\mathsf{true},\\mathsf{false}\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\mathsf{s}_{1}</span> as <span class="math">(\\mathsf{s_{LCCCS}},\\mathsf{s_{RR1CS}})</span></li>

      <li>Check that <span class="math">\\mathsf{s_{LCCCS}}=\\mathsf{s}_{2}</span> and <span class="math">\\mathsf{s_{RR1CS}}=\\mathsf{s_{EC}}</span></li>

    </ol>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open},\\mathsf{Eval})</span> denote an additively-homomorphic polynomial commitment scheme for multilinear polynomials over <span class="math">\\mathbb{F}_{p}</span>. Let <span class="math">\\mathsf{VC}=(\\mathsf{Gen},\\mathsf{Commit},\\mathsf{Open})</span> denote an additively-homomorphic commitment scheme with succinct commitments for vectors over <span class="math">\\mathbb{F}_{q}</span></p>

    <p class="text-gray-300">We define the generator and the encoder as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {G} (1 ^ {\\lambda}, (m, N, \\ell , t, q, d \\in \\mathbb {N})) \\to \\mathfrak {p p}:</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">n = 2 \\cdot (\\ell + 1)</span></li>

      <li><span class="math">\\mathsf{pp}_{\\mathsf{PC}}\\gets \\mathsf{PC.Gen}(1^{\\lambda},\\log n - 1)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. $\\mathsf{pp}_{\\mathsf{VC}} \\gets \\mathsf{VC.Gen}(1^{\\lambda},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{s}_{\\mathsf{EC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{s}_{\\mathsf{EC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the maximum among the number of constraints or the number of witness variables in </span>\\mathsf{s}_{\\mathsf{EC}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {K} (\\mathfrak {p p}, (([\\widetilde {M} _ {1}, \\dots , \\widetilde {M} _ {t} ], [ S _ {1}, \\dots , S _ {q} ], [ c _ {1}, \\dots , c _ {q} ])), (A, B, C)) \\rightarrow (\\mathfrak {p k}, \\mathfrak {v k}):</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{pk}\\gets (\\mathsf{pp},(([\\widetilde{M}_1,\\ldots ,\\widetilde{M}_t],[S_1,\\ldots ,S_q],[c_1,\\ldots ,c_q])),(A,B,C))</span></li>

      <li><span class="math">\\mathsf{vk}\\gets \\bot</span></li>

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})</span></li>

    </ol>

    <p class="text-gray-300">The verifier <span class="math">\\mathcal{V}</span> takes a tuple consisting of a linearized committed CCS instance and a committed relaxed R1CS instance <span class="math">(\\mathsf{U}_{\\mathsf{LCCS}},\\mathsf{U}_{\\mathsf{CRR1CS}})</span>, where <span class="math">\\mathsf{U}_{\\mathsf{LCCS}} = (C_1,u,\\mathsf{x}_1,r_x,v_1,\\ldots ,v_t)</span> and <span class="math">\\mathsf{U}_{\\mathsf{CRR1CS}} = (\\overline{E}_1,u_1,\\overline{W}_1,x_1)</span>, and a committed CCS instance <span class="math">\\mathsf{u}_{\\mathsf{CCS}} = (C_2,\\mathsf{x}_2)</span>. The prover <span class="math">\\mathcal{P}</span>, in addition to these instances, takes witnesses to all instances, <span class="math">\\mathsf{W}_{\\mathsf{LCCS}} = \\widetilde{w}_1</span>, <span class="math">\\mathsf{W}_{\\mathsf{CRR1CS}} = (E_1,W_1)</span>, and <span class="math">\\mathsf{w}_{\\mathsf{CCS}} = \\widetilde{w}_2</span>.</p>

    <p class="text-gray-300">Let <span class="math">s = \\log m</span> and <span class="math">s&#x27; = \\log n</span>. Let <span class="math">\\widetilde{z_1} = (\\widetilde{w_1, u, x_1})</span> and <span class="math">\\widetilde{z_2} = (\\widetilde{w_2, 1, x_2})</span>.</p>

    <p class="text-gray-300">The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}\\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\gamma \\stackrel {\\S}{\\leftarrow}\\mathbb{F}_p,\\beta \\stackrel {\\S}{\\leftarrow}\\mathbb{F}_p^s</span>, and sends them to <span class="math">\\mathcal{P}</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Sample <span class="math">r_x&#x27; \\stackrel{\\S}{\\leftarrow} \\mathbb{F}_p^s</span>.</li>

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span>: Run the sum-check protocol <span class="math">c \\gets \\langle \\mathcal{P}, \\mathcal{V}(r_x&#x27;) \\rangle (g, s, d + 1, \\sum_{j \\in [t]} \\gamma^j \\cdot v_j)</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} g (x) := \\left(\\sum_ {j \\in [ t ]} \\gamma^ {j} \\cdot L _ {j} (x)\\right) + \\gamma^ {t + 1} \\cdot Q (x) \\\\ L _ {j} (x) := \\widetilde {e q} (r _ {x}, x) \\cdot \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {j} (x, y) \\cdot \\widetilde {z} _ {1} (y)\\right) \\\\ Q (x) := \\widetilde {e q} (\\beta , x) \\cdot \\left(\\sum_ {i = 1} ^ {q} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {j} (x, y) \\cdot \\widetilde {z} _ {2} (y)\\right)\\right) \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">((\\sigma_1, \\ldots, \\sigma_t), (\\theta_1, \\ldots, \\theta_t))</span>, where for all <span class="math">i \\in [t]</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sigma_i = \\sum_{y \\in \\{0,1\\}^r} \\widetilde{M}_i(r_x&#x27;, y) \\cdot \\widetilde{z}_1(y)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\theta_i = \\sum_{y \\in \\{0,1\\}^r} \\widetilde{M}_i(r_x&#x27;, y) \\cdot \\widetilde{z}_2(y)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">e_1 \\gets \\widetilde{eq}(r_x, r_x&#x27;)</span> and <span class="math">e_2 \\gets \\widetilde{eq}(\\beta, r_x&#x27;)</span>, and check that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c = \\left(\\sum_{j \\in [t]} \\gamma^j \\cdot e_1 \\cdot \\sigma_j + \\gamma^{t+1} \\cdot e_2 \\cdot \\left(\\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\theta_j\\right)\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\rho \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}_p<span class="math"> and sends it to </span>\\mathcal{P}$.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">\\mathcal{P}</span> computes a committed relaxed R1CS instance <span class="math">\\mathsf{u}_{\\mathsf{CRR1CS}} = (\\overline{E}_2, u_2, \\overline{W}_2, x_2)</span> with structure <span class="math">\\mathsf{s}_{\\mathsf{EC}}</span> and witness <span class="math">\\mathsf{w}_{\\mathsf{CRR1CS}} = (E_2, W_2)</span> to compute the quantity <span class="math">C_1 + \\rho \\cdot C_2</span>, such that the following hold: (1) <span class="math">u_2 = 1</span>, (2) <span class="math">\\overline{E}_1 = \\overline{0}</span>, and (3) <span class="math">x_2 = (\\rho, C_1, C_2, C&#x27;)</span> for some <span class="math">C&#x27; \\in \\mathbb{G}_1</span>. <span class="math">\\mathcal{P}</span> then sends <span class="math">\\mathsf{u}_{\\mathsf{CRR1CS}}</span> to <span class="math">\\mathcal{V}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>: Check that <span class="math">\\overline{E}_2 = \\overline{0}</span>, <span class="math">u_2 = 1</span>, and <span class="math">x_2 = (\\rho, C_1, C_2, C&#x27;)</span> for some <span class="math">C&#x27; \\in \\mathbb{G}_1</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: Send <span class="math">\\overline{T} = \\mathsf{VC}.\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}}, T)</span>, where <span class="math">T = AZ_1 \\circ BZ_2 + AZ_2 \\circ BZ_1 - u_1 \\cdot CZ_2 - u_2 \\cdot CZ_1</span>, <span class="math">Z_1 = (W_1, x_1, u_1)</span>, and <span class="math">Z_2 = (W_2, x_2, u_2)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V \\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\rho^{\\star} \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}_p<span class="math"> and sends it to </span>\\mathcal{P}$.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}, \\mathcal{P}</span>: Output the folded linearized committed CCS instance <span class="math">(C&#x27;, u&#x27;, \\times&#x27;, r_x&#x27;, v_1&#x27;, \\ldots, v_t&#x27;)</span> and the folded committed relaxed R1CS instance <span class="math">(\\overline{E}^{\\star}, u^{\\star}, \\overline{W}^{\\star}, x^{\\star})</span>, where for all <span class="math">i \\in [t]</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">u&#x27; \\gets u + \\rho \\cdot 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\times&#x27; \\gets \\times_1 + \\rho \\cdot \\times_2</span></div>

    <div class="my-4 text-center"><span class="math-block">v_i&#x27; \\gets \\sigma_i + \\rho \\cdot \\theta_i</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline{E}^{\\star} \\gets \\overline{E}_1 + \\rho^{\\star} \\cdot \\overline{T}</span></div>

    <div class="my-4 text-center"><span class="math-block">u^{\\star} \\gets u_1 + \\rho^{\\star} \\cdot 1</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline{W}^{\\star} \\gets \\overline{W}_1 + \\rho^{\\star} \\cdot \\overline{W}_2</span></div>

    <div class="my-4 text-center"><span class="math-block">x^{\\star} \\gets x_1 + \\rho^{\\star} \\cdot x_2</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>: Output the folded witnesses <span class="math">\\mathsf{W}_{\\mathsf{LCCCS}} = \\widetilde{w}&#x27; \\gets \\widetilde{w}_1 + \\rho \\cdot \\widetilde{w}_2</span> and <span class="math">\\mathsf{W}_{\\mathsf{CRR1CS}} = (E^{\\star}, W^{\\star})</span>, where <span class="math">E^{\\star} \\gets E_1 + \\rho^{\\star} \\cdot T</span> and <span class="math">W^{\\star} \\gets W_1 + \\rho^{\\star} \\cdot W_2</span>.</li>

    </ol>

    <p class="text-gray-300">We recall Theorem 4 below. We prove correctness in Appendix H.4.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Theorem 6 (A multi-folding scheme for CCS over cycles).</h6>

    <p class="text-gray-300">Construction 7 is a public-coin multi-folding scheme for <span class="math">(\\mathcal{R}_{1}=\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{2}=\\mathcal{R}_{\\mathsf{CCCS}},\\mathsf{compat},\\mu=1,\\nu=1)</span>. with perfect completeness and knowledge soundness.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Assumption 2 (Non-interactivity).</h6>

    <p class="text-gray-300">There exists a non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{\\mathsf{CCCS}},1,1)</span> in the plain model.</p>

    <p class="text-gray-300">Justification. By applying the Fiat-Shamir transformation (Construction 3) to the multi-folding scheme in Construction 7, we obtain a non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{\\mathsf{CCCS}},1,1)</span> in the random oracle model. By instantiating the random oracle with an appropriate cryptographic hash function, we heuristically obtain a non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{\\mathsf{CCCS}},1,1)</span> in the plain model. ∎</p>

    <p class="text-gray-300">Given the above multi-folding scheme, we prove that it is IVC-compatible.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Lemma 12 (IVC-compatibility).</h6>

    <p class="text-gray-300">The non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRR1CS}},\\mathcal{R}_{\\mathsf{CCCS}},1,1)</span> (Construction 7, Assumption 2) is IVC-compatible.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">NP-completeness, partial functions, and monotonicity for <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span>, the underlying relation of <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>, holds by Lemma 3. To show the default instances property, we must show that <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{CRR1CS}}</span> both have default instances. The former requirement holds by Lemma 3, and the latter requirement holds due to Kothapalli et al. <em>[43]</em>. ∎</p>

    <p class="text-gray-300">We recall Theorem 2 below.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Theorem 7 (HyperNova over cycles).</h6>

    <p class="text-gray-300">Given the multi-folding scheme in Construction 7 instantiated with the Pedersen commitment scheme, Construction 2 produces an IVC scheme such that for step functions <span class="math">F_{j}</span> for <span class="math">j\\in[\\ell]</span> that can be expressed in CCS with <span class="math">m_{j}</span> constraints of degree <span class="math">d</span> and <span class="math">q_{j}</span> monomials, <span class="math">n_{j}</span> witness variables, <span class="math">t_{j}</span> CCS matrices, and <span class="math">N_{j}</span> non-zero entries in CCS matrices, and control function <span class="math">\\varphi</span> that can be expressed in CCS with <span class="math">m</span> constraints of degree <span class="math">d</span> and <span class="math">q_{\\varphi}</span> monomials, <span class="math">n_{\\varphi}</span> witness variables, <span class="math">t_{\\varphi}</span> CCS matrices, and <span class="math">N_{\\varphi}</span> non-zero entries in the CCS matrices, the efficiency characteristics are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The NIVC prover time for each step is a single MSM of size <span class="math">O(n_{\\varphi}+n_{j})</span> and <span class="math">O((N_{\\varphi}+N_{j})+(t_{\\varphi}+t_{j})\\cdot(m_{\\varphi}+m_{j})+(q_{\\varphi}+q_{j})\\cdot(m_{\\varphi}+m_{j})\\cdot d\\cdot\\log^{2}d)</span> finite field operations</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The size of the verifier circuit is $o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2\\cdot\\mathsf{G}+(d\\cdot\\log m_{j})\\cdot\\mathsf{F}+\\log m_{j}\\cdot\\mathsf{R}_{d}+2\\cdot\\mathsf{H}_{\\ell,t_{j}}+2\\cdot\\mathsf{M})<span class="math"> on the first curve and </span>\\mathsf{G}$ on the second curve in a cycle of elliptic curves</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{G}</span> is the number of constraints required to encode a group scalar multiplication natively (i.e., without field emulation), <span class="math">\\mathsf{H}</span> is the number of constraints required to encode a hash function, <span class="math">\\mathsf{F}</span> is the number of constraints to encode field operations, <span class="math">\\mathsf{R}</span> is the number of constraints to encode a cryptographic hash function used for randomness, and <span class="math">\\mathsf{M}</span> is the number of constraints to encode to memory read/write over a memory of size <span class="math">O(\\ell)</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof (Intuition).</h6>

    <p class="text-gray-300">This follows from <em>[43, Lemma 4]</em> and Theorem 3. ∎</p>

    <h2 id="sec-89" class="text-2xl font-bold">Appendix F nlookup: A lookup argument for HyperNova</h2>

    <p class="text-gray-300">This section describes a lookup argument, which we refer to as nlookup, that is suitable for use in recursive arguments such as Nova, HyperNova, and others.</p>

    <p class="text-gray-300">Suppose that there is a table <span class="math">T</span> of size <span class="math">n</span>. Now consider <span class="math">m</span> variables <span class="math">v_{1},\\ldots,v_{m}</span> in a CCS instance and we wish to enforce that those values are contained in <span class="math">T</span>.</p>

    <p class="text-gray-300">A classic approach is to store <span class="math">T</span> as a Merkle tree for which the circuit gets as public input a commitment. Then to prove that a certain value is in <span class="math">T</span>, the prover could supply as non-deterministic advice to the circuit a Merkle proof of inclusion, and the circuit verifies the Merkle proof of inclusion. This unfortunately requires <span class="math">O(m\\cdot\\log n)</span> hash evaluations inside the circuit, which is prohibitive. Plookup <em>[29]</em> provides an approach where the number of constraints is <span class="math">O(\\max(m,n))</span>, which is acceptable when <span class="math">m\\approx n</span>. It is unsuitable in the context of recursive SNARKs such as Nova where a particular recursive step may perform <span class="math">m&lt;&lt;n</span> lookup operations. A recent flurry of works (e.g., see cq <em>[26]</em> for the latest in this line of work) consider the case where <span class="math">m&lt;&lt;n</span>, but it is unclear how to adapt them to the setting of recursive SNARKs without incurring high recursion overheads.</p>

    <p class="text-gray-300">We provide a conceptually simple and yet efficient lookup argument, that we refer to as nlookup. For <span class="math">m</span> lookups on a table of size <span class="math">n</span> entries, nlookup requires <span class="math">O(m\\log n)</span> multiplications and <span class="math">O(\\log n)</span> hash operations inside a circuit (with small constants) and the prover performs <span class="math">O(n)</span> finite field operations. In particular, the prover does not commit to any additional polynomials. This lookup argument is <em>not</em> suitable for accelerating bitwise operations in the circuit model of computation, but it is a perfect tool for expressing finite state machines efficiently with Nova and HyperNova (e.g., see <em>[63, §2.4]</em>).</p>

    <p class="text-gray-300">nlookup in a nutshell. Without loss of generality, assume that <span class="math">n=2^{\\ell}</span>. We can view <span class="math">T</span> as a function from <span class="math">\\{0,1\\}^{\\ell}\\to\\mathbb{F}</span>. Furthermore, let <span class="math">\\widetilde{T}</span> denote the unique multilinear extension of the function <span class="math">T</span>. In other words, <span class="math">\\widetilde{T}</span> is a multilinear polynomial in <span class="math">\\ell</span> variables where the entries in the table are evaluations of <span class="math">\\widetilde{T}</span> over the Boolean hypercube <span class="math">\\{0,1\\}^{\\ell}</span>. To prove <span class="math">m</span> lookup operations, the prover specifies <span class="math">m</span> evaluation points <span class="math">q_{1},\\ldots,q_{m}</span> over the Boolean hypercube such that <span class="math">\\widetilde{T}(q_{i})=v_{i}</span> for all <span class="math">i\\in[m]</span>. This requires <span class="math">O(m\\log n)</span> Booleanity checks in the circuit to ensure that <span class="math">q_{i}\\in\\{0,1\\}^{\\ell}</span> for all <span class="math">i\\in[m]</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We now devise a multi-folding scheme where the prover and the verifier fold the task of checking the correctness of <span class="math">m</span> lookup operations into task of checking an evaluation of <span class="math">\\widetilde{T}</span> at a single point in its domain. Furthermore, in our context, the circuit maintains a running claim about an evaluation of <span class="math">\\widetilde{T}</span> and the folding scheme folds incoming lookup claims into this running claim.</p>

    <p class="text-gray-300">Suppose that the running claim is <span class="math">\\widetilde{T}(q_r) \\stackrel{?}{=} v_r</span> for some <span class="math">q_r \\in \\mathbb{F}^{\\log n}</span> and <span class="math">v_r \\in \\mathbb{F}</span>. At initialization, <span class="math">q_r</span> can be arbitrary and <span class="math">v_r \\gets \\widetilde{T}(q_r)</span>. Now, the folding scheme reduces the following claim to an evaluation of <span class="math">\\widetilde{T}</span>, where <span class="math">\\rho \\in \\mathbb{F}</span> is picked by the verifier at random.</p>

    <div class="my-4 text-center"><span class="math-block">v_r + \\sum_{i = \\{1, \\dots, m\\}} \\rho^i \\cdot v_i \\stackrel{?}{=}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j \\in \\{0, 1\\}^{\\log n}} \\widetilde{e q}(q_r, j) \\cdot \\widetilde{T}(j) + \\sum_{i = \\{1, \\dots, m\\}} \\rho^i \\cdot \\sum_{j \\in \\{0, 1\\}^{\\log n}} \\widetilde{e q}(q_i, j) \\cdot \\widetilde{T}(j)</span></div>

    <p class="text-gray-300">The folding scheme applies the sum-check protocol and outputs a new claim about <span class="math">\\widetilde{T}(q_r&#x27;) \\stackrel{?}{=} v_r&#x27;</span>. The prover's work in the folding scheme is <span class="math">O(n)</span> finite field operations. The verifier's work in the non-interactive folding scheme is <span class="math">O(\\log n)</span> hash and field operations. Furthermore, at the end of the sum-check protocol (i.e., inside the folding scheme), the verifier computes evaluations of <span class="math">m</span> <span class="math">\\widetilde{e q}</span> polynomials at a random point, this takes <span class="math">O(m \\cdot \\log n)</span> multiplications.</p>

    <h2 id="sec-90" class="text-2xl font-bold">F.1 Details and security proofs</h2>

    <p class="text-gray-300"><strong>Definition 29 (Polynomial Evaluation Relation).</strong> We define the polynomial evaluation relation <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> as follows. Let the public parameters consist of size parameter <span class="math">\\ell \\in \\mathbb{N}</span>. An <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> structure consists of <span class="math">\\widetilde{T}</span>, a multilinear polynomial in <span class="math">\\ell</span> variables. An <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> instance is <span class="math">(r, v) \\in (\\mathbb{F}^\\ell, \\mathbb{F})</span> where <span class="math">r</span> is an evaluation point and <span class="math">v</span> is a claimed evaluation. An <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> witness is <span class="math">\\perp</span>. We define <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{\\mathrm{poly}} = \\left\\{ \\left. \\left((\\ell, \\widetilde{T}), (r, v), \\perp\\right) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\ell \\in \\mathbb{N}, \\widetilde{T} \\in \\mathbb{F}^1[X_1, \\dots, X_\\ell], (r, v) \\in (\\mathbb{F}^\\ell, \\mathbb{F}) \\\\ \\widetilde{T}(r) = v \\end{array} \\right\\} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Definition 30 (Lookup Relation).</strong> We define the lookup relation <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> as follows. Let the public parameters consist of size parameter <span class="math">\\ell \\in \\mathbb{N}</span>. For vector <span class="math">T \\in \\mathbb{F}^n</span> (where <span class="math">n = 2^\\ell</span>), an <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> structure consists of the corresponding multilinear extension in <span class="math">\\ell</span> variables, <span class="math">\\widetilde{T}</span>. An <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> instance consists of value <span class="math">v \\in \\mathbb{F}</span>. An <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> witness consists of index <span class="math">q \\in \\{0,1\\}^\\ell</span>. We define <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{\\mathrm{lookup}} = \\left\\{ \\left. \\left((\\ell, \\widetilde{T}), v, q\\right) \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\ell \\in \\mathbb{N}, \\widetilde{T} \\in \\mathbb{F}^1[X_1, \\dots, X_\\ell], v \\in \\mathbb{F}, q \\in \\{0, 1\\}^\\ell \\\\ \\widetilde{T}(q) = v \\end{array} \\right\\} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We now provide a multi-folding between two relations, a polynomial evaluation instance and a collection of lookup instances.</p>

    <p class="text-gray-300">62</p>

    <p class="text-gray-300">63</p>

    <p class="text-gray-300">Construction 8 (A multi-folding scheme for lookup instances). We construct a multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathrm{poly}},\\mathcal{R}_{\\mathrm{lookup}},\\mathrm{compat},\\mu = 1,\\nu)</span> for arbitrary <span class="math">\\nu \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2)\\to \\{\\mathsf{true},\\mathsf{false}\\}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2</span>, then return true, otherwise, return false.</li>

    </ol>

    <p class="text-gray-300">We define the generator and the encoder as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{G}(1^{\\lambda},N)\\to \\mathsf{pp}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample size bound <span class="math">\\ell \\in \\mathbb{N}</span></li>

      <li>Output <span class="math">\\mathsf{pp} = \\ell</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}(\\mathsf{pp} = \\ell, \\widetilde{T} \\in \\mathbb{F}^1[X_1, \\ldots, X_\\ell]) \\to (\\mathsf{pk}, \\mathsf{vk})</span>: Output <span class="math">(\\mathsf{pk}, \\mathsf{vk}) = ((\\mathsf{pp}, \\widetilde{T}), \\mathsf{pp})</span>.</li>

    </ul>

    <p class="text-gray-300">The prover takes as input <span class="math">\\mathsf{pk} = (\\mathsf{pp} = \\ell, \\widetilde{T})</span> and the verifier takes as input <span class="math">\\mathsf{vk} = \\mathsf{pp} = \\ell</span>. The verifier <span class="math">\\mathcal{V}</span> takes a polynomial evaluation instance <span class="math">(q_r, v_r)</span> and a vector of lookup instances <span class="math">(v_1, \\ldots, v_m)</span>. The prover <span class="math">\\mathcal{P}</span>, in addition to the instances, takes witnesses to the lookup instances <span class="math">(q_1, \\ldots, q_m)</span>.</p>

    <p class="text-gray-300">The prover and the verifier proceed as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">(q_1, \\ldots, q_m)</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Check that for all <span class="math">i\\in [m]</span>, <span class="math">q_{i}\\in \\{0,1\\}^{\\ell}</span>.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span>: <span class="math">\\mathcal{V}</span> samples <span class="math">\\rho \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}<span class="math"> and send it to </span>\\mathcal{P}$.</li>

      <li><span class="math">\\mathcal{V}</span>: Sample <span class="math">q_r&#x27; \\stackrel{\\</span>}{\\leftarrow} \\mathbb{F}^s$.</li>

      <li><span class="math">\\mathcal{V} \\leftrightarrow \\mathcal{P}</span>: Run the sum-check protocol <span class="math">c \\gets \\langle \\mathcal{P}, \\mathcal{V}(q_r&#x27;) \\rangle (g, \\ell, 2, v_r + \\sum_{i \\in [m]} \\rho^i \\cdot v_i)</span>, where:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">g(x) := \\widehat{eq}(q_r, x) \\cdot \\widetilde{T}(x) + \\sum_{i \\in [m]} \\rho^i \\cdot \\widehat{eq}(q_i, x) \\cdot \\widetilde{T}(x)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span>: <span class="math">v_r&#x27;</span>, where <span class="math">v_r&#x27; = \\widetilde{T}(q_r&#x27;)</span>.</li>

      <li><span class="math">\\mathcal{V}</span>: Compute <span class="math">e \\gets \\widehat{eq}(q_r, q_r&#x27;)</span> and <span class="math">e_i \\gets \\widehat{eq}(q_i, q_r&#x27;)</span> for all <span class="math">i \\in [m]</span>. About if</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c \\neq e \\cdot v_r&#x27; + \\sum_{i \\in [m]} \\rho^i \\cdot e_i \\cdot v_r&#x27;.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}, \\mathcal{P}</span>: Output the folded polynomial evaluation instance <span class="math">(q_r&#x27;, v_r&#x27;)</span>.</li>

    </ol>

    <p class="text-gray-300">Theorem 8 (nlookup). Construction 8 is a public-coin multi-folding scheme for <span class="math">(\\mathcal{R}_{\\mathrm{poly}},\\mathcal{R}_{\\mathrm{lookup}},\\mathrm{compat},\\mu = 1,\\nu)</span> for arbitrary <span class="math">\\nu \\in \\mathbb{N}</span>.</p>

    <p class="text-gray-300">roof (Intuition). Completeness and knowledge soundness holds by the completeness and soundness of the sumcheck protocol. We provide a formal proof in Appendix H.5. ∎</p>

    <h2 id="sec-91" class="text-2xl font-bold">Appendix G Building HyperNova with a black-box use of Nova</h2>

    <p class="text-gray-300">We design a step circuit for Nova that runs the verifier’s logic in any IVC-compatible non-interactive multi-folding scheme. The step circuit is encoded with R1CS (a popular NP-complete constraint system <em>[31]</em>) and proven incrementally with Nova, but the step circuit is only in charge of running the verifier of the non-interactive multi-folding scheme, in addition to simple bookkeeping. As a result, this provides an IVC scheme, where each step of the incremental computation is expressed with any NP-complete language that has an IVC-compatible multi-folding scheme. Furthermore, we achieve this with a black box use of an IVC scheme for R1CS.</p>

    <p class="text-gray-300">In Nova, each step circuit takes as input the output of the previous step and produces the output for the current step. In HyperNova, besides the application’s IO, we augment them with the latest running instance. At each recursive step, the step circuit gets as non-deterministic input a purported instance <span class="math">\\mathsf{u}</span> in <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span> and <span class="math">\\pi</span>, where <span class="math">\\pi</span> is the prover’s output in the non-interactive multi-folding scheme. The step circuit checks that the public input of <span class="math">\\mathsf{u}</span> matches the application’s input provided to the step circuit. If so, it runs the verifier of the non-interactive folding scheme on <span class="math">(\\mathsf{vk},\\mathsf{U},\\mathsf{u},\\pi)</span>, where <span class="math">\\mathsf{vk}</span> is the verifier’s key and <span class="math">\\mathsf{U}</span> is the latest running instance passed from the prior step. It then provides uses the public output of <span class="math">\\mathsf{u}</span> and the output of the folding scheme verifier to construct the step’s output.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Construction 9 (A step circuit for Nova).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{NIFS}</span> be an IVC-compatible non-interactive multi-folding scheme for <span class="math">(\\mathcal{R}_{1},\\mathcal{R}_{2},1,1)</span>. Let <span class="math">\\mathsf{IVC}</span> denote the Nova’s IVC scheme for functions expressed as R1CS constraints.</p>

    <p class="text-gray-300">We first define a non-deterministic polynomial-time function <span class="math">\\mathsf{step}</span>, represented as an R1CS structure, that iteratively folds instances expressed in <span class="math">\\mathcal{R}_{\\mathsf{CCCS}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{step}(\\mathsf{vk},\\mathsf{U}_{i},z_{i};(\\mathsf{u},\\pi))\\to(\\mathsf{vk},\\mathsf{U}_{i+1},z_{i+1})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">(\\mathsf{in},\\mathsf{out})\\leftarrow\\mathsf{enc}_{\\mathsf{inst}}^{-1}(\\mathsf{u}^{\\prime})</span>, where <span class="math">\\mathsf{u}^{\\prime}</span> represents the portion of <span class="math">\\mathsf{u}</span> that does not contain commitments to the witness.</li>

      <li>Check that <span class="math">\\mathsf{in}=z_{i}</span></li>

      <li>Compute <span class="math">\\mathsf{U}_{i+1}\\leftarrow\\mathsf{NIFS}.\\mathsf{V}(\\mathsf{vk},\\mathsf{U}_{i},\\mathsf{u},\\pi)</span></li>

      <li>Output <span class="math">(\\mathsf{vk},\\mathsf{U}_{i+1},\\mathsf{out})</span></li>

    </ol>

    <p class="text-gray-300">Given <span class="math">F</span>, we define the corresponding IVC scheme <span class="math">(\\mathcal{G},\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>, which uses Nova in a black-box manner.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda},N)\\to\\mathsf{pp}</span>: Output <span class="math">(\\mathsf{NIFS}.\\mathcal{G}(1^{\\lambda},N),\\mathsf{IVC}.\\mathcal{G}(1^{\\lambda},N))</span></p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}((\\mathsf{pp}_{\\mathsf{NIFS}},\\mathsf{pp}_{\\mathsf{IVC}}),F)\\to (\\mathsf{pk},\\mathsf{vk})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{s}_1,\\mathsf{s}_2)\\gets \\mathsf{enc}_{\\mathsf{str}}(F)</span></li>

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{NIFS}})\\gets \\mathsf{NIFS.K}(\\mathsf{pp}_{\\mathsf{NIFS}},\\mathsf{s}_1,\\mathsf{s}_2)</span></li>

      <li>Compute <span class="math">(\\mathsf{pk}_{\\mathsf{IVC}},\\mathsf{vk}_{\\mathsf{IVC}})\\gets \\mathsf{IVC.K}(\\mathsf{pp}_{\\mathsf{IVC}},\\mathsf{step})</span></li>

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets ((F,\\mathsf{pk}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{NIFS}},\\mathsf{pk}_{\\mathsf{IVC}}),(\\mathsf{step},\\mathsf{pp}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{NIFS}},\\mathsf{vk}_{\\mathsf{IVC}})).</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{P}(\\mathsf{pk},(i,z_0,z_i),\\omega_i,\\Pi_i)\\to \\Pi_{i + 1}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">(\\Pi_i&#x27;,\\mathsf{U}_i,\\mathsf{W}_i)</span></li>

      <li>Let <span class="math">z_{i + 1}\\gets F(z_i,\\omega_i)</span> and compute <span class="math">(\\mathsf{u}_i,\\mathsf{w}_i)\\gets \\mathsf{enc}(F,(z_i,z_{i + 1}),\\omega_i).</span></li>

      <li>Compute <span class="math">(\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1},\\pi_{i + 1})\\gets \\mathsf{NIFS.P}(\\mathsf{pk}_{\\mathsf{NIFS}},(\\mathsf{U}_i,\\mathsf{W}_i),(\\mathsf{u}_i,\\mathsf{w}_i))</span></li>

      <li>Compute <span class="math">\\Pi_{i + 1}^{\\prime}\\gets \\mathsf{IVC.P}(\\mathsf{pk}_{\\mathsf{IVC}},i,(\\mathsf{vk}_{\\mathsf{NIFS}},\\mathsf{u}_{\\perp},z_0),(\\mathsf{vk}_{\\mathsf{NIFS}},\\mathsf{U}_i,z_i),(\\mathsf{u}_i,\\pi_{i + 1}),\\Pi_i^{\\prime})</span></li>

      <li>Output <span class="math">\\Pi_{i + 1} = (\\Pi_{i + 1}^{\\prime},\\mathsf{U}_{i + 1},\\mathsf{W}_{i + 1})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(i,z_0,z_i),\\Pi_i)\\to \\{0,1\\}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">(\\Pi_i&#x27;,\\mathsf{U}_i,\\mathsf{W}_i)</span>.</li>

      <li>Check that IVC.V(vkIVC, i, (vkNIFS, u⊥, z0), (vkNIFS, U_i, z_i), Π_i') = 1</li>

      <li>Check that (ppNIFS, step, U_i, W_i) ∈ RLCCCS</li>

    </ol>

    <p class="text-gray-300">Theorem 9 (A simple construction for IVC). Construction 9 is an IVC scheme.</p>

    <h2 id="sec-93" class="text-2xl font-bold">H Deferred Proofs</h2>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">H.1 Proof of Theorem 1 (A multi-folding scheme for CCS)</h3>

    <p class="text-gray-300">Lemma 13 (Perfect Completeness). Construction 1 satisfies perfect completeness.</p>

    <p class="text-gray-300">Proof. Consider the public parameters <span class="math">\\mathsf{pp} = (m,n,N,\\ell ,t,q,d,\\mathsf{pp}_{\\mathsf{PC}})\\gets \\mathcal{G}(1^{\\lambda},N)</span> and let <span class="math">s = \\log m</span> and <span class="math">s^{\\prime} = \\log n</span>.</p>

    <p class="text-gray-300">Consider arbitrary structures <span class="math">(\\mathsf{s}_1,\\mathsf{s}_2)</span>, where <span class="math">\\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2) = \\mathsf{true}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {s} _ {1} = \\mathsf {s} _ {2} = (\\widetilde {M} _ {1}, \\dots , \\widetilde {M} _ {t}), (S _ {1}, \\dots , S _ {q}), (c _ {1}, \\dots , c _ {q}) \\leftarrow \\mathcal {A} (\\mathsf {p p}).</span></div>

    <p class="text-gray-300">Consider the prover and verifier keys <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},(\\mathsf{s}_1,\\mathsf{s}_2))</span>. Suppose that the prover and the verifier are provided <span class="math">\\mu</span> linearized committed CCS instances <span class="math">\\vec{u}_1</span> and <span class="math">\\nu</span> committed CCS instances <span class="math">\\vec{u}_2</span>. Suppose that the prover additionally is provided with the corresponding satisfying witnesses <span class="math">\\vec{w}_1</span> and <span class="math">\\vec{w}_2</span>.</p>

    <p class="text-gray-300">As in the construction, let <span class="math">s = \\log m</span> and <span class="math">s&#x27; = \\log n</span>. Let <span class="math">\\widetilde{z}_{1,k} = (\\widetilde{w,u,\\times})</span>, where <span class="math">w = \\mathcal{L}_k.w</span>, <span class="math">u = \\mathcal{L}_k.\\phi .u</span>, and <span class="math">\\times = \\mathcal{L}_k.\\phi .\\times</span>. Similarly, let <span class="math">\\widetilde{z}_{2,k} = (\\widetilde{w,1,\\times})</span>, where <span class="math">w = \\mathcal{C}_k.w</span> and <span class="math">\\times = \\mathcal{C}_k.\\phi .\\times</span>.</p>

    <p class="text-gray-300">Because the input linearized committed CCS instance-witness pairs are satisfying, we have for all <span class="math">j \\in [t]</span> and <span class="math">k \\in [\\mu]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} v_{j,k} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x, y) \\cdot \\widetilde{z}_{1,k}(y) \\quad \\text{By precondition.} \\\\ = \\sum_{x \\in \\{0,1\\}^s} \\widetilde{eq}(r_x, x) \\cdot \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{1,k}(y)\\right) \\quad \\text{By Lemma 6.} \\\\ = \\sum_{x \\in \\{0,1\\}^s} L_{j,k}(x) \\quad \\text{By construction.} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Moreover, because the input committed CCS instance-witness pairs are satisfying, for all <span class="math">k \\in [\\nu]</span>, we have, for all <span class="math">x \\in \\{0,1\\}^s</span> that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right)</span></div>

    <p class="text-gray-300">Therefore, for all <span class="math">k \\in [\\nu]</span>, we have that the polynomial in variables <span class="math">t</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{x \\in \\{0,1\\}^s} \\widetilde{eq}(t, x) \\cdot \\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right)</span></div>

    <p class="text-gray-300">must be the zero polynomial. Therefore, for <span class="math">\\beta</span> sampled by the verifier, we have that for all <span class="math">k \\in [\\nu]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\sum_{x \\in \\{0,1\\}^s} \\widetilde{eq}(\\beta, x) \\cdot \\sum_{i=1}^{q} c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right) \\\\ = \\sum_{x \\in \\{0,1\\}^s} Q_k(x) \\quad \\text{By construction.} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, for <span class="math">\\gamma</span> sampled by the verifier, by linearity, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot \\mathcal{L}_k.\\phi.v_j = \\sum_{x \\in \\{0,1\\}^s} \\left(\\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot L_{j,k}(x)\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot Q_k(x)\\right)\\right) \\\\ = \\sum_{x \\in \\{0,1\\}^s} g(x) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by the perfect completeness of the sum-check protocol, we have for <span class="math">e_1 = \\widetilde{eq}(r_x, r_x&#x27;)</span>, <span class="math">e_2 = \\widetilde{eq}(\\beta, r_x&#x27;)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{j,k} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z}_{1,k}(y),</span></div>

    <p class="text-gray-300">for <span class="math">j \\in [t]</span> and <span class="math">k \\in [\\mu]</span>, and</p>

    <div class="my-4 text-center"><span class="math-block">\\theta_{j,k} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z}_{2,k}(y)</span></div>

    <p class="text-gray-300"><span class="math">j \\in [t]</span> and <span class="math">k \\in [\\nu]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c &amp;amp;= g(r_x&#x27;) \\\\ &amp;amp;= \\left( \\left( \\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot L_{j,k}(r_x&#x27;) \\right) + \\left( \\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot Q_k(r_x&#x27;) \\right) \\right) \\\\ &amp;amp;= \\left( \\left( \\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot e_1 \\cdot \\sigma_{j,k} \\right) + \\left( \\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot e_2 \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_{j,k} \\right) \\right). \\end{aligned}</span></div>

    <p class="text-gray-300">This implies that the verifier will not abort.</p>

    <p class="text-gray-300">Now, consider the following linearized committed CCS instances obtained by reducing input committed CCS instances (for all <span class="math">k \\in [\\nu]</span>):</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\mathcal{C}_k.\\phi.C, 1, \\mathcal{C}_k.\\phi.x, r_x&#x27;, \\theta_{1,k}, \\dots, \\theta_{t,k} \\right).</span></div>

    <p class="text-gray-300">By the precondition that committed CCS instance-witness pairs are satisfying and by the definition of <span class="math">(\\theta_{1,k},\\ldots,\\theta_{t,k})</span> for all <span class="math">k \\in [\\nu]</span>, we have that <span class="math">k</span>th linearized committed CCS instance is satisfied by the witness of the <span class="math">k</span>th committed CCS instances i.e., <span class="math">\\mathcal{C}_k.w</span>.</p>

    <p class="text-gray-300">Therefore, for a random <span class="math">\\rho</span> sampled by the verifier, and for</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} C &amp;amp;\\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k.\\phi.C + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k.\\phi.C \\\\ u &amp;amp;\\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k.\\phi.u + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot 1 \\\\ x &amp;amp;\\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k.\\phi.x + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k.\\phi.x \\\\ v_j &amp;amp;\\leftarrow \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\sigma_{j,k} + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\theta_{j,k} \\end{aligned}</span></div>

    <p class="text-gray-300">we have that the output linearized CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C, u, x, r_x&#x27;, v_1, \\dots, v_t)</span></div>

    <p class="text-gray-300">is satisfied by the witness <span class="math">\\widetilde{w} \\gets \\sum_{k \\in [\\mu]} \\rho^k \\cdot \\mathcal{L}_k.w + \\sum_{k \\in [\\nu]} \\rho^{\\mu+k} \\cdot \\mathcal{C}_k.w</span> by linearity and the additive homomorphism property of the polynomial commitment scheme.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">67</p>

    <p class="text-gray-300">Some of our probabilistic analysis below is adapted from the proof of forking lemma for folding schemes <em>[43]</em>, which itself builds on the proof of the forking lemma for interactive arguments <em>[11]</em>.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Lemma 14 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 1 satisfies knowledge soundness.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the structure and instances, and a malicious prover <span class="math">\\mathcal{P}^{*}</span> that succeeds with probability <span class="math">\\epsilon</span>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span>. Suppose on input <span class="math">\\mathsf{pp}</span> and random tape <span class="math">\\mathsf{r}</span>, the adversary <span class="math">\\mathcal{A}</span> picks structures satisfying <span class="math">\\mathsf{compat}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{s}=\\mathsf{s}_{1}=\\mathsf{s}_{2}=([M_{1},\\ldots,M_{t}],[S_{1},\\ldots,S_{q}],[c_{1},\\cdots,c_{q}]),</span></p>

    <p class="text-gray-300"><span class="math">\\mu</span> linearized committed CCS instances, <span class="math">\\nu</span> committed CCS instances, and some auxiliary state <span class="math">\\mathsf{st}</span>. We now construct an expected-polynomial time extractor <span class="math">\\mathcal{E}</span> that succeeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in obtaining satisfying witnesses for the original instances.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4"><span class="math">\\mathcal{E}(\\mathsf{pp},\\mathsf{r})</span>:</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain the output tuple from <span class="math">\\mathcal{A}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">((\\mathsf{s}_{1},\\mathsf{s}_{2}),(\\vec{u}_{1},\\vec{u}_{2}),\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp},\\mathsf{r}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},(\\mathsf{s}_{1},\\mathsf{s}_{2}))</span>.</li>

      <li>Run the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{u}^{(1)},\\mathsf{w}^{(1)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\vec{u}_{1},\\vec{u}_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">once with the final verifier challenge <span class="math">\\rho^{(1)}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Abort if <span class="math">(\\mathsf{pp},\\mathsf{s},\\mathsf{u}^{(1)},\\mathsf{w}^{(1)})\\not\\in\\mathcal{R}_{\\mathsf{LCCCS}}</span>.</li>

      <li>For <span class="math">i\\in\\{2,\\ldots,\\mu+\\nu\\}</span>, rewind the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{u}^{(i)},\\mathsf{w}^{(i)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\vec{u}_{1},\\vec{u}_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">with a different verifier’s final challenge <span class="math">\\rho^{(i)}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> while maintaining the same prior randomness. Keep doing so until </span>(\\mathsf{pp},\\mathsf{s},\\mathsf{u}^{(i)},\\mathsf{w}^{(i)})\\in\\mathcal{R}_{\\mathsf{LCCCS}}$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interpolating points <span class="math">(\\rho^{(i)},\\mathsf{w}^{(i)})</span> for all <span class="math">i\\in[\\mu+\\nu]</span> retrieve <span class="math">\\mu</span> witnesses <span class="math">\\vec{\\mathsf{w}}_{1}=(\\mathsf{w}_{1,1},\\ldots,\\mathsf{w}_{1,\\mu})</span> and <span class="math">\\nu</span> witnesses <span class="math">\\vec{\\mathsf{w}}_{2}=(\\mathsf{w}_{2,1},\\ldots,\\mathsf{w}_{2,\\nu})</span> such that for <span class="math">i\\in[\\mu+\\nu]</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{w}^{(i)}=\\sum_{k\\in[\\mu]}\\rho^{k}\\cdot\\mathsf{w}_{1,k}+\\sum_{k\\in[\\nu]}\\rho^{\\mu+k}\\cdot\\mathsf{w}_{2,k}.</span> (12)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\vec{\\mathsf{w}}_{1},\\vec{\\mathsf{w}}_{2})</span>.</li>

    </ol>

    <p class="text-gray-300">We first demonstrate that the extractor <span class="math">\\mathcal{E}</span> runs in expected polynomial time. Observe that <span class="math">\\mathcal{E}</span> runs the interaction once, and if it does not abort, keeps rerunning the interaction until <span class="math">\\mathcal{P}^*</span> succeeds. Thus, the expected number of times <span class="math">\\mathcal{E}</span> runs the interaction is</p>

    <div class="my-4 text-center"><span class="math-block">1 + \\Pr[\\text{First call to } \\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}] \\cdot \\frac{\\mu + \\nu - 1}{\\Pr[\\langle \\mathcal{P}^*, \\mathcal{V} \\rangle \\text{ succeeds}]} = 1 + \\epsilon \\cdot \\frac{\\mu + \\nu - 1}{\\epsilon} = \\mu + \\nu.</span></div>

    <p class="text-gray-300">Therefore, we have that the extractor runs in expected polynomial-time.</p>

    <p class="text-gray-300">We now analyze <span class="math">\\mathcal{E}</span>'s success probability. We must demonstrate that <span class="math">\\mathcal{E}</span> succeeds in producing <span class="math">\\vec{\\mathbf{w}}_1</span> and <span class="math">\\vec{\\mathbf{w}}_2</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pp}, \\mathsf{s}, \\vec{u}_1, \\vec{\\mathbf{w}}_1) \\in \\mathcal{R}_{\\mathsf{LCCCS}} \\quad \\text{and} \\quad (\\mathsf{pp}, \\mathsf{s}, \\vec{u}_2, \\vec{\\mathbf{w}}_2) \\in \\mathcal{R}_{\\mathsf{CCCS}}</span></div>

    <p class="text-gray-300">with probability <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To do so, we first show that the extractor successfully produces some output (i.e., does not abort) in under $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> rewinding steps with probability </span>\\epsilon - \\mathrm{negl}(\\lambda)<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a worst case bound and we have already established that the extractor runs in expected polynomial time. By the malicious prover&#x27;s success probability, we have that the extractor does not abort in step (4) with probability </span>\\epsilon<span class="math">. Given that the extractor does not abort in step (4), by Markov&#x27;s inequality, we have that the extractor rewinds more than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times with probability </span>(\\mu + \\nu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, the probability that the extractor does not abort in step (4) and requires less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> rewinds is </span>(1 - (\\mu + \\nu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\cdot \\epsilon = \\epsilon - \\mathrm{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, if the extractor does not abort, we show that the extractor succeeds in producing satisfying witnesses with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>. This brings the overall extractor success probability to <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Indeed, for <span class="math">i \\in \\{1, \\dots, \\mu + \\nu\\}</span>, let <span class="math">\\mathsf{u}^{(i)} = (C^{(i)}, u^{(i)}, \\mathsf{x}^{(i)}, r_x^{(i)}, v_1^{(i)}, \\dots, v_t^{(i)})</span>. We first show that the retrieved polynomials are valid openings to the corresponding commitments in the instance. For <span class="math">i \\in \\{1, \\dots, \\mu + \\nu\\}</span>, because <span class="math">\\mathsf{w}^{(i)}</span> is a satisfying witness, by construction,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{k \\in [\\mu]} \\rho^{(i)^k} \\cdot \\operatorname{Commit}(\\mathsf{pp}, \\mathsf{w}_{1,k}) + \\sum_{k \\in [\\nu]} \\rho^{(i)^{\\mu+k}} \\cdot \\operatorname{Commit}(\\mathsf{pp}, \\mathsf{w}_{2,k}) \\\\ = \\operatorname{Commit}(\\mathsf{pp}, \\left(\\sum_{k \\in [\\mu]} \\rho^{(i)^k} \\cdot \\mathsf{w}_{1,k}\\right) + \\left(\\sum_{k \\in [\\nu]} \\rho^{(i)^{\\mu+k}} \\cdot \\mathsf{w}_{2,k}\\right)) \\quad \\text{By additive homomorphism.} \\\\ = \\operatorname{Commit}(\\mathsf{pp}, \\mathsf{w}^{(i)}) \\quad \\text{By Equation (12).} \\\\ = C^{(i)} \\quad \\text{Witness } \\mathsf{w}^{(i)} \\text{ is a satisfying opening.} \\\\ = \\sum_{k \\in [\\mu]} \\rho^{(i)^k} \\cdot \\mathsf{u}_{1,k} \\cdot C + \\sum_{k \\in [\\nu]} \\rho^{(i)^{\\mu+k}} \\cdot \\mathsf{u}_{2,k} \\cdot C \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Interpolating, we have that for all <span class="math">i \\in [\\mu]</span> and <span class="math">j \\in [\\nu]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m m i t} (\\mathfrak {p p}, \\mathrm {w} _ {1, i}) = \\mathrm {u} _ {1, i}. C \\tag {13}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m m i t} (\\mathfrak {p p}, \\mathrm {w} _ {2, j}) = \\mathrm {u} _ {2, j}. C. \\tag {14}</span></div>

    <p class="text-gray-300">Next, we must argue that <span class="math">\\vec{\\mathsf{w}}_1</span> and <span class="math">\\vec{\\mathsf{w}}_2</span> satisfy the remainder of the instances <span class="math">\\vec{u}_1</span> and <span class="math">\\vec{u}_2</span> respectively under the structure <span class="math">\\mathsf{s}</span>.</p>

    <p class="text-gray-300">Indeed, consider <span class="math">\\{\\sigma_{j,k}\\}</span> (for all <span class="math">j\\in [t]</span> and <span class="math">k\\in [\\mu]</span>), and <span class="math">\\{\\theta_{j,k}\\}</span> (for all <span class="math">j\\in [t]</span> and <span class="math">k\\in [\\nu]</span>) sent by the prover which by the extractor's construction are identical across all executions of the interaction. By the verifier's computation we have that for <span class="math">i\\in \\{1,\\ldots ,\\mu +\\nu \\}</span> and all <span class="math">j\\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {k \\in [ \\mu ]} (\\rho^ {(i)}) ^ {k} \\cdot \\sigma_ {j, k} + \\sum_ {k \\in [ \\nu ]} (\\rho^ {(i)}) ^ {\\mu + k} \\cdot \\theta_ {j, k} = v _ {j} ^ {(i)} \\tag {15}</span></div>

    <p class="text-gray-300">Now, because <span class="math">\\mathsf{w}^{(i)}</span> is a satisfying witness, for <span class="math">i\\in \\{1,\\ldots ,\\mu +\\nu \\}</span> we have for all <span class="math">j\\in [t]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">v _ {j} ^ {(i)} = \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M _ {j}} (r _ {x} ^ {\\prime}, y) \\cdot \\widetilde {z} ^ {(i)} (y),</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{z}^{(i)} = (\\widetilde{w^{(i)},\\overline{u^{(i)}}},\\mathsf{x}^{(i)})</span> where <span class="math">w^{(i)}</span> is the result of interpreting <span class="math">\\mathsf{w}^{(i)}</span> as a multilinear polynomial.</p>

    <p class="text-gray-300">However, by Equations (12) and (15), for <span class="math">i \\in \\{1, \\dots, \\mu + \\nu\\}</span> and <span class="math">j \\in [t]</span>, this implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {k \\in [ \\mu ]} (\\rho^ {(i)}) ^ {k} \\cdot \\sigma_ {j, k} + \\sum_ {k \\in [ \\nu ]} (\\rho^ {(i)}) ^ {\\mu + k} \\cdot \\theta_ {j, k} \\\\ = \\sum_ {k \\in [ \\mu ]} (\\rho^ {(i)}) ^ {k} \\cdot \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M _ {j}} (r _ {x} ^ {\\prime}, y) \\cdot \\widetilde {z _ {1 , k}} (y) \\\\ + \\sum_ {k \\in [ \\nu ]} (\\rho^ {(i)}) ^ {\\mu + k} \\cdot \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M _ {j}} (r _ {x} ^ {\\prime}, y) \\cdot \\widetilde {z _ {2 , k}} (y), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{z_{1,k}} = (\\widetilde{w_{1,k},\\overline{u},\\mathsf{u}_{1,k}}.\\mathsf{x})</span> for <span class="math">k\\in [\\mu ]</span> where <span class="math">\\widetilde{w_{1,k}}</span> denotes the multilinear polynomial interpretation of <span class="math">\\mathsf{w}_{1,k}</span> and <span class="math">\\widetilde{z_{2,k}} = (\\widetilde{w_{2,k},\\overline{1},\\mathsf{u}_{2,k}}.\\mathsf{x})</span> for <span class="math">k\\in [\\nu ]</span> where <span class="math">w_{2,k}</span> represents the multilinear polynomial interpretation of <span class="math">\\mathsf{w}_{2,k}</span>. Interpolating, we have that, for all <span class="math">j\\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ \\mu ], \\sigma_ {j, k} = \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M _ {j}} (r _ {x} ^ {\\prime}, y) \\cdot \\widetilde {z _ {1 , k}} (y)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ \\nu ], \\theta_ {j, k} = \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M _ {j}} (r _ {x} ^ {\\prime}, y) \\cdot \\widetilde {z _ {2 , k}} (y)</span></div>

    <p class="text-gray-300">Thus, because that the verifier does not abort, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c &amp;amp;= \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot e_1 \\cdot \\sigma_{j,k}\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot e_2 \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_j\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot \\widetilde{eq}(r_x, r&#x27;_x) \\cdot \\sigma_{j,k}\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot \\widetilde{eq}(\\beta, r&#x27;_x) \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_{j,k}\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot \\widetilde{eq}(r_x, r&#x27;_x) \\cdot \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M_j}(r&#x27;_x, y) \\cdot \\widetilde{z_{1,k}}(y)\\right) + \\\\ &amp;amp;\\quad \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot \\widetilde{eq}(\\beta, r&#x27;_x) \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M_j}(r&#x27;_x, y) \\cdot \\widetilde{z_{2,k}}(y)\\right) \\\\ &amp;amp;= \\left(\\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot L_{j,k}(r&#x27;_x)\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot Q_k(r&#x27;_x)\\right)\\right) \\\\ &amp;amp;= g(r&#x27;_x) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the soundness of the sum-check protocol, this implies that with probability $1 - O(d \\cdot s) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>r'_x$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} T &amp;amp;= \\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot v_{j,k} + \\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot 0 \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} g(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\left(\\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot L_{j,k}(x)\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot Q_k(x)\\right)\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in [t], k \\in [\\mu]} \\gamma^{(k-1)\\cdot t+j} \\cdot \\left(\\sum_{x \\in \\{0,1\\}^s} L_{j,k}(x)\\right)\\right) + \\left(\\sum_{k \\in [\\nu]} \\gamma^{\\mu\\cdot t+k} \\cdot \\left(\\sum_{x \\in \\{0,1\\}^s} Q_k(x)\\right)\\right) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma [56], this implies that with probability $1 - O(t \\cdot \\mu + \\nu) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\gamma<span class="math">, we have for all </span>j \\in [t]<span class="math"> and </span>k \\in [\\mu]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">v_{j,k} = \\sum_{x \\in \\{0,1\\}^s} L_{j,k}(x),</span></div>

    <p class="text-gray-300">and for all <span class="math">k \\in [\\nu]</span></p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^s} Q_k(x).</span></div>

    <p class="text-gray-300">Now, for all <span class="math">j \\in [t]</span> and <span class="math">k \\in [\\mu]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_{j,k} &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} L_{j,k}(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\widetilde{eq}(r_x, x) \\cdot \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} M_j(x, y) \\cdot \\widetilde{z}_{1,k}(y)\\right) \\\\ &amp;amp;= \\sum_{y \\in \\{0,1\\}^{s&#x27;}} M_j(r_x, y) \\cdot \\widetilde{z}_{1,k}(y) \\end{aligned}</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\vec{\\mathbf{w}}_1</span> is a satisfying witness to <span class="math">\\vec{u}_1</span>.</p>

    <p class="text-gray-300">Finally, we have that for all <span class="math">k \\in [\\nu]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} 0 &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} Q_k(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\widetilde{eq}(\\beta, x) \\cdot \\left(\\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right)\\right) \\\\ &amp;amp;= \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\beta, y) \\cdot \\widetilde{z}_{2,k}(y)\\right) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma, this implies that with probability $1 - s /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\beta<span class="math">, we have that for all </span>x \\in \\{0,1\\}^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_{2,k}(y)\\right)</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\vec{\\mathbf{w}}_2</span> is a satisfying witness to <span class="math">\\vec{u}_2</span>.</p>

    <p class="text-gray-300">Thus, if the extractor does not abort, it succeeds in producing satisfying witness <span class="math">(\\vec{\\mathbf{w}}_1,\\vec{\\mathbf{w}}_2)</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <h2 id="sec-98" class="text-2xl font-bold">H.2 Proof of Lemma 3 (Folding CCS NIVC-compatibility)</h2>

    <p class="text-gray-300"><strong>Lemma 15 (NIVC-compatibility).</strong> Construction 1 is NIVC-compatible.</p>

    <p class="text-gray-300"><strong>Proof.</strong> NP-completeness of <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span> follows from [60, Lemma 1], which reduces R1CS to <span class="math">\\mathcal{R}_{\\mathrm{CCS}}</span>. Furthermore, Gennaro et al. [31, Section 7.4] and Parno et al. [54, Section 2.2.1] implicitly reduce circuit satisfiability to R1CS (Thaler [65, Section 8.4] provides explicit details). These two reductions induce the functions <span class="math">\\mathsf{enc}</span>, <span class="math">\\mathsf{enc}_{\\mathrm{str}}</span> and <span class="math">\\mathsf{enc}_{\\mathrm{inst}}</span>.</p>

    <p class="text-gray-300">In particular, let the circuit satisfiability relation be characterized by circuits over <span class="math">n</span> total gates, <span class="math">m</span> multiplication gates, and without loss of generality input size <span class="math">\\ell/2</span> and output size <span class="math">\\ell/2</span>. We demonstrate how to reduce circuit satisfiability to <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> characterized by size bounds <span class="math">m,n,N=\\Omega(m),\\ell,t=3,q=2,d=2</span>.</p>

    <p class="text-gray-300">First, we explicitly describe the function <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span>, which takes as input an arithmetic circuit <span class="math">F</span> and produces <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> and <span class="math">\\mathcal{R}_{\\mathsf{LCCS}}</span> structures <span class="math">\\mathsf{s}_{1}</span> and <span class="math">\\mathsf{s}_{2}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{enc}_{\\mathsf{str}}(F)\\to(\\mathsf{s}_{1},\\mathsf{s}_{2})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initalize matrices <span class="math">A,B,C\\in\\mathbb{F}^{m\\times(n+1)}</span> with zeros.</li>

      <li>For each multiplication gate index <span class="math">i\\in[m]</span> in <span class="math">F</span>, do the following:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">L</span> be the indices of all the upstream left input addition gates such that gate <span class="math">i</span> is the first downstream multiplication gate. Similarly let <span class="math">R</span> be all the upstream right input gates such that gate <span class="math">i</span> is the first downstream multiplication gate.</li>

      <li>Let <span class="math">A_{i,j}=1</span> for <span class="math">j\\in L</span>, <span class="math">B_{i,j}=1</span> for <span class="math">j\\in R</span>, and <span class="math">C_{i,i}=1</span>. This encodes the constraint that the result of multiplying the sum of all the upstream left addition gates and the sum of all the upstream right addition gates results in the wire value assigned at gate <span class="math">i</span>.</li>

      <li>Let <span class="math">S_{1}\\leftarrow\\{1,2\\}</span> and <span class="math">S_{2}\\leftarrow\\{3\\}</span>. Output CCS and LCCS structure</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{s}_{1}=\\mathsf{s}_{2}=\\Big{(}(\\widetilde{A},\\widetilde{B},\\widetilde{C}),(S_{1},S_{2}),(1,-1)\\Big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{A}</span>, <span class="math">\\widetilde{B}</span>, and <span class="math">\\widetilde{C}</span> denote the multilinear extensions of <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span>.</p>

    <p class="text-gray-300">By observation, we have that <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span> is invertible. In particular, given matrices <span class="math">A</span>, <span class="math">B</span>, and <span class="math">C</span>, we can parse out the inputs to each gate in the circuit <span class="math">F</span>.</p>

    <p class="text-gray-300">Next, we explicitly describe the function <span class="math">\\mathsf{enc}_{\\mathsf{inst}}</span>, which takes as input an arithmetic circuit public input <span class="math">x</span> and output <span class="math">y</span> and produces an <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> instance <span class="math">\\mathsf{x}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{enc}_{\\mathsf{inst}}((x,y))\\to\\mathsf{x}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(x,y)</span>.</li>

    </ol>

    <p class="text-gray-300">By observation, we have that <span class="math">\\mathsf{enc}_{\\mathsf{inst}}</span> is invertible. In particular, provided an <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> instance <span class="math">\\mathsf{x}\\in\\mathbb{F}^{\\ell}</span> we can recover an arithmetic circuit public input and output tuple <span class="math">(x,y)\\in(\\mathbb{F}^{\\ell/2},\\mathbb{F}^{\\ell/2})</span> by splitting <span class="math">\\mathsf{x}</span> into its first and second half.</p>

    <p class="text-gray-300">Given <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span> and <span class="math">\\mathsf{enc}_{\\mathsf{inst}}</span>, we can explicitly describe <span class="math">\\mathsf{enc}</span>, which takes as input an arithmetic circuit <span class="math">F</span>, a circuit input <span class="math">x</span>, a non-deterministic input <span class="math">w</span>, and an output <span class="math">y</span>, and outputs a corresponding <span class="math">\\mathcal{R}_{\\mathsf{CCS}}</span> structure-instance-witness tuple.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{enc}(F,(x,y),w)\\to\\mathsf{x}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">(\\mathsf{s}_{1},\\mathsf{s}_{2})\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(F)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathsf{x}\\leftarrow\\mathsf{enc}_{\\mathsf{inst}}((x,y))</span>.</li>

      <li>Let <span class="math">\\mathsf{w}</span> be the gate wire values that results from executing <span class="math">F</span> on inputs <span class="math">x</span> and <span class="math">w</span> excluding the public input <span class="math">x</span> and output <span class="math">y</span> wire values.</li>

      <li>Output CCS structure-instance-witness tuple <span class="math">(\\mathsf{s}_{2},\\mathsf{x},\\mathsf{w})</span>.</li>

    </ol>

    <p class="text-gray-300">By <em>Setty et al. [60, Lemma 1]</em> and <em>Parno et al. [54]</em>, for any arithmetic circuit <span class="math">F</span>, input <span class="math">x</span>, non-deterministic input <span class="math">w</span>, and output <span class="math">y</span>, for <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})\\leftarrow\\mathsf{enc}(F,(x,y),w)</span> we have that <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})\\in\\mathcal{R}_{2}^{\\prime}</span> if and only if <span class="math">F(x,w)=y</span>.</p>

    <p class="text-gray-300">Moreover, we have that <span class="math">\\mathsf{enc}</span> is invertible. In particular, Given a CCS structure-instance-witness pair <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})</span>, we can compute <span class="math">F</span> and <span class="math">(x,y)</span> by the invertibility of <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span> and <span class="math">\\mathsf{enc}_{\\mathsf{inst}}</span>, and compute <span class="math">w</span> by parsing the appropriate gates in <span class="math">\\mathsf{w}</span>. By observation, we have that <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})=\\mathsf{enc}(F,(x,y),w)</span>. Combining all prior assertions we have that the NP-completeness property holds.</p>

    <p class="text-gray-300">Next, by construction, for any arithmetic circuit <span class="math">F</span>, an input <span class="math">x</span>, a non-deterministic input <span class="math">w</span>, and an output <span class="math">y</span>, for <span class="math">\\mathcal{R}_{1}^{\\prime}</span> and <span class="math">\\mathcal{R}_{2}^{\\prime}</span> structures <span class="math">(\\mathsf{s}_{1},\\mathsf{s}_{2})\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(F)</span> and <span class="math">\\mathcal{R}_{2}^{\\prime}</span> instance <span class="math">\\mathsf{u}\\leftarrow\\mathsf{enc}_{\\mathsf{inst}}((x,y))</span> we have that <span class="math">(\\mathsf{s}_{2},\\mathsf{u},\\mathsf{w})=\\mathsf{enc}(F,(x,y),w)</span> for some <span class="math">\\mathcal{R}_{2}^{\\prime}</span> witness <span class="math">\\mathsf{w}</span> and that <span class="math">\\mathsf{compat}(\\mathsf{s}_{1},\\mathsf{s}_{2})=1</span>. Combining all the prior assertions we have that the partial functions property holds.</p>

    <p class="text-gray-300">Moreover, we have monotonicity holds by the construction of <span class="math">\\mathsf{enc}_{\\mathsf{str}}</span>. In particular, each gate in the input arithmetic circuit <span class="math">F</span> corresponds to exactly one constraint in the output CCS structure.</p>

    <p class="text-gray-300">Finally, we have that <span class="math">\\mathcal{R}_{\\mathsf{LCCCS}}</span> has default instances because for any public parameters and structure, we have that <span class="math">\\mathsf{u}_{\\perp}=(u=0,\\mathsf{x}=\\vec{0},r=0,v_{1}=0,\\ldots,v_{t}=0)</span> and <span class="math">\\mathsf{w}_{\\perp}=0</span> is a satisfying instance-witness pair in <span class="math">\\mathcal{R}_{1}</span>. ∎</p>

    <h3 id="sec-99" class="text-xl font-semibold mt-8">H.3 Proof of Theorem 4 (HyperNova)</h3>

    <h6 id="sec-100" class="text-base font-medium mt-4">Lemma 16 (Completeness)</h6>

    <p class="text-gray-300">Construction 2 is an NIVC scheme that satisfies completeness.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider arbitrary PPT adversary <span class="math">\\mathcal{A}</span>. Suppose <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span>. Suppose, on input <span class="math">\\mathsf{pp}</span>, <span class="math">\\mathcal{A}</span> produces polynomial-time functions <span class="math">(\\varphi,(F_{1},\\ldots,\\mathbb{F}_{\\ell}))</span>, instance <span class="math">(i,z_{0},z_{i})</span>, private input <span class="math">\\omega_{i}</span>, and NIVC proof <span class="math">\\Pi_{i}</span>. Suppose that for</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},(\\varphi,(F_{1},\\ldots,F_{\\ell})))</span></p>

    <p class="text-gray-300">we have that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1.</span></p>

    <p class="text-gray-300">Then, for <span class="math">\\mathsf{pc}_{i+1}\\in[\\ell]\\leftarrow\\varphi(z_{i},\\omega_{i})</span>, given</p>

    <p class="text-gray-300"><span class="math">z_{i+1}\\leftarrow F_{\\mathsf{pc}_{i+1}}(z_{i},\\omega_{i})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pi_{i+1}\\leftarrow\\mathcal{P}(\\mathsf{pk},(i,z_{0},z_{i}),\\omega_{i},\\Pi_{i})</span></p>

    <p class="text-gray-300">we must show that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i+1,z_{0},z_{i+1},\\Pi_{i+1})=1</span></p>

    <p class="text-gray-300">with probability <span class="math">1</span>. We show this by considering the case when <span class="math">i=0</span> and when <span class="math">i\\geq 1</span>.</p>

    <p class="text-gray-300">Indeed, suppose <span class="math">i=0</span>. By the base case of <span class="math">\\mathcal{P}</span> and <span class="math">F^{\\prime}_{\\mathsf{pc}_{1}}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pi_{1}=(((u_{\\perp},\\ldots,u_{\\perp}),(w_{\\perp},\\ldots,w_{\\perp})),(u_{1},w_{1}),\\mathsf{pc}_{1})</span></p>

    <p class="text-gray-300">for some <span class="math">(u_{1},w_{1})</span>. By definition, the instance-witness pair <span class="math">(u_{\\perp},w_{\\perp})</span> is satisfying. Moreover, by construction, <span class="math">(u_{1},w_{1})</span> must also be satisfying. Additionally, by the construction of <span class="math">F^{\\prime}_{\\mathsf{pc}_{1}}</span>, we have</p>

    <p class="text-gray-300"><span class="math">u^{\\prime}_{1}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},1,z_{0},F_{\\mathsf{pc}_{1}}(z_{0},w_{0}),u_{\\perp},\\mathsf{pc}_{1})).</span></p>

    <p class="text-gray-300">where <span class="math">u^{\\prime}_{1}</span> is the portion of <span class="math">u_{1}</span> that excludes the commitment to the <span class="math">w_{1}</span>. Therefore, we have</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{pp},1,z_{0},z_{1},\\Pi_{1})=1.</span></p>

    <p class="text-gray-300">Suppose instead that <span class="math">i\\geq 1</span>. Let <span class="math">\\Pi_{i}</span> be parsed as <span class="math">((U_{i},W_{i}),(u_{i},w_{i}),\\pi_{i})</span> and let <span class="math">\\Pi_{i+1}</span> be parsed as <span class="math">((U_{i+1},W_{i+1}),(u_{i+1},w_{i+1}),\\pi_{i+1})</span>. By the construction of <span class="math">\\mathcal{P}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">(U_{i+1}[\\mathsf{pc}_{i}],W_{i+1}[\\mathsf{pc}_{i}],\\pi)=\\mathsf{NIFS.P}(\\mathsf{pk}[\\mathsf{pc}_{i}],(U_{i}[\\mathsf{pc}_{i}],W_{i}[\\mathsf{pc}_{i}]),(u_{i},w_{i})).</span></p>

    <p class="text-gray-300">Thus, because <span class="math">\\Pi_{i}</span> is satisfying, we have that <span class="math">(u_{i},w_{i})</span> and <span class="math">(U_{i}[\\mathsf{pc}_{i}],W_{i}[\\mathsf{pc}_{i}])</span> are satisfying instance-witness pairs (with respect to compatible structures). Then, by the completeness of the underlying folding scheme, we have that <span class="math">(U_{i+1}[\\mathsf{pc}_{i}],W_{i+1}[\\mathsf{pc}_{i}])</span> is a satisfying instance-witness pair. Therefore, because <span class="math">(U_{i+1},W_{i+1})</span> copies the remaining elements from <span class="math">(U_{i},W_{i})</span>, we have that <span class="math">(U_{i+1},W_{i+1})</span> contains satisfying instance-witness pairs. Additionally, by the premise, we have that <span class="math">u^{\\prime}_{i}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},U_{i},\\mathsf{pc}_{i}))</span> where <span class="math">u^{\\prime}_{i}</span> represents the portion of <span class="math">u_{i}</span> that excludes the commitment to the witness. Therefore, <span class="math">\\mathcal{P}</span> can construct a satisfying instance-witness pair <span class="math">(u_{i+1},w_{i+1})</span> that represents the correct execution of <span class="math">F^{\\prime}_{\\mathsf{pc}_{i+1}}</span> on input <span class="math">(\\mathsf{vk}_{\\mathsf{fs}},U,u,\\mathsf{pc}_{i},(i,z_{0},z_{i}),\\omega_{i},\\pi)</span>. By construction, this particular input implies that</p>

    <p class="text-gray-300"><span class="math">u^{\\prime}_{i+1}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},i+1,z_{0},z_{i+1},U_{i+1},\\mathsf{pc}_{i+1}))</span> (16)</p>

    <p class="text-gray-300">by the correctness of the underlying folding scheme (again <span class="math">u^{\\prime}_{i+1}</span> represents the portion of <span class="math">u_{i+1}</span> that excludes the commitment to the witness). Moreover, because</p>

    <p class="text-gray-300"><span class="math">\\mathsf{pc}_{i+1}=\\varphi(z_{i},\\omega_{i})</span>, by construction, we have that <span class="math">1\\leq\\mathsf{pc}_{i+1}\\leq\\ell</span>. Thus, by Equation (16) we have</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i+1,z_{0},z_{i+1},\\Pi_{i+1})=1.</span></p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Lemma 17 (Knowledge Soundness).</h6>

    <p class="text-gray-300">Construction 2 is an IVC scheme that satisfies knowledge soundness.</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Our approach is inspired by a recursive extraction technique described by Bünz et al <em>[18]</em>. Let <span class="math">n</span> be a global constant. Consider deterministic expected polynomial-time adversary <span class="math">\\mathcal{P}^{<em>}</span>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span>. Suppose on input <span class="math">\\mathsf{pp}</span> and randomness <span class="math">\\mathsf{r}</span>, <span class="math">\\mathcal{P}^{</em>}</span> outputs deterministic polynomial-time function <span class="math">\\varphi</span>, <span class="math">\\ell</span> polynomial-time functions <span class="math">(F_{1},\\ldots,F_{\\ell})</span>, instance <span class="math">(z_{0},z)</span>, and NIVC proof <span class="math">\\Pi</span>. Let <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},(\\varphi,(F_{1},\\ldots,F_{\\ell})))</span>. Suppose that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},(n,z_{0},z),\\Pi)=1</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon</span>. We must construct an expected polynomial-time extractor <span class="math">\\mathcal{E}</span> that, with input <span class="math">(\\mathsf{pp},\\mathsf{r})</span>, outputs <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> such that by computing</p>

    <p class="text-gray-300"><span class="math">z_{i+1}\\leftarrow F_{\\varphi(z_{i},\\omega_{i})}(z_{i},\\omega_{i})</span></p>

    <p class="text-gray-300">we have that <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We show inductively that <span class="math">\\mathcal{E}</span> can construct an expected polynomial-time extractor <span class="math">\\mathcal{E}_{i}(\\mathsf{pp})</span> that outputs <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\Pi_{i})</span> such that for all <span class="math">j\\in\\{i+1,\\ldots,n\\}</span>,</p>

    <p class="text-gray-300"><span class="math">z_{j}=F_{\\varphi(z_{j-1},\\omega_{j-1})}(z_{j-1},\\omega_{j-1})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span> (17)</p>

    <p class="text-gray-300">for <span class="math">z_{n}=z</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Then, because in the base case when <span class="math">i=0</span>, <span class="math">\\mathcal{V}</span> checks that <span class="math">z_{0}=z_{i}</span>, the values <span class="math">(\\omega_{0},\\ldots,\\omega_{n-1})</span> retrieved by <span class="math">\\mathcal{E}_{0}(\\mathsf{pp})</span> are such that computing <span class="math">z_{i+1}=F(z_{i},\\omega_{i})</span> for all <span class="math">i\\geq 1</span> gives <span class="math">z_{n}=z</span>.</p>

    <p class="text-gray-300">At a high level, to construct an extractor <span class="math">\\mathcal{E}_{i-1}</span>, we first assume the existence of <span class="math">\\mathcal{E}_{i}</span> that satisfies the inductive hypothesis. We then use <span class="math">\\mathcal{E}_{i}(\\mathsf{pp})</span> to construct an adversary for the non-interactive folding scheme (which we denote as <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span>). This in turn guarantees an extractor for the non-interactive folding scheme, which we denote as <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span>. We then use <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> to construct <span class="math">\\mathcal{E}_{i-1}</span> that satisfies the inductive hypothesis.</p>

    <p class="text-gray-300">In the base case, for <span class="math">i=n</span>, let <span class="math">\\mathcal{E}_{n}(\\mathsf{pp},\\mathsf{r})</span> output <span class="math">(\\bot,\\bot,\\Pi_{n})</span> where <span class="math">\\Pi_{n}</span> is the output of <span class="math">\\mathcal{P}^{*}(\\mathsf{pp},\\mathsf{r})</span>. By the premise, <span class="math">\\mathcal{E}_{n}</span> succeeds with probability <span class="math">\\epsilon</span> in expected polynomial-time.</p>

    <p class="text-gray-300">For <span class="math">i\\geq 1</span>, suppose <span class="math">\\mathcal{E}</span> can construct an expected polynomial-time extractor <span class="math">\\mathcal{E}_{i}</span> that outputs <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}))</span>, and <span class="math">\\Pi_{i}</span> that satisfies the inductive hypothesis. To construct an extractor <span class="math">\\mathcal{E}_{i-1}</span>, <span class="math">\\mathcal{E}</span> first constructs an adversary <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> for the non-interactive folding scheme as follows:</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathcal{P}}_{i-1}(\\mathsf{pp},\\mathsf{r})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\Pi_{i})\\leftarrow\\mathcal{E}_{i}(\\mathsf{pp},\\mathsf{r})</span>.</li>

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),\\mathsf{pc}_{i})</span>.</li>

      <li>Compute compatible structures <span class="math">(\\mathsf{s}_{1,\\mathsf{pc}_{i}},\\mathsf{s}_{2,\\mathsf{pc}_{i}})\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(F^{\\prime}_{\\mathsf{pc}_{i}})</span>.</li>

      <li>Parse non-deterministic inputs <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1},\\pi_{i-1},\\mathsf{pc}_{i-1})</span> to <span class="math">F^{\\prime}_{\\mathsf{pc}_{i}}</span> from <span class="math">\\mathsf{enc}^{-1}(\\mathsf{s}_{2,\\mathsf{pc}_{i}},\\mathsf{u}_{i},\\mathsf{w}_{i})</span>.</li>

      <li>Output structures <span class="math">(\\mathsf{s}_{1,\\mathsf{pc}_{i-1}},\\mathsf{s}_{2,\\mathsf{pc}_{i-1}})</span>, unfolded instances <span class="math">(\\mathsf{U}_{i-1}[\\mathsf{pc}_{i-1}],\\mathsf{u}_{i-1})</span>, folded instance-witness pair <span class="math">(\\mathsf{U}_{i}[\\mathsf{pc}_{i-1}],\\mathsf{W}_{i}[\\mathsf{pc}_{i-1}])</span>, and folding proof <span class="math">\\pi_{i-1}</span>.</li>

    </ol>

    <p class="text-gray-300">We now analyze the success probability of <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span>. By the inductive hypothesis, we have that <span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span>, where <span class="math">\\Pi_{i}\\leftarrow\\mathcal{E}_{i}(\\mathsf{pp},\\mathsf{r})</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Therefore, by the the verifier’s checks we have that <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> is satisfying, <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> consists of satisfying instance-witness pairs, and that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}^{\\prime}_{i}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},\\mathsf{pc}_{i}))</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{u}^{\\prime}_{i}</span> represents the portion of <span class="math">\\mathsf{u}_{i}</span> that excludes the commitment to the witness. Then, by the construction of <span class="math">F^{\\prime}_{\\mathsf{pc}_{i}}</span> and the binding property of the hash function, we have that <span class="math">1\\leq\\mathsf{pc}_{i-1}\\leq\\ell</span> and</p>

    <p class="text-gray-300"><span class="math">\\mathsf{U}_{i}[\\mathsf{pc}_{i-1}]=\\mathsf{NIFS}.\\mathcal{V}(\\mathsf{vk},\\mathsf{U}_{i-1}[\\mathsf{pc}_{i-1}],\\mathsf{u}_{i-1},\\pi_{i-1})</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Thus, <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> succeeds in producing an accepting folded instance-witness pair <span class="math">(\\mathsf{U}_{i}[\\mathsf{pc}_{i-1}],\\mathsf{W}_{i}[\\mathsf{pc}_{i-1}])</span>, for instances <span class="math">\\mathsf{U}_{i-1}[\\mathsf{pc}_{i-1}]</span> and <span class="math">\\mathsf{u}_{i-1}</span>, with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in expected polynomial-time.</p>

    <p class="text-gray-300">Then, by the knowledge soundness of the underlying non-interactive multi-folding scheme (Assumption 1) there exists an extractor <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> that outputs <span class="math">(\\mathsf{W}_{i-1}[\\mathsf{pc}_{i-1}],\\mathsf{w}_{i-1})</span> such that <span class="math">(\\mathsf{U}_{i-1}[\\mathsf{pc}_{i-1}],\\mathsf{W}_{i-1}[\\mathsf{pc}_{i-1}])</span> and <span class="math">(\\mathsf{u}_{i-1},\\mathsf{w}_{i-1})</span> are satisfying with respect to structures <span class="math">\\mathsf{s}_{1,\\mathsf{pc}_{i-1}}</span> and <span class="math">\\mathsf{s}_{2,\\mathsf{pc}_{i-1}}</span> respectively with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in expected polynomial-time.</p>

    <p class="text-gray-300">Given an expected polynomial-time <span class="math">\\widetilde{\\mathcal{P}}_{i-1}</span> and an expected polynomial-time <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span>, <span class="math">\\mathcal{E}</span> constructs an expected polynomial time <span class="math">\\mathcal{E}_{i-1}</span> as follows</p>

    <p class="text-gray-300"><span class="math">\\mathcal{E}_{i-1}(\\mathsf{pp},\\mathsf{r})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\widetilde{\\mathcal{P}}_{i-1}(\\mathsf{pp},\\mathsf{r})</span> to retrieve unfolded instances <span class="math">(\\mathsf{u}^{\\prime}_{i-1},\\mathsf{u}_{i-1})</span> and parse</li>

    </ol>

    <p class="text-gray-300"><span class="math">((z_{i},\\ldots,z_{n-1}),(\\omega_{i},\\ldots,\\omega_{n-1}),\\Pi_{i})</span></p>

    <p class="text-gray-300">from its internal state.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse <span class="math">\\Pi_{i}</span> as <span class="math">((\\mathsf{U}_{i},\\mathsf{W}_{i}),(\\mathsf{u}_{i},\\mathsf{w}_{i}),\\mathsf{pc}_{i})</span>.</li>

      <li>Compute <span class="math">(\\mathsf{s}_{1,\\mathsf{pc}_{i}},\\mathsf{s}_{2,\\mathsf{pc}_{i}})\\leftarrow\\mathsf{enc}_{\\mathsf{str}}(F^{\\prime}_{\\mathsf{pc}_{i}})</span></li>

      <li>Parse private inputs <span class="math">z_{i-1}</span>, <span class="math">\\omega_{i-1}</span>, and <span class="math">\\mathsf{pc}_{i-1}</span> to <span class="math">F^{\\prime}_{\\mathsf{pc}_{i}}</span> from <span class="math">\\mathsf{enc}^{-1}(\\mathsf{s}_{2},\\mathsf{u}_{i},\\mathsf{w}_{i})</span>.</li>

      <li>Let <span class="math">(\\mathsf{w}^{\\prime}_{i-1},\\mathsf{w}_{i-1})\\leftarrow\\widetilde{\\mathcal{E}}_{i-1}(\\mathsf{pp})</span>.</li>

      <li>Set <span class="math">(\\mathsf{U}_{i-1},\\mathsf{W}_{i-1})\\leftarrow(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> and update</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{U}_{i-1}[\\mathsf{pc}_{i-1}],\\mathsf{W}_{i-1}[\\mathsf{pc}_{i-1}])\\leftarrow(\\mathsf{u}^{\\prime}_{i-1},\\mathsf{w}^{\\prime}_{i-1})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Pi_{i-1}\\leftarrow((\\mathsf{U}_{i-1},\\mathsf{W}_{i-1}),(\\mathsf{u}_{i-1},\\mathsf{w}_{i-1}),\\mathsf{pc}_{i-1})</span>.</li>

      <li>Output <span class="math">((z_{i-1},\\ldots,z_{n-1}),(\\omega_{i-1},\\ldots,\\omega_{n-1}),\\Pi_{i-1})</span>.</li>

    </ol>

    <p class="text-gray-300">We first reason that the output <span class="math">(z_{i-1},\\ldots,z_{n-1})</span>, and <span class="math">(\\omega_{i-1},\\ldots,\\omega_{n-1})</span> are valid. By the inductive hypothesis, we already have that for all <span class="math">j\\in\\{i+1,\\ldots,n\\}</span>,</p>

    <p class="text-gray-300"><span class="math">z_{j}=F_{\\mathsf{pc}_{j}}(z_{j-1},\\omega_{j-1}),</span></p>

    <p class="text-gray-300">and that <span class="math">\\mathcal{V}(\\mathsf{vk},i,z_{0},z_{i},\\Pi_{i})=1</span> with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Because <span class="math">\\mathcal{V}</span> additionally checks that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}^{\\prime}_{i}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},i,z_{0},z_{i},\\mathsf{U}_{i},\\mathsf{pc}_{i})),</span> (18)</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{u}^{\\prime}_{i}</span> represents the portion of <span class="math">\\mathsf{u}_{i}</span> that excludes the commitment to the witness, by the construction of <span class="math">F^{\\prime}_{\\mathsf{pc}_{i}}</span> and the binding property of the hash function, we have</p>

    <p class="text-gray-300"><span class="math">F_{\\mathsf{pc}_{i}}(z_{i-1},\\omega_{i-1})=z_{i}</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. Next, we argue that <span class="math">\\Pi_{i-1}</span> is valid. Because <span class="math">(\\mathsf{u}_{i},\\mathsf{w}_{i})</span> satisfies <span class="math">F^{\\prime}</span>, and <span class="math">(\\mathsf{U}_{i-1},\\mathsf{u}_{i-1})</span> were retrieved from <span class="math">\\mathsf{w}_{i}</span>, by the binding property of the hash function, and by Equation (18), we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{u}^{\\prime}_{i-1}=\\mathsf{enc}_{\\mathsf{inst}}(\\mathsf{hash}(\\mathsf{vk},i-1,z_{0},z_{i-1},\\mathsf{U}_{i-1},\\mathsf{pc}_{i-1}))</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{u}^{\\prime}_{i-1}</span> represents the portion of <span class="math">\\mathsf{u}_{i-1}</span> that excludes the commitment the witness. Additionally, in the case where <span class="math">i=1</span>, by the base case check of <span class="math">F^{\\prime}_{\\varphi(z_{0},\\omega_{0})}</span>, we have that <span class="math">z_{i-1}=z_{0}</span>. Because <span class="math">\\widetilde{\\mathcal{E}}_{i-1}</span> succeeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>, and the remainder of the elements of <span class="math">(\\mathsf{U}_{i-1},\\mathsf{W}_{i-1})</span> are directly copied from <span class="math">(\\mathsf{U}_{i},\\mathsf{W}_{i})</span> we have that all the elements of <span class="math">(\\mathsf{U}_{i-1},\\mathsf{W}_{i-1})</span> are satisfying. Moreover, by construction of <span class="math">F^{\\prime}_{\\mathsf{pc}_{i}}</span> we have that <span class="math">1\\leq\\mathsf{pc}_{i-1}\\leq\\ell</span>. Thus, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}(\\mathsf{vk},i-1,z_{0},z_{i-1},\\Pi_{i-1})=1</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">H.4 Proof of Theorem 4 (CycleFold)</p>

    <p class="text-gray-300">Lemma 18 (Perfect Completeness). Construction 7 satisfies perfect completeness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Consider public parameters $\\mathsf{pp} = (m,n,N,\\ell ,t,q,d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{s}_{\\mathsf{EC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\mathsf{pp}_{\\mathsf{PC}},\\mathsf{pp}_{\\mathsf{VC}})\\gets \\mathcal{G}(1^{\\lambda},N)<span class="math"> and let </span>s = \\log m<span class="math"> and </span>s^{\\prime} = \\log n<span class="math">. Let </span>\\mathsf{s}_{\\mathsf{EC}} = (A,B,C)<span class="math"> denote a committed relaxed R1CS structure defined over </span>F_{q}<span class="math">, with public IO </span>(\\rho ,C_1,C_2,C')<span class="math">, where </span>\\rho \\in \\mathbb{F}_p,C_1\\in \\mathbb{G}_1,C_2\\in \\mathbb{G}_1,C'\\in \\mathbb{G}_1<span class="math">. This constraint system enforces that </span>C' = C_1 + \\rho \\cdot C_2<span class="math">, where </span>+<span class="math"> is the elliptic curve point addition and </span>\\cdot<span class="math"> is the elliptic curve scalar multiplication operation in </span>\\mathbb{G}_1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consider arbitrary structures <span class="math">(\\mathsf{s}_1,\\mathsf{s}_2)\\gets \\mathcal{A}(\\mathsf{pp})</span> such that <span class="math">\\mathsf{compat}(\\mathsf{s}_1,\\mathsf{s}_2) = \\mathsf{true}</span>. Let <span class="math">\\mathsf{s}_1 = ((\\widetilde{M}_1,\\ldots ,\\widetilde{M}_t),(S_1,\\ldots ,S_q),(c_1,\\ldots ,c_q))</span>, and let <span class="math">\\mathsf{s}_2 = (A,B,C)</span>. Consider prover and verifier keys <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},(\\mathsf{s}_1,\\mathsf{s}_2))</span>. Suppose that the prover and the verifier are provided with a linearized committed CCS instance and a committed relaxed R1CS instance</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(C _ {1}, u, \\mathrm {x} _ {1}, r _ {x}, v _ {1}, \\dots , v _ {t}\\right), \\left(\\bar {E} _ {1}, u _ {1}, \\bar {W} _ {1}, x _ {1}\\right)\\right),</span></div>

    <p class="text-gray-300">and a committed CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C _ {2}, \\mathrm {x} _ {2}).</span></div>

    <p class="text-gray-300">Suppose that the prover additionally is provided with the corresponding satisfying witnesses <span class="math">(\\widetilde{w}_1,(E_1,W_1))</span> and <span class="math">\\widetilde{w}_2</span>.</p>

    <p class="text-gray-300">Because the input linearized committed CCS instance-witness pair is satisfying, we have, for <span class="math">\\widetilde{z}_1 = (\\widetilde{w_1,u},\\mathbf{x}_1)</span>, that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} v _ {j} = \\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {j} (r _ {x}, y) \\cdot \\widetilde {z} _ {1} (y) \\quad \\text {By precondition.} \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {s}} \\widetilde {e q} (r _ {x}, x) \\cdot \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {j} (x, y) \\cdot \\widetilde {z} _ {1} (y)\\right) \\quad \\text {By Lemma 6} \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {s}} L _ {j} (x) \\quad \\text {By construction.} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Furthermore, because the input committed relaxed R1CS instance-witness pair is also satisfying, we have for <span class="math">Z_{1} = (W_{1},u_{1},x_{1})</span>, <span class="math">AZ_{1}\\circ BZ_{1} = u\\cdot CZ_{1} + E_{1}</span>.</p>

    <p class="text-gray-300">Moreover, because the input committed CCS instance-witness pair is satisfying, we have, for all <span class="math">x \\in \\{0,1\\}^s</span> and for <span class="math">\\widetilde{z}_2(x) = (\\widetilde{w_2,1},\\mathbf{x}_2)(x)</span>, that</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {i = 1} ^ {q} c _ {i} \\cdot \\prod_ {j \\in S _ {i}} \\left(\\sum_ {y \\in \\{0, 1 \\} ^ {s ^ {\\prime}}} \\widetilde {M} _ {j} (x, y) \\cdot \\widetilde {z} _ {2} (y)\\right)</span></div>

    <p class="text-gray-300">Because the RHS vanishes on all <span class="math">x \\in \\{0,1\\}^s</span>, for <span class="math">\\beta</span> sampled by the verifier, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 0 = \\sum_{x \\in \\{0, 1 \\}^s} \\widetilde{e q} (\\beta , x) \\cdot \\sum_{i = 1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0, 1 \\}^s&#x27;} \\widetilde{M}_j (x, y) \\cdot \\widetilde{z}_2 (y)\\right) \\\\ = \\sum_{x \\in \\{0, 1 \\}^s} Q (x) \\quad \\text{By construction.} \\end{array}</span></div>

    <p class="text-gray-300">Therefore, for <span class="math">\\gamma</span> sampled by the verifier, by linearity, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{j \\in [t]} \\gamma^j \\cdot v_j = \\sum_{x \\in \\{0, 1 \\}^s} \\left(\\left(\\sum_{j \\in [t]} \\gamma^j \\cdot L_j (x)\\right) + \\gamma^{t + 1} \\cdot Q (x)\\right) \\\\ = \\sum_{x \\in \\{0, 1 \\}^s} g (x) \\quad \\text{By construction.} \\end{array}</span></div>

    <p class="text-gray-300">Therefore, by the perfect completeness of the sum-check protocol, we have for <span class="math">e_1 = \\widetilde{e q} (r_x,r_x&#x27;)</span>, <span class="math">e_2 = \\widetilde{e q} (\\beta ,r_x&#x27;)</span> and</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_i = \\sum_{y \\in \\{0, 1 \\}^{s&#x27;}} \\widetilde{M}_i (r_x&#x27;, y) \\cdot \\widetilde{z}_1 (y) \\quad \\text{and} \\quad \\theta_i = \\sum_{y \\in \\{0, 1 \\}^{s&#x27;}} \\widetilde{M}_i (r_x&#x27;, y) \\cdot \\widetilde{z}_2 (y)</span></div>

    <p class="text-gray-300">that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c = g (r_x&#x27;) \\\\ = \\left(\\left(\\sum_{j \\in [t]} \\gamma^j \\cdot L_j (r_x&#x27;)\\right) + \\gamma^{t + 1} \\cdot Q (r_x&#x27;)\\right) \\\\ = \\left(\\left(\\sum_{j \\in [t]} \\gamma^j \\cdot e_1 \\cdot \\sigma_j\\right) + \\gamma^{t + 1} \\cdot e_2 \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_j\\right). \\end{array}</span></div>

    <p class="text-gray-300">This implies that the verifier will not abort on step 5.</p>

    <p class="text-gray-300">By construction, the prover can construct <span class="math">\\mathsf{u}_{\\mathsf{CRR1CS}}</span> such that the verifier does not abort on step 8. Furthermore, the prover can construct <span class="math">\\mathsf{u}_{\\mathsf{CRR1CS}}</span> such that <span class="math">\\mathsf{w}_{\\mathsf{CRR1CS}}</span> is a satisfying witness under structure <span class="math">\\mathsf{s}_{\\mathsf{EC}}</span>. This implies that <span class="math">C&#x27; = C_1 + \\rho \\cdot C_2</span>, where <span class="math">C&#x27;</span> is parsed from <span class="math">x_2</span>, which is the public IO of <span class="math">\\mathsf{u}_{\\mathsf{CRR1CS}}</span>.</p>

    <p class="text-gray-300">Now, consider the linearized CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C_2, 1, \\mathbf{x}_2, r_x&#x27;, \\theta_1, \\dots, \\theta_t).</span></div>

    <p class="text-gray-300">By the precondition that the committed CCS instance <span class="math">(C_2, \\mathbf{x}_2)</span> is satisfied by <span class="math">\\widetilde{w}_2</span> and by the definition of <span class="math">\\theta_1, \\ldots, \\theta_t</span> we have that this linearized CCS instance is satisfied by the witness <span class="math">\\widetilde{w}_2</span>.</p>

    <p class="text-gray-300">80</p>

    <p class="text-gray-300">Therefore, for random <span class="math">\\rho</span> sampled by the verifier, and for <span class="math">C&#x27; = C_1 + \\rho \\cdot C_2</span>, <span class="math">u&#x27; = u + \\rho \\cdot 1</span>, <span class="math">\\mathsf{x}&#x27; = \\mathsf{x}_1 + \\rho \\cdot \\mathsf{x}_2</span>, <span class="math">v_i&#x27; = \\sigma_i + \\rho \\cdot \\theta_i</span>, we have that the output linearized CCS instance</p>

    <div class="my-4 text-center"><span class="math-block">(C&#x27;, u&#x27;, \\mathsf{x}&#x27;, r_x&#x27;, v_1&#x27;, \\ldots, v_t&#x27;)</span></div>

    <p class="text-gray-300">is satisfied by the witness <span class="math">\\widetilde{w}&#x27; = \\widetilde{w}_1 + \\rho \\cdot \\widetilde{w}_2</span> by the linearity and the additive homomorphism property of the commitment scheme.</p>

    <p class="text-gray-300">Now, we argue that the output committed relaxed R1CS instance <span class="math">(\\overline{E}^{\\star}, u^{\\star}, \\overline{W}^{\\star}, x^{\\star})</span> is satisfying under the witness <span class="math">(E^{\\star}, W^{\\star})</span>, for relaxed R1CS structure <span class="math">\\mathsf{s}_{\\mathsf{EC}} = (A, B, C)</span>. We need to establish the following. Let <span class="math">Z^{\\star} = (W^{\\star}, u^{\\star}, x^{\\star})</span>.</p>

    <div class="my-4 text-center"><span class="math-block">A Z^{\\star} \\circ B Z^{\\star} = u^{\\star} \\cdot C Z^{\\star} + E^{\\star} \\tag{19}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline{W}^{\\star} = \\mathsf{VC}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}}, W^{\\star}) \\tag{20}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline{E}^{\\star} = \\mathsf{VC}. \\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}}, E^{\\star}) \\tag{21}</span></div>

    <p class="text-gray-300">The latter two requirements hold from the additive homomorphism of the commitment scheme. We now focus on proving the first requirement. We are given that the input committed relaxed R1CS instance <span class="math">(\\overline{E}_1, u_1, \\overline{W}_1, x_1)</span> is satisfying under the witness <span class="math">(E_1, W_1)</span> and structure <span class="math">\\mathsf{s}_{\\mathsf{EC}}</span>. This implies that</p>

    <div class="my-4 text-center"><span class="math-block">A Z_1 \\circ B Z_2 = u_1 \\cdot C Z_1 + E_1,</span></div>

    <p class="text-gray-300">where <span class="math">Z_1 = (W_1, u_1, x_1)</span>. As noted above, the committed relaxed R1CS instance sent by the prover <span class="math">(\\overline{E}_2, u_2, \\overline{W}_2, x_2)</span> is satisfying under the witness <span class="math">(E_2, W_2)</span> and structure <span class="math">\\mathsf{s}_{\\mathsf{EC}}</span>. This implies that</p>

    <div class="my-4 text-center"><span class="math-block">A Z_2 \\circ B Z_2 = C Z_2,</span></div>

    <p class="text-gray-300">where <span class="math">Z_2 = (W_2, 1, x_2)</span>. (This is because by construction <span class="math">u_2 = 1</span> and <span class="math">E_2 = 0</span>.)</p>

    <p class="text-gray-300">Now, consider the LHS of the desired equality.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} A Z^{\\star} \\circ B Z^{\\star} &amp;amp;= A(Z_1 + \\rho^{\\star} \\cdot Z_2) \\circ B(Z_1 + \\rho^{\\star} \\cdot Z_2) \\\\ &amp;amp;= A Z_1 \\circ B Z_1 + \\rho^{\\star} \\cdot (A Z_1 \\circ B Z_2 + A Z_2 \\circ B Z_1) + (\\rho^{\\star})^2 \\cdot (A Z_2 \\circ B Z_2) \\\\ &amp;amp;= u_1 \\cdot C Z_1 + E_1 + \\rho^{\\star} \\cdot (A Z_1 \\circ B Z_2 + A Z_2 \\circ B Z_1) + (\\rho^{\\star})^2 \\cdot C Z_2 \\end{aligned}</span></div>

    <p class="text-gray-300">Consider the RHS of the desired equality.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} u^{\\star} \\cdot C Z^{\\star} + E^{\\star} &amp;amp;= (u_1 + \\rho^{\\star}) \\cdot C(Z_1 + \\rho^{\\star} \\cdot Z_2) + E_1 + \\rho^{\\star} \\cdot T \\\\ &amp;amp;= (u_1 + \\rho^{\\star}) \\cdot (C Z_1 + \\rho^{\\star} \\cdot C Z_2) + E_1 + \\rho^{\\star} \\cdot (A Z_1 \\circ B Z_2 + A Z_2 \\circ B Z_1 - u_1 \\cdot C Z_2 - C Z_1) \\\\ &amp;amp;= u_1 \\cdot C Z_1 + \\rho^{\\star} \\cdot (A Z_1 \\circ B Z_2 + A Z_2 \\circ B Z_1) + (\\rho^{\\star})^2 \\cdot C Z_2 \\end{aligned}</span></div>

    <p class="text-gray-300">This establishes the desired requirements.</p>

    <p class="text-gray-300">Lemma 19 (Knowledge Soundness). Construction 7 satisfies knowledge soundness.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the structure and instances, and a malicious prover <span class="math">\\mathcal{P}^{*}</span> that succeeds with probability <span class="math">\\epsilon</span>. Let <span class="math">\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda},N)</span>. Suppose on input <span class="math">\\mathsf{pp}</span> and random tape <span class="math">\\mathsf{r}</span>, the adversary <span class="math">\\mathcal{A}</span> picks a structure <span class="math">(\\mathsf{s}_{1},\\mathsf{s}_{2})=(((\\widetilde{M}_{1},\\ldots,\\widetilde{M}_{t}),(S_{1},\\ldots,S_{q}),(c_{1},\\ldots,c_{q})),(A,B,C))</span> such that <span class="math">\\mathsf{compat}(\\mathsf{s}_{1},\\mathsf{s}_{2})=\\mathsf{true}</span>, a pair of linearized committed CCS instance and a committed relaxed R1CS instance</p>

    <p class="text-gray-300"><span class="math">\\varphi_{1}=((C_{1},u,\\mathsf{x}_{1},r_{x},v_{1},\\ldots,v_{t}),(\\overline{E}_{1},u_{1},\\overline{W}_{1},x_{1}))</span></p>

    <p class="text-gray-300">and a committed CCS instance</p>

    <p class="text-gray-300"><span class="math">\\varphi_{2}=(C_{2},\\mathsf{x}_{2}),</span></p>

    <p class="text-gray-300">and some auxiliary state <span class="math">\\mathsf{st}</span>.</p>

    <p class="text-gray-300">We construct an expected-polynomial time extractor <span class="math">\\mathcal{E}</span> that succeeds with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span> in obtaining satisfying witnesses for the original instances as follows. Below, let <span class="math">\\mathcal{R}_{1}=\\mathcal{R}_{\\mathsf{LCCCS}}\\times\\mathcal{R}_{\\mathsf{CRRICS}}</span> and <span class="math">\\mathcal{R}_{2}=\\mathcal{R}_{\\mathsf{CCCS}}</span>.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4"><span class="math">\\mathcal{E}(\\mathsf{pp},\\mathsf{r})</span>:</h6>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain the output tuple from <span class="math">\\mathcal{A}</span>:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{s},\\varphi_{1},\\varphi_{2},\\mathsf{st})\\leftarrow\\mathcal{A}(\\mathsf{pp},\\mathsf{r}).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathcal{K}(\\mathsf{pp},\\mathsf{s})</span>.</li>

      <li>Run the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\varphi^{(1,1)},(\\widetilde{w},(E,W))^{(1,1)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\varphi_{1},\\varphi_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">once with the verifier’s final challenges <span class="math">\\rho^{(1)}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> and </span>\\rho^{\\star{}^{(1,1)}}\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{F}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Abort if <span class="math">(\\mathsf{pp},\\mathsf{s},\\varphi^{(1,1)},(\\widetilde{w},(E,W))^{(1,1)})\\not\\in\\mathcal{R}_{1}</span>.</li>

      <li>Rewind the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\varphi^{(1,2)},(\\widetilde{w},(E,W))^{(1,2)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\varphi_{1},\\varphi_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">with a different verifier’s challenge <span class="math">\\rho^{\\star{}^{(2,1)}}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> while maintaining the same prior randomness. Repeat until </span>(\\mathsf{pp},\\mathsf{s},\\varphi^{(1,2)},(\\widetilde{w},(E,W))^{(1,2)})\\in\\mathcal{R}_{1}$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rewind the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\varphi^{(2,1)},(\\widetilde{w},(E,W))^{(2,1)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\varphi_{1},\\varphi_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">with different verifier’s challenges <span class="math">\\rho^{(2)}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> and </span>\\rho^{\\star{}^{(2,1)}}\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\mathbb{F}</span> while maintaining the same prior randomness. Repeat until <span class="math">(\\mathsf{pp},\\mathsf{s},\\varphi^{(2,1)},(\\widetilde{w},(E,W))^{(2,1)})\\in\\mathcal{R}_{1}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Rewind the interaction</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\varphi^{(2,2)},(\\widetilde{w},(E,W))^{(2,2)})\\leftarrow\\langle\\mathcal{P}^{*},\\mathcal{V}\\rangle((\\mathsf{pk},\\mathsf{vk}),\\varphi_{1},\\varphi_{2},\\mathsf{st})</span></p>

    <p class="text-gray-300">with a different verifier’s challenge <span class="math">\\rho^{\\star^{(2,2)}}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathbb{F}<span class="math"> while maintaining the same prior randomness. Repeat until </span>(\\mathsf{pp},\\mathsf{s},\\varphi^{(2,1)},(\\widetilde{w},(E,W))^{(2,2)})\\in\\mathcal{R}_{1}$.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Abort if <span class="math">\\rho^{\\star^{(1,1)}}=\\rho^{\\star^{(1,2)}}</span>, <span class="math">\\rho^{(1)}=\\rho^{(2)}</span>, or <span class="math">\\rho^{\\star^{(2,1)}}=\\rho^{\\star^{(2,2)}}</span>.</li>

      <li>Interpolating points <span class="math">(\\rho^{(1)},\\widetilde{w}^{(1,1)})</span> and <span class="math">(\\rho^{(2)},\\widetilde{w}^{(2,1)})</span>, retrieve the witness polynomials <span class="math">\\widetilde{w}_{1}</span> and <span class="math">\\widetilde{w}_{2}</span> such that for <span class="math">i\\in\\{1,2\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\widetilde{w}_{1}+\\rho^{(i)}\\cdot\\widetilde{w}_{2}=\\widetilde{w}^{(i,1)}.</span> (22)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interpolating points <span class="math">(\\rho^{\\star^{(1,1)}},(E,W)^{(1,1)})</span> and <span class="math">(\\rho^{\\star^{(1,2)}},(E,W)^{(1,2)})</span>, retrieve <span class="math">(E_{1},W_{1})</span> and <span class="math">(T,W_{2})</span> such that for <span class="math">j\\in\\{1,2\\}</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">E_{1}+\\rho^{\\star^{(1,j)}}\\cdot T</span> <span class="math">=E^{(1,j)}</span> (23) <span class="math">W_{1}+\\rho^{\\star^{(1,j)}}\\cdot W_{2}</span> <span class="math">=W^{(1,j)}</span> (24)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">((\\widetilde{w_{1}},(E_{1},W_{1})),\\widetilde{w_{2}})</span>.</li>

    </ol>

    <p class="text-gray-300">We first demonstrate that the extractor <span class="math">\\mathcal{E}</span> runs in expected polynomial time. Observe that <span class="math">\\mathcal{E}</span> runs the interaction once, and if it does not abort, keeps rerunning the interaction until <span class="math">\\mathcal{P}^{*}</span> succeeds three additional times. Thus, the expected number of times <span class="math">\\mathcal{E}</span> runs the interaction is</p>

    <p class="text-gray-300"><span class="math">1+\\Pr[\\text{First call to }\\langle\\mathcal{P}^{<em>},\\mathcal{V}\\rangle\\text{ succeeds}]\\cdot\\frac{3}{\\Pr[\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle\\text{ succeeds}]}={1+\\epsilon\\cdot\\frac{3}{\\epsilon}}=4.</span></p>

    <p class="text-gray-300">Therefore, we have that the extractor runs in expected polynomial-time.</p>

    <p class="text-gray-300">We now analyze <span class="math">\\mathcal{E}</span>’s success probability. We must demonstrate that <span class="math">\\mathcal{E}</span> succeeds in producing <span class="math">(\\widetilde{w}_{1},(E_{1},W_{1}))</span> and <span class="math">\\widetilde{w}_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pp},\\mathsf{s},\\varphi_{1},(\\widetilde{w}_{1},(E_{1},W_{1})))\\in\\mathcal{R}_{1}\\quad\\text{and}\\quad(\\mathsf{pp},\\mathsf{s}_{1},\\varphi_{2},\\widetilde{w}_{2})\\in\\mathcal{R}_{2}</span></p>

    <p class="text-gray-300">with probability <span class="math">\\epsilon-\\mathsf{negl}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To do so, we first show that the extractor successfully produces <em>some</em> output (i.e., does not abort) in under $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> rewinding steps with probability </span>\\epsilon-\\mathsf{negl}(\\lambda)<span class="math">. Note that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a worst case bound and we have already established that the extractor runs in expected polynomial time. By the malicious prover’s success probability, we have that the extractor does not abort in step (4) with probability </span>\\epsilon<span class="math">. Given that the extractor does not abort in step (4), by Markov’s inequality, we have that the extractor rewinds more than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times with probability </span>4/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, the probability that the extractor does not abort in step (4) and requires less than </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> rewinds is </span>\\epsilon\\cdot(1-4/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, suppose that the extractor does not abort in step (4). Then, because the extractor randomly samples <span class="math">\\rho^{\\star^{(1,2)}}</span>, we have that <span class="math">\\rho^{\\star^{(1,1)}} \\neq \\rho^{\\star^{(1,2)}}</span> with probability $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Similarly, we have that, </span>\\rho^{(1)} \\neq \\rho^{(2)}<span class="math"> with probability </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\rho^{\\star^{(2,1)}} = \\rho^{\\star^{(2,2)}}<span class="math"> with probability </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, we have that the probability the extractor successfully produces some output in under </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ rewinding steps is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\epsilon \\cdot \\left(1 - \\frac {4}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(1 - \\frac {3}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) = \\epsilon - \\operatorname {n e g l} (\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Next, if the extractor does not abort, we show that the extractor succeeds in producing satisfying witnesses with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>. This brings the overall extractor success probability to <span class="math">\\epsilon -\\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We first show that the in the transcripts retrieved, the output witnesses for linearized committed CCS instances do not depend on the choice of <span class="math">\\rho^{\\star}</span>. More precisely, we show that, for <span class="math">i\\in \\{1,2\\}</span>, <span class="math">\\widetilde{w}^{(i,1)} = \\widetilde{w}^{(i,2)}</span>.</p>

    <p class="text-gray-300">For <span class="math">i\\in \\{1,2\\}</span> and <span class="math">j\\in \\{1,2\\}</span>, let</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi^ {(i, j)} = ((C ^ {(i, j)}, u ^ {(i, j)}, \\mathsf {x} ^ {(i, j)}, r _ {x} ^ {(i, j)}, v _ {1} ^ {(i, j)}, \\ldots , v _ {t} ^ {(i, j)}), (\\overline {{E}} ^ {(i, j)}, u ^ {\\star (i, j)}, \\overline {{W}} ^ {(i, j)}, x ^ {\\star (i, j)})).</span></div>

    <p class="text-gray-300">By the verifier's construction and because the transcripts share the same prefix prior to the choice of <span class="math">\\rho^{\\star}</span>, we have for <span class="math">i \\in \\{1,2\\}</span> that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(C ^ {(i, 1)}, u ^ {(i, 1)}, \\mathbf {x} ^ {(i, 1)}, r _ {x} ^ {(i, 1)}, v _ {1} ^ {(i, 1)}, \\dots , v _ {t} ^ {(i, 1)}\\right) = \\left(C ^ {(i, 2)}, u ^ {(i, 2)}, \\mathbf {x} ^ {(i, 2)}, r _ {x} ^ {(i, 2)}, v _ {1} ^ {(i, 2)}, \\dots , v _ {t} ^ {(i, 2)}\\right). \\tag {25}</span></div>

    <p class="text-gray-300">We are given that for <span class="math">i \\in \\{1,2\\}</span> and <span class="math">j \\in \\{1,2\\}</span>, <span class="math">\\widetilde{w}^{(i,j)}</span> is a satisfying witness and hence a valid opening of the commitment <span class="math">C^{(i,j)}</span>. By Equation 25, we have that for <span class="math">i \\in \\{1,2\\}</span>, <span class="math">C^{(i,1)} = C^{(i,2)}</span>. Therefore, by the binding property of the polynomial commitment scheme, with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>, we have for <span class="math">i \\in \\{1,2\\}</span> that</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {w} ^ {(i, 1)} = \\widetilde {w} ^ {(i, 2)}. \\tag {26}</span></div>

    <p class="text-gray-300">Given this equality of commitments and the associated witnesses for the output linearized committed CCS instances, we drop the second index when appropriate.</p>

    <p class="text-gray-300">We now show that the retrieved polynomials and vectors <span class="math">((\\widetilde{w}_1,(E_1,W_1)),\\widetilde{w}_2)</span> are valid openings to the corresponding commitments in the instance.</p>

    <p class="text-gray-300">For <span class="math">j \\in \\{1, 2\\}</span>, because <span class="math">(E, W)^{(1,j)}</span> is a satisfying witness to the folded committed relaxed R1CS instance, by construction,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m m i t} \\left(\\mathrm {p p} _ {\\mathrm {V C}}, W _ {1}\\right) + \\rho^ {\\star (1, j)} \\cdot \\operatorname {C o m m i t} \\left(\\mathrm {p p} _ {\\mathrm {V C}}, W _ {2}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m m i t} \\left(\\mathrm {p p} _ {\\mathrm {V C}}, W _ {1} + \\rho^ {\\star (1, j)} \\cdot W _ {2}\\right)</span></div>

    <p class="text-gray-300">By additive homomorphism.</p>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname {C o m m i t} \\left(\\mathrm {p p} _ {\\mathrm {V C}}, W ^ {(1, j)}\\right)</span></div>

    <p class="text-gray-300">By Equation (24).</p>

    <div class="my-4 text-center"><span class="math-block">= \\overline {{W}} ^ {(1, j)}</span></div>

    <p class="text-gray-300">Witness <span class="math">\\widetilde{W}^{(1,j)}</span> is a satisfying opening.</p>

    <div class="my-4 text-center"><span class="math-block">= \\overline {{W}} _ {1} + \\rho^ {\\star (1, j)} \\cdot \\overline {{W}} _ {2}</span></div>

    <p class="text-gray-300">By the verifier's computation.</p>

    <p class="text-gray-300">84</p>

    <p class="text-gray-300">Interpolating, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},W_{1})</span> <span class="math">=\\overline{W}_{1}</span> (27) <span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},W_{2})</span> <span class="math">=\\overline{W}_{2}</span> (28)</p>

    <p class="text-gray-300">Similarly,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},E_{1})+\\rho^{\\star^{(1,j)}}\\cdot\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},T)</span></p>

    <p class="text-gray-300"><span class="math">=\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},E_{1}+\\rho^{\\star^{(1,j)}}\\cdot T)</span> By additive homomorphism. <span class="math">=\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},E^{(1,j)})</span> By Equation (23). <span class="math">=\\overline{E}^{(1,j)}</span> Witness <span class="math">\\widetilde{E}^{(1,j)}</span> is a satisfying opening. <span class="math">=\\overline{E}_{1}+\\rho^{\\star^{(1,j)}}\\cdot\\overline{T}</span> By the verifier’s computation.</p>

    <p class="text-gray-300">Interpolating, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{VC}},E_{1})=\\overline{E}_{1}</span> (29)</p>

    <p class="text-gray-300">For <span class="math">j\\in\\{1,2\\}</span>, because <span class="math">(E,W)^{(1,j)}</span> is a satisfying witness to the committed relaxed R1CS instance <span class="math">(\\overline{E}^{(1,j)},u^{\\star^{(1,j)}},\\overline{W}^{(1,j)},x^{\\star^{(1,j)})}</span>, we have the following, where <span class="math">Z^{(1,j)}=(W^{(1,j)},u^{\\star^{(1,j)}},x^{\\star^{(1,j)}})</span>.</p>

    <p class="text-gray-300"><span class="math">AZ^{(1,j)}\\circ BZ^{(1,j)}=u^{\\star^{(1,j)}}\\cdot CZ^{(1,j)}+E^{(1,j)}</span></p>

    <p class="text-gray-300">By Equation (24), this implies that for <span class="math">j\\in\\{1,2\\}</span></p>

    <p class="text-gray-300"><span class="math">A\\cdot(Z_{1}+\\rho^{\\star^{(1,j)}}\\cdot Z_{2})\\circ B\\cdot(Z_{1}+\\rho^{\\star^{(1,j)}}\\cdot Z_{2})</span> <span class="math">=(u_{1}+\\rho^{\\star^{(1,j)}})\\cdot C\\cdot(Z_{1}+\\rho^{\\star^{(1,j)}}\\cdot Z_{2})+(E_{1}+\\rho^{\\star^{(1,j)}}\\cdot T),</span></p>

    <p class="text-gray-300">where <span class="math">Z_{1}=(W_{1},u_{1},x_{1})</span>, <span class="math">Z_{2}=(W_{2},1,x_{2})</span>, and <span class="math">x_{2}</span> is parsed from the transcripts and is identical across the two executions with the same <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Because the prover commits to <span class="math">W_{1}</span>, <span class="math">W_{2}</span>, and <span class="math">T</span> before the verifier sends the challenge <span class="math">\\rho^{\\star^{(1,j)}}</span>, we have with probability <span class="math">1-\\mathsf{negl}(\\lambda)</span> that</p>

    <p class="text-gray-300"><span class="math">AZ_{1}\\circ BZ_{1}</span> <span class="math">=u_{1}\\cdot CZ_{1}+E_{1}</span> (30) <span class="math">AZ_{2}\\circ BZ_{2}</span> <span class="math">=CZ_{2}.</span> (31)</p>

    <p class="text-gray-300">This implies that <span class="math">(E_{1},W_{1})</span> and <span class="math">(\\vec{0},W_{2})</span> meet the requirements of a satisfying witness for committed relaxed R1CS instances with structure <span class="math">(A,B,C)</span>. In particular, we have established that <span class="math">(E_{1},W_{1})</span> is a satisfying witness to the committed relaxed R1CS instance in <span class="math">\\varphi_{1}</span>.</p>

    <p class="text-gray-300">Furthermore, since the verifier checks that <span class="math">x_{2}=(\\rho^{(1)},C_{1},C_{2},C^{\\prime})</span> for some <span class="math">C^{\\prime}\\in\\mathbb{G}_{1}</span>, given that the we have have a witness satisfying Equation 31, this implies that for <span class="math">j\\in\\{1,2\\}</span></p>

    <p class="text-gray-300"><span class="math">C^{(1,j)}=C_{1}+\\rho^{(1)}\\cdot C_{2}</span> (32)</p>

    <p class="text-gray-300">With a similar reasoning via the accepting transcripts with <span class="math">\\rho^{(2)}</span> as the verifier's randomness, we can establish that for <span class="math">j \\in \\{1, 2\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">C^{(2,j)} = C_1 + \\rho^{(2)} \\cdot C_2 \\tag{33}</span></div>

    <p class="text-gray-300">For <span class="math">i \\in \\{1,2\\}</span> and <span class="math">j \\in \\{1,2\\}</span>, because <span class="math">\\widetilde{w}^{(i,j)}</span> is a satisfying witness to the folded linearized CCS instance, by construction,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}_1) + \\rho^{(i)} \\cdot \\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}_2)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}_1 + \\rho^{(i)} \\cdot \\widetilde{w}_2) \\quad \\text{By additive homomorphism.}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}^{(i,j)}) \\quad \\text{By Equations (22) and (26).}</span></div>

    <div class="my-4 text-center"><span class="math-block">= C^{(i,j)} \\quad \\text{Witness } \\widetilde{w}^{(i,j)} \\text{ is a satisfying opening.}</span></div>

    <div class="my-4 text-center"><span class="math-block">= C_1 + \\rho^{(i)} \\cdot C_2 \\quad \\text{By Equations 32 and 33}</span></div>

    <p class="text-gray-300">Interpolating, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}_1) = C_1 \\tag{34}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Commit}(\\mathfrak{pp}_{\\mathsf{PC}}, \\widetilde{w}_2) = C_2. \\tag{35}</span></div>

    <p class="text-gray-300">Next, we must argue that <span class="math">\\widetilde{w}_1</span> and <span class="math">\\widetilde{w}_2</span> satisfy the remainder of the instances <span class="math">\\varphi_1</span> and <span class="math">\\varphi_2</span> respectively under the structure <span class="math">\\mathfrak{s}</span>.</p>

    <p class="text-gray-300">Indeed, consider <span class="math">(\\sigma_1,\\ldots,\\sigma_t)</span> and <span class="math">(\\theta_1,\\ldots,\\theta_t)</span> sent by the prover which by the extractor's construction are identical across all executions of the interaction. By the verifier's computation we have that for <span class="math">i \\in \\{1,2\\}</span> and all <span class="math">j \\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j + \\rho^{(i)} \\cdot \\theta_j = v_j^{(i)} \\tag{36}</span></div>

    <p class="text-gray-300">Now, because <span class="math">\\widetilde{w}^{(i)}</span> is a satisfying witness, for <span class="math">i \\in \\{1,2\\}</span> we have for all <span class="math">j \\in [t]</span> that</p>

    <div class="my-4 text-center"><span class="math-block">v_j^{(i)} = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z}^{(i)}(y),</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{z}^{(i)} = (\\widetilde{w^{(i)}, u^{(i)}}, \\mathsf{x}^{(i)})</span>.</p>

    <p class="text-gray-300">However, by Equations (22) and (36), for <span class="math">i \\in \\{1,2\\}</span> and <span class="math">j \\in [t]</span>, this implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j + \\rho^{(i)} \\cdot \\theta_j = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_1}(y) + \\rho^{(i)} \\cdot \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_2}(y),</span></div>

    <p class="text-gray-300">where <span class="math">\\widetilde{z_1} = (\\widetilde{w_1, u, \\mathsf{x}_1})</span> and <span class="math">\\widetilde{z_2} = (\\widetilde{w_2, 1, \\mathsf{x}_2})</span>. Interpolating, we have that, for all <span class="math">j \\in [t]</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_j = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_1}(y)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\theta_j = \\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_2}(y)</span></div>

    <p class="text-gray-300">Thus, because that the verifier does not abort, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} c &amp;amp;= \\left(\\sum_{j \\in t} \\gamma^j \\cdot e_1 \\cdot \\sigma_j\\right) + \\left(\\gamma^{t+1} \\cdot e_2 \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_j\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in t} \\gamma^j \\cdot \\widetilde{eq}(r_x, r_x&#x27;) \\cdot \\sigma_j\\right) + \\left(\\gamma^{t+1} \\cdot \\widetilde{eq}(\\beta, r_x&#x27;) \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\theta_j\\right) \\\\ &amp;amp;= \\left(\\sum_{j \\in t} \\gamma^j \\cdot \\widetilde{eq}(r_x, r_x&#x27;) \\cdot \\sum_{y \\in \\{0,1\\}^s} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_1}(y)\\right) + \\\\ &amp;amp;\\quad \\left(\\gamma^{t+1} \\cdot \\widetilde{eq}(\\beta, r_x&#x27;) \\cdot \\sum_{i \\in [q]} c_i \\cdot \\prod_{j \\in S_i} \\sum_{y \\in \\{0,1\\}^s} \\widetilde{M}_j(r_x&#x27;, y) \\cdot \\widetilde{z_2}(y)\\right) \\\\ &amp;amp;= \\sum_{j \\in [t]} \\gamma_j \\cdot L_j(r_x&#x27;) + \\gamma^{t+1} \\cdot Q(r_x&#x27;) \\\\ &amp;amp;= g(r_x&#x27;) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by the soundness of the sum-check protocol, this implies that with probability $1 - O(d \\cdot s) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>r_x'$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\sum_{j \\in [t]} \\gamma^j \\cdot v_j + \\gamma^{t+1} \\cdot 0 &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} g(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\left(\\sum_{j \\in [t]} \\gamma^j \\cdot L_j(x) + \\gamma^{t+1} \\cdot Q(x)\\right) \\\\ &amp;amp;= \\sum_{j \\in [t]} \\gamma^j \\cdot \\left(\\sum_{x \\in \\{0,1\\}^s} L_j(x)\\right) + \\gamma^{t+1} \\cdot \\sum_{x \\in \\{0,1\\}^s} Q(x) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma [56], this implies that with probability $1 - O(t) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\gamma$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">v_j = \\sum_{x \\in \\{0,1\\}^s} L_j(x)</span></div>

    <p class="text-gray-300">for all <span class="math">j \\in [t]</span> and</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^s} Q(x).</span></div>

    <p class="text-gray-300">Now, for all <span class="math">j \\in [t]</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_j &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} L_j(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\widetilde{e}q(r_x, x) \\cdot \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} M_j(x, y) \\cdot \\widetilde{z}_1(y)\\right) \\\\ &amp;amp;= \\sum_{y \\in \\{0,1\\}^{s&#x27;}} M_j(r_x, y) \\cdot \\widetilde{z}_1(y) \\end{aligned}</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\widetilde{w_1}</span> is a satisfying witness to the linearized committed CCS instance in <span class="math">\\varphi_1</span>.</p>

    <p class="text-gray-300">Finally, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} 0 &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} Q(x) \\\\ &amp;amp;= \\sum_{x \\in \\{0,1\\}^s} \\widetilde{e}q(\\beta, x) \\cdot \\left(\\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_2(y)\\right)\\right) \\\\ &amp;amp;= \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(\\beta, y) \\cdot \\widetilde{z}_2(y)\\right) \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Schwartz-Zippel lemma, this implies that with probability $1 - s/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1 - \\mathrm{negl}(\\lambda)<span class="math"> over the choice of </span>\\beta<span class="math">, we have that for all </span>x \\in \\{0,1\\}^s$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{i=1}^q c_i \\cdot \\prod_{j \\in S_i} \\left(\\sum_{y \\in \\{0,1\\}^{s&#x27;}} \\widetilde{M}_j(x, y) \\cdot \\widetilde{z}_2(y)\\right)</span></div>

    <p class="text-gray-300">This implies that <span class="math">\\widetilde{w_2}</span> is a satisfying witness to <span class="math">\\varphi_2</span>.</p>

    <p class="text-gray-300">Thus, if the extractor does not abort, it succeeds in producing satisfying witness <span class="math">(\\widetilde{w_1}, \\widetilde{w_2})</span> with probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <h2 id="sec-106" class="text-2xl font-bold">H.5 Proof of Theorem 8 (nlookup)</h2>

    <p class="text-gray-300"><strong>Lemma 20 (Perfect Completeness).</strong> Construction 8 satisfies perfect completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider public parameters <span class="math">\\mathsf{pp} = \\ell \\leftarrow \\mathcal{G}(1^{\\lambda}, N)</span>. Consider a common structure <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = \\widetilde{T} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell]</span>. Consider the prover and verifier keys</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk},\\mathsf{vk})=(\\widetilde{T},\\bot)\\leftarrow\\mathcal{K}(\\mathsf{pp},\\widetilde{T}).</span> Suppose that the prover and the verifier are provided an instance in <span class="math">\\mathcal{R}_{\\mathsf{poly}}</span></p>

    <p class="text-gray-300"><span class="math">(q_{r},v_{r})</span></p>

    <p class="text-gray-300">and a vector of <span class="math">\\mathcal{R}_{\\mathsf{lookup}}</span> instances</p>

    <p class="text-gray-300"><span class="math">(v_{1},\\ldots,v_{m}).</span></p>

    <p class="text-gray-300">Suppose that the prover is additionally provided with the corresponding satisfying witnesses for the <span class="math">\\mathcal{R}_{\\mathsf{lookup}}</span> instances</p>

    <p class="text-gray-300"><span class="math">(q_{1},\\ldots,q_{m}).</span></p>

    <p class="text-gray-300">By the satisfiability of the input instances we have that <span class="math">v_{r}=\\widetilde{T}(q_{r})</span> and <span class="math">v_{i}=\\widetilde{T}(q_{i})</span> for all <span class="math">i\\in[m]</span>.</p>

    <p class="text-gray-300">Therefore, for <span class="math">\\rho\\in\\mathbb{F}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">v_{r}+\\sum_{i\\in[m]}\\rho^{i}\\cdot v_{i}</span> <span class="math">=\\widetilde{T}(q_{r})+\\sum_{i\\in[m]}\\rho^{i}\\cdot\\widetilde{T}(q_{i})</span> By precondition. <span class="math">=\\sum_{x\\in\\{0,1\\}^{2}}\\left(\\widetilde{eq}(q_{r},x)\\cdot\\widetilde{T}(x)+\\sum_{i\\in[m]}\\rho^{i}\\cdot\\widetilde{eq}(q_{i},x)\\cdot\\widetilde{T}(x)\\right)</span> By Lemma 6. <span class="math">=g(x)</span> By definition.</p>

    <p class="text-gray-300">Therefore, by the perfect completeness of the sum-check protocol, we have that <span class="math">c=g(q_{r}^{\\prime})</span> Thus, for <span class="math">v_{r}^{\\prime}=\\widetilde{T}(q_{r}^{\\prime})</span>, <span class="math">e=\\widetilde{eq}(q_{r},q_{r}^{\\prime})</span>, and <span class="math">e_{i}=\\widetilde{eq}(q_{i},q_{r}^{\\prime})</span> for all <span class="math">i\\in[m]</span>, we have that</p>

    <p class="text-gray-300"><span class="math">c</span> <span class="math">=g(q_{r}^{\\prime})</span> <span class="math">=\\widetilde{eq}(q_{r},q_{r}^{\\prime})\\cdot\\widetilde{T}(q_{r}^{\\prime})+\\sum_{i\\in[m]}\\rho^{i}\\cdot\\widetilde{eq}(q_{i},q_{r}^{\\prime})\\cdot\\widetilde{T}(q_{r}^{\\prime})</span> <span class="math">=e\\cdot v_{r}^{\\prime}+\\sum_{i\\in[m]}\\rho^{i}\\cdot e_{i}\\cdot v_{r}^{\\prime}</span></p>

    <p class="text-gray-300">Therefore, we have that the verifier does not abort.</p>

    <p class="text-gray-300">By construction, we have that <span class="math">v_{r}^{\\prime}=\\widetilde{T}(q_{r}^{\\prime})</span>. Therefore, the folded polynomial evaluation instance is satisfying.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Lemma 21 (Knowledge Soundness).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction 8 satisfies knowledge soundness assuming that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(2^{\\lambda})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an adversary <span class="math">\\mathcal{A}</span> that adaptively picks the structure and instances, and a malicious prover <span class="math">\\mathcal{P}^{<em>}</span> that succeeds with probability <span class="math">\\epsilon</span>. Let <span class="math">\\mathsf{pp}=\\ell\\leftarrow\\mathcal{P}^{</em>}</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(1^{\\lambda},N)</span>. Suppose on input <span class="math">\\mathsf{pp}</span> and random tape <span class="math">\\mathsf{r}</span>, the adversary <span class="math">\\mathcal{A}</span> picks a structure <span class="math">\\mathsf{s}_1 = \\mathsf{s}_2 = \\widetilde{T} \\in \\mathbb{F}[X_1, \\ldots, X_\\ell]</span>, an <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> instance <span class="math">(q_r, v_r)</span>, a vector of <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> instances <span class="math">(v_1, \\ldots, v_m)</span>, and some auxiliary state <span class="math">\\mathsf{st}</span>.</p>

    <p class="text-gray-300">We construct an extractor <span class="math">\\mathcal{E}</span> that succeeds with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span> in obtaining satisfying witnesses for the original instances. It works as follows.</p>

    <p class="text-gray-300">On input <span class="math">\\mathsf{pp}</span> and <span class="math">\\mathsf{r}</span>, <span class="math">\\mathcal{E}</span> first obtains the following tuple from <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">(\\widetilde {T}, (q _ {r}, v _ {r}), (v _ {1}, \\dots , v _ {m}), \\mathsf {s t}) \\leftarrow \\mathcal {A} (\\mathsf {p p}, \\mathsf {r}).</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> then computes <span class="math">(\\mathsf{pk},\\mathsf{vk})\\gets \\mathcal{K}(\\mathsf{pp},\\widetilde{T})</span>. Next, <span class="math">\\mathcal{E}</span> runs</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(q _ {r} ^ {\\prime}, v _ {r} ^ {\\prime}\\right), \\bot\\right) \\leftarrow \\langle \\mathcal {P} ^ {*}, \\mathcal {V} \\rangle \\left(\\left(\\mathrm {p k}, \\mathrm {v k}\\right), \\left(q _ {r}, v _ {r}\\right), \\left(v _ {1}, \\dots , v _ {m}\\right), \\mathrm {s t}\\right)</span></div>

    <p class="text-gray-300">and obtains the first message <span class="math">(q_{1},\\ldots ,q_{m})</span> from <span class="math">\\mathcal{P}^<em></span> by parsing the corresponding transcript. The extractor <span class="math">\\mathcal{E}</span> outputs <span class="math">(\\bot ,(q_1,\\dots ,q_m))</span> as the witness. Because the extractor only runs <span class="math">\\mathcal{P}^</em></span> once, it runs in expected polynomial-time.</p>

    <p class="text-gray-300">We must argue that <span class="math">\\bot</span> is a satisfying <span class="math">\\mathcal{R}_{\\mathrm{poly}}</span> witness for <span class="math">(q_r, v_r)</span>, and that <span class="math">(q_1, \\ldots, q_m)</span> are satisfying <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> witnesses for the input instances <span class="math">(v_1, \\ldots, v_m)</span> with probability <span class="math">\\epsilon - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Suppose that we have that the witness <span class="math">\\perp</span> output by <span class="math">\\mathcal{P}^*</span> is satisfying for the corresponding verifier's output <span class="math">(q_r&#x27;, v_r&#x27;)</span> with probability <span class="math">\\epsilon</span>. By definition, this means that</p>

    <div class="my-4 text-center"><span class="math-block">v _ {r} ^ {\\prime} = \\widetilde {T} \\left(q _ {r} ^ {\\prime}\\right) \\tag {37}</span></div>

    <p class="text-gray-300">with probability <span class="math">\\epsilon</span>. Moreover, this means that the verifier does not abort with probability at least <span class="math">\\epsilon</span>, and thus we have the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c = e \\cdot v _ {r} ^ {\\prime} + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot e _ {i} \\cdot v _ {r} ^ {\\prime} \\\\ = \\widetilde {e q} \\left(q _ {r}, q _ {r} ^ {\\prime}\\right) \\cdot v _ {r} ^ {\\prime} + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot \\widetilde {e q} \\left(q _ {i}, q _ {r} ^ {\\prime}\\right) \\cdot v _ {r} ^ {\\prime} \\quad \\text {By the verifier&#x27;s computation}. \\\\ = \\widetilde {e q} \\left(q _ {r}, q _ {r} ^ {\\prime}\\right) \\cdot \\widetilde {T} \\left(q _ {r} ^ {\\prime}\\right) + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot \\widetilde {e q} \\left(q _ {i}, q _ {r} ^ {\\prime}\\right) \\cdot \\widetilde {T} \\left(q _ {r} ^ {\\prime}\\right) \\quad \\text {By Equation 37}. \\\\ = g \\left(q _ {r} ^ {\\prime}\\right) \\quad \\text {By definition}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">with probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Then, by the soundness of the sum-check protocol, we must have that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} v _ {r} + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot v _ {i} = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} g (x) \\\\ = \\sum_ {x \\in \\{0, 1 \\} ^ {\\ell}} \\left(\\widetilde {e q} \\left(q _ {r}, x\\right) \\cdot \\widetilde {T} (x) + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot \\widetilde {e q} \\left(q _ {i}, x\\right) \\cdot \\widetilde {T} (x)\\right) \\quad \\text {By definition}. \\\\ = \\widetilde {T} \\left(q _ {r}\\right) + \\sum_ {i \\in [ m ]} \\rho^ {i} \\cdot \\widetilde {T} \\left(q _ {i}\\right) \\quad \\text {By Lemma 6}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">with probability <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>. By the Schwartz-Zippel lemma over <span class="math">\\rho</span>, this implies that <span class="math">v_r = \\widetilde{T}(q_r)</span> and <span class="math">v_i = \\widetilde{T}(q_i)</span> for all <span class="math">i \\in [m]</span> with probability <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Moreover, by the verifier's initial check, we have that <span class="math">q_i \\in \\{0,1\\}^\\ell</span> for all <span class="math">i \\in [m]</span>. Therefore, we have that</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pp}, \\widetilde{T}, (q_r, v_r), \\bot) \\in \\mathcal{R}_{\\mathsf{poly}}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{pp}, \\widetilde{T}, (v_1, \\ldots, v_m), (q_1, \\ldots, q_m)) \\in \\mathcal{R}_{\\mathsf{lookup}}^{(m)},</span></div>

    <p class="text-gray-300">with probability <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>. Because the extractor <span class="math">\\mathcal{E}</span> outputs the initial message from the prover, we have that the extractor succeeds with probability <span class="math">\\epsilon - \\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">91</p>`;
---

<BaseLayout title="HyperNova: Recursive arguments for customizable constraint s... (2023/573)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/573
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
