---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/278';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Circle STARKs';
const AUTHORS_HTML = 'Ulrich Haböck, David Levit, Shahar Papini';

const CONTENT = `    <p class="text-gray-300">Ulrich Haböck, David Levit, Shahar Papini uhaboeck@polygon.technology, david@starkware.co, spapini@starkware.co</p>

    <p class="text-gray-300">December 17, 2024<sup>∗</sup></p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Traditional STARKs <a href="#page-31-0">\\[BSBHR18b,</a> <a href="#page-32-0">BSCR</a><sup>+</sup>19, [COS20\\]](#page-32-1) require a cyclic group of a smooth order in the field. This allows efficient interpolation of points using the FFT algorithm, and writing constraints that involve neighboring rows. ECFFT <a href="#page-31-1">\\[BSCKL21,</a> [BSCKL22\\]](#page-31-2) introduced a way to make efficient STARKs for any finite field, by using a cyclic group of an elliptic curve. We show a simpler construction in the lines of ECFFT over the circle curve x <sup>2</sup> +y <sup>2</sup> = 1. When p+ 1 is divisible by a large power of 2, this construction is as efficient as traditional STARKs and ECFFT. Applied to the Mersenne prime p = 2<sup>31</sup> −1, which has been recently advertised in [\\[HLN23\\]](#page-33-0), our preliminary benchmarks indicate a speed-up by a factor of 1.4 compared to a traditional STARK using the Babybear prime p = 2<sup>31</sup> − 2 <sup>27</sup> + 1 from [\\[BG\\]](#page-31-3).</p>

    <h2 id="sec-3" class="text-2xl font-bold">Contents</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Notations and definitions</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">The circle curve</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">The circle curve as a group<br></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">The space of polynomials and Circle Codes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Vanishing polynomials and quotients</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">The circle FFT</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1</td>

            <td class="px-3 py-2 border-b border-gray-700">The sequence of domains</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.2</td>

            <td class="px-3 py-2 border-b border-gray-700">The circle FFT and its inverse<br></td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Properties of the FFT space</td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">STARK over the circle</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Constraint selectors<br></td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">The interactive oracle proof for AIR<br></td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Computing the overall quotient</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.4</td>

            <td class="px-3 py-2 border-b border-gray-700">A note on generalizations<br></td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Low-degree test over the Circle</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><sup>∗</sup>This version corrects minor typos in Section <a href="#page-25-0">5.3</a> and adds an optimized treatment of constraints with punctuated activation domains.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acknowledgements</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">31</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">Correlated agreement</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">Soundness in the oracle model</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.1<br>Soundness of the IOP of proximity to circle codes</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.2<br>Soundness of the IOP for AIR</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.3<br>Witness extraction<br></td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">An optimized circle STARK for non-zk</td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">Implementation remarks</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Scalable and Transparent Arguments of Knowledge (STARKs) [\\[BSBHR18b\\]](#page-31-0) are succinct, general purpose argument systems which allow for efficient proof composition, and moreover do not require any trust assumptions for their setup. While technically, the original definition of a STARK also covers argument systems with a trustless setup elliptic curve commitment scheme, such as [\\[BGH19\\]](#page-31-5) and the entire track of folding schemes initiated by it, the term has become synonymous to univariate argument systems which rely on the FRI low-degree test <a href="#page-31-6">\\[BSBHR18a,</a> <a href="#page-31-7">BSCI</a>+20], a proof of proximity for Reed-Solomon codes. STARKs are widely adopted in practice <a href="#page-33-1">\\[Sta23,</a> <a href="#page-33-2">Pola,</a> <a href="#page-33-3">Polc,</a> <a href="#page-33-4">Pold,</a> [BG\\]](#page-31-3), mainly because of their smaller embedding overhead in the arithmetization step (they are not bound to cryptographically large fields), and their simplicity compared to the aforementioned aggregation and folding schemes.</p>

    <p class="text-gray-300">In univariate STARKs witness data is encoded into polynomials over a univariate domain, thereby demanding a smooth arithmetization field which supports fast Fourier transform (FFT) techniques; either the classical multiplicative Fourier transform [\\[CT65\\]](#page-32-2), or the additive FFT [\\[LCH14\\]](#page-33-5). This restriction was lifted by the Elliptic Curve Fourier Transform (ECFFT) [\\[BSCKL21\\]](#page-31-1), which uses smooth subgroups of elliptic curves as the underlying domain for the Fourier transform. Although tightly connected with the group structure of elliptic curves, the ECFFT is an algebraic transform similar to the additive FFT, and it is constructed along a chain of curves over the non-smooth field,</p>

    <div class="my-4 text-center"><span class="math-block">C_0 \\xrightarrow{\\pi_1} C_1 \\xrightarrow{\\pi_2} C_2 \\xrightarrow{\\pi_3} \\dots</span></div>

    <p class="text-gray-300">with 2-to-1 maps between them (each of algebraic degree 2), halving the sizes of the domains in each step. The ECFFT permits efficient interpolation by (certain) low-degree rational functions over the curve. The basic design principles of STARKs – the interactive oracle proof and the low-degree test – can be carried over to these rational function spaces and their algebraic geometry codes [\\[BSCKL22\\]](#page-31-2). ECFFT-based STARKs, which we shall call elliptic curve STARKs, are as efficient as classical STARKs, in the concrete sense and not just asymptotically, and by dropping the smoothness assumption on the finite field, they uncover an unprecedented freedom in the choice of the concrete prime for arithmetization.</p>

    <p class="text-gray-300">In a recent note [\\[HLN23\\]](#page-33-0), the authors consider a different approach for the Mersenne prime p = 2<sup>31</sup> − 1, a non-smooth prime with exceptionally fast arithmetic. They consider the circle curve</p>

    <div class="my-4 text-center"><span class="math-block">x^2 + y^2 = 1</span></div>

    <p class="text-gray-300">as a smooth multiplicative subgroup of the "complex extension" of the prime field (i.e. the quadratic extension with respect to the irreducible polynomial x <sup>2</sup> + 1), and apply well-known optimizations for the classical FFT of real-valued functions, diminishing the extension field costs to only a small overhead in the number of additions. Furthermore, they observe that the extrapolated values lie in a linear subspace of the complex plane, a line which essentially depends only on the target coset, thereby reducing the commitment cost of Reed-Solomon code words to that of their "rectified" representation of half the size. While the approach from [\\[HLN23\\]](#page-33-0) is much more elementary than the one from <a href="#page-31-1">\\[BSCKL21,</a> [BSCKL22\\]](#page-31-2), its main drawback is a limited usefulness for constraint evaluation, when computing the overall quotient polynomial in the STARK. Similar to polar coordinates, the rectified representation is beneficial for computing products of polynomials. However, evaluating the overall constraint involves products and sums in quite arbitrary order, and demands – rather sooner than later – a conversion back to the ordinary complex representation. While this drawback is not drastic when dealing only with a small number of polynomials, it matters to STARKs with wide traces (such as <a href="#page-33-2">\\[Pola,</a> [Polb\\]](#page-33-6)), thwarting the advantage of that prime over ordinary two-adic primes of comparable size.</p>

    <p class="text-gray-300">Motivated by [\\[HLN23\\]](#page-33-0), we propose a simpler construction along the lines of <a href="#page-31-1">\\[BSCKL21,</a> [BSCKL22\\]](#page-31-2), tailored to the Mersenne prime p = 2<sup>31</sup> − 1 and the circle curve. As every (smooth) quadratic curve, the circle curve is isomorphic to the projective line over the prime field and thus of size (p + 1) (this is a wellknown fact but we will recapitulate it below). And it is a cyclic group, with its operation inherited from the action of the rotation group SO(2) over the field. The circle curve has the following benefits over the elliptic curve approach:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Firstly, and contrary to elliptic curves, the group squaring map (in the sense of a multiplicative group notation) is of quadratic degree and 2-to-1, dropping the need of a chain of curves.</li>

      <li>2. Second, because rotation carries polynomials to polynomials in a degree-preserving manner, we may choose an FFT that is again with respect to a polynomial basis, instead of one comprised of rational functions. (Similar to the additive FFT and elliptic curve FFT, this polynomial basis is not the standard monomial one, and there is no known efficient conversion between the two).</li>

      <li>3. Thirdly, and perhaps most importantly, simplicity: The reader does not need to have any background in algebraic geometry. Taking advantage of the above mentioned projective line view of the curve (in algebraic geometry terms, it has genus zero) the proofs are elementary and self-contained, without assuming knowledge on divisor calculus and the Riemann-Roch theorem. All that is needed is familiarity with the notion of a projective space, and not even that if one does not intend going through the proofs.</li>

    </ul>

    <p class="text-gray-300">Although many of these features (if not all) are due to the genus of the circle curve, there is one point where the circle curve causes extra considerations. There is a gap of dimension one, between the image space of the FFT and the space of all polynomials of corresponding degree bound, the latter of which turns out the natural space for STARKs over the circle. In other words, FFT domains are one point too small to uniquely determine a polynomial of that degree bound, and this anomaly needs to be taken into account in a few places of the protocol: First, when computing the overall quotient, and second, in a preparatory step for the low-degree test. It turns out that in both cases the dimension gap can be treated cheaply (i.e. the computational cost is negligible) and without any loss in security.</p>

    <p class="text-gray-300">Overall, circle STARKs are as efficient as classical STARKs over smooth fields (or an ECFFT-based STARK), and their mathematical foundation is "as close as can be" to the classical case. The entire interactive oracle proof over the circle uses polynomials (bivariate, though<a href="#page-2-0">1</a> ) and the low-degree test is similar to the well-known FRI for Reed-Solomon codes. We believe that this helps a wider adoption in practice.</p>

    <p class="text-gray-300">The document is organized as follows. In the first part we provide all relevant preliminaries:</p>

    <p class="text-gray-300">• Section <a href="#page-3-0">2</a> and <a href="#page-4-0">3</a> introduce basic notions and discuss properties of the circle curve, its space of polynomials and Circle Codes, the Reed-Solomon type of code generated by them. In particular, we cover vanishing polynomials and quotients, the key ingredients for STARKs.</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>1</sup>Although we do not dwell on it, we stress the fact that the projective line view allows the entire circle STARK to be seen as a univariate one based on generalized Reed-Solomon codes.</p>

    <p class="text-gray-300">• In Section <a href="#page-12-0">4</a> we describe the FFT over the circle, the circle FFT and its inverse. We investigate the image space of the circle FFT and the aforementioned dimension gap.</p>

    <p class="text-gray-300">With the complete FFT tool-set ready, we are able to approach our target application, circle STARKs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In Section <a href="#page-19-0">5</a> we describe the interactive oracle proof for an elementary system of constraints, a restricted algebraic intermediate representation yet expressive enough to highlight the general principle. We discuss the extra measures needed to deal with the aforementioned dimension gap.</li>

      <li>Eventually, in Section <a href="#page-28-0">6,</a> we describe the low-degree test for polynomials over the circle curve. That proof of proximity is similar to FRI, with the folding steps in circle FFT style.</li>

    </ul>

    <p class="text-gray-300">The second part is largely informal, focusing on the protocol steps, the involved polynomial arithmetic, and the few differences to univariate STARKs. A fully formal treatment, including security notions as well as their proofs (in the ordinary oracle model) is postponed to the appendix: In Appendix <a href="#page-34-0">A</a> we cite the celebrated correlated agreement theorem for Reed-Solomon codes <a href="#page-31-7">\\[BSCI</a><sup>+</sup>20], and explain how it is taken over to circle Codes. In Appendix <a href="#page-35-0">B</a> we prove soundness (in the oracle model) of both circle FRI and the circle STARK from Section <a href="#page-19-0">5.</a> In Appendix <a href="#page-43-0">C</a> we further sketch a variant of the circle STARK in which the evaluation domain is a superset of the trace domain. While this variant is not able to support zero-knowledge, it optimizes the extrapolation effort of the prover for certain parameter settings.</p>

    <p class="text-gray-300">We conclude the paper with a final section on implementation remarks, Appendix <a href="#page-44-0">D,</a> in which we provide preliminary benchmarks of the circle FFT over the Mersenne prime p = 2<sup>31</sup> − 1. Compared to the classical FFT over the equally sized Babybear prime p = 2<sup>31</sup> −2 <sup>27</sup> + 1 from [\\[BG\\]](#page-31-3), our measurements indicate a speedup by a factor of 1.4, and we expect to achieve the same advantage in a fully optimized implementation of the FFT and the entire STARK.</p>

    <p class="text-gray-300">Although our main target is the Mersenne prime p = 2<sup>31</sup> − 1, we note that our considerations apply to arbitrary primes p with (p + 1) being smooth, and the entire document takes this into account<a href="#page-3-1">2</a> . We point out that the circle FFT is related, yet different to the recent Galois-FFT [\\[LX23\\]](#page-33-7), which (up to isomorphism) shares the same underlying space and group action. The Galois-FFT is concretely less efficient than the circle FFT (it costs the double of multiplications), and beyond that not as useful for STARKs, since its function spaces are not invariant under action of their corresponding subgroup. A detailed comparison of the two FFTs is given in the companion note [\\[Hab24\\]](#page-32-3).</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Notations and definitions</h2>

    <p class="text-gray-300">Let us start with the central property of the primes we consider.</p>

    <p class="text-gray-300"><span id="page-3-2"></span>Definition 1 (CFFT-friendly prime). Any prime p for which (p+ 1) is divisible by 2 <sup>n</sup>+1 for sufficiently large n ≥ 1, will be called CFFT-friendly, and any such n is a supported order, and N = 2<sup>n</sup> a supported domain size.</p>

    <p class="text-gray-300">Remark 1. The reason for demanding 2 <sup>n</sup>+1 instead of 2 <sup>n</sup> being a factor (p + 1) in Definition <a href="#page-3-2">1</a> is due to the existence of suitable FFT domains and will become clear in Section <a href="#page-12-0">4.</a></p>

    <p class="text-gray-300">Which n ≥ 1 is considered sufficiently large depends on the application. In the context of STARK one typically wants a small prime p with p + 1 being as smooth as possible. A compelling choice is the Mersenne prime</p>

    <div class="my-4 text-center"><span class="math-block">p = 2^{31} - 1,</span></div>

    <p class="text-gray-300">called M31 in [\\[HLN23\\]](#page-33-0), which for its exceptionally efficient arithmetic is also our main target. However, other choices of CFFT friendly primes might be useful in practice, and for this reason why we keep our exposition as general as possible.</p>

    <p class="text-gray-300"><span id="page-3-1"></span><sup>2</sup> In fact, this approach can be generalized to non-prime finite fields F<sup>q</sup> with (q + 1) being smooth as well.</p>

    <p class="text-gray-300">CFFT-friendly primes are of the form  <span class="math">p = 2^{n+1} \\cdot t - 1</span>  for integers  <span class="math">n, t \\ge 1</span> . In particular,  <span class="math">p - 1 = 2 \\cdot t&#x27;</span>  with  <span class="math">t&#x27; = 2^n \\cdot t - 1</span>  being odd, or equivalently</p>

    <p class="text-gray-300"><span class="math-block">p \\equiv 3 \\mod 4</span> ,</p>

    <p class="text-gray-300">meaning that -1 does not have a square root modulo p. For any such prime, the polynomial  <span class="math">x^2 + 1</span>  has no roots in the prime field  <span class="math">\\mathbb{F}_p</span> .</p>

    <p class="text-gray-300">We shall denote the algebraic closure of  <span class="math">\\mathbb{F}_p</span>  by K, and  <span class="math">\\pm i</span>  the roots of  <span class="math">x^2 + 1</span>  in K. Finite extensions of  <span class="math">\\mathbb{F}_p</span>  will be denoted by F, and considered as a subfield of K. In rare cases it will be useful to work with F(i), the field that results from F by adjoining the root i. If i is contained in F then F(i) = F; otherwise F(i) is a quadratic extension of F.</p>

    <p class="text-gray-300">For any finite extension F of  <span class="math">\\mathbb{F}_p</span>  we will write F[x] and F[x,y] for the ring of polynomials in one and two variables, respectively. Likewise, we use the notation  <span class="math">F[x]^{\\leq d}</span>  and  <span class="math">F[x,y]^{\\leq d}</span>  of all polynomials over F of total degree at most d. Polynomials from F[x,y] will be often denoted as p(x,y), which will not cause confusion with the prime p although we override notation. Given a polynomial p(x,y) from F[x,y], the ideal generated by it is denoted as (p(x,y)).</p>

    <p class="text-gray-300">For certain aspects, mostly within proofs, the one and two-dimensional projective spaces  <span class="math">P^1(F)</span>  and  <span class="math">P^2(F)</span>  over a finite extension F of  <span class="math">\\mathbb{F}_p</span>  will be useful. We consider them contained in the corresponding projective space  <span class="math">P^1(K)</span>  and  <span class="math">P^2(K)</span>  over the algebraic closure K, and we use the common notation (t:s) and (x:y:z) for points in  <span class="math">P^1(K)</span>  and  <span class="math">P^2(K)</span> , respectively. Points with non-zero last coordinate,  <span class="math">s \\neq 0</span>  or  <span class="math">z \\neq 0</span> , are affine points.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">3 The circle curve</h3>

    <p class="text-gray-300">Although we target CFFT-friendly primes p (cf. Definition 1), most of this section depends only on the property  <span class="math">p \\equiv 3 \\mod 4</span> . Thus, unless stated otherwise, let  <span class="math">\\mathbb{F}_p</span>  be the prime field with modulus  <span class="math">p \\equiv 3 \\mod 4</span> .</p>

    <p class="text-gray-300">We define the Circle Curve, denoted by  <span class="math">C = C(\\mathbb{F}_p)</span> , to be the (smooth) algebraic variety over  <span class="math">\\mathbb{F}_p</span>  defined by the equation</p>

    <div class="my-4 text-center"><span class="math-block">C: x^2 + y^2 = 1,</span></div>

    <p class="text-gray-300">or equivalently, in projective coordinates</p>

    <div class="my-4 text-center"><span class="math-block">C: X^2 + Y^2 = Z^2.</span></div>

    <p class="text-gray-300"><span id="page-4-1"></span>Remark 2. By the condition on the modulus p, there are no  <span class="math">\\mathbb{F}_p</span> -rational points at infinity Z=0, and the projective view seems of not much use. However, the complete geometric picture unfolds when considering the curve over the algebraic closure K of  <span class="math">\\mathbb{F}_p</span> , in which there are two points at infinity,  <span class="math">\\infty=(1:i:0)</span>  and  <span class="math">\\bar{\\infty}=(1:-i:0)</span> , with  <span class="math">\\pm i</span>  being the square roots of -1. These two points, which are  <span class="math">\\mathbb{F}_p(i)</span> -rational, will play a prominent role in our construction.</p>

    <p class="text-gray-300">The arithmetization of circle STARK takes place over the circle curve domain. Witnesses are encoded into low-degree polynomials over that domain, and subjected to certain algebraic relations, the constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-4-2"></span><strong>Lemma 1.</strong> There is an isomorphism between the circle curve  <span class="math">C(\\mathbb{F}_p)</span>  and the projective line  <span class="math">P^1(\\mathbb{F}_p)</span>  which extends to arbitrary extensions of  <span class="math">\\mathbb{F}_p</span> , including its algebraic closure K. In particular, for any finite extension F of  <span class="math">\\mathbb{F}_p</span> , the number of points of the circle curve over F is</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> The isomorphism is the stereographic projection onto the y-axis with center (-1,0), defined by the equations</p>

    <div class="my-4 text-center"><span class="math-block">t = \\frac{y}{x+1}, \\quad (x,y) = \\left(\\frac{1-t^2}{1+t^2}, \\frac{2 \\cdot t}{1+t^2}\\right).</span></div>

    <p class="text-gray-300">Under this isomorphism (-1,0) is identified with infinity of the projective line, and the two curve points  <span class="math">\\infty = (1:+i:0), \\bar{\\infty} = (1:-i:0)</span>  from Remark 2 correspond to  <span class="math">t=\\pm i</span> .</p>

    <p class="text-gray-300">Although we pivot to the bivariate representation of the circle curve, the projective line view will be extremely useful within proofs. The isomorphism from Lemma 1 allows a direct translation of bivariate function fields into univariate ones, and consequently a much more elementary treatment, avoiding general tools from algebraic geometry such as the Riemann-Roch theorem. Nevertheless, whenever useful we provide complementing remarks addressed to the reader with background in algebraic geometry.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.1 The circle curve as a group</h3>

    <p class="text-gray-300">The p+1 points of  <span class="math">C(\\mathbb{F}_p)</span>  form a group with the group operation</p>

    <div class="my-4 text-center"><span class="math-block">(x_0, y_0) \\cdot (x_1, y_1) := (x_0 \\cdot x_1 - y_0 \\cdot y_1, x_0 \\cdot y_1 + y_0 \\cdot x_1).</span></div>

    <p class="text-gray-300">(We somewhat override notation here, but as we do not use entry-wise multiplication this will not cause confusion.) For this reason, we shall call  <span class="math">C(\\mathbb{F}_p)</span>  also the <em>circle group</em>. The circle group is cyclic because the map  <span class="math">(x,y) \\mapsto x + i \\cdot y</span>  is a group homomorphism between  <span class="math">C(\\mathbb{F}_p)</span>  and a multiplicative subgroup of the extension  <span class="math">\\mathbb{F}_p(i)</span> . The group has (1,0) as its neutral element, and for any  <span class="math">P = (P_x, P_y)</span>  in  <span class="math">C(\\mathbb{F}_p)</span>  we shall call</p>

    <div class="my-4 text-center"><span class="math-block">T_P(x,y) := P \\cdot (x,y) = (P_x \\cdot x - P_y \\cdot y, P_x \\cdot y + P_y \\cdot x),</span></div>

    <p class="text-gray-300">the rotation, or translation by P. The squaring map with respect to the group operation is the quadratic map</p>

    <div class="my-4 text-center"><span class="math-block">\\pi(x,y) := (x,y) \\cdot (x,y) = (x^2 - y^2, 2 \\cdot x \\cdot y) = (2 \\cdot x^2 - 1, 2 \\cdot x \\cdot y), \\tag{1}</span></div>

    <p class="text-gray-300">and group inverses are given by the degree-one map</p>

    <div class="my-4 text-center"><span class="math-block">J(x,y) := (x, -y). \\tag{2}</span></div>

    <p class="text-gray-300">Note that, as in any group, the map J is an involution, i.e. J(J(P)) = P for every  <span class="math">P \\in C(\\mathbb{F}_p)</span> , and that J and  <span class="math">\\pi</span>  commute, i.e.  <span class="math">\\pi(J(P)) = J(\\pi(P))</span>  for every  <span class="math">P \\in C(\\mathbb{F}_p)</span> .</p>

    <p class="text-gray-300">Remark 3. The definition of  <span class="math">T_P</span>  extends to the entire projective variety over K, and it is easily verified that both  <span class="math">\\infty</span>  and  <span class="math">\\bar{\\infty}</span>  from Remark 2 are fixed points under the action of the circle group. We stress the fact that the existence of fixed points is in stark contrast to the elliptic curve case. We will see below that these fixed points allow a more elegant choice of rotation-invariant Riemann-Roch spaces.</p>

    <p class="text-gray-300"><span id="page-5-1"></span><strong>Remark 4.</strong> Under the isomorphism from Lemma 1, the circle group law translates to the projective line as  <span class="math">(t_1:s_1) \\oplus (t_2:s_2) = (t_1 \\cdot s_2 + t_2 \\cdot s_1:s_1 \\cdot s_2 - t_1 \\cdot t_2)</span> , or in affine coordinates  <span class="math">t_1 \\oplus t_2 = \\frac{t_1 + t_2}{1 - t_1 \\cdot t_2}</span> . In other words, the circle group is isomorphic to a subgroup of linear automorphisms of the projective line, those which leave  <span class="math">\\pm i</span>  invariant. This is exactly the subgroup chosen in the Galois-FFT [LX23].</p>

    <p class="text-gray-300">Since  <span class="math">C(\\mathbb{F}_p)</span>  is cyclic, for each  <span class="math">N \\geq 1</span>  which divides (p+1) there is a unique cyclic subgroup of size N. In the case of a two-adic order  <span class="math">N=2^n</span>  we shall denote that unique subgroup by  <span class="math">G_n</span> . The following type of sets are the suitable domains of the circle FFT described in Section 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 2.</strong> Let  <span class="math">G_{n-1}</span>  be a (cyclic) subgroup of  <span class="math">C(\\mathbb{F}_p)</span>  of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{n-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{n-1}<span class="math"> ,  </span>n \\ge 1<span class="math"> . Any disjoint union  </span>D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1}<span class="math"> , i.e. with  </span>Q \\cdot G_{n-1} \\cap Q^{-1} \\cdot G_{n-1} = \\emptyset<span class="math"> , is called a <em>twin-coset</em> of size  </span>N = 2^n<span class="math"> . In the exceptional case that such a twin-coset D is again a coset of the subgroup  </span>G_n$  of double the size, we call D a <em>standard position coset</em> of size N.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Twin-cosets are composed of those pairs in the quotient group  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span>  which are mapped to one another under the inverse map J. This particularly excludes fixed points of J, which are those elements  <span class="math">Q \\cdot G_{n-1}</span>  with  <span class="math">Q^{-1} \\cdot G_{n-1} = Q \\cdot G_{n-1}</span> , or  <span class="math">Q^2 \\in G_{n-1}</span> . In other words, fixed points of J in the quotient group are either the trivial element or an element of order two, if it exists. In the latter case, the union of the two fixed points form the subgroup  <span class="math">G_n</span>  of size  <span class="math">2^n</span> . See Figure 1 for an illustration of standard position cosets and twin-cosets.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Let p be a prime such that  <span class="math">p \\equiv 3 \\mod 4</span> , and let  <span class="math">n \\ge 1</span> . The existence of standard position cosets of size  <span class="math">2^n</span>  is equivalent to that p is CFFT-friendly supporting the order n. In this case, standard position cosets are unique and of the form</p>

    <div class="my-4 text-center"><span class="math-block">D = Q \\cdot G_n = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1},</span></div>

    <p class="text-gray-300">with  <span class="math">Q \\in C(\\mathbb{F}_p)</span>  being an element of order  <span class="math">2^{n+1}</span> .</p>

    <p class="text-gray-300">Proof. Since  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span>  is cyclic, and excluding fixed points of J, there is at most one J-invariant pair  <span class="math">\\{Q \\cdot G_{n-1}, Q^{-1} \\cdot G_{n-1}\\}</span> , with  <span class="math">Q \\cdot G_{n-1} \\neq Q^{-1} \\cdot G_{n-1}</span> , which forms a coset in  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span> . In fact, since the two elements of the pair are different, we must have  <span class="math">Q^2 \\notin G_{n-1}</span> , and since it is a coset of order two, their difference  <span class="math">Q \\cdot G_{n-1} \\cdot (Q^{-1} \\cdot G_{n-1})^{-1} = Q^2 \\cdot G_{n-1}</span>  must be of order two, meaning that  <span class="math">Q \\cdot G_{n-1}</span>  has order four. The existence of order four elements in  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span>  is equivalent to that  <span class="math">2^{n+1}</span>  divides (p+1), completing the proof of the proposition.</p>

    <p class="text-gray-300">Although breaking with the group structure, twin-cosets are natural evaluation domains for the FFT. They are used to work around the non-smooth behaviour of the circle FFT under rotation, and are the typical extrapolation target in our application. Similar to the decomposition of univariate evaluation domains into cosets of smaller size, twin-coset domains, and in particular standard position cosets, can be decomposed into twin-cosets of smaller size.</p>

    <p class="text-gray-300"><span id="page-6-1"></span><strong>Lemma 2.</strong> Let p be a CFFT-friendly prime supporting the order  <span class="math">m \\geq 1</span> , and  <span class="math">G_k</span>  denote the subgroup of order  <span class="math">2^k</span>  for  <span class="math">k \\leq m</span> . Then any subset of  <span class="math">D \\subseteq C(\\mathbb{F}_p) \\setminus G_m</span>  which is invariant under  <span class="math">G_{m-1}</span>  and J can be decomposed into twin-cosets of size  <span class="math">N = 2^n</span> , for any  <span class="math">n \\leq m</span> . In particular for a standard position coset D of size  <span class="math">M = 2^m</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">D = Q \\cdot G_m = \\bigcup_{k=0}^{M/N-1} (Q^{4 \\cdot k + 1} \\cdot G_{n-1} \\cup Q^{-4 \\cdot k - 1} \\cdot G_{n-1}),</span></div>

    <p class="text-gray-300">where Q is an element from  <span class="math">C(\\mathbb{F}_p)</span>  of order  <span class="math">2^{m+1}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Since  <span class="math">n \\leq m</span>  the subset D is also invariant under  <span class="math">G_{n-1}</span>  and disjoint from  <span class="math">G_n</span> . Thus, as a J-invariant subset of  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span>  which does not contain fixed points of J, it is a union of J-invariant pairs in  <span class="math">C(\\mathbb{F}_p)/G_{n-1}</span> . This proves the first assertion. The second claim follows from  <span class="math">D = Q \\cdot G_{m-1} \\cup Q^{-1} \\cdot G_{m-1}</span> , where Q is an element of order  <span class="math">2^{m+1}</span> , and the decomposition</p>

    <div class="my-4 text-center"><span class="math-block">G_{m-1} = \\bigcup_{k=0}^{M/N-1} Q^{4 \\cdot k} \\cdot G_{n-1} = \\bigcup_{k=0}^{M/N-1} Q^{-4 \\cdot k} \\cdot G_{n-1},</span></div>

    <p class="text-gray-300">taking  <span class="math">Q^4</span>  as a generator of  <span class="math">G_{m-1}</span> .</p>

    <p class="text-gray-300"><span id="page-6-0"></span><strong>Lemma 3.</strong> If D is a twin-coset of size  <span class="math">N = 2^n</span> ,  <span class="math">n \\ge 2</span> , then its image  <span class="math">\\pi(D)</span>  under the squaring map  <span class="math">\\pi</span>  is a twin-coset of size N/2. More specifically, if D is a standard position coset, so is  <span class="math">\\pi(D)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Since  <span class="math">\\pi</span>  is a group endomorphism which maps  <span class="math">G_{n-1}</span>  onto the subgroup  <span class="math">G_{n-2}</span> , the image of a twin-coset  <span class="math">D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1}</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">\\pi(D) = \\pi(Q) \\cdot G_{n-2} \\cup \\pi(Q)^{-1} \\cdot G_{n-2}.</span></div>

    <p class="text-gray-300">Moreover, as  <span class="math">\\pi(Q)^2 = \\pi(Q^2)</span> , and  <span class="math">Q^2 \\notin G_{n-1}</span> , also  <span class="math">\\pi(Q)^2 \\notin G_{n-2}</span> , showing that the two cosets of  <span class="math">G_{n-2}</span>  are disjoint. Hence  <span class="math">\\pi(D)</span>  is a twin-coset, and its size is N/2. Finally, if D is invariant under  <span class="math">G_n</span> , then  <span class="math">\\pi(D)</span>  is invariant under  <span class="math">\\pi(G_n) = G_{n-1}</span> . Together with the first assertion, this proves that standard position cosets are mapped onto standard position cosets.</p>

    <p class="text-gray-300"><span id="page-7-1"></span>Figure 1: A schematic illustration of the three smallest standard position cosets in the affine plane over  <span class="math">\\mathbb{F}_p</span> , and general twin-cosets of the same size.</p>

    <p class="text-gray-300"><img src="_page_7_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <h2 id="sec-8" class="text-2xl font-bold">3.2 The space of polynomials and Circle Codes</h2>

    <p class="text-gray-300">Let F be an extension field of  <span class="math">\\mathbb{F}_p</span> . Over the circle curve, for any <em>even</em> integer  <span class="math">N \\geq 0</span>  we define  <span class="math">\\mathcal{L}_N(F)</span>  as the space of all bivariate polynomials with coefficients in F, and of total degree at most N/2,</p>

    <p class="text-gray-300"><span id="page-7-2"></span> <span class="math-block">\\mathcal{L}_N(F) = \\left\\{ p(x, y) \\in F[x, y] / (x^2 + y^2 - 1) : \\deg p \\le \\frac{N}{2} \\right\\},</span>  (3)</p>

    <p class="text-gray-300">where deg p in (3) means the <em>smallest</em> total degree of a representative within the class  <span class="math">p(x, y) + (x^2 + y^2 - 1)</span> . (Recall that  <span class="math">(x^2 + y^2 - 1)</span>  denotes the ideal in F[x, y] generated by  <span class="math">x^2 + y^2 - 1</span> ). Even though the functions in  <span class="math">\\mathcal{L}_N(F)</span>  are polynomials, we shall often use f and g for elements from  <span class="math">\\mathcal{L}_N(F)</span> .</p>

    <p class="text-gray-300">Remark 5. In terms of algebraic geometry,  <span class="math">\\mathcal{L}_N(F)</span>  equals the Riemann-Roch space over C(F) for the  <span class="math">\\mathbb{F}_p</span> -rational divisor  <span class="math">\\frac{N}{2} \\cdot \\infty + \\frac{N}{2} \\cdot \\bar{\\infty}</span> . In other words,  <span class="math">\\mathcal{L}_N(F)</span>  consists of all F-rational functions with poles only at  <span class="math">\\infty</span>  and  <span class="math">\\bar{\\infty}</span> , each at most of order N/2. It is due to the specific structure of the circle curve (in hand-wavy geometric terms, its projective closure is the Riemann sphere and not a group) that unlike in the elliptic curve case, the relevant function space can be again chosen as a space of <em>polynomials</em> instead of rational functions (under the bivariate view). However, we emphasize that this is not an essential feature.</p>

    <p class="text-gray-300">For a circle STARK the bivariate polynomials from  <span class="math">\\mathcal{L}_N(F)</span>  are what low-degree extensions are for classical univariate proofs. The crucial properties of  <span class="math">\\mathcal{L}_N(F)</span> , as shown by the following proposition, are (1) rotation invariance, which is needed for the next-neighbour relation and efficient encoding, and (2) good separability, leading to maximum distance separable codes.</p>

    <p class="text-gray-300"><span id="page-7-6"></span><strong>Proposition 2.</strong> For even integer  <span class="math">N \\geq 0</span>  the space of polynomials  <span class="math">\\mathcal{L}_N(F)</span>  has the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-7-4"></span>1. It is invariant under rotation, i.e. for each  <span class="math">f \\in \\mathcal{L}_N(F)</span>  and  <span class="math">P \\in C(\\mathbb{F}_p)</span> , also  <span class="math">f \\circ T_P \\in \\mathcal{L}_N(F)</span> . (Here and in the sequel,  <span class="math">\\circ</span>  denotes functional composition.)</li>

      <li><span id="page-7-5"></span>2. Its dimension is N+1, and every non-trivial  <span class="math">f \\in \\mathcal{L}_N(F)</span> , i.e.  <span class="math">f \\notin (x^2+y^2-1)</span> , has at most N zeros over C(F).</li>

    </ul>

    <p class="text-gray-300"><span id="page-7-3"></span><sup>&</sup>lt;sup>3</sup>We consider a divisor  <span class="math">D = \\sum n_P \\cdot P</span>  to be  <span class="math">\\mathbb{F}_p</span> -rational, if it is invariant under every automorphism of the Galois group of K over  <span class="math">\\mathbb{F}_p</span> , where K is the algebraic closure of  <span class="math">\\mathbb{F}_p</span> . That is, if  <span class="math">\\alpha</span>  is such an automorphism, then  <span class="math">n_{\\alpha(P)} = n_P</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Property 1 is trivial, since  <span class="math">T_P</span>  is linear and hence does not change the total degree of a polynomial.</p>

    <p class="text-gray-300">To prove Property 2, we make use of the fact that under the isomorphism from Lemma 1 the space  <span class="math">\\mathcal{L}_N(F)</span>  is carried over to</p>

    <p class="text-gray-300"><span id="page-8-0"></span> <span class="math-block">L_N(F) = \\left\\{ \\frac{p(t)}{(1+t^2)^{\\frac{N}{2}}} : p \\in F[t], \\deg p(t) \\le N \\right\\}.</span>  (4)</p>

    <p class="text-gray-300">As this representation will be useful in other proofs, we elaborate it in detail: The univariate representation of a bivariate monomial  <span class="math">x^j \\cdot y^k</span>  of degree  <span class="math">j + k \\le N/2</span> , where  <span class="math">j, k \\ge 0</span> , is</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(1-t^2)^j\\cdot (2\\cdot t)^k}{(1+t^2)^{j+k}} = \\frac{(1-t^2)^j\\cdot (2\\cdot t)^k\\cdot (1+t^2)^{N/2-j-k}}{(1+t^2)^{N/2}},</span></div>

    <p class="text-gray-300">which is of the claimed form. Conversely, let us compute the bivariate representation of a function  <span class="math">t^k/(1+t^2)^{N/2}</span>  with  <span class="math">0 \\le k \\le N</span> . Writing  <span class="math">k = 2 \\cdot j + \\varepsilon</span> , with  <span class="math">0 \\le j \\le N/2</span>  and  <span class="math">\\varepsilon \\in \\{0,1\\}</span>  (where in the edge case j = N/2 we have  <span class="math">\\varepsilon = 0</span> ), the function corresponds to</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{y^{2 \\cdot j + \\varepsilon}}{(1+x)^{2 \\cdot j + \\varepsilon}} \\cdot \\frac{(1+x)^{2 \\cdot N/2}}{((1+x)^2 + y^2)^{N/2}},</span></div>

    <p class="text-gray-300">which over the circle  <span class="math">x^2 + y^2 = 1</span>  is equal to</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{y^{\\varepsilon} \\cdot (1+x)^{j} \\cdot (1-x)^{j}}{(1+x)^{2 \\cdot j + \\varepsilon}} \\cdot \\frac{(1+x)^{N/2}}{2^{N/2}}, = 2^{-N/2} \\cdot y^{\\varepsilon} \\cdot (1-x)^{j} \\cdot (1+x)^{N/2 - j - \\varepsilon},</span></div>

    <p class="text-gray-300">which is a polynomial of total degree at most N/2.</p>

    <p class="text-gray-300">From the univariate representation (4) of  <span class="math">\\mathcal{L}_N(F)</span> , we eventually conclude that  <span class="math">\\dim \\mathcal{L}_N(F) = N+1</span> . Moreover, every fractional function  <span class="math">p(t)/(1+t^2)^{N/2}</span>  with p(t) of degree  <span class="math">\\leq N</span>  and N+1 zeros (possibly including infinity) must be trivial. This completes the proof of the Proposition.</p>

    <p class="text-gray-300">Remark 6. The above proof reduces to a three-liner when using results from algebraic geometry: The  <span class="math">\\mathbb{F}_p</span> -rational divisor  <span class="math">\\frac{N}{2} \\cdot \\infty + \\frac{N}{2} \\cdot \\bar{\\infty}</span>  is invariant under the group action, and so is its Riemann-Roch space. As the degree of the divisor is equal to N, the Riemann-Roch theorem tells us that  <span class="math">\\dim \\mathcal{L}_N(F) = N + 1 - g</span> , where g = 0 is the genus of the circle curve. (This is in fact the most notable difference from elliptic curves, where g = 1 and the dimension of space equals the degree of the divisor.) In regards of the number of zeros, any non-trivial function over the circle curve has the same number of zeros as poles in the algebraic closure K, with multiplicities taken into account.</p>

    <p class="text-gray-300">Note that by repeatedly substituting  <span class="math">y^2 = 1 - x^2</span>  every polynomial p(x, y) from  <span class="math">\\mathcal{L}_N(F)</span>  can be reduced to the form</p>

    <p class="text-gray-300"><span id="page-8-1"></span> <span class="math-block">p(x,y) = p_0(x) + y \\cdot p_1(x), \\tag{5}</span></p>

    <p class="text-gray-300">with  <span class="math">p_0 \\in F[x]^{\\leq N/2}</span>  and  <span class="math">p_1 \\in F[x]^{\\leq \\frac{N}{2}-1}</span> . We shall call the representation (5) the <em>canonical form</em> of a polynomial from  <span class="math">\\mathcal{L}_N(F)</span> . The canonical form shows that the collection of monomials</p>

    <p class="text-gray-300"><span class="math-block">1, x, \\dots, x^{\\frac{N}{2}}, \\quad y, y \\cdot x, \\dots, y \\cdot x^{\\frac{N}{2} - 1}</span>  (6)</p>

    <p class="text-gray-300">spans the space  <span class="math">\\mathcal{L}_N(F)</span> , and by the dimension of  <span class="math">\\mathcal{L}_N(F)</span> , it must be a basis. We call it the <em>monomial basis</em> of  <span class="math">\\mathcal{L}_N</span> .</p>

    <p class="text-gray-300"><span id="page-8-2"></span>For subsets D of the circle curve, typically a standard position coset or a twin-coset, we eventually define circle codes as the linear codes which stem from the space of polynomials of degree at most N/2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3</strong> (Circle Code). Let p be a prime satisfying  <span class="math">p=3 \\mod 4</span> , and N be an <em>even</em> integer,  <span class="math">2 \\leq N &lt; p+1</span> . Take D any proper subset of the circle curve  <span class="math">C(\\mathbb{F}_p)</span>  of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> N, and F be an (arbitrary, possibly infinite) extension field of  <span class="math">\\mathbb{F}_p</span> . The <em>circle code</em> with values in F and evaluation domain D, is linear code with code words from the space</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$C_N(F,D) = \\left\\{ f(P) \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{P \\in D} : f \\in \\mathcal{L}_N(F) \\right\\}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 7.</strong> The circle code is the algebraic geometry code generated by the Riemann-Roch space of the divisor  <span class="math">\\frac{N}{2} \\cdot \\infty + \\frac{N}{2} \\cdot \\bar{\\infty}</span> , with an evaluation domain of  <span class="math">\\mathbb{F}_p</span> -rational points. In particular, due to the genus of the circle curve (Lemma 1) it is a generalized Reed-Solomon code. See also Theorem 1 below.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The block length of the circle code is equal to the size of the evaluation domain D. By Proposition 2 the code is invariant under every rotation by  <span class="math">Q \\in C(\\mathbb{F}_p)</span>  which maps D onto itself, and the same holds for the involution J whenever J(D) = D. Moreover, Proposition 2 tells us that functions from  <span class="math">\\mathcal{L}_N(F)</span>  with more than N zeros are trivial, and hence the domain evaluation map  <span class="math">\\mathcal{L}_N(F) \\to F^D</span> , which takes a polynomial f to  $f(P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{P \\in D}$ , is a linear and injective map. Consequently</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">k = \\dim \\mathcal{C}_N(F, D) = N + 1,</span></div>

    <p class="text-gray-300">and the minimum distance of the code is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$d = \\min_{f \\in \\mathcal{L}_N(F), f \\neq 0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{P \\in D \\ : \\ f(P) \\neq 0\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- N =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- k + 1.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This means that the code hits the Singleton bound, i.e. d + k - 1 =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, and we have d =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- N. In other words  <span class="math">\\mathcal{C}_N(F, D)</span>  is maximum distance separable.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following theorem is an immediate consequence of Lemma 1 but nevertheless important for our purposes, as it allows for ordinary Reed-Solomon techniques.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-9-0"></span><strong>Theorem 1.</strong> Given a circle code  <span class="math">C = C_N(F, D)</span>  as in Definition 3, where F is an arbitrary (possibly infinite) field. Then C is isomorphic to a Reed-Solomon code  <span class="math">\\mathsf{RS}_{N+1}[F,S]</span>  over a set  <span class="math">S \\subseteq \\mathbb{F}_p</span>  of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and rate  $\\rho = (N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The isomorphism and its inverse is distance-preserving and computable within  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\log N)<span class="math">  field operations over  </span>\\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Choose Q be from  <span class="math">C(\\mathbb{F}_p)</span>  so that  <span class="math">T_Q(D) = Q \\cdot D</span>  does not contain the point (-1,0). (Since D is a proper subset of the circle such a Q exists.) Then  <span class="math">\\phi \\circ T_Q</span> , where  <span class="math">\\phi</span>  is as in Lemma 1, is also an isomorphism between the circle curve and the projective line, which maps the set D one-to-one onto the affine set  <span class="math">S = \\phi(Q \\cdot D)</span> . Under this isomorphism the space of polynomials  <span class="math">\\mathcal{L}_N(F)</span>  is again carried over to the univariate space  <span class="math">L_N(F)</span>  as described by Equation (4). Overall, the map which takes a word w from  <span class="math">F^D</span>  to the word  <span class="math">(1+t^2)^{N/2} \\cdot (w \\circ (\\phi \\circ T_Q)^{-1})</span>  over S is the claimed isomorphism between the linear codes.  <span class="math">\\square</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-9-1"></span><strong>Corollary 1.</strong> Let  <span class="math">C = C_N(F, D)</span>  be a circle code as in Definition 3, with values over a (possibly infinite) extension field of  <span class="math">\\mathbb{F}_p</span> , and rate  $\\rho = (N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Then for given proximity parameter  </span>\\theta = 1 - \\left(1 + \\frac{1}{2 \\cdot m}\\right) \\cdot \\sqrt{\\rho}<span class="math"> , where  </span>m \\geq 1<span class="math">  is an arbitrary integer, and  </span>f \\in F^D<span class="math">  with  </span>d(f, C) \\leq \\theta$ , there are at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\ell(\\theta) \\leq \\sqrt{\\frac{m \\cdot (m+1)}{\\rho}} &lt; \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">code words  <span class="math">\\theta</span> -close to f. There is a deterministic algorithm which outputs all  <span class="math">\\theta</span> -close code words within  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})$  field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof.</em> The bound is the list size bound assured by the Guruswami-Sudan decoder for the isomorphic Reed-Solomon code, run with multiplicity parameter  <span class="math">m \\geq 1</span> . Using the discriminant method for finding factors of the form Y - p(X) for the Guruswami-Sudan polynomial Q(X,Y) consumes  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})<span class="math">  field operations. (See [GS99] for details.) Since the isomorphism costs only  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  field operations, the asymptotic bound does not change.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the application of circle STARKs, we will consider purely two-adic  <span class="math">N=2^n, n \\geq 1</span> , and encoding will be done by FFT-based extrapolation, extending the set of values given over a standard position coset of size N (or more generally, a twin-coset), to those over the evaluation domain D, a union of other twin-cosets. Since the dimension of the code is N+1, such an encoder necessarily addresses only a subspace of the entire code, having codimension one. This dimension gap is the most notable difference to both the classical univariate as well as the elliptic curve case. Luckily, it turns out that this tiny gap is "tame" and will lead to only a few changes in the way computations are done, with no significant impact to both soundness and performance.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.3 Vanishing polynomials and quotients</h3>

    <p class="text-gray-300">Let D be a subset of  <span class="math">C(\\mathbb{F}_p)</span>  of even size N, where  <span class="math">2 \\leq N &lt; p+1</span> . We call any non-zero<sup>4</sup>polynomial from  <span class="math">\\mathcal{L}_N = \\mathcal{L}_N(\\mathbb{F}_p)</span> , which evaluates to zero over D a vanishing polynomial of the set D. Decomposing D into pairs of points  <span class="math">\\{P_k, Q_k\\}</span> ,  <span class="math">1 \\leq k \\leq N/2</span> , and taking the product of linear functions going through these pairs,</p>

    <div class="my-4 text-center"><span class="math-block">v_D(x,y) = \\prod_{k=1}^{N/2} ((x - P_{k,x}) \\cdot (Q_{k,y} - P_{k,y}) - (y - P_{k,y}) \\cdot (Q_{k,x} - P_{k,x})),</span></div>

    <p class="text-gray-300">shows that vanishing polynomials do exist. With respect to the degree bound of  <span class="math">\\mathcal{L}_N</span> , vanishing polynomials are essentially unique, as shown by the following lemma.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-10-2"></span><strong>Lemma 4.</strong> Let D be a subset of  <span class="math">C(\\mathbb{F}_p)</span>  of even size N, where  <span class="math">2 \\leq N &lt; p+1</span> , and let  <span class="math">\\mathcal{L}_N = \\mathcal{L}_N(\\mathbb{F}_p)</span> . Then the set of polynomials from  <span class="math">\\mathcal{L}_N</span> , which vanish over D,  $\\mathcal{V}(D) = \\{v \\in \\mathcal{L}_N : v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_D = 0\\}<span class="math"> , is a one-dimensional subspace of  </span>\\mathcal{L}_N<span class="math"> . Every non-zero  </span>v \\in \\mathcal{V}(D)$  takes a non-zero value outside D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> The statements are an immediate consequence of Proposition 2 saying that every non-zero  <span class="math">f \\in \\mathcal{L}_N(\\mathbb{F}_p)</span>  has at most N zeros. Thus any non-zero  <span class="math">v \\in \\mathcal{V}</span>  must be non-zero outside D. Second, if v and v' are non-zero polynomials from  <span class="math">\\mathcal{V}(D)</span> , take a point  <span class="math">P \\in C(\\mathbb{F}_p)</span>  outside D and  <span class="math">\\lambda \\in \\mathbb{F}_p</span>  so that  <span class="math">v&#x27; - \\lambda \\cdot v</span>  vanishes also at P. Again, by the number of zeros  <span class="math">v&#x27; - \\lambda \\cdot v</span>  must be throughout zero over the circle curve.</p>

    <p class="text-gray-300"><strong>Remark 8.</strong> We point out that Lemma 4 does not hold for odd set sizes N, since  <span class="math">\\mathbb{F}_p</span> -rational vanishing polynomials of odd degree do not exist. In the context of single-point quotients as needed in the DEEP algebraic linking step of the STARK, we will work around this issue by moving to the complex extension. See Proposition 4 below.</p>

    <p class="text-gray-300">We are mostly interested in vanishing polynomials of FFT domains, which are standard position cosets, or more generally twin-cosets. Given a twin-coset  <span class="math">D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1}</span> , where  <span class="math">n \\geq 1</span> , we know from Lemma 3 that its image under the power map  <span class="math">\\pi^{n-1}</span>  is a twin-coset of size two, and thus of the form  <span class="math">\\pi^{n-1}(D) = \\{(x_D, \\pm y_D)\\}</span> . We therefore may take</p>

    <p class="text-gray-300"><span id="page-10-3"></span> <span class="math-block">v_D(x,y) := v_n(x,y) - x_D,</span>  (7)</p>

    <p class="text-gray-300">with</p>

    <p class="text-gray-300"><span id="page-10-4"></span> <span class="math-block">v_n(x,y) := \\pi_x \\circ \\pi^{n-1}(x,y),</span>  (8)</p>

    <p class="text-gray-300">where  <span class="math">\\pi_x</span>  is the projection onto the x-axis, as vanishing polynomial of D.</p>

    <p class="text-gray-300">Note that since  <span class="math">\\pi</span>  commutes with J, the x-coordinate of  <span class="math">\\pi^{n-1}(x,y)</span>  does not depend on y, and both  <span class="math">v_n</span>  and  <span class="math">v_D</span>  polynomials are from  <span class="math">\\mathbb{F}_p[x]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">v_n(x,y) = v_n(x) \\in \\mathbb{F}_p[x]^{\\leq N/2},\\tag{9}</span></div>

    <p class="text-gray-300"><span class="math-block">v_D(x,y) = v_D(x) \\in \\mathbb{F}_p[x]^{\\leq N/2},</span>  (10)</p>

    <p class="text-gray-300"><span id="page-10-1"></span><sup>&</sup>lt;sup>4</sup>By non-zero we mean that the polynomial is not contained in  <span class="math">(x^2 + y^2 - 1)</span> .</p>

    <p class="text-gray-300">since their degree is equal to 2 <sup>n</sup>−<sup>1</sup> = N/2. By construction v<sup>D</sup> evaluates to zero over D. We shall call it the vanishing polynomial of D. Notice that whenever D is a standard position coset, its image π n−1 (D) is again a standard position coset and thus x<sup>D</sup> = 0. In this case the vanishing polynomial v<sup>D</sup> is v<sup>n</sup> itself. The vanishing polynomial v<sup>D</sup> can be evaluated succinctly, i.e. by only O(n) field operations: Keeping track of the x-coordinates only, each application of the squaring map costs 1 multiplication and 2 additions. The first few polynomials are</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_1(x) &amp;= x, \\\\ v_2(x) &amp;= 2 \\cdot x^2 - 1, \\\\ v_3(x) &amp;= 2 \\cdot (2 \\cdot x^2 - 1)^2 - 1 = 8 \\cdot x^4 - 8 \\cdot x^2 + 1, \\\\ v_4(x) &amp;= 8 \\cdot (2 \\cdot x^2 - 1)^4 - 8 \\cdot (2 \\cdot x^2 - 1)^2 + 1 = 128 \\cdot x^8 - 256 \\cdot x^6 + 160 \\cdot x^4 - 32 \\cdot x^2 + 1. \\end{aligned}</span></div>

    <p class="text-gray-300">It follows directly from the defining Equation <a href="#page-10-3">\\(7\\)</a> and <a href="#page-10-4">\\(8\\)</a> that the vanishing polynomial of a twin-coset D of size 2 <sup>n</sup> is invariant under both Gn−<sup>1</sup> and the involution J. In the particular case of (standard position) cosets, vanishing polynomials do alternate under the action of Gn.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-11-3"></span>Lemma 5. Let D = Q · G<sup>n</sup> be a standard position coset of Gn, the subgroup of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gn</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2n. Then its vanishing polynomial v<sup>D</sup> = v<sup>n</sup> alternates under the action of Gn, i.e. v<sup>n</sup> ◦ T<sup>P</sup> = −vn, where P is a generator of Gn.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Observe that under π n−1 the subgroup G<sup>n</sup> is mapped onto the two-element subgroup G<sup>1</sup> = {(±1, 0)}, and a generator P of G<sup>n</sup> is mapped onto the generator (−1, 0) of G1. Thus</p>

    <div class="my-4 text-center"><span class="math-block">v_n \\circ T_P = \\pi_x \\circ \\pi^{n-1} \\circ T_P = \\pi_x \\circ T_{(-1,0)} \\circ \\pi^{n-1} = -\\pi_x \\circ \\pi^{n-1} = -v_n,</span></div>

    <p class="text-gray-300">since π<sup>x</sup> changes the sign under rotation by (−1, 0).</p>

    <p class="text-gray-300"><span id="page-11-2"></span>Remark 9. The alternating behaviour naturally extends to vanishing polynomials of arbitrary rotations of standard position cosets.</p>

    <p class="text-gray-300">We eventually show the existence of domain quotient polynomials.</p>

    <p class="text-gray-300"><span id="page-11-1"></span>Proposition 3 (Domain quotients). Let D be a subset of C(Fp) of even size N, where 2 ≤ N < p+ 1. Take F any extension field of Fp, and any even integer M, N ≤ M < p + 1. Then every polynomial f ∈ LM(F) which vanishes over D is of the form f = q · v with q from LM−<sup>N</sup> (F) and v from V(D).</p>

    <p class="text-gray-300">Proof. The property follows from the univariate representation <a href="#page-8-0">\\(4\\)</a> of the function spaces as used in the proof of Proposition <a href="#page-7-6">2.</a> In univariate coordinates, the polynomial v(t) ∈ L<sup>N</sup> (F) is a rational function with simple zeros over D, poles at ±i of order N/2 each, and no other zeros and poles in the algebraic closure K of Fp. Likewise, f has only poles at ±i at order at most M/2 each, and no other poles in K. Altogether, the pole set of the univariate quotient q(t) = <sup>f</sup>(t)/<sup>v</sup>D(t) is contained in ±i, each of order at most M/2 − N/2. This shows that q(t) ∈ LM−<sup>N</sup> (F), and so its bivariate representation is contained in LM−<sup>N</sup> (F).</p>

    <p class="text-gray-300">For the single-point quotients as needed in the context of DEEP algebraic linking, we move over to Fp(i) rational polynomials. (However, we stress the fact that there are alternative and equally efficient approaches, see Remark <a href="#page-24-0">20.</a>) As building block we take the linear function</p>

    <div class="my-4 text-center"><span class="math-block">v(x,y) = 1 - (x + i \\cdot y)</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">v_P(x,y) = v\\left(P_x \\cdot x + P_y \\cdot y, -P_y \\cdot x + P_x \\cdot y\\right) \\tag{11}</span></div>

    <p class="text-gray-300"><span id="page-11-0"></span>for an arbitrary F-rational affine point P = (Px, Py) on the circle curve. (This function has only one zero on the curve over F, a simple zero at P, and only one pole, a simple pole at ∞¯ .)</p>

    <p class="text-gray-300"><strong>Proposition 4</strong> (DEEP quotients). Let F be an extension field of  <span class="math">\\mathbb{F}_p</span> , and take an even N < (p+1). Then for every  <span class="math">f \\in \\mathcal{L}_N(F)</span> , and every F-rational point  <span class="math">P = (P_x, P_y)</span>  on the circle curve, the single-point quotient  <span class="math">q = (f - f(P))/v_P</span> , with  <span class="math">v_P</span>  as defined above, is in  <span class="math">\\mathcal{L}_N(F(i))</span> . Consequently both "real" and "imaginary" parts in the decomposition into F-rational functions</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{f-f(P)}{v_P} = \\operatorname{Re}\\left(\\frac{f-f(P)}{v_P}\\right) + i \\cdot \\operatorname{Im}\\left(\\frac{f-f(P)}{v_P}\\right),</span></div>

    <p class="text-gray-300">where in the case F(i) = F we take  <span class="math">\\operatorname{Re}\\left(\\frac{f - f(P)}{v_P}\\right) := \\frac{f - f(P)}{v_P}</span>  and  <span class="math">\\operatorname{Im}\\left(\\frac{f - f(P)}{v_P}\\right) := 0</span> , are polynomials from  <span class="math">\\mathcal{L}_N(F)</span> .</p>

    <p class="text-gray-300">Proof. The proof goes along the lines of that of Proposition 3, with the difference that by definition the univariate representation  <span class="math">v_P(t) = c \\cdot (t-t_P)/(t+i)</span>  has a simple zero at the univariate parameter  <span class="math">t_P</span>  of P, and a simple pole at -i corresponding to  <span class="math">\\bar{\\infty}</span> . (In the case that P = (-1,0), we have  <span class="math">v_P(t) = c \\cdot 1/(t+i)</span> , which has a simple zero at  <span class="math">t_P = \\infty</span> .) It has no other zeros and poles in the algebraic closure K of  <span class="math">\\mathbb{F}_p</span> . The univariate representation of f has only poles at  <span class="math">\\pm i</span>  of order at most  <span class="math">\\frac{N}{2}</span>  each, and no other poles in K. The quotient  <span class="math">(f(t)-f(t_P))/v_P(t)</span>  has only poles at  <span class="math">\\pm i</span> , each of order at most  <span class="math">\\frac{N}{2}</span> . Thus  <span class="math">(f(t)-f(t_P))/v_P(t)</span>  is the univariate representation of a polynomial q from  <span class="math">\\mathcal{L}_N(F(i))</span> , satisfying that  <span class="math">f-f(P)=q \\cdot v_P</span>  over the circle curve.  <span class="math">\\square</span></p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">4 The circle FFT</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From now on we throughout assume that p is a CFFT-friendly prime supporting the domain size  <span class="math">2^n</span> , where  <span class="math">n \\geq 1</span> , and that  <span class="math">G_n</span>  is the unique proper subgroup of the circle curve  <span class="math">C(\\mathbb{F}_p)</span> , of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= N = 2^n<span class="math"> . Furthermore, F denotes an arbitrary extension field of  </span>\\mathbb{F}_p$ . The <em>circle FFT</em> for a twin-coset</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1},</span></div>

    <p class="text-gray-300">with  <span class="math">Q \\in C(\\mathbb{F}_p) \\setminus G_n</span> , interpolates functions from  <span class="math">F^D</span>  by polynomials from the space  <span class="math">\\mathcal{L}_N(F)</span> , via computing the coefficients with respect to a specific basis, the FFT-basis  <span class="math">\\mathcal{B}_n</span>  of the circle, an N-dimensional basis of polynomials which only depends on the size of the domain.</p>

    <p class="text-gray-300"><span id="page-12-1"></span><strong>Definition 4.</strong> For any integer j from the interval  <span class="math">0 \\le j \\le 2^n - 1</span> , let  <span class="math">(j_0, \\ldots, j_{n-1}) \\in \\{0, 1\\}^n</span>  denote its bit representation, satisfying  <span class="math">j = j_0 + j_1 \\cdot 2 + \\ldots + j_{n-1} \\cdot 2^{n-1}</span> . The <em>FFT-basis of order</em> n is the family  <span class="math">\\mathcal{B}_n</span>  of polynomials</p>

    <div class="my-4 text-center"><span class="math-block">b_j^{(n)}(x,y) := y^{j_0} \\cdot v_1(x)^{j_1} \\cdot \\dots \\cdot v_{n-1}^{j_{n-1}}(x), \\quad 0 \\le j \\le 2^n - 1,</span></div>

    <p class="text-gray-300">where  <span class="math">v_k(x)</span> ,  <span class="math">1 \\le k \\le n-1</span> , is the vanishing polynomial of the standard position coset of size  <span class="math">2^k</span>  defined in Section 3.3. (In cases where n is obvious from the context, we shall omit the superscript.)</p>

    <p class="text-gray-300">Since  <span class="math">\\deg v_k(x) = 2^{k-1}</span>  the total degree of the polynomials from  <span class="math">\\mathcal{B}_n</span>  is bounded by  <span class="math">\\leq 2^{n-1}</span> , and thus in fact  <span class="math">\\mathcal{B}_n \\subseteq \\mathcal{L}_N(F)</span> . That they are linearly independent will be a consequence of the FFT itself. (See Corollary 2.)</p>

    <p class="text-gray-300">Let us gather the main result in a single statement.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem</strong> (Summary of Theorem 2 and 3). Let p be a CFFT-friendly prime supporting the order  <span class="math">n \\geq 1</span> , and F be a finite extension field of  <span class="math">\\mathbb{F}_p</span> . Take D, a twin-coset of the cyclic subgroup  <span class="math">G_{n-1}</span>  of the circle curve over  <span class="math">\\mathbb{F}_p</span> , of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^n<span class="math"> . There exists an algorithm, which given a function from  </span>F^D<span class="math">  computes the coefficients with respect to the basis  </span>\\mathcal{B}_n<span class="math"> , consumes  </span>N \\cdot n<span class="math">  additions over F and  </span>N \\cdot \\frac{n}{2}<span class="math">  multiplications with precomputed elements of  </span>\\mathbb{F}_p<span class="math"> . Its inverse, which given the coefficients with respect to  </span>\\mathcal{B}_n$  computes the values over D, or any other twin-coset of the same size, has the same computational cost.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similar to the ECFFT, the circle FFT is an non-harmonic FFT, although the group structure of the domain place a central role. Its construction is inherently related to two group endomorphisms of the circle curve, the group squaring map  <span class="math">\\pi</span>  and the inversion map J. The need for two endomorphisms, one of quadratic degree and another one which is linear, is intertwined with the goal of obtaining interpolants from a space of low-degree functions (in algebraic geometry terms, a  <span class="math">G_n</span> -invariant Riemann-Roch space) the dimension of which fits as tight as possible the size of the domain. Whereas in the elliptic curve case this fit is met perfectly, the circle FFT faces a tiny dimension gap between the image of the FFT and the full space of polynomials of given degree bound. By Proposition 2</p>

    <div class="my-4 text-center"><span class="math-block">\\dim \\mathcal{L}_N(F) = N + 1,</span></div>

    <p class="text-gray-300">and  <span class="math">\\mathcal{L}&#x27;_N(F) = \\langle \\mathcal{B}_n \\rangle</span>  the image space of the transform, has</p>

    <div class="my-4 text-center"><span class="math-block">\\dim \\mathcal{L}&#x27;_N(F) = \\dim \\langle \\mathcal{B}_n \\rangle = N,</span></div>

    <p class="text-gray-300">and thus is a subspace of  <span class="math">\\mathcal{L}_N(F)</span>  of co-dimension one. We devote an extra Section 4.3 for investigating this gap. The findings in that section will provide the necessary tools for treating it in a circle STARK.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4.1 The sequence of domains</h3>

    <p class="text-gray-300">Although everything in this section applies in full generality to twin-coset domains, we recommend to think of it as standard position cosets during a first read.</p>

    <p class="text-gray-300">By definition, a twin-coset  <span class="math">D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1}</span>  is invariant under the involution J, and moreover each J-orbit in D has exactly two points. Thus the quotient map</p>

    <div class="my-4 text-center"><span class="math-block">\\phi_J: D \\to D/J, \\quad P \\mapsto \\{P, J(P)\\},\\</span></div>

    <p class="text-gray-300">is 2-to-1. By Lemma 3, with  <span class="math">D_n=D</span>  being a twin-coset of size  <span class="math">2^n</span> , the recursively obtained images  <span class="math">D_j=\\pi(D_{j+1})</span> , for j=n-1 down to 1, are twin-cosets with respect to the decreasing chain of subgroups</p>

    <div class="my-4 text-center"><span class="math-block">G_{n-1}\\supset G_{n-2}\\supset\\ldots\\supset G_0.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That is, each  <span class="math">D_j</span>  is of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^j<span class="math">  and a twin-coset of the subgroup  </span>G_{j-1}<span class="math"> . Since J and  </span>\\pi$  commute, we obtain the following commutative diagram, in which each of the maps is 2-to-1 and onto, and thus halves the set sizes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">D_{n} \\xrightarrow{\\pi} D_{n-1} \\xrightarrow{\\pi} D_{n-2} \\xrightarrow{\\pi} \\cdots \\xrightarrow{\\pi} D_{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\downarrow^{\\phi_{J}} \\qquad \\qquad \\downarrow^{\\phi_{J}} \\qquad \\qquad \\downarrow^{\\phi_{J}} \\qquad \\qquad \\downarrow^{\\phi_{J}}</span></div>

    <div class="my-4 text-center"><span class="math-block">D_{n}/J \\xrightarrow{\\pi} D_{n-1}/J \\xrightarrow{\\pi} D_{n-2}/J \\xrightarrow{\\pi} \\cdots \\xrightarrow{\\pi} D_{1}/J</span></div>

    <div class="my-4 text-center"><span class="math-block">(12)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The final twin-coset  <span class="math">D_1</span>  consists of exactly two points (it is a twin-coset of the trivial subgroup  <span class="math">G_0</span> ), forming a single J-orbit, and thus  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D_1/\\phi_J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the involution J has orbits of the form  <span class="math">\\{(x, \\pm y)\\}</span> , and thus we may regard the quotients  <span class="math">S_j = D_j/J</span>  as subsets of the x-axis, and  <span class="math">\\phi_J = \\pi_x</span>  as the projection onto it, as illustrated by the following diagram.</p>

    <p class="text-gray-300"><span id="page-13-1"></span> <span class="math-block">C(\\mathbb{F}_p) \\subseteq \\mathbb{F}_p^2 \\qquad D_n \\xrightarrow{\\pi} D_{n-1} \\xrightarrow{\\pi} D_{n-2} \\xrightarrow{\\pi} \\cdots \\xrightarrow{\\pi} D_1</span></p>

    <div class="my-4 text-center"><span class="math-block">\\downarrow^{\\phi_J = \\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x}</span></div>

    <div class="my-4 text-center"><span class="math-block">C(\\mathbb{F}_p)/J \\subseteq \\mathbb{F}_p \\qquad S_n \\xrightarrow{\\pi} S_{n-1} \\xrightarrow{\\pi} S_{n-2} \\xrightarrow{\\pi} \\cdots \\xrightarrow{\\pi} S_1</span></div>

    <div class="my-4 text-center"><span class="math-block">(13)</span></div>

    <p class="text-gray-300">In this diagram, the squaring endomorphism  <span class="math">\\pi: S_j \\longrightarrow S_{j-1}</span>  is the 2-to-1 map  <span class="math">x \\mapsto 2 \\cdot x^2 - 1</span> . This univariate view on the quotients  <span class="math">D_j/J</span>  will be particularly convenient in the description of the circle FFT.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">4.2 The circle FFT and its inverse</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a twin-coset D of a subgroup  <span class="math">G_{n-1}</span> , of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^n<span class="math"> , the FFT is a divide-and-conquer algorithm which recursively reduces the interpolation problem for  </span>f \\in F^D$  along the chain of projections</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">D = D_n \\stackrel{\\phi_J = \\pi_x}{\\longrightarrow} S_n \\stackrel{\\pi}{\\longrightarrow} S_{n-1} \\stackrel{\\pi}{\\longrightarrow} \\dots \\stackrel{\\pi}{\\longrightarrow} S_1,</span></div>

    <p class="text-gray-300">as in (13), considering  <span class="math">S_j = D_j/J</span>  as subsets of the x-axis,  <span class="math">1 \\le j \\le n</span> .</p>

    <p class="text-gray-300">In the first step, we decompose the given function f over  <span class="math">D_n</span>  into "even" and "odd" part with respect to the involution J, using</p>

    <p class="text-gray-300"><span id="page-14-3"></span><span id="page-14-2"></span> <span class="math-block">t_0(x,y) = y</span></p>

    <p class="text-gray-300">as our "reference odd function". (This terminology is justified by  <span class="math">t_0 \\circ J = -t_0</span> .) Concretely, we split  <span class="math">f \\in F^{D_n}</span>  into the unique functions  <span class="math">f_0, f_1 \\in F^{S_n}</span>  over the univariate domain  <span class="math">S_n</span> , defined by</p>

    <div class="my-4 text-center"><span class="math-block">f_0(x) = \\frac{f(x,y) + f(x,-y)}{2},\\tag{14}</span></div>

    <div class="my-4 text-center"><span class="math-block">f_1(x) = \\frac{f(x,y) - f(x,-y)}{2 \\cdot y},\\tag{15}</span></div>

    <p class="text-gray-300">and satisfying</p>

    <p class="text-gray-300"><span id="page-14-7"></span> <span class="math-block">f(x,y) = f_0(x) + y \\cdot f_1(x). \\tag{16}</span></p>

    <p class="text-gray-300">(Note that the right hand sides of (14) and (15) do not depend on which of the two preimages of x are taken.) We then proceed with  <span class="math">f_0</span>  and  <span class="math">f_1</span>  separately and as follows.</p>

    <p class="text-gray-300">In the other steps, we receive a function  <span class="math">f_{k_0,...,k_{n-j}} \\in F^{S_j}</span>  from a previous step, where  <span class="math">2 \\leq j \\leq n</span> . We choose</p>

    <p class="text-gray-300"><span id="page-14-5"></span><span id="page-14-4"></span> <span class="math-block">t_1(x,y) = x</span></p>

    <p class="text-gray-300">as the "reference odd function" (in the sense that it is odd along the fibres of  <span class="math">\\pi</span> , which are parametrized by action of T(x) = -x). Overriding notation and writing again f for  <span class="math">f_{k_0,...,k_{n-j}}</span> , we split it into  <span class="math">f_0 = f_{k_0,...,k_{n-j},0}</span>  and  <span class="math">f_1 = f_{k_0,...,k_{n-j},1}</span>  from  <span class="math">F^{S_{j-1}}</span>  over the projected domain  <span class="math">S_{j-1} = \\pi(S_j)</span> , defined by</p>

    <div class="my-4 text-center"><span class="math-block">f_0(\\pi(x)) = \\frac{f(x) + f(-x)}{2},\\tag{17}</span></div>

    <div class="my-4 text-center"><span class="math-block">f_1(\\pi(x)) = \\frac{f(x) - f(-x)}{2 \\cdot x},\\tag{18}</span></div>

    <p class="text-gray-300">and hence</p>

    <p class="text-gray-300"><span id="page-14-6"></span> <span class="math-block">f(x) = f_0(\\pi(x)) + x \\cdot f_1(\\pi(x)), \\tag{19}</span></p>

    <p class="text-gray-300">where  <span class="math">\\pi(x) = 2 \\cdot x^2 - 1</span> . (The right hand sides (17) and (18) are independent on the choice  <span class="math">\\pm x</span>  from the same preimage, thus  <span class="math">f_0</span>  and  <span class="math">f_1</span>  are well-defined.) These two functions  <span class="math">f_0 = f_{k_0,\\dots,k_{n-j},0}</span> ,  <span class="math">f_1 = f_{k_0,\\dots,k_{n-j},1}</span>  are then processed separately and in the same manner, until one ends up with constant functions</p>

    <div class="my-4 text-center"><span class="math-block">f_{k_0,...,k_{n-1}} \\in F^{S_1}</span></div>

    <p class="text-gray-300">over the single-point domain  <span class="math">S_1</span> . The output of the algorithm are the constants  <span class="math">c_k = f_{k_0,\\dots,k_{n-1}} \\in F</span> , for each k in the interval  <span class="math">0 \\le k \\le 2^n - 1</span> , where  <span class="math">(k_0,\\dots,k_{n-1}) \\in \\{0,1\\}^n</span>  are the bits of  <span class="math">k = k_0 + k_1 \\cdot 2 + \\dots + k_{n-1} \\cdot 2^{n-1}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-14-1"></span><strong>Theorem 2</strong> (Circle FFT). Let p be a CFFT-friendly prime supporting the order  <span class="math">n \\ge 1</span> , take  <span class="math">D \\subset C(\\mathbb{F}_p)</span>  a twin-coset of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^n<span class="math"> . Given  </span>f \\in F^D<span class="math">  a function over D with values in an extension field F of  </span>\\mathbb{F}_p<span class="math"> , the above described algorithm outputs the coefficients  </span>c_k \\in F<span class="math"> ,  </span>0 \\le k \\le 2^n - 1<span class="math"> , with respect to the FFT basis from Definition 4, so that  </span>\\sum_{k=0}^{2^n-1} c_k \\cdot b_k$  evaluates to f over D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> We first show, by induction on  <span class="math">1 \\leq j \\leq n</span> , that for every function over  <span class="math">S_j = D_j/J</span> , the algorithm outputs its coefficients with respect to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{B}_j^{(0)} = \\left\\{ b_{2 \\cdot k}^{(j)} : 0 \\le k \\le 2^{j-1} - 1 \\right\\},</span></div>

    <p class="text-gray-300">that are those polynomials from  <span class="math">\\mathcal{B}_j</span> , which only depend on x. For j=1, the quotient  <span class="math">S_1</span>  consists of a single point and the claim is trivial. Assume that the claim holds for some  <span class="math">j \\geq 1</span> , and let f be a function over  <span class="math">S_{j+1}</span> , and decompose it into  <span class="math">f_0</span> ,  <span class="math">f_1 \\in F^{S_j}</span>  defined by (17) and (18) such that (19) holds. By the induction hypothesis the algorithm outputs their coefficients with respect to the basis  <span class="math">\\mathcal{B}_j^{(0)}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">f_i = \\sum_{k=0}^{2^{j-1}-1} c_k^{(i)} \\cdot b_{2 \\cdot k}^{(j)},</span></div>

    <p class="text-gray-300">over  <span class="math">S_i</span> , for both i = 0, 1. Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">f(x) = \\sum_{k=0}^{2^{j-1}-1} c_k^{(0)} \\cdot b_{2 \\cdot k}^{(j)}(\\pi(x)) + c_k^{(1)} \\cdot x \\cdot b_{2 \\cdot k}^{(j)}(\\pi(x)) = \\sum_{k&#x27;=0}^{2^{j}-1} c_{k&#x27;} \\cdot b_{2 \\cdot k&#x27;}^{(j+1)}(x),</span></div>

    <p class="text-gray-300">with  <span class="math">c_{k&#x27;} = c_{i+2 \\cdot k} = c_k^{(i)}</span> , since by the definition of the vanishing polynomials, we have that  <span class="math">x^i \\cdot b_{2k}^{(j)}(\\pi(x)) = b_{2 \\cdot (i+2 \\cdot k)}^{(j+1)}</span>  for  <span class="math">i \\in \\{0,1\\}</span>  and  <span class="math">0 \\le k \\le 2^{j-1} - 1</span> .</p>

    <p class="text-gray-300">The final step, corresponding to the projection from  <span class="math">D_n</span>  to  <span class="math">S_n = D_n/J</span> , is proven in the same manner, using the even-odd decomposition into (14) and (15) satisfying (16). We leave the details to the reader.  <span class="math">\\square</span></p>

    <p class="text-gray-300"><span id="page-15-1"></span><strong>Remark 10.</strong> In practice one omits the factor 2 in the denominator of odd and even parts, both with respect to J and T. This scaled FFT yields the coefficients with respect to the scaled basis  <span class="math">\\frac{1}{2^n} \\cdot b_k</span> ,  <span class="math">0 \\le k &lt; 2^n</span> . It consumes  <span class="math">n \\cdot 2^{n-1}</span>  multiplications of elements from F with precomputed elements from the base field  <span class="math">\\mathbb{F}_p</span> , and  <span class="math">n \\cdot 2^n</span>  additions of elements from F.</p>

    <p class="text-gray-300">The inverse FFT is obtained along the lines of the proof of Theorem 2. At the "bottom level" of the recursion, one starts with given coefficients  <span class="math">c_k = c_{k_0,\\dots,k_{n-1}} \\in F</span> , where  <span class="math">(k_0,\\dots,k_{n-1}) \\in \\{0,1\\}^n</span>  are the bits of k, all regarded as constant functions  <span class="math">f_{k_0,\\dots,k_{n-1}}</span>  over the single-point domain  <span class="math">S_1</span> , and recursively combines their values into the ones over the domain of double the size using Equation (19) Leveraging anti-symmetry of the odd parts along the fibers of the projection, each level of the tree consumes in total  <span class="math">2^n</span>  additions, but only the half number of multiplications. We leave the details to the reader, and only cite the following theorem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-15-0"></span><strong>Theorem 3</strong> (inverse circle FFT). Let p be a CFFT-friendly prime supporting the domain size  <span class="math">N=2^n</span> ,  <span class="math">n \\geq 1</span> , and take D a twin-coset of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N. Given  <span class="math">(c_k) \\in F^N</span>  a coefficient vector with values in an extension field F of  <span class="math">\\mathbb{F}_p</span> , the inverse transform as sketched above computes the values of  <span class="math">f=\\sum_{k=0}^{2^n-1}c_k \\cdot b_k</span>  over the domain D.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 11.</strong> The cost of the inverse FFT is the same as for the scaled FFT described in Remark 10: It consumes  <span class="math">n \\cdot 2^{n-1}</span>  multiplications of elements from F with (precomputed) elements from  <span class="math">\\mathbb{F}_p</span> , and  <span class="math">n \\cdot 2^n</span>  additions of elements from F.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-15-2"></span>Remark 12. The inverse FFT can be generalized to  <span class="math">D = G_n</span> , the exceptional set of size N which is invariant under J and  <span class="math">G_{n-1}</span>  but not a twin-coset. The only difference is that  <span class="math">\\phi_J</span>  is only almost 2-to-1, leading to quotients of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_k/J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2} + 1$  being one point larger than in the ordinary FFT. However, these slightly larger domains do not cause any additional computational cost, as there is always one point of the domain at which the twiddle is zero, and thus combining odd and even parts is for free. In terms of field operations, this variant is as efficient as the ordinary FFT.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As the Cooley-Tukey FFT, both the circle FFT and its inverse can be implemented as a butterfly network, with a similar layout as in a classical FFT. An explicit description is given in Appendix D.</p>

    <p class="text-gray-300">Let us discuss an immediate consquence of Theorem 2.</p>

    <p class="text-gray-300"><span id="page-16-0"></span>Corollary 2 (FFT basis). Under the assumption of Theorem 2, the polynomials from  <span class="math">\\mathcal{B}_n</span>  (Definition 4) form the basis of an N-dimensional subspace  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  of  <span class="math">\\mathcal{L}_N(F)</span> , where  <span class="math">N=2^n</span> .</p>

    <p class="text-gray-300">Proof. We have already seen that total degree of each  <span class="math">b_k(x,y) = y^{k_0} \\cdot v_1(x)^{k_1} \\cdot \\dots \\cdot v_{n-1}(x)^{k_{n-1}}</span> ,  <span class="math">0 \\le k \\le 2^n - 1</span> , is bounded by  <span class="math">2^{n-1}</span> . By Theorem 2 their values over D form a basis of  <span class="math">F^D</span> , where D is a twin-coset of size  <span class="math">2^n</span> , proving that their span is at least N-dimensional. Since there are only N such polynomials, the dimension is thus equal to N.</p>

    <p class="text-gray-300">We call the image space  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  spanned by the basis  <span class="math">\\mathcal{B}_n</span>  the <em>FFT-space</em> of order n, or of dimension  <span class="math">N=2^n</span> . Its description with respect to the standard monomial basis is as follows.</p>

    <p class="text-gray-300"><span id="page-16-1"></span><strong>Lemma 6.</strong> Let p be a CFFT-friendly prime supporting the domain size  <span class="math">N = 2^n</span> ,  <span class="math">n \\ge 1</span> , and F be a finite extension field of  <span class="math">\\mathbb{F}_p</span> . Then</p>

    <p class="text-gray-300"><span class="math-block">\\mathcal{L}&#x27;_{N}(F) = \\left\\{ p_{0}(x) + y \\cdot p_{1}(x) : p_{i}(x) \\in F[x], \\deg p_{i}(x) \\le \\frac{N}{2} - 1, \\ i = 0, 1 \\right\\}.</span>  (20)</p>

    <p class="text-gray-300">Proof. By the definition of  <span class="math">b_k</span> , each function from  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is of the claimed form  <span class="math">p_0(x) + y \\cdot p_1(x)</span>  with  <span class="math">\\deg p_i \\leq \\frac{N}{2} - 1</span> . In particular,  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is contained in the span of the N monomials  <span class="math">1, x, \\ldots, x^{\\frac{N}{2}-1}</span>  and  <span class="math">y, y \\cdot x, \\ldots, y \\cdot x^{\\frac{N}{2}-1}</span> . Since  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is N-dimensional, the span of the monomials cannot be larger than  <span class="math">\\mathcal{L}&#x27;_N(F)</span> , proving the claim of the lemma.</p>

    <p class="text-gray-300">Recall that dim  <span class="math">\\mathcal{L}_N(F) = N+1</span>  and thus the FFT space  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is a subspace of  <span class="math">\\mathcal{L}_N(F)</span>  with co-dimension one. In terms of the monomial basis,  <span class="math">\\mathcal{L}_N(F)</span>  misses the highest order monomial in x, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_N(F) = \\mathcal{L}&#x27;_N(F) + \\langle x^{N/2} \\rangle.</span></div>

    <p class="text-gray-300">Since vanishing polynomial  <span class="math">v_n(x)</span>  is of degree  <span class="math">\\deg v_n(x) = N/2</span> , we may also decompose the full space of polynomials as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_N(F) = \\mathcal{L}&#x27;_N(F) + \\langle v_n \\rangle,</span></div>

    <p class="text-gray-300">which turns out the more useful view for our purposes. See Section 4.3 for details on this decomposition.</p>

    <p class="text-gray-300"><strong>Remark 13.</strong> In univariate coordinates the involution is expressed as J(t) = -t, the doubling map is  <span class="math">\\pi(t) = \\frac{2 \\cdot t}{1 - t^2}</span> , and the generator T of its kernel group (i.e. the translation by (-1,0)) is  <span class="math">T(t) = -\\frac{1}{t}</span> . Twincosets are carried over to twin-cosets with respect to group law of the projective line (cf. Remark 4), invariant under J and without fixed points. The FFT basis with respect to such a coset D of size  <span class="math">N = 2^n</span>  is now composed from the twiddles</p>

    <p class="text-gray-300"><span class="math-block">t_0 = \\frac{2 \\cdot t}{1 + t^2}</span>  and  <span class="math">t_1 = \\frac{1 - t^2}{1 + t^2}</span> ,</p>

    <p class="text-gray-300">yielding a basis of an N-dimensional subspace  <span class="math">L&#x27;_N(F)</span>  of the univariate Riemann-Roch space  <span class="math">L_N(F) = F[t]^{\\leq N}/(1+t^2)^{N/2}</span> .</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">4.3 Properties of the FFT space</h4>

    <p class="text-gray-300">As before, p is a CFFT-friendly prime supporting the order  <span class="math">n \\ge 1</span> , and  <span class="math">N = 2^n</span> . In this section we shall investigate the decomposition</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_N(F) = \\mathcal{L}&#x27;_N(F) + \\langle v_n \\rangle,</span></div>

    <p class="text-gray-300">and provide a characterization of  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  in terms of its behaviour at infinity which will be useful for the analysis of the various quotients involved in the IOP of the circle STARK.</p>

    <p class="text-gray-300">The most remarkable property is that, although the circle FFT is a non-harmonic transform, the FFT space is invariant under rotation.</p>

    <p class="text-gray-300"><span id="page-17-1"></span><strong>Proposition 5.</strong> The FFT space  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is invariant under the action of  <span class="math">G_n</span> , the cyclic subgroup of order  <span class="math">N=2^n</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that by Lemma 6,  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  is the span of the monomials  <span class="math">1, x, \\ldots, x^{N/2-1}</span>  and  <span class="math">y, y \\cdot x, \\ldots, y \\cdot x^{N/2-1}</span> . Consider following vanishing polynomial of  <span class="math">G = G_n</span>  the cyclic subgroup of order  <span class="math">2^n</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">v_G(x,y) = y \\cdot \\prod_{i=1}^{\\frac{N}{2}-1} (x - x_k),</span></div>

    <p class="text-gray-300">where  <span class="math">x_k</span>  runs through the x-coordinates of half of the powers  <span class="math">P^k</span>  of a generator P of  <span class="math">G_n</span> , except the two outermost ones on the x-axis. By the degree in x, the polynomial  <span class="math">v_G</span>  belongs to  <span class="math">\\mathcal{L}&#x27;_N(F)</span> , and its only term of maximum degree, belonging to  <span class="math">y \\cdot x^{\\frac{N}{2}-1}</span> , is non-zero. Hence  <span class="math">v_G</span>  is linearly independent from the monomials of lower total degree, altogether forming a basis of  <span class="math">\\mathcal{L}&#x27;_N(F)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}&#x27;_N(F) = \\langle x^k \\cdot y^j : \\deg(x^k \\cdot y^j) &lt; N/2 \\rangle + \\langle v_G \\rangle.</span></div>

    <p class="text-gray-300">By degree, a rotation of a monomial of degree < N/2 is again of degree < N/2, and by Remark 9,  <span class="math">v \\circ T_P</span>  is a scalar multiple of v. This proves the claim of the lemma.</p>

    <p class="text-gray-300">Proposition 5 together with Lemma 5 shows that  <span class="math">\\mathcal{L}_N(F) = \\mathcal{L}&#x27;_N(F) + \\langle v_n \\rangle</span>  is a decomposition into  <span class="math">G_n</span> -invariant subspaces (which moreover are J-invariant). The following orthogonality result will be useful for determining the decomposition of polynomials from  <span class="math">\\mathcal{L}_N(F)</span> .</p>

    <p class="text-gray-300"><span id="page-17-2"></span><strong>Lemma 7.</strong> Over every  <span class="math">G_n</span> -invariant and J-invariant domain  <span class="math">D \\subseteq C(\\mathbb{F}_p)</span> , the vanishing polynomial  <span class="math">v_n</span>  is orthogonal to the FFT space  <span class="math">\\mathcal{L}&#x27;_N(F)</span> , i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\langle v_n, f \\rangle_D = 0,</span></div>

    <p class="text-gray-300">for every f from  <span class="math">\\mathcal{L}&#x27;_{N}(F)</span> , where the inner product is taken over D.</p>

    <p class="text-gray-300"><em>Proof.</em> We keep track of the inner product  <span class="math">\\langle v_n, f \\rangle_D</span>  while repeatedly decomposing f into even and odd parts as in the FFT. In the first step, we write  <span class="math">f = f_0(x) + y \\cdot f_1(x)</span> , where  <span class="math">f_0</span> ,  <span class="math">f_1</span>  are polynomials of degree  <span class="math">\\leq N/2 - 1</span> . By the discussion preceding Lemma 5 the vanishing polynomial  <span class="math">v_n</span>  is invariant under the involution J, thus</p>

    <div class="my-4 text-center"><span class="math-block">\\langle v_n, f_0(x) + y \\cdot f_1(x) \\rangle_D = \\langle v_n, f_0(x) \\rangle_D,</span></div>

    <p class="text-gray-300">as the product  <span class="math">y \\cdot f_1(x) \\cdot v_n(x)</span>  alternates under J, and hence its sum over D vanishes. (Note that this holds also if D includes fixed points of J, since there y = 0.)</p>

    <p class="text-gray-300">In the next step we decompose  <span class="math">f_0 = (f_{0,0} \\circ \\pi) + x \\cdot (f_{0,1} \\circ \\pi)</span>  with  <span class="math">f_{0,0}</span> ,  <span class="math">f_{0,1}</span>  being polynomials of degree  <span class="math">\\leq N/4 - 1</span> . If  <span class="math">n \\geq 2</span> , then  <span class="math">v_n = v_{n-1} \\circ \\pi</span> , and thus</p>

    <div class="my-4 text-center"><span class="math-block">\\langle v_n, (f_{0,0} \\circ \\pi) + x \\cdot (f_{0,1} \\circ \\pi) \\rangle_D = \\langle v_{n-1} \\circ \\pi, (f_{0,0} \\circ \\pi) \\rangle_D,</span></div>

    <p class="text-gray-300">since  <span class="math">x \\cdot (f_{0,1} \\circ \\pi) \\cdot (v_{n-1} \\circ \\pi)</span>  alternates under the action of  <span class="math">T = T_{(-1,0)}</span>  and thus its sum over D is zero. The latter inner product can be written as one over the projected domain  <span class="math">\\pi(D)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle v_{n-1} \\circ \\pi, f_{0,0} \\circ \\pi \\rangle_D = 2 \\cdot \\langle v_{n-1}, f_{0,0} \\rangle_{\\pi(D)},</span></div>

    <p class="text-gray-300">thereby reducing the orthogonality claim to that of  <span class="math">v_{n-1}</span>  with the polynomial  <span class="math">f_{0,0}</span>  of degree  <span class="math">\\leq N/4-1</span> , over the  <span class="math">G_{n-1}</span> -invariant domain  <span class="math">\\pi(D)</span> .</p>

    <p class="text-gray-300">Continuing in this manner, we eventually end up with an inner product of the vanishing polynomial  <span class="math">v_1</span>  with the constant function  <span class="math">f_{0,\\dots,0}</span> , taken over the  <span class="math">G_1</span> -invariant set  <span class="math">\\pi^{n-1}(D)</span> . As  <span class="math">v_1</span>  alternates under  <span class="math">G_1</span> , that inner product must be zero, proving the claim of the Lemma.</p>

    <p class="text-gray-300">Let us investigate the behaviour of polynomials from  <span class="math">\\mathcal{L}_N(F)</span>  at infinity. For that we consider the limits of their quotients with the monomial  <span class="math">x^{N/2}</span>  at the two  <span class="math">\\mathbb{F}_p(i)</span> -rational points at infinity, i.e.  <span class="math">\\infty = (1:+i:0)</span>  and  <span class="math">\\bar{\\infty} = (1:-i:0)</span> . However, in order to avoid explicitly referring to these projective points, we use the following formula as definition for these limits. Given a polynomial f in  <span class="math">\\mathcal{L}_N(F)</span> , we set</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{f}{r^{N/2}}(\\infty) := f^{(N/2)}(1, i), \\tag{21}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{f}{r^{N/2}}(\\bar{\\infty}) := f^{(N/2)}(1, -i), \\tag{22}</span></div>

    <p class="text-gray-300">where  <span class="math">f^{(N/2)}</span>  is the homogeneous part of degree N/2. These limits pick out the coefficients of the two terms of degree N/2, and combines their coefficients by taking (x,y) = (1,i) and (x,y) = (1,-i), respectively. Their value is in F(i), which depending on F might be an extension, or not.</p>

    <p class="text-gray-300"><span id="page-18-1"></span><strong>Lemma 8.</strong> Take  <span class="math">f \\in \\mathcal{L}&#x27;_N(F)</span> , and let  <span class="math">c_{N-1} \\in F</span>  be its coefficient with respect to the highest-order basis function  <span class="math">b_{N-1}</span>  of the FFT basis. Then</p>

    <p class="text-gray-300"><span id="page-18-0"></span> <span class="math-block">\\frac{f}{x^{N/2}}(\\bar{\\infty}) = -\\frac{f}{x^{N/2}}(\\infty) = -i \\cdot \\frac{2^{\\frac{N}{2}}}{N} \\cdot c_{N-1}.</span>  (23)</p>

    <p class="text-gray-300">On the other hand, the vanishing polynomial  <span class="math">v_n</span>  of the standard position coset of size  <span class="math">N=2^n</span> , satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{v_n}{x^{N/2}}(\\bar{\\infty}) = +\\frac{v_n}{x^{N/2}}(\\infty) = 2^{\\frac{N}{2}-1},\\tag{24}</span></div>

    <p class="text-gray-300">and the same limits hold for the vanishing polynomial of a twin-coset of size N.</p>

    <p class="text-gray-300"><em>Proof.</em> The coefficient  <span class="math">c = c_{N-1}</span>  of a polynomial  <span class="math">f \\in \\mathcal{L}&#x27;_N(F)</span>  belongs to the basis function  <span class="math">b_{N-1}(x,y) = y \\cdot v_1(x) \\cdot v_2(x) \\cdot \\ldots \\cdot v_{n-1}(x)</span> , which is the only basis function with a term of total degree equal to N/2. Concretely,</p>

    <div class="my-4 text-center"><span class="math-block">b_{N-1}(x,y) = y \\cdot \\left(\\frac{2^{N/2}}{N} \\cdot x^{\\frac{N}{2}-1} + p(x)\\right),</span></div>

    <p class="text-gray-300">where p(x) is a polynomial of degree < N/2 - 1. Evaluating the quotient with  <span class="math">x^{N/2}</span>  at  <span class="math">\\infty = (1:i:0)</span>  and  <span class="math">\\bar{\\infty} = (1:-i:0)</span>  yields Equation (23). The limits of the vanishing polynomial are proven similarly, using that</p>

    <div class="my-4 text-center"><span class="math-block">v_n(x) = 2^{\\frac{N}{2}-1} \\cdot x^{\\frac{N}{2}} + p(x),</span></div>

    <p class="text-gray-300"><span id="page-18-2"></span>for some polynomial p(x) of degree  <span class="math">\\deg p(x) \\leq N/2 - 1</span> .</p>

    <p class="text-gray-300"><strong>Remark 14.</strong> As circle STARKs typically use transitional constraints, the explicit limit of a function under rotation is useful. For arbitrary g from the full space of polynomials  <span class="math">\\mathcal{L}_N(F)</span> , and  <span class="math">P = (P_x, P_y) \\in C(\\mathbb{F}_p)</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{g \\circ T_P}{x^{N/2}}(\\infty) = (P_x + i \\cdot P_y)^{-N/2} \\cdot \\frac{g}{x^{N/2}}(\\infty), \\tag{25}</span></div>

    <p class="text-gray-300">and likewise at  <span class="math">\\bar{\\infty}</span> , with <em>i</em> replaced by -i. These limits are a consequence of that  <span class="math">\\infty</span>  and  <span class="math">\\bar{\\infty}</span>  are fixed points under  <span class="math">T_P</span> , and the monomial  <span class="math">h(x,y) = x^{N/2}</span>  satisfies that</p>

    <p class="text-gray-300"><span id="page-19-2"></span> <span class="math-block">\\frac{h}{h \\circ T_P^{-1}} = \\frac{x^{N/2}}{(P_x \\cdot x + P_y \\cdot y)^{N/2}},</span></p>

    <p class="text-gray-300">which evaluates to  <span class="math">(P_x + i \\cdot P_y)^{-N/2}</span>  at  <span class="math">\\infty</span> , and to the conjugate expression at  <span class="math">\\bar{\\infty}</span> . In particular if P is a generator of  <span class="math">G_n</span>  the cyclic subgroup of order N, then  <span class="math">(P_x + i \\cdot P_y)^{-N/2} = -1</span> , which together with Proposition 6 from below yields an alternative proof of rotation invariance of  <span class="math">\\mathcal{L}&#x27;_N(F)</span> .</p>

    <p class="text-gray-300">Motivated by Lemma 8 we define the linear subspaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_{N}^{-}(F) = \\left\\{ f \\in \\mathcal{L}_{N}(F) : \\frac{f}{x^{N/2}}(\\infty) = -\\frac{f}{x^{N/2}}(\\bar{\\infty}) \\right\\}, \\tag{26}</span></div>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math-block">\\mathcal{L}_{N}^{+}(F) = \\left\\{ f \\in \\mathcal{L}_{N}(F) : \\frac{f}{x^{N/2}}(\\infty) = +\\frac{f}{x^{N/2}}(\\bar{\\infty}) \\right\\}.</span>  (27)</p>

    <p class="text-gray-300">These are the spaces of polynomials having alternating or non-alternating limits at infinity, both with respect to the action of the involution J on  <span class="math">\\{\\infty, \\bar{\\infty}\\}</span> .</p>

    <p class="text-gray-300"><strong>Lemma 9.</strong> Suppose that  <span class="math">N, M \\geq 2</span>  are even integers. If  <span class="math">f \\in \\mathcal{L}_N^-(F)</span>  and  <span class="math">g \\in \\mathcal{L}_M^+(F)</span> , or vice-versa, then  <span class="math">f \\cdot g \\in \\mathcal{L}_{N+M}^-(F)</span> . For all other combinations of f and g, having either alternating or non-alternating limits at infinity, their product  <span class="math">f \\cdot g \\in \\mathcal{L}_{N+M}^+(F)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The claim follows from the degree of the product, and that it has alternating limits at infinity if and only if exactly one of the two functions has alternating limits at infinity.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><span id="page-19-1"></span><strong>Proposition 6.</strong> The FFT space is characterized by having alternating limits at infinity,  <span class="math">\\mathcal{L}_N^-(F) = \\mathcal{L}_N&#x27;(F)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Write  <span class="math">g \\in \\mathcal{L}_N(F)</span>  as  <span class="math">g = f + \\lambda \\cdot v_n</span> , with  <span class="math">f \\in \\mathcal{L}&#x27;_N(F)</span>  and  <span class="math">v_n</span>  the vanishing polynomial of a standard position coset of size N, and  <span class="math">\\lambda \\in F</span> . By Lemma 8  <span class="math">f \\in \\mathcal{L}_N^-(F)</span>  and  <span class="math">v_n \\in \\mathcal{L}_N^+(F)</span> , and we obtain that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{g}{x^{N/2}}(\\infty) + \\frac{g}{x^{N/2}}(\\bar{\\infty}) = 2 \\cdot \\lambda \\cdot \\frac{v_n}{x^{N/2}}(\\infty),</span></div>

    <p class="text-gray-300">which is zero if and only if  <span class="math">\\lambda = 0</span> , or equivalently  <span class="math">g \\in \\mathcal{L}&#x27;_N(F)</span> .</p>

    <h2 id="sec-14" class="text-2xl font-bold">5 STARK over the circle</h2>

    <p class="text-gray-300">Circle STARKs are similar to univariate STARKs, with the only difference that the underlying algebraic function space is the space of bivariate polynomials over the circle curve, i.e.  <span class="math">\\mathbb{F}_p[x,y]/(x^2+y^2-1)</span> , rather than univariate polynomials over the "line". Circle STARKs address arithmetic circuits over prime fields  <span class="math">\\mathbb{F}_p</span>  where (p-1) is not acceptably smooth but (p+1) is, meaning that it is CFFT-friendly (recall Definition 1) for sufficiently large order. Witness data is encoded into bivariate polynomials, by means of the circle FFT from Section 4, and constraint satisfaction is carried over to algebraic relations imposed on these polynomials. The interactive oracle proof is essentially the same as in the univariate case, with just a</p>

    <p class="text-gray-300">few changes which are related to the dimension gap between the output space of the circle FFT and the full space of polynomials. For the sake of simplicity we restrict our exposition to algebraic intermediate representations (AIR) with constraints between neighbouring rows only. Generalizations like arbitrary row offset, non-periodic constraints, permutation and lookup arguments are done in the usual manner, and are shortly discussed in Section 5.4. The protocol of the STARK is described in an informal style, but this does not mean that we neglect rigor. A formal treatment, including a fully-fledged security analysis is moved to Appendix B.</p>

    <p class="text-gray-300">Let p be CFFT-friendly prime, supporting sufficiently large orders so that each of the domains below are supported by p. In circle STARK, the  <span class="math">trace\\ domain</span>  is the standard position coset</p>

    <div class="my-4 text-center"><span class="math-block">H \\subset C(\\mathbb{F}_p)</span></div>

    <p class="text-gray-300">of a cyclic and proper subgroup  <span class="math">G = G_n</span>  of the circle curve  <span class="math">C(\\mathbb{F}_p)</span> , of size  <span class="math">N = 2^n</span> , with  <span class="math">n \\ge 1</span> , and the trace is organised column-wise  <span class="math">t_1, \\ldots, t_w \\in \\mathbb{F}_p^N</span> , each placed over the domain H in the usual manner, using the group translation T by a generator of G for the timeline. The trace columns are interpolated by polynomials</p>

    <div class="my-4 text-center"><span class="math-block">p_1, \\ldots, p_w \\in \\mathbb{F}_p[x, y]/(x^2 + y^2 - 1)</span></div>

    <p class="text-gray-300">of total degree at most N/2, meaning that  <span class="math">p_i \\in \\mathcal{L}_N(\\mathbb{F}_p)</span>  (actually, they are from the FFT-space  <span class="math">\\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span> ), and these polynomials are subject to a set of constraints, say</p>

    <p class="text-gray-300"><span id="page-20-1"></span> <span class="math-block">P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0,</span>  (28)</p>

    <p class="text-gray-300">for i = 1, ..., C, holding over the entire domain H, and where  <span class="math">s_i \\in \\mathcal{L}_N(\\mathbb{F}_p)</span>  is a predefined selector polynomial. Each constraint is a polynomial</p>

    <div class="my-4 text-center"><span class="math-block">P_i \\in \\mathbb{F}_p[S, X_1, \\dots, X_w, Y_1, \\dots, Y_w],</span></div>

    <p class="text-gray-300">of total degree  <span class="math">^5</span>  at most the maximum number of twin-cosets of size N.</p>

    <div class="my-4 text-center"><span class="math-block">\\deg P_i \\le \\frac{p^2 + 1}{N} - 1,</span></div>

    <p class="text-gray-300">and the degree in the selector variable S is at most  <span class="math">\\deg_S P_i \\leq 1</span> . Algebraic intermediate representations allow for periodic constraints only, meaning that each constraint  <span class="math">C_i</span>  is enforced on a subdomain  <span class="math">H_i \\subseteq H</span> , a coset of a subgroup of G, with optionally one point removed for boundary conditions, and will be described in detail in Section 5.1. Their selector polynomials  <span class="math">s_i \\in \\mathcal{L}_N(\\mathbb{F}_p)</span>  are built from domain vanishing polynomials and are succinctly evaluable. (It turns out that these are again from the FFT space  <span class="math">\\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span> .) Consequently there is no need to provide and verify them in a precomputation phase.</p>

    <p class="text-gray-300">The polynomials  <span class="math">p_1, \\ldots, p_w</span> , as well as further ones provided in the course of the protocol, are committed by their values over a larger <em>evaluation domain</em>  <span class="math">D \\subseteq C(\\mathbb{F}_p)</span> , a standard position coset of at least double the size of H. In other words, the prover commits to code words of the circle code  <span class="math">C_N(D)</span>  with values in the prime field  <span class="math">\\mathbb{F}_p</span> , or some finite extension F of it. Being again in standard position, D is disjoint from H, and we assume that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = 2^B$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for some  <span class="math">B \\geq 1</span> . The degree of the algebraic intermediate representation is</p>

    <div class="my-4 text-center"><span class="math-block">d = \\max_{i=1,\\dots,C} \\deg P_i,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which by the above assumptions is bounded by  $d \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C(\\mathbb{F}_p)/G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> . In high-performance instances, one typically chooses a parameter setup which limits the extrapolation effort to that of the evaluation domain. There, the maximum constraint degree is bounded by  </span>d \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-20-0"></span><sup>&</sup>lt;sup>5</sup>The degree bound stems from the size of the maximum extrapolation target for the circle FFT, which is  <span class="math">C(\\mathbb{F}_p) \\setminus G</span> . It can be relaxed to deg  $C_i \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C(\\mathbb{F}_p)/G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  if one uses the modified domain evaluation from Remark 12.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">5.1 Constraint selectors</h4>

    <p class="text-gray-300">Let us discuss the selector polynomials for subdomains  <span class="math">H&#x27; \\subset H</span> , which are an arbitrary position coset of a proper subgroup  <span class="math">G&#x27; \\subset G</span> , the group of the trace domain H. Recall the definition of  <span class="math">\\mathcal{V}(S)</span>  of any even-sized set S, as given in Lemma 4.</p>

    <p class="text-gray-300"><strong>Lemma 10.</strong> Let H be a standard position coset of size  <span class="math">N=2^n</span>  and  <span class="math">H&#x27; \\subset H</span>  an arbitrary position coset of a subgroup G' of size  <span class="math">N&#x27;=2^{n&#x27;}</span> , where  <span class="math">1 \\leq n&#x27; &lt; n</span> . Then for any two non-zero  <span class="math">v_H \\in \\mathcal{V}(H)</span> ,  <span class="math">v_{H&#x27;} \\in \\mathcal{V}(H&#x27;)</span>  the quotient</p>

    <div class="my-4 text-center"><span class="math-block">s_{H&#x27;} = \\frac{v_H}{v_{H&#x27;}}</span></div>

    <p class="text-gray-300">is a polynomial from  <span class="math">\\mathcal{V}(H \\setminus H&#x27;)</span>  which alternates under the action of G'. In particular, since  <span class="math">\\mathcal{V}(H \\setminus H&#x27;) \\subseteq \\mathcal{L}_{N-N&#x27;}(\\mathbb{F}_p)</span>  the polynomial  <span class="math">s_{H&#x27;}</span>  belongs to the FFT space  <span class="math">\\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Proposition 3 already implies that the quotient  <span class="math">s_{H&#x27;}</span>  is equal to a polynomial q from  <span class="math">\\mathcal{L}_{N-N&#x27;}(\\mathbb{F}_p)</span>  satisfying  <span class="math">v_H = q \\cdot v_{H&#x27;}</span>  over the circle curve. Since  <span class="math">v_H</span>  is a non-zero polynomial, so must be q. By Lemma 4  <span class="math">v_{H&#x27;}</span>  is non-zero outside H', hence every point from  <span class="math">H \\setminus H&#x27;</span>  is a zero of q. This shows that  <span class="math">q \\in \\mathcal{V}(H \\setminus H&#x27;)</span>  and thus is throughout non-zero outside  <span class="math">H \\setminus H&#x27;</span> .</p>

    <p class="text-gray-300">To see the alternating behaviour under G', let P' be a generator of G'. Since n' < n, that generator is an even power of a generator of G, and hence by Lemma 5 the vanishing polynomial  <span class="math">v_H</span>  is invariant under P'. For the vanishing polynomial of H' itself, we have alternating behaviour under  <span class="math">T_{P&#x27;}</span> , i.e.  <span class="math">v_{H&#x27;} \\circ T_{P&#x27;} = -v_{H&#x27;}</span> . (Cf. Remark 9.) Therefore  <span class="math">s_{H&#x27;} \\circ T_{P&#x27;} = -s_{H&#x27;}</span>  on its set of definition  <span class="math">C(\\mathbb{F}_p) \\setminus H&#x27;</span> , in other words</p>

    <div class="my-4 text-center"><span class="math-block">q \\circ T_{P&#x27;}(P) + q(P) = 0</span></div>

    <p class="text-gray-300">for every  <span class="math">P \\in C(\\mathbb{F}_p) \\setminus H&#x27;</span> . Since  <span class="math">q \\circ T_{P&#x27;} + q \\in \\mathcal{L}_{N-N&#x27;}(\\mathbb{F}_p)</span>  and there are more than N points outside H', Proposition 2 yields that  <span class="math">q \\circ T_{P&#x27;} + q = 0</span>  everywhere on the circle curve, proving the claimed alternating behaviour of q.</p>

    <p class="text-gray-300"><span id="page-21-2"></span>Remark 15. By their degree, domain selectors have trivial limits at infinity,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{s_{H&#x27;}}{x^{N/2}}(\\bar{\\infty}) = \\frac{s_{H&#x27;}}{x^{N/2}}(\\infty) = 0.</span></div>

    <p class="text-gray-300">If one takes  <span class="math">v_n</span>  as the vanishing polynomial of H and a suitable rotation  <span class="math">v_{H&#x27;} = v_m \\circ T_Q^{-1}</span> , m = n', as vanishing polynomial of H', then one can show that the concrete value for  <span class="math">P = (P_x, P_y) \\in H&#x27;</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">s_{H&#x27;}(P) = \\frac{v_n&#x27;(P_x)}{v_m&#x27;(P_x \\cdot Q_x + P_y \\cdot Q_y)} \\cdot \\frac{P_y}{P_y \\cdot Q_x - P_x \\cdot Q_y},</span></div>

    <p class="text-gray-300">where  <span class="math">v_n&#x27;</span>  and  <span class="math">v_m&#x27;</span>  are the (formal) derivatives of  <span class="math">v_n</span>  and  <span class="math">v_m</span> . That is,  <span class="math">v_1&#x27;(x) = 1</span> , and for  <span class="math">k \\geq 2</span> , we have  <span class="math">v_k&#x27;(x) = 4^{k-1} \\cdot \\prod_{j=1}^{k-1} v_j(x)</span> .</p>

    <p class="text-gray-300">As DEEP quotients, selectors of singleton domains need a separate treatment.</p>

    <p class="text-gray-300"><span id="page-21-1"></span><strong>Lemma 11.</strong> Let H be a standard position coset of size  <span class="math">N=2^n</span> , and P be an arbitrary point from H. Taking  <span class="math">v_0(x,y)=\\frac{y}{1+x}</span> , the quotient</p>

    <div class="my-4 text-center"><span class="math-block">s_P = \\frac{v_n}{v_0 \\circ T_P^{-1}},</span></div>

    <p class="text-gray-300">is a polynomial from  <span class="math">\\mathcal{L}_N(\\mathbb{F}_p)</span> , which has a non-zero value at P and is zero elsewhere on H. Furthermore,  <span class="math">s_P</span>  is contained in the FFT-space  <span class="math">\\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span> .</p>

    <p class="text-gray-300">Proof. In univariate coordinates  <span class="math">v_n(t) \\in L_N(\\mathbb{F}_p)</span>  has throughout simple zeros, in particular at  <span class="math">t_P</span>  corresponding to the point  <span class="math">P \\in H</span> . The reference function  <span class="math">v_0</span>  translates to  <span class="math">v_0(t) = t</span> , which has a simple zero at t = 0 and a simple pole at infinity. Its rotation  <span class="math">v_0 \\circ T_P^{-1}</span>  thus has a simple zero at  <span class="math">t_P</span>  and a simple pole at  <span class="math">-1/t_P</span> . Altogether, we conclude that the quotient  <span class="math">v_H(t)/v(t) \\in L_N(\\mathbb{F}_p)</span>  and it has a non-zero value at  <span class="math">t_P</span> . This proves the first assertion.</p>

    <p class="text-gray-300">To see that  <span class="math">s_P</span>  belongs to the FFT space, we investigate its limit with respect to  <span class="math">x^{N/2}</span>  at infinity. Consider</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{v_n}{x^{N/2}} = \\frac{s_P}{x^{N/2}} \\cdot (v_0 \\circ T_P^{-1}).</span></div>

    <p class="text-gray-300">By Lemma 8 the vanishing polynomial  <span class="math">v_n</span>  belongs to  <span class="math">\\mathcal{L}_N^+(\\mathbb{F}_p)</span> , whereas  <span class="math">v_0(\\infty) = -v_0(\\bar{\\infty})</span>  which by Remark 14 also holds for the rotated function  <span class="math">v_P</span> . Therefore  <span class="math">s_P \\in \\mathcal{L}_N^-(\\mathbb{F}_p)</span> , which by Proposition 6 is the FFT space.</p>

    <p class="text-gray-300"><span id="page-22-2"></span>Remark 16. It follows from the proof of Lemma 11 that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{s_P}{x^{N/2}}(\\bar{\\infty}) = -\\frac{s_P}{x^{N/2}}(\\infty) = i \\cdot \\frac{v_n}{x^{N/2}}(\\infty),</span></div>

    <p class="text-gray-300">which by Lemma 8 is non-zero. It can be shown that the concrete value at  <span class="math">P = (P_x, P_y)</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">s_P(P) = -2 \\cdot v_n&#x27;(P_x) \\cdot P_y,</span></div>

    <p class="text-gray-300">with  <span class="math">v&#x27;_n</span>  as the derivative of  <span class="math">v_n</span>  as described in Remark 15, and the statement of Lemma 11 extends to twin-coset domains H with vanishing function  <span class="math">v_H = v_n - x_H</span> . The normalized single-point quotient</p>

    <div class="my-4 text-center"><span class="math-block">\\ell_P(Q) = -\\frac{1}{2 \\cdot v_n&#x27;(P_x) \\cdot P_y} \\cdot s_P(Q)</span></div>

    <p class="text-gray-300">is the "Lagrangian" for the FFT space  <span class="math">\\mathcal{L}&#x27;_N(F)</span>  and may be taken for evaluating any  <span class="math">f \\in \\mathcal{L}&#x27;_N(F)</span>  at arbitrary outside points Q via the inner product formula</p>

    <p class="text-gray-300"><span class="math-block">f(Q) = \\langle f(P), \\ell_P(Q) \\rangle_{P \\subset H}</span> .</p>

    <p class="text-gray-300">With precomputed normalizing factors<sup>6</sup>, the values of  <span class="math">\\ell_P(Q)</span>  for  <span class="math">P \\in H</span>  can be computed efficiently by decomposing the twin-coset H into twin-cosets of size four, over each of which the same four products  <span class="math">Q_x \\cdot P_x</span> ,  <span class="math">Q_y \\cdot P_x</span> ,  <span class="math">Q_x \\cdot P_y</span> ,  <span class="math">Q_y \\cdot P_y</span>  are involved in the formula for  <span class="math">Q \\cdot P^{-1}</span> , and taking Montgomery batch inversion for the values of  <span class="math">1/v_0</span>  over  <span class="math">Q \\cdot H</span> .</p>

    <p class="text-gray-300"><span id="page-22-3"></span><strong>Remark 17.</strong> In an optimization of the circle STARK, discussed in Remark 22, the selector polynomial of a punctuated domain  <span class="math">H&#x27; = H \\setminus \\{P\\}</span> , with  <span class="math">P = (P_x, P_y) \\in H</span> , is taken as the tangent functional at P instead,</p>

    <div class="my-4 text-center"><span class="math-block">s_P = x_P \\cdot x + y_P \\cdot y - 1.</span></div>

    <p class="text-gray-300">That selector polynomial has a zero of multiplicity 2 at P, and no other zeroes on the circle. In the particular case that P = (1, 0), the functional is contained in the space  <span class="math">\\mathcal{L}_2^+(\\mathbb{F}_p)</span>  defined in Section 4.3</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">5.2 The interactive oracle proof for AIR</h3>

    <p class="text-gray-300">The interactive oracle proof for the satisfiability of the AIR, i.e. the existence of low-degree polynomials  <span class="math">p_1, \\ldots, p_w \\in \\mathbb{F}_p[X,Y]/(X^2+Y^2-1)</span>  which satisfy each of the constraints (28) over the trace domain H,  <span class="math">i=1,\\ldots,C</span> , goes as follows.</p>

    <p class="text-gray-300"><span id="page-22-1"></span><sup>&</sup>lt;sup>6</sup>By the invariance of  <span class="math">v_n</span>  under  <span class="math">G_{n-1}</span>  and J, the alternating behaviour of  <span class="math">v_0</span>  under J, and  <span class="math">J \\circ T_P = T_{P^{-1}} \\circ J</span> , the normalizing factors are invariant under  <span class="math">G_{n-1}</span>  and alternate under J.</p>

    <p class="text-gray-300">In the first round, the prover computes the values of its trace polynomials p1, . . . p<sup>w</sup> ∈ L<sup>N</sup> (Fp) over the evaluation domain D using its decomposition into twin-cosets from Lemma <a href="#page-6-1">2,</a> and shares their oracles, denoted by</p>

    <div class="my-4 text-center"><span class="math-block">[p_1],\\ldots,[p_w],</span></div>

    <p class="text-gray-300">with the verifier. (That is, it gives the verifier access to the oracles.)</p>

    <p class="text-gray-300">In the second round the verifier sends a random challenge β ←\\$ F, drawn uniformly from a suitably large extension field F of Fp, which is used to reduce the C domain identities into a single one,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{C} \\beta^{i-1} \\cdot P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0</span></div>

    <p class="text-gray-300">to hold over the trace domain H. (The soundness error of this step is a usual, and depends on the size of the extension field F and C.) In order to prove this identity, the prover uses Proposition <a href="#page-11-1">3</a> and computes the quotient polynomial q ∈ L(d−1)·<sup>N</sup> (F) subject to the overall identity</p>

    <p class="text-gray-300"><span id="page-23-0"></span> <span class="math-block">\\sum_{i=1}^{C} \\beta^{i-1} \\cdot P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = q \\cdot v_H,</span> (29)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where v<sup>H</sup> is the vanishing polynomial of H. To keep with one and the same degree bound imposed by the size of H, the quotient q ∈ L(d−1)·<sup>N</sup> (F) is split into polynomials q1, . . . , qd−<sup>1</sup> ∈ L<sup>N</sup> (F), and a further parameter λ ∈ F, by taking a decomposition of unity for a disjoint union H¯ = Sd−<sup>1</sup> <sup>k</sup>=1 H<sup>k</sup> of twin-cosets of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= N built from their vanishing polynomials,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-23-1"></span> <span class="math-block">q = \\lambda \\cdot v_{\\bar{H}} + \\sum_{k=1}^{d-1} \\frac{v_{\\bar{H}}}{v_{H_k}} \\cdot q_k. \\tag{30}</span></p>

    <p class="text-gray-300">This extra parameter λ attributes the aforementioned dimension gap, and is the main difference to the classical univariate as well as the elliptic curve case. We will describe the details of the decomposition, and how to compute it, in Section <a href="#page-25-0">5.3</a> below. The prover sets up the oracles</p>

    <div class="my-4 text-center"><span class="math-block">[q_1],\\ldots,[q_{d-1}]</span></div>

    <p class="text-gray-300">for their values over the evaluation domain D, and sends them, together with λ, to the verifier.</p>

    <p class="text-gray-300">Having all the oracles in place, the next step is the DEEP algebraic linking, which reduces satisfiability of the overall identity <a href="#page-23-0">\\(29\\)</a> to a low-degree test on single-point quotients. (In lose terms, this step turns the low-degree test into a polynomial commitment scheme.) The verifier responds with a random point</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma \\leftarrow \\$ C(F) \\setminus (D \\cup H)</span></div>

    <p class="text-gray-300">from the circle curve over the extension field F, which is the DEEP query at which the overall identity <a href="#page-23-0">\\(29\\)</a> is checked. In return, the prover claims the values vi,0, vi,<sup>1</sup> of p<sup>i</sup> at the points γ and T(γ) respectively, for each i = 1, . . . , w, as well as the values v1, . . . , vd−<sup>1</sup> of q1, . . . , qd−<sup>1</sup> at γ. Eventually, both prover and verifier then engage in a low-degree test for the real and imaginary parts of the DEEP quotients defined in Proposition <a href="#page-11-0">4,</a></p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Re/Im}\\left(\\frac{p_i-v_{i,0}}{v_{\\gamma}}\\right),\\operatorname{Re/Im}\\left(\\frac{p_i-v_{i,1}}{v_{T(\\gamma)}}\\right)</span></div>

    <p class="text-gray-300">for each i = 1, . . . , w, and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Re}/\\mathsf{Im}\\left(\\frac{q_1-v_1}{v_\\gamma}\\right),\\dots,\\mathsf{Re}/\\mathsf{Im}\\left(\\frac{q_{d-1}-v_{d-1}}{v_\\gamma}\\right)</span></div>

    <p class="text-gray-300">which is a joint proximity test to the circle code C<sup>N</sup> (F, D). The proximity test is explained in Section <a href="#page-28-0">6.</a> If the proximity test passes, and if the claimed values satisfy the overall identity <a href="#page-23-0">\\(29\\)</a> at γ, using <a href="#page-23-1">\\(30\\)</a>, and computing the values of the selectors si(γ) by itself, then the verifier accepts.</p>

    <p class="text-gray-300"><strong>Remark 18.</strong> Taking real and imaginary parts reduces the low degree test for F(i)-rational functions to a low-degree test for F-rational functions, and is done to avoid larger fields than demanded by soundness. Although this doubles the number of functions subject to the test, we shall see that it does not cause significant computational overhead, for both the prover and the verifier. (Cf. Remark 23.)</p>

    <p class="text-gray-300">The formal treatment of the protocol, including a clarification of security notions is given in Appendix B. We simply state its soundness error in the (ordinary) oracle model.</p>

    <p class="text-gray-300"><strong>Theorem</strong> (Summary of Theorem 7 and 8, Appendix B). Let  <span class="math">n, w, C, d, B \\ge 1</span> , and let p be a CFFT-friendly prime supporting the order n+B, and so that  <span class="math">d \\cdot 2^n &lt; p+1</span> , and select F any finite extension of  <span class="math">\\mathbb{F}_p</span> . Consider the simple AIR from above, with trace length  <span class="math">N=2^n</span>  and w columns, subject to the given C constraints of maximum degree d. Then the above described interactive oracle proof for the satisfiability of the AIR has soundness and knowledge-soundness error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_{AIR} = \\ell^+ \\cdot \\left( \\frac{C-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{d \\cdot (N+2)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1-2^{n+B}} \\right) + \\varepsilon_{PROX},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $\\varepsilon_{PROX} := \\varepsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, n, m, L)<span class="math">  is the soundness error of the joint proximity test for real and imaginary parts of the DEEP quotients to  </span>\\mathcal{C}_N(F, D)<span class="math"> , Theorem 6, run with agreement parameter  </span>\\alpha = \\alpha(m)<span class="math"> , where  </span>3 \\le m \\le N/2<span class="math"> , and  </span>\\ell^+<span class="math">  is the list size bound of the slightly larger circle code  </span>\\mathcal{C}_{N+2}(F, D)<span class="math">  for an agreement set density  </span>> \\alpha$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 19. The above IOP follows the common design principle being a chain of probabilistic reductions, and hence the proofs in Appendix B elaborate the soundness errors of the separate protocol rounds. By means of the [BSCS16] transform, the interactive oracle proof can be turned into a SNARK in the random oracle model. We postpone an explicit treatment, similar to that in the most recent update of [Sta23], to a future version of the paper.</p>

    <p class="text-gray-300">Theorem 7 asserts that, if a (possibly computationally unbounded) algorithm  <span class="math">P^<em></span>  succeeds the verifier with a probability larger than  <span class="math">\\varepsilon_{AIR}</span> , then there exist low-degree polynomials  <span class="math">p_1,\\ldots,p_w\\in\\mathbb{F}_p[X,Y]/(X^2+Y^2-1)</span>  which satisfy each of the C constraints (28) over the trace domain H. Furthermore,  <span class="math">P^</em></span>  can be turned into an algorithm which extracts such a solution, and which has comparable running-time: Once sampled a first round message  <span class="math">[f_1],\\ldots,[f_w]</span>  on which  <span class="math">P^*</span>  is able to succeed with that probability, then this solution is one of the at most  <span class="math">\\ell^+</span>  many collections of degree  <span class="math">\\leq N/2+1</span>  polynomials, which jointly agree with  <span class="math">f_1,\\ldots,f_w</span>  over a set  <span class="math">A\\subseteq D</span>  of density  <span class="math">\\geq \\alpha</span> . The at most  <span class="math">\\ell^+</span>  many candidate collections are obtained by the Guruswami-Sudan list decoder over a suitable finite extension of  <span class="math">\\mathbb{F}_p</span> . See Appendix B for details.</p>

    <p class="text-gray-300">Let us quickly explain the ingredients of Equation (47) to the advanced reader. The part in the brackets is the soundness error of the protocol in the polynomial oracle model. Its first term is subject to the batching step of the C constraints, which amounts to zero-testing an ordinary univariate polynomial of degree C-1 over the extension field F. The second term is the soundness error bound of the DEEP algebraic linking step, which is a zero test for a polynomial from  <span class="math">\\mathcal{L}_{d\\cdot(N+2)}(F)</span>  at a random point  <span class="math">\\gamma \\in C(F) \\setminus D</span> . The slightly increased degree bound in  <span class="math">\\mathcal{L}_{d\\cdot(N+2)}(F)</span>  attributes the step of passing from DEEP quotients to the non-quotients, which is also responsible for the slightly different list size bound  <span class="math">\\ell^+</span> .</p>

    <p class="text-gray-300"><span id="page-24-0"></span>Remark 20. As in the construction of singleton selectors (Lemma 11) one may alternatively choose the rational function</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{v}_P(x,y) = v_0(P_x \\cdot x - P_y \\cdot y, P_y \\cdot x + P_x \\cdot y)</span></div>

    <p class="text-gray-300">where  <span class="math">v_0(x,y) = y/(1+x)</span> , for DEEP quotients. These quotients stay in the field F, but to assure that the non-quotients have no (affine) pole, one needs to run the low-degree test on both the quotients and the non-quotients. This approach leads again to a batch of double the size and hence comparable computational cost. Without proof we state that the soundness error of this variant is the same as in Theorem 7.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">5.3 Computing the overall quotient</h4>

    <p class="text-gray-300">The quotient  <span class="math">q \\in \\mathcal{L}_{(d-1)\\cdot N}(F)</span>  is computed by value from those of  <span class="math">f_1, \\ldots, f_w</span>  over a union of twin-cosets  <span class="math">H_k</span>  of size N,</p>

    <div class="my-4 text-center"><span class="math-block">\\bar{H} = \\bigcup_{k=1}^{d-1} H_k,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">disjoint to the trace domain and of overall  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= (d-1) \\cdot N<span class="math"> . (Typically  </span>\\bar{H}<span class="math">  is chosen a subset of the evaluation domain D.) Recall that by Proposition 2 dim  </span>\\mathcal{L}_{(d-1) \\cdot N} = (d-1) \\cdot N + 1<span class="math"> , and thus the union  </span>\\bar{H}<span class="math">  is one point too small to uniquely determine a polynomial from  </span>\\mathcal{L}_{(d-1) \\cdot N}<span class="math"> . In our decomposition, this missing point is characterized by an additional scalar multiple of the vanishing polynomial of  </span>\\bar{H}<span class="math"> , as the following lemma shows. It is a generalization of the decomposition  </span>\\mathcal{L}_N(F) = \\mathcal{L}'_N(F) + \\langle v_n \\rangle<span class="math">  from Section 4.3 to a union of twin-cosets. Recall that the vanishing polynomial of the twin-coset  </span>H_k$  is of the form</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">v_{H_k}(x) = v_n(x) - c_k</span></div>

    <p class="text-gray-300">for some  <span class="math">c_k \\in \\mathbb{F}_p</span> .</p>

    <p class="text-gray-300"><span id="page-25-2"></span><strong>Lemma 12</strong> (Decomposition Lemma). Consider disjoint twin-cosets  <span class="math">H_k</span> , k = 1, ..., d-1, of size  <span class="math">N = 2^n</span> , and take  <span class="math">v_{\\bar{H}} = \\prod_{k=1}^{d-1} v_{H_k}</span>  as a vanishing polynomial of the union  <span class="math">\\bar{H} = \\bigcup_{k=1}^{d-1} H_k</span> . Then every  <span class="math">q \\in \\mathcal{L}_{(d-1) \\cdot N}(F)</span>  is uniquely decomposed into</p>

    <p class="text-gray-300"><span id="page-25-1"></span> <span class="math-block">q = \\lambda \\cdot v_{\\bar{H}} + \\sum_{k=1}^{d-1} \\frac{v_{\\bar{H}}}{v_{H_k}} \\cdot q_k, \\tag{31}</span></p>

    <p class="text-gray-300">with  <span class="math">\\lambda \\in F</span>  and  <span class="math">q_k \\in \\mathcal{L}&#x27;_N(F)</span> , for each  <span class="math">k = 1, \\dots, d-1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Since each  <span class="math">\\frac{v_{\\bar{H}}}{v_{H_k}}</span>  is non-zero over  <span class="math">H_k</span>  and vanishes over the other twin-cosets, the functions from  <span class="math">q_k \\in \\mathcal{L}&#x27;_N(F)</span>  are uniquely determined by the values of q over  <span class="math">\\bar{H}</span> . Hence the interpolation map for the union  <span class="math">\\bar{H}</span> , which maps given values over  <span class="math">\\bar{H}</span>  to the combined interpolant  <span class="math">\\sum_{k=1}^{d-1} \\frac{v_{\\bar{H}}}{v_{H_k}} \\cdot q_k</span> , with each  <span class="math">q_k \\in \\mathcal{L}&#x27;_N(F)</span> , is a linear map from  <span class="math">F^{\\bar{H}}</span>  into  <span class="math">\\mathcal{L}_{(d-1)\\cdot N}(F)</span>  which has a trivial kernel. Consequently the dimension of its range is equal to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d \\cdot N<span class="math"> . Since  </span>v_{\\bar{H}}<span class="math">  is obviously not contained in that range, they together span a  </span>((d-1)\\cdot N+1)<span class="math"> -dimensional subspace of  </span>\\mathcal{L}_{(d-1)\\cdot N}(F)<span class="math"> , which by the dimension of the latter must be the entire space  </span>\\mathcal{L}_{(d-1)\\cdot N}(F)$ . This proves the claim of the lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 21.</strong> Recall that by Lemma 5, and the discussion preceding it, the selector  <span class="math">\\frac{v_{\\bar{H}}}{v_{H_k}} = \\prod_{j \\neq k} v_{H_j}</span>  is invariant under J and  <span class="math">G_{n-1}</span> , and hence constant over twin-cosets of size N. In practice one chooses a normalized variant of the selector, which evaluates to 1 over  <span class="math">H_k</span> . With such a choice no extra multiplications are needed to obtain the values of  <span class="math">q_k</span>  over  <span class="math">H_k</span>  from those of q.</p>

    <p class="text-gray-300">To uniquely determine q we additionally consider its limit at infinity, as introduced in Section 4.3. This leads to a <em>limit-at-infinity calculus</em> for deriving the scalar  <span class="math">\\lambda</span>  in the decomposition (31). Dividing the overall identity (29) by the monomial of maximum degree, i.e.  <span class="math">x^{d \\cdot N/2}</span>  where d is the degree of the algebraic intermediate representation, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\sum_{i} \\beta^{i-1} \\cdot P_{i}\\left(s_{i}, p_{1}, \\dots, p_{w}, p_{1} \\circ T, \\dots, p_{w} \\circ T\\right)}{x^{d \\cdot N/2}} = \\left(\\lambda \\cdot \\prod_{k=1}^{d-1} \\frac{v_{H_{j}}}{x^{N/2}} + \\sum_{k=1}^{d-1} \\frac{q_{k}}{x^{N/2}} \\cdot \\prod_{j \\neq k} \\frac{v_{H_{j}}}{x^{N/2}}\\right) \\cdot \\frac{v_{H_{j}}}{x^{N/2}},</span></div>

    <p class="text-gray-300">and evaluating it at  <span class="math">\\infty</span>  yields</p>

    <p class="text-gray-300"><span id="page-26-0"></span> <span class="math-block">\\sum_{i=1}^{L} \\beta^{i-1} \\cdot P_i^{(d)} \\left( \\frac{s_i}{x^{N/2}}(\\infty), \\frac{p_1}{x^{N/2}}(\\infty), \\dots, \\frac{p_w}{x^{N/2}}(\\infty), \\frac{p_1 \\circ T}{x^{N/2}}(\\infty), \\dots, \\frac{p_w \\circ T}{x^{N/2}}(\\infty) \\right) \\\\ = \\left( \\lambda \\cdot \\prod_{k=1}^{d-1} \\frac{v_{H_k}}{x^{N/2}}(\\infty) + \\sum_{k=1}^{d-1} \\frac{q_k}{x^{N/2}}(\\infty) \\cdot \\prod_{j \\neq k} \\frac{v_{H_j}}{x^{N/2}}(\\infty) \\right) \\cdot \\frac{v_H}{x^{N/2}}(\\infty), \\tag{32}</span></p>

    <p class="text-gray-300">and likewise at  <span class="math">\\bar{\\infty}</span> , where  <span class="math">P_i^{(d)}</span>  denotes the homogeneous part of degree d of the constraint  <span class="math">P_i</span> . Using Lemma 8 the values at  <span class="math">\\infty</span>  are easily determined:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The values of  <span class="math">\\frac{v_H}{x^{N/2}}(\\infty)</span> ,  <span class="math">\\frac{v_H}{x^{N/2\\cdot(d-1)}}(\\infty)</span>  and  <span class="math">\\frac{s_i}{x^{N/2}}(\\infty)</span> , are determined using Lemma 8 and Remark 15 and 16, and may be precomputed. Since  <span class="math">\\frac{s_i}{h}(\\infty) = 0</span>  whenever the constraint selection domain  <span class="math">H_i</span>  is a proper non-singleton subgroup of H, we only need to take into account those terms of degree d, which correspond to global or single-point constraints.</li>

      <li>The values  <span class="math">\\frac{p_i}{h}(\\infty)</span> ,  <span class="math">i=1,\\ldots,w</span> , as well as  <span class="math">\\frac{q_k}{h}(\\infty)</span> ,  <span class="math">k=1,\\ldots,d-1</span> , are computed from the highest-order coefficients of their Fourier transforms using Lemma 8. (Recall that the transform of  <span class="math">q_k</span>  is needed anyway to compute its values over the entire evaluation domain D.)</li>

      <li>The values  <span class="math">\\frac{p_i \\circ T}{x^{N/2}}(\\infty)</span> ,  <span class="math">1 \\le i \\le M</span> , are also determined from the limits of the non-rotated functions using Equation 25. In particular, since  <span class="math">T = T_P</span>  for a generator P of the subgroup G, we have that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\frac{p_i \\circ T}{x^{N/2}}(\\infty) = (P_x + i \\cdot P_y)^{-N/2} \\cdot \\frac{p_i}{x^{N/2}}(\\infty) = -\\frac{p_i}{x^{N/2}}(\\infty),</span></div>

    <p class="text-gray-300">and the same holds at  <span class="math">\\bar{\\infty}</span> .</p>

    <p class="text-gray-300">Since  <span class="math">\\frac{v_H}{x^{N/2}}(\\infty)</span>  and  <span class="math">\\frac{v_{\\bar{H}}}{x^{(d-1)\\cdot N/2}}(\\infty) \\neq 0</span>  we can always extract  <span class="math">\\lambda</span>  from (32).</p>

    <p class="text-gray-300">A closer inspection of the overall identity at infinity shows that the limit-at-infinity calculus can be simplified or even omitted. The polynomials  <span class="math">s_i, p_i, p_i \\circ T</span>  belong to the FFT space  <span class="math">\\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span>  and hence have alternating limits at infinity,</p>

    <div class="my-4 text-center"><span class="math-block">s_i, p_i, p_i \\circ T \\in \\mathcal{L}_N^-(\\mathbb{F}_p),</span></div>

    <p class="text-gray-300">whereas the vanishing polynomial  <span class="math">v_H</span>  belongs to  <span class="math">\\mathcal{L}_N^+(F)</span> . Since the limits of q at infinity are only determined by the terms of order d, we obtain that</p>

    <div class="my-4 text-center"><span class="math-block">q \\in \\begin{cases} \\mathcal{L}^{-}_{(d-1) \\cdot N}(F) &amp; \\text{if } d \\text{ is odd,} \\\\ \\mathcal{L}^{+}_{(d-1) \\cdot N}(F) &amp; \\text{if } d \\text{ is even.} \\end{cases}</span></div>

    <p class="text-gray-300">(A product of an odd number of polynomials which are odd at infinity is again odd at infinity, and likewise a product of an even number of such polynomials is even at infinity.) On the other hand, each  <span class="math">v_{H_k}</span>  belongs to  <span class="math">\\mathcal{L}_N^+(F)</span>  (they are polynomials in x only) and every  <span class="math">q_k \\in \\mathcal{L}_N^-(F)</span>  (as they belong to  <span class="math">\\mathcal{L}_N&#x27;(F)</span> , showing that in the decomposition</p>

    <div class="my-4 text-center"><span class="math-block">q = \\lambda \\cdot \\prod_{k=1}^{d-1} v_{H_k} + \\sum_{k=1}^{d-1} q_k \\cdot \\prod_{j \\neq k} v_{H_j}</span></div>

    <p class="text-gray-300">the term belonging to  <span class="math">\\lambda</span>  is from  <span class="math">\\mathcal{L}^+_{(d-1)\\cdot N}(F)</span> , whereas the sum involving the  <span class="math">q_k</span>  belongs to  <span class="math">\\mathcal{L}^-_{(d-1)\\cdot N}(F)</span> . Since  <span class="math">F^{\\{\\infty,\\infty\\}}</span>  is a direct sum of the space of odd and even functions (under the action of J), and since the limits of  <span class="math">\\prod_{k=1}^{d-1} v_{H_j}</span>  are non-zero, we conclude that in the case d is odd we must have  <span class="math">\\lambda = 0</span> , and in the case d is even, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{k=1}^{d-1} \\frac{q_k}{x^{N/2}}(\\infty) \\cdot \\prod_{j \\neq k} \\frac{v_{H_j}}{x^{N/2}}(\\infty) = 0.</span></div>

    <p class="text-gray-300">Therefore, if d is odd one can omit the limit-at-infinity calculus. In the other case when d is even, no limits of q<sup>k</sup> are needed.</p>

    <p class="text-gray-300"><span id="page-27-1"></span>Remark 22. The quotient decomposition and the limit-at-infinity calculus extends to the case where one takes the linear tangent polynomial from Remark <a href="#page-22-3">17</a> as the selector for a punctuated domain H′ = H\\{(1, 0)}. (We choose the exceptional point P = (1, 0) for simplicity. The general case follows by rotation.) In this case we may allow a constraint P<sup>i</sup> subject to H′ to be of maximum degree without selector, i.e. of total degree</p>

    <div class="my-4 text-center"><span class="math-block">\\deg_{X_1,\\dots,X_w,Y_1,\\dots Y_w} P_i = d,</span></div>

    <p class="text-gray-300">where d is the degree of the AIR, at negligible extra cost for the prover. With the tangent selector belonging to L2(F), the overall quotient q is then in the slightly larger space L(d−1)·N+2(F), and can be computed from the values over the extended domain</p>

    <div class="my-4 text-center"><span class="math-block">H_0 \\cup \\bigcup_{k=1}^{d-1} H_k,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where H<sup>0</sup> is any twin-coset of size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2, disjoint to the other Hk. The decomposition from Lemma <a href="#page-25-2">12</a> generalizes to the extended domain as well, and given the fact that for P = (1, 0) the tangent selector is contained in L + 2 (F), we obtain that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">q \\in \\begin{cases} \\mathcal{L}^-_{(d-1)\\cdot N+2}(F) &amp; \\text{ if } d \\text{ is odd,} \\\\ \\mathcal{L}^+_{(d-1)\\cdot N+2}(F) &amp; \\text{ if } d \\text{ is even.} \\end{cases}</span></div>

    <p class="text-gray-300">Again, in the case d is odd, the term with respect to the vanishing polynomial of the extended domain vanishes, and in the case when d is even, no limits of the q<sup>k</sup> are needed.</p>

    <h2 id="sec-18" class="text-2xl font-bold">5.4 A note on generalizations</h2>

    <p class="text-gray-300">Our restrictive notion of AIR can be generalized to transitional constraints of arbitrary offset, involving arbitrary powers T <sup>k</sup> of the shift. The limit-at-infinity calculus from Section <a href="#page-25-0">5.3,</a> and in particular its analysis how it can be simplified or dropped, remains unchanged. The same holds when moving to a "plonkish" arithmetization taking non-succinct precomputed selector polynomials which are naturally from the FFT space.</p>

    <p class="text-gray-300">Univariate sumcheck techniques (<a href="#page-32-0">\\[BSCR</a>+19, <a href="#page-32-6">CHM</a>+20] or the one that uses running sums <a href="#page-32-7">\\[HGdB21,</a> [GK22\\]](#page-32-8)) as well as the grand product argument from Plonk [\\[GWC19\\]](#page-32-9) can be carried over to an IOP over the circle curve, with a negligible change of the soundness error. The same is true for lookup arguments such as [\\[GW20\\]](#page-32-10) or [\\[Hab22a\\]](#page-32-11), and the recent improvement [\\[PH23\\]](#page-33-8).</p>

    <p class="text-gray-300">Zero-knowledge is obtained in the usual manner, by inserting sufficient randomness in the encoding of the trace polynomials, and using the <a href="#page-32-0">\\[BSCR</a>+19] randomization of FRI, which carries over to the circle without changes. We refer to [\\[HK24\\]](#page-32-12) for a detailed description of the randomization, including the component polynomials of the quotient decomposition.</p>

    <p class="text-gray-300">Note that using the tweaked inverse FFT from Remark <a href="#page-15-2">12</a> allows to efficiently evaluate a representation with respect to the FFT basis over a domain in "group position", the only target not covered by twin-cosets. In Appendix <a href="#page-43-0">C</a> we make use of this exception, and describe an optimized variant of the STARK in which the evaluation domain D is a superset of the trace domain. In this context, we point out that arbitrary cosets can be handled by means of the "Mersenne FFT" from [\\[HLN23\\]](#page-33-0), which is a regular FFT over the complex extension Fp(i) optimized for "real" functions. By the rotation invariance of the FFT space, Proposition <a href="#page-17-1">5,</a> the extrapolation map from a standard position coset H to any other coset of the same size is of convolutional (i.e. circulant) form, and thus can be evaluated by the Mersenne FFT. Compared to a regular FFT, the Mersenne FFT costs the same number of multiplication but causes a significant overhead in the number of additions, essentially thwarting the advantage of Mersenne arithmetics. It is for this reason why we do not advertise this approach, although a coset-centric view would bring circle STARKs even closer to the univariate case.</p>

    <p class="text-gray-300">We further point out that circle codes (and variants of it) may be used in the construction of efficient diffusion layers in arithmetic hash functions such as Poseidon [GKR<sup>+</sup>21], Rescue [AAB<sup>+</sup>20], Rescue Prime [SAD20] and Monolith [GKL<sup>+</sup>23]. We shall elaborate on this in an upcoming writeup [HS24].</p>

    <h2 id="sec-19" class="text-2xl font-bold">6 Low-degree test over the Circle</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in the previous section we assume a prime p which is CFFT-friendly for a sufficiently large order, so that the evaluation domain of the following circle code is supported. Given a degree parameter  <span class="math">N=2^n, n\\geq 1</span> , a blow-up factor  <span class="math">2^B, B\\geq 1</span> , let  <span class="math">D\\subset C(\\mathbb{F}_p)</span>  be a standard position coset of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{B+n}<span class="math"> , and consider  </span>C=C_N(F,D)<span class="math">  the circle code with values in a finite extension F of  </span>\\mathbb{F}_p$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given a proximity parameter  <span class="math">\\theta \\in (0,1)</span> , the interactive oracle proof of proximity (IOPP) to  <span class="math">\\mathcal{C}</span>  is an interactive oracle protocol that proves a given word  <span class="math">f \\in F^D</span>  being  <span class="math">\\theta</span> -close to a word from the circle code, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">d(f, \\mathcal{C}) = \\min_{w \\in \\mathcal{C}} d(f, w) &lt; \\theta,</span></div>

    <p class="text-gray-300">where d denotes the relative Hamming distance over D. In other words, the IOPP proves the existence of a polynomial q from  <span class="math">\\mathcal{L}_N(F)</span>  which agrees with f on a set of density at least  <span class="math">1 - \\theta</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{P \\in D : f(P) = q(P)\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\ge 1 - \\theta.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Circle codes are closely related to Reed-Solomon codes. In fact, due to the projective line representation of the circle curve they essentially <em>are</em> Reed-Solomon codes (cf. Theorem 1) although their rate</p>

    <div class="my-4 text-center"><span class="math-block">\\rho = 2^{-B} \\cdot \\left(1 + \\frac{1}{2^n}\\right),\\,</span></div>

    <p class="text-gray-300">is slightly off the common use case of  <span class="math">\\rho=2^{-B}</span> . The Circle Proof of Proximity is an adaption of FRI [BSBHR18a] to this generalized code, and its soundness analysis will be taken, in large parts verbatim, from that for Reed-Solomon codes [BSCI<sup>+</sup>20] in the list decoding regime. That is, the proximity parameter will be bounded by</p>

    <div class="my-4 text-center"><span class="math-block">\\theta &lt; 1 - \\sqrt{\\rho}</span></div>

    <p class="text-gray-300">the Johnson-Guruswami-Sudan list decoding radius.</p>

    <p class="text-gray-300">In the bivariate representation of the circle, the circle proof of proximity with r rounds, where  <span class="math">0 \\le r \\le n</span> , carries over the folding procedure of FRI to the chain of 2-to-1 projections</p>

    <p class="text-gray-300"><span id="page-28-1"></span> <span class="math-block">C(\\mathbb{F}_p) \\subseteq \\mathbb{F}_p^2 \\qquad D_m \\xrightarrow{\\pi} D_{m-1} \\xrightarrow{\\pi} D_{m-2} \\xrightarrow{\\pi} D_{m-2} \\xrightarrow{\\pi} D_{m-r+1}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\downarrow^{\\phi_J = \\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad \\downarrow^{\\pi_x} \\qquad (33)</span></div>

    <div class="my-4 text-center"><span class="math-block">C(\\mathbb{F}_p)/J \\subseteq \\mathbb{F}_p \\qquad D_m/J \\xrightarrow{\\pi} D_{m-1}/J \\xrightarrow{\\pi} D_{m-2}/J \\xrightarrow{\\pi} \\cdots \\xrightarrow{\\pi} D_{m-r+1}/J</span></div>

    <p class="text-gray-300">which starts with the standard position coset  <span class="math">D_m</span>  of size  <span class="math">2^m</span> , where m = B + n, then takes the quotient with respect to the involution J, i.e. the projection onto the x-axis, and subsequently continues by (r-1) repeated application of the  <span class="math">\\pi(x) = 2 \\cdot x^2 - 1</span> , until ending up with quotient of the standard position coset  <span class="math">D_{m-r+1}</span> , consisting of  <span class="math">2^{m-r}</span>  elements. (Choosing the maximum number of rounds r = n, the chain would end with the quotient  <span class="math">D_{B+1}/J</span>  of size  <span class="math">2^B</span> .) However, before applying the folding steps, the prover uses Lemma 7 from Section 4.3 to decompose  <span class="math">f \\in \\mathcal{L}_N(F)</span>  into</p>

    <div class="my-4 text-center"><span class="math-block">f = g + \\lambda \\cdot v_n</span></div>

    <p class="text-gray-300">where g is from the FFT space  <span class="math">\\mathcal{L}&#x27;_N(F)</span> ,  <span class="math">\\lambda \\in F</span> , and  <span class="math">v_n</span>  is the vanishing polynomial of the standard position coset of size  <span class="math">N=2^n</span> . This decomposition is crucial, as the function spaces need to halve under folding to eventually end up with the trivial space of constant functions. Taking function spaces synonymous for their domain evaluations, the proximity claim of f to  <span class="math">\\mathcal{L}_N(F)</span>  reduces to that of g to the FFT space  <span class="math">\\mathcal{L}&#x27;^{(0)} := \\mathcal{L}&#x27;_N(F)</span> , which under repeated folding of "even" and "odd" parts as in the circle FFT, is step-wise reduced to proximity claims to the spaces</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}^{(j)} := \\left\\{ p(x) \\in F[x] : \\deg p(x) &lt; 2^{n-j} \\right\\},\\,</span></div>

    <p class="text-gray-300">for j = 1, ..., r, until one ends up with the space  <span class="math">\\mathcal{L}^{(r)}</span>  of polynomials in x of degree  <span class="math">\\leq 2^{n-r}</span> .</p>

    <p class="text-gray-300">For notational convenience we will write</p>

    <div class="my-4 text-center"><span class="math-block">C(\\mathbb{F}_p) \\subseteq \\mathbb{F}_p^2 \\qquad S_0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\downarrow^{\\phi_J = \\pi_1} \\qquad \\qquad \\downarrow^{\\pi_1}</span></div>

    <div class="my-4 text-center"><span class="math-block">C(\\mathbb{F}_p)/J \\subseteq \\mathbb{F}_p \\qquad S_1 \\xrightarrow{\\pi_2} S_2 \\xrightarrow{\\pi_3} S_3 \\xrightarrow{\\pi_4} \\xrightarrow{\\pi_r} S_{r+1}</span></div>

    <p class="text-gray-300">for the chain in (33), even though this conflicts the notation used in Section 4, and we set  <span class="math">T_1 = J</span>  and  <span class="math">T_j(x) = -x</span>  otherwise. Likewise, we use the unified notation  <span class="math">t_i</span>  for the twiddle used in each step, which is  <span class="math">t_1 = y</span>  in the first step, and  <span class="math">t_j = x</span>  in the other cases.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-29-3"></span><strong>Protocol 1</strong> (Circle FRI). Let D be a standard position coset of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{B+n}<span class="math"> , where  </span>B \\ge 1<span class="math">  and  </span>n \\ge 1<span class="math"> , and let  </span>C = C_N(F, D)<span class="math">  be the circle code with evaluation domain D and rate  </span>\\rho = \\frac{N+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , where  </span>N = 2^n<span class="math"> . For given proximity parameter  </span>\\theta \\in (0, 1 - \\sqrt{\\rho})<span class="math"> , the interactive oracle proof of a function  </span>f \\in F^D<span class="math">  being  </span>\\theta$ -close to the circle code C, consists of a commit phase and a subsequent query phase, which are as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">1. Commit phase:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(a) (Decomposition.) The prover uses Lemma 7 to compute the decomposition of  <span class="math">f \\in \\mathcal{L}_N(F)</span>  into  <span class="math">f = g + \\lambda \\cdot v_n</span>  with  <span class="math">g \\in \\mathcal{L}&#x27;_N(F)</span>  and  <span class="math">\\lambda \\in F</span> . It sends  <span class="math">\\lambda</span>  to the verifier.</li>

      <li>(b) (Folding.) For each  <span class="math">j=1,\\ldots,r</span> , corresponding to  <span class="math">\\pi_j:S_{j-1}\\longrightarrow S_j</span>  as above, the prover holds a function  <span class="math">g_{j-1}\\in F^{S_{j-1}}</span>  from the previous round. (In the first round  <span class="math">g_0=g</span> .) It receives a random challenge  <span class="math">\\lambda_j \\leftarrow F</span>  from the verifier, and uses it to build the random linear combination</li>

    </ul>

    <p class="text-gray-300"><span id="page-29-2"></span><span id="page-29-1"></span><span id="page-29-0"></span> <span class="math-block">g_j = g_{j-1,0} + \\lambda_j \\cdot g_{j-1,1} \\tag{34}</span></p>

    <p class="text-gray-300">of  <span class="math">g_{j-1,0}, g_{j-1,1} \\in F^{S_j}</span>  from the "even-odd" decomposition with respect to  <span class="math">T_j</span> , i.e.</p>

    <p class="text-gray-300"><span class="math-block">g_{j-1,0} \\circ \\pi_j = \\frac{g_{j-1} + (g_{j-1} \\circ T_j)}{2},</span>  (35)</p>

    <div class="my-4 text-center"><span class="math-block">g_{j-1,1} \\circ \\pi_j = \\frac{g_{j-1} - (g_{j-1} \\circ T_j)}{2 \\cdot t_j}, \\tag{36}</span></div>

    <p class="text-gray-300">using the corresponding twiddle  <span class="math">t_j</span>  as defined above. The prover sets up the oracle for  <span class="math">g_j</span> , and sends it to the verifier. (In the last round, the prover sends  <span class="math">g_{r+1} \\in \\mathcal{L}^{(r)}</span> , in plain.)</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">2. Query phase:</h4>

    <p class="text-gray-300">(a) The verifier samples  <span class="math">s \\geq 1</span>  queries uniformly from D. For each query Q, we write  <span class="math">Q_0 = Q</span>  and consider its trace  <span class="math">Q_j \\in S_j</span> ,  <span class="math">j = 1 \\dots, n</span> , under the chain of projections  <span class="math">\\pi_j : S_{j-1} \\longrightarrow S_j</span> . The verifier asks the oracle for the values of f at  <span class="math">Q_0</span>  and  <span class="math">T_1(Q_0)</span> , and of  <span class="math">g_j</span>  at  <span class="math">Q_j</span>  and  <span class="math">T_j(Q_j)</span> , for  <span class="math">j = 1, \\dots, r</span> . It takes the answers to check whether each  <span class="math">g_j</span>  was properly formed from  <span class="math">g_{j-1}</span>  via the folding (34), using  <span class="math">g_0 = f - \\lambda \\cdot v_n</span>  and the equations (35), (36) for  <span class="math">j = 1, \\dots, r</span> .</p>

    <p class="text-gray-300">If the oracle answers satisfy these checks for each of the s queries, then the verifier accepts. (Otherwise, it rejects.)</p>

    <p class="text-gray-300">For STARKs, where one faces a batch of DEEP quotients, proximity alone is not good enough (unless one works in the unique decoding regime) and the stronger notion of correlated agreement is crucial. We say that a batch of functions  <span class="math">f_1, \\ldots, f_L \\in F^D</span>  has  <span class="math">(1-\\theta)</span> -correlated agreement with a codeword from C, if the set of joint agreement has density at least  <span class="math">1-\\theta</span> , i.e.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bigcap_{k=1}^{L} \\{ P \\in D : f_k(P) = p(P) \\} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge (1 - \\theta) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for FRI, correlated agreement already plays a central role in the soundness analysis of Protocol 1, and its generalization to several functions comes without additional difficulties.</p>

    <p class="text-gray-300"><span id="page-30-2"></span><strong>Protocol 2</strong> (batch Circle FRI). Under the same assumptions as Protocol 1, the interactive oracle proof for a batch of functions  <span class="math">f_1, \\ldots, f_L \\in F^D</span>  having correlated  <span class="math">(1 - \\theta)</span> -agreement to a codeword from  <span class="math">C_N(F, D)</span> , is as follows. In the first step, given a random challenge  <span class="math">\\lambda_0 \\leftarrow F</span>  from the verifier, the prover computes the values of the linear combination</p>

    <p class="text-gray-300"><span id="page-30-1"></span> <span class="math-block">f = \\sum_{k=1}^{L} \\lambda_0^{k-1} \\cdot f_i \\tag{37}</span></p>

    <p class="text-gray-300">over D. Now, both prover and verifier run Protocol 1 on f, with its query phase extended by a check of (37) at each of the s queries Q.</p>

    <p class="text-gray-300"><span id="page-30-0"></span>Remark 23. In our STARK we need to batch both real and imaginary parts of DEEP quotients for a typically large collection of code words  <span class="math">g_k \\in F^D</span> , k = 1, ..., L, overall doubling the batch size. (Actually, most of the words are over  <span class="math">\\mathbb{F}_p</span> , but this does not play a role for what follows.) Leveraging linearity one can essentially halve the batching effort, resulting in comparable costs as if the quotients where over F instead of F(i). Let us illustrate this for a single fixed point  <span class="math">\\gamma \\in C(F)</span> , a generalization to several points is straightforward. Both real and imaginary part of the quotienting map, which sends g to  <span class="math">(g - g(\\gamma))/v_{\\gamma}</span> , are linear maps from  <span class="math">\\mathcal{L}_N(F)</span>  to  <span class="math">\\mathcal{L}_N(F)</span> , which we denote by  <span class="math">\\text{Re}_{\\gamma}</span>  and  <span class="math">\\text{Im}_{\\gamma}</span> . For any batching randomness  <span class="math">\\mu \\in F</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">g = \\sum_{k=0}^{L-1} \\mu^k \\cdot \\operatorname{Re}_{\\gamma}(g_k) + \\sum_{k=0}^{L-1} \\mu^{L+k} \\cdot \\operatorname{Im}_{\\gamma}(g_k) = \\operatorname{Re}_{\\gamma} \\left( \\sum_{k=0}^{L-1} \\mu^k \\cdot g_k \\right) + \\mu^L \\cdot \\operatorname{Im}_{\\gamma} \\left( \\sum_{k=0}^{L-1} \\mu^k \\cdot g_k \\right).</span></div>

    <p class="text-gray-300">For this type of linear combination the prover only needs to compute the values of  <span class="math">\\bar{g} = \\sum_{k=0}^{L-1} \\mu^k \\cdot g_k</span>  over D, the linear combination of the claims  <span class="math">\\bar{v}_{\\gamma} = \\sum_{k=0}^{L-1} \\mu^k \\cdot g_k(\\gamma)</span> , and computes the values of g over D according to</p>

    <div class="my-4 text-center"><span class="math-block">g = \\left( \\mathsf{Re} \\left( \\frac{1}{v_\\gamma} \\right) + \\mu^L \\cdot \\mathsf{Im} \\left( \\frac{1}{v_\\gamma} \\right) \\right) \\cdot (\\bar{g} - \\bar{v}_\\gamma) = \\frac{\\mathsf{Re}(v_\\gamma) - \\mu^L \\cdot \\mathsf{Im}(v_\\gamma)}{\\mathsf{Re}(v_\\gamma)^2 + \\mathsf{Im}(v_\\gamma)^2} \\cdot (\\bar{g} - \\bar{v}_\\gamma).</span></div>

    <p class="text-gray-300">Hence for large batches, the computational overhead introduced by the extension F(i) is negligible, essentially reducing the batching cost to that of computing  <span class="math">\\bar{g}</span> . For the same reason the effort of the verifier is reduced to essentially that of computing  <span class="math">\\bar{g}</span>  at the sample points from the query phase of the proximity test.</p>

    <p class="text-gray-300">We eventually are able to state the soundness error of the batch IOP of proximity. Its proof, which relies on the correlated agreement theorem for Reed-Solomon codes, is postponed to Appendix B.</p>

    <p class="text-gray-300"><strong>Theorem</strong> (Summary Theorem 6, Appendix B). If an adversary passes the batch IOP of proximity (Protocol 2) for  <span class="math">f_1, \\ldots, f_L \\in F^D</span>  and agreement parameter  <span class="math">\\alpha = \\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)</span> , for some  <span class="math">m \\geq 3</span> , with a probability larger than</p>

    <p class="text-gray-300"><span id="page-30-3"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_{PROX} = \\left(L - \\frac{2}{3}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\sqrt{\\rho^{-3}}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{(2 \\cdot m + 1) \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1) \\cdot r}{\\sqrt{\\rho^{-1}} \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\alpha^s,\\tag{38}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $\\rho^- = \\frac{N}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , then  </span>f_1, \\ldots, f_L<span class="math">  have correlated agreement to  </span>C_N(F, D)<span class="math">  on a set of density of at least  </span>\\alpha > \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 24. One would expect to see the rate  $\\rho = (N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in Equation (38). In fact, the soundness analysis in Appendix B.1 combines the correlated agreement theorem with respect to codes of different rates: The circle code with rate  </span>\\rho<span class="math">  for the batching step, coming from the space  </span>\\mathcal{L}_N(F)<span class="math"> , and the subcodes which stem from the FFT spaces  </span>\\mathcal{L}^{(j)}<span class="math">  as above, having slightly smaller rate  </span>\\rho^-<span class="math"> . For the sake of readability, we dominate  </span>1/\\sqrt{\\rho}<span class="math">  by  </span>1/\\sqrt{\\rho^-}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for standard FRI, we note that the protocol can be generalized to reduction steps of higher two-adic size, and the round-by-round soundness analysis from Appendix B is adapted accordingly.</p>

    <p class="text-gray-300">We would like to thank Eli Ben-Sasson, Dan Carmon, Alessandro Chiesa, Angus Gruen, Swastik Kopparty, and Elijah Riggs for helpful discussion and feedback. We also thank Liam Eagen and Jeroen Zuiddam for pointing out the work of [LX23], and Ariel Gabizon for pointing out typos. Special thanks to Jacqueline Nabaglo for finalizing the Babybear AVX2 code right in time for our benchmarks.</p>

    <h2 id="sec-23" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-31-8"></span>[AAB<sup>+</sup>20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. <em>IACR Trans. Symmetric Cryptol.</em>, 2020(3):1–45, 2020.</li>

      <li><span id="page-31-3"></span>[BG] Jeremy Bruestle and Paul Gafni. RISC Zero zkVM: scalable, transparent arguments of RISC-V integrity. https://www.risczero.com/proof-system-in-detail.pdf.</li>

      <li><span id="page-31-5"></span>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Recursive proof composition without a trusted setup. In <em>IACR ePrint Archive 2019/1021</em>, 2019. https://eprint.iacr.org/2019/1021.</li>

      <li><span id="page-31-6"></span>[BSBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In <em>ICALP 2018</em>, 2018. Full paper: https://eccc.weizmann.ac.il/report/2017/134/.</li>

      <li><span id="page-31-0"></span>[BSBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. In <em>IACR ePrint Archive 2018/046</em>, 2018. https://eprint.iacr.org/2018/046.</li>

      <li><span id="page-31-7"></span>[BSCI<sup>+</sup>20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for Reed-Solomon codes. In <em>FOCS 2020</em>, 2020. Full paper: https://eprint.iacr.org/2020/654.</li>

      <li><span id="page-31-1"></span>[BSCKL21] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. Elliptic Curve Fast Fourier Transform (ECFFT) Part I: Fast polynomial algorithms over all finite fields. In Electronic Colloquium on Compputational Complexity, volume TR21-103, 2021. https://eccc.weizmann.ac.il/report/2021/103/.</li>

      <li><span id="page-31-2"></span>[BSCKL22] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. Scalable and transparent proofs over all large fields, via elliptic curves (ECFFT part II). In <em>IACR ePrint Archive</em> 2022/1542, 2022. https://eprint.iacr.org/2022/1542.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-32-0"></span>[BSCR<sup>+</sup>19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Y. Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, volume 11476 of LNCS. Springer, 2019.</li>

      <li><span id="page-32-5"></span>[BSCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In TCC 2016, pages 31–60, 2016.</li>

      <li><span id="page-32-6"></span>[CHM<sup>+</sup>20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In EUROCRYPT 2020, volume 12105 of LNCS, 2020. Full paper: <https://eprint.iacr.org/2019/1047.pdf>.</li>

      <li><span id="page-32-1"></span>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In EUROCRYPT 2020, volume 12105 of LNCS, 2020. Full paper: <https://eprint.iacr.org/2019/1076.pdf>.</li>

      <li><span id="page-32-2"></span>[CT65] James W. Cooley and John W. Tukey. An algorithm for the machine calculation of complex Fourier series. In Mathematics of Computation, volume 19 (90), pages 297–301, 1965.</li>

      <li><span id="page-32-8"></span>[GK22] Ariel Gabizon and Dmitry Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of the table size. In IACR ePrint Archive 2022/1447, 2022. <https://eprint.iacr.org/2022/1447>.</li>

      <li><span id="page-32-14"></span>[GKL+23] Lorenzo Grassi, Dmitry Khovratovich, Reinhard Lüftenegger, Christian Rechberger, Markus Schofnegger, and Roman Walch. Monolith: Circuit-friendly hash functions with new nonlinear layers for fast and constant-time implementations. IACR Cryptol. ePrint Arch., page 1025, 2023.</li>

      <li><span id="page-32-13"></span>[GKR+21] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roz, and Markus Schofnegger. POSEIDON: A new hash function for zero-knowledge proof systems. In USENIX Security Symposium 2021, 2021.</li>

      <li><span id="page-32-4"></span>[GS99] Venkatesan Guruswami and Madhu Sudan. Improved decoding of Reed-Solomon and algebraicgeometry codes. In IEEE Trans. on Information Theory, volume 45(6), 1999.</li>

      <li><span id="page-32-10"></span>[GW20] Ariel Gabizon and Zachary J. Williamson. Plookup: A simplified polynomial protocol for lookup tables. In IACR ePrint Archive 2020/315, 2020. <a href="https://eprint.iacr.org/2020/315">https://eprint.iacr.org/2020/</a> <a href="https://eprint.iacr.org/2020/315">315</a>.</li>

      <li><span id="page-32-9"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical non-interactive arguments of knowledge. In IACR ePrint Archive 2019/953, 2019. <https://eprint.iacr.org/2019/953>.</li>

      <li><span id="page-32-11"></span>[Hab22a] Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. In IACR ePrint Archive 2022/1530, 2022. <https://eprint.iacr.org/2022/1530>.</li>

      <li><span id="page-32-15"></span>[Hab22b] Ulrich Haböck. A summary on the FRI low-degree test. In IACR ePrint Archive 2022/1216, 2022. <https://eprint.iacr.org/2022/1216>.</li>

      <li><span id="page-32-3"></span>[Hab24] Ulrich Haböck. A note on the G-FFT. In IACR ePrint Archive 2024/1036, 2024. <a href="https://eprint.iacr.org/2024/1036">https:</a> <a href="https://eprint.iacr.org/2024/1036">//eprint.iacr.org/2024/1036</a>.</li>

      <li><span id="page-32-7"></span>[HGdB21] Ulrich Haböck, Alberto Garoffolo, and Daniele di Benedetto. Darlin: Recursive proofs based on Marlin. In IACR ePrint Archive 2021/930, 2021. <https://eprint.iacr.org/2021/930>.</li>

      <li><span id="page-32-12"></span>[HK24] Ulrich Haböck and Al Kinde. A note on adding zero-knowledge to STARKs. In IACR ePrint Archive 2024/1037, 2024. <https://eprint.iacr.org/2024/1037>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-33-0"></span>[HLN23] Ulrich Haböck, Daniel Lubarov, and Jacqueline Nabaglo. Reed-Solomon Codes over the Circle Group. In IACR ePrint Archive 2023/82, 2023. <https://eprint.iacr.org/2023/824>.</li>

      <li><span id="page-33-10"></span>[HS24] Ulrich Haböck and Markus Schofnegger. Efficient MDS matrices from linear codes. In preparation, 2024.</li>

      <li><span id="page-33-5"></span>[LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. Novel polynomial basis and its application to Reed-Solomon erasure codes. In FOCS 2014, 2014.</li>

      <li><span id="page-33-7"></span>[LX23] Songsong Li and Chaoping Xing. Fast Fourier transform via automorphicsm groups of rational function fields. In arXiv:2310.14462, 2023. <https://arxiv.org/abs/2310.14462>.</li>

      <li><span id="page-33-8"></span>[PH23] Shahar Papini and Ulrich Haböck. Improving logarithmic derivative lookups using GKR. In IACR ePrint Archive 2023/1284, 2023. <https://eprint.iacr.org/2023/1284>.</li>

      <li><span id="page-33-2"></span>[Pola] Polygon Labs / Polygon Zero. Plonky2: Fast recursive arguments with PLONK and FRI. <https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf>.</li>

      <li><span id="page-33-6"></span>[Polb] Polygon Labs / Polygon Zero. Plonky3: A toolkit for implementing polynomial IOPs. <a href="https://github.com/Plonky3/Plonky3">https:</a> <a href="https://github.com/Plonky3/Plonky3">//github.com/Plonky3/Plonky3</a>.</li>

      <li><span id="page-33-3"></span>[Polc] Polyogon Labs. Polygon Hermez. <a href="https://github.com/orgs/0xPolygonHermez/repositories">https://github.com/orgs/0xPolygonHermez/</a> <a href="https://github.com/orgs/0xPolygonHermez/repositories">repositories</a>.</li>

      <li><span id="page-33-4"></span>[Pold] Polyogon Labs. Polygon Miden: A STARK-based virtual machine. <a href="https://github.com/maticnetwork/miden">https://github.com/</a> <a href="https://github.com/maticnetwork/miden">maticnetwork/miden</a>.</li>

      <li><span id="page-33-9"></span>[SAD20] Alan Szepieniec, Tomer Ashur, and Siemen Dhooghe. Rescue-Prime: a standard specification (SoK). IACR Cryptol. ePrint Arch., page 1143, 2020.</li>

      <li><span id="page-33-1"></span>[Sta23] StarkWare Team. ethSTARK documentation – version 1.2. In IACR ePrint Archive 2021/582, 2023. <https://eprint.iacr.org/2021/582>.</li>

    </ul>

    <h2 id="sec-24" class="text-2xl font-bold">A Correlated agreement</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we resume the correlated agreement theorem from [BSCI<sup>+</sup>20]. Although tighter statements hold in the unique decoding regime, we restrict ourselves to proximity parameters  <span class="math">\\theta</span>  from the interval  <span class="math">\\left(\\frac{1-\\rho}{2},1-\\sqrt{\\rho}\\right)</span>  as we aspire largest possible distances in our application. Given a Reed-Solomon code  <span class="math">\\mathsf{RS}_k[F,S]</span>  of rate  $\\rho=k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  over a finite field F with defining set S, the correlated agreement theorem states that, if a random linear combination of words from  </span>F^S$  happens to be close to the code just for a small fraction of randomnesses, then this is the case for all the involved words, since then they coincide with a respective code word over a joint agreement set of sufficiently large size. The theorem is of fundamental importance in the design of code-based proofs, since taking random linear combinations is a standard reduction technique.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To simplify notation, we shall call any polynomial  <span class="math">p \\in F[X]</span>  of  <span class="math">\\deg p \\leq k-1</span>  to belong to the code  <span class="math">\\mathsf{RS}_k[F,D]</span> , and we will not distinguish between the polynomial itself and the code word generated from it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-34-2"></span><strong>Theorem 4.</strong> (Correlated agreement theorem, full version of [BSCI<sup>+</sup>20], Theorem 6.2) Let  <span class="math">\\mathsf{RS}_k = \\mathsf{RS}_k[F,S]</span>  be the Reed-Solomon code over a a finite field F with defining set  <span class="math">S \\subseteq F</span>  and rate  $\\rho = k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Given a proximity parameter  </span>\\theta = 1 - \\sqrt{\\rho} \\cdot \\left(1 + \\frac{1}{2m}\\right)<span class="math"> , with  </span>m \\geq 3<span class="math"> , and words  </span>f_1, f_1, ..., f_L \\in F^S$  for which</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\lambda \\in F: d\\big(f_1 + \\lambda \\cdot f_2 + \\ldots + \\lambda^{L-1} \\cdot f_L, \\mathsf{RS}_k\\big) \\leq \\theta\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} > \\varepsilon,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span id="page-34-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon = (L-1) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\rho^{\\frac{3}{2}}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (39)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then there exist polynomials  <span class="math">p_1(X)</span> ,  <span class="math">p_2(X)</span> ,..., <span class="math">p_L(X)</span>  belonging to  <span class="math">\\mathsf{RS}_k</span> , and a set  <span class="math">A \\subseteq S</span>  of density  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge 1 - \\theta<span class="math">  on which  </span>f_1, \\ldots, f_L<span class="math">  jointly coincide with  </span>p_1, \\ldots, p_L$ , respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof of the correlated agreement theorem is an algebraic analysis of the Guruswami-Sudan list decoder over the rational function field K = F(Z). It uses the Polichuk-Spielmann lemma to "glue together" the outputs of the decoder for  <span class="math">f_1 + \\lambda \\cdot f_2 + \\ldots + \\lambda^{N-1} \\cdot f_N</span>  over the "small" field F by means of the decoder result for the word</p>

    <div class="my-4 text-center"><span class="math-block">f_1 + Z \\cdot f_2 + \\ldots + Z^{N-1} \\cdot f_N \\in K^D</span></div>

    <p class="text-gray-300">over the infinite field K: If for a noticeable fraction of  <span class="math">\\lambda</span> 's the distance to the Reed-Solomon code is  <span class="math">\\leq \\theta</span> , then the same holds over F(Z).</p>

    <p class="text-gray-300">In FRI the oracles are tested jointly across the rounds, and one wishes to control the fraction of "good points" (where a query would succeed) under each further folding step. For this purpose [BSCI<sup>+</sup>20] prove a refinement of the correlated agreement theorem, which works with weighted Hamming distances. Given a vector of weights  <span class="math">\\mu: S \\longrightarrow [0,1]</span>  over S, we define the (relative) weight of subset  <span class="math">A \\subset S</span>  as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mu(A) := \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\sum_{x \\in A} \\mu(x).$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A function  <span class="math">f \\in F^S</span>  is said to have (relative)  <span class="math">\\mu</span> -agreement of at least  <span class="math">\\alpha</span>  with another function  <span class="math">g \\in F^S</span> , if</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{agree}_{\\mu}(f,g) := \\mu\\left(\\left\\{x \\in S \\ : \\ f(x) = g(x)\\right\\}\\right) &gt; \\alpha,</span></div>

    <p class="text-gray-300">and we write</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{agree}_{\\mu}(f,\\mathsf{RS}_k) &gt; \\alpha,</span></div>

    <p class="text-gray-300"><span id="page-34-3"></span>if there exists a  <span class="math">p \\in \\mathsf{RS}_k[F,S]</span>  for which  <span class="math">agree_\\mu(f,p) &gt; \\alpha</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> (Weighted correlated agreement theorem, full version of [BSCI<sup>+</sup>20], Theorem 7.2) Let  <span class="math">\\theta \\in \\left(\\frac{1-\\rho}{2}, 1-\\sqrt{\\rho}\\right)</span> , where  <span class="math">\\theta = 1-\\sqrt{\\rho} \\cdot \\left(1+\\frac{1}{2m}\\right)</span> , for some integer  <span class="math">m \\geq 3</span> , and assume that  <span class="math">\\mu: S \\longrightarrow [0,1]</span>  is a vector of weights over S with common denominator  <span class="math">M \\geq 1</span> , i.e. for all x in S</p>

    <div class="my-4 text-center"><span class="math-block">\\mu(\\{x\\}) = \\frac{m_x}{M},</span></div>

    <p class="text-gray-300">for an integer value  <span class="math">m_x \\in [0, M]</span> . Suppose that for  <span class="math">f_1, f_2, \\ldots, f_L \\in F^S</span> ,</p>

    <p class="text-gray-300"><span id="page-35-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\lambda: agree_{\\mu}(f_1 + \\lambda \\cdot f_2 + \\ldots + \\lambda^{L-1} \\cdot f_L, \\mathsf{RS}_k) > \\alpha\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} > \\max\\left(\\varepsilon, (L-1) \\cdot \\frac{M \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\frac{2m+1}{\\sqrt{\\rho}}\\right), \\quad (40)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with  <span class="math">\\varepsilon</span>  as in (39). Then there exist polynomials  <span class="math">p_0(X)</span> ,  <span class="math">p_1(X)</span> , ...,  <span class="math">p_{L-1}(X)</span>  from  <span class="math">\\mathsf{RS}_k[F,S]</span> , and a set A of relative weight  <span class="math">\\mu(A) &gt; \\alpha</span>  on which  <span class="math">f_i</span>  coincides with  <span class="math">p_i</span>  for all  <span class="math">i = 0, \\ldots, L-1</span> .</p>

    <p class="text-gray-300">Both Theorem 4 and Theorem 5 do not make any assumptions on the form of the evaluation domain S and hence, by Theorem 1, they also apply to circle codes (Definition 3).</p>

    <h2 id="sec-25" class="text-2xl font-bold">B Soundness in the oracle model</h2>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}_p</span>  be a CFFT-friendly prime. An interactive oracle proof over the circle curve  <span class="math">C(\\mathbb{F}_p)</span>  (in short, a circle IOP) is an interactive protocol, in which one party, the prover, wants to convince a second party, the verifier, upon that given words  <span class="math">f_1, \\ldots, f_w \\in \\mathbb{F}_p^D</span>  over some domain  <span class="math">D \\subseteq C(\\mathbb{F}_p)</span>  satisfy certain properties. These properties are of the form</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\alpha} = \\left\\{ \\vec{f} = (f_1, \\dots, f_w) \\in (\\mathbb{F}_p^D)^w \\ : \\ \\exists \\vec{p} = (p_1, \\dots, p_w) \\in \\mathcal{L}_R \\ \\land \\ \\mathsf{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha \\in [0,1]</span>  is an agreement parameter, and  <span class="math">\\mathcal{L}_R \\subseteq \\left(F[X,Y]^{\\leq d}\\right)^w</span>  is a set of low-degree polynomials defined by certain algebraic relations. (That is,  <span class="math">\\mathcal{L}_R</span>  is an algebraic set.) In each round of the oracle proof, the verifier sends a public random coin (a <em>challenge</em>) and the prover responds with a new set of words, over D or another specified domain of the circle, having values in  <span class="math">\\mathbb{F}_p</span> , or in a specified finite extension of it. As an information theoretic model for an ideal vector commitment scheme, the words from the prover are not sent in plain but provided to the verifier via a secure and trusted channel, the <em>oracle</em>. Upon receiving, the verifier is merely given <em>oracle access</em> to the words for a specified (and typically small) number of queries, asking for the word entry at an arbitrary (typically random) position, immediately or at any later step of the protocol. After a certain number of rounds, the verifier accepts or rejects, based on the answers of the oracle queries and the random challenge. In our IOPs the queries to the oracle are deferred to a separate query stage at the end of the protocol.</p>

    <p class="text-gray-300">The discussed circle IOPs follow the common design principle of probabilistic proofs: They form a chain of probabilistic reductions stepwise simplifying the assertion to be proven,</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\alpha} = R_{\\alpha}^{(0)} \\xrightarrow{\\rho_1} R_{\\alpha}^{(1)} \\xrightarrow{\\rho_2} \\dots \\xrightarrow{\\rho_r} R_{\\alpha}^{(r)},</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\rho_1, \\ldots, \\rho_r</span>  are the verifier challenges, and each round relation  $R_{\\alpha}^{(k)} = R_{\\alpha}^{(k)}(\\mathfrak{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq k})<span class="math">  is a relation on the transcript  </span>\\mathfrak{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq k}<span class="math">  of previous prover and verifier messages, being of a similar form as above. (That is, the transcript is proximate to a specified algebraic set of low-degree polynomials, in the correlated agreement sense and with the same agreement parameter  </span>\\alpha<span class="math"> .) Each reduction  </span>R_{\\alpha}^{(k-1)} \\longrightarrow R_{\\alpha}^{(k)}<span class="math">  has its own soundness error  </span>\\varepsilon^{(k)} \\in (0,1)<span class="math"> , meaning that whenever the &quot;current&quot; transcript from a prover  </span>P^*<span class="math">  does not belong to the relation  </span>R_{\\alpha}^{(k-1)}<span class="math">  then, except for a set of &quot;bad&quot; randomnesses  </span>\\rho_k<span class="math">  of probability at most  </span>\\varepsilon^{(k)}<span class="math"> , the prover is not able to respond with a next round message so that the extended transcript is in  </span>R_{\\alpha}^{(k)}$ . The soundness error of the entire protocol is then dominated by the sum of the round-wise soundness errors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We omit a discussion of asymptotic security and restrict our results to the concrete soundness errors. This is justified by that in our application, it is natural <em>not</em> to step beyond a fixed CFFT-friendly field  <span class="math">\\mathbb{F}_p</span>  (such as the Mersenne field M31), making an asymptotic analysis with respect to the relation to be proven useless.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">B.1 Soundness of the IOP of proximity to circle codes</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The soundness analysis of circle FRI (Protocol 1 and more generally Protocol 2) is essentially a translation of the one of standard FRI (Section 8.2.1. in the full version of [BSCI<sup>+</sup>20]) to the folding cascade of the circle FFT. Recall that, in the low-degree test for a single word  <span class="math">f \\in F^D</span>  over a domain of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^B \\cdot N<span class="math"> , where  </span>N = 2^n<span class="math"> , the prover provides the correction-factor  </span>\\lambda \\in F<span class="math">  so that  </span>f - \\lambda \\cdot v_D$  is in the FFT-space</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}^{(0)} := \\left\\{ p_0(X) + p_1(X) \\cdot Y \\in F[X, Y] : \\deg p_i(X) &lt; 2^{n-1} \\right\\},\\,</span></div>

    <p class="text-gray-300">which under repeated folding along the chain of projections</p>

    <div class="my-4 text-center"><span class="math-block">S_0 \\xrightarrow{\\pi_1} S_1 \\xrightarrow{\\pi_2} S_2 \\xrightarrow{\\pi_3} \\dots \\xrightarrow{\\pi_r} S_r,</span></div>

    <p class="text-gray-300">is turned into polynomials from</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}^{(j)} := \\{ p(X) \\in F[X] : \\deg p(X) &lt; 2^{n-j} \\}, \\tag{41}</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\leq j \\leq r</span> , where the number of rounds  <span class="math">r \\leq n</span> . We consider the quotient map  <span class="math">\\pi_1 = \\phi_J</span>  as the projection onto the x-axis,  <span class="math">\\pi_1 = \\pi_x</span> , and hence  <span class="math">S_1, \\ldots, S_r</span>  as univariate domains. The codes corresponding to the function spaces  <span class="math">\\mathcal{L}^{(j)}</span> , except for j = 0, are therefore ordinary Reed-Solomon codes</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{C}^{(j)} := \\mathsf{RS}_{2^{n-j}}(F, S_j),\\tag{42}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for  <span class="math">1 \\le j \\le r</span> , having throughout the same rate  $\\rho^- := 2^{n-j}/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{-B}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fix an agreement parameter  <span class="math">\\alpha \\in (0,1)</span> . Given  <span class="math">g_0 \\in F^{S_0}</span> , we say that a prover  <span class="math">P^*</span>  succeeds the commitment phase, if it is able to respond with round oracles  <span class="math">g_1, g_2, \\ldots, g_r</span>  on the respective verifier challenges  <span class="math">\\lambda_1, \\ldots, \\lambda_r</span> , which  <span class="math">\\alpha</span> -consistently fold down to a codeword from  <span class="math">\\mathcal{C}^{(r)}</span> . That is, there exists  <span class="math">p_r \\in \\mathcal{C}^{(r)}</span>  for which</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{P \\in S_0 : \\text{ all folding checks hold } \\wedge g_r \\circ \\pi_r \\circ \\ldots \\circ \\pi_1(P) = p_r \\circ \\pi_r \\circ \\ldots \\circ \\pi_1(P)\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} > \\alpha.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Any such transcript (or more generally any set of oracles)  <span class="math">(g_0, \\lambda_1, g_1, \\dots, \\lambda_r, g_r)</span>  will be called  <span class="math">\\alpha</span> -good for the code  <span class="math">\\mathcal{C}^{(r)}</span> . (We demand proximity of  <span class="math">g_r</span>  to  <span class="math">\\mathcal{C}^{(r)}</span>  instead of being a member of it for proof reasons. In the protocol, the verifier rejects any final  <span class="math">g_r</span>  which is not equal in full length to a Reed-Solomon codeword.)</p>

    <p class="text-gray-300">The soundness error of the commitment phase goes along the following lines. Starting with the relation</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\alpha}^{(0)}:=\\{g_0\\,:\\,\\exists p_0\\in\\mathcal{C}_N(F,D)\\,\\wedge\\,\\operatorname{agree}(g_0,p_0)&gt;\\alpha\\},</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">each round of the commit phase,  <span class="math">1 \\leq j \\leq r</span> , is a randomized reduction from a transcript  $\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq j-1} = (g_0, \\lambda_1, g_1, \\dots, \\lambda_{j-1}, g_{j-1})<span class="math">  being member of the relation  </span>R_{\\alpha}^{(j-1)}<span class="math">  to that its continuation  </span>\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq j} = (\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq j-1}, \\lambda_j, g_j)$  being a member of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">R_{\\alpha}^{(j)} := \\left\\{ (g_0, \\lambda_1, g_1, \\dots, \\lambda_j, g_j) : (g_0, \\lambda_1, g_1, \\dots, \\lambda_j, g_j) \\text{ is } \\alpha\\text{-good for } \\mathcal{C}^{(j)} \\right\\}.</span></div>

    <p class="text-gray-300"><span id="page-36-1"></span>The error of such a reduction step will be given by the weighted correlated agreement theorem (Theorem 5), and overall error is dominated by the sum of the round-wise errors.</p>

    <p class="text-gray-300"><strong>Lemma 13</strong> (Soundness commit phase). Take an agreement parameter  <span class="math">\\alpha = \\left(1 + \\frac{1}{2 \\cdot m}\\right) \\cdot \\sqrt{\\rho}</span> , where  <span class="math">m \\geq 3</span> . Suppose that a (possibly computationally unbounded) algorithm  <span class="math">P^*</span>  succeeds the commitment phase of  <span class="math">r \\geq 1</span>  rounds with probability larger than</p>

    <div class="my-4 text-center"><span class="math-block">\\varepsilon_C = \\varepsilon_1 + \\ldots + \\varepsilon_r,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $\\varepsilon_j := \\varepsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, M_j, \\rho^-, m)<span class="math">  is the soundness error in Theorem 5 for a Reed-Solomon code with rate  </span>\\rho^- = 2^{-B}<span class="math">  and evaluation domain size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>M_j =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{j-1}<span class="math">  is the common weight denominator M, and m is the multiplicity parameter. Then  </span>g_0<span class="math">  coincides with a polynomial from  </span>\\mathcal{L}^{(0)}<span class="math">  over a set of density strictly larger than  </span>\\alpha$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> We prove the Lemma by induction in r the number of rounds,  <span class="math">1 \\le r \\le n</span> . We start by proving the base case r = 1. If with probability greater than  <span class="math">\\varepsilon_1 = \\varepsilon(S_1, M_1, \\rho, m)</span> , with  <span class="math">M_1</span> ,  <span class="math">\\rho</span>  and m as above, the prover is able to answer with  <span class="math">g_1</span>  so that  <span class="math">(g_0, \\lambda_1, g_1)</span>  is  <span class="math">\\alpha</span> -good for the Reed-Solomon code  <span class="math">\\mathcal{C}^{(1)}</span> , then in particular</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\Bigl[\\lambda_1 \\ : \\ \\mathsf{agree}\\left(g_{0,0} + \\lambda_1 \\cdot g_{0,1}, \\mathcal{C}^{(1)}\\right) &gt; \\alpha\\Bigr] &gt; \\varepsilon_1.</span></div>

    <p class="text-gray-300">By Theorem 5 (or, in this case also Theorem 4) both  <span class="math">g_{0,0}</span>  and  <span class="math">g_{0,1}</span>  jointly agree with corresponding polynomials  <span class="math">p_0(X), p_1(X)</span>  of degree  <span class="math">&lt; 2^{n-1}</span> , over a set  <span class="math">A \\subseteq S_1</span>  of density  <span class="math">&gt; \\alpha</span> . The preimage  <span class="math">\\pi_1^{-1}(A)</span>  has density  <span class="math">&gt; \\alpha</span> , and over this set the word  <span class="math">g_0</span>  agrees with the polynomial  <span class="math">p_0(X) + Y \\cdot p_1(X)</span> , which is from the FFT space  <span class="math">\\mathcal{L}^{(0)}(F)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume that the Lemma holds for r, where  <span class="math">1 \\le r &lt; n</span> , and that a prover  <span class="math">P^*</span>  succeeds the commitment phase for (r+1) rounds with probability greater than  <span class="math">(\\varepsilon_1 + \\ldots + \\varepsilon_r) + \\varepsilon_{r+1}</span> . Then the set  <span class="math">\\mathfrak T</span>  of transcripts  $\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_r = (\\lambda_1, g_1, \\ldots, \\lambda_r, g_r)<span class="math">  for which the conditional success probability of  </span>P^*<span class="math">  is greater than  </span>\\varepsilon_{r+1}$ , and hence in particular</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\Big[\\lambda_{r+1} : (\\lambda_1, g_1, \\dots, \\lambda_r, g_r, \\lambda_{r+1}, g_{r,0} + \\lambda_{r+1} \\cdot g_{r,1}) \\text{ is } \\alpha\\text{-good for } \\mathcal{C}^{(r+1)}\\Big] &gt; \\varepsilon_{r+1},</span></div>

    <p class="text-gray-300">has probability  <span class="math">\\Pr[\\mathfrak{T}] &gt; \\varepsilon_1 + \\ldots + \\varepsilon_r</span> . Since consistency of a folding step is a property of the fiber of the projection (the even and odd functions are constant over fibers), the latter probability is equal to</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\lambda_{j+1} : \\operatorname{agree}_{\\nu}\\left(g_{r,0} + \\lambda_{j+1} \\cdot g_{r,1}, \\mathcal{C}^{(r+1)}\\right) > \\alpha\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with  $\\nu = \\nu_{\\mathsf{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_r}<span class="math">  being the &quot;average consistency&quot; of the transcript  </span>\\mathsf{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_r<span class="math">  over a fiber of  </span>\\pi_{r+1}$ , defined by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\nu(y) := \\frac{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{P \\in (\\pi_{r+1} \\circ \\ldots \\circ \\pi_1)^{-1}(y) \\ : \\ \\text{all folding checks hold for } \\mathsf{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_r\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\pi_{r+1} \\circ \\ldots \\circ \\pi_1)^{-1}(y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">for  <span class="math">y \\in S_{r+1}</span> . Notice that the numerator of  <span class="math">\\nu</span>  is constant over fibers of  <span class="math">\\pi_1</span> , hence the weights have common denominator  <span class="math">M_{r+1} = 2^r</span> . By our assumption the conditional success probability is greater than  <span class="math">\\varepsilon_{r+1} = \\varepsilon(S_{r+1}, M_{r+1}, \\rho, m)</span> , and we conclude from Theorem 5 that both  <span class="math">g_{r,0}</span>  and  <span class="math">g_{r,1}</span>  jointly agree with the values of respective polynomials  <span class="math">p_0, p_1 \\in \\mathcal{L}^{(r+1)}</span>  over a set  <span class="math">A_{r+1} \\subseteq S_{r+1}</span>  of relative weight  <span class="math">\\nu(A_{r+1}) &gt; \\alpha</span> . (Recall that  <span class="math">\\mathcal{L}^{(r+1)}</span>  is the space of polynomials in x of degree  <span class="math">&lt; 2^{n-(r+1)}</span> .) Over the preimage  <span class="math">A_r = \\pi_{r+1}^{-1}(A_{r+1})</span> , the word  <span class="math">g_r</span>  coincides with the values of  <span class="math">p_0(\\pi_{r+1}(X)) + X \\cdot p_1(\\pi_{r+1}(X)) \\in \\mathcal{L}^{(r)}</span> , and the set of good  <span class="math">P \\in (\\pi_r \\circ \\ldots \\circ \\pi_1)^{-1}(A_r)</span> , on which all folding checks against  <span class="math">(g_1, \\ldots, g_r)</span>  hold, is of density</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{P \\in (\\pi_r \\circ \\ldots \\circ \\pi_1)^{-1}(A_r) \\ : \\ \\text{all folding checks hold for } \\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_r\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in A_{r+1}} \\nu(y) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\pi_{r+1} \\circ \\ldots \\circ \\pi_1)^{-1}(y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ &= \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{r+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_{y \\in A_{r+1}} \\nu(y) = \\operatorname{agree}_{\\nu}(g_{r+1}, \\mathcal{C}^{(r)}) > \\alpha. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In other words, the restricted trace  <span class="math">(\\lambda_1, g_1, \\ldots, \\lambda_r, g_r)</span>  is  <span class="math">\\alpha</span> -good for  <span class="math">\\mathcal{C}^{(r)}</span> . Since the probability of  <span class="math">P^*</span>  producing such a trace is greater than  <span class="math">\\varepsilon_1 + \\ldots + \\varepsilon_r</span> , we conclude from the induction hypothesis that  <span class="math">g_0</span>  has  <span class="math">\\alpha</span> -agreement with  <span class="math">\\mathcal{C}^{(0)}</span> . This completes the proof of the Lemma.</p>

    <p class="text-gray-300">The batch proof of proximity has an additional preceding batching step, and we define a successful pass of the commit phase in a similar manner, taking into account the folding check of the batching round.</p>

    <p class="text-gray-300"><span id="page-38-1"></span><strong>Lemma 14</strong> (Soundness error commit phase, batch FRI). Take an agreement parameter  <span class="math">\\alpha = \\left(1 + \\frac{1}{2 \\cdot m}\\right) \\cdot \\sqrt{\\rho}</span> , where  <span class="math">m \\geq 3</span> . Suppose that a (possibly computationally unbounded) algorithm  <span class="math">P^*</span>  succeeds the commitment phase of batch circle FRI (Protocol 2) with  <span class="math">r \\geq 1</span>  rounds, with probability larger than  <span class="math">\\varepsilon_C = \\varepsilon_0 + \\varepsilon_1 + \\ldots + \\varepsilon_r</span> , where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $-\\varepsilon_0 := \\varepsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, L, \\rho, m)<span class="math">  is the soundness error in Theorem 4 for a Reed-Solomon code with rate  </span>\\rho = 2^{-B} + 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and evaluation domain size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , batch size L, and m as the multiplicity parameter.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then  <span class="math">(f_1, \\ldots, f_L)</span>  has joint  <span class="math">\\alpha</span> -agreement with the circle code  <span class="math">\\mathcal{C}_N(F, S_0)</span> . That is, there exist polynomials  <span class="math">p_1(X,Y),\\ldots,p_L(X,Y)</span>  of total degree  <span class="math">\\leq N/2</span> , which coincide with the respective words  <span class="math">f_1,\\ldots,f_L</span>  on a set A of density  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> \\alpha$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> Including round j=0 for the batching step into the notion of  <span class="math">\\alpha</span> -goodness of a transcript  <span class="math">\\mathsf{tr}=(\\lambda_0,g_0,\\lambda_1,g_1,\\ldots,\\lambda_r,g_r)</span> , the proof is almost identical to that of Lemma 13. We hence only point out the key differences.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The base case r=0 corresponds to doing the batching step only, and uses the correlated agreement theorem with respect to the full circle code  <span class="math">C_N(F,D)</span>  of rate  $\\rho=(N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{-B}+1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For the other cases  </span>1 \\leq r < n<span class="math"> , the folding step over  </span>S_{r+1}<span class="math">  refers to the Reed-Solomon of two-adic rate  </span>\\rho^-=2^{-B}<span class="math"> , but the consistency measure  </span>\\nu<span class="math">  of the transcript  </span>\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\leq r}=(\\lambda_0,g_0,\\lambda_1,g_1,\\ldots,\\lambda_r,g_r)<span class="math">  now has common denominator  </span>M_r=2^{-r}$ , since no invariance of the numerator is present.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The soundness error of the query phase is the probability that  <span class="math">s \\geq 1</span>  queries fail to detect a transcript  <span class="math">(\\lambda_0, g_0, \\lambda_1, g_1, \\dots, \\lambda_r, g_r)</span>  with a consistency set  <span class="math">A \\subseteq S_0</span>  of only at most density  <span class="math">\\alpha</span> . Since the samples are uniformly and independently drawn from  <span class="math">S_0</span> , that soundness error is</p>

    <p class="text-gray-300"><span class="math-block">\\varepsilon_Q = \\alpha^s</span> .</p>

    <p class="text-gray-300">Combining the soundness error of the commitment phase with the soundness error of the query phase eventually leads the soundness error as stated in Section 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-38-0"></span><strong>Theorem 6</strong> (Soundness batch FRI). Given oracles for  <span class="math">f_1, \\ldots, f_L</span>  from  <span class="math">F^D</span>  over a standard position coset D of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{B+n}<span class="math"> , where  </span>B, n \\ge 1<span class="math"> , and suppose a prover  </span>P^*<span class="math">  passes batch circle FRI (Protocol 2) with  </span>0 \\le r \\le n<span class="math">  rounds,  </span>s \\ge 1<span class="math">  queries, and agreement parameter  </span>\\alpha = \\left(1 + \\frac{1}{2 \\cdot m}\\right) \\cdot \\sqrt{\\rho}<span class="math"> , where  </span>m \\ge 3$ , with a probability larger than</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math-block">\\varepsilon = \\varepsilon_C + \\varepsilon_O</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\varepsilon_C</span>  is as in Lemma 14 and  <span class="math">\\varepsilon_Q</span>  as above. Then there are polynomials  <span class="math">p_1(X,Y), \\ldots, p_L(X,Y)</span>  of total degree  <span class="math">\\leq N/2</span>  which agree with  <span class="math">f_1, \\ldots, f_L</span>  on a joint set A of density  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> \\alpha$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 25.</strong> Taking the correlated agreement decoder from Proposition 7 yields such claimed polynomials within strictly bounded polynomial time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose that a prover  <span class="math">P^*</span>  passes batch circle FRI (Protocol 2) for agreement parameter  <span class="math">\\alpha = (1+1/(2m)) \\cdot \\sqrt{\\rho}</span>  with a probability greater than  <span class="math">\\varepsilon_C + \\varepsilon_Q</span>  as specified above. Then  <span class="math">\\mathfrak{T}</span>  the set of transcripts  $\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C = (\\lambda_0, g_0, \\ldots, \\lambda_r, g_r)<span class="math">  of the commitment phase, for which the conditional success probability of  </span>P^*<span class="math">  is greater than  </span>\\varepsilon_Q<span class="math"> , must be of probability  </span>\\Pr[\\mathfrak{T}] > \\varepsilon_C<span class="math"> . Since  </span>g_r \\in \\mathcal{C}^{(r)}<span class="math">  and the conditional probability is greater than  </span>\\varepsilon_Q = \\alpha^s<span class="math"> , we know that  </span>\\operatorname{tr}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C<span class="math">  must be  </span>\\alpha<span class="math"> -good, and from  </span>\\Pr[\\mathfrak{T}] > \\varepsilon_C<span class="math">  we conclude by Lemma 14 that  </span>(f_1, \\ldots, f_L)<span class="math">  has joint  </span>\\alpha<span class="math"> -agreement with the circle code  </span>\\mathcal{C}_N(F, S_0)<span class="math"> . This proves that the soundness error  </span>\\varepsilon<span class="math">  of batch circle FRI is bounded by  </span>\\varepsilon_C + \\varepsilon_Q$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Remark 26.</strong> The soundness error bound as stated in Section 6 is derived from Theorem 6 as follows. Taking the sum as upper bound for the max in Equation 40, we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\varepsilon_C &\\leq (L-1) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot \\rho^{3/2}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\sum_{j=1}^r \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot (\\rho^-)^{3/2}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + (L_j - 1) \\cdot \\frac{M_j \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\frac{2 \\cdot m + 1}{\\sqrt{\\rho^-}} \\\\ &< \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot (\\rho^-)^{3/2}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\left(L - 1 + \\sum_{j=1}^r \\frac{1}{2^{2j}}\\right) + r \\cdot \\frac{2 \\cdot m + 1}{\\sqrt{\\rho^-}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\\\ &< \\left(L - \\frac{2}{3}\\right) \\cdot \\frac{\\left(m + \\frac{1}{2}\\right)^7}{3 \\cdot (\\rho^-)^{3/2}} \\cdot \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{2 \\cdot m + 1}{\\sqrt{\\rho^-}} \\cdot \\frac{r \\cdot (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Together with  <span class="math">\\varepsilon_Q = \\alpha^s</span>  and taking  <span class="math">\\theta = 1 - \\alpha</span> , we arrive at the claimed soundness error bound.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">B.2 Soundness of the IOP for AIR</h3>

    <p class="text-gray-300">The entire section takes the same assumptions as used in Section 5. That is, p is CFFT-friendly for sufficiently large orders so that the circle curve  <span class="math">C(\\mathbb{F}_p)</span>  is large enough to host the trace domain H and the evaluation domain D, both standard position cosets of size  <span class="math">N=2^n</span>  and  <span class="math">M=2^B\\cdot N</span> , where  <span class="math">B\\geq 1</span> . We say that a collection of low-degree polynomials  <span class="math">p_1,\\ldots,p_w\\in \\mathbb{F}_p[X,Y]/(X^2+Y^2-1)</span>  a solution of the AIR (with w columns of length  <span class="math">N=2^n</span> ) if each of the  <span class="math">C\\geq 1</span>  polynomial constraints</p>

    <p class="text-gray-300"><span id="page-39-1"></span> <span class="math-block">P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0,</span>  (43)</p>

    <p class="text-gray-300">for  <span class="math">1 \\leq i \\leq C</span> , is satisfied over the trace domain H. (Here, T is the rotation by a generator of H.) The selector polynomials  <span class="math">s_i \\in \\mathcal{L}_N(\\mathbb{F}_p)</span>  are combinations of the ones described in Section 5.1, expressive enough to cover periodic constraints and their boundary conditions. The degree of the algebraic intermediate representation,</p>

    <div class="my-4 text-center"><span class="math-block">d = \\max_{i} \\deg P_i,</span></div>

    <p class="text-gray-300">is such that there exist sufficiently many twin-cosets of the size of H to determine the polynomial in (43) by means of the circle FFT.</p>

    <p class="text-gray-300">The parameter setup of the circle STARK for the specific AIR over  <span class="math">\\mathbb{F}_p</span>  is as follows. Given the security parameter  <span class="math">\\mathfrak{l} \\in \\mathbb{N}</span> , one chooses the wished multiplicity parameter m for the proximity test to  <span class="math">\\mathcal{C} = \\mathcal{C}_N(F, D)</span> ,</p>

    <p class="text-gray-300"><span class="math-block">3 \\le m \\le N/2</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and determines the number of samples  <span class="math">s \\geq 1</span>  and the degree of the finite extension F of  <span class="math">\\mathbb{F}_p</span> , so that the expression on the right hand side in Equation (47) (i.e. the soundness error) is bounded by  <span class="math">2^{-\\mathfrak{l}}</span> . (The concrete choice of the multiplicity parameter m is a trade off between proof size and efficiency.) The upper bound on m is to assure that the guaranteed agreement to the circle code  <span class="math">\\mathcal{C}</span>  of rate  $\\rho = (N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is not too close to its list-decodability bound  </span>\\sqrt{\\rho}$ , that is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\alpha = \\left(1 + \\frac{1}{2m}\\right) \\cdot \\sqrt{\\rho} &gt; \\sqrt{\\rho^+},\\tag{44}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with  $\\rho^+ = (N+3)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In particular there is an integer  </span>m^+$  so that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\ge \\left(1 + \\frac{1}{2m^+}\\right) \\cdot \\sqrt{\\rho^+},\\tag{45}</span></div>

    <p class="text-gray-300"><span id="page-39-2"></span>the smallest such is the one to be used in Equation (47). This slightly larger agreement set size is needed in the soundness proof to assure that the non-quotiented words are within list-decodable distance to the slightly larger code  <span class="math">C_{N^+}(F,D)</span> , with  <span class="math">N^+=N+2</span> .</p>

    <p class="text-gray-300"><strong>Protocol 3</strong> (Circle IOP for AIR). Let  <span class="math">p_1(X,Y), \\ldots, p_w(X,Y) \\in \\mathbb{F}_p[X,Y]^{\\leq N/2}</span>  be polynomials of degree deg  <span class="math">p_i \\leq N/2</span>  satisfying the AIR constraints (43) over the trace domain H, for every  <span class="math">i = 1, \\ldots, C</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>0. The prover sets up the domain evaluation oracles  <span class="math">[p_1], \\ldots, [p_w]</span>  for the values of  <span class="math">p_1(X, Y), \\ldots, p_w(X, Y)</span>  over D, and sends them to the verifier.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. Upon receiving a randomness  <span class="math">\\beta \\leftarrow \\$$  F from the verifier, the prover computes the domain quotient  </span>q_{\\beta}(X,Y) \\in F[X,Y]<span class="math">  of degree  </span>\\leq (d-1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2$  satisfying the identity</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^{C} \\beta^{i-1} \\cdot P_i(s_i, p_1, \\dots, p_w, (p_1 \\circ T), \\dots, (p_w \\circ T)) = q_\\beta \\cdot v_H,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and decomposes it into segment polynomials  <span class="math">q_{\\beta,j}(X,Y) \\in F[X,Y]</span> ,  <span class="math">j=1,\\ldots,d-1</span> , each of degree  $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math"> , and the dimension-gap scalar  </span>\\lambda \\in F<span class="math"> , with respect to a union of twin-cosets  </span>\\bar{H} = \\bigcup_{j=1}^{d-1} H_j<span class="math">  having overall size  </span>(d-1) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . (See Section 5.3 for details on this decomposition). It sends the oracles</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">[q_{\\beta,1}],\\ldots,[q_{\\beta,d-1}]</span></div>

    <p class="text-gray-300">for their values over D, and  <span class="math">\\lambda</span>  to the verifier. The overall identity to be proven is therefore</p>

    <p class="text-gray-300"><span id="page-40-0"></span> <span class="math-block">\\sum_{i=1}^{C} \\beta^{i-1} \\cdot P_i(s_i, p_1, \\dots, p_w, (p_1 \\circ T), \\dots, (p_w \\circ T)) = v_H \\cdot \\left(\\lambda \\cdot v_{\\bar{H}} + \\sum_{j=1}^{d-1} \\frac{v_{\\bar{H}}}{v_{H_j}} \\cdot q_{\\beta, j}\\right). \\tag{46}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. The verifier samples a random DEEP query, i.e. a random point  <span class="math">\\gamma \\leftarrow C(F) \\setminus (D \\cup H)</span>  drawn uniformly from the circle curve over the extension field F, and sends it to the prover. The prover answers with the evaluation claims  <span class="math">(\\gamma, v_{i,1})</span> ,  <span class="math">(T(\\gamma), v_{i,2})</span> , i = 1, ..., w, for the witness polynomials  <span class="math">p_i(X, Y)</span> , and  <span class="math">(\\gamma, v_j)</span> , j = 1, ..., d-1, for the segment polynomials  <span class="math">q_{\\beta,j}(X, Y)</span> .</li>

      <li>3. Both prover and verifier engage in the batch circle FRI (Protocol 2) for the real and imaginary parts of the DEEP quotients defined in Proposition 4,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathit{Re/Im}\\left(\\frac{p_i-v_{i,0}}{v_{\\gamma}}\\right), \\mathit{Re/Im}\\left(\\frac{p_i-v_{i,1}}{v_{T(\\gamma)}}\\right)</span></div>

    <p class="text-gray-300">for each i = 1, ..., w, and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathit{Re/Im}\\left(\\frac{q_{\\beta,1}-v_1}{v_\\gamma}\\right),\\ldots,\\mathit{Re/Im}\\left(\\frac{q_{\\beta,d-1}-v_{d-1}}{v_\\gamma}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is a joint proximity test to the circle code  <span class="math">C_N(F,D)</span> , where N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. (Recall Remark 23 on efficient batching of the DEEP quotients.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If circle FRI passes, and if the evaluation claims satisfy the overall identity (46) at  <span class="math">(X,Y) = \\gamma</span> , the verifier accepts. (Otherwise, it rejects.)</p>

    <p class="text-gray-300"><strong>Remark 27.</strong> In regards to query phase of batch circle FRI, it is assumed that the verifier aborts if one of the values responded by the oracle is not from the specified field. This is necessary to conclude a solution over  <span class="math">\\mathbb{F}_p</span>  and not only the extension field F.</p>

    <p class="text-gray-300">We finally show the concrete soundness error of Protocol 3 in the oracle model. The proof is almost identical to that for the univariate case in [Hab22b], with minor adaptions to the circle setting. Round 1 reduces the initial relation, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\alpha}^{(0)} = \\left\\{ \\vec{f} = (f_1, \\dots, f_w) \\in (\\mathbb{F}_p^D)^w \\ : \\exists \\vec{p} = (p_1, \\dots, p_w) \\in \\mathcal{L}_{N^+}(\\mathbb{F}_p)^w \\ \\land \\ \\mathsf{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_{i=1}^{C} P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0 \\text{ over } H</span></div>

    <p class="text-gray-300">by means of the verifier challenge  <span class="math">\\beta</span>  to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} R_{\\alpha}^{(1)} &amp;= \\Big\\{ \\vec{f} = (f_1, \\dots, f_{w+d-1}) \\in (\\mathbb{F}_p^D)^w \\times (F^D)^{d-1} \\ : \\\\ &amp;\\exists \\vec{p} = (p_1, \\dots, p_w, q_1, \\dots, q_{d-1}) \\in \\mathcal{L}_{N^+}(\\mathbb{F}_p)^w \\times \\mathcal{L}_{N^+}(F)^{d-1} \\\\ &amp;\\land \\ \\operatorname{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha \\ \\land \\ \\operatorname{identity} \\ (46) \\ \\operatorname{holds} \\ \\Big\\}, \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and its soundness error is shown to be  $\\varepsilon_1 := \\ell^+ \\cdot \\frac{C-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Round 2 is the DEEP algebraic linking step and uses the random point  </span>\\gamma<span class="math">  for reducing  </span>R_{\\alpha}^{(1)}$  to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} R_{\\alpha}^{(2)} &amp;= \\Big\\{ \\vec{f} = (f_1, \\dots, f_{w+d-1}) \\in (\\mathbb{F}_p^D)^w \\times (F^D)^{d-1} \\ : \\\\ &amp;\\exists \\vec{p} = (p_1, \\dots, p_w, q_1, \\dots, q_{d-1}) \\in \\mathcal{L}_{N^+}(\\mathbb{F}_p)^w \\times \\mathcal{L}_{N^+}(F)^{d-1} \\\\ &amp; \\wedge \\ \\mathsf{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha \\ \\wedge \\ \\vec{p} \\ \\mathsf{evaluates} \\ \\mathsf{to} \\ \\mathsf{the} \\ \\mathsf{claims} \\ \\mathsf{at} \\ \\gamma \\ \\mathsf{and} \\ T(\\gamma) \\Big\\}, \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and its soundness error will be seen to be  $\\varepsilon_2 := \\ell^+ \\cdot \\frac{d \\cdot N^+}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C(F) \\setminus (D \\cup H)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Finally, membership to  </span>R_{\\alpha}^{(2)}<span class="math">  is assured whenever their DEEP quotients are proximate to a vector of polynomials with components from  </span>\\mathcal{L}_N(F)<span class="math"> , in the correlated agreement sense and with agreement parameter  </span>\\alpha > \\sqrt{\\rho}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-41-0"></span><strong>Theorem 7</strong> (Soundness). Suppose that a (possibly computationally unbounded) algorithm  <span class="math">P^*</span>  provides a first message  <span class="math">[f_1], \\ldots, [f_w]</span>  on which it is able to succeed Protocol 3 with a probability greater than</p>

    <p class="text-gray-300"><span id="page-41-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\varepsilon_{AIR} = \\ell^{+} \\cdot \\left(\\frac{C-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{d \\cdot N^{+}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1 - 2^{n+B}}\\right) + \\varepsilon_{PROX},\\tag{47}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\ell^+ = \\frac{m^+ + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span> , and  <span class="math">N^+</span> ,  <span class="math">\\rho^+</span> ,  <span class="math">m^+</span>  as above, and  $\\varepsilon_{PROX} := \\varepsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, n, m, L)<span class="math">  is the soundness error of the joint proximity test for real and imaginary parts of the DEEP quotients, run with agreement parameter  </span>\\alpha = \\alpha(m)<span class="math"> . Then there exist polynomials  </span>p_1(X,Y), \\ldots, p_w(X,Y) \\in \\mathbb{F}_p[X,Y]^{\\leq N/2+1}<span class="math">  which agree with  </span>f_1, \\ldots, f_w<span class="math">  on a joint set of density  </span>> \\alpha<span class="math"> , and which satisfy all AIR constraints (43) over the trace domain  </span>H, 1 \\leq i \\leq C$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> Without loss of generality, we assume that the prover  <span class="math">P^<em></span>  oracles are over the specified field, and in particular first round oracles are from  <span class="math">\\mathbb{F}_p^D</span> . Otherwise, modify  <span class="math">P^</em></span>  to take arbitrary values wherever it does not comply. Since the verifier rejects values outside the non-specified field anyway, the success probability of this modified algorithm does not decrease.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us denote  $\\varepsilon_1 = \\ell \\cdot \\frac{C-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ,  </span>\\varepsilon_2 = \\ell \\cdot \\frac{d \\cdot (N+2)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1-2^{n+B}}<span class="math"> , and  </span>\\varepsilon_3 = \\varepsilon_{PROX}<span class="math">  as above. Suppose that  </span>f_1, \\ldots, f_w \\in \\mathbb{F}_p^D<span class="math">  are a first message, on which  </span>P^<em><span class="math">  succeeds with a probability greater than  </span>\\varepsilon = \\varepsilon_1 + \\varepsilon_2 + \\varepsilon_3<span class="math"> . Then the fraction of &quot;good&quot; challenges  </span>\\alpha<span class="math"> , on which  </span>P^</em><span class="math">  is able to continue with a success probability larger than  </span>\\varepsilon_2 + \\varepsilon_3$  is bounded from below by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\beta:\\Pr\\left(P^*\\text{ succeeds }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta\\right)>\\varepsilon_2+\\varepsilon_3\\right]>\\varepsilon_1.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Likewise, for every such "good"  <span class="math">\\beta</span>  (by the definition of  <span class="math">\\varepsilon_1</span> , there are more than  <span class="math">\\ell^+ \\cdot (C-1)</span>  many) there exists a second message of  <span class="math">P^*</span> , i.e. words  <span class="math">q_{\\beta,0}, \\ldots, q_{\\beta,d-1} \\in F^D</span>  such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\gamma \\in C(F) \\setminus (D \\cup H) : \\Pr(P^* \\text{ succeeds }</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gamma) > \\varepsilon_3\\right] > \\varepsilon_2.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each such "good"  <span class="math">\\gamma \\in C(F) \\setminus (D \\cup H)</span>  (by the definition of  <span class="math">\\varepsilon_2</span> , there are more than  <span class="math">\\ell \\cdot d \\cdot (N+2)</span>  such) the evaluation claims pass the verifier checks, and moreover the soundness of circle FRI enforces the DEEP quotients</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{f_1(x) - v_{1,0}}{v_{\\gamma}(x)}, \\frac{f_1(x) - v_{1,1}}{v_{T(\\gamma)}(x)}, \\dots, \\frac{f_w(x) - v_{w,0}}{v_{\\gamma}(x)}, \\frac{f_w(x) - v_{w,1}}{v_{T(\\gamma)}(x)}, \\frac{q_{\\beta,1}(x) - v_0}{v_{\\gamma}(x)}, \\dots, \\frac{q_{\\beta,d-1}(x) - v_{d-1}}{v_{\\gamma}(x)}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">to agree with a collection of bivariate polynomials of degree  $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2<span class="math">  with coefficients in  </span>F_i = F(i)<span class="math"> , on a joint set A of density at least  </span>\\alpha > \\sqrt{\\rho^+}$ . Cancelling out the denominators, we see that the non-quotients</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(f_1,\\ldots,f_w,q_{\\beta,0},\\ldots,q_{\\beta,d-1})</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">have correlated agreement on a set of density  <span class="math">\\geq \\alpha</span>  with a collection of polynomials from  <span class="math">F_i[X, Y]</span> , each of degree  $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/2 + 2$ , and which satisfies the evaluation claims.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In what follows we shall call an element  <span class="math">(h_1(X,Y),\\ldots,h_l(X,Y))</span>  from  <span class="math">F[X,Y]^l</span> , with component polynomials of degree  <span class="math">\\leq N^+/2</span> , having correlated agreement with a vector of functions  <span class="math">(\\phi_1,\\ldots,\\phi_l)</span>  on a set of density  <span class="math">\\geq \\alpha</span> , an  <span class="math">\\alpha</span> -configuration for that vector of functions. Note that since  <span class="math">\\alpha &gt; (1 + \\frac{1}{2m^+}) \\cdot \\sqrt{\\rho^+}</span> , the Guruswami-Sudan list size bound (for the correlated agreement code, c.f. Proposition 7) tells us there are at most</p>

    <div class="my-4 text-center"><span class="math-block">\\ell^+ = \\frac{m^+ + \\frac{1}{2}}{\\sqrt{\\rho^+}}</span></div>

    <p class="text-gray-300"> <span class="math">\\alpha</span> -configurations for  <span class="math">(\\phi_0(x), \\dots, \\phi_{l-1}(x))</span> .</p>

    <p class="text-gray-300">Let us keep a combination of "good" first and second messages  <span class="math">(f_1,\\ldots,f_w)</span> ,  <span class="math">(q_{\\beta,1},\\ldots,q_{\\beta,d-1})</span>  fixed. We have seen above that the existence of a single "good"  <span class="math">\\gamma</span>  implies the existence of an  <span class="math">\\alpha</span> -configuration for  <span class="math">(f_1,\\ldots,f_w,q_{\\beta,0},\\ldots,q_{\\beta,d-1})</span> . By the Guruswami-Sudan list size bound for  <span class="math">\\mathcal{C}_{N^+}(K,D)</span>  there are at most  <span class="math">\\ell^+</span>  such  <span class="math">\\alpha</span> -configurations. However, since there are more than  <span class="math">\\ell^+ \\cdot d \\cdot N^+</span>  many "good"  <span class="math">\\gamma</span> , and each establishes an  <span class="math">\\alpha</span> -configuration which moreover evaluates to the claimed values, we conclude from the pigeon-hole principle that there is at least one  <span class="math">\\alpha</span> -configuration,</p>

    <div class="my-4 text-center"><span class="math-block">(p_1, \\dots, p_w, q_{\\beta,0}, \\dots, q_{\\beta,d-1}) \\in F[X, Y]^{w+d-1},</span></div>

    <p class="text-gray-300">for which the overall identity (46) holds at more than  <span class="math">d \\cdot N^+</span>  many  <span class="math">\\gamma</span> . By the maximum number of zeros of a polynomial from  <span class="math">F[X,Y]^{\\leq d \\cdot N^+/2}</span>  (Proposition 2) this configuration is a solution of it, hence  <span class="math">(p_1,\\ldots,p_w) \\in F[X,Y]^w</span>  is an  <span class="math">\\alpha</span> -configuration for  <span class="math">(f_1,\\ldots,f_w)</span>  which satisfies</p>

    <p class="text-gray-300"><span id="page-42-2"></span> <span class="math-block">\\sum_{i=1}^{C} \\alpha^{i-1} \\cdot P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0</span> (48)</p>

    <p class="text-gray-300">over the trace domain H.</p>

    <p class="text-gray-300">We have seen that for each "good"  <span class="math">\\alpha</span>  there exists an  <span class="math">\\alpha</span> -configuration for  <span class="math">(f_1, \\ldots, f_w)</span>  which is a solution of (48). Again, by the Guruswami-Sudan list size bound for  <span class="math">\\mathcal{C}_{N^+}[K,D]</span> , there can be at most  <span class="math">\\ell^+</span>  many w-configurations. Since there are more than  <span class="math">\\ell^+ \\cdot (C-1)</span>  many "good"  <span class="math">\\alpha</span> , we conclude again from the pigeon-hole principle that there is at least one  <span class="math">\\alpha</span> -configuration, which we again denote by  <span class="math">(p_1,\\ldots,p_w)</span> , for which there are at least C many "good"  <span class="math">\\alpha</span>  for which (48) holds. By linear algebra (the Vandermonde matrix is invertible) we conclude that this configuration satisfies</p>

    <div class="my-4 text-center"><span class="math-block">P_i(s_i, p_1, \\dots, p_w, p_1 \\circ T, \\dots, p_w \\circ T) = 0</span></div>

    <p class="text-gray-300">over H, for every  <span class="math">i = 1, \\ldots, C</span> . This completes the proof.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">B.3 Witness extraction</h4>

    <p class="text-gray-300">Witness extraction is based on the correlated agreement decoder, which essentially is the Guruswami-Sudan list decoder on the isomorphic generalized Reed-Solomon code, over a suitably extended alphabet.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-42-1"></span><strong>Proposition 7</strong> (Correlated agreement decoder). Let  <span class="math">C = C_N(F, D)</span>  be a circle code of rate  $\\rho = (N+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  with values in a finite extension field F of  </span>\\mathbb{F}_p<span class="math"> , generated by the space of polynomials  </span>\\mathcal{L}_N(F)$ . Assume that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> <span class="math">\\vec{f} = (f_1, \\dots, f_L) \\in (F^D)^L</span>  jointly agree with  <span class="math">\\vec{p} = (p_1, \\dots, p_L) \\in \\mathcal{L}_N(F)^L</span>  over a set of density  <span class="math">&gt; \\alpha</span> , denoted by  <span class="math">\\operatorname{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha</span> , where  <span class="math">\\alpha = (1 + \\frac{1}{2m}) \\cdot \\sqrt{\\rho}</span> . Then there at most</p>

    <div class="my-4 text-center"><span class="math-block">\\ell = \\frac{m + \\frac{1}{2}}{\\sqrt{\\rho}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">such  <span class="math">\\vec{p} = (p_1, \\dots, p_L) \\in \\mathcal{L}_N(F)^L</span>  so that  <span class="math">\\operatorname{agree}(\\vec{f}, \\vec{p}) &gt; \\alpha</span> , and a deterministic polynomial-time algorithm that outputs all such  <span class="math">\\vec{p}</span> . The run time of that algorithm is  $O(L^2 \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{15})$  operations over F.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Take  <span class="math">F_L</span>  a finite extension of F of degree  <span class="math">\\dim(F_L/F) \\geq L</span> , and  <span class="math">\\zeta_1, \\ldots, \\zeta_L \\in F_L</span>  any choice of elements which are linearly independent over F. Then  <span class="math">\\vec{f} = (f_1, \\ldots, f_L) \\in (F^D)^L</span>  jointly agree with a  <span class="math">\\vec{p} = (p_1, \\ldots, p_L) \\in \\mathcal{L}_N(F)^L</span>  on a set A of density  <span class="math">&gt; \\alpha</span> , if and only if the word  <span class="math">f = \\sum_{j=1}^L \\zeta_j \\cdot f_j \\in F_L^D</span>  agrees with a word from the circle code  <span class="math">\\mathcal{C}_N(F_L, D)</span> , over the same set A. Corollary 1) applied to the circle code over the extended alphabet yields the assertion of the proposition.</p>

    <p class="text-gray-300">With the correlated agreement decoder one is able to extract witnesses from any prover that succeeds the circle IOP for AIR with a probability beyond the soundness error.</p>

    <p class="text-gray-300"><span id="page-43-1"></span><strong>Theorem 8</strong> (Knowledge Soundness). Assume that a prover  <span class="math">P^<em></span>  passes Protocol 3 with a probability  <span class="math">\\varepsilon^</em></span>  greater than the soundness error  <span class="math">\\varepsilon_{AIR}</span>  from Theorem 7. Then there is probabilistic algorithm  <span class="math">\\mathcal{E} = \\mathcal{E}^{P^<em>}(aux)</span>  with oracle access to the first round function of  <span class="math">P^</em></span> , that outputs a solution  <span class="math">(p_1, \\ldots, p_w) \\in \\mathcal{L}_{N^+}(\\mathbb{F}_p)^w</span>  of the AIR, within an expected number of  <span class="math">O(1/(\\varepsilon^<em> - \\varepsilon))</span>  calls to  <span class="math">P^</em></span> .</p>

    <p class="text-gray-300">Proof. The extractor  <span class="math">\\mathcal{E}</span>  samples a first round message  <span class="math">[f_1], \\ldots, [f_w]</span>  of  <span class="math">P^<em></span> , reads out  <span class="math">f_1, \\ldots, f_w \\in \\mathbb{F}_p^D</span>  in full length, applies the correlated agreement decoder from Proposition 7, and eventually tests each of its outputs  <span class="math">\\vec{p} \\in L_{N^+}(\\mathbb{F}_p)^w</span>  on being a solution to the AIR. The set of "good" first round messages  <span class="math">[f_1], \\ldots, [f_w]</span>  on which  <span class="math">P^</em></span>  is able to succeed with a probability greater than  <span class="math">\\varepsilon_{AIR}</span> , is at least of probability  <span class="math">\\varepsilon^<em> - \\varepsilon_{AIR}</span> . Thus the extractor  <span class="math">\\mathcal{E}</span>  needs to sample on average  <span class="math">1/(\\varepsilon^</em> - \\varepsilon_{AIR})</span>  first round messages to obtain such a good first round message. On such a message, the correlated agreement decoder ouputs (at least) one solution of the AIR.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The circle STARK in Section 5 assumes that both the trace domain H and evaluation domain D are disjoint standard position cosets. In practice one typically chooses d the degree of the AIR so that  $d-1 \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  so that no additional extrapolation effort is needed for evaluating the overall quotient q.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In case when zero-knowledge is not a target, one can minimize the extrapolation effort even further by selecting the evaluation domain as a superset of the trace domain. In this case,  <span class="math">H \\subset D</span>  and the degree of the algebraic intermediate representation is equal to  <span class="math">d \\leq m</span>  with  $m =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^B<span class="math"> , where  </span>B \\geq 1<span class="math"> . We again assume that H a coset of  </span>G_n<span class="math">  is in standard position, and consequently D must be in &quot;group position&quot;, i.e.  </span>D = G_{n+B}<span class="math"> . (Note that D is a coset of  </span>G_{n+B}<span class="math">  which contains a generator of  </span>G_{n+1}<span class="math"> , hence it must be equal to  </span>G_{n+B}<span class="math"> .) It is for this reason the extrapolation target  </span>D \\setminus H<span class="math">  (as D itself) cannot be written as a disjoint union of standard position twin-cosets alone. If Q is a generator of  </span>G_{n+B}<span class="math"> , then  </span>D \\setminus H$  is the union of the twin-cosets</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">H_k = Q^k \\cdot G_{n-1} \\cup Q^{-k} \\cdot G_{n-1},</span></div>

    <p class="text-gray-300">for  <span class="math">1 \\le k \\le m-1</span> , except for k=m/2 which corresponds to H itself, and the exceptional case  <span class="math">G_n</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">D \\setminus H = G_n \\cup \\bigcup_{k \\neq m/2} H_k.</span></div>

    <p class="text-gray-300">However, the exception  <span class="math">H_0 = G_n</span>  is no drawback for efficiency. For computing the values of  <span class="math">f_i \\in \\mathcal{L}&#x27;_N(\\mathbb{F}_p)</span>  over  <span class="math">H_0</span>  one takes the variant of the inverse FFT from Remark 12, and for extrapolating values over  <span class="math">H_0</span>  to the full domain D one uses rotated coordinates under which  <span class="math">H_0</span>  is in standard position. This yields words which stem from the function space</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}&#x27;(F, H_0) := \\mathcal{L}&#x27;_N(F) \\circ T_Q^{m/2},</span></div>

    <p class="text-gray-300">since  <span class="math">Q^{m/2} \\cdot H_0</span>  is in standard position. According to this mixed-type decomposition of  <span class="math">D \\setminus H</span> , the overall quotient q splits into</p>

    <div class="my-4 text-center"><span class="math-block">q = \\lambda \\cdot \\prod_{k} v_{H_k} + \\sum_{k} q_k \\cdot \\prod_{j \\neq k} v_{H_j}, \\tag{49}</span></div>

    <p class="text-gray-300">with  <span class="math">q_0 \\in \\mathcal{L}&#x27;_N(F, H_0)</span>  and all other  <span class="math">q_k \\in \\mathcal{L}&#x27;_N(F)</span> , and  <span class="math">\\lambda \\in F</span> . (Here, k ranges from  <span class="math">0 \\le k \\le m-1</span> , except k = m/2.) The analysis of the overall identity at infinity is as before, with the following differences. Recall that by Equation (25) we have</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{g \\circ T_Q^{m/2}}{x^{N/2}}(\\infty) = (Q_x + i \\cdot Q_y)^{-m/2 \\cdot N/2} \\cdot \\frac{g}{x^{N/2}}(\\infty) = i \\cdot \\frac{g}{x^{N/2}}(\\infty),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\frac{g \\circ T_Q^{m/2}}{x^{N/2}}(\\bar{\\infty}) = (Q_x - i \\cdot Q_y)^{-m/2 \\cdot N/2} \\cdot \\frac{g}{x^{N/2}}(\\bar{\\infty}) = -i \\cdot \\frac{g}{x^{N/2}}(\\bar{\\infty}).</span></div>

    <p class="text-gray-300">Therefore  <span class="math">q_0</span>  as a function from  <span class="math">\\mathcal{L}&#x27;_N(F) \\circ T_Q^{m/2}</span>  belongs to  <span class="math">\\mathcal{L}_N^+(F)</span> , and the vanishing polynomial  <span class="math">v_{H_0} = v_H \\circ T_Q^{m/2}</span>  belongs to  <span class="math">\\mathcal{L}_N^-(F)</span> . All other component polynomials  <span class="math">q_k</span>  belong to  <span class="math">\\mathcal{L}_N^-(F)</span> , and all other vanishing polynomials  <span class="math">v_{H_k}</span>  belong to  <span class="math">\\mathcal{L}_N^+(F)</span> . Thus the product of all vanishing polynomials  <span class="math">\\prod_k v_{H_k}</span>  is odd at infinity, whereas each product  <span class="math">q_k \\cdot \\prod_{j \\neq k} v_{H_j}</span>  in the sum is even at infinity. From this we conclude that in the case d is even, where  <span class="math">q \\in \\mathcal{L}_{(d-1)\\cdot N}^+</span> , we must have  <span class="math">\\lambda = 0</span> , and in the case d is odd, where  <span class="math">q \\in \\mathcal{L}_{(d-1)\\cdot N}^-</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{k} \\frac{q_k}{x^{N/2}} \\cdot \\prod_{j \\neq k} \\frac{v_{H_j}}{x^{N/2}} = 0.</span></div>

    <p class="text-gray-300">For the final low-degree test over D one again uses rotated coordinates, this time using an element of order  <span class="math">2^{n+B+1}</span>  which moves D into standard position.</p>

    <p class="text-gray-300">At the time of writing, a full implementation of the circle STARK is not yet ready. As a preview of what to expect in terms of performance, we provide preliminary benchmarks of the circle FFT over the Mersenne prime field M31, compared to the regular FFT over the equally sized Babybear field, see Table 1. The advantage of vectorized M31 arithmetics (AVX2 multiplications are about 40% faster than with BabyBear, see also [HLN23]) directly translates to the single-threaded FFT cost. With high thread count, our current implementation becomes memory-bound, and thus, M31 CFFT and BabyBear performance is similar. Take note that the current implementation does not apply memory optimizations (such as Radix  <span class="math">2^k</span>  FFT or 4-step). With such optimizations, memory bandwidth is expected to be much less of a bottleneck on personal hardware.</p>

    <p class="text-gray-300">Let us discuss some details of the circle FFT implementation. When ordered correctly, the circle FFT algorithm is almost identical to the radix-2 FFT algorithm, only with different twiddle factors. For a twin coset  <span class="math">D = Q \\cdot G_{n-1} \\cup Q^{-1} \\cdot G_{n-1}</span> , define this ordering as  <span class="math">P : \\{0, \\ldots, 2^n - 1\\} \\longrightarrow D</span> :</p>

    <div class="my-4 text-center"><span class="math-block">P(i) := \\begin{cases} Q \\cdot G^i, &amp; i &lt; 2^{n-1}, \\\\ Q^{-1} \\cdot G^{-i}, &amp; i \\ge 2^{n-1}, \\end{cases}</span></div>

    <p class="text-gray-300">https://github.com/Plonky3/Plonky3/commit/86d13ddf269427c4788cdd41f413308a6050f9f3</p>

    <p class="text-gray-300"><span id="page-44-1"></span><sup>&</sup>lt;sup>8</sup>Babybear code used for the benchmarks:</p>

    <p class="text-gray-300"><span id="page-45-0"></span>Table 1: FFT algorithm runtime comparison<a href="#page-44-1">8</a> between Babybear and M31, for a batch FFT of 128 polynomials. Measured 100 iterations on Intel i7-1165G7, at a fixed 1.5 Ghz frequency, single threaded, using AVX2 vectorization. Our current multi-threaded implementation becomes memory bottlenecked at domain sizes ≥ 2 <sup>16</sup> (emphasized by a gray background), but this will be optimized in future.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">FFT size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Threads</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M31 CFFT (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BabyBear FFT (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ratio</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">11.0</td>

            <td class="px-3 py-2 border-b border-gray-700">17.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">86.8</td>

            <td class="px-3 py-2 border-b border-gray-700">121</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">387</td>

            <td class="px-3 py-2 border-b border-gray-700">542</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1700</td>

            <td class="px-3 py-2 border-b border-gray-700">2384</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">7400</td>

            <td class="px-3 py-2 border-b border-gray-700">10345</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">5.57</td>

            <td class="px-3 py-2 border-b border-gray-700">7.04</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">67.0</td>

            <td class="px-3 py-2 border-b border-gray-700">67.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">321</td>

            <td class="px-3 py-2 border-b border-gray-700">319</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1410</td>

            <td class="px-3 py-2 border-b border-gray-700">1400</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">6170</td>

            <td class="px-3 py-2 border-b border-gray-700">6110</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where G is a generator of order 2 n−1 . An evaluation of a function f : D → F is f ◦ P. Algorithm <a href="#page-45-1">1</a> takes such an evaluation and computes coefficients of the interpolating function in the FFT space. For a small number of columns, we recommend the CFFT interpolation to use precomputed inverse twiddles. Unlike for the regular FFT, it is unclear how to efficiently compute these on the fly without doing an expensive inverse operation. However, for batched CFFT, this is less of an issue. For the evaluation implementation (inverse of interpolation), computing the twiddles can be done on the fly, though it is more expansive than a regular FFT, since it involves operations in the complex extension Fp(i) of Fp.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Algorithm 1 Circle FFT (interpolation)</h4>

    <pre><code class="language-text">1: procedure CFFT(a)
2: # First layer
3: step ← N/2
4: for k = 0, 1, . . . , step − 1 do
5: twiddle ← (QGk
                       ).y
6: butterfly(a[k], a[k + step], twiddle)
7:
8: # Rest of the layers
9: for l = 0, 1, . . . , n − 2 do
10: step ← step/2
11: for i = 0, 1, . . . , N/(2 · step) − 1 do
12: j ← i · 2 · step
13: for k = 0, 1, . . . , step − 1 do
14: twiddle ← ((QGk
                              )
                               2
                                ).x
15: butterfly(a[j + k], a[j + k + step], twiddle)
16: procedure butterfly(a, b, t)
17: a, b ← a + b,(a − b)/t</code></pre>`;
---

<BaseLayout title="Circle STARKs (2024/278)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/278
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="circle-starks-2024" />
  </article>
</BaseLayout>
