---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/504';
---

<BaseLayout title="Polylogarithmic Proofs for Binary Towers (2024/504)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Polylogarithmic Proofs for Multilinears over Binary Towers
      </h1>
      <p class="text-gray-400 mb-2">
        Benjamin E. Diamond, Jim Posen
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; Full Version &middot; eprint 2024/504
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Some Historical Remarks</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Our Contributions</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">
                Ring-Switching</a>
            </li>
            <li>
              <a href="#sec-1.4"
                class="hover:text-white">
                Binary BaseFold</a>
            </li>
            <li>
              <a href="#sec-1.5"
                class="hover:text-white">
                Concurrent and Subsequent Works</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Background and Notation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Multilinear Polynomials</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Error-Correcting Codes</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                The Novel Polynomial Basis</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                FRI</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                Tensor Products of Fields</a>
            </li>
            <li>
              <a href="#sec-2.6"
                class="hover:text-white">
                Proximity Gaps</a>
            </li>
            <li>
              <a href="#sec-2.7"
                class="hover:text-white">
                Security Definitions</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">Ring-Switching</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Ring-Switching Protocol</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Efficiency</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Binary BaseFold</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Using FRI in Novel Polynomial Basis</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                FRI Folding, Revisited</a>
            </li>
            <li>
              <a href="#sec-4.3"
                class="hover:text-white">
                Our Large-Field IOPCS</a>
            </li>
            <li>
              <a href="#sec-4.4"
                class="hover:text-white">
                Efficiency</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Unrolled Small-Field IOPCS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Combined Small-Field Protocol</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Efficiency</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ol>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Abstract</h2>

      <p class="text-gray-300">
        The use of small fields has come to typify the design of modern,
        production-oriented SNARKs. In this work, we treat multilinear
        polynomial commitment over tiny fields. A tiny-field
        polynomial&mdash;in the nomenclature of Diamond and Posen
        (EUROCRYPT &rsquo;25)&mdash;is defined over a field that has
        fewer elements than the polynomial itself has coefficients. We
        focus on multilinears over the field with just two elements.
      </p>

      <p class="text-gray-300 mt-4">
        In this work, we generically reduce the problem of tiny-field
        commitment to that of large-field commitment. We introduce a
        sumcheck-based compiler&mdash;called
        &ldquo;ring-switching&rdquo;&mdash;which, upon being fed a
        multilinear polynomial commitment scheme over some large
        extension field, yields a further scheme over that field&rsquo;s
        ground field. The resulting scheme lacks embedding overhead, in
        that its commitment cost, on each input, equals that of the
        large-field scheme on each input of identical size (in bits).
        Its evaluation protocol&rsquo;s overhead is linear for the
        prover and logarithmic for the verifier, and is essentially
        optimal.
      </p>

      <p class="text-gray-300 mt-4">
        Instantiating our ring-switching reduction on the BaseFold
        (CRYPTO &rsquo;24) large-field multilinear polynomial
        commitment scheme&mdash;or more precisely on a characteristic-2
        adaptation of that scheme that we develop at length&mdash;we
        obtain an extremely fast polynomial commitment scheme for
        bit-valued multilinears. Our scheme outperforms its
        state-of-the-art peers, a fact we demonstrate experimentally.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">1 &ensp;Introduction</h2>

      <p class="text-gray-300">
        Today&rsquo;s fastest, production-oriented SNARKs universally
        use small fields. Before 2022, virtually all SNARKs operated
        over just one&mdash;cryptographically large&mdash;field. The
        small-field revolution began in earnest with ethSTARK and
        Plonky2. Those systems decouple the respective fields used
        within their arithmetization and cryptography portions. That is,
        they use small fields&mdash;sized roughly like a 64-bit
        register&mdash;for their arithmetizations; each, during its
        security-critical portions, passes to a cryptographically large
        field extension of its arithmetization field. Subsequent
        production-oriented SNARKs like Plonky3 and RISC Zero have
        embraced similar designs, based on 32-bit prime fields; S-two
        has adopted a related architecture based on Hab&ouml;ck, Levit
        and Papini&rsquo;s Circle STARK [HLP24]. By using small fields,
        these systems have managed to deliver industry-leading provers,
        which outperform those grounded in elliptic-curve-based SNARKs
        (like Sonic [MBKM19], PlonK [GWC19] and Marlin [Chi+20]).
      </p>

      <p class="text-gray-300 mt-4">
        These SNARKs all use arithmetization fields which, though
        relatively small, are nonetheless at least as large as the
        statements they&rsquo;re capable of proving. This fact is not a
        coincidence. Indeed, all of them operate by, roughly, arranging
        their witness data into a trace table, Reed&ndash;Solomon-encoding
        that table&rsquo;s columns, and finally invoking a low-degree
        test based on FRI [BBHR18a]. Reed&ndash;Solomon codes demand
        alphabets that are at least as large as their block lengths are.
      </p>

      <p class="text-gray-300 mt-4">
        A recent work of Diamond and Posen [DP25] breaks this
        trace-length barrier, in that it treats even polynomials over
        tiny fields&mdash;fields smaller than the statement&rsquo;s
        trace length. Crucially, that work does so without embedding
        overhead. One might trivially attempt to commit to a tiny-field
        multilinear simply by embedding its coefficients into an
        extension, before blackbox-invoking a standard scheme on the
        resulting object. That approach would face at least two
        deficiencies. On the efficiency front, it would secure no gain
        from the tininess of its input&rsquo;s coefficients. On the
        security front, it would fail to guarantee the tininess of the
        prover&rsquo;s input, a security desideratum which, in practice,
        turns out to be essential.
      </p>

      <p class="text-gray-300 mt-4">
        In this work, we introduce a generic reduction from the problem
        of tiny-field multilinear polynomial commitment to that of
        large-field multilinear commitment. Our techniques are rather
        different from those of Diamond&ndash;Posen [DP25]. Our
        reduction, applied to any large-field scheme, yields a
        corresponding tiny-field scheme, which moreover lacks embedding
        overhead. It is agnostic to the large-field scheme used. In
        fact, our reduction works even on recently introduced,
        state-of-the-art large-field schemes like Blaze [Bre+25] and
        WHIR [ACFY25], and even on large-field schemes that
        haven&rsquo;t been created yet. Its overhead over the underlying
        large-field scheme given to it is essentially optimal, and beats
        that associated with alternative constructions, like Hashcaster.
      </p>

      <!-- 1.1 Some Historical Remarks -->
      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 &ensp;Some Historical Remarks
      </h3>

      <p class="text-gray-300">
        Diamond and Posen [DP25] break the trace-length barrier by
        further decoupling two fields which, in all of the small-field
        schemes noted above, coincide: the arithmetization field and the
        alphabet field. All of those schemes use just one prime
        field&mdash;again, sized just under 32 or 64 bits&mdash;both as
        the coefficient field of the polynomials committed and as the
        alphabet of the Reed&ndash;Solomon code used to encode them. The
        scheme [DP25] makes possible the simultaneous use of a tiny
        arithmetization field and a small alphabet field. Separately,
        that work reintroduces the use of binary fields, fields of
        characteristic 2. Finally, that work treats exclusively
        multilinear polynomials; in this capacity, it extends an
        important line of work which includes Libra [Xie+19], Virgo
        [ZXZS20], Spartan [Set20], Brakedown [Gol+23], and HyperPlonk
        [CBBZ23].
      </p>

      <p class="text-gray-300 mt-4">
        To make their technique work, Diamond and Posen [DP25] introduce
        a data-casting operation&mdash;which they call packing, and
        which is based on field extensions&mdash;which serves to recast
        a witness defined over
        <span class="math">\mathbb&#123;F&#125;_2</span>, say, into a
        shorter witness over the larger field
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;32&#125;&#125;</span>.
        They then apply a Brakedown-like multilinear commitment
        procedure to the resulting witness, whose coefficient field,
        crucially, is large enough to be used as a Reed&ndash;Solomon
        alphabet.
      </p>

      <p class="text-gray-300 mt-4">
        As Diamond and Posen [DP25] implicitly observe, unlike DEEP-ALI
        [BGKS19], Brakedown [Gol+23]&mdash;like its predecessor works
        Bootle, Chiesa and Groth [BCG20] and Ron-Zewi and Rothblum
        [RR24]&mdash;decouples the coding-theoretic specifications of
        its code from the semantics of its code. This decoupling makes
        Diamond and Posen&rsquo;s packing procedure coherent.
      </p>

      <p class="text-gray-300 mt-4">
        Zeilberger, Chen and Fisch&rsquo;s BaseFold PCS [ZCF24,
        &sect;&nbsp;5] seems to be the first multilinear polynomial
        commitment scheme with a polylogarithmic verifier that
        doesn&rsquo;t use quotienting. This work&rsquo;s small-field
        PCS works in a drop-in way with the PIOP of [DP25]. By
        combining this work&rsquo;s PCS with that work&rsquo;s PIOP,
        one stands to obtain an efficient, full-blown SNARK for binary
        witnesses.
      </p>

      <!-- 1.2 Our Contributions -->
      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 &ensp;Our Contributions
      </h3>

      <p class="text-gray-300">
        We sketch our contributions here.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>A reduction from tiny-field commitment to huge-field
        commitment.</strong> Ring-switching is a generic compiler, which,
        on input a multilinear polynomial commitment scheme over some
        large extension field
        <span class="math">L/K</span>, yields a new multilinear
        polynomial commitment scheme over the ground field
        <span class="math">K</span>. Here,
        <span class="math">L</span> can be of any characteristic,
        including 2. Each scheme our compiler outputs lacks embedding
        overhead, in that its commitment cost on each
        <span class="math">K</span>-multilinear equals the original
        scheme&rsquo;s commitment cost on an
        <span class="math">L</span>-multilinear of equal size in bits.
      </p>

      <p class="text-gray-300 mt-4">
        We write <span class="math">2^\kappa</span> for the degree of
        <span class="math">L</span> over
        <span class="math">K</span>, which we assume is a power of 2.
        Diamond and Posen&rsquo;s [DP25, &sect;&nbsp;4] packing
        procedure takes in an
        <span class="math">\ell</span>-variate multilinear
        <span class="math">t(X_0, \ldots, X_&#123;\ell-1&#125;)</span>
        over <span class="math">K</span> and produces the packed
        multilinear
        <span class="math">t'(X_0, \ldots, X_&#123;\ell'-1&#125;)</span>
        over <span class="math">L</span>, where
        <span class="math">\ell' := \ell - \kappa</span>.
        Our <span class="math">K</span>-scheme&rsquo;s commitment
        procedure simply packs
        <span class="math">t(X_0,\ldots,X_&#123;\ell-1&#125;)</span>
        and invokes the underlying
        <span class="math">L</span>-scheme&rsquo;s commitment
        procedure on
        <span class="math">t'(X_0,\ldots,X_&#123;\ell'-1&#125;)</span>,
        the result. The hard part is relating an evaluation claim on
        <span class="math">t</span> to one on
        <span class="math">t'</span>. To do this, we devise an unusual
        matrix-transposition trick, and write down an
        <span class="math">\ell - \kappa</span>-round sumcheck between
        <span class="math">t'</span> and a new sort of polynomial we
        call a ring-switch equality indicator.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>An improved multilinear PCS for large binary fields,
        based on BaseFold.</strong> Zeilberger, Chen and
        Fisch&rsquo;s BaseFold PCS [ZCF24, &sect;&nbsp;5] is an
        important multilinear polynomial commitment scheme for large
        prime fields. In order to spin up a target for our ring-switching
        reduction, we develop a characteristic-2 variant of BaseFold
        PCS, i.e.&nbsp;for large binary fields. We also improve that
        scheme by incorporating into it higher-arity folding, an
        optimization that reduces its proof sizes by more than half.
      </p>

      <p class="text-gray-300 mt-4">
        To make higher-arity folding work with BaseFold, we introduce
        oracle-skipping, a new higher-arity folding mechanism. Our
        security proof necessitates a different sort of proximity gap
        than FRI&rsquo;s approach does, one pertaining not to low-degree
        curves but instead to tensor combinations. Precisely this kind
        of proximity gap is established in recent work of Diamond and
        Gruen [DG25], which we leverage.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>A state-of-the-art PCS for multilinears over tiny
        binary fields.</strong> Putting the two parts above together, we
        obtain an extremely fast PCS for tiny-field multilinears. On a
        28-variate multilinear over
        <span class="math">\mathbb&#123;F&#125;_2</span>, our scheme
        achieves singlethreaded commitment and opening times of just 144
        and 160 milliseconds, respectively; our multithreaded commitment
        and opening times are 44 and 71 milliseconds, respectively. Our
        proofs for polynomials of this size are 0.351&nbsp;MiB, and our
        verifier runs in under a millisecond.
      </p>

      <p class="text-gray-300 mt-4">
        Our measurements beat Plonky3&rsquo;s by between one and two
        orders of magnitude. Plonky3 takes 25 and 13 seconds,
        respectively, to commit a comparable amount of data, in the
        singlethreaded setting, and 4 and 2 seconds in multithreaded
        mode. Its proofs are also larger, and its verifier is around 20
        milliseconds.
      </p>

      <!-- 1.3 Ring-Switching -->
      <h3 id="sec-1.3" class="text-xl font-semibold mt-8 mb-3">
        1.3 &ensp;Ring-Switching
      </h3>

      <p class="text-gray-300">
        In this subsection, we gently introduce ring-switching,
        prioritizing technical simplicity and accuracy. We fix a field
        extension <span class="math">L/K</span> of power-of-2 degree
        <span class="math">2^\kappa</span>. Though ring-switching works
        for any such field extension, of any characteristic, the special
        case <span class="math">K = \mathbb&#123;F&#125;_2</span> and
        <span class="math">L = \mathbb&#123;F&#125;_&#123;2^&#123;128&#125;&#125;</span>
        is especially important and exemplary. We write
        <span class="math">\mathcal&#123;B&#125;_\kappa := \&#123;0,1\&#125;^\kappa</span>
        for the <span class="math">\kappa</span>-dimensional unit cube.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>The problem.</strong> We assume access to a large-field
        multilinear polynomial commitment scheme for multilinears over
        <span class="math">L</span>. How might we obtain a small-field
        commitment scheme for multilinears over
        <span class="math">K</span>, assuming access to that large-field
        scheme?
      </p>

      <p class="text-gray-300 mt-4">
        We begin with a small-field multilinear, say
        <span class="math">t(X_0, \ldots, X_&#123;\ell-1&#125;) \in K[X_0, \ldots, X_&#123;\ell-1&#125;]^&#123;\leq 1&#125;</span>,
        that we&rsquo;d like to commit to. Following Diamond and Posen
        [DP25], we fix a basis
        <span class="math">(\beta_v)_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125;</span>
        of <span class="math">L</span> over
        <span class="math">K</span>, write
        <span class="math">\ell' := \ell - \kappa</span>, and define the
        packed multilinear:
      </p>

      <div class="math-block">
        t'(X_0, \dots, X_&#123;\ell'-1&#125;) := \sum_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125; t(v_0, \dots, v_&#123;\kappa-1&#125;, X_0, \dots, X_&#123;\ell'-1&#125;) \cdot \beta_v. \tag&#123;1&#125;
      </div>

      <p class="text-gray-300 mt-4">
        Our commitment procedure is simple: it just packs
        <span class="math">t(X_0, \ldots, X_&#123;\ell-1&#125;)</span>
        and invokes the underlying large-field scheme&rsquo;s commitment
        procedure on
        <span class="math">t'(X_0, \ldots, X_&#123;\ell'-1&#125;)</span>.
        This procedure lacks embedding overhead, since
        <span class="math">t</span> and
        <span class="math">t'</span> are of the same size in bits.
      </p>

      <p class="text-gray-300 mt-4">
        To check an evaluation claim on <span class="math">t</span>,
        we must reduce it to one on
        <span class="math">t'</span>. We fix a point
        <span class="math">(r_0, \ldots, r_&#123;\ell-1&#125;)</span>
        and an evaluation claim
        <span class="math">s \stackrel&#123;?&#125;&#123;=&#125; t(r_0, \ldots, r_&#123;\ell-1&#125;)</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>A strawman approach.</strong> The prover sends values
        <span class="math">(\hat&#123;s&#125;_v)_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125;</span>
        which&mdash;it claims&mdash;respectively satisfy
        <span class="math">\hat&#123;s&#125;_v \stackrel&#123;?&#125;&#123;=&#125; t(v_0, \dots, v_&#123;\kappa-1&#125;, r_\kappa, \dots, r_&#123;\ell-1&#125;)</span>
        for each <span class="math">v \in \mathcal&#123;B&#125;_\kappa</span>.
        The verifier checks whether
      </p>

      <div class="math-block">
        s \stackrel&#123;?&#125;&#123;=&#125; \sum_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125; \widetilde&#123;\text&#123;eq&#125;&#125;(v_0, \dots, v_&#123;\kappa-1&#125;, r_0, \dots, r_&#123;\kappa-1&#125;) \cdot \hat&#123;s&#125;_v \tag&#123;3&#125;
      </div>

      <p class="text-gray-300 mt-4">
        holds. While this protocol is complete, it&rsquo;s not secure.
        The basis
        <span class="math">(\beta_v)_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125;</span>
        is linearly independent over <span class="math">K</span>, but
        not over <span class="math">L</span>.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Our solution.</strong> Our idea is&mdash;very
        roughly&mdash;to further decompose the claims until they are
        defined over <span class="math">K</span>. We may then apply the
        linear combination &ldquo;slice-wise&rdquo;. For each
        <span class="math">v \in \mathcal&#123;B&#125;_\kappa</span>,
        the verifier can freely basis-decompose the prover&rsquo;s
        quantity
        <span class="math">\hat&#123;s&#125;_v</span>, writing
      </p>

      <div class="math-block">
        \hat&#123;s&#125;_v = \sum_&#123;u \in \mathcal&#123;B&#125;_\kappa&#125; \hat&#123;s&#125;_&#123;u,v&#125; \cdot \beta_u \tag&#123;5&#125;
      </div>

      <p class="text-gray-300 mt-4">
        for appropriate <span class="math">K</span>-elements. After
        further decomposition, batching via random scalars
        <span class="math">(r''_0, \ldots, r''_&#123;\kappa-1&#125;)</span>,
        and running a sumcheck, the verifier must finally evaluate the
        &ldquo;ring-switch equality indicator&rdquo;
      </p>

      <div class="math-block">
        \widetilde&#123;\text&#123;eq&#125;&#125;(\varphi_0(r_\kappa), \dots, \varphi_0(r_&#123;\ell-1&#125;), \varphi_1(r'_0), \dots, \varphi_1(r'_&#123;\ell'-1&#125;))
      </div>

      <p class="text-gray-300 mt-4">
        where <span class="math">\varphi_0</span> and
        <span class="math">\varphi_1</span> denote the two canonical
        embeddings of <span class="math">L</span> into the tensor
        algebra
        <span class="math">A := L \otimes_K L</span>. The verifier may
        compute this quantity succinctly in just
        <span class="math">2 \cdot 2^\kappa \cdot \ell'</span>
        <span class="math">L</span>-multiplications.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Hashcaster.</strong> We compare ring-switching in detail
        to Hashcaster. Soukhanov&rsquo;s Hashcaster [Sou24] is a SNARK
        for binary witnesses. That work yields an alternative reduction
        from the problem of evaluating the
        <span class="math">K</span>-multilinear to that of evaluating
        its packed <span class="math">L</span>-multilinear.
        Hashcaster&rsquo;s verifier must compute a matrix
        transformation that entails a quadratic number of
        <span class="math">L</span>-multiplications in the extension
        degree <span class="math">2^\kappa</span>. Ring-switching&rsquo;s
        verifier&rsquo;s number of
        <span class="math">L</span>-multiplications grows only linearly.
      </p>

      <!-- 1.4 Binary BaseFold -->
      <h3 id="sec-1.4" class="text-xl font-semibold mt-8 mb-3">
        1.4 &ensp;Binary BaseFold
      </h3>

      <p class="text-gray-300">
        In order to apply ring-switching, we need a large-field scheme
        to invoke it on. To this end, we adapt BaseFold PCS [ZCF24,
        &sect;&nbsp;5] to the characteristic 2 setting. To achieve this,
        we must re-examine the classic additive NTT of Lin, Chung and
        Han [LCH14]. We show that that NTT fits into a framework
        articulated by Hab&ouml;ck, Levit and Papini [HLP24], though it
        predates that latter work.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>The problem.</strong> BaseFold PCS identifies a
        connection between FRI and multilinear evaluation. Each honest
        FRI prover begins with the evaluation of some polynomial
        <span class="math">P(X) := \sum_&#123;j=0&#125;^&#123;2^\ell-1&#125; a_j \cdot X^j</span>
        over its initial domain
        <span class="math">S^&#123;(0)&#125;</span>. During the course of
        the protocol, the prover repeatedly &ldquo;folds&rdquo; its
        initial word. BaseFold PCS relies on the fact whereby a FRI
        execution which begins on the Reed&ndash;Solomon encoding will
        end on a constant polynomial whose value equals the multilinear
        evaluation at the verifier&rsquo;s FRI challenges. For maps
        chosen generically, this fact will fail to hold in
        characteristic 2.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Our solution.</strong> We recover BaseFold PCS in
        characteristic 2 by introducing a specialization of binary FRI
        that works compatibly with Lin&ndash;Chung&ndash;Han&rsquo;s
        additive NTT [LCH14]. We introduce a particular choice of
        folding maps
        <span class="math">q^&#123;(0)&#125;, \ldots, q^&#123;(\ell-1)&#125;</span>
        which causes the equality between the final FRI constant and the
        multilinear evaluation to re-emerge. The right choice turns out
        to be that for which, for each <span class="math">i</span>, the
        composition identity
        <span class="math">\widehat&#123;W&#125;_i = q^&#123;(i-1)&#125; \circ \dots \circ q^&#123;(0)&#125;</span>
        holds, where
        <span class="math">\widehat&#123;W&#125;_i</span> are
        Lin&ndash;Chung&ndash;Han&rsquo;s normalized subspace vanishing
        polynomials.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Oracle-skipping.</strong> Standard FRI supports
        arbitrary-arity folding, controlled by a folding arity parameter
        <span class="math">\eta \geq 1</span>. BaseFold PCS, however,
        does not support the use of univariate higher-arity folding. We
        introduce a new, multilinear style of many-to-one FRI folding.
        We parameterize our method by a constant
        <span class="math">\vartheta</span>: the prover performs
        standard 2-to-1 folding
        <span class="math">\vartheta</span> times in succession,
        committing only to the last among the oracles it obtains. Our
        folding technique makes necessary a tensor-folding proximity gap
        of the sort recently established by Diamond and Gruen [DG25].
      </p>

      <!-- 1.5 Concurrent and Subsequent Works -->
      <h3 id="sec-1.5" class="text-xl font-semibold mt-8 mb-3">
        1.5 &ensp;Concurrent and Subsequent Works
      </h3>

      <p class="text-gray-300">
        <strong>Blaze.</strong> Blaze [Bre+25] is a polynomial
        commitment scheme for multilinears over large binary fields.
        Using a technique grounded in code-switching [RR24], Blaze
        obtains a strictly linear-time commitment procedure, a
        linear-time prover, and a polylogarithmic verifier. Operating
        over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;128&#125;&#125;</span>
        throughout, Blaze reports commitment and proving times that
        improve upon binary BaseFold&rsquo;s by roughly threefold at the
        <span class="math">\ell = 28</span> problem size, though its
        proofs are larger (2.5&nbsp;MiB compared to 1.4&nbsp;MiB for
        binary BaseFold). Incorporating oracle-skipping and further
        concrete proof size optimizations, this work obtains a proof
        size of 0.436&nbsp;MiB in the
        <span class="math">\ell = 28</span> case.
      </p>

      <p class="text-gray-300 mt-4">
        Blaze&rsquo;s PCS is compatible with this work&rsquo;s
        ring-switching compiler. Upon instantiating our ring-switching
        reduction on Blaze&rsquo;s large-field PCS, one would obtain an
        alternative small-field scheme.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. BACKGROUND AND NOTATION                                   -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        2 &ensp;Background and Notation
      </h2>

      <p class="text-gray-300">
        We write <span class="math">\mathbb&#123;N&#125;</span> for the
        nonnegative integers. All fields in this work are finite. We fix
        a binary field <span class="math">L</span>. For each
        <span class="math">\ell \in \mathbb&#123;N&#125;</span>, we write
        <span class="math">\mathcal&#123;B&#125;_\ell</span> for the
        <span class="math">\ell</span>-dimensional boolean hypercube
        <span class="math">\&#123;0,1\&#125;^\ell \subset L^\ell</span>.
        For <span class="math">L</span> a field and
        <span class="math">R \subset L^\vartheta</span> a subset, we write
        <span class="math">\mu(R) := \frac&#123;|R|&#125;&#123;|L|^\vartheta&#125;</span>.
      </p>

      <!-- 2.1 Multilinear Polynomials -->
      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 &ensp;Multilinear Polynomials
      </h3>

      <p class="text-gray-300">
        An <span class="math">\ell</span>-variate polynomial in
        <span class="math">L[X_0,\ldots,X_&#123;\ell-1&#125;]</span> is
        multilinear if each of its indeterminates appears with
        individual degree at most 1. We introduce the
        <span class="math">2 \cdot \ell</span>-variate polynomial
      </p>

      <div class="math-block">
        \widetilde&#123;\operatorname&#123;eq&#125;&#125;(X_0,\dots,X_&#123;\ell-1&#125;,Y_0,\dots,Y_&#123;\ell-1&#125;) := \prod_&#123;i=0&#125;^&#123;\ell-1&#125;(1-X_i)\cdot (1-Y_i) + X_i\cdot Y_i.
      </div>

      <p class="text-gray-300 mt-4">
        For each fixed
        <span class="math">(r_0, \ldots, r_&#123;\ell-1&#125;) \in L^\ell</span>,
        the vector
        <span class="math">(\widetilde&#123;\text&#123;eq&#125;&#125;(r_0, \ldots, r_&#123;\ell-1&#125;, w_0, \ldots, w_&#123;\ell-1&#125;))_&#123;w \in \mathcal&#123;B&#125;_\ell&#125;</span>
        takes the form of a tensor product expansion
        <span class="math">\bigotimes_&#123;i=0&#125;^&#123;\ell-1&#125; (1 - r_i, r_i)</span>,
        computable in
        <span class="math">2^\ell</span> <span class="math">L</span>-additions
        and <span class="math">L</span>-multiplications.
      </p>

      <!-- 2.2 Error-Correcting Codes -->
      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 &ensp;Error-Correcting Codes
      </h3>

      <p class="text-gray-300">
        A code of block length <span class="math">n</span> over the
        alphabet <span class="math">\Sigma</span> is a subset of
        <span class="math">\Sigma^n</span>. A linear
        <span class="math">[n,k,d]</span>-code over
        <span class="math">L</span> is a
        <span class="math">k</span>-dimensional linear subspace
        <span class="math">C \subset L^n</span> for which
        <span class="math">d(v_0,v_1) \geq d</span> holds for each
        unequal pair. The unique decoding radius is
        <span class="math">\lfloor \frac&#123;d-1&#125;&#123;2&#125; \rfloor</span>.
      </p>

      <p class="text-gray-300 mt-4">
        We recall Reed&ndash;Solomon codes. We fix nonnegative message
        length and rate parameters <span class="math">\ell</span> and
        <span class="math">\mathcal&#123;R&#125;</span>, as well as a subset
        <span class="math">S \subset L</span> of size
        <span class="math">2^&#123;\ell+\mathcal&#123;R&#125;&#125;</span>. We write
        <span class="math">C</span> for the Reed&ndash;Solomon code
        <span class="math">\mathsf&#123;RS&#125;_&#123;L,S&#125;[2^&#123;\ell+\mathcal&#123;R&#125;&#125;,2^\ell]</span>,
        defined to be the set of evaluation vectors of polynomials of
        degree less than <span class="math">2^\ell</span> over
        <span class="math">S</span>.
      </p>

      <div class="formal-block formal-block-lemma mt-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 2.1
        </p>
        <p class="text-gray-300">
          If
          <span class="math">d(f,C) \geq \frac&#123;d&#125;&#123;2&#125;</span>,
          then Algorithm 1 (Berlekamp&ndash;Welch) outputs
          <span class="math">\bot</span>.
        </p>
      </div>

      <!-- 2.3 The Novel Polynomial Basis -->
      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 &ensp;The Novel Polynomial Basis
      </h3>

      <p class="text-gray-300">
        We recall in detail the novel polynomial basis of Lin, Chung and
        Han [LCH14, &sect;&nbsp;II.&nbsp;C.]. We fix a binary field
        <span class="math">L</span> of degree
        <span class="math">r</span> over
        <span class="math">\mathbb&#123;F&#125;_2</span>. We fix an
        <span class="math">\mathbb&#123;F&#125;_2</span>-basis
        <span class="math">(\beta_0, \dots, \beta_&#123;r-1&#125;)</span>
        of <span class="math">L</span>. For each
        <span class="math">i \in \&#123;0, \dots, \ell\&#125;</span>, we
        define the subspace vanishing polynomial
        <span class="math">W_i(X) := \prod_&#123;u \in U_i&#125;(X-u)</span>
        and its normalized variant
        <span class="math">\widehat&#123;W&#125;_i(X) := \frac&#123;W_i(X)&#125;&#123;W_i(\beta_i)&#125;</span>.
        The novel polynomial basis elements are
        <span class="math">X_j(X) := \prod_&#123;i=0&#125;^&#123;\ell-1&#125;\widehat&#123;W&#125;_i(X)^&#123;j_i&#125;</span>.
      </p>

      <!-- 2.4 FRI -->
      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 &ensp;FRI
      </h3>

      <p class="text-gray-300">
        We recall Ben-Sasson, Bentov, Horesh and Riabzev&rsquo;s
        [BBHR18a] Fast Reed&ndash;Solomon Interactive Oracle Proof of
        Proximity (FRI). For
        <span class="math">L</span> a binary field, FRI yields an IOP
        of proximity for the Reed&ndash;Solomon code. Internally, FRI
        makes use of a fixed, global sequence of subspaces and maps:
      </p>

      <div class="math-block">
        S = S^&#123;(0)&#125; \xrightarrow&#123;q^&#123;(0)&#125;&#125; S^&#123;(1)&#125; \xrightarrow&#123;q^&#123;(1)&#125;&#125; S^&#123;(2)&#125; \xrightarrow&#123;q^&#123;(2)&#125;&#125; \cdots \xrightarrow&#123;q^&#123;(\ell-1)&#125;&#125; S^&#123;(\ell)&#125;.
      </div>

      <p class="text-gray-300 mt-4">
        For each <span class="math">i</span>,
        <span class="math">q^&#123;(i)&#125;</span> is a subspace polynomial
        of degree 2, whose kernel is 1-dimensional and contained in
        <span class="math">S^&#123;(i)&#125;</span>.
      </p>

      <!-- 2.5 Tensor Products of Fields -->
      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 &ensp;Tensor Products of Fields
      </h3>

      <p class="text-gray-300">
        We define the tensor product
        <span class="math">A := L \otimes_K L</span> of
        <span class="math">L</span> with itself over
        <span class="math">K</span>. Each
        <span class="math">A</span>-element is, concretely, a
        <span class="math">2^\kappa \times 2^\kappa</span> array of
        <span class="math">K</span>-elements. For each
        <span class="math">a \in A</span>, there is a unique tuple of
        <span class="math">L</span>-elements
        <span class="math">(a_v)_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125;</span>
        for which
        <span class="math">a = \sum_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125; a_v \otimes \beta_v</span>
        holds (the column representation). Similarly, there is a unique
        row representation.
      </p>

      <p class="text-gray-300 mt-4">
        The maps <span class="math">\varphi_0</span> and
        <span class="math">\varphi_1</span> respectively embed
        <span class="math">L</span> into
        <span class="math">A</span>&rsquo;s left-hand column and top
        row. Concretely,
        <span class="math">\varphi_0(\alpha) \cdot a</span> differs from
        <span class="math">a</span> by column-wise multiplication by
        <span class="math">\alpha</span>;
        <span class="math">\varphi_1(\alpha) \cdot a</span> differs from
        <span class="math">a</span> by row-wise multiplication by
        <span class="math">\alpha</span>.
      </p>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 2.2 (Packed Polynomial)
        </p>
        <p class="text-gray-300">
          For each extension <span class="math">L/K</span>, with
          <span class="math">K</span>-basis
          <span class="math">(\beta_v)_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125;</span>,
          and each multilinear
          <span class="math">t(X_0, \ldots, X_&#123;\ell-1&#125;)</span>
          over <span class="math">K</span>, we write
          <span class="math">\ell' := \ell - \kappa</span> and define
          the packed polynomial
          <span class="math">t'(X_0,\ldots,X_&#123;\ell'-1&#125;) := \sum_&#123;v \in \mathcal&#123;B&#125;_\kappa&#125; t(v_0,\ldots,v_&#123;\kappa-1&#125;,X_0,\ldots,X_&#123;\ell'-1&#125;) \cdot \beta_v</span>.
        </p>
      </div>

      <!-- 2.6 Proximity Gaps -->
      <h3 id="sec-2.6" class="text-xl font-semibold mt-8 mb-3">
        2.6 &ensp;Proximity Gaps
      </h3>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 2.3 (Ben-Sasson et al. [Ben+23, Thm. 4.1])
        </p>
        <p class="text-gray-300">
          For each proximity parameter
          <span class="math">e \in \&#123;0, \ldots, \lfloor \frac&#123;d-1&#125;&#123;2&#125; \rfloor\&#125;</span>
          and each pair of words
          <span class="math">u_0</span> and
          <span class="math">u_1</span> in
          <span class="math">L^&#123;2^&#123;\ell+\mathcal&#123;R&#125;&#125;&#125;</span>, if
          <span class="math">\Pr_&#123;r \in L&#125;[d((1-r) \cdot u_0 + r \cdot u_1, C) \le e] > \frac&#123;n&#125;&#123;|L|&#125;</span>,
          then
          <span class="math">d^2((u_i)_&#123;i=0&#125;^1, C^2) \le e</span>.
        </p>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 2.4 (Diamond&ndash;Gruen [DG25, Cor. 1])
        </p>
        <p class="text-gray-300">
          Reed&ndash;Solomon codes exhibit tensor-style proximity gaps
          within the unique decoding radius. For each proximity parameter
          <span class="math">e</span>, tensor arity
          <span class="math">\vartheta \geq 1</span>, and list of words,
          if the probability that the tensor combination is within
          distance <span class="math">e</span> to
          <span class="math">C</span> exceeds
          <span class="math">\vartheta \cdot \frac&#123;n&#125;&#123;|L|&#125;</span>,
          then the interleaved distance is at most
          <span class="math">e</span>.
        </p>
      </div>

      <!-- 2.7 Security Definitions -->
      <h3 id="sec-2.7" class="text-xl font-semibold mt-8 mb-3">
        2.7 &ensp;Security Definitions
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 2.8 (IOPCS)
        </p>
        <p class="text-gray-300">
          An interactive oracle polynomial commitment scheme (IOPCS) is
          a tuple of algorithms
          <span class="math">\Pi = (\mathsf&#123;Setup&#125;, \mathsf&#123;Commit&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>
          with Setup, Commit, and an evaluation IOP
          <span class="math">b \leftarrow \langle \mathcal&#123;P&#125;([f], s, r; t), \mathcal&#123;V&#125;([f], s, r) \rangle</span>.
        </p>
      </div>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 2.9 (Security of IOPCS)
        </p>
        <p class="text-gray-300">
          The IOPCS <span class="math">\Pi</span> is secure if, for each
          PPT adversary
          <span class="math">\mathcal&#123;A&#125;</span>, there exists a PPT
          emulator <span class="math">\mathcal&#123;E&#125;</span> and a
          negligible function <span class="math">\mathsf&#123;negl&#125;</span>
          such that
          <span class="math">\Pr[\mathsf&#123;Real&#125;_&#123;\mathcal&#123;A&#125;&#125;^&#123;\Pi,\ell&#125;(\lambda) \neq \mathsf&#123;Ideal&#125;_&#123;\mathcal&#123;E&#125;,\mathcal&#123;A&#125;&#125;^&#123;\Pi,\ell&#125;(\lambda)] \leq \mathsf&#123;negl&#125;(\lambda)</span>.
        </p>
      </div>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 2.10 (Small-Field IOPCS)
        </p>
        <p class="text-gray-300">
          A small-field IOPCS is defined identically to Definition 2.8,
          except that the polynomial
          <span class="math">t(X_0,\ldots,X_&#123;\ell-1&#125;)</span> is
          required to have coefficients in a subfield
          <span class="math">K \subset L</span>, and the emulator must
          extract a polynomial over <span class="math">K</span>.
        </p>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3. RING-SWITCHING                                            -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        3 &ensp;Ring-Switching
      </h2>

      <p class="text-gray-300">
        In this section, we formally present ring-switching. The key
        identity underlying the protocol is tensor-algebraic:
      </p>

      <div class="math-block">
        \varphi_1(t')(\varphi_0(r_\kappa),\ldots,\varphi_0(r_&#123;\ell-1&#125;)) = \sum_&#123;w \in \mathcal&#123;B&#125;_&#123;\ell'&#125;&#125; \varphi_0(\widetilde&#123;\operatorname&#123;eq&#125;&#125;(r_\kappa,\ldots,r_&#123;\ell-1&#125;,w_0,\ldots,w_&#123;\ell'-1&#125;)) \cdot \varphi_1(t'(w_0,\ldots,w_&#123;\ell'-1&#125;)). \tag&#123;30&#125;
      </div>

      <p class="text-gray-300 mt-4">
        For each pair of <span class="math">L</span>-elements
        <span class="math">\alpha_0</span> and
        <span class="math">\alpha_1</span>, the exterior product
        satisfies
        <span class="math">\alpha_0 \star \alpha_1 = \varphi_0(\alpha_0) \cdot \varphi_1(\alpha_1)</span>,
        where the right-hand product is the ambient multiplication in
        the tensor algebra.
      </p>

      <!-- 3.1 Ring-Switching Protocol -->
      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 &ensp;Ring-Switching Protocol
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Construction 3.1 (Ring-Switching Compiler)
        </p>
        <p class="text-gray-300">
          A large-field scheme
          <span class="math">\Pi' = (\mathsf&#123;Setup&#125;', \mathsf&#123;Commit&#125;', \mathcal&#123;P&#125;', \mathcal&#123;V&#125;')</span>
          is given as input. The small-field scheme
          <span class="math">\Pi</span> is defined as follows:
        </p>
        <ol class="text-gray-300 mt-2 ml-6 list-decimal space-y-2">
          <li>
            <strong>Setup:</strong> Run
            <span class="math">\Pi'.\mathsf&#123;Setup&#125;'(1^\lambda, \ell')</span>,
            where <span class="math">\ell' = \ell - \kappa</span>.
          </li>
          <li>
            <strong>Commit:</strong> Pack
            <span class="math">t(X_0,\ldots,X_&#123;\ell-1&#125;)</span>
            into
            <span class="math">t'(X_0,\ldots,X_&#123;\ell'-1&#125;)</span>
            via Definition 2.2; output
            <span class="math">\Pi'.\mathsf&#123;Commit&#125;'(\mathsf&#123;params&#125;, t')</span>.
          </li>
          <li>
            <strong>Evaluate:</strong>
            <span class="math">\mathcal&#123;P&#125;</span> computes
            <span class="math">\hat&#123;s&#125; := \varphi_1(t')(\varphi_0(r_\kappa), \dots, \varphi_0(r_&#123;\ell-1&#125;))</span>
            and sends the
            <span class="math">A</span>-element
            <span class="math">\hat&#123;s&#125;</span> to
            <span class="math">\mathcal&#123;V&#125;</span>.
            <span class="math">\mathcal&#123;V&#125;</span> checks the
            evaluation claim via the column decomposition, samples
            batching scalars, then both parties execute an
            <span class="math">\ell'</span>-round sumcheck. At the end,
            <span class="math">\mathcal&#123;V&#125;</span> computes
            <span class="math">e := \widetilde&#123;\text&#123;eq&#125;&#125;(\varphi_0(r_\kappa), \dots, \varphi_0(r_&#123;\ell-1&#125;), \varphi_1(r'_0), \dots, \varphi_1(r'_&#123;\ell'-1&#125;))</span>
            and verifies the final sumcheck check using the underlying
            large-field scheme.
          </li>
        </ol>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 3.2 (Completeness)
        </p>
        <p class="text-gray-300">
          If
          <span class="math">\Pi'</span> is complete, then
          <span class="math">\Pi</span> also is.
        </p>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 3.5 (Security)
        </p>
        <p class="text-gray-300">
          If
          <span class="math">\Pi'</span> is secure, then
          <span class="math">\Pi</span> also is. The soundness error
          contributed by ring-switching is at most
          <span class="math">\frac&#123;2 \cdot \ell' + \kappa&#125;&#123;|L|&#125;</span>.
        </p>
      </div>

      <!-- 3.2 Efficiency -->
      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 &ensp;Efficiency
      </h3>

      <p class="text-gray-300">
        <strong>Prover cost.</strong> The prover&rsquo;s main cost is
        that of computing the tensor expansion
        <span class="math">\bigotimes_&#123;i=\kappa&#125;^&#123;\ell-1&#125; (1 - r_i, r_i)</span>,
        taking
        <span class="math">2^&#123;\ell'&#125;</span>
        <span class="math">L</span>-multiplications. The total prover
        cost is
        <span class="math">O(2^\ell) \cdot \lambda</span>
        <span class="math">K</span>-operations&mdash;linear in the
        input length and the security parameter.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Verifier cost.</strong> To compute
        <span class="math">e</span>, the verifier must perform
        <span class="math">2 \cdot 2^\kappa \cdot \ell'</span>
        <span class="math">L</span>-multiplications (via Remark 3.4:
        alternating column-scaling and row-scaling with transpositions).
        The verifier is logarithmic in the statement size and quadratic
        in <span class="math">\lambda</span> (up to polylogarithmic
        factors):
        <span class="math">O(\ell) \cdot \widetilde&#123;O&#125;(\lambda^2)</span>
        <span class="math">K</span>-operations.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Comparison to Hashcaster.</strong> Hashcaster&rsquo;s
        verifier&rsquo;s dependence on
        <span class="math">\lambda</span> is cubic
        (<span class="math">\widetilde&#123;O&#125;(\lambda^3)</span>
        <span class="math">K</span>-operations), as opposed to our
        quadratic. Hashcaster&rsquo;s prover, if implemented na&iuml;vely,
        is about
        <span class="math">2^\kappa</span>-fold more costly than ours.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. BINARY BASEFOLD                                           -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        4 &ensp;Binary BaseFold
      </h2>

      <p class="text-gray-300">
        In this section, we present our large-field PCS. We tie together
        Lin, Chung and Han [LCH14]&rsquo;s additive NTT and FRI
        [BBHR18a].
      </p>

      <!-- 4.1 Using FRI in Novel Polynomial Basis -->
      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 &ensp;Using FRI in Novel Polynomial Basis
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 4.1 (Domains and Folding Maps)
        </p>
        <p class="text-gray-300">
          For each <span class="math">i \in \&#123;0, ..., \ell\&#125;</span>,
          we define the domain
          <span class="math">S^&#123;(i)&#125; := \widehat&#123;W&#125;_i(\langle \beta_0, \dots, \beta_&#123;\ell+\mathcal&#123;R&#125;-1&#125; \rangle)</span>.
          For each
          <span class="math">i \in \&#123;0, \dots, \ell - 1\&#125;</span>,
          we define
          <span class="math">q^&#123;(i)&#125;(X) := \frac&#123;W_i(\beta_i)^2&#125;&#123;W_&#123;i+1&#125;(\beta_&#123;i+1&#125;)&#125; \cdot X \cdot (X+1)</span>.
        </p>
      </div>

      <div class="formal-block formal-block-lemma mt-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 4.2
        </p>
        <p class="text-gray-300">
          For each
          <span class="math">i \in \&#123;0, ..., \ell-1\&#125;</span>,
          we have the equality
          <span class="math">q^&#123;(i)&#125; \circ \widehat&#123;W&#125;_i = \widehat&#123;W&#125;_&#123;i+1&#125;</span>
          of polynomials.
        </p>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 4.3
        </p>
        <p class="text-gray-300">
          For each
          <span class="math">i \in \&#123;0, ..., \ell - 1\&#125;</span>,
          <span class="math">q^&#123;(i)&#125;(S^&#123;(i)&#125;) = S^&#123;(i+1)&#125;</span>.
        </p>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Corollary 4.4
        </p>
        <p class="text-gray-300">
          For each
          <span class="math">i \in \&#123;0, \dots, \ell\&#125;</span>,
          <span class="math">\widehat&#123;W&#125;_i = q^&#123;(i-1)&#125; \circ \dots \circ q^&#123;(0)&#125;</span>
          holds.
        </p>
      </div>

      <!-- 4.2 FRI Folding, Revisited -->
      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 &ensp;FRI Folding, Revisited
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 4.6 (Lagrange-style Folding)
        </p>
        <p class="text-gray-300">
          We fix an index <span class="math">i</span> and a map
          <span class="math">f^&#123;(i)&#125;: S^&#123;(i)&#125; \to L</span>.
          For each <span class="math">r \in L</span>, we define
          <span class="math">\mathsf&#123;fold&#125;(f^&#123;(i)&#125;, r): S^&#123;(i+1)&#125; \to L</span>
          by setting, for each
          <span class="math">y \in S^&#123;(i+1)&#125;</span>:
        </p>
        <div class="math-block">
          \mathsf&#123;fold&#125;(f^&#123;(i)&#125;, r)(y) = \begin&#123;bmatrix&#125; 1 - r &amp; r \end&#123;bmatrix&#125; \cdot \begin&#123;bmatrix&#125; x_1 &amp; -x_0 \\ -1 &amp; 1 \end&#123;bmatrix&#125; \cdot \begin&#123;bmatrix&#125; f^&#123;(i)&#125;(x_0) \\ f^&#123;(i)&#125;(x_1) \end&#123;bmatrix&#125;
        </div>
        <p class="text-gray-300 mt-2">
          where
          <span class="math">(x_0, x_1) := q^&#123;(i)&#125;^&#123;-1&#125;(\&#123;y\&#125;)</span>
          is the fiber over <span class="math">y</span>.
        </p>
      </div>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Definition 4.8 (Iterated Folding)
        </p>
        <p class="text-gray-300">
          For a positive folding factor
          <span class="math">\vartheta</span>, we abbreviate
          <span class="math">\mathsf&#123;fold&#125;(f^&#123;(i)&#125;, r_0, \dots, r_&#123;\vartheta-1&#125;) := \mathsf&#123;fold&#125;(\dots \mathsf&#123;fold&#125;(f^&#123;(i)&#125;, r_0), \dots, r_&#123;\vartheta-1&#125;)</span>.
        </p>
      </div>

      <div class="formal-block formal-block-lemma mt-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 4.9
        </p>
        <p class="text-gray-300">
          For each folding factor <span class="math">\vartheta</span>,
          each <span class="math">y \in S^&#123;(i+\vartheta)&#125;</span>,
          there is a
          <span class="math">2^\vartheta \times 2^\vartheta</span>
          invertible matrix <span class="math">M_y</span> such that
          <span class="math">\mathsf&#123;fold&#125;(f^&#123;(i)&#125;,r_0,\ldots,r_&#123;\vartheta-1&#125;)(y) = [\bigotimes_&#123;j=0&#125;^&#123;\vartheta-1&#125;(1-r_j,r_j)] \cdot M_y \cdot [f^&#123;(i)&#125;(x_0), \ldots, f^&#123;(i)&#125;(x_&#123;2^\vartheta-1&#125;)]^T</span>.
        </p>
      </div>

      <!-- 4.3 Our Large-Field IOPCS -->
      <h3 id="sec-4.3" class="text-xl font-semibold mt-8 mb-3">
        4.3 &ensp;Our Large-Field IOPCS
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Construction 4.12 (Binary BaseFold IOPCS)
        </p>
        <p class="text-gray-300">
          We define
          <span class="math">\Pi = (\mathsf&#123;Setup&#125;, \mathsf&#123;Commit&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>:
        </p>
        <ol class="text-gray-300 mt-2 ml-6 list-decimal space-y-2">
          <li>
            <strong>Setup:</strong> Choose a binary field
            <span class="math">L/\mathbb&#123;F&#125;_2</span> of
            degree <span class="math">r \geq \ell + \mathcal&#123;R&#125;</span>.
            Fix a folding factor
            <span class="math">\vartheta \mid \ell</span> and a
            repetition parameter
            <span class="math">\gamma = \omega(\log \lambda)</span>.
          </li>
          <li>
            <strong>Commit:</strong> Use
            <span class="math">t</span>&rsquo;s Lagrange coefficients
            as the coefficients, in the novel polynomial basis, of
            <span class="math">P(X)</span>. Using Algorithm 2 (additive
            NTT), compute the Reed&ndash;Solomon codeword
            <span class="math">f: S^&#123;(0)&#125; \to L</span>.
          </li>
          <li>
            <strong>Evaluate:</strong> Interleave a sumcheck with FRI
            folding. For each round, the prover sends a sumcheck
            polynomial and folds its oracle. At multiples of
            <span class="math">\vartheta</span>, it commits the folded
            oracle (oracle-skipping). The verifier checks via
            <span class="math">\gamma</span> query repetitions.
          </li>
        </ol>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 4.13 (Completeness)
        </p>
        <p class="text-gray-300">
          The IOPCS of Construction 4.12 is complete.
        </p>
      </div>

      <div class="formal-block formal-block-lemma mt-6">
        <p class="font-semibold text-amber-400 mb-2">
          Lemma 4.14
        </p>
        <p class="text-gray-300">
          If <span class="math">f^&#123;(i)&#125;</span> is the
          evaluation of
          <span class="math">P^&#123;(i)&#125;(X) = \sum_&#123;j=0&#125;^&#123;2^&#123;\ell-i&#125;-1&#125; a_j \cdot X_j^&#123;(i)&#125;(X)</span>,
          then under honest prover behavior,
          <span class="math">f^&#123;(i+1)&#125;</span> is the
          evaluation of
          <span class="math">P^&#123;(i+1)&#125;(X) = \sum_&#123;j=0&#125;^&#123;2^&#123;\ell-i-1&#125;-1&#125; ((1-r_i') \cdot a_&#123;2j&#125; + r_i' \cdot a_&#123;2j+1&#125;) \cdot X_j^&#123;(i+1)&#125;(X)</span>.
        </p>
      </div>

      <div class="formal-block formal-block-theorem mt-6">
        <p class="font-semibold text-green-400 mb-2">
          Theorem 4.17 (Security)
        </p>
        <p class="text-gray-300">
          The IOPCS of Construction 4.12 is secure.
        </p>
      </div>

      <!-- 4.4 Efficiency -->
      <h3 id="sec-4.4" class="text-xl font-semibold mt-8 mb-3">
        4.4 &ensp;Efficiency
      </h3>

      <p class="text-gray-300">
        <strong>Prover cost.</strong> In its commitment phase, the
        prover uses Lin, Chung and Han&rsquo;s additive NTT to encode
        its length-<span class="math">2^\ell</span> vector, using
        <span class="math">2^&#123;\ell+\mathcal&#123;R&#125;-1&#125; \cdot \ell</span>
        <span class="math">L</span>-multiplications and
        <span class="math">2^&#123;\ell+\mathcal&#123;R&#125;&#125; \cdot \ell</span>
        <span class="math">L</span>-additions. The prover is linear-time.
      </p>

      <p class="text-gray-300 mt-4">
        <strong>Verifier cost.</strong> The verifier expends
        <span class="math">O(\ell)</span>
        <span class="math">L</span>-operations for the sumcheck, and
        <span class="math">O(\lambda \cdot \ell)</span> total
        <span class="math">L</span>-operations for
        <span class="math">\gamma</span> query repetitions.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. UNROLLED SMALL-FIELD IOPCS                                -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">
        5 &ensp;Unrolled Small-Field IOPCS
      </h2>

      <p class="text-gray-300">
        In this section, we describe a one-shot small-field IOPCS
        construction. This construction inlines the large-field IOPCS of
        Section 4 into the ring-switching reduction of Section 3, and
        streamlines the combination by unifying the two sumchecks.
      </p>

      <!-- 5.1 Combined Small-Field Protocol -->
      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 &ensp;Combined Small-Field Protocol
      </h3>

      <div class="formal-block formal-block-definition mt-6">
        <p class="font-semibold text-blue-400 mb-2">
          Construction 5.1 (Combined Small-Field IOPCS)
        </p>
        <p class="text-gray-300">
          We define
          <span class="math">\Pi = (\mathsf&#123;Setup&#125;, \mathsf&#123;Commit&#125;, \mathcal&#123;P&#125;, \mathcal&#123;V&#125;)</span>.
          Setup chooses a rate parameter
          <span class="math">\mathcal&#123;R&#125;</span> and an extension
          field <span class="math">L/K</span> of degree
          <span class="math">2^\kappa</span>. Commit packs
          <span class="math">t</span> into
          <span class="math">t'</span>, flattens
          <span class="math">t'</span> into a univariate polynomial
          <span class="math">P(X)</span> via the novel basis, and
          Reed&ndash;Solomon-encodes it via Algorithm 2. The evaluation
          IOP interleaves ring-switching&rsquo;s sumcheck with binary
          BaseFold&rsquo;s FRI folding:
          <span class="math">\mathcal&#123;P&#125;</span> sends
          <span class="math">\hat&#123;s&#125;</span>, the parties run an
          <span class="math">\ell'</span>-round sumcheck combined with
          oracle-skipping FRI, and
          <span class="math">\mathcal&#123;V&#125;</span> performs
          <span class="math">\gamma</span> query repetitions.
        </p>
      </div>

      <!-- 5.2 Efficiency -->
      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 &ensp;Efficiency
      </h3>

      <p class="text-gray-300">
        <strong>Concrete soundness.</strong> Construction 5.1&rsquo;s
        concrete soundness error is bounded from above by
      </p>

      <div class="math-block">
        \frac&#123;\kappa + 2 \cdot \ell'&#125;&#123;|L|&#125; + \frac&#123;2^&#123;\ell' + \mathcal&#123;R&#125;&#125;&#125;&#123;|L|&#125; + \left(\frac&#123;1&#125;&#123;2&#125; + \frac&#123;1&#125;&#123;2 \cdot 2^&#123;\mathcal&#123;R&#125;&#125;&#125;\right)^\gamma. \tag&#123;43&#125;
      </div>

      <p class="text-gray-300 mt-4">
        <strong>Proof sizes.</strong> In Table 1 below, we compare
        [DP25, Cons. 3.11] and Construction 5.1 on input polynomials
        over
        <span class="math">\mathbb&#123;F&#125;_2</span>, processing
        evaluation claims over
        <span class="math">\mathbb&#123;F&#125;_&#123;2^&#123;128&#125;&#125;</span>,
        attaining 100 bits of provable security.
      </p>

      <table class="w-full text-sm mt-6">
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">
              Num. Variables
              <span class="math">\ell</span>
            </th>
            <th class="text-left py-2 px-3 text-gray-300">
              Log Inv. Rate
              <span class="math">\mathcal&#123;R&#125;</span>
            </th>
            <th class="text-left py-2 px-3 text-gray-300">
              [DP25, Cons. 3.11]
            </th>
            <th class="text-left py-2 px-3 text-gray-300">
              Construction 5.1
            </th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3" rowspan="3">24 (2 MiB)</td>
            <td class="py-2 px-3">1</td>
            <td class="py-2 px-3">0.922 MiB</td>
            <td class="py-2 px-3">0.202 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">2</td>
            <td class="py-2 px-3">0.758 MiB</td>
            <td class="py-2 px-3">0.143 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">3</td>
            <td class="py-2 px-3">0.681 MiB</td>
            <td class="py-2 px-3">0.129 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3" rowspan="3">28 (32 MiB)</td>
            <td class="py-2 px-3">1</td>
            <td class="py-2 px-3">3.562 MiB</td>
            <td class="py-2 px-3">0.342 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">2</td>
            <td class="py-2 px-3">2.935 MiB</td>
            <td class="py-2 px-3">0.237 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">3</td>
            <td class="py-2 px-3">2.629 MiB</td>
            <td class="py-2 px-3">0.210 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3" rowspan="3">32 (512 MiB)</td>
            <td class="py-2 px-3">1</td>
            <td class="py-2 px-3">14.050 MiB</td>
            <td class="py-2 px-3">0.514 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">2</td>
            <td class="py-2 px-3">11.598 MiB</td>
            <td class="py-2 px-3">0.351 MiB</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">3</td>
            <td class="py-2 px-3">14.376 MiB</td>
            <td class="py-2 px-3">0.336 MiB</td>
          </tr>
        </tbody>
      </table>
      <p class="text-gray-500 text-xs mt-2">
        Table 1: Proof sizes of polynomial commitment schemes for
        <span class="math">\mathbb&#123;F&#125;_2</span>-multilinears.
        Folding factor
        <span class="math">\vartheta := 4</span>, Merkle cap height
        <span class="math">j := 8</span>.
      </p>

      <p class="text-gray-300 mt-6">
        <strong>Concrete performance.</strong> We benchmark
        Construction 5.1 against Plonky3 using Binius, an open-source
        SNARK. Both schemes use a 128-bit field. This work uses the
        GHASH field
        <span class="math">\mathbb&#123;F&#125;_2[X]/(X^&#123;128&#125; + X^7 + X^2 + X + 1) \cong \mathbb&#123;F&#125;_&#123;2^&#123;128&#125;&#125;</span>.
        Plonky3 uses the quartic extension of the Baby Bear prime field.
        Throughout, we use rate
        <span class="math">\rho = \frac&#123;1&#125;&#123;2&#125;</span>
        and attain 100 bits of provable security.
      </p>

      <table class="w-full text-sm mt-6">
        <thead>
          <tr class="border-b border-gray-700">
            <th class="text-left py-2 px-3 text-gray-300">Protocol</th>
            <th class="text-left py-2 px-3 text-gray-300">Proof Size</th>
            <th class="text-left py-2 px-3 text-gray-300">Commit (ST)</th>
            <th class="text-left py-2 px-3 text-gray-300">Commit (MT)</th>
            <th class="text-left py-2 px-3 text-gray-300">Prove (ST)</th>
            <th class="text-left py-2 px-3 text-gray-300">Prove (MT)</th>
            <th class="text-left py-2 px-3 text-gray-300">Verify (ST)</th>
          </tr>
        </thead>
        <tbody class="text-gray-400">
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Plonky3</td>
            <td class="py-2 px-3">1.931 MiB</td>
            <td class="py-2 px-3">24,893 ms</td>
            <td class="py-2 px-3">3,991 ms</td>
            <td class="py-2 px-3">13,257 ms</td>
            <td class="py-2 px-3">1,794 ms</td>
            <td class="py-2 px-3">18.2 ms</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Cons. 5.1</td>
            <td class="py-2 px-3">0.351 MiB</td>
            <td class="py-2 px-3">144 ms</td>
            <td class="py-2 px-3">44 ms</td>
            <td class="py-2 px-3">160 ms</td>
            <td class="py-2 px-3">71 ms</td>
            <td class="py-2 px-3">0.7 ms</td>
          </tr>
          <tr class="border-b border-gray-800">
            <td class="py-2 px-3">Cons. 5.1*</td>
            <td class="py-2 px-3">0.930 MiB</td>
            <td class="py-2 px-3">143 ms</td>
            <td class="py-2 px-3">44 ms</td>
            <td class="py-2 px-3">181 ms</td>
            <td class="py-2 px-3">75 ms</td>
            <td class="py-2 px-3">1.8 ms</td>
          </tr>
        </tbody>
      </table>
      <p class="text-gray-500 text-xs mt-2">
        Table 2: Concrete performance benchmarks on 28-variate
        multilinears over
        <span class="math">\mathbb&#123;F&#125;_2</span> (this work) and
        batches of 16 degree-<span class="math">2^&#123;24&#125;</span>
        polynomials over Baby Bear (Plonky3). AWS c7i.8xlarge, SHA-256
        Merklization.
      </p>

      <p class="text-gray-300 mt-4">
        Our scheme outperforms Plonky3 by between one and two orders of
        magnitude across all computational performance metrics. Our
        proofs are also smaller by more than fivefold.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">References</h2>
      <ol class="text-sm text-gray-400 space-y-3">
        <li id="ref-ACFY25">
          [ACFY25] Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, and
          Eylon Yogev. &ldquo;WHIR: Reed-Solomon Proximity Testing with
          Super-Fast Verification&rdquo;. EUROCRYPT 2025, pp.
          214&ndash;243.
        </li>
        <li id="ref-AER24">
          [AER24] Guillermo Angeris, Alex Evans, and Gyumin Roh.
          <em>A Note on Ligero and Logarithmic Randomness</em>. ePrint
          2024/1399.
        </li>
        <li id="ref-AHIV23">
          [AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and
          Muthuramakrishnan Venkitasubramaniam. &ldquo;Ligero:
          lightweight sublinear arguments without a trusted
          setup&rdquo;. <em>Designs, Codes and Cryptography</em> (2023).
        </li>
        <li id="ref-BBHR18a">
          [BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and
          Michael Riabzev. &ldquo;Fast Reed-Solomon Interactive Oracle
          Proofs of Proximity&rdquo;. ICALP 2018, 14:1&ndash;14:17.
        </li>
        <li id="ref-BBHR18b">
          [BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and
          Michael Riabzev. <em>Scalable, transparent, and post-quantum
          secure computational integrity</em>. ePrint 2018/046.
        </li>
        <li id="ref-BCG20">
          [BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth.
          &ldquo;Linear-Time Arguments with Sublinear Verification from
          Tensor Codes&rdquo;. TCC 2020, pp. 19&ndash;46.
        </li>
        <li id="ref-BCS16">
          [BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas
          Spooner. &ldquo;Interactive Oracle Proofs&rdquo;. TCC 2016,
          pp. 31&ndash;60.
        </li>
        <li id="ref-Ben23">
          [Ben+23] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik
          Kopparty, and Shubhangi Saraf. &ldquo;Proximity Gaps for
          Reed&ndash;Solomon Codes&rdquo;. <em>Journal of the ACM</em>
          70.5 (Oct. 2023).
        </li>
        <li id="ref-BGKS19">
          [BGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and
          Shubhangi Saraf. <em>DEEP-FRI: Sampling Outside the Box
          Improves Soundness</em>. ePrint 2019/336.
        </li>
        <li id="ref-Bre25">
          [Bre+25] Martijn Brehm, Binyi Chen, Ben Fisch, Nicolas Resch,
          Ron D. Rothblum, and Hadas Zeilberger. &ldquo;Blaze: Fast
          SNARKs from Interleaved RAA Codes&rdquo;. EUROCRYPT 2025, pp.
          123&ndash;152.
        </li>
        <li id="ref-Can89">
          [Can89] David G Cantor. &ldquo;On arithmetical algorithms over
          finite fields&rdquo;. <em>J. Combinatorial Theory, Series
          A</em> 50.2 (1989), pp. 285&ndash;300.
        </li>
        <li id="ref-CBBZ23">
          [CBBZ23] Binyi Chen, Benedikt B&uuml;nz, Dan Boneh, and
          Zhenfei Zhang. &ldquo;HyperPlonk: Plonk with Linear-Time
          Prover and High-Degree Custom Gates&rdquo;. EUROCRYPT 2023.
        </li>
        <li id="ref-Chi20">
          [Chi+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush
          Mishra, Noah Vesely, and Nicholas Ward. &ldquo;Marlin:
          Preprocessing zkSNARKs with Universal and Updatable
          SRS&rdquo;. EUROCRYPT 2020, pp. 738&ndash;768.
        </li>
        <li id="ref-COS20">
          [COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner.
          &ldquo;Fractal: Post-quantum and Transparent Recursive Proofs
          from Holography&rdquo;. EUROCRYPT 2020, pp. 769&ndash;793.
        </li>
        <li id="ref-DG25">
          [DG25] Benjamin E. Diamond and Angus Gruen. &ldquo;Proximity
          Gaps in Interleaved Codes&rdquo;. <em>IACR Comms. in
          Cryptology</em> 1.4 (Jan. 2025).
        </li>
        <li id="ref-DP24">
          [DP24] Benjamin E. Diamond and Jim Posen. &ldquo;Proximity
          Testing with Logarithmic Randomness&rdquo;. <em>IACR Comms. in
          Cryptology</em> 1.1 (2024).
        </li>
        <li id="ref-DP25">
          [DP25] Benjamin E. Diamond and Jim Posen. &ldquo;Succinct
          Arguments over Towers of Binary Fields&rdquo;. EUROCRYPT 2025,
          pp. 93&ndash;122.
        </li>
        <li id="ref-GG13">
          [GG13] Joachim von zur Gathen and J&uuml;rgen Gerhard.
          <em>Modern Computer Algebra</em>. 3rd Edition. Cambridge
          University Press, 2013.
        </li>
        <li id="ref-GLL19">
          [GLL19] Shay Gueron, Adam Langley, and Yehuda Lindell.
          <em>AES-GCM-SIV: Nonce Misuse-Resistant Authenticated
          Encryption</em>. RFC 8452, Apr. 2019.
        </li>
        <li id="ref-GM10">
          [GM10] Shuhong Gao and Todd Mateer. &ldquo;Additive Fast
          Fourier Transforms Over Finite Fields&rdquo;. <em>IEEE Trans.
          Inf. Theory</em> 56.12 (2010), pp. 6265&ndash;6272.
        </li>
        <li id="ref-Gol23">
          [Gol+23] Alexander Golovnev, Jonathan Lee, Srinath Setty,
          Justin Thaler, and Riad S. Wahby. &ldquo;Brakedown:
          Linear-Time and Field-Agnostic SNARKs for R1CS&rdquo;. CRYPTO
          2023, pp. 193&ndash;226.
        </li>
        <li id="ref-Gur06">
          [Gur06] Venkatesan Guruswami. <em>Algorithmic Results in List
          Decoding</em>. Foundations and Trends in TCS 2. now publishers,
          2006.
        </li>
        <li id="ref-GWC19">
          [GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana
          Ciobotaru. <em>PLONK</em>. ePrint 2019/953.
        </li>
        <li id="ref-Hab22">
          [Hab22] Ulrich Hab&ouml;ck. <em>A summary on the FRI low
          degree test</em>. ePrint 2022/1216.
        </li>
        <li id="ref-Hab24">
          [Hab24] Ulrich Hab&ouml;ck. <em>A note on the G-FFT</em>.
          ePrint 2024/1036.
        </li>
        <li id="ref-HLP24">
          [HLP24] Ulrich Hab&ouml;ck, David Levit, and Shahar Papini.
          <em>Circle STARKs</em>. ePrint 2024/278.
        </li>
        <li id="ref-LAH16">
          [LAH16] S.-J. Lin, T. Y. Al-Naffouri, and Y. S. Han.
          &ldquo;FFT Algorithm for Binary Extension Finite Fields and
          Its Application to Reed&ndash;Solomon Codes&rdquo;. <em>IEEE
          Trans. Inf. Theory</em> 62.10 (2016), pp. 5343&ndash;5358.
        </li>
        <li id="ref-Lan02">
          [Lan02] Serge Lang. <em>Algebra</em>. Revised Third Edition.
          Springer, 2002.
        </li>
        <li id="ref-LCH14">
          [LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han.
          &ldquo;Novel Polynomial Basis and Its Application to
          Reed&ndash;Solomon Erasure Codes&rdquo;. IEEE FOCS 2014, pp.
          316&ndash;325.
        </li>
        <li id="ref-Li18">
          [Li+18] Wen-Ding Li, Ming-Shing Chen, Po-Chun Kuo, Chen-Mou
          Cheng, and Bo-Yin Yang. &ldquo;Frobenius Additive Fast Fourier
          Transform&rdquo;. ACM ISSAC 2018.
        </li>
        <li id="ref-LN96">
          [LN96] Rudolf Lidl and Harald Niederreiter. <em>Finite
          Fields</em>. 2nd Edition. Cambridge University Press, 1996.
        </li>
        <li id="ref-LX24">
          [LX24] Songsong Li and Chaoping Xing. &ldquo;Fast Fourier
          transform via automorphism groups of rational function
          fields&rdquo;. SODA 2024, pp. 3836&ndash;3859.
        </li>
        <li id="ref-MBKM19">
          [MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah
          Meiklejohn. &ldquo;Sonic: Zero-Knowledge SNARKs from
          Linear-Size Universal and Updatable Structured Reference
          Strings&rdquo;. ACM CCS 2019, pp. 2111&ndash;2128.
        </li>
        <li id="ref-RR24">
          [RR24] Noga Ron-Zewi and Ron Rothblum. &ldquo;Local Proofs
          Approaching the Witness Length&rdquo;. <em>Journal of the
          ACM</em> 71.3 (June 2024).
        </li>
        <li id="ref-Set20">
          [Set20] Srinath Setty. &ldquo;Spartan: Efficient and
          General-Purpose zkSNARKs Without Trusted Setup&rdquo;. CRYPTO
          2020, pp. 704&ndash;737.
        </li>
        <li id="ref-Sou24">
          [Sou24] Lev Soukhanov. &ldquo;Hashcaster&rdquo;. Unpublished
          report. Sept. 2024.
        </li>
        <li id="ref-Tha22">
          [Tha22] Justin Thaler. <em>Proofs, Arguments and
          Zero-Knowledge</em>. Foundations and Trends in Privacy and
          Security, vol. 4. now publishers, 2022.
        </li>
        <li id="ref-Wat79">
          [Wat79] William C. Waterhouse. &ldquo;The Normal Basis
          Theorem&rdquo;. <em>The American Mathematical Monthly</em>
          86.3 (1979), pp. 212&ndash;212.
        </li>
        <li id="ref-Xie19">
          [Xie+19] Tiacheng Xie, Jiaheng Zhang, Yupeng Zhang,
          Charalampos Papamanthou, and Dawn Song. &ldquo;Libra: Succinct
          Zero-Knowledge Proofs with Optimal Prover Computation&rdquo;.
          CRYPTO 2019, pp. 733&ndash;764.
        </li>
        <li id="ref-ZCF24">
          [ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch.
          &ldquo;BaseFold: Efficient Field-Agnostic Polynomial
          Commitment Schemes from Foldable Codes&rdquo;. CRYPTO 2024,
          pp. 138&ndash;169.
        </li>
        <li id="ref-ZXZS20">
          [ZXZS20] Jiaheng Zhang, Tiancheng Xie, Yupeng Zhang, and Dawn
          Song. &ldquo;Transparent Polynomial Delegation and Its
          Applications to Zero Knowledge Proof&rdquo;. IEEE S&amp;P
          2020, pp. 859&ndash;876.
        </li>
      </ol>
    </section>
  </article>
</BaseLayout>
