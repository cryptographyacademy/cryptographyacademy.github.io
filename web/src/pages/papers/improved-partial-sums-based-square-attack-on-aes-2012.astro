---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/280';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved ``Partial Sums&quot;-based Square Attack on AES';
const AUTHORS_HTML = 'Michael Tunstall';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The Square attack as a means of attacking reduced round variants of AES was described in the initial description of the Rijndael block cipher. This attack can be applied to AES, with a relatively small number of chosen plaintext-ciphertext pairs, reduced to less than six rounds in the case of AES-128 and seven rounds otherwise and several extensions to this attack have been described in the literature. In this paper we describe new variants of these attacks that have a smaller time complexity than those present in the literature. Specifically, we demonstrate that the quantity of chosen plaintext-ciphertext pairs can be halved producing the same reduction in the time complexity. We also demonstrate that the time complexity can be halved again for attacks applied to AES-128 and reduced by a smaller factor for attacks applied to AES-192. This is achieved by eliminating hypotheses on-the-fly when bytes in consecutive subkeys are related because of the key schedule.</p>
    </section>

    <p class="text-gray-300">The Advanced Encryption Standard (AES) [8] was standardized in 2001 from a proposal by Daemen and Rijmen [5]. It has since been analyzed with regard to numerous attacks ranging from purely theoretical cryptanalysis to attacks that require some extra information, e.g from some side channel [11], to succeed.</p>

    <p class="text-gray-300">In Daemen and Rijmen's AES proposal an attack is described that is referred to as the Square attack [5]. This attack was so-called since it was first presented in the description of the block cipher Square [4]. The Square attack is based on a particular property arising from the structure of AES. That is, for a set of 256 plaintexts where each byte at an arbitrary index is a distinct value and all the other bytes are equal, the XOR sum of the 256 intermediate states after three rounds of AES will be zero.</p>

    <p class="text-gray-300">Some optimizations to this attack have been proposed in the literature. Ferguson et al. proposed a way of conducting the Square attack referred to as the &quot;partial sums&quot; method [7]. This allowed the Square attack to be conducted with a relatively low time complexity for reduced round variants of AES. The time complexity of these attacks was further reduced following an observation made by Lucks. He noted that given a known last subkey in AES-192 then information on previous subkeys can be derived.</p>

    <p class="text-gray-300">Recent cryptanalytical attacks have predominantly been focused on other properties, such as impossible differentials [1, 9, 12]. The use of impossible differentials is related to the Square attack but allows an attacker to overcome variants of AES with more rounds. Recently, a marginal attack on AES has also been proposed that is based on the use of bicliques [3]. However, for suitably reduced round variants of AES the &quot;partial sums&quot; method proposed by Ferguson et al. is currently the most efficient chosen plaintext attack.</p>

    <p class="text-gray-300">In this paper we describe how the attacks proposed by Ferguson et al. and Lucks can be improved. Specifically, we show that the number of chosen plaintext-ciphertext pairs required to conduct the Square attack can be halved and therefore halve the time complexity of the attack. Moreover, we demonstrate that the time complexity of the Square attack can be halved again when applied to AES-128, and reduced to a lesser extent for AES-192, by exploiting relationships between key bytes as they are derived. In this paper we restrict ourselves to attacks that require a relatively small number of chosen plaintext-ciphertext pairs. The attacks proposed by Ferguson et al., based on the Square attack, that require around  <span class="math">2^{128}</span>  chosen plaintext-ciphertext pairs are beyond the cope of this paper [7].</p>

    <p class="text-gray-300">This paper is organized as follows. In Section 2 we define the notation we use to describe AES. In Section 3 we describe the property that the Square attack is based on. In Section 4 we describe how the Square attack can be applied to AES-128, and in Section 5 we describe how the Square can be applied to AES-192 and AES-256. We summarize our contribution and conclude in Section 6.</p>

    <p class="text-gray-300">return C</p>

    <p class="text-gray-300">In this paper, multiplications in  <span class="math">\\mathbb{F}_{2^8}</span>  are considered to be polynomial multiplications modulo the irreducible polynomial  <span class="math">x^8 + x^4 + x^3 + x + 1</span> . It should be clear from the context when a mathematical expression contains integer multiplication.</p>

    <pre><code class="language-text">Algorithm 1: The AES encryption function.Input: The 128-bit plaintext block P and 128, 192 or 256-bit secret key K, with N set to 10, 12, 14 respectively.Output: The 128-bit ciphertext block C.X \\leftarrow \\text{AddRoundKey}(P, K);for i \\leftarrow 1 to N doX \\leftarrow \\text{SubBytes}(X);X \\leftarrow \\text{ShiftRows}(X);if i \\neq N thenX \\leftarrow \\text{MixColumns}(X);endX \\leftarrow \\text{AddRoundKey}(X, K);endC \\leftarrow X;
</code></pre>

    <p class="text-gray-300">The structure of the Advanced Encryption Standard (AES), as used to perform encryption, is illustrated in Algorithm 1. In discussing the AES we consider that all intermediate variables of the encryption operation variables are arranged in a  <span class="math">4 \\times 4</span>  array of bytes, referred to as the state matrix. For example, the 128-bit plaintext  <span class="math">P = (p_1, p_2, \\dots, p_{16})</span> , where each  <span class="math">p_i \\in \\{1, \\dots, 16\\}</span>  is one byte, is arranged in the following fashion</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} p_1 &amp; p_5 &amp; p_9 &amp; p_{13} \\\\ p_2 &amp; p_6 &amp; p_{10} &amp; p_{14} \\\\ p_3 &amp; p_7 &amp; p_{11} &amp; p_{15} \\\\ p_4 &amp; p_8 &amp; p_{12} &amp; p_{16} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">The encryption itself is conducted by the repeated use of a round function that comprises the following operations executed in sequence:</p>

    <p class="text-gray-300">The AddRoundKey operation XORs each byte of the array with a byte from a corresponding subkey. In each instance of the AddRoundKey a fresh 16-byte subkey is used from the subkey bytes generated by the key schedule. We describe how this is done in more detail for the different variants of AES in Section 2.2.</p>

    <p class="text-gray-300">The SubBytes operation is the only nonlinear step of the block cipher, consisting of a substitution table applied to each byte of the state. This replaces each byte of the state matrix by its multiplicative inverse, followed by an affine mapping. In the remainder of this paper we will refer to the function S as this substitution table and  <span class="math">S^{-1}</span>  as its inverse.</p>

    <p class="text-gray-300">The ShiftRows operation is a byte-wise permutation of the state that operates on each row.</p>

    <p class="text-gray-300">The MixColumns operation operates on the state column by column. Each column of the state matrix is considered as a vector where each of its four elements belong to  <span class="math">\\mathbb{F}_{2^8}</span> . A  <span class="math">4\\times 4</span>  matrix M whose elements are also in  <span class="math">\\mathbb{F}_{2^8}</span>  is used to map this column into a new vector. This operation is applied to the four columns of the state matrix. Here M and its inverse  <span class="math">M^{-1}</span>  are defined as</p>

    <p class="text-gray-300"><span class="math">$M = \\begin{pmatrix} 2 &amp; 3 &amp; 1 &amp; 1 \\\\ 1 &amp; 2 &amp; 3 &amp; 1 \\\\ 1 &amp; 1 &amp; 2 &amp; 3 \\\\ 3 &amp; 1 &amp; 1 &amp; 2 \\end{pmatrix} \\text{ and } M^{-1} = \\begin{pmatrix} 14 &amp; 11 &amp; 13 &amp; 9 \\\\ 9 &amp; 14 &amp; 11 &amp; 13 \\\\ 13 &amp; 9 &amp; 14 &amp; 11 \\\\ 11 &amp; 13 &amp; 9 &amp; 14 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">All the elements in M and  <span class="math">M^{-1}</span>  are elements of  <span class="math">\\mathbb{F}_{2^8}</span>  expressed in decimal.</p>

    <p class="text-gray-300">In Algorithm 1 we can see that the last round does not include the execution of a MixColumns operation. In all the attacks considered in this paper we will assume that the last round does not include a MixColumns operation. This is important to note since it has been shown that the presence of a MixColumns operation in the last round would affect the security of AES [6].</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 The Key Schedule</h3>

    <p class="text-gray-300">The key schedule generates a series of subkeys from the secret key. There are three variants of the AES corresponding to the three possible bit lengths of the secret key used, i.e. 128, 192 or 256 bits. In Algorithm 2 we show how the subkey bytes are generated from an initial secret key K. The function S is the substitution function used in the SubBytes operation described above. The function f is, for the most part, the identity function. However, when K is a 256-bit key and f is the substitution function f is a round constant that changes for each loop. We refer the reader to the AES specification for a more detailed description of the key schedule [8].</p>

    <p class="text-gray-300">For AES-128, knowing one subkey will allow the original key to be derived. For AES-192 and AES-256 there will still be some ambiguity and two subkeys are required to derive the original key.</p>

    <p class="text-gray-300">If we consider two plaintexts that have a XOR difference that is non-zero in one byte, then this difference will expand in a known manner. After one round the XOR difference between the intermediate states would show that one column of the state matrix has a non-zero difference. This property will then propagate to all the bytes in the state matrix after the second round by the same reasoning. An example where the difference in two plaintexts is at index one is shown in Figure 1.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Algorithm 2:</strong> The AES key schedule function.</h4>

    <pre><code class="language-text">Input: X-bit secret key K, with X set to 128, 192 or 256 and N set to 10, 12, 14 respectively, RCON. Output: W a stream of subkey bytes. for i \\leftarrow 0 to X/8 - 1 do W[i] \\leftarrow K[i]; for i \\leftarrow 1 to \\lceil (N+1) \\cdot (X/128)^2 \\rceil do
</code></pre>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} \\mathsf{Plaintext} \\\\ \\begin{pmatrix} \\mathsf{Q} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp;</span>$</p>

    <p class="text-gray-300">Fig. 1. Propagation of a one-byte difference across two rounds of AES. A structure in this difference is imposed by the MixColumns operation (see Section 2.1).</p>

    <p class="text-gray-300">It is therefore impossible that the XOR difference between two such plaintexts will be zero in any byte after two rounds. This property will persist until the next MixColumns operation, and is used for impossible differential cryptanalysis since the XOR difference after two rounds cannot be zero [2].</p>

    <p class="text-gray-300">This property is also used to construct an attack referred to as the Square attack (so-called since it was first presented in the description of the block cipher Square [4]) and was first presented in the original description of AES [5]. We consider 256 distinct plaintexts that are equal in fifteen bytes. After computing two rounds of AES the property described above will be valid between all possible pairs, i.e. across all 256 intermediate states the bytes at each index will contain one of each possible value. The XOR sum of the 256 bytes at each index will therefore be equal to zero. There will not be one instance of each possible value across the 256 bytes at each index after the next MixColumns operation. However, the XOR sum of the bytes at each index will still be zero after the MixColumns operation, and this property will remain true until the next SubBytes operation. In the remainder of this paper we will refer to a set of 256 chosen plaintext-ciphertext pairs where the 256 distinct plaintexts that are equal in fifteen bytes as a  <span class="math">\\delta</span> -set.</p>

    <p class="text-gray-300">Attacks based on the Square attack applicable to AES-128 are presented in this section.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Analyzing Four-Round AES</h3>

    <p class="text-gray-300">An attack based on the property described in Section 3 was originally detailed by Daemen and Rijmen in their AES proposal [5]. If we consider one  <span class="math">\\delta</span> -set, the XOR sum of the intermediate states at the end of the third round is equal to zero. For a four-round variant of AES an attacker can use this observation to validate hypotheses on the last subkey byte-by-byte, where an attacker checks that the XOR sum of the input to the final round is equal to zero. For each byte this will return the correct subkey byte and one additional incorrect hypothesis per byte with a probability of 255/256. That is, any random sequence of byte will have an XOR sum equal to zero with a probability of 1/256 and there are 255 such sequences. This will result in an expected total number of key hypotheses for the last subkey of  <span class="math">\\left(1+\\frac{255}{256}\\right)^{16}\\approx 2^{16}</span> , since the length of the lists of hypotheses are mutually independent. One can determine the key if one repeats the analysis, i.e. one takes  <span class="math">2^9</span>  chosen plaintexts and conducts the above analysis twice. This would have a time complexity of  <span class="math">2^9</span>  one-round decryptions ( <span class="math">2^7</span>  encryptions of a four-round AES).</p>

    <p class="text-gray-300">Biham and Keller observed the sum of a sequence of random bytes can be computed by only considering one example of values that occur with an odd-numbered frequency. Since values that occur with an even-numbered frequency will have no effect on the XOR sum across all 256 intermediate values [2]. Given 256 bytes taken from the same index from a  <span class="math">\\delta</span> -set, one can remove all values that occur with an even-numbered frequency and keep one example of those that occur with an odd-numbered frequency.</p>

    <p class="text-gray-300">We define Z as the number of instances of a given value that occur in a sequence of 256 bytes. The probability of observing a given value n times is</p>

    <p class="text-gray-300"><span class="math">$\\Pr(Z=n) = {256 \\choose n} 256^{-n} \\left(1 - \\frac{1}{256}\\right)^{256-n} \\tag{1}</span>$</p>

    <p class="text-gray-300">for  <span class="math">1 \\le n \\le 256</span> . The probability of observing an odd number of a given value is therefore  <span class="math">\\Pr(X = 1) + \\Pr(X = 3) + \\ldots + \\Pr(X = 255) = 0.43</span> , and therefore the number of values that need to be treated decreases to  <span class="math">256 \\times 0.43 = 110</span> . The analysis given by Biham and Keller stops here and we provide a more precise analysis below.</p>

    <p class="text-gray-300">We define Y as the number of distinct values that occur in a sequence of 256 bytes. The probability of observing m distinct values is</p>

    <p class="text-gray-300"><span class="math">$\\Pr(Y=m) = \\frac{256_{(m)} \\left\\{ {256 \\atop m} \\right\\}}{256^{256}}, \\tag{2}</span>$</p>

    <p class="text-gray-300">for  <span class="math">1 \\leq m \\leq 256</span> . We define  <span class="math">r_{(m)} = r\\,(r-1)\\dots(r-m+1)</span>  and  <span class="math">\\left\\{\\begin{smallmatrix} n\\\\i \\end{smallmatrix}\\right\\}</span>  as a function that returns the Stirling numbers of the second kind. That is, the number of ways of partitioning n elements into i non-empty sets. The expectation of x is simply  <span class="math">\\sum_{i=1}^{256} i\\,\\Pr(Y=i) = 162</span> .</p>

    <p class="text-gray-300">For a sequence of 256 bytes that consist of m distinct values, the probability distribution will be somewhat similar to that defined by Biham and Keller. Again we define Z as the number of instances of a given value that occur in a sequence of 256 bytes. The probability of observing observing a given value n times given that there are m distinct values is</p>

    <p class="text-gray-300"><span class="math">$\\Pr(Z = n \\mid Y = m) = {256 \\choose n} m^{-n} \\left( 1 - \\frac{1}{m} \\right)^{256 - n}</span>$
(3)</p>

    <p class="text-gray-300">for  <span class="math">1 \\le m, n \\le 256</span> . Again, the probability of observing an odd number of a given value is therefore  <span class="math">\\Pr(X=1 \\mid Y=m) + \\Pr(X=3 \\mid Y=m) + \\ldots + \\Pr(X=255 \\mid Y=m)</span>  for a given m. We define A as the number of distinct values that occur with an odd-numbered frequency. Then the expectation of A</p>

    <p class="text-gray-300">will be:</p>

    <p class="text-gray-300"><span class="math">$E(A) = \\sum_{i=1}^{256} i \\Pr(Y=i) \\sum_{j=0}^{127} \\Pr(Z=(2j+1) | Y=i) \\approx 78</span>$
(4)</p>

    <p class="text-gray-300">That is, the sum of the number of distinct values occurring with an odd-numbered frequency i P<sup>127</sup> <sup>j</sup>=0 Pr(X = (2 j + 1)| Y = i) multiplied by the probability of it occurring. This would reduce the time complexity of an attack requiring two &delta;-sets to 156 one-round decryptions (approximately 2<sup>5</sup> encryptions of a four-round AES).</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Analyzing Five-Round AES</h3>

    <p class="text-gray-300">An extension to the above attack was also first presented in the original description of AES [5]. This attack allowed an extra round to be analyzed with an increase in the time complexity. Rather than analyzing the final subkey byte-by-byte, one analyzes the penultimate subkey.</p>

    <p class="text-gray-300">In order to do this one is obliged to guess 32 bits of the final subkey to determine one column of the state matrix before the XOR with the penultimate subkey. One can then compute the MixColumns operation on this column, and validate hypotheses on a byte of a subkey equivalent to the penultimate subkey (one could compute the MixColumns operation on the derived subkey to determine the penultimate subkey). A valid byte would allow the property described in Section 3 to be observed. Each evaluation reduces the potential key space of five bytes being analyzed by a factor of 256, and one would need to conduct this analysis five times to determine 32 bits of the final subkey [5].</p>

    <p class="text-gray-300">If we define each of the 2<sup>32</sup> partial decryptions as having a time complexity equivalent to a quarter of a round, analyzing five sets of 256 ciphertexts to determine 32 bits of the last subkey and eight bits of the &quot;penultimate&quot; subkey, can be computed with an effort equivalent to 240/4 one-round AES decryptions for one &delta;-set. Given this is a quarter of the work required for one set of 256 acquisitions, the total complexity to determine a key using five &delta;-sets would be 5 &middot; 2 <sup>40</sup> one-round AES decryptions, or equivalent to 2<sup>40</sup> five-round AES encryption operations.</p>

    <p class="text-gray-300">The cryptanalysis cannot be significantly improved by following the reasoning given in Section 4.1. That is, if one partially decrypts a &delta;-set using hypotheses on 32 bits of the last subkey, one can then form hypotheses on individual bytes of the penultimate subkey using one example of distinct values that occur with an odd-numbered frequency. One could follow this reasoning with the 32-bit values taken from the ciphertexts. However, over 256 acquisitions the probability of observing a value that occurs with an even-numbered frequency will be too low to have any significant impact on the time complexity of an attack.</p>

    <p class="text-gray-300">Ferguson et al. present a way of conducting this attack that is referred to as the &quot;partial sums&quot; method [7]. They observe that conducting the attack involves computing</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i} S^{-1}(S_0(c_{i,0} \\oplus k_0) \\oplus S_1(c_{i,1} \\oplus k_1) \\oplus S_2(c_{i,2} \\oplus k_2) \\oplus S_3(c_{i,3} \\oplus k_3) \\oplus k_4),</span>$
(5)</p>

    <p class="text-gray-300">where S&lambda;, for &lambda; &isin; {0, . . . , 3}, are bijective look-up tables that consist of the function S and a multiplication by a field element from F<sup>2</sup> <sup>8</sup> . These are evaluated efficiently by associating a &quot;partial sum&quot; x<sup>k</sup> to each ciphertext where x<sup>k</sup> is defined as</p>

    <p class="text-gray-300"><span class="math">$x_k \\leftarrow \\sum_{j=0}^k S_j \\left( c_j \\oplus k_j \\right) \\,. \\tag{6}</span>$</p>

    <p class="text-gray-300">This gives a map from (c0, c1, c2, c3) 7&rarr; (xk, xk+1, . . . , c3). In order to conduct an attack one can compute (x1, c2, c3), i.e. ((S0(c<sup>0</sup> &oplus; k0) &oplus; S1(c<sup>1</sup> &oplus; k1)), c2, c3), for all the ciphertexts in a &delta;-set for all possible values of  <span class="math">k_0</span>  and  <span class="math">k_1</span> . This will take  <span class="math">2^{24}</span>  executions of the function S resulting in  <span class="math">2^{24}</span>  values for  <span class="math">(x_1, c_2, c_3)</span> . This continues by computing  <span class="math">(x_2, c_3)</span>  for all possible values of  <span class="math">k_2</span>  that also requires a  <span class="math">2^{24}</span>  executions of the function S resulting in  <span class="math">2^{32}</span>  values for  <span class="math">(x_2, c_3)</span> . Computing the  <span class="math">2^{40}</span>  values for  <span class="math">x_3</span>  for all values of  <span class="math">k_3</span>  will require a further  <span class="math">2^{40}</span>  executions of the function S. The last step will require  <span class="math">2^{48}</span>  executions of the function  <span class="math">S^{-1}</span> . Using the estimate provided by Ferguson et al., that the time complexity of one AES encryption is equivalent to  <span class="math">2^8</span>  executions of the function S [7], implementing the attack described above will have a time complexity equivalent to approximately  <span class="math">2^{40}</span>  five-round AES encryption operations. This has the same time complexity as the straightforward approach described previously. The method reported by Ferguson et al. can only be applied when groups of  <span class="math">\\delta</span> -sets are treated together (see Section 4.3).</p>

    <p class="text-gray-300">The above analyses assume that one only considers one byte of the subkey that is equivalent to the penultimate subkey. However, if we consider more bytes of the penultimate subkey then fewer  <span class="math">\\delta</span> -sets are required. An attacker guesses 32 bits of the last subkey which allows an attacker to validate hypotheses on four bytes of a subkey that is equivalent to the penultimate subkey. For one guess of 32 bits of the final subkey one would expect a hypothesis for any byte of the subkey that is equivalent to the penultimate subkey to produce an XOR sum equal to zero with a probability equal to  <span class="math">1/2^8</span> . Given that there are four such bytes the probability that four bytes of this subkey will produce four sequences with XOR sums equal to zero is  <span class="math">1/2^{32}</span> . Therefore, in order to determine 32 bits of the last subkey and 32 bits of a subkey equivalent to the penultimate subkey one would expect to need two  <span class="math">\\delta</span> -sets. This would reduce the time complexity of the attack detailed by Daemen and Rijmen [5] to approximately  <span class="math">2^{39}</span>  five-round AES encryption operations.</p>

    <p class="text-gray-300">The analysis of the hypotheses can be further optimized if the relationship between the last and penultimate subkey are verified as the attack progresses. If we consider one  <span class="math">\\delta</span> -set, one can analyze two columns of the penultimate subkey by guessing eight bytes of the last subkey (in two sets of four bytes). This will produce two sets of  <span class="math">2^{32}</span>  hypotheses with a time complexity equivalent to  <span class="math">2^{36}</span>  five-round AES encryption operations (using the estimations given above). One can then eliminate hypotheses in each set that are inconsistent, given that we have hypotheses on eight bytes of the penultimate key and eight bytes of the last subkey. However, we note that extra computation is required to change the hypotheses on the derived values to hypotheses for the penultimate subkey. That is, the four bytes corresponding to the penultimate subkey are multiplied by M as described in Section 2.1. This can be efficiently computed by considering the input vector as a 32-bit word and the matrix multiplication conducted using 32-bit operations. We estimate the complexity of this to be approximately equivalent to (5), which is equivalent to  <span class="math">1/2^6</span>  five-round AES encryption operations. Operating on these  <span class="math">2^{32}</span>  values will require the equivalent of  <span class="math">2^{26}</span>  five-round AES encryption operations, which is negligible compared to the generation of the hypotheses.</p>

    <p class="text-gray-300">From the AES key schedule we can see that any subkey byte can be computed from two specific bytes in either the previous or following subkey. From the two sets of hypotheses generated, as described above, there will be three cases where known relationships between these sets of hypotheses can be verified. Given that the probability that all three bytes of a given hypotheses can be verified will be  <span class="math">1/2^{24}</span> , one would expect that the two sets of  <span class="math">2^{32}</span>  hypotheses can be reduced to one set of  <span class="math">2^{40}</span>  hypotheses. A third set of  <span class="math">2^{32}</span>  hypotheses can then be generated for one of the remaining columns of the penultimate subkey and four bytes of the last subkey. There will be a further four bytes of the last subkey that are generated by bytes for which there are already hypotheses, and an element from the set of of  <span class="math">2^{40}</span>  hypotheses will validate a hypothesis from the new set of  <span class="math">2^{32}</span>  hypotheses with a probability of  <span class="math">1/2^{32}</span> . One would therefore expect to combine these two sets to produce a set of  <span class="math">2^{40}</span>  hypotheses for 96 bits of the penultimate and 96 bits of the last subkey. A set of  <span class="math">2^{32}</span>  hypotheses can then be generated for the final column of the penultimate subkey and four bytes of the final subkey. At this point on can verify whether an entire subkey can be generated from the penultimate subkey. For each of the  <span class="math">2^{32}</span>  hypotheses generated, hypotheses in the set of  <span class="math">2^{40}</span>  hypotheses for 96 bits of the penultimate and 96</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\bullet &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\bullet &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\bullet \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\bullet &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\bullet &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\bullet \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\bullet &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\bullet &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\bullet \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\rightarrow \\begin{pmatrix} \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\\\ \\bullet &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">Fig. 2. Propagation of a four-byte difference across one round of AES, where &#9679; represents a non-zero difference.</p>

    <p class="text-gray-300">bits of the last subkey will produce valid keys with a probability of  <span class="math">1/(2^8)^9 = 1/2^{72}</span>  (since there will be nine bytes in the last subkey that will not have been verified previously). One would, therefore, expect to generate two hypotheses from the two sets of hypotheses. One that is correct and one that fulfills the criteria by chance. A detailed example of how an instance of this attack would be conducted is given in Appendix A.</p>

    <p class="text-gray-300">The time complexity of the entire attack will be  <span class="math">2^{38}</span>  five-round AES encryption operations and require  <span class="math">2^{40}</span>  hypotheses to be stored in memory. If a second  <span class="math">\\delta</span> -set is included the time complexity will increase, but the memory requirements will become negligible. The time complexity does not double since an attacker only requires sufficient information to determine which of the two remaining hypotheses are false. This should be possible with work equivalent to  <span class="math">2^{36}</span>  five-round AES encryptions, i.e. the generation of hypotheses of 32-bits of the final and 32 bits of the penultimate subkeys. These attack are summarized in Table 1.</p>

    <p class="text-gray-300">Table 1. Summary of the Square Attack on Five-Round AES-128.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Analyzing an Extra Round</h3>

    <p class="text-gray-300">The attack described above applied to a five-round AES can be extended to attack a six-round AES. In order to permit an extra round to be analyzed a set of  <span class="math">2^{32}</span>  plaintexts are chosen that give all the possible ciphertexts that differ at indexes 1,6,11, and 16. An attacker will then seek to choose the 256 plaintext-ciphertext pairs that produce intermediate states that differ in only one byte after one round, i.e. the input required to attack a five-round AES, as shown in Figure 2.</p>

    <p class="text-gray-300">The simplest way of achieving this would be to choose 256 32-bit values for the first column of the intermediate state that differ in one byte. These 32-bit values can be deciphered for a given hypothesis for four bytes of the first subkey (specifically the bytes at indexes 1, 6, 11, and 16). This will produce 256 plaintexts that produce a  <span class="math">\\delta</span> -set after one round that can be analyzed using the attack described in Section 4.2, each of which will provide one hypothesis for the secret key given the hypotheses for 32 bits of the first subkey. This would increase the time complexity of an attack by a factor of  <span class="math">2^{32}</span> , but allow an extra round to be analyzed.</p>

    <p class="text-gray-300">Ferguson et al. observed that all  <span class="math">2^{32}</span>  can be used as a set of acquisitions to conduct the Square attack [7]. That is, a set of  <span class="math">2^{32}</span>  distinct plaintexts differing at, for example, indexes 1, 6, 11, and 16 described above can be viewed as  <span class="math">2^{24}</span>   <span class="math">\\delta</span> -sets. This remains true after the first round but an attacker cannot distinguish individual  <span class="math">\\delta</span> -sets after the first round without knowing four bytes of the first subkey. However, an attacker can treat all  <span class="math">2^{32}</span>  acquisitions together, i.e. the attack described in the previous</p>

    <p class="text-gray-300">section work in the same manner but with a set of  <span class="math">2^{32}</span> , rather than  <span class="math">2^8</span> , acquisitions. We refer to a set of  <span class="math">2^{32}</span>  plaintext-ciphertext pairs that are equivalent to  <span class="math">2^{24}</span>   <span class="math">\\delta</span> -sets as a  <span class="math">\\Delta</span> -set.</p>

    <p class="text-gray-300">An attack would proceed in the same manner as described in Section 4.2. Using the same notation the computation of the sets of  <span class="math">(x_1, c_2, c_3)</span>  will require  <span class="math">2^{48}</span>  executions of the function S. This would result in  <span class="math">2^{32}</span>  triples  <span class="math">(x_1, c_2, c_3)</span> . However, a maximum of  <span class="math">2^{24}</span>  values distinct values are possible. As described in Section 4.1, one only needs to keep one example of the triplets that occur with an odd-numbered frequency. Likewise, this will produce at most  <span class="math">2^{16}</span>  values for  <span class="math">(x_2, c_3)</span>  per key hypothesis, and at most  <span class="math">2^{8}</span>  values for  <span class="math">x_3</span>  per key hypothesis. The time complexity of the entire analysis requires  <span class="math">2^{50}</span>  executions of the function S for all four 32-bit sets for the final subkey, which given our estimate given above corresponds to  <span class="math">2^{42}</span>  AES encryptions operations. This is increased to  <span class="math">2^{44}</span>  where five  <span class="math">\\Delta</span> -sets are required to determine the key.</p>

    <p class="text-gray-300">Given that only two  <span class="math">\\Delta</span> -sets are required to determine the key, see Section 4.2, one the complexity using the &quot;partial sums&quot; method can be reduced to  <span class="math">2^{43}</span> . This is not immediately apparent since evaluating (5) will reduce the number of key hypotheses for  <span class="math">\\{k_0, k_1, k_2, k_3, k_4\\}</span>  by a factor of 256. Intuitively, one would expect that the same effort would be required to analyze one  <span class="math">\\Delta</span> -set four times, resulting in an attack with the same time complexity as that proposed by Ferguson et al. We note that evaluating (5) once for a given  <span class="math">\\Delta</span> -set will requires  <span class="math">2^{48}</span>  executions of the function S. A second evaluation of an instance of (5) with  <span class="math">k_4</span>  replaced with a different key byte from the penultimate subkey will require  <span class="math">2^{40}</span>  executions of the function S. This is because  <span class="math">S_{\\lambda}(c_{i,\\lambda} \\oplus k_{\\lambda})</span> , for one  <span class="math">\\lambda \\in \\{0,\\ldots,3\\}</span> , will already have been computed for all i (we note that this will involve carefully choosing the order in which the first instance of (5) is evaluated). This same reasoning applies for a third and fourth evaluation of (5) that will result in an 8-tuple consisting of four bytes of the last subkey and four bytes of the penultimate subkey. The overall complexity of evaluating (5) four times for one  <span class="math">\\Delta</span> -set is, therefore, approximately  <span class="math">2^{48}</span>  executions of the function S. The time complexity of the repeating this for all four 32-bit sets for the final subkey requires  <span class="math">2^{50}</span>  executions of the function S, which given our estimate given above corresponds to  <span class="math">2^{42}</span>  AES encryptions operations. This is increased to  <span class="math">2^{43}</span>  where two  <span class="math">\\Delta</span> -sets are required to determine the key.</p>

    <p class="text-gray-300">We can reduce the time complexity further if we exploit the relationships between key bytes in adjacent subkeys. That is, one can generate 8-tuples of key byte values using the &quot;partial sums&quot; sums technique proposed by Ferguson et al. and use the attack described in Section 4.2 to reduce the number of key hypotheses. Given one set of  <span class="math">2^{32}</span>  plaintext-ciphertext pairs an attack with a time complexity equivalent to  <span class="math">2^{42}</span>  six-round AES encryption operations and require that  <span class="math">2^{40}</span>  key hypotheses are stored in memory. Again, more acquisitions can be used to reduce the memory requirements at the cost of an increased time complexity. This is summarized in Table 2.</p>

    <p class="text-gray-300">Table 2. Summary of the Square Attack on Five-Round AES-128.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number of <span class="math">\\delta</span> -sets</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&middot;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time<br>Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining<br>Hypotheses</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span> 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42}</span> <span class="math">2^{42}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2<br>1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Applying the Square Attack to AES-192 and AES-256</h2>

    <p class="text-gray-300">In this section we describe how the attacks described in Section 4 are applicable to AES-192 and AES-256.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Analyzing Five-Round AES</h3>

    <p class="text-gray-300">Attacking a five-round AES-192 will function using a time complexity equivalent to  <span class="math">2^{39}</span>  AES encryption operations using the attack described in Section 4.2 based on the attack proposed by Ferguson et al. [7]. That is, two  <span class="math">\\delta</span> -sets would be sufficient to determine the last two subkeys of a five-round instance of AES-192 or AES-256.</p>

    <p class="text-gray-300">An attack on an instance of AES-256 cannot be made more efficient by analyzing two consecutive subkeys since there are no direct relationships. However, one can exploit the relationships between two consecutive subkeys when attacking an AES-192. This would follow a similar technique to that presented in Section 4.2. If one acquires a  <span class="math">\\delta</span> -set, one can analyze two columns of the penultimate subkey by guessing eight bytes of the last subkey (in two sets of four bytes). This will produce two sets of  <span class="math">2^{32}</span>  hypotheses with a time complexity equivalent to  <span class="math">2^{36}</span>  five-round AES encryption operations. One can then eliminate hypotheses in each set that are inconsistent, since we would have hypotheses on eight bytes of the penultimate key and eight bytes of the last subkey. Given the key schedule, one would expect that the two sets of  <span class="math">2^{32}</span>  hypotheses can be reduced to one set of  <span class="math">2^{48}</span>  hypotheses. A third set of  <span class="math">2^{32}</span>  hypotheses can then be generated for one of the remaining columns of the penultimate subkey and four bytes of the last subkey. One would expect that this would produce  <span class="math">2^{64}</span>  hypotheses with the relevant subkeys. This is because, in each case, there are two key bytes in the penultimate key that can each be derived from bytes the last subkey. A detailed example of how this attack would be conducted is given in Appendix B.</p>

    <p class="text-gray-300">As previously, the memory requirements of the above attack can be reduced by acquiring more  <span class="math">\\delta</span> -sets at the cost of an increase in the time complexity. However, one would only need to analyse half the information present in a second  <span class="math">\\delta</span> -set to reduce the hypotheses to a trivial amount. The details of the square attack applied to five-round AES-192 and AES-256 are shown in Table 3 and 4 respectively.</p>

    <p class="text-gray-300">Table 3. Summary of the Square Attack on Five-Round AES-192.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4. Summary of the Square Attack on Five-Round AES-256.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number of <span class="math">\\delta</span> -sets</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time<br>Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining<br>Hypotheses</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span> 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span> <span class="math">2^{39}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 <sup>128</sup> 1</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Analyzing Six-Round AES</h3>

    <p class="text-gray-300">The attacks on five rounds of AES-192 and AES-256 can be extended by assuming that an attacker knows the last subkey. The time complexity of the five-round attack does increases by a factor of  <span class="math">2^{128}</span>  when it is applied to a six round variants of AES-256. However, Lucks observed that knowledge of</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} \\bullet &amp; \\bullet &amp; \\bullet \\\\ \\bullet &amp; \\bullet &amp; \\bullet \\\\ \\bullet &amp; \\bullet &amp; \\bullet \\\\ \\bullet &amp; \\bullet &amp;</span>$</p>

    <p class="text-gray-300">Fig. 3. The known information from the last subkey, where &bull; represents a known value and &#8728; represents a derived value.</p>

    <p class="text-gray-300">the last subkey would allow an attacker to directly derive bytes in previous subkeys when attacking AES-192 [10]. That is, 64 bits of the penultimate subkey and 32 bits of the antepenultimate subkey, as shown in Figure 3.</p>

    <p class="text-gray-300">Following the reasoning in Section 4.2, a computational effort equivalent to  <span class="math">2^{22}</span>  (i.e. a factor of  <span class="math">2^{16}</span>  less than the standard attack) six-round AES-192 encryption operations to treat each  <span class="math">\\delta</span> -set. As previously, two  <span class="math">\\delta</span> -sets would be sufficient to determine the penultimate and antepenultimate subkeys.</p>

    <p class="text-gray-300">One can reduce this to one set if one uses the relationships between two consecutive subkey as described in Section 5.1. Since much of the subkeys are already known the memory requirements are much reduced. The details of the square attack applied to five-round AES-192 and AES-256 are shown in Table 5 and 6 respectively.</p>

    <p class="text-gray-300"><strong>Table 5.</strong> Summary of the Square Attack on Six-Round AES-192 using  <span class="math">\\delta</span> -sets..</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{150}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{151}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 6.</strong> Summary of the Square Attack on Six-Round AES-256 using  <span class="math">\\delta</span> -sets..</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{166}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{167}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">We can also note that introducing an extra round before, and acquiring  <span class="math">\\Delta</span> -sets will lead to a more efficient attack. This involves conducting the five-round attack described in Section 5.1 on a six-round AES using  <span class="math">\\Delta</span> -sets rather than  <span class="math">\\delta</span> -sets. The details of the square attack applied to six-round AES-192 and AES-256 using  <span class="math">\\Delta</span> -sets are shown in Table 7 and 8 respectively.</p>

      <h3 id="sec-5.3" class="text-xl font-semibold mt-8">5.3 Analyzing an Extra Round</h3>

    <p class="text-gray-300">As described in Section 4.3, an extra round can be added where an attacker uses  <span class="math">\\Delta</span> -sets [7]. Given that a large amount of the penultimate subkey is known the &quot;partial sums&quot; method of conducting the Square attack can be further optimized. We recall that the attack requires that (5) is evaluated as described in Section 4.2. Note that the attack does not proceed exactly as the six-round attack given in Section 5.2 as the relationships between the bytes of the subkeys will be different.</p>

    <p class="text-gray-300"><strong>Table 7.</strong> Summary of the Square Attack on Six-Round AES-192 using  <span class="math">\\Delta</span> -sets.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining<br>Hypotheses</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300"><strong>Table 8.</strong> Summary of the Square Attack on Five-Round AES-256 using  <span class="math">\\Delta</span> -sets.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number Memory of <span class="math">\\delta</span> -sets</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining<br>Hypotheses</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 <sup>128</sup> 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42}</span> <span class="math">2^{43}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span> 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">If, for example, an attacker wishes to evaluate (5) and knows  <span class="math">(k_0, k_1)</span>  these values can be evaluated before the unknown  <span class="math">(k_2, k_3)</span> . Generating  <span class="math">2^{24}</span>  values for  <span class="math">(x_1, c_2, c_3)</span>  will require  <span class="math">2^{33}</span>  executions of the function S. Then  <span class="math">2^{16}</span>  values for  <span class="math">(x_2, c_3)</span>  per hypotheses for  <span class="math">k_2</span>  can be generated with  <span class="math">2^{32}</span>  executions of the function S, and continue as per the attack described in Section 4.3. The time complexity of the entire analysis will be  <span class="math">2^{34}</span>  evaluations of the function S. That is,  <span class="math">2^{36}</span>  executions of the function S for all four 32-bit sets for the final subkey, which corresponds to  <span class="math">2^{28}</span>  AES encryptions operations.</p>

    <p class="text-gray-300">Table 9. Summary of the Square Attack on Seven-Round AES-192.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{153}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{154}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">In this paper we have demonstrated that the &quot;partial sums&quot; method of conducting the Square attack can be improved by analyzing more information per  <span class="math">\\delta</span> -set (or  <span class="math">\\Delta</span> -set). This allows the time complexity of attacks to be halved. For AES-128 the time complexity can be halved again, and reduced by a smaller amount for AES-192, by eliminating key hypotheses on-the-fly.</p>

    <p class="text-gray-300">In Table 11 we present a summary of the attacks presented in this paper alongside similar attacks in the literature. The memory requirements are the number of state matrices, or equivalent, that need to be stored in memory. The number of acquisitions are the number of chosen plaintexts enciphered with an unknown key, where the number is given in multiples of  <span class="math">2^8</span>  or  <span class="math">2^{32}</span>  so that it is clear how many  <span class="math">\\delta</span>  or  <span class="math">\\Delta</span> -sets are required to conduct the attack. The time complexity is expressed as the computational effort required to compute that many AES encryption operations.</p>

    <p class="text-gray-300">In this paper we have focused on attacks that require relatively few chosen plaintext-ciphertext pairs. Ferguson et al. also proposed a Square attack applicable to seven rounds of a AES-128 and eight rounds for AES-192 and AES-256. However, this attack requires approximately 2<sup>128</sup> chosen plaintext-ciphertext pairs and is beyond the scope of this paper although one would expect the proposed strategy to aid in the analysis.</p>

    <p class="text-gray-300">Table 10. Summary of the Square Attack on Seven-Round AES-256.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Number</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Remaining</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">of <span class="math">\\delta</span> -sets</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Hypotheses</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{170}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{171}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 11. Summary of attacks presented in this paper.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">D 1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">TZ T (1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">3.6</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Q 1 1</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key Length</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Memory</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Acquisitions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[5]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{6}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[2] (corrected)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{5}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[5]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">generic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{11}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^8</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38.5}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^8</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{39}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[5]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">generic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">5 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">generic</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">6 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{44}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42.5}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{43}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{176}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ferguson et al. [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">19 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{155}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{154}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{192}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">21 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{172}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">This paper</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">_</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2 \\cdot 2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{171}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>B. Bahrak and M. R. Aref. Impossible differential attack on seven-round AES-128. <em>IET Information Security Journal</em>, 2(2):28&ndash;32, 2008.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>E. Biham and N. Keller. Cryptanalysis of reduced variants of Rijndael. unpublished, 1999. http://www.madchat.fr/crypto/codebreakers/35-ebiham.pdf.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Bogdanov, D. Khovratovich, and C. Rechberger. Biclique cryptanalysis of the full AES. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 344&ndash;371. Springer, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Daemen, L. Knudsen, and V. Rijmen. The block cipher Square. In E. Biham, editor, FSE '97, volume 1267 of LNCS, pages 149&ndash;165. Springer, 1997.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Daemen and V. Rijmen. AES proposal: Rijndael. In AES Round 1 Technical Evaluation CD-1: Documentation. NIST, August 1998. http://www.nist.gov/aes.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>O. Dunkelman and N. Keller. The effects of the omission of last round's MixColumns on AES. <em>Information Processing Letters</em>, 110(8&ndash;9):304&ndash;308, 2010.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>N. Ferguson, J. Kelsey, S. Lucks, B. Schneier, M. Stay, D. Wagner, and D. Whiting. Improved cryptanalysis of Rijndael. In B. Schneier, editor, FSE 2000, volume 1978 of LNCS, pages 213&ndash;230. Springer, 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>FIPS PUB 197. Advanced encryption standard (AES). Federal Information Processing Standards Publication 197, National Institute of Standards and Technology (NIST), Gaithersburg, MD, USA, November 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Lu, O. Dunkelman, N. Keller, and J. Kim. New impossible differential attacks on AES. In D. R. Chowdhury, V. Rijmen, and A. Das, editors, <em>INDOCRYPT 2008</em>, volume 5365 of <em>LNCS</em>, pages 279&ndash;293. Springer, 2008.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Stefan Lucks. Attacking seven rounds of Rijndael under 196-bit and 256-bit keys. In AES Candidate Conference 2000, 2000. http://csrc.nist.gov/encryption/aes/round2/conf3/aes3conf.htm.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Mangard, E. Oswald, and T. Popp. Power Analysis Attacks: Revealing the Secrets of Smart Cards. Springer-Verlag, 2007.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>W. Zhang, W. Wu, and D. Feng. New results on impossible differential cryptanalysis of reduced AES. In K.-H. Nam and G. Rhee, editors, ICISC 2007, volume 4817 of LNCS, pages 239&ndash;250. Springer, 2007.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">In this section we describe an example of the attack presented in Section 4.2. We assume the worst case where an attacker only has one &delta;-set. Other versions should be possible (i.e. where one chooses to examine the columns of the penultimate subkey in a different order).</p>

    <p class="text-gray-300">We define the last two subkeys as</p>

    <p class="text-gray-300"><span class="math">$K_4 = \\begin{pmatrix} k_{4,1} &amp; k_{4,5} &amp; k_{4,9} &amp; k_{4,13} \\\\ k_{4,2} &amp; k_{4,6} &amp; k_{4,10} &amp; k_{4,14} \\\\ k_{4,3} &amp; k_{4,7} &amp; k_{4,11} &amp; k_{4,15} \\\\ k_{4,4} &amp; k_{4,8} &amp; k_{4,12} &amp; k_{4,16} \\end{pmatrix} \\quad \\text{and}</span>$</p>

    <p class="text-gray-300"><span class="math">$K_5 = \\begin{pmatrix} k_{5,1} &amp; k_{5,5} &amp; k_{5,9} &amp; k_{5,13} \\\\ k_{5,2} &amp; k_{5,6} &amp; k_{5,10} &amp; k_{5,14} \\\\ k_{5,3} &amp; k_{5,7} &amp; k_{5,11} &amp; k_{5,15} \\\\ k_{5,4} &amp; k_{5,8} &amp; k_{5,12} &amp; k_{5,16} \\end{pmatrix}.</span>$</p>

    <p class="text-gray-300">If an attacker has a &delta;-set, one can conduct an analysis as described in Section 4.2. That is, one can guess, for example, the key bytes {k5,1, k5,14, k5,11, k5,8} which will allow hypotheses to be formed on each element of {k4,1, k4,2, k4,3, k4,4} independently. Note that while the attack derives information on a transformed version of {k4,1, k4,2, k4,3, k4,4} this can be easily inverted for each hypotheses for the whole set. With a time complexity equivalent to 2<sup>18</sup> five-round AES encryptions one would expect to obtain 2<sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_1 = \\{k_{5,1}, k_{5,14}, k_{5,11}, k_{5,8}, k_{4,1}, k_{4,2}, k_{4,3}, k_{4,4}\\} ,</span>$</p>

    <p class="text-gray-300">which can be stored in a hash table.</p>

    <p class="text-gray-300">One can then conduct the same analysis by making hypotheses on {k5,13, k5,10, k5,7, k5,4} which will allow hypotheses to be derived on the elements of {k4,13, k4,14, k4,15, k4,16}. Likewise, this will provide 2 <sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_2 = \\{k_{5,13}, k_{5,10}, k_{5,7}, k_{5,4}, k_{4,13}, k_{4,14}, k_{4,15}, k_{4,16}\\}.</span>$</p>

    <p class="text-gray-300">However, as each element in &gamma;<sup>2</sup> is generated the following relationships between the elements in &gamma;<sup>2</sup> and &gamma;<sup>1</sup> can be verified:</p>

    <p class="text-gray-300"><span class="math">$k_{5,1} = S(k_{4,14}) \\oplus k_{4,1} \\oplus \\text{RCON}, \\quad k_{5,4} = S(k_{4,13}) \\oplus k_{4,13}</span>$</p>

    <p class="text-gray-300">and  <span class="math">k_{5,14} = k_{5,11} \\oplus k_{4,14}</span></p>

    <p class="text-gray-300">A given element of &gamma;<sup>2</sup> will therefore have 2<sup>8</sup> elements in &gamma;<sup>1</sup> that will satisfy these constraints, given that a incorrect key value will fulfill these relationships with probability 1/2 <sup>24</sup>. The resulting 2<sup>40</sup> hypotheses for {&gamma;1, &gamma;2} can also be stored in a hash table.</p>

    <p class="text-gray-300">One can continue in a straightforward manner to derive 2<sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_3 = \\{k_{5,5}, k_{5,2}, k_{5,15}, k_{5,12}, k_{4,5}, k_{4,6}, k_{4,7}, k_{4,8}\\}.</span>$</p>

    <p class="text-gray-300">For each element in &gamma;<sup>3</sup> an attacker can verify the following relationships with {&gamma;1, &gamma;2}:</p>

    <p class="text-gray-300"><span class="math">$k_{5,2} = S(k_{4,15}) \\oplus k_{4,2}, \\quad k_{5,5} = k_{5,1} \\oplus k_{4,5} \\quad k_{5,8} = k_{5,4} \\oplus k_{4,8}</span>$</p>

    <p class="text-gray-300">and  <span class="math">k_{5,14} = k_{5,10} \\oplus k_{4,14}</span></p>

    <p class="text-gray-300">Again the resulting 2<sup>40</sup> hypotheses for {&gamma;1, &gamma;2, &gamma;3} can be stored in a hash table. Lastly, one can perform the same analysis on</p>

    <p class="text-gray-300"><span class="math">$\\gamma_4 = \\{k_{5,9}, k_{5,6}, k_{5,3}, k_{5,16}, k_{4,9}, k_{4,10}, k_{4,11}, k_{4,12}\\} .</span>$</p>

    <p class="text-gray-300">Each element from &gamma;<sup>4</sup> can be used to see if a valid pair {K4, K5} has been found by searching in {&gamma;1, &gamma;2, &gamma;3} for values that satisfy the remaining relationships between the two subkeys:</p>

    <p class="text-gray-300"><span class="math">$k_{5,4} = S(k_{4,13}) \\oplus k_{4,4}, \\ k_{5,6} = k_{5,2} \\oplus k_{4,6}, \\ k_{5,7} = k_{5,3} \\oplus k_{4,7}, \\ k_{5,9} = k_{5,5} \\oplus k_{4,9}, \\ k_{5,10} = k_{5,6} \\oplus k_{4,10}, \\ k_{5,11} = k_{5,7} \\oplus k_{4,11}, \\ k_{5,12} = k_{5,8} \\oplus k_{4,12}, \\ k_{5,13} = k_{5,9} \\oplus k_{4,13}, \\ \\text{and} \\ k_{5,16} = k_{5,12} \\oplus k_{4,16}</span>$</p>

    <p class="text-gray-300">Given that an incorrect hypothesis for {K4, K5} will validate these equations with a probability of 1/2 8 9 = 1/2 <sup>72</sup>, one would expect to have two hypotheses for {K4, K5} (i.e. the correct key and one incorrect one that fulfills the criteria by chance) and therefore two hypotheses for the AES key.</p>

    <p class="text-gray-300">In this section we describe an example of the attack presented in Section 5.1. We assume the worst case where an attacker only has one &delta;-set. Other versions should be possible (i.e. where one chooses to examine the columns of the penultimate subkey in a different order).</p>

    <p class="text-gray-300">We define the last two subkeys as</p>

    <p class="text-gray-300"><span class="math">$K_4 = \\begin{pmatrix} k_{4,1} &amp; k_{4,5} &amp; k_{4,9} &amp; k_{4,13} \\\\ k_{4,2} &amp; k_{4,6} &amp; k_{4,10} &amp; k_{4,14} \\\\ k_{4,3} &amp; k_{4,7} &amp; k_{4,11} &amp; k_{4,15} \\\\ k_{4,4} &amp; k_{4,8} &amp; k_{4,12} &amp; k_{4,16} \\end{pmatrix} \\quad \\text{and} \\quad</span>$</p>

    <p class="text-gray-300"><span class="math">$K_5 = \\begin{pmatrix} k_{5,1} &amp; k_{5,5} &amp; k_{5,9} &amp; k_{5,13} \\\\ k_{5,2} &amp; k_{5,6} &amp; k_{5,10} &amp; k_{5,14} \\\\ k_{5,3} &amp; k_{5,7} &amp; k_{5,11} &amp; k_{5,15} \\\\ k_{5,4} &amp; k_{5,8} &amp; k_{5,12} &amp; k_{5,16} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">If an attacker has a &delta;-set, one can conduct an analysis as described in Section 4.2. As previously, one can guess, for example, the key bytes {k5,1, k5,14, k5,11, k5,8} which will allow hypotheses to be formed on each element of {k4,1, k4,2, k4,3, k4,4} independently. Note that while the attack derives information on a transformed version of {k4,1, k4,2, k4,3, k4,4} this can be easily inverted for each hypotheses for the whole set. With a time complexity equivalent to 2<sup>18</sup> five-round AES encryptions one would expect to obtain 2<sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_1 = \\{k_{5,1}, k_{5,14}, k_{5,11}, k_{5,8}, k_{4,1}, k_{4,2}, k_{4,3}, k_{4,4}\\} ,</span>$</p>

    <p class="text-gray-300">which can be stored in a hash table.</p>

    <p class="text-gray-300">One can then conduct the same analysis by making hypotheses on {k5,13, k5,10, k5,7, k5,4} which will allow hypotheses to be derived on the elements of {k4,13, k4,14, k4,15, k4,16}. Likewise, this will provide 2 <sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_2 = \\{k_{5,5}, k_{5,2}, k_{5,15}, k_{5,12}, k_{4,5}, k_{4,6}, k_{4,7}, k_{4,8}\\} .</span>$</p>

    <p class="text-gray-300">However, as each element in &gamma;<sup>2</sup> is generated the following relationships between the elements in &gamma;<sup>2</sup> and &gamma;<sup>1</sup> can be verified:</p>

    <p class="text-gray-300"><span class="math">$k_{5,15} = k_{4,7} \\oplus k_{5,11}</span>$
and  <span class="math">k_{5,12} = k_{4,4} \\oplus k_{5,8}</span> .</p>

    <p class="text-gray-300">A given element of &gamma;<sup>2</sup> will therefore have 2<sup>16</sup> elements in &gamma;<sup>1</sup> that will satisfy these constraints, given that a incorrect key value will fulfill these relationships with probability 1/2 <sup>16</sup>. This will result in 2<sup>48</sup> hypotheses for {&gamma;1, &gamma;2}. Continuing in a straightforward manner to derive 2<sup>32</sup> hypotheses for</p>

    <p class="text-gray-300"><span class="math">$\\gamma_3 = \\{k_{5,13}, k_{5,10}, k_{5,7}, k_{5,4}, k_{4,13}, k_{4,14}, k_{4,15}, k_{4,16}\\}.</span>$</p>

    <p class="text-gray-300">For each element in &gamma;<sup>3</sup> an attacker can verify the following relationships with {&gamma;1, &gamma;2}:</p>

    <p class="text-gray-300"><span class="math">$k_{5,14} = k_{4,6} \\oplus k_{5,10}</span>$
and  <span class="math">k_{5,11} = k_{4,3} \\oplus k_{5,7}</span></p>

    <p class="text-gray-300">This will result in 2<sup>64</sup> hypotheses for {&gamma;1, &gamma;2, &gamma;3} and the set</p>

    <p class="text-gray-300"><span class="math">$\\gamma_4 = \\{k_{5,9}, k_{5,6}, k_{5,3}, k_{5,16}, k_{4,9}, k_{4,10}, k_{4,11}, k_{4,12}\\},\\,</span>$</p>

    <p class="text-gray-300">can be used to check each element from &gamma;<sup>4</sup> can be used to see if a valid pair {K4, K5} has been found by searching in {&gamma;1, &gamma;2, &gamma;3} for values that satisfy the remaining relationships between the two subkeys using</p>

    <p class="text-gray-300"><span class="math">$k_{5,13} = k_{4,5} \\oplus k_{5,9}, \\quad k_{5,9} = k_{4,1} \\oplus k_{5,5}, \\quad k_{5,10} = k_{4,2} \\oplus k_{5,6},</span>$</p>

    <p class="text-gray-300">and  <span class="math">k_{5,16} = k_{4,8} \\oplus k_{5,12}</span> .</p>

    <p class="text-gray-300">Given that an incorrect hypothesis for {K4, K5} will validate these equations with a probability of 1/2 8 4 = 1/2 <sup>32</sup>, one would expect to have 2<sup>64</sup> hypotheses for {K4, K5}.</p>

    </section>
`;
---

<BaseLayout title="Improved ``Partial Sums&quot;-based Square Attack on AES (2012/280)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/280
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The Advanced Encryption Standard</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">The Key Schedule</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">The Square Attack</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Applying the Square Attack to AES-128</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Analyzing Four-Round AES</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Analyzing Five-Round AES</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Analyzing an Extra Round</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Applying the Square Attack to AES-192 and AES-256</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Analyzing Five-Round AES</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Analyzing Six-Round AES</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">Analyzing an Extra Round</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Using the Key Schedule to Complement the Square Attack on Five-Round AES-128</a></li>
        <li><a href="#app-b" class="hover:text-white">Using the Key Schedule to Complement the Square Attack on Five-Round AES-192</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="improved-partial-sums-based-square-attack-on-aes-2012" />
  </article>
</BaseLayout>
