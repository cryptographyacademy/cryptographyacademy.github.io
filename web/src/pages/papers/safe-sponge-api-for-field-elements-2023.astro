---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/522';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SAFE: Sponge API for Field Elements';
const AUTHORS_HTML = 'JP Aumasson, Dmitry Khovratovich, Bart Mennink, Por&ccedil;u Quine';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">From hashing and commitment schemes to Fiat-Shamir and encryption,
hash functions are everywhere in zero-knowledge proofsystems (ZKPs), and minor performance changes in \`\`vanilla&#x27;&#x27; implementations can translate in major discrepancies when the hash is processed as a circuit within the proofsystem.

Protocol designers have resorted to a number of techniques and custom
modes to optimize hash functions for ZKPs settings, but so far without a single established, well-studied construction. To address this need, we define the Sponge API for Field Elements (SAFE), a unified framework for permutation-based schemes (including AEAD, Sigma, PRNGs, and so on).  SAFE eliminates the performance overhead, is pluggable in any field-oriented protocol, and is suitable for any permutation algorithm.

SAFE is implemented in Filecoin&#x27;s Neptune hash framework, {which is} our reference implementation (in Rust). SAFE is also being integrated in other prominent ZKP projects. This report specifies SAFE and describes some use cases.

Among other improvements, our construction is  among the first to store
the protocol metadata in the sponge inner part in a provably secure
way, which may be of independent interest to the sponge use cases outside of ZKP.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> hashing &middot; fiat-shamir &middot; sponges</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Sponge functions <a href="#page-8-0">[BDPV07]</a> are the basis of permutation-based symmetric primitives' design, as studied by Daemen et al.: hash functions, MACs, authenticated encryption schemes, PRNGs, and others. When operating in Duplex mode (Fig. <a href="#page-2-0">1)</a> <a href="#page-8-1">[BDPV11]</a>, a sponge can be seen as stateful object that can ingest input (&quot;absorb&quot;) and produce output (&quot;squeeze&quot;) at any time and in arbitrary order.</p>

    <p class="text-gray-300">The duplex specification sees the input and output as raw bits, and leaves application-specific encoding to the users. However, in zero-knowledge proofsystems (ZKPs) specifications, hash functions often process field elements (with respect to some canonical encoding), rather than raw bits. Performance being critical to reduce the proof generation and verification cost, dedicated &quot;field-friendly&quot;, algebraic hash functions were designed, most of which are sponges. These include for example Poseidon <a href="#page-8-2">[GKR</a><sup>+</sup>21], Rescue <a href="#page-8-3">[AAB</a><sup>+</sup>20], MiMC <a href="#page-8-4">[AGR</a><sup>+</sup>16], and Reinforced Concrete <a href="#page-8-5">[LRG</a><sup>+</sup>22].</p>

    <p class="text-gray-300">A typical sponge function makes one call to the inner permutation P per r input bits (or other base units) to be hashed (absorbed) or outputted (squeezed), with r called rate. Despite its relative simplicity, sponge-like constructions can and have been &quot;misused&quot;, or misimplemented, particularly when working with prime field arithmetic, for which constructions are less established and specifications not as rigorous as the generic one. Here we outline the most common misuse patterns we have observed, based on our experience contributing to and auditing ZKP projects (excluding trivial failures such as overwriting the full state):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Domain separation: When the input data fills the full rate, no padding or any other length-dependent separator is applied. A classical example is hashing two field elements inside a Merkle tree with r = 2 field elements, where only 1 call to P is made to reduce costs.</li>
      <li>Cross-protocol collisions: Two protocols with one being an extension of the other start with the same state. As a result, they output the same prefix on the same inputs.</li>
    </ul>

    <p class="text-gray-300"><sup>1</sup><a href="https://github.com/filecoin-project/neptune/tree/master/src/sponge" target="_blank" rel="noopener noreferrer">https://github.com/filecoin-project/neptune/tree/master/src/sponge</a>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Superfluous permutations: Making an extra call between squeezing out data and absorbing it.</li>
      <li>Custom constructions: Using nested sponge calls (instead of chaining squeeze-absorb calls) in multi-round non-interactive protocols obtained via Fiat-Shamir heuristic. This unnecessarily increases the complexity, and may jeopardize the provable security guarantees.</li>
    </ul>

    <p class="text-gray-300">Whereas the last two issues are just extra work for a caller, the former two may breach not only security proofs but also the concrete security of real protocols. The API presented below solves all those and offers secure and efficient usage patterns for many use cases. It also reduces the workload of developers and makes a step towards a unified cross-platform interface.</p>

    <p class="text-gray-300">Contribution. We propose SAFE, a generic API for sponge functions, as well as a production-ready reference implementation. SAFE comes with a security proof, which is available as a separate report. As its main features, SAFE:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Does not use any padding, thus not wasting an extra call to the sponge permutation in any circumstances.</li>
      <li>Is independent of an underlying permutation and thus can be used with almost every design on the market (including Poseidon's).</li>
      <li>Eliminates a number of misuse patterns by limiting the set of operations callable at sponge and by binding a protocol designer to a specific order of these operations.</li>
      <li>Is provably secure in the random permutation model in a number of settings, including the overlooked but frequently required cross-protocol security.</li>
      <li>Is among the first constructions to store the protocol's metadata in the sponge inner part, provably losing no security.</li>
    </ul>

    <p class="text-gray-300">SAFE is suitable for a variety of use cases encountered in real-world ZK proofsystems, including:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Hashing with fixed-length input, as found in commitment schemes, Merkle trees, and signatures.</li>
      <li>Fiat-Shamir transforms and other stateful oracle simulations, where the sequence and size of input values is fixed and known in advance.</li>
      <li>Authenticated encryption (in the ZK setting, also verifiable encryption) of predetermined-length messages. A classical example is an encryption of a coin secret on recipient's public key in privacy-preserving cryptocurrencies <a href="#page-8-6">[HBHW22]</a>.</li>
      <li>Pseudo-random generation of field elements from a seed, with a reseeding mechanism.</li>
    </ul>

    <p class="text-gray-300">SAFE however does not support variable-length hashing when the length of data hashed is unknown in advance. This sacrifice is inevitable for a drastic performance and simplicity improvement, and did not prove problematic when we surveyed ZK projects' engineers.</p>

    <p class="text-gray-300">A (duplexed) sponge is a stateful object parameterized by a capacity c and a rate r where c + r = n is the inner state's width. As Fig. <a href="#page-2-0">1</a> shows, state changes are driven by three operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Permutation of the width-n state by P.</li>
      <li>Injection of input data M<sup>i</sup> (&quot;absorption&quot;), by chunks of up to r elements.</li>
      <li>Extraction of output data Z<sup>i</sup> (&quot;squeezing&quot;), by chunks of up to r elements.</li>
    </ul>

    <p class="text-gray-300">The original sponge was defined for bitstring states, but all the security results carry over to field-element states, as long these use a sound, fixed-size encoding. When defined over field elements, sponge parameters (c, r, n) are usually expressed in terms of field elements, which lead to the notion of arithmetic capacity.</p>

    <p class="text-gray-300">A sponge is traditionally initialized to the full-zero state. Input data then overwrites up to r given state elements at time, whereas the c-wide inner part is never touched nor outputted. This construction provides security up to c/2 bits in the random permutation model in the indifferentiability framework <a href="#page-8-7">[MRH04,</a> <a href="#page-8-8">CDMP05]</a>. This result means that it behaves like a random oracle and, among others, achieves this level of preimage and collision resistance provided the output size is large enough. It is widely believed that concrete instances such as SHA-3 keep the same security level.</p>

    <p class="text-gray-300">    <img src="_page_2_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Duplex sponge.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 API Overview</h3>

    <p class="text-gray-300">We assume a sponge width of n = r+c field elements, where r is the rate and c the capacity. Here F is the finite field type, thus elements of F <sup>L</sup> are vectors of L field elements. Length is the length type, an unsigned integer properly bounded counting the number field elements. State is the type of the internal state, consisting of field elements and other variables.</p>

    <p class="text-gray-300">A SAFE sponge object should expose the following operations to protocol designers (details appear in Section <a href="#page-3-0">3.3</a> and Section <a href="#page-4-0">3.4)</a>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>START(IOPattern, DomainSeparator): This initializes the inner state of the sponge, modifying up to c/2 field elements of the state. It's done once in the lifetime of a sponge.</li>
      <li>ABSORB(Length : L, F <sup>L</sup> : X[L]): This injects L field elements to the state from the array X, interleaving calls to the permutation. It also checks if the current call matches the IO pattern.</li>
      <li>SQUEEZE(Length : L) &rarr; F <sup>L</sup>: This extracts L field elements from the state, interleaving calls to the permutation as defined in Section <a href="#page-4-0">3.4.</a> It also checks if the current call matches the IO pattern.</li>
      <li>FINISH(Length) &rarr; Result: This marks the end of the sponge life, preventing any further operation. In particular, the state is erased from memory. The result is 'OK', or an error.</li>
    </ul>

    <p class="text-gray-300">The general workflow of a sponge prescribed by SAFE is then as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The consumer protocol initializes the sponge: START(IO[], D) where IO is a sequence of future calls and their respective lengths (what we call &quot;IO pattern&quot;) and D is a domain separator. One can also start from a precomputed state, but said state must come from a properly initialized sponge.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol makes a chain of calls C1, C2, . . . , C&#8467;, whose input lengths and types correspond to S. Each C<sup>i</sup> is either an ABSORB or a SQUEEZE call.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The protocol closes the sponge with a FINISH() call.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The most important element of the design is IOPattern, which is a compact encoding of the pattern of ABSORB and SQUEEZE calls during the sponge lifetime. An implementation must forbid to finish the sponge usage if this pattern is violated (see below). In particular, the output from SQUEEZE calls must not be used if the IO pattern is not followed.</p>

    <p class="text-gray-300">Remark 1. Several IO patterns can belong to the same equivalence class, and thus leading to identical instances. This is because consecutive calls of a same type (ABSORB or SQUEEZE) are aggregated to define the initial state. An application that needs to absorb L &gt; 1 elements in a row can thus do it one by one (with L calls to ABSORB), or with a single call including the L elements.</p>

    <p class="text-gray-300">Important notes:</p>

    <p class="text-gray-300">    <img src="_page_3_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: SAFE API as in-between the low-level sponge calls and application layer.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Dealing with non-field elements: The API assumes that the input is (represented as) field elements, however applications may need to process other data types. It is the responsibility of users to properly encode such inputs as field elements. If objects of different types are processed by multiple runs of a same instance, at the same position, then some signalling of the input type is required to avoid collisions between different elements of distinct types encoded identically (incurring a performance overhead).</li>
      <li>Precomputed state: Multiple &quot;forks&quot; of a sponge can be created, by storing the state after a given number of operations, and restarting from it with distinct ABSORB calls in distinct branches. Note that all forks must do the same calls sequence, as specified to the START call.</li>
    </ul>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Security</h3>

    <p class="text-gray-300">The security of SAFE API is captured by the following theorem, which essentially says that the SAFE outputs are indistinguishable from that of a random oracle.</p>

    <p class="text-gray-300">Theorem 1. Let P be a cryptographic protocol that employs random oracles R1, R2, . . . , R<sup>k</sup> and is secure in the random oracle model against adversaries that make up to 2 &lambda; queries to the oracles. Then, the implementation of this protocol with oracle R<sup>i</sup> instantiated with the SAFE API using a field of size at least 2 <sup>2</sup><sup>&lambda;</sup> and a domain separator D<sup>i</sup> (pairwise distinct) is secure agains adversaries that make up to 2 &lambda; queries to underlying hash H and permutation P.</p>

    <p class="text-gray-300">It implies that whenever SAFE is used in one or multiple (with different IO patterns or domain separators) protocols, at least c log<sup>2</sup> |F| bits of security is guaranteed against collision, preimage, or distinguishing attacks. Details are provided in a separate report.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 From IO Patterns to Tags to Instances</h3>

    <p class="text-gray-300">Let c &lt; n be the number of capacity elements. The SAFE sponge state consists of the following elements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Permutation state V &isin; F n.</li>
      <li>Absorb position absorb pos &le; n &minus; c.</li>
      <li>Squeeze position squeeze pos &le; n &minus; c.</li>
      <li>IO pattern expected (as defined by START).</li>
    </ul>

    <p class="text-gray-300">The sponge updates itself by calling inner permutation P. It is also able to compute parameter tag T using H, a cryptographic hash function producing 256-bit digests, by default the SHA3-256.</p>

    <p class="text-gray-300">An instance is characterized by a tag derived from an IO pattern, which is a sequence of absorb phases and squeeze phases and their respective number of field elements. The tag is used as an initial value, to ensure that distinct instances behave differently. Using distinct tags for different, non-equivalent usage patterns avoids trivial collisions between input sequences of different length, where a &quot;non-input&quot; element is replaced by a zero element in the colliding message (this would lead to a collision because of the lack of padding). Furthermore, for applications that need to distinguish equivalent IO patterns, a domain separator can be set.</p>

    <p class="text-gray-300">A tag is calculated from an IO pattern and a domain separator as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Encode the IO pattern as a list of 32-bit words, whose MSB set to 1 for ABSORB calls and to 0 for SQUEEZE calls. For example, an instance that does 2 ABSORB calls with 3 elements each and then does one SQUEEZE call with 3 elements is described by the three words [0x80000003, 0x80000003, 0x00000003].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Aggregate any contiguous ABSORB or SQUEEZE calls within a single call: in our example, we would replace [0x80000003, 0x80000003] with a single 0x80000006.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Serialize the list of words into a byte string and append to it the domain separator D: for example, if D is the two-byte sequence 0x4142, then the example above would yield the string (if big-endian convention is used): 0x80000006000000034142.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Hash the string obtained with the hasher H to a 256-bit tag T (truncating the hash if needed).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Given its tag string, an instance admits an arbitrary number of executions, which are in addition characterized by an input Y &isin; (F r ) &#8902; . In other words, a tag is not like an execution-specific nonce; it is a characterization of the expected usage in terms of IO pattern, and of a domain separator (which can be use to create different instances/tags for a same IO pattern).</p>

    <p class="text-gray-300">Remark 2. The 32-bit encoding restricts the number of elements absorbed or squeezed to 2 <sup>31</sup> &minus; 1 per call. For applications that need to absorb or squeeze such a large number of elements, the operation must therefore be done via multiple calls, rather than a single one.</p>

    <p class="text-gray-300">Remark 3. If the hash function used to create the tag received field elements rather than byte strings, and can directly process calls 32-bit integers as field elements, then the serialization mechanism (incl. endianness aspects) is not needed.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Detailed API</h3>

    <p class="text-gray-300">Everything begins with START, which computes a tag from the IO pattern and domain separator. This operation is unique as it writes the tag into the inner part of the state, which makes us to use a new security proof (Section <a href="#page-3-1">3.2)</a>. Each call to ABSORB or SQUEEZE both:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Writes to or read the outer part of the permutation state and calls the permutation P.</li>
      <li>Verifies its own parameters against the initially supplied IO pattern (&quot;early abort&quot; misuse detection).</li>
    </ul>

    <p class="text-gray-300">When all calls are done, the FINISH operation verifies that no call is left undone.</p>

    <p class="text-gray-300">We describe the reference implementation of all the four operations in Algorithms <a href="#page-5-0">1</a> and <a href="#page-5-1">2.</a></p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Algorithm 1 START and FINISH operations.</h3>

    <p class="text-gray-300">If field elements are 248 bit or more, T is converted to a field element. Otherwise T is parsed as two or more field elements (but at most c/2 elements, if c is the arithmetic capacity).</p>

    <h3 id="sec-misc-2" class="text-xl font-semibold mt-8">START:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Given an IO pattern IO (as a list of calls with the respective number of elements) and a byte string D used as domain separator, compute the tag T as described in Section <a href="#page-3-0">3.3.</a></li>
      <li>2: Set the permutation state to all zeros and add T to the first min(256, log<sup>2</sup> |F|) bits of the inner part of the state (with respect to the field's addition).</li>
      <li>3: Set both absorb and squeeze positions to zero: absorb pos = squeeze pos = 0.</li>
      <li>4: Set the IO count to zero: io count = 0.</li>
      <li>5: Set the IO pattern expected to IO[L].</li>
    </ul>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">FINISH:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Check that io count equals the length of the IO pattern expected. Return an error otherwise.</li>
      <li>2: Erase the state and its variables.</li>
    </ul>

    <h2 id="sec-misc-4" class="text-2xl font-bold">Algorithm 2 ABSORB and SQUEEZE operations.</h2>

    <h2 id="sec-misc-5" class="text-2xl font-bold">ABSORB:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: If L == 0, return.</li>
      <li>2: For i = 0, 1, .., L &minus; 1    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If absorb pos == (n &minus; c) then    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set V = P(V ), to permute the state.</li>
      <li>Set absorb pos = 0, to restart writing at the zero offset.</li>
    </ul></li>
      <li>Add X[i] to the state element at absorb pos.</li>
      <li>Do absorb pos + +.</li>
    </ul></li>
      <li>3: Compute the 32-bit encoding of L to the IO pattern.</li>
      <li>4: Verify that the word obtained is equal to the io countth word of the IO pattern expected, abort upon mismatch (and erase the state).</li>
      <li>5: Do io count + +.</li>
      <li>6: Set squeeze pos = (n &minus; c), to force a permute at the start of the next SQUEEZE.</li>
    </ul>

    <h2 id="sec-misc-6" class="text-2xl font-bold">SQUEEZE:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: If L == 0, return.</li>
      <li>2: For i = 0, 1, .., L &minus; 1    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If squeeze pos == (n &minus; c) then    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Set V = P(V ), to permute the state.</li>
      <li>Set squeeze pos = 0, to restart reading output at the zero offset.</li>
      <li>Set absorb pos = 0, to start writing at the zero offset in the next ABSORB.</li>
    </ul></li>
      <li>Set Y [i] to the state element at position squeeze pos: Y [i] = V [squeeze pos]</li>
      <li>Do squeeze pos + +.</li>
    </ul></li>
      <li>3: Compute the 32-bit encoding of L + 2<sup>31</sup> with the IO pattern.</li>
      <li>4: Verify that the word obtained is equal to the io countth word of the IO pattern expected, abort upon mismatch (and erase the state).</li>
      <li>5: Do io count + +.</li>
    </ul>

    <p class="text-gray-300">Remark 4. We do not set absorb pos to (n &minus; c) as in ABSORB as we may want the state to absorb at the same positions that have been squeezed, for example in example is authenticated encryption.</p>

    <p class="text-gray-300">SAFE among others supports the following use cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Hashing example of L elements is given in Algorithm <a href="#page-6-0">3.</a> Note that if the L elements are absorbed using more than one call &ndash; for example, via ABSORB(1, X1) followed by ABSORB(L &minus; 1,(X2, . . . , XL)) &ndash; then the resulting hash will not change. We stress that no padding is required here.</p></li>
      <li><p class="text-gray-300">Merkle tree (Algorithm <a href="#page-6-1">4)</a>. Consider a binary tree whose leaves and nodes are field elements, for example from a 256-bit field F. Again, the two ABSORB calls can be replaced by a single ABSORB(2,(X1, X2)), which will yield the same result. This construction generalizes to binary trees whose elements are tuples, in some F <sup>L</sup>, L &gt; 1. Again, no padding is required.</p></li>
      <li><p class="text-gray-300">Commitment scheme example with three 2-field elements is given in Algorithm <a href="#page-6-2">5.</a> Note that the tag will be the same for committing six 1-field elements. If this difference matters for an application, a domain separator should be used.</p></li>
      <li><p class="text-gray-300">An example of a two-round interactive Sigma protocol is given in Algorithm <a href="#page-7-0">6.</a> Here Prover sends a proof of knowledge in three steps while getting Verifier's challenges in between. Note that the sponge absorbs exactly those elements that Prover sends to Verifier. Thus a protocol designer can use a simple rule of thumb just absorb everything that is sent out.</p></li>
      <li><p class="text-gray-300">Authenticated encryption with SAFE is a simplification of the SpongeWrap mode <a href="#page-8-1">[BDPV11]</a>. The encryption example, where we encrypt b blocks of data of different lengths, is given in Algorithm <a href="#page-7-1">7.</a> This construction is the most efficient when L<sup>i</sup> &equiv; 0 mod r, that is, all blocks fit the rate parameter of the sponge. This mode can be adapted to supported associated data (authenticated but not encrypted), in the same vein as the SpongeWrap mode. Note that there is no padding overhead, nor we spend unneeded calls to P.</p></li>
      <li><p class="text-gray-300">Stream cipher and PRNG example is given in Algorithm <a href="#page-7-2">8.</a> A stream cipher generates a pseudo-random stream from a secret key and a not necessarily secret nonce, while a PRNG generates a pseudo-random stream from a seed.</p></li>
    </ul>

    <h3 id="sec-misc-7" class="text-xl font-semibold mt-8">Algorithm 3 SAFE for fixed-length hashing</h3>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Protocol:</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Sponge calls via SAFE:</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1: Select X1, X2, , XL<br>for hashing;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1: START(IO[2], D) with IO be the encoding of the fol</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2: Get hash T.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">lowing calls, and D an arbitrary domain separator;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2: ABSORB(L, X[]);</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3: T &larr; SQUEEZE(1);</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4: FINISH().</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">If the L elements are absorbed using more than one call &ndash; for example, via ABSORB(1, X1) followed by ABSORB(L &minus; 1,(X2, . . . , XL)) &ndash; then the resulting hash will not change.</p>

    <pre><code class="language-text">Algorithm 4 SAFE for Merkle tree of arity 2
Pseudocode:
 1: Select child node hashes X1, X2;
 2: Get parent hash T.
                                                         Sponge calls via SAFE:
                                                          1: START(IO[2], D);
                                                          2: ABSORB(2, X[]);
                                                          3: T &larr; SQUEEZE(1);
                                                          4: FINISH().
</code></pre>

    <h3 id="sec-misc-8" class="text-xl font-semibold mt-8">Algorithm 5 SAFE for Commitment schemes</h3>

    <pre><code class="language-text">Pseudocode:
 1: Select values for commitment X1, X2, X3 &isin; F
                                               2
                                                ;
 2: Get commmitment C.
                                                        Sponge calls via SAFE:
                                                          1: START(IO[4], D);
                                                          2: ABSORB(2, X1[]);
                                                          3: ABSORB(2, X2[]);
                                                          4: ABSORB(2, X3[]);
                                                          5: C &larr; SQUEEZE(1);
                                                          6: FINISH().
</code></pre>

    <h3 id="sec-misc-9" class="text-xl font-semibold mt-8"><strong>Algorithm 6</strong> SAFE for Sigma protocols</h3>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6">Interactive form:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Parties agree on the common input  <span class="math">Z \\in \\mathbb{F}^z</span> ;</li>
      <li>2: Prover prepares and sends proof elements  <span class="math">\\pi_1 \\in \\mathbb{F}^{L_1}</span>  and  <span class="math">\\pi_2 \\in \\mathbb{F}^{L_2}</span> ;</li>
      <li>3: Verifier responds with challenge  <span class="math">c_1 \\in \\mathbb{F}</span> ;</li>
      <li>4: Prover prepares and sends proof element  <span class="math">\\pi_3 \\in \\mathbb{F}^{L_3}</span> ;</li>
      <li>5: Verifier responds with challenges  <span class="math">c_2, c_3 \\in \\mathbb{F}</span> ;</li>
      <li>6: Prover sends final proof  <span class="math">\\pi_4</span> .</li>
    </ul>

    <h3 id="sec-misc-11" class="text-xl font-semibold mt-8">Sponge calls via SAFE:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1:  <span class="math">\\mathsf{START}(IO[6], D)</span>  with IO be the encoding of the following calls, and D an arbitrary domain separator;</li>
      <li>2: ABSORB(z, Z);</li>
      <li>3: ABSORB <span class="math">(L_1, \\pi_1)</span> ;</li>
      <li>4: ABSORB <span class="math">(L_2, \\pi_2)</span> ;</li>
      <li>5:  <span class="math">c_1 \\leftarrow \\mathsf{SQUEEZE}(1)</span> ;</li>
      <li>6: ABSORB <span class="math">(L_3, \\pi_3)</span> ;</li>
      <li>7:  <span class="math">c_2 \\leftarrow \\mathsf{SQUEEZE}(1)</span> ;</li>
      <li>8:  <span class="math">c_3 \\leftarrow \\mathsf{SQUEEZE}(1);</span></li>
      <li>9: FINISH().</li>
    </ul>

    <h2 id="sec-misc-12" class="text-2xl font-bold">Algorithm 7 SAFE for authenticated encryption</h2>

    <h3 id="sec-misc-13" class="text-xl font-semibold mt-8">Pseudocode:</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Get key  <span class="math">K \\in \\mathbb{F}^k</span> ;</li>
      <li>2: Get nonce  <span class="math">N \\in \\mathbb{F}^m</span> ;</li>
      <li>3: Encrypt data blocks  <span class="math">D_1, D_2, \\ldots, D_b</span> , where  <span class="math">D_i \\in \\mathbb{F}^{L_i}</span> ;</li>
      <li>4: Get ciphertext C.</li>
    </ul>

    <h2 id="sec-misc-14" class="text-2xl font-bold">Sponge calls via SAFE:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: START(IO[2b+2], D);</li>
      <li>2: ABSORB(k, K);</li>
      <li><span class="math">3: \\mathsf{ABSORB}(m, N);</span></li>
      <li>4:  <span class="math">C_1 \\leftarrow \\mathsf{SQUEEZE}(L_1);</span></li>
      <li>5: ABSORB <span class="math">(L_1, D_1)</span> ;</li>
      <li>6:  <span class="math">C_2 \\leftarrow \\mathsf{SQUEEZE}(L_2);</span></li>
      <li>7: ABSORB <span class="math">(L_2, D_2)</span> ;</li>
      <li>8: ...</li>
      <li>9:  <span class="math">C_b \\leftarrow \\mathsf{SQUEEZE}(L_b);</span></li>
      <li>10: ABSORB <span class="math">(L_b, D_b)</span> ;</li>
      <li>11:  <span class="math">S \\leftarrow \\mathsf{SQUEEZE}(1)</span> ;</li>
      <li>12: FINISH(). Upon success of FINISH() and of previous calls, the string  <span class="math">(C_1 + D_1)||(C_2 + D_2)||\\cdots||(C_b + D_b)||S</span>  will be the ciphertext, where &quot;+&quot; denotes addition in  <span class="math">\\mathbb{F}</span> .</li>
    </ul>

    <h3 id="sec-misc-15" class="text-xl font-semibold mt-8">Algorithm 8 SAFE for stream cipher and PRNG</h3>

    <h4 id="sec-misc-16" class="text-lg font-semibold mt-6">Protocol:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: if PRNG then</li>
      <li>2: Get seed  <span class="math">S \\in \\mathbb{F}^s</span> ;</li>
      <li>3: <strong>else</strong>Stream cipher</li>
      <li>4: Get key  <span class="math">K \\in \\mathbb{F}^k</span> ;</li>
      <li>5: Get nonce  <span class="math">N \\in \\mathbb{F}^m</span> ;</li>
      <li>6: end if</li>
      <li>7: Generate L stream elements C[];</li>
      <li>8: <strong>if</strong> Stream cipher <strong>then</strong></li>
      <li>9: Encrypt data D[] with C[].</li>
      <li>10: end if</li>
    </ul>

    <h4 id="sec-misc-17" class="text-lg font-semibold mt-6">Sponge calls via SAFE:</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: if PRNG then</li>
      <li>2: ABSORB(s, S);</li>
      <li>3: <strong>else</strong>Stream cipher</li>
      <li>4: ABSORB(k, K);</li>
      <li>5: ABSORB(m, N);</li>
      <li>6: end if</li>
      <li>7:  <span class="math">C_1 \\leftarrow \\mathsf{SQUEEZE}(L_1)</span> ;</li>
      <li>8:  <span class="math">C_2 \\leftarrow \\mathsf{SQUEEZE}(L_2);</span></li>
      <li>9: ...</li>
      <li>10:  <span class="math">C_b \\leftarrow \\mathsf{SQUEEZE}(L_b)</span> ;</li>
      <li>11: FINISH(). For the stream cipher case, the plaintext  <span class="math">D_1, \\ldots, D_b</span>  with  <span class="math">D_i</span>  consists of  <span class="math">L_i</span>  field elements is then encrypted to  <span class="math">(C_1 + D_1)||(C_2 + D_2)||\\cdots||(C_b + D_b)</span> .</li>
    </ul>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>[AAB+20] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of Symmetric-Key Primitives for Advanced Cryptographic Protocols. IACR ToSC, (3):1&ndash;45, 2020.</li>
      <li>[AGR+16] Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. MiMC: Efficient Encryption and Cryptographic Hashing with Minimal Multiplicative Complexity. In ASIACRYPT, 2016.</li>
      <li>[BDPV07] Guido Bertoni, Joan Daemen, Micha&uml;el Peeters, and Gilles Van Assche. Sponge functions. Ecrypt Hash Workshop 2007, May 2007.</li>
      <li>[BDPV11] Guido Bertoni, Joan Daemen, Micha&uml;el Peeters, and Gilles Van Assche. Duplexing the sponge: Singlepass authenticated encryption and other applications. In SAC, 2011.</li>
      <li>[CDMP05] Jean-S&acute;ebastien Coron, Yevgeniy Dodis, C&acute;ecile Malinaud, and Prashant Puniya. Merkle-Damg&#730;ard revisited: How to construct a hash function. In CRYPTO, 2005.</li>
      <li>[GKR+21] Lorenzo Grassi, Dmitry Khovratovich, Arnab Roy, Christian Rechberger, and Markus Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. USENIX Security, 2021.</li>
      <li>[HBHW22] Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. ZCash protocol specification, 2022. <a href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf" target="_blank" rel="noopener noreferrer">https://github.com/zcash/zips/blob/master/protocol/protocol.pdf</a>.</li>
      <li>[LRG+22] Reinhard L&uml;uftenegger, Christian Rechberger, Lorenzo Grassi, Markus Schofnegger, Roman Walch, and Dmitry Khovratovich. Reinforced Concrete: A fast hash function for verifiable computation. In ACM CCS, 2022.</li>
      <li>[MRH04] Ueli M. Maurer, Renato Renner, and Clemens Holenstein. Indifferentiability, impossibility results on reductions, and applications to the random oracle methodology. In TCC, 2004.</li>
    </ul>

    </section>
`;
---

<BaseLayout title="SAFE: Sponge API for Field Elements (2023/522)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/522
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li><a href="#sec-2" class="hover:text-white">Sponges</a></li>
        <li>
          <a href="#sec-3" class="hover:text-white">The SAFE API</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">API Overview</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Security</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">From IO Patterns to Tags to Instances</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Detailed API</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">SAFE Applications</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="safe-sponge-api-for-field-elements-2023" />
  </article>
</BaseLayout>
