---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/1154';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Post-Quantum Zero-Knowledge Proofs for Accumulators with Applications to Ring Signatures from Symmetric-Key Primitives';
const AUTHORS_HTML = 'David Derler, Sebastian Ramacher, Daniel Slamanig';

const CONTENT = `    <p class="text-gray-300">Post-Quantum Zero-Knowledge Proofs for Accumulators with Applications to Ring Signatures from Symmetric-Key Primitives</p>

    <p class="text-gray-300">David Derler^{1}, Sebastian Ramacher^{1}, and Daniel Slamanig^{2}</p>

    <p class="text-gray-300">^{1} IAIK, Graz University of Technology, Graz, Austria</p>

    <p class="text-gray-300">^{2} AIT Austrian Institute of Technology, Vienna, Austria</p>

    <p class="text-gray-300">firstname.lastname@tugraz.at, firstname.lastname@ait.ac.at</p>

    <p class="text-gray-300">Abstract. In this paper we address the construction of privacy-friendly cryptographic primitives for the post-quantum era and in particular accumulators with zero-knowledge membership proofs and ring signatures. This is an important topic as it helps to protect the privacy of users in online authentication or emerging technologies such as cryptocurrencies. Recently, we have seen first such constructions, mostly based on assumptions related to codes and lattices. We, however, ask whether it is possible to construct such primitives without relying on structured hardness assumptions, but solely based on symmetric-key primitives such as hash functions or block ciphers. This is interesting because the resistance of latter primitives to quantum attacks is quite well understood.</p>

    <p class="text-gray-300">In doing so, we choose a modular approach and firstly construct an accumulator (with one-way domain) that allows to efficiently prove knowledge of (a pre-image of) an accumulated value in zero-knowledge. We, thereby, take care that our construction can be instantiated solely from symmetric-key primitives and that our proofs are of sublinear size. Latter is non trivial to achieve in the symmetric setting due to the absence of algebraic structures which are typically used in other settings to make these efficiency gains. Regarding efficient instantiations of our proof system, we rely on recent results for constructing efficient non-interactive zero-knowledge proofs for general circuits. Based on this building block, we then show how to construct logarithmic size ring signatures solely from symmetric-key primitives. As constructing more advanced primitives only from symmetric-key primitives is a very recent field, we discuss some interesting open problems and future research directions. Finally, we want to stress that our work also indirectly impacts other fields: for the first time it raises the requirement for collision resistant hash functions with particularly low AND count.</p>

    <p class="text-gray-300">Keywords: post-quantum cryptography, privacy-preserving cryptography, provable security, accumulator, zero-knowledge for circuits</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The design of cryptographic schemes that remain secure in the advent of powerful quantum computers has become an important topic in recent years. Although</p>

    <p class="text-gray-300">it is hard to predict when quantum computers will be powerful enough to break factoring and discrete logarithm based cryptosystems, it is important to start the transition to post-quantum cryptography early enough to eventually not end up in a rush. This is underpinned by the NIST post-quantum cryptography standardization project, which aims at identifying the next generation of public key encryption, key exchange and digital signature schemes basing their security on conjectured quantum hard problems. Apart from these fundamental schemes, there are many other valuable schemes which would nicely complement a post-quantum cryptographic toolbox. In this paper we are interested in privacy-friendly cryptographic primitives for the post-quantum era and in particular accumulators with zero-knowledge membership proofs and ring signatures. Such schemes help to protect the privacy of users, and significantly gained importance due to recent computing trends such as Cloud computing or the Internet of Things (IoT). Examples where privacy-enhancing protocols are already widely deployed today are remote attestation via direct anonymous attestation (DAA) <em>[x1]</em> as used by the Trusted Platform Module (TPM), privacy-friendly online authentication within Intel’s Enhanced Privacy ID (EPID) <em>[x2]</em>, or usage within emerging technologies such as cryptocurrencies to provide privacy of transactions.</p>

    <p class="text-gray-300">Let us now briefly discuss the primitives we construct in this paper. An accumulator scheme <em>[x3]</em> allows to represent a finite set as a succinct value called the accumulator. For every element in the accumulated set, one can efficiently compute a so called witness to certify its membership in the accumulator. However, it should be computationally infeasible to find a witness for non-accumulated values. We are interested in accumulators supporting efficient zero-knowledge membership proofs. Ring signature schemes <em>[x10]</em> allow a member of an ad-hoc group <span class="math">\\mathcal{R}</span> (the so called ring), defined by the member’s public keys, to anonymously sign a message on behalf of <span class="math">\\mathcal{R}</span>. Such a signature attests that some member of <span class="math">\\mathcal{R}</span> produced the signature, but the actual signer remains anonymous.</p>

    <p class="text-gray-300">For ring signatures there is a known approach to construct them from accumulators and non-interactive zero-knowledge proof systems in the random oracle model. The main technical hurdle in the post-quantum setting is to find accumulators, and, more importantly, compatible proof systems under suitable assumptions. Only recently, Libert et al. in <em>[x11]</em> showed that it is possible to instantiate this approach in the post-quantum setting and provided the first post-quantum accumulator from lattices. This combined with suitable non-interactive variants of <span class="math">\\Sigma</span>-protocols yields post-quantum ring signatures in the random oracle model (ROM). However, this does not give rise to a construction of ring signatures from symmetric-key primitives such as hash functions or block ciphers, as we pursue in this paper. The main technical tools we use in our construction are recent results from zero-knowledge proof systems for</p>

    <p class="text-gray-300">general circuits <em>[x10, CDG^{+}17]</em>, and our techniques are inspired by recent approaches to construct post-quantum signature schemes based on these proof systems <em>[CDG^{+}17]</em>. We note that there are also post-quantum ring signature candidates from problems related to codes <em>[x16]</em> and multivariate cryptography <em>[x15]</em>. However, they all have size linear in the number of ring members, whereas we are only interested in sublinear ones. Additionally, former schemes are proven secure in weaker security models.</p>

    <p class="text-gray-300">Contribution. Our contributions are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We present the first post-quantum accumulator (with one-way domain) together with efficient zero-knowledge proofs of (a pre-image of) an accumulated value, which solely relies on assumptions related to symmetric-key primitives. That is, we do not require any structured hardness assumptions. Our proofs are of sublinear size in the number of accumulated elements and can be instantiated in both, the ROM as well as the quantum accessible ROM (QROM). Besides being used as an important building block in this paper, such accumulators are of broader interest. In particular, such accumulators with efficient zero-knowledge membership proofs have many other applications beyond this work, e.g., membership revocation <em>[BCD^{+}17]</em> or anonymous cash such as Zerocoin <em>[x14]</em>. We also note that the only previous construction of post-quantum accumulators with efficient zero-knowledge membership proofs in <em>[x12]</em> relies on hardness assumptions on lattices.</li>

      <li>We use our proposed accumulator to construct ring signatures of sublinear size. Therefore, we prove an additional property—simulation-sound extractability—of the proof system (ZKB++ <em>[CDG^{+}17]</em>) we are using. This then allows us to rigorously prove the security of our ring signature construction in the strongest model of security for ring signatures due to Bender et al. <em>[x5]</em>. Consequently, we propose a construction of sublinear size ring signatures solely from symmetric-key primitives.</li>

      <li>We present a selection of symmetric-key primitives that can be used to instantiate our ring signature construction and evaluate the practicality of our approach. In particular, we present signature sizes for rings of various sizes when instantiating the one-way function and hash function using LowMC <em>[ARS^{+}15, ARS^{+}16]</em>. Finally, we present some interesting directions for future research within this very recent domain.</li>

    </ul>

    <p class="text-gray-300">Additional Contribution Compared to PQCrypto’18 Version. We propose a concrete, optimized implementation of the circuit used in the zero-knowledge membership proof for the accumulator. Our techniques roughly allow reduce the proof (signature) sizes by a factor of 2 when compared to the circuit used for the evaluation in the PQCrypto’18 version. A recent work of Boneh et al. <em>[x2]</em>, who construct post-quantum group signatures, also presents results allowing to optimize our zero-knowledge membership proof sizes compared to the PQCrypto’18 version. We want to emphasize that the results presented in this extended full paper allow for even smaller zero-knowledge membership proofs than what is obtained with the optimizations due to Boneh et al. in <em>[x2]</em>.</p>

    <p class="text-gray-300">Note that the optimizations presented in this version also allows to instantiate the group signature scheme <em>[x1, Construction II]</em> with smaller signature sizes.</p>

    <h2 id="sec-1" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Notation. Let <span class="math">x\\ \\epsilon^{0}\\ X</span> denote the operation that picks an element uniformly at random from a finite set <span class="math">X</span> and assigns it to <span class="math">x</span>. We assume that all algorithms run in polynomial time and use <span class="math">y\\ \\leftarrow\\mathsf{A}(x)</span> to denote that <span class="math">y</span> is assigned the output of the potentially probabilistic algorithm <span class="math">\\mathsf{A}</span> on input <span class="math">x</span> and fresh random coins. For algorithms representing adversaries we use calligraphic letters, e.g., <span class="math">\\mathcal{A}</span>. We assume that every algorithm outputs a special symbol <span class="math">\\bot</span> on error. We write <span class="math">\\Pr[\\Omega:\\mathcal{E}]</span> to denote the probability of an event <span class="math">\\mathcal{E}</span> over the probability space <span class="math">\\Omega</span>. A function <span class="math">\\epsilon:\\mathbb{N}\\to\\mathbb{R}^{+}</span> is called negligible if for all <span class="math">c&gt;0</span> there is a <span class="math">k_{0}</span> such that <span class="math">\\epsilon(k)&lt;1/k^{c}</span> for all <span class="math">k&gt;k_{0}</span>. In the remainder of this paper, we use <span class="math">\\epsilon</span> to denote such a negligible function. Finally, we define <span class="math">[n]\\coloneqq\\{1,\\ldots,n\\}</span>.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Zero-Knowledge Proofs and <span class="math">\\bm{\\Sigma}</span>-Protocols</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Sigma</span>-Protocols. Let <span class="math">L\\subseteq\\mathsf{X}</span> be an NP-language with witness relation <span class="math">R</span> so that $L=\\{x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\exists w:R(x,w)=1\\}<span class="math">. A </span>\\Sigma<span class="math">-protocol for language </span>L$ is defined as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-3" class="text-base font-medium mt-4">Definition 1 (<span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">A <span class="math">\\Sigma</span>-protocol for language <span class="math">L</span> is an interactive three-move protocol between a PPT prover <span class="math">\\mathsf{P}=(\\mathsf{Commit},\\mathsf{Prove})</span> and a PPT verifier <span class="math">\\mathsf{V}=(\\mathsf{Challenge},\\mathsf{Verify})</span>, where <span class="math">\\mathsf{P}</span> makes the first move and transcripts are of the form <span class="math">(\\mathsf{a},\\mathsf{e},\\mathsf{z})\\in\\mathsf{A}\\times\\mathsf{E}\\times\\mathsf{Z}</span>, where <span class="math">\\mathsf{a}</span> is output by <span class="math">\\mathsf{Commit}</span>, <span class="math">\\mathsf{e}</span> is output by <span class="math">\\mathsf{Challenge}</span> and <span class="math">\\mathsf{z}</span> is output by <span class="math">\\mathsf{Prove}</span>. Additionally, <span class="math">\\Sigma</span> protocols satisfy the following properties</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Completeness.</h6>

    <p class="text-gray-300">For all security parameters <span class="math">\\kappa</span>, and for all <span class="math">(x,w)\\in R</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle\\mathsf{P}(1^{\\kappa},x,w),\\mathsf{V}(1^{\\kappa},x)\\rangle=1]=1.</span></p>

    <h6 id="sec-5" class="text-base font-medium mt-4"><span class="math">s</span>-Special Soundness.</h6>

    <p class="text-gray-300">There exists a PPT extractor <span class="math">\\mathsf{E}</span> so that for all <span class="math">x</span>, and for all sets of accepting transcripts <span class="math">\\{(\\mathsf{a},\\mathsf{e}_{i},\\mathsf{z}_{i})\\}_{i\\in[s]}</span> with respect to <span class="math">x</span> where <span class="math">\\forall i,j\\in[s],i\\neq j:\\mathsf{e}_{i}\\neq\\mathsf{e}_{j}</span>, generated by any algorithm with polynomial runtime in <span class="math">\\kappa</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\,w\\leftarrow\\mathsf{E}(1^{\\kappa},x,\\{(\\mathsf{a},\\mathsf{e}_{i},\\mathsf{z}_{i})\\}_{i\\in[s]})\\,:\\,(x,w)\\in R\\,\\big{]}\\geq 1-\\epsilon(\\kappa).</span></p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Special Honest-Verifier Zero-Knowledge.</h6>

    <p class="text-gray-300">There exists a PPT simulator <span class="math">\\mathsf{S}</span> so that for every <span class="math">x\\in L</span> and every challenge <span class="math">\\mathsf{e}\\in\\mathsf{E}</span>, it holds that a transcript <span class="math">(\\mathsf{a},\\mathsf{e},\\mathsf{z})</span>, where <span class="math">(\\mathsf{a},\\mathsf{z})\\leftarrow\\mathsf{S}(1^{\\kappa},x,\\mathsf{e})</span> is computationally indistinguishable from a transcript resulting from an honest execution of the protocol.</p>

    <p class="text-gray-300">The <span class="math">s</span>-special soundness property gives an immediate bound for soundness: if no witness exists then (ignoring a negligible error) the prover can successfully</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer at most to <span class="math">(s - 1) / t</span> challenges, where $t =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the challenge space. In case this value is too large, it is possible to reduce the soundness error using </span>\\ell<span class="math">-fold parallel repetition of the </span>\\Sigma<span class="math">-protocol. Furthermore, it is also well known that one can easily express conjunctions and disjunctions of languages proven using </span>\\Sigma$-protocols. For the formal details refer to [Dam10, CDS94].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Non-Interactive ZK Proof Systems.</strong> Now, we recall a standard definition of non-interactive zero-knowledge proof systems. Therefore, let <span class="math">L</span> be an NP-language with witness relation <span class="math">R</span> so that <span class="math">L = \\{x \\mid \\exists w : R(x, w) = 1\\}</span>.</p>

    <p class="text-gray-300"><strong>Definition 2 (Non-Interactive Zero-Knowledge Proof System).</strong> A non-interactive proof system <span class="math">\\Pi</span> is a tuple of algorithms (Setup, Proof, Verify), defined as:</p>

    <p class="text-gray-300">Setup(1^κ): This algorithm takes a security parameter κ as input, and outputs a common reference string crs.</p>

    <p class="text-gray-300">Proof(crs, x, w): This algorithm takes a common reference string crs, a statement x, and a witness w as input, and outputs a proof π.</p>

    <p class="text-gray-300">Verify(crs, x, π): This algorithm takes a common reference string crs, a statement x, and a proof π as input, and outputs a bit b ∈ {0, 1}.</p>

    <p class="text-gray-300">We require the properties completeness, adaptive zero-knowledge, and simulation-sound extractability as defined below.</p>

    <p class="text-gray-300"><strong>Definition 3 (Completeness).</strong> A non-interactive proof system <span class="math">\\Pi</span> is complete, if for every adversary <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\kappa}), (x, w) \\leftarrow \\mathcal {A} (\\mathsf {c r s}), &amp;amp; \\mathsf {V e r i f y} (\\mathsf {c r s}, x, \\pi) = 1 \\\\ \\pi \\leftarrow \\mathsf {P r o o f} (\\mathsf {c r s}, x, w) &amp;amp; \\vee (x, w) \\notin R \\end{array} \\right] \\approx 1.</span></div>

    <p class="text-gray-300"><strong>Definition 4 (Adaptive Zero-Knowledge).</strong> A non-interactive proof system <span class="math">\\Pi</span> is adaptively zero-knowledge, if there exists a PPT simulator <span class="math">S = (\\mathcal{S}_1,\\mathcal{S}_2)</span> such that for every PPT adversary <span class="math">\\mathcal{A}</span> there is a negligible function <span class="math">\\epsilon (\\cdot)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l l} \\operatorname <em> {P r} \\left[ \\mathsf {c r s} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\kappa}) : \\mathcal {A} ^ {\\mathcal {P} (\\mathsf {c r s}, \\cdot , \\cdot)} (\\mathsf {c r s}) = 1 \\right] - &amp; \\\\ \\operatorname </em> {P r} \\left[ (\\mathsf {c r s}, \\tau) \\leftarrow \\mathcal {S} _ {1} (1 ^ {\\kappa}) : \\mathcal {A} ^ {\\mathcal {S} (\\mathsf {c r s}, \\tau , \\cdot , \\cdot)} (\\mathsf {c r s}) = 1 \\right] &amp; \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon (\\kappa),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where, <span class="math">\\tau</span> denotes a simulation trapdoor. Thereby, <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{S}</span> return <span class="math">\\perp</span> if <span class="math">(x,w)\\notin R</span> or <span class="math">\\pi \\gets \\operatorname{Proof}(\\mathrm{crs},x,w)</span> and <span class="math">\\pi \\gets S_2(\\mathrm{crs},\\tau ,x)</span>, respectively, otherwise.</p>

    <p class="text-gray-300"><strong>Definition 5 (Simulation-Sound Extractability).</strong> An adaptively zero-knowledge non-interactive proof system <span class="math">\\Pi</span> is simulation-sound extractable, if there exists a PPT extractor <span class="math">\\mathcal{E} = (\\mathcal{E}_1,\\mathcal{E}_2)</span> such that for every adversary <span class="math">\\mathcal{A}</span> it holds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l l} \\operatorname <em> {P r} \\left[ (\\mathsf {c r s}, \\tau) \\leftarrow \\mathcal {S} _ {1} (1 ^ {\\kappa}) : \\mathcal {A} (\\mathsf {c r s}, \\tau) = 1 \\right] - &amp; \\\\ \\operatorname </em> {P r} \\left[ (\\mathsf {c r s}, \\tau , \\xi) \\leftarrow \\mathcal {E} _ {1} (1 ^ {\\kappa}) : \\mathcal {A} (\\mathsf {c r s}, \\tau) = 1 \\right] &amp; \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 0,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and for every PPT adversary <span class="math">\\mathcal{A}</span> there is a negligible function <span class="math">\\varepsilon_2(\\cdot)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{l l} (\\mathsf{crs}, \\tau, \\xi) \\leftarrow \\mathcal{E}_1(1^\\kappa), &amp;amp; \\mathsf{Verify}(\\mathsf{crs}, x^\\star, \\pi^\\star) = 1 \\wedge \\\\ (x^\\star, \\pi^\\star) \\leftarrow \\mathcal{A}^{\\mathcal{S}(\\mathsf{crs}, \\tau, \\cdot)}(\\mathsf{crs}), &amp;amp; (x^\\star, \\pi^\\star) \\notin \\mathcal{Q}_\\mathsf{S} \\wedge (x^\\star, w) \\notin R \\end{array} \\right] \\leq \\varepsilon_2(\\kappa),</span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{S}(\\mathsf{crs}, \\tau, x) \\coloneqq \\mathcal{S}_2(\\mathsf{crs}, \\tau, x)</span> and <span class="math">\\mathcal{Q}_S</span> keeps track of the queries to and answers of <span class="math">\\mathcal{S}</span>.</p>

    <p class="text-gray-300">The Fiat-Shamir Transform. The Fiat-Shamir transform [FS86] is a frequently used tool to convert <span class="math">\\Sigma</span>-protocols <span class="math">\\langle \\mathsf{P}, \\mathsf{V} \\rangle</span> to their non-interactive counterparts. Essentially, the transform removes the interaction between <span class="math">\\mathsf{P}</span> and <span class="math">\\mathsf{V}</span> by using a RO <span class="math">H: \\mathsf{A} \\times \\mathsf{X} \\to \\mathsf{E}</span> to obtain the challenge <span class="math">\\mathsf{e}</span>. That is, one uses a PPT algorithm <span class="math">\\mathsf{Challenge}&#x27;(1^\\kappa, \\mathsf{a}, x)</span> which obtains <span class="math">\\mathsf{e} \\gets H(\\mathsf{a}, x)</span> and returns <span class="math">\\mathsf{e}</span>. Then, the prover can locally obtain the challenge <span class="math">\\mathsf{e}</span> after computing the initial message <span class="math">\\mathsf{a}</span>. Starting a verifier <span class="math">\\mathsf{V}&#x27; = (\\mathsf{Challenge}&#x27;, \\mathsf{Verify})</span> on the same initial message <span class="math">\\mathsf{a}</span> will then yield the same challenge <span class="math">\\mathsf{e}</span>. More formally, we obtain the non-interactive PPT algorithms <span class="math">(\\mathsf{P}_H, \\mathsf{V}_H)</span> indexed by the used RO:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{P}_H(1^\\kappa, x, w)</span>: Start <span class="math">\\mathsf{P}</span> on <span class="math">(1^\\kappa, x, w)</span>, obtain the first message <span class="math">\\mathsf{a}</span>, answer with <span class="math">\\mathsf{e} \\gets H(\\mathsf{a}, x)</span>, and finally obtain <span class="math">\\mathsf{z}</span>. Returns <span class="math">\\pi \\gets (\\mathsf{a}, \\mathsf{z})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{V}_H(1^\\kappa, x, \\pi)</span>: Parse <span class="math">\\pi</span> as <span class="math">(\\mathsf{a}, \\mathsf{z})</span>. Start <span class="math">\\mathsf{V}&#x27;</span> on <span class="math">(1^\\kappa, x)</span>, send <span class="math">\\mathsf{a}</span> as first message to <span class="math">\\mathsf{V}&#x27;</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mathsf{V}&#x27;</span> outputs <span class="math">\\mathsf{e}</span>, reply with <span class="math">\\mathsf{z}</span> and output 1 if <span class="math">\\mathsf{V}&#x27;</span> accepts and 0 otherwise.</p>

    <p class="text-gray-300">One can obtain a non-interactive proof system satisfying the properties above by applying the Fiat-Shamir transform to any <span class="math">\\Sigma</span>-protocol where the min-entropy <span class="math">\\alpha</span> of the commitment <span class="math">\\mathsf{a}</span> sent in the first phase is so that <span class="math">2^{-\\alpha}</span> is negligible in the security parameter <span class="math">\\kappa</span> and the challenge space <span class="math">\\mathsf{E}</span> is exponentially large in the security parameter. Formally, <span class="math">\\mathsf{Setup}(1^\\kappa)</span> fixes a RO <span class="math">H: \\mathsf{A} \\times \\mathsf{X} \\to \\mathsf{E}</span>, sets <span class="math">\\mathsf{crs} \\gets (1^\\kappa, H)</span> and returns <span class="math">\\mathsf{crs}</span>. The algorithms Proof and Verify are defined as follows: <span class="math">\\mathsf{Proof}(\\mathsf{crs}, x, w) \\coloneqq \\mathsf{P}_H(1^\\kappa, x, w)</span>, <span class="math">\\mathsf{Verify}(\\mathsf{crs}, x, \\pi) \\coloneqq \\mathsf{V}_H(1^\\kappa, x, \\pi)</span>.</p>

    <p class="text-gray-300">Signatures via Fiat-Shamir. The Fiat-Shamir (FS) transform can elegantly be used to convert (canonical) identification schemes into adaptively secure signature schemes. The basic idea is similar to above, but slightly differs regarding the challenge generation, i.e., one additionally includes the message upon generating the challenge. Note that in the context of the stronger variant of the FS transform we rely on, one can simply modify the language so that the statements additionally include the message to be signed. This is because our variant of the FS transform includes the statement upon challenge generation, which is why extending the statement by the message also implicitly means including the message in the challenge generation. We will not make this language change explicit in the following, but implicitly assume that the language is changed if a message is included as the last parameter of the statement to be proven.</p>

    <p class="text-gray-300">6 This is a stronger variant of FS (cf. [FKMV12, BPW12]). The original weaker variant of the FS transform does not include the statement <span class="math">x</span> in the challenge computation.</p>

    <p class="text-gray-300">The Unruh Transform. Similar to FS, Unruh’s transform <em>[x21, x22, x23]</em> allows one to construct NIZK proofs and signature schemes from <span class="math">\\Sigma</span>-protocols. In contrast to the FS transform, Unruh’s transform can be proven secure in the QROM (quantum random oracle model), strengthening the security guarantee against quantum adversaries. At a high level, Unruh’s transform works as follows: given <span class="math">\\Sigma</span>-protocol, the prover repeats the first phase of the <span class="math">\\Sigma</span>-protocol <span class="math">t</span> times and for each of those runs produces responses for <span class="math">M</span> randomly selected challenges. All those responses are permuted using a random permutation <span class="math">G</span>. Querying the random oracle on all first rounds all permuted responses then determines the responses to publish for each round.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Efficient NIZK Proof Systems for General Circuits</h3>

    <p class="text-gray-300">ZKB++ <em>[CDG+17]</em>, an optimized version of ZKBoo <em>[x13]</em>, is a proof system for zero-knowledge proofs over arbitrary circuits. ZKBoo and ZKB++ build on the MPC-in-the-head paradigm by Ishai et al. <em>[x15]</em>, which roughly works as follows. The prover simulates all parties of a multiparty computation protocol (MPC) implementing the joint evaluation of some function, say <span class="math">y=\\text{SHA-256}(x)</span>, and computes commitments to the states of all players. The verifier then randomly corrupts a subset of the players and checks whether those players did the computation correctly.</p>

    <p class="text-gray-300">ZKBoo generalizes the idea of <em>[x15]</em> by replacing MPC with circuit decompositions. There the idea is to decompose the circuit into three shares, where revealing the wire values of two shares does not leak any information about the wire values on the input of the circuit. The explicit formulas for circuit decomposition can be found in <em>[x13]</em> for ZKBoo and in <em>[CDG+17]</em> for ZKB++. Multiplication gates induce some dependency between the individual shares which is why the wire values on the output of the multiplication gates needs to be stored in the transcripts. Hence, the transcripts grow linearly in the number of multiplication gates. Due to space limitations we do not include further details on ZKB++ and refer the reader to <em>[CDG+17]</em> for the details.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 PQ Accumulators & ZK Membership Proofs</h2>

    <p class="text-gray-300">Our goal is to come up with an accumulator and associated efficient zero-knowledge membership proof system, which remains secure in the face of attacks by a quantum attacker. The first building block we, thus, require for our constructions are accumulators which can be proven secure under an assumption which is believed to resist attacks by a quantum computer. In this work our goal is to solely rely on unstructured assumptions, and thus resort to using Merkle tree as accumulators. Merkle trees were first used in the context of accumulators by Buldas, Laud, and Lipmaa in <em>[x5]</em>, who called their primitive undeniable attesters. In the fashion of <em>[x10]</em>, we then extend the accumulator model to accumulators with one-way domain, i.e., accumulators where the accumulation domain coincides with the range of a one-way function so that one can</p>

    <p class="text-gray-300">accumulate images of the one-way function. For the associated zero-knowledge membership proof system, we build up on recent progress in proving statements over general circuits as discussed in Section 2.2.</p>

    <p class="text-gray-300">The main technical hurdle we face in this context is designing the statement to be proven with the proof system so that we can actually obtain proofs which are sublinear (in particular logarithmic) in the number of accumulated elements. Obtaining sublinear proofs is complicated mainly due to the absence of any underlying algebraic structure on the accumulator.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3.1 Formal Model</h2>

    <p class="text-gray-300">We rely on the formalization of accumulators by [DHS15], which we slightly adapt to fit our requirement for a deterministic Eval algorithm. Based on this formalization we then restate the Merkle tree accumulator (having a deterministic Eval algorithm) within this framework.</p>

    <p class="text-gray-300"><strong>Definition 6 (Accumulator).</strong> A static accumulator is a tuple of efficient algorithms (Gen, Eval, WitCreate, Verify) which are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Gen}(1^{\\kappa},t)</span>: This algorithm takes a security parameter <span class="math">\\kappa</span> and a parameter <span class="math">t</span>. If <span class="math">t \\neq \\infty</span>, then <span class="math">t</span> is an upper bound on the number of elements to be accumulated. It returns a key pair <span class="math">(\\mathsf{sk}_{\\Lambda}, \\mathsf{pk}_{\\Lambda})</span>, where <span class="math">\\mathsf{sk}_{\\Lambda} = \\emptyset</span> if no trapdoor exists. We assume that the accumulator public key <span class="math">\\mathsf{pk}_{\\Lambda}</span> implicitly defines the accumulation domain <span class="math">\\mathsf{D}_{\\Lambda}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Eval}((\\mathsf{sk}_{\\Lambda}^{-},\\mathsf{pk}_{\\Lambda}),\\mathcal{X})</span>: This deterministic algorithm takes a key pair <span class="math">(\\mathsf{sk}_{\\Lambda}^{-},\\mathsf{pk}_{\\Lambda})</span> and a set <span class="math">\\mathcal{X}</span> to be accumulated and returns an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span> together with some auxiliary information <span class="math">\\mathsf{aux}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{WitCreate}((\\mathsf{sk}_{\\Lambda}^{-},\\mathsf{pk}_{\\Lambda}),\\Lambda_{\\mathcal{X}},\\mathsf{aux},x_{i})</span>: This algorithm takes a key pair <span class="math">(\\mathsf{sk}_{\\Lambda}^{-},\\mathsf{pk}_{\\Lambda})</span>, an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span>, auxiliary information <span class="math">\\mathsf{aux}</span> and a value <span class="math">x_{i}</span>. It returns <span class="math">\\perp</span>, if <span class="math">x_{i} \\notin \\mathcal{X}</span>, and a witness <span class="math">\\mathsf{wit}_{x_i}</span> for <span class="math">x_{i}</span> otherwise.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}(\\mathsf{pk}_{\\Lambda}, \\Lambda_{\\mathcal{X}}, \\mathsf{wit}_{x_i}, x_i)</span>: This algorithm takes a public key <span class="math">\\mathsf{pk}_{\\Lambda}</span>, an accumulator <span class="math">\\Lambda_{\\mathcal{X}}</span>, a witness <span class="math">\\mathsf{wit}_{x_i}</span> and a value <span class="math">x_i</span>. It returns 1 if <span class="math">\\mathsf{wit}_{x_i}</span> is a witness for <span class="math">x_i \\in \\mathcal{X}</span> and 0 otherwise.</p>

    <p class="text-gray-300">We require accumulators to be correct and collision free. While we omit the straight forward correctness notion, we recall the collision freeness notion below, which requires that finding a witness for a non-accumulated value is hard.</p>

    <p class="text-gray-300"><strong>Definition 7 (Collision Freeness).</strong> A cryptographic accumulator is collision-free, if for all PPT adversaries <span class="math">\\mathcal{A}</span> there is a negligible function <span class="math">\\varepsilon(\\cdot)</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf{sk}_{\\Lambda}, \\mathsf{pk}_{\\Lambda}) \\leftarrow \\mathsf{Gen}(1^{\\kappa}, t), \\\\ (\\mathsf{wit}_{x_i}^*, x_i^*, \\mathcal{X}^*) \\leftarrow \\mathcal{A}(\\mathsf{pk}_{\\Lambda}) \\end{array} : \\begin{array}{c} \\mathsf{Verify}(\\mathsf{pk}_{\\Lambda}, \\Lambda^*, \\mathsf{wit}_{x_i}^*, x_i^*) = 1 \\wedge \\\\ x_i^* \\notin \\mathcal{X}^* \\end{array} \\right] \\leq \\varepsilon(\\kappa),</span></div>

    <p class="text-gray-300">where <span class="math">\\Lambda^{<em>} \\gets \\mathsf{Eval}_{r^{</em>}}((\\mathsf{sk}_{\\Lambda}, \\mathsf{pk}_{\\Lambda}), \\mathcal{X}^{*})</span>.</p>

    <p class="text-gray-300">|  Gen(1κ,t): Fix a family of hash functions {Hk}k∈Kκ with Hk: {0,1}∗ → {0,1}κ ∀ k ∈ Kκ. Choose k←R Kκ and return (skA, pkA) ← (∅, Hk).  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Eval((skA, pkA), X): Parse pkA as Hk and X as (x0, ..., xn-1).a If ∅ k ∈ N so that n = 2k return ⊥. Otherwise, let ℓu,v refer to the u-th leaf (the leftmost leaf is indexed by 0) in the v-th layer (the root is indexed by 0) of a perfect binary tree. Return ΛX ← ℓ0,0 and aux ← ((ℓu,v)u∈[n/2k-v])v∈[k], where  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓu,v ← {Hk(ℓ2u,v+1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ2u+1,v+1) if v < k, and Hk(xi) if v = k.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  WitCreate((skA, pkA), ΛX, aux, xi): Parse aux as ((ℓu,v)u∈[n/2k-v])v∈[k] and return witxi where  |</p>

    <p class="text-gray-300">|  witxi ← (ℓ⌊i/2v⌋+η,k-v)0≤v≤k, where η = {1 if ↓i/2v⌋ (mod 2) = 0 -1 otherwise.  |</p>

    <p class="text-gray-300">|  Verify(pkA, ΛX, witxi, xi): Parse pkA as Hk, ΛX as ℓ0,0, set ℓi,k ← Hk(xi). Recursively check for all 0 < v < k whether the following holds and return 1 if so. Otherwise return 0.  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ⌊i/2v+1⌋,k-(v+1) = {Hk(ℓ⌊i/2v⌋,k-v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ⌊i/2v⌋+1,k-v) if ↓i/2v⌋ (mod 2) = 0 Hk(ℓ⌊i/2v⌋-1,k-v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ⌊i/2v⌋,k-v) otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  a We assume without loss of generality that X is an ordered sequence instead of a set.  |</p>

    <p class="text-gray-300">Scheme 1. Merkle tree accumulator.</p>

    <p class="text-gray-300">In Scheme 1, we cast the Merkle tree accumulator in the framework of [DHS15].</p>

    <p class="text-gray-300">Then, we restate some well-known lemmas and sketch the respective proofs.</p>

    <p class="text-gray-300">Lemma 1. Scheme 1 is correct.</p>

    <p class="text-gray-300">The lemma above is easily verified by inspection. The proof is omitted.</p>

    <p class="text-gray-300">Lemma 2. If  <span class="math">\\{H_k\\}_{k \\in \\mathsf{K}^\\kappa}</span>  is a family of collision resistant hash functions, the accumulator in Scheme 1 is collision free.</p>

    <p class="text-gray-300">Proof (Sketch). Upon setup, the reduction engages with a collision resistance challenger for the family of hash functions, obtains  <span class="math">H_{k}</span> , and completes the setup as in the original protocol. Now, one may observe that every collision in the accumulator output by the adversary implies that the reduction knows at least two colliding inputs for  <span class="math">H_{k}</span> , which upper bounds the probability of a collision in the accumulator by the collision probability of the hash function.</p>

    <p class="text-gray-300">We now extend the definition of accumulators to ones with one-way domain following the definition of [DKNS04], but we adapt it to our notation.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 8 (Accumulator with One-Way Domain)</h6>

    <p class="text-gray-300">A collision-free accumulator with accumulation domain <span class="math">\\mathsf{D}_{\\mathsf{\\Lambda}}</span> and associated function family <span class="math">\\{f_{\\mathsf{\\Lambda}}:\\mathsf{I}_{\\mathsf{\\Lambda}}\\to\\mathsf{D}_{\\mathsf{\\Lambda}}\\}</span> where <span class="math">\\mathsf{Gen}(1^{\\kappa},t)</span> also selects <span class="math">f_{\\mathsf{\\Lambda}}</span> is called an accumulator with one-way domain if</p>

    <p class="text-gray-300">There exists an efficient algorithm <span class="math">D</span> that on input <span class="math">(x,z)\\in\\mathsf{D}_{\\mathsf{\\Lambda}}\\times\\mathsf{I}_{\\mathsf{\\Lambda}}</span> returns <span class="math">1</span> if and only if <span class="math">f_{\\mathsf{\\Lambda}}(z)=x</span>. There exists a (probabilistic) algorithm <span class="math">W</span> that on input <span class="math">1^{\\kappa}</span> returns a pair <span class="math">(x,z)\\in\\mathsf{D}_{\\mathsf{\\Lambda}}\\times\\mathsf{I}_{\\mathsf{\\Lambda}}</span> with <span class="math">D(x,z)=1</span>. For all PPT adversaries <span class="math">\\mathcal{A}</span> there is a negligible function <span class="math">\\varepsilon(\\cdot)</span> such that:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\,(x,z)\\leftarrow W(1^{\\kappa}),z^{\\ast}\\leftarrow\\mathcal{A}(1^{\\kappa},x)\\,:\\,D(x,z)=1\\,\\big{]}\\leq\\varepsilon(\\kappa).</span></p>

    <p class="text-gray-300">Note that when we set <span class="math">f_{\\mathsf{\\Lambda}}</span> to be the identity function, then we have a conventional accumulator.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.4 Membership Proofs of Logarithmic Size</h3>

    <p class="text-gray-300">The main technical tool used by <em>[x10]</em> to obtain zero-knowledge membership proofs of constant size is to exploit a property of the accumulator which is called quasi-commutativity. Clearly, such a property requires some underlying algebraic structure which we explicitly want to sacrifice in favor of being able to solely rely on assumptions related to symmetric-key primitives with relatively well understood post-quantum security. To this end we have to use a different technique. First observe that when naïvely proving that a non-revealed value is a member of our accumulator would amount to a disjunctive proof of knowledge over all members, which is at least of linear size. Therefore, this is not an option and we have to develop an alternative technique.</p>

    <p class="text-gray-300">The Relation. Essentially our idea is to “emulate” some kind of commutativity within the order of the inputs to the hash function in each level by a disjunctive proof statement, i.e., we exploit the disjunction to hide where the path through the tree continues. The single statements in every level of the tree are then included in one big conjunction. The length of this statement is <span class="math">\\mathcal{O}(k)=\\mathcal{O}(\\log n)</span>. More formally we define a relation <span class="math">R</span> on <span class="math">\\{0,1\\}^{\\kappa}\\times\\{f_{\\mathsf{\\Lambda}}\\}\\times\\{H_{k}\\}\\times\\mathsf{I}_{\\mathsf{\\Lambda}}\\times(\\{0,1\\}^{\\kappa})^{2k}</span> which—for a given non-revealed pre-image <span class="math">z</span>—attests membership of the corresponding image <span class="math">f_{\\mathsf{\\Lambda}}(z)</span> in the accumulator <span class="math">\\mathsf{\\Lambda}_{\\mathcal{X}}</span>:</p>

    <p class="text-gray-300"><span class="math">((\\mathsf{\\Lambda}_{\\mathcal{X}},f_{\\mathsf{\\Lambda}},H_{k}),(z,(a_{i})_{i\\in[k]},(b_{i})_{i\\in[k]}))\\in R\\iff(a_{k}=f_{\\mathsf{\\Lambda}}(z)\\ \\vee\\ b_{k}=f_{\\mathsf{\\Lambda}}(z))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\wedge\\ \\bigwedge_{i=0}^{k-1}(a_{i}=H_{k}(a_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i+1})\\vee a_{i}=H_{k}(b_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{i+1})),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{\\Lambda}_{\\mathcal{X}}=a_{0}</span>. In Figure 1 we illustrate that the relation indeed works for arbitrary members of the accumulator without influencing the form of the statement or the witness. This illustrates that proving the statement in this way does not reveal any information on which path in the tree was taken. To see this,</p>

    <p class="text-gray-300">observe that at each level of the tree the relation covers both cases where  <span class="math">a_i</span>  is either a left or right child. Given that, it is easy to verify that having a witness for relation  <span class="math">R</span>  implies having a witness for the accumulator together with some (non-revealed) member.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Visualization of different paths in the Merkle tree and the corresponding witness. The nodes on the path corresponding to  <span class="math">a_0</span> ,  <span class="math">a_1</span>  and  <span class="math">a_2</span>  are underlined.</p>

    <p class="text-gray-300">Remark 1. In order to use relation  <span class="math">R</span>  with the conventional accumulator in Scheme 1, we just have to set  <span class="math">f_{\\Lambda}</span>  to be the identity function (which yields  <span class="math">x = z</span> ) and then set  <span class="math">a_{k} = H_{k}(z)</span>  and  <span class="math">b_{k} = H_{k}(z)</span> .</p>

    <p class="text-gray-300">Now, the remaining piece to finally be able to plug in a witness  <span class="math">\\mathsf{wt}_{f_{\\Lambda}(z)}</span>  for some accumulated value  <span class="math">f_{\\Lambda (z)}</span>  with pre-image  <span class="math">z</span>  into the relation  <span class="math">R</span>  above is some efficient helper algorithm which rearranges the values  <span class="math">z</span>  and  <span class="math">\\mathsf{wt}_{f_{\\Lambda}(z)}</span>  so that they are compatible with the format required by  <span class="math">R</span> . Such an algorithm is easily implemented, which is why we only define the interface below.</p>

    <p class="text-gray-300">Trans  <span class="math">(z, \\mathrm{wt}_{f_{\\Lambda}(z)})</span> : Takes as input a value  <span class="math">z</span>  as well as a witness  <span class="math">\\mathrm{wt}_{f_{\\Lambda(z)}}</span>  and returns a witness of the form  <span class="math">(z, (a_i)_{i \\in [k]}, (b_i)_{i \\in [k]})</span>  for  <span class="math">R</span> .</p>

    <p class="text-gray-300">Since Trans can be viewed as a permutation on the indexes it is easy to see that the function implemented by Trans is bijective and its inverse is easy to compute. We denote the computation of the inverse of the function implemented by Trans as  <span class="math">(z, \\mathrm{wt}_{f_{\\Lambda}(z)}) \\gets \\mathrm{Trans}^{-1}(z, (a_i)_{i \\in [n]}, (b_i)_{i \\in [n]})</span> .</p>

    <p class="text-gray-300">The two main lines of more recent work in the design of ring signatures target reducing the signature size or removing the requirement for random oracles (e.g., [DKNS04, CGS07, GK15, BCC+15, DS16, Gon17, MS17]). We, however, note that all these approaches require assumptions that do not withstand a quantum computer. To the best of our knowledge, the first non-trivial post-quantum</p>

    <p class="text-gray-300">scheme (i.e., one that does not have linear size signatures) in the random oracle model is the lattice-based scheme recently proposed by Libert et al. [LLNW16]. We provide an alternative construction in the random oracle model with logarithmic sized signatures, but avoid lattice assumptions and only rely on symmetric-key primitives.</p>

    <p class="text-gray-300">Below, we formally define ring signature schemes (adopting [BKM09]).</p>

    <p class="text-gray-300">Definition 9 (Ring Signature). A ring signature scheme RS is a tuple RS = (Setup, Gen, Sign, Verify) of PPT algorithms, which are defined as follows.</p>

    <p class="text-gray-300">Setup(1^K): This algorithm takes as input a security parameter  <span class="math">\\kappa</span>  and outputs public parameters PP.</p>

    <p class="text-gray-300">Gen(PP): This algorithm takes as input parameters PP and outputs a keypair (sk, pk).</p>

    <p class="text-gray-300">Sign( <span class="math">\\mathsf{sk}_i, m, \\mathcal{R}</span> ): This algorithm takes as input a secret key  <span class="math">\\mathsf{sk}_i</span> , a message  <span class="math">m \\in \\mathcal{M}</span>  and a ring  <span class="math">\\mathcal{R} = (\\mathsf{pk}_j)_{j \\in [n]}</span>  of  <span class="math">n</span>  public keys such that  <span class="math">\\mathsf{pk}_i \\in \\mathcal{R}</span> . It outputs a signature  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">Verify  <span class="math">(m,\\sigma ,\\mathcal{R})</span>  : This algorithm takes as input a message  <span class="math">m\\in \\mathcal{M}</span>  , a signature  <span class="math">\\sigma</span>  and a ring  <span class="math">\\mathcal{R}</span>  . It outputs a bit  <span class="math">b\\in \\{0,1\\}</span></p>

    <p class="text-gray-300">A secure ring signature scheme needs to be correct, unforgeable, and anonymous. While we omit the obvious correctness definition, we subsequently provide formal definitions for the remaining properties following [BKM09]. We note that Bender et al. in [BKM09] have formalized multiple variants of these properties, where we always use the strongest one.</p>

    <p class="text-gray-300">Unforgeability requires that without any secret key  <span class="math">\\mathsf{sk}_i</span>  that corresponds to a public key  <span class="math">\\mathsf{pk}_i\\in \\mathcal{R}</span> , it is infeasible to produce valid signatures with respect to arbitrary such rings  <span class="math">\\mathcal{R}</span> . Our unforgeability notion is the strongest notion defined in [BKM09] and is there called unforgeability w.r.t. insider corruption.</p>

    <p class="text-gray-300">Definition 10 (Unforgeability). A ring signature scheme provides unforgeability, if for all PPT adversaries  <span class="math">\\mathcal{A}</span> , there exists a negligible function  <span class="math">\\varepsilon(\\cdot)</span>  such that it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} \\mathsf {P P} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\kappa}), &amp;amp; \\mathsf {V e r i f y} (m ^ {*}, \\sigma^ {*}, \\mathcal {R} ^ {*}) = 1 \\wedge \\\\ \\{(s k, p k) \\leftarrow \\mathsf {G e n} (\\mathsf {P P}) \\} _ {i \\in [ \\mathsf {p o l y} (\\kappa) ]}, &amp;amp; (\\cdot , m ^ {*}, \\mathcal {R} ^ {*}) \\notin \\mathcal {Q} ^ {\\mathsf {S i g n}} \\wedge \\\\ \\mathcal {O} \\leftarrow \\{\\mathsf {S i g} (\\cdot , \\cdot , \\cdot), \\mathsf {K e y} (\\cdot) \\}, &amp;amp; \\mathcal {R} ^ {*} \\subseteq \\{\\mathsf {p k} _ {i} \\} _ {i \\in [ \\mathsf {p o l y} (\\kappa) ] \\setminus \\mathcal {Q} ^ {\\mathsf {K e y}}} \\end{array} \\right] \\leq \\varepsilon (\\kappa),</span></div>

    <p class="text-gray-300">where  <span class="math">\\operatorname{Sig}(i, m, \\mathcal{R}) \\coloneqq \\operatorname{Sign}(\\mathsf{sk}_i, m, \\mathcal{R})</span> ,  <span class="math">\\operatorname{Sig}</span>  returns  <span class="math">\\perp</span>  if  <span class="math">\\mathsf{pk}_i \\notin \\mathcal{R} \\vee i \\notin [\\mathsf{poly}(\\kappa)]</span> , and  <span class="math">\\mathcal{Q}^{\\mathrm{Sig}}</span>  records the queries to  <span class="math">\\operatorname{Sig}</span> . Furthermore,  <span class="math">\\operatorname{Key}(i)</span>  returns  <span class="math">\\mathsf{sk}_i</span>  and  <span class="math">\\mathcal{Q}^{\\mathrm{Key}}</span>  records the queries to  <span class="math">\\operatorname{Key}</span> .</p>

    <p class="text-gray-300">Anonymity requires that it is infeasible to tell which ring member produced a certain signature as long as there are at least two honest members in the ring. Our anonymity notion is the strongest notion defined in [BKM09] and is there called anonymity against full key exposure.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 11 (Anonymity)</h6>

    <p class="text-gray-300">A ring signature scheme provides anonymity, if for all PPT adversaries <span class="math">\\mathcal{A}</span> and for all polynomials <span class="math">\\mathsf{poly}(\\cdot)</span>, there exists a negligible function <span class="math">\\varepsilon(\\cdot)</span> such that it holds that</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\kappa}),\\\\ \\{(\\mathsf{sk}_{i},\\mathsf{pk}_{i})\\leftarrow\\mathsf{Gen}(\\mathsf{PP})\\}_{i\\in[\\mathsf{poly}(\\kappa)]},\\\\ b\\leftarrow\\mathsf{\\!\\!}^{\\kappa}\\{0,1\\},\\ \\mathcal{O}\\leftarrow\\{\\mathsf{Sig}(\\cdot,\\cdot,\\cdot)\\},\\\\ (m,j_{0},j_{1},\\mathcal{R},\\mathsf{st})\\leftarrow\\mathcal{A}^{\\mathcal{O}}(\\{\\mathsf{pk}_{i}\\}_{i\\in[\\mathsf{poly}(\\kappa)]}),\\\\ \\sigma\\leftarrow\\mathsf{Sign}(\\mathsf{sk}_{j_{b}},m,\\mathcal{R}),\\\\ b^{\\star}\\leftarrow\\mathcal{A}^{\\mathcal{O}}(\\mathsf{st},\\sigma,\\{\\mathsf{sk}_{i}\\}_{i\\in[\\mathsf{poly}(\\kappa)]})\\end{array}:\\ \\begin{array}[]{l}\\mathsf{b}=b^{\\star}\\ \\wedge\\\\ \\{\\mathsf{pk}_{j_{i}}\\}_{i\\in\\{0,1\\}}\\subseteq\\mathcal{R}\\\\ \\end{array}\\right]\\leq\\nicefrac{{1}}{{2}}+\\varepsilon(\\kappa), \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{Sig}(i,m,\\mathcal{R})\\coloneqq\\mathsf{Sign}(\\mathsf{sk}_{i},m,\\mathcal{R})</span>.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.2 Generic Approaches to Design Ring Signatures</h3>

    <p class="text-gray-300">A folklore approach to design ring signatures in the random oracle model is to use the NP relation <span class="math">R_{\\mathsf{RS}}</span> together with a one-way function <span class="math">\\mu</span>, which defines the relation between secret and public keys:</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{R},\\mathsf{sk})\\in R_{\\mathsf{RS}}\\ \\iff\\ \\exists\\ \\mathsf{pk}_{i}\\in\\mathcal{R}_{\\mathsf{RS}}\\ :\\ \\mathsf{pk}_{i}=\\mu(\\mathsf{sk}),</span></p>

    <p class="text-gray-300">and allows to demonstrate knowledge of a witness (a secret key) of one of the public keys in the ring <span class="math">\\mathcal{R}</span>. Usually, one then designs a <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{\\mathsf{RS}}</span> and converts it into a signature scheme using the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300">Linear-Size Signatures. A frequently used instantiation of the above approach is instantiating the relation above by means of a disjunctive proof of knowledge <em>[x10]</em>. Using this approach, one obtains ring signatures of linear size. It might be tempting to think that there is a lot of optimization potential for signature sizes in ring signatures. However, without additional assumptions about how the keys are provided to the verifier, signatures of linear size are already the best one can hope for: the verifier needs to get every public key in the ring to verify the signature.</p>

    <p class="text-gray-300">Reducing Signature Size. However, to further reduce the signature size there is a nice trick which is based on the observation that in many practical scenarios the prospective ring members are already clear prior to the signature generation. Consequently, one can compactly encode all public keys in this ring within some suitable structure and compute the signatures with respect to this compact structure. This trick was first used by Dodis et al. <em>[x13]</em>. Loosely their approach can be described as follows. They use a cryptographic accumulator with a one-way domain to accumulate the ring <span class="math">\\mathcal{R}</span>, a set of public keys being the output of applying the one-way function <span class="math">\\mu</span> to the respective secret key. This way they obtain a succinct representation of <span class="math">\\mathcal{R}</span>. Then, they use a proof system that allows to prove knowledge of a witness of one accumulated value (i.e., the public key) and knowledge of the pre-image thereof (i.e., the corresponding secret key). This proof can be turned into a signature using the Fiat-Shamir heuristic.</p>

    <p class="text-gray-300">Depending on the size of the zero-knowledge membership proof this can yield sublinear (logarithmic or even constant size) signatures. Dodis et al. presented</p>

    <p class="text-gray-300">an instantiation of an accumulator together with the respective zero-knowledge proofs that yield constant size ring signatures based on the strong RSA assumption. Logarithmic size ring signatures under lattice assumptions are presented in <em>[x14]</em>.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.3 Our Construction of Logarithmic Size Ring Signatures</h3>

    <p class="text-gray-300">Our construction basically follows the approach discussed above to reduce signature size. However, in contrast to Dodis et al., besides targeting the post-quantum setting, we (1) <em>do not</em> require a trusted setup, and (2) cannot rely on accumulators with one-way domain which provide <em>quasi-commutativity</em>. Latter is too restricting and not compatible with the setting in which we work. In particular, it excludes Merkle tree accumulators, which is why we chose to rely on a more generic formalization of accumulators (cf. Section 3). Like Dodis et al., we assume that in practical situations rings often stay the same for a long period of time (e.g., some popular rings are used very often by various members of the ring), or have an implicit short description. Consequently, we measure the signature size as that of the actual signature, i.e., the information one requires <em>in addition</em> to the group description. We want to stress once again that when counting the description of the ring as part of the signature, every secure ring signature schemes needs to have signature sizes which are at least linear in the size of the ring.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the ease of presentation let us fix one such popular ring <span class="math">\\mathcal{R}</span> identified by the corresponding accumulator <span class="math">\\mathsf{\\Lambda}_{\\mathcal{R}}</span> and we assume that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{t}<span class="math"> for some </span>t\\in\\mathbb{N}$. We present our construction as Scheme 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Remark 2</h6>

    <p class="text-gray-300">Note that in Scheme 2 crs is not a common reference string (CRS) that needs to be honestly computed by a trusted third party. We simply stick with the notion including a CRS for formal reasons, i.e,. to allow the abstract notion of NIZKs, but as we exclusively use NIZK from <span class="math">\\Sigma</span>-protocols, we do not require a trusted setup and crs is just a description of the hash function which can be globally fixed, e.g., to SHA-256 or SHA-3. Recall, within Fiat-Shamir <span class="math">\\mathsf{\\Pi.Setup}(1^{\\kappa})</span> fixes a RO <span class="math">H:\\mathsf{A}\\times\\mathsf{X}\\to\\mathsf{E}</span>, sets <span class="math">\\mathsf{crs}\\leftarrow(1^{\\kappa},H)</span> and returns crs.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 3</h6>

    <p class="text-gray-300">A trusted setup in context of ring signatures is actually problematic, as it assumes that some mutually trusted party honestly executes the setup. For instance, in case of the strong RSA accumulator <em>[x3, x10]</em> as used within <em>[x11]</em>, the party running the <span class="math">\\mathsf{Gen}</span> algorithm of the accumulator can arbitrarily cheat. This can easily be done by keeping the accumulator secret (a trapdoor) instead of discarding it. Using this information, a dishonest setup allows to insert and delete arbitrary elements into and from the accumulator without changing the accumulator value. In context of ring signatures one thus can arbitrarily modify existing rings used within signatures, which could lead to</p>

    <p class="text-gray-300">|  Setup(1κ): Let Λ be the accumulator with one-way domain based on Scheme 1, run (skΛ, pkΛ) ← Λ.Gen(1κ, t) (note that skΛ = ∅). Run crs ← Π.Setup(1κ) and return PP ← (pkΛ, crs) = ((Hk, fΛ), (1κ, H)).  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  KeyGen(PP): Parse PP as ((Hk, fΛ), crs), run (x, z) ← fΛ.W(1κ), and set pk ← (PP, x), sk ← (pk, z). Return (sk, pk).  |</p>

    <p class="text-gray-300">|  Sign(ski, m, R): Parse sk, as (((Hk, fΛ), crs), xi), zi) and R as (pk1, ..., pk t) = ((·, x1), ..., (·, xt)). Let X = (x1, ..., xt), run (ΛX, aux) ← Λ.Eval((·, pkΛ), X) and witfΛ(zi) ← Λ.WitCreate((·, pkΛ), ΛX, aux, fΛ(zi)). Obtain (zi, (aj)j∈[t], (bj)j∈[t]) ← Trans(zi, witfΛ(zi)), and return the signature σ ← (π, ΛX), where π ← Π.Proof(crs, (ΛX, fΛ, Hk), (zi, (aj)j∈[t], (bj)j∈[t])).  |</p>

    <p class="text-gray-300">|  Verify(m, σ, R): Parse σ as (π, ΛX) and R as (pk1, ..., pk t) = (((Hk, fΛ), crs), x1), ..., (·, xt)). Let X = (x1, ..., xt), and compute (Λ'X, aux') ← Λ.Eval((·, pkΛ), X).  |</p>

    <p class="text-gray-300">|  If Λ'X ≠ ΛX return 0. Otherwise return Π.Verify(crs, (ΛX, fΛ, Hk), π).  |</p>

    <p class="text-gray-300">Scheme 2. Construction of logarithmic size RS.</p>

    <p class="text-gray-300">modification of rings to just include public keys into the ring so that for every member of the ring the sole fact to know that one of these persons produced a signature already leads to severe consequences. We stress that in our case there is no trusted setup. In particular, there is no accumulator secret and the public parameters are just descriptions of hash functions and a OWF.</p>

    <p class="text-gray-300">Now, we argue that our ring signature presented in Scheme 2 represents a secure ring signature scheme, where we omit correctness which is straightforward to verify.</p>

    <p class="text-gray-300">Theorem 1. If  <span class="math">\\Lambda</span>  is a collision free accumulator with one-way domain with respect to  <span class="math">f_{\\Lambda}</span>  and  <span class="math">\\Pi</span>  is a simulation-sound extractable non-interactive proof system, then the ring signature scheme in Scheme 2 is unforgeable.</p>

    <p class="text-gray-300">Proof. We prove unforgeability using a sequence of games.</p>

    <p class="text-gray-300">Game 0: The original unforgeability game.</p>

    <p class="text-gray-300">Game 1: As Game 0, but we modify Gen to setup  <span class="math">(\\mathsf{crs},\\tau)</span>  using  <span class="math">S_{1}</span>  and henceforth simulate all proofs in Sign without a witness using  <span class="math">\\tau</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transition - Game 0  <span class="math">\\rightarrow</span>  Game 1: A distinguisher between Game 0 and Game 1 is a zero-knowledge distinguisher for  <span class="math">\\Pi</span> , i.e.,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}[S_0] - \\operatorname{Pr}[S_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon_{\\mathbf{zk}}(\\kappa)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game 2: As Game 1, but we further modify Gen to setup  <span class="math">(\\mathsf{crs},\\tau ,\\xi)</span>  using  <span class="math">\\mathcal{E}_1</span>  and store  <span class="math">\\xi</span></p>

    <p class="text-gray-300">Transition - Game 1  <span class="math">\\rightarrow</span>  Game 2: By simulation-sound extractability, this change is only conceptual, i.e.,  <span class="math">\\operatorname<em>{Pr}[S_1] = \\operatorname</em>{Pr}[S_2]</span> .</p>

    <p class="text-gray-300">Game 3: As Game 2, but for the forgery  <span class="math">(m^{<em>},\\sigma^{</em>},\\mathcal{R}^{<em>})</span>  output by the adversary we parse  <span class="math">\\sigma^{</em>}</span>  as  <span class="math">(\\pi ,\\Lambda_{\\mathcal{X}})</span>  and obtain  <span class="math">(z_{i},(a_{i})_{i\\in [k]},(b_{i})_{i\\in [k]})\\gets \\mathcal{E}_{2}(\\mathsf{crs},\\xi ,(\\Lambda_{\\mathcal{X}},f_{\\Lambda},H_{k}),\\pi)</span> . If the extractor fails, we abort.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transition - Game 2 <span class="math">\\rightarrow</span> Game 3: Game 2 and Game 3 proceed identically, unless we abort. The probability for the abort event to happen is upper bounded by <span class="math">\\varepsilon_{\\mathsf{ext}}(\\kappa)</span> which is why we can conclude that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_3] - \\Pr[S_2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon_{\\mathsf{ext}}(\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 4: As Game 3, but we abort if we have extracted <span class="math">(z_{i},(a_{i})_{i\\in [n]},(b_{i})_{i\\in [n]})</span> so that <span class="math">(\\cdot ,\\mathsf{wt}_{f_{\\Lambda}(z_i)})\\gets \\mathsf{Trans}^{-1}(z_i,(a_i)_{i\\in [n]},(b_i)_{i\\in [n]})</span> is a valid witness for some <span class="math">f_{\\Lambda}(z_i)</span> which was never accumulated.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transition - Game 3 <span class="math">\\rightarrow</span> Game 4: If we abort in Game 4, we have a collision for the accumulator. That is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[S_3] - \\operatorname</em>{Pr}[S_4]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon_{\\mathsf{cf}}(\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 5: As Game 4, but we guess the index <span class="math">i^{\\star}</span> the adversary will attack beforehand, and abort if our guess is wrong.</p>

    <p class="text-gray-300">Transition - Game 4 <span class="math">\\rightarrow</span> Game 5: The success probability in Game 4 is the same as in Game 5, unless our guess is wrong, i.e., <span class="math">\\operatorname<em>{Pr}[S_5] = 1 / \\mathsf{poly}(\\kappa) \\cdot \\operatorname</em>{Pr}[S_4]</span>.</p>

    <p class="text-gray-300">Case 6: As Game 5, but instead of honestly generating the keypair for user <span class="math">i^{\\star}</span>, we engage with a challenger of a OWF to obtain <span class="math">x_{i^{\\star}}</span> and include it in <span class="math">\\mathsf{pk}_{i^{\\star}}</span> accordingly. We set <span class="math">\\mathsf{sk}_{i^{\\star}} \\gets \\emptyset</span>.</p>

    <p class="text-gray-300">Transition - Game 5 <span class="math">\\rightarrow</span> Game 6: This change is conceptual, i.e., <span class="math">\\operatorname<em>{Pr}[S_5] = \\operatorname</em>{Pr}[S_6]</span>.</p>

    <p class="text-gray-300">In the last game, we have an adversary against the OWF, i.e., <span class="math">\\operatorname<em>{Pr}[S_6] \\leq \\varepsilon_{\\mathsf{owf}}(\\kappa)</span>. All in all, we have that <span class="math">\\operatorname</em>{Pr}[S_0] \\leq \\mathsf{poly}(\\kappa) \\cdot \\varepsilon_{\\mathsf{owf}}(\\kappa) + \\varepsilon_{\\mathsf{zk}}(\\kappa) + \\varepsilon_{\\mathsf{ext}}(\\kappa) + \\varepsilon_{\\mathsf{cf}}(\\kappa)</span></p>

    <p class="text-gray-300">Theorem 2. If <span class="math">\\Pi</span> is a zero-knowledge non-interactive proof system, then the ring signature scheme in Scheme 2 is anonymous.</p>

    <p class="text-gray-300">Proof. We prove anonymity using a sequence of games.</p>

    <p class="text-gray-300">Game 0: The original anonymity game.</p>

    <p class="text-gray-300">Case 1: As Game 0, but we modify Gen to setup <span class="math">(\\mathsf{crs},\\tau)</span> using <span class="math">S_{1}</span> and henceforth simulate all proofs in Sign without a witness using <span class="math">\\tau</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Transition - Game 0 <span class="math">\\rightarrow</span> Game 1: A distinguisher between Game 0 and Game 1 is a zero-knowledge distinguisher for <span class="math">\\Pi</span>, i.e., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname<em>{Pr}[S_0] - \\operatorname</em>{Pr}[S_1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\varepsilon_{\\mathsf{zk}}(\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Game 1 the simulation is independent of <span class="math">b</span>, meaning that <span class="math">\\operatorname<em>{Pr}[S_1] = 1/2</span>. Thus, we have <span class="math">\\operatorname</em>{Pr}[S_0] \\leq 1/2 + \\varepsilon_{\\mathsf{zk}}(\\kappa)</span>, which concludes the proof.</p>

    <p class="text-gray-300">In this section we discuss some implementation aspects regarding instantiating our ring signature scheme. Moreover, we evaluate the efficiency of a concrete instantiation. Since we require simulation-sound extractable NIZK proof systems, we confirm that the Fiat-Shamir (resp. Unruh) transformed version of ZKB++ represents a suitable proof system in the ROM (resp. QROM). We again want to note that we were not able to include the ZKB++ construction due to space limitations, but refer the reader to [CDG+17] for the details.</p>

    <p class="text-gray-300">5.1 Simulation-Sound Extractability of ZKB++</p>

    <p class="text-gray-300">To instantiate our ring signature scheme using ZKB++, we first need to confirm that the NIZK proof system obtained by applying the Fiat-Shamir/Unruh transform to ZKB++ is in fact simulation-sound extractable. For the Unruh-transformed proof system, this was already shown in <em>[CDG+17, Theorem 2]</em> in the QROM, which is why we only focus on the Fiat-Shamir version. We base our argumentation upon the argumentation in <em>[x11]</em>. What we have to do is to show that the FS transformed ZKB++ is zero-knowledge and provides quasi-unique responses in the ROM. We do so by proving two lemmas. Combining those lemmas with <em>[x11, Theorem 2 and Theorem 3]</em> then yields simulation-sound extractability as a corollary.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">Q_{H}</span> be the number of queries to the random oracle <span class="math">H</span>, <span class="math">Q_{S}</span> be the overall queries to the simulator, and let the commitments be instantiated via a RO <span class="math">H^{\\prime}</span> with output space <span class="math">\\{0,1\\}^{\\rho}</span> and the committed values having min entropy <span class="math">\\nu</span>. Then the probability <span class="math">\\epsilon(\\kappa)</span> for all PPT adversaries <span class="math">\\mathcal{A}</span> to break zero-knowledge of <span class="math">\\kappa</span> parallel executions of the FS transformed ZKB++ is bounded by <span class="math">\\epsilon(\\kappa)\\leq\\nicefrac{{s}}{{2^{\\nu}}}+\\nicefrac{{(Q_{S}\\cdot Q_{H})}}{{2^{3\\cdot\\rho}}}</span>.</p>

    <p class="text-gray-300">The lemma above was already proven for ZKBoo in <em>[DOR+16]</em>. For ZKB++ the argumentation is the same. We restate the proof below for completeness.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We bound the probability of any PPT adversary <span class="math">\\mathcal{A}</span> to win the zero-knowledge game by showing that the simulation of the proof oracle is statistically close to the real proof oracle. For our proof let the environment maintain a list H where all entries are initially set to <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">The zero-knowledge game where the proofs are honestly computed, and the ROs are simulated honestly. As Game 0, but whenever the adversary requests a proof for some tuple <span class="math">(x,w)</span> we choose <span class="math">\\texttt{e}\\xleftarrow{\\text{\\tiny H}}\\{0,1,2\\}^{\\kappa}</span> before computing a and z. If <span class="math">\\texttt{H}[(\\texttt{a},x)]\\neq\\bot</span> we abort and call that event <span class="math">E</span>. Otherwise, we set <span class="math">\\texttt{H}[(\\texttt{a},x)]\\leftarrow\\texttt{e}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Both games proceed identically unless <span class="math">E</span> happens. The message a includes 3 RO commitments with respect to <span class="math">H^{\\prime}</span>, i.e., the min-entropy is lower bounded by <span class="math">3\\cdot\\rho</span>. We have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\nicefrac{{(Q_{S}\\cdot Q_{H})}}{{2^{3\\cdot\\rho}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As Game 1, but we compute the commitments in a so that the ones which will never be opened according to e contain random values.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The statistical difference between Game 1 and Game 2 can be upper bounded by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{1}]-\\Pr[S_{2}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa\\cdot\\nicefrac{{1}}{{2^{\\nu}}}<span class="math"> (for compactness we collapsed the </span>s$ game changes into a single game).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As Game 2, but we use the HVZK simulator to obtain <span class="math">(\\texttt{a},\\texttt{e},\\texttt{z})</span>. This change is conceptual, i.e., <span class="math">\\Pr[S_{2}]=\\Pr[S_{3}]</span>.</p>

    <p class="text-gray-300">In Game 0, we sample from the first distribution of the zero-knowledge game, whereas we sample from the second one in Game 3; the distinguishing bounds shown above conclude the proof. ∎</p>

    <p class="text-gray-300">###</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let the commitments be instantiated via a RO <span class="math">H^{\\prime}</span> with output space <span class="math">\\{0,1\\}^{\\rho}</span> and let <span class="math">Q_{H^{\\prime}}</span> be the number of queries to <span class="math">H^{\\prime}</span>, then the probability to break quasi-unique responses is bounded by <span class="math">Q_{H^{\\prime}}^{2}/2^{\\rho}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To break quasi-unique responses, the adversary would need to come up with two valid proofs <span class="math">(\\mathsf{a},\\mathsf{e},\\mathsf{z})</span> and <span class="math">(\\mathsf{a},\\mathsf{e},\\mathsf{z}^{\\prime})</span>. The last message <span class="math">\\mathsf{z}</span> (resp <span class="math">\\mathsf{z}^{\\prime}</span>) only contains openings to commitments, meaning that breaking quasi unique responses implies finding a collision for at least one of the commitments. The probability for this to happen is upper bounded by <span class="math">Q_{H^{\\prime}}^{2}/2^{\\rho}</span> which concludes the proof. ∎</p>

    <p class="text-gray-300">Combining Lemma 3 and Lemma 4 with <em>[x10, Theorem 2 and Theorem 3]</em> yields the following corollary.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">The FS transformed ZKB++ is simulation-sound extractable.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.2 Implementation of the Circuit</h3>

    <p class="text-gray-300">One very important factor, when it comes to the actual size of the signatures, is the concrete implementation of the circuit. To this end, we explicitly describe our design strategy, which uses 2-to-1 multiplexers as central components. A 2-to-1 multiplexer selects between two input wires based on a selection bit. In particular, given a selection bit <span class="math">s</span> and two input wires <span class="math">i_{0}</span> and <span class="math">i_{1}</span>, the multiplexer outputs <span class="math">i_{s}</span>. More formally, we can describe the multiplexer as function <span class="math">\\nu</span> defined as</p>

    <p class="text-gray-300"><span class="math">\\nu(s,i_{0},i_{1})=(\\neg s\\ \\wedge\\ i_{0})\\ \\vee\\ (s\\ \\wedge\\ i_{1}).</span></p>

    <p class="text-gray-300">This function can be expressed using only 1 AND and 2 XOR gates for 1-bit input wires as</p>

    <p class="text-gray-300"><span class="math">\\nu(s,i_{0},i_{1})=((i_{0}\\oplus i_{1})\\wedge s)\\oplus i_{0}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For values of multiple bits, <span class="math">\\nu</span> is applied bit-by-bit. Now, to instantiate $a_{i}=H_{k}(a_{i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i+1})\\ \\vee\\ a_{i}=H_{k}(b_{i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{i+1})<span class="math"> in a straight-forward way, it would be possible to write the expression as </span>a_{i}=\\nu(s_{i+1},H_{k}(a_{i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b_{i+1}),H_{k}(b_{i+1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{i+1})<span class="math"> where the selection bits </span>s_{i+1}<span class="math"> encode the path and are additionally part of the witness. Besides the cost for the two hash function evaluations, this would require us to account for 1 AND gate for each output bit of the hash function </span>H_{k}$ and each level of the Merkle tree accumulator.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, with a little more care, we can even obtain a more efficient solution. Namely, when shifting the multiplexer from the output of the hash function to its inputs and when additionally rotating <span class="math">a_{i+1}</span> and <span class="math">b_{i+1}</span> based on the selection bit we obtain an equivalent representation of the equation given above:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$a_{i}=H_{k}(\\nu(s_{i+1},a_{i+1},b_{i+1})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu(s_{i+1},b_{i+1},a_{i+1})).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When we let $\\nu^{\\prime}(s,i_{0},i_{1})=\\nu(s,i_{0},i_{1})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\nu(s,i_{1},i_{0})$, we can write this as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">a_{i}=H_{k}(\\nu^{\\prime}(s_{i+1},a_{i+1},b_{i+1})).</span></p>

    <p class="text-gray-300">The important point to observe here is that we can trade one (cheap) additional multiplexer for one (expensive) full evaluation of the hash function. Note that <span class="math">\\nu^{\\prime}</span> computes <span class="math">(i_{0}\\oplus i_{1})\\wedge s</span> twice, and thus we can further simplify it and explicitly instantiate <span class="math">\\nu^{\\prime}</span> as conditional swap gate:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\nu^{\\prime}(s,i_{0},i_{1})=i_{0}\\oplus s^{\\prime}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i_{1}\\oplus s^{\\prime}\\text{ where }s^{\\prime}=(i_{0}\\oplus i_{1})\\wedge s.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus <span class="math">\\nu^{\\prime}</span> only requires 1 AND gate. Additionally, the possibility to swap the inputs allows us to drop all <span class="math">a_{i}</span> from the witness and to re-write the statement as</p>

    <p class="text-gray-300"><span class="math">\\Lambda_{\\mathcal{X}}=H_{k}(\\nu^{\\prime}(s_{1},H_{k}(\\dots H_{k}(\\nu^{\\prime}(s_{k},f_{\\Lambda}(z),b_{k}),\\dots),b_{1}))).</span></p>

    <p class="text-gray-300">We remark that this statement bears similarities with the recent statement used by Boneh et al. <em>[x1]</em>. However, in contrast to our work, they introduce a novel property for the used hash function which they term third preimage resistance, and construct a third preimage resistant hash function <span class="math">H</span> as <span class="math">H(x,y)=H(x,y)\\oplus H(y,x)</span>. The important difference to our approach is that they need two evaluations of the hash function, whereas we only need one.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 Selection of Symmetric-Key Primitives</h3>

    <p class="text-gray-300">When instantiating our ring signature scheme using ZKB++, the selection of the underlying primitives is of importance for the actual signature sizes as well as the overall performance. As ZKB++’s proof size depends on the number of multiplication gates and the size of the operands, we require a OWF and a collision-resistant hash function with a representation as circuit, where the product of the multiplicative complexity and the number of bits required to store field elements is minimal. Note that for the OWF we can observe that, when instantiating it with a block cipher, only one plaintext-ciphertext pair per key is visible to an adversary. Hence, we have the same requirements as in <em>[CDG+17]</em>, which is why we also choose LowMC <em>[ARS+15, ARS+16]</em> with a reduced data complexity to build the OWF. For the selection of the collision-resistant hash function we are presented with different options:</p>

    <p class="text-gray-300">Standardized Hash Functions. SHA-256 or SHA-3 are the obvious choices for collision resistant hash functions. SHA-256’s compression function requires around 25000 multiplication gates <em>[BCG+14]</em> and SHA-3’s permutation even more with around 38400 gates <em>[x21]</em>.</p>

    <p class="text-gray-300">Sponge Construction with Low Multiplicative Complexity Ciphers. Using a block cipher with small multiplicative complexity as permutation in a sponge construction, e.g., using LowMC or MiMC <em>[AGR+16]</em>, enables the construction of hash functions with similar security guarantees as SHA-256 and SHA-3, but with a significantly reduced multiplicative complexity. Using the numbers from <em>[AGR+16]</em>, MiMCHash-256 requires 1293 multiplications with a field size of 1025 bits. LowMCHash-256 only requires a 1 bit binary field and 3540 AND gates. Thus, a hash based on LowMC is a better candidate for our use case.</p>

    <p class="text-gray-300">Davies-Mayer Transformation with Low Multiplicative Complexity Ciphers. As a lower-cost alternative to sponge based constructions, Boneh et al. [BEF18] suggest to use a collision resistant hash function obtained by applying the Davis-Meyer transformation to a block cipher with low multiplicative complexity. This is reasonable because collision resistance is only required for a fixed message length, being equivalent to the sum of block size and key size of the underlying blockcipher (i.e., LowMC).</p>

    <p class="text-gray-300">Finally we present signature sizes when instantiating our ring signature scheme with LowMC for both, the OWF and the hash function. For the instantiation of the hash function we present estimations based on sponge constructions as well as Davies-Mayer constructions. Table 1 presents the signature size estimations for the sponge-based instantiation for different choices of ring sizes and aiming at a 128 bit post-quantum security level. We compute them using the formulas from  <span class="math">\\left[\\mathrm{CDG}^{+}17\\right]</span> . The proofs are of size  <span class="math">t \\cdot (c + 2s + \\log_2(3) + \\ell \\cdot m + i)</span>  bits when using the Fiat-Shamir transform, and of  <span class="math">t \\cdot (c + 3s + \\log_2(3) + 2\\ell \\cdot m + i)</span>  bits when using the Unruh-transform, respectively, where  <span class="math">t</span>  is the number of repetitions,  <span class="math">c</span>  the size of the commitments,  <span class="math">i</span>  the size of the input to the circuit,  <span class="math">\\ell</span>  the size of the underlying field,  <span class="math">m</span>  the number of AND gates, and  <span class="math">s</span>  the size of the seeds used to generate the random tapes. We use ZKB++ as instantiated in  <span class="math">\\left[\\mathrm{CDG}^{+}17\\right]</span>  and give the numbers for both the Fiat-Shamir and Unruh transformed proof system.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ring size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(FS/ROM)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Unruh/QROM)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2k</td>

            <td class="px-3 py-2 border-b border-gray-700">948708 + 1775214 · k bits</td>

            <td class="px-3 py-2 border-b border-gray-700">1560156 + 3437862 · k bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">1200 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2289 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">2283 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">4388 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">4450 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">8584 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Following [BEF18] we also present numbers using a hash function obtained using the Davies-Meyer transform in Table 2.</p>

    <p class="text-gray-300">Table 1. Signature sizes at the 128 bit post-quantum security level using LowMC with 1024 bit block size, 10 S-boxes and 118 rounds in the sponge framework.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ring size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(FS/ROM)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">σ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Unruh/QROM)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2k</td>

            <td class="px-3 py-2 border-b border-gray-700">948708 + 986814 · k bits</td>

            <td class="px-3 py-2 border-b border-gray-700">1560156 + 1861062 · k bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">719 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">1327 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">1321 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">2463 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">2526 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">4735 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Signature sizes at the 128 bit post-quantum security level using Davies-Meyer with LowMC with 256 bit block size, 10 S-boxes and 58 rounds.</p>

    <p class="text-gray-300">Improvements compared to the Work of Boneh et al. [BEF18]. Using the same LowMC instance with 1374 AND gates as Boneh et al. [BEF18], we obtain significantly shorter sizes for the membership proof in the accumulator</p>

    <p class="text-gray-300">(and therefore also significantly shorter ring signature sizes) compared to what we would obtain when using their techniques to prove membership in the accumulator in zero knowledge. For ring size of <span class="math">2^{20}</span> we obtain 2134 KB when using Fiat-Shamir and 3952 KB when using Unruh, respectively. This reduction in proof (signature) size is not surprising: observe that the statement they have to prove requires the evaluation of two hash functions per level in the tree. We only require a conditional swap gate and a single hash function evaluation yielding a much lower number of required AND gates (roughly <span class="math">\\nicefrac{{1}}{{2}}</span>). We want to stress that our conditional swap gate-based approach is also useful to reduce the group signature sizes of <em>[x1, Construction II]</em>, which internally uses zero-knowledge membership proofs with respect to a Merkle tree accumulator.</p>

    <p class="text-gray-300">Finally, we also note that Ligero <em>[x1]</em>, a recent NIZK proof system for general circuits, offers proofs of logarithmic size in the number of multiplication gates in the prime field case respectively in the number of AND and XOR gates in the case of binary fields, which would allow us to reduce the signature size significantly. However, to the best of our knowledge, it is unclear whether Ligero provides simulation-sound extractability.</p>

    <h2 id="sec-31" class="text-2xl font-bold">6 Conclusions</h2>

    <p class="text-gray-300">In this this work we made some important steps towards establishing privacy-enhancing primitives which are solely built from symmetric-key primitives and therefore do not require any structured hardness assumptions. In our work, we followed a modular concept and first introduced a post-quantum accumulator with efficient zero-knowledge membership proofs of sublinear size. Besides the applications to logarithmic size ring signatures as we presented in this paper, we believe that our post-quantum accumulator construction with zero-knowledge proofs may well have broader impact in the construction of other (privacy-enhancing) protocols in the post-quantum setting.</p>

    <p class="text-gray-300">Open Questions. In addition, we believe that our work also opens up quite some possibilities for further research.</p>

    <p class="text-gray-300">First, in the context of privacy-enhancing protocols, it would be interesting to investigate how to extend our methods to obtain group signatures <em>[x7]</em>, i.e., anonymous signatures that provide the possibility to re-identify anonymous signers by a dedicated party. We note that Dodis et al. <em>[x6]</em> informally discuss that when adding ID escrow functionality to their ring signature scheme yields group signatures. Basically, the lattice-based construction of Libert et al. <em>[x14]</em> can be considered as an instantiation of the former paradigm. The problem is that this paradigm requires IND-CCA2 secure public-key encryption, which does not exist given our constraints. In addition, it is well known <em>[x2, x5]</em> that group signatures in the static model by Bellare et al. in <em>[x3]</em> imply public-key encryption. This means that the best one could hope for would be a construction being secure in a weakened version of the Bellare et al. model. Work in this direction was earlier pursued by Camenisch and Groth <em>[x5]</em>, who showed how to construct group signature schemes in a</p>

    <p class="text-gray-300">weaker model from one-way functions and non-interactive zero-knowledge arguments. The question which remains open in our context is whether one can find instantiations without the requirement for structured hardness assumptions and providing the practical efficiency one would hope for, i.e., ideally instantiations which just require to prove statements with respect to a few evaluations of a block cipher. A similar question was recently investigated by Boneh et al. in <em>[x1]</em>, where they constructed practical group signature schemes from symmetric-key primitives. They use a security model without opening mechanism but with revocation feature for keys and signatures, respectively. Since this is a different model, our question still remains open.</p>

    <p class="text-gray-300">Second, in the context of symmetric-key primitives, one may observe that—despite the recent trend to construct symmetric-key primitives with particularly low AND count—there is no practical application so far which would require collision resistant hash functions with particularly low AND count. Since our accumulator construction relies on collision resistant hash functions, our work may well also open up new fields of research in the symmetric-key community.</p>

    <p class="text-gray-300">Acknowledgments. The authors have been supported by EU H2020 Project Prismacloud, grant agreement nº644962. We thank Christian Rechberger for discussions on the choice of symmetric-key primitives, especially regarding the instantiation of hash functions using LowMC, as well as for providing us with updated LowMC instances. We also thank Daniel Kales for ideas to reduce the cost for the conditional swap gate.</p>

    <h2 id="sec-32" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AGR^{+}16] M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and T. Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In ASIACRYPT, 2016.</li>

      <li>[AHIV17] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In CCS, 2017.</li>

      <li>[ARS^{+}15] M. R. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. In EUROCRYPT, 2015.</li>

      <li>[ARS^{+}16] M. R. Albrecht, C. Rechberger, T. Schneider, T. Tiessen, and M. Zohner. Ciphers for MPC and FHE. IACR Cryptology ePrint Archive, 2016:687, 2016.</li>

      <li>[AW04] M. Abdalla and B. Warinschi. On the minimal assumptions of group signature schemes. In ICICS, 2004.</li>

      <li>[BCC04] E. F. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In CCS, 2004.</li>

      <li>[BCC^{+}15] J. Bootle, A. Cerulli, P. Chaidos, E. Ghadafi, J. Groth, and C. Petit. Short accountable ring signatures based on DDH. In ESORICS, 2015.</li>

      <li>[BCD^{+}17] F. Baldimtsi, J. Camenisch, M. Dubovitskaya, A. Lysyanskaya, L. Reyzin, K. Samelin, and S. Yakoubov. Accumulators with applications to anonymity-preserving revocation. In IEEE EuroS&P 2017, 2017.</li>

      <li>[BCG^{+}14] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer, and M. Virza. Zerocash: Decentralized anonymous payments from bitcoin. In IEEE SP, 2014.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[Bd93] J. Benaloh and M. de Mare. One-way Accumulators: A Decentralized Alternative to Digital Signatures. In EUROCRYPT, 1993.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BEF18] D. Boneh, S. Eskandarian, and B. Fisch. Post-quantum group signatures from symmetric primitives. IACR Cryptology ePrint Archive, 2018:261, 2018.</li>

      <li>[BKM09] A. Bender, J. Katz, and R. Morselli. Ring signatures: Stronger definitions, and constructions without random oracles. J. Cryptology, 22(1):114–138, 2009.</li>

      <li>[BL07] E. Brickell and J. Li. Enhanced privacy id: a direct anonymous attestation scheme with enhanced revocation capabilities. In WPES, 2007.</li>

      <li>[BLL00] A. Buldas, P. Laud, and H. Lipmaa. Accountable certificate management using undeniable attestations. In CCS, 2000.</li>

      <li>[BMW03] M. Bellare, D. Micciancio, and B. Warinschi. Foundations of group signatures: Formal definitions, simplified requirements, and a construction based on general assumptions. In EUROCRYPT, 2003.</li>

      <li>[BP97] N. Baric and B. Pfitzmann. Collision-free Accumulators and Fail-stop Signature Schemes Without Trees. In EUROCRYPT, pages 480–494, 1997.</li>

      <li>[BPW12] D. Bernhard, O. Pereira, and B. Warinschi. How not to prove yourself: Pitfalls of the fiat-shamir heuristic and applications to helios. In ASIACRYPT, 2012.</li>

      <li>[CDG^{+}17] M. Chase, D. Derler, S. Goldfeder, C. Orlandi, S. Ramacher, C. Rechberger, D. Slamanig, and G. Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In CCS, 2017.</li>

      <li>[CDS94] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of partial knowledge and simplified design of witness hiding protocols. In CRYPTO, 1994.</li>

      <li>[CG04] J. Camenisch and J. Groth. Group signatures: Better efficiency and new theoretical aspects. In SCN, 2004.</li>

      <li>[CGS07] N. Chandran, J. Groth, and A. Sahai. Ring signatures of sub-linear size without random oracles. In ICALP, 2007.</li>

      <li>[CL02] J. Camenisch and A. Lysyanskaya. Dynamic Accumulators and Application to Efficient Revocation of Anonymous Credentials. In CRYPTO, 2002.</li>

      <li>[CvH91] D. Chaum and E. van Heyst. Group signatures. In EUROCRYPT, 1991.</li>

      <li>[Dam10] I. Damgård. On <span class="math">\\Sigma</span>-protocols. 2010. http://www.cs.au.dk/~ivan/Sigma.pdf.</li>

      <li>[DHS15] D. Derler, C. Hanser, and D. Slamanig. Revisiting cryptographic accumulators, additional properties and relations to other primitives. In CT-RSA, 2015.</li>

      <li>[DKNS04] Y. Dodis, A. Kiayias, A. Nicolosi, and V. Shoup. Anonymous identification in ad hoc groups. In EUROCRYPT, 2004.</li>

      <li>[DOR^{+}16] D. Derler, C. Orlandi, S. Ramacher, C. Rechberger, and D. Slamanig. Digital signatures from symmetric-key primitives. IACR Cryptology ePrint Archive, 2016:1085, 2016.</li>

      <li>[DS16] D. Derler and D. Slamanig. Key-homomorphic signatures and applications to multiparty signatures and non-interactive zero-knowledge. IACR Cryptology ePrint Archive, 2016:792, 2016.</li>

      <li>[FKMV12] S. Faust, M. Kohlweiss, G. A. Marson, and D. Venturi. On the non-malleability of the fiat-shamir transform. In INDOCRYPT, 2012.</li>

      <li>[FS86] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, 1986.</li>

      <li>[GK15] J. Groth and M. Kohlweiss. One-out-of-many proofs: Or how to leak a secret and spend a coin. In EUROCRYPT, 2015.</li>

    </ul>

    <p class="text-gray-300">[GMO16] I. Giacomelli, J. Madsen, and C. Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In USENIX Security, 2016.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Gon17] A. González. A ring signature of size <span class="math">\\theta(\\sqrt[3]{n})</span> without random oracles. Cryptology ePrint Archive, Report 2017/905, 2017.</li>

      <li>[IKOS09] Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai. Zero-knowledge proofs from secure multiparty computation. SIAM J. Comput., 39(3):1121–1152, 2009.</li>

      <li>[LLNW16] B. Libert, S. Ling, K. Nguyen, and H. Wang. Zero-knowledge arguments for lattice-based accumulators: Logarithmic-size ring signatures and group signatures without trapdoors. In EUROCRYPT, 2016.</li>

      <li>[MCG08] C. A. Melchor, P. Cayrel, and P. Gaborit. A new efficient threshold ring signature scheme based on coding theory. In PQCrypto, 2008.</li>

      <li>[MGGR13] I. Miers, C. Garman, M. Green, and A. D. Rubin. Zerocoin: Anonymous distributed e-cash from bitcoin. In IEEE S&P, 2013.</li>

      <li>[MP17] M. S. E. Mohamed and A. Petzoldt. Ringrainbow - an efficient multivariate ring signature scheme. In AFRICACRYPT, 2017.</li>

      <li>[MS17] G. Malavolta and D. Schröder. Efficient ring signatures in the standard model. In ASIACRYPT, 2017.</li>

      <li>[NIS15] NIST. SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions. National Institute of Standards and Technology (NIST), FIPS PUB 202, U.S. Department of Commerce, 2015.</li>

      <li>[RST01] R. L. Rivest, A. Shamir, and Y. Tauman. How to leak a secret. In ASIACRYPT, 2001.</li>

      <li>[Unr12] D. Unruh. Quantum proofs of knowledge. In EUROCRYPT, 2012.</li>

      <li>[Unr15] D. Unruh. Non-interactive zero-knowledge proofs in the quantum random oracle model. In EUROCRYPT, 2015.</li>

      <li>[Unr16] D. Unruh. Computationally binding quantum commitments. In EUROCRYPT, 2016.</li>

    </ul>`;
---

<BaseLayout title="Post-Quantum Zero-Knowledge Proofs for Accumulators with App... (2017/1154)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/1154
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
