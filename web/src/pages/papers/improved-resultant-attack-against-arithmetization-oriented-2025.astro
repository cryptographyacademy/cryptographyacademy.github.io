---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/259';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Resultant Attack against Arithmetization-Oriented Primitives';
const AUTHORS_HTML = 'Augustin Bariant, Aurélien Boeuf, Pierre Briaud, Maël Hostettler, Morten Øygarden, Håvard Raddum';

const CONTENT = `    <p class="text-gray-300">Augustin Bariant<sup>1</sup> , Aur´elien Boeuf<sup>2</sup> , Pierre Briaud<sup>3</sup> , Ma¨el Hostettler<sup>4</sup> , Morten Øygarden<sup>3</sup> , and H˚avard Raddum<sup>3</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><sup>1</sup> ANSSI, Paris, France 2 INRIA, Paris, France 3 Simula UiB, Bergen, Norway <sup>4</sup> T´el´ecom SudParis, Evry-Courcouronnes, France ´ augustin.bariant@ssi.gouv.fr, aurelien.boeuf@inria.fr mael.hostettler@telecom-sudparis.eu {pierre,morten.oygarden,haavardr}@simula.no</p>
    </blockquote>

    <p class="text-gray-300">Abstract. In the last decade, the introduction of advanced cryptographic protocols operating on large finite fields F<sup>q</sup> has raised the need for efficient cryptographic primitives in this setting, commonly referred to as Arithmetization-Oriented (AO). The cryptanalysis of AO hash functions is essentially done through the study of the CICO problem on the underlying permutation. On several AO hash functions relying on S-boxes with low degree inverse, two recent works at Crypto 2024 and Asiacrypt 2024 managed to solve the CICO problem much more efficiently than traditional Gr¨obner basis methods, using respectively advanced Gr¨obner basis techniques and resultants.</p>

    <p class="text-gray-300">In this paper, we propose an attack framework based on resultants that applies to a wide range of AO permutations and improves significantly upon these two recent works. Our improvements mainly come from an efficient reduction procedure that we propose and rigorously analyze, taking advantage of fast multivariate multiplication. We present the most efficient attacks on Griffin, Arion, Anemoi, and Rescue. We show that most variants of Griffin, Arion and Anemoi fail to reach the claimed security level. For the first time, we successfully break a parameter set of Rescue, namely its 512-bit security variant. The presented theory and complexity estimates are backed up with experimental attacks. Notably, we practically find CICO solutions for 8 out of 10 rounds of Griffin, 11 out of 21 rounds of Anemoi, 6 out of 18 rounds of Rescue, improving by respectively 1, 3 and 1 rounds on the previous best practical attacks.</p>

    <p class="text-gray-300">Cryptographic protocols for zero-knowledge (ZK) proofs, multi-party computation (MPC) and fully homomorphic encryption (FHE) offer strong privacypreserving functionalities. Real-world implementations of these protocols will often have to operate in conjunction with symmetric primitives such as encryption schemes and hash functions. However, ZK, MPC and FHE protocols tend to operate over large prime fields, and their efficiency is often linked to the number and type of non-linear operations the protocol has to perform. As a result, the standard symmetric primitive choices of AES and SHA-3 – which work over binary fields and have been designed with a different efficiency paradigm in mind – tend to be slow when run as a part of these protocols.</p>

    <p class="text-gray-300">Numerous "ZK-/MPC-/FHE-friendly" symmetric ciphers and hash functions have been designed in recent years to address this problem. Depending on the target use case, these primitives often work over particular prime fields, and try to limit the number of non-linear operations to perform when executing the primitive. The implementation cost of such primitives varies depending on the protocol where they are used. In FHE-friendly designs, where the output of one multiplication is used as an input for the next, the multiplicative depth—defined as the number of sequential multiplications required—is the most important factor. In MPC-friendly primitives, however, this quantity is irrelevant; what matters is the total number of multiplications, as each of them increases the communication cost between the parties. Such subtleties mean there is not one single optimal primitive, and also explain the large number of new proposals. Schemes in this category are often referred to as <em>Arithmetization-Oriented</em> (AO).</p>

    <p class="text-gray-300">Security of AO hash functions. A series of recent works have focused on designing AO permutations  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  (where  <span class="math">\\mathbb{F}_q</span>  is a finite field), which are turned into hash functions via the sponge construction [6]. Examples of this trend include Poseidon [17,18], Rescue [1], Griffin [16], Arion [22], Anemoi [8] and XHash8/12 [2]. The security of these constructions against algebraic attacks is measured with the <em>Constrained-Input Constrained-Output</em> (CICO) problem, which is the typical setting for studying the security of hash functions in sponge mode [6]. We focus on the following variant, which has received the most attention in the literature.</p>

    <p class="text-gray-300"><span id="page-1-0"></span><strong>Definition 1 (The CICO-1 Problem).</strong> Let <span class="math-block">t \\geq 2</span>  and  <span class="math">F : \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span>  be a permutation. The goal is to find  <span class="math">\\mathbf{x} \\in \\{0\\} \\times \\mathbb{F}_q^{t-1}</span>  such that  <span class="math">F(\\mathbf{x}) \\in \\{0\\} \\times \\mathbb{F}_q^{t-1}</span> .</p>

    <p class="text-gray-300">We remark that most of the AO permutations laves the specific choice of matrix unspecified. In these case the exact choice of entry set to 0 does not matter, as this only changes the outer linear layer by a permutation.</p>

    <p class="text-gray-300">The CICO-1 problem can be solved generically in approximately q permutation calls, and many AO permutation designs claim to be resistant to CICO-1 attacks up to q equivalent permutation computations. In the case of Poseidon, which is composed of r rounds having a small degree d, one can symbolically evaluate the permutation F in the single indeterminate x. Solving the CICO problem in this case boils down to finding the root of a univariate polynomial in degree at most  <span class="math">d^r</span> , which should be considerably smaller than q for the attack to succeed.</p>

    <p class="text-gray-300">However, in the cases of Rescue, Griffin, Arion and Anemoi, the round function contains high-degree components of the form  <span class="math">y \\mapsto y^{1/\\alpha}</span>  for some small integer  <span class="math">\\alpha &gt; 1</span> . These so-called  <span class="math">\\alpha</span> -inversions are of very high degree and make</p>

    <p class="text-gray-300">the straightforward symbolic evaluation of F infeasible. Instead, one typically adopts a multivariate polynomial modeling by introducing a new variable for each α-inversion and applies a two-stage approach to find a low-degree univariate polynomial representing the CICO solutions. First, a grevlex Gr¨obner basis of the polynomial ideal is computed, typically using F4/F<sup>5</sup> <a href="#page-31-4">\\[13,</a>[15\\]](#page-31-5), and second, it is converted into a lex Gr¨obner basis which contains a univariate polynomial, typically using FGLM [\\[14\\]](#page-31-6). This approach is currently the most efficient technique to solve generic multivariate systems. However, systems arising from the modeling of the CICO problem on AO permutations are all but generic, and two recent works exploited their structure to reduce further the complexity of the CICO attack on different primitives: the FreeLunch attack [\\[3\\]](#page-30-4) and the Resultant attack [\\[26\\]](#page-31-7).</p>

    <p class="text-gray-300">FreeLunches and Resultants. The FreeLunch attack of [\\[3\\]](#page-30-4) derives custommade monomial orders for which the given multivariate polynomial system is already a Gr¨obner basis G, which allows for side-stepping the first step mentioned above. The bottleneck of the attack lies in computing a univariate polynomial in the ideal generated by G; it can be performed by generating the multiplication matrix with respect to one variable and then computing its characteristic polynomial, without computing a second Gr¨obner basis as in the lex order. The Resultant attack of [\\[26\\]](#page-31-7) is an altogether different approach that eliminates variables from the multivariate system by the successive computation of resultants. Following this strategy produces a univariate polynomial in the ideal generated by the polynomial system. Let us note that this is not the first occurrence of resultants in the context of the cryptanalysis of AO primitives, as [\\[7\\]](#page-30-5) also computes a univariate polynomial as the resultant of two high-degree bivariate polynomials. That said, our approach is much closer to [\\[26\\]](#page-31-7), which we will focus on in the following.</p>

    <p class="text-gray-300">Both the attacks of [\\[3\\]](#page-30-4) and [\\[26\\]](#page-31-7) have proved effective in their own right, with each breaking several instances of AO hash functions previously thought to be secure. However, at the current state of the art, it is unclear if (and how) the two approaches compare on these primitives or even relate to each other from a more theoretical perspective. Indeed, the two papers consider to some extent different targets, with [\\[3\\]](#page-30-4) focusing on Griffin, Arion, Anemoi and XHash8, while [\\[26\\]](#page-31-7) focuses on Rescue, Jarvis and Anemoi. In the case of Anemoi, practical experiments on scaled-down versions show the Resultant method to be more efficient than its FreeLunch counterpart, but the eventual complexity estimates of both attacks are comparable.<a href="#page-2-0">5</a></p>

    <p class="text-gray-300">Our Contributions. In this paper, we improve upon the resultant method by introducing a new efficient polynomial reduction method that exploits fast multivariate multiplication. We strive to keep our approach general, so it is readily applicable to as many AO hash functions as possible.</p>

    <p class="text-gray-300"><span id="page-2-0"></span><sup>5</sup> <a href="#page-31-7">\\[26,</a> Table 6] use ω = 2.376 while <a href="#page-30-4">\\[3,</a> Table 1] use ω = 2.81. Comparing both theoretical estimates with the same ω gives similar attack complexities.</p>

    <p class="text-gray-300">We complement our new method with a thorough complexity analysis, borrowing some tools from the FreeLunch attack. We show that our attack considerably lowers the complexity of solving the CICO problem for primitives like Griffin, Arion, Rescue, and Anemoi. We also experimentally run the attack and solve the CICO problem for 8 rounds of Griffin, 11 rounds of Anemoi, and 6 rounds of Rescue, improving upon the literature by respectively 1, 3, and 1 rounds.</p>

    <p class="text-gray-300">Outline. Section 2 introduces the necessary background on Gröbner bases and resultants, and briefly describes [3,26]. Section 3 presents our attack at a high level and analyzes the efficient reduction method. Using this first analysis, Section 4 provides complexity estimates for the different attack steps. Finally, Section 5 applies these estimates on selected permutations and reports on the practical experiments.</p>

    <p class="text-gray-300"><strong>Notation.</strong> Let  <span class="math">q = p^e</span>  for p prime and  <span class="math">e \\in \\mathbb{N}_{&gt;0}</span> , where p is either odd and greater than  <span class="math">2^{\\lambda}</span>  with e = 1, or p = 2 and  <span class="math">e \\geq \\lambda</span> . Let  <span class="math">\\mathbb{F}_q</span>  denote the finite field with q elements.</p>

    <p class="text-gray-300">We consider a multivariate polynomial ring of the form  <span class="math">R = \\mathbb{F}_q[x, z_1, \\dots, z_n]</span> . We will also use the notation  <span class="math">R_i</span>  for the subring  <span class="math">\\mathbb{F}_q[x, z_1, \\dots, z_i]</span>  for  <span class="math">0 \\le i \\le n</span> . For  <span class="math">h \\in R</span> , we denote by  <span class="math">\\deg_x(h)</span>  (resp.  <span class="math">\\deg_{z_i}(h)</span> ) the partial degree of h with respect to x (resp.  <span class="math">z_i</span> ). Any set of polynomials  <span class="math">\\mathcal{P} = \\{h_1, \\dots, h_m\\} \\subset R</span>  is implicitly associated to the system  <span class="math">\\{h_1 = 0, \\dots, h_m = 0\\}</span> , and we write  <span class="math">I = \\langle \\mathcal{P} \\rangle</span>  for the ideal generated by  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300">The complexities of our algorithms will be given in terms of  <span class="math">\\mathbb{F}_q</span> -operations and will be expressed using either the big-O notation  <span class="math">\\mathcal{O}(\\cdot)</span>  or the soft-O notation  <span class="math">\\widetilde{\\mathcal{O}}(\\cdot)</span>  where logarithmic factors are omitted.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.1 Preliminary Theory</h4>

    <p class="text-gray-300">Gröbner bases, normal forms and weighted orders. We refer to [12] for details on the theory of Gröbner bases and we only introduce the notation needed to present our algorithms. We write  <span class="math">\\prec</span>  for a monomial order,  <span class="math">\\prec_{lex}</span>  for a lexicographical monomial order, and LT(h), LM(h) and LC(h) respectively for the leading term, leading monomial and leading coefficient of h once such an order is fixed. We extend this notation to an arbitrary subset  <span class="math">\\mathcal{P}</span>  of R endowed with  <span class="math">\\prec</span> , for example  <span class="math">LM(\\mathcal{P}) = \\{LM(h_1), LM(h_2), \\dots\\}</span> .</p>

    <p class="text-gray-300"><strong>Definition 2 (Gröbner basis).</strong> A Gröbner basis of an ideal I with respect to a monomial order is any finite set  <span class="math">\\mathcal{G}</span>  such that  <span class="math">\\langle \\mathcal{G} \\rangle = I</span>  and  <span class="math">\\langle \\text{LM}(\\mathcal{G}) \\rangle = \\text{LM}(I)</span> .</p>

    <p class="text-gray-300"><span id="page-3-2"></span><strong>Definition 3 (Reduced Gröbner basis).</strong> The reduced Gröbner basis  <span class="math">\\mathcal{G}</span>  of an ideal I with respect to a monomial order is the unique  <span class="math">\\mathcal{G}</span>  such that i)  <span class="math">\\forall h \\in \\mathcal{G}</span> , LC(h) = 1; and ii)  <span class="math">\\forall h \\in \\mathcal{G}</span> , no monomial of h belongs to  <span class="math">\\langle LM(\\mathcal{G} \\setminus \\{h\\}) \\rangle</span> .</p>

    <p class="text-gray-300"><strong>Definition 4 (Normal form with respect to a Gröbner basis).</strong> Let  <span class="math">I \\subset R</span>  be an ideal, let  <span class="math">\\prec</span>  be a monomial order and let  <span class="math">\\mathcal{G}</span>  be a Gröbner basis of I with respect to  <span class="math">\\prec</span> . For any  <span class="math">f \\in R</span> , there exists a unique polynomial  <span class="math">\\rho \\in R</span>  such that  <span class="math">f - \\rho \\in I</span>  and such that either  <span class="math">\\rho = 0</span>  or no term of  <span class="math">\\rho</span>  is divisible by any element of  <span class="math">LM(\\mathcal{G})</span> . We will refer to this polynomial as the normal form of f with respect to  <span class="math">\\mathcal{G}</span>  or as the reduction of f modulo  <span class="math">\\mathcal{G}</span> .</p>

    <p class="text-gray-300">There exists a canonical basis for the vector space R/I whose elements are given by all the monomials in R that are not in  <span class="math">\\mathrm{LM}(I)</span> . The normal form of a polynomial  <span class="math">f \\in R</span>  can be seen as the decomposition of  <span class="math">\\overline{f} \\in R/I</span>  in this basis. Finally, an ideal I for which the basis R/I is finite is said to be zero-dimensional. In this case, its cardinality is called the ideal degree, denoted by  <span class="math">d_I</span> .</p>

    <p class="text-gray-300">In this paper, the complexity analysis will be conducted using degree estimates of polynomials with respect to a fixed weight vector, referred to as weighted degrees:</p>

    <p class="text-gray-300"><strong>Definition 5 (Weighted degree).</strong> Given a weight vector  <span class="math">\\mathbf{w} = (w_0, \\dots, w_n) \\in \\mathbb{R}^{n+1}_{\\geq 0}</span> , the weighted degree of a monomial  <span class="math">\\mu = x^{\\beta_0} \\prod_{i=1}^n z_i^{\\beta_i} \\in R</span>  is defined as:</p>

    <div class="my-4 text-center"><span class="math-block">d_{\\mathbf{w}}\\left(x^{\\beta_0}\\prod_{i=1}^n z_i^{\\beta_i}\\right) = \\sum_{i=0}^n w_i \\beta_i.</span></div>

    <p class="text-gray-300">From a weight vector  <span class="math">\\boldsymbol{w} \\in \\mathbb{R}^{n+1}_{\\geq 0}</span>  and a lexicographical order  <span class="math">\\prec_{lex}</span>  on R, one can define a particular weight order that we will call the <em>wdeglex</em> monomial order.</p>

    <p class="text-gray-300"><span id="page-4-1"></span><strong>Definition 6 (wdeglex monomial order).</strong> The weighted graded lexicographical (wdeglex) monomial order  <span class="math">\\prec</span>  with respect to the weight vector  <span class="math">\\mathbf{w} \\in \\mathbb{R}^{n+1}_{\\geq 0}</span>  and the lexicographical order  <span class="math">\\prec_{lex}</span>  on R is the monomial order defined as follows. For monomials  <span class="math">\\mu</span>  and  <span class="math">\\mu&#x27;</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mu \\prec \\mu&#x27; \\qquad \\textit{iff} \\qquad \\begin{cases} d_{\\boldsymbol{w}}(\\mu) &lt; d_{\\boldsymbol{w}}(\\mu&#x27;) &amp; \\textit{or} \\\\ d_{\\boldsymbol{w}}(\\mu) = d_{\\boldsymbol{w}}(\\mu&#x27;) &amp; \\textit{and} \\quad \\mu \\prec_{lex} \\mu&#x27;. \\end{cases}</span></div>

    <p class="text-gray-300">Given a fixed weight vector  <span class="math">\\boldsymbol{w}</span> , the weighted degree  <span class="math">d_{\\boldsymbol{w}}(f)</span>  of f can be defined as the maximal weighted degree of the monomials in f. By definition of the above order  <span class="math">\\prec</span> , we have  <span class="math">d_{\\boldsymbol{w}}(f) = d_{\\boldsymbol{w}}(\\mathrm{LM}_{\\prec}(f))</span> .</p>

    <p class="text-gray-300"><strong>Resultants.</strong> The resultant of two univariate polynomials in X over a commutative ring R is an element of R defined as the determinant of the so-called Sylvester matrix. Resultants are a powerful tool to eliminate variables in a multivariate polynomial ring (in this case, R is itself a polynomial ring).</p>

    <p class="text-gray-300"><strong>Definition 7 (Resultant of two polynomials).</strong> Let R be a commutative ring, and let f, g be two non-constant polynomials in R[X]:</p>

    <p class="text-gray-300"><span id="page-4-0"></span> <span class="math-block">f = \\sum_{i=0}^{\\gamma} a_i X^i, \\ a_i \\in R, \\ a_{\\gamma} \\neq 0, \\qquad g = \\sum_{i=0}^{\\delta} b_i X^i, \\ b_i \\in R, \\ b_{\\delta} \\neq 0.</span></p>

    <p class="text-gray-300">The Sylvester matrix associated to f and g in  <span class="math">R^{(\\gamma+\\delta)\\times(\\gamma+\\delta)}</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">Syl(f,g) = \\begin{bmatrix} a_{\\gamma} &amp; \\cdots &amp; a_{1} &amp; a_{0} &amp; 0 \\\\ &amp; \\ddots &amp; &amp; \\ddots &amp; \\ddots \\\\ 0 &amp; a_{\\gamma} &amp; \\cdots &amp; a_{1} &amp; a_{0} \\\\ b_{\\delta} &amp; b_{\\delta-1} &amp; \\cdots &amp; b_{0} &amp; 0 \\\\ &amp; \\ddots &amp; \\ddots &amp; &amp; \\ddots \\\\ 0 &amp; b_{\\delta} &amp; b_{\\delta-1} &amp; \\cdots &amp; b_{0} \\end{bmatrix} \\right\\} \\gamma</span></div>

    <p class="text-gray-300">The resultant of f and g with respect to X is defined as</p>

    <p class="text-gray-300"><span id="page-5-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$Res(f,g) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Syl(f,g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in R.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When R[X] is a multivariate polynomial ring and when the choice of the variable X is ambiguous, we denote the resultant of two multivariate polynomials f and g with respect to X as  <span class="math">Res_X(f,g)</span> .</p>

    <p class="text-gray-300">It is readily seen that  <span class="math">\\mathrm{Res}_X(f,g) \\in R \\cap \\langle f,g \\rangle</span> , and therefore it vanishes at any potential common roots of f and g.</p>

    <p class="text-gray-300">In addition to the determinant-based definition of the resultant, we will use a specific case of the following result.</p>

    <p class="text-gray-300"><strong>Proposition 1.</strong> Let R be an integral domain and let  <span class="math">f, g \\in R[X]</span>  as in Definition 7. Assume their roots (in some extension field) are  <span class="math">\\zeta_1, \\ldots, \\zeta_{\\gamma}</span>  and  <span class="math">\\eta_1, \\ldots, \\eta_{\\delta}</span>  respectively. Then their resultant is given by:</p>

    <div class="my-4 text-center"><span class="math-block">Res(f,g) = a_{\\gamma}^{\\delta} b_{\\delta}^{\\gamma} \\prod_{i=1}^{\\gamma} \\prod_{j=1}^{\\delta} (\\zeta_i - \\eta_j)$$ $$= a_{\\gamma}^{\\delta} \\prod_{i=1}^{\\gamma} g(\\zeta_i) = (-1)^{\\gamma \\delta} b_{\\delta}^{\\gamma} \\prod_{j=1}^{\\delta} f(\\eta_j).</span></div>

    <p class="text-gray-300"><em>Proof.</em> We refer for example to [11, Chapter 3, (1.4), page 79], which applies to univariate polynomials over any field. We apply this result in the particular case when the field is the fraction field of the integral domain R, recalling that in our context R will be a multivariate polynomial ring.</p>

    <p class="text-gray-300">Fast multivariate polynomial multiplication. An important building block to derive the complexities of the methods in this paper is the cost of multiplying two multivariate polynomials. We start by denoting the complexity of multiplying two univariate polynomials of degree  <span class="math">\\leq d</span>  over  <span class="math">\\mathbb{F}_q</span>  as  <span class="math">\\mathcal{M}(d)</span>  operations in  <span class="math">\\mathbb{F}_q</span> . The most efficient univariate multiplication algorithm is an FFT-based technique with quasi-linear complexity [9],</p>

    <p class="text-gray-300"><span id="page-5-1"></span> <span class="math-block">\\mathcal{M}(d) = \\mathcal{O}(d\\log(d)\\log(\\log(d))). \\tag{1}</span></p>

    <p class="text-gray-300">We will rely on this univariate algorithm to also compute the product of multivariate polynomials using the Kronecker trick presented in [21, §3.4]. In this way, the product of two polynomials in  <span class="math">\\mathbb{F}_q[x_1,\\ldots,x_n]</span>  with degree  <span class="math">\\alpha_i</span>  and  <span class="math">\\beta_i</span>  respectively in the variable  <span class="math">x_i</span>  takes</p>

    <p class="text-gray-300"><span id="page-6-1"></span> <span class="math-block">\\mathcal{M}\\left(\\prod_{i=1}^{n} (\\alpha_i + \\beta_i + 1)\\right) \\tag{2}</span></p>

    <p class="text-gray-300">operations in  <span class="math">\\mathbb{F}_q</span> . This product has degree  <span class="math">\\alpha_i + \\beta_i</span>  in the variable  <span class="math">x_i</span>  and typically has  <span class="math">\\prod_{i=1}^n (\\alpha_i + \\beta_i + 1)</span>  nonzero coefficients.</p>

    <p class="text-gray-300">Univariate root finding. The roots of a univariate polynomial of degree d in  <span class="math">\\mathbb{F}_q</span>  can be computed by applying the efficient FFT-based technique of [4]. Assuming that  <span class="math">\\mathcal{M}(d) = \\mathcal{O}(d \\log(d) \\log(\\log(d)))</span>  and that this polynomial has a few roots in  <span class="math">\\mathbb{F}_q</span> , finding the roots of this polynomial requires</p>

    <p class="text-gray-300"><span id="page-6-3"></span> <span class="math-block">\\mathcal{O}(d\\log(d)(\\log(d) + \\log(q))\\log(\\log(d))) \\tag{3}</span></p>

    <p class="text-gray-300">operations in  <span class="math">\\mathbb{F}_q</span> .</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">2.2 The FreeLunch Approach</h4>

    <p class="text-gray-300">The approach of [3] relies on the existence of specific monomial orders for certain AO permutations in which the initial modeling is already a Gröbner basis. In these cases, the initial step of modeling the polynomial system (and, indeed, Gröbner basis) is referred to as <strong>sysGen</strong>. Even though such a Gröbner basis is <em>conceptually</em> easy to obtain, its elements can still contain variables of high degree, making them difficult to compute in practice.</p>

    <p class="text-gray-300">Instead of applying the FGLM algorithm to derive a second Gröbner basis from the output of the sysGen step, [3] suggests a more tailored approach. As such, the next two steps of the FreeLunch method involve constructing a multiplication matrix (matGen) and computing its characteristic polynomial (polyDet). Indeed, the structure of the first Gröbner basis makes this operation more efficient than generic algorithms that can be applied to it.<sup>6</sup> The final step, uniSol, is to find the roots of this polynomial, as described in Section 2.1.</p>

    <p class="text-gray-300">This last uniSol step is typically negligible compared to the rest of the attack. However, it is unclear which of the other steps is the most costly. In [3, Appendix A], it is argued that sysGen is easier to perform than polyDet, but this claim is based solely on heuristics. The comparison between matGen and polyDet appears to be just as difficult. While the <em>generic</em> upper bound for matGen [14, Proposition 3.1] is greater than the complexity estimate for polyDet, [3] remarks that this is likely a loose upper bound that can be further improved by taking into account the underlying structure. Experiments do not provide more insight for this comparison, as there are examples where both matGen and polyDet become the bottleneck [3, Section 6.1].</p>

    <p class="text-gray-300"><span id="page-6-0"></span><sup>&</sup>lt;sup>6</sup> Faster algorithms exist [5], but they cannot be applied directly in our setting as a stability requirement is not necessarily met.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 The Resultant Approach</h3>

    <p class="text-gray-300">The idea of [\\[26\\]](#page-31-7) is to compute iterated resultants starting from the initial modeling, which allows eliminating variables and eventually producing a univariate polynomial. The authors consider two modelings: the direct modeling referred to as "forward", and the "start-from-the-middle" (SFTM) modeling. In both cases, new variables are introduced each round at each output of inverse power map S-boxes, which suggests a suitable elimination path. The construction of these modelings is analogous to the sysGen step of [\\[3\\]](#page-30-4). Still, [\\[26\\]](#page-31-7) does not estimate its cost and assumes it to be negligible compared to the cost of subsequent steps.</p>

    <p class="text-gray-300">Once the system has been generated, iterated resultants are computed efficiently by exploiting the structure of the Sylvester matrices involved. After each resultant computation, a so-called "cubic substitution procedure" is applied to decrease the degree of the remaining variables in the resultant. This substitution can be seen as a reduction by some of the polynomials of the initial modeling whose leading monomials are of the form z 3 i (for a particular monomial ordering). We will only be interested in the direct modeling, where this approach yields a univariate polynomial. When applied to the STFM modeling, the same approach yields two bivariate polynomials, and the final bivariate resultant is computed differently by a generic algorithm based on Fast Lagrange interpolation [\\[10\\]](#page-31-12). Finally, [\\[26\\]](#page-31-7) uses a standard uniSol step to extract the roots of the univariate polynomial.</p>

    <p class="text-gray-300">The computational bottleneck for this approach seems to depend on the choice of modeling. In the SFTM modeling, the final bivariate resultant computation is estimated as the bottleneck (see <a href="#page-31-7">\\[26,</a> Figure 7 and 12, Table 4]), whereas cubic substitutions seem to be the bottleneck in the forward modeling (see <a href="#page-31-7">\\[26,</a> Table 2]).</p>

    <p class="text-gray-300">At a very high level, our work improves upon the Resultant attack, borrowing theoretical tools from the FreeLunch approach. In this section, we give an overview of our improved resultant attack and highlight the key differences between our attack and the resultant attack of [\\[26\\]](#page-31-7). We leave the complexity analysis for Section <a href="#page-14-0">4.</a> This analysis allows us to precisely bound the complexity of all steps, which was not the case in <a href="#page-30-4">\\[3</a>[,26\\]](#page-31-7).</p>

    <p class="text-gray-300">In most of this paper, we will consider the case where the unknown input x of the CICO-1 problem has only one single degree of freedom (as opposed to t−1), for instance, x ∈ {0} <sup>t</sup>−<sup>1</sup>×Fq, which allows us to model the CICO solutions with a well-defined polynomial system, which has on average 1 CICO solution (as opposed to q t−2 ). In concrete attacks, we usually use round-bypassing techniques, as performed in <a href="#page-30-6">\\[4,</a><a href="#page-30-4">3,</a>[26\\]](#page-31-7), and manage to reduce the CICO-1 problem on a fullround permutation into a CICO-like problem on a round-reduced variant where the input has only one degree of freedom. The idea is to let the entries of x consist of univariate polynomials in F[x] that are carefully chosen so that the growth of the degree in x induced by the first non-linear operations is limited, thus effectively bypassing a small number of initial rounds. For simplicity, we omit round-bypassing techniques in the presentation of our attack but will apply them on concrete permutations in Section 5. We highlight that we only rely on existing round-bypassing techniques and do not improve upon the state of the art in that regard.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Modeling Strategy</h3>

    <p class="text-gray-300"><strong>Scope of application.</strong> Recall that the value of q is assumed to be sufficiently large so that the CICO-1 problem of Definition 1 is not trivially broken by a brute-force attack, i.e.,  <span class="math">q \\geq 2^{\\lambda}</span> , where  <span class="math">\\lambda</span>  is the security parameter. In the following, we will focus on a permutation  <span class="math">F: \\mathbb{F}_q^t \\to \\mathbb{F}_q^t</span> ,  <span class="math">t \\geq 2</span>  that satisfies the following two conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It is built from affine layers denoted  <span class="math">A_i</span>  and a non-linear layer denoted S, both operating on  <span class="math">\\mathbb{F}_q^t</span> . These building blocks appear in an alternating pattern, starting and ending with the affine layer (if needed, one can set  <span class="math">A_0 = Id</span> ). In other words, the entire permutation can be described as:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F = A_r \\circ S \\circ \\ldots \\circ A_1 \\circ S \\circ A_0</span></div>

    <p class="text-gray-300">where the number of calls to S is referred to as the number of rounds, denoted by r.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The only high-degree components in S are power maps  <span class="math">y\\mapsto y^{1/\\alpha}</span> , denoted as  <span class="math">\\alpha</span> -inversions, where  <span class="math">\\alpha</span>  is coprime to q-1 and small (typically  <span class="math">\\alpha=3</span>  or 5). We write  <span class="math">\\ell</span>  for the number of such  <span class="math">\\alpha</span> -inversions in S. As an example,  <span class="math">\\ell=1</span>  for Anemoi, Arion and Griffin, while  <span class="math">\\ell=t</span>  for Rescue-Prime.</li>

    </ol>

    <p class="text-gray-300">We remark that many ZK-friendly AO permutations fall into this category, including Rescue-Prime, Arion, Griffin, and Anemoi. The XHash construction also belongs to this framework, but the authors only claimed CICO resistance with multiple constraints in output.</p>

    <p class="text-gray-300">Modeling the CICO Problem. As announced above, we let the input state to F consist of polynomials in an unknown variable x, except for one element that is set to 0. We can then compute the evolution of this polynomial state through F by successively applying  <span class="math">A_i</span>  and S on the state elements, interpreted as polynomials in  <span class="math">\\mathbb{F}_q[x]</span>  rather than field elements. The degree of the polynomials in the internal state clearly increases after every application of S. When  <span class="math">\\ell=0</span> , which is the case for example in Poseidon and Poseidon2, S is of low degree and this increase is simply exponential in the number of rounds. However, when  <span class="math">\\ell \\geq 1</span> , the  <span class="math">\\alpha</span> -inversion is of very high degree (of the same order of magnitude as q), so applying S directly to the polynomial state is in general not feasible.</p>

    <p class="text-gray-300">Similarly to [3,26], we therefore introduce new variables  <span class="math">z_i</span>  for  <span class="math">1 \\le i \\le n</span>  as the output of each  <span class="math">\\alpha</span> -inversion. Since we introduce these variables one after</p>

    <p class="text-gray-300">the other, we are ensured that the input of the  <span class="math">\\alpha</span> -inversion whose output is  <span class="math">z_i</span>  is a low-degree polynomial in  <span class="math">x, z_1, \\ldots, z_{i-1}</span>  (independent of  <span class="math">z_i, \\ldots, z_n</span> ), which we call  <span class="math">f_i(x, z_1, \\ldots, z_{i-1})</span> . For each such new variable  <span class="math">z_i</span> , we add the equation  <span class="math">z_i^{\\alpha} - f_i(x, z_1, \\ldots, z_{i-1}) = 0</span>  to our polynomial system. In the current setting, we need  <span class="math">n = \\ell r</span>  new variables  <span class="math">z_i</span> . This number may be decreased thanks to round-bypassing techniques that set the input of some  <span class="math">\\alpha</span> -inversions to polynomials of the form  <span class="math">f(x)^{\\alpha}</span>  (possibly constant), so that there is no need to add an extra variable for the output. We call them bypassed  <span class="math">\\alpha</span> -inversions.</p>

    <p class="text-gray-300">One key improvement of our modeling compared to the modelings of [3,26] is that we <em>efficiently</em> reduce state polynomials after each multiplication in S, ensuring that their degree in each  <span class="math">z_i</span>  never exceeds  <span class="math">\\alpha - 1</span> . While [3,26] have suggested computing normal forms for the same purpose, they do so naïvely, without analyzing or optimizing the reduction.</p>

    <p class="text-gray-300">Using this modeling strategy, the output of F consists of polynomials in  <span class="math">\\mathbb{F}_q[x,z_1,\\ldots,z_n]</span> , and we set the first polynomial of the output state equal to 0 to get a CICO solution. We denote this polynomial by  <span class="math">h(x,z_1,\\ldots,z_n)</span>  and add the equation  <span class="math">h(x,z_1,\\ldots,z_n)=0</span>  to our polynomial system. Thus, we obtain the following system modeling the CICO problem for F:</p>

    <p class="text-gray-300"><span id="page-9-0"></span> <span class="math-block">\\mathcal{P} = \\begin{cases} z_1^{\\alpha} - f_1(x) &amp;= 0\\\\ z_2^{\\alpha} - f_2(x, z_1) &amp;= 0\\\\ &amp;\\vdots\\\\ z_n^{\\alpha} - f_n(x, z_1, \\dots, z_{n-1}) &amp;= 0\\\\ h(x, z_1, \\dots, z_n) &amp;= 0. \\end{cases}</span> (4)</p>

    <p class="text-gray-300">This modeling coincides with the forward modeling of [26]. We also recover the modelings of [3], except for the modeling of Anemoi, in which the authors artificially increase the degree of h to get directly a Gröbner basis.</p>

    <p class="text-gray-300"><strong>FreeLunch systems.</strong> The main feature of the modelings of [3] is that they yield Gröbner bases where the leading monomial of  <span class="math">z_i^{\\alpha} - f_i</span>  is  <span class="math">z_i^{\\alpha}</span>  for  <span class="math">1 \\leq i \\leq n</span> , and the leading monomial of  <span class="math">h(x, z_1, \\ldots, z_n)</span>  is univariate in x. To obtain these Gröbner bases, the authors of [3] consider a particular wdeglex monomial order (Definition 6), introduced in [3, Construction 1] with different notations.</p>

    <p class="text-gray-300"><span id="page-9-1"></span><strong>Construction 1.</strong> For a system  <span class="math">\\mathcal{P}</span>  following the structure of System (4), let  <span class="math">\\prec_{\\mathcal{P}}</span>  be the wdeglex monomial order associated with the order  <span class="math">x \\prec_{lex} z_1 \\prec_{lex} \\cdots \\prec_{lex} z_n</span>  and the weight vector  <span class="math">\\mathbf{w} = (w_0, \\ldots, w_n) \\in \\mathbb{R}^{n+1}_{\\geq 0}</span>  defined recursively by:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{cases} w_0 = 1, \\\\ w_i = d_{(w_0,\\dots,w_{i-1})}(f_i)/\\alpha \\text{ for } 1 \\leq i \\leq n. \\end{cases}</span></div>

    <p class="text-gray-300">All the Gröbner bases studied in [3] correspond to systems  <span class="math">\\mathcal{P}</span>  that are  <span class="math">\\prec_{\\mathcal{P}}</span> -Gröbner bases. We refer to them as FreeLunch, following [3, Proposition 5].</p>

    <p class="text-gray-300"><span id="page-9-2"></span><strong>Definition 8 (FreeLunch Gröbner basis).</strong> A system  <span class="math">\\mathcal{P}</span>  as in (4) is a FreeLunch Gröbner basis if it is a  <span class="math">\\prec_{\\mathcal{P}}</span> -Gröbner basis.</p>

    <p class="text-gray-300">Using the wdeglex order as an analysis tool. Contrary to [3], our work applies to modelings that are not necessarily Gröbner bases with respect to the order defined in Construction 1, i.e., the leading monomial of h is not necessarily univariate in x. Still, we heavily rely on this order in our analysis.</p>

    <p class="text-gray-300">Indeed, note that the complexity of multivariate multiplication depends on the partial degrees in all variables (see Equation (2)). While the degree in  <span class="math">z_i</span>  remains low due to reductions by  <span class="math">z_i^{\\alpha} - f_i</span>  polynomials, these reductions increase the degree in x. Controlling this x-degree seems challenging. For instance, standard degree arguments based on partial or total degrees fail to upper-bound it. However, we observe that the weighted degree used in Construction 1 may only decrease after these reductions since  <span class="math">d_{\\boldsymbol{w}}(z_i^{\\alpha}) \\geq d_{\\boldsymbol{w}}(f_i)</span> . Therefore, we use this quantity to rigorously upper-bound the x-degree of polynomials at all points of the attack.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><strong>Definition 9 (Extra notation).</strong> For a system  <span class="math">\\mathcal{P} = \\{z_1^{\\alpha} - f_1, \\dots, z_n^{\\alpha} - f_n, h\\}</span>  as in (4) and a polynomial  <span class="math">f \\in R</span> , we denote the weighted degree defined in Construction 1 as  <span class="math">d_{\\mathcal{P}}(f)</span>  (instead of  <span class="math">d_{\\boldsymbol{w}}(f)</span> ). For  <span class="math">1 \\leq i \\leq n</span> , we denote by  <span class="math">\\mathcal{P}_i</span>  the subsystem  <span class="math">\\{z_1^{\\alpha} - f_1, \\dots, z_i^{\\alpha} - f_i\\}</span>  viewed in  <span class="math">R_i</span> . Using Construction 1, we similarly consider  <span class="math">\\prec_{\\mathcal{P}_i}</span>  and its associated weighted degree  <span class="math">d_{\\mathcal{P}_i}(f)</span>  on  <span class="math">R_i</span> . In the following, we will allow ourselves to use  <span class="math">\\prec_{\\mathcal{P}}</span>  and  <span class="math">d_{\\mathcal{P}}(f)</span>  for these last two notations to compare polynomials in  <span class="math">R_i</span> , even when the system  <span class="math">\\mathcal{P}</span>  is not fully generated.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.2 Attack Description</h3>

    <p class="text-gray-300">Adopting the taxonomy of Sections 2.2 and 2.3, we can – at a high level – divide our framework into three steps: sysGen, iteRes and uniSol. The uniSol step is performed using generic methods, as described in Section 2.1. In this section, we point out how the other steps differ from that of [3,26].</p>

    <p class="text-gray-300">sysGen. This step generates round by round a system of the form (4) where the  <span class="math">f_i</span> 's are reduced, i.e., where  <span class="math">\\deg_{z_j}(f_i) &lt; \\alpha</span>  for j < i. For that purpose, we decompose the non-linear layer S into a sequence of multiplications, and apply this sequence of multiplications to multivariate polynomials. As in [3,26], we also immediately reduce the result of each multiplication to maintain reduced outputs. However, we do it efficiently with a dedicated algorithm (Algorithm 1) that offers clear improvements over naive normal form computation. In particular, we can estimate its complexity which introduces only a logarithmic overhead compared to the complexity of multivariate multiplication. This leads to an accurate complexity estimate for the entire sysGen step, which was missing in [3,26].</p>

    <p class="text-gray-300">iteRes. This step computes a series of resultants starting from the output of sysGen to produce a univariate polynomial. Similarly to the modelings of [26], this output is of the form (4), allowing us to follow the same elimination path as in their work. However, we take advantage of our efficient reduction procedure (Algorithm 1) to improve the computation of resultants of [26]. It seems that this also improves upon the approach of [20] from the computer algebra</p>

    <p class="text-gray-300">literature, which seems to perform similar computations, but with standard reductions. More precisely, instead of performing a cubic substitution after the computation of each resultant, we apply reductions within their computation. Indeed, each resultant can be computed as a series of multivariate additions and multiplications, and we can apply Algorithm <a href="#page-12-0">1</a> on the output of each multiplication similarly to sysGen. Ultimately, the iteRes step produces a univariate polynomial in x, whose roots are computed in the uniSol step.</p>

    <p class="text-gray-300">The precise complexity estimates for sysGen and iteRes can be found in Section <a href="#page-14-0">4.</a> Beyond improving upon <a href="#page-30-4">\\[3,</a>[26\\]](#page-31-7), the fact that both steps are based on Algorithm <a href="#page-12-0">1</a> enables a straightforward comparison to identify the dominant cost, which was again not possible in <a href="#page-30-4">\\[3,</a>[26\\]](#page-31-7).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.3 Improved Reduction Algorithm</h3>

    <p class="text-gray-300">This section describes and analyzes the reduction algorithm we use, presented in Algorithm <a href="#page-12-0">1.</a> This algorithm is a normal form computation (in the sense of Definition <a href="#page-3-2">4\\)</a> with respect to a lexicographical Gr¨obner basis extracted from a system as in <a href="#page-9-0">\\(4\\)</a>.</p>

    <p class="text-gray-300"><span id="page-11-0"></span>Proposition 2. For any 1 ≤ k ≤ n, let P<sup>k</sup> be the polynomial system composed of the first k equations of a system P as in <a href="#page-9-0">\\(4\\)</a>. Then P<sup>k</sup> is a Gr¨obner basis with respect to the lex ordering defined by x ≺lex z<sup>1</sup> ≺lex · · · ≺lex zk.</p>

    <p class="text-gray-300">Proof. The leading terms of its elements are pairwise coprime, hence the result by Buchberger's second criterion <a href="#page-31-8">\\[12,</a> Chapter 2, §9, Prop 4 and Thm 3].</p>

    <p class="text-gray-300">We will say that a polynomial g ∈ Fq[x, z1, . . . , zk] is reduced with respect to P if it is reduced with respect to P<sup>k</sup> and the lex order defined in Proposition <a href="#page-11-0">2,</a> i.e., if degz<sup>i</sup> (g) ≤ α − 1 for all 1 ≤ j ≤ k. We will also adopt the notation S<sup>k</sup> for the quotient ring Rk/⟨Pk⟩, which can be seen as our working ring. Note that contrary to [\\[3\\]](#page-30-4), we never consider the reduction by the polynomial h. Since P is not a Gr¨obner basis in general, we cannot directly define normal forms associated to P.</p>

    <p class="text-gray-300">Given g ∈ Fq[x, z1, . . . , zk] and Pk, Algorithm <a href="#page-12-0">1</a> efficiently computes the desired normal form of g with respect to Pk. This algorithm operates under two key conditions, namely that deg<sup>z</sup><sup>i</sup> (g) ≤ 2α − 2 for 1 ≤ i ≤ k and that the set P<sup>k</sup> is also reduced. The first condition is always met when g is the product of two reduced polynomials, and we always apply Algorithm <a href="#page-12-0">1</a> after running a multivariate multiplication in sysGen and iteRes. Algorithm <a href="#page-12-0">1</a> is a recursive procedure that heavily relies on the fact that the reduction of z<sup>i</sup> does not introduce variables z<sup>j</sup> for j ≥ i, so that we can reduce the z<sup>i</sup> sequentially for decreasing i.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">Algorithm 1 Reducek(g(x, z1, . . . , zk),Pk)</h3>

    <p class="text-gray-300">Input: A polynomial <sup>g</sup> <sup>∈</sup> <sup>F</sup>q[x, z1, . . . , zk], where deg<sup>z</sup><sup>i</sup> (g) < 2α − 1 for 1 ≤ i ≤ k, and a reduced polynomial system P<sup>k</sup> that shares the same first k polynomials with <a href="#page-9-0">\\(4\\)</a>.</p>

    <pre><code class="language-text">Output: The normal form of g with respect to Pk and x ≺lex z1 ≺lex · · · ≺lex zk.
1: if k = 0 then
2: return g
3: end if
4: write g as g =
                   2Xα−2
                    i=0
                        gi(x, z1, . . . , zk−1)z
                                           i
                                           k
5: ρ ← Reducek−1(gα−1, Pk−1) · z
                                   α−1
                                   k
6: for i = 0 to α − 2 do
7: ρ ← ρ + Reducek−1(gi + Reducek−1(gα+i, Pk−1) · fk, Pk−1) · z
                                                                      i
                                                                      k
                                                   ▷ 2α − 1 calls to Reducek−1 in total
8: end for</code></pre>

    <p class="text-gray-300">In our analysis, we bound the complexity of Algorithm <a href="#page-12-0">1</a> depending on k and on the maximum possible x-degree observed in this algorithm, denoted by dx.</p>

    <p class="text-gray-300">Proposition 3. Let C(k, dx) be the complexity of Algorithm <a href="#page-12-0">1</a> in Fq-operations, expressed as a function of k and d<sup>x</sup> the maximum possible x-degree of polynomials manipulated in this algorithm. We have</p>

    <p class="text-gray-300"><span id="page-12-2"></span> <span class="math-block">C(k, d_x) = \\widetilde{\\mathcal{O}}\\left(d_x(2\\alpha - 1)^k\\right).</span></p>

    <p class="text-gray-300">Proof. When k = 0, Algorithm <a href="#page-12-0">1</a> returns g and the complexity is approximately 0. Otherwise, when k ≥ 1, we perform 2α − 1 recursive calls to Reducek−<sup>1</sup> and α − 1 multivariate multiplications between Reducek−1(gα+<sup>i</sup> ,Pk) and fk. These polynomials only involve variables x, z1, . . . , zk−1, and their degrees in each z<sup>i</sup> are all bounded by α − 1. In addition, by definition of this quantity, the degree in x of the product is bounded by dx. Thus, using fast multivariate multiplication (Equation <a href="#page-6-1">\\(2\\)</a>), each multiplication costs M (d<sup>x</sup> + 1)(2α − 1)k−<sup>1</sup> field operations. This gives:</p>

    <div class="my-4 text-center"><span class="math-block">C(0, d_x) = 0</span></div>

    <p class="text-gray-300">9: return ρ</p>

    <p class="text-gray-300"><span class="math-block">C(k, d_x) = (2\\alpha - 1)C(k - 1, d_x) + (\\alpha - 1)\\mathcal{M}((d_x + 1)(2\\alpha - 1)^{k-1})</span>  for  <span class="math">k &gt; 0</span> .</p>

    <p class="text-gray-300">This complexity can be unfolded as follows, with <sup>M</sup>(d) = <sup>O</sup>e(d) and <sup>d</sup><sup>x</sup> <sup>≥</sup> 1:</p>

    <p class="text-gray-300"><span class="math-block">C(k, d_x) = \\sum_{i=1}^{k} (2\\alpha - 1)^{k-i} (\\alpha - 1) \\mathcal{M}((d_x + 1)(2\\alpha - 1)^{i-1})</span>  (5)</p>

    <p class="text-gray-300"><span id="page-12-3"></span><span id="page-12-1"></span> <span class="math-block">= \\widetilde{\\mathcal{O}}\\left(\\sum_{i=1}^{k} (2\\alpha - 1)^{k-1} (\\alpha - 1) d_x\\right)</span> (6)</p>

    <div class="my-4 text-center"><span class="math-block">= \\widetilde{\\mathcal{O}}\\left(kd_x(2\\alpha - 1)^k\\right)$$ $$= \\widetilde{\\mathcal{O}}\\left(d_x(2\\alpha - 1)^k\\right)</span></div>

    <p class="text-gray-300">Remark 1. Each depth k − j for 0 ≤ j ≤ k − 1 induces approximately the same cost in the final complexity of Algorithm <a href="#page-12-0">1,</a> as all terms in the sum in front of <a href="#page-12-1">\\(6\\)</a> are independent of i.</p>

    <p class="text-gray-300">As stated at the end of Section <a href="#page-8-0">3.1,</a> the value of d<sup>x</sup> is difficult to obtain in general and cannot be easily upper-bounded using standard tools. Therefore, Lemma <a href="#page-13-0">1</a> gives another complexity expression that depends on the weighted degree dP<sup>k</sup> (g) of the input polynomial, that indeed bounds d<sup>x</sup> and that will be much simpler to compute in our context.</p>

    <p class="text-gray-300"><span id="page-13-0"></span>Lemma 1. Let P<sup>k</sup> be as in Definition <a href="#page-10-0">9</a> where the polynomials are reduced, and let g ∈ R<sup>k</sup> such that degz<sup>i</sup> (g) ≤ 2α−2 for 1 ≤ i ≤ k. The complexity of reduction of g by P<sup>k</sup> with Algorithm <a href="#page-12-0">1</a> can be upper-bounded by:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}_k}(g)(2\\alpha-1)^k\\right).</span></div>

    <p class="text-gray-300">Proof. All polynomials manipulated by Reduce<sup>k</sup> are reductions of parts of the input polynomial g, therefore the weighted degree of these polynomials can only be less than d<sup>P</sup><sup>k</sup> (g). Since the x-degree is less than the weighted degree, we have d<sup>x</sup> ≤ d<sup>P</sup><sup>k</sup> (g) and conclude with Proposition <a href="#page-12-2">3.</a></p>

    <p class="text-gray-300">While reducing FreeLunch systems using Algorithm <a href="#page-12-0">1,</a> the leading terms of the polynomials involved are often univariate in x, so that d<sup>x</sup> = d<sup>P</sup><sup>k</sup> (g), and Lemma <a href="#page-13-0">1</a> gives a tight bound. This bound is also easier to apply than the one given by Proposition <a href="#page-12-2">3.</a></p>

    <p class="text-gray-300">Finally, Corollary <a href="#page-13-1">1</a> bounds the cost of multiplication in Sk, assuming that each element of S<sup>k</sup> is represented as its normal form with respect to P<sup>k</sup> and ≺<sup>P</sup><sup>k</sup> . As mentioned above, this cost is higher than that of multivariate multiplication in Fq[x, z1, . . . , zk] by only a logarithmic factor.</p>

    <p class="text-gray-300"><span id="page-13-1"></span>Corollary 1. Let g1, g<sup>2</sup> be two reduced polynomials in S<sup>k</sup> = Rk/⟨Pk⟩. The complexity of computing their product g1g<sup>2</sup> and reducing it using Algorithm <a href="#page-12-0">1</a> is given by:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d_x(2\\alpha-1)^k\\right) = \\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}_k}(g_1)d_{\\mathcal{P}_k}(g_2)(2\\alpha-1)^k\\right),</span></div>

    <p class="text-gray-300">where d<sup>x</sup> is the maximum possible x-degree of polynomials manipulated in Algorithm <a href="#page-12-0">1</a> applied to g1g2.</p>

    <p class="text-gray-300">Proof. Since d<sup>x</sup> is also a bound on the x-degree of g1g2, computing the mere product costs <sup>O</sup><sup>e</sup> dx(2α − 1)<sup>k</sup> by fast multivariate multiplication. Then, using Proposition <a href="#page-12-2">3,</a> the reduction has the same cost up to a logarithmic factor. One can finally upper-bound d<sup>x</sup> by d<sup>P</sup><sup>k</sup> (g1g2) = d<sup>P</sup><sup>k</sup> (g1)d<sup>P</sup><sup>k</sup> (g2).</p>

    <p class="text-gray-300">d</p>

    <p class="text-gray-300">We now estimate the complexity of sysGen and iteRes based on the cost of Algorithm 1. As with our estimate for the reduction algorithm, we first provide complexity bounds using x-degrees and then adapt them to give bounds depending on the weighted degree of the last polynomial  <span class="math">h \\in \\mathcal{P}</span> . In Section 5, we will see that this quantity is relatively straightforward to compute in practice, so that complexity estimates for our attack are easily derivable on concrete permutations.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Complexity Analysis of sysGen</h3>

    <p class="text-gray-300">Recall that sysGen corresponds to the modeling strategy outlined in Section 3.1 but where Algorithm 1 is applied after every multiplication of two polynomials when computing the round function. The same method was outlined in [3, Complexity of computing  <span class="math">P&#x27;_{\\mathcal{G}}</span> , p. 37], though without a detailed analysis, as the cost of the reductions was heuristically neglected compared to the other steps of the FreeLunch attack. To proceed with this analysis, let us rewrite sysGen more explicitly for an unspecified scheme that fits into our framework. This may be done in two steps: first, create an arithmetic circuit and then evaluate it with a given procedure. Recall that due to round-bypass techniques, some  <span class="math">\\alpha</span> -inversions do not require the introduction of new variables  <span class="math">z_i</span> , namely the bypassed  <span class="math">\\alpha</span> -inversions.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Arithmetic circuit generation</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Write the permutation as an arithmetic circuit over  <span class="math">\\mathbb{F}_q</span>  where the gates are linear operations, field multiplications and  <span class="math">\\alpha</span> -inversions. This circuit possesses t input wires and t output wires.</li>

      <li>2. Generalize these arithmetic gates to operations over the multivariate polynomial ring  <span class="math">\\mathbb{F}_q[x, z_1, \\ldots, z_n]</span> , where n is the number of non-bypassed  <span class="math">\\alpha</span> -inversions in the circuit. The wires now contain polynomials in  <span class="math">\\mathbb{F}_q[x, z_1, \\ldots, z_n]</span> .</li>

      <li>3. After each polynomial multiplication gate, add a gate representing a call to Algorithm 1 on the output, reducing it with the polynomial system  <span class="math">\\mathcal{P}_k</span> , where k is the current number of introduced variables.</li>

    </ul>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Evaluation of the circuit</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Set the first input wire to 0 and the other input wires to polynomials in x.</li>

      <li>2. Initialize an array  <span class="math">\\mathcal{P} = [\\ ]</span>  of length j = 0 at the start and proceed in the evaluation of the circuit in any coherent order.  <span class="math">\\mathcal{P}</span>  will eventually contain the  <span class="math">z_i^{\\alpha} f_i</span>  polynomials of the final system.</li>

      <li>3. When encountering a non-bypassed  <span class="math">\\alpha</span> -inversion, perform the following instructions:</li>

      <li>(a) Let f be the input of the  <span class="math">\\alpha</span> -inversion.</li>

      <li>(b) Increment j.</li>

      <li>(c) Append  <span class="math">z_j^{\\alpha} f</span>  to  <span class="math">\\mathcal{P}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(d) Assign the polynomial  <span class="math">z_j</span>  to the output wire of the  <span class="math">\\alpha</span> -inversion.</li>

      <li>4. The first output wire is returned along with  <span class="math">\\mathcal{P}</span> . They form a polynomial system as in (4) where  <span class="math">\\deg_{z_j}(f_i) &lt; \\alpha</span>  for  <span class="math">1 \\leq j &lt; i, \\ 1 \\leq i \\leq n, \\ \\deg_{z_j}(f_i) = 0</span>  for  <span class="math">j \\geq i</span> , and  <span class="math">\\deg_{z_j}(h) &lt; \\alpha, \\ 1 \\leq j \\leq n</span> .</li>

    </ul>

    <p class="text-gray-300">Throughout this procedure, the table  <span class="math">\\mathcal{P}</span>  always contains polynomials of the form  <span class="math">z_i^{\\alpha} - f_i</span>  where  <span class="math">f_i</span>  is reduced. We upper-bound the complexity of sysGen in the following proposition, using the bound previously found for Algorithm 1.</p>

    <p class="text-gray-300"><span id="page-15-0"></span><strong>Proposition 4.</strong> The complexity of sysGen in terms of  <span class="math">\\mathbb{F}_q</span> -operations is upperbounded by:</p>

    <p class="text-gray-300"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(Md_x(2\\alpha-1)^n\\right)</span> ,</p>

    <p class="text-gray-300">where M is the number of multiplications in the permutation, n the number of non-bypassed  <span class="math">\\alpha</span> -inversions, and  <span class="math">d_x</span>  the highest degree in x observed in the procedure.</p>

    <p class="text-gray-300"><em>Proof.</em> We apply M times the multiplication and reduction procedure analyzed in Corollary 1. The number of variables in such a procedure is always  <span class="math">\\leq n</span> , and the degree in x is by definition  <span class="math">\\leq d_x</span> . This yields the announced upper bound.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Remark 2. The bound of Proposition 4 is given in terms of field multiplications. However, it is common to compare the cost of an attack in terms of the number of permutation evaluations, each of them costing at least M field multiplications. Therefore, the cost of sysGen can be estimated to  <span class="math">\\widetilde{\\mathcal{O}}(d_x(2\\alpha-1)^n)</span>  permutation evaluations. In addition, for iterated-round constructions, the costliest operations of sysGen lie in the last permutation round, which accounts for a factor 1/r of the total number of multiplications.</p>

    <p class="text-gray-300">On some permutations, such as Rescue, computing the value  <span class="math">d_x</span>  in Proposition 4 is straightforward. However, we may want to generically bound  <span class="math">d_x</span>  for all permutations from the weighted degrees of the polynomial system to use the complexity bound of Proposition 4 more straightforwardly. However, it may happen that the x-degree of the polynomials processed in sysGen grows beyond the maximum weighted degree of the polynomials in the final polynomial system. This might happen if high-degree computations are performed in the cipher (and therefore in the original sysGen procedure), and their result is not needed for the generation of the final polynomial system. Based on an observation that the x-degree may only decrease with monomial cancellations (and not reductions), we slightly tweak the sysGen procedure to get the following bound on  <span class="math">d_x</span> .</p>

    <p class="text-gray-300"><strong>Proposition 5.</strong> The maximum x-degree observed throughout sysGen, denoted  <span class="math">d_x</span>  in Proposition 4, can be upper-bounded by:</p>

    <div class="my-4 text-center"><span class="math-block">d_x \\leq \\max(d_{\\mathcal{P}}(f_1), \\dots, d_{\\mathcal{P}}(f_n), d_{\\mathcal{P}}(h)),</span></div>

    <p class="text-gray-300">up to a little tweak in the procedure.</p>

    <p class="text-gray-300">Proof. Let d = max(d<sup>P</sup> (f1), . . . , d<sup>P</sup> (fn), d<sup>P</sup> (h)) where P is created by the original sysGen procedure. The only obstacle to this bound is the theoretical case where some polynomials computed in sysGen have x-degrees strictly more than d. To that end, we remark that all encountered monomials with x-degrees strictly more than d do not have any impact on the final polynomial system, and that they will eventually vanish by cancellation. Indeed, their x-degrees cannot be reduced in the reduction procedure, and no monomial with larger or equal xdegrees appear in the final polynomial system P (since degx(f) ≤ d<sup>P</sup> (f) for all f ∈ P). This implies that the resulting polynomial system P will be unchanged if all such monomials are discarded when encountered. Such a tweak does not change the output system P, and ensures that the highest x-degree encountered is at most d.</p>

    <p class="text-gray-300">In order to lighten the complexity analysis of this paper, we assume that the weighted degree of h is close to the maximum weighted degrees of the f<sup>i</sup> , up to a small constant c.</p>

    <p class="text-gray-300"><span id="page-16-0"></span>Assumption 1. We assume max(d<sup>P</sup> (f1), . . . , d<sup>P</sup> (fn), d<sup>P</sup> (h)) ≤ c · d<sup>P</sup> (h) for a small constant c.</p>

    <p class="text-gray-300">In practice, our analysis of Section <a href="#page-20-0">5</a> shows that for the CICO systems of Arion, Griffin and even-characteristic Anemoi, h is the highest weighted degree polynomial in P, so we can take c = 1. For odd-characteristic Anemoi, f<sup>n</sup> has the hightest weighted degree, but we show that we may take c = 2. The case of Rescue is peculiar: one could take c = α, but we show that sysGen does not require calls to Algorithm <a href="#page-12-0">1,</a> so the attack complexity is dominated by iteRes.</p>

    <p class="text-gray-300">Recall that the system P output of sysGen follows the structure of System <a href="#page-9-0">\\(4\\)</a>, where furthermore the f<sup>i</sup> 's and h are reduced modulo the ≺lex-Gr¨obner basis formed by the first n polynomials. The structure of this system naturally suggests eliminating the z<sup>i</sup> 's from top to bottom, by computing the series of resultants hn, . . . , h0, where:</p>

    <p class="text-gray-300"><span class="math-block">h_n = h</span> , and  <span class="math">h_{i-1} = \\operatorname{Res}_{z_i}(h_i, z_i^{\\alpha} - f_i)</span>  for  <span class="math">i = n, \\dots, 1</span> .</p>

    <p class="text-gray-300">Indeed, it is readily seen that h<sup>i</sup> ∈ R<sup>i</sup> = Fq[x, z1, . . . , z<sup>i</sup> ] for 0 ≤ i ≤ n, and in particular h<sup>0</sup> is univariate in x. To limit degree growth in the remaining variables, this approach was tweaked in [\\[26\\]](#page-31-7) by applying cubic substitution (in our terminology, reduction) after the computation of each resultant.</p>

    <p class="text-gray-300">As mentioned earlier, our approach applies the reduction of Algorithm <a href="#page-12-0">1</a> after each multiplication in the resultant computation, rather than only on the resultant itself. We denote the non-reduced resultant as Res<sup>i</sup> = Res<sup>z</sup>i+1 (hi+1, z<sup>α</sup> <sup>i</sup>+1 − fi+1) and reserve the notation h<sup>i</sup> for the reduced polynomial considered in our approach. Each resultant h<sup>i</sup> can in theory be computed directly as a Sylvester determinant, i.e., a polynomial expression in R<sup>i</sup> on fi+1 and the coefficients of hi+1, interpreted as a polynomial of Ri−1[z<sup>i</sup> ]. This method can be efficient for small α's – we will indeed use it in our applications in Section <a href="#page-20-0">5</a> for α = 3 – but for large α's, the polynomial expression is too heavy and this technique becomes inefficient. Hence for general α's we use another approach based on Proposition <a href="#page-5-0">1.</a> The complexity estimates of this section correspond to this latter algorithm, and assume an unbounded α.</p>

    <p class="text-gray-300">Resultant computation for general α. Our method to compute resultants for α > 3 consists in applying the following proposition.</p>

    <p class="text-gray-300"><span id="page-17-0"></span>Proposition 6. Let us denote by F<sup>R</sup>i−<sup>1</sup> the algebraic closure of the fraction field of Ri−1. We have:</p>

    <p class="text-gray-300"><span id="page-17-2"></span> <span class="math-block">Res_{i-1} = Res_{z_i}(h_i, z_i^{\\alpha} - f_i) = \\prod_{j=0}^{\\alpha-1} h_i(\\theta \\chi^j),</span>  (7)</p>

    <p class="text-gray-300">where χ ∈ F<sup>q</sup> is an α-th primitive root of unity and θ ∈ F<sup>R</sup>i−<sup>1</sup> is an α-th root of fi.</p>

    <p class="text-gray-300">Proof. We use Proposition <a href="#page-5-0">1</a> by making the roots of z α <sup>i</sup> −f<sup>i</sup> explicit, namely θχ<sup>j</sup> for 0 ≤ j ≤ α − 1. We obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Res}_{z_i}(h_i, z_i^{\\alpha} - f_i) = (-1)^{\\alpha(\\alpha - 1)} \\prod_{j=0}^{\\alpha - 1} h_i(\\theta \\chi^j) = \\prod_{j=0}^{\\alpha - 1} h_i(\\theta \\chi^j).</span></div>

    <p class="text-gray-300">Using Proposition <a href="#page-17-0">6,</a> the computation of this resultant boils down to α multiplications of multivariate polynomials in FRi−<sup>1</sup> . In order to perform the computation on a simpler ring, we introduce new formal variables θ and χ and perform the computation in Ri−1[θ, χ]/⟨θ <sup>α</sup> − f<sup>i</sup> , χ<sup>0</sup> + . . . + χ α−1 ⟩. In addition, we aim at producing a reduced polynomial hi−<sup>1</sup> by applying a variant of Algorithm <a href="#page-12-0">1</a> after each multiplication. Therefore, we will directly perform the multiplications in the subring Si−1[θ, χ]/⟨θ <sup>α</sup> − f<sup>i</sup> , χ<sup>0</sup> + . . . + χ α−1 ⟩ where Si−<sup>1</sup> = Ri−1/⟨Pi−1⟩. With a slight abuse of notation, we can identify the formal variable z<sup>i</sup> with θ, yielding the natural isomorphism:</p>

    <div class="my-4 text-center"><span class="math-block">S_{i-1}[\\theta,\\chi]/\\langle \\theta^{\\alpha}-f,\\chi^0+\\ldots+\\chi^{\\alpha-1}\\rangle \\cong S_i[\\chi]/\\langle \\chi^0+\\ldots+\\chi^{\\alpha-1}\\rangle,</span></div>

    <p class="text-gray-300">which essentially allows us to compute in the familiar ring S<sup>i</sup> with one extra variable χ. In order to account for χ, we show that we may use Algorithm <a href="#page-12-0">1</a> with i+ 1 variables. The complexity of this computation is estimated in the following lemma, whose proof provides more details on how we apply Algorithm <a href="#page-12-0">1.</a></p>

    <p class="text-gray-300">Lemma 2. For 1 ≤ i ≤ n, the reduced resultant hi−<sup>1</sup> can be computed from h<sup>i</sup> and P in</p>

    <p class="text-gray-300"><span id="page-17-1"></span> <span class="math-block">\\widetilde{\\mathcal{O}}(d_{\\mathcal{P}}(h_i)(2\\alpha-1)^{i+2}).</span></p>

    <p class="text-gray-300"><em>Proof.</em> The idea is similar to the fast multivariate multiplication and reduction in  <span class="math">S_i</span> , but with an extra variable  <span class="math">\\chi</span>  and equation  <span class="math">\\chi^0 + ... + \\chi^{\\alpha-1}</span> . In order to reuse the bounds of Corollary 1, we perform all operations in  <span class="math">S_i[\\chi]/\\langle \\chi^{\\alpha} - 1 \\rangle</span> , and reduce by  <span class="math">\\chi^0 + ... + \\chi^{\\alpha-1}</span>  at the end. Let us consider the reduced system  <span class="math">\\mathcal{P}_i^{\\chi} = \\mathcal{P}_i \\cup \\{\\chi^{\\alpha} - 1 = 0\\}</span> . Note that  <span class="math">\\chi^{\\alpha} - 1 = 0</span>  fits the shape of the first nequations of System 4 (in a very simple manner). We can thus treat  <span class="math">\\mathcal{P}_i^{\\chi}</span>  as a polynomial system composed of the first i+1 equations of System 4, and we can directly use the bounds of Corollary 1: the multivariate multiplication and reduction cost  <span class="math">\\tilde{\\mathcal{O}}(d_x(2\\alpha-1)^{i+1})</span>  operations altogether, where  <span class="math">d_x</span>  is a bound on the x-degrees during the computation. Following Lemma 1,  <span class="math">d_x</span>  can be bounded by the product of the weighted degrees of the two inputs of the multiplication. Note that Construction 1 for  <span class="math">\\mathcal{P}_i^{\\chi}</span>  defines the weighted degree of  <span class="math">\\chi</span>  as  <span class="math">d_{\\mathcal{P}_i^{\\chi}}(\\chi) = 0</span> , so  <span class="math">\\chi</span>  is not involved in the weighted degree  <span class="math">d_{\\mathcal{P}^{\\chi}}</span> . Therefore, for all j, we have  <span class="math">d_{\\mathcal{P}_{i}^{\\chi}}(h_{i}(z_{i}\\chi^{j})) = d_{\\mathcal{P}_{i}^{\\chi}}(h_{i}(z_{i})) = d_{\\mathcal{P}}(h_{i})</span> . In order to perform this product of  <span class="math">\\alpha</span> terms of weighted degree  <span class="math">d_{\\mathcal{P}}(h_i)</span> , we may apply a divide-and-conquer method to minimize the number of high weighted degree multiplication (as sketched in Appendix A): this costs  <span class="math">\\widetilde{\\mathcal{O}}(\\alpha d_{\\mathcal{P}}(h_i)(2\\alpha-1)^{i+1}) = \\widetilde{\\mathcal{O}}(d_{\\mathcal{P}}(h_i)(2\\alpha-1)^{i+2})</span> . operations. The final reduction by  <span class="math">\\chi^0 + ... + \\chi^{\\alpha-1}</span>  has linear cost w.r.t. the size of the output of the previous steps.</p>

    <p class="text-gray-300">Remark 3. Based on our analysis, if we first give a complexity bound using x-degrees and then bound these x-degrees by weighted degrees as was done in sysGen, the resulting bound is weaker by a factor approximately  <span class="math">\\alpha</span> . Indeed, the multiplication grouping seems harder to take into account.</p>

    <p class="text-gray-300">Estimating the cost of iteRes comes down to estimating the weighted degrees of the  <span class="math">h_i</span> 's, which is done in the following lemma.</p>

    <p class="text-gray-300"><span id="page-18-0"></span><strong>Lemma 3.</strong> For  <span class="math">1 \\le i \\le n</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block">d_{\\mathcal{P}}(h_i) \\le \\alpha^{n-i} d_{\\mathcal{P}}(h).</span></div>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">1 \\leq i \\leq n</span> . Since  <span class="math">h_i</span>  is obtained from  <span class="math">\\operatorname{Res}_i</span>  from reductions that cannot increase the weighted degree, we have  <span class="math">d_{\\mathcal{P}_i}(h_i) \\leq d_{\\mathcal{P}_i}(\\operatorname{Res}_i)</span> . Using Proposition 6, and the polynomial system  <span class="math">\\mathcal{P}_i^{\\chi}</span>  defined in the proof of Lemma 2, we have:</p>

    <div class="my-4 text-center"><span class="math-block">d_{\\mathcal{P}}(h_{i-1}) = d_{\\mathcal{P}_{i}^{X}}(h_{i-1}) \\le d_{\\mathcal{P}_{i}^{X}}(\\operatorname{Res}_{i-1}) = \\sum_{j=0}^{\\alpha-1} d_{\\mathcal{P}_{i}^{X}}(h_{i}(z_{i}\\chi^{j})) = \\alpha d_{\\mathcal{P}}(h_{i}).</span></div>

    <p class="text-gray-300">As  <span class="math">d_{\\mathcal{P}}(h_n) = d_{\\mathcal{P}}(h)</span> , we can conclude by induction on i = n, ..., 1.</p>

    <p class="text-gray-300">We can finally give a bound for the iteRes step that depends on the weighted degree of the last polynomial  <span class="math">h \\in \\mathcal{P}</span> .</p>

    <p class="text-gray-300"><span id="page-18-1"></span><strong>Proposition 7.</strong> Given a reduced polynomial system  <span class="math">\\mathcal{P}</span> , the complexity of iteRes in  <span class="math">\\mathbb{F}_q</span> -operations can be upper-bounded by:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}}(h)(2\\alpha-1)^{n+2}\\right).</span></div>

    <p class="text-gray-300"><em>Proof.</em> By combining Lemma 2 and 3, obtaining the <em>i</em>-th polynomial  <span class="math">h_i</span>  from previously computed data costs  <span class="math">\\widetilde{\\mathcal{O}}(d_{\\mathcal{P}}(h_i)(2\\alpha-1)^{i+2})</span> . Computing the entire series  <span class="math">h_n, \\ldots, h_1</span>  therefore costs</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(\\sum_{i=1}^{n} d_{\\mathcal{P}}(h_{i})(2\\alpha - 1)^{i+2}\\right) = \\widetilde{\\mathcal{O}}\\left(\\sum_{i=1}^{n} \\alpha^{n-i} d_{\\mathcal{P}}(h)(2\\alpha - 1)^{i+2}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}}(h)(2\\alpha - 1)^{n+2}\\sum_{i=1}^{n} \\left(\\frac{\\alpha}{2\\alpha - 1}\\right)^{n-i}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}}(h)(2\\alpha - 1)^{n+2}\\right).</span></div>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.3 Overall Attack Complexity</h3>

    <p class="text-gray-300">We now have everything needed to upper-bound the entire attack complexity.</p>

    <p class="text-gray-300"><strong>Proposition 8.</strong> Let  <span class="math">d_x</span>  be the maximum x-degree observed throughout sysGen, and let M be the number of multiplications in the cipher. The complexity of the resultant attack in terms of  <span class="math">\\mathbb{F}_q</span> -operations is</p>

    <p class="text-gray-300"><span id="page-19-0"></span> <span class="math-block">\\widetilde{\\mathcal{O}}\\left(Md_x(2\\alpha-1)^n+d_{\\mathcal{P}}(h)(2\\alpha-1)^{n+2}\\right).</span></p>

    <p class="text-gray-300">Proof. Proposition 4 states that sysGen costs  <span class="math">\\widetilde{\\mathcal{O}}(Md_x(2\\alpha-1)^n)</span>  operations in  <span class="math">\\mathbb{F}_q</span> , and Proposition 7 states that iteRes costs  <span class="math">\\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}}(h)(2\\alpha-1)^{n+2}\\right)</span>  operations in  <span class="math">\\mathbb{F}_q</span> . Finally, the last univariate resultant is of degree  <span class="math">d_{\\mathcal{P}}(h_0) \\leq d_{\\mathcal{P}}(h)\\alpha^n</span>  by Lemma 3. Therefore, uniSol costs  <span class="math">\\widetilde{\\mathcal{O}}(d_{\\mathcal{P}}(h)\\alpha^n)</span>  using Equation (3), which is less than iteRes.</p>

    <p class="text-gray-300">Using Assumption 1, and assuming that the number M of multiplications in the cipher is small, the previous bound can be simplified as a function of  <span class="math">d_{\\mathcal{P}}(h)</span> . As explained in Remark 2, the second assumption is sound because the cost of sysGen is dominated by the last modeling round, which effectively comprises a small number of multiplications.</p>

    <p class="text-gray-300"><strong>Corollary 2.</strong> Under Assumption 1, and assuming that the number of multiplications M in the cipher is small, the complexity of the resultant attack in  <span class="math">\\mathbb{F}_q</span> -operations is:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d_{\\mathcal{P}}(h)(2\\alpha-1)^{n+2}\\right).</span></div>

    <p class="text-gray-300"><em>Proof.</em> Using the two assumptions, the complexity of sysGen can be simplified as  <span class="math">\\widetilde{\\mathcal{O}}(d_{\\mathcal{P}}(h)(2\\alpha-1)^n)</span> . The cost of the other steps is the same as in Proposition 8.</p>

    <p class="text-gray-300">Under Assumption 1, our analysis shows that the complexity of sysGen and iteRes differ only by logarithmic factors when  <span class="math">\\alpha</span>  is small, and that uniSo1 has a lower cost. Finally, we remark that in the special case when  <span class="math">\\mathcal{P}</span>  is a FreeLunch Gröbner basis (see Definition 8), we have a particularly succinct complexity estimate depending only on  <span class="math">\\alpha</span>  and the ideal degree.</p>

    <p class="text-gray-300"><strong>Corollary 3.</strong> If  <span class="math">\\mathcal{P}</span>  is a FreeLunch Gröbner basis generating an ideal of degree  <span class="math">d_I</span> , the complexity of the resultant attack in  <span class="math">\\mathbb{F}_q</span> -operations is:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d_I\\alpha^2\\left(\\frac{2\\alpha-1}{\\alpha}\\right)^{n+2}\\right).</span></div>

    <p class="text-gray-300"><em>Proof.</em> As  <span class="math">\\mathcal{P}</span>  is a FreeLunch Gröbner basis with respect to  <span class="math">\\prec_{\\mathcal{P}}</span> , the leading monomial of the last polynomial h is of the form  <span class="math">x^d</span> , so  <span class="math">d_{\\mathcal{P}}(h) = d</span> . Proposition 7 together with the fact that  <span class="math">d_I = d\\alpha^n</span>  concludes the proof.</p>

    <p class="text-gray-300">For realistic values of  <span class="math">\\alpha</span>  and n, this last result improves upon the asymptotic complexity of the FreeLunch attack, where the cost of polyDet was estimated to be  <span class="math">\\widetilde{\\mathcal{O}}(d_I\\alpha^{n(\\omega-1)})</span>  operations in  <span class="math">\\mathbb{F}_q</span>  [3, Section 3.2].</p>

    <p class="text-gray-300">In this section, we estimate the complexity of our attack against the permutations of Griffin, Arion, Rescue and Anemoi, where the respective primitives are briefly recalled in Appendix C. To this end, we re-use existing bypassing techniques from [4] and [3]. We also slightly refine the complexity estimates to include logarithmic factors and we instantiate the parameters that were left unspecified in Section 4, such as  <span class="math">d_x</span>  or  <span class="math">d_{\\mathcal{P}}(h)</span> , noting that these parameters are influenced by the application of bypassing techniques. We support this theoretical analysis with experimental results on round-reduced Griffin, Anemoi and Rescue.</p>

    <p class="text-gray-300">Resultant computation when  <span class="math">\\alpha = 3</span> . As briefly mentioned in Section 4.2, our applications for  <span class="math">\\alpha = 3</span>  use a different resultant algorithm than the one derived from Proposition 6. For these cases, we compute directly the Sylvester determinant by using the method sketched in [26, Proof of Lemma 3]. More details are given in Appendix B. Concretely, this method requires 9 products in the quotient ring  <span class="math">S_k</span>  (and thus 9 multivariate multiplications and calls to Algorithm 1) to compute the resultant  <span class="math">h_k</span>  from  <span class="math">h_{k+1}</span> .</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">5.1 Keeping Track of Logarithmic Factors</h4>

    <p class="text-gray-300">Most of the complexities in the previous sections of this paper were given with  <span class="math">\\widetilde{\\mathcal{O}}(\\cdot)</span>  to lighten the formulae. In this subsection, we explicit the logarithmic factors behind the  <span class="math">\\widetilde{\\mathcal{O}}(\\cdot)</span>  and give new bounds in  <span class="math">\\mathcal{O}(\\cdot)</span>  that we will instantiate on the different primitives. A common assumption in previous works is that the constants behind those  <span class="math">\\mathcal{O}(\\cdot)</span>  are small, given that all logarithmic factors have been accounted for. We will also make this assumption, which allows us to evaluate the expression inside the  <span class="math">\\mathcal{O}(\\cdot)</span>  to evaluate the complexity of the attack steps.</p>

    <p class="text-gray-300">Refining Proposition <a href="#page-12-2">3</a> and Corollary <a href="#page-13-1">1.</a> For the cost of a single multiplication and reduction (in other words, a product in Sk) in sysGen, we adopt a more precise estimate that includes logarithmic factors. To express this complexity, we introduce the notation D<sup>i</sup> = (dx+1)(2α−1)<sup>i</sup> for 1 ≤ i ≤ k. Referring back to Equation <a href="#page-12-3">\\(5\\)</a> with the univariate multiplication complexity of Equation <a href="#page-6-3">\\(3\\)</a>, we get the following estimate for Algorithm <a href="#page-12-0">1</a> when the first k variables are involved and where d<sup>x</sup> is still the maximal x-degree observed in this algorithm:</p>

    <div class="my-4 text-center"><span class="math-block">C(k, d_x) = \\mathcal{O}\\left(D_k \\sum_{i=0}^{k-1} \\log(D_i) \\log(\\log(D_i))\\right)$$ $$= \\mathcal{O}\\left(D_k k \\log(D_k) \\log(\\log(D_k))\\right).</span></div>

    <p class="text-gray-300">At the same time, the multiplication that precedes the reduction costs:</p>

    <p class="text-gray-300"><span class="math-block">\\mathcal{O}\\left(D_k \\log(D_k) \\log(\\log(D_k))\\right)</span> ,</p>

    <p class="text-gray-300">which corresponds to a negligible fraction of 1/k of the complexity estimate C(k, dx) for this reduction. Therefore, we consider that the complexity of one product in the quotient ring S<sup>k</sup> is C(k, dx).</p>

    <p class="text-gray-300">Concrete estimate of sysGen. Let M′ be the number of multivariate multiplications needed to evaluate one round of the permutation circuit as described in Section <a href="#page-14-1">4.1.</a> From now on, d<sup>x</sup> refers to the maximum x-degree in the computations of sysGen. Let D<sup>i</sup> = (d<sup>x</sup> + 1)(2α − 1)<sup>i</sup> and let k<sup>i</sup> be the number of introduced variables in rounds 1, ..., i (thus k<sup>r</sup> = n). We then estimate the complexity of sysGen to be</p>

    <div class="my-4 text-center"><span class="math-block">M&#x27; \\sum_{i=1}^{r} C(k_i, d_x) = \\mathcal{O}\\left(M&#x27; \\sum_{i=1}^{r} D_{k_i} k_i \\log(D_{k_i}) \\log(\\log(D_{k_i}))\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\mathcal{O}\\left(M&#x27; k_r \\log(D_n) \\log(\\log(D_n)) \\sum_{i=1}^{r} D_{k_i}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\mathcal{O}\\left(M&#x27; (d_x + 1) n \\log(D_n) \\log(\\log(D_n)) \\sum_{i=1}^{r} (2\\alpha - 1)^{k_i}\\right).</span></div>

    <p class="text-gray-300">Even if this condition is not indispensable, in our discussion we assume the same number ℓ of variables introduced per round. In this case, k<sup>i</sup> follows an arithmetic progression with common difference ℓ. Assuming that ℓ > 0, the last sum is dominated by (2α − 1)<sup>k</sup><sup>r</sup> = (2α − 1)<sup>n</sup> . We thus obtain:</p>

    <div class="my-4 text-center"><span class="math-block">C_{\\text{sysGen}} = \\mathcal{O}(M&#x27;(d_x + 1)(2\\alpha - 1)^n n \\log(D_n) \\log(\\log(D_n))). \\tag{8}</span></div>

    <p class="text-gray-300">Concrete estimate of iteRes. As suggested by the proof of Proposition <a href="#page-18-1">7,</a> the cost of computing the first resultant, corresponding to the last round, dominates. Indeed, the weighted degree d<sup>P</sup> (hi) increases by a factor α while the number of variables reduces by 1 at each step, thereby the cost of multiplication in S<sup>i</sup> decreases by a factor (2α − 1)/α in each step. We now consider two variants. In the α = 3 case, we use the method described in Appendix <a href="#page-32-1">B,</a> which costs 9 operations in S<sup>i</sup> . The argument mentioned above applies, and we bound this step with the complexity of the first resultant. We thus define D = αd<sup>P</sup> (h)(2α−1)n−<sup>1</sup> and estimate the complexity of iteRes for α = 3 as:</p>

    <div class="my-4 text-center"><span class="math-block">C_{\\text{iteRes}} = 9 \\cdot C(n - 1, \\alpha \\cdot d_{\\mathcal{P}}(h))</span></div>

    <p class="text-gray-300"><span class="math-block">= \\mathcal{O}(9n(\\alpha d_{\\mathcal{P}}(h) + 1)(2\\alpha - 1)^{n-1}\\log(D)\\log(\\log(D))).</span> (9)</p>

    <p class="text-gray-300"><span id="page-22-0"></span>When α > 3, we use the method described in Section <a href="#page-16-1">4.2</a> by computing the resultant as the polynomial product in Proposition <a href="#page-17-0">6.</a> From the proof of Lemma <a href="#page-17-1">2,</a> we recall that computing hi−<sup>1</sup> can be done through operations in the ring Si+1. The polynomial product is computed through a standard divide-andconquer approach, as described in Appendix <a href="#page-32-0">A.</a> Writing E = 2⌈log<sup>2</sup> <sup>α</sup>⌉ , D = αd<sup>P</sup> (h)(2α − 1)n+1 and referring to Appendix <a href="#page-32-0">Af</a>or the first equality, we obtain the following bound for iteRes by bounding the cost for the first resultant:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathcal{C}_{\\text{iteRes}} &amp;= \\sum_{j=1}^{\\log_2 E} \\frac{E}{2^j} C\\left(n+1, 2^j d_{\\mathcal{P}}(h)\\right) \\\\ &amp;= \\mathcal{O}\\left(\\sum_{j=1}^{\\log_2 E} \\frac{\\alpha}{2^j} (2^j d_{\\mathcal{P}}(h)+1)(n+1)(2\\alpha-1)^{n+1} \\log(D) \\log(\\log(D))\\right) \\\\ &amp;= \\mathcal{O}(d_{\\mathcal{P}}(h)(2\\alpha-1)^{n+1}(n+1)\\alpha \\log(\\alpha) \\log(D) \\log(\\log(D))). \\end{split}</span></div>

    <h2 id="sec-20" class="text-2xl font-bold">5.2 Griffin</h2>

    <p class="text-gray-300">We focus on the proposed instances of the Griffin hash function with α ∈ {3, 5}, and the number of branches t is 3 or a multiple of 4 (up to t = 24) <a href="#page-31-2">\\[16,</a> Table 2].</p>

    <p class="text-gray-300">Primitive-specific considerations. From the round function of Griffin in Appendix <a href="#page-33-1">C.1,</a> it is easy to see that evaluating the Griffin circuit can be performed in M′ = α + 2(t − 2) (multivariate) multiplications each round. Let us denote b the number of bypassed rounds, and d<sup>b</sup> be the x-degree after the bypass. We follow the techniques of <a href="#page-30-4">\\[3,</a> Section 4.1] to bypass the b first α-inversions. Informally, this is done by selecting the inputs to Griffin on all branches except for the one fixed to 0 in such a way that the inputs to the α-inversions in the first rounds are always constant. For t = 3, 4, we have b = 1 and d<sup>1</sup> = 1; for t = 8, we have b = 2 and d<sup>2</sup> = 3; for t ≥ 12, we have b = 3 and d<sup>3</sup> = 6α + 3. Following the analysis of [\\[3\\]](#page-30-4) for a given t, and using the order of Construction <a href="#page-9-1">1,</a> the leading monomial of the state polynomials after the (i + b)-th round is x di with d<sup>i</sup> = db(2α + 1)<sup>i</sup> , and the weights of the z<sup>i</sup> 's are d<sup>P</sup> (zi) = di/α. We easily observe that the weighted degrees of the manipulated polynomials never exceed  <span class="math">d_{\\mathcal{P}}(h)</span> , therefore  <span class="math">d_x \\leq d_{\\mathcal{P}}(h)</span> . Since  <span class="math">\\mathcal{P}</span>  is a FreeLunch Gröbner basis, we have  <span class="math">d_{\\mathcal{P}}(h) = \\deg_x(h) = d_b(2\\alpha+1)^{r-b}</span> , which we use to estimate the complexity of sysGen and iteRes. The degree of the final univariate polynomial in uniSol is  <span class="math">\\alpha^{r-b}d_{\\mathcal{P}}(h) = d_b\\alpha^{r-b}(2\\alpha+1)^{r-b}</span> , which also corresponds to the ideal degree.</p>

    <p class="text-gray-300">Complexity. Table 1 presents the estimated complexities for the sysGen, iteRes and uniSol steps against the parameters proposed in [16, Table 2]. The complexity of uniSol was computed using (3) with  <span class="math">\\log_2(q) \\approx 256</span>  for the field size. For comparison, we also give the complexity of the polyDet step from the FreeLunch attack, as reported in [3, Table 2]. From Table 1 we see that the complexity of solving the CICO problem is lower than the claimed security level for all cases except for  <span class="math">\\alpha = 5</span>  and t = 3.</p>

    <p class="text-gray-300">| <span class="math">\\begin{array}{c ccccccccccccccccccccccccccccccccccc</span>         |                                                    |     |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---------------------------------------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">----------------------------------------------------</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-----</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{c ccccccccccccccccccccccccccccccccccc</span></td>

            <td class="px-3 py-2 border-b border-gray-700">3 3 16 92 92 83 120</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\begin{array}{c ccccccccccccccccccccccccccccccccccc</span></td>

            <td class="px-3 py-2 border-b border-gray-700">4 15 87 87 78 112</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 3 14 102 106 92 141<br>4 11 81 85 75 110<br>8 9 63 66 58 81</td>

            <td class="px-3 py-2 border-b border-gray-700">8 11 63 61 57 76</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 11 81 85 75 110<br>8 9 63 66 58 81</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\geq 12 \\ 10  55  53  51  64</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 9 63 66 58 81</td>

            <td class="px-3 py-2 border-b border-gray-700">5 3 14 102 106 92 141</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|                                                               | 4 11 81 85 75 110                                  |     |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>12 9 60 62 56 74</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 9 63 66 58 81</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-23-0"></span><strong>Table 1.</strong> Complexity (in  <span class="math">\\log_2 \\mathbb{F}_q</span> -multiplications) of the steps of our attack on full-round variants of Griffin with 128-bit security claim.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">5.3 ArionHash</h4>

    <p class="text-gray-300">We focus on the Arion parameters given in [22, Table 3], which include normal parameters, as well as a more aggressive variant named " <span class="math">\\alpha</span> -ArionHash". Following the nomenclature of Appendix C.2, these variants have  <span class="math">t \\in \\{3,4,5,6,8\\}</span>  branches and an additional parameter  <span class="math">e \\in \\{3,5\\}</span> , both of which affect the degree growth of the involved polynomials. There is  <span class="math">\\ell=1</span>   <span class="math">\\alpha</span> -inversion per round, and the exponent  <span class="math">\\alpha</span>  used for inversions can lie in the range  <span class="math">121 \\le \\alpha \\le 257</span> , though we will focus on the case  <span class="math">\\alpha=121</span> .</p>

    <p class="text-gray-300"><strong>Primitive-specific considerations.</strong> Evaluating the Arion circuit can be done in M' = 5(t-1) multivariate polynomial multiplications for each round (for both e = 3 and e = 5). We follow the bypass technique of [3, Section 4.2], which achieves a one-round bypass with x-degree  <span class="math">d_1 = 3e</span>  after the first round and n = r - 1. Following this analysis under the order defined in Construction 1, the leading term of state polynomials after the (i + 1)-th round is  <span class="math">x^{d_i}</span>  with</p>

    <p class="text-gray-300"> <span class="math">d_i = d_1(2^{t-1}(e+1)-e)^i</span>  and the weight of the  <span class="math">z_i</span> 's are defined as  <span class="math">d_{\\mathcal{P}}(z_i) = d_i/\\alpha</span> . We observe that the manipulated polynomials have a weighted degree less than  <span class="math">d_{\\mathcal{P}}(h)</span>  at any time, therefore  <span class="math">d_x \\leq d_{\\mathcal{P}}(h)</span> . Eventually,  <span class="math">d_{\\mathcal{P}}(h) = \\deg_x(h) = d_1(2^{t-1}(e+1)-e)^{r-1} = 3e(2^{t-1}(e+1)-e)^{r-1}</span> , and the final univariate polynomial is of degree  <span class="math">3e(\\alpha(2^{t-1}(e+1)-e))^{r-1}</span> , which is also the degree of the ideal.</p>

    <p class="text-gray-300">Complexity. In Table 2, we present the estimated attack complexities for the parameter sets of ArionHash proposed in [22, Table 3], including the more aggressive  <span class="math">\\alpha</span> -Arion parameters. For the estimate of uniSol we have used  <span class="math">\\log_2(q) \\approx 250</span>  (as specified in [22, Table 3]). Table 2 shows that almost all parameter variants for Arion are broken by our approach of computing iterated resultants.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e t r s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sysGen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iteRes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">[3, \\mathtt{polyDet}]</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e t r s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sysGer</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">niteRes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">[3, {\\tt polyDet}]</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 3 6</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">3 3 5</td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">79</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">84</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 5</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">71</td>

            <td class="px-3 py-2 border-b border-gray-700">114</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">73</td>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">88</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 5</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">119</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 4</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">67</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

            <td class="px-3 py-2 border-b border-gray-700">8 4</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">82</td>

            <td class="px-3 py-2 border-b border-gray-700">67</td>

            <td class="px-3 py-2 border-b border-gray-700">98</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 3 6</td>

            <td class="px-3 py-2 border-b border-gray-700">79</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">5 3 4</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">68</td>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">83</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">86</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">72</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 5</td>

            <td class="px-3 py-2 border-b border-gray-700">76</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">74</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">75</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 5</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">122</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700">79</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">94</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 4</td>

            <td class="px-3 py-2 border-b border-gray-700">71</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

            <td class="px-3 py-2 border-b border-gray-700">8 4</td>

            <td class="px-3 py-2 border-b border-gray-700">71</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">101</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-24-0"></span><strong>Table 2.</strong> Theoretical complexities (in  <span class="math">\\log_2 \\mathbb{F}_q</span> -multiplications) of attacks against full-round variants of Arion with 128-bit security using  <span class="math">\\alpha = 121</span> . Normal parameters are in the left table, and the more aggressive  <span class="math">\\alpha</span> -Arion parameters are in the right table.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.4 Rescue</h4>

    <p class="text-gray-300">The Rescue Prime [1] hash function allows for a wide array of choices in terms of  <span class="math">\\alpha</span>  and number of branches t. Unlike the two previous examples, Rescue applies an  <span class="math">\\alpha</span> -inversion in each branch for every round, for a total of rt inversions.</p>

    <p class="text-gray-300"><strong>Primitive-specific considerations.</strong> The round function of Rescue applies a polynomial of degree  <span class="math">\\alpha</span>  before applying  <span class="math">\\alpha</span> -inversions at all branches. A consequence of this for our modeling is that all  <span class="math">f_i</span> 's are expected to be of degree  <span class="math">\\alpha</span> , and hence all weights in Construction 1 will be 1; this property is kept on all rounds. An observation of a similar effect was also made in [26, Lemma 2]. For the sysGen step, this means that we only have to reduce elements of the form  <span class="math">z_i^{\\alpha}</span> , which is done by simple additions of  <span class="math">z_i^{\\alpha} - f_i</span> . As no costly multiplications and calls to Algorithm 1 are required, the cost of sysGen is considered negligible for Rescue; this is also what we observed in practice.</p>

    <p class="text-gray-300">[4, Section 4.4] describes how to bypass one round with  <span class="math">d_1 = 1</span> , which leads to n = t(r-1). Since h is simply an affine polynomial in the t  <span class="math">z_i</span> -variables of the last round, we have  <span class="math">d_{\\mathcal{P}}(h) = 1</span> . For one bypassed round we expect a univariate degree of  <span class="math">d_{\\mathcal{P}}(h_0) \\leq \\alpha^{t(r-1)} d_{\\mathcal{P}}(h) = \\alpha^{t(r-1)}</span> . In practical experiments for  <span class="math">\\alpha = t = 3</span> , we observe that this upper bound is reached and corresponds to the ideal degree for reduced-round instances.</p>

    <p class="text-gray-300">Complexity. In Table 3, we present the complexity of the dominant iteRes step computed with Equation (9) for  <span class="math">t=\\alpha=3</span> . We consider reduced-round variants to compare with [26, Table 4], and full-round variants to compare with the security claim of the designers of Rescue [23]. Note that they derived the number of rounds for security level  <span class="math">\\lambda</span>  by first computing the number of rounds to withstand the best (previously) known attack in  <span class="math">2^{\\lambda}</span> , and multiplying this number with 1.5 for a 50% security margin. In Table 3, we can see that the full-round versions for security levels 80 and 128 remain secure but with a significantly smaller margin, while the 256-bit level has essentially no security margin. Finally, the 512-bit level fails to guarantee this amount of security.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iteRes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[26]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Designers' estimation [23]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">69</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">81</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

            <td class="px-3 py-2 border-b border-gray-700">99</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">257</td>

            <td class="px-3 py-2 border-b border-gray-700">181</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">66</td>

            <td class="px-3 py-2 border-b border-gray-700">475</td>

            <td class="px-3 py-2 border-b border-gray-700">330</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|    |        |        |      |                            |</p>

    <p class="text-gray-300"><span id="page-25-0"></span><strong>Table 3.</strong> Theoretical complexities (in  <span class="math">\\log_2 \\mathbb{F}_q</span> -multiplications) for attacking variants of Rescue with  <span class="math">t = \\alpha = 3</span>  and  <span class="math">\\log_2(q) \\approx 512</span> . Our analysis show that the complexity of sysGen is negligible compared to the rest of the attack.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">5.5 Anemoi</h4>

    <p class="text-gray-300">A quick reminder of Anemoi is given in Appendix C.4. We especially refer to this for details on the non-linear component  <span class="math">\\mathcal{H}</span> , which will be useful in the following. We remark that the system  <span class="math">\\mathcal{P}</span>  produced by sysGen for Anemoi is not a FreeLunch Gröbner basis<sup>7</sup>. We consider Anemoi with any number  <span class="math">t = 2\\ell</span>  of branches, extending on the work of [3] which only considered 2 branches. This gives rise to the possibility of bypassing a round, which we explain below.</p>

    <p class="text-gray-300"><span id="page-25-1"></span><sup>&</sup>lt;sup>7</sup> To circumvent this, the authors of [3] instead consider a subideal of  <span class="math">\\langle \\mathcal{P} \\rangle</span>  for which a FreeLunch Gröbner basis can easily be computed. We do not proceed as such.</p>

    <p class="text-gray-300"><strong>Primitive-specific considerations.</strong> The specifications of Anemoi slightly differ over  <span class="math">\\mathbb{F}_p</span>  (called <em>odd</em> characteristic) and over  <span class="math">\\mathbb{F}_{2^n}</span>  (<em>even</em> characteristic): the round function is different and  <span class="math">\\alpha</span>  is fixed to 3 in  <span class="math">\\mathbb{F}_{2^n}</span> . A common property of both settings is that  <span class="math">\\ell</span>   <span class="math">\\alpha</span> -inversions are performed in separate components  <span class="math">\\mathcal{H}</span>  each round, and a straightforward <strong>sysGen</strong> gives equations even more structured than System (4): for  <span class="math">1 \\leq i \\leq r</span>  and  <span class="math">1 \\leq j \\leq \\ell</span> , the j-th equation of round i is  <span class="math">z_{i,j}^{\\alpha} = f_{i,j}(x, z_{1,1}, \\ldots, z_{i-1,\\ell})</span> , and the last equation  <span class="math">h(x, z_{1,1}, \\ldots, z_{r,\\ell}) = 0</span> . At first glance, this gives  <span class="math">n = r\\ell</span> , but round-bypass techniques may reduce the number of variables, for both types of fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Bypassing rounds.</strong> For  <span class="math">\\ell \\geq 2</span> , let us denote  <span class="math">(v_1, \\ldots, v_\\ell) = \\mathcal{M}_y^{-1}(0, \\ldots, 0, 1)</span> , where  <span class="math">\\mathcal{M}_y</span>  is the matrix from Appendix C.4. From the same figure one can then see that the input  $(0, \\ldots, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(v_1 x, \\ldots, v_\\ell x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  leads to  </span>\\ell - 1<span class="math">  constant components  </span>\\mathcal{H}<span class="math">  at the first round. This implies that we can remove  </span>\\ell - 1<span class="math">  variables in the first round, for instance  </span>z_{1,1}, \\ldots, z_{1,\\ell-1}<span class="math"> , and their corresponding equations. This gives  </span>n = (r-1)\\ell + 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-26-0"></span>Lemma 4 (Odd characteristic parameters). Let  <span class="math">\\mathcal{P}</span>  be the output of sysGen from an input state of degree 1 in x allowing for a round-bypass. We have:</p>

    <p class="text-gray-300"><span class="math-block">M&#x27; = \\ell,</span>   <span class="math">d_{\\mathcal{P}}(h) \\le \\left(\\frac{\\alpha+2}{\\alpha}\\right)^r.</span></p>

    <p class="text-gray-300"><em>Proof.</em> First, for a non constant component  <span class="math">\\mathcal{H}</span>  with inputs a, b, we can see that</p>

    <p class="text-gray-300"><span class="math-block">\\mathcal{H}(a,b) = (a - 2gbz + gz^2 - g^{-1}, b - z),</span>   <span class="math">z^{\\alpha} = -gb^2 - g^{-1} + a</span></p>

    <p class="text-gray-300">where z is the newly introduced variable and g a non-zero field element. The multiplication with z being essentially free, we need one multiplication per  <span class="math">\\mathcal{H}</span>  (to compute  <span class="math">b^2</span> ), which gives  <span class="math">M&#x27;=\\ell</span> . The fact that  <span class="math">d_{\\mathcal{P}}(h) \\leq \\left(\\frac{\\alpha+2}{\\alpha}\\right)^r</span>  can be proven inductively on the number of rounds. It is clearly true for i=0, since the initial input has degree 1 in x. Now let us suppose that the polynomial state after round i is of weighted degree  <span class="math">\\left(\\frac{\\alpha+2}{\\alpha}\\right)^i</span> . Given the expression of  <span class="math">\\mathcal{H}</span>  shown above, we have, for any variable z introduced at round j,  <span class="math">d_{\\mathcal{P}}(z) = d_{\\mathcal{P}}(b^2)/\\alpha \\leq \\frac{2}{\\alpha}\\left(\\frac{\\alpha+2}{\\alpha}\\right)^i</span>  by definition (see Construction 1). Now the leading term of the output of  <span class="math">\\mathcal{H}</span>  comes from the term zb since  <span class="math">d_{\\mathcal{P}}(z^2) \\leq d_{\\mathcal{P}}(zb)</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">d_{\\mathcal{P}}(zb) = d_{\\mathcal{P}}(z) + d_{\\mathcal{P}}(b) \\le \\left(\\frac{\\alpha + 2}{\\alpha}\\right)^{i+1}.</span></div>

    <p class="text-gray-300"><span id="page-26-1"></span><strong>Characteristic 2.</strong> The characteristic 2 case was not studied in [3], but we can analyze it in our framework without much additional work. We can also apply the same round-skip trick. However, <strong>sysGen</strong> is more costly, because of the change to  <span class="math">x \\mapsto x^3</span>  operations instead of  <span class="math">x \\mapsto x^2</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5 (Even characteristic parameters).</strong> Let  <span class="math">\\mathcal{P}</span>  be the system output by sysGen from an input state of degree 1 in x allowing for a round-bypass. We have:</p>

    <div class="my-4 text-center"><span class="math-block">M&#x27; = 2\\ell, d_{\\mathcal{P}}(h) \\le 3^r.</span></div>

    <p class="text-gray-300"><em>Proof.</em> Using the same notations as previously,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{H}(a,b) = (a \\oplus gb^2z \\oplus gbz^2 \\oplus gz^3 \\oplus g^{-1}, b \\oplus z), \\qquad z^3 = gb^3 \\oplus g^{-1} \\oplus a.</span></div>

    <p class="text-gray-300">This time, since multiplication by z is essentially free, we need two multiplications per  <span class="math">\\mathcal{H}</span>  (to compute  <span class="math">b^2</span>  and  <span class="math">b^3</span> ), which gives  <span class="math">M&#x27;=2\\ell</span> . We prove that  <span class="math">d_{\\mathcal{P}}(h) \\leq 3^r</span>  inductively on the number of rounds. For i=0, the initial input has degree 1 in x. Suppose that the state after round i has weighted degree  <span class="math">3^i</span> . We have that  <span class="math">d_{\\mathcal{P}}(z) = d_{\\mathcal{P}}(b^3)/3 \\leq 3^i</span>  by definition. So, in the output of  <span class="math">\\mathcal{H}</span> , the terms of highest weighted degree come from  <span class="math">b^2z</span> ,  <span class="math">bz^2</span>  and  <span class="math">z^3</span> . They all have the same weighted degree,  <span class="math">3^{i+1}</span> , which completes the induction.</p>

    <p class="text-gray-300">We can use the conservative bound  <span class="math">d_x \\leq \\max_{p \\in \\mathcal{P}} (d_{\\mathcal{P}}(p))</span> . The polynomials with the highest weighted degree in  <span class="math">\\mathcal{P}</span>  are the  <span class="math">z_{r,j}^{\\alpha} - f_{r,j}</span> , for any j. They have a weighted degree of  <span class="math">2\\left((\\alpha+2)/\\alpha\\right)^{r-1}</span>  in odd characteristic (larger than  <span class="math">d_{\\mathcal{P}}(h)</span>  by a factor 2), and  <span class="math">3^r</span>  in characteristic 2 (equal to  <span class="math">d_{\\mathcal{P}}(h)</span> ). Using the parameters from Lemma 4 and 5, we give complexity estimates for sysGen and iteRes in Tables 4 and 5. For comparison, we also give estimates from [3,26] on the  <span class="math">\\ell=1</span>  parameters. Although [26] only considered the case of  <span class="math">\\alpha=3</span> , we have computed the complexities for larger  <span class="math">\\alpha</span> 's using [26, Theorem 5] with  <span class="math">d_l=(\\alpha+2)^{\\lfloor r/2\\rfloor}</span>  and  <span class="math">d_h=(\\alpha+2)^{\\lceil r/2\\rceil}</span>  (assuming that the cubic substitution step can be generalized in an efficient manner).</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.6 Experimental Attacks</h3>

    <p class="text-gray-300">The computational experiments were conducted on a system with the following hardware specifications:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Processor: AMD EPYC 9354, 32-core</li>

      <li>Memory: 1 TB DDR5 RAM (16  <span class="math">\\times</span>  64 GB HMCG94AEBRA109N, 4800 MT/s)</li>

    </ul>

    <p class="text-gray-300">To ensure as fair a comparison as possible with previous works (especially [3] and [4]), we executed all experiments in a single-threaded setting. However, it is worth noting that many computational steps in our approach could be parallelized to some extent. Also, note that [26] used 8 threads in their attack against Anemoi, and 32 threads against Rescue—Prime.</p>

    <p class="text-gray-300">From an implementation standpoint, the core computational routines are written in C++ for performance reasons, while the round-skipping preprocessing and the verification of the CICO solutions are handled in Python.</p>

    <p class="text-gray-300">The codebase uses the NTL library [25] exclusively for univariate polynomial multiplication, using its optimized implementation of the small-prime Fast</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α ℓ r sysGen iteRes [3, polyDet] [26]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α ℓ r sysGen iteRes [3, polyDet] [26]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 1 21</td>

            <td class="px-3 py-2 border-b border-gray-700">78</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">118</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">3 1 37</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">130</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

            <td class="px-3 py-2 border-b border-gray-700">191</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 14</td>

            <td class="px-3 py-2 border-b border-gray-700">89</td>

            <td class="px-3 py-2 border-b border-gray-700">89</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2 22</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">134</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 12</td>

            <td class="px-3 py-2 border-b border-gray-700">105</td>

            <td class="px-3 py-2 border-b border-gray-700">104</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3 17</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">144</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 12</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4 16</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 10</td>

            <td class="px-3 py-2 border-b border-gray-700">154</td>

            <td class="px-3 py-2 border-b border-gray-700">153</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6 13</td>

            <td class="px-3 py-2 border-b border-gray-700">199</td>

            <td class="px-3 py-2 border-b border-gray-700">198</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5 1 21</td>

            <td class="px-3 py-2 border-b border-gray-700">91</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">133</td>

            <td class="px-3 py-2 border-b border-gray-700">5 1 37</td>

            <td class="px-3 py-2 border-b border-gray-700">151</td>

            <td class="px-3 py-2 border-b border-gray-700">157</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

            <td class="px-3 py-2 border-b border-gray-700">231</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 14</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2 22</td>

            <td class="px-3 py-2 border-b border-gray-700">164</td>

            <td class="px-3 py-2 border-b border-gray-700">169</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 12</td>

            <td class="px-3 py-2 border-b border-gray-700">131</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3 17</td>

            <td class="px-3 py-2 border-b border-gray-700">182</td>

            <td class="px-3 py-2 border-b border-gray-700">186</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 12</td>

            <td class="px-3 py-2 border-b border-gray-700">167</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4 16</td>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 10</td>

            <td class="px-3 py-2 border-b border-gray-700">199</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6 13</td>

            <td class="px-3 py-2 border-b border-gray-700">258</td>

            <td class="px-3 py-2 border-b border-gray-700">262</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7 1 20</td>

            <td class="px-3 py-2 border-b border-gray-700">96</td>

            <td class="px-3 py-2 border-b border-gray-700">103</td>

            <td class="px-3 py-2 border-b border-gray-700">174</td>

            <td class="px-3 py-2 border-b border-gray-700">141</td>

            <td class="px-3 py-2 border-b border-gray-700">7 1 36</td>

            <td class="px-3 py-2 border-b border-gray-700">162</td>

            <td class="px-3 py-2 border-b border-gray-700">170</td>

            <td class="px-3 py-2 border-b border-gray-700">307</td>

            <td class="px-3 py-2 border-b border-gray-700">252</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 13</td>

            <td class="px-3 py-2 border-b border-gray-700">113</td>

            <td class="px-3 py-2 border-b border-gray-700">119</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2 21</td>

            <td class="px-3 py-2 border-b border-gray-700">177</td>

            <td class="px-3 py-2 border-b border-gray-700">183</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 12</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

            <td class="px-3 py-2 border-b border-gray-700">153</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3 17</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">212</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 11</td>

            <td class="px-3 py-2 border-b border-gray-700">174</td>

            <td class="px-3 py-2 border-b border-gray-700">179</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4 15</td>

            <td class="px-3 py-2 border-b border-gray-700">236</td>

            <td class="px-3 py-2 border-b border-gray-700">241</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 10</td>

            <td class="px-3 py-2 border-b border-gray-700">227</td>

            <td class="px-3 py-2 border-b border-gray-700">232</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6 13</td>

            <td class="px-3 py-2 border-b border-gray-700">296</td>

            <td class="px-3 py-2 border-b border-gray-700">300</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11 1 19</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">111</td>

            <td class="px-3 py-2 border-b border-gray-700">198</td>

            <td class="px-3 py-2 border-b border-gray-700">158</td>

            <td class="px-3 py-2 border-b border-gray-700">11 1 35</td>

            <td class="px-3 py-2 border-b border-gray-700">179</td>

            <td class="px-3 py-2 border-b border-gray-700">187</td>

            <td class="px-3 py-2 border-b border-gray-700">358</td>

            <td class="px-3 py-2 border-b border-gray-700">288</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 13</td>

            <td class="px-3 py-2 border-b border-gray-700">129</td>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2 21</td>

            <td class="px-3 py-2 border-b border-gray-700">203</td>

            <td class="px-3 py-2 border-b border-gray-700">211</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 11</td>

            <td class="px-3 py-2 border-b border-gray-700">156</td>

            <td class="px-3 py-2 border-b border-gray-700">163</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3 17</td>

            <td class="px-3 py-2 border-b border-gray-700">238</td>

            <td class="px-3 py-2 border-b border-gray-700">245</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 11</td>

            <td class="px-3 py-2 border-b border-gray-700">202</td>

            <td class="px-3 py-2 border-b border-gray-700">208</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4 15</td>

            <td class="px-3 py-2 border-b border-gray-700">274</td>

            <td class="px-3 py-2 border-b border-gray-700">280</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 10</td>

            <td class="px-3 py-2 border-b border-gray-700">264</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6 13</td>

            <td class="px-3 py-2 border-b border-gray-700">345</td>

            <td class="px-3 py-2 border-b border-gray-700">351</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-28-0"></span>Table 4. Theoretical complexities (in log<sup>2</sup> Fq-multiplications) for attacking full-round variants of Anemoi in odd characteristic proposed for 128-bit security on the left-hand side table, and 256-bit security on the right-hand side table. To stay consistent with the assumptions of previous work, we used ω = 2.81 for the attack of [\\[3\\]](#page-30-4) and ω = 2.376 for [\\[26\\]](#page-31-7). Experiments show that the attack on odd-characteristic Anemoi is heavily dominated by iteRes in practice.</p>

    <p class="text-gray-300">Fourier Transform. For multivariate polynomial multiplication, we extend the bivariate polynomial multiplication algorithm used in PML [\\[24\\]](#page-31-16), utilizing the Kronecker substitution method to obtain the complexity described in Equation <a href="#page-6-1">\\(2\\)</a> for any number of variables. Note that the polyDet step of the experimental attacks in [\\[3\\]](#page-30-4) was also coded with NTL and PML. [\\[26\\]](#page-31-7) instead used maple for the core of their experimental attacks. The complete implementation is available on github : <a href="https://github.com/maelhos/improved-resultant-attack">github.com/maelhos/improved-resultant-attack.</a> Finally, let us mention that this code also implements the resultant technique of Lemma <a href="#page-17-1">2</a> based on "field shifts". For α = 3, it is approximately 10 times slower than the Sylvester matrix-based resultant computation presented in Appendix <a href="#page-32-1">B.</a></p>

    <p class="text-gray-300">In all our attacks, we use a 55-bit prime p = 0x64ec6dd0392073, as in [\\[3\\]](#page-30-4) and as in the attack of [\\[26\\]](#page-31-7) against Anemoi. Note that [\\[26\\]](#page-31-7) used the 64-bit prime p = 2<sup>64</sup> − 59 for their experimental attack against Rescue–Prime, to compare to [\\[4\\]](#page-30-6) which used the same prime. We stress that the multi-threading of [\\[26\\]](#page-31-7) somewhat compensates this prime difference, so that we can fairly compare our single-thread attack on Rescue–Prime to theirs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ r sysGen iteRes uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ℓ r sysGen iteRes uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1 24</td>

            <td class="px-3 py-2 border-b border-gray-700">109</td>

            <td class="px-3 py-2 border-b border-gray-700">110</td>

            <td class="px-3 py-2 border-b border-gray-700">93</td>

            <td class="px-3 py-2 border-b border-gray-700">1 44</td>

            <td class="px-3 py-2 border-b border-gray-700">189</td>

            <td class="px-3 py-2 border-b border-gray-700">190</td>

            <td class="px-3 py-2 border-b border-gray-700">158</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 15</td>

            <td class="px-3 py-2 border-b border-gray-700">107</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">87</td>

            <td class="px-3 py-2 border-b border-gray-700">2 25</td>

            <td class="px-3 py-2 border-b border-gray-700">171</td>

            <td class="px-3 py-2 border-b border-gray-700">172</td>

            <td class="px-3 py-2 border-b border-gray-700">135</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3 13</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">124</td>

            <td class="px-3 py-2 border-b border-gray-700">97</td>

            <td class="px-3 py-2 border-b border-gray-700">3 20</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

            <td class="px-3 py-2 border-b border-gray-700">185</td>

            <td class="px-3 py-2 border-b border-gray-700">142</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4 12</td>

            <td class="px-3 py-2 border-b border-gray-700">142</td>

            <td class="px-3 py-2 border-b border-gray-700">141</td>

            <td class="px-3 py-2 border-b border-gray-700">108</td>

            <td class="px-3 py-2 border-b border-gray-700">4 17</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">197</td>

            <td class="px-3 py-2 border-b border-gray-700">148</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6 11</td>

            <td class="px-3 py-2 border-b border-gray-700">179</td>

            <td class="px-3 py-2 border-b border-gray-700">178</td>

            <td class="px-3 py-2 border-b border-gray-700">132</td>

            <td class="px-3 py-2 border-b border-gray-700">6 14</td>

            <td class="px-3 py-2 border-b border-gray-700">226</td>

            <td class="px-3 py-2 border-b border-gray-700">225</td>

            <td class="px-3 py-2 border-b border-gray-700">166</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8 10</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">204</td>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">8 12</td>

            <td class="px-3 py-2 border-b border-gray-700">247</td>

            <td class="px-3 py-2 border-b border-gray-700">245</td>

            <td class="px-3 py-2 border-b border-gray-700">179</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-29-0"></span>Table 5. Theoretical complexities (in log<sup>2</sup> Fq-multiplications) for attacking full-round variants of Anemoi in even characteristic (with α = 3) proposed for 128-bit security on the left-hand side table, and 256-bit security on the right-hand side table. The complexity of uniSol was computed with log<sup>2</sup> (q) ≈ 256.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overall</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sysGen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">iteRes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">uniSol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cipher</td>

            <td class="px-3 py-2 border-b border-gray-700">t</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">r Type</td>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">Theor.</td>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">T</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">Ref</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Anemoi 2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">FL</td>

            <td class="px-3 py-2 border-b border-gray-700">2d</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[3]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">49m</td>

            <td class="px-3 py-2 border-b border-gray-700">< 256</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[26]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.16</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">40ms</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05</td>

            <td class="px-3 py-2 border-b border-gray-700">6.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.16</td>

            <td class="px-3 py-2 border-b border-gray-700">3s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.08 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">10h</td>

            <td class="px-3 py-2 border-b border-gray-700">< 256</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[26]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">1m25s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3</td>

            <td class="px-3 py-2 border-b border-gray-700">65s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">20s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.58 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res. 13m51s</td>

            <td class="px-3 py-2 border-b border-gray-700">9.5</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">4s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.4 12m27s 9.5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1m24s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.3 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">10 Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">2h38m</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">31s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2h28m</td>

            <td class="px-3 py-2 border-b border-gray-700">77</td>

            <td class="px-3 py-2 border-b border-gray-700">10m</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">11 Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">1d22h</td>

            <td class="px-3 py-2 border-b border-gray-700">283</td>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">5m57s</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1d21h</td>

            <td class="px-3 py-2 border-b border-gray-700">283</td>

            <td class="px-3 py-2 border-b border-gray-700">58m</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">194 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Griffin 12 6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">FL</td>

            <td class="px-3 py-2 border-b border-gray-700">1m</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4s</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[3]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">10s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06</td>

            <td class="px-3 py-2 border-b border-gray-700">1.15s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">7.45s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.08 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">FL</td>

            <td class="px-3 py-2 border-b border-gray-700">3h32m</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">43m</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[3]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">5m30s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">1m12s</td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1m05s</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3m13s 1.53 New</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">4h20m</td>

            <td class="px-3 py-2 border-b border-gray-700">81.1</td>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1h14m 75.4 1h11m 81.1 1h55m 40.5 New</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rescue</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">GB</td>

            <td class="px-3 py-2 border-b border-gray-700">3d</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[4]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">15m</td>

            <td class="px-3 py-2 border-b border-gray-700">< 256</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[26]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">2.4s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02</td>

            <td class="px-3 py-2 border-b border-gray-700">1.6s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">0.06 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">1d</td>

            <td class="px-3 py-2 border-b border-gray-700">< 256</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[26]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">6m6s</td>

            <td class="px-3 py-2 border-b border-gray-700">10.1</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1</td>

            <td class="px-3 py-2 border-b border-gray-700">5m41s 10.1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">12s</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1 New</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">Res.</td>

            <td class="px-3 py-2 border-b border-gray-700">2d4h</td>

            <td class="px-3 py-2 border-b border-gray-700">570</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1s</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2d3h</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">570 11m27 210 New</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6. Summary of practical attacks against round-reduced permutations for α = 3. Time (T) and memory (M) in GigaBytes are provided for each step. Our theoretical complexity (Theor.) is also given for the overall attack, counted as the log<sup>2</sup> of the number of Fq-operations. The number of rounds is given as r and the number of branches in the state is given as t. Type refers to type of attack, where FL indicates FreeLunch, Res is resultant attack of this paper or [\\[26\\]](#page-31-7), and GB indicates Gr¨obner basis. Anemoi refers to its odd-characteristic variant.</p>

    <p class="text-gray-300">This paper shows that we still need better estimates of the security of AO primitives against algebraic attacks. Building upon recent works <a href="#page-30-4">\\[3,</a>[26\\]](#page-31-7), we can derive an improved algebraic attack based on resultants. With a detailed and refined complexity analysis, we show the new attack has a significantly lower complexity than was known before on the hash functions Griffin, Arion, Rescue, and Anemoi. These theoretical estimates are verified by extensive practical implementations that solve the associated CICO problems. The new insights should lead to a more robust foundation when selecting parameters for new AO primitives.</p>

    <p class="text-gray-300">This work has been facilitated through the COSINUS associate team between Inria and Simula. The authors would like to thank J´erˆome Plˆut for insightful discussions regarding multivariate resultants. The work of Aur´elien Bœuf was supported by the European Research Council (ERC, grant agreement no. 101041545 "ReSCALE"). Morten Øygarden has been supported by the Norwegian Research Council through the project qsIo2.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-30-1"></span>1. A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and A. Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. IACR Transactions on Symmetric Cryptology, pages 1–45, 2020.</li>

      <li><span id="page-30-3"></span>2. T. Ashur, A. Kindi, and M. Mahzoun. XHash8 and XHash12: Efficient STARKfriendly Hash Functions. Cryptology ePrint Archive, Paper 2023/1045, 2023.</li>

      <li><span id="page-30-4"></span>3. A. Bariant, A. Boeuf, A. Lemoine, I. Manterola Ayala, M. Øygarden, L. Perrin, and H. Raddum. The Algebraic FreeLunch: Efficient Gr¨obner Basis Attacks Against Arithmetization-Oriented Primitives. In Annual International Cryptology Conference (Crypto), pages 139–173. Springer, 2024.</li>

      <li><span id="page-30-6"></span>4. A. Bariant, C. Bouvier, G. Leurent, and L. Perrin. Algebraic Attacks against Some Arithmetization-Oriented Primitives. IACR Transactions on Symmetric Cryptology, pages 73–101, 2022.</li>

      <li><span id="page-30-7"></span>5. J. Berthomieu, V. Neiger, and M. Safey El Din. Faster change of order algorithm for Gr¨obner bases under shape and stability assumptions. In 2022 International Symposium on Symbolic and Algebraic Computation, Lille, France, July 2022.</li>

      <li><span id="page-30-0"></span>6. G. Bertoni, J. Daemen, M. Peeters, and G. Assche. Sponge functions, 2007.</li>

      <li><span id="page-30-5"></span>7. T. Beyne, A. Canteaut, I. Dinur, M. Eichlseder, G. Leander, G. Leurent, M. Naya-Plasencia, L. Perrin, Y. Sasaki, Y. Todo, and F. Wiemer. Out of oddity – new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In Annual International Cryptology Conference (Crypto), pages 299–328. Springer, 2020.</li>

      <li><span id="page-30-2"></span>8. C. Bouvier, P. Briaud, P. Chaidos, L. Perrin, R. Salen, V. Velichkov, and D. Willems. New design techniques for efficient arithmetization-oriented hash functions: Anemoi permutations and jive compression mode. In Annual International Cryptology Conference (Crypto), pages 507–539. Springer, 2023.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-31-10"></span>9. D. G. Cantor and E. L. Kaltofen. On fast multiplication of polynomials over arbitrary algebras. Acta Informatica, 28(7):693–701, 1991.</li>

      <li><span id="page-31-12"></span>10. G. E. Collins. The calculation of multivariate polynomial resultants. In Proceedings of the Second ACM Symposium on Symbolic and Algebraic Manipulation, SYM-SAC '71, page 212–222, New York, NY, USA, 1971. Association for Computing Machinery.</li>

      <li><span id="page-31-9"></span>11. D. A. Cox, J. Little, and D. O'Shea. Using Algebraic Geometry. Graduate Texts in Mathematics. Springer, Second edition, 2005.</li>

      <li><span id="page-31-8"></span>12. D. A. Cox, J. Little, and D. O'Shea. Ideals, Varieties, and Algorithms. Springer International Publishing, 2015.</li>

      <li><span id="page-31-4"></span>13. J.-C. Faug\`ere. A new efficient algorithm for computing gr¨obner bases (f4). Journal of Pure and Applied Algebra, 139(1):61–88, 1999.</li>

      <li><span id="page-31-6"></span>14. J.-C. Faug\`ere, P. M. Gianni, D. Lazard, and T. Mora. Efficient Computation of Zero-Dimensional Gr¨obner Bases by Change of Ordering. 16(4):329–344, 1993.</li>

      <li><span id="page-31-5"></span>15. J. C. Faug\`ere. A new efficient algorithm for computing Gr¨obner bases without reduction to zero (F5). In Proceedings of the 2002 international symposium on Symbolic and algebraic computation, pages 75–83, 2002.</li>

      <li><span id="page-31-2"></span>16. L. Grassi, Y. Hao, C. Rechberger, M. Schofnegger, R. Walch, and Q. Wang. Horst Meets Fluid-SPN: Griffin for Zero-Knowledge Applications. In Annual International Cryptology Conference (Crypto), pages 573–606. Springer, 2023.</li>

      <li><span id="page-31-0"></span>17. L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. Poseidon: A New Hash Function for Zero-Knowledge Proof Systems. In 30th USENIX Security Symposium (USENIX Security 21), pages 519–535, 2021.</li>

      <li><span id="page-31-1"></span>18. L. Grassi, D. Khovratovich, and M. Schofnegger. Poseidon2: A Faster Version of the Poseidon Hash Function. In International Conference on Cryptology in Africa (AfricaCrypt), pages 177–203. Springer, 2023.</li>

      <li><span id="page-31-17"></span>19. G. Labahn, V. Neiger, and W. Zhou. Fast, deterministic computation of the Hermite normal form and determinant of a polynomial matrix. Journal of Complexity, 42:44–71, 2017.</li>

      <li><span id="page-31-13"></span>20. X. Li, M. Moreno Maza, and Eric Schost. Fast arithmetic for triangular sets: ´ From theory to practice. Journal of Symbolic Computation, 44(7):891–907, 2009. International Symposium on Symbolic and Algebraic Computation.</li>

      <li><span id="page-31-11"></span>21. R. T. Moenck. Practical fast polynomial multiplication. In Proceedings of the Third ACM Symposium on Symbolic and Algebraic Computation, SYMSAC '76, page 136–148, New York, NY, USA, 1976. Association for Computing Machinery.</li>

      <li><span id="page-31-3"></span>22. A. Roy, M. J. Steiner, and S. Trevisani. Arion: Arithmetization-oriented permutation and hashing from generalized triangular dynamical systems. arXiv preprint arXiv:2303.04639, 2023.</li>

      <li><span id="page-31-14"></span>23. A. Szepieniec, T. Ashur, and S. Dhooghe. Rescue-prime: a standard specification (SoK). Cryptology ePrint Archive, 2020.</li>

      <li><span id="page-31-16"></span>24. The PML team. PML: Polynomial Matrix Library, 2023. Version 0.3, <a href="https://github.com/vneiger/pml">https://</a> <a href="https://github.com/vneiger/pml">github.com/vneiger/pml.</a></li>

      <li><span id="page-31-15"></span>25. V. Shoup, et al. NTL: A Library for Doing Number Theory. <a href="https://libntl.org/">https://libntl.org/.</a></li>

      <li><span id="page-31-7"></span>26. H.-S. Yang, Q.-X. Zheng, J. Yang, Q.-F. Liu, and D. Tang. A New Security Evaluation Method Based on Resultant for Arithmetic-Oriented Algorithms. In International Conference on the Theory and Application of Cryptology and Information Security (AsiaCrypt), pages 457–489. Springer, 2024.</li>

    </ul>

    <p class="text-gray-300">We briefly describe a divide-and-conquer method for performing the multiplications when computing the product in Equation (7), in order to limit the number of high-degree computations. We present the case of univariate polynomials for simplicity, noting that the multivariate case generalizes in a straightforward manner. Consider the product  <span class="math">\\prod_{i=1}^{\\alpha} h_i</span> , where  <span class="math">h_1, h_2, \\ldots, h_{\\alpha}</span>  are univariate polynomials of degree d. The idea is to first compute pairs of products  <span class="math">h_{2i}h_{2i-1}</span> ,  <span class="math">1 \\leq i \\leq \\alpha/2</span> , of degree at most 2d. Then compute new pairs of products of degree at most 4d, and so on. Writing  <span class="math">e = \\lceil \\log_2 \\alpha \\rceil</span> , and  <span class="math">E = 2^e</span> , this will cost at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{E}{2}\\mathcal{M}(2d) + \\frac{E}{4}\\mathcal{M}(4d) + \\ldots + \\frac{E}{E}\\mathcal{M}(Ed). \\tag{10}</span></div>

    <p class="text-gray-300">By applying Equation (1) for  <span class="math">\\mathcal M</span>  and suppressing log-factors, this requires</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathcal{O}}\\left(d\\left(2\\frac{E}{2}+4\\frac{E}{4}+\\ldots+E\\right)\\right)=\\widetilde{\\mathcal{O}}(deE)=\\widetilde{\\mathcal{O}}(d\\alpha).</span></div>

    <p class="text-gray-300">We recall the method outlined in [26] for computing resultants in the context of Rescue where  <span class="math">\\alpha = 3</span> , that we can easily generalize for any system as in (4). This approach exploits the specific structure of the Sylvester matrix, noting that the second polynomial,  <span class="math">z^{\\alpha} - f</span> , contains only a single non-constant monomial in z.</p>

    <p class="text-gray-300"><strong>Proposition 9.</strong> Let R, f and h be defined as above. The following statement holds:</p>

    <div class="my-4 text-center"><span class="math-block">Res_{z}(h, z^{\\alpha} - f) = \\begin{vmatrix} a_{0} &amp; fa_{\\alpha-1} &amp; \\dots &amp; fa_{2} &amp; fa_{1} \\\\ a_{1} &amp; a_{0} &amp; fa_{\\alpha-1} &amp; \\dots &amp; fa_{2} \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots \\\\ a_{\\alpha-2} &amp; \\dots &amp; a_{1} &amp; a_{0} &amp; fa_{\\alpha-1} \\\\ a_{\\alpha-1} &amp; a_{\\alpha-2} &amp; \\dots &amp; a_{1} &amp; a_{0} \\end{vmatrix}.</span></div>

    <p class="text-gray-300"><em>Proof.</em> The Sylvester matrix associated to h and  <span class="math">z^{\\alpha} - f</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">Syl(h, z^{\\alpha} - f) = \\begin{bmatrix} a_{\\alpha-1} &amp; \\dots &amp; a_1 &amp; a_0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; a_{\\alpha-1} &amp; \\dots &amp; a_1 &amp; a_0 &amp; \\cdots &amp; 0 \\\\ &amp; &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots &amp; \\ddots \\\\ 0 &amp; &amp; \\cdots &amp; 0 &amp; a_{\\alpha-1} &amp; \\dots &amp; a_1 &amp; a_0 \\\\ 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -f &amp; 0 &amp; 0 \\\\ &amp; &amp; \\ddots &amp; &amp; \\ddots &amp; &amp; \\ddots \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -f \\end{bmatrix}.</span></div>

    <p class="text-gray-300">In order to compute the determinant of this matrix, let us denote its <em>i</em>-th column by  <span class="math">C_i</span>  for  <span class="math">0 \\le i \\le 2\\alpha - 2</span> . We perform the determinant-preserving operations</p>

    <p class="text-gray-300"> <span class="math">C_{i+\\alpha} \\leftarrow C_{i+\\alpha} + f \\times C_i</span>  for  <span class="math">i = 0, \\dots, \\alpha - 2</span>  to cancel the bottom-right part of the matrix. This gives:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Syl(h,z^{\\alpha}-f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\begin{vmatrix} \\mathbf{A} & \\mathbf{B} \\\\ \\mathbf{I}_{\\alpha-1} & \\mathbf{0}_{\\alpha-1,\\alpha} \\end{vmatrix},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\mathbf{B} \\in R^{\\alpha \\times \\alpha}</span>  corresponds to the desired matrix. Finally, the determinant of the block matrix is equal to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the  <span class="math">\\alpha=3</span>  case, [26] explicitly expressed the determinant on the right-hand side in terms of f and the coefficients  <span class="math">a_i</span> , then analyzed the number of multiplications in the resulting polynomial. This computation led to a total of 12 multiplications:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{vmatrix} a_0 &amp; fa_2 &amp; fa_1 \\\\ a_1 &amp; a_0 &amp; fa_2 \\\\ a_2 &amp; a_1 &amp; a_0 \\end{vmatrix} = a_2^3 f^2 - 3a_2 a_1 a_0 f + a_1^3 f + a_0^3.</span></div>

    <p class="text-gray-300">This precise number is used in the proof of [26, Theorem 2]. We remark that we can bring the number of multiplications down to 9, by computing</p>

    <p class="text-gray-300"><span class="math-block">c_1 = a_1 f</span> ,  <span class="math">c_2 = a_2 f</span> ,  <span class="math">\\operatorname{Res}(h, z^3 - f) = a_2 c_2^2 + a_1^2 c_1 - a_0 (3a_1 c_2 - a_0^2)</span> .</p>

    <p class="text-gray-300">We use the value 9 in our applications when  <span class="math">\\alpha = 3</span> , yielding a modest constant-factor improvement over the naive counting. In the context of iteRes, recall that these 9 multiplications are over a quotient ring of the form  <span class="math">S_k</span> , each of them corresponding to one standard multiplication followed by a reduction via Algorithm 1.</p>

    <p class="text-gray-300">For larger values of  <span class="math">\\alpha</span> , writing out the determinant symbolically quickly becomes infeasible. Moreover, the common algorithms for computing determinants in  <span class="math">\\mathcal{O}(\\alpha^{\\omega})</span>  perform inversions in the coefficient ring, and are hence not applicable when working over multivariate polynomial rings. A notable exception is the method of [19], which computes the determinant for matrices over <em>univariate</em> polynomial rings, but it is not clear to us whether these techniques can be generalized to the multivariate case. These observations led us to adopt the algorithm presented in Section 4.2 for any  <span class="math">\\alpha &gt; 3</span> .</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">C Round Functions of Selected Primitives</h4>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">C.1 Griffin</h4>

    <p class="text-gray-300">The Griffin permutation works over  <span class="math">\\mathbb{F}_q^t</span> , where  <span class="math">\\alpha</span>  is the smallest integer coprime to q-1. The number of branches t is either chosen to be 3, or a multiple of four. The non-linear layer of Griffin is  <span class="math">(x_0, \\ldots, x_{t-1}) \\mapsto (y_0, \\ldots, y_{t-1})</span> , where each  <span class="math">y_i</span>  is defined by the equations:</p>

    <div class="my-4 text-center"><span class="math-block">y_i := \\begin{cases} x_0^{1/\\alpha} &amp; \\text{if } i = 0 \\\\ x_1^{\\alpha} &amp; \\text{if } i = 1 \\\\ F_2 = x_2 \\cdot (L_2(y_0, y_1, 0)^2 + \\delta_2 \\cdot L_2(y_0, y_1, 0) + \\mu_2) &amp; \\text{if } i = 2 \\\\ F_i = x_i \\cdot (L_i(y_0, y_1, x_{i-1})^2 + \\delta_i \\cdot L_i(y_0, y_1, x_{i-1}) + \\mu_i) &amp; \\text{otherwise,} \\end{cases}</span></div>

    <p class="text-gray-300">where δ<sup>i</sup> , µ<sup>i</sup> ∈ F<sup>q</sup> are constants, and L<sup>i</sup> denote linear functions. The Griffin round applies an invertible t×t matrix and adds round constants after each non-linear layer. One round with t = 4 is depicted in Figure <a href="#page-34-1">1.</a></p>

    <p class="text-gray-300"><img src="_page_34_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-34-1"></span>Fig. 1. Round function of Griffin with t = 4. (Figure from [\\[3\\]](#page-30-4).)</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">C.2 Arion</h4>

    <p class="text-gray-300">The Arion permutation [\\[22\\]](#page-31-3) operates over F t q , where e is the smallest integer coprime to q − 1, and 121 ≤ α ≤ 257 is another integer coprime q − 1. The non-linear layer of Arion is defined as (x0, . . . , xt−1) 7→ (y0, . . . , yt−1}, such that</p>

    <div class="my-4 text-center"><span class="math-block">y_{t-1} = x_{t-1}^{1/\\alpha},</span></div>

    <div class="my-4 text-center"><span class="math-block">y_i = f_i = x_i^e \\cdot g_i(\\sigma_{i,t}) + h_i(\\sigma_{i,t}), \\qquad t - 2 \\ge i \\ge 0,</span></div>

    <p class="text-gray-300">where g<sup>i</sup> and h<sup>i</sup> are univariate polynomial functions of degree 2, and σi,t is the sum of all previously computed inputs and outputs:</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_{i,t} = \\sum_{j=i+1}^{t-1} x_j + y_j(x_0, \\dots, x_{t-1}) .</span></div>

    <p class="text-gray-300">An affine function is applied after each non-linear layer. One round of the Arion permutation is depicted in Figure <a href="#page-35-1">2</a> for t = 4.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">C.3 Rescue</h4>

    <p class="text-gray-300">The Rescue permutation [\\[1\\]](#page-30-1) operates with t branches over Fq, and α is chosen as the smallest integer coprime to q − 1. The round function is depicted in Figure <a href="#page-35-2">3,</a> where the S-box is given by x 7→ x α and S −1 is defined as x 7→ x <sup>1</sup>/α. An MDS matrix and round constants are applied after each S/S<sup>−</sup><sup>1</sup> -layer.</p>

    <p class="text-gray-300"><img src="_page_35_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><strong>Fig. 2.</strong> Round function Arion with t = 4. (Figure from [3].)</p>

    <p class="text-gray-300"><span id="page-35-1"></span><img src="_page_35_Picture_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 3. The round function of Rescue.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">C.4 Anemoi</h3>

    <p class="text-gray-300">The Anemoi families of permutations operate over  <span class="math">\\mathbb{F}_q</span> , where  <span class="math">q=2^n</span>  or q is an odd prime. They take as parameters  <span class="math">\\ell</span> , where the number of branches is  <span class="math">2\\ell</span> ,  <span class="math">\\alpha</span>  in the odd characteristic case, the number of rounds r, and some non-zero field element g. The rounds functions are depicted in Figure 4. The nonlinear mappings  <span class="math">\\mathcal{H}</span>  are depicted in Figure 5.  <span class="math">\\mathcal{M}_x</span>  and  <span class="math">\\mathcal{M}_y</span>  correspond to multiplications by MDS matrices.</p>

    <p class="text-gray-300"><img src="_page_36_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-36-0"></span>Fig. 4. The r-th round of Anemoi, figure taken from [\\[8\\]](#page-30-2).</p>

    <p class="text-gray-300"><img src="_page_36_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-36-1"></span>Fig. 5. The nonlinear layer H of Anemoi. On the left-hand side is the characteristic 2 variant, and on the right-hand side is the odd characteristic variant. Figures taken from [\\[8\\]](#page-30-2).</p>`;
---

<BaseLayout title="Improved Resultant Attack against Arithmetization-Oriented P... (2025/259)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/259
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="improved-resultant-attack-against-arithmetization-oriented-2025" />
  </article>
</BaseLayout>
