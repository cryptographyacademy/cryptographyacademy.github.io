---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/305';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Zero Knowledge Sumcheck and its Applications';
const AUTHORS_HTML = 'Alessandro Chiesa, Michael A.  Forbes, Nicholas Spooner';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Many seminal results in Interactive Proofs (IPs) use algebraic techniques based on low-degree polynomials, the study of which is pervasive in theoretical computer science. Unfortunately, known methods for endowing such proofs with zero knowledge guarantees do not retain this rich algebraic structure.

In this work, we develop algebraic techniques for obtaining zero knowledge variants of proof protocols in a way that leverages and preserves their algebraic structure. Our constructions achieve unconditional (perfect) zero knowledge in the Interactive Probabilistically Checkable Proof (IPCP) model of Kalai and Raz [KR08] (the prover first sends a PCP oracle, then the prover and verifier engage in an Interactive Proof in which the verifier may query the PCP).

Our main result is a zero knowledge variant of the sumcheck protocol [LFKN92] in the IPCP model. The sumcheck protocol is a key building block in many IPs, including the protocol for polynomial-space computation due to Shamir [Sha92], and the protocol for parallel computation due to Goldwasser, Kalai, and Rothblum [GKR15]. A core component of our result is an algebraic commitment scheme, whose hiding property is guaranteed by algebraic query complexity lower bounds [AW09,JKRS09].  This commitment scheme can then be used to considerably strengthen our previous work [BCFGRS16] that gives a sumcheck protocol with much weaker zero knowledge guarantees, itself using algebraic techniques based on algorithms for polynomial identity testing [RS05,BW04].

We demonstrate the applicability of our techniques by deriving zero knowledge variants of well-known protocols based on algebraic techniques. First, we construct zero knowledge IPCPs for NEXP starting with the Multi-prover Interactive Proofs of Babai, Fortnow, and Lund [BFL91]. This result is a direct application of our zero knowledge sumcheck and our algebraic commitment scheme, augmented with the use of \`randomized&#x27; low-degree extensions.

We also construct protocols in a more restricted model where the prover and verifier engage in a standard Interactive Proof with oracle access to a uniformly random low-degree polynomial (soundness holds with respect to any oracle). In this setting we achieve zero knowledge variants of the protocols of Shamir and of Goldwasser, Kalai, and Rothblum.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> zero knowledge &middot; sumcheck &middot; algebraic query complexity &middot; interactive proofs &middot; probabilistically checkable proofs</p>
    </section>

    <p class="text-gray-300">Alessandro Chiesa</p>

    <p class="text-gray-300">Nicholas Spooner</p>

    <p class="text-gray-300">alexch@berkeley.edu UC Berkeley</p>

    <p class="text-gray-300">miforbes@csail.mit.edu Simons Institute for the Theory of Computing</p>

    <p class="text-gray-300">nick.spooner@berkeley.edu University of Toronto and UC Berkeley</p>

    <p class="text-gray-300">April 6, 2017</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Many seminal results in Interactive Proofs (IPs) use algebraic techniques based on low-degree polynomials, the study of which is pervasive in theoretical computer science. Unfortunately, known methods for endowing such proofs with zero knowledge guarantees do not retain this rich algebraic structure.</p>

    <p class="text-gray-300">In this work, we develop algebraic techniques for obtaining zero knowledge variants of proof protocols in a way that leverages and preserves their algebraic structure. Our constructions achieve unconditional (perfect) zero knowledge in the Interactive Probabilistically Checkable Proof (IPCP) model of Kalai and Raz <a href="#page-61-0">[KR08]</a> (the prover first sends a PCP oracle, then the prover and verifier engage in an Interactive Proof in which the verifier may query the PCP).</p>

    <p class="text-gray-300">Our main result is a zero knowledge variant of the sumcheck protocol <a href="#page-62-0">[LFKN92]</a> in the IPCP model. The sumcheck protocol is a key building block in many IPs, including the protocol for polynomial-space computation due to Shamir <a href="#page-62-1">[Sha92]</a>, and the protocol for parallel computation due to Goldwasser, Kalai, and Rothblum <a href="#page-61-1">[GKR15]</a>. A core component of our result is an algebraic commitment scheme, whose hiding property is guaranteed by algebraic query complexity lower bounds <a href="#page-60-0">[AW09;</a> <a href="#page-61-2">JKRS09]</a>. This commitment scheme can then be used to considerably strengthen our previous work <a href="#page-60-1">[BCFGRS16]</a> that gives a sumcheck protocol with much weaker zero knowledge guarantees, itself using algebraic techniques based on algorithms for polynomial identity testing <a href="#page-62-2">[RS05;</a> <a href="#page-60-2">BW04]</a>.</p>

    <p class="text-gray-300">We demonstrate the applicability of our techniques by deriving zero knowledge variants of well-known protocols based on algebraic techniques. First, we construct zero knowledge IPCPs for NEXP starting with the Multi-prover Interactive Proofs of Babai, Fortnow, and Lund <a href="#page-60-3">[BFL91]</a>. This result is a direct application of our zero knowledge sumcheck and our algebraic commitment scheme, augmented with the use of 'randomized' low-degree extensions.</p>

    <p class="text-gray-300">We also construct protocols in a more restricted model where the prover and verifier engage in a standard Interactive Proof with oracle access to a uniformly random low-degree polynomial (soundness holds with respect to <em>any</em> oracle). In this setting we achieve zero knowledge variants of the protocols of Shamir and of Goldwasser, Kalai, and Rothblum.</p>

    <p class="text-gray-300">Keywords: zero knowledge; sumcheck; algebraic query complexity; probabilistically checkable and interactive proofs</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">3</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1<br>Prior techniques for achieving zero knowledge<br>1.2<br>Our goal: algebraic techniques for zero knowledge<br>1.3<br>Main result: a zero knowledge sumcheck</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3<br>4<br>4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4<br>Applications: delegating computation in zero knowledge</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Techniques</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.1<br>An algebraic approach for zero knowledge in the BFL protocol<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.2<br>Algebraic commitments from algebraic query complexity lower bounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.3<br>A zero knowledge sumcheck protocol<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.4<br>Challenges: handling recursion</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5<br>Sum-product circuits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Roadmap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Preliminaries</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.1<br>Basic notations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.2<br>Sampling partial sums of random low-degree polynomials</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3<br>Interactive probabilistically checkable proofs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.4<br>Zero knowledge for Interactive PCPs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5<br>Sumcheck protocol and its zero knowledge variant</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algebraic query complexity of polynomial summation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Zero knowledge sumcheck from algebraic query lower bounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1<br>Step 1<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.2<br>Step 2<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Zero knowledge for non-deterministic exponential time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Delegating sum-product computations</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.1<br>Intuition for definition<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.2<br>Sum-product formulas</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.3<br>Sum-product circuits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Zero knowledge sum-product protocols</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.1<br>The case of sum-product evaluation<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.2<br>The case of sum-product satisfaction</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 Zero knowledge for polynomial space</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11 Zero knowledge for the evaluation of low-depth circuits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.1 Notations for layered arithmetic circuits<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.2 Sum-product subcircuits and oracle inputs</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.3 Sum-product subcircuits for layered arithmetic circuits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.4 Sum-product subcircuits for small-space Turing machines</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.5 Proof of Theorem 11.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Acknowledgments</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algebraic query complexity of polynomial summation: details</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A.1<br>Proof of Theorem 5.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A.2<br>Proof of Corollary 5.3<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A.3<br>Upper bounds<br></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Proof of Theorem 7.2 via sum-product circuits</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">References</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">The notion of <em>Interactive Proofs</em> (IPs) [BM88; GMR89] is fundamental in Complexity Theory and Cryptography. An Interactive Proof for a language  <span class="math">\\mathscr{L}</span>  is a protocol between a probabilistic polynomial-time <em>verifier</em> and a resource-unbounded <em>prover</em> that works as follows: given a common input x, the prover and verifier exchange some number of messages and then the verifier either accepts or rejects. If x is in  <span class="math">\\mathscr{L}</span>  then the verifier always accepts; if instead x is not in  <span class="math">\\mathscr{L}</span>  then the verifier rejects with high probability, regardless of the prover's actions. The seminal results of Lund, Fortnow, Karloff, and Nisan [LFKN92] and Shamir [Sha92] demonstrate the surprising expressiveness of Interactive Proofs, in particular showing that every language decidable in polynomial space has an Interactive Proof.</p>

    <p class="text-gray-300">Research on IPs has recently focused on new and more refined goals, motivated by the paradigm of <em>delegation of computation</em>, in which a resource-limited verifier receives the help of a resource-rich prover to check the output of an expensive (but tractable) computation. In this setting bounding the complexity of the honest prover is important. While every IP protocol has a polynomial-space prover, this prover may run in superpolynomial time, even if the protocol is for a tractable language. Recent work has focused on <em>doubly-efficient</em> IPs, where the prover is efficient (it runs in polynomial time) and the verifier is highly efficient (it runs in, say, quasilinear time). Doubly-efficient IPs can be achieved, with various tradeoffs, for many types of computation: languages decidable by uniform circuits of polylogarithmic depth [GKR15]; languages decidable in polynomial time and bounded-polynomial space [RRR16]; and languages decidable by conjunctions of polynomially-many 'local' conditions [RG17].</p>

    <p class="text-gray-300">A key building block in <em>all</em> of these protocols is the <em>sumcheck protocol</em> [LFKN92], which is an Interactive Proof for claims of the form &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) = 0</span> &quot;, where H is a subset of a finite field  <span class="math">\\mathbb{F}</span>  and F is an m-variate polynomial over  <span class="math">\\mathbb{F}</span>  of small individual degree. The use of sumcheck imbues the aforementioned protocols with an algebraic structure, where the verifier <em>arithmetizes</em> a boolean problem into a statement about low-degree polynomials, which can then be checked via the sumcheck protocol. This algebraic structure is not only elegant, but also very useful. Indeed, this structure is crucial not only for highly-efficient software and hardware systems for delegating computation [CMT12; TRMP12; Tha13; Tha15; WHGSW16; WJBSTWW17] but also for a diverse set of compelling theoretical applications such as memory delegation [CKLR11], refereed delegation [CRR13], IPs of proximity [RVW13], and many others.</p>

    <p class="text-gray-300">Despite these subsequent works demonstrating the flexibility of sumcheck to accommodate additional desirable properties, the zero knowledge [GMR89] properties of sumcheck have not been explored. This is surprising because zero knowledge, the ability of the prover to establish the validity of an assertion while revealing no insight into its proof, is highly desirable for the cryptographic applications of Interactive Proofs. Unfortunately, achieving zero knowledge is nontrivial because the sumcheck protocol reveals the results of intermediate computations, in particular the partial sums  <span class="math">\\sum_{\\vec{\\alpha} \\in H^{m-i}} F(c_1, \\ldots, c_i, \\vec{\\alpha})</span>  for  <span class="math">c_1, \\ldots, c_i \\in \\mathbb{F}</span>  chosen by the verifier. These partial sums are in general #P-hard to compute so they convey significant additional knowledge to the verifier.</p>

    <p class="text-gray-300">The goal of this work is to enlarge the existing algebraic toolkit based on low-degree polynomials and use these tools to provide a native extension of the sumcheck protocol that is zero knowledge, and to explore applications of such an extension. As we discuss shortly, however, we cannot expect to do so within the model of Interactive Proofs.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Prior techniques for achieving zero knowledge</h3>

    <p class="text-gray-300">We briefly describe why existing methods fall short of our goal, which is making the sumcheck protocol zero knowledge in an algebraic way. A seminal result in cryptography says that if one-way functions exist then every language having an IP also has a <em>computational</em> zero knowledge IP [GMR89; IY87; BGGHKMR88]; this assumption is 'minimal' in the sense that if one-way functions do not exist then computational zero knowledge IPs capture only &quot;average-case&quot; BPP [Ost91; OW93]. While powerful, such results are unsatisfactory from our perspective. First, cryptography adds significant efficiency overheads, especially when used in a non-blackbox way as these results do. Second, the results rely on transformations that erase all the algebraic structure of the underlying protocols. While these limitations can be mitigated by using cryptography that leverages some of the underlying structure [CD98], the costs incurred by the use of cryptography remain significant. Ideally, we wish to <em>avoid</em> intractability assumptions.</p>

    <p class="text-gray-300">Unfortunately, this is impossible to achieve under standard complexity assumptions, because Interactive Proofs that are <em>statistical</em> zero knowledge are limited to languages in  <span class="math">\\mathbf{AM} \\cap \\mathbf{coAM}</span>  [For87; AH91]. Such languages (conjecturally) do not even include  <span class="math">\\mathbf{NP}</span> , so that we cannot even hope to achieve a 'zero knowledge sumcheck protocol' (which would give  <span class="math">\\#\\mathbf{P}</span> ).</p>

    <p class="text-gray-300">The quest for zero knowledge without relying on intractability assumptions led to the formulation of <em>Multi-prover Interactive Proofs</em> (MIPs) [BGKW88], where the verifier exchanges messages with two or more non-communicating provers. Groundbreaking results establish that MIPs are very powerful: all (and only) languages decidable in non-deterministic exponential time have MIPs [BFL91] and, in fact, even <em>perfect</em> zero knowledge MIPs [BGGHKMR88; DFKNS92]. Similar results hold even for the related model of <em>Probabilistically Checkable Proofs</em> (PCPs) [FRS88; BFLS91; FGLSS96; AS98; ALMSS98], where the prover outputs a proof string that the verifier can check by reading only a few randomly-chosen locations. Namely, all (and only) languages decidable in non-deterministic exponential time have PCPs [BFLS91] and, in fact, even <em>statistical</em> zero knowledge PCPs [KPT97; IMSX15].</p>

    <p class="text-gray-300">However, while information-theoretic, the aforementioned works rely on transformations that, once again, discard the rich algebraic structure of the underlying protocols. Thus, zero knowledge in this setting continues to be out of reach of simple and elegant algebraic techniques.</p>

    <p class="text-gray-300">Our goal is to develop information-theoretic techniques for achieving zero knowledge in a way that leverages, and preserves, the algebraic structure of the sumcheck protocol and other protocols that build on it. An additional goal is to preserve the simplicity and elegance of these foundational protocols.</p>

    <p class="text-gray-300">Yet, as discussed, we cannot hope to do so with Interactive Proofs, and so we work in another model. We choose to work in a model that combines features of both Interactive Proofs and PCPs: the <em>Interactive PCP</em> (IPCP) model of Kalai and Raz [KR08]. The prover first sends to the verifier a long string as a PCP oracle, after which the prover and verifier engage in an Interactive Proof. The verifier is free at any point to query the PCP oracle at locations of its choice, and the verifier only pays for the number of queries it makes, so that exponentially-large PCP oracles are allowed.</p>

    <p class="text-gray-300">Kalai and Raz [KR08] show that the IPCP model has efficiency advantages over both PCPs and IPs (individually). Goyal, Ishai, Mahmoody, and Sahai [GIMS10] construct efficient zero knowledge IPCPs, but their techniques mirror those for zero knowledge PCPs and, in particular, are not algebraic.</p>

    <p class="text-gray-300">One can think of the IPCP model as lying somewhere 'in between' the IP and MIP models. Indeed, it is equivalent to a (2-prover) MIP where one of the provers is stateless (its answers do not depend on the verifier's prior messages or queries). This means that soundness is easier to achieve for an IPCP than for an MIP. Zero knowledge, however, is more difficult for an IPCP than for an MIP, because the stateless prover cannot choose which queries it will answer.</p>

    <p class="text-gray-300">A significant advantage of the IPCP model over the MIP model is that one can easily compile (public-coin) IPCPs into cryptographic proofs via transformations that preserve zero knowledge, while only making a black-box use of cryptography. For example, using collision-resistant functions one can obtain public-coin interactive arguments by extending ideas of [Kil92; IMSX15]; also, using random oracles one can obtain publicly-verifiable non-interactive arguments via [BCS16] (extending the Fiat&ndash;Shamir paradigm [FS86] and Micali's &quot;CS proofs&quot; [Mic00]). In contrast, known transformations for MIPs yield private-coin arguments [BC12], or do not preserve zero knowledge [KRR14].</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Main result: a zero knowledge sumcheck</h3>

    <p class="text-gray-300">Our main result is a zero knowledge analogue of the sumcheck protocol [LFKN92], a key building block in many protocols. We now informally state and discuss this result, and in the next sub-section we discuss its applications.</p>

    <p class="text-gray-300">The goal of the sumcheck protocol is to efficiently verify claims of the form &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) = 0</span> &quot;, where H is a subset of a finite field  <span class="math">\\mathbb F</span>  and F is an m-variate polynomial over  <span class="math">\\mathbb F</span>  of low individual degree. As the sumcheck protocol is often used in situations where the polynomial F is only implicitly defined (including this paper), it is helpful to adopt the viewpoint of Meir [Mei13], regarding the sumcheck protocol as a <em>reduction</em> from the summation &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) = 0</span> &quot; to an evaluation &quot; <span class="math">F(\\vec{c}) = b</span> &quot;; the latter can be checked directly by the verifier or by another protocol. The verifier in this reduction does not need any information about F, aside from knowing that F has small individual degree. The completeness property of the reduction is that if the summation claim is true, then so is the evaluation claim with probability one. Its soundness property is that if the summation claim is false, then so is the evaluation claim with high probability.</p>

    <p class="text-gray-300">The theorem below states the existence of sumcheck protocol in the above sense that works in the IPCP model and is zero knowledge, which means that a verifier does not learn any information beyond the fact that F sums to 0 on  <span class="math">H^m</span>  (and, in our case, a single evaluation of F). As usual, this means that we establish an efficient procedure for simulating</p>

    <p class="text-gray-300">the interaction of a (possibly malicious) verifier with the prover, where the simulator only uses the knowledge of the sum of F on H<sup>m</sup> (and a single evaluation of F) but otherwise has no actual access to the prover (or F). This interaction is a random variable depending on the randomness of both the verifier and the prover, and we show that the simulated interaction perfectly replicates this random variable.</p>

    <p class="text-gray-300">Theorem 1.1 (Informal version of Theorem <a href="#page-22-0">6.4)</a>. <em>There exists an IPCP for sumcheck with the following zero knowledge guarantee: the view of any probabilistic polynomial-time verifier in the protocol can be perfectly and efficiently simulated by a simulator that makes only a single query to</em> F<em>. Moreover, we do not require the full power of the IPCP model: the honest prover's PCP consists only of a random multi-variate polynomial over</em> F <em>of small individual degree.</em></p>

    <p class="text-gray-300">Our result significantly strengthens the IPCP for sumcheck of <a href="#page-60-1">[BCFGRS16]</a> (co-authored by this paper's authors), which is only zero knowledge with respect to a simulator which requires <em>unrestricted</em> query access to F. Namely, in order to simulate a verifier's view, their simulator must make a number of queries to F that equals the number of queries to the PCP oracle made by the verifier. This zero knowledge guarantee is weaker than the above because a malicious verifier can make an <em>arbitrarily-large</em> (but polynomial) number of queries to the PCP oracle. However, this weaker guarantee suffices in some cases, such as in the previous work <a href="#page-60-1">[BCFGRS16]</a>.</p>

    <p class="text-gray-300">Perhaps more damaging is that when using this 'weakly zero knowledge' sumcheck protocol recursively (as required in applications), we would incur an <em>exponential blowup</em>: each simulated query recursively requires further queries to be simulated. In contrast, the 'strongly zero knowledge' sumcheck protocol that we achieve only requires the simulator to make a single query to F regardless of the malicious verifier's runtime, both providing a stronger zero knowledge guarantee and avoiding any exponential blow-up.</p>

    <p class="text-gray-300">An important property of our sumcheck protocol (which also holds for <a href="#page-60-1">[BCFGRS16]</a>), is that it suffices for the honest prover to send as an oracle a uniformly random polynomial of a certain arity and degree. This brings the result 'closer to IP', in the sense that while IPCP captures all of NEXP, only languages in PSPACE have IPCPs (with perfect completeness) where the honest prover behaves in this way. The same property holds for some of our applications.</p>

    <p class="text-gray-300">Algebraic commitments. As detailed in Section <a href="#page-7-0">2,</a> a key ingredient of our result is a commitment scheme based on algebraic techniques. That is, the prover wishes to commit to a value b &isin; F, and to do so sends a PCP oracle to the verifier. To then reveal (decommit) b, the prover and verifier engage in an Interactive Proof. We show that the sumcheck protocol naturally yields such a commitment scheme, where the PCP oracle is simply a random low-degree polynomial R such that P ~&alpha;&isin;H<sup>m</sup> R(~&alpha;) = b. The soundness guarantee of the sumcheck protocol shows that this commitment scheme is binding, so that the prover cannot &quot;reveal&quot; a value other than the correct b. To establish the hiding property, which states that the verifier cannot learn anything about b before the prover reveals it, we leverage lower bounds on the algebraic query complexity of polynomial summation, previously studied for completely different reasons <a href="#page-60-0">[AW09;</a> <a href="#page-61-2">JKRS09]</a>.</p>

    <p class="text-gray-300">As our commitments are themselves defined by low degree polynomials, they are 'transparent' to low degree testing. That is, in various protocols the prover sends to the verifier the evaluation table of a low-degree polynomial as a PCP oracle, and the verifier ensures that this evaluation table is (close to) low degree via low degree testing. In our zero knowledge setting, we need the prover to hide the evaluation table under a commitment (to be revealed selectively), and yet still allow the verifier to check that the underlying evaluation table represents a low-degree polynomial. Our commitments naturally have this property due to their algebraic structure, which we exploit in our applications discussed below.</p>

    <p class="text-gray-300">Overall, the methods of this paper not only significantly deviate from traditional methods for achieving zero knowledge but also further illustrate the close connection between zero knowledge and Algebraic Complexity Theory, the theory of efficient manipulations of algebraic circuits and low-degree polynomials. This connection was first seen in our prior work developing the 'weakly zero knowledge sumcheck' of <a href="#page-60-1">[BCFGRS16]</a>, used here as a subroutine. Indeed, this subroutine derives its zero-knowledge guarantee from an efficient algorithm for adaptively simulating random low-degree polynomials <a href="#page-60-1">[BCFGRS16;</a> <a href="#page-60-2">BW04]</a>. This algorithm itself relies on deterministic algorithms for polynomial identity testing of certain restricted classes of algebraic circuits <a href="#page-62-2">[RS05]</a>. We believe that it is an exciting research direction to further investigate this surprising connection, and to further broaden the set of information-theoretic algebraic techniques that are useful towards zero knowledge.</p>

    <p class="text-gray-300">The original sumcheck protocol (without zero knowledge) has many applications, including to various methods of delegating computation. Our zero knowledge sumcheck protocol can be used to obtain zero knowledge analogues of foundational results in this area: we achieve natural zero knowledge extensions of the first construction of PCPs/MIPs <a href="#page-60-3">[BFL91;</a> <a href="#page-60-11">BFLS91]</a>, Shamir's protocol <a href="#page-62-1">[Sha92]</a>, and doubly-efficient Interactive Proofs for low-depth circuits <a href="#page-61-1">[GKR15]</a>.</p>

      <h4 id="sec-1.4.1" class="text-lg font-semibold mt-6">1.4.1 Delegating non-deterministic exponential time</h4>

    <p class="text-gray-300">One of the earliest and most influential applications of the sumcheck protocol is the construction of Multi-prover Interactive Proofs for NEXP due to Babai, Fortnow, and Lund <a href="#page-60-3">[BFL91]</a>; the same construction also demonstrated the power of low-degree testing as a tool for checking arbitrary computations, another highly influential insight. The subsequent improvements by Babai, Fortnow, Levin, and Szegedy <a href="#page-60-11">[BFLS91]</a> led to the formulation and the study of <em>Probabilistically-Checkable Proofs</em> <a href="#page-60-11">[BFLS91;</a> <a href="#page-61-10">FGLSS96]</a> and then the celebrated PCP Theorem <a href="#page-60-12">[AS98;</a> <a href="#page-60-13">ALMSS98]</a>.</p>

    <p class="text-gray-300">We show how, by using our zero knowledge sumcheck protocol, we can obtain a zero knowledge analogue of the classical constructions of <a href="#page-60-3">[BFL91;</a> <a href="#page-60-11">BFLS91]</a>.</p>

    <p class="text-gray-300">Theorem 1.2 (Informal version of Theorem <a href="#page-27-1">7.2)</a>. NEXP <em>has perfect zero knowledge Interactive PCPs.</em></p>

    <p class="text-gray-300">Our construction extends the protocol of <a href="#page-60-3">[BFL91;</a> <a href="#page-60-11">BFLS91]</a>, which can be viewed as an IPCP that is later 'compiled' into an MIP or a PCP. This protocol reduces the NEXP-complete problem of determining the satisfiability of a 'succinct' 3CNF, to testing whether there exists a low-degree polynomial satisfying an (exponentially large) set of constraints. A polynomial satisfying these constraints is necessarily a low-degree extension of a satisfying assignment, and thus implies the existence of such an assignment. The prover sends such a polynomial as an oracle, which the verifier then low-degree tests. That the constraints are satisfied can be checked using the sumcheck protocol.</p>

    <p class="text-gray-300">To make this protocol zero knowledge we need to ensure that the oracle hides the original witness. We achieve this by sending not the low-degree extension itself but an algebraic commitment to it. The zero knowledge sumcheck then reduces the problem of checking the constraint on this witness to a single evaluation point of the low degree extension. However, this itself is not zero knowledge as evaluations of the low-degree extension can reveal information about the witness, especially if this evaluation is over the interpolating set H<sup>m</sup>. Thus, our construction exploits the fact that the sumcheck protocol works for <em>any</em> low-degree extension of the witness, and not just the one of minimal degree. Thus, the prover will instead send (the commitment to) a randomly sampled extension of the witness of slightly higher (but still constant) individual degree. The evaluations of this polynomial will (outside the interpolating set H<sup>m</sup>) be O(1)-wise independent. As the sumcheck reduction will reduce to an evaluation point outside H<sup>m</sup> with high probability, the prover can then decommit the evaluation at this point to complete the sumcheck protocol without revealing any non-trivial information. We discuss this construction in more detail in Section <a href="#page-7-1">2.1.</a></p>

      <h4 id="sec-1.4.2" class="text-lg font-semibold mt-6">1.4.2 Delegating polynomial space</h4>

    <p class="text-gray-300">The above result shows that a powerful prover can convince a probabilistic polynomial-time verifier of NEXP statements in perfect zero knowledge in the IPCP model. Now we turn our attention to protocols where the honest prover need not be a NEXP machine. One such protocol, due to Shamir <a href="#page-62-1">[Sha92]</a>, provides an Interactive Proof for the PSPACE-complete True Quantified Boolean Formula (TQBF) problem. This protocol is a more sophisticated application of the sumcheck protocol because sumcheck is applied <em>recursively</em>.</p>

    <p class="text-gray-300">We aim to obtain zero knowledge analogues for these types of more complex protocols as well but now, to tackle the greater complexity, we proceed in two steps. First, we design a generic framework called <em>sum-product circuits</em> (which we believe to be of independent interest) that can express in a unified way a large class of 'sumcheck-based Interactive Proofs', such as Shamir's protocol. Second, we show how to use our zero knowledge sumcheck protocol to obtain zero knowledge analogues of these, and thus also for Shamir's protocol. We discuss this further in Section <a href="#page-12-0">2.5.</a></p>

    <p class="text-gray-300">As before, the resulting protocols are within the IPCP model. However, a key feature of these protocols that differentiates them from our result for NEXP is that the prover <em>does not need the full power of IPCPs</em>: it suffices for the honest prover to send a PCP oracle that is the evaluation table of a random low-degree polynomial. Of course, soundness will continue to hold against any malicious prover that uses the PCP oracle in arbitrary ways.</p>

    <p class="text-gray-300">Theorem 1.3 (Informal version of Theorem <a href="#page-44-1">10.2)</a>. PSPACE <em>has perfect zero knowledge Interactive PCPs, where the honest prover sends a random low-degree polynomial as the oracle.</em></p>

    <p class="text-gray-300">As discussed above, any language having an IPCP where the honest prover sends a random low-degree polynomial (and achieves perfect completeness) can be decided in PSPACE. In contrast, in the general case, deciding languages having IPCPs is NEXP-hard. This result shows that moreover, all that is required to achieve unconditional zero knowledge for PSPACE is the ability to send a uniformly random polynomial as an oracle.</p>

      <h4 id="sec-1.4.3" class="text-lg font-semibold mt-6">1.4.3 Delegating low-depth circuits</h4>

    <p class="text-gray-300">The doubly-efficient Interactive Proofs for low-depth circuits due to Goldwasser, Kalai, and Rothblum <a href="#page-61-1">[GKR15]</a> are another landmark result that makes a recursive use of the sumcheck protocol. Their construction can be viewed as a 'scaled down' version of Shamir's protocol where the prover is efficient and the verifier is highly efficient.</p>

    <p class="text-gray-300">We obtain a zero knowledge analogue of this protocol; again it suffices for the honest prover to send a random lowdegree polynomial as the oracle (and soundness holds against any oracle). We do so by showing how the computation of low-depth circuits can be reduced to a corresponding sum-product circuit, by following the arithmetization in <a href="#page-61-1">[GKR15]</a>; then we rely on our zero knowledge results for sum-product circuits, mentioned above.</p>

    <p class="text-gray-300">The protocol of <a href="#page-61-1">[GKR15]</a> is an IP for delegating certain <em>tractable</em> computations: the evaluation of log-space uniform NC (circuits of polynomial size and polylogarithmic depth). The prover runs in polynomial time, while the verifier runs in quasilinear time and logarithmic space. But what does achieving zero knowledge mean in this case? If the simulator can run in polynomial time, then it can trivially simulate the verifier's view by simply running the honest prover. We thus need to consider a fine-grained notion of zero knowledge, by analyzing in more detail the overhead incurred by the simulator with respect to the malicious verifier's running time. This reckoning is similar to <a href="#page-60-16">[BRV17]</a>, who study zero knowledge for Interactive Proofs of Proximity, and is a relaxation of <em>knowledge tightness</em> <a href="#page-61-15">[Gol01,</a> Section 4.4.4.2].</p>

    <p class="text-gray-300">Concretely, we show that the running time of our simulator is a fixed (and small) polynomial in the verifier's running time, with only a polylogarithmic dependence on the size of the circuit. For example, the view of a malicious verifier running in time, say, O(n 2 ) can be simulated in time O&tilde;(n 6 ). If the circuit has size O(n 8 ), then the zero knowledge guarantee is meaningful because the simulator is not able to evaluate the circuit.</p>

    <p class="text-gray-300">Theorem 1.4 (Informal version of Theorem <a href="#page-47-1">11.1)</a>. <em>Log-space uniform</em> NC <em>has perfect zero knowledge Interactive PCPs, where the honest prover sends a random low-degree polynomial as the oracle, and the verifier runs in quasilinear time and logarithmic space. The simulator overhead is a small polynomial: the view of a verifier running in time</em> T <em>can be simulated in time</em> T 3 &middot; polylog(n)<em>.</em></p>

    <p class="text-gray-300">An interesting open problem is whether the simulator overhead can be reduced to T &middot; polylog(n), as required in the (quite strict) definition given in <a href="#page-61-15">[Gol01,</a> Section 4.4.4.2]. It seems that our techniques are unlikely to achieve this because they depend on solving systems of linear equations in &Omega;(T) variables.</p>

    <p class="text-gray-300">Finally, a property in <a href="#page-61-1">[GKR15]</a> that has been very useful in subsequent work is that the verifier only needs to query a single point in the low-degree extension of its input. In this case, the verifier runs in polylogarithmic time and logarithmic space. Our zero knowledge analogue retains these properties. Additionally, in this setting the size of the circuit is subexponential in the running time of the verifier. Our zero knowledge guarantee then implies that we obtain zero knowledge under the standard (not fine-grained) definition.</p>

    <p class="text-gray-300">We summarize the techniques underlying our contributions. We begin in Section 2.1 by recalling the protocol of Babai, Fortnow, and Lund, in order to explain its sources of information leakage and how one could prevent them via algebraic techniques. This discussion motivates the goal of an <em>algebraic</em> commitment scheme, described in Section 2.2. Then in Section 2.3 we explain how to use this tool to obtain our main result, a zero knowledge sumcheck protocol.</p>

    <p class="text-gray-300">The rest of the section is then dedicated to explaining how to achieve our other applications, which involve achieving zero knowledge for <em>recursive</em> uses of the sumcheck protocol. First we explain in Section 2.4 what are the challenges that arise with regard to zero knowledge in recursive invocations of the sumcheck protocol, such as in the protocol of Shamir. Then in Section 2.5 we describe the framework of sum-product circuits, and the techniques within it that allows us to achieve zero knowledge for the protocols of Shamir and of Goldwasser, Kalai, and Rothblum.</p>

    <p class="text-gray-300">We recall the protocol of Babai, Fortnow, and Lund [BFL91] ('BFL protocol'), in order to explain its sources of information leakage and how one could prevent them via algebraic techniques. These are the ideas that underlie our algebraic construction of an unconditional (perfect) zero knowledge IPCP for <strong>NEXP</strong> (see Section 1.4.1).</p>

    <p class="text-gray-300">The BFL protocol, and why it leaks. The O3SAT problem is the following NEXP-complete problem: given a boolean formula B, does there exist a boolean function A such that</p>

    <p class="text-gray-300"><span class="math">$B(z, b_1, b_2, b_3, A(b_1), A(b_2), A(b_3)) = 0</span>$
for all  <span class="math">z \\in \\{0, 1\\}^r, b_1, b_2, b_3 \\in \\{0, 1\\}^s</span> ?</p>

    <p class="text-gray-300">The BFL protocol constructs an IPCP for O3SAT and later converts it to an MIP. Only the first step is relevant for us. In the BFL protocol, the honest prover first sends a PCP oracle  <span class="math">\\hat{A} \\colon \\mathbb{F}^s \\to \\mathbb{F}</span>  that is the unique multilinear extension (in some finite field  <span class="math">\\mathbb{F}</span> ) of a valid witness  <span class="math">A \\colon \\{0,1\\}^s \\to \\{0,1\\}</span> . The verifier must check that (a)  <span class="math">\\hat{A}</span>  is a boolean function on  <span class="math">\\{0,1\\}^s</span> , and (b)  <span class="math">\\hat{A}</span> 's restriction to  <span class="math">\\{0,1\\}^s</span>  is a valid witness for B. To do these checks, the verifier arithmetizes B into an arithmetic circuit  <span class="math">\\hat{B}</span> , and reduces the checks to conditions that involve  <span class="math">\\hat{A}</span> ,  <span class="math">\\hat{B}</span> , and other low-degree polynomials. A technique of [BFLS91] allows the verifier to 'bundle' all of these conditions into a low-degree polynomial f such that (with high probability over the choice of f) the conditions hold if and only if f sums to f0 on f1, f2, f3. The verifier checks that this is the case via a sumcheck protocol with the prover. The soundness of the sumcheck protocol depends on the PCP oracle being the evaluation of a low-degree polynomial; the verifier checks this using a low-degree test.</p>

    <p class="text-gray-300">We see that the BFL protocol is <em>not</em> zero knowledge for two reasons: (i) the verifier has oracle access to  <span class="math">\\hat{A}</span>  and, in particular, to the witness A; (ii) the prover's messages during the sumcheck protocol leak further information about A (namely, hard-to-compute partial sums of f, which itself depends on A).</p>

    <p class="text-gray-300">A blueprint for zero knowledge. We now describe the 'blueprint' for an approach to achieve zero knowledge in the BFL protocol. The prover does not send  <span class="math">\\hat{A}</span>  directly but instead a <em>commitment</em> to it. After this, the prover and verifier engage in a sumcheck protocol with suitable zero knowledge guarantees; at the end of this protocol, the verifier needs to evaluate f at a point of its choice, which involves evaluating  <span class="math">\\hat{A}</span>  at three points. Now the prover reveals the requested values of  <span class="math">\\hat{A}</span> , without leaking any information beyond these, so that the verifier can perform its check. We explain how these ideas motivate the need for certain algebraic tools, which we later obtain and use to instantiate our approach.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) Randomized low-degree extension. Even if the prover reveals only three values of  <span class="math">\\hat{A}</span> , these may still leak information about A. We address this problem via a randomized low-degree extension. Indeed, while the prover in the BFL protocol sends the unique multilinear extension of A, one can verify that any extension of A of sufficiently low degree also works. We exploit this flexibility as follows: the prover randomly samples  <span class="math">\\hat{A}</span>  in such a way that any three evaluations of  <span class="math">\\hat{A}</span>  do not reveal any information about A. Of course, if any of these evaluations is within  <span class="math">\\{0,1\\}^s</span> , then no extension of A has this property. Nevertheless, during the sumcheck protocol, the prover can ensure that the verifier chooses only evaluations outside of  <span class="math">\\{0,1\\}^s</span>  (by aborting if the verifier deviates), which incurs only a small increase in the soundness error. With this modification in place, it suffices for the prover to let  <span class="math">\\hat{A}</span>  be a random degree-4 extension of A: by a dimensionality argument, any 3 evaluations outside of  <span class="math">\\{0,1\\}^s</span>  are now independent and uniformly random in  <span class="math">\\mathbb{F}</span> . Remarkably, we are thus able to reduce a claim about A to a claim which contains no information about A.</li>
      <li>(2) Low-degree testing the commitment. The soundness of the sumcheck protocol relies on f having low degree, or at least being close to a low-degree polynomial. This in turn depends on the PCP oracle  <span class="math">\\hat{A}</span>  being close to a low-degree</li>
    </ul>

    <p class="text-gray-300">polynomial. If the prover sends  <span class="math">\\hat{A}</span> , the verifier can simply low-degree test it. However, if the prover sends a commitment to  <span class="math">\\hat{A}</span> , then it is not clear what the verifier should do. One option would be for the prover to reveal <em>more</em> values of  <span class="math">\\hat{A}</span>  (in addition to the aforementioned three values), in order to enable the verifier to conduct its low-degree test on  <span class="math">\\hat{A}</span> . The prover would then have to ensure that revealing these additional evaluations is 'safe' by increasing the amount of independence among values in  <span class="math">\\hat{A}</span>  (while still restricting the verifier to evaluations outside of  <span class="math">\\{0,1\\}^s</span> ), which would lead to a blowup in the degree of  <span class="math">\\hat{A}</span>  that is proportional to the number of queries that the verifier wishes to make. For the low-degree test to work, however, the verifier <em>must</em> see more evaluations than the degree. In sum, this circularity is inherent. To solve this problem, we will design an 'algebraic' commitment scheme that is <em>transparent to low-degree tests</em>: the verifier can perform a low-degree test on the commitment itself (without the help of the prover), which will ensure access to a  <span class="math">\\hat{A}</span>  that is low-degree. We discuss this further in Section 2.2.</p>

    <p class="text-gray-300">(3) Sumcheck in zero knowledge. We need a sumcheck protocol where the prover's messages leak little information about f. The prior work in [BCFGRS16] achieves an IPCP for sumcheck that is 'weakly' zero knowledge: any verifier learns at most one evaluation of f for each query it makes to the PCP oracle. If the verifier could evaluate f by itself, as was the case in that paper, this guarantee would suffice for zero knowledge. In our setting, however, the verifier <em>cannot</em> evaluate f by itself because f is (necessarily) hidden behind the algebraic commitment.</p>

    <p class="text-gray-300">One approach to compensate would be to further randomize  <span class="math">\\hat{A}</span>  by letting  <span class="math">\\hat{A}</span>  be a random extension of A of some well-chosen degree d. We are limited to d of polynomial size because the honest verifier's running time is  <span class="math">\\Omega(d)</span> . But this means that a polynomial-time malicious verifier, participating in the protocol of [BCFGRS16] and making  <span class="math">d^2</span>  queries to the PCP oracle, could learn information about A.</p>

    <p class="text-gray-300">We resolve this by relying on more algebraic techniques, achieving an IPCP for sumcheck with a much stronger zero knowledge guarantee (see Theorem 1.1): any malicious verifier that makes polynomially-many queries to the PCP oracle learns only a <em>single</em> evaluation of f. This suffices for zero knowledge in our setting: learning one evaluation of f implies learning only three evaluations of  <span class="math">\\hat{A}</span> , which can be made 'safe' if  <span class="math">\\hat{A}</span>  is chosen to be a random extension of A of high-enough degree. Our sumcheck protocol uses as building blocks both our algebraic commitment scheme and the [BCFGRS16] sumcheck; we summarize its construction in Section 2.3.</p>

    <p class="text-gray-300"><strong>Remark 2.1.</strong> Kilian, Petrank, and Tardos [KPT97] construct PCPs for <strong>NEXP</strong> that are statistical zero knowledge, via a combinatorial construction that makes black-box use of the PCP Theorem. Our modification of the BFL protocol achieves a perfect zero knowledge IPCP via algebraic techniques, avoiding the use of the PCP Theorem.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Algebraic commitments from algebraic query complexity lower bounds</h3>

    <p class="text-gray-300">We describe how the sumcheck protocol can be used to construct an information-theoretic commitment scheme that is 'algebraic', in the IPCP model. (Namely, an algebraic <em>interactive locking scheme</em>; see Remark 2.2 below.) The prover commits to a message by sending to the verifier a PCP oracle that perfectly hides the message; subsequently, the prover can reveal positions of the message by engaging with the verifier in an Interactive Proof, whose soundness guarantees statistical binding. A key algebraic property that we rely on is that the commitment is 'transparent' to low-degree tests.</p>

    <p class="text-gray-300">Committing to an element. We first consider the simple case of committing to a single element a in  <span class="math">\\mathbb{F}</span> . Let k be a security parameter, and set  <span class="math">N:=2^k</span> . Suppose that the prover samples a random B in  <span class="math">\\mathbb{F}^N</span>  such that  <span class="math">\\sum_{i=1}^N B_i=a</span> , and sends B to the verifier as a commitment. Observe that any N-1 entries of B do not reveal any information about a, and so any verifier with oracle access to B that makes less than N queries cannot learn any information about a. However, as B is unstructured it is not clear how the prover can convince the verifier that  <span class="math">\\sum_{i=1}^N B_i=a</span> .</p>

    <p class="text-gray-300">Instead, we can consider imbuing B with additional structure by providing its low-degree extension. That is, the prover thinks of B as a function from  <span class="math">\\{0,1\\}^k</span>  to  <span class="math">\\mathbb{F}</span> , and sends its unique multilinear extension  <span class="math">\\hat{B} \\colon \\mathbb{F}^k \\to \\mathbb{F}</span>  to the verifier. Subsequently, the prover can reveal a to the verifier, and then engage in a sumcheck protocol for the claim &quot; <span class="math">\\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\hat{B}(\\vec{\\beta}) = a</span> &quot; to establish the correctness of a. The soundness of the sumcheck protocol protects the verifier against cheating provers and hence guarantees that this scheme is binding.</p>

    <p class="text-gray-300">However, giving B additional structure calls into question the hiding property of the scheme. Indeed, surprisingly a result of [JKRS09] shows that this new scheme is <em>not</em> hiding (in fields of characteristic different than 2): it holds that  <span class="math">\\hat{B}(2^{-1}, \\ldots, 2^{-1}) = a \\cdot 2^{-k}</span>  for any choice of B, so the verifier can learn a with only a single query to  <span class="math">\\hat{B}</span> !</p>

    <p class="text-gray-300">Sending an extension of B has created a new problem: querying the extension outside of  <span class="math">\\{0,1\\}^k</span> , the verifier can learn information that may require many queries to B to compute. Indeed, this additional power is precisely what</p>

    <p class="text-gray-300">underlies the soundness of the sumcheck protocol. To resolve this, we need to understand what the verifier can learn about B given some low-degree extension  <span class="math">\\hat{B}</span> . This is precisely the setting of algebraic query complexity [AW09].</p>

    <p class="text-gray-300">A natural approach is to let  <span class="math">\\hat{B}</span>  be chosen uniformly at random from the set of degree-d extensions of B for some d&gt;1. It is not hard to see that if d is very large (say,  <span class="math">|\\mathbb{F}|</span> ) then  <span class="math">2^k</span>  queries are required to determine the summation of  <span class="math">\\hat{B}</span>  on  <span class="math">H^m</span> . But we need d to be small to achieve soundness. A result of [JKRS09] shows that d=2 suffices: given a random multiquadratic extension  <span class="math">\\hat{B}</span>  of B, one needs  <span class="math">2^k</span>  queries to  <span class="math">\\hat{B}</span>  to determine  <span class="math">\\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\hat{B}(\\vec{\\beta})</span> .</p>

    <p class="text-gray-300"><strong>Committing to a polynomial.</strong> The prover in our zero knowledge protocols needs to commit not just to a single element but to the evaluation of an m-variate polynomial Q over  <span class="math">\\mathbb{F}</span>  of degree  <span class="math">d_Q</span> . We extend our ideas to this setting.</p>

    <p class="text-gray-300">Letting K be a subset of  <span class="math">\\mathbb{F}</span>  of size  <span class="math">d_Q+1</span> , the prover samples a random  <span class="math">B^{\\vec{x}}</span>  in  <span class="math">\\mathbb{F}^N</span>  such that  <span class="math">\\sum_{i=1}^N B_i^{\\vec{x}} = Q(\\vec{x})</span>  for each  <span class="math">\\vec{x} \\in K^m</span> . We can view all of these strings as a single function  <span class="math">B \\colon K^m \\times \\{0,1\\}^k \\to \\mathbb{F}</span> , and as before we consider its unique low-degree extension  <span class="math">\\hat{B} \\colon \\mathbb{F}^m \\times \\mathbb{F}^k \\to \\mathbb{F}</span> ; viewed as a polynomial,  <span class="math">\\hat{B}(\\vec{X},\\vec{Y})</span>  has degree at most  <span class="math">d_Q</span>  in  <span class="math">\\vec{X}</span>  and is multilinear in  <span class="math">\\vec{Y}</span> . Observe that since  <span class="math">\\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\hat{B}(\\vec{X},\\vec{\\beta})</span>  is a polynomial of individual degree  <span class="math">d_Q</span>  that agrees with Q on  <span class="math">K^m</span> , it must equal Q. The binding property of the commitment scheme is clear: the prover can decommit to  <span class="math">Q(\\vec{\\alpha})</span>  for any  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span>  by using the sumcheck protocol as before. We are left to argue the hiding property.</p>

    <p class="text-gray-300">It is not difficult to see that we run into the same issue as in the single-value case: we have  <span class="math">\\hat{B}(\\vec{\\alpha}, 2^{-1}, \\dots, 2^{-1}) = Q(\\vec{\\alpha}) \\cdot 2^{-k}</span>  for any  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> . We resolve this by again choosing a <em>random</em> extension  <span class="math">\\hat{B}</span>  of degree d &gt; 1 in  <span class="math">\\vec{Y}</span>  (and degree  <span class="math">d_Q</span>  in  <span class="math">\\vec{X}</span> ). Yet, arguing the hiding property now requires a <em>stronger</em> statement than the one proved in [JKRS09]. Not only do we need to know that the verifier cannot determine  <span class="math">Q(\\vec{\\alpha})</span>  for a particular  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> , but we need to know that the verifier cannot determine  <span class="math">Q(\\vec{\\alpha})</span>  for any  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> , or even any linear combination of any such values. We prove that this stronger guarantee holds in the same parameter regime: if d &gt; 1 then  <span class="math">2^k</span>  queries are both necessary and sufficient.</p>

    <p class="text-gray-300"><strong>Transparency to low-degree tests.</strong> Recall that a key algebraic property we required from our commitment scheme is that the verifier can perform a low-degree test on the committed polynomial without the assistance of the prover. Our commitment scheme naturally has this property. If the PCP oracle  <span class="math">\\tilde{B} \\colon \\mathbb{F}^m \\times \\mathbb{F}^k \\to \\mathbb{F}</span>  is low-degree, then it is a commitment to the low-degree  <span class="math">Q \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  defined as  <span class="math">Q(\\vec{X}) := \\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\tilde{B}(\\vec{X}, \\vec{\\beta})</span> . In fact, even if  <span class="math">\\tilde{B} \\colon \\mathbb{F}^m \\times \\mathbb{F}^k \\to \\mathbb{F}</span>  is merely <em>close</em> to a low-degree  <span class="math">\\hat{B} \\colon \\mathbb{F}^m \\times \\mathbb{F}^k \\to \\mathbb{F}</span> , then we can still regard  <span class="math">\\tilde{B}</span>  as a commitment to the low-degree  <span class="math">Q \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  defined as  <span class="math">Q(\\vec{X}) := \\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\hat{B}(\\vec{X}, \\vec{\\beta})</span> , because the verifier can check claims of the form &quot; <span class="math">Q(\\vec{\\alpha}) = a</span> &quot; by obtaining the value of  <span class="math">\\hat{B}</span>  it needs at the end of the sumcheck protocol via self-correction on  <span class="math">\\tilde{B}</span> .</p>

    <p class="text-gray-300"><strong>Beyond the boolean hypercube.</strong> For efficiency reasons analogous to those in [BFLS91; GKR15], instead of viewing B as a function from  <span class="math">K^m \\times \\{0,1\\}^k</span>  to  <span class="math">\\mathbb F</span> , we view B as a function from  <span class="math">K^m \\times H^{k&#x27;}</span>  to  <span class="math">\\mathbb F</span>  for a subset H of  <span class="math">\\mathbb F</span>  of size  <span class="math">\\mathbb F^{\\Omega(1)}</span>  and  <span class="math">K&#x27; := \\log N/\\log |H|</span> . This requires us to extend our claims about the algebraic query complexity of polynomial summation to arbitrary sets H. We show that if d &gt; 2(|H| - 1), then  <span class="math">|H|^{k&#x27;} = N</span>  queries are necessary to determine  <span class="math">Q(\\vec{\\alpha})</span>  for any  <span class="math">\\vec{\\alpha}</span>  (or any linear combination of these). See Section 5 for details.</p>

    <p class="text-gray-300"><strong>Decommitting in zero knowledge.</strong> To use our commitment scheme in zero knowledge protocols, we must ensure that, in the decommitment phase, the verifier cannot learn any information beyond the value  <span class="math">a:=Q(\\vec{\\alpha})</span>  for a chosen  <span class="math">\\vec{\\alpha}</span> . To decommit, the prover sends the value a and has to convince the verifier that the claim &quot; <span class="math">\\sum_{\\vec{\\beta} \\in \\{0,1\\}^k} \\hat{B}(\\vec{\\alpha}, \\vec{\\beta}) = a</span> &quot; is true. However, if the prover and verifier simply run the sumcheck protocol on this claim, the prover leaks partial sums  <span class="math">\\sum_{\\vec{\\beta} \\in \\{0,1\\}^{k-i}} \\hat{B}(\\vec{\\alpha}, c_1, \\dots, c_i, \\vec{\\beta})</span>  for  <span class="math">c_1, \\dots, c_i \\in \\mathbb{F}</span>  chosen by the verifier, which could reveal additional information about Q. Instead, the prover and verifier run on this claim the IPCP for sumcheck of [BCFGRS16], whose 'weak' zero knowledge guarantee ensures that this cannot happen. (Thus, in addition to the commitment, the honest prover also sends the evaluation of a random low-degree polynomial as required by the IPCP for sumcheck of [BCFGRS16].)</p>

    <p class="text-gray-300"><strong>Remark 2.2</strong> (comparison with [GIMS10]). Goyal, Ishai, Mahmoody, and Sahai [GIMS10] define and construct <em>interactive locking schemes</em>, information-theoretic commitment schemes in the IPCP model. Their scheme is combinatorial, and we do not know how to use it in our setting (it is not clear how to low-degree test the committed message without disrupting zero knowledge). Putting this difference aside, their construction and our construction are incomparable. On the one hand, we achieve perfect hiding while they only achieve statistical hiding. On the other hand, their scheme is 'oracle efficient' (any query to the oracle can be computed statelessly in polynomial time) while our scheme is not.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 A zero knowledge sumcheck protocol</h3>

    <p class="text-gray-300">We summarize the ideas behind our main result, a zero knowledge sumcheck protocol (see Theorem 1.1). This result not only enables us to modify the BFL protocol to achieve zero knowledge (as discussed above), but also to modify the Shamir and GKR protocols to achieve zero knowledge (as discussed below). The two building blocks underlying our sumcheck protocol are our algebraic commitments (see Section 2.2 above) and the IPCP for sumcheck of [BCFGRS16]. We now cover necessary background and then describe our protocol.</p>

    <p class="text-gray-300"><strong>Previous sumcheck protocols.</strong> The sumcheck protocol [LFKN92] is an IP for claims of the form &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) = 0</span> &quot;, where H is a subset of a finite field  <span class="math">\\mathbb F</span>  and F is an m-variate polynomial over  <span class="math">\\mathbb F</span>  of small individual degree. The protocol has m rounds: in round i, the prover sends the univariate polynomial  <span class="math">g_i(X_i) := \\sum_{\\vec{\\alpha} \\in H^{m-i}} F(c_1, \\dots, c_{i-1}, X_i, \\vec{\\alpha})</span> ; the verifier checks that  <span class="math">\\sum_{\\alpha_i \\in H} g_i(\\alpha_i) = g_{i-1}(c_{i-1})</span>  and replies with a uniformly random challenge  <span class="math">c_i \\in \\mathbb F</span> . After round m, the verifier outputs the claim &quot; <span class="math">F(c_1, \\dots, c_m) = g_m(c_1, \\dots, c_m)</span> &quot;. If F is of sufficiently low degree and does not sum to a over the space, then the output claim is false with high probability. Note that the verifier does not need access to F.</p>

    <p class="text-gray-300">The IPCP for sumcheck of [BCFGRS16] modifies the above protocol as follows. The prover first sends a PCP oracle that equals the evaluation of a random 'masking' polynomial R; the verifier checks that R is (close to) low degree. After that the prover and verifier conduct an Interactive Proof. The prover sends  <span class="math">z \\in \\mathbb{F}</span>  that allegedly equals  <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} R(\\vec{\\alpha})</span> , and the verifier responds with a uniformly random challenge  <span class="math">\\rho \\in \\mathbb{F}^*</span> . The prover and verifier now run the (standard) sumcheck protocol to reduce the claim &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} \\rho F(\\vec{\\alpha}) + R(\\vec{\\alpha}) = \\rho a + z</span> &quot; to a claim &quot; <span class="math">\\rho F(\\vec{c}) + R(\\vec{c}) = b</span> &quot; for random  <span class="math">\\vec{c} \\in \\mathbb{F}^m</span> . The verifier queries R at  <span class="math">\\vec{c}</span>  and then outputs the claim &quot; <span class="math">F(\\vec{c}) = \\frac{b - R(\\vec{c})}{\\rho}</span> &quot;. If  <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} F(\\vec{\\alpha}) \\neq a</span>  then with high probability over the choice of  <span class="math">\\rho</span>  and the verifier's messages in the sumcheck protocol, this claim will be false.</p>

    <p class="text-gray-300">A key observation is that if the verifier makes no queries to R, then the prover's messages are identically distributed to the sumcheck protocol applied to a uniformly random polynomial Q. When the verifier does make queries to R, simulating the resulting conditional distribution involves techniques from Algebraic Complexity Theory, as shown in [BCFGRS16]. Given Q, the verifier's queries to  <span class="math">R(\\vec{\\alpha})</span>  for  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span>  are identically distributed to  <span class="math">Q(\\vec{\\alpha}) - \\rho F(\\vec{\\alpha})</span> . Thus the simulator need only make at most one query to F for every query to F. That is, any verifier making F0 queries to F1 learns no more than it would learn by making F1 queries to F3 alone.</p>

    <p class="text-gray-300">As discussed, this zero knowledge guarantee does not suffice for the applications that we consider: when a sumcheck protocol is used as a subroutine of another protocol, F may itself be recursively defined in terms of large sums which the verifier cannot evaluate on its own. The verifier does, however, have oracle access to R, and so can learn enough information about F to break zero knowledge.</p>

    <p class="text-gray-300">Our sumcheck protocol. The zero knowledge guarantee that we aim for is the following: any polynomial-time verifier learns no more than it would by making <em>one</em> query to F, regardless of its number of queries to the PCP oracle.</p>

    <p class="text-gray-300">The main idea to achieve this guarantee is the following. The prover sends a PCP oracle that is an <em>algebraic commitment Z</em> to the aforementioned masking polynomial R. Then, as before, the prover and verifier run the sumcheck protocol to reduce the claim &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} \\rho F(\\vec{\\alpha}) + R(\\vec{\\alpha}) = \\rho a + z</span> &quot; to a claim &quot; <span class="math">\\rho F(\\vec{c}) + R(\\vec{c}) = b</span> &quot; for random  <span class="math">\\vec{c} \\in \\mathbb{F}^m</span> .</p>

    <p class="text-gray-300">We now face two problems. First, the verifier cannot simply query R at  <span class="math">\\vec{c}</span>  and then output the claim &quot; <span class="math">F(\\vec{c}) = \\frac{b - R(\\vec{c})}{\\rho}</span> &quot;, since the verifier only has oracle access to the commitment Z of R. Second, the prover could cheat the verifier by having Z be a commitment to an R that is far from low degree, which allows cheating in the sumcheck protocol.</p>

    <p class="text-gray-300">The first problem is addressed by the fact that our algebraic commitment scheme has a decommitment sub-protocol that is zero knowledge: the prover can reveal  <span class="math">R(\\vec{c})</span>  in such a way that no other values about R are also revealed as a side-effect. As discussed, this relies on the protocol of [BCFGRS16], used a subroutine (for the second time).</p>

    <p class="text-gray-300">The second problem is taken care of by the fact that our algebraic commitment scheme is 'transparent' to low-degree tests: the verifier simply performs a low-degree test on Z, which by self-correction gives the verifier oracle access to a low-degree Z' that is a commitment to a low-degree R.</p>

    <p class="text-gray-300">Overall, the only value that a malicious verifier can learn is  <span class="math">F(\\vec{c})</span>  for  <span class="math">\\vec{c} \\in \\mathbb{F}^m</span>  of its choice.</p>

    <p class="text-gray-300"><strong>Remark 2.3.</strong> Our sumcheck protocol 'leaks' a single evaluation of F. We believe that this limitation is inherent: the honest verifier always outputs a true claim about one evaluation of F, which it cannot do without learning that evaluation. Either way, this guarantee is strong enough for applications: we ensure that learning a single evaluation of F does not harm zero knowledge, either because it carries no information or because the verifier can evaluate F itself.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Challenges: handling recursion</h3>

    <p class="text-gray-300">We have so far discussed the ideas behind our main result (a zero knowledge sumcheck protocol) and how to use it to achieve a natural zero knowledge analogue of the classical MIP/PCP construction for NEXP [BFL91; BFLS91]. Other applications require additional ideas to overcome challenges that arise when the sumcheck protocol is used <em>recursively</em>.</p>

    <p class="text-gray-300"><strong>Shamir's protocol.</strong> Consider the goal of achieving zero knowledge for Shamir's protocol for <strong>PSPACE</strong> [Sha92]. This protocol reduces checking any <strong>PSPACE</strong> computation to checking that:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{x_1 \\in \\{0,1\\}} \\prod_{x_2 \\in \\{0,1\\}} \\dots \\sum_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1, \\dots, x_n) = 0</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{\\phi}</span>  is the (efficiently computable) arithmetization over a finite field  <span class="math">\\mathbb{F}</span>  of a certain boolean formula  <span class="math">\\phi</span> . Since Shamir's protocol is similar to the sumcheck protocol, a natural starting point would be to try to merely adapt the techniques that 'worked' in the case of the sumcheck protocol. However, the similarity between the two protocols is only superficial (e.g., it lacks the useful linear structure present in the sumcheck protocol). An accurate way to compare the two is to view Shamir's protocol as a <em>recursive</em> application of the sumcheck protocol, as shown by Meir [Mei13].</p>

    <p class="text-gray-300">For example, the TQBF problem is downward self-reducible [TV07]: for  <span class="math">i \\in \\{1, ..., n\\}</span>  let</p>

    <p class="text-gray-300"><span class="math">$G_i(X_1,\\ldots,X_i) := \\sum_{x_{i+1}\\in\\{0,1\\}} \\prod_{x_{i+2}\\in\\{0,1\\}} \\ldots \\sum_{x_{n-1}\\in\\{0,1\\}} \\prod_{x_n\\in\\{0,1\\}} \\hat{\\phi}(X_1,\\ldots,X_i,x_{i+1},\\ldots,x_n) .</span>$</p>

    <p class="text-gray-300">From this one obtains the recurrence</p>

    <p class="text-gray-300">
<span class="math">$G_i(X_1, \\dots, X_i) = \\sum_{x_{i+1} \\in \\{0,1\\}} G_{i+2}(X_1, \\dots, X_i, x_{i+1}, 0) \\cdot G_{i+2}(X_1, \\dots, X_i, x_{i+1}, 1) . \\tag{1}</span>$</p>

    <p class="text-gray-300">In other words, with oracle access to  <span class="math">G_{i+2}</span> , one can use a (small) sumcheck to compute  <span class="math">G_i</span> . This suggests a recursive approach: if we could check evaluations of  <span class="math">G_{i+2}</span>  in zero knowledge, then maybe we could use this as a subprotocol to check evaluations of  <span class="math">G_i</span>  also in zero knowledge.</p>

    <p class="text-gray-300"><strong>GKR's protocol.</strong> The recursive structure is perhaps more evident in the doubly-efficient Interactive Proof of Goldwasser, Kalai, and Rothblum [GKR15] ('GKR protocol'). Its barebones sub-protocol checks a more complex arithmetic expression: the output of a layered arithmetic circuit. Fix an input x to the circuit, and let  <span class="math">V_i(j) \\colon [S] \\to \\mathbb{F}</span>  be the value of the j-th gate in layer i (S is the number of gates in a layer). For some subset  <span class="math">H \\subseteq \\mathbb{F}</span>  and sufficiently large m, one views  <span class="math">V_i</span>  as a function from  <span class="math">H^m</span>  to  <span class="math">\\mathbb{F}</span>  by imposing some ordering on  <span class="math">H^m</span> . One can relate  <span class="math">V_{i-1}</span>  to  <span class="math">V_i</span>  as follows:</p>

    <p class="text-gray-300">
<span class="math">$V_{i-1}(\\vec{z}) = \\sum_{\\vec{\\omega}_1, \\vec{\\omega}_2 \\in H^m} \\operatorname{add}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_i(\\vec{\\omega}_1) + V_i(\\vec{\\omega}_2) \\right) + \\operatorname{mul}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_i(\\vec{\\omega}_1) \\cdot V_i(\\vec{\\omega}_2) \\right)</span>$
(2)</p>

    <p class="text-gray-300">where  <span class="math">\\operatorname{add}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2)</span>  is 1 if the  <span class="math">\\vec{z}</span> -th gate in layer i-1 is an addition gate whose inputs are the  <span class="math">\\vec{\\omega}_1</span> -th and  <span class="math">\\vec{\\omega}_2</span> -th gates in layer i, and  <span class="math">\\operatorname{mul}_i</span>  is defined similarly for multiplication gates.</p>

    <p class="text-gray-300">We again see a recursive structure: a function defined as the summation over some product space of a polynomial whose terms are functions of the same form; this allows to check  <span class="math">V_{i-1}</span>  given a protocol for checking  <span class="math">V_i</span> .</p>

    <p class="text-gray-300">The use of recursion in the GKR protocol is even more involved: the barebones protocol relies on the verifier having oracle access to low-degree extensions of  <span class="math">\\operatorname{add}_i</span>  and  <span class="math">\\operatorname{mul}_i</span> . For very restricted classes of circuits, the verifier can efficiently 'implement' these oracles; however, for the class of circuits that is ultimately supported by the protocol this requires a further sub-protocol that delegates the evaluation of these oracles to the prover, and this is done by <em>composing</em> multiple instances of the GKR protocol. To achieve zero knowledge we also have to tackle this form of recursion.</p>

    <p class="text-gray-300"><strong>The leakage of recursion.</strong> By now the central role of recursion in applications of the sumcheck protocol is clear. There are two main sources of leakage that we need to overcome in order to achieve zero knowledge in such applications.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">Checking evaluations of  <span class="math">G_{i+2}</span> ,  <span class="math">V_i</span> , or  <span class="math">add_i</span>  and  <span class="math">mul_i</span> , even in zero knowledge, leaks the evaluations themselves. The verifier, however, is not able to compute these itself (else it would not need to delegate), which means that information is leaked.</p></li>
      <li><p class="text-gray-300">The number of claims can grow exponentially: a claim about  <span class="math">G_i</span>  (resp.  <span class="math">V_{i-1}</span> ) is reduced to <em>two</em> claims about  <span class="math">G_{i+2}</span>  (resp.  <span class="math">V_i</span> ). There are standard techniques that leverage interaction to reduce multiple claims about a low-degree polynomial to a single one, but we need to replace these with zero knowledge equivalents.</p></li>
    </ol>

    <p class="text-gray-300">We tackle both issues by devising a general framework that captures their shared algebraic structure, solving these problems within this framework, and then recovering the protocols of Shamir and GKR as special cases.</p>

    <p class="text-gray-300">We introduce the notion of <em>sum-product circuits</em> and show that the sumcheck protocol naturally gives rise to algebraic Interactive Proofs for checking the value of such circuits. We then explain how to achieve zero knowledge variants of these by building on the techniques discussed in Section 2.1. We recover zero knowledge variants of the protocols of Shamir and GKR as special cases of this approach.</p>

    <p class="text-gray-300">Sum-product circuits are an abstract way of encoding 'sum-product expressions'. A sum-product expression is either a polynomial over some finite field  <span class="math">\\mathbb{F}</span>  represented by a small arithmetic circuit or a polynomial of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\beta} \\in H^m} C(\\vec{X}, \\vec{\\beta}, P_1(\\vec{X}, \\vec{\\beta}), \\dots, P_n(\\vec{X}, \\vec{\\beta}))</span>$
(3)</p>

    <p class="text-gray-300">where C is a low-degree 'combiner' polynomial represented by a small arithmetic circuit, and  <span class="math">P_1, \\ldots, P_n</span>  are sumproduct expressions. Both Equation 1 (for Shamir's protocol) and Equation 2 (for GKR's protocol) are of this form.</p>

    <p class="text-gray-300">Like a standard arithmetic circuit, a sum-product circuit is a directed acyclic graph associated with a field  <span class="math">\\mathbb F</span>  in which we associate to each vertex a <em>value</em>, which in our case is the sum-product expression that it computes. Each internal vertex is labeled by a combiner polynomial, and there is an edge from u to v if the sum-product expression of v appears in that of u. For example, the above expression would correspond to a vertex labeled with C, with outgoing edges to the vertices corresponding to  <span class="math">P_1, \\ldots, P_n</span> . An input to the circuit is a labeling of the leaf vertices with small arithmetic circuits. We now spell this out in a little more detail.</p>

    <p class="text-gray-300"><strong>Definition 2.4</strong> (Informal version of Definition 8.8). A sum-product circuit C is a rooted directed acyclic graph where each internal vertex is labeled with an arithmetic circuit  <span class="math">C_v</span>  over a finite field  <span class="math">\\mathbb{F}</span> . An input x to C labels each leaf v with a polynomial  <span class="math">x_v</span>  over  <span class="math">\\mathbb{F}</span> . The value of a vertex v on input v is a multivariate polynomial v over  <span class="math">\\mathbb{F}</span>  defined as follows: if v is a leaf vertex then v and v is an internal vertex then, for a chosen integer v,</p>

    <p class="text-gray-300">
<span class="math">$v[\\mathbf{x}](\\vec{X}) := \\sum_{\\vec{\\beta} \\in H^m} C_v(\\vec{X}, \\vec{\\beta}, u_1[\\mathbf{x}](\\vec{X}, \\vec{\\beta}), \\dots, u_t[\\mathbf{x}](\\vec{X}, \\vec{\\beta})) . \\tag{4}</span>$</p>

    <p class="text-gray-300">The <strong>value</strong> of C on input x is denoted C[x] and equals the value of the root vertex r (and we require that  <span class="math">C[x] \\in F</span> ).</p>

    <p class="text-gray-300">We next describe an Interactive Proof that works for any sum-product circuit. The protocols of Shamir [Sha92] and of GKR [GKR15] can be viewed as this protocol applied to specific sum-product circuits (computing  <span class="math">G_0</span>  and  <span class="math">V_0</span>  respectively). After that, we explain how to modify the Interactive Proof to obtain a corresponding zero knowledge IPCP for any sum-product circuit, which allows us to derive our zero knowledge variants of these two protocols.</p>

    <p class="text-gray-300">A significant advantage of working with sum-product circuits is that they are easy to compose. For example, we can view the composition of the GKR protocol with itself as a <em>composition of sum-product circuits</em>. We can then apply our zero knowledge IPCP to the resulting circuit and directly obtain a zero knowledge analogue of the full GKR protocol.</p>

      <h4 id="sec-2.5.1" class="text-lg font-semibold mt-6">2.5.1 Delegating the evaluation of a sum-product circuit</h4>

    <p class="text-gray-300">We explain how to use the sumcheck protocol to obtain an Interactive Proof for checking the value of a sum-product circuit. The protocol is recursively defined: to prove that  <span class="math">\\mathcal{C}[\\mathtt{x}] = a</span>  (i.e., that  <span class="math">r[\\mathtt{x}] = a</span> ), it suffices to show that the values of r's children  <span class="math">u_1,\\ldots,u_t</span>  satisfy Equation 4 where the left-hand side is a. The sumcheck protocol interactively reduces this claim to a new claim &quot; <span class="math">C_v(\\vec{c},u_1[\\mathtt{x}](\\vec{c}),\\ldots,u_t[\\mathtt{x}](\\vec{c})) = b</span> &quot; for  <span class="math">\\vec{c} \\in \\mathbb{F}^m</span>  chosen uniformly at random by the verifier and  <span class="math">b \\in \\mathbb{F}</span>  chosen by the prover. The prover sends  <span class="math">h_1 := u_1[\\mathtt{x}](\\vec{c}),\\ldots,h_t := u_t[\\mathtt{x}](\\vec{c})</span> , reducing this new claim</p>

    <p class="text-gray-300">to the set of claims &quot; <span class="math">h_i = u_i[x](\\vec{c})</span> &quot; for i = 1, ..., t and &quot; <span class="math">C_v(\\vec{c}, h_1, ..., h_t) = b</span> &quot;. The latter can be checked by the verifier directly and the rest can be recursively checked via the same procedure. Eventually the protocol reaches the leaf vertices, which are labeled with small arithmetic circuits that the verifier can evaluate on its own.</p>

    <p class="text-gray-300">One technicality is that, as defined, the degree of the polynomial at a vertex may be exponentially large, and so the prover would have to send exponentially-large messages in the sumcheck protocol. To avoid this, we use a well-known interactive sub-protocol for <em>degree reduction</em> [She92; GKR15]. Since for all  <span class="math">\\vec{x}</span>  the value  <span class="math">v[x](\\vec{x})</span>  depends only on  <span class="math">u_1[x](\\vec{x}, \\vec{\\beta}), \\ldots, u_t[x](\\vec{x}, \\vec{\\beta})</span>  for  <span class="math">\\vec{\\beta} \\in H^m</span> , we can safely replace each  <span class="math">u_i[x]</span>  with the unique degree-(|H|-1) extension  <span class="math">\\hat{u}_i[x]</span>  of its evaluation over  <span class="math">H^m</span> . The degree of the summand in Equation 4 is now at most  <span class="math">\\delta |H|</span> , where  <span class="math">\\delta</span>  is the <em>total</em> degree of  <span class="math">C_v</span> . Now that the sumcheck protocol is only invoked on low-degree polynomials, efficiency is recovered.</p>

    <p class="text-gray-300">Another technicality is that since a sum-product circuit is a directed acyclic graph (as opposed to a tree), it is possible that a single vertex v will have many claims about it. If each such claim reduces to many claims about other vertices, the number of claims to check could grow exponentially. This is in fact the case in both Shamir's and GKR's protocols. To avoid this blowup, the verifier checks a random linear combination of the claims about each vertex v. It is not difficult to see that soundness is preserved, and the number of claims per vertex is reduced to one.</p>

      <h4 id="sec-2.5.2" class="text-lg font-semibold mt-6">2.5.2 Achieving zero knowledge</h4>

    <p class="text-gray-300">The Interactive Proof for sum-product circuits that we have described above is not zero knowledge. First, the sumcheck protocol, which is used to reduce claims about parent vertices to claims about child vertices, leaks information in the form of partial sums of the summand polynomial, as usual. Second, in order to reduce a claim about the root to claims about its children, the prover must provide evaluations of the polynomials of the children. These may be hard for the verifier to compute (indeed, if the verifier could compute both of these on its own then there would be no need to recurse). We use the ideas discussed in Section 2.1 to resolve both of these issues, obtaining a zero knowledge variant in the IPCP model (where the honest prover sends a random low-degree polynomial as the oracle).</p>

    <p class="text-gray-300">We resolve the first issue by using our zero knowledge sumcheck protocol. Its zero knowledge guarantee states that the protocol reveals only one value of the summand function, which can be computed via one query to each of the  <span class="math">\\hat{u}_i[\\mathbf{x}]</span> , which are precisely the  <span class="math">h_i</span> 's sent by the prover. We are left to ensure that  <span class="math">h_i</span> 's do not leak information.</p>

    <p class="text-gray-300">As in our modification of the BFL protocol, rather than taking the unique degree-(|H|-1) extension  <span class="math">\\hat{v}[\\mathbf{x}](\\vec{X})</span>  of  <span class="math">v[\\mathbf{x}](\\vec{X})</span> , we will instead take a <em>random</em> degree- <span class="math">(|H|+\\delta)</span>  extension  <span class="math">\\hat{v}[\\mathbf{x}]</span> , where  <span class="math">\\delta</span>  depends only on the circuit structure (in all of our protocols,  <span class="math">\\delta</span>  is a small constant). This ensures that the few evaluations actually revealed by the prover are uniformly random in  <span class="math">\\mathbb{F}</span> . The prover sends, for each vertex v, the evaluation of a random polynomial  <span class="math">R_v</span> , which defines the random low-degree extension as  <span class="math">\\dot{v}[\\mathbf{x}](\\vec{X}) := \\hat{v}[\\mathbf{x}](\\vec{X}) + \\mathbb{Z}_{H^m}(\\vec{X}) \\cdot R_v(\\vec{X})</span>  where  <span class="math">\\mathbb{Z}_{H^m}</span>  is a degree-|H| polynomial that is zero on  <span class="math">H^m</span>  and nonzero on  <span class="math">(\\mathbb{F}-H)^m</span> . The prover cannot simply send  <span class="math">R_v</span> , however, because the verifier could then query it in order to 'derandomize'  <span class="math">\\dot{v}[\\mathbf{x}]</span> . Instead, the prover sends a commitment to  <span class="math">R_v</span>  using our algebraic commitment scheme. The decommitment is performed 'implicitly' during the sumcheck for vertex v. See Section 9.1 for details.</p>

    <p class="text-gray-300">Finally, recall that in order to avoid a blowup in the number of claims we have to check, the verifier checks a random linear combination of the claims about any given vertex; this is a linear operation. Also, to avoid a blowup in the degree, we take the low-degree extension, which is also a linear operation. Both of these operations are 'compatible' with sumcheck, and thus zero knowledge is straightforwardly maintained.</p>

    <p class="text-gray-300">After providing formal definitions in Section <a href="#page-15-0">4,</a> the rest of the paper is organized as summarized by the table below. The shaded boxes denote some previous results that we rely on.</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Basic notations</h3>

    <p class="text-gray-300">For  <span class="math">n \\in \\mathbb{N}</span>  we denote by [n] the set  <span class="math">\\{1, \\ldots, n\\}</span> . For  <span class="math">m, n \\in \\mathbb{N}</span>  we denote by m + [n] the set  <span class="math">\\{m + 1, \\ldots, m + n\\}</span> . For a set  <span class="math">X, n \\in \\mathbb{N}, I \\subseteq [n]</span> , and  <span class="math">\\vec{x} \\in X^n</span> , we denote by  <span class="math">\\vec{x}_I</span>  the vector  <span class="math">(x_i)_{i \\in I}</span>  that is  <span class="math">\\vec{x}</span>  restricted to the coordinates in I.</p>

    <p class="text-gray-300"><strong>Functions, distributions, fields.</strong> We use  <span class="math">f: D \\to R</span>  to denote a function with domain D and range R; given a subset  <span class="math">\\tilde{D}</span>  of D, we use  <span class="math">f|_{\\tilde{D}}</span>  to denote the restriction of f to  <span class="math">\\tilde{D}</span> . Given a distribution  <span class="math">\\mathcal{D}</span> , we write  <span class="math">x \\leftarrow \\mathcal{D}</span>  to denote that x is sampled according to  <span class="math">\\mathcal{D}</span> . We denote by  <span class="math">\\mathbb{F}</span>  a finite field and by  <span class="math">\\mathbb{F}_q</span>  the field of size q. Arithmetic operations over  <span class="math">\\mathbb{F}_q</span>  take time polylog q and space  <span class="math">O(\\log q)</span> .</p>

    <p class="text-gray-300"><strong>Polynomials.</strong> We denote by  <span class="math">\\mathbb{F}[X_{1,\\dots,m}]</span>  the ring of polynomials in m variables over  <span class="math">\\mathbb{F}</span> . Given a polynomial P in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}]</span> ,  <span class="math">\\deg_{X_i}(P)</span>  is the degree of P in the variable  <span class="math">X_i</span> . The <em>individual degree</em> of a polynomial is its maximum degree in any variable,  <span class="math">\\max_{1\\leq i\\leq m}\\deg_{X_i}(P)</span> ; we always refer to the individual degree unless otherwise specified. We denote by  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span>  the subspace consisting of  <span class="math">P\\in\\mathbb{F}[X_{1,\\dots,m}]</span>  with individual degree at most d.</p>

    <p class="text-gray-300"><strong>Languages and relations.</strong> We denote by  <span class="math">\\mathscr{L}</span>  a language consisting of <em>instances</em> x, and by  <span class="math">\\mathscr{R}</span>  a (binary ordered) relation consisting of pairs (x, w), where x is the <em>instance</em> and w is the <em>witness</em>. We denote by  <span class="math">\\operatorname{Lan}(\\mathscr{R})</span>  the language corresponding to  <span class="math">\\mathscr{R}</span> , and by  <span class="math">\\mathscr{R}|_{x}</span>  the set of witnesses in  <span class="math">\\mathscr{R}</span>  for x (if  <span class="math">x \\notin \\operatorname{Lan}(\\mathscr{R})</span>  then  <span class="math">\\mathscr{R}|_{x} := \\emptyset</span> ). As always, we assume that |w| is bounded by some computable function of n := |x|; in fact, we are mainly interested in relations arising from nondeterministic languages:  <span class="math">\\mathscr{R} \\in \\mathbf{NTIME}(T)</span>  if there exists a T(n)-time machine M such that M(x, w) outputs 1 if and only if  <span class="math">(x, w) \\in \\mathscr{R}</span> . Throughout, we assume that  <span class="math">T(n) \\ge n</span> .</p>

    <p class="text-gray-300"><strong>Low-degree extensions.</strong> Let  <span class="math">\\mathbb F</span>  be a finite filed, H a subset of  <span class="math">\\mathbb F</span> , and m a positive integer. The <em>low-degree extension</em> (LDE) of a function  <span class="math">f \\colon H^m \\to \\mathbb F</span>  is denoted  <span class="math">\\hat f</span>  and is the unique polynomial in  <span class="math">\\mathbb F[X_{1,\\dots,m}^{\\leq |H|-1}]</span>  that agrees with f on  <span class="math">H^m</span> . In particular,  <span class="math">\\hat f \\colon \\mathbb F^m \\to \\mathbb F</span>  is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\hat{f}(\\vec{X}) := \\sum_{\\vec{\\beta} \\in H^m} I_{H^m}(\\vec{X}, \\vec{\\beta}) \\cdot f(\\vec{\\beta}) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">I_{H^m}(\\vec{X},\\vec{Y}) := \\prod_{i=1}^m \\sum_{\\omega \\in H} \\prod_{\\gamma \\in H \\setminus \\{\\omega\\}} \\frac{(X_i - \\gamma)(Y_i - \\gamma)}{(\\omega - \\gamma)^2}</span>  is the unique polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq |H|-1}]</span>  such that, for all  <span class="math">(\\vec{\\alpha}, \\vec{\\beta}) \\in H^m \\times H^m</span> ,  <span class="math">I_{H^m}(\\vec{\\alpha}, \\vec{\\beta})</span>  equals 1 when  <span class="math">\\vec{\\alpha} = \\vec{\\beta}</span>  and equals 0 otherwise. Note that  <span class="math">I_{H^m}(\\vec{X}, \\vec{Y})</span>  can be generated and evaluated in time  <span class="math">\\operatorname{poly}(|H|, m, \\log |\\mathbb{F}|)</span>  and space  <span class="math">O(\\log |\\mathbb{F}| + \\log m)</span> , so  <span class="math">\\hat{f}(\\vec{\\alpha})</span>  can be evaluated in time  <span class="math">|H|^m \\cdot \\operatorname{poly}(|H|, m, \\log |\\mathbb{F}|)</span>  and space  <span class="math">O(m \\cdot \\log |\\mathbb{F}|)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbb F</span>  be a finite field, m,d positive integers, and H a subset of  <span class="math">\\mathbb F</span> , and recall that  <span class="math">\\mathbb F[X_{1,\\dots,m}^{\\leq d}]</span>  is the subspace of  <span class="math">\\mathbb F[X_{1,\\dots,m}]</span>  consisting of those polynomials with individual degrees at most d. Given  <span class="math">Q \\in \\mathbb F[X_{1,\\dots,m}^{\\leq d}]</span>  and  <span class="math">\\vec{\\alpha} \\in \\mathbb F^{\\leq m}</span>  (vectors over  <span class="math">\\mathbb F</span>  of length at most m), we define  <span class="math">Q(\\vec{\\alpha}) := \\sum_{\\vec{\\gamma} \\in H^{m-|\\vec{\\alpha}|}} Q(\\vec{\\alpha},\\vec{\\gamma})</span> , i.e., the answer to a query that specifies only a prefix of the variables is the sum of the values obtained by letting the remaining variables range over H.</p>

    <p class="text-gray-300">In Section 6 we rely on the fact, formally stated below and proved in [BCFGRS16], that one can efficiently sample the distribution  <span class="math">R(\\vec{\\alpha})</span> , where R is uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span>  and  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^{\\leq m}</span>  is fixed, even conditioned on any polynomial number of (consistent) values for  <span class="math">R(\\vec{\\alpha}_1),\\dots,R(\\vec{\\alpha}_\\ell)</span>  (with  <span class="math">\\vec{\\alpha}_1,\\dots,\\vec{\\alpha}_\\ell\\in\\mathbb{F}^{\\leq m}</span> ). More precisely, the sampling algorithm runs in time that is only poly(log  <span class="math">|\\mathbb{F}|,m,d,|H|,\\ell</span> ), which is much faster than the trivial running time of  <span class="math">\\Omega(d^m)</span>  achieved by sampling R explicitly. This &quot;succinct&quot; sampling follows from the notion of succinct constraint detection studied in [BCFGRS16] for the case of partial sums of low-degree polynomials.</p>

    <p class="text-gray-300"><strong>Corollary 4.1</strong> ([BCFGRS16]). There exists a probabilistic algorithm  <span class="math">\\mathcal{A}</span>  such that, for every finite field  <span class="math">\\mathbb{F}</span> , positive integers m, d, subset H of  <span class="math">\\mathbb{F}</span> , subset  <span class="math">S = \\{(\\alpha_1, \\beta_1), \\dots, (\\alpha_\\ell, \\beta_\\ell)\\} \\subseteq \\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span> , and  <span class="math">(\\alpha, \\beta) \\in \\mathbb{F}^{\\leq m} \\times \\mathbb{F}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}(\\mathbb{F}, m, d, H, S, \\alpha) = \\beta\\right] = \\Pr_{R \\leftarrow \\mathbb{F}[X_{1, \\dots, m}^{\\leq d}]} \\left[ R(\\alpha) = \\beta \\middle| \\begin{array}{c} R(\\alpha_{1}) = \\beta_{1} \\\\ \\vdots \\\\ R(\\alpha_{\\ell}) = \\beta_{\\ell} \\end{array} \\right] .</span>$</p>

    <p class="text-gray-300">An <em>Interactive Probabilistically Checkable Proof</em> (Interactive PCP, IPCP) <a href="#page-61-0">[KR08]</a> is a Probabilistically Checkable Proof <a href="#page-60-11">[BFLS91;</a> <a href="#page-61-16">FGLSS91;</a> <a href="#page-60-12">AS98;</a> <a href="#page-60-13">ALMSS98]</a> followed by an Interactive Proof <a href="#page-60-17">[Bab85;</a> <a href="#page-61-3">GMR89]</a>. Namely, the prover P and verifier V interact as follows: P sends to V a probabilistically checkable proof &pi;; afterwards, P and V &pi; engage in an interactive proof. Thus, V may read a few bits of &pi; but must read subsequent messages from P in full. An <em>IPCP system</em> for a relation R is thus a pair (P, V ), where P, V are probabilistic interactive algorithms working as described, that satisfies naturally-defined notions of perfect completeness and soundness with a given error &epsilon;(&middot;); see <a href="#page-61-0">[KR08]</a> for details.</p>

    <p class="text-gray-300">We say that an IPCP has k rounds if this &quot;PCP round&quot; is followed by a k-round interactive proof. (Though note that <a href="#page-60-1">[BCFGRS16]</a> counts the PCP round towards round complexity.) Beyond round complexity, we also measure how many bits the prover sends and how many the verifier reads: the <em>proof length</em> l is the length of &pi; in bits plus the number of bits in all subsequent prover messages; the <em>query complexity</em> q is the number of bits of &pi; read by the verifier plus the number of bits in all subsequent prover messages (since the verifier must read all of those bits).</p>

    <p class="text-gray-300">In this work, we do not count the number of bits in the verifier messages, nor the number of random bits used by the verifier; both are bounded from above by the verifier's running time, which we do consider. Overall, we say that a language L (resp., relation R) belongs to the complexity class IPCP[&epsilon;, k, l, q] if there is an IPCP system for L (resp., R) in which: (1) the soundness error is &epsilon;(n); (2) the number of rounds is at most k(n); (3) the proof length is at most l(n); (4) the query complexity is at most q(n). We sometimes also specify the time and/or space complexity of the (honest) prover algorithm and/or (honest) verifier algorithm.</p>

    <p class="text-gray-300">Finally, an IPCP is <em>non-adaptive</em> if the verifier queries are non-adaptive, i.e., the queried locations depend only on the verifier's inputs; it is <em>public-coin</em> if each verifier message is chosen uniformly and independently at random, and all of the verifier queries happen after receiving the last prover message. <em>All of the IPCPs discussed in this paper are both non-adaptive and public-coin.</em></p>

    <p class="text-gray-300">We define the notion of zero knowledge for IPCPs that we consider: <em>perfect zero knowledge via straightline simulators</em>. This notion is quite strong not only because it unconditionally guarantees perfect simulation of the verifier's view but also because straightline simulation typically implies desirable properties. We first provide context and then definitions.</p>

    <p class="text-gray-300">At a high level, zero knowledge requires that the verifier's view can be efficiently simulated without the prover. Converting the informal statement into a mathematical one involves many choices, including choosing which verifier class to consider (e.g., the honest verifier? all polynomial-time verifiers?), the quality of the simulation (e.g., is it identically distributed to the view? statistically close to it? computationally close to it?), the simulator's dependence on the verifier (e.g., is it non-uniform? or is the simulator universal?), and others. The definition below considers the case of perfect simulation via universal simulators against verifiers making a bounded number of queries to the proof oracle.</p>

    <p class="text-gray-300">Moreover, in the case of universal simulators, one distinguishes between a non-blackbox use of the verifier, which means that the simulator takes the verifier's code as input, and a blackbox use of it, which means that the simulator only accesses the verifier via a restricted interface; we consider this latter case. Different models of proof systems call for different interfaces, which grant carefully-chosen &quot;extra powers&quot; to the simulator (in comparison to the prover) so to ensure that efficiency of the simulation does not imply the ability to efficiently decide the language. For example: in ZK IPs, the simulator may rewind the verifier; in ZK PCPs, the simulator may adaptively answer oracle queries. In ZK IPCPs (our setting), the natural definition would allow a blackbox simulator to rewind the verifier <em>and also</em> to adaptively answer oracle queries. The definition below, however, considers only simulators that are straightline <a href="#page-61-17">[FS89;</a> <a href="#page-61-18">DS98]</a>, that is they do not rewind the verifier, because our constructions achieve this stronger notion.</p>

    <p class="text-gray-300">We are now ready to define the notion of perfect zero knowledge via straightline simulators for IPCPs <a href="#page-61-13">[GIMS10]</a>.</p>

    <p class="text-gray-300">Definition 4.2. <em>Let</em> A, B <em>be algorithms and</em> x, y <em>strings. We denote by</em> View hB(y), A(x)i <em>the</em> view <em>of</em> A(x) <em>in an IPCP protocol with</em> B(y)<em>, i.e., the random variable</em> (x, r, s1, . . . , sn, t1, . . . , tm) <em>where</em> x <em>is</em> A<em>'s input,</em> r <em>is</em> A<em>'s randomness,</em> s1, . . . , s<sup>n</sup> <em>are</em> B<em>'s messages, and</em> t1, . . . , t<sup>m</sup> <em>are the answers to</em> A<em>'s queries to the proof oracle sent by</em> B<em>.</em></p>

    <p class="text-gray-300">Straightline simulators in the context of IPs were used in [FS89], and later defined in [DS98]. The definition below considers this notion in the context of IPCPs, where the simulator also has to answer oracle queries by the verifier. Note that since we consider the notion of perfect zero knowledge, the definition of straightline simulation needs to allow the efficient simulator to work even with inefficient verifiers [GIMS10].</p>

    <p class="text-gray-300"><strong>Definition 4.3.</strong> We say that an algorithm B has <strong>straightline access</strong> to another algorithm A if B interacts with A, without rewinding, by exchanging messages with A and also answering any oracle queries along the way. We denote by  <span class="math">B^A</span>  the concatenation of A's random tape and B's output. (Since A's random tape could be super-polynomially large, B cannot sample it for A and then output it; instead, we restrict B to not see it, and we prepend it to B's output.)</p>

    <p class="text-gray-300"><strong>Definition 4.4.</strong> An IPCP system (P,V) for a relation  <span class="math">\\mathscr{R}</span>  is perfect zero knowledge (via straightline simulators) against unbounded queries (resp., against query bound b) with simulator overhead  <span class="math">s: \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}</span>  if there exists a simulator algorithm S such that for every algorithm (resp., b-query algorithm)  <span class="math">\\tilde{V}</span>  and instance-witness pair  <span class="math">(x, w) \\in \\mathscr{R}</span> ,  <span class="math">S^{\\tilde{V}}(x)</span>  and View  <span class="math">\\langle P(x, w), \\tilde{V}(x) \\rangle</span>  are identically distributed. Moreover, S must run in time  <span class="math">O(s(|x|, q_{\\tilde{V}}(|x|)))</span> , where  <span class="math">q_{\\tilde{V}}(\\cdot)</span>  is  <span class="math">\\tilde{V}</span> 's query complexity.</p>

    <p class="text-gray-300">The case of a language  <span class="math">\\mathcal{L}</span>  is similar: the quantification is for all  <span class="math">x \\in \\mathcal{L}</span>  and the view to simulate is  <span class="math">View \\langle P(x), \\tilde{V}(x) \\rangle</span> .</p>

    <p class="text-gray-300"><strong>Remark 4.5.</strong> Throughout this paper, an algorithm is b-query if it makes <u>strictly fewer than</u> b queries to its oracle. This is because all of our results will be of a 'query threshold' character, i.e. if the verifier makes b queries it learns some information, but any verifier making strictly fewer queries learns nothing.</p>

    <p class="text-gray-300"><strong>Remark 4.6.</strong> The standard definition of zero knowledge allows the simulator overhead s to be any fixed polynomial.</p>

    <p class="text-gray-300"><strong>Remark 4.7.</strong> The definition above places a strict bound on the running time of the simulator. This is in contrast to most zero knowledge results, which can only bound its <em>expected</em> running time.</p>

    <p class="text-gray-300">We say that a language  <span class="math">\\mathcal{L}</span>  (resp., relation  <span class="math">\\mathcal{R}</span> ) belongs to the complexity class  <span class="math">\\mathbf{PZK}</span> - <span class="math">\\mathbf{IPCP}[\\varepsilon, k, l, q, b, s]</span>  if there is an IPCP system for  <span class="math">\\mathcal{L}</span>  (resp.,  <span class="math">\\mathcal{R}</span> ), with the corresponding parameters, that is perfect zero knowledge with query bound b; also, it belongs to the complexity class  <span class="math">\\mathbf{PZK}</span> - <span class="math">\\mathbf{IPCP}[\\varepsilon, k, l, q, *, s]</span>  if the same is true with unbounded queries. In this paper we only consider zero knowledge against bounded queries. (Note that, even in this case, one can 'cover' all polynomial-time malicious verifiers by setting b to be superpolynomial in the input size.)</p>

    <p class="text-gray-300"><strong>Remark 4.8.</strong> Kalai and Raz [KR08] give a general transformation for IPCPs that reduces the verifier's query complexity q to 1. The transformation preserves our zero knowledge guarantee, with a small increase in the simulator overhead.</p>

      <h3 id="sec-4.5" class="text-xl font-semibold mt-8">4.5 Sumcheck protocol and its zero knowledge variant</h3>

    <p class="text-gray-300">The sumcheck protocol [LFKN92] is a fundamental building block of numerous results in complexity theory and cryptography. We rely on it in Section 6, so we briefly review it here. The protocol consists of an Interactive Proof for a claim of the form &quot; <span class="math">\\sum_{\\alpha_1,\\dots,\\alpha_m\\in H}F(\\alpha_1,\\dots,\\alpha_m)=a</span> &quot;, where F is an m-variate polynomial of individual degree d with coefficients in a finite field  <span class="math">\\mathbb{F},H</span>  is a subset of  <span class="math">\\mathbb{F}</span> , and a is an element of  <span class="math">\\mathbb{F}</span> . The prover and verifier receive  <span class="math">(\\mathbb{F},m,d,H,a)</span>  as input; in addition, the prover receives F as input while the verifier has only oracle access to F. In the i-th round, the prover sends the univariate polynomial  <span class="math">F_i(X):=\\sum_{\\alpha_{i+1},\\dots,\\alpha_m\\in H}F(c_1,\\dots,c_{i-1},X,\\alpha_{i+1},\\dots,\\alpha_m)</span> , and the verifier replies with a uniformly random element  <span class="math">c_i\\in\\mathbb{F}</span>  and checks that  <span class="math">F_{i-1}(c_{i-1})=\\sum_{\\alpha\\in H}F_i(\\alpha)</span>  (defining  <span class="math">F_0(c_0)</span>  to be the element a). At the end of the interaction, the verifier also checks that  <span class="math">F_m(c_m)=F(c_1,\\dots,c_m)</span> , by querying F at the random location  <span class="math">(c_1,\\dots,c_m)</span> . This interactive proof is public-coin, and has m rounds, communication complexity poly(log  <span class="math">|\\mathbb{F}|,m</span> ), and soundness error  <span class="math">\\frac{md}{|\\mathbb{F}|}</span> . The prover runs in time poly(log  <span class="math">|\\mathbb{F}|,|H|^m</span> ) and space poly(log  <span class="math">|\\mathbb{F}|,m,|H|</span> ) and the verifier runs in time poly(log  <span class="math">|\\mathbb{F}|,m,d,|H|</span> ) and space  <span class="math">O(\\log |\\mathbb{F}|\\cdot m)</span> .</p>

    <p class="text-gray-300">The sumcheck protocol is <em>not</em> zero knowledge, because the prover reveals partial sums of F to the verifier. If we assume the existence of one-way functions, the protocol can be made computational zero knowledge by leveraging the fact that it is public-coin [GMR89; IY87; BGGHKMR88] (in fact, if we further assume the hardness of certain problems related to discrete logarithms then more efficient transformations are known [CD98]); moreover, there is strong evidence that assuming one-way functions is necessary [Ost91; OW93]. Even more, achieving statistical zero knowledge for sumcheck instances would cause unlikely complexity-theoretic collapses [For87; AH91].</p>

    <p class="text-gray-300">Nevertheless, [BCFGRS16] have shown that, in the <em>Interactive PCP</em> model (see Section 4.3), a simple variant of the sumcheck protocol is <em>perfect zero knowledge</em>. The variant is as follows: the prover sends a proof oracle containing the evaluation of a random m-variate polynomial A of individual degree d, conditioned on summing to 0 on  <span class="math">H^m</span> ; the verifier replies with a random element  <span class="math">\\rho \\in \\mathbb{F}</span> ; then the prover and verifier engage in a sumcheck protocol for the claim &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} \\rho F(\\vec{\\alpha}) + A(\\vec{\\alpha}) = a</span> &quot;, with the verifier accessing A via self-correction (after low-degree testing it). The proof oracle thus consists of  <span class="math">|\\mathbb{F}|^m</span>  field elements, and the verifier accesses only poly( <span class="math">\\log |\\mathbb{F}|, m, d</span> ) of them.</p>

    <p class="text-gray-300">The auxiliary polynomial A acts as a &quot;masking polynomial&quot;, and yields the following zero knowledge guarantee: there exists a polynomial-time simulator algorithm that perfectly simulates the view of any malicious verifier, provided it can query F in as many locations as the total number of queries that the malicious verifier makes to either F or A.</p>

    <p class="text-gray-300">We have described in Section 2.2 an algebraic commitment scheme based on the sumcheck protocol and lower bounds on the algebraic query complexity of polynomial summation. The purpose of this section is to describe this construction in more detail, and then provide formal statements for the necessary lower bounds.</p>

    <p class="text-gray-300">We begin with the case of committing to a single element  <span class="math">a \\in \\mathbb{F}</span> . The prover chooses a uniformly random string  <span class="math">B \\in \\mathbb{F}^N</span>  such that  <span class="math">\\sum_{i=1}^N B_i = a</span> , for some  <span class="math">N \\in \\mathbb{N}</span> . Fixing some  <span class="math">d \\in \\mathbb{N}</span> ,  <span class="math">G \\subseteq \\mathbb{F}</span>  and  <span class="math">k \\in \\mathbb{N}</span>  such that  <span class="math">|G| \\leq d+1</span>  and  <span class="math">|G|^k = N</span> , the prover views B as a function from  <span class="math">G^k</span>  to  <span class="math">\\mathbb{F}</span>  (via an ordering on  <span class="math">G^k</span> ) and sends the evaluation of a degree-d extension  <span class="math">\\hat{B} \\colon \\mathbb{F}^k \\to \\mathbb{F}</span>  of B. The verifier tests that  <span class="math">\\hat{B}</span>  is indeed (close to) a low-degree polynomial but (ideally) cannot learn any information about a without reading all of B (i.e., without making N queries). Subsequently, the prover can decommit to a by convincing the verifier that  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} \\hat{B}(\\vec{\\beta}) = a</span>  via the sumcheck protocol.</p>

    <p class="text-gray-300">To show that the above is a commitment scheme, we must show both binding and hiding. Both properties depend on the choice of d. The binding property follows from the soundness of the sumcheck protocol, and we thus would like the degree d of  <span class="math">\\hat{B}</span>  to be as small as possible. A natural choice would be d=1 (so |G|=2), which makes  <span class="math">\\hat{B}</span>  the unique multilinear extension of B. However (as discussed in Section 2.2) this choice of parameters does not provide any hiding: it holds that  <span class="math">\\sum_{\\beta \\in \\{0,1\\}^k} B(\\beta) = \\hat{B}(2^{-1},\\ldots,2^{-1}) \\cdot 2^k</span>  (as long as  <span class="math">\\operatorname{char}(\\mathbb{F}) \\neq 2</span> ). We therefore need to understand how the choice of d affects the number of queries to  <span class="math">\\hat{B}</span>  required to compute a. This is precisely the setting of algebraic query complexity, which we discuss next.</p>

    <p class="text-gray-300">The algebraic query complexity (defined in [AW09] to study 'algebrization') of a function f is the (worst-case) number of queries to some low-degree extension  <span class="math">\\hat{B}</span>  of a string B required to compute f(B). This quantity is bounded from above by the standard query complexity of f, but it may be the case (as above) that the low-degree extension confers additional information that helps in computing f with fewer queries. The usefulness of this information depends on parameters d and G of the low-degree extension. Our question amounts to understanding this dependence for the function  <span class="math">\\mathrm{SUM}\\colon \\mathbb{F}^N \\to \\mathbb{F}</span>  given by  <span class="math">\\mathrm{SUM}(B) := \\sum_{i=1}^N B_i</span> . This has been studied before in [JKRS09]: if  <span class="math">G = \\{0,1\\}</span>  and d=2 then the algebraic query complexity of  <span class="math">\\mathrm{SUM}</span>  is exactly N.</p>

    <p class="text-gray-300">For our purposes, however, it is not enough to commit to a single field element. Rather, we need to commit to the evaluation of a polynomial  <span class="math">Q\\colon \\mathbb{F}^m\\to \\mathbb{F}</span>  of degree  <span class="math">d_Q</span> , which we do as follows. Let K be a subset of  <span class="math">\\mathbb{F}</span>  of size  <span class="math">d_Q+1</span> . The prover samples, for each  <span class="math">\\vec{\\alpha}\\in K^m</span> , a random string  <span class="math">B^{\\vec{\\alpha}}\\in \\mathbb{F}^N</span>  such that  <span class="math">\\mathrm{SUM}(B^{\\vec{\\alpha}})=Q(\\vec{\\alpha})</span> . The prover views these strings as a function  <span class="math">B\\colon K^m\\times G^k\\to \\mathbb{F}</span> , and takes a low-degree extension  <span class="math">\\hat{B}\\colon \\mathbb{F}^m\\times \\mathbb{F}^k\\to \\mathbb{F}</span> . The polynomial  <span class="math">\\hat{B}(\\vec{X},\\vec{Y})</span>  has degree  <span class="math">d_Q</span>  in  <span class="math">\\vec{X}</span>  and d in  <span class="math">\\vec{Y}</span> ; this is a commitment to Q because  <span class="math">\\sum_{\\vec{\\beta}\\in G^k}\\hat{B}(\\vec{X},\\vec{\\beta})</span>  is a degree- <span class="math">d_Q</span>  polynomial that agrees with Q on  <span class="math">K^m</span> , and therefore equals Q.</p>

    <p class="text-gray-300">Once again we will decommit to  <span class="math">Q(\\vec{\\alpha})</span>  using the sumcheck protocol, and so for binding we need d to be small. For hiding, as in the single-element case, if d is too small then a few queries to  <span class="math">\\hat{\\mathcal{B}}</span>  can yield information about Q. Moreover, it could be the case that the verifier can leverage the fact that  <span class="math">\\hat{\\mathcal{B}}</span>  is a <em>joint</em> low-degree extension to learn some linear combination of evaluations of Q. We must exclude these possibilities in order to obtain our zero knowledge guarantees.</p>

    <p class="text-gray-300">This question amounts to a generalization of algebraic query complexity where, given a list of strings  <span class="math">B_1, \\ldots, B_M</span> , we determine how many queries we need to make to their <em>joint</em> low-degree extension  <span class="math">\\hat{B}</span>  to determine any nontrivial linear combination  <span class="math">\\sum_{i=1}^M c_i \\cdot \\text{SUM}(B_i)</span> . We will show that the 'generalized' algebraic query complexity of SUM is exactly N provided  <span class="math">d \\geq 2(|G|-1)</span>  (which is also the case for the standard algebraic query complexity).</p>

    <p class="text-gray-300">In the remainder of the section we state our results in a form equivalent to the above that is more useful to us. Given an arbitrary polynomial  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq d&#x27;}]</span> , we ask how many queries are required to determine any nontrivial linear combination of  <span class="math">\\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha},\\vec{y})</span>  for  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^m</span> . The following theorem is more general: it states that not only do we require many queries to determine <em>any</em> linear combination, but that the number of queries grows linearly with the number of independent combinations that we wish to learn.</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> (algebraic query complexity of polynomial summation). Let  <span class="math">\\mathbb{F}</span>  be a field,  <span class="math">m, k, d, d&#x27; \\in \\mathbb{N}</span> , and G, K, L be finite subsets of  <span class="math">\\mathbb{F}</span>  such that  <span class="math">K \\subseteq L</span> ,  <span class="math">d&#x27; \\ge |G| - 2</span> , and |K| = d + 1. If  <span class="math">S \\subseteq \\mathbb{F}^{m+k}</span>  is such that there exist matrices  <span class="math">C \\in \\mathbb{F}^{L^m \\times \\ell}</span>  and  <span class="math">D \\in \\mathbb{F}^{S \\times \\ell}</span>  such that for all  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\le d}, Y_{1,\\dots,k}^{\\le d&#x27;}]</span>  and all  <span class="math">i \\in \\{1,\\dots,\\ell\\}</span></p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in L^m} C_{\\vec{\\alpha},i} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{q} \\in S} D_{\\vec{q},i} Z(\\vec{q}) \\enspace ,</span>$</p>

    <p class="text-gray-300">then  <span class="math">|S| \\ge \\operatorname{rank}(BC) \\cdot (\\min\\{d&#x27; - |G| + 2, |G|\\})^k</span> , where  <span class="math">B \\in \\mathbb{F}^{K^m \\times L^m}</span>  is such that column  <span class="math">\\vec{\\alpha}</span>  of B represents  <span class="math">Z(\\vec{\\alpha})</span> in the basis  <span class="math">(Z(\\vec{\\beta}))_{\\vec{\\beta} \\in K^m}</span> .</p>

    <p class="text-gray-300">We describe a special case of the above theorem that is necessary for our zero knowledge results, and then give an equivalent formulation in terms of random variables that we use in later sections. (Essentially, the linear structure of the problem implies that 'worst-case' statements are equivalent to 'average-case' statements.)</p>

    <p class="text-gray-300"><strong>Corollary 5.2.</strong> Let  <span class="math">\\mathbb{F}</span>  be a finite field, G be a subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">d, d&#x27; \\in \\mathbb{N}</span>  with  <span class="math">d&#x27; \\geq 2(|G| - 1)</span> . If  <span class="math">S \\subseteq \\mathbb{F}^{m+k}</span>  is such that there exist  <span class="math">(c_{\\vec{\\alpha}})_{\\vec{\\alpha} \\in \\mathbb{F}^m}</span>  and  <span class="math">(d_{\\vec{\\beta}})_{\\vec{\\beta} \\in \\mathbb{F}^{m+k}}</span>  such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for all  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq d&#x27;}]</span>  it holds that  <span class="math">\\sum_{\\vec{\\alpha} \\in \\mathbb{F}^m} c_{\\vec{\\alpha}} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{q} \\in S} d_{\\vec{q}} Z(\\vec{q})</span>  and there exists  <span class="math">Z&#x27; \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq d&#x27;}]</span>  such that  <span class="math">\\sum_{\\vec{\\alpha} \\in \\mathbb{F}^m} c_{\\vec{\\alpha}} \\sum_{\\vec{y} \\in G^k} Z&#x27;(\\vec{\\alpha}, \\vec{y}) \\neq 0</span> ,</li>
      <li>then  <span class="math">|S| \\geq |G|^k</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Corollary 5.3</strong> (equivalent statement of Corollary 5.2). Let  <span class="math">\\mathbb{F}</span>  be a finite field, G be a subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">d, d&#x27; \\in \\mathbb{N}</span>  with  <span class="math">d&#x27; \\geq 2(|G|-1)</span> . Let Q be a subset of  <span class="math">\\mathbb{F}^{m+k}</span>  with  <span class="math">|Q| &lt; |G|^k</span>  and let Z be uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}, Y_{1,\\ldots,m}^{\\leq d&#x27;}, Y_{1,\\ldots,m}^{\\leq d&#x27;}]</span> . The ensembles  <span class="math">\\left(\\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y})\\right)_{\\vec{\\alpha} \\in \\mathbb{F}^m}</span>  and  <span class="math">\\left(Z(\\vec{q})\\right)_{\\vec{q} \\in Q}</span>  are independent.</p>

    <p class="text-gray-300">The proofs of these results, and derivations of corresponding upper bounds, are provided in Appendix A.</p>

    <p class="text-gray-300">We leverage lower bounds on the algebraic query complexity of polynomial summation (Section 5) to obtain an analogue of the sumcheck protocol with a strong zero knowledge guarantee, which we use in the applications that we consider.</p>

    <p class="text-gray-300">The sumcheck protocol [LFKN92] is an Interactive Proof for claims of the form  <span class="math">\\sum_{\\vec{x} \\in H^m} F(\\vec{x}) = a</span> , where H is a subset of a finite field  <span class="math">\\mathbb{F}</span> , F is an m-variate polynomial over  <span class="math">\\mathbb{F}</span>  of individual degree at most d, and a is an element of  <span class="math">\\mathbb{F}</span> . The sumcheck protocol is not zero knowledge (conjecturally).</p>

    <p class="text-gray-300">Prior work [BCFGRS16] obtains a sumcheck protocol, in the Interactive PCP model, with a certain zero knowledge guarantee. In that protocol, the prover first sends a proof oracle that consists of the evaluation of a random m-variate polynomial R of individual degree at most d; after that, the prover and the verifier run the (standard) sumcheck protocol on a new polynomial obtained from F and R. The purpose of R is to 'mask' the partial sums, which are the intermediate values sent by the prover during the sumcheck protocol.</p>

    <p class="text-gray-300">The zero knowledge guarantee in [BCFGRS16] is the following: any verifier that makes q queries to R learns at most q evaluations of F. This guarantee suffices to obtain a zero knowledge protocol for  <span class="math">\\#\\mathbf{P}</span>  (the application in [BCFGRS16]) because the verifier can evaluate F efficiently at any point (as F is merely an arithmetization of a 3SAT formula).</p>

    <p class="text-gray-300">We achieve a much stronger guarantee: any verifier that makes polynomially-many queries to R learns at most a single evaluation of F (that, moreover, lies within a chosen subset  <span class="math">I^m</span>  of  <span class="math">\\mathbb{F}^m</span> ). Our applications require this guarantee because we use the sumcheck simulator as a sub-simulator in a larger protocol, where F is a randomized low-degree extension of some function that is hard to compute for the verifier. The randomization introduces bounded independence, which makes a small number of queries easy to simulate.</p>

    <p class="text-gray-300">The main idea to achieve zero knowledge as above is the following. Rather than sending the masking polynomial R directly, the prover sends a (perfectly-hiding and statistically-binding) commitment to it in the form of a random (m+k)-variate polynomial Z. The 'real' mask is recovered by summing out k variables:  <span class="math">R(\\vec{X}) := \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{X}, \\vec{\\beta})</span> . Our lower bounds on the algebraic query complexity of polynomial summation (Section 5) imply that any q queries to Z, with  <span class="math">q &lt; |G|^k</span> , yield no information about R. The prover, however, can elect to decommit to  <span class="math">R(\\vec{c})</span>  for a single point  <span class="math">\\vec{c} \\in I^m</span>  chosen by the verifier. This is achieved using the zero knowledge sumcheck protocol of [BCFGRS16] as a subroutine: the prover sends  <span class="math">w := R(\\vec{c})</span>  and then proves that  <span class="math">w = \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta})</span> .</p>

    <p class="text-gray-300">subroutine: the prover sends  <span class="math">w:=R(\\vec{c})</span>  and then proves that  <span class="math">w=\\sum_{\\vec{\\beta}\\in G^k}Z(\\vec{c},\\vec{\\beta})</span> .</p>

    <p class="text-gray-300">The protocol thus proceeds as follows. Given a security parameter  <span class="math">\\lambda\\in\\mathbb{N}</span> , the prover sends the evaluations of two polynomials  <span class="math">Z\\in\\mathbb{F}[X_{1,\\dots,k}^{\\leq d}]</span>  and  <span class="math">A\\in\\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  as proof oracles. The verifier checks that both of these evaluations are close to low-degree, and uses self-correction to make for querying them. The prover sends two field elements  <span class="math">z_1</span>  and  <span class="math">z_2</span> , which are (allegedly) the summations of Z and A over  <span class="math">H^m\\times G^k</span>  and  <span class="math">G^k</span> , respectively. The verifier replies with a random challenge  <span class="math">\\rho\\in\\mathbb{F}\\setminus\\{0\\}</span> . The prover and the verifier then engage in the standard (not zero knowledge) sumcheck protocol on the claim &quot; <span class="math">\\sum_{\\vec{\\alpha}\\in H^m}\\rho F(\\vec{\\alpha})+R(\\vec{\\alpha})=\\rho a+z_1</span> &quot;. This reduces the correctness of this claim to checking a claim of the form &quot; <span class="math">\\rho F(\\vec{c})+R(\\vec{c})=b</span> &quot; for some  <span class="math">\\vec{c}\\in I^m</span>  and  <span class="math">b\\in\\mathbb{F}</span> ; the prover then decommits to  <span class="math">w:=R(\\vec{c})</span>  as above. In sum, the verifier deduces that, with high probability, the claim &quot; <span class="math">\\rho F(\\vec{c})=b-w</span> &quot; is true if and only if the original claim was.</p>

    <p class="text-gray-300">If the verifier could evaluate F then the verifier could simply check the aforementioned claim and either accept or reject. We do not give the verifier access to F and, instead, we follow [Mei13] and phrase sumcheck as a <em>reduction</em> from a claim about a sum of a polynomial over a large product space to a claim about the evaluation of that polynomial at a single point. This view of the sumcheck protocol is useful later on when designing more complex protocols, which employ sumcheck as a subprotocol. The completeness and soundness definitions below are thus modified according to this viewpoint, where the verifier simply outputs the claim at the end.</p>

    <p class="text-gray-300">Our protocol will be sound relative to a promise variant of the sumcheck protocol, which we now define.</p>

    <p class="text-gray-300"><strong>Definition 6.1.</strong> The sumcheck relation and its promise variant are defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The sumcheck relation is the relation  <span class="math">\\mathscr{R}_{SC}</span>  of instance-witness pairs  <span class="math">((\\mathbb{F}, m, d, H, a), F)</span>  such that:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathbb{F}</span>  is a finite field, H is a subset of  <span class="math">\\mathbb{F}</span> , a is an element of  <span class="math">\\mathbb{F}</span> , and m, d are positive integers with  <span class="math">\\frac{md}{|\\mathbb{F}|} &lt; \\frac{1}{2}</span> ;</li>
      <li>F is a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span>  and sums to a on  <span class="math">H^m</span> .</li>
    </ul></li>
      <li>The sumcheck promise relation is the pair of relations  <span class="math">(\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{yes}}, \\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{no}})</span>  where  <span class="math">\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{yes}} := \\mathscr{R}_{\\mathrm{SC}}</span>  and  <span class="math">\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{no}}</span>  are the pairs  <span class="math">\\left((\\mathbb{F}, m, d, H, a), F\\right)</span>  such that  <span class="math">(\\mathbb{F}, m, d, H, a)</span>  is as above and F is in  <span class="math">\\mathbb{F}[X_{1, \\dots, m}^{\\leq d}]</span>  but does <u>not</u> sum to a on  <span class="math">H^m</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Remark 6.2.</strong> In the case where the verifier can easily determine that F is low-degree (e.g., F is given as an arithmetic circuit), a protocol for the promise relation can be used to check the plain relation. In our setting, the verifier cannot even access F, and so the promise is necessary.</p>

    <p class="text-gray-300">The definition below captures our zero knowledge goal for the sumcheck promise relation, in the Interactive PCP model. The key aspect of this definition is that the simulator is only allowed to make a <em>single</em> query to the summand polynomial F; in contrast, the definition of [BCFGRS16] allows the simulator to make as many queries to F as the malicious verifier makes to the proof oracle. (Another aspect, motivated by the simulator's limitation, is that we now have to explicitly consider a bound b on a malicious verifier's queries.) This <em>strong</em> form of zero knowledge, achieved by severely restricting the simulator's access to F, is crucial for achieving the results in our paper.</p>

    <p class="text-gray-300"><strong>Definition 6.3.</strong> A b-strong perfect zero knowledge Interactive PCP system for sumcheck with soundness error  <span class="math">\\varepsilon</span>  is a pair of interactive algorithms (P, V) that satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>COMPLETENESS. For every  <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)\\in\\mathscr{R}^{\\mathsf{yes}}_{\\mathsf{SC}},\\,V(\\mathbb{F},m,d,H,a)</span>  when interacting with  <span class="math">P^F(\\mathbb{F},m,d,H,a)</span>  outputs a claim of the form &quot; <span class="math">F(\\vec{\\gamma})=a</span> &quot; (with  <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^m</span>  and  <span class="math">a\\in\\mathbb{F}</span> ) that is true with probability 1.</li>
      <li>SOUNDNESS. For every  <span class="math">((\\mathbb{F}, m, d, H, a), F) \\in \\mathscr{R}^{no}_{SC}</span>  and malicious prover  <span class="math">\\tilde{P}</span> ,  <span class="math">V(\\mathbb{F}, m, d, H, a)</span>  when interacting with  <span class="math">\\tilde{P}</span>  outputs a claim of the form &quot; <span class="math">F(\\vec{\\gamma}) = a</span> &quot; (with  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span>  and  <span class="math">a \\in \\mathbb{F}</span> ) that is true with probability at most  <span class="math">\\varepsilon</span> .</li>
      <li>ZERO KNOWLEDGE. There exists a straightline simulator S such that, for every instance-witness pair  <span class="math">((\\mathbb{F}, m, d, H, a), F) \\in \\mathscr{R}^{\\mathsf{yes}}_{\\mathsf{SC}}</span>  and b-query malicious verifier  <span class="math">\\tilde{V}</span> , the following two distributions are equal</li>
    </ul>

    <p class="text-gray-300"><span class="math">$S^{\\tilde{V},F}(\\mathbb{F},m,d,H,a)</span>$
and View  <span class="math">\\langle P^F(\\mathbb{F},m,d,H,a), \\tilde{V} \\rangle</span> .</p>

    <p class="text-gray-300">Moreover, the simulator S makes  <span class="math">\\underline{only\\ a\\ single\\ query}</span>  to F (at a location that possibly depends on  <span class="math">\\tilde{V}</span>  and its random choices) and runs in time  <span class="math">\\operatorname{poly}(\\log |\\mathbb{F}|, m, d, |H|, \\mathsf{q}_{\\tilde{V}})</span> , where  <span class="math">\\mathsf{q}_{\\tilde{V}}</span>  is  <span class="math">\\tilde{V}</span> 's query complexity.</p>

    <p class="text-gray-300">The main result of this section, stated below, is a construction that efficiently fulfills the definition above.</p>

    <p class="text-gray-300"><strong>Theorem 6.4</strong> (Strong PZK Sumcheck). For every positive integer  <span class="math">\\lambda</span>  with  <span class="math">\\lambda \\leq |\\mathbb{F}|</span> , positive integer k, and subset I of  <span class="math">\\mathbb{F}</span> , there exists a  <span class="math">\\lambda^k</span> -strong perfect zero knowledge Interactive PCP system (P,V) for sumcheck with soundness error  <span class="math">\\varepsilon = O(\\frac{(m+k)\\cdot(d+\\lambda)}{|I|})</span>  and the following efficiency parameters.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Oracle round: P sends an oracle proof string  <span class="math">\\pi</span> , consisting of the evaluation tables of polynomials  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  and  <span class="math">A \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  drawn uniformly at random.</li>
      <li>Interactive proof: after the oracle round, P and V engage in an (m+k+1)-round interactive proof; across the interaction, the verifier sends to the prover m+k+1 field elements, while the prover sends to the verifier  <span class="math">O((m+k)\\cdot d)</span>  field elements. (In particular, the interaction is public-coin.)</li>
      <li>Queries: after the interactive proof, V non-adaptively queries  <span class="math">\\pi</span>  at poly(log  <span class="math">|\\mathbb{F}|</span> , m, d) locations.</li>
      <li>Space and time:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P runs in time  <span class="math">|\\mathbb{F}|^{O(m+k)}</span>  and space poly <span class="math">(\\log |\\mathbb{F}|, d^m, \\lambda^k, |H|)</span> , and</li>
      <li>V runs in time poly( <span class="math">\\log |\\mathbb{F}|, m, d, |H|, k, \\lambda</span> ) and space  <span class="math">O((m+k) \\log |\\mathbb{F}|)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">In addition, there is a simulator S witnessing perfect zero knowledge for (P,V) such that S's single query to the summand polynomial F belongs to the set  <span class="math">I^m</span> , and S runs in time  <span class="math">\\operatorname{poly}(|H|, m, d, k, \\lambda, \\log |\\mathbb{F}|) \\cdot \\mathsf{q}_{\\widetilde{V}}^3</span> .</p>

    <p class="text-gray-300"><strong>Remark 6.5.</strong> With two-way access to the random tape, the prover can be made to run in space poly <span class="math">(\\log |\\mathbb{F}|, d, m, \\lambda, k, |H|)</span> .</p>

    <p class="text-gray-300">We divide the proof in two steps. First (Section 6.1), we exhibit a protocol with the above properties in a hybrid model in which the prover and verifier have access to random low-degree polynomials. Second (Section 6.2), we use low-degree testing and self-correction to 'compile' this protocol into an Interactive PCP.</p>

    <p class="text-gray-300">We construct a public-coin Interactive Proof for sumcheck that achieves zero knowledge in a model where the prover and verifier have access to certain low-degree polynomials. In the soundness case, these may be arbitrary; in the zero knowledge case, these are random and depend only on the size parameters of the instance.</p>

    <p class="text-gray-300"><strong>Construction 6.6.</strong> Let G be any subset of  <span class="math">\\mathbb{F}</span>  of size  <span class="math">\\lambda</span> . In the Interactive Proof system  <span class="math">(P_{\\mathrm{IP}}^{\\star}, V_{\\mathrm{IP}}^{\\star})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  and  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  receive a sumcheck instance  <span class="math">(\\mathbb{F}, m, d, H, a)</span>  as common input;</li>
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  and  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  receive polynomials  <span class="math">Z \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}, Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>  and  <span class="math">A \\in \\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>  as oracles;</li>
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  additionally receives a summand polynomial  <span class="math">F \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span>  as an oracle.</li>
    </ul>

    <p class="text-gray-300">The interaction between  <span class="math">P_{\\mathrm{IP}}^{\\star}</span>  and  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  sends two elements in  <span class="math">\\mathbb{F}</span>  to  <span class="math">V_{\\mathrm{IP}}^{\\star}</span> :  <span class="math">z_1 := \\sum_{\\vec{\\alpha} \\in H^m} \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{\\alpha}, \\vec{\\beta})</span>  and  <span class="math">z_2 := \\sum_{\\vec{\\beta} \\in G^k} A(\\vec{\\beta})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span>  draws a random element  <span class="math">\\rho_1</span>  in  <span class="math">\\mathbb{F}\\setminus\\{0\\}</span>  and sends it to  <span class="math">P_{\\mathrm{IP}}^{\\star}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  and  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  run the sumcheck IP [LFKN92] on the statement &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha}) = \\rho_1 a + z_1</span> &quot; where</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$Q(X_1, \\dots, X_m) := \\rho_1 F(X_1, \\dots, X_m) + \\sum_{\\vec{\\beta} \\in G^k} Z(X_1, \\dots, X_m, \\vec{\\beta}) ,</span>$</p>

    <p class="text-gray-300">with  <span class="math">P_{\\mathrm{IP}}^{\\star}</span>  playing the role of the prover and  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  that of the verifier, and the following modification.</p>

    <p class="text-gray-300">For  <span class="math">i=1,\\ldots,m</span> , in the i-th round,  <span class="math">V_{\\mathrm{IP}}^{\\star}</span>  samples its random element  <span class="math">c_i</span>  from the set I rather than from all of  <span class="math">\\mathbb{F}</span> ; if  <span class="math">P_{\\mathrm{IP}}^{\\star}</span>  ever receives  <span class="math">c_i \\in \\mathbb{F} \\setminus I</span> , it immediately aborts. In particular, in the m-th round,  <span class="math">P_{\\mathrm{IP}}^{\\star}</span>  sends a polynomial  <span class="math">g_m(X_m) := \\rho_1 F(c_1,\\ldots,c_{m-1},X_m) + \\sum_{\\vec{\\beta} \\in G^k} Z(c_1,\\ldots,c_{m-1},X_m,\\vec{\\beta})</span>  for some  <span class="math">c_1,\\ldots,c_{m-1} \\in I</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{\\text{IP}}^{\\star}</span>  sends  <span class="math">c_m \\in I</span>  to  <span class="math">P_{\\text{IP}}^{\\star}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span>  sends the element  <span class="math">w:=\\sum_{\\vec{\\beta}\\in G^k}Z(\\vec{c},\\vec{\\beta})</span>  to  <span class="math">V_{\\mathrm{IP}}^{\\star}</span> , where  <span class="math">\\vec{c}:=(c_1,\\ldots,c_m)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span>  draws a random element  <span class="math">\\rho_2</span>  in  <span class="math">\\mathbb{F} \\setminus \\{0\\}</span>  and sends it to  <span class="math">P_{\\mathrm{IP}}^{\\star}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">P_{\\text{IP}}^{\\star}</span>  and  <span class="math">V_{\\text{IP}}^{\\star}</span>  engage in the sumcheck IP [LFKN92] on the claim &quot; <span class="math">\\sum_{\\vec{\\beta} \\in G^k} \\rho_2 Z(\\vec{c}, \\vec{\\beta}) + A(\\vec{\\beta}) = \\rho_2 w + z_2</span> &quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span>  outputs the claim &quot; <span class="math">F(\\vec{c}) = \\frac{g_m(c_m) w}{\\rho_1}</span> &quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">We prove the following lemma about the construction above.</p>

    <p class="text-gray-300"><strong>Lemma 6.7.</strong> The IP system  <span class="math">(P_{\\rm IP}^{\\star}, V_{\\rm IP}^{\\star})</span>  satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness. For every instance-witness pair  <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)\\in\\mathscr{R}^{\\mathsf{yes}}_{\\mathrm{SC}}</span> , polynomial  <span class="math">Z\\in\\mathbb{F}[X^{\\leq d}_{1,\\dots,m},Y^{\\leq 2\\lambda}_{1,\\dots,k}]</span> , and polynomial  <span class="math">A\\in\\mathbb{F}[Y^{\\leq 2\\lambda}_{1,\\dots,k}]</span> ,  <span class="math">V^{\\star}_{\\mathrm{IP}}{}^{Z,A}(\\mathbb{F},m,d,H,a)</span>  when interacting with  <span class="math">P^{\\star}_{\\mathrm{IP}}{}^{F,Z,A}(\\mathbb{F},m,d,H,a)</span>  outputs a claim of the form &quot; <span class="math">F(\\vec{\\gamma})=a</span> &quot; (with  <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^m</span>  and  <span class="math">a\\in\\mathbb{F}</span> ) that is true with probability 1.</li>
      <li>SOUNDNESS. For every instance-witness pair  <span class="math">((\\mathbb{F}, m, d, H, a), F) \\in \\mathscr{R}^{\\text{no}}_{SC}</span> , polynomial  <span class="math">Z \\in \\mathbb{F}[X^{\\leq d}_{1,\\dots,m}, Y^{\\leq 2\\lambda}_{1,\\dots,k}]</span> , polynomial  <span class="math">A \\in \\mathbb{F}[Y^{\\leq 2\\lambda}_{1,\\dots,k}]</span> , and malicious prover  <span class="math">\\tilde{P}</span> ,  <span class="math">V^{\\star}_{IP}{}^{Z,A}(\\mathbb{F}, m, d, H, a)</span>  when interacting with  <span class="math">\\tilde{P}</span>  outputs a claim of the form &quot; <span class="math">F(\\vec{\\gamma}) = a</span> &quot; (with  <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span>  and  <span class="math">a \\in \\mathbb{F}</span> ) that is true with probability at most  <span class="math">\\frac{md}{|I|} + \\frac{k \\cdot 2\\lambda + 2}{|\\mathbb{F}| 1}</span> .</li>
      <li>ZERO KNOWLEDGE. There exists a straightline simulator  <span class="math">S_{\\mathrm{IP}}^{\\star}</span>  such that, for every instance-witness pair  <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)\\in \\mathscr{R}_{\\mathrm{SC}}^{\\mathsf{yes}}</span>  and  <span class="math">\\lambda^k</span> -query malicious verifier  <span class="math">\\tilde{V}</span> , the following two distributions are equal</li>
    </ul>

    <p class="text-gray-300"><span class="math">$S^{\\star \\; \\tilde{V},F}_{\\mathrm{IP}}(\\mathbb{F},m,d,H,a) \\quad \\textit{and} \\quad \\mathrm{View} \\; \\langle P^{\\star \\; F,Z,A}_{\\mathrm{IP}}(\\mathbb{F},m,d,H,a), \\tilde{V}^{Z,A} \\rangle \\;\\; ,</span>$</p>

    <p class="text-gray-300">where Z is uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  and A is uniformly random in  <span class="math">\\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> . Moreover:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">S_{1P}^{\\star}</span>  makes a single query to F at a point in  <span class="math">I^{m}</span> ;</li>
      <li><span class="math">S_{\\text{IP}}^{\\star}</span>  runs in time</li>
    </ul>

    <p class="text-gray-300"><span class="math">$(m+k)((d+\\lambda)\\mathsf{q}_{\\tilde{V}}|H|+(d+\\lambda)^3\\mathsf{q}_{\\tilde{V}}^3)\\cdot\\operatorname{poly}(\\log|\\mathbb{F}|)=\\operatorname{poly}(|H|,m,d,k,\\lambda,\\log|\\mathbb{F}|)\\cdot\\mathsf{q}_{\\tilde{V}}^3</span>$</p>

    <p class="text-gray-300">where  <span class="math">q_{\\tilde{V}}</span>  is  <span class="math">\\tilde{V}</span> 's query complexity;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">S_{\\text{IP}}^{\\star}</span> 's behavior does not depend on a until after the simulated  <span class="math">\\tilde{V}</span>  sends its first message.</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Completeness is clear from the protocol description and the completeness property of sumcheck. Soundness follows from the fact that, if  <span class="math">((\\mathbb{F}, m, d, H, a), F) \\in \\mathscr{R}^{no}_{SC}</span> , we can argue as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every polynomial  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> , with probability  <span class="math">1 \\frac{1}{|\\mathbb{F}|-1}</span>  over the choice of  <span class="math">\\rho_1, \\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha}) \\neq \\rho_1 a + z_1</span> , i.e., the sumcheck claim is false.</li>
      <li>Therefore, by the soundness guarantee of sumcheck, with probability at least 1 md/|I|, either the verifier rejects or  <span class="math">\\rho_1 F(\\vec{c}) + \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta}) \\neq g_m(c_m)</span> .</li>
      <li><span class="math">\\bullet</span>  Finally, we distinguish two cases depending on  <span class="math">\\tilde{P}</span> :    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\tilde{P}</span>  sends  <span class="math">w \\neq \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta})</span> , then  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} \\rho_2 Z(\\vec{c}, \\vec{\\beta}) + A(\\vec{\\beta}) \\neq \\rho_2 w + z_2</span>  with probability  <span class="math">1 \\frac{1}{|\\mathbb{F}| 1}</span>  over the choice of  <span class="math">\\rho_2</span> , for any choice of A. In this case, by the soundness guarantee of the sumcheck protocol the verifier rejects with probability at least  <span class="math">1 \\frac{k \\cdot 2\\lambda}{|\\mathbb{F}|}</span> .</li>
      <li>If  <span class="math">\\tilde{P}</span>  sends  <span class="math">w=\\sum_{\\vec{\\beta}\\in G^k}Z(\\vec{c},\\vec{\\beta})</span> , then  <span class="math">F(\\vec{c})\\neq \\frac{g_m(c_m)-w}{\\rho_1}</span>  with probability 1.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Taking a union bound on the above cases yields the claimed soundness error.</p>

    <p class="text-gray-300">To show the (perfect) zero knowledge guarantee, we need to construct a suitably-efficient straightline simulator that perfectly simulates the view of any malicious verifier  <span class="math">\\tilde{V}</span> . We first construct an <em>inefficient</em> simulator  <span class="math">S_{\\text{slow}}^{\\star}</span> , and prove that its output follows the desired distribution; afterwards, we explain how the simulator can be made efficient.</p>

    <p class="text-gray-300">The simulator  <span class="math">S_{\\mathrm{slow}}^{\\star}</span> , given straightline access to  <span class="math">\\tilde{V}</span>  and oracle access to F, works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Draw  <span class="math">Z_{\\text{sim}} \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  and  <span class="math">A_{\\text{sim}} \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq d}]</span>  uniformly at random.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Begin simulating  <span class="math">\\tilde{V}</span> . Its queries to Z and A are answered according to  <span class="math">Z_{\\text{sim}}</span>  and  <span class="math">A_{\\text{sim}}</span>  respectively.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Send  <span class="math">z^1_{\\mathrm{sim}} := \\sum_{\\vec{\\alpha} \\in H^m} \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{\\alpha}, \\vec{\\beta})</span>  and  <span class="math">z^2_{\\mathrm{sim}} := \\sum_{\\vec{\\beta} \\in G^k} A(\\vec{\\beta})</span>  to  <span class="math">\\tilde{V}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Receive  <span class="math">\\tilde{\\rho}_1</span> . Draw  <span class="math">Q_{\\text{sim}} \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span>  uniformly at random conditioned on  <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q_{\\text{sim}}(\\vec{\\alpha}) = \\tilde{\\rho}_1 a + z_{\\text{sim}}^1</span> , then engage in the sumcheck protocol on the claim &quot; <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q_{\\text{sim}}(\\vec{\\alpha}) = \\tilde{\\rho}_1 a + z_{\\text{sim}}^1</span> &quot;. If in any round  <span class="math">\\tilde{V}</span>  sends  <span class="math">c_i \\notin I</span>  as a challenge, abort.</li>
    </ol></li>
      <li>5. Let  <span class="math">\\vec{c} \\in I^m</span>  be the point chosen by  <span class="math">\\tilde{V}</span>  in the sumcheck protocol above. Query  <span class="math">F(\\vec{c})</span> , and draw  <span class="math">Z&#x27;_{\\text{sim}} \\in \\mathbb{F}[X^{\\leq d}_{1,\\dots,m}, Y^{\\leq 2\\lambda}_{1,\\dots,k}]</span>  uniformly at random conditioned on    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\sum_{\\vec{\\alpha} \\in H^m} \\sum_{\\vec{\\beta} \\in G^k} Z&#x27;_{\\text{sim}}(\\vec{\\alpha}, \\vec{\\beta}) = z_{\\text{sim}}^1</span> ,</li>
      <li><span class="math">\\sum_{\\vec{\\beta} \\in G^k} Z&#x27;_{\\mathrm{sim}}(\\vec{c}, \\vec{\\beta}) = w_{\\mathrm{sim}}</span> , where  <span class="math">w_{\\mathrm{sim}} := Q_{\\mathrm{sim}}(\\vec{c}) \\tilde{\\rho}_1 F(\\vec{c})</span> , and</li>
      <li><span class="math">Z&#x27;_{\\rm sim}(\\vec{\\gamma}) = Z_{\\rm sim}(\\vec{\\gamma})</span>  for all previous queries  <span class="math">\\vec{\\gamma}</span>  to Z.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">From this point on, answer all queries to Z with  <span class="math">Z&#x27;_{sim}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Receive  <span class="math">\\tilde{\\rho}_2</span>  from  <span class="math">\\tilde{V}</span> . Draw  <span class="math">Q&#x27;_{\\text{sim}} \\in \\mathbb{F}[X^{\\leq d}_{1,\\dots,m}]</span>  uniformly at random conditioned on</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>   <span class="math">\\sum_{\\vec{\\beta} \\in G^k} Q_{\\text{sim}}&#x27;(\\vec{\\beta}) = \\tilde{\\rho}_2 w_{\\text{sim}} + z_{\\text{sim}}^2</span> , and</li>
      <li><span class="math">Q_{\\mathrm{sim}}^{\\prime,\\vec{i}}(\\vec{\\gamma}) = \\tilde{\\rho}_2 Z_{\\mathrm{sim}}^{\\prime}(\\vec{c},\\vec{\\gamma}) + A_{\\mathrm{sim}}(\\vec{\\gamma})</span>  for all previous queries  <span class="math">\\vec{\\gamma}</span>  to A.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">From this point on, answer all queries to  <span class="math">A(\\vec{\\gamma})</span>  with  <span class="math">Q&#x27;_{\\rm sim}(\\vec{\\gamma}) - \\tilde{\\rho}_2 Z&#x27;_{\\rm sim}(\\vec{c}, \\vec{\\gamma})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Engage in the sumcheck protocol on the claim &quot; <span class="math">\\sum_{\\vec{\\beta} \\in G^k} Q&#x27;_{\\text{sim}}(\\vec{\\beta}) = \\tilde{\\rho}_2 w_{\\text{sim}} + z_{\\text{sim}}^2</span> &quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the view of the simulated  <span class="math">\\tilde{V}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">Q(\\vec{X}) := \\tilde{\\rho}_1 F(\\vec{X}) + \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{X}, \\vec{\\beta})</span> , and  <span class="math">Q&#x27;(\\vec{Y}) := \\tilde{\\rho}_2 Z(\\vec{c}, \\vec{Y}) + A(\\vec{Y})</span> . Observe that there exists a (deterministic) function  <span class="math">v(\\cdot)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\mathrm{View}\\; \\langle P_{\\mathrm{IP}}^{\\star\\,F,Z,A}, \\tilde{V}^{F,Z,A} \\rangle = v(Q,Q&#x27;,F,Z,Z,r) \\quad \\text{and} \\quad S_{\\mathrm{slow}}^{\\star\\,\\tilde{V},F} = v(Q_{\\mathrm{sim}},Q&#x27;_{\\mathrm{sim}},F,Z_{\\mathrm{sim}},Z&#x27;_{\\mathrm{sim}},r) \\;\\;,</span>$</p>

    <p class="text-gray-300">where the random variable r is  <span class="math">\\tilde{V}</span> 's private randomness. Indeed,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\tilde{V}</span> 's queries to Z up to Step 5 are answered by Z and  <span class="math">Z_{\\text{sim}}</span>  respectively, and after Step 5 by Z and  <span class="math">Z&#x27;_{\\text{sim}}</span>  respectively;</li>
      <li>V's queries to  <span class="math">A(\\cdot)</span>  are answered by  <span class="math">Q&#x27;(\\cdot) \\tilde{\\rho}_2 Z(\\vec{c}, \\cdot)</span>  and  <span class="math">Q&#x27;_{\\text{sim}}(\\cdot) \\tilde{\\rho}_2 Z&#x27;_{\\text{sim}}(\\vec{c}, \\cdot)</span>  respectively;</li>
      <li><span class="math">\\bullet</span>  the messages between  <span class="math">P_{\\mathrm{IP}}^{\\star}</span>  and  <span class="math">\\tilde{V}</span>  in the first sumcheck are a sumcheck on Q and  <span class="math">Q_{\\mathrm{sim}}</span>  respectively;</li>
      <li><span class="math">w=Q(\\vec{c})-\\tilde{\\rho}_1F(\\vec{c})</span>  in one case and  <span class="math">w_{\\rm sim}=Q_{\\rm sim}(\\vec{c})-\\tilde{\\rho}_1F(\\vec{c})</span>  in the other case; and</li>
      <li>the messages between  <span class="math">P_{\\text{IP}}^{\\star}</span>  and V in the second sumcheck are a sumcheck on Q' and  <span class="math">Q&#x27;_{\\text{sim}}</span>  respectively. We now argue that the outputs of  <span class="math">v(\\cdot)</span>  in the two cases are identically distributed:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$v(Q, Q&#x27;, F, Z, Z, r) \\sim v(Q_{\\text{sim}}, Q&#x27;_{\\text{sim}}, F, Z_{\\text{sim}}, Z&#x27;_{\\text{sim}}, r)</span>$
.</p>

    <p class="text-gray-300">We do so via several 'hybrids', the first of which considers the distribution of Q. For every fixed  <span class="math">B \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> , consider the following probability value, where  <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  is uniformly random, and  <span class="math">U \\subseteq \\mathbb{F}^{m+k} \\times \\mathbb{F}</span>  is a set of query-answer pairs:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} p(B|U) &amp;:= \\Pr_{Z} \\left[ Q(\\vec{\\alpha}) = B(\\vec{\\alpha}) \\quad \\forall \\, \\vec{\\alpha} \\in \\mathbb{F}^m \\, \\left| \\, \\, Z(\\vec{\\gamma}) = \\omega \\quad \\forall \\, (\\vec{\\gamma}, \\omega) \\in U \\right] \\\\ &amp;= \\Pr_{Z} \\left[ \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{\\alpha}, \\vec{\\beta}) = B(\\vec{\\alpha}) - \\tilde{\\rho}_1 F(\\vec{\\alpha}) \\quad \\forall \\, \\vec{\\alpha} \\in \\mathbb{F}^m \\, \\left| \\, \\, Z(\\vec{\\gamma}) = \\omega \\quad \\forall \\, (\\vec{\\gamma}, \\omega) \\in U \\right] \\right] \\end{split}</span>$</p>

    <p class="text-gray-300">The probability value p(B|U) describes the distribution of Q in a real execution, when U is the set of query-answer pairs to Z made by  <span class="math">\\tilde{V}</span> . By our lower bounds on the algebraic query complexity of polynomial summation (Corollary 5.3), whenever  <span class="math">|U| &lt; \\lambda^k</span> ,</p>

    <p class="text-gray-300"><span class="math">$p(B|U) = \\Pr_{Z} \\left[ \\sum_{\\vec{\\beta} \\in G^{k}} Z(\\vec{\\alpha}, \\vec{\\beta}) = B(\\vec{\\alpha}) - \\tilde{\\rho}_{1} F(\\vec{\\alpha}) \\quad \\forall \\vec{\\alpha} \\in \\mathbb{F}^{m} \\right] = 1/|\\mathbb{F}[X_{1, \\dots, m}^{\\leq d}]|.</span>$</p>

    <p class="text-gray-300">since Z is uniformly random. Thus Q is uniformly random, and hence is identically distributed to  <span class="math">Q_{\\text{sim}}</span> . Thus:</p>

    <p class="text-gray-300"><span class="math">$v(\\mathbf{Q}, Q&#x27;, F, Z, Z, r) \\sim v(\\mathbf{Q_{sim}}, Q&#x27;, F, Z, Z, r)</span>$</p>

    <p class="text-gray-300">Next,  <span class="math">Q&#x27;(\\vec{Y}) = \\tilde{\\rho}_2 Z(\\vec{c}, \\vec{Y}) + A(\\vec{Y})</span>  is uniformly random such that  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} Q&#x27;(\\vec{\\beta}) = \\tilde{\\rho}_2 w + z_2</span> , while  <span class="math">Q&#x27;_{\\rm sim}</span>  is uniformly random such that  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} Q&#x27;_{\\rm sim}(\\vec{\\beta}) = \\tilde{\\rho}_2 w_{\\rm sim} + z_{\\rm sim}^2</span>  and  <span class="math">Q&#x27;_{\\rm sim}(\\vec{\\gamma}_i) = \\tilde{\\rho}_2 Z&#x27;_{\\rm sim}(\\vec{c}, \\vec{\\gamma}_i) + A_{\\rm sim}(\\vec{\\gamma}_i)</span>  for  <span class="math">\\vec{\\gamma}_1, \\ldots \\vec{\\gamma}_k</span>  adversarially chosen. Since  <span class="math">A_{\\rm sim}</span>  is itself uniformly random such that  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} A_{\\rm sim}(\\vec{\\beta}) = 0</span> , this gives that  <span class="math">(Q&#x27;, Z) \\sim (Q&#x27;_{\\rm sim}, Z&#x27;_{\\rm sim})</span> , as Z and  <span class="math">Z&#x27;_{\\rm sim}</span>  are both uniformly random summing to zero. Moreover, queries to  <span class="math">Z&#x27;_{\\rm sim}</span>  are independent of  <span class="math">Q_{\\rm sim}</span>  by Corollary 5.3. Thus,</p>

    <p class="text-gray-300"><span class="math">$v(Q_{\\text{sim}}, \\mathbf{Q&#x27;}, F, \\mathbf{Z}, \\mathbf{Z}, r) \\sim v(Q_{\\text{sim}}, \\mathbf{Q&#x27;_{\\text{sim}}}, F, \\mathbf{Z&#x27;_{\\text{sim}}}, \\mathbf{Z&#x27;_{\\text{sim}}}, r)</span>$
.</p>

    <p class="text-gray-300">Finally we examine  <span class="math">Z_{\\rm sim}</span> , which is used only to answer queries to Z until Step 5. Note that  <span class="math">Z&#x27;_{\\rm sim}</span>  is drawn identically to  <span class="math">Z_{\\rm sim}</span>  except for the additional condition that  <span class="math">\\sum_{\\vec{\\beta} \\in G^k} Z&#x27;_{\\rm sim}(\\vec{c},\\vec{\\beta}) = v_{\\rm sim}</span> , and that  <span class="math">\\tilde{V}</span> 's queries to Z remain consistent. By Corollary 5.3, the summation condition is independent of the answers to  <span class="math">\\tilde{V}</span> 's queries to Z. So  <span class="math">\\tilde{V}</span> 's queries to  <span class="math">Z_{\\rm sim}</span>  are hence identically distributed to the same queries to  <span class="math">Z&#x27;_{\\rm sim}</span> , and thus</p>

    <p class="text-gray-300"><span class="math">$v(Q_{\\text{sim}}, Q&#x27;_{\\text{sim}}, F, \\mathbf{Z&#x27;_{\\text{sim}}}, Z&#x27;_{\\text{sim}}, r) \\sim v(Q_{\\text{sim}}, Q&#x27;_{\\text{sim}}, F, \\mathbf{Z&#x27;_{\\text{sim}}}, Z&#x27;_{\\text{sim}}, r)</span>$
.</p>

    <p class="text-gray-300">This concludes the argument for the correctness of the inefficient simulator  <span class="math">S_{\\mathrm{slow}}^{\\star}</span> .</p>

    <p class="text-gray-300">To complete the proof of zero knowledge, we note that  <span class="math">S_{\\mathrm{slow}}^{\\star}</span>  can be transformed into an efficient simulator  <span class="math">S_{\\mathrm{IP}}^{\\star}</span>  by using succinct constraint detection for the Reed&ndash;Muller code extended with partial sums [BCFGRS16]: more precisely, we can use the algorithm of Corollary 4.1 to answer both point and sum queries to Z, A, and Q, in a stateful way, maintaining corresponding tables  <span class="math">\\mathrm{ans}_{Z_{\\mathrm{sim}}}</span> ,  <span class="math">\\mathrm{ans}_{A_{\\mathrm{sim}}}</span> , and  <span class="math">\\mathrm{ans}_{Q_{\\mathrm{sim}}}</span> .</p>

    <p class="text-gray-300">The Interactive Proof described and analyzed in Section 6.1 assumes that the prover and verifier have access to certain low-degree polynomials. We now use low-degree testing and self-correction to compile that Interactive Proof into an Interactive PCP, where the prover sends to the verifier evaluations of these polynomials as part of the proof oracle. This will conclude the proof of Theorem 6.4.</p>

    <p class="text-gray-300">Proof of Theorem 6.4. Construct an IPCP system (P, V) for sumcheck as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover P, given input  <span class="math">(\\mathbb{F}, m, d, H, a)</span>  and oracle access to F, samples polynomials  <span class="math">Z \\in \\mathbb{F}[X_{1, \\dots, m}^{\\leq d}, Y_{1, \\dots, k}^{\\leq 2\\lambda}]</span> ,  <span class="math">A \\in \\mathbb{F}[Y_{1, \\dots, k}^{\\leq 2\\lambda}]</span>  uniformly at random, and sends their evaluations to the verifier V; then P simulates  <span class="math">P_{\\mathrm{IP}}^{\\star}^{F, Z, A}(\\mathbb{F}, m, d, H, a)</span> .</li>
      <li>The verifier V, after receiving a proof string  <span class="math">\\pi = (Z,A)</span> , simulates  <span class="math">V_{\\mathrm{IP}}^{\\star}{}^{F,\\pi}(\\mathbb{F},m,d,H,a)</span>  up to  <span class="math">V_{\\mathrm{IP}}{}^{\\circ}</span> 's two queries  <span class="math">\\vec{\\alpha}_1 \\in \\mathbb{F}^{m+k}, \\vec{\\alpha}_2 \\in \\mathbb{F}^k</span>  to Z,A respectively (which occur after the interaction), which V does not answer directly but instead answers as follows. First, V checks that Z is  <span class="math">\\varrho</span> -close to the evaluation of a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  by performing an individual-degree test with proximity parameter  <span class="math">\\varrho:=\\frac{1}{8}</span>  and soundness error  <span class="math">\\epsilon:=\\frac{md}{|\\mathbb{F}|}</span>  [GS06; GR15]; then, V computes  <span class="math">Z(\\vec{\\alpha}_1)</span>  via self-correction with soundness error  <span class="math">\\epsilon</span>  [RS96; AS03], and replies with this value. The procedures above are repeated to determine  <span class="math">A(\\vec{\\alpha}_2)</span> . Both procedures require poly( <span class="math">\\log |\\mathbb{F}|, m, d</span> ) queries and time. Finally, V rejects if  <span class="math">V_{\\mathrm{IP}}</span>  rejects or the individual degree test rejects.</li>
    </ul>

    <p class="text-gray-300">Completeness and perfect zero knowledge of (P,V) are inherited, in a straightforward way, from those of  <span class="math">(P_{\\rm IP},V_{\\rm IP})</span> . We now argue soundness. Consider an instance-witness pair  <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)\\in\\mathscr{R}^{\\rm no}_{\\rm SC}</span>  and a malicious prover  <span class="math">\\tilde{P}</span> , and denote by  <span class="math">\\tilde{\\pi}=(\\tilde{Z},\\tilde{A})</span>  the proof string sent by  <span class="math">\\tilde{P}</span> . We distinguish between the following two cases.</p>

    <p class="text-gray-300">&bull; Case 1:  <span class="math">\\tilde{Z}</span>  is  <span class="math">\\varrho</span> -far from evaluations of polynomials in  <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>  or  <span class="math">\\tilde{A}</span>  is  <span class="math">\\varrho</span> -far from evaluations of polynomials in  <span class="math">\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> .</p>

    <p class="text-gray-300">In this case, the low-degree test accepts with probability at most  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300">&bull; Case 2:  <span class="math">\\tilde{Z}</span>  is  <span class="math">\\varrho</span> -close to evaluations of polynomials in  <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>  and  <span class="math">\\tilde{A}</span>  is  <span class="math">\\varrho</span> -close to evaluations of polynomials in  <span class="math">\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> .</p>

    <p class="text-gray-300">In this case, let  <span class="math">\\tilde{Z}&#x27;</span>  be the unique polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  whose evaluation is  <span class="math">\\varrho</span> -close to  <span class="math">\\tilde{Z}</span> ; this polynomial exists because  <span class="math">\\varrho</span>  is less than the unique decoding radius (of the corresponding Reed&ndash;Muller code), which equals  <span class="math">\\frac{1}{2}(1-\\frac{d}{|\\mathbb{F}|})^m(1-\\frac{2\\lambda}{|\\mathbb{F}|})^k</span> , and is at least  <span class="math">\\frac{1}{4}</span>  by the assumption that  <span class="math">\\frac{md}{|\\mathbb{F}|}+\\frac{k\\cdot 2\\lambda}{|\\mathbb{F}|}&lt;\\frac{1}{2}</span> .  <span class="math">\\tilde{A}&#x27;</span>  is defined analogously. By the soundness of  <span class="math">(P_{\\mathrm{IP}},V_{\\mathrm{IP}})</span> , the probability that  <span class="math">V_{\\mathrm{IP}}^{F,\\tilde{Z}&#x27;,\\tilde{A}&#x27;}</span>  accepts is at most  <span class="math">\\frac{md}{|I|}+\\frac{k\\cdot 2\\lambda+2}{|\\mathbb{F}|}</span>  (see Lemma 6.7). However V only has access to  <span class="math">\\tilde{\\pi}</span> , and uses self-correction on it to compute  <span class="math">\\tilde{Z}&#x27;,\\tilde{A}&#x27;</span>  at the location  <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^m</span>  required by  <span class="math">V_{\\mathrm{IP}}</span> ; the probability that the returned values are not correct is at most  <span class="math">2\\epsilon</span> . Hence, by a union bound, V accepts with probability at most  <span class="math">\\frac{md}{|I|}+\\frac{k\\cdot 2\\lambda+2}{|\\mathbb{F}|}+2\\epsilon</span> .</p>

    <p class="text-gray-300">Overall, we deduce that V accepts with probability at most  <span class="math">\\max\\{\\epsilon\\,,\\,\\frac{md}{|I|}+\\frac{k\\cdot 2\\lambda+2}{|\\mathbb{F}|}+2\\epsilon\\}\\leq 6\\frac{(m+k)\\cdot (d+\\lambda)}{|I|}.</span></p>

    <p class="text-gray-300">In this section we use the zero knowledge sumcheck protocol developed in Section 6 (along with the [BCFGRS16] protocol) to derive a zero knowledge analogue of the [BFL91; BFLS91] protocol for NEXP. Recall that in this protocol, the prover first sends a low-degree extension of a NEXP witness, and then engages in the [LFKN92] sumcheck protocol on a polynomial related to the instance. To make this zero knowledge, the prover will first take a <em>randomized</em> low-degree extension R of the witness (which provides some bounded independence). The oracle contains a commitment to R: the prover draws a polynomial uniformly at random subject to the condition that 'summing out' a few of its variables yields R, and places its evaluation in the oracle.</p>

    <p class="text-gray-300">The prover and verifier then engage in the zero knowledge sumcheck detailed in Section 6 on the [BFLS91] polynomial. This ensures that the verifier learns nothing through the interaction except for a single evaluation of the summand polynomial, which corresponds to learning a constant number of evaluations of the randomized witness. Bounded independence ensures that these evaluations do not leak any information. The prover provides these evaluations to the verifier, who will then check their correctness by engaging in an instance of the [BCFGRS16] sumcheck protocol for each evaluation. Note that here we are satisfied with the weaker guarantee provided by the [BCFGRS16] protocol because the simulator is able to simulate any polynomial number of queries to the commitment.</p>

    <p class="text-gray-300">Following [BFLS91], the arithmetization encodes bit strings as elements in  <span class="math">H^m</span>  for some H of size poly(|B|), rather than with  <span class="math">H = \\{0, 1\\}</span>  as in [BFL91], for greater efficiency.</p>

    <p class="text-gray-300">We start by defining the <em>oracle 3-satisfiability problem</em>, which is the <strong>NEXP</strong>-complete problem used by [BFL91] to construct two-prover interactive proofs for <strong>NEXP</strong>.</p>

    <p class="text-gray-300"><strong>Definition 7.1</strong> ( <span class="math">\\mathcal{R}_{O3SAT}</span> ). The <strong>oracle 3-satisfiability relation</strong>, denoted  <span class="math">\\mathcal{R}_{O3SAT}</span> , consists of all instance-witness pairs (x, w) = ((r, s, B), A), where r, s are positive integers,  <span class="math">B: \\{0, 1\\}^{r+3s+3} \\to \\{0, 1\\}</span>  is a boolean formula, and  <span class="math">A: \\{0, 1\\}^s \\to \\{0, 1\\}</span>  is a function, that satisfy the following condition:</p>

    <p class="text-gray-300"><span class="math">$\\forall z \\in \\{0,1\\}^r, \\ \\forall b_1, b_2, b_3 \\in \\{0,1\\}^s, \\ B(z,b_1,b_2,b_3,A(b_1),A(b_2),A(b_3)) = 1</span>$
.</p>

    <p class="text-gray-300"><strong>Theorem 7.2</strong> (PZK IPCP for NEXP). For every query bound function b(n), the NEXP-complete relation  <span class="math">\\mathcal{R}_{O3SAT}</span>  has a (public coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail:</p>

    <pre><code class="language-text">\\mathcal{R}_{\\mathrm{O3SAT}} \\in \\mathbf{PZK\\text{-}IPCP} \\begin{bmatrix} soundness\\ error: &amp; 1/2 \\\\ round\\ complexity: &amp; O(r+s+\\log b) \\\\ proof\\ length: &amp; \\operatorname{poly}(2^{|B|},b) \\\\ query\\ complexity: &amp; \\operatorname{poly}(|B|+\\log b) \\\\ prover\\ time: &amp; \\operatorname{poly}(2^{|B|},b) \\\\ verifier\\ time: &amp; \\operatorname{poly}(|B|+\\log b) \\\\ verifier\\ space: &amp; O(|B|+\\log b) \\\\ simulator\\ overhead: &amp; \\operatorname{poly}(|B|+\\log b) \\cdot \\mathsf{q}_{\\tilde{V}}^3 \\end{bmatrix}.
</code></pre>

    <p class="text-gray-300">Note that the prover running time given above assumes that the prover is given a witness as auxiliary input.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathbb{F}</span>  be an extension field of  <span class="math">\\mathbb{F}_2</span> . Let  <span class="math">\\hat{B} \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  be the 'direct' arithmetization of the negation of B: rewrite B by using ANDs and NOTs; negate its output; replace each  <span class="math">\\mathrm{AND}(a,b)</span>  with  <span class="math">a \\cdot b</span>  and  <span class="math">\\mathrm{NOT}(a)</span>  with 1-a. For every  <span class="math">\\vec{x} \\in \\{0,1\\}^{r+3s+3}</span> ,  <span class="math">\\hat{B}(\\vec{x}) = 0</span>  if  <span class="math">B(\\vec{x})</span>  is true, and  <span class="math">\\hat{B}(\\vec{x}) = 1</span>  if  <span class="math">B(\\vec{x})</span>  is false. Note that  <span class="math">\\hat{B}</span>  is computable in time  <span class="math">\\mathrm{poly}(|B|)</span>  and has total degree O(|B|).</p>

    <p class="text-gray-300">Observe that  <span class="math">(r,s,B) \\in \\mathscr{R}_{\\mathrm{O3SAT}}</span>  if and only if there exists a multilinear function  <span class="math">\\hat{A} \\colon \\mathbb{F}^s \\to \\mathbb{F}</span>  that is boolean on  <span class="math">\\{0,1\\}^s</span>  such that  <span class="math">\\hat{B}(\\vec{z},\\vec{b}_1,\\vec{b}_2,\\vec{b}_3,\\hat{A}(\\vec{b}_1),\\hat{A}(\\vec{b}_2),\\hat{A}(\\vec{b}_3)) = 0</span>  for all  <span class="math">\\vec{z} \\in \\{0,1\\}^r</span> ,  <span class="math">\\vec{b}_1,\\vec{b}_2,\\vec{b}_3 \\in \\{0,1\\}^s</span> . The requirement that  <span class="math">\\hat{A}</span>  is boolean on  <span class="math">\\{0,1\\}^s</span>  can be encoded by  <span class="math">2^s</span>  constraints:  <span class="math">\\hat{A}(\\vec{b})(1-\\hat{A}(\\vec{b})) = 0</span>  for every  <span class="math">\\vec{b} \\in \\{0,1\\}^s</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup>This section is written so that the proof can be understood independently of subsequent sections of the paper. Using the framework of sum-product circuits developed in Section 8, we can simplify this proof; see Appendix B.</p>

    <p class="text-gray-300">These constraints can be expressed as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\left\\{g_1(\\vec{\\alpha}) := \\hat{B}(\\vec{z}, \\vec{b}_1, \\vec{b}_2, \\vec{b}_3, \\hat{A}(\\vec{b}_1), \\hat{A}(\\vec{b}_2), \\hat{A}(\\vec{b}_3)) = 0\\right\\}_{\\vec{z} \\in \\{0,1\\}^r, \\, \\vec{b}_i \\in \\{0,1\\}^s} \\\\ \\left\\{g_2(\\vec{\\beta}) := \\hat{A}(\\vec{b})(1 - \\hat{A}(\\vec{b})) = 0\\right\\}_{\\vec{b} \\in \\{0,1\\}^s} \\end{split}</span>$</p>

    <p class="text-gray-300">Let F be the polynomial over  <span class="math">\\mathbb{F}</span>  given by</p>

    <p class="text-gray-300"><span class="math">$F(\\vec{X}, \\vec{Y}) := \\sum_{\\vec{\\alpha} \\in \\{0,1\\}^{r+3s}} \\left( g_1(\\vec{\\alpha}) \\vec{X}^{\\vec{\\alpha}} + g_2(\\vec{\\alpha}_{[s]}) \\vec{Y}^{\\vec{\\alpha}} \\right) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\vec{X}^{\\vec{\\alpha}} := X_1^{\\alpha_1} \\cdots X_\\ell^{\\alpha_\\ell}</span>  for  <span class="math">\\vec{\\alpha} \\in \\{0,1\\}^\\ell</span> , and  <span class="math">\\vec{\\alpha}_{[s]}</span>  are the first s coordinates in  <span class="math">\\vec{\\alpha}</span> .</p>

    <p class="text-gray-300">Note that F is the zero polynomial if and only if all the above equations hold. Since F is a polynomial of total degree r+3s, if F is not the zero polynomial then it is zero on at most an  <span class="math">\\frac{r+3s}{|\\mathbb{F}|}</span>  fraction of points in  <span class="math">\\mathbb{F}^{2(r+3s)}</span> .</p>

    <p class="text-gray-300">For  <span class="math">\\alpha_i \\in \\{0,1\\}</span>  it holds that  <span class="math">X_i^{\\alpha_i} = 1 + (X_i - 1)\\alpha_i</span> , so we can also write</p>

    <p class="text-gray-300"><span class="math">$F(\\vec{X}, \\vec{Y}) = \\sum_{\\vec{\\alpha} \\in \\{0,1\\}^{r+3s}} \\left( g_1(\\vec{\\alpha}) \\cdot \\prod_{i=1}^{r+3s} (1 + (X_i - 1)\\alpha_i) + g_2(\\vec{\\alpha}_{[s]}) \\cdot \\prod_{i=1}^{r+3s} (1 + (Y_i - 1)\\alpha_i) \\right) =: \\sum_{\\vec{\\alpha} \\in \\{0,1\\}^{r+3s}} f(\\vec{X}, \\vec{Y}, \\vec{\\alpha}) .</span>$</p>

    <p class="text-gray-300">Let H be a subfield of  <span class="math">\\mathbb{F}</span> ; define  <span class="math">m_1:=r/\\log|H|</span>  and  <span class="math">m_2:=s/\\log|H|</span>  (assuming without loss of generality that both are integers). For  <span class="math">i\\in\\{1,2\\}</span> , let  <span class="math">\\gamma_i\\colon H^{m_i}\\to\\{0,1\\}^{m_i\\log|H|}</span>  be the lexicographic order on  <span class="math">H^{m_i}</span> . The low-degree extension  <span class="math">\\hat{\\gamma}_i</span>  of  <span class="math">\\gamma_i</span>  is computable by an arithmetic circuit constructible in time  <span class="math">\\operatorname{poly}(|H|,m_i,\\log|\\mathbb{F}|)</span>  [GKR15, Claim 4.2]. Let  <span class="math">\\gamma\\colon H^{m_1+3m_2}\\to\\{0,1\\}^{r+3s}</span>  be such that  <span class="math">\\gamma(\\vec{\\alpha},\\vec{\\beta}_1,\\vec{\\beta}_2,\\vec{\\beta}_3)=(\\gamma_1(\\vec{\\alpha}),\\gamma_2(\\vec{\\beta}_1),\\gamma_2(\\vec{\\beta}_2),\\gamma_2(\\vec{\\beta}_3))</span>  for all  <span class="math">\\vec{\\alpha}\\in H^{m_1},\\vec{\\beta}_1,\\vec{\\beta}_2,\\vec{\\beta}_3\\in H^{m_2}</span> ; let  <span class="math">\\hat{\\gamma}\\colon \\mathbb{F}^{m_1+3m_2}\\to\\mathbb{F}^{r+3s}</span>  be its low-degree extension.</p>

    <p class="text-gray-300">We can use the above notation to write F equivalently as</p>

    <p class="text-gray-300"><span class="math">$F(\\vec{X}, \\vec{Y}) = \\sum_{\\substack{\\vec{\\alpha} \\in H^{m_1} \\\\ \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3 \\in H^{m_2}}} g_1(\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)) \\prod_{i=1}^{r+3s} (1 + (X_i - 1)\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)_i) + g_2(\\hat{\\gamma}_2(\\vec{\\beta}_1)) \\prod_{i=1}^{r+3s} (1 + (Y_i - 1)\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)_i) .</span>$</p>

    <p class="text-gray-300">We are now ready to specify the protocol. Let  <span class="math">k := \\lceil \\log b / \\log |H| \\rceil</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover draws a polynomial Z uniformly at random from  <span class="math">\\mathbb{F}[X_{1,\\dots,m_2}^{\\leq |H|+2},Y_{1,\\dots,k}^{\\leq 2|H|}]</span> , subject to the condition that  <span class="math">\\sum_{\\vec{\\beta}\\in G^k}Z(\\vec{\\alpha},\\vec{\\beta})=A(\\gamma_2(\\vec{\\alpha}))</span>  for all  <span class="math">\\vec{\\alpha}\\in H^{m_2}</span> . It then generates an oracle  <span class="math">\\pi_0</span>  for the  <span class="math">|H|^k</span> -strong zero knowledge sumcheck protocol (Section 6) on input  <span class="math">(\\mathbb{F},m_1+3m_2,\\deg(f),H,0)</span>  and oracles  <span class="math">\\pi_1,\\pi_2,\\pi_3</span>  for the [BCFGRS16] zero knowledge sumcheck protocol on input  <span class="math">(\\mathbb{F},k,2|H|,H,\\cdot)</span> . (Recall that in both zero knowledge sumchecks, the oracle message does not depend on the claim itself.) The prover sends an oracle which is the concatenation of the evaluation of Z with  <span class="math">(\\pi_0,\\pi_1,\\pi_2,\\pi_3)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier chooses  <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r+3s}</span>  uniformly at random and sends them to the prover. The prover and verifier engage in the zero knowledge sumcheck protocol of Section 6 on the claim &quot; <span class="math">F(\\vec{x}, \\vec{y}) = 0</span> &quot; with  <span class="math">I = \\mathbb{F} \\setminus H</span>  using  <span class="math">\\pi_1</span>  as the oracle message. This reduces the claim to checking that  <span class="math">f(\\vec{x}, \\vec{y}, \\vec{c}, \\vec{c}_1&#x27;, \\vec{c}_2&#x27;, \\vec{c}_3&#x27;) = a</span>  for uniformly random  <span class="math">\\vec{c} \\in (\\mathbb{F} \\setminus H)^{m_1}</span> ,  <span class="math">\\vec{c}_1&#x27;, \\vec{c}_2&#x27;, \\vec{c}_3&#x27; \\in (\\mathbb{F} \\setminus H)^{m_2}</span>  and some  <span class="math">a \\in \\mathbb{F}</span>  provided by the prover.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover provides  <span class="math">h_i := A(\\gamma_2(\\vec{c}_i&#x27;))</span>  for each  <span class="math">i \\in \\{1, 2, 3\\}</span> . The verifier substitutes these values into the expression for f to check the above claims, and rejects if they do not hold.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover and verifier engage in the zero knowledge sumcheck protocol of [BCFGRS16] on the claims &quot; <span class="math">\\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{\\alpha}, \\vec{\\beta}) = h_i</span> &quot; for each  <span class="math">i \\in \\{1, 2, 3\\}</span> , using  <span class="math">\\pi_i</span>  as the oracle message.</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier checks that Z is low-degree (with proximity parameter  <span class="math">\\varrho := \\frac{1}{8}</span>  and soundness error  <span class="math">\\varepsilon := \\frac{1}{|\\mathbb{F}|}</span> ), and uses self-correction (with soundness error  <span class="math">\\varepsilon</span> ) to query it at the points required by the [BCFGRS16] protocol above.</li>
    </ol>

    <p class="text-gray-300"><strong>Completeness.</strong> If  <span class="math">((r, s, B), A) \\in \\mathcal{R}_{O3SAT}</span>  then  <span class="math">F(\\vec{X}, \\vec{Y})</span>  is the zero polynomial; hence  <span class="math">F(\\vec{x}, \\vec{y}) = 0</span>  for all  <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r+3s}</span> . Completeness follows from the completeness of the zero knowledge sumcheck protocols.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Suppose that  <span class="math">(r,s,B) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span>  and let  <span class="math">(\\tilde{Z},\\tilde{\\pi}_0,\\tilde{\\pi}_1,\\tilde{\\pi}_2,\\tilde{\\pi}_3)</span>  be the oracle message. If  <span class="math">\\tilde{Z}</span>  is  <span class="math">\\varrho</span> -far from an evaluation of a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\ldots,m_2}^{\\leq |H|+2},Y_{1,\\ldots,k}^{\\leq \\lambda}]</span>  then the verifier rejects with probability at least  <span class="math">1-\\varepsilon</span> . Otherwise, there exists a unique polynomial  <span class="math">Z \\in \\mathbb{F}[X_{1,\\ldots,m_2}^{\\leq |H|+2},Y_{1,\\ldots,k}^{\\leq \\lambda}]</span>  whose evaluation is  <span class="math">\\varrho</span> -close to  <span class="math">\\tilde{Z}</span> . Let  <span class="math">\\tilde{A}:=\\sum_{\\vec{\\beta}\\in H^k}Z(\\vec{X},\\vec{\\beta})</span> , which we think of as playing the role of  <span class="math">\\hat{A}(\\gamma_2(\\cdot))</span>  in F.</p>

    <p class="text-gray-300">If  <span class="math">(r,s,B) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span>  then there is no choice of  <span class="math">\\hat{A}</span>  such that  <span class="math">F(\\vec{X},\\vec{Y})</span>  is the zero polynomial. Thus,  <span class="math">F(\\vec{x},\\vec{y})=0</span>  with probability at most  <span class="math">(r+3s)/|\\mathbb{F}|</span>  over the choice of  <span class="math">\\vec{x},\\vec{y}</span> . By the soundness of the zero knowledge sumcheck protocol (Theorem 6.4), the verifier outputs a false claim &quot; <span class="math">f(\\vec{x},\\vec{y},\\vec{\\alpha})=a</span> &quot; with probability at least  <span class="math">1-O((m_1+m_2+k)|H|)/(|\\mathbb{F}|-|H|))</span> . If substituting  <span class="math">h_i</span>  for  <span class="math">\\hat{A}(\\gamma_2(\\vec{c}_i&#x27;))</span>  in f does not yield a, then the verifier rejects. Otherwise, it must be the case that for at least one  <span class="math">i\\in\\{1,2,3\\}</span> ,  <span class="math">\\hat{A}(\\vec{c}_i&#x27;)\\neq h_i</span> . By the soundness of the [BCFGRS16] sumcheck protocol, the verifier rejects with probability at least  <span class="math">1-O((m_1+m_2+k)|H|/|\\mathbb{F}|)=1-O((r+s+\\log b)|H|/|\\mathbb{F}|)</span> .</p>

    <p class="text-gray-300">Zero knowledge. Perfect zero knowledge for this protocol is witnessed by the following simulator.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Draw a uniformly random polynomial  <span class="math">Z_{\\text{sim}} \\in \\mathbb{F}[X_{1,...,m_2}^{\\leq |H|+2},Y_{1,...,k}^{\\leq 2|H|}]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Run the  <span class="math">|H|^k</span> -strong ZK sumcheck simulator on input  <span class="math">(\\mathbb{F}, m_1 + 3m_2, \\deg(f), H, 0)</span> , and use it to answer queries to  <span class="math">\\pi_0</span>  throughout. In parallel, run three copies of the simulator for the [BCFGRS16] sumcheck on input  <span class="math">(\\mathbb{F}, k, 2|H|, H, \\cdot)</span> , and use them to answer queries to  <span class="math">\\pi_1, \\pi_2, \\pi_3</span>  respectively. Recall that the behavior of each simulator does not depend on the claim being proven until after the first simulated message, so we can choose these later.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Receive  <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r+3s}</span>  from  <span class="math">\\tilde{V}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Simulate the strong ZK sumcheck protocol on the claim &quot; <span class="math">F(\\vec{x}, \\vec{y}) = 0</span> &quot;. The subsimulator will query f at a single location  <span class="math">\\vec{c} \\in (\\mathbb{F} H)^{r+3s}</span> . Reply with the value  <span class="math">f(\\vec{x}, \\vec{y}, \\vec{c})</span> , for  <span class="math">\\vec{c} = (\\vec{c}_0, \\vec{c}_1, \\vec{c}_2, \\vec{c}_3) \\in (\\mathbb{F} \\setminus H)^{r+3s}</span> . To compute this requires values  <span class="math">\\hat{A}(\\hat{\\gamma}(\\vec{c}_i))</span>  for  <span class="math">i \\in \\{1, 2, 3\\}</span> ; we substitute each of these with  <span class="math">h^i_{\\text{sim}} \\in \\mathbb{F}</span>  drawn uniformly at random (except: if  <span class="math">\\vec{c}_i = \\vec{c}_j</span>  for  <span class="math">i \\neq j</span>  then fix  <span class="math">h^i_{\\text{sim}} = h^j_{\\text{sim}}</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For  <span class="math">i \\in \\{1, 2, 3\\}</span> , simulate the [BCFGRS16] sumcheck protocol on the claim &quot; <span class="math">\\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{\\alpha}, \\vec{\\beta}) = h_{\\text{sim}}^i</span> &quot;. Whenever the subsimulator queries Z, answer using  <span class="math">Z_{\\text{sim}}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The verifier's view consists of its interaction with P during the four sumchecks, and its queries to the oracle. The Section 6 zero knowledge sumcheck subsimulator guarantees that the queries to  <span class="math">\\pi_0</span>  and the first sumcheck are perfectly simulated given a single query to f at the point  <span class="math">\\vec{c} \\in (\\mathbb{F} \\setminus H)^{r+3s}</span>  chosen by  <span class="math">\\tilde{V}</span> . Since  <span class="math">\\hat{A}&#x27;(\\vec{X}) = \\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{X}, \\vec{\\beta}) \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq |H|+2}]</span> , the evaluation of  <span class="math">\\hat{A}</span>  at any 3 points outside of  <span class="math">H^m</span>  does not determine its value at any point in  <span class="math">H^m</span> . In particular, this means that the values  <span class="math">h_i</span>  sent by the prover in the original protocol are independently uniformly random in  <span class="math">\\mathbb{F}</span>  (except if  <span class="math">\\vec{c}_i = \\vec{c}_j</span>  for  <span class="math">i \\neq j</span>  as above). Thus the  <span class="math">h_{\\text{sim}}^i</span>  are identically distributed to the  <span class="math">h_i</span> , and therefore both the prover message and the simulator's query are perfectly simulated.</p>

    <p class="text-gray-300">The [BCFGRS16] sumcheck simulator ensures that the view of the verifier in the rest of the sumchecks is perfectly simulated given  <span class="math">q_{\\tilde{V}}</span>  queries to Z, where  <span class="math">q_{\\tilde{V}}</span>  is the number of queries the verifier makes across all  <span class="math">\\pi_i</span> ,  <span class="math">i \\in \\{1, 2, 3\\}</span> . Hence the number of 'queries' the simulator makes to  <span class="math">Z_{\\text{sim}}</span>  is strictly less than b (because  <span class="math">\\tilde{V}</span>  is b-query). By Corollary 5.3, any set of strictly less than b queries to Z is independent of  <span class="math">\\hat{A}&#x27;</span> , and so the answers are identically distributed to the answers to those queries if they were made to a uniformly random polynomial, which is the distribution of  <span class="math">Z_{\\text{sim}}</span> .</p>

    <p class="text-gray-300">Clearly drawing a uniformly random polynomial in  <span class="math">Z_{\\text{sim}} \\in \\mathbb{F}[X_{1,\\dots,m_2}^{\\leq |H|+2},Y_{1,\\dots,k}^{\\leq 2|H|}]</span>  is not something we can do in polynomial time. However, we can instead use the algorithm of Corollary 4.1 to draw Z (a simple modification allows us to handle different degrees in  <span class="math">\\vec{X}, \\vec{Y}</span> , or we could simply set the degree bound for both to be 2|H|; the proof still goes through). The running time of the simulator is then  <span class="math">\\operatorname{poly}(m_1, m_2, k, |H|, \\log |\\mathbb{F}|)</span> .</p>

    <p class="text-gray-300">It remains to choose  <span class="math">\\mathbb F</span>  and H. We set  <span class="math">|H| = \\operatorname{poly}(r+s+\\log b)</span>  and  <span class="math">|\\mathbb F| = \\operatorname{poly}(|H|)</span>  large enough that the soundness error is o(1). The running time of the verifier is then  <span class="math">\\operatorname{poly}(|B|, \\log b)</span> , as is the running time of the simulator. The proof length is  <span class="math">\\mathbb F^{O(m_1+m_2+k)} = 2^{O(r+s)} \\cdot \\operatorname{poly}(b)</span> .</p>

    <p class="text-gray-300">We define <em>sum-product circuits</em>, a type of computation involving alternations of (i) summing polynomials over hypercubes, and (ii) combining polynomials via low-degree arithmetic circuits. Computing the output of a sum-product circuit is (conjecturally) hard (indeed, we will show that it is <strong>PSPACE</strong>-complete), but we show how to efficiently delegate such computations via an Interactive Proof.</p>

    <p class="text-gray-300">We proceed in three steps. First, we provide intuition for why it is natural to consider sum-product alternations (Section 8.1). Then, we define sum-product <em>formulas</em>, which are a special case (in a way that is analogous to how boolean formulas specialize boolean circuits) and show how to delegate their evaluation (Section 8.2). Finally, we define sum-product <em>circuits</em> and show how to delegate their evaluation (Section 8.3).</p>

    <p class="text-gray-300">In later sections, we additionally achieve zero knowledge via an Interactive PCP (Section 9), and explain how to 'program' sum-product circuits so that: their evaluation captures <strong>PSPACE</strong> (Section 10) or, more generally, low-depth circuit computations (Section 11); and their satisfaction captures <strong>NEXP</strong> (Section 7).</p>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Intuition for definition</h3>

    <p class="text-gray-300">We provide intuition for why it is natural to consider sum-product alternations. Let  <span class="math">\\mathbb{F}</span>  be a finite field, H a subset of  <span class="math">\\mathbb{F}</span> , and m a positive integer.<sup>2</sup> The sumcheck protocol (Section 4.5) supports checking claims of the form &quot; <span class="math">a = \\sum_{\\vec{\\beta} \\in H^m} P(\\vec{\\beta})</span> &quot; for a given field element  <span class="math">a \\in \\mathbb{F}</span>  and low-degree m-variate polynomial P over  <span class="math">\\mathbb{F}</span> , if the verifier can efficiently evaluate P at any point (e.g., the verifier has a small arithmetic circuit for P, or the verifier has oracle access to P, or others).</p>

    <p class="text-gray-300">Can the verifier still check the claim even if P is an expression involving other polynomials?</p>

    <p class="text-gray-300">Suppose that  <span class="math">P(\\vec{X})</span>  (allegedly) equals  <span class="math">C(\\vec{X}, P_1(\\vec{X}), \\dots, P_t(\\vec{X}))</span>  for some low-degree t-variate 'combiner' polynomial C and low-degree m-variate polynomials  <span class="math">P_1, \\dots, P_t</span> , and suppose that the verifier has small arithmetic circuits for all these polynomials. In this case the verifier can still efficiently evaluate P at any given point, and the sumcheck protocol directly applies. However, now suppose instead that each polynomial  <span class="math">P_i(\\vec{X})</span>  itself (allegedly) equals  <span class="math">\\sum_{\\vec{\\gamma} \\in H^m} C(\\vec{X}, P_{i,1}(\\vec{X}, \\vec{\\gamma}), \\dots, P_{i,t}(\\vec{X}, \\vec{\\gamma}))</span>  for some low-degree 2m-variate polynomials  <span class="math">P_{i,1}, \\dots, P_{i,t}</span> . Now the sumcheck protocol does not directly apply, due to the alternation of sums and products. What to do?</p>

    <p class="text-gray-300">Sum-product expressions, and protocols for them. More generally (and informally), we call  <span class="math">P \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  an m-variate sum-product expression if (i) P is a low-degree (individual degree less than |H|) arithmetic circuit, or (ii)  <span class="math">P(\\vec{X})</span>  equals  <span class="math">\\sum_{\\vec{\\beta} \\in H^m} C(\\vec{X}, \\vec{\\beta}, P_1(\\vec{X}, \\vec{\\beta}), \\dots, P_t(\\vec{X}, \\vec{\\beta}))</span>  where C is a low-degree 'combiner' arithmetic circuit and  <span class="math">P_1, \\dots, P_t</span>  are 2m-variate sum-product expressions.</p>

    <p class="text-gray-300">By building on ideas of [Sha92; She92; GKR15], we can <em>still</em> use the sumcheck protocol, now as a subroutine of a larger Interactive Proof, to verify claims of the form &quot; <span class="math">a = P(\\vec{\\omega})</span> &quot; for a given  <span class="math">a \\in \\mathbb{F}</span> , sum-product expression P, and  <span class="math">\\vec{\\omega} \\in \\mathbb{F}^m</span> , as we now sketch &mdash; and thereby handle sum-product alternations.</p>

    <p class="text-gray-300">If P is an arithmetic circuit, then the verifier can check the claim directly by evaluating P at  <span class="math">\\vec{\\omega}</span> . Otherwise, proceed as follows. Define  <span class="math">\\hat{P}</span>  to be the low-degree extension of P (see Section 4.1):</p>

    <p class="text-gray-300"><span class="math">$\\hat{P}(X) = \\sum_{\\vec{\\alpha} \\in H^m} I_{H^n}(\\vec{X}, \\vec{\\alpha}) \\sum_{\\vec{\\beta} \\in H^m} C(\\vec{\\alpha}, \\vec{\\beta}, P_1(\\vec{\\alpha}, \\vec{\\beta}), \\dots, P_t(\\vec{\\alpha}, \\vec{\\beta})) .</span>$</p>

    <p class="text-gray-300">Recall that  <span class="math">I_{H^m}(\\vec{X}, \\vec{Y})</span>  is the unique m-variate polynomial, of degree less than |H|, such that, for all  <span class="math">(\\vec{\\alpha}, \\vec{\\beta}) \\in H^m \\times H^m</span> ,  <span class="math">I_{H^m}(\\vec{\\alpha}, \\vec{\\beta})</span>  equals 1 when  <span class="math">\\vec{\\alpha} = \\vec{\\beta}</span>  and equals 0 otherwise.</p>

    <p class="text-gray-300">The prover and verifier run the sumcheck protocol on the claim &quot; <span class="math">a = \\hat{P}(\\vec{\\omega})</span> &quot; and obtain a new claim</p>

    <p class="text-gray-300">&quot;
<span class="math">$a&#x27; = I_{H^n}(\\vec{\\omega}, \\vec{r_2}) \\cdot C(\\vec{r_1}, \\vec{r_2}, P_1(\\vec{r_1}, \\vec{r_2}), \\dots, P_t(\\vec{r_1}, \\vec{r_2}))</span>$
&quot;</p>

    <p class="text-gray-300">for some  <span class="math">a&#x27; \\in \\mathbb{F}</span>  derived from the prover's messages and  <span class="math">\\vec{r}_1, \\vec{r}_2 \\in \\mathbb{F}^m</span>  drawn uniformly at random by the verifier. The prover then sends  <span class="math">h_1, \\ldots, h_t</span>  and the verifier checks that  <span class="math">a&#x27; = I_{H^n}(\\vec{\\omega}, \\vec{r}_2) \\cdot C(h_1, \\ldots, h_t)</span> . (Note that this expression</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>Throughout, we assume that  <span class="math">|\\mathbb{F}|</span>  is at least a constant fraction larger than |H|. In fact, we will typically take  <span class="math">|\\mathbb{F}|</span>  to be larger than this (e.g., at least polynomial in |H|) to achieve good soundness.</p>

    <p class="text-gray-300">involves only low-degree polynomials.) The verifier then recursively checks, for  <span class="math">i=1,\\ldots,t</span> , that &quot; <span class="math">a_i=P_i(\\vec{r}_1,\\vec{r}_2)</span> &quot;, relying on the fact that each  <span class="math">P_i</span>  is itself a sum-product expression.</p>

    <p class="text-gray-300">The reason for taking the low-degree extension  <span class="math">\\hat{P}</span>  of P is to prevent a degree blowup for intermediate claims, and is also used in the GKR protocol [GKR15] as well as Shen's protocol [She92] (known as degree reduction there). In particular, depending on the form of the combiner C, the degree of  <span class="math">P(\\vec{X})</span>  can be somewhat larger than that of the  <span class="math">P_i</span>  subexpressions. Even a factor 2 increase in the degree would, after k rounds, lead to a factor k increase overall, which for modest k would make the communication complexity of the sumcheck protocol superpolynomial. The degree reduction step ensures that the degrees of the intermediate claims do not increase.</p>

    <p class="text-gray-300"><strong>Towards sum-product formulas.</strong> The above informal discussion motivates the formulation of tree-like computations that combine values of previous hypercube sums by way of functions of bounded degree &mdash; we call these <em>sum-product formulas</em> (in analogy to boolean formulas that are also tree-like computations). Our definition also features crucial degrees of freedom, which make 'programming' these formulas more efficient, that we now discuss.</p>

    <p class="text-gray-300">First, we allow each internal vertex v in the tree to be labeled with a potentially different combiner arithmetic circuit  <span class="math">C_v</span>  of small (total) degree. An input  <span class="math">\\mathbf{x}</span>  to the sum-product formula then consists of labeling each leaf vertex v with a polynomial  <span class="math">\\mathbf{x}_v</span> , potentially represented as an arithmetic circuit, of small (individual) degree, and the edges in the tree determine how to 'evaluate' a vertex, as follows. The value of a vertex v on input  <span class="math">\\mathbf{x}</span>  equals the circuit  <span class="math">\\mathbf{x}_v</span>  if v is a leaf vertex, or equals  <span class="math">\\sum_{\\vec{\\beta} \\in H^m} C_v \\left(u_1[\\mathbf{x}](\\vec{X}, \\vec{\\beta}) \\dots, u_t[\\mathbf{x}](\\vec{X}, \\vec{\\beta})\\right)</span>  if v is an internal vertex, where  <span class="math">u_1, \\dots, u_t</span>  are the children of v. The value of the formula on  <span class="math">\\mathbf{x}</span>  is the value of the root on  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">Second, we allow flexible 'arity' in the sums: each edge e is labeled with finite sets of positive integers  <span class="math">\\rho_e</span>  and  <span class="math">\\sigma_e</span>  that determine which 'free variables' and 'summation variables' are passed on to the child corresponding to e. In other words, now the recursion looks like  <span class="math">\\sum_{\\vec{\\beta} \\in H^{m_v}} C_v \\left(u_1[\\mathbf{x}](\\vec{X}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\ldots, u_t[\\mathbf{x}](\\vec{X}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}})\\right)</span>  where  <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span>  and  <span class="math">m_v := \\max(\\sigma_{e_1} \\cup \\cdots \\cup \\sigma_{e_{\\mathrm{out}_T(v)}})</span> .</p>

    <p class="text-gray-300">In Section 8.2 we provide the formal definition of sum-product formulas, and also describe how to outsource computations about them. We provide this only as a simpler stepping stone towards the next definition.</p>

    <p class="text-gray-300"><strong>Sum-product circuits: re-using sub-computations.</strong> A boolean formula is limited in that it cannot re-use sub-computations; a sum-product formula is similarly limited. Thus, in analogy to boolean circuits, we consider <em>sum-product circuits</em>, in which sub-computations can be re-used according to an underlying directed acyclic graph (in fact, we will need a multi-graph), rather than a tree. Of course, one can always reduce sum-product circuits to sum-product formulas by 'opening up' the graph into a tree &mdash; but in the worst case this incurs an exponential blowup in the resulting tree. We use a standard trick to modify the protocol for sum-product formulas so to support merging multiple sub-claim computations at a vertex into one claim (regardless of the in-degree of the vertex), which avoids this explosion. This is also a necessary step in GKR's protocol [GKR15] (though we implement it differently for compatibility with our zero-knowledge protocols).</p>

    <p class="text-gray-300">In Section 8.3 we provide a formal definition of sum-product circuits, and then describe how to extend the ideas discussed so far to also support outsourcing computations about sum-product circuits. In the rest of the paper we only use (and must use) sum-product circuits, as sum-product formulas are not expressive enough for our purposes.</p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8">8.2 Sum-product formulas</h3>

    <p class="text-gray-300">The purpose of this section is to (i) introduce <em>sum-product formulas</em>, and (ii) give proof systems for two computational problems about these, <em>evaluation</em> and <em>satisfaction</em>.</p>

      <h4 id="sec-8.2.1" class="text-lg font-semibold mt-6">8.2.1 Formal definition</h4>

    <p class="text-gray-300">As with a boolean formula, the 'topology' of a a sum-product formula is a <em>tree</em>. A (rooted) tree T=(V,E) is an acyclic connected graph in which edges are directed away from a distinguished vertex, known as the root of T and denoted  <span class="math">r_T</span> ; the sinks of the graph are known as the leaves of T while all other vertices are known as internal vertices. The depth of a vertex v, denoted  <span class="math">depth_T(v)</span> , is the number of edges on the path from  <span class="math">r_T</span>  to v (thus  <span class="math">r_T</span>  has depth 0). The depth of T, denoted depth(T), is the maximum depth of any vertex v in V. The width of T, denoted width(T), is the maximum number of vertices at any depth:  <span class="math">\\max_{i=1}^{depth(T)} |\\{v \\in V : depth_T(v) = i\\}|</span> . The <em>out-degree</em> of a vertex v is denoted v, and equals the number of children of v; the <em>in-degree</em> is 1 for all vertices except the root.</p>

    <p class="text-gray-300">As outlined in Section 8.1, we eventually consider trees in which each internal vertex specifies a function that is recursively defined in terms of its children's functions. The number of inputs to these functions varies from vertex to vertex, and we specify the <em>arity</em> of these functions via certain edge labels. Namely, each edge e=(u,v) is labeled by two &quot;projections&quot;  <span class="math">\\rho_e</span>  and  <span class="math">\\sigma_e</span>  that, respectively, specify which free variables of u (the  <span class="math">\\vec{X}</span>  part in Equation 5 below) and summation variables of u (the  <span class="math">\\vec{\\beta}</span>  part in Equation 5 below) are passed on to v. In order for these projections to yield a well-defined notion of arity, they must satisfy certain consistency properties, and this motivates the following definition.</p>

    <p class="text-gray-300"><strong>Definition 8.1.</strong> A tuple  <span class="math">T=(V,E,\\rho,\\sigma)</span>  is an <strong>ari-tree</strong> if (V,E) is a tree and both  <span class="math">\\rho</span>  and  <span class="math">\\sigma</span>  label every edge e in E with finite sets of positive integers  <span class="math">\\rho_e</span>  and  <span class="math">\\sigma_e</span>  that satisfy the following property. For every vertex v in V, there exists a (unique) non-negative integer arity(v) such that: (1) if v is the root then  <span class="math">\\operatorname{arity}(v)=0</span> , otherwise  <span class="math">\\operatorname{arity}(v)=|\\rho_e|+|\\sigma_e|</span>  where e is v's (unique) incoming edge; (2)  <span class="math">\\rho_{e_1},\\ldots,\\rho_{e_t}\\subseteq\\{1,\\ldots,\\operatorname{arity}(v)\\}</span> , where  <span class="math">e_1,\\ldots,e_t</span>  are v's outgoing edges.</p>

    <p class="text-gray-300">For convenience, we denote by  <span class="math">\\operatorname{arity}(T)</span>  the maximum of  <span class="math">\\operatorname{arity}(v)</span>  across all vertices v in the vertex set V of T. Moreover, for every vertex v, we define  <span class="math">m_v := \\max(\\sigma_{e_1} \\cup \\cdots \\cup \\sigma_{e_t})</span>  so that  <span class="math">\\sigma_{e_1}, \\ldots, \\sigma_{e_t} \\subseteq \\{1, \\ldots, m_v\\}</span> .</p>

    <p class="text-gray-300">We are now ready to define a sum-product formula  <span class="math">\\mathcal{F}</span> , an input x for  <span class="math">\\mathcal{F}</span> , and how to evaluate  <span class="math">\\mathcal{F}</span>  on x.</p>

    <p class="text-gray-300"><strong>Definition 8.2.</strong> A sum-product formula is a tuple  <span class="math">\\mathcal{F} = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, T, C)</span>  where:  <span class="math">\\mathbb{F}</span>  is a finite field, H is a subset of  <span class="math">\\mathbb{F}</span>  (represented as a list of field elements),  <span class="math">\\delta_{\\mathsf{in}}</span> ,  <span class="math">\\delta_{\\mathsf{lf}}</span>  are positive integers (represented in unary) with  <span class="math">\\delta_{\\mathsf{lf}} \\geq |H|</span> ,  <span class="math">T = (V, E, \\rho, \\sigma)</span>  is an ari-tree, and C labels each internal vertex v of T with an arithmetic circuit  <span class="math">C_v(\\vec{X}, \\vec{Y}, \\vec{Z})</span> :  <span class="math">\\mathbb{F}^{\\mathsf{arity}(v)} \\times \\mathbb{F}^{\\mathsf{mv}} \\times \\mathbb{F}^{\\mathsf{out}_T(v)} \\to \\mathbb{F}</span>  of <u>total</u> degree at most  <span class="math">\\delta_{\\mathsf{ln}}</span> . An <strong>input</strong>  <span class="math">\\mathbb{E}</span>  for  <span class="math">\\mathcal{F}</span>  labels each leaf vertex v of T with a polynomial  <span class="math">\\mathbb{E}_v</span> :  <span class="math">\\mathbb{F}^{\\mathsf{arity}(v)} \\to \\mathbb{F}</span>  of <u>individual</u> degree at most  <span class="math">\\delta_{\\mathsf{lf}}</span> . The <strong>value</strong> of  <span class="math">\\mathcal{F}</span>  on an input  <span class="math">\\mathbb{E}</span>  is denoted  <span class="math">\\mathcal{F}[\\mathbb{E}]</span>  and equals  <span class="math">r_T[\\mathbb{E}]</span> , which we define below.</p>

    <p class="text-gray-300">The value of a vertex v of T on an input x is denoted v[x] and is recursively defined as follows. If v is a leaf vertex, then v[x] equals the polynomial  <span class="math">x_v</span> . If v is an internal vertex, then v[x] is the arity(v)-variate polynomial over  <span class="math">\\mathbb{F}</span>  defined by the following expression:</p>

    <p class="text-gray-300">
<span class="math">$\\sum_{\\vec{\\beta} \\in H^{m_v}} C_v(\\vec{X}, \\vec{\\beta}, u_1[\\mathbf{x}](\\vec{X}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, u_t[\\mathbf{x}](\\vec{X}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}})) , \\qquad (5)</span>$</p>

    <p class="text-gray-300">where  <span class="math">t := \\text{out}_T(v)</span> , and  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  are the outgoing edges of v. In particular,  <span class="math">\\mathcal{F}[x] = r_T[x]</span>  is a constant in  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">Given a sum-product formula we can ask two types of computational problems: (<em>evaluation</em>) does a given input lead to a given output? (<em>satisfaction</em>) does there exist an input that leads to a given output? We now define each of these.</p>

    <p class="text-gray-300"><strong>Definition 8.3</strong> (SPFE problem). The <strong>sum-product formula evaluation problem</strong> is the following: given a sum-product formula  <span class="math">\\mathcal{F}</span> , value y, and input x (given as a mapping from each leaf vertex v of  <span class="math">\\mathcal{F}</span> 's ari-tree T to an arithmetic circuit computing the polynomial  <span class="math">x_v</span> ), determine if  <span class="math">\\mathcal{F}[x] = y</span> . This problem induces the language</p>

    <p class="text-gray-300"><span class="math">$\\mathscr{L}_{\\mathrm{SPFE}} := \\big\\{ (\\mathcal{F}, \\mathtt{y}, \\mathtt{x}) \\; \\textit{s.t.} \\; \\mathcal{F}[\\mathtt{x}] = \\mathtt{y} \\big\\} \\; .</span>$</p>

    <p class="text-gray-300">(When x is given as above, space(x) denotes the maximum space required to evaluate any circuit in x.)</p>

    <p class="text-gray-300"><strong>Definition 8.4</strong> (SPFS problem). The sum-product formula satisfaction problem is the following: given a sum-product formula  <span class="math">\\mathcal{F}</span> , partial mapping of leaf vertices to arithmetic circuits x, and value y, determine if there exists a mapping z from the leaf vertices not in the domain of x to polynomials s.t.  <span class="math">\\mathcal{F}[x,z] = y</span> . This problem induces the relation</p>

    <p class="text-gray-300"><span class="math">$\\mathscr{R}_{\\mathrm{SPFS}} := \\left\\{ \\left( (\\mathcal{F}, y, x), z \\right) \\text{s.t. } \\mathcal{F}[x, z] = y \\right\\} \\ .</span>$</p>

    <p class="text-gray-300">(We refer to x as the explicit input and z as the auxiliary input.)</p>

      <h4 id="sec-8.2.2" class="text-lg font-semibold mt-6">8.2.2 Delegating sum-product formula evaluation problems</h4>

    <p class="text-gray-300">We give an Interactive Proof to delegate sum-product formula evaluation problems.</p>

    <p class="text-gray-300"><strong>Theorem 8.5</strong> (IP for SPFE). There exists a public-coin Interactive Proof for the language  <span class="math">\\mathcal{L}_{\\text{SPFE}}</span> . In more detail:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{L}_{\\mathrm{SPFE}} \\in \\mathbf{AM} \\left[ \\begin{array}{ll} \\textit{soundness error:} &amp; O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}} \\cdot \\mathsf{arity}(T) \\cdot |V(T)|/|\\mathbb{F}|) \\\\ \\textit{round complexity:} &amp; O(\\mathsf{depth}(T) \\cdot \\mathsf{arity}(T)) \\\\ \\textit{prover time:} &amp; \\mathsf{poly}(|\\mathcal{F}|, |\\mathtt{x}|, |H|^{\\mathsf{arity}(T)}) \\\\ \\textit{verifier time:} &amp; \\mathsf{poly}(|\\mathcal{F}|) + O(|\\mathtt{x}|) \\\\ \\textit{verifier space:} &amp; O(\\mathsf{arity}(T) \\cdot \\mathsf{width}(T) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{F}| + \\mathsf{space}(\\mathtt{x})) \\end{array} \\right]</span>$</p>

    <p class="text-gray-300">Before describing the Interactive Proof system, we define for every vertex v in the ari-tree (of a sum-product formula) a function  <span class="math">\\hat{v}[\\mathbf{x}]</span>  based on the function  <span class="math">v[\\mathbf{x}]</span> , as follows. If v is a leaf vertex, then  <span class="math">\\hat{v}[\\mathbf{x}]</span>  equals the polynomial  <span class="math">\\mathbf{x}_v</span> . If instead v is an internal vertex, then  <span class="math">\\hat{v}[\\mathbf{x}]</span>  is the low-degree extension of the evaluation of  <span class="math">v[\\mathbf{x}]</span>  on  <span class="math">H^{\\text{arity}(v)}</span> :</p>

    <p class="text-gray-300">
<span class="math">$\\hat{v}[\\mathbf{x}](\\vec{X}) := \\sum_{\\vec{\\alpha} \\in H^{\\mathrm{arity}(v)}} I_{H^{\\mathrm{arity}(v)}}(\\vec{X}, \\vec{\\alpha}) \\sum_{\\vec{\\beta} \\in H^{m_v}} C_v(\\vec{\\alpha}, \\vec{\\beta}, u_1[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, u_t[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\Big) \\ . \\tag{6}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\hat{v}[x]</span>  agrees with v[x] on  <span class="math">H^{\\mathsf{arity}(v)}</span> , we can equivalently define  <span class="math">\\hat{v}[x]</span>  in terms of the  <span class="math">\\hat{u}_i[x]</span>  rather than the  <span class="math">u_i[x]</span> :</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\hat{v}[\\mathbf{x}](\\vec{X}) := &amp; \\sum_{\\vec{\\alpha} \\in H^{\\mathrm{arity}(v)}} I_{H^{\\mathrm{arity}(v)}}(\\vec{X}, \\vec{\\alpha}) \\sum_{\\vec{\\beta} \\in H^{m_v}} C_v \\left(\\vec{\\alpha}, \\vec{\\beta}, \\hat{u}_1[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, \\hat{u}_t[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\right) \\\\ = &amp; \\sum_{\\vec{\\alpha} \\in H^{\\mathrm{arity}(v)}} \\sum_{\\vec{\\beta} \\in H^{m_v}} I_{H^{\\mathrm{arity}(v)}}(\\vec{X}, \\vec{\\alpha}) \\cdot C_v \\left(\\vec{\\alpha}, \\vec{\\beta}, \\hat{u}_1[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, \\hat{u}_t[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\right) \\; . \\end{split}</span>$</p>

    <p class="text-gray-300">Note that the summand in the last line above is a polynomial, and its individual degree in  <span class="math">(\\vec{\\alpha}, \\vec{\\beta})</span>  is at most  <span class="math">|H| + \\delta_{\\rm in} \\cdot \\max\\{\\delta_{\\rm lf}, |H|\\} \\le 2\\delta_{\\rm in}\\delta_{\\rm lf}</span> . Indeed,  <span class="math">\\hat{u}_i[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_i}}, \\vec{\\beta}|_{\\sigma_{e_i}})</span>  has individual degree at most  <span class="math">\\delta_{\\rm lf}</span>  if  <span class="math">u_i</span>  is a leaf, and individual degree at most |H| otherwise (as  <span class="math">\\hat{v}[\\mathbf{x}]</span>  has individual degree at most |H| in  <span class="math">\\vec{X}</span> );  <span class="math">C_v</span>  computes a polynomial of total degree at most  <span class="math">\\delta_{\\rm in}</span> ; and  <span class="math">I_{H^{\\rm arity}(v)}(\\vec{X}, \\vec{\\alpha})</span>  has individual degree at most |H| in  <span class="math">\\vec{\\alpha}</span> . We use this degree bound below.</p>

    <p class="text-gray-300"><em>Proof.</em> The prover and verifier receive a SPFE instance  <span class="math">(\\mathcal{F}, y, x)</span>  as input. They both associate, for each vertex v of its ari-tree T, a label  <span class="math">(\\vec{\\gamma}_v, a_v)</span>  with  <span class="math">\\vec{\\gamma}_v \\in \\mathbb{F}^{\\mathsf{arity}(v)}</span>  and  <span class="math">a_v \\in \\mathbb{F}</span> ; for the root, this label equals  <span class="math">(\\bot, y)</span> , while for all other vertices this label is defined during the protocol. The prover and verifier then interact as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of T taken in (any) topological order, letting  <span class="math">t := \\mathsf{out}_T(v)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) The prover and verifier invoke the sumcheck protocol [LFKN92; Sha92] on the claim &quot; <span class="math">\\hat{v}[x](\\vec{\\gamma}_v) = a_v</span> &quot;. By the end of this subprotocol, the verifier has chosen  <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\mathsf{arity}(v)}</span>  and  <span class="math">\\vec{c}_2 \\in \\mathbb{F}^{m_v}</span>  uniformly at random, and has derived from the prover's messages a value  <span class="math">b \\in \\mathbb{F}</span>  that allegedly satisfies the following equality:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$b := I_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_v, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, \\hat{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}}, \\vec{c}_2|_{\\sigma_{e_1}}), \\dots, \\hat{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}}, \\vec{c}_2|_{\\sigma_{e_t}})) \\ , \\tag{7}</span>$</p>

    <p class="text-gray-300">where  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  are v's outgoing edges.</p>

    <p class="text-gray-300">(b) The prover sends  <span class="math">h_1:=\\hat{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}},\\vec{c}_2|_{\\sigma_{e_1}}),\\ldots,h_t:=\\hat{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}},\\vec{c}_2|_{\\sigma_{e_t}})\\in\\mathbb{F}</span> , and the verifier checks that</p>

    <p class="text-gray-300">
<span class="math">$b = I_{H^{\\mathsf{arity}(v)}}(\\vec{\\gamma}_v, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, h_1, \\dots, h_t) \\ . \\tag{8}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(c) For  <span class="math">j=1,\\ldots,t</span> , the verifier sets  <span class="math">(\\vec{\\gamma}_{u_j},a_{u_j}):=((\\vec{c}_1|_{\\rho_{e_j}},\\vec{c}_2|_{\\sigma_{e_j}}),h_j).</span></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every leaf vertex v of T, the verifier checks that  <span class="math">\\hat{v}[x](\\vec{\\gamma}_v) = a_v</span> , i.e., that  <span class="math">x_v(\\vec{\\gamma}_v) = a_v</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">While the above description considers sequential invocations of the sumcheck protocol, these can be run in parallel in  <span class="math">\\operatorname{depth}(T)</span>  phases: first the root (which has depth 0), then all vertices of depth 1, then all vertices of depth 2, and so on until all vertices of depth  <span class="math">\\operatorname{depth}(T)-1</span> . Each such phase requires  <span class="math">O(\\operatorname{arity}(T))</span>  rounds, so that the number of rounds is now  <span class="math">O(\\operatorname{depth}(T) \\cdot \\operatorname{arity}(T))</span> , as claimed. The claimed running times for the prover and verifier follow immediately from the above description. The claimed space bound follows from the observation that in phase i, if we also check the</p>

    <p class="text-gray-300">leaf vertices at depth i during this phase, then the verifier may discard  <span class="math">(\\vec{\\gamma}_v, a_v)</span>  for all vertices v with depth <span class="math">_T(v) &lt; i-1</span> ; and that the value of  <span class="math">I_{H^{\\operatorname{arity}(v)}}</span>  can be computed in space  <span class="math">O(\\log(\\operatorname{arity}(v)) + \\log |\\mathbb{F}|)</span> . We are left to argue the claimed soundness error.</p>

    <p class="text-gray-300">If for some internal vertex v it holds that  <span class="math">v[\\mathbf{x}](\\gamma_v) \\neq a_v</span> , then the soundness property of the sumcheck protocol implies that either the verifier rejects or Equation 7 holds with probability at most  <span class="math">2\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}} \\cdot \\mathsf{arity}(v)/|\\mathbb{F}|</span> . In this latter case, either Equation 7 fails to hold and the verifier rejects, or there exists  <span class="math">j \\in \\{1,\\ldots,\\mathsf{out}_T(v)\\}</span>  such that  <span class="math">e_j \\neq \\hat{u}_j[\\mathbf{x}](\\vec{c}_1,\\vec{c}_2)</span> , which means that there exists a vertex u in the next layer (in fact,  <span class="math">u=u_j</span>  suffices) for which  <span class="math">\\hat{u}[\\mathbf{x}](\\vec{\\gamma}_u) \\neq a_u</span> . If u is a leaf vertex then the verifier will reject when considering u; otherwise we repeat the above argument. Taking a union bound over the internal vertices of T yields the claimed soundness error.</p>

      <h4 id="sec-8.2.3" class="text-lg font-semibold mt-6">8.2.3 Delegating sum-product formula satisfaction problems</h4>

    <p class="text-gray-300">We give an Interactive PCP to delegate sum-product formula <em>satisfaction</em> problems, via a simple extension of the Interactive Proof for <em>evaluation</em> problems in the previous section. Similarly to [Sha92; She92; GKR15], the verifier only needs to access the formula's input at a few locations, at the end of the protocol; thus the prover can simply send the input as a proof oracle, and the verifier can query it (via suitable low-degree testing and self-correction of polynomials).</p>

    <p class="text-gray-300"><strong>Theorem 8.6</strong> (IPCP for SPFS). There exists a (public-coin and non-adaptive) Interactive PCP for the relation  <span class="math">\\mathcal{R}_{SPFS}</span> . In more detail:</p>

    <pre><code class="language-text">\\mathscr{R}_{\\mathrm{SPFS}} \\in \\mathbf{IPCP} \\begin{bmatrix} \\textit{soundness error:} &amp; O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}} \\cdot \\mathsf{arity}(T) \\cdot |V(T)|/|\\mathbb{F}|) \\\\ \\textit{pround complexity:} &amp; O(\\mathsf{depth}(T) \\cdot \\mathsf{arity}(T)) \\\\ \\textit{proof length:} &amp; O(|V(T)| \\cdot |\\mathbb{F}|^{\\mathsf{arity}(T)}) \\\\ \\textit{query complexity:} &amp; |V(T)| \\cdot \\mathsf{poly}(\\log |\\mathbb{F}|, \\mathsf{arity}(T), \\delta_{\\mathsf{lf}}) \\\\ \\textit{prover time:} &amp; \\mathsf{poly}(|\\mathcal{F}|, |\\mathbb{x}|, |\\mathbb{z}|, |H|^{\\mathsf{arity}(T)}) \\\\ \\textit{verifier time:} &amp; \\mathsf{poly}(|\\mathcal{F}|, |\\mathbb{x}|) \\\\ \\textit{verifier space:} &amp; O(\\mathsf{arity}(T) \\cdot \\mathsf{width}(T) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{F}| + \\mathsf{space}(\\mathbb{x})) \\end{bmatrix}
</code></pre>

    <p class="text-gray-300"><em>Proof sketch.</em> The prover and verifier receive a SPFS instance  <span class="math">(\\mathcal{F}, y, x)</span>  as input, and the prover additionally receives an auxiliary input z for  <span class="math">\\mathcal{F}</span>  that is a valid witness for  <span class="math">(\\mathcal{F}, y, x)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Oracle. The prover sends to the verifier the proof string  <span class="math">\\pi := \\mathcal{F}</span> , where each polynomial  <span class="math">\\mathbf{z}_v \\colon \\mathbb{F}^{\\mathsf{arity}(v)} \\to \\mathbb{F}</span>  is represented by its evaluation table over the whole domain.</li>
      <li>Interaction. The prover and verifier engage in an Interactive Proof for the claim &quot; <span class="math">(\\mathcal{F}, y, (x, z)) \\in \\mathcal{L}_{SPFE}</span> &quot; using the protocol from the proof of Theorem 8.5 above. The verifier must access z only at the end of the protocol, and at few locations: for each leaf vertex v of T where v is not in the domain of x, the verifier needs the value of  <span class="math">z_v</span>  at a single location  <span class="math">\\vec{\\gamma}_v</span> . Thus, the verifier tests that each  <span class="math">z_v</span>  is close to the evaluation of a polynomial of suitable degree [GS06; GR15], and then uses self-correction to read each  <span class="math">z_v(\\vec{\\gamma}_v)</span>  [RS96; AS03].</li>
    </ul>

    <p class="text-gray-300">Setting parameters for low-degree testing and self-correction appropriately (for the case of individual-degree multivariate polynomials) yields the parameters claimed in the theorem statement.  <span class="math">\\Box</span></p>

      <h3 id="sec-8.3" class="text-xl font-semibold mt-8">8.3 Sum-product circuits</h3>

    <p class="text-gray-300">The purpose of this section is to (i) introduce <em>sum-product circuits</em>, and (ii) give proof systems for two computational problems about these, <em>evaluation</em> and <em>satisfaction</em>.</p>

      <h4 id="sec-8.3.1" class="text-lg font-semibold mt-6">8.3.1 Formal definition</h4>

    <p class="text-gray-300">As with a boolean circuit, the 'topology' of a a sum-product circuit is a directed acyclic multi-graph: a tuple G=(V,E) where E is a multi-set of directed edges in  <span class="math">V\\times V</span>  with no directed cycles. We assume that there is a single vertex  <span class="math">r_G\\in V</span>  with in-degree zero, known as the root. The vertices with out-degree zero are known as the leaves, while</p>

    <p class="text-gray-300">all other vertices are known as internal vertices. We also assume that, for every vertex v, all directed paths from the root  <span class="math">r_G</span>  to v have the same length, which we denote  <span class="math">\\operatorname{depth}_G(v)</span> . The depth of G, denoted  <span class="math">\\operatorname{depth}(G)</span> , is the maximum depth of any vertex v in V. The width of G, denoted  <span class="math">\\operatorname{width}(G)</span> , is the maximum number of vertices at any depth:  <span class="math">\\max_{i=1}^{\\operatorname{depth}(G)} |\\{v \\in V : \\operatorname{depth}_G(v) = i\\}|</span> . The in-degree and out-degree of a vertex v are denoted by  <span class="math">\\operatorname{in}_G(v)</span>  and  <span class="math">\\operatorname{out}_G(v)</span> ; we also define  <span class="math">\\operatorname{in}(G) := \\max_{v \\in V} \\operatorname{in}_G(v)</span> .</p>

    <p class="text-gray-300"><strong>Definition 8.7.</strong> A tuple  <span class="math">G = (V, E, \\rho, \\sigma)</span>  is an <strong>ari-graph</strong> if (V, E) is a directed acyclic multi-graph and both  <span class="math">\\rho</span>  and  <span class="math">\\sigma</span>  label every edge e in E with finite sets of positive integers  <span class="math">\\rho_e</span>  and  <span class="math">\\sigma_e</span>  that satisfy the following property. For every vertex v in V, there exists a (unique) non-negative integer arity(v) such that: (1) if v is the root then  <span class="math">\\operatorname{arity}(v) = 0</span> , otherwise  <span class="math">\\operatorname{arity}(v) = |\\rho_{e_1}| + |\\sigma_{e_1}| = \\cdots = |\\rho_{e_{\\operatorname{in}_G(v)}}| + |\\sigma_{e_{\\operatorname{in}_G(v)}}|</span>  where  <span class="math">e_1, \\ldots, e_{\\operatorname{in}_G(v)}</span>  are v's incoming edges; (2)  <span class="math">\\rho_{e_1}, \\ldots, \\rho_{e_{\\operatorname{out}_G(v)}} \\subseteq \\{1, \\ldots, \\operatorname{arity}(v)\\}</span> , where  <span class="math">e_1, \\ldots, e_{\\operatorname{out}_G(v)}</span>  are v's outgoing edges.</p>

    <p class="text-gray-300">For convenience, we denote by  <span class="math">\\operatorname{arity}(G)</span>  the maximum of  <span class="math">\\operatorname{arity}(v)</span>  across all vertices v in the vertex set V of G. Moreover, for every vertex v, we define  <span class="math">m_v := \\max(\\sigma_{e_1} \\cup \\dots \\cup \\sigma_{e_{\\operatorname{out}_G(v)}})</span>  so that  <span class="math">\\sigma_{e_1}, \\dots, \\sigma_{e_{\\operatorname{out}_G(v)}} \\subseteq \\{1, \\dots, m_v\\}</span> . We are now ready to define a sum-product circuit  <span class="math">\\mathcal{C}</span> , an input x for  <span class="math">\\mathcal{C}</span> , and how to evaluate  <span class="math">\\mathcal{C}</span>  on x.</p>

    <p class="text-gray-300"><strong>Definition 8.8.</strong> A sum-product circuit is a tuple  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, G, \\mathcal{C})</span>  where:  <span class="math">\\mathbb{F}</span>  is a finite field, H is a subset of  <span class="math">\\mathbb{F}</span>  (represented as a list of field elements),  <span class="math">\\delta_{\\mathsf{in}}</span> ,  <span class="math">\\delta_{\\mathsf{lf}}</span>  are positive integers (represented in unary) with  <span class="math">\\delta_{\\mathsf{lf}} \\geq |H|</span> ,  <span class="math">G = (V, E, \\rho, \\sigma)</span>  is an ari-graph, and  <span class="math">\\mathcal{C}</span>  labels each internal vertex v of G with an arithmetic circuit  <span class="math">C_v(\\vec{X}, \\vec{Y}, \\vec{Z})</span> :  <span class="math">\\mathbb{F}^{\\mathsf{arity}(v)} \\times \\mathbb{F}^{\\mathsf{mv}} \\times \\mathbb{F}^{\\mathsf{out}_T(v)} \\to \\mathbb{F}</span>  of <u>total</u> degree at most  <span class="math">\\delta_{\\mathsf{in}}</span> . An <strong>input</strong>  <span class="math">\\mathbb{E}</span>  for  <span class="math">\\mathcal{C}</span>  labels each leaf vertex v of G with a polynomial  <span class="math">\\mathbb{E}_v</span> :  <span class="math">\\mathbb{F}^{\\mathsf{depth}_G(v) \\cdot m} \\to \\mathbb{F}</span>  of <u>individual</u> degree at most  <span class="math">\\delta_{\\mathsf{lf}}</span> . The <strong>value</strong> of  <span class="math">\\mathcal{C}</span>  on an input  <span class="math">\\mathbb{E}</span>  is denoted  <span class="math">\\mathcal{C}[\\mathbb{E}]</span>  and equals  <span class="math">r_G[\\mathbb{E}]</span> , which we define below.</p>

    <p class="text-gray-300">The value of a vertex v of G on an input x is denoted v[x] and is recursively defined as follows. If v is a leaf vertex, then v[x] equals the polynomial  <span class="math">x_v</span> . If v is an internal vertex, then v[x] is the arity(v)-variate polynomial over  <span class="math">\\mathbb{F}</span>  defined by the following expression:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\beta} \\in H^{m_v}} C_v \\left( \\vec{X}, \\vec{\\beta}, u_1[\\mathbf{x}] (\\vec{X}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, u_t[\\mathbf{x}] (\\vec{X}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\right) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">t := \\text{out}_G(v)</span> , and  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  are the outgoing edges of v (with multiplicity). In particular,  <span class="math">C[x] = r_G[x]</span>  is a constant in F.</p>

    <p class="text-gray-300">Given a sum-product circuit we can ask two types of computational problems: (<em>evaluation</em>) does a given input lead to a given output? (<em>satisfaction</em>) does there exist an input that leads to a given output? We now define each of these.</p>

    <p class="text-gray-300"><strong>Definition 8.9</strong> (SPCE problem). The sum-product circuit evaluation problem is the following: given a sum-product circuit C, value y, and input x (given as a mapping from each leaf vertex v of C's ari-graph G to an arithmetic circuit computing the polynomial  <span class="math">x_v</span> ), determine if C[x] = y. This problem induces the language</p>

    <p class="text-gray-300"><span class="math">$\\mathscr{L}_{\\mathrm{SPCE}} := \\big\\{ (\\mathcal{C}, \\mathtt{y}, \\mathtt{x}) \\; \\textit{s.t.} \\; \\mathcal{C}[\\mathtt{x}] = \\mathtt{y} \\big\\} \\;\\; .</span>$</p>

    <p class="text-gray-300">(When x is given as above, space(x) denotes the maximum space required to evaluate any circuit in x.)</p>

    <p class="text-gray-300"><strong>Definition 8.10</strong> (SPCS problem). The <strong>sum-product circuit satisfaction problem</strong> is the following: given a sum-product circuit C, partial mapping of leaf vertices to arithmetic circuits x, and value y, determine if there exists a mapping z from the leaf vertices not in the domain of x to polynomials s.t. C[x, z] = y. This problem induces the relation</p>

    <p class="text-gray-300"><span class="math">$\\mathscr{R}_{\\mathrm{SPCS}} := \\left\\{ \\left( (\\mathcal{C}, \\mathtt{y}, \\mathtt{x}), \\mathtt{z} \\right) \\textit{s.t. } \\mathcal{C}[\\mathtt{x}, \\mathtt{z}] = \\mathtt{y} \\right\\} \\; .</span>$</p>

    <p class="text-gray-300">(We refer to x as the explicit input and z as the auxiliary input.)</p>

      <h4 id="sec-8.3.2" class="text-lg font-semibold mt-6">8.3.2 Delegating sum-product circuit evaluation problems</h4>

    <p class="text-gray-300">We give an Interactive Proof to delegate sum-product formula evaluation problems.</p>

    <p class="text-gray-300"><strong>Theorem 8.11</strong> (IP for SPCE). There exists a public-coin Interactive Proof for the language  <span class="math">\\mathcal{L}_{SPCE}</span> . In more detail:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{L}_{SPCE} \\in \\mathbf{AM} \\left[ \\begin{array}{ccc} \\textit{soundness error:} &amp; O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}} \\cdot \\mathsf{arity}(G) \\cdot |V(G)|/|\\mathbb{F}|) \\\\ \\textit{round complexity:} &amp; O(\\mathsf{depth}(G) \\cdot \\mathsf{arity}(G)) \\\\ \\textit{prover time:} &amp; \\mathsf{poly}(|\\mathcal{C}|, |\\mathbf{x}|, |H|^{\\mathsf{arity}(G)}) \\\\ \\textit{verifier time:} &amp; \\mathsf{poly}(|\\mathcal{C}|) + O(\\mathsf{in}(G) \\cdot |\\mathbf{x}|) \\\\ \\textit{verifier space:} &amp; O(\\mathsf{arity}(G) \\cdot \\mathsf{width}(G) \\cdot \\mathsf{in}(G) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{C}| + \\mathsf{space}(\\mathbf{x})) \\end{array} \\right]</span>$</p>

    <p class="text-gray-300"><em>Proof sketch.</em> The prover and verifier receive as input a SPCE instance (C, y, x). They both associate with each vertex v of its ari-graph G a <em>set</em> of labels  <span class="math">L_v</span> ; for the root, this set contains only the pair  <span class="math">(\\bot, y)</span> , while for all other vertices this set is initially empty and will be populated with at most  <span class="math">\\inf_G(v)</span>  pairs during the protocol. The prover and verifier then interact as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of G taken in (any) topological order, letting  <span class="math">t := \\mathsf{out}_G(v)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) For every  <span class="math">(\\vec{\\gamma}_j, a_j)</span>  in  <span class="math">L_v</span> , the verifier samples a random  <span class="math">\\alpha_j \\in \\mathbb{F}</span>  and sends it to the prover.</li>
      <li>(b) The prover and verifier invoke the sumcheck protocol on the following claim:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">
<span class="math">$\\text{\`\`} \\quad \\sum_{j=1}^{|L_v|} \\alpha_j \\hat{v}[\\mathbf{x}](\\vec{\\gamma}_j) = \\sum_{j=1}^{|L_v|} \\alpha_j a_j \\quad \\text{&#x27;&#x27;}.</span>$</p>

    <p class="text-gray-300">By the end of this subprotocol, the verifier has chosen  <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\mathsf{arity}(v)}</span>  and  <span class="math">\\vec{c}_2 \\in \\mathbb{F}^{m_v}</span>  uniformly at random, and has derived from the prover's messages a value  <span class="math">b \\in \\mathbb{F}</span>  that allegedly satisfies the following equality:</p>

    <p class="text-gray-300"><span class="math">$b = \\sum_{j=1}^{|L_v|} \\alpha_j \\Big( I_{H^{\\text{arity}(v)}}(\\vec{\\gamma_j}, \\vec{c}_1) \\cdot C_v \\Big( \\vec{c}_1, \\vec{c}_2, \\hat{u}_1[\\mathbf{x}] \\Big( \\vec{c}_1|_{\\rho_{e_1}}, \\vec{c}_2|_{\\sigma_{e_1}} \\Big), \\dots, \\hat{u}_t[\\mathbf{x}] \\Big( \\vec{c}_1|_{\\rho_{e_t}}, \\vec{c}_2|_{\\sigma_{e_t}} \\Big) \\Big) \\Big) \\ , \\tag{9}</span>$</p>

    <p class="text-gray-300">where  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  are the outgoing edges of v (with multiplicity).</p>

    <p class="text-gray-300">(c) The prover sends  <span class="math">h_1:=\\hat{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}},\\vec{c}_2|_{\\sigma_{e_1}}),\\ldots,h_t:=\\hat{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}},\\vec{c}_2|_{\\sigma_{e_t}})\\in\\mathbb{F}</span> , and the verifier checks that</p>

    <p class="text-gray-300"><span class="math">$b = \\sum_{j=1}^{|L_v|} \\alpha_j \\Big( I_{H^{\\text{arity}(v)}}(\\vec{\\gamma_j}, \\vec{c}_1) \\cdot C_v \\Big( \\vec{c}_1, \\vec{c}_2, h_1, \\dots, h_t \\Big) \\Big) \\ . \\tag{10}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(d) For every  <span class="math">j=1,\\ldots,t</span> , the verifier adds the label  <span class="math">((\\vec{c}_1|_{\\rho_{e_i}},\\vec{c}_2|_{\\sigma_{e_i}}),h_j)</span>  to  <span class="math">L_{u_j}</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every leaf vertex v of G, and for every  <span class="math">(\\vec{\\gamma}, a) \\in L_v</span> , the verifier checks that  <span class="math">\\hat{v}[x](\\vec{\\gamma}) = a</span> , i.e., that  <span class="math">x_v(\\vec{\\gamma}) = a</span> . (Note that every set  <span class="math">L_v</span>  has had  <span class="math">\\inf_G(v)</span>  labels added to it. The size of  <span class="math">L_v</span>  is then at most  <span class="math">\\inf_G(v)</span> , with the 'strictly less' case occurring if the verifier happens to have added the same label twice.)</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">While the above description considers sequential invocations of the sumcheck protocol, these can be run in parallel in  <span class="math">\\operatorname{depth}(G)</span>  phases: first the root (which has depth 0), then all vertices of depth 1, then all vertices of depth 2, and so on until all vertices of depth  <span class="math">\\operatorname{depth}(G) - 1</span> . Each such phase requires  <span class="math">O(\\operatorname{arity}(G))</span>  rounds, so that the number of rounds is now  <span class="math">O(\\operatorname{depth}(G) \\cdot \\operatorname{arity}(G))</span> , as claimed. The claimed running times for the prover and verifier follow immediately from the above description. The claimed space bound can be attained by discarding all labels at previous levels before moving to the next level, and checking leaf vertices at the same time as the internal vertices at the same depth. We are left to argue the claimed soundness error.</p>

    <p class="text-gray-300">Suppose that, when considering some internal vertex v of G in the protocol above, there exists  <span class="math">(\\vec{\\gamma}, a) \\in L_v</span>  such that  <span class="math">\\hat{v}[\\mathbf{x}](\\vec{\\gamma}) \\neq a</span> . Then, with probability at least  <span class="math">1 - 1/|\\mathbb{F}|</span> , it holds that  <span class="math">\\sum_{j=1}^{|L_v|} \\alpha_j \\hat{v}[\\mathbf{x}](\\vec{\\gamma}_j) \\neq \\sum_{j=1}^{|L_v|} \\alpha_j a_j</span> , which means that the prover and verifier invoke the sumcheck protocol on a false claim. By the soundness of the sumcheck protocol, either</p>

    <p class="text-gray-300">the verifier rejects or Equation 9 holds with probability at most  <span class="math">2\\delta_{\\text{in}}\\delta_{\\text{lf}}\\cdot\\text{arity}(v)/|\\mathbb{F}|</span> . In this latter case, either Equation 10 fails to hold and the verifier rejects, or there exists  <span class="math">j\\in\\{1,\\ldots,\\text{out}_G(v)\\}</span>  such that  <span class="math">h_j\\neq\\hat{u}_j[\\mathtt{x}](\\vec{c}_1|_{\\rho_{e_j}},\\vec{c}_2|_{\\sigma_{e_j}})</span> , which means that there exists a vertex u in the next layer (in particular,  <span class="math">u=u_j</span> ) for which there exists  <span class="math">(\\vec{\\gamma}&#x27;,a&#x27;)\\in L_u</span>  such that  <span class="math">\\hat{u}[\\mathtt{x}](\\vec{\\gamma}&#x27;)\\neq a&#x27;</span> . If u is a leaf vertex then the verifier will reject when considering u; otherwise we repeat the above argument. Taking a union bound over the internal vertices of G yields the claimed soundness error.</p>

      <h4 id="sec-8.3.3" class="text-lg font-semibold mt-6">8.3.3 Delegating sum-product circuit satisfaction problems</h4>

    <p class="text-gray-300">We give an Interactive PCP to delegate sum-product circuit satisfaction problems.</p>

    <p class="text-gray-300"><strong>Theorem 8.12</strong> (IPCP for SPCS). There exists a (public-coin and non-adaptive) Interactive PCP for the relation  <span class="math">\\mathcal{R}_{SPCS}</span> . In more detail:</p>

    <pre><code class="language-text"> \\mathcal{R}_{SPCS} \\in \\mathbf{IPCP} \\left[ \\begin{array}{ll} \\textit{soundness error:} &amp; O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}} \\cdot \\mathsf{arity}(G) \\cdot |E(G)|/|\\mathbb{F}|) \\\\ \\textit{round complexity:} &amp; O(\\mathsf{depth}(G) \\cdot \\mathsf{arity}(G)) \\\\ \\textit{proof length:} &amp; O(|V(G)| \\cdot |\\mathbb{F}|^{\\mathsf{arity}(G)}) \\\\ \\textit{query complexity:} &amp; |V(G)| \\cdot \\mathsf{poly}(\\log |\\mathbb{F}|, \\mathsf{arity}(G), \\delta_{\\mathsf{lf}}) \\\\ \\textit{prover time:} &amp; \\mathsf{poly}(|\\mathcal{C}|, |\\mathbf{x}|, |\\mathbf{z}|, |H|^{\\mathsf{arity}(G)}) \\\\ \\textit{verifier time:} &amp; \\mathsf{poly}(|\\mathcal{C}|, |\\mathbf{x}|) \\\\ \\textit{verifier space:} &amp; O(\\mathsf{arity}(G) \\cdot \\mathsf{width}(G) \\cdot \\mathsf{in}(G) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{C}| + \\mathsf{space}(\\mathbf{x})) \\end{array} \\right]
</code></pre>

    <p class="text-gray-300"><em>Proof.</em> The protocol is analogous to that in the proof of Theorem 8.6, which considers the relation  <span class="math">\\mathscr{R}_{\\mathrm{SPFS}}</span>  (sum-product formula satisfaction) rather than  <span class="math">\\mathscr{R}_{\\mathrm{SPCS}}</span>  (sum-product circuit satisfaction). Specifically, we only need to replace the Interactive Proof for the language  <span class="math">\\mathscr{L}_{\\mathrm{SPFE}}</span>  (sum-product formula evaluation) with the Interactive Proof for the language  <span class="math">\\mathscr{L}_{\\mathrm{SPCE}}</span>  (sum-product circuit evaluation) that we gave in the proof of Theorem 8.11. We omit the details, except for one technicality that we now describe.</p>

    <p class="text-gray-300">The strategy described in the above paragraph eventually leads the verifier to read, via self-correction, at most  <span class="math">\\operatorname{in}_G(v)</span>  values of  <span class="math">\\mathbf{z}_v</span>  for every leaf vertex v of G not in the domain of  <span class="math">\\mathbf{x}</span> . Overall, the verifier reads at most  <span class="math">\\sum_v \\operatorname{in}_G(v) \\leq |E(G)|</span>  values via self-correction, which corresponds to  <span class="math">|E(G)| \\cdot \\operatorname{poly}(\\log |\\mathbb{F}| + \\operatorname{arity}(G) + \\delta_{\\operatorname{lf}})</span>  actual queries, and a soundness error of  <span class="math">O(\\delta_{\\operatorname{in}}\\delta_{\\operatorname{lf}} \\cdot \\operatorname{arity}(G) \\cdot |V(G)|/|\\mathbb{F}|)</span> . To obtain the stated query complexity, we reduce the number of values read via self-correction to a single value per leaf vertex, via the following standard trick.</p>

    <p class="text-gray-300">Let  <span class="math">t_1,\\ldots,t_{\\mathsf{in}_G(v)}\\in\\mathbb{F}</span>  be arbitrary distinct values known to both the prover and verifier, and let  <span class="math">A_v\\colon\\mathbb{F}\\to\\mathbb{F}^{\\mathsf{arity}(v)}</span>  be the unique polynomial of degree less than  <span class="math">\\mathsf{in}_G(v)</span>  such that  <span class="math">A_v(t_i)=\\vec{\\gamma_i}</span>  for every  <span class="math">(\\vec{\\gamma_i},a_i)\\in L_v</span> . The prover sends  <span class="math">B_v:=(\\mathbf{z}_v\\circ A_v)\\colon\\mathbb{F}\\to\\mathbb{F}</span>  to the verifier (as a list of at most  <span class="math">\\mathsf{arity}(v)\\cdot\\mathsf{in}_G(v)\\cdot\\delta_{\\mathsf{lf}}</span>  coefficients), who checks that  <span class="math">B_v(t_i)=a_i</span>  for every  <span class="math">i\\in\\{1,\\ldots,\\mathsf{in}_G(v)\\}</span> . The verifier then picks  <span class="math">t\\in\\mathbb{F}</span>  uniformly at random and checks that  <span class="math">\\mathbf{z}_v(A_v(t))=B_v(t)</span> ; this involves obtaining, via self-correction, the value of  <span class="math">\\mathbf{z}_v</span>  at  <span class="math">A_v(t)</span> . Soundness is maintained because if the prover sends  <span class="math">B_v&#x27;\\neq B_v</span>  then the probability that  <span class="math">\\mathbf{z}_v(A_v(t))=B_v&#x27;(t)</span>  for uniformly random  <span class="math">t\\in\\mathbb{F}</span>  is at most  <span class="math">\\mathsf{arity}(v)\\cdot\\mathsf{in}_G(v)\\cdot\\delta_{\\mathsf{lf}}/|\\mathbb{F}|</span> . The overall soundness error is then, by a union bound, at most  <span class="math">O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}}\\cdot\\mathsf{arity}(G)\\cdot|V(G)|/|\\mathbb{F}|)+\\sum_v\\mathsf{arity}(v)\\cdot\\mathsf{in}_G(v)\\cdot\\delta_{\\mathsf{lf}}/|\\mathbb{F}|=O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}}\\cdot\\mathsf{arity}(G)\\cdot|E(G)|/|\\mathbb{F}|)</span> . The additional space required for this test is  <span class="math">O(\\mathsf{arity}(G)\\cdot\\mathsf{in}(G)\\cdot\\mathsf{log}\\,|\\mathbb{F}|+\\mathsf{log}\\,|\\mathcal{C}|)</span> , so the space bound is unaffected.</p>

    <p class="text-gray-300">The protocols for delegating sum-product computations described in Section 8 are not zero knowledge. We show how to delegate, in the Interactive PCP model, sum-product circuit evaluation problems (Section 9.1) and satisfaction problems (Section 9.2). As a special case, we also obtain the same for sum-product formulas.</p>

    <p class="text-gray-300">The purpose of this section is to show that the language  <span class="math">\\mathcal{L}_{SPCE}</span>  (consisting of sum-product circuit evaluation problems, see Definition 8.9) has perfect zero knowledge Interactive PCPs:</p>

    <p class="text-gray-300"><strong>Theorem 9.1</strong> (PZK IPCP for  <span class="math">\\mathcal{L}_{SPCE}</span> ). For every query bound function b(n), the language  <span class="math">\\mathcal{L}_{SPCE}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail, letting  <span class="math">\\alpha := \\log b/\\log |H|</span> :</p>

    <pre><code class="language-text">\\mathscr{L}_{\\mathrm{SPCE}} \\in \\mathbf{PZK\\text{-}IPCP} \\begin{bmatrix} soundness \\ error: &amp; O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{lf}} \\cdot \\mathrm{in}(G) \\cdot (\\mathrm{arity}(G) + \\alpha) \\cdot |V(G)|/|\\mathbb{F}|) \\\\ proof \\ length: &amp; O(|V(G)| \\cdot |\\mathbb{F}|^{\\mathrm{arity}(G) + \\alpha}) \\\\ query \\ complexity: &amp; |V(G)| \\cdot \\mathrm{poly}(\\log |\\mathbb{F}|, \\mathrm{arity}(G), \\alpha, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{lf}}, \\mathrm{in}(G)) \\\\ prover \\ time: &amp; \\mathrm{poly}(|\\mathcal{C}|, |\\mathbb{x}|, |\\mathbb{F}|^{\\mathrm{arity}(G) + \\alpha}) \\\\ verifier \\ time: &amp; \\mathrm{poly}(|\\mathcal{C}|, \\alpha) + O(\\mathrm{in}(G) \\cdot |\\mathbb{x}|) \\\\ verifier \\ space: &amp; O((\\mathrm{arity}(G) + \\alpha) \\cdot \\mathrm{width}(G) \\cdot \\mathrm{in}(G) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{C}| + \\mathrm{space}(\\mathbb{x})) \\\\ simulator \\ overhead: &amp; \\mathrm{poly}(|\\mathcal{C}|, \\alpha) \\cdot (|\\mathbb{x}| + \\mathsf{q}_V^3). \\end{bmatrix}
We introduce some notation before the space G:
</code></pre>

    <p class="text-gray-300">We introduce some notation before the proof. Given a subset H of  <span class="math">\\mathbb{F}</span>  and a positive integer m, we denote by  <span class="math">\\mathbb{Z}_{H^m}</span>  the m-variate polynomial  <span class="math">\\prod_{i=1}^m \\prod_{\\alpha \\in H} (X_i - \\alpha)</span> . Note that  <span class="math">\\mathbb{Z}_{H^m}</span>  is zero on  <span class="math">H^m</span>  and nonzero on  <span class="math">(\\mathbb{F} - H)^m</span> , and can be evaluated in  <span class="math">\\operatorname{poly}(|H| + m)</span>  field operations and space  <span class="math">O(\\log m + \\log |\\mathbb{F}|)</span> .</p>

    <p class="text-gray-300">To guide us to the proof of the above theorem, it is instructive to look at why the protocol of Theorem 8.11 may not be zero knowledge. We identify two potential sources of leakage: the first is the values  <span class="math">\\hat{v}[\\mathbf{x}](\\vec{c})</span>  for internal vertices v which the prover sends in Step 1c of the protocol; the second is the partial sums which are leaked by the sumcheck subprotocol itself.</p>

    <p class="text-gray-300">We resolve the first issue by replacing, for each internal vertex v, the low-degree extension  <span class="math">\\hat{v}[\\mathbf{x}]</span>  in the SPCE protocol with a randomized low-degree extension  <span class="math">\\dot{v}[\\mathbf{x}]</span> , which is  <span class="math">\\operatorname{in}_G(v)</span> -wise independent outside of  <span class="math">H^{\\operatorname{arity}(v)}</span> . More precisely, for any list of distinct query points  <span class="math">\\vec{\\gamma}_1,\\ldots,\\vec{\\gamma}_{\\operatorname{in}_G(v)}\\in(\\mathbb{F}-H)^{\\operatorname{arity}(v)},</span>   <span class="math">(\\dot{v}[\\mathbf{x}](\\vec{\\gamma}_i))_{i=1}^{\\operatorname{in}_G(v)}</span>  is uniformly random in  <span class="math">\\mathbb{F}^\\ell</span> . Given such a low-degree extension, it suffices to ensure that the verifier may only learn its evaluations inside  <span class="math">(\\mathbb{F}-H)^m</span> , and then only on at most  <span class="math">\\operatorname{in}_G(v)</span>  distinct points; then we can simulate all of these queries with uniformly random field elements.</p>

    <p class="text-gray-300">Given a sum-product circuit  <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\text{in}},\\delta_{\\text{lf}},G,C)</span> , we define for every vertex v in its ari-graph  <span class="math">G=(V,E,\\rho,\\sigma)</span>  a random variable  <span class="math">\\dot{v}[\\mathtt{x}]</span>  based on  <span class="math">v[\\mathtt{x}]</span> , as follows. Let  <span class="math">\\lambda:=2\\delta_{\\text{in}}\\cdot(\\delta_{\\text{lf}}+\\text{in}(G))=\\Omega(|H|)</span> . If v is a leaf vertex, then  <span class="math">\\dot{v}[\\mathtt{x}]</span>  simply equals  <span class="math">\\mathtt{x}_v</span>  with probability 1. If instead v is an internal vertex, then  <span class="math">\\dot{v}[\\mathtt{x}]</span>  is a &quot;randomized&quot; low-degree extension of  <span class="math">v[\\mathtt{x}]</span> :</p>

    <p class="text-gray-300"><span class="math">$\\dot{v}[\\mathbf{x}](\\vec{X}) := \\hat{v}[\\mathbf{x}](\\vec{X}) + \\mathbb{Z}_{H^{\\mathsf{arity}(v)}}(\\vec{X}) \\sum_{\\vec{\\gamma} \\in G^k} R_v(\\vec{X}, \\vec{\\gamma}) \\enspace,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{v}[x]</span>  is the fixed low-degree extension of v[x] that we used in Section 8 (see Equation 6), k is a security parameter, G is an arbitrary subset of  <span class="math">\\mathbb{F}</span>  of size  <span class="math">\\lambda</span>  with  <span class="math">0 \\in G</span> ,  <span class="math">R_v</span>  is uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\operatorname{arity}(v)}^{\\leq in_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> , and  <span class="math">\\operatorname{in}_G(v)</span>  is the in-degree of v in G. (In the protocol, the verifier receives in the oracle message the evaluation table of independently drawn  <span class="math">R_v</span> , for every internal vertex v of G.)</p>

    <p class="text-gray-300">Since  <span class="math">\\dot{v}[x]</span>  agrees with v[x] on  <span class="math">H^{\\text{arity}(v)}</span> , we can equivalently write (using the definition of  <span class="math">\\hat{v}[x]</span> ):</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\dot{v}[\\mathbf{x}](\\vec{X}) := &amp; \\left( \\sum_{\\vec{\\alpha} \\in H^{\\mathrm{arity}(v)}} \\sum_{\\vec{\\beta} \\in H^{m_v}} I_{H^{\\mathrm{arity}(v)}}(\\vec{X}, \\vec{\\alpha}) \\cdot C_v \\big(\\vec{\\alpha}, \\vec{\\beta}, \\dot{u}_1[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\big) \\right) \\\\ &amp; + \\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{X}) \\sum_{\\vec{\\gamma} \\in G^k} R_v(\\vec{X}, \\vec{\\gamma}) \\\\ &amp;= \\sum_{\\vec{\\alpha} \\in H^{\\mathrm{arity}(v)}} \\sum_{\\vec{\\beta} \\in H^{m_v}} \\sum_{\\vec{\\gamma} \\in G^k} \\left( I_{G^k}(\\vec{0}, \\vec{\\gamma}) \\cdot I_{H^{\\mathrm{arity}(v)}}(\\vec{X}, \\vec{\\alpha}) \\cdot C_v \\big(\\vec{\\alpha}, \\vec{\\beta}, \\dot{u}_1[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_1}}, \\vec{\\beta}|_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{\\alpha}|_{\\rho_{e_t}}, \\vec{\\beta}|_{\\sigma_{e_t}}) \\right) \\\\ &amp; + I_{H^{\\mathrm{arity}(v)+m_v}} \\big( (\\vec{\\alpha}, \\vec{\\beta}), \\vec{0} \\big) \\cdot \\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{X}) \\cdot R_v(\\vec{X}, \\vec{\\gamma}) \\big) \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">Note that the individual degree of  <span class="math">\\dot{v}[x](\\vec{X})</span>  is exactly  <span class="math">|H| + \\inf_G(v)</span> . The individual degree of the summand in the last line (in  <span class="math">\\vec{\\alpha}, \\vec{\\beta}, \\vec{\\gamma}</span> ) is at most  <span class="math">\\max\\{2\\lambda, |H| + \\inf_G(v) + \\delta_{\\mathsf{in}} \\cdot \\max\\{\\delta_{\\mathsf{lf}}, |H| + \\max_{1 \\leq i \\leq \\mathsf{out}_G(v)} \\mathsf{in}_G(u_i)\\}\\} \\leq 2\\lambda</span> .</p>

    <p class="text-gray-300">Observe first that  <span class="math">R_v</span>  is a perfectly-hiding commitment to the random polynomial  <span class="math">S_v(\\vec{X}) := \\sum_{\\vec{\\gamma} \\in G^k} R_v(\\vec{X}, \\vec{\\gamma})</span> , and so  <span class="math">S_v(\\vec{x})</span>  itself is uniformly random even conditioned on strictly fewer than  <span class="math">\\lambda^k</span>  queries to  <span class="math">R_v</span> . Then since  <span class="math">\\mathbb{Z}_{H^{\\mathsf{arity}(v)}}(\\vec{X})</span> is non-zero in  <span class="math">(\\mathbb{F} - H)^{\\mathsf{arity}(v)}</span>  and the individual degree of  <span class="math">S_v</span>  is  <span class="math">\\mathsf{in}_G(v)</span> , the required independence property holds. If we ensure that the verifier chooses its challenges in the sumcheck protocol from  <span class="math">\\mathbb{F}-H</span>  rather than all of  <span class="math">\\mathbb{F}</span>  (i.e. the prover aborts otherwise), then the values sent to the verifier in the SPCE protocol will indeed be uniformly random.</p>

    <p class="text-gray-300">We resolve the second issue by replacing the sumcheck subprotocol with the zero knowledge IPCP for sumcheck defined in Section 6. This requires sending O(|V(G)|) proofs, which we can concatenate together with the  <span class="math">R_v</span>  into a single oracle. Note that here we will require the full strength of the zero knowledge guarantee which we obtain in Theorem 6.4 (as opposed to the weaker guarantee of [BCFGRS16]), because the simulator is not able to make an arbitrary polynomial number of queries to  <span class="math">\\dot{v}[x]</span>  for any internal vertex v. Instead the number of queries must be bounded by  <span class="math">\\inf_G(v)</span>  for each v, so that these queries can be simulated by choosing uniformly random field elements; the zero knowledge guarantee of Theorem 6.4 allows us to do exactly that.</p>

    <p class="text-gray-300">We are now ready to put everything together.</p>

    <p class="text-gray-300"><em>Proof.</em> Fix  <span class="math">k := \\lceil \\log b / \\log \\lambda \\rceil</span> . The prover and verifier receive as input a SPCE instance  <span class="math">(\\mathcal{C}, y, x)</span> . We first describe the oracle message that is first sent to the verifier, and then describe the subsequent interaction between the prover and verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Oracle. The prover sends to the verifier a proof string  <span class="math">\\pi</span>  that contains, for each internal vertex v of G:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the evaluation table of the polynomial  <span class="math">R_v \\in \\mathbb{F}[X_{1,\\ldots,\\mathsf{arity}(v)}^{\\leq \\mathsf{in}_G(v)},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>  drawn independently and uniformly at random; a proof string  <span class="math">\\pi_v</span>  which is the oracle sent in a  <span class="math">\\lambda^k</span> -strong zero knowledge sumcheck protocol on input  <span class="math">(\\mathbb{F},\\mathsf{arity}(v)+1)</span></li>
      <li><span class="math">m_v + k, \\lambda, H, \\cdot</span> ). <sup>3</sup></li>
    </ul></li>
      <li>&bull; Interaction. The prover and verifier associate, for each vertex v of G, a set of labels  <span class="math">L_v</span> ; for the root, this set contains only the pair  <span class="math">(\\bot, y)</span> , while for all other vertices this set is initially empty and will be populated during the protocol. The prover and verifier then interact as follows.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of G taken in (any) topological order, letting  <span class="math">t := \\mathsf{out}_G(v)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) For every  <span class="math">(\\vec{\\gamma}_i, a_i)</span>  in  <span class="math">L_v</span> , the verifier samples a random  <span class="math">\\alpha_i \\in \\mathbb{F}</span>  and sends it to the prover.</li>
      <li>(b) The prover and verifier invoke a  <span class="math">\\lambda^k</span> -strong perfect zero knowledge Interactive Probabilistically Checkable Proof system for sumcheck (see Section 6) on the claim</li>
    </ul></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\text{\`\`} \\quad \\sum_{j=1}^{|L_v|} \\alpha_j \\dot{v}[\\mathbf{x}](\\vec{\\gamma}_j) = \\sum_{j=1}^{|L_v|} \\alpha_j a_j \\quad \\text{\`\`}</span>$</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{3}&lt;/sup&gt;</span> Recall that we do not need to specify a until later on in the protocol, and it will depend on the verifier's random choices.</p>

    <p class="text-gray-300">using  <span class="math">\\pi_v</span>  as the oracle, and with  <span class="math">I := \\mathbb{F} \\setminus H</span> . By the end of this subprotocol, the verifier has chosen  <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\operatorname{arity}(v)}</span> ,  <span class="math">\\vec{c}_2 \\in \\mathbb{F}^m</span> , and  <span class="math">\\vec{c}_3 \\in \\mathbb{F}^k</span>  uniformly at random, and has derived from the prover's messages a value  <span class="math">b \\in \\mathbb{F}</span>  that allegedly satisfies the following equality:</p>

    <p class="text-gray-300"><span class="math">$b = \\sum_{j=1}^{|L_v|} \\alpha_j \\Big( I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\mathsf{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v \\Big( \\vec{c}_1, \\vec{c}_2, \\dot{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}}, \\vec{c}_2|_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}}, \\vec{c}_2|_{\\sigma_{e_t}}) \\Big) \\quad (11)</span>$</p>

    <p class="text-gray-300"><span class="math">$+ I_{H^{\\mathsf{arity}(v)+m_v}} \\Big( (\\vec{c}_1, \\vec{c}_2), \\vec{0} \\Big) \\cdot \\mathbb{Z}_{H^{\\mathsf{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\Big) \\quad ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  are the outgoing edges of v (with multiplicity).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(c) The prover sends  <span class="math">\\vec{h}_v := (h_1, \\dots, h_t)</span>  where  <span class="math">h_1 := \\dot{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}}, \\vec{c}_2|_{\\sigma_{e_1}}), \\dots, h_t := \\dot{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}}, \\vec{c}_2|_{\\sigma_{e_t}}).</span>  For every  <span class="math">j = 1, \\dots, t</span> , the verifier adds the label  <span class="math">((\\vec{c}_1|_{\\rho_{e_i}}, \\vec{c}_2|_{\\sigma_{e_j}}), h_j)</span>  to  <span class="math">L_{u_j}</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of G, the verifier checks that</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$b = \\sum_{j=1}^{|L_v|} \\alpha_j \\Big( I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v \\Big( \\vec{c}_1, \\vec{c}_2, \\vec{h}_v \\Big) + I_{H^{\\mathrm{arity}(v)} + m_v} \\big( (\\vec{c}_1, \\vec{c}_2), \\vec{0} \\big) \\cdot \\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\Big) \\ . \\tag{12}</span>$</p>

    <p class="text-gray-300">For this, the prover sends  <span class="math">\\left(R_v(\\vec{\\gamma}_j,\\vec{c}_3)\\right)_{j=1}^{|L_v|}</span> , which the verifier uses to compute the above expression. The verifier checks that these values are correct using a standard interpolation trick and a single query to  <span class="math">R_v</span> . To make this query, the verifier (i) tests that  <span class="math">R_v</span>  is close to (the evaluation of) a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(v)}^{\\leq \\mathsf{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> ; (ii) uses self-correction to make the required query.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every leaf vertex v of G, and for every  <span class="math">(\\vec{\\gamma}, a) \\in L_v</span> , the verifier checks that  <span class="math">\\dot{v}[x](\\vec{\\gamma}) = a</span> , i.e., that  <span class="math">x_v(\\vec{\\gamma}) = a</span> .</li>
    </ol>

    <p class="text-gray-300"><strong>Efficiency.</strong> The protocol runs a  <span class="math">\\lambda^k</span> -strong zero knowledge sumcheck protocol at most |V| times on polynomials of at most  <span class="math">\\operatorname{arity}(G) + k</span>  variables. Inspection of the protocol shows that we can execute Step 1 in parallel for all vertices at the same depth, so the number of rounds is at most  <span class="math">\\operatorname{depth}(G)(\\operatorname{arity}(G) + 2k + 2)</span> . The running time of the verifier is clearly polynomial in  <span class="math">|\\mathcal{C}|</span> . The number of queries to the  <span class="math">R_v</span>  is at most  <span class="math">|V(G)| \\cdot \\operatorname{poly}(\\log |\\mathbb{F}| + k + \\lambda)</span> , and the number of queries to the  <span class="math">\\pi_v</span>  is at most  <span class="math">|V(G)| \\cdot \\operatorname{poly}(\\log |\\mathbb{F}| + \\operatorname{arity}(G) + k + \\lambda)</span> .</p>

    <p class="text-gray-300"><strong>Completeness.</strong> Perfect completeness is clear from the protocol description and the perfect completeness of the zero-knowledge sumcheck protocol.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Let  <span class="math">v_1, v_2, \\ldots</span>  be any topological order of the internal vertices of G, and define let  <span class="math">V_{\\geq i}</span>  be the union of  <span class="math">\\{v_j: j \\geq i\\}</span>  and the leaf vertices of G. First we argue that if before iteration i of Step 1 there exists  <span class="math">v \\in V_{\\geq i}</span>  such that  <span class="math">L_v</span>  contains  <span class="math">(\\vec{\\gamma}, a)</span>  with  <span class="math">\\dot{v}[\\mathbf{x}](\\vec{\\gamma}) \\neq a</span> , then after this iteration with high probability either (a) the verifier rejects, or (b) there exists  <span class="math">w \\in V_{\\geq i+1}</span> , such that there is  <span class="math">(\\vec{\\gamma}&#x27;, b) \\in L_w</span>  with  <span class="math">\\dot{w}[\\mathbf{x}](\\vec{\\gamma}&#x27;) \\neq b</span> . If  <span class="math">v \\in V_{\\geq i+1}</span>  then there is nothing to do, so we may assume that  <span class="math">v = v_i</span> . The probability that  <span class="math">\\sum_{j=1}^{|L_{v_i}|} \\alpha_j \\dot{v}_i[\\mathbf{x}](\\vec{\\gamma}_j) = \\sum_{j=1}^{|L_{v_i}|} \\alpha_j a_j</span>  is  <span class="math">1/|\\mathbb{F}|</span> . So with probability  <span class="math">1 - 1/|\\mathbb{F}|</span>  we run the zero knowledge sumcheck protocol on a false claim about a polynomial with (arity <span class="math">(v) + m_v + k</span> ) variables and individual degree at most  <span class="math">2\\lambda</span> , which means that with probability at least  <span class="math">1 - O((\\operatorname{arity}(v) + m_v + k) \\cdot \\lambda/(|\\mathbb{F}| - |H|))</span>  either the verifier rejects or outputs the false claim</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} b &amp;= \\sum_{j=1}^{|L_v|} \\left( \\alpha_j I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v \\big( \\vec{c}_1, \\vec{c}_2, \\dot{u}_1[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_1}}, \\vec{c}_2|_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{c}_1|_{\\rho_{e_t}}, \\vec{c}_2|_{\\sigma_{e_t}}) \\right) \\\\ &amp;+ I_{H^{\\mathrm{arity}(v)+m_v}} \\big( (\\vec{c}_1, \\vec{c}_2), \\vec{0} \\big) \\cdot \\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\big) \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">The verifier receives values  <span class="math">(r_j)_{j=1}^{|L_v|}</span> , which it substitutes for  <span class="math">R_v(\\vec{\\gamma}_j, \\vec{c}_3)</span>  in Equation 12. If this expression does not evaluate to b, then the verifier rejects. If  <span class="math">R_v</span>  is far from any polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathrm{arity}(v)}^{\\leq \\mathrm{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2}]</span> , then the verifier rejects with high probability. If there exists some j such that  <span class="math">r_j \\neq R_v(\\vec{\\gamma}_j, \\vec{c}_3)</span> , then by the soundness of the polynomial interpolation test, the verifier will reject with probability at least  <span class="math">1 - O((\\mathrm{arity}(v) + k) \\cdot \\lambda/|\\mathbb{F}|)</span> . Otherwise, it must be</p>

    <p class="text-gray-300">the case that  <span class="math">\\dot{u}_i[x](\\vec{c}) \\neq h_i</span>  where  <span class="math">u_i</span>  is one of the  <span class="math">\\mathsf{out}_G(v_i)</span>  children of  <span class="math">v_i</span> . Since  <span class="math">u_i \\in V_{&gt;i+1}</span> , with high probability after this iteration either the verifier has already rejected or there is  <span class="math">w \\in V_{&gt;i+1}</span>  and  <span class="math">(\\vec{\\gamma}&#x27;, a&#x27;) \\in L_w</span>  with  <span class="math">\\dot{w}[x](\\vec{\\gamma}&#x27;) \\neq a&#x27;</span> .</p>

    <p class="text-gray-300">The above implies soundness in a straightforward way: if  <span class="math">\\mathbb{C}[x] \\neq y</span>  then the condition is satisfied before the first iteration, and in each iteration with high probability either the condition is maintained or the verifier rejects. Thus with high probability either the verifier rejects or the invariant holds before the last iteration; after the last iteration, the verifier will reject with high probability because only leaf vertices are left (and claims about them are checked directly). More precisely, by a union bound over all the internal vertices, and setting the parameters of the proximity test appropriately, if  <span class="math">C[x] \\neq y</span>  then the verfier accepts with probability  <span class="math">O(|V(G)|(\\mathsf{arity}(G) + k) \\cdot \\lambda/(|\\mathbb{F}| - |H|))</span> .</p>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> We prove that the protocol has perfect zero knowledge by exhibiting a polynomial-time simulator that perfectly samples the view of any malicious verifier. We will assume that the simulator maintains the label sets  <span class="math">L_v</span> in the same way as the honest verifier, but for clarity we will not state this in its description.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. For every internal vertex v of G, sample  <span class="math">R_{\\text{sim}}^v \\in \\mathbb{F}[X_{1,\\dots,\\text{arity}(v)}^{\\leq \\ln_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>  uniformly at random. Use  <span class="math">R_{\\text{sim}}^v</span>  to answer queries</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of G, run the  <span class="math">\\lambda^k</span> -strong ZK sumcheck simulator on input ( <span class="math">\\mathbb{F}</span> , arity(v) +  <span class="math">m_v</span>  + k,  <span class="math">\\lambda</span> , H, &middot;), and use it to answer queries to  <span class="math">\\pi_v</span>  throughout. Recall that the behavior of each simulator does not depend on the claim being proven until after the first simulated message, so we can choose these later.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every internal vertex v of G taken in (any) topological order, letting  <span class="math">t := \\mathsf{out}_G(v)</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Receive  <span class="math">\\tilde{\\alpha}_1, \\ldots, \\tilde{\\alpha}_{|L_v|}</span>  from the verifier.</li>
      <li>(b) Using the subsimulator for v, simulate the strong ZK sumcheck protocol on the claim</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\text{\`\`} \\quad \\sum_{j=1}^{|L_v|} \\tilde{\\alpha}_j \\dot{v}[\\mathbf{x}](\\vec{\\gamma}_j) = \\sum_{j=1}^{|L_v|} \\tilde{\\alpha}_j a_j \\quad \\text{&#x27;&#x27;}.</span>$</p>

    <p class="text-gray-300">The subsimulator will query the oracle F at a single location  <span class="math">\\vec{c} = (\\vec{c}_1, \\vec{c}_2, \\vec{c}_3)</span>  with  <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\operatorname{arity}(v)}, \\vec{c}_2 \\in \\mathbb{F}^{m_v}</span> , and  <span class="math">\\vec{c}_3 \\in \\mathbb{F}^k</span> . Reply with the value</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\sum_{j=1}^{|L_v|} \\alpha_j \\Big( I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\mathsf{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, h^1_{\\mathrm{sim}}, \\dots, h^t_{\\mathrm{sim}}) \\\\ + I_{H^{\\mathsf{arity}(v)+m_v}}((\\vec{c}_1, \\vec{c}_2), \\vec{0}) \\cdot \\mathbb{Z}_{H^{\\mathsf{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\Big) \\ , \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">h_{\\text{sim}}^1, \\dots, h_{\\text{sim}}^t \\in \\mathbb{F}</span>  are chosen as follows. Let  <span class="math">e_1 = (v, u_1), \\dots, e_t = (v, u_t)</span>  be the outgoing edges of v (with multiplicity). For every  <span class="math">k \\in \\{1, \\ldots, t\\}</span> , letting  <span class="math">\\vec{c}_k := (\\vec{c}_1|_{\\rho_{e_k}}, \\vec{c}_2|_{\\sigma_{e_k}})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. if  <span class="math">u_k</span>  is a leaf vertex, then  <span class="math">h_{\\text{sim}}^k := \\mathbf{x}_{u_k}(\\vec{c}_k)</span> .</li>
      <li>ii. if  <span class="math">u_k</span>  is an internal vertex and  <span class="math">(\\vec{c}_k, h) \\in L_{u_k}</span>  for some  <span class="math">h \\in \\mathbb{F}</span> ,  <span class="math">h^k_{\\text{sim}} := h</span> . \\niii. if  <span class="math">u_k</span>  is an internal vertex and  <span class="math">(\\vec{c}_k, h) \\notin L_{u_k}</span>  for all  <span class="math">h \\in \\mathbb{F}</span> , sample  <span class="math">h^k_{\\text{sim}}</span>  at random and add  <span class="math">(\\vec{c}_k, h^k_{\\text{sim}})</span>  to  <span class="math">L_{u_k}</span> .</li>
      <li>(c) Send  <span class="math">h_{\\text{sim}}^1, \\ldots, h_{\\text{sim}}^t</span>  to the verifier.</li>
    </ul>

    <p class="text-gray-300">The view of the verifier in a real execution is composed of the messages from the prover during each sumcheck protocol, the values  <span class="math">\\dot{v}[\\mathbf{x}](\\vec{\\gamma})</span>  for every internal vertex v in V and  <span class="math">(\\vec{\\gamma}, a) \\in L_v</span> , and the verifier's queries to the oracles  <span class="math">R_v</span>  and  <span class="math">\\pi_v</span>  for every internal vertex v in V.</p>

    <p class="text-gray-300">Any b-query malicious verifier  <span class="math">\\tilde{V}</span>  may query any  <span class="math">R_v</span>  at strictly fewer than b points. By Corollary 5.3,  <span class="math">S_v(\\vec{x}) :=</span>  <span class="math">\\sum_{\\vec{y} \\in G^k} R_v(\\vec{x}, \\vec{y})</span>  is uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(v)}^{\\leq \\mathsf{in}_G(v)}]</span> , even conditioned on the values of the fewer than  <span class="math">\\lambda^k \\leq b</span> queries made by  <span class="math">\\tilde{V}</span>  to  <span class="math">R_v</span> . Therefore any string  <span class="math">(\\dot{v}[x](\\vec{\\gamma}_1), \\dots, \\dot{v}[x](\\vec{\\gamma}_\\ell))</span>  for  <span class="math">\\ell \\leq \\inf_G(v)</span>  and distinct  <span class="math">\\vec{\\gamma}_1, \\dots, \\vec{\\gamma}_\\ell \\in</span>  <span class="math">(\\mathbb{F}-H)^{\\mathsf{arity}(v)}</span>  is identically distributed to a uniformly random string in  <span class="math">\\mathbb{F}^\\ell</span> . Observe that for every internal vertex v in  <span class="math">V, |L_v| \\leq \\inf_G(v)</span> , and the prover sends  <span class="math">\\dot{v}[\\mathbf{x}](\\vec{\\gamma})</span>  for each  <span class="math">(\\vec{\\gamma}, a) \\in L_v</span> , so all of these values are uniformly random in  <span class="math">\\mathbb{F}</span> , and thus identically distributed to the values  <span class="math">h_{\\mathrm{sim}}^i</span>  the simulator sends.</p>

    <p class="text-gray-300">Clearly  <span class="math">R_{\\text{sim}}^v</span>  and  <span class="math">R_v</span>  are identically distributed for every internal vertex v in V. The perfect zero knowledge property of the strong ZK sumcheck simulator guarantees that the simulation of  <span class="math">\\pi_v</span>  and the messages sent during the sumcheck protocol is perfect given a single query to the oracle F. We simulate this query by substituting values  <span class="math">h^i_{\\rm sim}</span>  in place of  <span class="math">\\dot{u}_i[\\mathbf{x}](\\vec{c}_i)</span> , which we argue above are identically distributed.</p>

    <p class="text-gray-300">It follows from the description and the efficiency of the subsimulator that the simulator runs in time  <span class="math">\\operatorname{poly}(|\\mathcal{C}|) \\cdot |\\mathbf{x}| + |V(G)|(\\operatorname{arity}(G) + k)(\\lambda \\mathsf{q}_{\\tilde{V}}|H| + \\lambda^3 \\mathsf{q}_{\\tilde{V}}^3) \\cdot \\operatorname{poly}(\\log |\\mathbb{F}|)</span> , provided we use the algorithm of Corollary 4.1 for Step 1.  <span class="math">\\square</span></p>

    <p class="text-gray-300">To make the sum-product circuit satisfaction protocol zero knowledge, in addition to the above considerations we must also avoid leaking information about the witness x. This we achieve using similar techniques to those seen previously: for each leaf vertex w, rather than directly sending the auxiliary input polynomial  <span class="math">z_w(\\vec{X})</span> , the prover sends a polynomial  <span class="math">z_w&#x27;(\\vec{X}, \\vec{Y})</span>  chosen randomly from the set of low-degree polynomials summing over  <span class="math">H^k</span>  to  <span class="math">z_w(\\vec{X})</span>  for some appropriately-chosen k. This acts as a perfectly hiding commitment to the witness.</p>

    <p class="text-gray-300">We show that we can efficiently construct a sum-product circuit  <span class="math">\\mathcal{C}&#x27;</span>  which outputs y on input  <span class="math">(x, z&#x27;_w)</span>  if and only if the original sum-product circuit outputs y on input  <span class="math">(x, z_w)</span> . We then obtain our zero-knowledge protocol by running the protocol of Theorem 9.1 on  <span class="math">\\mathcal{C}&#x27;</span> , implementing the queries to the input as queries to the proof (with self-correction).</p>

    <p class="text-gray-300"><strong>Theorem 9.2</strong> (PZK IPCP for  <span class="math">\\mathcal{R}_{SPCS}</span> ). For every query bound function b(n), the relation  <span class="math">\\mathcal{R}_{SPCS}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail, letting  <span class="math">\\alpha := \\log b/\\log |H|</span> :</p>

    <pre><code class="language-text">\\mathscr{R}_{\\mathrm{SPCS}} \\in \\mathbf{PZK\\text{-}IPCP} \\begin{bmatrix} soundness \\ error: &amp; O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{lf}} \\cdot \\mathrm{in}(G) \\cdot (\\mathrm{arity}(G) + \\alpha) \\cdot |V(G)|/|\\mathbb{F}|) \\\\ vound \\ complexity: &amp; O(\\mathrm{depth}(G) \\cdot (\\mathrm{arity}(G) + \\alpha)) \\\\ proof \\ length: &amp; O(|V(G)| \\cdot |\\mathbb{F}|^{\\mathrm{arity}(G) + 2\\alpha}) \\\\ query \\ complexity: &amp; |V(G)| \\cdot \\mathrm{poly}(\\log |\\mathbb{F}|, \\mathrm{arity}(G), \\alpha, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{lf}}, \\mathrm{in}(G)) \\\\ prover \\ time: &amp; \\mathrm{poly}(|\\mathcal{C}|, |\\mathbb{x}|, |\\mathbb{z}|, |\\mathbb{F}|^{\\mathrm{arity}(G) + \\alpha}) \\\\ verifier \\ time: &amp; \\mathrm{poly}(|\\mathcal{C}|, |\\mathbb{x}|) \\\\ verifier \\ space: &amp; O((\\mathrm{arity}(G) + \\alpha) \\cdot \\mathrm{width}(G) \\cdot \\mathrm{in}(G) \\cdot \\log |\\mathbb{F}| + \\log |\\mathcal{C}| + \\mathrm{space}(\\mathbb{x})) \\\\ simulator \\ overhead: &amp; \\mathrm{poly}(|\\mathcal{C}|, \\alpha) \\cdot (|\\mathbb{x}| + \\mathsf{q}_{\\tilde{V}}^3). \\end{bmatrix}
</code></pre>

    <p class="text-gray-300"><em>Proof.</em> Fix  <span class="math">k := \\log b/\\log |H|</span> . Let  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, G, C)</span>  be a sum-product circuit and let  <span class="math">G = (V, E, \\rho, \\sigma)</span>  be its ari-graph. Let  <span class="math">\\mathsf{x}</span>  be a partial mapping of the leaf vertices of G to arithmetic circuits. We construct the new sum-product circuit  <span class="math">\\mathcal{C}&#x27; = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\max\\{\\delta_{\\mathsf{lf}}, 2|H|\\}, G&#x27;, C&#x27;)</span>  where:</p>

    <p class="text-gray-300">&bull; the new ari-graph  <span class="math">G&#x27; = (V&#x27;, E&#x27;, \\rho&#x27;, \\sigma&#x27;)</span>  extends G by adding a new vertex  <span class="math">v_w</span>  and a new edge  <span class="math">(w, v_w)</span>  for each leaf vertex w not in the domain of x as follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} V&#x27; &amp;:= V \\cup \\{v_w : w \\in V \\text{ is a leaf}\\} \\ , \\\\ E&#x27; &amp;:= E \\cup \\{(w, v_w) : w \\in V \\text{ is a leaf}\\} \\ , \\\\ \\rho&#x27;_e &amp;:= \\begin{cases} \\rho_e &amp; \\text{if } e \\in E \\\\ \\{1, \\dots, \\operatorname{arity}(w)\\} &amp; \\text{if } e = (w, v_w) \\text{ and } w \\text{ is a leaf in } V \\end{cases} \\ , \\\\ \\sigma&#x27;_e &amp;:= \\begin{cases} \\sigma_e &amp; \\text{if } e \\in E \\\\ \\{1, \\dots, k\\} &amp; \\text{if } e = (w, v_w) \\text{ and } w \\text{ is a leaf in } V \\end{cases} . \\end{split}</span>$</p>

    <p class="text-gray-300">Note that the vertex and edge sets at most double in size,  <span class="math">\\operatorname{depth}(G&#x27;) = \\operatorname{depth}(G) + 1</span> ,  <span class="math">\\operatorname{arity}(v_w) = \\operatorname{arity}(w) + k</span>  and  <span class="math">m_{v_w} = k</span> .</p>

    <p class="text-gray-300">&bull; C' is such that  <span class="math">C&#x27;_v := C_v</span>  for every internal vertex v in V, and  <span class="math">C&#x27;_v</span>  is the univariate polynomial X for every leaf vertex v in V.</p>

    <p class="text-gray-300">Before describing the protocol, we prove a claim that relates the two sum-product circuits  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{C}&#x27;</span> .</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{l} \\textbf{Claim. For every } \\textbf{y} \\in \\mathbb{F}, \\ (\\mathcal{C}, \\textbf{y}, \\textbf{x}) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}}) \\ \\textit{if and only if} \\ (\\mathcal{C}&#x27;, \\textbf{y}, (\\textbf{x}, \\textbf{z}&#x27;)) \\in \\mathcal{L}_{\\mathrm{SPCE}} \\ \\textit{for some input } \\textbf{z}&#x27; \\ \\textit{for } \\mathcal{C}&#x27; \\ \\textit{such that} \\ \\textbf{z}&#x27;_{v_w} \\in \\mathbb{F}[X_{1, \\dots, \\mathsf{arity}(w)}^{\\leq \\delta_{\\mathsf{lf}}}, Y_{1, \\dots, k}^{\\leq 2|H|}] \\ \\textit{for every leaf } w \\ \\textit{in } V. \\end{array}</span></p>

    <p class="text-gray-300"><em>Proof of claim.</em> First suppose that  <span class="math">(\\mathcal{C}, y, x) \\in \\mathcal{L}(\\mathcal{R}_{SPCS})</span> , so there exists an auxiliary input z for  <span class="math">\\mathcal{C}</span>  such that  <span class="math">\\mathcal{C}[x, z] = y</span> . Define  <span class="math">\\mathbf{z}&#x27;</span>  to be the auxiliary input for  <span class="math">\\mathcal{C}&#x27;</span>  such that  <span class="math">\\mathbf{z}&#x27;_{v_m}(\\vec{X}, \\vec{Y}) := I_{H^k}(\\vec{Y}, \\vec{0}) \\cdot \\mathbf{x}_w(\\vec{X})</span>  for every leaf w in V in the domain of  <span class="math">\\mathbf{z}</span> . Note that for each such leaf w in V,  <span class="math">\\mathbf{z}&#x27;_{v_w}</span>  respects the desired degree bounds and, moreover,  <span class="math">w[\\mathbf{x},\\mathbf{z}&#x27;](\\vec{X}) = 0</span>  <span class="math">\\sum_{\\vec{\\beta} \\in H^k} I_{H^k}(\\vec{\\beta}, \\vec{0}) \\cdot \\mathbf{z}_w(\\vec{X}) = \\mathbf{z}_w(\\vec{X}) = w[\\mathbf{x}, \\mathbf{z}](\\vec{X}).</span>  By construction of G', we deduce that  <span class="math">\\mathcal{C}&#x27;[\\mathbf{x}, \\mathbf{z}&#x27;] = \\mathbf{y}</span> , so that  <span class="math">(\\mathcal{C}&#x27;, y, (x, z&#x27;)) \\in \\mathscr{L}_{SPCE}.</span></p>

    <p class="text-gray-300">Next suppose that  <span class="math">(\\mathcal{C}&#x27;, \\mathbf{y}, (\\mathbf{x}, \\mathbf{z}&#x27;)) \\in \\mathscr{L}_{\\mathrm{SPCE}}</span>  for some input  <span class="math">\\mathbf{z}&#x27;</span>  for  <span class="math">\\mathcal{C}&#x27;</span>  such that  <span class="math">\\mathbf{z}&#x27;_{v_w} \\in \\mathbb{F}[X_{1,\\ldots,\\mathsf{arity}(w)}^{\\leq \\delta_{\\mathrm{lf}}}, Y_{1,\\ldots,k}^{\\leq 2|H|}]</span>  for every leaf w in V not in the domain of  <span class="math">\\mathbf{z}</span> . Define  <span class="math">\\mathbf{z}</span>  to be the input for  <span class="math">\\mathcal{C}</span>  such that  <span class="math">\\mathbf{z}_w(\\vec{X}) := \\sum_{\\beta \\in H^k} \\mathbf{z}&#x27;_{v_w}(\\vec{X}, \\vec{\\beta})</span>  for each leaf w in V. Note that for each leaf w in V not in the domain of x,  <span class="math">z_w</span>  has individual degree at most  <span class="math">\\delta_{lf}</span>  and, moreover,  <span class="math">w[\\mathbf{x}, \\mathbf{z}](\\vec{X}) = \\sum_{\\beta \\in H^k} \\mathbf{z}&#x27;_{v_w}(\\vec{X}, \\vec{\\beta}) = w[\\mathbf{x}, \\mathbf{z}&#x27;](\\vec{X})</span> . By construction of G', this implies that  <span class="math">C[\\mathbf{x}, \\mathbf{z}&#x27;] = \\mathbf{y}</span> , so that  <span class="math">(\\mathcal{C}, y, x) \\in \\mathcal{L}(\\mathcal{R}_{SPCS})</span> .</p>

    <p class="text-gray-300">The protocol proceeds as follows. The prover and verifier receive a SPCS instance  <span class="math">(\\mathcal{C}, \\forall, x)</span>  as input, and the prover additionally receives an auxiliary input z for C that is a valid witness for (C, y, x). Both use C to construct the new sum-product circuit  <span class="math">\\mathcal{C}&#x27;</span>  from the above claim; in addition, the prover uses z to sample an input z' for  <span class="math">\\mathcal{C}&#x27;</span>  by choosing. for each leaf w in the domain of  <span class="math">\\mathbf{z}</span> , a polynomial  <span class="math">\\mathbf{z}&#x27;_{v_w} \\in \\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(w)}^{\\leq \\hat{\\delta}_{\\mathsf{lf}}},Y_{1,\\dots,k}^{\\leq 2|H|}]</span>  uniformly at random conditioned on  <span class="math">\\sum_{\\vec{\\beta} \\in H^k} \\mathbf{z}&#x27;_{v_w}(\\vec{\\alpha}, \\vec{\\beta}) = \\mathbf{z}_w(\\vec{\\alpha})</span>  for all  <span class="math">\\vec{\\alpha} \\in \\mathbb{F}^{\\mathsf{arity}(w)}</span> . The prover and verifier then engage in the zero knowledge Interactive Probabilistically Checkable Proof for the language  <span class="math">\\mathscr{L}_{\\mathrm{SPCE}}</span>  (see Theorem 9.1) on input  <span class="math">(\\mathcal{C}&#x27;, y, (x, z&#x27;))</span> , with the prover appending the auxiliary input  <span class="math">\\mathbf{z}&#x27;</span>  to the proof oracle. At the end of the protocol the verifier needs to make a single query  <span class="math">\\vec{\\gamma}_{v_w}</span>  to  <span class="math">\\mathbf{z}&#x27;_{v_w}</span>  for each leaf vertex w in the domain of  <span class="math">\\mathbf{x}</span> , so the verifier tests that  <span class="math">\\mathbf{z}&#x27;_{v_w}</span>  is close to the evaluation of a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(w)}^{\\leq \\delta_{\\mathsf{lf}}},Y_{1,\\dots,k}^{\\leq 2|H|}]</span>  and then uses self-correction to read  <span class="math">\\mathbf{z}&#x27;_{v_w}(\\vec{\\gamma}_{v_w})</span> . Completeness is straightforward to argue; we only discuss soundness and then zero knowledge.</p>

    <p class="text-gray-300">Suppose that  <span class="math">(\\mathcal{C}, y, x) \\notin \\mathscr{L}(\\mathscr{R}_{\\mathrm{SPCS}})</span> , and let  <span class="math">\\tilde{z}</span>  be the input for  <span class="math">\\mathcal{C}&#x27;</span>  that the prover has appended to the proof oracle. If there exists a leaf vertex w in the domain of  <span class="math">\\tilde{\\mathbf{z}}</span>  such that  <span class="math">\\tilde{\\mathbf{z}}_{v_w}</span>  is more than  <span class="math">\\delta</span> -far from a polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(w)}^{\\leq \\delta_{\\mathsf{lf}}},Y_{1,\\dots,k}^{\\leq 2|H|}]</span> , then the verifier accepts with probability at most  <span class="math">\\epsilon</span> . So suppose that this is not the case, and let  <span class="math">\\tilde{\\mathbf{z}}&#x27;_{v_w}</span>  be the unique polynomial in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathsf{arity}(w)}^{\\leq \\delta_{\\mathsf{lf}}},Y_{1,\\dots,k}^{\\leq 2|H|}]</span>  that is  <span class="math">\\delta</span> -close to  <span class="math">\\tilde{\\mathbf{z}}_{v_w}</span> . Using self-correction, the verifier obtains  <span class="math">\\tilde{\\mathbf{z}}&#x27;_{v_w}(\\vec{\\gamma}_{v_w})</span>  with probability at least  <span class="math">1-\\epsilon</span> . By a union bound, the probability that the verifier learns all the values correctly is at least  <span class="math">1 - \\epsilon |V(G)|</span> . By the claim,  <span class="math">(\\mathcal{C}, y, x) \\notin \\mathcal{L}(\\mathcal{R}_{SPCS})</span>  implies that  <span class="math">(\\mathcal{C}&#x27;, y, (x, \\tilde{z}&#x27;)) \\notin \\mathcal{L}_{SPCE}</span> , so if all of the verifier's queries are answered according to  <span class="math">\\tilde{\\mathbf{z}}&#x27;</span> , the soundness of the protocol for  <span class="math">\\mathscr{L}_{\\mathrm{SPCE}}</span>  implies that the verifier accepts with probability at most  <span class="math">O(\\delta_{\\mathsf{in}}\\delta_{\\mathsf{lf}}\\cdot\\mathsf{in}(G)\\cdot(\\mathsf{arity}(G)+\\log b)\\cdot|V(G)|/|\\mathbb{F}|)</span> . Setting  <span class="math">\\epsilon</span>  and  <span class="math">\\delta</span>  appropriately yields the claimed soundness error.</p>

    <p class="text-gray-300">Perfect zero knowledge follows from Corollary 5.3: if a verifier makes fewer than  <span class="math">|H|^k</span>  queries to the proof, then each  <span class="math">\\mathbf{z}&#x27;_n</span>  is indistinguishable from a random polynomial. The simulator for this protocol simply runs the simulator from Theorem 9.1 on (C', y, (x, z')), and uses the algorithm of Corollary 4.1 to simulate its queries to each  <span class="math">z&#x27;_v</span> .</p>

    <p class="text-gray-300">We present an efficient reduction from problems decidable in polynomial space (<strong>PSPACE</strong>) to sum-product circuit evaluation problems ( <span class="math">\\mathcal{L}_{SPCE}</span> , Definition 8.9). The reduction yields perfect zero knowledge IPCPs for <strong>PSPACE</strong>, via our construction of perfect zero knowledge IPCPs for  <span class="math">\\mathcal{L}_{SPCE}</span>  (Theorem 9.1), resolving an open problem of [BCFGRS16].</p>

    <p class="text-gray-300">Our starting point is the language of true quantified boolean formulas (TQBFs), which is PSPACE-complete:</p>

    <p class="text-gray-300"><strong>Definition 10.1.</strong> Let  <span class="math">\\mathcal{L}_{TQBF}</span>  be the language of quantified boolean formulas  <span class="math">\\Phi = Q_1 x_1 \\cdots Q_n x_n \\phi(x_1, \\dots, x_n)</span> , with  <span class="math">Q_i \\in \\{\\forall, \\exists\\}</span> , that evaluate to true. We denote by n the number of variables and by c the number of clauses in  <span class="math">\\phi</span> .</p>

    <p class="text-gray-300">The theorem below is a 'zero knowledge analogue' of Shamir's protocol for  <span class="math">\\mathcal{L}_{TQBF}</span>  [Sha92], sharing all its key features except that it is an Interactive PCP rather than an Interactive Proof. We prove that  <span class="math">\\mathcal{L}_{TQBF}</span>  has a public-coin Interactive PCP that is perfect zero knowledge, with exponential proof length and polynomial query complexity; also, like Shamir's protocol, the number of rounds is  <span class="math">O(n^2)</span> , the prover runs in space poly(c) and the verifier in time poly(c).</p>

    <p class="text-gray-300"><strong>Theorem 10.2</strong> (PZK IPCP for <strong>PSPACE</strong>). For every query bound function b(n), the <strong>PSPACE</strong>-complete language  <span class="math">\\mathcal{L}_{TQBF}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail:</p>

    <pre><code class="language-text">\\mathcal{L}_{\\mathrm{TQBF}} \\in \\mathbf{PZK\\text{-}IPCP} \\begin{bmatrix} soundness\\ error: &amp; 1/2 \\\\ round\\ complexity: &amp; O(n \\cdot (n + \\log \\mathsf{b})) \\\\ proof\\ length: &amp; (|\\Phi| + \\log \\mathsf{b})^{O(n + \\log \\mathsf{b})} \\\\ query\\ complexity: &amp; \\mathrm{poly}(|\\Phi|, \\log \\mathsf{b}) \\\\ prover\\ time: &amp; (|\\Phi| + \\log \\mathsf{b})^{O(n + \\log \\mathsf{b})} \\\\ verifier\\ time: &amp; \\mathrm{poly}(n, \\log \\mathsf{b}) + O(c) \\\\ verifier\\ space: &amp; O((n + \\log \\mathsf{b}) \\cdot \\log |\\Phi|) \\\\ simulator\\ overhead: &amp; \\mathrm{poly}(n + \\log \\mathsf{b}) \\cdot \\mathsf{q}_{\\tilde{V}}^3. \\end{bmatrix}.
</code></pre>

    <p class="text-gray-300">We first state and prove the reduction from  <span class="math">\\mathcal{L}_{TQBF}</span>  to  <span class="math">\\mathcal{L}_{SPCE}</span>  (Lemma 10.3 below), and then prove the theorem. The reduction is based on Shen's arithmetization of QBFs [She92] and (at least implicitly) his idea of degree reduction. (In particular, we do not rely on Shamir's restriction to 'simple' QBFs [Sha92].) We use Shen's arithmetization in order to ensure that the arithmetized expression only takes boolean values.</p>

    <p class="text-gray-300"><strong>Lemma 10.3</strong> ( <span class="math">\\mathcal{L}_{TQBF} \\to \\mathcal{L}_{SPCE}</span> ). There exists a polynomial-time function f such that, for every quantified boolean formula  <span class="math">\\Phi</span>  and prime p,  <span class="math">f(\\Phi,p) \\in \\mathcal{L}_{SPCE}</span>  if and only if  <span class="math">\\Phi</span>  is true. Moreover, if  <span class="math">\\Phi</span>  has n variables and c clauses then  <span class="math">f(\\Phi,p)</span>  is a sum-product circuit instance  <span class="math">\\mathcal{C} = (\\mathbb{F},H,\\delta_{in},\\delta_{lf},G,C)</span>  with  <span class="math">|\\mathbb{F}|=p</span> ,  <span class="math">|H|=\\Theta(1)</span> ,  <span class="math">\\delta_{in}=\\Theta(1)</span> ,  <span class="math">\\delta_{lf}=\\Theta(c)</span> ,  <span class="math">|V(G)|=\\Theta(n)</span> , arity G(G)=G(n), in G(G)=G(n), width G(G)=G(n), space G(G) space G(G).</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\Phi</span>  be a quantified boolean formula that, without loss of generality, has the following 'regular' form:</p>

    <p class="text-gray-300"><span class="math">$\\Phi = \\forall x_1 \\exists x_2 \\cdots \\forall x_{n-1} \\exists x_n \\, \\phi(x_1, x_2, \\dots, x_{n-1}, x_n) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\phi</span>  is a 3-CNF formula with c clauses, and n is even. This regular form is achievable with only constant multiplicative overheads in the number of variables and clauses. We arithmetize the formula and quantifiers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The arithmetization of a 3-CNF formula  <span class="math">\\phi</span>  with variables  <span class="math">z_1, \\ldots, z_n</span>  and clauses  <span class="math">K_1, \\ldots, K_c</span>  is the polynomial  <span class="math">\\hat{\\phi}</span>  of total degree at most 3c given by:  <span class="math">\\hat{\\phi}(Z_1, \\ldots, Z_n) := \\prod_{K \\in \\phi} (1 \\prod_{\\{i: z_i \\in K\\}} (1 Z_i) \\cdot \\prod_{\\{i: \\bar{z}_i \\in K\\}} Z_i)</span> . Note that  <span class="math">\\hat{\\phi}(x_1, \\ldots, x_n) = \\phi(x_1, \\ldots, x_n)</span>  for all boolean  <span class="math">x_1, \\ldots, x_n</span>  (i.e., they agree on the boolean hypercube).</li>
      <li>The arithmetization of the two quantifiers is as follows:  <span class="math">\\forall x \\, \\phi(x)</span>  maps to  <span class="math">\\prod_{x \\in \\{0,1\\}} \\hat{\\phi}(x)</span>  and  <span class="math">\\exists x \\, \\phi(x)</span>  maps to  <span class="math">\\coprod_{x \\in \\{0,1\\}} \\hat{\\phi}(x) := \\left(1 (1 \\hat{\\phi}(0))(1 \\hat{\\phi}(1))\\right)</span> . These arithmetic expressions have the same value as the boolean expressions (over any field); in particular they are 0 or 1.</li>
    </ul>

    <p class="text-gray-300">For any prime p, consider the following construction.</p>

    <p class="text-gray-300">&bull; Use n, c, p to construct a sum-product circuit instance C = (F, H, &delta;in, &delta;lf, G, C) where</p>

    <p class="text-gray-300">
<span class="math">$\\mathbb{F} := \\mathbb{F}_p \\, ; \\ H := \\{0,1\\} \\, ; \\ \\delta_{\\mathrm{in}} := 4 \\, ; \\ \\delta_{\\mathrm{lf}} := 3c \\, ;</span>$</p>

    <p class="text-gray-300">the ari-graph G := (V, E) is defined as follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} V &amp;:= \\{v_i\\}_{i \\in \\{0, \\dots, n\\}} \\\\ E &amp;:= \\{e_i, e_i&#x27; = (v_i, v_{i+1})\\}_{i \\in \\{0, \\dots, n-1\\}} \\\\ \\rho_e &amp;:= \\{1, \\dots, i\\} \\quad \\text{if } e = e_i \\text{ or } e = e_i&#x27; \\text{ for some } i \\in \\{0, \\dots, n-1\\}, \\\\ \\sigma_e &amp;:= \\begin{cases} \\{1\\} &amp; \\text{if } e = e_i \\text{ for some } i \\in \\{0, \\dots, n-1\\} \\text{ or } \\\\ \\{2\\} &amp; \\text{if } e = e_i&#x27; \\text{ for some } i \\in \\{0, \\dots, n-1\\}, \\end{cases} \\\\ C_{v_i} &amp;:= \\begin{cases} (1 - X_i)X_i \\cdot ZZ&#x27; &amp; \\text{if } i \\in \\{0, \\dots, n-1\\} \\text{ is even or } \\\\ (1 - X_i)X_i \\cdot (1 - (1 - Z)(1 - Z&#x27;)) &amp; \\text{if } i \\in \\{0, \\dots, n-1\\} \\text{ is odd,} \\end{cases} \\end{split}</span>$</p>

    <p class="text-gray-300">where Z, Z 0 in both cases correspond to the edges e<sup>i</sup> , e0 i .</p>

    <p class="text-gray-300">&bull; Construct an input x for C that maps v<sup>n</sup> to the polynomial &phi;&circ; in Fp[X &le;3c <sup>1</sup>,...,n] that equals the arithmetization of &phi;.</p>

    <p class="text-gray-300">See Figure <a href="#page-46-0">1,</a> Figure <a href="#page-46-1">2,</a> Figure <a href="#page-46-2">3</a> for diagrams of this sum-product circuit and input for 2, 4, n variables respectively. We claim that for every even i in {0, . . . , n} and x1, . . . , x<sup>i</sup> &isin; {0, 1}:</p>

    <p class="text-gray-300"><span class="math">$v_i[\\mathbf{x}](x_1, x_2, \\dots, x_{i-1}, x_i) = \\prod_{x_{i+1} \\in \\{0,1\\}} \\prod_{x_{i+2} \\in \\{0,1\\}} \\dots \\prod_{x_{n-1} \\in \\{0,1\\}} \\hat{\\phi}(x_1, x_2, \\dots, x_{n-1}, x_n) . \\tag{13}</span>$</p>

    <p class="text-gray-300">We argue the equality by induction on i. When i = n, Equation <a href="#page-45-0">13</a> is vn[x] = &phi;&circ;, which holds by definition; next, we assume the equality for i + 2 and prove it for i. By construction, for every x1, . . . , x<sup>i</sup> &isin; {0, 1},</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} v_{i+1}[\\mathbf{x}](x_1,\\dots,x_i) &amp;= \\sum_{x_{i+1},x_{i+1}&#x27; \\in \\{0,1\\}} (1-x_{i+1})x_{i+1}&#x27; \\cdot (1-(1-v_{x_{i+2}}[\\mathbf{x}](x_1,\\dots,x_i,x_{i+1}))(1-v_{x_{i+2}}[\\mathbf{x}](x_1,\\dots,x_i,x_{i+1}&#x27;))) \\\\ &amp;= (1-(1-v_{x_{i+2}}[\\mathbf{x}](x_1,\\dots,x_i,0))(1-v_{x_{i+2}}[\\mathbf{x}](x_1,\\dots,x_i,1))) \\\\ &amp;= \\coprod_{x_{i+2} \\in \\{0,1\\}} \\dots \\prod_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1,x_2,\\dots,x_{n-1},x_n) \\ , \\end{split}</span>$</p>

    <p class="text-gray-300">where the second equality follows by the inductive assumption. Then, by a similar argument,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} v_i[\\mathbf{x}](x_1,\\dots,x_i) &amp;= v_{i+1}[\\mathbf{x}](x_1,\\dots,x_i,0) \\cdot v_i[\\mathbf{x}](x_1,\\dots,x_i,1) \\\\ &amp;= \\prod_{x_{i+1} \\in \\{0,1\\}} \\prod_{x_{i+2} \\in \\{0,1\\}} \\cdots \\prod_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1,x_2,\\dots,x_{n-1},x_n) \\enspace, \\end{split}</span>$</p>

    <p class="text-gray-300">which completes the induction.</p>

    <p class="text-gray-300">We now turn to the reduction's completeness and soundness. The key fact, which immediately follows from Equation <a href="#page-45-0">13</a> and the arithmetization's properties, is that the quantified boolean formula &Phi; is true if and only if C[x] = v<sup>x</sup><sup>1</sup> [x] is 1 (over any field F). Thus, regardless of the choice of prime p, &Phi; is true if and only if (C, 1, x) &isin; LSPCE.</p>

    <p class="text-gray-300"><em>Proof of Theorem <a href="#page-44-1">10.2.</a></em> The prover and verifier receive as input a quantified boolean formula &Phi;. They agree on a deterministic procedure to find a prime in the range [cn<sup>3</sup> log b, 2cn<sup>3</sup> log b]; this can easily be done in polynomial time by exhaustive search and brute-force primality testing. The prover and the verifier then engage in the perfect zero knowledge Interactive PCP for LSPCE (Theorem <a href="#page-38-2">9.1)</a> on the input f(&Phi;, p). The soundness error of the protocol is O(&delta;in&delta;lf &middot; in(G) &middot; (arity(G) + log b) &middot; |V (G)|/|F|) = O(cn<sup>2</sup> log b/p); the size of p ensures that the soundness error is O(1/n) &lt; 1/2 for sufficiently large n.</p>

    <p class="text-gray-300">    <img src="_page_46_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Sum-product circuit and its input for QBF with 2 variables.</p>

    <p class="text-gray-300">    <img src="_page_46_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Sum-product circuit and its input for QBF with 4 variables.</p>

    <p class="text-gray-300">    <img src="_page_46_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: Sum-product circuit and its input for QBF with n variables.</p>

    <p class="text-gray-300">We present a 'zero knowledge analogue' of GKR's protocol for circuit evaluation [GKR15], except that the protocol is an Interactive PCP rather than an Interactive Proof. We achieve this by exhibiting an efficient reduction from circuit evaluation (for certain circuits) to sum-product circuit evaluation problems ( <span class="math">\\mathcal{L}_{SPCE}</span> , Definition 8.9). The reduction then yields the desired zero knowledge protocol (Theorem 11.1 below), via our construction of perfect zero knowledge Interactive PCPs for  <span class="math">\\mathcal{L}_{SPCE}</span>  (Theorem 9.1). We now provide context, state the theorem, and then describe its proof.</p>

    <p class="text-gray-300">Goldwasser, Kalai, and Rothblum [GKR15] give <em>interactive proofs for muggles</em> (also known as <em>doubly-efficient interactive proofs</em> [RRR16]) for low-depth circuits that are sufficiently uniform.</p>

    <p class="text-gray-300">Namely, given a language  <span class="math">\\mathscr L</span>  decidable by a family of  <span class="math">O(\\log S(n))</span> -space uniform boolean circuits of size S(n) and depth D(n), [GKR15] gives a public-coin Interactive Proof for  <span class="math">\\mathscr L</span>  where the prover runs in time  <span class="math">\\operatorname{poly}(S(n))</span>  and the verifier runs in time  <span class="math">(n+D(n))\\cdot\\operatorname{poly}(\\log S(n))</span>  and space  <span class="math">O(\\log S(n))</span> ; the number of rounds and communication complexity are  <span class="math">D(n)\\cdot\\operatorname{poly}(\\log S(n))</span> . Moreover, if the verifier is given oracle access to the low-degree extension of the circuit's input, the verifier runs only in time  <span class="math">D(n)\\cdot\\operatorname{poly}(\\log S(n))</span> ; this <em>sub-linear</em> running time enables applications to Interactive Proofs <em>of Proximity</em> [RVW13].</p>

    <p class="text-gray-300">The theorem below provides similar features, but in addition also provides perfect zero knowledge, via an Interactive PCP instead of an Interactive Proof.</p>

    <p class="text-gray-300"><strong>Theorem 11.1</strong> (PZK IPCP for low-depth uniform boolean circuits). Let  <span class="math">\\mathcal{L}</span>  be a language decidable by a family of  <span class="math">O(\\log S(n))</span> -space uniform boolean circuits of size S(n) and depth D(n), and let b(n) be a query bound function. Then  <span class="math">\\mathcal{L}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail:</p>

    <pre><code class="language-text"> \\mathcal{L} \\in \\mathbf{PZK\\text{-}IPCP} \\left[ \\begin{array}{ccc} soundness\\ error : &amp; 1/2 \\\\ round\\ complexity : &amp; D(n) \\cdot \\log b(n) \\cdot \\operatorname{poly}(\\log S(n)) \\\\ proof\\ length : &amp; D(n) \\cdot \\operatorname{poly}(S(n), b(n)) \\\\ query\\ complexity : &amp; D(n) \\cdot \\operatorname{poly}(\\log S(n), \\log b(n)) \\\\ prover\\ time : &amp; D(n) \\cdot \\operatorname{poly}(S(n), b(n)) \\\\ verifier\\ time : &amp; n \\cdot \\operatorname{poly}(D(n), \\log S(n), \\log b(n)) \\\\ verifier\\ space : &amp; O(\\log S(n) + \\log b(n)/\\log\\log S(n)) \\\\ simulator\\ overhead : &amp; \\operatorname{poly}(D(n), \\log S(n), \\log b(n)) \\cdot (n + \\operatorname{q}_{\\widetilde{V}}^3). \\end{array} \\right]
</code></pre>

    <p class="text-gray-300">Moreover, if the verifier (resp. simulator) is given oracle access to the low-degree extension of the circuit's input, the verifier runs in time  <span class="math">D(n) \\cdot \\operatorname{poly}(\\log S(n), \\log b(n))</span> , and the simulator overhead is  <span class="math">\\operatorname{poly}(D(n), \\log S(n), \\log b(n)) \\cdot \\operatorname{q}_{\\widetilde{V}}^3</span> .</p>

    <p class="text-gray-300">Our proof of the theorem follows the structure in [GKR15]. After recalling some notions for circuits (Section 11.1) and extending some of our definitions (Section 11.2), we proceed in three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1 (Section 11.3). We reduce the evaluation of a given layered arithmetic circuit to the evaluation of a sum-product circuit, when given oracles for low-degree extensions for the circuit's wiring predicates. One can view this step as casting the barebones protocol of [GKR15, Section 3] in the framework of sum-product circuits.</li>
      <li>Step 2 (Section 11.4). We reduce small-space Turing machine computations to sum-product circuit evaluations.</li>
      <li>Step 3 (Section 11.5). We combine the previous two steps to prove the theorem, using the fact that small-space Turing machines can evaluate low-degree extensions of the wiring predicates for sufficiently uniform boolean circuits.</li>
    </ul>

    <p class="text-gray-300">Before discussing each of the above steps, we discuss consequences for Turing machine computations.</p>

    <p class="text-gray-300">As in [GKR15], we can derive from the above theorem a useful corollary for Turing machine computations, using their reduction from Turing machines to boolean circuits.</p>

    <p class="text-gray-300"><strong>Corollary 11.2</strong> (PZK IPCP for Turing machines). Let  <span class="math">\\mathcal{L}</span>  be a language decidable by a (deterministic) Turing machine in space  <span class="math">s(n) = \\Omega(\\log n)</span> , and let b(n) be a query bound function. Then  <span class="math">\\mathcal{L}</span>  has a (public-coin and non-adaptive)</p>

    <p class="text-gray-300">Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail:</p>

    <pre><code class="language-text"> \\mathcal{L} \\in \\mathbf{PZK\\text{-}IPCP} \\left[ \\begin{array}{ccc} soundness\\ error: &amp; 1/2 \\\\ round\\ complexity: &amp; \\operatorname{poly}(s(n)) \\cdot \\log b(n) \\\\ &amp; proof\\ length: &amp; \\operatorname{poly}(2^{s(n)}, b(n)) \\\\ &amp; query\\ complexity: &amp; \\operatorname{poly}(s(n), b(n)) \\\\ &amp; prover\\ time: &amp; \\operatorname{poly}(2^{s(n)}, b(n)) \\\\ &amp; verifier\\ time: &amp; n \\cdot \\operatorname{poly}(s(n), \\log b(n)) \\\\ &amp; verifier\\ space: &amp; O(s(n) + \\log b(n)/\\log s(n)) \\end{array} \\right] .
</code></pre>

    <p class="text-gray-300"><em>Proof.</em> By [GKR15, Lemma 4.1], a language  <span class="math">\\mathscr{L}</span>  decidable by a Turing machine in time t(n) and space s(n) is also decidable by a O(s(n))-space uniform circuit family of size  <span class="math">\\operatorname{poly}(t(n)2^{s(n)}) = \\operatorname{poly}(2^{s(n)})</span>  and depth  <span class="math">\\operatorname{poly}(s(n))</span> . Applying Theorem 11.1 to this circuit family yields the corollary.</p>

    <p class="text-gray-300">In each of the results above, one can set the query bound b(n) to be superpolynomial in n (say,  <span class="math">b(n) := n^{O(\\log \\log n)}</span> ) to obtain Interactive PCPs that are perfect zero knowledge against all polynomial-time malicious verifiers, without affecting the efficiency of the honest verifier.</p>

    <p class="text-gray-300">We briefly recall some definitions and observations from [GKR15].</p>

    <p class="text-gray-300"><strong>Definition 11.3.</strong> A layered arithmetic circuit  <span class="math">C: \\mathbb{F}^n \\to \\mathbb{F}</span>  of depth D and size S (with  <span class="math">n \\leq S</span> ) is an arithmetic circuit, with fan-in 2, arranged into D+1 layers: the output layer (layer 0) has a single gate; layers  <span class="math">1, \\ldots, D-1</span>  have S gates each; and the input layer (layer D) has n gates. For  <span class="math">i \\in \\{0, \\ldots, D-1\\}</span> , each gate in layer i has two inputs, which are gates in layer i + 1; the i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i are i gates in layer i gates in layer i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gates i gat</p>

    <p class="text-gray-300">For  <span class="math">i \\in \\{1, \\dots, D-1\\}</span> , we denote by  <span class="math">V_i \\colon \\mathbb{F}^n \\times [S] \\to \\mathbb{F}</span>  the function such that  <span class="math">V_i(\\vec{x}, j) = v</span>  if and only if the j-th gate of the i-th layer has value v when C's input is  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> . Moreover, we denote by  <span class="math">V_D \\colon \\mathbb{F}^n \\times [n] \\to \\mathbb{F}</span>  the function  <span class="math">V_D(\\vec{x}, j) := x_j</span> , and by  <span class="math">V_D \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  the function  <span class="math">V_0(\\vec{x}) := C(x)</span> .</p>

    <p class="text-gray-300">Let  <span class="math">H \\subseteq \\mathbb{F}</span>  and  <span class="math">m, m&#x27; \\in \\mathbb{N}</span>  be such that  <span class="math">|H| \\ge 2</span> ,  <span class="math">m \\ge \\lceil \\log S / \\log |H| \\rceil</span> , and  <span class="math">m&#x27; \\ge \\lceil \\log n / \\log |H| \\rceil</span> .</p>

    <p class="text-gray-300">For  <span class="math">i \\in \\{1, ..., D-1\\}</span> , we can equivalently view  <span class="math">V_i</span>  as a function from  <span class="math">\\mathbb{F}^n \\times H^m</span>  to  <span class="math">\\mathbb{F}</span> , by taking an arbitrary order  <span class="math">\\alpha</span>  on  <span class="math">H^m</span> , and letting  <span class="math">V_i(\\vec{x}, \\vec{z}) = 0</span>  for every  <span class="math">\\vec{z} \\in H^m</span>  with  <span class="math">\\alpha(z) &gt; S</span> . The following equation then relates  <span class="math">V_{i-1}</span>  to  <span class="math">V_i</span> :</p>

    <p class="text-gray-300"><span class="math">$V_{i-1}(\\vec{x}, \\vec{z}) = \\sum_{\\vec{\\omega}_1, \\vec{\\omega}_2 \\in H^m} \\operatorname{add}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_i(\\vec{x}, \\vec{\\omega}_1) + V_i(\\vec{x}, \\vec{\\omega}_2) \\right) + \\operatorname{mul}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_i(\\vec{x}, \\vec{\\omega}_1) \\cdot V_i(\\vec{x}, \\vec{\\omega}_2) \\right)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathrm{add}_i\\colon H^{3m}\\to\\mathbb{F}</span>  (resp.,  <span class="math">\\mathrm{mul}_i\\colon H^{3m}\\to\\mathbb{F}</span> ) is the predicate such that, for every  <span class="math">(\\vec{a},\\vec{b},\\vec{c})\\in H^{3m}</span> ,  <span class="math">\\mathrm{add}_i(\\vec{a},\\vec{b},\\vec{c})</span>  (resp.,  <span class="math">\\mathrm{mul}_i(\\vec{a},\\vec{b},\\vec{c})</span> ) equals 1 if the  <span class="math">\\alpha(\\vec{a})</span> -th gate of layer i-1 is an addition (resp., multiplication) gate whose inputs are gates  <span class="math">\\alpha(\\vec{b})\\le\\alpha(\\vec{c})</span>  of layer i, or 0 otherwise. The situation for the input layer and output layer is somewhat different.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The input layer (layer D) has n gates (rather than S), so we can equivalently view  <span class="math">V_D</span>  as a function from  <span class="math">\\mathbb{F}^n \\times H^{m&#x27;}</span>  to  <span class="math">\\mathbb{F}</span> , by taking an arbitrary order  <span class="math">\\alpha&#x27;</span>  on  <span class="math">H^{m&#x27;}</span> , and letting  <span class="math">V_D(\\vec{x}, \\vec{z}) = 0</span>  for every  <span class="math">\\vec{z} \\in H^{m&#x27;}</span>  with  <span class="math">\\alpha&#x27;(z) &gt; n</span> . Naturally, we need to adjust the expression for  <span class="math">V_{D-1}</span>  and the definitions of  <span class="math">\\operatorname{add}_D</span> ,  <span class="math">\\operatorname{mul}_D</span>  appropriately.</li>
      <li>The output layer (layer 0) has a single gate (rather than S), so and we can write</li>
    </ul>

    <p class="text-gray-300"><span class="math">$V_0(\\vec{x}) = \\sum_{\\vec{\\omega}_1, \\vec{\\omega}_2 \\in H^m} \\operatorname{add}_1(\\vec{0}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_1(\\vec{x}, \\vec{\\omega}_1) + V_1(\\vec{x}, \\vec{\\omega}_2) \\right) + \\operatorname{mul}_1(\\vec{0}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\cdot \\left( V_1(\\vec{x}, \\vec{\\omega}_1) \\cdot V_1(\\vec{x}, \\vec{\\omega}_2) \\right) \\ .</span>$</p>

    <p class="text-gray-300"><strong>Remark 11.4.</strong> For  <span class="math">i \\in \\{1, ..., D\\}</span> , we view  <span class="math">V_i</span>  as a function not only of the gate number j (represented as  <span class="math">\\vec{z} \\in H^m</span> ) but also of the circuit's input  <span class="math">\\vec{x}</span> , and we view  <span class="math">V_0</span>  as a function of the input only. In contrast, [GKR15] defines  <span class="math">V_0, ..., V_D</span>  with  <span class="math">\\vec{x}</span>  'hard-coded'. We require the additional flexibility ( <span class="math">\\vec{x}</span>  is an input) to compose sum-product circuits below.</p>

      <h3 id="sec-11.2" class="text-xl font-semibold mt-8">11.2 Sum-product subcircuits and oracle inputs</h3>

    <p class="text-gray-300">Later on we will need to assemble different sum-product circuits into one such circuit, which requires relaxing the definition of an ari-graph to allow the root to have positive arity. This is stated formally below (difference highlighted).</p>

    <p class="text-gray-300"><strong>Definition 11.5</strong> (extends Definition 8.7). A tuple  <span class="math">G = (V, E, \\rho, \\sigma)</span>  is an <strong>ari-graph</strong> if (V, E) is a directed acyclic multi-graph and both  <span class="math">\\rho</span>  and  <span class="math">\\sigma</span>  label every edge e in E with finite sets of positive integers  <span class="math">\\rho_e</span>  and  <span class="math">\\sigma_e</span>  that satisfy the following property. For every vertex v in V, there exists a (unique) non-negative integer arity(v) such that, if  <span class="math">e_1, \\ldots, e_t</span>  are v's outgoing edges: (1) if v is the root then arity(v) =  <span class="math">\\max(\\sigma_{e_1} \\cup \\ldots \\cup \\sigma_{e_t})</span> , otherwise arity(v) =  <span class="math">|\\rho_{e_1}| + |\\sigma_{e_1}| = \\cdots = |\\rho_{e_t}| + |\\sigma_{e_t}|</span>  where  <span class="math">e_1, \\ldots, e_{\\inf_G(v)}</span>  are v's incoming edges; (2)  <span class="math">\\rho_{e_1}, \\ldots, \\rho_{e_t} \\subseteq \\{1, \\ldots, \\operatorname{arity}(v)\\}</span> .</p>

    <p class="text-gray-300">For consistency, we retain the original definition of sum-product circuits, where the root must have arity zero, and so its value is a constant in  <span class="math">\\mathbb{F}</span> . Instead, we now define sum-product <em>sub</em>circuits, where the root may have positive arity.</p>

    <p class="text-gray-300"><strong>Definition 11.6.</strong> A sum-product subcircuit C is a tuple  <span class="math">(\\mathbb{F}, H, \\delta_{in}, \\delta_{lf}, G, C)</span>  whose definition is identical to that of a sum-product circuit (see Definition 8.8), except that the root of G may have positive arity. In particular, C[x] may be a non-constant polynomial (having the same arity as the root of G).</p>

    <p class="text-gray-300">It is not difficult to see that, provided the arities match, we can replace a leaf of a sum-product circuit C with a sum-product <em>subcircuit</em>  <span class="math">C_0</span>  computing the same function (over the appropriate subdomain) without affecting C's output.</p>

    <p class="text-gray-300">Finally, in the discussions below, we also need a way to talk about oracles in the context of a sum-product (sub)circuit. The structure of the protocol is such that the calls to the oracle will be made at the leaves of C, and so we associate the oracle with the circuit's input.</p>

    <p class="text-gray-300"><strong>Definition 11.7.</strong> Given a sub-product (sub)circuit C and a list of oracles  <span class="math">O = \\{O_i\\}_{i \\in [\\ell]}</span>  with  <span class="math">O_i \\colon \\mathbb{F}^k \\to \\mathbb{F}</span>  for each  <span class="math">i \\in [\\ell]</span> , we say that  <span class="math">\\mathbf{x}^O</span>  is an <strong>oracle input</strong> for C if it labels the leaves of C with oracle circuits: arithmetic circuits that may include oracle gates. An oracle gate is a gate labeled with the name of an oracle  <span class="math">O_i</span> ; it has k inputs and a single output defined as the evaluation of  <span class="math">O_i</span>  on its inputs.</p>

    <p class="text-gray-300">We show that the evaluation problem for a given layered arithmetic circuit can be reduced to a sum-product subcircuit, when given oracles for low-degree extensions of the wiring predicates. The reduction essentially consists of casting the <em>barebones protocol</em> of [GKR15, Section 3] as (the evaluation of) a sum-product subcircuit on an oracle input. The barebones protocol is an Interactive Proof that enables a verifier to check a statement of the form &quot; <span class="math">C(\\vec{x}) = y</span> &quot;, where C is a layered arithmetic circuit of size S and depth D, in time  <span class="math">n \\cdot \\operatorname{poly}(D, \\log S)</span>  and space  <span class="math">O(\\log S)</span> , provided that the verifier has oracle access to low-degree extensions of the wiring predicates  <span class="math">\\{\\operatorname{add}_i, \\operatorname{mul}_i\\}_{i \\in \\{1, \\dots, D\\}}</span>  for the circuit C. The arithmetization of C underlying that protocol provides the basic intuition for how to 'program' a sum-product subcircuit to encode this computation.</p>

    <p class="text-gray-300"><strong>Lemma 11.8</strong> (sum-product subcircuits for layered arithmetic circuits). Let  <span class="math">\\mathbb{F}</span>  be a finite field,  <span class="math">C \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  a layered arithmetic circuit of depth D and size S,  <span class="math">H \\subseteq \\mathbb{F}</span> ,  <span class="math">m, m&#x27; \\in \\mathbb{N}</span>  and  <span class="math">F = (add_i, mul_i)_{i \\in \\{1, \\dots, D\\}}</span>  any degree- <span class="math">\\delta</span>  extensions of the wiring predicates  <span class="math">\\{add_i, mul_i\\}_{i \\in \\{1, \\dots, D\\}}</span> , with  <span class="math">\\delta \\leq \\operatorname{polylog}(S)</span> . Then there exists a sum-product subcircuit C, constructible in time  <span class="math">n \\cdot \\operatorname{poly}(D, \\log S)</span>  and space  <span class="math">O(\\log S)</span> , and oracle input  <span class="math">\\mathbf{x}^F</span>  constructible in time  <span class="math">\\operatorname{poly}(D, \\log S)</span>  and space  <span class="math">O(\\log S)</span> , such that  <span class="math">C[\\mathbf{x}^F](\\vec{x}) = C(\\vec{x})</span> , for all  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> .</p>

    <p class="text-gray-300">Moreover,  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, G, C)</span>  where  <span class="math">|H| = \\mathrm{poly}(D, \\log S)</span> ,  <span class="math">\\delta_{\\mathsf{in}} = \\Theta(1)</span> ,  <span class="math">\\delta_{\\mathsf{lf}} = \\mathrm{poly}(D, \\log S)</span> ,  <span class="math">|V(G)| = \\Theta(D)</span> ,  <span class="math">\\mathsf{arity}(G) = O(n + \\log S/\\log |\\mathbb{F}|)</span> ,  <span class="math">\\mathsf{in}(G) = \\Theta(1)</span> , width <span class="math">(G) = \\Theta(1)</span> ; and  <span class="math">\\mathsf{space}(\\mathbb{x}) = O(\\log S)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">H \\subseteq \\mathbb{F}</span>  be such that  <span class="math">|\\mathbb{F}|^{\\Omega(1)} \\le |H| \\le \\operatorname{poly}(D, \\log S)</span> ;  <span class="math">m \\in \\mathbb{N}</span>  be such that  <span class="math">S \\le |H|^m \\le \\operatorname{poly}(S)</span> ;  <span class="math">m&#x27; \\in \\mathbb{N}</span>  be such that  <span class="math">n \\le |H|^{m&#x27;} \\le n \\cdot \\operatorname{poly}(D, \\log S)</span> .</p>

    <p class="text-gray-300">    <img src="_page_50_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_50_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_50_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: Sum-product circuit and its input for layered circuit of depth 1.</p>

    <p class="text-gray-300">Figure 5: Sum-product circuit and its input for layered circuit of depth 2.</p>

    <p class="text-gray-300">Figure 6: Sum-product circuit and its input for layered circuit of depth  <span class="math">{\\cal D}.</span></p>

    <p class="text-gray-300">First, we use D, m, m' to construct an ari-graph  <span class="math">G = (V, E, \\rho, \\sigma)</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} V &amp;:= \\{v_i\\}_{i \\in \\{0, \\dots, D\\}} \\cup \\{u_{\\text{add}_i}, u_{\\text{mul}_i}\\}_{i \\in \\{1, \\dots, D\\}} \\\\ E &amp;:= \\{e_i, e_i&#x27; = (v_i, v_{i+1})\\}_{i \\in \\{0, \\dots, D-1\\}} \\cup \\{(v_i, u_{f_{i+1}}) : f \\in \\{\\text{add}, \\text{mul}\\}\\}_{i \\in \\{0, \\dots, D-1\\}} \\\\ \\rho_e &amp;:= \\begin{cases} \\varnothing &amp; \\text{if } e = (v_0, u_{f_1}) \\text{ for } f \\in \\{\\text{add}, \\text{mul}\\}, \\text{ or } \\\\ n + [m] &amp; \\text{if } e = (v_i, u_{f_{i+1}}) \\text{ for } f \\in \\{\\text{add}, \\text{mul}\\} \\text{ and } i \\in \\{1, \\dots, D-1\\}, \\\\ [n] &amp; \\text{otherwise}; \\end{cases} \\\\ \\sigma_e &amp;:= \\begin{cases} [2m] &amp; \\text{if } e = (v_i, u_{f_{i+1}}) \\text{ for } f \\in \\{\\text{add}, \\text{mul}\\} \\text{ and } i \\in \\{0, \\dots, D-2\\}, \\\\ [m] &amp; \\text{if } e = e_i \\text{ for some } i \\in \\{0, \\dots, D-2\\}, \\\\ [2m&#x27;] &amp; \\text{if } e = (v_{D-1}, u_{f_D}) \\text{ for } f \\in \\{\\text{add}, \\text{mul}\\}, \\\\ [m&#x27;] &amp; \\text{if } e = e_{D-1}, \\text{ or } \\\\ m&#x27; + [m&#x27;] &amp; \\text{if } e = e&#x27;_{D-1}. \\end{cases} \\end{split}</span>$</p>

    <p class="text-gray-300">Note that E is a multiset and contains, for every  <span class="math">i \\in \\{0, \\ldots, D-1\\}</span> , two distinct edges,  <span class="math">e_i</span>  and  <span class="math">e&#x27;_i</span> , from  <span class="math">v_i</span>  to  <span class="math">v_{i+1}</span>  (with different projection labels). The root of G is  <span class="math">v_0</span> , and its leaves are  <span class="math">v_D</span>  and  <span class="math">\\{u_{\\mathrm{add}_i}, u_{\\mathrm{mul}_i}\\}_{i \\in \\{1, \\ldots, D\\}}</span> .</p>

    <p class="text-gray-300">Next, we construct the sum-product circuit  <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\mathrm{in}},\\delta_{\\mathrm{lf}},G,C)</span>  where  <span class="math">\\delta_{\\mathrm{in}}:=3</span> ,  <span class="math">\\delta_{\\mathrm{lf}}:=\\max(\\delta,|H|)</span> , and C labels internal vertices of G as follows. For every  <span class="math">i\\in\\{0,\\ldots,D-1\\}</span> ,  <span class="math">C_{v_i}:=X_1\\cdot(Y_1+Y_2)+X_2\\cdot Y_1\\cdot Y_2</span> , where  <span class="math">Y_1,Y_2</span>  correspond to  <span class="math">e_i,e_i&#x27;</span>  respectively, and  <span class="math">X_1,X_2</span>  correspond to  <span class="math">(v_i,u_{\\mathrm{add}_i}),(v_i,u_{\\mathrm{mul}_i})</span>  respectively. Finally, we construct the input x for C as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet \\ \\ \\text{for all } \\stackrel{f}{f} \\in \\{\\text{add}, \\text{mul}\\}, \\, \\mathbf{x}_{u_{f_1}} \\ \\text{is the oracle circuit that outputs } \\hat{f}_1(\\vec{0}, \\vec{\\omega}_1, \\vec{\\omega}_2) \\ \\text{on input } (\\vec{\\omega}_1, \\vec{\\omega}_2);</span></li>
      <li>for all  <span class="math">i \\in \\{2, ..., D\\}</span>  and  <span class="math">f \\in \\{\\text{add, mul}\\}</span> ,  <span class="math">\\mathbf{x}_{u_{f_i}}</span>  is the oracle circuit that outputs  <span class="math">\\hat{f}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2)</span>  on input  <span class="math">(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2)</span> ;</li>
      <li><span class="math">x_{v_D}</span>  is the polynomial  <span class="math">V_D(\\vec{x}, \\vec{z}) := \\sum_{\\vec{\\beta} \\in H^{m&#x27;}} I_{H^{m&#x27;}}(\\vec{z}, \\vec{\\beta}) x_{\\alpha&#x27;(\\vec{\\beta})}</span>  (with  <span class="math">x_i := 0</span>  for i &gt; n), which has individual degree less than |H|, that is the low-degree extension of  <span class="math">V_D</span>  and can be computed in time  <span class="math">|H|^{m&#x27;} \\cdot \\operatorname{poly}(|H|, m&#x27;) \\le n \\cdot \\operatorname{poly}(D, \\log S)</span>  and space  <span class="math">O(m&#x27; \\cdot \\log |H|) \\le \\log n + \\operatorname{polylog}(D, \\log S) \\le O(\\log S)</span> .</li>
    </ul>

    <p class="text-gray-300">See Figure 4, Figure 5, Figure 6 for diagrams of this sum-product circuit and input for depth 1, 2, D respectively.</p>

    <p class="text-gray-300">We are left to argue correctness of the reduction: it is easy to see that  <span class="math">v_D[\\mathbf{x}^F](\\vec{x}, \\vec{z}) = V_D(\\vec{x}, \\vec{z})</span>  for every  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{z} \\in H^{m&#x27;}</span> ; hence, for every  <span class="math">i \\in \\{1, \\dots, D-1\\}</span> ,  <span class="math">v_i[\\mathbf{x}^F](\\vec{x}, \\vec{z}) = V_i(\\vec{x}, \\vec{z})</span>  for every  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{z} \\in H^m</span> . We conclude that  <span class="math">\\mathcal{C}[\\mathbf{x}^F] = v_0[\\mathbf{x}^F] = V_0</span>  (as functions in  <span class="math">\\vec{x}</span> ), as claimed.</p>

      <h3 id="sec-11.4" class="text-xl font-semibold mt-8">11.4 Sum-product subcircuits for small-space Turing machines</h3>

    <p class="text-gray-300">We show that small-space Turing machine computations can be reduced to the evaluation of sum-product subcircuits whose size is polynomially related to the space bound. This theorem is the analogue of [GKR15, Theorem 4.4] for our</p>

    <p class="text-gray-300">framework: we use Lemma 11.8 and then instantiate the oracle input with explicit arithmetic circuits.</p>

    <p class="text-gray-300">To prove Theorem 11.1 we need to construct a sum-product subcircuit whose value is a function  <span class="math">f \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  computable by a Turing machine in small space. However, if we simply apply Lemma 11.8 to a circuit given by [GKR15, Lemma 4.3], then we only obtain sum-product subcircuits for <em>boolean</em> functions computable in small space. We therefore apply [GKR15, Lemma 4.3] to the language  <span class="math">\\mathscr{L}_f := \\{(\\vec{x},a) : f(\\vec{x}) = a\\}</span> , which by Lemma 11.8 yields a subcircuit whose value is a function  <span class="math">f&#x27; \\colon \\mathbb{F}^n \\times \\mathbb{F} \\to \\{0,1\\}</span> , the indicator function of  <span class="math">\\mathscr{L}_f</span> . Then it holds that  <span class="math">\\sum_{a \\in \\mathbb{F}} a \\cdot f&#x27;(x,a) = f(x)</span> , and this summation can be implemented by adding an extra vertex to the subcircuit.</p>

    <p class="text-gray-300"><strong>Lemma 11.9</strong> (sum-product subcircuits for small-space Turing machines). Let  <span class="math">s \\colon \\mathbb{N} \\to \\mathbb{N}</span>  be a space function with  <span class="math">s(n) = \\Omega(\\log n)</span> , H an extension field of  <span class="math">\\mathbb{F}_2</span> , and  <span class="math">\\mathbb{F}</span>  an extension field of H with  <span class="math">|H| = \\operatorname{poly}(s(n))</span>  and  <span class="math">|\\mathbb{F}| = \\operatorname{poly}(|H|)</span> . Let  <span class="math">f \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  be a function computable by a non-deterministic Turing machine M in space s(n) in the following sense: M accepts  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  if and only if s(n) = s(n). Then there exist a sum-product subcircuit  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  if and only if  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is constructible in time  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is a space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  is a space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the space  <span class="math">s(n) \\in \\mathbb{F}^n \\times \\mathbb{F}</span>  in the sp</p>

    <p class="text-gray-300">Moreover,  <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\mathsf{in}},\\delta_{\\mathsf{lf}},G,C)</span>  where  <span class="math">\\delta_{\\mathsf{in}}=\\Theta(1)</span> ,  <span class="math">\\delta_{\\mathsf{lf}}=\\mathrm{poly}(s(n))</span> ,  <span class="math">|V(G)|=O(s^2(n))</span> ,  <span class="math">\\mathsf{arity}(G)=O(n+s(n)/\\log|\\mathbb{F}|)</span> ,  <span class="math">\\mathsf{in}(G)=\\Theta(1)</span> ,  <span class="math">\\mathsf{width}(G)=\\Theta(1)</span> ; and  <span class="math">\\mathsf{space}(\\mathtt{x})=O(s(n))</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Fix an input length n, and let  <span class="math">k := \\log |\\mathbb{F}|/\\log |H|</span>  (k is an integer because  <span class="math">\\mathbb{F}</span>  is an extension field of H). Let  <span class="math">\\gamma \\colon H^k \\to \\mathbb{F}</span>  be the trivial isomorphism, and let  <span class="math">\\mathscr{L} := \\{(\\vec{x}, \\vec{z}) : f(\\vec{x}) = \\gamma(\\vec{z})\\}</span> . Note that  <span class="math">\\mathscr{L}</span>  is computable by a non-deterministic Turing machine in space O(s(n)) because (i) f is and (ii)  <span class="math">\\gamma(\\vec{z})</span>  can be implemented at the bit level as the identity function. By [GKR15, Lemma 4.3],  <span class="math">\\mathscr{L}</span>  can be computed by a layered arithmetic circuit C over  <span class="math">\\mathbb{F}</span>  of size  <span class="math">S(n) = \\operatorname{poly}(2^{s(n)})</span>  and depth  <span class="math">D(n) = O(s^2(n))</span> ; moreover, one can generate arithmetic circuits for and evaluate some low-degree extensions  <span class="math">\\hat{\\operatorname{add}}_i</span> ,  <span class="math">\\hat{\\operatorname{mul}}_i</span>  of the wiring predicates in time  <span class="math">\\operatorname{poly}(s(n))</span>  and space  <span class="math">O(\\log s(n))</span> . The degree of these extensions is  <span class="math">\\operatorname{poly}(s(n)) = \\operatorname{polylog}(S(n))</span> , independent of  <span class="math">\\mathbb{F}</span>  (which is crucial for soundness).</p>

    <p class="text-gray-300">Note that H is of size  <span class="math">\\operatorname{poly}(s(n)) = \\operatorname{poly}(D(n), \\log S(n))</span> . By Lemma 11.8, we can construct a sum-product subcircuit  <span class="math">\\mathcal{C}&#x27; = (\\mathbb{F}, H, \\delta_{\\operatorname{in}}, \\delta_{\\operatorname{lf}}, G, C)</span>  and oracle input  <span class="math">\\mathbf{x}^F</span>  such that  <span class="math">\\mathcal{C}&#x27;[\\mathbf{x}^F](\\vec{x}, \\vec{z}) = C(\\vec{x}, \\vec{z})</span>  for every  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{z} \\in H^k</span> . We replace the oracle gates in  <span class="math">\\mathbf{x}^F</span>  with the explicit circuits for  <span class="math">\\operatorname{add}_i</span> ,  <span class="math">\\operatorname{mul}_i</span>  to obtain a non-oracle input  <span class="math">\\mathbf{x}&#x27;</span> .</p>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">$f(\\vec{x}) = \\sum_{\\vec{z} \\in H^k} C(\\vec{x}, \\vec{z}) \\cdot \\gamma(\\vec{z}) = \\sum_{\\vec{z} \\in H^k} \\mathcal{C}&#x27;[\\mathbf{x}](\\vec{x}, \\vec{z}) \\cdot \\hat{\\gamma}(\\vec{z})</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{\\gamma} \\colon \\mathbb{F}^k \\to \\mathbb{F}</span>  is the unique  <span class="math">\\mathbb{F}</span> -linear function such that  <span class="math">\\hat{\\gamma}(\\vec{z}) = \\gamma(\\vec{z})</span>  for  <span class="math">\\vec{z} \\in H^k</span> . Note that  <span class="math">\\hat{\\gamma}</span>  is computable by an arithmetic circuit of size O(k), and can be evaluated in space  <span class="math">O(k + \\log |\\mathbb{F}|) = O(\\log |\\mathbb{F}|)</span> .</p>

    <p class="text-gray-300">The sum-product subcircuit  <span class="math">\\mathcal{C}</span>  is obtained from  <span class="math">\\mathcal{C}&#x27;</span>  by adding a vertex v to G labeled with  <span class="math">X \\cdot Y</span>  and a leaf vertex  <span class="math">u_{\\gamma}</span> , and two edges  <span class="math">e := (v, r_G)</span>  and  <span class="math">e&#x27; := (v, u_{\\gamma})</span>  with labels  <span class="math">(\\rho_e, \\sigma_e) := ([n], [k])</span>  and  <span class="math">(\\rho_{e&#x27;}, \\sigma_{e&#x27;}) := (\\varnothing, [k])</span> . The input x is obtained from x' by mapping  <span class="math">u_{\\gamma}</span>  to the arithmetic circuit computing  <span class="math">\\hat{\\gamma}</span> .</p>

      <h3 id="sec-11.5" class="text-xl font-semibold mt-8">11.5 Proof of Theorem 11.1</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathscr{L}</span>  be a language decidable by a family of  <span class="math">O(\\log S(n))</span> -space uniform boolean circuits of size S(n) and depth D(n), and let b(n) be a query bound function. The prover and verifier receive an input  <span class="math">\\vec{x} \\in \\{0,1\\}^n</span> . Let C be the boolean circuit (i.e., arithmetic circuit over  <span class="math">\\mathbb{F}_2</span> ) for this input size; we assume that C is layered with fan-in 2, as in Definition 11.3. (Any circuit can be efficiently converted into this form, with only a quadratic increase in size and a  <span class="math">\\log S(n)</span> -factor increase in depth, which does not affect the theorem's statement.)</p>

    <p class="text-gray-300">Let H be an extension field of  <span class="math">\\mathbb{F}_2</span>  and  <span class="math">\\mathbb{F}</span>  an extension field of H such that  <span class="math">|\\mathbb{F}| = \\text{poly}(D(n), \\log S(n))</span>  and  <span class="math">|H| = |\\mathbb{F}|^{\\Omega(1)}</span> . Define  <span class="math">m := \\lceil \\log S(n) / \\log |H| \\rceil</span>  and  <span class="math">m&#x27; := \\lceil \\log n / \\log |H| \\rceil</span> . Throughout we fix  <span class="math">\\delta_{\\text{in}} = \\Theta(1)</span>  and  <span class="math">\\delta_{\\text{lf}} = \\text{poly}(D(n), \\log S(n))</span> , as these settings suffice for all the (sub)circuits that we construct.</p>

    <p class="text-gray-300">Part A: efficiently computable sum-product subcircuits for low-degree extensions of the wiring predicates. By [GKR15, Claim 4.6], for every  <span class="math">i \\in \\{1, \\dots, D(n)\\}</span> , the low-degree extensions  <span class="math">\\hat{\\text{add}}_i, \\hat{\\text{mul}}_i \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  of C's wiring predicates can be computed by a Turing machine in space  <span class="math">O(\\log S(n))</span> . The machine takes as input  <span class="math">1^n</span> , H,  <span class="math">\\mathbb{F}</span> , m, m', i,  <span class="math">f \\in \\{\\text{add, mul}\\}</span> , and  <span class="math">(\\vec{a}, \\vec{b}, \\vec{c}) \\in \\mathbb{F}^{3m}</span> , and outputs  <span class="math">\\hat{f}_i(\\vec{a}, \\vec{b}, \\vec{c})</span> . Here we consider all inputs besides  <span class="math">(\\vec{a}, \\vec{b}, \\vec{c})</span>  as hard-coded in the machine. By Lemma 11.9, there exist sum-product subcircuits  <span class="math">\\mathcal{C}_{f_i} = (\\mathbb{F}, H, \\delta_{\\text{in}}, \\delta_{\\text{lf}}, G_{f_i}, C_{f_i})</span>  and inputs  <span class="math">\\mathbf{x}_{f_i}</span>  (for every  <span class="math">f \\in \\text{add}</span> , mul and  <span class="math">i \\in \\{1, \\dots, D\\}</span> ) such that  <span class="math">\\mathcal{C}_{f_i}[\\mathbf{x}_{f_i}](\\vec{a}, \\vec{b}, \\vec{c}) = \\hat{f}_i(\\vec{a}, \\vec{b}, \\vec{c})</span>  for all  <span class="math">(\\vec{a}, \\vec{b}, \\vec{c}) \\in \\mathbb{F}^{3m}</span> .</p>

    <p class="text-gray-300">For every  <span class="math">f \\in \\operatorname{add}</span> ,  <span class="math">\\operatorname{mul}</span>  and  <span class="math">i \\in \\{1, \\ldots, D\\}</span> , we have  <span class="math">|V(G_{f_i})| = \\operatorname{poly}(\\log S(n))</span> ,  <span class="math">\\operatorname{arity}(G_{f_i}) = O(\\log S(n)/\\log |\\mathbb{F}|)</span> ,  <span class="math">\\operatorname{in}(G_{f_i}) = \\Theta(1)</span> , width <span class="math">(G_{f_i}) = \\Theta(1)</span> , and  <span class="math">\\operatorname{space}(\\mathbf{x}_{f_i}) = O(\\log S(n))</span> .</p>

    <p class="text-gray-300">Part B: sum-product circuit with oracle input for  <span class="math">C(\\vec{x})</span> . We now invoke Lemma 11.8 on C to obtain a sum-product subcircuit  <span class="math">C&#x27; = (\\mathbb{F}, H, \\delta_{\\text{in}}, \\delta_{\\text{lf}}, G&#x27;, C&#x27;)</span>  and oracle input  <span class="math">x^F</span> . For the theorem, we need to transform this into a sum-product <em>circuit</em> (i.e., where the root has arity 0). To do this, we will modify the projections so that the input  <span class="math">\\vec{x}</span>  is no longer 'carried down', and then 'hard-code' it into  <span class="math">x^F</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\rho&#x27;</span>  be given by defining, for every  <span class="math">e \\in E&#x27;</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\rho_e&#x27; := \\begin{cases} \\{1,\\dots,m\\} &amp; \\text{ if } e = (v_i,u_{f_{i+1}}) \\text{ for } f \\in \\{\\text{add},\\text{mul}\\} \\text{ and } i \\in \\{1,\\dots,D-1\\} \\text{ or } \\\\ \\varnothing &amp; \\text{ otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300">Observe that in  <span class="math">G&#x27;&#x27;:=(V(G&#x27;), E(G&#x27;), \\rho&#x27;, \\sigma(G&#x27;))</span> , the root  <span class="math">v_0</span>  has arity <span class="math">(v_0)=0</span> , and so G'' is an ari-graph. Let the input  <span class="math">\\mathbf{x}&#x27;^F</span>  be identical to  <span class="math">\\mathbf{x}^F</span>  except that  <span class="math">\\mathbf{x}&#x27;^F_{v_D}(\\vec{Z}):=\\mathbf{x}^F_{v_D}(\\vec{x},\\vec{Z})</span> ; that is, we 'hard-code' the input  <span class="math">\\vec{x}</span>  to the circuit C into the input  <span class="math">\\mathbf{x}&#x27;^F</span>  of the sum-product circuit (as in the original GKR protocol). This can only reduce the degree of  <span class="math">\\mathbf{x}&#x27;^F_{v_D}</span> . Now let  <span class="math">C&#x27;&#x27;:=(\\mathbb{F},H,\\delta_{\\mathrm{in}},\\delta_{\\mathrm{if}},G&#x27;&#x27;,C&#x27;)</span> ; it holds that that C'' is a sum-product circuit and  <span class="math">C&#x27;&#x27;[\\mathbf{x}&#x27;^F]=C&#x27;[\\mathbf{x}^F](\\vec{x})</span> .</p>

    <p class="text-gray-300">We obtain the following parameters:  <span class="math">|V(G&#x27;&#x27;)| = \\Theta(D(n))</span> ,  <span class="math">\\operatorname{arity}(G&#x27;&#x27;) = O(\\log S(n)/\\log |\\mathbb{F}|)</span> ,  <span class="math">\\operatorname{in}(G&#x27;&#x27;) = \\Theta(1)</span> , width <span class="math">(G&#x27;&#x27;) = \\Theta(1)</span> ; and  <span class="math">\\operatorname{space}(\\mathbf{x}&#x27;^F) = O(\\log S(n))</span> .</p>

    <p class="text-gray-300"><strong>Part C: composing sum-product subcircuits.</strong> The final sum-product circuit  <span class="math">C = (\\mathbb{F}, H, \\delta_{\\text{in}}, \\delta_{\\text{lf}}, G, C)</span>  is constructed as follows. The ari-graph G is obtained from G'' by replacing each leaf node  <span class="math">u_{f_i}</span>  with the ari-graph  <span class="math">G_{f_i}</span> , every  <span class="math">f \\in \\text{add}</span> , mul and  <span class="math">i \\in \\{1, \\ldots, D\\}</span> . The vertex label C is the union of the vertex labels C' and  <span class="math">\\{C_{f_i}\\}_{f \\in \\{\\text{add}, \\text{mul}\\}}\\}_{i \\in \\{1, \\ldots, D\\}}</span> .</p>

    <p class="text-gray-300">add, mul and  <span class="math">i \\in \\{1, \\ldots, D\\}</span> . The vertex label C is the union of the vertex labels C' and  <span class="math">\\{C_{f_i}\\}_{f \\in \\{\\text{add,mul}\\}, i \\in \\{1, \\ldots, D\\}}</span> . The input  <span class="math">\\mathbf{x}</span>  for C is equals the union of  <span class="math">\\{\\mathbf{x}_{f_i}\\}_{f \\in \\{\\text{add,mul}\\}, i \\in \\{1, \\ldots, D\\}}</span>  and the mapping  <span class="math">\\mathbf{x}_{v_D} := \\mathbf{x}_{v_D}&#x27;^F</span>  (for  <span class="math">v_D \\in G&#x27;&#x27;</span> ). Given the above definitions, one can verify that  <span class="math">C[\\mathbf{x}] = C(\\vec{x})</span> .</p>

    <p class="text-gray-300">Moreover, by inspection:  <span class="math">|V(G)| = D(n) \\cdot \\operatorname{poly}(\\log S(n))</span> ,  <span class="math">\\operatorname{arity}(G) = O(\\log S(n)/\\log |\\mathbb{F}|)</span> ,  <span class="math">\\operatorname{in}(G) = \\Theta(1)</span> ,  <span class="math">\\operatorname{width}(G) = \\operatorname{poly}(\\log S(n))</span> , and  <span class="math">\\operatorname{space}(\\mathbf{x}) = O(\\log S(n))</span> .</p>

    <p class="text-gray-300">Part D: invoke PZK IPCP for sum-product circuit evaluation. All oracles have now been instantiated, we can now rely on our construction of perfect zero knowledge Interactive PCPs for sum-product circuit evaluation problems. More precisely, the prover and verifier construct the sum-product circuit  <span class="math">\\mathcal{C}</span>  and its input x as above, in time  <span class="math">n \\cdot \\operatorname{poly}(D(n), \\log S(n))</span>  and space  <span class="math">O(\\log S(n))</span> . (While this amount of space is not enough to store the whole circuit at once, the verifier can construct each part as needed.) The prover and verifier then engage in the protocol of Theorem 9.1 on the input  <span class="math">(\\mathcal{C}, 1, x)</span> . Correctness comes from the fact that  <span class="math">(\\mathcal{C}, 1, x) \\in \\mathscr{L}_{\\operatorname{SPCE}}</span>  if and only if  <span class="math">C(\\vec{x}) = 1</span> .</p>

    <p class="text-gray-300">Plugging the parameters above into Theorem 9.1 yields the parameters claimed by Theorem 11.1, with the exception of the verifier space bound. A direct computation only shows that the verifier runs in space  <span class="math">\\operatorname{poly}(\\log S(n))</span> , because  <span class="math">\\operatorname{width}(G) = \\operatorname{poly}(\\log S(n))</span> . Yet, since  <span class="math">\\mathcal C</span>  is 'treelike' in the sense that the subcircuits can be handled independently, the evaluation protocol need only consider a constant number of vertices at any one time, at the expense of a  <span class="math">\\operatorname{poly}(\\log S(n))</span> -factor increase in the round complexity. Doing so yields the claimed  <span class="math">O(\\log S(n))</span>  space complexity of the verifier.</p>

    <p class="text-gray-300">The authors would like to thank Eli Ben-Sasson for numerous enlightening conversations in early stages of this work. The authors also thank Thomas Vidick for suggesting that we use our techniques to obtain a zero knowledge analogue of <a href="#page-60-3">[BFL91;</a> <a href="#page-60-11">BFLS91]</a>, as captured by Theorem <a href="#page-27-1">7.2.</a> The authors thank Tom Gur for comments on the writeup.</p>

    <p class="text-gray-300">In this section we prove the results whose statements appear in Section 5.</p>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 Proof of Theorem 5.1</h3>

    <p class="text-gray-300">First, since Z has individual degree at most d in  <span class="math">\\vec{X}</span> , we can rewrite any such linear combination in the following way:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in L^m} C_{\\vec{\\alpha},i} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{\\alpha} \\in L^m} C_{\\vec{\\alpha},i} \\sum_{\\vec{\\beta} \\in K^m} b_{\\vec{\\beta},\\vec{\\alpha}} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{\\alpha} \\in K^m} C&#x27;_{\\vec{\\alpha},i} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{q} \\in S} D_{\\vec{q},i} Z(\\vec{q}) \\ ,</span>$</p>

    <p class="text-gray-300">where C':=BC. If d'=|G|-2 then the bound is trivial. Otherwise, let H be some arbitrary subset of G of size  <span class="math">\\min\\{d&#x27;-|G|+2,|G|\\}</span> . Let  <span class="math">P_0\\subseteq \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq |H|-1}]</span>  be such that for all  <span class="math">p\\in P_0</span>  and for all  <span class="math">\\vec{q}\\in S, p(\\vec{q})=0</span> . Since this is at most S linear constraints,  <span class="math">P_0</span>  has dimension at least  <span class="math">(d+1)^m|H|^k-|S|</span> . Let  <span class="math">B_0\\in \\mathbb{F}^{n\\times (d+1)^m|H|^k}</span>  be a matrix whose rows form a basis for the vector space  <span class="math">\\{\\left(p(\\vec{\\alpha},\\vec{\\beta})\\right)_{\\vec{\\alpha}\\in K^m,\\vec{\\beta}\\in H^k}:p\\in P_0\\}</span>  of evaluations of polynomials in  <span class="math">P_0</span>  on  <span class="math">K^m\\times H^k</span> ; we have  <span class="math">n\\geq (d+1)^m|H|^k-|S|</span> . By an averaging argument there exists  <span class="math">\\vec{\\beta}_0\\in H^k</span>  such that the submatrix  <span class="math">B_{\\vec{\\beta}_0}</span>  consisting of columns  <span class="math">(\\vec{\\alpha},\\vec{\\beta}_0)</span>  of  <span class="math">B_0</span>  for each  <span class="math">\\vec{\\alpha}\\in K^m</span>  has rank at least  <span class="math">(d+1)^m-|S|/|H|^k</span> .</p>

    <p class="text-gray-300">Let  <span class="math">q \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq |G|-1}]</span>  be the polynomial such that  <span class="math">q(\\vec{\\beta}_0)=1</span> , and  <span class="math">q(\\vec{y})=0</span>  for all  <span class="math">\\vec{y} \\in G^k-\\{\\vec{\\beta}_0\\}</span> . For arbitrary  <span class="math">p \\in P_0</span> , let  <span class="math">Z(\\vec{X},\\vec{Y}):=q(\\vec{Y})p(\\vec{X},\\vec{Y})\\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d},Y_{1,\\dots,k}^{\\leq |H|+|G|-2}]</span> . Observe that our choice of H ensures that the degree of Z in  <span class="math">\\vec{Y}</span>  is at most d'. Then for all  <span class="math">i \\in \\{1,\\dots,\\ell\\}</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in K^m} C&#x27;_{\\vec{\\alpha},i} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{\\alpha} \\in K^m} C&#x27;_{\\vec{\\alpha},i} \\cdot p(\\vec{\\alpha}, \\vec{\\beta}_0) = \\sum_{\\vec{q} \\in S} D_{\\vec{q},i} \\cdot Z(\\vec{\\alpha}, \\vec{y}) = 0 .</span>$</p>

    <p class="text-gray-300">Thus the column space of C' is contained in the null space of  <span class="math">B_{\\vec{\\beta}_0}</span> , and so the null space of  <span class="math">B_{\\vec{\\beta}_0}</span>  has rank at least  <span class="math">\\operatorname{rank}(C&#x27;)</span> . Hence  <span class="math">(d+1)^m - \\operatorname{rank}(C&#x27;) \\geq \\operatorname{rank}(B_{\\vec{\\beta}_0}) \\geq (d+1)^m - |S|/|H|^k</span> , so  <span class="math">|S| \\geq \\operatorname{rank}(C&#x27;) \\cdot |H|^k</span> , which yields the theorem.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 Proof of Corollary 5.3</h3>

    <p class="text-gray-300">We will need a simple fact from linear algebra: that 'linear independence equals statistical independence'. That is, if we sample an element from a vector space and examine some subsets of its entries, these distributions are independent if and only if there does not exist a linear dependence between the induced subspaces. The formal statement of the claim is as follows; its proof is deferred to the end of this subsection.</p>

    <p class="text-gray-300"><strong>Claim A.1.</strong> Let  <span class="math">\\mathbb{F}</span>  be a finite field and D a finite set. Let  <span class="math">V \\subseteq \\mathbb{F}^D</span>  be an  <span class="math">\\mathbb{F}</span> -vector space, and let  <span class="math">\\vec{v}</span>  be a random variable which is uniform over V. For any subdomains  <span class="math">S, S&#x27; \\subseteq D</span> , the restrictions  <span class="math">\\vec{v}|_S</span>  and  <span class="math">\\vec{v}|_{S&#x27;}</span>  are statistically dependent if and only if there exist constants  <span class="math">(c_i)_{i \\in S}</span>  and  <span class="math">(d_i)_{i \\in S&#x27;}</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>there exists  <span class="math">\\vec{w} \\in V</span>  such that  <span class="math">\\sum_{i \\in S} c_i w_i \\neq 0</span> , and</li>
      <li>for all  <span class="math">\\vec{w} \\in V</span> ,  <span class="math">\\sum_{i \\in S} c_i w_i = \\sum_{i \\in S&#x27;} d_i w_i</span> .</li>
    </ul>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">$\\left\\{\\left(\\left(Z(\\vec{\\gamma})\\right)_{\\vec{\\gamma}\\in\\mathbb{F}^{m+k}},\\left(\\sum_{\\vec{y}\\in G^k}Z(\\vec{\\alpha},\\vec{y})\\right)_{\\vec{\\alpha}\\in\\mathbb{F}^m}\\right):Z\\in\\mathbb{F}[X_{1,...,m}^{\\leq d},Y_{1,...,k}^{\\leq d&#x27;}]\\right\\}</span>$</p>

    <p class="text-gray-300">is an  <span class="math">\\mathbb{F}</span> -vector space with domain  <span class="math">\\mathbb{F}^{m+k} \\cup \\mathbb{F}^m</span> . Consider subdomains  <span class="math">\\mathbb{F}^m</span>  and S. Since  <span class="math">|S| &lt; |G|^k</span> , by Theorem 5.1 there exist no constants  <span class="math">(c_{\\vec{\\alpha}})_{\\alpha \\in \\mathbb{F}^m}</span> ,  <span class="math">(d_{\\vec{\\gamma}})_{\\vec{\\gamma} \\in S}</span>  such that the conditions of the claim hold. This completes the proof.</p>

    <p class="text-gray-300"><em>Proof of Claim A.1.</em> For arbitrary  <span class="math">\\vec{x} \\in \\mathbb{F}^S</span> ,  <span class="math">\\vec{x}&#x27; \\in \\mathbb{F}^{S&#x27;}</span> , we define the quantity</p>

    <p class="text-gray-300"><span class="math">$p_{\\vec{x}, \\vec{x}&#x27;} := \\Pr_{\\vec{v} \\in V} [\\vec{v}|_S = \\vec{x} \\wedge \\vec{v}|_{S&#x27;} = \\vec{x}&#x27;]</span>$
.</p>

    <p class="text-gray-300">Let  <span class="math">d:=\\dim(V)</span> , and let  <span class="math">B\\in\\mathbb{F}^{D\\times d}</span>  be a basis for V. Let  <span class="math">B_S\\in\\mathbb{F}^{S\\times d}</span>  be B restricted to rows corresponding to elements of S, and let  <span class="math">B_{S&#x27;}</span>  be defined likewise. Finally, let  <span class="math">B_{S,S&#x27;}\\in\\mathbb{F}^{(|S|+|S&#x27;|)\\times d}</span>  be the matrix whose rows are the rows of  <span class="math">B_S</span> , followed by the rows of  <span class="math">B_{S&#x27;}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$p_{\\vec{x}, \\vec{x}&#x27;} = \\Pr_{\\vec{z} \\in \\mathbb{F}^d} \\left[ B_{S, S&#x27;} \\cdot \\vec{z} = (\\vec{x}, \\vec{x}&#x27;) \\right] .</span>$</p>

    <p class="text-gray-300">One can verify that, for any matrix  <span class="math">A \\in \\mathbb{F}^{m \\times n}</span> .</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\vec{z} \\in \\mathbb{F}^n} [A\\vec{z} = \\vec{b}] = \\begin{cases} \\mathbb{F}^{-\\operatorname{rank}(A)} &amp; \\text{if } \\vec{b} \\in \\operatorname{colsp}(A), \\text{ and} \\\\ 0 &amp; \\text{otherwise}. \\end{cases}</span>$</p>

    <p class="text-gray-300">The column space  <span class="math">\\operatorname{colsp}(B_{S,S&#x27;}) \\subseteq \\operatorname{colsp}(B_S) \\times \\operatorname{colsp}(B_{S&#x27;})</span> , and equality holds if and only if  <span class="math">\\operatorname{rank}(B_{S,S&#x27;}) = \\operatorname{rank}(B_S) + \\operatorname{rank}(B_{S&#x27;})</span> . It follows that  <span class="math">p_{\\vec{x},\\vec{x}&#x27;} = \\operatorname{Pr}_{\\vec{v} \\in V}[\\vec{v}|_S = \\vec{x}] \\cdot \\operatorname{Pr}_{\\vec{v} \\in V}[\\vec{v}|_{S&#x27;} = \\vec{x}&#x27;]</span>  if and only if  <span class="math">\\operatorname{rank}(B_{S,S&#x27;}) = \\operatorname{rank}(B_S) + \\operatorname{rank}(B_{S&#x27;})</span> . By the rank-nullity theorem and the construction of  <span class="math">B_{S,S&#x27;}</span> , this latter condition holds if and only if  <span class="math">\\operatorname{nul}(B_{S,S&#x27;}^T) \\subseteq \\operatorname{nul}(B_S^T) \\times \\operatorname{nul}(B_{S&#x27;}^T)</span> . To conclude the proof, it remains only to observe that the condition in the claim is equivalent to the existence of vectors  <span class="math">\\vec{c} \\in \\mathbb{F}^S</span> ,  <span class="math">\\vec{d} \\in \\mathbb{F}^{S&#x27;}</span>  such that  <span class="math">\\vec{c} \\notin \\operatorname{nul}(B_S^T)</span>  but  <span class="math">(\\vec{c}, -\\vec{d}) \\in \\operatorname{nul}(B_{S,S&#x27;}^T)</span> .</p>

    <p class="text-gray-300">In this section we show that in certain cases the degree constraints in Theorem 5.1 are tight.</p>

      <h4 id="app-a.3.1" class="text-lg font-semibold mt-6">A.3.1 The case of multilinear polynomials</h4>

    <p class="text-gray-300">The first result is for the case of multivariate polynomials over any finite field, where  <span class="math">H \\subseteq \\mathbb{F}</span>  is arbitrary. The proof is a simple extension of a proof due to [JKRS09] for the case  <span class="math">H = \\{0, 1\\}</span> .</p>

    <p class="text-gray-300"><strong>Theorem A.2</strong> (Multilinear Polynomials). Let  <span class="math">\\mathbb{F}</span>  be a finite field, H a subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\gamma := \\sum_{\\alpha \\in H} \\alpha</span> . For every  <span class="math">P \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq 1}]</span>  (i.e., for every m-variate multilinear polynomial P) it holds that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = \\begin{cases} P\\big(\\frac{\\gamma}{|H|}, \\dots, \\frac{\\gamma}{|H|}\\big) \\cdot |H|^m &amp; \\textit{ if } \\operatorname{char}(\\mathbb{F}) \\nmid |H| \\\\ \\kappa \\cdot \\gamma^m &amp; \\textit{ if } \\operatorname{char}(\\mathbb{F}) \\mid |H| \\end{cases} \\;,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\kappa</span>  is the coefficient of  <span class="math">X_1 \\cdots X_m</span>  in P.</p>

    <p class="text-gray-300"><em>Proof.</em> First suppose that  <span class="math">\\operatorname{char}(\\mathbb{F})</span>  does not divide |H|. Let  <span class="math">\\vec{\\alpha}</span>  be uniformly random in  <span class="math">H^m</span> ; in particular,  <span class="math">\\alpha_i</span>  and  <span class="math">\\alpha_j</span>  are independent for  <span class="math">i \\neq j</span> . For every monomial  <span class="math">m(\\vec{X}) = X_1^{e_1} \\cdots X_m^{e_m}</span>  with  <span class="math">e_1, \\dots, e_m \\in \\{0, 1\\}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{E}[M(\\vec{\\alpha})] = \\mathbb{E}[\\alpha_1^{e_1} \\cdots \\alpha_m^{e_m}] = \\mathbb{E}[\\alpha_1^{e_1}] \\cdots \\mathbb{E}[\\alpha_m^{e_m}] = \\mathbb{E}[\\alpha_1]^{e_1} \\cdots \\mathbb{E}[\\alpha_m]^{e_m} = M(\\mathbb{E}[\\alpha_1], \\dots, \\mathbb{E}[\\alpha_m]) \\enspace .</span>$</p>

    <p class="text-gray-300">Since P is a linear combination of monomials,  <span class="math">\\mathbb{E}[P(\\vec{\\alpha})] = P(\\mathbb{E}[\\vec{\\alpha}])</span> . Each  <span class="math">\\alpha_i</span>  is uniformly random in H, so  <span class="math">\\mathbb{E}[\\alpha_i] = \\frac{1}{|H|} \\sum_{\\alpha \\in H} \\alpha = \\frac{\\gamma}{|H|}</span> , and thus  <span class="math">P(\\mathbb{E}[\\vec{\\alpha}]) = P(\\frac{\\gamma}{|H|}, \\dots, \\frac{\\gamma}{|H|})</span> , which implies that  <span class="math">\\mathbb{E}[P(\\vec{\\alpha})] = P(\\frac{\\gamma}{|H|}, \\dots, \\frac{\\gamma}{|H|})</span> . To deduce the claimed relation, it suffices to note that  <span class="math">\\mathbb{E}[P(\\vec{\\alpha})] = \\frac{1}{|H|^m} \\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha})</span> .</p>

    <p class="text-gray-300">Next suppose that  <span class="math">\\operatorname{char}(\\mathbb{F})</span>  divides |H|. For every monomial  <span class="math">m(\\vec{X}) = X_1^{e_1} \\cdots X_m^{e_m}</span>  with  <span class="math">e_1, \\dots, e_m \\in \\{0, 1\\}</span> :</p>

    <p class="text-gray-300">&bull; if there exists  <span class="math">j \\in [m]</span>  such that  <span class="math">e_j = 0</span>  then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} M(\\vec{\\alpha}) = |H| \\sum_{\\alpha_1, \\dots, \\alpha_{j-1}, \\alpha_{j+1}, \\dots, \\alpha_m \\in H} \\alpha_1^{e_1} \\cdots \\alpha_{j-1}^{e_{j-1}} \\alpha_{j+1}^{e_{j+1}} \\cdots \\alpha_m^{e_m} = 0 .</span>$</p>

    <p class="text-gray-300">&bull; if instead  <span class="math">e_1 = \\cdots = e_m = 1</span>  then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} M(\\vec{\\alpha}) = \\sum_{\\vec{\\alpha} \\in H^m} \\prod_{i=1}^m \\alpha_i = \\prod_{i=1}^m \\sum_{\\alpha_i \\in H} \\alpha_i = \\left(\\sum_{\\alpha \\in H} \\alpha\\right)^m .</span>$</p>

    <p class="text-gray-300">The following corollary shows that for prime fields of odd size, the value of  <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha})</span>  can be computed efficiently for any  <span class="math">H \\subseteq \\mathbb{F}</span>  using at most a single query to P.</p>

    <p class="text-gray-300"><strong>Corollary A.3.</strong> Let  <span class="math">\\mathbb{F}</span>  be a prime field of odd size, H a subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\gamma := \\sum_{\\alpha \\in H} \\alpha</span> . For every  <span class="math">P \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq 1}]</span>  (i.e., for every m-variate multilinear polynomial P) it holds that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = \\begin{cases} P\\left(\\frac{\\gamma}{|H|}, \\dots, \\frac{\\gamma}{|H|}\\right) \\cdot |H|^m &amp; \\text{ if } \\operatorname{char}(\\mathbb{F}) \\nmid |H| \\\\ 0 &amp; \\text{ if } \\operatorname{char}(\\mathbb{F}) \\mid |H| \\end{cases}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Theorem A.2 directly implies both cases. If  <span class="math">\\operatorname{char}(\\mathbb{F})</span>  does not divide |H|, then the claimed value is as in the theorem. If instead  <span class="math">\\operatorname{char}(\\mathbb{F})</span>  divides |H|, then it must be the case that  <span class="math">H=\\mathbb{F}</span> , since  <span class="math">p:=\\operatorname{char}(\\mathbb{F})</span>  equals  <span class="math">|\\mathbb{F}|</span> ; in this case,  <span class="math">\\gamma=\\sum_{\\alpha\\in H}\\alpha=(p-1)p/2</span> , which is divisible by p since 2 must divide p-1 (as p is odd).</p>

      <h4 id="app-a.3.2" class="text-lg font-semibold mt-6">A.3.2 The case of subsets with group structure</h4>

    <p class="text-gray-300">In this section we show that if H is assumed to have some group structure, then few queries may suffice even for polynomials of degree greater than one. In particular, the following result shows that a single query suffices for  <span class="math">d \\leq |H|</span>  when H is a multiplicative subgroup of  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300"><strong>Lemma A.4</strong> (Multiplicative Groups). Let  <span class="math">\\mathbb{F}</span>  be a field, H a finite multiplicative subgroup of  <span class="math">\\mathbb{F}</span> , and m,d positive integers with d &lt; |H|. For every  <span class="math">P \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = P(0, \\dots, 0) \\cdot |H|^m .</span>$</p>

    <p class="text-gray-300"><strong>Remark A.5.</strong> The hypothesis that d &lt; |H| is necessary for the lemma, as we now explain. Choose  <span class="math">H = \\mathbb{K}^{\\times}</span> , where  <span class="math">\\mathbb{K}</span>  is a proper subfield of  <span class="math">\\mathbb{F}</span> , m = 1, and d = |H|. Consider the polynomial  <span class="math">X^{|H|}</span> , which has degree at least  <span class="math">d : X^{|H|}</span>  vanishes on 0; however,  <span class="math">X^{|H|}</span>  evaluates to 1 everywhere on H so that its sum over H equals  <span class="math">|H| \\neq 0</span> . (Note that if H is a multiplicative subgroup of  <span class="math">\\mathbb{F}</span>  then  <span class="math">\\operatorname{char}(\\mathbb{F}) \\nmid |H|</span>  because |H| equals  <span class="math">\\operatorname{char}(\\mathbb{F})^k - 1</span>  for some positive integer k.)</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is by induction on the number of variables m. The base case is when m=1, which we argue as follows. The group H is cyclic, because it is a (finite) multiplicative subgroup of a field; so let  <span class="math">\\omega</span>  generate H. Writing  <span class="math">P(X_1) = \\sum_{j=0}^d \\beta_j X_1^j</span>  for some  <span class="math">\\beta_0, \\ldots, \\beta_d \\in \\mathbb{F}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\alpha_1 \\in H} P(\\alpha_1) = \\sum_{i=0}^{|H|-1} P(\\omega^i) = \\sum_{i=0}^{|H|-1} \\sum_{j=0}^d \\beta_j \\omega^{ij} = \\sum_{j=0}^d \\beta_j \\sum_{i=0}^{|H|-1} (\\omega^j)^i = \\beta_0 |H| = f(0)|H| ,</span>$</p>

    <p class="text-gray-300">which proves the base case. The second-to-last equality follows from the fact that for every  <span class="math">\\gamma \\in H</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=0}^{|H|-1} \\gamma^i = \\begin{cases} |H| &amp; \\text{if } \\gamma = 1 \\\\ \\frac{\\gamma^{|H|}-1}{\\gamma-1} = 0 &amp; \\text{if } \\gamma \\neq 1 \\end{cases}.</span>$</p>

    <p class="text-gray-300">For the inductive step, assume the statement for any number of variables less than m; we now prove that it holds for m variables as well. Let  <span class="math">P_{\\alpha}</span>  denote P with the variable  <span class="math">X_1</span>  fixed to  <span class="math">\\alpha</span> . Next, apply the inductive assumption below in</p>

    <p class="text-gray-300">the second equality (with m-1 variables) and last one (with 1 variable), to obtain</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\alpha_1, \\dots, \\alpha_m) = \\sum_{\\alpha_1 \\in H} \\sum_{(\\alpha_2, \\dots, \\alpha_m) \\in H^{m-1}} P_{\\alpha_1}(\\alpha_2, \\dots, \\alpha_m)</span>$</p>

    <p class="text-gray-300"><span class="math">$= |H|^{m-1} \\sum_{\\alpha_1 \\in H} P_{\\alpha_1}(0^{m-1})</span>$</p>

    <p class="text-gray-300"><span class="math">$= |H|^{m-1} \\sum_{\\alpha_1 \\in H} P(\\alpha_1, 0, \\dots, 0)</span>$</p>

    <p class="text-gray-300"><span class="math">$= |H|^m P(0, \\dots, 0) ,</span>$</p>

    <p class="text-gray-300">as claimed.</p>

    <p class="text-gray-300"><strong>Lemma A.6</strong> (Additive Groups). Let  <span class="math">\\mathbb{F}</span>  be a field, H a finite additive subgroup of  <span class="math">\\mathbb{F}</span> , and m,d positive integers with d &lt; |H|. For every  <span class="math">P \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = \\kappa \\cdot a_0^m \\ ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\kappa</span>  is the coefficient of  <span class="math">X_1^{|H|-1} \\cdots X_m^{|H|-1}</span>  in P, and  <span class="math">a_0</span>  is the (formal) linear term of the subspace polynomial  <span class="math">\\prod_{h \\in H} (X - h)</span> . In particular, if P has total degree strictly less than m(|H| - 1), then the above sum evaluates to 0.</p>

    <p class="text-gray-300"><em>Proof.</em> Without loss of generality, let d:=|H|-1. The proof is by induction on the number of variables m. When m=1, we have that  <span class="math">P(X)=\\sum_{j=0}^d\\beta_jX^j</span>  for some  <span class="math">\\beta_0,\\ldots,\\beta_d\\in\\mathbb{F}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\alpha \\in H} P(\\alpha) = \\sum_{\\alpha \\in H} \\sum_{j=0}^{d} \\beta_j \\alpha^j = \\sum_{j=0}^{d} \\beta_j \\sum_{\\alpha \\in H} \\alpha^j = \\beta_d a_0</span>$</p>

    <p class="text-gray-300">where the final equality follows by [BC99, Theorem 1], and the fact that d = |H| - 1.</p>

    <p class="text-gray-300">For the inductive step, assume the statement for m-1 variables; we now prove that it holds for m variables as well. Let  <span class="math">P_{\\alpha}</span>  denote P with the variable  <span class="math">X_1</span>  fixed to  <span class="math">\\alpha</span> ; we have  <span class="math">P_{\\alpha}(X_2,\\ldots,X_m)=\\sum_{\\vec{e}\\in\\{0,\\ldots,d\\}^m}\\beta_{\\vec{e}}\\cdot\\alpha^{e_1}X_2^{e_2}\\ldots X_m^{e_m}</span> . Next, apply the inductive hypothesis below in the second equality (with m-1 variables) to obtain</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\vec{\\alpha} \\in H^m} P(\\alpha_1, \\dots, \\alpha_m) = \\sum_{\\alpha_1 \\in H} \\sum_{(\\alpha_2, \\dots, \\alpha_m) \\in H^{m-1}} P_{\\alpha_1}(\\alpha_2, \\dots, \\alpha_m) = \\sum_{\\alpha_1 \\in H} a_0^{m-1} \\kappa(\\alpha_1) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\kappa(X_1) := \\sum_{j=0}^d \\beta_{(j,d,\\dots,d)} X_1^j</span> . Applying the hypothesis again for 1 variable yields</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\alpha_1 \\in H} a_0^{m-1} \\kappa(\\alpha_1) = a_0^m \\cdot \\beta_{(d,\\dots,d)} ,</span>$</p>

    <p class="text-gray-300">and the claim follows.</p>

    <p class="text-gray-300">In this section we re-prove Theorem 7.2 using sum-product circuits. In particular we reduce  <span class="math">\\mathcal{R}_{O3SAT}</span>  to  <span class="math">\\mathcal{R}_{SPCS}</span>  by constructing a sum-product circuit whose satisfaction encodes oracle 3-satisfiability. The reduction then yields Theorem 7.2 by the perfect zero knowledge IPCP for  <span class="math">\\mathcal{R}_{SPCS}</span>  given in Theorem 9.2.</p>

    <p class="text-gray-300"><strong>Lemma B.1</strong> ( <span class="math">\\mathcal{R}_{O3SAT} \\to \\mathcal{R}_{SPCS}</span> ). Let H be an extension field of  <span class="math">\\mathbb{F}_2</span>  with  <span class="math">|H| \\geq 8</span> , and  <span class="math">\\mathbb{F}</span>  an extension field of H. There exist polynomial-time functions f, g such that for every  <span class="math">r, s \\in \\mathbb{N}</span>  and boolean formula  <span class="math">B : \\{0, 1\\}^{r+3s+3} \\to \\{0, 1\\}</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if  <span class="math">A: \\{0,1\\}^s \\to \\{0,1\\}</span>  is such that  <span class="math">((r,s,B),A) \\in \\mathcal{R}_{O3SAT}</span>  then</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\vec{x},\\vec{y} \\leftarrow \\mathbb{F}^{r+3s}} \\left[ \\left( (f(r,s,B,\\vec{x},\\vec{y}),0,\\bot),g(A) \\right) \\in \\mathscr{R}_{\\mathrm{SPCS}} \\right] = 1 \\ ;</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if  <span class="math">(r, s, B) \\notin \\mathcal{L}(\\mathcal{R}_{O3SAT})</span>  then</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\vec{x}, \\vec{y} \\leftarrow \\mathbb{F}^{r+3s}} \\left[ \\left( f(r, s, B, \\vec{x}, \\vec{y}), 0, \\bot \\right) \\in \\mathcal{L}(\\mathcal{R}_{SPCS}) \\right] \\le \\frac{r+3s}{|\\mathbb{F}|}.</span>$</p>

    <p class="text-gray-300">Moreover,  <span class="math">f(r, s, B, \\vec{x}, \\vec{y})</span>  is a sum-product circuit  <span class="math">(\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, G, C)</span>  with  <span class="math">\\delta_{\\mathsf{in}} = O(|B| \\cdot |H|)</span> ,  <span class="math">\\delta_{\\mathsf{lf}} = O(|H|)</span> ,  <span class="math">|V(G)| = \\Theta(1)</span> , arity  <span class="math">G(G) = O((r+s)/\\log|H|)</span> ,  <span class="math">|V(G)| = \\Theta(1)</span> , width  <span class="math">G(G) = \\Theta(1)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Recall that in Section 7 we reduced checking  <span class="math">((B, r, s), A) \\in \\mathcal{R}_{O3SAT}</span>  to checking whether the following expression is the zero polynomial, for some polynomials  <span class="math">g_1, g_2</span>  which depend on the low-degree extension of A.</p>

    <p class="text-gray-300"><span class="math">$F(\\vec{X}, \\vec{Y}) = \\sum_{\\substack{\\vec{\\alpha} \\in H^{m_1} \\\\ \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3 \\in H^{m_2}}} g_1(\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)) \\prod_{i=1}^{r+3s} (1 + (X_i - 1)\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)_i) + g_2(\\hat{\\gamma}_2(\\vec{\\beta}_1)) \\prod_{i=1}^{r+3s} (1 + (Y_i - 1)\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3)_i) .</span>$</p>

    <p class="text-gray-300">Fix  <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r+3s}</span> . We construct a sum-product circuit  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathsf{in}}, \\delta_{\\mathsf{lf}}, G, C)</span>  whose value with explicit input  <span class="math">\\perp</span>  (the empty map) and auxiliary input  <span class="math">\\hat{A}</span>  is  <span class="math">F(\\vec{x}, \\vec{y})</span> . Fix  <span class="math">\\delta_{\\mathsf{in}} := O(|B| \\cdot |H|)</span>  and  <span class="math">\\delta_{\\mathsf{lf}} := |H|</span> . Let  <span class="math">G = (V, E, \\sigma, \\rho)</span>  be the ari-graph defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} V &amp;:= \\{v, u\\} \\ , \\\\ E &amp;:= \\{e_1, e_2, e_3 = (v, u)\\} \\ , \\\\ \\rho_e &amp;:= \\varnothing \\quad \\text{for all } e \\in E \\ , \\\\ \\sigma_{e_i} &amp;:= m_1 + (i-1)m_2 + [m_2] \\quad \\text{ for } i \\in \\{1, 2, 3\\} \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">The vertex label C is given by</p>

    <p class="text-gray-300"><span class="math">$C_v := \\left( \\hat{B}(\\vec{Y}, Z_1, Z_2, Z_3) \\cdot \\prod_{i=1}^{r+3s+3} (1 + (x_i - 1)) \\hat{\\gamma}(\\vec{Y})_i \\right) + \\left( Z_1(1 - Z_1) \\cdot \\prod_{i=1}^{r+3s} (1 + (y_i - 1)) \\hat{\\gamma}(\\vec{Y})_i \\right) ,</span>$</p>

    <p class="text-gray-300">where the variables  <span class="math">Z_1, Z_2, Z_3</span>  correspond to the edges  <span class="math">e_1, e_2, e_3</span>  respectively.</p>

    <p class="text-gray-300">From the construction of the circuit, if  <span class="math">\\mathbf{z}_u = \\hat{A}(\\hat{\\gamma}_2(\\cdot))</span>  then  <span class="math">\\mathcal{C}[\\mathbf{x},\\mathbf{z}] = F(\\vec{x},\\vec{y})</span> . The stated parameters follow easily. If  <span class="math">((r,s,B),A) \\in \\mathscr{R}_{\\mathrm{O3SAT}}</span>  then  <span class="math">F(\\vec{X},\\vec{Y})</span>  is the zero polynomial. Hence  <span class="math">F(\\vec{x},\\vec{y}) = 0</span>  for all  <span class="math">\\vec{x},\\vec{y} \\in \\mathbb{F}^{r+3s}</span> . We conclude that if  <span class="math">((r,s,B),A) \\in \\mathscr{R}_{\\mathrm{O3SAT}}</span>  then  <span class="math">((\\mathcal{C},0,\\mathbf{x}),\\mathbf{z}) \\in \\mathscr{R}_{\\mathrm{SPCS}}</span>  with probability 1 over the choice of  <span class="math">\\vec{x},\\vec{y}</span> .</p>

    <p class="text-gray-300">If  <span class="math">(r, s, B) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span>  then there is no choice of  <span class="math">\\hat{A}</span>  such that  <span class="math">F(\\vec{X}, \\vec{Y})</span>  is the zero polynomial. Thus, for any choice of  <span class="math">\\hat{A}</span> ,  <span class="math">F(\\vec{x}, \\vec{y}) = 0</span>  with probability at most  <span class="math">(r + 3s)/|\\mathbb{F}|</span>  over the choice of  <span class="math">\\vec{x}, \\vec{y}</span> . We conclude that if  <span class="math">(r, s, B) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span>  then  <span class="math">(\\mathcal{C}, 0, \\mathbf{x}) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span>  with probability at most  <span class="math">(r + 3s)/|\\mathbb{F}|</span> .</p>

    <p class="text-gray-300">Proof of Theorem 7.2. The protocol proceeds as follows. The prover and verifier determinstically (non-interactively) choose an extension field H of  <span class="math">\\mathbb{F}_2</span>  and an extension field  <span class="math">\\mathbb{F}</span>  of H such that  <span class="math">|\\mathbb{F}| = \\text{poly}(|H|)</span>  and  <span class="math">|H| = \\text{poly}(|B|, \\log b)</span> . The verifier chooses  <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r+3s}</span>  uniformly at random, and sends them to the prover; the prover and verifier construct the sum-product circuit  <span class="math">\\mathcal{C} := f(r, s, B, \\vec{x}, \\vec{y})</span> , and then engage in the protocol of Theorem 9.2 on the input  <span class="math">(\\mathcal{C}, 0, \\bot)</span> , with auxiliary input g(A).</p>

    <p class="text-gray-300">If  <span class="math">((B,r,s),A) \\in \\mathcal{R}_{\\mathrm{O3SAT}}</span>  then  <span class="math">((\\mathcal{C},0,\\perp),g(A)) \\in \\mathcal{R}_{\\mathrm{SPCS}}</span>  with probability 1, and so the verifier will accept with probability 1. If  <span class="math">(B,r,s) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span>  then  <span class="math">(\\mathcal{C},0,\\perp) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span>  with probability at most  <span class="math">(r+3s)/|\\mathbb{F}|</span> . Also, if  <span class="math">(\\mathcal{C},0,\\perp) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span> , then the verifier accepts with probability at most  <span class="math">O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{lf}}\\cdot\\mathrm{in}(G)\\cdot(\\mathrm{arity}(G)+\\alpha)\\cdot|V(G)|/|\\mathbb{F}|) = O(\\frac{|H|^2\\cdot|B|\\cdot(r+s+\\log b)}{|\\mathbb{F}|\\cdot\\log|H|})</span> . By our choices of the cardinality of H and  <span class="math">\\mathbb{F}</span> , both of these probabilities are O(1/|B|) so that, by a union bound, the probability that the verifier accepts is also O(1/|B|), which is less than 1/2.</p>

    <p class="text-gray-300">The protocol as stated is not an IPCP because there is a round of interaction before the oracle is sent. However, observe that the oracle does not depend on the choice of  <span class="math">\\vec{x}</span> ,  <span class="math">\\vec{y}</span> , and therefore can be sent before this interaction.</p>

    <p class="text-gray-300">[AH91] William Aiello and Johan Hastad. &quot;Statistical Zero-Knowledge Languages can be Recognized in Two Rounds&quot;. &#730; In: <em>Journal of Computer and System Sciences</em> 42.3 (1991). Preliminary version appeared in FOCS '87., pp. 327&ndash; 345. [ALMSS98] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. &quot;Proof verification and the hardness of approximation problems&quot;. In: <em>Journal of the ACM</em> 45.3 (1998). Preliminary version in FOCS '92., pp. 501&ndash;555. [AS03] Sanjeev Arora and Madhu Sudan. &quot;Improved Low-Degree Testing and its Applications&quot;. In: <em>Combinatorica</em> 23.3 (2003). Preliminary version appeared in STOC '97., pp. 365&ndash;426. [AS98] Sanjeev Arora and Shmuel Safra. &quot;Probabilistic checking of proofs: a new characterization of NP&quot;. In: <em>Journal of the ACM</em> 45.1 (1998). Preliminary version in FOCS '92., pp. 70&ndash;122. [AW09] Scott Aaronson and Avi Wigderson. &quot;Algebrization: A New Barrier in Complexity Theory&quot;. In: <em>ACM Transactions on Computation Theory</em> 1.1 (2009), 2:1&ndash;2:54. [BC12] Nir Bitansky and Alessandro Chiesa. &quot;Succinct Arguments from Multi-Prover Interactive Proofs and their Efficiency Benefits&quot;. In: <em>Proceedings of the 32nd Annual International Cryptology Conference</em>. CRYPTO '12. 2012, pp. 255&ndash;272. [BC99] Nigel P. Byott and Robin J. Chapman. &quot;Power Sums over Finite Subspaces of a Field&quot;. In: <em>Finite Fields and Their Applications</em> 5.3 (July 1999), pp. 254&ndash;265. [BCFGRS16] Eli Ben-Sasson, Alessandro Chiesa, Michael A. Forbes, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. <em>On Probabilistic Checking in Perfect Zero Knowledge</em>. Cryptology ePrint Archive, Report 2016/988. 2016. [BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. &quot;Interactive oracle proofs&quot;. In: <em>Proceedings of the 14th Theory of Cryptography Conference</em>. TCC '16-B. 2016, pp. 31&ndash;60. [BFL91] Laszl &acute; o Babai, Lance Fortnow, and Carsten Lund. &quot;Non-Deterministic Exponential Time has Two-Prover Inter- &acute; active Protocols&quot;. In: <em>Computational Complexity</em> 1 (1991). Preliminary version appeared in FOCS '90., pp. 3&ndash; 40. [BFLS91] Laszl &acute; o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. &quot;Checking computations in polylogarithmic &acute; time&quot;. In: <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>. STOC '91. 1991, pp. 21&ndash;32. [BGGHKMR88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan Hastad, Joe Kilian, Silvio Micali, and Phillip &#730; Rogaway. &quot;Everything Provable is Provable in Zero-Knowledge&quot;. In: <em>Proceedings of the 8th Annual International Cryptology Conference</em>. CRYPTO '89. 1988, pp. 37&ndash;56. [BGKW88] Michael Ben-Or, Shafi Goldwasser, Joe Kilian, and Avi Wigderson. &quot;Multi-prover interactive proofs: how to remove intractability assumptions&quot;. In: <em>Proceedings of the 20th Annual ACM Symposium on Theory of Computing</em>. STOC '88. 1988, pp. 113&ndash;131. [BM88] Laszl &acute; o Babai and Shlomo Moran. &quot;Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of &acute; Complexity Classes&quot;. In: <em>Journal of Computer and System Sciences</em> 36.2 (1988), pp. 254&ndash;276. [BRV17] Itay Berman, Ron D. Rothblum, and Vinod Vaikuntanathan. <em>Zero-Knowledge Proofs of Proximity</em>. Cryptology ePrint Archive, Report 2017/114. 2017. [BW04] Andrej Bogdanov and Hoeteck Wee. &quot;A Stateful Implementation of a Random Function Supporting Parity Queries over Hypercubes&quot;. In: <em>Proceedings of the 7th International Workshop on Approximation Algorithms for Combinatorial Optimization Problems, and of the 8th International Workshop on Randomization and Computation</em>. APPROX-RANDOM '04. 2004, pp. 298&ndash;309. [Bab85] Laszl &acute; o Babai. &quot;Trading group theory for randomness&quot;. In: &acute; <em>Proceedings of the 17th Annual ACM Symposium on Theory of Computing</em>. STOC '85. 1985, pp. 421&ndash;429. [CD98] Ronald Cramer and Ivan Damgard. &quot;Zero-Knowledge Proofs for Finite Field Arithmetic; or: Can Zero-Knowledge &#730; be for Free?&quot; In: <em>Proceedings of the 18th Annual International Cryptology Conference</em>. CRYPTO '98. 1998, pp. 424&ndash;441. [CKLR11] Kai-Min Chung, Yael Kalai, Feng-Hao Liu, and Ran Raz. &quot;Memory Delegation&quot;. In: <em>Proceeding of the 31st</em></p>

    <p class="text-gray-300"><em>Annual Cryptology Conference</em>. CRYPTO '10. 2011, pp. 151&ndash;168.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. &quot;Practical Verified Computation with Streaming Interactive Proofs&quot;. In: <em>Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</em>. ITCS '12. 2012, pp. 90&ndash;112.</p></li>
      <li><p class="text-gray-300">[CRR13] Ran Canetti, Ben Riva, and Guy N. Rothblum. &quot;Refereed delegation of computation&quot;. In: <em>Information and Computation</em> 226 (2013), pp. 16&ndash;36.</p></li>
      <li><p class="text-gray-300">[DFKNS92] Cynthia Dwork, Uriel Feige, Joe Kilian, Moni Naor, and Shmuel Safra. &quot;Low Communication 2-Prover Zero-Knowledge Proofs for NP&quot;. In: <em>Proceedings of the 11th Annual International Cryptology Conference</em>. CRYPTO '92. 1992, pp. 215&ndash;227.</p></li>
      <li><p class="text-gray-300">[DS98] Cynthia Dwork and Amit Sahai. &quot;Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints&quot;. In: <em>Proceedings of the 18th Annual International Cryptology Conference</em>. CRYPTO '98. 1998, pp. 442&ndash;457.</p></li>
      <li><p class="text-gray-300">[FGLSS91] Uriel Feige, Shafi Goldwasser, Laszl &acute; o Lov &acute; asz, Shmuel Safra, and Mario Szegedy. &quot;Approximating clique is &acute; almost NP-complete (preliminary version)&quot;. In: <em>Proceedings of the 32nd Annual Symposium on Foundations of Computer Science</em>. SFCS '91. 1991, pp. 2&ndash;12.</p></li>
      <li><p class="text-gray-300">[FGLSS96] Uriel Feige, Shafi Goldwasser, Laszlo Lovasz, Shmuel Safra, and Mario Szegedy. &quot;Interactive proofs and the &acute; hardness of approximating cliques&quot;. In: <em>Journal of the ACM</em> 43.2 (1996). Preliminary version in FOCS '91., pp. 268&ndash;292.</p></li>
      <li><p class="text-gray-300">[FRS88] Lance Fortnow, John Rompel, and Michael Sipser. &quot;On the Power of Multi-Prover Interactive Protocols&quot;. In: <em>Theoretical Computer Science</em>. 1988, pp. 156&ndash;161.</p></li>
      <li><p class="text-gray-300">[FS86] Amos Fiat and Adi Shamir. &quot;How to prove yourself: practical solutions to identification and signature problems&quot;. In: <em>Proceedings of the 6th Annual International Cryptology Conference</em>. CRYPTO '86. 1986, pp. 186&ndash;194.</p></li>
      <li><p class="text-gray-300">[FS89] Uriel Feige and Adi Shamir. &quot;Zero Knowledge Proofs of Knowledge in Two Rounds&quot;. In: <em>Proceedings of the 9th Annual International Cryptology Conference</em>. CRYPTO '89. 1989, pp. 526&ndash;544.</p></li>
      <li><p class="text-gray-300">[For87] Lance Fortnow. &quot;The Complexity of Perfect Zero-Knowledge (Extended Abstract)&quot;. In: <em>Proceedings of the 19th Annual ACM Symposium on Theory of Computing</em>. STOC '87. 1987, pp. 204&ndash;209.</p></li>
      <li><p class="text-gray-300">[GIMS10] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. &quot;Interactive locking, zero-knowledge PCPs, and unconditional cryptography&quot;. In: <em>Proceedings of the 30th Annual Conference on Advances in Cryptology</em>. CRYPTO'10. 2010, pp. 173&ndash;190.</p></li>
      <li><p class="text-gray-300">[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. &quot;Delegating Computation: Interactive Proofs for Muggles&quot;. In: <em>Journal of the ACM</em> 62.4 (2015), 27:1&ndash;27:64.</p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. &quot;The knowledge complexity of interactive proof systems&quot;. In: <em>SIAM Journal on Computing</em> 18.1 (1989). Preliminary version appeared in STOC '85., pp. 186&ndash;208.</p></li>
      <li><p class="text-gray-300">[GR15] Tom Gur and Ron D. Rothblum. &quot;Non-Interactive Proofs of Proximity&quot;. In: <em>Proceedings of the 6th Innovations in Theoretical Computer Science Conference</em>. ITCS '15. 2015, pp. 133&ndash;142.</p></li>
      <li><p class="text-gray-300">[GS06] Oded Goldreich and Madhu Sudan. &quot;Locally testable codes and PCPs of almost-linear length&quot;. In: <em>Journal of the ACM</em> 53 (4 2006). Preliminary version in STOC '02., pp. 558&ndash;655.</p></li>
      <li><p class="text-gray-300">[Gol01] Oded Goldreich. <em>Foundations of Cryptography: Volume 1</em>. Cambridge University Press, 2001. ISBN: 978-0-521- 03536-1.</p></li>
      <li><p class="text-gray-300">[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. <em>On Zero-Knowledge PCPs: Limitations, Simplifications, and Applications</em>. Available at <a href="http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf" target="_blank" rel="noopener noreferrer">http://www.cs.virginia.edu/&tilde;mohammad/files/</a> <a href="http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf" target="_blank" rel="noopener noreferrer">papers/ZKPCPs-Full.pdf</a>. 2015.</p></li>
      <li><p class="text-gray-300">[IY87] Russell Impagliazzo and Moti Yung. &quot;Direct Minimum-Knowledge Computations&quot;. In: <em>Proceedings of the 7th Annual International Cryptology Conference</em>. CRYPTO '87. 1987, pp. 40&ndash;51.</p></li>
      <li><p class="text-gray-300">[JKRS09] Ali Juma, Valentine Kabanets, Charles Rackoff, and Amir Shpilka. &quot;The Black-Box Query Complexity of Polynomial Summation&quot;. In: <em>Computational Complexity</em> 18.1 (2009), pp. 59&ndash;79.</p></li>
      <li><p class="text-gray-300">[KPT97] Joe Kilian, Erez Petrank, and Gabor Tardos. &quot;Probabilistically checkable proofs with zero knowledge&quot;. In: &acute; <em>Proceedings of the 29th Annual ACM Symposium on Theory of Computing</em>. STOC '97. 1997, pp. 496&ndash;505.</p></li>
      <li><p class="text-gray-300">[KR08] Yael Kalai and Ran Raz. &quot;Interactive PCP&quot;. In: <em>Proceedings of the 35th International Colloquium on Automata, Languages and Programming</em>. ICALP '08. 2008, pp. 536&ndash;547.</p></li>
      <li><p class="text-gray-300">[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. &quot;How to delegate computations: the power of no-signaling proofs&quot;. In: <em>Proceedings of the 46th Annual ACM Symposium on Theory of Computing</em>. STOC '14. 2014, pp. 485&ndash;494.</p></li>
      <li><p class="text-gray-300">[Kil92] Joe Kilian. &quot;A note on efficient zero-knowledge proofs and arguments&quot;. In: <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>. STOC '92. 1992, pp. 723&ndash;732.</p></li>
      <li><p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. &quot;Algebraic Methods for Interactive Proof Systems&quot;. In: <em>Journal of the ACM</em> 39.4 (1992), pp. 859&ndash;868.</p></li>
      <li><p class="text-gray-300">[Mei13] Or Meir. &quot;IP = PSPACE Using Error-Correcting Codes&quot;. In: <em>SIAM Journal on Computing</em> 42.1 (2013), pp. 380&ndash; 403.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. &quot;Computationally Sound Proofs&quot;. In: <em>SIAM Journal on Computing</em> 30.4 (2000). Preliminary version appeared in FOCS '94., pp. 1253&ndash;1298.</p></li>
      <li><p class="text-gray-300">[OW93] Rafail Ostrovsky and Avi Wigderson. &quot;One-Way Functions are Essential for Non-Trivial Zero-Knowledge&quot;. In: <em>Proceedings of the 2nd Israel Symposium on Theory of Computing Systems</em>. ISTCS '93. 1993, pp. 3&ndash;17.</p></li>
      <li><p class="text-gray-300">[Ost91] Rafail Ostrovsky. &quot;One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs&quot;. In: <em>Proceedings of the 6th Annual Structure in Complexity Theory Conference</em>. CoCo '91. 1991, pp. 133&ndash;138.</p></li>
      <li><p class="text-gray-300">[RG17] Guy N. Rothblum and Oded Goldreich. <em>Simple doubly-efficient interactive proof systems for locally-characterizable sets</em>. ECCC TR17-018. 2017.</p></li>
      <li><p class="text-gray-300">[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. &quot;Constant-Round Interactive Proofs for Delegating Computation&quot;. In: <em>Proceedings of the 48th ACM Symposium on the Theory of Computing</em>. STOC '16. 2016, pp. 49&ndash; 62.</p></li>
      <li><p class="text-gray-300">[RS05] Ran Raz and Amir Shpilka. &quot;Deterministic polynomial identity testing in non-commutative models&quot;. In: <em>Computational Complexity</em> 14.1 (2005). Preliminary version appeared in CCC '04., pp. 1&ndash;19.</p></li>
      <li><p class="text-gray-300">[RS96] Ronitt Rubinfeld and Madhu Sudan. &quot;Robust Characterizations of Polynomials with Applications to Program Testing&quot;. In: <em>SIAM Journal on Computing</em> 25.2 (1996), pp. 252&ndash;271.</p></li>
      <li><p class="text-gray-300">[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. &quot;Interactive proofs of proximity: delegating computation in sublinear time&quot;. In: <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>. STOC '13. 2013, pp. 793&ndash;802.</p></li>
      <li><p class="text-gray-300">[Sha92] Adi Shamir. &quot;IP = PSPACE&quot;. In: <em>Journal of the ACM</em> 39.4 (1992), pp. 869&ndash;877.</p></li>
      <li><p class="text-gray-300">[She92] Alexander Shen. &quot;IP = PSPACE: Simplified Proof&quot;. In: <em>Journal of the ACM</em> 39.4 (1992), pp. 878&ndash;880.</p></li>
      <li><p class="text-gray-300">[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. &quot;Verifiable Computation with Massively Parallel Interactive Proofs&quot;. In: <em>CoRR</em> abs/1202.1350 (2012).</p></li>
      <li><p class="text-gray-300">[TV07] Luca Trevisan and Salil Vadhan. &quot;Pseudorandomness and Average-Case Complexity Via Uniform Reductions&quot;. In: <em>Computational Complexity</em> 16.4 (2007), pp. 331&ndash;364.</p></li>
      <li><p class="text-gray-300">[Tha13] Justin Thaler. &quot;Time-Optimal Interactive Proofs for Circuit Evaluation&quot;. In: <em>Proceedings of the 33rd Annual International Cryptology Conference</em>. CRYPTO '13. 2013, pp. 71&ndash;89.</p></li>
      <li><p class="text-gray-300">[Tha15] Justin Thaler. <em>A Note on the GKR Protocol</em>. <a href="http://people.cs.georgetown.edu/jthaler/GKRNote.pdf" target="_blank" rel="noopener noreferrer">http : / / people . cs . georgetown . edu / jthaler /</a> <a href="http://people.cs.georgetown.edu/jthaler/GKRNote.pdf" target="_blank" rel="noopener noreferrer">GKRNote.pdf</a>. 2015.</p></li>
      <li><p class="text-gray-300">[WHGSW16] Riad S. Wahby, Max Howald, Siddharth J. Garg, Abhi Shelat, and Michael Walfish. &quot;Verifiable ASICs&quot;. In: <em>Proceedings of the 37th IEEE Symposium on Security and Privacy</em>. S&amp;P '16. 2016, pp. 759&ndash;778.</p></li>
      <li><p class="text-gray-300">[WJBSTWW17] Riad S. Wahby, Ye Ji, Andrew J. Blumberg, Abhi Shelat, Justin Thaler, Michael Walfish, and Thomas Wies. <em>Full accounting for verifiable outsourcing</em>. Cryptology ePrint Archive, Report 2017/242. 2017.</p></li>
    </ul>

`;
---

<BaseLayout title="A Zero Knowledge Sumcheck and its Applications (2017/305)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/305
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Prior techniques for achieving zero knowledge</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Our goal: algebraic techniques for zero knowledge</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Main result: a zero knowledge sumcheck</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Applications: delegating computation in zero knowledge</a></li>
            <li><a href="#sec-1.4.1" class="hover:text-white">Delegating non-deterministic exponential time</a></li>
            <li><a href="#sec-1.4.2" class="hover:text-white">Delegating polynomial space</a></li>
            <li><a href="#sec-1.4.3" class="hover:text-white">Delegating low-depth circuits</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Techniques</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">An algebraic approach for zero knowledge in the BFL protocol</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Algebraic commitments from algebraic query complexity lower bounds</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">A zero knowledge sumcheck protocol</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Challenges: handling recursion</a></li>
            <li><a href="#sec-2.5" class="hover:text-white">Sum-product circuits</a></li>
            <li><a href="#sec-2.5.1" class="hover:text-white">Delegating the evaluation of a sum-product circuit</a></li>
            <li><a href="#sec-2.5.2" class="hover:text-white">Achieving zero knowledge</a></li>
          </ol>
        </li>
        <li><a href="#sec-3" class="hover:text-white">Roadmap</a></li>
        <li>
          <a href="#sec-4" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">Basic notations</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">Sampling partial sums of random low-degree polynomials</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Interactive probabilistically checkable proofs</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Zero knowledge for Interactive PCPs</a></li>
            <li><a href="#sec-4.5" class="hover:text-white">Sumcheck protocol and its zero knowledge variant</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Algebraic query complexity of polynomial summation</a></li>
        <li>
          <a href="#sec-6" class="hover:text-white">Zero knowledge sumcheck from algebraic query lower bounds</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-6.1" class="hover:text-white">Step 1</a></li>
            <li><a href="#sec-6.2" class="hover:text-white">Step 2</a></li>
          </ol>
        </li>
        <li><a href="#sec-7" class="hover:text-white">Zero knowledge for non-deterministic exponential time</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">Delegating sum-product computations</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Intuition for definition</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Sum-product formulas</a></li>
            <li><a href="#sec-8.2.1" class="hover:text-white">Formal definition</a></li>
            <li><a href="#sec-8.2.2" class="hover:text-white">Delegating sum-product formula evaluation problems</a></li>
            <li><a href="#sec-8.2.3" class="hover:text-white">Delegating sum-product formula satisfaction problems</a></li>
            <li><a href="#sec-8.3" class="hover:text-white">Sum-product circuits</a></li>
            <li><a href="#sec-8.3.1" class="hover:text-white">Formal definition</a></li>
            <li><a href="#sec-8.3.2" class="hover:text-white">Delegating sum-product circuit evaluation problems</a></li>
            <li><a href="#sec-8.3.3" class="hover:text-white">Delegating sum-product circuit satisfaction problems</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-9" class="hover:text-white">Zero knowledge sum-product protocols</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-9.1" class="hover:text-white">The case of sum-product evaluation</a></li>
            <li><a href="#sec-9.2" class="hover:text-white">The case of sum-product satisfaction</a></li>
          </ol>
        </li>
        <li><a href="#sec-10" class="hover:text-white">Zero knowledge for polynomial space</a></li>
        <li>
          <a href="#sec-11" class="hover:text-white">Zero knowledge for the evaluation of low-depth circuits</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-11.1" class="hover:text-white">Notations for layered arithmetic circuits</a></li>
            <li><a href="#sec-11.2" class="hover:text-white">Sum-product subcircuits and oracle inputs</a></li>
            <li><a href="#sec-11.3" class="hover:text-white">Sum-product subcircuits for layered arithmetic circuits</a></li>
            <li><a href="#sec-11.4" class="hover:text-white">Sum-product subcircuits for small-space Turing machines</a></li>
            <li><a href="#sec-11.5" class="hover:text-white">Proof of Theorem 11.1</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a.1" class="hover:text-white">Proof of Theorem 5.1</a></li>
        <li><a href="#app-a.2" class="hover:text-white">Proof of Corollary 5.3</a></li>
        <li><a href="#app-a.3" class="hover:text-white">Upper bounds</a></li>
        <li><a href="#app-a.3.1" class="hover:text-white">The case of multilinear polynomials</a></li>
        <li><a href="#app-a.3.2" class="hover:text-white">The case of subsets with group structure</a></li>
        <li><a href="#app-b" class="hover:text-white">Proof of Theorem 7.2 via sum-product circuits</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-zero-knowledge-sumcheck-and-its-applications-2017" />
  </article>
</BaseLayout>
