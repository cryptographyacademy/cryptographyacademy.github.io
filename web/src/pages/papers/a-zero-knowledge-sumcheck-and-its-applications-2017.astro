---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2017/305';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Zero Knowledge Sumcheck and its Applications';
const AUTHORS_HTML = 'Alessandro Chiesa, Michael A.  Forbes, Nicholas Spooner';

const CONTENT = `    <p class="text-gray-300">Alessandro Chiesa alexch@berkeley.edu UC Berkeley Michael A. Forbes miforbes@csail.mit.edu Simons Institute for the Theory of Computing Nicholas Spooner nick.spooner@berkeley.edu University of Toronto and UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Many seminal results in Interactive Proofs (IPs) use algebraic techniques based on low-degree polynomials, the study of which is pervasive in theoretical computer science. Unfortunately, known methods for endowing such proofs with zero knowledge guarantees do not retain this rich algebraic structure.</p>

    <p class="text-gray-300">In this work, we develop algebraic techniques for obtaining zero knowledge variants of proof protocols in a way that leverages and preserves their algebraic structure. Our constructions achieve unconditional (perfect) zero knowledge in the Interactive Probabilistically Checkable Proof (IPCP) model of Kalai and Raz <em>[x13]</em> (the prover first sends a PCP oracle, then the prover and verifier engage in an Interactive Proof in which the verifier may query the PCP).</p>

    <p class="text-gray-300">Our main result is a zero knowledge variant of the sumcheck protocol <em>[x11]</em> in the IPCP model. The sumcheck protocol is a key building block in many IPs, including the protocol for polynomial-space computation due to Shamir <em>[x15]</em>, and the protocol for parallel computation due to Goldwasser, Kalai, and Rothblum <em>[x6]</em>. A core component of our result is an algebraic commitment scheme, whose hiding property is guaranteed by algebraic query complexity lower bounds <em>[x2, x10]</em>. This commitment scheme can then be used to considerably strengthen our previous work <em>[x3]</em> that gives a sumcheck protocol with much weaker zero knowledge guarantees, itself using algebraic techniques based on algorithms for polynomial identity testing <em>[x12, x4]</em>.</p>

    <p class="text-gray-300">We demonstrate the applicability of our techniques by deriving zero knowledge variants of well-known protocols based on algebraic techniques. First, we construct zero knowledge IPCPs for <span class="math">\\mathbf{NEXP}</span> starting with the Multi-prover Interactive Proofs of Babai, Fortnow, and Lund <em>[x2]</em>. This result is a direct application of our zero knowledge sumcheck and our algebraic commitment scheme, augmented with the use of ‘randomized’ low-degree extensions.</p>

    <p class="text-gray-300">We also construct protocols in a more restricted model where the prover and verifier engage in a standard Interactive Proof with oracle access to a uniformly random low-degree polynomial (soundness holds with respect to <em>any</em> oracle). In this setting we achieve zero knowledge variants of the protocols of Shamir and of Goldwasser, Kalai, and Rothblum.</p>

    <p class="text-gray-300">Keywords: zero knowledge; sumcheck; algebraic query complexity; probabilistically checkable and interactive proofs</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1 Prior techniques for achieving zero knowledge  3 1.2 Our goal: algebraic techniques for zero knowledge  4 1.3 Main result: a zero knowledge sumcheck  4 1.4 Applications: delegating computation in zero knowledge  6</p>

    <p class="text-gray-300">2  Techniques  8 2.1 An algebraic approach for zero knowledge in the BFL protocol  8 2.2 Algebraic commitments from algebraic query complexity lower bounds  9 2.3 A zero knowledge sumcheck protocol  11 2.4 Challenges: handling recursion  12 2.5 Sum-product circuits  13</p>

    <p class="text-gray-300">3  Roadmap  15</p>

    <p class="text-gray-300">4  Preliminaries  16 4.1 Basic notations  16 4.2 Sampling partial sums of random low-degree polynomials  16 4.3 Interactive probabilistically checkable proofs  17 4.4 Zero knowledge for Interactive PCPs  17 4.5 Sumcheck protocol and its zero knowledge variant  18</p>

    <p class="text-gray-300">5  Algebraic query complexity of polynomial summation  20</p>

    <p class="text-gray-300">6  Zero knowledge sumcheck from algebraic query lower bounds  22 6.1 Step 1  24 6.2 Step 2  27</p>

    <p class="text-gray-300">7  Zero knowledge for non-deterministic exponential time  28</p>

    <p class="text-gray-300">8  Delegating sum-product computations  31 8.1 Intuition for definition  31 8.2 Sum-product formulas  32 8.3 Sum-product circuits  35</p>

    <p class="text-gray-300">9  Zero knowledge sum-product protocols  39 9.1 The case of sum-product evaluation  39 9.2 The case of sum-product satisfaction  43</p>

    <p class="text-gray-300">10 Zero knowledge for polynomial space  45</p>

    <p class="text-gray-300">11 Zero knowledge for the evaluation of low-depth circuits  48 11.1 Notations for layered arithmetic circuits  49 11.2 Sum-product subcircuits and oracle inputs  50 11.3 Sum-product subcircuits for layered arithmetic circuits  50 11.4 Sum-product subcircuits for small-space Turing machines  51 11.5 Proof of Theorem 11.1  52</p>

    <p class="text-gray-300">Acknowledgments  54</p>

    <p class="text-gray-300">A  Algebraic query complexity of polynomial summation: details  55 A.1 Proof of Theorem 5.1  55 A.2 Proof of Corollary 5.3  55 A.3 Upper bounds  56</p>

    <p class="text-gray-300">B  Proof of Theorem 7.2 via sum-product circuits  59</p>

    <p class="text-gray-300">References  61</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The notion of <em>Interactive Proofs</em> (IPs) <em>[x1, x13]</em> is fundamental in Complexity Theory and Cryptography. An Interactive Proof for a language <span class="math">\\mathscr{L}</span> is a protocol between a probabilistic polynomial-time <em>verifier</em> and a resource-unbounded <em>prover</em> that works as follows: given a common input <span class="math">\\mathbf{x}</span>, the prover and verifier exchange some number of messages and then the verifier either accepts or rejects. If <span class="math">\\mathbf{x}</span> is in <span class="math">\\mathscr{L}</span> then the verifier always accepts; if instead <span class="math">\\mathbf{x}</span> is not in <span class="math">\\mathscr{L}</span> then the verifier rejects with high probability, regardless of the prover’s actions. The seminal results of Lund, Fortnow, Karloff, and Nisan <em>[x21]</em> and Shamir <em>[x24]</em> demonstrate the surprising expressiveness of Interactive Proofs, in particular showing that every language decidable in polynomial space has an Interactive Proof.</p>

    <p class="text-gray-300">Research on IPs has recently focused on new and more refined goals, motivated by the paradigm of <em>delegation of computation</em>, in which a resource-limited verifier receives the help of a resource-rich prover to check the output of an expensive (but tractable) computation. In this setting bounding the complexity of the honest prover is important. While every IP protocol has a polynomial-space prover, this prover may run in superpolynomial time, even if the protocol is for a tractable language. Recent work has focused on <em>doubly-efficient</em> IPs, where the prover is efficient (it runs in polynomial time) and the verifier is highly efficient (it runs in, say, quasilinear time). Doubly-efficient IPs can be achieved, with various tradeoffs, for many types of computation: languages decidable by uniform circuits of polylogarithmic depth <em>[x12]</em>; languages decidable in polynomial time and bounded-polynomial space <em>[x30]</em>; and languages decidable by conjunctions of polynomially-many ‘local’ conditions <em>[x32]</em>.</p>

    <p class="text-gray-300">A key building block in <em>all</em> of these protocols is the <em>sumcheck protocol</em> <em>[x21]</em>, which is an Interactive Proof for claims of the form “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>”, where <span class="math">H</span> is a subset of a finite field <span class="math">\\mathbb{F}</span> and <span class="math">F</span> is an <span class="math">m</span>-variate polynomial over <span class="math">\\mathbb{F}</span> of small individual degree. The use of sumcheck imbues the aforementioned protocols with an algebraic structure, where the verifier <em>arithmetizes</em> a boolean problem into a statement about low-degree polynomials, which can then be checked via the sumcheck protocol. This algebraic structure is not only elegant, but also very useful. Indeed, this structure is crucial not only for highly-efficient software and hardware systems for delegating computation <em>[x10, x31, x27, x28, x29, x33]</em> but also for a diverse set of compelling theoretical applications such as memory delegation <em>[x9]</em>, refereed delegation <em>[x11]</em>, IPs of proximity <em>[x32]</em>, and many others.</p>

    <p class="text-gray-300">Despite these subsequent works demonstrating the flexibility of sumcheck to accommodate additional desirable properties, the <em>zero knowledge</em> <em>[x13]</em> properties of sumcheck have not been explored. This is surprising because zero knowledge, the ability of the prover to establish the validity of an assertion while revealing no insight into its proof, is highly desirable for the cryptographic applications of Interactive Proofs. Unfortunately, achieving zero knowledge is nontrivial because the sumcheck protocol reveals the results of intermediate computations, in particular the partial sums <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m-1}}F(c_{1},\\ldots,c_{i},\\vec{\\alpha})</span> for <span class="math">c_{1},\\ldots,c_{i}\\in\\mathbb{F}</span> chosen by the verifier. These partial sums are in general <span class="math">\\#\\mathbf{P}</span>-hard to compute so they convey significant additional knowledge to the verifier.</p>

    <p class="text-gray-300">The goal of this work is to enlarge the existing algebraic toolkit based on low-degree polynomials and use these tools to provide a native extension of the sumcheck protocol that is zero knowledge, and to explore applications of such an extension. As we discuss shortly, however, we cannot expect to do so within the model of Interactive Proofs.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Prior techniques for achieving zero knowledge</h3>

    <p class="text-gray-300">We briefly describe why existing methods fall short of our goal, which is making the sumcheck protocol zero knowledge in an algebraic way. A seminal result in cryptography says that if one-way functions exist then every language having an IP also has a <em>computational</em> zero knowledge IP <em>[x13, x23, x10]</em>; this assumption is ‘minimal’ in the sense that if one-way functions do not exist then computational zero knowledge IPs capture only “average-case” <span class="math">\\mathbf{BPP}</span> <em>[x26, x27]</em>. While powerful, such results are unsatisfactory from our perspective. First, cryptography adds significant efficiency overheads, especially when used in a non-blackbox way as these results do. Second, the results rely on transformations that erase all the algebraic structure of the underlying protocols. While these limitations can be mitigated by using cryptography that leverages some of the underlying structure <em>[x10]</em>, the costs incurred by the use of cryptography remain significant. Ideally, we wish to <em>avoid</em> intractability assumptions.</p>

    <p class="text-gray-300">Unfortunately, this is impossible to achieve under standard complexity assumptions, because Interactive Proofs that are <em>statistical</em> zero knowledge are limited to languages in <span class="math">\\mathbf{AM}\\cap\\mathbf{coAM}</span> <em>[x14, x1]</em>. Such languages (conjecturally) do not even include <span class="math">\\mathbf{NP}</span>, so that we cannot even hope to achieve a ‘zero knowledge sumcheck protocol’ (which would give <span class="math">\\#\\mathbf{P}</span>).</p>

    <p class="text-gray-300">The quest for zero knowledge without relying on intractability assumptions led to the formulation of Multi-prover Interactive Proofs (MIPs) <em>[x1]</em>, where the verifier exchanges messages with two or more non-communicating provers. Groundbreaking results establish that MIPs are very powerful: all (and only) languages decidable in non-deterministic exponential time have MIPs <em>[x3]</em> and, in fact, even perfect zero knowledge MIPs <em>[x4, x11]</em>. Similar results hold even for the related model of Probabilistically Checkable Proofs (PCPs) <em>[x10, x11, x12, x2, x13]</em>, where the prover outputs a proof string that the verifier can check by reading only a few randomly-chosen locations. Namely, all (and only) languages decidable in non-deterministic exponential time have PCPs <em>[x1]</em> and, in fact, even statistical zero knowledge PCPs <em>[x16, x15]</em>.</p>

    <p class="text-gray-300">However, while information-theoretic, the aforementioned works rely on transformations that, once again, discard the rich algebraic structure of the underlying protocols. Thus, zero knowledge in this setting continues to be out of reach of simple and elegant algebraic techniques.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Our goal: algebraic techniques for zero knowledge</h3>

    <p class="text-gray-300">Our goal is to develop information-theoretic techniques for achieving zero knowledge in a way that leverages, and preserves, the algebraic structure of the sumcheck protocol and other protocols that build on it. An additional goal is to preserve the simplicity and elegance of these foundational protocols.</p>

    <p class="text-gray-300">Yet, as discussed, we cannot hope to do so with Interactive Proofs, and so we work in another model. We choose to work in a model that combines features of both Interactive Proofs and PCPs: the Interactive PCP (IPCP) model of Kalai and Raz <em>[x14]</em>. The prover first sends to the verifier a long string as a PCP oracle, after which the prover and verifier engage in an Interactive Proof. The verifier is free at any point to query the PCP oracle at locations of its choice, and the verifier only pays for the number of queries it makes, so that exponentially-large PCP oracles are allowed.</p>

    <p class="text-gray-300">Kalai and Raz <em>[x14]</em> show that the IPCP model has efficiency advantages over both PCPs and IPs (individually). Goyal, Ishai, Mahmoody, and Sahai <em>[x12]</em> construct efficient zero knowledge IPCPs, but their techniques mirror those for zero knowledge PCPs and, in particular, are not algebraic.</p>

    <p class="text-gray-300">One can think of the IPCP model as lying somewhere ‘in between’ the IP and MIP models. Indeed, it is equivalent to a (2-prover) MIP where one of the provers is stateless (its answers do not depend on the verifier’s prior messages or queries). This means that soundness is easier to achieve for an IPCP than for an MIP. Zero knowledge, however, is more difficult for an IPCP than for an MIP, because the stateless prover cannot choose which queries it will answer.</p>

    <p class="text-gray-300">A significant advantage of the IPCP model over the MIP model is that one can easily compile (public-coin) IPCPs into cryptographic proofs via transformations that preserve zero knowledge, while only making a black-box use of cryptography. For example, using collision-resistant functions one can obtain public-coin interactive arguments by extending ideas of <em>[x17, x16]</em>; also, using random oracles one can obtain publicly-verifiable non-interactive arguments via <em>[x5]</em> (extending the Fiat–Shamir paradigm <em>[x12]</em> and Micali’s “CS proofs” <em>[x18]</em>). In contrast, known transformations for MIPs yield private-coin arguments <em>[x6]</em>, or do not preserve zero knowledge <em>[x13]</em>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Main result: a zero knowledge sumcheck</h3>

    <p class="text-gray-300">Our main result is a zero knowledge analogue of the sumcheck protocol <em>[x19]</em>, a key building block in many protocols. We now informally state and discuss this result, and in the next sub-section we discuss its applications.</p>

    <p class="text-gray-300">The goal of the sumcheck protocol is to efficiently verify claims of the form “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>”, where <span class="math">H</span> is a subset of a finite field <span class="math">\\mathbb{F}</span> and <span class="math">F</span> is an <span class="math">m</span>-variate polynomial over <span class="math">\\mathbb{F}</span> of low individual degree. As the sumcheck protocol is often used in situations where the polynomial <span class="math">F</span> is only implicitly defined (including this paper), it is helpful to adopt the viewpoint of Meir <em>[x20]</em>, regarding the sumcheck protocol as a reduction from the summation “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>” to an evaluation “<span class="math">F(\\vec{c})=b</span>”; the latter can be checked directly by the verifier or by another protocol. The verifier in this reduction does not need any information about <span class="math">F</span>, aside from knowing that <span class="math">F</span> has small individual degree. The completeness property of the reduction is that if the summation claim is true, then so is the evaluation claim with probability one. Its soundness property is that if the summation claim is false, then so is the evaluation claim with high probability.</p>

    <p class="text-gray-300">The theorem below states the existence of sumcheck protocol in the above sense that works in the IPCP model and is zero knowledge, which means that a verifier does not learn any information beyond the fact that <span class="math">F</span> sums to <span class="math">0</span> on <span class="math">H^{m}</span> (and, in our case, a single evaluation of <span class="math">F</span>). As usual, this means that we establish an efficient procedure for simulating</p>

    <p class="text-gray-300">the interaction of a (possibly malicious) verifier with the prover, where the simulator only uses the knowledge of the sum of <span class="math">F</span> on <span class="math">H^{m}</span> (and a single evaluation of <span class="math">F</span>) but otherwise has no actual access to the prover (or <span class="math">F</span>). This interaction is a random variable depending on the randomness of both the verifier and the prover, and we show that the simulated interaction perfectly replicates this random variable.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 1.1 (Informal version of Theorem 6.4).</h6>

    <p class="text-gray-300">There exists an IPCP for sumcheck with the following zero knowledge guarantee: the view of any probabilistic polynomial-time verifier in the protocol can be perfectly and efficiently simulated by a simulator that makes only a single query to <span class="math">F</span>. Moreover, we do not require the full power of the IPCP model: the honest prover’s PCP consists only of a random multi-variate polynomial over <span class="math">\\mathbb{F}</span> of small individual degree.</p>

    <p class="text-gray-300">Our result significantly strengthens the IPCP for sumcheck of <em>[x1]</em> (co-authored by this paper’s authors), which is only zero knowledge with respect to a simulator which requires unrestricted query access to <span class="math">F</span>. Namely, in order to simulate a verifier’s view, their simulator must make a number of queries to <span class="math">F</span> that equals the number of queries to the PCP oracle made by the verifier. This zero knowledge guarantee is weaker than the above because a malicious verifier can make an arbitrarily-large (but polynomial) number of queries to the PCP oracle. However, this weaker guarantee suffices in some cases, such as in the previous work <em>[x1]</em>.</p>

    <p class="text-gray-300">Perhaps more damaging is that when using this ‘weakly zero knowledge’ sumcheck protocol recursively (as required in applications), we would incur an exponential blowup: each simulated query recursively requires further queries to be simulated. In contrast, the ‘strongly zero knowledge’ sumcheck protocol that we achieve only requires the simulator to make a single query to <span class="math">F</span> regardless of the malicious verifier’s runtime, both providing a stronger zero knowledge guarantee and avoiding any exponential blow-up.</p>

    <p class="text-gray-300">An important property of our sumcheck protocol (which also holds for <em>[x1]</em>), is that it suffices for the honest prover to send as an oracle a uniformly random polynomial of a certain arity and degree. This brings the result ‘closer to IP’, in the sense that while IPCP captures all of <span class="math">\\mathbf{NEXP}</span>, only languages in <span class="math">\\mathbf{PSPACE}</span> have IPCPs (with perfect completeness) where the honest prover behaves in this way. The same property holds for some of our applications.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Algebraic commitments.</h4>

    <p class="text-gray-300">As detailed in Section 2, a key ingredient of our result is a commitment scheme based on algebraic techniques. That is, the prover wishes to commit to a value <span class="math">b\\in\\mathbb{F}</span>, and to do so sends a PCP oracle to the verifier. To then reveal (decommit) <span class="math">b</span>, the prover and verifier engage in an Interactive Proof. We show that the sumcheck protocol naturally yields such a commitment scheme, where the PCP oracle is simply a random low-degree polynomial <span class="math">R</span> such that <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})=b</span>. The soundness guarantee of the sumcheck protocol shows that this commitment scheme is binding, so that the prover cannot “reveal” a value other than the correct <span class="math">b</span>. To establish the hiding property, which states that the verifier cannot learn anything about <span class="math">b</span> before the prover reveals it, we leverage lower bounds on the algebraic query complexity of polynomial summation, previously studied for completely different reasons <em>[x1, x2]</em>.</p>

    <p class="text-gray-300">As our commitments are themselves defined by low degree polynomials, they are ‘transparent’ to low degree testing. That is, in various protocols the prover sends to the verifier the evaluation table of a low-degree polynomial as a PCP oracle, and the verifier ensures that this evaluation table is (close to) low degree via low degree testing. In our zero knowledge setting, we need the prover to hide the evaluation table under a commitment (to be revealed selectively), and yet still allow the verifier to check that the underlying evaluation table represents a low-degree polynomial. Our commitments naturally have this property due to their algebraic structure, which we exploit in our applications discussed below.</p>

    <p class="text-gray-300">Overall, the methods of this paper not only significantly deviate from traditional methods for achieving zero knowledge but also further illustrate the close connection between zero knowledge and Algebraic Complexity Theory, the theory of efficient manipulations of algebraic circuits and low-degree polynomials. This connection was first seen in our prior work developing the ‘weakly zero knowledge sumcheck’ of <em>[x1]</em>, used here as a subroutine. Indeed, this subroutine derives its zero-knowledge guarantee from an efficient algorithm for adaptively simulating random low-degree polynomials <em>[x1, x3]</em>. This algorithm itself relies on deterministic algorithms for polynomial identity testing of certain restricted classes of algebraic circuits <em>[x10]</em>. We believe that it is an exciting research direction to further investigate this surprising connection, and to further broaden the set of information-theoretic algebraic techniques that are useful towards zero knowledge.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">1.4 Applications: delegating computation in zero knowledge</p>

    <p class="text-gray-300">The original sumcheck protocol (without zero knowledge) has many applications, including to various methods of delegating computation. Our zero knowledge sumcheck protocol can be used to obtain zero knowledge analogues of foundational results in this area: we achieve natural zero knowledge extensions of the first construction of PCPs/MIPs <em>[x1, x2]</em>, Shamir’s protocol <em>[x24]</em>, and doubly-efficient Interactive Proofs for low-depth circuits <em>[x11]</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.4.1 Delegating non-deterministic exponential time</h4>

    <p class="text-gray-300">One of the earliest and most influential applications of the sumcheck protocol is the construction of Multi-prover Interactive Proofs for <span class="math">\\mathbf{NEXP}</span> due to Babai, Fortnow, and Lund <em>[x1]</em>; the same construction also demonstrated the power of low-degree testing as a tool for checking arbitrary computations, another highly influential insight. The subsequent improvements by Babai, Fortnow, Levin, and Szegedy <em>[x1]</em> led to the formulation and the study of <em>Probabilistically-Checkable Proofs</em> <em>[x2, x13]</em> and then the celebrated PCP Theorem <em>[x4, x2]</em>.</p>

    <p class="text-gray-300">We show how, by using our zero knowledge sumcheck protocol, we can obtain a zero knowledge analogue of the classical constructions of <em>[x1, x2]</em>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 1.2 (Informal version of Theorem 7.2).</h6>

    <p class="text-gray-300"><span class="math">\\mathbf{NEXP}</span> has perfect zero knowledge Interactive PCPs.</p>

    <p class="text-gray-300">Our construction extends the protocol of <em>[x1, x2]</em>, which can be viewed as an IPCP that is later ‘compiled’ into an MIP or a PCP. This protocol reduces the <span class="math">\\mathbf{NEXP}</span>-complete problem of determining the satisfiability of a ‘succinct’ 3CNF, to testing whether there exists a low-degree polynomial satisfying an (exponentially large) set of constraints. A polynomial satisfying these constraints is necessarily a low-degree extension of a satisfying assignment, and thus implies the existence of such an assignment. The prover sends such a polynomial as an oracle, which the verifier then low-degree tests. That the constraints are satisfied can be checked using the sumcheck protocol.</p>

    <p class="text-gray-300">To make this protocol zero knowledge we need to ensure that the oracle hides the original witness. We achieve this by sending not the low-degree extension itself but an algebraic commitment to it. The zero knowledge sumcheck then reduces the problem of checking the constraint on this witness to a single evaluation point of the low degree extension. However, this itself is not zero knowledge as evaluations of the low-degree extension can reveal information about the witness, especially if this evaluation is over the interpolating set <span class="math">H^{m}</span>. Thus, our construction exploits the fact that the sumcheck protocol works for <em>any</em> low-degree extension of the witness, and not just the one of minimal degree. Thus, the prover will instead send (the commitment to) a randomly sampled extension of the witness of slightly higher (but still constant) individual degree. The evaluations of this polynomial will (outside the interpolating set <span class="math">H^{m}</span>) be <span class="math">O(1)</span>-wise independent. As the sumcheck reduction will reduce to an evaluation point outside <span class="math">H^{m}</span> with high probability, the prover can then decommit the evaluation at this point to complete the sumcheck protocol without revealing any non-trivial information. We discuss this construction in more detail in Section 2.1.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">1.4.2 Delegating polynomial space</h4>

    <p class="text-gray-300">The above result shows that a powerful prover can convince a probabilistic polynomial-time verifier of <span class="math">\\mathbf{NEXP}</span> statements in perfect zero knowledge in the IPCP model. Now we turn our attention to protocols where the honest prover need not be a <span class="math">\\mathbf{NEXP}</span> machine. One such protocol, due to Shamir <em>[x24]</em>, provides an Interactive Proof for the <span class="math">\\mathbf{PSPACE}</span>-complete True Quantified Boolean Formula (TQBF) problem. This protocol is a more sophisticated application of the sumcheck protocol because sumcheck is applied <em>recursively</em>.</p>

    <p class="text-gray-300">We aim to obtain zero knowledge analogues for these types of more complex protocols as well but now, to tackle the greater complexity, we proceed in two steps. First, we design a generic framework called <em>sum-product circuits</em> (which we believe to be of independent interest) that can express in a unified way a large class of ‘sumcheck-based Interactive Proofs’, such as Shamir’s protocol. Second, we show how to use our zero knowledge sumcheck protocol to obtain zero knowledge analogues of these, and thus also for Shamir’s protocol. We discuss this further in Section 2.5.</p>

    <p class="text-gray-300">As before, the resulting protocols are within the IPCP model. However, a key feature of these protocols that differentiates them from our result for <span class="math">\\mathbf{NEXP}</span> is that the prover <em>does not need the full power of IPCPs</em>: it suffices for the honest prover to send a PCP oracle that is the evaluation table of a random low-degree polynomial. Of course, soundness will continue to hold against any malicious prover that uses the PCP oracle in arbitrary ways.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Theorem 1.3 (Informal version of Theorem 10.2).</h6>

    <p class="text-gray-300">PSPACE has perfect zero knowledge Interactive PCPs, where the honest prover sends a random low-degree polynomial as the oracle.</p>

    <p class="text-gray-300">As discussed above, any language having an IPCP where the honest prover sends a random low-degree polynomial (and achieves perfect completeness) can be decided in PSPACE. In contrast, in the general case, deciding languages having IPCPs is NEXP-hard. This result shows that moreover, all that is required to achieve unconditional zero knowledge for PSPACE is the ability to send a uniformly random polynomial as an oracle.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">1.4.3 Delegating low-depth circuits</h4>

    <p class="text-gray-300">The doubly-efficient Interactive Proofs for low-depth circuits due to Goldwasser, Kalai, and Rothblum <em>[x11]</em> are another landmark result that makes a recursive use of the sumcheck protocol. Their construction can be viewed as a ‘scaled down’ version of Shamir’s protocol where the prover is efficient and the verifier is highly efficient.</p>

    <p class="text-gray-300">We obtain a zero knowledge analogue of this protocol; again it suffices for the honest prover to send a random low-degree polynomial as the oracle (and soundness holds against any oracle). We do so by showing how the computation of low-depth circuits can be reduced to a corresponding sum-product circuit, by following the arithmetization in <em>[x11]</em>; then we rely on our zero knowledge results for sum-product circuits, mentioned above.</p>

    <p class="text-gray-300">The protocol of <em>[x11]</em> is an IP for delegating certain tractable computations: the evaluation of log-space uniform <span class="math">\\mathbf{NC}</span> (circuits of polynomial size and polylogarithmic depth). The prover runs in polynomial time, while the verifier runs in quasilinear time and logarithmic space. But what does achieving zero knowledge mean in this case? If the simulator can run in polynomial time, then it can trivially simulate the verifier’s view by simply running the honest prover. We thus need to consider a fine-grained notion of zero knowledge, by analyzing in more detail the overhead incurred by the simulator with respect to the malicious verifier’s running time. This reckoning is similar to <em>[x3]</em>, who study zero knowledge for Interactive Proofs of Proximity, and is a relaxation of knowledge tightness <em>[x10, Section 4.4.4.2]</em>.</p>

    <p class="text-gray-300">Concretely, we show that the running time of our simulator is a fixed (and small) polynomial in the verifier’s running time, with only a polylogarithmic dependence on the size of the circuit. For example, the view of a malicious verifier running in time, say, <span class="math">O(n^{2})</span> can be simulated in time <span class="math">\\tilde{O}(n^{6})</span>. If the circuit has size <span class="math">O(n^{8})</span>, then the zero knowledge guarantee is meaningful because the simulator is not able to evaluate the circuit.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Theorem 1.4 (Informal version of Theorem 11.1).</h6>

    <p class="text-gray-300">Log-space uniform <span class="math">\\mathbf{NC}</span> has perfect zero knowledge Interactive PCPs, where the honest prover sends a random low-degree polynomial as the oracle, and the verifier runs in quasilinear time and logarithmic space. The simulator overhead is a small polynomial: the view of a verifier running in time <span class="math">T</span> can be simulated in time <span class="math">T^{3}\\cdot\\mathrm{polylog}(n)</span>.</p>

    <p class="text-gray-300">An interesting open problem is whether the simulator overhead can be reduced to <span class="math">T\\cdot\\mathrm{polylog}(n)</span>, as required in the (quite strict) definition given in <em>[x10, Section 4.4.4.2]</em>. It seems that our techniques are unlikely to achieve this because they depend on solving systems of linear equations in <span class="math">\\Omega(T)</span> variables.</p>

    <p class="text-gray-300">Finally, a property in <em>[x11]</em> that has been very useful in subsequent work is that the verifier only needs to query a single point in the low-degree extension of its input. In this case, the verifier runs in polylogarithmic time and logarithmic space. Our zero knowledge analogue retains these properties. Additionally, in this setting the size of the circuit is subexponential in the running time of the verifier. Our zero knowledge guarantee then implies that we obtain zero knowledge under the standard (not fine-grained) definition.</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We summarize the techniques underlying our contributions. We begin in Section 2.1 by recalling the protocol of Babai, Fortnow, and Lund, in order to explain its sources of information leakage and how one could prevent them via algebraic techniques. This discussion motivates the goal of an <em>algebraic</em> commitment scheme, described in Section 2.2. Then in Section 2.3 we explain how to use this tool to obtain our main result, a zero knowledge sumcheck protocol.</p>

    <p class="text-gray-300">The rest of the section is then dedicated to explaining how to achieve our other applications, which involve achieving zero knowledge for <em>recursive</em> uses of the sumcheck protocol. First we explain in Section 2.4 what are the challenges that arise with regard to zero knowledge in recursive invocations of the sumcheck protocol, such as in the protocol of Shamir. Then in Section 2.5 we describe the framework of sum-product circuits, and the techniques within it that allows us to achieve zero knowledge for the protocols of Shamir and of Goldwasser, Kalai, and Rothblum.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.1 An algebraic approach for zero knowledge in the BFL protocol</h3>

    <p class="text-gray-300">We recall the protocol of Babai, Fortnow, and Lund <em>[x1]</em> (‘BFL protocol’), in order to explain its sources of information leakage and how one could prevent them via algebraic techniques. These are the ideas that underlie our algebraic construction of an unconditional (perfect) zero knowledge IPCP for <span class="math">\\mathbf{NEXP}</span> (see Section 1.4.1).</p>

    <p class="text-gray-300">The BFL protocol, and why it leaks. The <span class="math">\\mathrm{O3SAT}</span> problem is the following <span class="math">\\mathbf{NEXP}</span>-complete problem: given a boolean formula <span class="math">B</span>, does there exist a boolean function <span class="math">A</span> such that</p>

    <p class="text-gray-300"><span class="math">B(z,b_{1},b_{2},b_{3},A(b_{1}),A(b_{2}),A(b_{3}))=0\\quad\\text{for all }z\\in\\{0,1\\}^{r},b_{1},b_{2},b_{3}\\in\\{0,1\\}^{s}\\enspace?</span></p>

    <p class="text-gray-300">The BFL protocol constructs an IPCP for <span class="math">\\mathrm{O3SAT}</span> and later converts it to an MIP. Only the first step is relevant for us.</p>

    <p class="text-gray-300">In the BFL protocol, the honest prover first sends a PCP oracle <span class="math">\\hat{A}\\colon\\mathbb{F}^{s}\\to\\mathbb{F}</span> that is the unique multilinear extension (in some finite field <span class="math">\\mathbb{F}</span>) of a valid witness <span class="math">A\\colon\\{0,1\\}^{s}\\to\\{0,1\\}</span>. The verifier must check that (a) <span class="math">\\hat{A}</span> is a boolean function on <span class="math">\\{0,1\\}^{s}</span>, and (b) <span class="math">\\hat{A}</span>’s restriction to <span class="math">\\{0,1\\}^{s}</span> is a valid witness for <span class="math">B</span>. To do these checks, the verifier arithmetizes <span class="math">B</span> into an arithmetic circuit <span class="math">\\hat{B}</span>, and reduces the checks to conditions that involve <span class="math">\\hat{A}</span>, <span class="math">\\hat{B}</span>, and other low-degree polynomials. A technique of <em>[x1]</em> allows the verifier to ‘bundle’ all of these conditions into a low-degree polynomial <span class="math">f</span> such that (with high probability over the choice of <span class="math">f</span>) the conditions hold if and only if <span class="math">f</span> sums to <span class="math">0</span> on <span class="math">\\{0,1\\}^{r+3s+3}</span>. The verifier checks that this is the case via a sumcheck protocol with the prover. The soundness of the sumcheck protocol depends on the PCP oracle being the evaluation of a low-degree polynomial; the verifier checks this using a low-degree test.</p>

    <p class="text-gray-300">We see that the BFL protocol is <em>not</em> zero knowledge for two reasons: (i) the verifier has oracle access to <span class="math">\\hat{A}</span> and, in particular, to the witness <span class="math">A</span>; (ii) the prover’s messages during the sumcheck protocol leak further information about <span class="math">A</span> (namely, hard-to-compute partial sums of <span class="math">f</span>, which itself depends on <span class="math">A</span>).</p>

    <p class="text-gray-300">A blueprint for zero knowledge. We now describe the ‘blueprint’ for an approach to achieve zero knowledge in the BFL protocol. The prover does not send <span class="math">\\hat{A}</span> directly but instead a <em>commitment</em> to it. After this, the prover and verifier engage in a sumcheck protocol with suitable zero knowledge guarantees; at the end of this protocol, the verifier needs to evaluate <span class="math">f</span> at a point of its choice, which involves evaluating <span class="math">\\hat{A}</span> at three points. Now the prover reveals the requested values of <span class="math">\\hat{A}</span>, without leaking any information beyond these, so that the verifier can perform its check. We explain how these ideas motivate the need for certain algebraic tools, which we later obtain and use to instantiate our approach.</p>

    <p class="text-gray-300">(1) Randomized low-degree extension. Even if the prover reveals only three values of <span class="math">\\hat{A}</span>, these may still leak information about <span class="math">A</span>. We address this problem via a <em>randomized low-degree extension</em>. Indeed, while the prover in the BFL protocol sends the <em>unique</em> multilinear extension of <span class="math">A</span>, one can verify that <em>any</em> extension of <span class="math">A</span> of sufficiently low degree also works. We exploit this flexibility as follows: the prover randomly samples <span class="math">\\hat{A}</span> in such a way that any three evaluations of <span class="math">\\hat{A}</span> do not reveal any information about <span class="math">A</span>. Of course, if any of these evaluations is within <span class="math">\\{0,1\\}^{s}</span>, then no extension of <span class="math">A</span> has this property. Nevertheless, during the sumcheck protocol, the prover can ensure that the verifier chooses only evaluations outside of <span class="math">\\{0,1\\}^{s}</span> (by aborting if the verifier deviates), which incurs only a small increase in the soundness error. With this modification in place, it suffices for the prover to let <span class="math">\\hat{A}</span> be a random degree-<span class="math">4</span> extension of <span class="math">A</span>: by a dimensionality argument, any <span class="math">3</span> evaluations outside of <span class="math">\\{0,1\\}^{s}</span> are now independent and uniformly random in <span class="math">\\mathbb{F}</span>. Remarkably, we are thus able to reduce a claim about <span class="math">A</span> to a claim which contains <em>no information</em> about <span class="math">A</span>.</p>

    <p class="text-gray-300">(2) Low-degree testing the commitment. The soundness of the sumcheck protocol relies on <span class="math">f</span> having low degree, or at least being close to a low-degree polynomial. This in turn depends on the PCP oracle <span class="math">\\hat{A}</span> being close to a low-degree</p>

    <p class="text-gray-300">polynomial. If the prover sends <span class="math">\\hat{A}</span>, the verifier can simply low-degree test it. However, if the prover sends a commitment to <span class="math">\\hat{A}</span>, then it is not clear what the verifier should do. One option would be for the prover to reveal <em>more</em> values of <span class="math">\\hat{A}</span> (in addition to the aforementioned three values), in order to enable the verifier to conduct its low-degree test on <span class="math">\\hat{A}</span>. The prover would then have to ensure that revealing these additional evaluations is ‘safe’ by increasing the amount of independence among values in <span class="math">\\hat{A}</span> (while still restricting the verifier to evaluations outside of <span class="math">\\{0,1\\}^{s}</span>), which would lead to a blowup in the degree of <span class="math">\\hat{A}</span> that is proportional to the number of queries that the verifier wishes to make. For the low-degree test to work, however, the verifier <em>must</em> see more evaluations than the degree. In sum, this circularity is inherent. To solve this problem, we will design an ‘algebraic’ commitment scheme that is <em>transparent to low-degree tests</em>: the verifier can perform a low-degree test on the commitment itself (without the help of the prover), which will ensure access to a <span class="math">\\hat{A}</span> that is low-degree. We discuss this further in Section 2.2.</p>

    <p class="text-gray-300">(3) Sumcheck in zero knowledge. We need a sumcheck protocol where the prover’s messages leak little information about <span class="math">f</span>. The prior work in <em>[x1]</em> achieves an IPCP for sumcheck that is ‘weakly’ zero knowledge: any verifier learns at most one evaluation of <span class="math">f</span> for each query it makes to the PCP oracle. If the verifier could evaluate <span class="math">f</span> by itself, as was the case in that paper, this guarantee would suffice for zero knowledge. In our setting, however, the verifier <em>cannot</em> evaluate <span class="math">f</span> by itself because <span class="math">f</span> is (necessarily) hidden behind the algebraic commitment.</p>

    <p class="text-gray-300">One approach to compensate would be to further randomize <span class="math">\\hat{A}</span> by letting <span class="math">\\hat{A}</span> be a random extension of <span class="math">A</span> of some well-chosen degree <span class="math">d</span>. We are limited to <span class="math">d</span> of polynomial size because the honest verifier’s running time is <span class="math">\\Omega(d)</span>. But this means that a polynomial-time malicious verifier, participating in the protocol of <em>[x1]</em> and making <span class="math">d^{2}</span> queries to the PCP oracle, could learn information about <span class="math">A</span>.</p>

    <p class="text-gray-300">We resolve this by relying on more algebraic techniques, achieving an IPCP for sumcheck with a much stronger zero knowledge guarantee (see Theorem 1.1): any malicious verifier that makes polynomially-many queries to the PCP oracle learns only a <em>single</em> evaluation of <span class="math">f</span>. This suffices for zero knowledge in our setting: learning one evaluation of <span class="math">f</span> implies learning only three evaluations of <span class="math">\\hat{A}</span>, which can be made ‘safe’ if <span class="math">\\hat{A}</span> is chosen to be a random extension of <span class="math">A</span> of high-enough degree. Our sumcheck protocol uses as building blocks both our algebraic commitment scheme and the <em>[x1]</em> sumcheck; we summarize its construction in Section 2.3.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Remark 2.1.</h6>

    <p class="text-gray-300">Kilian, Petrank, and Tardos <em>[x14]</em> construct PCPs for <span class="math">\\mathbf{NEXP}</span> that are statistical zero knowledge, via a combinatorial construction that makes black-box use of the PCP Theorem. Our modification of the BFL protocol achieves a perfect zero knowledge IPCP via algebraic techniques, avoiding the use of the PCP Theorem.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.2 Algebraic commitments from algebraic query complexity lower bounds</h3>

    <p class="text-gray-300">We describe how the sumcheck protocol can be used to construct an information-theoretic commitment scheme that is ‘algebraic’, in the IPCP model. (Namely, an algebraic <em>interactive locking scheme</em>; see Remark 2.2 below.) The prover commits to a message by sending to the verifier a PCP oracle that perfectly hides the message; subsequently, the prover can reveal positions of the message by engaging with the verifier in an Interactive Proof, whose soundness guarantees statistical binding. A key algebraic property that we rely on is that the commitment is ‘transparent’ to low-degree tests.</p>

    <p class="text-gray-300">Committing to an element. We first consider the simple case of committing to a single element <span class="math">a</span> in <span class="math">\\mathbb{F}</span>. Let <span class="math">k</span> be a security parameter, and set <span class="math">N:=2^{k}</span>. Suppose that the prover samples a random <span class="math">B</span> in <span class="math">\\mathbb{F}^{N}</span> such that <span class="math">\\sum_{i=1}^{N}B_{i}=a</span>, and sends <span class="math">B</span> to the verifier as a commitment. Observe that any <span class="math">N-1</span> entries of <span class="math">B</span> do not reveal any information about <span class="math">a</span>, and so any verifier with oracle access to <span class="math">B</span> that makes less than <span class="math">N</span> queries cannot learn any information about <span class="math">a</span>. However, as <span class="math">B</span> is unstructured it is not clear how the prover can convince the verifier that <span class="math">\\sum_{i=1}^{N}B_{i}=a</span>.</p>

    <p class="text-gray-300">Instead, we can consider imbuing <span class="math">B</span> with additional structure by providing its low-degree extension. That is, the prover thinks of <span class="math">B</span> as a function from <span class="math">\\{0,1\\}^{k}</span> to <span class="math">\\mathbb{F}</span>, and sends its unique multilinear extension <span class="math">\\hat{B}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}</span> to the verifier. Subsequently, the prover can reveal <span class="math">a</span> to the verifier, and then engage in a sumcheck protocol for the claim “<span class="math">\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{\\beta})=a</span>” to establish the correctness of <span class="math">a</span>. The soundness of the sumcheck protocol protects the verifier against cheating provers and hence guarantees that this scheme is binding.</p>

    <p class="text-gray-300">However, giving <span class="math">B</span> additional structure calls into question the hiding property of the scheme. Indeed, surprisingly a result of <em>[x11]</em> shows that this new scheme is <em>not</em> hiding (in fields of characteristic different than 2): it holds that <span class="math">\\hat{B}(2^{-1},\\ldots,2^{-1})=a\\cdot 2^{-k}</span> for any choice of <span class="math">B</span>, so the verifier can learn <span class="math">a</span> with only a single query to <span class="math">\\hat{B}</span>!</p>

    <p class="text-gray-300">Sending an extension of <span class="math">B</span> has created a new problem: querying the extension outside of <span class="math">\\{0,1\\}^{k}</span>, the verifier can learn information that may require many queries to <span class="math">B</span> to compute. Indeed, this additional power is precisely what</p>

    <p class="text-gray-300">underlies the soundness of the sumcheck protocol. To resolve this, we need to understand what the verifier can learn about <span class="math">B</span> given some low-degree extension <span class="math">\\hat{B}</span>. This is precisely the setting of <em>algebraic query complexity</em> <em>[x1]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A natural approach is to let <span class="math">\\hat{B}</span> be chosen uniformly at random from the set of degree-<span class="math">d</span> extensions of <span class="math">B</span> for some <span class="math">d&gt;1</span>. It is not hard to see that if <span class="math">d</span> is very large (say, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) then </span>2^{k}<span class="math"> queries are required to determine the summation of </span>\\hat{B}<span class="math"> on </span>H^{m}<span class="math">. But we need </span>d<span class="math"> to be small to achieve soundness. A result of <em>[x10]</em> shows that </span>d=2<span class="math"> suffices: given a random multiquadratic extension </span>\\hat{B}<span class="math"> of </span>B<span class="math">, one needs </span>2^{k}<span class="math"> queries to </span>\\hat{B}<span class="math"> to determine </span>\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{\\beta})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Committing to a polynomial. The prover in our zero knowledge protocols needs to commit not just to a single element but to the evaluation of an <span class="math">m</span>-variate polynomial <span class="math">Q</span> over <span class="math">\\mathbb{F}</span> of degree <span class="math">d_{Q}</span>. We extend our ideas to this setting.</p>

    <p class="text-gray-300">Letting <span class="math">K</span> be a subset of <span class="math">\\mathbb{F}</span> of size <span class="math">d_{Q}+1</span>, the prover samples a random <span class="math">B^{\\vec{x}}</span> in <span class="math">\\mathbb{F}^{N}</span> such that <span class="math">\\sum_{i=1}^{N}B_{i}^{\\vec{x}}=Q(\\vec{x})</span> for each <span class="math">\\vec{x}\\in K^{m}</span>. We can view all of these strings as a single function <span class="math">B\\colon K^{m}\\times\\{0,1\\}^{k}\\to\\mathbb{F}</span>, and as before we consider its unique low-degree extension <span class="math">\\hat{B}:\\mathbb{F}^{m}\\times\\mathbb{F}^{k}\\to\\mathbb{F}</span>; viewed as a polynomial, <span class="math">\\hat{B}(\\vec{X},\\vec{Y})</span> has degree at most <span class="math">d_{Q}</span> in <span class="math">\\vec{X}</span> and is multilinear in <span class="math">\\vec{Y}</span>. Observe that since <span class="math">\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{X},\\vec{\\beta})</span> is a polynomial of individual degree <span class="math">d_{Q}</span> that agrees with <span class="math">Q</span> on <span class="math">K^{m}</span>, it must equal <span class="math">Q</span>. The binding property of the commitment scheme is clear: the prover can decommit to <span class="math">Q(\\vec{\\alpha})</span> for any <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span> by using the sumcheck protocol as before. We are left to argue the hiding property.</p>

    <p class="text-gray-300">It is not difficult to see that we run into the same issue as in the single-value case: we have <span class="math">\\hat{B}(\\vec{\\alpha},2^{-1},\\ldots,2^{-1})=Q(\\vec{\\alpha})\\cdot 2^{-k}</span> for any <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span>. We resolve this by again choosing a <em>random</em> extension <span class="math">\\hat{B}</span> of degree <span class="math">d&gt;1</span> in <span class="math">\\vec{Y}</span> (and degree <span class="math">d_{Q}</span> in <span class="math">\\vec{X}</span>). Yet, arguing the hiding property now requires a <em>stronger</em> statement than the one proved in <em>[x10]</em>. Not only do we need to know that the verifier cannot determine <span class="math">Q(\\vec{\\alpha})</span> for a particular <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span>, but we need to know that the verifier cannot determine <span class="math">Q(\\vec{\\alpha})</span> for <em>any</em> <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span>, or even <em>any linear combination of any such values</em>. We prove that this stronger guarantee holds in the same parameter regime: if <span class="math">d&gt;1</span> then <span class="math">2^{k}</span> queries are both necessary and sufficient.</p>

    <p class="text-gray-300">Transparency to low-degree tests. Recall that a key algebraic property we required from our commitment scheme is that the verifier can perform a low-degree test on the committed polynomial without the assistance of the prover. Our commitment scheme naturally has this property. If the PCP oracle <span class="math">\\hat{B}\\colon\\mathbb{F}^{m}\\times\\mathbb{F}^{k}\\to\\mathbb{F}</span> is low-degree, then it is a commitment to the low-degree <span class="math">Q\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> defined as <span class="math">Q(\\vec{X}):=\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{X},\\vec{\\beta})</span>. In fact, even if <span class="math">\\hat{B}\\colon\\mathbb{F}^{m}\\times\\mathbb{F}^{k}\\to\\mathbb{F}</span> is merely <em>close</em> to a low-degree <span class="math">\\hat{B}\\colon\\mathbb{F}^{m}\\times\\mathbb{F}^{k}\\to\\mathbb{F}</span>, then we can still regard <span class="math">\\hat{B}</span> as a commitment to the low-degree <span class="math">Q\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> defined as <span class="math">Q(\\vec{X}):=\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{X},\\vec{\\beta})</span>, because the verifier can check claims of the form “<span class="math">Q(\\vec{\\alpha})=a</span>” by obtaining the value of <span class="math">\\hat{B}</span> it needs at the end of the sumcheck protocol via self-correction on <span class="math">\\hat{B}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Beyond the boolean hypercube. For efficiency reasons analogous to those in <em>[x3, x11]</em>, instead of viewing <span class="math">B</span> as a function from <span class="math">K^{m}\\times\\{0,1\\}^{k}</span> to <span class="math">\\mathbb{F}</span>, we view <span class="math">B</span> as a function from <span class="math">K^{m}\\times H^{k^{\\prime}}</span> to <span class="math">\\mathbb{F}</span> for a subset <span class="math">H</span> of <span class="math">\\mathbb{F}</span> of size <span class="math">\\mathbb{F}^{\\Omega(1)}</span> and $k^{\\prime}:=\\log N/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This requires us to extend our claims about the algebraic query complexity of polynomial summation to arbitrary sets </span>H<span class="math">. We show that if </span>d>2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<span class="math">, then </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k^{\\prime}}=N<span class="math"> queries are necessary to determine </span>Q(\\vec{\\alpha})<span class="math"> for any </span>\\vec{\\alpha}$ (or any linear combination of these). See Section 5 for details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Decommitting in zero knowledge. To use our commitment scheme in zero knowledge protocols, we must ensure that, in the decommitment phase, the verifier cannot learn any information beyond the value <span class="math">a:=Q(\\vec{\\alpha})</span> for a chosen <span class="math">\\vec{\\alpha}</span>. To decommit, the prover sends the value <span class="math">a</span> and has to convince the verifier that the claim “<span class="math">\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k}}\\hat{B}(\\vec{\\alpha},\\vec{\\beta})=a</span>” is true. However, if the prover and verifier simply run the sumcheck protocol on this claim, the prover leaks partial sums <span class="math">\\sum_{\\vec{\\beta}\\in\\{0,1\\}^{k-1}}\\hat{B}(\\vec{\\alpha},c_{1},\\ldots,c_{i},\\vec{\\beta})</span> for <span class="math">c_{1},\\ldots,c_{i}\\in\\mathbb{F}</span> chosen by the verifier, which could reveal additional information about <span class="math">Q</span>. Instead, the prover and verifier run on this claim the IPCP for sumcheck of <em>[x2]</em>, whose ‘weak’ zero knowledge guarantee ensures that this cannot happen. (Thus, in addition to the commitment, the honest prover also sends the evaluation of a random low-degree polynomial as required by the IPCP for sumcheck of <em>[x2]</em>.)</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Remark 2.2 (comparison with <em>[x12]</em>).</h6>

    <p class="text-gray-300">Goyal, Ishai, Mahmoody, and Sahai <em>[x12]</em> define and construct <em>interactive locking schemes</em>, information-theoretic commitment schemes in the IPCP model. Their scheme is combinatorial, and we do not know how to use it in our setting (it is not clear how to low-degree test the committed message without disrupting zero knowledge). Putting this difference aside, their construction and our construction are incomparable. On the one hand, we achieve perfect hiding while they only achieve statistical hiding. On the other hand, their scheme is ‘oracle efficient’ (any query to the oracle can be computed statelessly in polynomial time) while our scheme is not.</p>

    <p class="text-gray-300">2.3 A zero knowledge sumcheck protocol</p>

    <p class="text-gray-300">We summarize the ideas behind our main result, a zero knowledge sumcheck protocol (see Theorem 1.1). This result not only enables us to modify the BFL protocol to achieve zero knowledge (as discussed above), but also to modify the Shamir and GKR protocols to achieve zero knowledge (as discussed below). The two building blocks underlying our sumcheck protocol are our algebraic commitments (see Section 2.2 above) and the IPCP for sumcheck of <em>[x1]</em>. We now cover necessary background and then describe our protocol.</p>

    <p class="text-gray-300">Previous sumcheck protocols. The sumcheck protocol <em>[x11]</em> is an IP for claims of the form “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})=0</span>”, where <span class="math">H</span> is a subset of a finite field <span class="math">\\mathbb{F}</span> and <span class="math">F</span> is an <span class="math">m</span>-variate polynomial over <span class="math">\\mathbb{F}</span> of small individual degree. The protocol has <span class="math">m</span> rounds: in round <span class="math">i</span>, the prover sends the univariate polynomial <span class="math">g_{i}(X_{i}):=\\sum_{\\vec{\\alpha}\\in H^{m-i}}F(c_{1},\\ldots,c_{i-1},X_{i},\\vec{\\alpha})</span>; the verifier checks that <span class="math">\\sum_{\\alpha_{i}\\in H}g_{i}(\\alpha_{i})=g_{i-1}(c_{i-1})</span> and replies with a uniformly random challenge <span class="math">c_{i}\\in\\mathbb{F}</span>. After round <span class="math">m</span>, the verifier outputs the claim “<span class="math">F(c_{1},\\ldots,c_{m})=g_{m}(c_{1},\\ldots,c_{m})</span>”. If <span class="math">F</span> is of sufficiently low degree and does not sum to <span class="math">a</span> over the space, then the output claim is false with high probability. Note that the verifier does not need access to <span class="math">F</span>.</p>

    <p class="text-gray-300">The IPCP for sumcheck of <em>[x1]</em> modifies the above protocol as follows. The prover first sends a PCP oracle that equals the evaluation of a random ‘masking’ polynomial <span class="math">R</span>; the verifier checks that <span class="math">R</span> is (close to) low degree. After that the prover and verifier conduct an Interactive Proof. The prover sends <span class="math">z\\in\\mathbb{F}</span> that allegedly equals <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}R(\\vec{\\alpha})</span>, and the verifier responds with a uniformly random challenge <span class="math">\\rho\\in\\mathbb{F}^{*}</span>. The prover and verifier now run the (standard) sumcheck protocol to reduce the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}\\rho F(\\vec{\\alpha})+R(\\vec{\\alpha})=\\rho a+z</span>” to a claim “<span class="math">\\rho F(\\vec{c})+R(\\vec{c})=b</span>” for random <span class="math">\\vec{c}\\in\\mathbb{F}^{m}</span>. The verifier queries <span class="math">R</span> at <span class="math">\\vec{c}</span> and then outputs the claim “<span class="math">F(\\vec{c})=\\frac{b-R(\\vec{c})}{p}</span>”. If <span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}F(\\vec{\\alpha})\\neq a</span> then with high probability over the choice of <span class="math">\\rho</span> and the verifier’s messages in the sumcheck protocol, this claim will be false.</p>

    <p class="text-gray-300">A key observation is that if the verifier makes no queries to <span class="math">R</span>, then the prover’s messages are identically distributed to the sumcheck protocol applied to a uniformly random polynomial <span class="math">Q</span>. When the verifier does make queries to <span class="math">R</span>, simulating the resulting conditional distribution involves techniques from Algebraic Complexity Theory, as shown in <em>[x1]</em>. Given <span class="math">Q</span>, the verifier’s queries to <span class="math">R(\\vec{\\alpha})</span> for <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span> are identically distributed to <span class="math">Q(\\vec{\\alpha})-\\rho F(\\vec{\\alpha})</span>. Thus the simulator need only make at most one query to <span class="math">F</span> for every query to <span class="math">R</span>. That is, any verifier making <span class="math">q</span> queries to <span class="math">R</span> learns no more than it would learn by making <span class="math">q</span> queries to <span class="math">F</span> alone.</p>

    <p class="text-gray-300">As discussed, this zero knowledge guarantee does not suffice for the applications that we consider: when a sumcheck protocol is used as a subroutine of another protocol, <span class="math">F</span> may itself be recursively defined in terms of large sums which the verifier cannot evaluate on its own. The verifier does, however, have oracle access to <span class="math">R</span>, and so can learn enough information about <span class="math">F</span> to break zero knowledge.</p>

    <p class="text-gray-300">Our sumcheck protocol. The zero knowledge guarantee that we aim for is the following: any polynomial-time verifier learns no more than it would by making one query to <span class="math">F</span>, regardless of its number of queries to the PCP oracle.</p>

    <p class="text-gray-300">The main idea to achieve this guarantee is the following. The prover sends a PCP oracle that is an algebraic commitment <span class="math">Z</span> to the aforementioned masking polynomial <span class="math">R</span>. Then, as before, the prover and verifier run the sumcheck protocol to reduce the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}\\rho F(\\vec{\\alpha})+R(\\vec{\\alpha})=\\rho a+z</span>” to a claim “<span class="math">\\rho F(\\vec{c})+R(\\vec{c})=b</span>” for random <span class="math">\\vec{c}\\in\\mathbb{F}^{m}</span>.</p>

    <p class="text-gray-300">We now face two problems. First, the verifier cannot simply query <span class="math">R</span> at <span class="math">\\vec{c}</span> and then output the claim “<span class="math">F(\\vec{c})=\\frac{b-R(\\vec{c})}{\\rho}</span>”, since the verifier only has oracle access to the commitment <span class="math">Z</span> of <span class="math">R</span>. Second, the prover could cheat the verifier by having <span class="math">Z</span> be a commitment to an <span class="math">R</span> that is far from low degree, which allows cheating in the sumcheck protocol.</p>

    <p class="text-gray-300">The first problem is addressed by the fact that our algebraic commitment scheme has a decommitment sub-protocol that is zero knowledge: the prover can reveal <span class="math">R(\\vec{c})</span> in such a way that no other values about <span class="math">R</span> are also revealed as a side-effect. As discussed, this relies on the protocol of <em>[x1]</em>, used a subroutine (for the second time).</p>

    <p class="text-gray-300">The second problem is taken care of by the fact that our algebraic commitment scheme is ‘transparent’ to low-degree tests: the verifier simply performs a low-degree test on <span class="math">Z</span>, which by self-correction gives the verifier oracle access to a low-degree <span class="math">Z^{\\prime}</span> that is a commitment to a low-degree <span class="math">R</span>.</p>

    <p class="text-gray-300">Overall, the only value that a malicious verifier can learn is <span class="math">F(\\vec{c})</span> for <span class="math">\\vec{c}\\in\\mathbb{F}^{m}</span> of its choice.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Remark 2.3.</h6>

    <p class="text-gray-300">Our sumcheck protocol ‘leaks’ a single evaluation of <span class="math">F</span>. We believe that this limitation is inherent: the honest verifier always outputs a true claim about one evaluation of <span class="math">F</span>, which it cannot do without learning that evaluation. Either way, this guarantee is strong enough for applications: we ensure that learning a single evaluation of <span class="math">F</span> does not harm zero knowledge, either because it carries no information or because the verifier can evaluate <span class="math">F</span> itself.</p>

    <p class="text-gray-300">2.4 Challenges: handling recursion</p>

    <p class="text-gray-300">We have so far discussed the ideas behind our main result (a zero knowledge sumcheck protocol) and how to use it to achieve a natural zero knowledge analogue of the classical MIP/PCP construction for NEXP <em>[x1, x2]</em>. Other applications require additional ideas to overcome challenges that arise when the sumcheck protocol is used <em>recursively</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Shamir’s protocol.</h4>

    <p class="text-gray-300">Consider the goal of achieving zero knowledge for Shamir’s protocol for PSPACE <em>[x19]</em>. This protocol reduces checking any PSPACE computation to checking that:</p>

    <p class="text-gray-300"><span class="math">\\sum_{x_{1}\\in\\{0,1\\}}\\prod_{x_{2}\\in\\{0,1\\}}\\ldots\\sum_{x_{n-1}\\in\\{0,1\\}}\\prod_{x_{n}\\in\\{0,1\\}}\\hat{\\phi}(x_{1},\\ldots,x_{n})=0</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{\\phi}</span> is the (efficiently computable) arithmetization over a finite field <span class="math">\\mathbb{F}</span> of a certain boolean formula <span class="math">\\phi</span>. Since Shamir’s protocol is similar to the sumcheck protocol, a natural starting point would be to try to merely adapt the techniques that ‘worked’ in the case of the sumcheck protocol. However, the similarity between the two protocols is only superficial (e.g., it lacks the useful linear structure present in the sumcheck protocol). An accurate way to compare the two is to view Shamir’s protocol as a <em>recursive</em> application of the sumcheck protocol, as shown by Meir <em>[x16]</em>.</p>

    <p class="text-gray-300">For example, the TQBF problem is <em>downward self-reducible</em> <em>[x20]</em>: for <span class="math">i\\in\\{1,\\ldots,n\\}</span> let</p>

    <p class="text-gray-300"><span class="math">G_{i}(X_{1},\\ldots,X_{i}):=\\sum_{x_{i+1}\\in\\{0,1\\}}\\prod_{x_{i+2}\\in\\{0,1\\}}\\ldots\\sum_{x_{n-1}\\in\\{0,1\\}}\\prod_{x_{n}\\in\\{0,1\\}}\\hat{\\phi}(X_{1},\\ldots,X_{i},x_{i+1},\\ldots,x_{n})\\enspace.</span></p>

    <p class="text-gray-300">From this one obtains the recurrence</p>

    <p class="text-gray-300"><span class="math">G_{i}(X_{1},\\ldots,X_{i})=\\sum_{x_{i+1}\\in\\{0,1\\}}G_{i+2}(X_{1},\\ldots,X_{i},x_{i+1},0)\\cdot G_{i+2}(X_{1},\\ldots,X_{i},x_{i+1},1)\\enspace.</span> (1)</p>

    <p class="text-gray-300">In other words, with oracle access to <span class="math">G_{i+2}</span>, one can use a (small) sumcheck to compute <span class="math">G_{i}</span>. This suggests a recursive approach: if we could check evaluations of <span class="math">G_{i+2}</span> in zero knowledge, then maybe we could use this as a subprotocol to check evaluations of <span class="math">G_{i}</span> also in zero knowledge.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">GKR’s protocol.</h4>

    <p class="text-gray-300">The recursive structure is perhaps more evident in the doubly-efficient Interactive Proof of Goldwasser, Kalai, and Rothblum <em>[x11]</em> (‘GKR protocol’). Its barebones sub-protocol checks a more complex arithmetic expression: the output of a layered arithmetic circuit. Fix an input <span class="math">x</span> to the circuit, and let <span class="math">V_{i}(j)\\colon[S]\\to\\mathbb{F}</span> be the value of the <span class="math">j</span>-th gate in layer <span class="math">i</span> (<span class="math">S</span> is the number of gates in a layer). For some subset <span class="math">H\\subseteq\\mathbb{F}</span> and sufficiently large <span class="math">m</span>, one views <span class="math">V_{i}</span> as a function from <span class="math">H^{m}</span> to <span class="math">\\mathbb{F}</span> by imposing some ordering on <span class="math">H^{m}</span>. One can relate <span class="math">V_{i-1}</span> to <span class="math">V_{i}</span> as follows:</p>

    <p class="text-gray-300"><span class="math">V_{i-1}(\\vec{z})=\\sum_{\\vec{\\omega}_{1},\\vec{\\omega}_{2}\\in H^{m}}\\operatorname{add}_{i}(\\vec{z},\\vec{\\omega}_{1},\\vec{\\omega}_{2})\\cdot\\big{(}V_{i}(\\vec{\\omega}_{1})+V_{i}(\\vec{\\omega}_{2})\\big{)}+\\operatorname{mul}_{i}(\\vec{z},\\vec{\\omega}_{1},\\vec{\\omega}_{2})\\cdot\\big{(}V_{i}(\\vec{\\omega}_{1})\\cdot V_{i}(\\vec{\\omega}_{2})\\big{)}</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\operatorname{add}_{i}(\\vec{z},\\vec{\\omega}_{1},\\vec{\\omega}_{2})</span> is <span class="math">1</span> if the <span class="math">\\vec{z}</span>-th gate in layer <span class="math">i-1</span> is an addition gate whose inputs are the <span class="math">\\vec{\\omega}_{1}</span>-th and <span class="math">\\vec{\\omega}_{2}</span>-th gates in layer <span class="math">i</span>, and <span class="math">\\operatorname{mul}_{i}</span> is defined similarly for multiplication gates.</p>

    <p class="text-gray-300">We again see a recursive structure: a function defined as the summation over some product space of a polynomial whose terms are functions of the same form; this allows to check <span class="math">V_{i-1}</span> given a protocol for checking <span class="math">V_{i}</span>.</p>

    <p class="text-gray-300">The use of recursion in the GKR protocol is even more involved: the barebones protocol relies on the verifier having oracle access to low-degree extensions of <span class="math">\\operatorname{add}_{i}</span> and <span class="math">\\operatorname{mul}_{i}</span>. For very restricted classes of circuits, the verifier can efficiently ‘implement’ these oracles; however, for the class of circuits that is ultimately supported by the protocol this requires a further sub-protocol that delegates the evaluation of these oracles to the prover, and this is done by <em>composing</em> multiple instances of the GKR protocol. To achieve zero knowledge we also have to tackle this form of recursion.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">The leakage of recursion.</h4>

    <p class="text-gray-300">By now the central role of recursion in applications of the sumcheck protocol is clear. There are two main sources of leakage that we need to overcome in order to achieve zero knowledge in such applications.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Checking evaluations of <span class="math">G_{i+2}</span>, <span class="math">V_{i}</span>, or <span class="math">\\operatorname{add}_{i}</span> and <span class="math">\\operatorname{mul}_{i}</span>, even in zero knowledge, leaks the evaluations themselves. The verifier, however, is not able to compute these itself (else it would not need to delegate), which means that information is leaked.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The number of claims can grow exponentially: a claim about <span class="math">G_{i}</span> (resp. <span class="math">V_{i-1}</span>) is reduced to <em>two</em> claims about <span class="math">G_{i+2}</span> (resp. <span class="math">V_{i}</span>). There are standard techniques that leverage interaction to reduce multiple claims about a low-degree polynomial to a single one, but we need to replace these with zero knowledge equivalents.</li>

    </ol>

    <p class="text-gray-300">We tackle both issues by devising a general framework that captures their shared algebraic structure, solving these problems within this framework, and then recovering the protocols of Shamir and GKR as special cases.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.5 Sum-product circuits</h3>

    <p class="text-gray-300">We introduce the notion of <em>sum-product circuits</em> and show that the sumcheck protocol naturally gives rise to algebraic Interactive Proofs for checking the value of such circuits. We then explain how to achieve zero knowledge variants of these by building on the techniques discussed in Section 2.1. We recover zero knowledge variants of the protocols of Shamir and GKR as special cases of this approach.</p>

    <p class="text-gray-300">Sum-product circuits are an abstract way of encoding ‘sum-product expressions’. A sum-product expression is either a polynomial over some finite field <span class="math">\\mathbb{F}</span> represented by a small arithmetic circuit or a polynomial of the form</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\beta}\\in H^{m}}C\\big{(}\\vec{X},\\vec{\\beta},P_{1}(\\vec{X},\\vec{\\beta}),\\ldots,P_{n}(\\vec{X},\\vec{\\beta})\\big{)}</span> (3)</p>

    <p class="text-gray-300">where <span class="math">C</span> is a low-degree ‘combiner’ polynomial represented by a small arithmetic circuit, and <span class="math">P_{1},\\ldots,P_{n}</span> are sum-product expressions. Both Equation 1 (for Shamir’s protocol) and Equation 2 (for GKR’s protocol) are of this form.</p>

    <p class="text-gray-300">Like a standard arithmetic circuit, a sum-product circuit is a directed acyclic graph associated with a field <span class="math">\\mathbb{F}</span> in which we associate to each vertex a <em>value</em>, which in our case is the sum-product expression that it computes. Each internal vertex is labeled by a combiner polynomial, and there is an edge from <span class="math">u</span> to <span class="math">v</span> if the sum-product expression of <span class="math">v</span> appears in that of <span class="math">u</span>. For example, the above expression would correspond to a vertex labeled with <span class="math">C</span>, with outgoing edges to the vertices corresponding to <span class="math">P_{1},\\ldots,P_{n}</span>. An input to the circuit is a labeling of the leaf vertices with small arithmetic circuits. We now spell this out in a little more detail.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 2.4 (Informal version of Definition 8.8).</h6>

    <p class="text-gray-300">A <em>sum-product circuit</em> <span class="math">\\mathcal{C}</span> is a rooted directed acyclic graph where each internal vertex is labeled with an arithmetic circuit <span class="math">C_{v}</span> over a finite field <span class="math">\\mathbb{F}</span>. An <em>input <span class="math">\\mathbf{x}</span></em> to <span class="math">\\mathcal{C}</span> labels each leaf <span class="math">v</span> with a polynomial <span class="math">\\mathbf{x}_{v}</span> over <span class="math">\\mathbb{F}</span>. The value of a vertex <span class="math">v</span> on input <span class="math">\\mathbf{x}</span> is a multivariate polynomial <span class="math">v[\\mathbf{x}]</span> over <span class="math">\\mathbb{F}</span> defined as follows: if <span class="math">v</span> is a leaf vertex then <span class="math">v[\\mathbf{x}]</span> equals <span class="math">\\mathbf{x}_{v}</span>; if instead <span class="math">v</span> is an internal vertex then, for a chosen integer <span class="math">m</span>,</p>

    <p class="text-gray-300"><span class="math">v<a href="\\vec{X}">\\mathbf{x}</a>:=\\sum_{\\vec{\\beta}\\in H^{m}}C_{v}\\big{(}\\vec{X},\\vec{\\beta},u_{1}<a href="\\vec{X},\\vec{\\beta}">\\mathbf{x}</a>,\\ldots,u_{t}<a href="\\vec{X},\\vec{\\beta}">\\mathbf{x}</a>\\big{)}\\enspace.</span> (4)</p>

    <p class="text-gray-300">The <em>value</em> of <span class="math">\\mathcal{C}</span> on input <span class="math">\\mathbf{x}</span> is denoted <span class="math">\\mathcal{C}[\\mathbf{x}]</span> and equals the value of the root vertex <span class="math">r</span> (and we require that <span class="math">\\mathcal{C}[\\mathbf{x}]\\in\\mathbb{F}</span>).</p>

    <p class="text-gray-300">We next describe an Interactive Proof that works for any sum-product circuit. The protocols of Shamir <em>[x20]</em> and of GKR <em>[x12]</em> can be viewed as this protocol applied to specific sum-product circuits (computing <span class="math">G_{0}</span> and <span class="math">V_{0}</span> respectively). After that, we explain how to modify the Interactive Proof to obtain a corresponding zero knowledge IPCP for any sum-product circuit, which allows us to derive our zero knowledge variants of these two protocols.</p>

    <p class="text-gray-300">A significant advantage of working with sum-product circuits is that they are easy to compose. For example, we can view the composition of the GKR protocol with itself as a <em>composition of sum-product circuits</em>. We can then apply our zero knowledge IPCP to the resulting circuit and directly obtain a zero knowledge analogue of the full GKR protocol.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">2.5.1 Delegating the evaluation of a sum-product circuit</h4>

    <p class="text-gray-300">We explain how to use the sumcheck protocol to obtain an Interactive Proof for checking the value of a sum-product circuit. The protocol is recursively defined: to prove that <span class="math">\\mathcal{C}[\\mathbf{x}]=a</span> (i.e., that <span class="math">r[\\mathbf{x}]=a</span>), it suffices to show that the values of <span class="math">r</span>’s children <span class="math">u_{1},\\ldots,u_{t}</span> satisfy Equation 4 where the left-hand side is <span class="math">a</span>. The sumcheck protocol interactively reduces this claim to a new claim “<span class="math">C_{v}\\big{(}\\vec{c},u_{1}<a href="\\vec{c}">\\mathbf{x}</a>,\\ldots,u_{t}<a href="\\vec{c}">\\mathbf{x}</a>\\big{)}=b</span>” for <span class="math">\\vec{c}\\in\\mathbb{F}^{m}</span> chosen uniformly at random by the verifier and <span class="math">b\\in\\mathbb{F}</span> chosen by the prover. The prover sends <span class="math">h_{1}:=u_{1}<a href="\\vec{c}">\\mathbf{x}</a>,\\ldots,h_{t}:=u_{t}<a href="\\vec{c}">\\mathbf{x}</a></span>, reducing this new claim</p>

    <p class="text-gray-300">to the set of claims “<span class="math">h_{i}=u_{i}\\mathbf{x}</span>” for <span class="math">i=1,\\ldots,t</span> and “<span class="math">C_{v}(\\vec{c},h_{1},\\ldots,h_{t})=b</span>”. The latter can be checked by the verifier directly and the rest can be recursively checked via the same procedure. Eventually the protocol reaches the leaf vertices, which are labeled with small arithmetic circuits that the verifier can evaluate on its own.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">One technicality is that, as defined, the degree of the polynomial at a vertex may be exponentially large, and so the prover would have to send exponentially-large messages in the sumcheck protocol. To avoid this, we use a well-known interactive sub-protocol for <em>degree reduction</em> <em>[x21, x13]</em>. Since for all <span class="math">\\vec{x}</span> the value <span class="math">v\\mathbf{x}</span> depends only on <span class="math">u_{1}\\mathbf{x},\\vec{\\beta}),\\ldots,u_{t}\\mathbf{x}</span> for <span class="math">\\vec{\\beta}\\in H^{m}</span>, we can safely replace each <span class="math">u_{i}[\\mathbf{x}]</span> with the unique degree-$(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<span class="math"> extension </span>\\hat{u}_{i}[\\mathbf{x}]<span class="math"> of its evaluation over </span>H^{m}<span class="math">. The degree of the summand in Equation 4 is now at most </span>\\delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\delta<span class="math"> is the <em>total</em> degree of </span>C_{v}$. Now that the sumcheck protocol is only invoked on low-degree polynomials, efficiency is recovered.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Another technicality is that since a sum-product circuit is a directed acyclic graph (as opposed to a tree), it is possible that a single vertex <span class="math">v</span> will have many claims about it. If each such claim reduces to many claims about other vertices, the number of claims to check could grow exponentially. This is in fact the case in both Shamir’s and GKR’s protocols. To avoid this blowup, the verifier checks a random linear combination of the claims about each vertex <span class="math">v</span>. It is not difficult to see that soundness is preserved, and the number of claims per vertex is reduced to one.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">2.5.2 Achieving zero knowledge</h4>

    <p class="text-gray-300">The Interactive Proof for sum-product circuits that we have described above is not zero knowledge. First, the sumcheck protocol, which is used to reduce claims about parent vertices to claims about child vertices, leaks information in the form of partial sums of the summand polynomial, as usual. Second, in order to reduce a claim about the root to claims about its children, the prover must provide evaluations of the polynomials of the children. These may be hard for the verifier to compute (indeed, if the verifier could compute both of these on its own then there would be no need to recurse). We use the ideas discussed in Section 2.1 to resolve both of these issues, obtaining a zero knowledge variant in the IPCP model (where the honest prover sends a random low-degree polynomial as the oracle).</p>

    <p class="text-gray-300">We resolve the first issue by using our zero knowledge sumcheck protocol. Its zero knowledge guarantee states that the protocol reveals only one value of the summand function, which can be computed via one query to each of the <span class="math">\\hat{u}_{i}[\\mathbf{x}]</span>, which are precisely the <span class="math">h_{i}</span>’s sent by the prover. We are left to ensure that <span class="math">h_{i}</span>’s do not leak information.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As in our modification of the BFL protocol, rather than taking the unique degree-$(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<span class="math"> extension </span>\\hat{v}\\mathbf{x}<span class="math"> of </span>v\\mathbf{x}<span class="math">, we will instead take a <em>random</em> degree-</span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\delta)<span class="math"> extension </span>\\hat{v}[\\mathbf{x}]<span class="math">, where </span>\\delta<span class="math"> depends only on the circuit structure (in all of our protocols, </span>\\delta<span class="math"> is a small constant). This ensures that the few evaluations actually revealed by the prover are uniformly random in </span>\\mathbb{F}<span class="math">. The prover sends, for each vertex </span>v<span class="math">, the evaluation of a random polynomial </span>R_{v}<span class="math">, which defines the random low-degree extension as </span>\\hat{v}\\mathbf{x}:=\\hat{v}\\mathbf{x}+\\mathbb{Z}_{H^{m}}(\\vec{X})\\cdot R_{v}(\\vec{X})<span class="math"> where </span>\\mathbb{Z}_{H^{m}}<span class="math"> is a degree-</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> polynomial that is zero on </span>H^{m}<span class="math"> and nonzero on </span>(\\mathbb{F}-H)^{m}<span class="math">. The prover cannot simply send </span>R_{v}<span class="math">, however, because the verifier could then query it in order to ‘derandomize’ </span>\\hat{v}[\\mathbf{x}]<span class="math">. Instead, the prover sends a commitment to </span>R_{v}<span class="math"> using our algebraic commitment scheme. The decommitment is performed ‘implicitly’ during the sumcheck for vertex </span>v$. See Section 9.1 for details.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, recall that in order to avoid a blowup in the number of claims we have to check, the verifier checks a random linear combination of the claims about any given vertex; this is a linear operation. Also, to avoid a blowup in the degree, we take the low-degree extension, which is also a linear operation. Both of these operations are ‘compatible’ with sumcheck, and thus zero knowledge is straightforwardly maintained.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">After providing formal definitions in Section 4, the rest of the paper is organized as summarized by the table below. The shaded boxes denote some previous results that we rely on.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">4 Preliminaries</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.1 Basic notations</h3>

    <p class="text-gray-300">For <span class="math">n\\in\\mathbb{N}</span> we denote by <span class="math">[n]</span> the set <span class="math">\\{1,\\ldots,n\\}</span>. For <span class="math">m,n\\in\\mathbb{N}</span> we denote by <span class="math">m+[n]</span> the set <span class="math">\\{m+1,\\ldots,m+n\\}</span>. For a set <span class="math">X</span>, <span class="math">n\\in\\mathbb{N}</span>, <span class="math">I\\subseteq[n]</span>, and <span class="math">\\vec{x}\\in X^{n}</span>, we denote by <span class="math">\\vec{x}_{I}</span> the vector <span class="math">\\big{(}x_{i}\\big{)}_{i\\in I}</span> that is <span class="math">\\vec{x}</span> restricted to the coordinates in <span class="math">I</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Functions, distributions, fields. We use <span class="math">f\\colon D\\to R</span> to denote a function with domain <span class="math">D</span> and range <span class="math">R</span>; given a subset <span class="math">\\tilde{D}</span> of <span class="math">D</span>, we use $f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tilde{D}}<span class="math"> to denote the restriction of </span>f<span class="math"> to </span>\\tilde{D}<span class="math">. Given a distribution </span>\\mathcal{D}<span class="math">, we write </span>x\\leftarrow\\mathcal{D}<span class="math"> to denote that </span>x<span class="math"> is sampled according to </span>\\mathcal{D}<span class="math">. We denote by </span>\\mathbb{F}<span class="math"> a finite field and by </span>\\mathbb{F}_{q}<span class="math"> the field of size </span>q<span class="math">. Arithmetic operations over </span>\\mathbb{F}_{q}<span class="math"> take time </span>\\operatorname{polylog}q<span class="math"> and space </span>O(\\log q)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Polynomials. We denote by <span class="math">\\mathbb{F}[X_{1,\\ldots,m}]</span> the ring of polynomials in <span class="math">m</span> variables over <span class="math">\\mathbb{F}</span>. Given a polynomial <span class="math">P</span> in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}]</span>, <span class="math">\\operatorname{deg}_{X_{i}}(P)</span> is the degree of <span class="math">P</span> in the variable <span class="math">X_{i}</span>. The <em>individual degree</em> of a polynomial is its maximum degree in any variable, <span class="math">\\max_{1\\leq i\\leq m}\\operatorname{deg}_{X_{i}}(P)</span>; we always refer to the individual degree unless otherwise specified. We denote by <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span> the subspace consisting of <span class="math">P\\in\\mathbb{F}[X_{1,\\ldots,m}]</span> with individual degree at most <span class="math">d</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Languages and relations. We denote by <span class="math">\\mathscr{L}</span> a language consisting of <em>instances</em> <span class="math">\\mathbf{x}</span>, and by <span class="math">\\mathscr{R}</span> a (binary ordered) relation consisting of pairs <span class="math">(\\mathbf{x},\\mathbf{w})</span>, where <span class="math">\\mathbf{x}</span> is the <em>instance</em> and <span class="math">\\mathbf{w}</span> is the <em>witness</em>. We denote by <span class="math">\\operatorname{Lan}(\\mathscr{R})</span> the language corresponding to <span class="math">\\mathscr{R}</span>, and by $\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbf{x}}<span class="math"> the set of witnesses in </span>\\mathscr{R}<span class="math"> for </span>\\mathbf{x}<span class="math"> (if </span>\\mathbf{x}\\not\\in\\operatorname{Lan}(\\mathscr{R})<span class="math"> then </span>\\mathscr{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathbf{x}}:=\\emptyset<span class="math">). As always, we assume that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is bounded by some computable function of </span>n:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; in fact, we are mainly interested in relations arising from nondeterministic languages: </span>\\mathscr{R}\\in\\mathbf{NTIME}(T)<span class="math"> if there exists a </span>T(n)<span class="math">-time machine </span>M<span class="math"> such that </span>M(\\mathbf{x},\\mathbf{w})<span class="math"> outputs </span>1<span class="math"> if and only if </span>(\\mathbf{x},\\mathbf{w})\\in\\mathscr{R}<span class="math">. Throughout, we assume that </span>T(n)\\geq n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Low-degree extensions. Let <span class="math">\\mathbb{F}</span> be a finite filed, <span class="math">H</span> a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">m</span> a positive integer. The <em>low-degree extension</em> (LDE) of a function <span class="math">f\\colon H^{m}\\to\\mathbb{F}</span> is denoted <span class="math">\\hat{f}</span> and is the unique polynomial in $\\mathbb{F}[X_{1,\\ldots,m}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}]<span class="math"> that agrees with </span>f<span class="math"> on </span>H^{m}<span class="math">. In particular, </span>\\hat{f}\\colon\\mathbb{F}^{m}\\to\\mathbb{F}$ is defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\hat{f}(\\vec{X}):=\\sum_{\\vec{\\beta}\\in H^{m}}I_{H^{m}}(\\vec{X},\\vec{\\beta})\\cdot f(\\vec{\\beta})\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">I_{H^{m}}(\\vec{X},\\vec{Y}):=\\prod_{i=1}^{m}\\sum_{\\omega\\in H}\\prod_{\\gamma\\in H\\setminus\\{\\omega\\}}\\frac{(X_{i}-\\gamma)(Y_{i}-\\gamma)}{(\\omega-\\gamma)^{2}}</span> is the unique polynomial in $\\mathbb{F}[X_{1,\\ldots,m}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}]<span class="math"> such that, for all </span>(\\vec{\\alpha},\\vec{\\beta})\\in H^{m}\\times H^{m}<span class="math">, </span>I_{H^{m}}(\\vec{\\alpha},\\vec{\\beta})<span class="math"> equals </span>1<span class="math"> when </span>\\vec{\\alpha}=\\vec{\\beta}<span class="math"> and equals </span>0<span class="math"> otherwise. Note that </span>I_{H^{m}}(\\vec{X},\\vec{Y})<span class="math"> can be generated and evaluated in time </span>\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and space </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log m)<span class="math">, so </span>\\hat{f}(\\vec{\\alpha})<span class="math"> can be evaluated in time </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m}\\cdot\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and space </span>O(m\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.2 Sampling partial sums of random low-degree polynomials</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">m,d</span> positive integers, and <span class="math">H</span> a subset of <span class="math">\\mathbb{F}</span>, and recall that <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span> is the subspace of <span class="math">\\mathbb{F}[X_{1,\\ldots,m}]</span> consisting of those polynomials with individual degrees at most <span class="math">d</span>. Given <span class="math">Q\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span> and <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{\\leq m}</span> (vectors over <span class="math">\\mathbb{F}</span> of length at most <span class="math">m</span>), we define $Q(\\vec{\\alpha}):=\\sum_{\\vec{\\gamma}\\in H^{m-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}Q(\\vec{\\alpha},\\vec{\\gamma})<span class="math">, i.e., the answer to a query that specifies only a prefix of the variables is the sum of the values obtained by letting the remaining variables range over </span>H$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Section 6 we rely on the fact, formally stated below and proved in <em>[x1]</em>, that one can efficiently sample the distribution <span class="math">R(\\vec{\\alpha})</span>, where <span class="math">R</span> is uniformly random in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]</span> and <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{\\leq m}</span> is fixed, <em>even conditioned on any polynomial number of (consistent) values for <span class="math">R(\\vec{\\alpha}_{1}),\\ldots,R(\\vec{\\alpha}_{\\ell})</span></em> (with <span class="math">\\vec{\\alpha}_{1},\\ldots,\\vec{\\alpha}_{\\ell}\\in\\mathbb{F}^{\\leq m}</span>). More precisely, the sampling algorithm runs in time that is only $\\operatorname{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell)<span class="math">, which is much faster than the trivial running time of </span>\\Omega(d^{m})<span class="math"> achieved by sampling </span>R$ explicitly. This “succinct” sampling follows from the notion of <em>succinct constraint detection</em> studied in <em>[x1]</em> for the case of partial sums of low-degree polynomials.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-30" class="text-base font-medium mt-4">Corollary 4.1 (<em>[x1]</em>).</h6>

    <p class="text-gray-300">There exists a probabilistic algorithm <span class="math">\\mathcal{A}</span> such that, for every finite field <span class="math">\\mathbb{F}</span>, positive integers <span class="math">m,d</span>, subset <span class="math">H</span> of <span class="math">\\mathbb{F}</span>, subset <span class="math">S=\\{(\\alpha_{1},\\beta_{1}),\\ldots,(\\alpha_{\\ell},\\beta_{\\ell})\\}\\subseteq\\mathbb{F}^{\\leq m}\\times\\mathbb{F}</span>, and <span class="math">(\\alpha,\\beta)\\in\\mathbb{F}^{\\leq m}\\times\\mathbb{F}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\Big{[}\\mathcal{A}(\\mathbb{F},m,d,H,S,\\alpha)=\\beta\\Big{]}=\\Pr_{R\\leftarrow\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]}\\left[R(\\alpha)=\\beta\\begin{array}[]{c}R(\\alpha_{1})=\\beta_{1}\\\\ \\vdots\\\\ R(\\alpha_{\\ell})=\\beta_{\\ell}\\end{array}\\right]\\enspace. \\]</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover <span class="math">\\mathcal{A}</span> runs in time $m(d\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+d^{3}\\ell^{3})\\cdot\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\ell^{3}\\cdot\\mathrm{poly}(m,d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.3 Interactive probabilistically checkable proofs</h3>

    <p class="text-gray-300">An <em>Interactive Probabilistically Checkable Proof</em> (Interactive PCP, IPCP) <em>[x13]</em> is a Probabilistically Checkable Proof <em>[x2, x11, x1, x3]</em> followed by an Interactive Proof <em>[x4, x12]</em>. Namely, the prover <span class="math">P</span> and verifier <span class="math">V</span> interact as follows: <span class="math">P</span> sends to <span class="math">V</span> a probabilistically checkable proof <span class="math">\\pi</span>; afterwards, <span class="math">P</span> and <span class="math">V^{\\pi}</span> engage in an interactive proof. Thus, <span class="math">V</span> may read a few bits of <span class="math">\\pi</span> but must read subsequent messages from <span class="math">P</span> in full. An <em>IPCP system</em> for a relation <span class="math">\\mathscr{R}</span> is thus a pair <span class="math">(P,V)</span>, where <span class="math">P,V</span> are probabilistic interactive algorithms working as described, that satisfies naturally-defined notions of perfect completeness and soundness with a given error <span class="math">\\varepsilon(\\cdot)</span>; see <em>[x13]</em> for details.</p>

    <p class="text-gray-300">We say that an IPCP has <span class="math">\\mathsf{k}</span> rounds if this “PCP round” is followed by a <span class="math">\\mathsf{k}</span>-round interactive proof. (Though note that <em>[x5]</em> counts the PCP round towards round complexity.) Beyond round complexity, we also measure how many bits the prover sends and how many the verifier reads: the <em>proof length</em> <span class="math">\\mathsf{l}</span> is the length of <span class="math">\\pi</span> in bits plus the number of bits in all subsequent prover messages; the <em>query complexity</em> <span class="math">\\mathsf{q}</span> is the number of bits of <span class="math">\\pi</span> read by the verifier plus the number of bits in all subsequent prover messages (since the verifier must read all of those bits).</p>

    <p class="text-gray-300">In this work, we do not count the number of bits in the verifier messages, nor the number of random bits used by the verifier; both are bounded from above by the verifier’s running time, which we do consider. Overall, we say that a language <span class="math">\\mathscr{L}</span> (resp., relation <span class="math">\\mathscr{R}</span>) belongs to the complexity class <span class="math">\\mathbf{IPCP}[\\varepsilon,\\mathsf{k},\\mathsf{l},\\mathsf{q}]</span> if there is an IPCP system for <span class="math">\\mathscr{L}</span> (resp., <span class="math">\\mathscr{R}</span>) in which: (1) the soundness error is <span class="math">\\varepsilon(n)</span>; (2) the number of rounds is at most <span class="math">\\mathsf{k}(n)</span>; (3) the proof length is at most <span class="math">\\mathsf{l}(n)</span>; (4) the query complexity is at most <span class="math">\\mathsf{q}(n)</span>. We sometimes also specify the time and/or space complexity of the (honest) prover algorithm and/or (honest) verifier algorithm.</p>

    <p class="text-gray-300">Finally, an IPCP is <em>non-adaptive</em> if the verifier queries are non-adaptive, i.e., the queried locations depend only on the verifier’s inputs; it is <em>public-coin</em> if each verifier message is chosen uniformly and independently at random, and all of the verifier queries happen after receiving the last prover message. <em>All of the IPCPs discussed in this paper are both non-adaptive and public-coin.</em></p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">4.4 Zero knowledge for Interactive PCPs</h3>

    <p class="text-gray-300">We define the notion of zero knowledge for IPCPs that we consider: <em>perfect zero knowledge via straightline simulators</em>. This notion is quite strong not only because it unconditionally guarantees perfect simulation of the verifier’s view but also because straightline simulation typically implies desirable properties. We first provide context and then definitions.</p>

    <p class="text-gray-300">At a high level, zero knowledge requires that the verifier’s view can be efficiently simulated without the prover. Converting the informal statement into a mathematical one involves many choices, including choosing which verifier class to consider (e.g., the honest verifier? all polynomial-time verifiers?), the quality of the simulation (e.g., is it identically distributed to the view? statistically close to it? computationally close to it?), the simulator’s dependence on the verifier (e.g., is it non-uniform? or is the simulator universal?), and others. The definition below considers the case of perfect simulation via universal simulators against verifiers making a bounded number of queries to the proof oracle.</p>

    <p class="text-gray-300">Moreover, in the case of universal simulators, one distinguishes between a non-blackbox use of the verifier, which means that the simulator takes the verifier’s code as input, and a blackbox use of it, which means that the simulator only accesses the verifier via a restricted interface; we consider this latter case. Different models of proof systems call for different interfaces, which grant carefully-chosen “extra powers” to the simulator (in comparison to the prover) so to ensure that efficiency of the simulation does not imply the ability to efficiently decide the language. For example: in ZK IPs, the simulator may rewind the verifier; in ZK PCPs, the simulator may adaptively answer oracle queries. In ZK IPCPs (our setting), the natural definition would allow a blackbox simulator to rewind the verifier <em>and also</em> to adaptively answer oracle queries. The definition below, however, considers only simulators that are straightline <em>[x10, x11]</em>, that is they do not rewind the verifier, because our constructions achieve this stronger notion.</p>

    <p class="text-gray-300">We are now ready to define the notion of perfect zero knowledge via straightline simulators for IPCPs <em>[x11]</em>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">Let <span class="math">A,B</span> be algorithms and <span class="math">x,y</span> strings. We denote by <span class="math">\\mathrm{View}\\ \\langle B(y),A(x)\\rangle</span> the view of <span class="math">A(x)</span> in an IPCP protocol with <span class="math">B(y)</span>, i.e., the random variable <span class="math">(x,r,s_{1},\\ldots,s_{n},t_{1},\\ldots,t_{m})</span> where <span class="math">x</span> is <span class="math">A</span>’s input, <span class="math">r</span> is <span class="math">A</span>’s randomness, <span class="math">s_{1},\\ldots,s_{n}</span> are <span class="math">B</span>’s messages, and <span class="math">t_{1},\\ldots,t_{m}</span> are the answers to <span class="math">A</span>’s queries to the proof oracle sent by <span class="math">B</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Straightline simulators in the context of IPs were used in <em>[x10]</em>, and later defined in <em>[x11]</em>. The definition below considers this notion in the context of IPCPs, where the simulator also has to answer oracle queries by the verifier. Note that since we consider the notion of perfect zero knowledge, the definition of straightline simulation needs to allow the efficient simulator to work even with inefficient verifiers <em>[x14]</em>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 4.3.</h6>

    <p class="text-gray-300">We say that an algorithm <span class="math">B</span> has straightline access to another algorithm <span class="math">A</span> if <span class="math">B</span> interacts with <span class="math">A</span>, without rewinding, by exchanging messages with <span class="math">A</span> and also answering any oracle queries along the way. We denote by <span class="math">B^{A}</span> the concatenation of <span class="math">A</span>’s random tape and <span class="math">B</span>’s output. (Since <span class="math">A</span>’s random tape could be super-polynomially large, <span class="math">B</span> cannot sample it for <span class="math">A</span> and then output it; instead, we restrict <span class="math">B</span> to not see it, and we prepend it to <span class="math">B</span>’s output.)</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An IPCP system <span class="math">(P,V)</span> for a relation <span class="math">\\mathscr{R}</span> is perfect zero knowledge (via straightline simulators) against unbounded queries (resp., against query bound <span class="math">\\mathtt{b}</span>) with simulator overhead <span class="math">s\\colon\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}</span> if there exists a simulator algorithm <span class="math">S</span> such that for every algorithm (resp., <span class="math">\\mathtt{b}</span>-query algorithm) <span class="math">\\tilde{V}</span> and instance-witness pair <span class="math">(\\mathtt{x},\\mathtt{w})\\in\\mathscr{R}</span>, <span class="math">S^{\\tilde{V}}(\\mathtt{x})</span> and <span class="math">\\mathrm{View}\\ \\langle P(\\mathtt{x},\\mathtt{w}),\\tilde{V}(\\mathtt{x})\\rangle</span> are identically distributed. Moreover, <span class="math">S</span> must run in time $O(s(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\mathtt{q}_{\\tilde{V}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathtt{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)))<span class="math">, where </span>\\mathtt{q}_{\\tilde{V}}(\\cdot)<span class="math"> is </span>\\tilde{V}$’s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The case of a language <span class="math">\\mathscr{L}</span> is similar: the quantification is for all <span class="math">\\mathtt{x}\\in\\mathscr{L}</span> and the view to simulate is <span class="math">\\mathrm{View}\\ \\langle P(\\mathtt{x}),\\tilde{V}(\\mathtt{x})\\rangle</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Remark 4.5.</h6>

    <p class="text-gray-300">Throughout this paper, an algorithm is <span class="math">\\mathtt{b}</span>-query if it makes strictly fewer than <span class="math">\\mathtt{b}</span> queries to its oracle. This is because all of our results will be of a ‘query threshold’ character, i.e. if the verifier makes <span class="math">\\mathtt{b}</span> queries it learns some information, but any verifier making strictly fewer queries learns nothing.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 4.6.</h6>

    <p class="text-gray-300">The standard definition of zero knowledge allows the simulator overhead <span class="math">s</span> to be any fixed polynomial.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Remark 4.7.</h6>

    <p class="text-gray-300">The definition above places a strict bound on the running time of the simulator. This is in contrast to most zero knowledge results, which can only bound its expected running time.</p>

    <p class="text-gray-300">We say that a language <span class="math">\\mathscr{L}</span> (resp., relation <span class="math">\\mathscr{R}</span>) belongs to the complexity class <span class="math">\\mathbf{PZK\\text{-}IPCP}[\\varepsilon,\\mathtt{k},\\mathtt{l},\\mathtt{q},\\mathtt{b},s]</span> if there is an IPCP system for <span class="math">\\mathscr{L}</span> (resp., <span class="math">\\mathscr{R}</span>), with the corresponding parameters, that is perfect zero knowledge with query bound <span class="math">\\mathtt{b}</span>; also, it belongs to the complexity class <span class="math">\\mathbf{PZK\\text{-}IPCP}[\\varepsilon,\\mathtt{k},\\mathtt{l},\\mathtt{q},*,s]</span> if the same is true with unbounded queries. In this paper we only consider zero knowledge against bounded queries. (Note that, even in this case, one can ‘cover’ all polynomial-time malicious verifiers by setting <span class="math">\\mathtt{b}</span> to be superpolynomial in the input size.)</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 4.8.</h6>

    <p class="text-gray-300">Kalai and Raz <em>[x16]</em> give a general transformation for IPCPs that reduces the verifier’s query complexity <span class="math">\\mathtt{q}</span> to <span class="math">1</span>. The transformation preserves our zero knowledge guarantee, with a small increase in the simulator overhead.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">4.5 Sumcheck protocol and its zero knowledge variant</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The sumcheck protocol <em>[x12]</em> is a fundamental building block of numerous results in complexity theory and cryptography. We rely on it in Section 6, so we briefly review it here. The protocol consists of an Interactive Proof for a claim of the form “<span class="math">\\sum_{\\alpha_{1},\\ldots,\\alpha_{m}\\in H}F(\\alpha_{1},\\ldots,\\alpha_{m})=a</span>”, where <span class="math">F</span> is an <span class="math">m</span>-variate polynomial of individual degree <span class="math">d</span> with coefficients in a finite field <span class="math">\\mathbb{F}</span>, <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">a</span> is an element of <span class="math">\\mathbb{F}</span>. The prover and verifier receive <span class="math">(\\mathbb{F},m,d,H,a)</span> as input; in addition, the prover receives <span class="math">F</span> as input while the verifier has only oracle access to <span class="math">F</span>. In the <span class="math">i</span>-th round, the prover sends the univariate polynomial <span class="math">F_{i}(X):=\\sum_{\\alpha_{i+1},\\ldots,\\alpha_{m}\\in H}F(c_{1},\\ldots,c_{i-1},X,\\alpha_{i+1},\\ldots,\\alpha_{m})</span>, and the verifier replies with a uniformly random element <span class="math">c_{i}\\in\\mathbb{F}</span> and checks that <span class="math">F_{i-1}(c_{i-1})=\\sum_{\\alpha\\in H}F_{i}(\\alpha)</span> (defining <span class="math">F_{0}(c_{0})</span> to be the element <span class="math">a</span>). At the end of the interaction, the verifier also checks that <span class="math">F_{m}(c_{m})=F(c_{1},\\ldots,c_{m})</span>, by querying <span class="math">F</span> at the random location <span class="math">(c_{1},\\ldots,c_{m})</span>. This interactive proof is public-coin, and has <span class="math">m</span> rounds, communication complexity $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m)<span class="math">, and soundness error </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. The prover runs in time </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m})<span class="math"> and space </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verifier runs in time </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and space </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot m)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The sumcheck protocol is not zero knowledge, because the prover reveals partial sums of <span class="math">F</span> to the verifier. If we assume the existence of one-way functions, the protocol can be made computational zero knowledge by leveraging the fact that it is public-coin <em>[x13, x20, x1]</em> (in fact, if we further assume the hardness of certain problems related to discrete logarithms then more efficient transformations are known <em>[x7]</em>); moreover, there is strong evidence that assuming one-way functions is necessary <em>[x21, x22]</em>. Even more, achieving statistical zero knowledge for sumcheck instances would cause unlikely complexity-theoretic collapses <em>[x10, x2]</em>.</p>

    <p class="text-gray-300">###</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Nevertheless, <em>[x1]</em> have shown that, in the <em>Interactive PCP</em> model (see Section 4.3), a simple variant of the sumcheck protocol is <em>perfect zero knowledge</em>. The variant is as follows: the prover sends a proof oracle containing the evaluation of a random <span class="math">m</span>-variate polynomial <span class="math">A</span> of individual degree <span class="math">d</span>, conditioned on summing to <span class="math">0</span> on <span class="math">H^{m}</span>; the verifier replies with a random element <span class="math">\\rho\\in\\mathbb{F}</span>; then the prover and verifier engage in a sumcheck protocol for the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}\\rho F(\\vec{\\alpha})+A(\\vec{\\alpha})=a</span>”, with the verifier accessing <span class="math">A</span> via self-correction (after low-degree testing it). The proof oracle thus consists of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m}<span class="math"> field elements, and the verifier accesses only </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d)$ of them.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The auxiliary polynomial <span class="math">A</span> acts as a “masking polynomial”, and yields the following zero knowledge guarantee: there exists a polynomial-time simulator algorithm that perfectly simulates the view of any malicious verifier, provided it can query <span class="math">F</span> in as many locations as the <em>total</em> number of queries that the malicious verifier makes to either <span class="math">F</span> or <span class="math">A</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Algebraic query complexity of polynomial summation</p>

    <p class="text-gray-300">We have described in Section 2.2 an algebraic commitment scheme based on the sumcheck protocol and lower bounds on the algebraic query complexity of polynomial summation. The purpose of this section is to describe this construction in more detail, and then provide formal statements for the necessary lower bounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We begin with the case of committing to a single element <span class="math">a\\in\\mathbb{F}</span>. The prover chooses a uniformly random string <span class="math">B\\in\\mathbb{F}^{N}</span> such that <span class="math">\\sum_{i=1}^{N}B_{i}=a</span>, for some <span class="math">N\\in\\mathbb{N}</span>. Fixing some <span class="math">d\\in\\mathbb{N}</span>, <span class="math">G\\subseteq\\mathbb{F}</span> and <span class="math">k\\in\\mathbb{N}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq d+1<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}=N<span class="math">, the prover views </span>B<span class="math"> as a function from </span>G^{k}<span class="math"> to </span>\\mathbb{F}<span class="math"> (via an ordering on </span>G^{k}<span class="math">) and sends the evaluation of a degree-</span>d<span class="math"> extension </span>\\hat{B}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}<span class="math"> of </span>B<span class="math">. The verifier tests that </span>\\hat{B}<span class="math"> is indeed (close to) a low-degree polynomial but (ideally) cannot learn any information about </span>a<span class="math"> without reading <em>all</em> of </span>B<span class="math"> (i.e., without making </span>N<span class="math"> queries). Subsequently, the prover can decommit to </span>a<span class="math"> by convincing the verifier that </span>\\sum_{\\vec{\\beta}\\in G^{k}}\\hat{B}(\\vec{\\beta})=a$ via the sumcheck protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To show that the above is a commitment scheme, we must show both binding and hiding. Both properties depend on the choice of <span class="math">d</span>. The binding property follows from the soundness of the sumcheck protocol, and we thus would like the degree <span class="math">d</span> of <span class="math">\\hat{B}</span> to be as small as possible. A natural choice would be <span class="math">d=1</span> (so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math">), which makes </span>\\hat{B}<span class="math"> the unique multilinear extension of </span>B<span class="math">. However (as discussed in Section 2.2) this choice of parameters does not provide any hiding: it holds that </span>\\sum_{\\beta\\in\\{0,1\\}^{k}}B(\\beta)=\\hat{B}(2^{-1},\\ldots,2^{-1})\\cdot 2^{k}<span class="math"> (as long as </span>\\operatorname{char}(\\mathbb{F})\\neq 2<span class="math">). We therefore need to understand how the choice of </span>d<span class="math"> affects the number of queries to </span>\\hat{B}<span class="math"> required to compute </span>a$. This is precisely the setting of <em>algebraic query complexity</em>, which we discuss next.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The algebraic query complexity (defined in <em>[x1]</em> to study ‘algebrization’) of a function <span class="math">f</span> is the (worst-case) number of queries to some low-degree extension <span class="math">\\hat{B}</span> of a string <span class="math">B</span> required to compute <span class="math">f(B)</span>. This quantity is bounded from above by the standard query complexity of <span class="math">f</span>, but it may be the case (as above) that the low-degree extension confers additional information that helps in computing <span class="math">f</span> with fewer queries. The usefulness of this information depends on parameters <span class="math">d</span> and <span class="math">G</span> of the low-degree extension. Our question amounts to understanding this dependence for the function <span class="math">\\textsc{Sum}\\colon\\mathbb{F}^{N}\\to\\mathbb{F}</span> given by <span class="math">\\textsc{Sum}(B):=\\sum_{i=1}^{N}B_{i}</span>. This has been studied before in <em>[x10]</em>: if <span class="math">G=\\{0,1\\}</span> and <span class="math">d=2</span> then the algebraic query complexity of <span class="math">\\textsc{Sum}</span> is exactly <span class="math">N</span>.</p>

    <p class="text-gray-300">For our purposes, however, it is not enough to commit to a single field element. Rather, we need to commit to the evaluation of a polynomial <span class="math">Q\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> of degree <span class="math">d_{Q}</span>, which we do as follows. Let <span class="math">K</span> be a subset of <span class="math">\\mathbb{F}</span> of size <span class="math">d_{Q}+1</span>. The prover samples, for each <span class="math">\\vec{\\alpha}\\in K^{m}</span>, a random string <span class="math">B^{\\vec{\\alpha}}\\in\\mathbb{F}^{N}</span> such that <span class="math">\\textsc{Sum}(B^{\\vec{\\alpha}})=Q(\\vec{\\alpha})</span>. The prover views these strings as a function <span class="math">B\\colon K^{m}\\times G^{k}\\to\\mathbb{F}</span>, and takes a low-degree extension <span class="math">\\hat{B}\\colon\\mathbb{F}^{m}\\times\\mathbb{F}^{k}\\to\\mathbb{F}</span>. The polynomial <span class="math">\\hat{B}(\\vec{X},\\vec{Y})</span> has degree <span class="math">d_{Q}</span> in <span class="math">\\vec{X}</span> and <span class="math">d</span> in <span class="math">\\vec{Y}</span>; this is a commitment to <span class="math">Q</span> because <span class="math">\\sum_{\\vec{\\beta}\\in G^{k}}\\hat{B}(\\vec{X},\\vec{\\beta})</span> is a degree-<span class="math">d_{Q}</span> polynomial that agrees with <span class="math">Q</span> on <span class="math">K^{m}</span>, and therefore equals <span class="math">Q</span>.</p>

    <p class="text-gray-300">Once again we will decommit to <span class="math">Q(\\vec{\\alpha})</span> using the sumcheck protocol, and so for binding we need <span class="math">d</span> to be small. For hiding, as in the single-element case, if <span class="math">d</span> is too small then a few queries to <span class="math">\\hat{\\mathcal{B}}</span> can yield information about <span class="math">Q</span>. Moreover, it could be the case that the verifier can leverage the fact that <span class="math">\\hat{\\mathcal{B}}</span> is a <em>joint</em> low-degree extension to learn some linear combination of evaluations of <span class="math">Q</span>. We must exclude these possibilities in order to obtain our zero knowledge guarantees.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This question amounts to a generalization of algebraic query complexity where, given a list of strings <span class="math">B_{1},\\ldots,B_{M}</span>, we determine how many queries we need to make to their <em>joint</em> low-degree extension <span class="math">\\hat{B}</span> to determine any nontrivial linear combination <span class="math">\\sum_{i=1}^{M}c_{i}\\cdot\\textsc{Sum}(B_{i})</span>. We will show that the ‘generalized’ algebraic query complexity of <span class="math">\\textsc{Sum}</span> is exactly <span class="math">N</span> provided $d\\geq 2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)$ (which is also the case for the standard algebraic query complexity).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the remainder of the section we state our results in a form equivalent to the above that is more useful to us. Given an arbitrary polynomial <span class="math">Z\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq d^{\\prime}}]</span>, we ask how many queries are required to determine any nontrivial linear combination of <span class="math">\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})</span> for <span class="math">\\vec{\\alpha}\\in\\mathbb{F}^{m}</span>. The following theorem is more general: it states that not only do we require many queries to determine <em>any</em> linear combination, but that the number of queries grows linearly with the number of independent combinations that we wish to learn.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 5.1 (algebraic query complexity of polynomial summation).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a field, <span class="math">m,k,d,d^{\\prime}\\in\\mathbb{N}</span>, and <span class="math">G,K,L</span> be finite subsets of <span class="math">\\mathbb{F}</span> such that <span class="math">K\\subseteq L</span>, $d^{\\prime}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math">, and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=d+1<span class="math">. If </span>S\\subseteq\\mathbb{F}^{m+k}<span class="math"> is such that there exist matrices </span>C\\in\\mathbb{F}^{L^{m}\\times\\ell}<span class="math"> and </span>D\\in\\mathbb{F}^{S\\times\\ell}<span class="math"> such that for all </span>Z\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq d^{\\prime}}]<span class="math"> and all </span>i\\in\\{1,\\ldots,\\ell\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\alpha}\\in L^{m}}C_{\\vec{\\alpha},i}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})=\\sum_{\\vec{q}\\in S}D_{\\vec{q},i}Z(\\vec{q})\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\mathrm{rank}(BC) \\cdot (\\min\\{d' -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\})^k<span class="math">, where </span>B \\in \\mathbb{F}^{K^m \\times L^m}<span class="math"> is such that column </span>\\vec{\\alpha}<span class="math"> of </span>B<span class="math"> represents </span>Z(\\vec{\\alpha})<span class="math"> in the basis </span>(Z(\\vec{\\beta}))_{\\vec{\\beta} \\in K^m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe a special case of the above theorem that is necessary for our zero knowledge results, and then give an equivalent formulation in terms of random variables that we use in later sections. (Essentially, the linear structure of the problem implies that 'worst-case' statements are equivalent to 'average-case' statements.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 5.2. Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">G</span> be a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">d, d&#x27; \\in \\mathbb{N}</span> with $d' \\geq 2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)<span class="math">. If </span>S \\subseteq \\mathbb{F}^{m + k}<span class="math"> is such that there exist </span>(c_{\\vec{\\alpha}})_{\\vec{\\alpha} \\in \\mathbb{F}^m}<span class="math"> and </span>(d_{\\vec{\\beta}})_{\\vec{\\beta} \\in \\mathbb{F}^{m + k}}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq d&#x27;}]</span> it holds that <span class="math">\\sum_{\\vec{\\alpha} \\in \\mathbb{F}^m} c_{\\vec{\\alpha}} \\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y}) = \\sum_{\\vec{q} \\in S} d_{\\vec{q}} Z(\\vec{q})</span> and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- there exists <span class="math">Z&#x27; \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq d&#x27;}]</span> such that <span class="math">\\sum_{\\vec{\\alpha} \\in \\mathbb{F}^m} c_{\\vec{\\alpha}} \\sum_{\\vec{y} \\in G^k} Z&#x27;(\\vec{\\alpha}, \\vec{y}) \\neq 0</span>, then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 5.3 (equivalent statement of Corollary 5.2). Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">G</span> be a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">d, d&#x27; \\in \\mathbb{N}</span> with $d' \\geq 2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)<span class="math">. Let </span>Q<span class="math"> be a subset of </span>\\mathbb{F}^{m + k}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k<span class="math"> and let </span>Z<span class="math"> be uniformly random in </span>\\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq d'}]<span class="math">. The ensembles </span>\\left(\\sum_{\\vec{y} \\in G^k} Z(\\vec{\\alpha}, \\vec{y})\\right)_{\\vec{\\alpha} \\in \\mathbb{F}^m}<span class="math"> and </span>\\left(Z(\\vec{q})\\right)_{\\vec{q} \\in Q}$ are independent.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proofs of these results, and derivations of corresponding upper bounds, are provided in Appendix A.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">6 Zero knowledge sumcheck from algebraic query lower bounds</p>

    <p class="text-gray-300">We leverage lower bounds on the algebraic query complexity of polynomial summation (Section 5) to obtain an analogue of the sumcheck protocol with a strong zero knowledge guarantee, which we use in the applications that we consider.</p>

    <p class="text-gray-300">The sumcheck protocol <em>[x14]</em> is an Interactive Proof for claims of the form <span class="math">\\sum_{\\vec{x}\\in H^{m}}F(\\vec{x})=a</span>, where <span class="math">H</span> is a subset of a finite field <span class="math">\\mathbb{F}</span>, <span class="math">F</span> is an <span class="math">m</span>-variate polynomial over <span class="math">\\mathbb{F}</span> of individual degree at most <span class="math">d</span>, and <span class="math">a</span> is an element of <span class="math">\\mathbb{F}</span>. The sumcheck protocol is <em>not</em> zero knowledge (conjecturally).</p>

    <p class="text-gray-300">Prior work <em>[x1]</em> obtains a sumcheck protocol, in the Interactive PCP model, with a certain zero knowledge guarantee. In that protocol, the prover first sends a proof oracle that consists of the evaluation of a random <span class="math">m</span>-variate polynomial <span class="math">R</span> of individual degree at most <span class="math">d</span>; after that, the prover and the verifier run the (standard) sumcheck protocol on a new polynomial obtained from <span class="math">F</span> and <span class="math">R</span>. The purpose of <span class="math">R</span> is to ‘mask’ the partial sums, which are the intermediate values sent by the prover during the sumcheck protocol.</p>

    <p class="text-gray-300">The zero knowledge guarantee in <em>[x1]</em> is the following: <em>any verifier that makes <span class="math">q</span> queries to <span class="math">R</span> learns at most <span class="math">q</span> evaluations of <span class="math">F</span></em>. This guarantee suffices to obtain a zero knowledge protocol for <span class="math">\\#\\mathbf{P}</span> (the application in <em>[x1]</em>) because the verifier can evaluate <span class="math">F</span> efficiently at any point (as <span class="math">F</span> is merely an arithmetization of a 3SAT formula).</p>

    <p class="text-gray-300">We achieve a much stronger guarantee: <em>any verifier that makes polynomially-many queries to <span class="math">R</span> learns at most a single evaluation of <span class="math">F</span></em> (that, moreover, lies within a chosen subset <span class="math">I^{m}</span> of <span class="math">\\mathbb{F}^{m}</span>). Our applications require this guarantee because we use the sumcheck simulator as a sub-simulator in a larger protocol, where <span class="math">F</span> is a randomized low-degree extension of some function that is hard to compute for the verifier. The randomization introduces bounded independence, which makes a small number of queries easy to simulate.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The main idea to achieve zero knowledge as above is the following. Rather than sending the masking polynomial <span class="math">R</span> directly, the prover sends a (perfectly-hiding and statistically-binding) commitment to it in the form of a random <span class="math">(m+k)</span>-variate polynomial <span class="math">Z</span>. The ‘real’ mask is recovered by summing out <span class="math">k</span> variables: <span class="math">R(\\vec{X}):=\\sum_{\\vec{\\beta}\\in G^{k}}Z(\\vec{X},\\vec{\\beta})</span>. Our lower bounds on the algebraic query complexity of polynomial summation (Section 5) imply that any <span class="math">q</span> queries to <span class="math">Z</span>, with $q<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}<span class="math">, yield <em>no information</em> about </span>R<span class="math">. The prover, however, can elect to decommit to </span>R(\\vec{c})<span class="math"> for a single point </span>\\vec{c}\\in I^{m}<span class="math"> chosen by the verifier. This is achieved using the zero knowledge sumcheck protocol of <em>[x1]</em> as a subroutine: the prover sends </span>w:=R(\\vec{c})<span class="math"> and then proves that </span>w=\\sum_{\\vec{\\beta}\\in G^{k}}Z(\\vec{c},\\vec{\\beta})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol thus proceeds as follows. Given a security parameter <span class="math">\\lambda\\in\\mathbb{N}</span>, the prover sends the evaluations of two polynomials <span class="math">Z\\in\\mathbb{F}[X^{\\leq d}_{1,\\ldots,m},Y^{\\leq 2\\lambda}_{1,\\ldots,k}]</span> and <span class="math">A\\in\\mathbb{F}[Y^{\\leq 2\\lambda}_{1,\\ldots,k}]</span> as proof oracles. The verifier checks that both of these evaluations are close to low-degree, and uses self-correction to make for querying them. The prover sends two field elements <span class="math">z_{1}</span> and <span class="math">z_{2}</span>, which are (allegedly) the summations of <span class="math">Z</span> and <span class="math">A</span> over <span class="math">H^{m}\\times G^{k}</span> and <span class="math">G^{k}</span>, respectively. The verifier replies with a random challenge <span class="math">\\rho\\in\\mathbb{F}\\setminus\\{0\\}</span>. The prover and the verifier then engage in the standard (not zero knowledge) sumcheck protocol on the claim “<span class="math">\\sum_{\\vec{\\alpha}\\in H^{m}}\\rho F(\\vec{\\alpha})+R(\\vec{\\alpha})=\\rho a+z_{1}</span>”. This reduces the correctness of this claim to checking a claim of the form “<span class="math">\\rho F(\\vec{c})+R(\\vec{c})=b</span>” for some <span class="math">\\vec{c}\\in I^{m}</span> and <span class="math">b\\in\\mathbb{F}</span>; the prover then decommits to <span class="math">w:=R(\\vec{c})</span> as above. In sum, the verifier deduces that, with high probability, the claim “<span class="math">\\rho F(\\vec{c})=b-w</span>” is true if and only if the original claim was.</p>

    <p class="text-gray-300">If the verifier could evaluate <span class="math">F</span> then the verifier could simply check the aforementioned claim and either accept or reject. We do not give the verifier access to <span class="math">F</span> and, instead, we follow <em>[x18]</em> and phrase sumcheck as a <em>reduction</em> from a claim about a sum of a polynomial over a large product space to a claim about the evaluation of that polynomial at a single point. This view of the sumcheck protocol is useful later on when designing more complex protocols, which employ sumcheck as a subprotocol. The completeness and soundness definitions below are thus modified according to this viewpoint, where the verifier simply outputs the claim at the end.</p>

    <p class="text-gray-300">Our protocol will be sound relative to a <em>promise variant</em> of the sumcheck protocol, which we now define.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 6.1.</h6>

    <p class="text-gray-300">The sumcheck relation and its promise variant are defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>The sumcheck relation is the relation <span class="math">\\mathscr{R}_{\\mathrm{SC}}</span> of instance-witness pairs <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)</span> such that:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span>, <span class="math">a</span> is an element of <span class="math">\\mathbb{F}</span>, and <span class="math">m,d</span> are positive integers with $\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{1}{2}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">F</span> is a polynomial in <span class="math">\\mathbb{F}[X^{\\leq d}_{1,\\ldots,m}]</span> and sums to <span class="math">a</span> on <span class="math">H^{m}</span>.</li>

      <li>The sumcheck promise relation is the pair of relations <span class="math">(\\mathscr{R}^{\\text{res}}_{\\mathrm{SC}},\\mathscr{R}^{\\text{no}}_{\\mathrm{SC}})</span> where <span class="math">\\mathscr{R}^{\\text{res}}_{\\mathrm{SC}}:=\\mathscr{R}_{\\mathrm{SC}}</span> and <span class="math">\\mathscr{R}^{\\text{no}}_{\\mathrm{SC}}</span> are the pairs <span class="math">\\left((\\mathbb{F},m,d,H,a),F\\right)</span> such that <span class="math">(\\mathbb{F},m,d,H,a)</span> is as above and <span class="math">F</span> is in <span class="math">\\mathbb{F}[X^{\\leq d}_{1,\\ldots,m}]</span> but does <em>not</em> sum to <span class="math">a</span> on <span class="math">H^{m}</span>.</li>

    </ul>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 6.2.</h6>

    <p class="text-gray-300">In the case where the verifier can easily determine that <span class="math">F</span> is low-degree (e.g., <span class="math">F</span> is given as an arithmetic circuit), a protocol for the promise relation can be used to check the plain relation. In our setting, the verifier cannot even access <span class="math">F</span>, and so the promise is necessary.</p>

    <p class="text-gray-300">The definition below captures our zero knowledge goal for the sumcheck promise relation, in the Interactive PCP model. The key aspect of this definition is that the simulator is only allowed to make a <em>single</em> query to the summand polynomial <span class="math">F</span>; in contrast, the definition of <em>[x1]</em> allows the simulator to make as many queries to <span class="math">F</span> as the malicious verifier makes to the proof oracle. (Another aspect, motivated by the simulator’s limitation, is that we now have to explicitly consider a bound <span class="math">b</span> on a malicious verifier’s queries.) This <em>strong</em> form of zero knowledge, achieved by severely restricting the simulator’s access to <span class="math">F</span>, is crucial for achieving the results in our paper.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 6.3.</h6>

    <p class="text-gray-300">A <span class="math">b</span>-strong perfect zero knowledge Interactive PCP system for sumcheck with soundness error <span class="math">\\varepsilon</span> is a pair of interactive algorithms <span class="math">(P,V)</span> that satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For every <span class="math">\\big{(}(\\mathbb{F},m,d,H,a),F\\big{)}\\in\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{yes}}</span>, <span class="math">V(\\mathbb{F},m,d,H,a)</span> when interacting with <span class="math">P^{F}(\\mathbb{F},m,d,H,a)</span> outputs a claim of the form “<span class="math">F(\\vec{\\gamma})=a</span>” (with <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span> and <span class="math">a\\in\\mathbb{F}</span>) that is true with probability <span class="math">1</span>.</li>

      <li>Soundness. For every <span class="math">\\big{(}(\\mathbb{F},m,d,H,a),F\\big{)}\\in\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{no}}</span> and malicious prover <span class="math">\\tilde{P}</span>, <span class="math">V(\\mathbb{F},m,d,H,a)</span> when interacting with <span class="math">\\tilde{P}</span> outputs a claim of the form “<span class="math">F(\\vec{\\gamma})=a</span>” (with <span class="math">\\vec{\\gamma}\\in\\mathbb{F}^{m}</span> and <span class="math">a\\in\\mathbb{F}</span>) that is true with probability at most <span class="math">\\varepsilon</span>.</li>

      <li>Zero knowledge. There exists a straightline simulator <span class="math">S</span> such that, for every instance-witness pair <span class="math">\\big{(}(\\mathbb{F},m,d,H,a),F\\big{)}\\in\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{yes}}</span> and <span class="math">b</span>-query malicious verifier <span class="math">\\tilde{V}</span>, the following two distributions are equal</li>

    </ul>

    <p class="text-gray-300"><span class="math">S^{\\tilde{V},F}(\\mathbb{F},m,d,H,a)\\quad\\text{and}\\quad\\mathrm{View}\\,\\left\\langle P^{F}(\\mathbb{F},m,d,H,a),\\tilde{V}\\right\\rangle\\ .</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, the simulator <span class="math">S</span> makes only a single query to <span class="math">F</span> (at a location that possibly depends on <span class="math">\\tilde{V}</span> and its random choices) and runs in time $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\mathfrak{q}_{\\tilde{V}})<span class="math">, where </span>\\mathfrak{q}_{\\tilde{V}}<span class="math"> is </span>\\tilde{V}$’s query complexity.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main result of this section, stated below, is a construction that efficiently fulfills the definition above.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 6.4 (Strong PZK Sumcheck).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every positive integer <span class="math">\\lambda</span> with $\\lambda\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, positive integer </span>k<span class="math">, and subset </span>I<span class="math"> of </span>\\mathbb{F}<span class="math">, there exists a </span>\\lambda^{k}<span class="math">-strong perfect zero knowledge Interactive PCP system </span>(P,V)<span class="math"> for sumcheck with soundness error </span>\\varepsilon=O(\\frac{(m+k)\\cdot(d+\\lambda)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ and the following efficiency parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle round: <span class="math">P</span> sends an oracle proof string <span class="math">\\pi</span>, consisting of the evaluation tables of polynomials <span class="math">Z\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> and <span class="math">A\\in\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> drawn uniformly at random.</li>

      <li>Interactive proof: after the oracle round, <span class="math">P</span> and <span class="math">V</span> engage in an (<span class="math">m+k+1</span>)-round interactive proof; across the interaction, the verifier sends to the prover <span class="math">m+k+1</span> field elements, while the prover sends to the verifier <span class="math">O((m+k)\\cdot d)</span> field elements. (In particular, the interaction is public-coin.)</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Queries: after the interactive proof, <span class="math">V</span> non-adaptively queries <span class="math">\\pi</span> at $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d)$ locations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Space and time:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">P</span> runs in time $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{O(m+k)}<span class="math"> and space </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d^{m},\\lambda^{k},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition, there is a simulator <span class="math">S</span> witnessing perfect zero knowledge for <span class="math">(P,V)</span> such that <span class="math">S</span>’s single query to the summand polynomial <span class="math">F</span> belongs to the set <span class="math">I^{m}</span>, and <span class="math">S</span> runs in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d,k,\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot\\mathfrak{q}_{V}^{3}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 6.5.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With two-way access to the random tape, the prover can be made to run in space $\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,d,m,\\lambda,k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We divide the proof in two steps. First (Section 6.1), we exhibit a protocol with the above properties in a hybrid model in which the prover and verifier have access to random low-degree polynomials. Second (Section 6.2), we use low-degree testing and self-correction to ‘compile’ this protocol into an Interactive PCP.</p>

    <p class="text-gray-300">6.1 Step 1</p>

    <p class="text-gray-300">We construct a public-coin Interactive Proof for sumcheck that achieves zero knowledge in a model where the prover and verifier have access to certain low-degree polynomials. In the soundness case, these may be arbitrary; in the zero knowledge case, these are random and depend only on the size parameters of the instance.</p>

    <p class="text-gray-300"><strong>Construction 6.6.</strong> Let <span class="math">G</span> be any subset of <span class="math">\\mathbb{F}</span> of size <span class="math">\\lambda</span>. In the Interactive Proof system <span class="math">(P_{\\mathrm{IP}}^{\\star}, V_{\\mathrm{IP}}^{\\star})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> receive a sumcheck instance <span class="math">(\\mathbb{F}, m, d, H, a)</span> as common input;</li>

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> receive polynomials <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> and <span class="math">A \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> as oracles;</li>

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> additionally receives a summand polynomial <span class="math">F \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> as an oracle.</li>

    </ul>

    <p class="text-gray-300">The interaction between <span class="math">P_{\\mathrm{IP}}^{\\star}</span> and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> sends two elements in <span class="math">\\mathbb{F}</span> to <span class="math">V_{\\mathrm{IP}}^{\\star}</span>: <span class="math">z_1 := \\sum_{\\vec{\\alpha} \\in H^m} \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{\\alpha}, \\vec{\\beta})</span> and <span class="math">z_2 := \\sum_{\\vec{\\beta} \\in G^k} A(\\vec{\\beta})</span>.</li>

      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span> draws a random element <span class="math">\\rho_{1}</span> in <span class="math">\\mathbb{F} \\setminus \\{0\\}</span> and sends it to <span class="math">P_{\\mathrm{IP}}^{\\star}</span>.</li>

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> run the sumcheck IP [LFKN92] on the statement “<span class="math">\\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha}) = \\rho_1 a + z_1</span>” where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">Q(X_1, \\dots, X_m) := \\rho_1 F(X_1, \\dots, X_m) + \\sum_{\\vec{\\beta} \\in G^k} Z(X_1, \\dots, X_m, \\vec{\\beta}) \\text{ ,}</span></div>

    <p class="text-gray-300">with <span class="math">P_{\\mathrm{IP}}^{\\star}</span> playing the role of the prover and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> that of the verifier, and the following modification.</p>

    <p class="text-gray-300">For <span class="math">i = 1, \\ldots, m</span>, in the <span class="math">i</span>-th round, <span class="math">V_{\\mathrm{IP}}^{\\star}</span> samples its random element <span class="math">c_i</span> from the set <span class="math">I</span> rather than from all of <span class="math">\\mathbb{F}</span>; if <span class="math">P_{\\mathrm{IP}}^{\\star}</span> ever receives <span class="math">c_i \\in \\mathbb{F} \\setminus I</span>, it immediately aborts. In particular, in the <span class="math">m</span>-th round, <span class="math">P_{\\mathrm{IP}}^{\\star}</span> sends a polynomial <span class="math">g_m(X_m) := \\rho_1 F(c_1, \\ldots, c_{m-1}, X_m) + \\sum_{\\vec{\\beta} \\in G^k} Z(c_1, \\ldots, c_{m-1}, X_m, \\vec{\\beta})</span> for some <span class="math">c_1, \\ldots, c_{m-1} \\in I</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span> sends <span class="math">c_m \\in I</span> to <span class="math">P_{\\mathrm{IP}}^{\\star}</span>.</li>

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> sends the element <span class="math">w := \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta})</span> to <span class="math">V_{\\mathrm{IP}}^{\\star}</span>, where <span class="math">\\vec{c} := (c_1, \\ldots, c_m)</span>.</li>

      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span> draws a random element <span class="math">\\rho_2</span> in <span class="math">\\mathbb{F} \\setminus \\{0\\}</span> and sends it to <span class="math">P_{\\mathrm{IP}}^{\\star}</span>.</li>

      <li><span class="math">P_{\\mathrm{IP}}^{\\star}</span> and <span class="math">V_{\\mathrm{IP}}^{\\star}</span> engage in the sumcheck IP [LFKN92] on the claim “<span class="math">\\sum_{\\vec{\\beta} \\in G^k} \\rho_2 Z(\\vec{c}, \\vec{\\beta}) + A(\\vec{\\beta}) = \\rho_2 w + z_2</span>”.</li>

      <li><span class="math">V_{\\mathrm{IP}}^{\\star}</span> outputs the claim “<span class="math">F(\\vec{c}) = \\frac{g_m(c_m) - w}{\\rho_1}</span>”.</li>

    </ol>

    <p class="text-gray-300">We prove the following lemma about the construction above.</p>

    <p class="text-gray-300"><strong>Lemma 6.7.</strong> The IP system <span class="math">(P_{\\mathrm{IP}}^{\\star}, V_{\\mathrm{IP}}^{\\star})</span> satisfies the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Completeness.</strong> For every instance-witness pair <span class="math">\\big((\\mathbb{F}, m, d, H, a), F\\big) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{ess}}</span>, polynomial <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>, and polynomial <span class="math">A \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>, <span class="math">V_{\\mathrm{IP}}^{\\star Z, A}(\\mathbb{F}, m, d, H, a)</span> when interacting with <span class="math">P_{\\mathrm{IP}}^{\\star F, Z, A}(\\mathbb{F}, m, d, H, a)</span> outputs a claim of the form “<span class="math">F(\\vec{\\gamma}) = a</span>” (with <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> and <span class="math">a \\in \\mathbb{F}</span>) that is true with probability 1.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <strong>Soundness.</strong> For every instance-witness pair <span class="math">\\big((\\mathbb{F}, m, d, H, a), F\\big) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{ns}}</span>, polynomial <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>, polynomial <span class="math">A \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>, and malicious prover <span class="math">\\hat{P}</span>, <span class="math">V_{\\mathrm{IP}}^{\\star Z, A}(\\mathbb{F}, m, d, H, a)</span> when interacting with <span class="math">\\hat{P}</span> outputs a claim of the form “<span class="math">F(\\vec{\\gamma}) = a</span>” (with <span class="math">\\vec{\\gamma} \\in \\mathbb{F}^m</span> and <span class="math">a \\in \\mathbb{F}</span>) that is true with probability at most $\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{k \\cdot 2\\lambda + 2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Zero knowledge.</strong> There exists a straightline simulator <span class="math">S_{\\mathrm{IP}}^{\\star}</span> such that, for every instance-witness pair <span class="math">\\big((\\mathbb{F}, m, d, H, a), F\\big) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{ess}}</span> and <span class="math">\\lambda^k</span>-query malicious verifier <span class="math">\\hat{V}</span>, the following two distributions are equal</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">S_{\\mathrm{IP}}^{\\star \\hat{V}, F}(\\mathbb{F}, m, d, H, a) \\quad \\text{and} \\quad \\operatorname{View} \\langle P_{\\mathrm{IP}}^{\\star F, Z, A}(\\mathbb{F}, m, d, H, a), \\hat{V}^{Z, A} \\rangle \\text{ ,}</span></div>

    <p class="text-gray-300">where <span class="math">Z</span> is uniformly random in <span class="math">\\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> and <span class="math">A</span> is uniformly random in <span class="math">\\mathbb{F}[Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>. Moreover:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{\\mathrm{IP}}^{\\star}</span> makes a single query to <span class="math">F</span> at a point in <span class="math">I^{m}</span>;</li>

      <li><span class="math">S_{\\mathrm{IP}}^{\\star}</span> runs in time</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$(m + k)((d + \\lambda)\\mathfrak{q}_{\\tilde{V}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ (d + \\lambda)^{3}\\mathfrak{q}_{\\tilde{V}}^{3})\\cdot \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d,k,\\lambda ,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\cdot \\mathfrak{q}_{\\tilde{V}}^{3}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathfrak{q}_{\\tilde{V}}</span> is <span class="math">\\tilde{V}</span>'s query complexity;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{\\mathrm{IP}}^{\\star}</span>'s behavior does not depend on <span class="math">a</span> until after the simulated <span class="math">\\tilde{V}</span> sends its first message.</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness is clear from the protocol description and the completeness property of sumcheck. Soundness follows from the fact that, if <span class="math">((\\mathbb{F}, m, d, H, a), F) \\in \\mathcal{R}_{\\mathrm{SC}}^{\\mathrm{me}}</span>, we can argue as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For every polynomial <span class="math">Z \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span>, with probability $1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math"> over the choice of </span>\\rho_1, \\sum_{\\vec{\\alpha} \\in H^m} Q(\\vec{\\alpha}) \\neq \\rho_1 a + z_1$, i.e., the sumcheck claim is false.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Finally, we distinguish two cases depending on <span class="math">\\tilde{P}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">\\tilde{P}</span> sends <span class="math">w \\neq \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta})</span>, then <span class="math">\\sum_{\\vec{\\beta} \\in G^k} \\rho_2 Z(\\vec{c}, \\vec{\\beta}) + A(\\vec{\\beta}) \\neq \\rho_2 w + z_2</span> with probability $1 - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}<span class="math"> over the choice of </span>\\rho_2<span class="math">, for any choice of </span>A<span class="math">. In this case, by the soundness guarantee of the sumcheck protocol the verifier rejects with probability at least </span>1 - \\frac{k \\cdot 2\\lambda}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\tilde{P}</span> sends <span class="math">w = \\sum_{\\vec{\\beta} \\in G^k} Z(\\vec{c}, \\vec{\\beta})</span>, then <span class="math">F(\\vec{c}) \\neq \\frac{g_m(c_m) - w}{\\rho_1}</span> with probability 1.</li>

    </ul>

    <p class="text-gray-300">Taking a union bound on the above cases yields the claimed soundness error.</p>

    <p class="text-gray-300">To show the (perfect) zero knowledge guarantee, we need to construct a suitably-efficient straightline simulator that perfectly simulates the view of any malicious verifier <span class="math">\\tilde{V}</span>. We first construct an inefficient simulator <span class="math">S_{\\mathrm{slow}}^{\\star}</span>, and prove that its output follows the desired distribution; afterwards, we explain how the simulator can be made efficient.</p>

    <p class="text-gray-300">The simulator <span class="math">S_{\\mathrm{slow}}^{\\star}</span>, given straightline access to <span class="math">\\tilde{V}</span> and oracle access to <span class="math">F</span>, works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Draw <span class="math">Z_{\\mathrm{sim}} \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> and <span class="math">A_{\\mathrm{sim}} \\in \\mathbb{F}[Y_{1,\\dots,k}^{\\leq d}]</span> uniformly at random.</li>

      <li>Begin simulating <span class="math">\\tilde{V}</span>. Its queries to <span class="math">Z</span> and <span class="math">A</span> are answered according to <span class="math">Z_{\\mathrm{sim}}</span> and <span class="math">A_{\\mathrm{sim}}</span> respectively.</li>

      <li>Send <span class="math">z_{\\mathrm{sim}}^{1} \\coloneqq \\sum_{\\vec{\\alpha} \\in H^{m}} \\sum_{\\vec{\\beta} \\in G^{k}} Z(\\vec{\\alpha}, \\vec{\\beta})</span> and <span class="math">z_{\\mathrm{sim}}^{2} \\coloneqq \\sum_{\\vec{\\beta} \\in G^{k}} A(\\vec{\\beta})</span> to <span class="math">\\tilde{V}</span>.</li>

      <li>Receive <span class="math">\\tilde{\\rho}_{1}</span>. Draw <span class="math">Q_{\\mathrm{sim}} \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> uniformly at random conditioned on <span class="math">\\sum_{\\vec{\\alpha} \\in H^{m}} Q_{\\mathrm{sim}}(\\vec{\\alpha}) = \\tilde{\\rho}_{1}a + z_{\\mathrm{sim}}^{1}</span>, then engage in the sumcheck protocol on the claim “<span class="math">\\sum_{\\vec{\\alpha} \\in H^{m}} Q_{\\mathrm{sim}}(\\vec{\\alpha}) = \\tilde{\\rho}_{1}a + z_{\\mathrm{sim}}^{1}</span>”. If in any round <span class="math">\\tilde{V}</span> sends <span class="math">c_{i} \\notin I</span> as a challenge, abort.</li>

      <li>Let <span class="math">\\vec{c} \\in I^{m}</span> be the point chosen by <span class="math">\\tilde{V}</span> in the sumcheck protocol above. Query <span class="math">F(\\vec{c})</span>, and draw <span class="math">Z_{\\mathrm{sim}}^{\\prime} \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> uniformly at random conditioned on</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{\\vec{\\alpha} \\in H^{m}} \\sum_{\\vec{\\beta} \\in G^{k}} Z_{\\mathrm{sim}}^{\\prime}(\\vec{\\alpha}, \\vec{\\beta}) = z_{\\mathrm{sim}}^{1}</span>,</li>

      <li><span class="math">\\sum_{\\vec{\\beta} \\in G^{k}} Z_{\\mathrm{sim}}^{\\prime}(\\vec{c}, \\vec{\\beta}) = w_{\\mathrm{sim}}</span>, where <span class="math">w_{\\mathrm{sim}} := Q_{\\mathrm{sim}}(\\vec{c}) - \\tilde{\\rho}_{1} F(\\vec{c})</span>, and</li>

      <li><span class="math">Z_{\\mathrm{sim}}^{\\prime}(\\vec{\\gamma}) = Z_{\\mathrm{sim}}(\\vec{\\gamma})</span> for all previous queries <span class="math">\\vec{\\gamma}</span> to <span class="math">Z</span>.</li>

    </ul>

    <p class="text-gray-300">From this point on, answer all queries to <span class="math">Z</span> with <span class="math">Z_{\\mathrm{sim}}^{\\prime}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive <span class="math">\\tilde{\\rho}_{2}</span> from <span class="math">\\tilde{V}</span>. Draw <span class="math">Q_{\\mathrm{sim}}^{\\prime} \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq d}]</span> uniformly at random conditioned on</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sum_{\\vec{\\beta} \\in G^{k}} Q_{\\mathrm{sim}}^{\\prime}(\\vec{\\beta}) = \\tilde{\\rho}_{2} w_{\\mathrm{sim}} + z_{\\mathrm{sim}}^{2}</span>, and</li>

      <li><span class="math">Q_{\\mathrm{sim}}^{\\prime}(\\vec{\\gamma}) = \\tilde{\\rho}_{2} Z_{\\mathrm{sim}}^{\\prime}(\\vec{c}, \\vec{\\gamma}) + A_{\\mathrm{sim}}(\\vec{\\gamma})</span> for all previous queries <span class="math">\\vec{\\gamma}</span> to <span class="math">A</span>.</li>

    </ul>

    <p class="text-gray-300">From this point on, answer all queries to <span class="math">A(\\vec{\\gamma})</span> with <span class="math">Q_{\\mathrm{sim}}^{\\prime}(\\vec{\\gamma}) - \\tilde{\\rho}_{2}Z_{\\mathrm{sim}}^{\\prime}(\\vec{c},\\vec{\\gamma})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Engage in the sumcheck protocol on the claim “<span class="math">\\sum_{\\vec{\\beta} \\in G^{k}} Q_{\\mathrm{sim}}^{\\prime}(\\vec{\\beta}) = \\tilde{\\rho}_{2} w_{\\mathrm{sim}} + z_{\\mathrm{sim}}^{2}</span>”.</li>

      <li>Output the view of the simulated <span class="math">\\tilde{V}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">Q(\\vec{X}):=\\tilde{\\rho}_{1}F(\\vec{X})+\\sum_{\\vec{\\beta}\\in G^{k}}Z(\\vec{X},\\vec{\\beta})</span>, and <span class="math">Q^{\\prime}(\\vec{Y}):=\\tilde{\\rho}_{2}Z(\\vec{c},\\vec{Y})+A(\\vec{Y})</span>. Observe that there exists a (deterministic) function <span class="math">v(\\cdot)</span> such that</p>

    <p class="text-gray-300">$\\mathrm{View}\\ \\langle P_{\\mathrm{IP}}^{\\star,F,Z,A},\\tilde{V}^{F,Z,A}\\rangle=v(Q,Q^{\\prime},F,Z,Z,r)\\quad\\text{and}\\quad S_{\\mathrm{slow}}^{\\star}\\stackrel{{\\scriptstyle\\tilde{V},F}}{{{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle</p>

    <p class="text-gray-300">6.2 Step 2</p>

    <p class="text-gray-300">The Interactive Proof described and analyzed in Section 6.1 assumes that the prover and verifier have access to certain low-degree polynomials. We now use low-degree testing and self-correction to compile that Interactive Proof into an Interactive PCP, where the prover sends to the verifier evaluations of these polynomials as part of the proof oracle. This will conclude the proof of Theorem 6.4.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Proof of Theorem 6.4.</h6>

    <p class="text-gray-300">Construct an IPCP system <span class="math">(P,V)</span> for sumcheck as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">P</span>, given input <span class="math">(\\mathbb{F},m,d,H,a)</span> and oracle access to <span class="math">F</span>, samples polynomials <span class="math">Z\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>, <span class="math">A\\in\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> uniformly at random, and sends their evaluations to the verifier <span class="math">V</span>; then <span class="math">P</span> simulates <span class="math">P_{\\mathrm{IP}}^{\\star\\&gt;F,Z,A}(\\mathbb{F},m,d,H,a)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The verifier <span class="math">V</span>, after receiving a proof string <span class="math">\\pi=(Z,A)</span>, simulates <span class="math">V_{\\mathrm{IP}}^{\\star\\&gt;F,\\pi}(\\mathbb{F},m,d,H,a)</span> up to <span class="math">V_{\\mathrm{IP}}</span>’s two queries <span class="math">\\vec{\\alpha}_{1}\\in\\mathbb{F}^{m+k},\\vec{\\alpha}_{2}\\in\\mathbb{F}^{k}</span> to <span class="math">Z,A</span> respectively (which occur after the interaction), which <span class="math">V</span> does not answer directly but instead answers as follows. First, <span class="math">V</span> checks that <span class="math">Z</span> is <span class="math">\\varrho</span>-close to the evaluation of a polynomial in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> by performing an individual-degree test with proximity parameter <span class="math">\\varrho:=\\frac{1}{8}</span> and soundness error $\\epsilon:=\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> <em>[x11, x13]</em>; then, </span>V<span class="math"> computes </span>Z(\\vec{\\alpha}_{1})<span class="math"> via self-correction with soundness error </span>\\epsilon<span class="math"> <em>[x22, x1]</em>, and replies with this value. The procedures above are repeated to determine </span>A(\\vec{\\alpha}_{2})<span class="math">. Both procedures require </span>\\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m,d)<span class="math"> queries and time. Finally, </span>V<span class="math"> rejects if </span>V_{\\mathrm{IP}}$ rejects or the individual degree test rejects.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness and perfect zero knowledge of <span class="math">(P,V)</span> are inherited, in a straightforward way, from those of <span class="math">(P_{\\mathrm{IP}},V_{\\mathrm{IP}})</span>. We now argue soundness. Consider an instance-witness pair <span class="math">\\big{(}(\\mathbb{F},m,d,H,a),F\\big{)}\\in\\mathscr{R}_{\\mathrm{SC}}^{\\mathrm{nu.}}</span> and a malicious prover <span class="math">\\tilde{P}</span>, and denote by <span class="math">\\tilde{\\pi}=(\\tilde{Z},\\tilde{A})</span> the proof string sent by <span class="math">\\tilde{P}</span>. We distinguish between the following two cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Case 1: <span class="math">\\tilde{Z}</span> is <span class="math">\\varrho</span>-far from evaluations of polynomials in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> or <span class="math">\\tilde{A}</span> is <span class="math">\\varrho</span>-far from evaluations of polynomials in <span class="math">\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>.</em></li>

    </ul>

    <p class="text-gray-300">In this case, the low-degree test accepts with probability at most <span class="math">\\epsilon</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Case 2: <span class="math">\\tilde{Z}</span> is <span class="math">\\varrho</span>-close to evaluations of polynomials in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> and <span class="math">\\tilde{A}</span> is <span class="math">\\varrho</span>-close to evaluations of polynomials in <span class="math">\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span>.</em></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this case, let <span class="math">\\tilde{Z}^{\\prime}</span> be the unique polynomial in <span class="math">\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> whose evaluation is <span class="math">\\varrho</span>-close to <span class="math">\\tilde{Z}</span>; this polynomial exists because <span class="math">\\varrho</span> is less than the unique decoding radius (of the corresponding Reed–Muller code), which equals $\\frac{1}{2}(1-\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{m}(1-\\frac{2\\lambda}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})^{k}<span class="math">, and is at least </span>\\frac{1}{4}<span class="math"> by the assumption that </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{k\\cdot 2\\lambda}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<\\frac{1}{2}<span class="math">. </span>\\tilde{A}^{\\prime}<span class="math"> is defined analogously. By the soundness of </span>(P_{\\mathrm{IP}},V_{\\mathrm{IP}})<span class="math">, the probability that </span>V_{\\mathrm{IP}}^{F,\\tilde{Z}^{\\prime},\\tilde{A}^{\\prime}}<span class="math"> accepts is at most </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{k\\cdot 2\\lambda+2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (see Lemma 6.7). However </span>V<span class="math"> only has access to </span>\\tilde{\\pi}<span class="math">, and uses self-correction on it to compute </span>\\tilde{Z}^{\\prime},\\tilde{A}^{\\prime}<span class="math"> at the location </span>\\vec{\\alpha}\\in\\mathbb{F}^{m}<span class="math"> required by </span>V_{\\mathrm{IP}}<span class="math">; the probability that the returned values are not correct is at most </span>2\\epsilon<span class="math">. Hence, by a union bound, </span>V<span class="math"> accepts with probability at most </span>\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{k\\cdot 2\\lambda+2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+2\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Overall, we deduce that <span class="math">V</span> accepts with probability at most $\\max\\{\\epsilon\\,,\\,\\frac{md}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{k\\cdot 2\\lambda+2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+2\\epsilon\\}\\leq 6\\frac{(m+k)\\cdot(d+\\lambda)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">In this section we use the zero knowledge sumcheck protocol developed in Section 6 (along with the [BCFGRS16] protocol) to derive a zero knowledge analogue of the [BFL91; BFLS91] protocol for NEXP. Recall that in this protocol, the prover first sends a low-degree extension of a NEXP witness, and then engages in the [LFKN92] sumcheck protocol on a polynomial related to the instance. To make this zero knowledge, the prover will first take a randomized low-degree extension  <span class="math">R</span>  of the witness (which provides some bounded independence). The oracle contains a commitment to  <span class="math">R</span> : the prover draws a polynomial uniformly at random subject to the condition that 'summing out' a few of its variables yields  <span class="math">R</span> , and places its evaluation in the oracle.</p>

    <p class="text-gray-300">The prover and verifier then engage in the zero knowledge sumcheck detailed in Section 6 on the [BFLS91] polynomial. This ensures that the verifier learns nothing through the interaction except for a single evaluation of the summand polynomial, which corresponds to learning a constant number of evaluations of the randomized witness. Bounded independence ensures that these evaluations do not leak any information. The prover provides these evaluations to the verifier, who will then check their correctness by engaging in an instance of the [BCFGRS16] sumcheck protocol for each evaluation. Note that here we are satisfied with the weaker guarantee provided by the [BCFGRS16] protocol because the simulator is able to simulate any polynomial number of queries to the commitment.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Following [BFLS91], the arithmetization encodes bit strings as elements in  <span class="math">H^{m}</span>  for some  <span class="math">H</span>  of size  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , rather than with  </span>H = \\{0, 1\\}$  as in [BFL91], for greater efficiency.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We start by defining the oracle 3-satisfiability problem, which is the NEXP-complete problem used by [BFL91] to construct two-prover interactive proofs for NEXP.</p>

    <p class="text-gray-300">Definition 7.1 ( <span class="math">\\mathcal{R}_{\\mathrm{O3SAT}}</span> ). The oracle 3-satisfiability relation, denoted  <span class="math">\\mathcal{R}_{\\mathrm{O3SAT}}</span> , consists of all instance-witness pairs  <span class="math">(\\mathbf{x}, \\mathbf{w}) = ((r, s, B), A)</span> , where  <span class="math">r, s</span>  are positive integers,  <span class="math">B: \\{0, 1\\}^{r + 3s + 3} \\to \\{0, 1\\}</span>  is a boolean formula, and  <span class="math">A: \\{0, 1\\}^s \\to \\{0, 1\\}</span>  is a function, that satisfy the following condition:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall z \\in \\{0, 1 \\} ^ {r}, \\forall b _ {1}, b _ {2}, b _ {3} \\in \\{0, 1 \\} ^ {s}, B (z, b _ {1}, b _ {2}, b _ {3}, A (b _ {1}), A (b _ {2}), A (b _ {3})) = 1.</span></div>

    <p class="text-gray-300">Theorem 7.2 (PZK IPCP for NEXP). For every query bound function  <span class="math">b(n)</span> , the NEXP-complete relation  <span class="math">\\mathcal{R}_{\\mathrm{O3SAT}}</span>  has a (public coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all  <span class="math">b</span> -query malicious verifiers. In more detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RO3SAT ∈ PZK-IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1/2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(r + s + log b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(2</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">, b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(2</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">, b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">simulator overhead:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log b) · qV3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that the prover running time given above assumes that the prover is given a witness as auxiliary input.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let  <span class="math">\\mathbb{F}</span>  be an extension field of  <span class="math">\\mathbb{F}_2</span> . Let  <span class="math">\\hat{B} \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  be the 'direct' arithmetization of the negation of  <span class="math">B</span> : rewrite  <span class="math">B</span>  by using ANDs and NOTs; negate its output; replace each  <span class="math">\\mathrm{AND}(a, b)</span>  with  <span class="math">a \\cdot b</span>  and  <span class="math">\\mathrm{NOT}(a)</span>  with  <span class="math">1 - a</span> . For every  <span class="math">\\vec{x} \\in \\{0, 1\\}^{r + 3s + 3}</span> ,  <span class="math">\\hat{B}(\\vec{x}) = 0</span>  if  <span class="math">B(\\vec{x})</span>  is true, and  <span class="math">\\hat{B}(\\vec{x}) = 1</span>  if  <span class="math">B(\\vec{x})</span>  is false. Note that  <span class="math">\\hat{B}</span>  is computable in time  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  and has total degree  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that  <span class="math">(r,s,B)\\in \\mathcal{R}_{\\mathrm{O3SAT}}</span>  if and only if there exists a multilinear function  <span class="math">\\hat{A}\\colon \\mathbb{F}^s\\to \\mathbb{F}</span>  that is boolean on  <span class="math">\\{0,1\\} ^s</span>  such that  <span class="math">\\hat{B} (\\vec{z},\\vec{b}_1,\\vec{b}_2,\\vec{b}_3,\\hat{A} (\\vec{b}_1),\\hat{A} (\\vec{b}_2),\\hat{A} (\\vec{b}_3)) = 0</span>  for all  <span class="math">\\vec{z}\\in \\{0,1\\} ^r,\\vec{b}_1,\\vec{b}_2,\\vec{b}_3\\in \\{0,1\\} ^s</span> . The requirement that  <span class="math">\\hat{A}</span>  is boolean on  <span class="math">\\{0,1\\} ^s</span>  can be encoded by  <span class="math">2^{s}</span>  constraints:  <span class="math">\\hat{A} (\\vec{b})(1 - \\hat{A} (\\vec{b})) = 0</span>  for every  <span class="math">\\vec{b}\\in \\{0,1\\} ^s</span> .</p>

    <p class="text-gray-300">These constraints can be expressed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left\\{g_{1}(\\vec{\\alpha}) := \\hat{B}(\\vec{z}, \\vec{b}_{1}, \\vec{b}_{2}, \\vec{b}_{3}, \\hat{A}(\\vec{b}_{1}), \\hat{A}(\\vec{b}_{2}), \\hat{A}(\\vec{b}_{3})) = 0 \\right\\}_{\\vec{z} \\in \\{0, 1\\}^{r}, \\vec{b}_{i} \\in \\{0, 1\\}^{s}} \\\\ \\left\\{g_{2}(\\vec{\\beta}) := \\hat{A}(\\vec{b})(1 - \\hat{A}(\\vec{b})) = 0 \\right\\}_{\\vec{b} \\in \\{0, 1\\}^{s}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">F</span> be the polynomial over <span class="math">\\mathbb{F}</span> given by</p>

    <div class="my-4 text-center"><span class="math-block">F(\\vec{X}, \\vec{Y}) := \\sum_{\\vec{\\alpha} \\in \\{0, 1\\}^{r + 3s}} \\left(g_{1}(\\vec{\\alpha}) \\vec{X}^{\\vec{\\alpha}} + g_{2}(\\vec{\\alpha}_{[s]}) \\vec{Y}^{\\vec{\\alpha}}\\right),</span></div>

    <p class="text-gray-300">where <span class="math">\\vec{X}^{\\vec{\\alpha}} := X_1^{\\alpha_1} \\cdots X_\\ell^{\\alpha_\\ell}</span> for <span class="math">\\vec{\\alpha} \\in \\{0,1\\}^\\ell</span>, and <span class="math">\\vec{\\alpha}_{[s]}</span> are the first <span class="math">s</span> coordinates in <span class="math">\\vec{\\alpha}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">F</span> is the zero polynomial if and only if all the above equations hold. Since <span class="math">F</span> is a polynomial of total degree <span class="math">r + 3s</span>, if <span class="math">F</span> is not the zero polynomial then it is zero on at most an $\\frac{r + 3s}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> fraction of points in </span>\\mathbb{F}^{2(r + 3s)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\alpha_{i} \\in \\{0,1\\}</span> it holds that <span class="math">X_{i}^{\\alpha_{i}} = 1 + (X_{i} - 1)\\alpha_{i}</span>, so we can also write</p>

    <div class="my-4 text-center"><span class="math-block">F(\\vec{X}, \\vec{Y}) = \\sum_{\\vec{\\alpha} \\in \\{0, 1\\}^{r + 3s}} \\left(g_{1}(\\vec{\\alpha}) \\cdot \\prod_{i = 1}^{r + 3s} (1 + (X_{i} - 1)\\alpha_{i}) + g_{2}(\\vec{\\alpha}_{[s]}) \\cdot \\prod_{i = 1}^{r + 3s} (1 + (Y_{i} - 1)\\alpha_{i})\\right) =: \\sum_{\\vec{\\alpha} \\in \\{0, 1\\}^{r + 3s}} f(\\vec{X}, \\vec{Y}, \\vec{\\alpha}).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H</span> be a subfield of <span class="math">\\mathbb{F}</span>; define $m_1 \\coloneqq r / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>m_2 \\coloneqq s / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (assuming without loss of generality that both are integers). For </span>i \\in \\{1, 2\\}<span class="math">, let </span>\\gamma_i \\colon H^{m_i} \\to \\{0, 1\\}^{m_i \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> be the lexicographic order on </span>H^{m_i}<span class="math">. The low-degree extension </span>\\hat{\\gamma}_i<span class="math"> of </span>\\gamma_i<span class="math"> is computable by an arithmetic circuit constructible in time </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, m_i, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> [GKR15, Claim 4.2]. Let </span>\\gamma \\colon H^{m_1 + 3m_2} \\to \\{0, 1\\}^{r + 3s}<span class="math"> be such that </span>\\gamma(\\vec{\\alpha}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3) = (\\gamma_1(\\vec{\\alpha}), \\gamma_2(\\vec{\\beta}_1), \\gamma_2(\\vec{\\beta}_2), \\gamma_2(\\vec{\\beta}_3))<span class="math"> for all </span>\\vec{\\alpha} \\in H^{m_1}, \\vec{\\beta}_1, \\vec{\\beta}_2, \\vec{\\beta}_3 \\in H^{m_2}<span class="math">; let </span>\\hat{\\gamma} \\colon \\mathbb{F}^{m_1 + 3m_2} \\to \\mathbb{F}^{r + 3s}$ be its low-degree extension.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can use the above notation to write <span class="math">F</span> equivalently as</p>

    <p class="text-gray-300">$$ \\begin{array}{l} F(\\vec{X}, \\vec{Y}) = \\sum_{\\substack{\\vec{\\alpha} \\in H^{m_{1}} \\\\ \\vec{\\beta}_{1}, \\vec{\\beta}_{2}, \\vec{\\beta}_{3} \\in H^{m_{2}}}} g_{1}(\\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_{1}, \\vec{\\beta}_{2}, \\vec{\\beta}_{3})) \\prod_{i = 1}^{r + 3s} (1 + (X_{i} - 1) \\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_{1}, \\vec{\\beta}_{2}, \\vec{\\beta}_{3})_{i}) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>g_{2}(\\hat{\\gamma}_{2}(\\vec{\\beta}_{1})) \\prod_{i = 1}^{r + 3s} (1 + (Y_{i} - 1) \\hat{\\gamma}(\\vec{\\alpha}, \\vec{\\beta}_{1}, \\vec{\\beta}_{2}, \\vec{\\beta}_{3})_{i}).</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We are now ready to specify the protocol. Let $k \\coloneqq \\lceil \\log b / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. The prover draws a polynomial <span class="math">Z</span> uniformly at random from $\\mathbb{F}[X_{1,\\dots,m_2}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">, subject to the condition that </span>\\sum_{\\vec{\\beta} \\in G^{k}} Z(\\vec{\\alpha}, \\vec{\\beta}) = A(\\gamma_{2}(\\vec{\\alpha}))<span class="math"> for all </span>\\vec{\\alpha} \\in H^{m_{2}}<span class="math">. It then generates an oracle </span>\\pi_0<span class="math"> for the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}<span class="math">-strong zero knowledge sumcheck protocol (Section 6) on input </span>(\\mathbb{F}, m_1 + 3m_2, \\deg(f), H, 0)<span class="math"> and oracles </span>\\pi_1, \\pi_2, \\pi_3<span class="math"> for the [BCFGRS16] zero knowledge sumcheck protocol on input </span>(\\mathbb{F}, k, 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, H, \\cdot)<span class="math">. (Recall that in both zero knowledge sumchecks, the oracle message does not depend on the claim itself.) The prover sends an oracle which is the concatenation of the evaluation of </span>Z<span class="math"> with </span>(\\pi_0, \\pi_1, \\pi_2, \\pi_3)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier chooses <span class="math">\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r + 3s}</span> uniformly at random and sends them to the prover. The prover and verifier engage in the zero knowledge sumcheck protocol of Section 6 on the claim “<span class="math">F(\\vec{x}, \\vec{y}) = 0</span>” with <span class="math">I = \\mathbb{F} \\setminus H</span> using <span class="math">\\pi_1</span> as the oracle message. This reduces the claim to checking that <span class="math">f(\\vec{x}, \\vec{y}, \\vec{c}, \\vec{c}_1, \\vec{c}_2, \\vec{c}_3) = a</span> for uniformly random <span class="math">\\vec{c} \\in (\\mathbb{F} \\setminus H)^{m_1}, \\vec{c}_1, \\vec{c}_2, \\vec{c}_3 \\in (\\mathbb{F} \\setminus H)^{m_2}</span> and some <span class="math">a \\in \\mathbb{F}</span> provided by the prover.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover provides <span class="math">h_i \\coloneqq A(\\gamma_2(\\vec{c}_i&#x27;))</span> for each <span class="math">i \\in \\{1, 2, 3\\}</span>. The verifier substitutes these values into the expression for <span class="math">f</span> to check the above claims, and rejects if they do not hold.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover and verifier engage in the zero knowledge sumcheck protocol of [BCFGRS16] on the claims “<span class="math">\\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{\\alpha}, \\vec{\\beta}) = h_i</span>” for each <span class="math">i \\in \\{1, 2, 3\\}</span>, using <span class="math">\\pi_i</span> as the oracle message.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5. The verifier checks that <span class="math">Z</span> is low-degree (with proximity parameter <span class="math">\\varrho := \\frac{1}{8}</span> and soundness error $\\varepsilon := \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">), and uses self-correction (with soundness error </span>\\varepsilon$) to query it at the points required by the [BCFGRS16] protocol above.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Completeness.</strong> If <span class="math">((r,s,B),A)\\in \\mathcal{R}_{\\mathrm{O3SAT}}</span> then <span class="math">F(\\vec{X},\\vec{Y})</span> is the zero polynomial; hence <span class="math">F(\\vec{x},\\vec{y}) = 0</span> for all <span class="math">\\vec{x},\\vec{y}\\in \\mathbb{F}^{r + 3s}</span>. Completeness follows from the completeness of the zero knowledge sumcheck protocols.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Soundness.</strong> Suppose that <span class="math">(r,s,B) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span> and let <span class="math">(\\tilde{Z},\\tilde{\\pi}_0,\\tilde{\\pi}_1,\\tilde{\\pi}_2,\\tilde{\\pi}_3)</span> be the oracle message. If <span class="math">\\tilde{Z}</span> is <span class="math">\\varrho</span>-far from an evaluation of a polynomial in $\\mathbb{F}[X_{1,\\dots,m_2}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2},Y_{1,\\dots,k}^{\\leq \\lambda}]<span class="math"> then the verifier rejects with probability at least </span>1 - \\varepsilon<span class="math">. Otherwise, there exists a unique polynomial </span>Z \\in \\mathbb{F}[X_{1,\\dots,m_2}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2},Y_{1,\\dots,k}^{\\leq \\lambda}]<span class="math"> whose evaluation is </span>\\varrho<span class="math">-close to </span>\\tilde{Z}<span class="math">. Let </span>\\tilde{A} := \\sum_{\\vec{\\beta}\\in H^k}Z(\\vec{X},\\vec{\\beta})<span class="math">, which we think of as playing the role of </span>\\tilde{A} (\\gamma_2(\\cdot))<span class="math"> in </span>F$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(r,s,B)\\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span> then there is no choice of <span class="math">\\tilde{A}</span> such that <span class="math">F(\\vec{X},\\vec{Y})</span> is the zero polynomial. Thus, <span class="math">F(\\vec{x},\\vec{y}) = 0</span> with probability at most $(r + 3s) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\vec{x},\\vec{y}<span class="math">. By the soundness of the zero knowledge sumcheck protocol (Theorem 6.4), the verifier outputs a false claim “</span>f(\\vec{x},\\vec{y},\\vec{\\alpha}) = a<span class="math">” with probability at least </span>1 - O((m_1 + m_2 + k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">). If substituting </span>h_i<span class="math"> for </span>\\tilde{A} (\\gamma_2(\\vec{c}_i'))<span class="math"> in </span>f<span class="math"> does not yield </span>a<span class="math">, then the verifier rejects. Otherwise, it must be the case that for at least one </span>i\\in \\{1,2,3\\}<span class="math">, </span>\\tilde{A} (\\vec{c}_i')\\neq h_i<span class="math">. By the soundness of the [BCFGRS16] sumcheck protocol, the verifier rejects with probability at least </span>1 - O(\\frac{k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. Taking a union bound, the verifier rejects with probability at least </span>1 - O((m_1 + m_2 + k)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 1 - O((r + s + \\log b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> Perfect zero knowledge for this protocol is witnessed by the following simulator.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Draw a uniformly random polynomial $Z_{\\mathrm{sim}} \\in \\mathbb{F}[X_{1,\\dots,m_2}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Receive <span class="math">\\vec{x},\\vec{y}\\in \\mathbb{F}^{r + 3s}</span> from <span class="math">\\tilde{V}</span>.</li>

      <li>Simulate the strong ZK sumcheck protocol on the claim “<span class="math">F(\\vec{x},\\vec{y}) = 0</span>”. The subsimulator will query <span class="math">f</span> at a single location <span class="math">\\vec{c} \\in (\\mathbb{F} - H)^{r + 3s}</span>. Reply with the value <span class="math">f(\\vec{x},\\vec{y},\\vec{c})</span>, for <span class="math">\\vec{c} = (\\vec{c}_0, \\vec{c}_1, \\vec{c}_2, \\vec{c}_3) \\in (\\mathbb{F} \\setminus H)^{r + 3s}</span>. To compute this requires values <span class="math">\\tilde{A}(\\tilde{\\gamma}(\\vec{c}_i))</span> for <span class="math">i \\in \\{1,2,3\\}</span>; we substitute each of these with <span class="math">h_{\\mathrm{sim}}^i \\in \\mathbb{F}</span> drawn uniformly at random (except: if <span class="math">\\vec{c}_i = \\vec{c}_j</span> for <span class="math">i \\neq j</span> then fix <span class="math">h_{\\mathrm{sim}}^i = h_{\\mathrm{sim}}^j</span>).</li>

      <li>For <span class="math">i \\in \\{1, 2, 3\\}</span>, simulate the [BCFGRS16] sumcheck protocol on the claim “<span class="math">\\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{\\alpha}, \\vec{\\beta}) = h_{\\mathrm{sim}}^i</span>”. Whenever the subsimulator queries <span class="math">Z</span>, answer using <span class="math">Z_{\\mathrm{sim}}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier's view consists of its interaction with <span class="math">P</span> during the four sumchecks, and its queries to the oracle. The Section 6 zero knowledge sumcheck subsimulator guarantees that the queries to <span class="math">\\pi_0</span> and the first sumcheck are perfectly simulated given a single query to <span class="math">f</span> at the point <span class="math">\\vec{c} \\in (\\mathbb{F} \\setminus H)^{r + 3s}</span> chosen by <span class="math">\\tilde{V}</span>. Since $\\tilde{A}'(\\vec{X}) = \\sum_{\\vec{\\beta} \\in H^k} Z(\\vec{X}, \\vec{\\beta}) \\in \\mathbb{F}[X_{1,\\dots,m}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2}]<span class="math">, the evaluation of </span>\\tilde{A}<span class="math"> at any 3 points outside of </span>H^m<span class="math"> does not determine its value at any point in </span>H^m<span class="math">. In particular, this means that the values </span>h_i<span class="math"> sent by the prover in the original protocol are independently uniformly random in </span>\\mathbb{F}<span class="math"> (except if </span>\\vec{c}_i = \\vec{c}_j<span class="math"> for </span>i \\neq j<span class="math"> as above). Thus the </span>h_{\\mathrm{sim}}^i<span class="math"> are identically distributed to the </span>h_i$, and therefore both the prover message and the simulator's query are perfectly simulated.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The [BCFGRS16] sumcheck simulator ensures that the view of the verifier in the rest of the sumchecks is perfectly simulated given <span class="math">q_{\\tilde{V}}</span> queries to <span class="math">Z</span>, where <span class="math">q_{\\tilde{V}}</span> is the number of queries the verifier makes across all <span class="math">\\pi_i</span>, <span class="math">i \\in \\{1, 2, 3\\}</span>. Hence the number of 'queries' the simulator makes to <span class="math">Z_{\\mathrm{sim}}</span> is strictly less than <span class="math">b</span> (because <span class="math">\\tilde{V}</span> is <span class="math">b</span>-query). By Corollary 5.3, any set of strictly less than <span class="math">b</span> queries to <span class="math">Z</span> is independent of <span class="math">\\tilde{A}&#x27;</span>, and so the answers are identically distributed to the answers to those queries if they were made to a uniformly random polynomial, which is the distribution of <span class="math">Z_{\\mathrm{sim}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly drawing a uniformly random polynomial in $Z_{\\mathrm{sim}} \\in \\mathbb{F}[X_{1,\\dots,m_2}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> is not something we can do in polynomial time. However, we can instead use the algorithm of Corollary 4.1 to draw </span>Z<span class="math"> (a simple modification allows us to handle different degrees in </span>\\vec{X}, \\vec{Y}<span class="math">, or we could simply set the degree bound for both to be </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; the proof still goes through). The running time of the simulator is then </span>\\mathrm{poly}(m_1, m_2, k,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It remains to choose <span class="math">\\mathbb{F}</span> and <span class="math">H</span>. We set $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(r + s + \\log b)<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> large enough that the soundness error is </span>o(1)<span class="math">. The running time of the verifier is then </span>\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log b)<span class="math">, as is the running time of the simulator. The proof length is </span>\\mathbb{F}^{O(m_1 + m_2 + k)} = 2^{O(r + s)} \\cdot \\mathrm{poly}(b)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">8 Delegating sum-product computations</p>

    <p class="text-gray-300">We define <em>sum-product circuits</em>, a type of computation involving alternations of (i) summing polynomials over hypercubes, and (ii) combining polynomials via low-degree arithmetic circuits. Computing the output of a sum-product circuit is (conjecturally) hard (indeed, we will show that it is PSPACE-complete), but we show how to efficiently delegate such computations via an Interactive Proof.</p>

    <p class="text-gray-300">We proceed in three steps. First, we provide intuition for why it is natural to consider sum-product alternations (Section 8.1). Then, we define sum-product <em>formulas</em>, which are a special case (in a way that is analogous to how boolean formulas specialize boolean circuits) and show how to delegate their evaluation (Section 8.2). Finally, we define sum-product <em>circuits</em> and show how to delegate their evaluation (Section 8.3).</p>

    <p class="text-gray-300">In later sections, we additionally achieve zero knowledge via an Interactive PCP (Section 9), and explain how to ‘program’ sum-product circuits so that: their evaluation captures PSPACE (Section 10) or, more generally, low-depth circuit computations (Section 11); and their satisfaction captures NEXP (Section 7).</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">8.1 Intuition for definition</h3>

    <p class="text-gray-300">We provide intuition for why it is natural to consider sum-product alternations. Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">H</span> a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">m</span> a positive integer. The sumcheck protocol (Section 4.5) supports checking claims of the form “<span class="math">a=\\sum_{\\vec{\\beta}\\in H^{m}}P(\\vec{\\beta})</span>” for a given field element <span class="math">a\\in\\mathbb{F}</span> and low-degree <span class="math">m</span>-variate polynomial <span class="math">P</span> over <span class="math">\\mathbb{F}</span>, if the verifier can efficiently evaluate <span class="math">P</span> at any point (e.g., the verifier has a small arithmetic circuit for <span class="math">P</span>, or the verifier has oracle access to <span class="math">P</span>, or others).</p>

    <p class="text-gray-300">Can the verifier still check the claim even if <span class="math">P</span> is an expression involving other polynomials?</p>

    <p class="text-gray-300">Suppose that <span class="math">P(\\vec{X})</span> (allegedly) equals <span class="math">C(\\vec{X},P_{1}(\\vec{X}),\\ldots,P_{t}(\\vec{X}))</span> for some low-degree <span class="math">t</span>-variate ‘combiner’ polynomial <span class="math">C</span> and low-degree <span class="math">m</span>-variate polynomials <span class="math">P_{1},\\ldots,P_{t}</span>, and suppose that the verifier has small arithmetic circuits for all these polynomials. In this case the verifier can still efficiently evaluate <span class="math">P</span> at any given point, and the sumcheck protocol directly applies. However, now suppose instead that each polynomial <span class="math">P_{i}(\\vec{X})</span> <em>itself</em> (allegedly) equals <span class="math">\\sum_{\\vec{\\gamma}\\in H^{m}}C(\\vec{X},P_{i,1}(\\vec{X},\\vec{\\gamma}),\\ldots,P_{i,t}(\\vec{X},\\vec{\\gamma}))</span> for some low-degree <span class="math">2m</span>-variate polynomials <span class="math">P_{i,1},\\ldots,P_{i,t}</span>. Now the sumcheck protocol <em>does not</em> directly apply, due to the <em>alternation</em> of sums and products. What to do?</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sum-product expressions, and protocols for them. More generally (and informally), we call <span class="math">P\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> an <span class="math">m</span>-variate <em>sum-product expression</em> if (i) <span class="math">P</span> is a low-degree (individual degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) arithmetic circuit, or (ii) </span>P(\\vec{X})<span class="math"> equals </span>\\sum_{\\vec{\\beta}\\in H^{m}}C(\\vec{X},\\vec{\\beta},P_{1}(\\vec{X},\\vec{\\beta}),\\ldots,P_{t}(\\vec{X},\\vec{\\beta}))<span class="math"> where </span>C<span class="math"> is a low-degree ‘combiner’ arithmetic circuit and </span>P_{1},\\ldots,P_{t}<span class="math"> are </span>2m$-variate sum-product expressions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By building on ideas of <em>[x19, x20, x15]</em>, we can <em>still</em> use the sumcheck protocol, now as a subroutine of a larger Interactive Proof, to verify claims of the form “<span class="math">a=P(\\vec{\\omega})</span>” for a given <span class="math">a\\in\\mathbb{F}</span>, sum-product expression <span class="math">P</span>, and <span class="math">\\vec{\\omega}\\in\\mathbb{F}^{m}</span>, as we now sketch — and thereby handle sum-product alternations.</p>

    <p class="text-gray-300">If <span class="math">P</span> is an arithmetic circuit, then the verifier can check the claim directly by evaluating <span class="math">P</span> at <span class="math">\\vec{\\omega}</span>. Otherwise, proceed as follows. Define <span class="math">\\hat{P}</span> to be the low-degree extension of <span class="math">P</span> (see Section 4.1):</p>

    <p class="text-gray-300"><span class="math">\\hat{P}(X)=\\sum_{\\vec{\\alpha}\\in H^{m}}I_{H^{n}}(\\vec{X},\\vec{\\alpha})\\sum_{\\vec{\\beta}\\in H^{m}}C(\\vec{\\alpha},\\vec{\\beta},P_{1}(\\vec{\\alpha},\\vec{\\beta}),\\ldots,P_{t}(\\vec{\\alpha},\\vec{\\beta}))\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that <span class="math">I_{H^{m}}(\\vec{X},\\vec{Y})</span> is the unique <span class="math">m</span>-variate polynomial, of degree less than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, such that, for all </span>(\\vec{\\alpha},\\vec{\\beta})\\in H^{m}\\times H^{m}<span class="math">, </span>I_{H^{m}}(\\vec{\\alpha},\\vec{\\beta})<span class="math"> equals </span>1<span class="math"> when </span>\\vec{\\alpha}=\\vec{\\beta}<span class="math"> and equals </span>0$ otherwise.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover and verifier run the sumcheck protocol on the claim “<span class="math">a=\\hat{P}(\\vec{\\omega})</span>” and obtain a new claim</p>

    <p class="text-gray-300"><span class="math">\`\`a^{\\prime}=I_{H^{n}}(\\vec{\\omega},\\vec{r}_{2})\\cdot C(\\vec{r}_{1},\\vec{r}_{2},P_{1}(\\vec{r}_{1},\\vec{r}_{2}),\\ldots,P_{t}(\\vec{r}_{1},\\vec{r}_{2}))&quot;</span></p>

    <p class="text-gray-300">for some <span class="math">a^{\\prime}\\in\\mathbb{F}</span> derived from the prover’s messages and <span class="math">\\vec{r}_{1},\\vec{r}_{2}\\in\\mathbb{F}^{m}</span> drawn uniformly at random by the verifier. The prover then sends <span class="math">h_{1},\\ldots,h_{t}</span> and the verifier checks that <span class="math">a^{\\prime}=I_{H^{n}}(\\vec{\\omega},\\vec{r}_{2})\\cdot C(h_{1},\\ldots,h_{t})</span>. (Note that this expression</p>

    <p class="text-gray-300">involves only low-degree polynomials.) The verifier then recursively checks, for <span class="math">i=1,\\ldots,t</span>, that “<span class="math">a_{i}=P_{i}(\\vec{r}_{1},\\vec{r}_{2})</span>”, relying on the fact that each <span class="math">P_{i}</span> is itself a sum-product expression.</p>

    <p class="text-gray-300">The reason for taking the low-degree extension <span class="math">\\hat{P}</span> of <span class="math">P</span> is to prevent a degree blowup for intermediate claims, and is also used in the GKR protocol <em>[x14]</em> as well as Shen’s protocol <em>[x34]</em> (known as <em>degree reduction</em> there). In particular, depending on the form of the combiner <span class="math">C</span>, the degree of <span class="math">P(\\vec{X})</span> can be somewhat larger than that of the <span class="math">P_{i}</span> subexpressions. Even a factor <span class="math">2</span> increase in the degree would, after <span class="math">k</span> rounds, lead to a factor <span class="math">2^{k}</span> increase overall, which for modest <span class="math">k</span> would make the communication complexity of the sumcheck protocol superpolynomial. The degree reduction step ensures that the degrees of the intermediate claims do not increase.</p>

    <p class="text-gray-300">Towards sum-product formulas. The above informal discussion motivates the formulation of tree-like computations that combine values of previous hypercube sums by way of functions of bounded degree — we call these <em>sum-product formulas</em> (in analogy to boolean formulas that are also tree-like computations). Our definition also features crucial degrees of freedom, which make ‘programming’ these formulas more efficient, that we now discuss.</p>

    <p class="text-gray-300">First, we allow each internal vertex <span class="math">v</span> in the tree to be labeled with a potentially different combiner arithmetic circuit <span class="math">C_{v}</span> of small (total) degree. An input <span class="math">\\mathtt{x}</span> to the sum-product formula then consists of labeling each leaf vertex <span class="math">v</span> with a polynomial <span class="math">\\mathtt{x}_{v}</span>, potentially represented as an arithmetic circuit, of small (individual) degree, and the edges in the tree determine how to ‘evaluate’ a vertex, as follows. The <em>value</em> of a vertex <span class="math">v</span> on input <span class="math">\\mathtt{x}</span> equals the circuit <span class="math">\\mathtt{x}_{v}</span> if <span class="math">v</span> is a leaf vertex, or equals <span class="math">\\sum_{\\vec{\\beta}\\in H^{m}}C_{v}\\big{(}u_{1}<a href="\\vec{X},\\vec{\\beta}">\\mathtt{x}</a>\\ldots,u_{t}<a href="\\vec{X},\\vec{\\beta}">\\mathtt{x}</a>\\big{)}</span> if <span class="math">v</span> is an internal vertex, where <span class="math">u_{1},\\ldots,u_{t}</span> are the children of <span class="math">v</span>. The value of the formula on <span class="math">\\mathtt{x}</span> is the value of the root on <span class="math">\\mathtt{x}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Second, we allow flexible ‘arity’ in the sums: each edge <span class="math">e</span> is labeled with finite sets of positive integers <span class="math">\\rho_{e}</span> and <span class="math">\\sigma_{e}</span> that determine which ‘free variables’ and ‘summation variables’ are passed on to the child corresponding to <span class="math">e</span>. In other words, now the recursion looks like $\\sum_{\\vec{\\beta}\\in H^{m_{v}}}C_{v}\\big{(}u_{1}[\\mathtt{x}](\\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{1}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{1}}}),\\ldots,u_{t}[\\mathtt{x}](\\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{t}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{t}}})\\big{)}<span class="math"> where </span>e_{1}=(v,u_{1}),\\ldots,e_{t}=(v,u_{t})<span class="math"> and </span>m_{v}:=\\max(\\sigma_{e_{1}}\\cup\\cdots\\cup\\sigma_{e_{\\text{sub}_{T}(v)}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Section 8.2 we provide the formal definition of sum-product formulas, and also describe how to outsource computations about them. We provide this only as a simpler stepping stone towards the next definition.</p>

    <p class="text-gray-300">Sum-product circuits: re-using sub-computations. A boolean formula is limited in that it cannot re-use sub-computations; a sum-product formula is similarly limited. Thus, in analogy to boolean circuits, we consider <em>sum-product circuits</em>, in which sub-computations can be re-used according to an underlying directed acyclic graph (in fact, we will need a multi-graph), rather than a tree. Of course, one can always reduce sum-product circuits to sum-product formulas by ‘opening up’ the graph into a tree — but in the worst case this incurs an exponential blowup in the resulting tree. We use a standard trick to modify the protocol for sum-product formulas so to support merging multiple sub-claim computations at a vertex into one claim (regardless of the in-degree of the vertex), which avoids this explosion. This is also a necessary step in GKR’s protocol <em>[x14]</em> (though we implement it differently for compatibility with our zero-knowledge protocols).</p>

    <p class="text-gray-300">In Section 8.3 we provide a formal definition of sum-product circuits, and then describe how to extend the ideas discussed so far to also support outsourcing computations about sum-product circuits. In the rest of the paper we only use (and must use) sum-product circuits, as sum-product formulas are not expressive enough for our purposes.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">8.2 Sum-product formulas</h3>

    <p class="text-gray-300">The purpose of this section is to (i) introduce <em>sum-product formulas</em>, and (ii) give proof systems for two computational problems about these, <em>evaluation</em> and <em>satisfaction</em>.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">8.2.1 Formal definition</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As with a boolean formula, the ‘topology’ of a a sum-product formula is a <em>tree</em>. A (rooted) tree <span class="math">T=(V,E)</span> is an acyclic connected graph in which edges are directed away from a distinguished vertex, known as the root of <span class="math">T</span> and denoted <span class="math">r_{T}</span>; the sinks of the graph are known as the leaves of <span class="math">T</span> while all other vertices are known as internal vertices. The <em>depth</em> of a vertex <span class="math">v</span>, denoted <span class="math">\\mathsf{depth}_{T}(v)</span>, is the number of edges on the path from <span class="math">r_{T}</span> to <span class="math">v</span> (thus <span class="math">r_{T}</span> has depth <span class="math">0</span>). The depth of <span class="math">T</span>, denoted <span class="math">\\mathsf{depth}(T)</span>, is the maximum depth of any vertex <span class="math">v</span> in <span class="math">V</span>. The width of <span class="math">T</span>, denoted <span class="math">\\mathsf{width}(T)</span>, is the maximum number of vertices at any depth: $\\max_{i=1}^{\\mathsf{depth}(T)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{v\\in V:\\mathsf{depth}_{T}(v)=i\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The <em>out-degree</em> of a vertex </span>v<span class="math"> is denoted </span>\\mathsf{out}_{T}(v)<span class="math"> and equals the number of children of </span>v<span class="math">; the <em>in-degree</em> is </span>1$ for all vertices except the root.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">As outlined in Section 8.1, we eventually consider trees in which each internal vertex specifies a function that is recursively defined in terms of its children’s functions. The number of inputs to these functions varies from vertex to vertex, and we specify the <em>arity</em> of these functions via certain edge labels. Namely, each edge <span class="math">e=(u,v)</span> is labeled by two “projections” <span class="math">\\rho_{e}</span> and <span class="math">\\sigma_{e}</span> that, respectively, specify which free variables of <span class="math">u</span> (the <span class="math">\\vec{X}</span> part in Equation 5 below) and summation variables of <span class="math">u</span> (the <span class="math">\\vec{\\beta}</span> part in Equation 5 below) are passed on to <span class="math">v</span>. In order for these projections to yield a well-defined notion of arity, they must satisfy certain consistency properties, and this motivates the following definition.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 8.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A tuple <span class="math">T=(V,E,\\rho,\\sigma)</span> is an <span class="math">\\mathbf{ari}</span>-tree if <span class="math">(V,E)</span> is a tree and both <span class="math">\\rho</span> and <span class="math">\\sigma</span> label every edge <span class="math">e</span> in <span class="math">E</span> with finite sets of positive integers <span class="math">\\rho_{e}</span> and <span class="math">\\sigma_{e}</span> that satisfy the following property. For every vertex <span class="math">v</span> in <span class="math">V</span>, there exists a (unique) non-negative integer <span class="math">\\mathsf{arity}(v)</span> such that: (1) if <span class="math">v</span> is the root then <span class="math">\\mathsf{arity}(v)=0</span>, otherwise $\\mathsf{arity}(v)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{e}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where </span>e<span class="math"> is </span>v<span class="math">’s (unique) incoming edge; (2) </span>\\rho_{e_{1}},\\ldots,\\rho_{e_{t}}\\subseteq\\{1,\\ldots,\\mathsf{arity}(v)\\}<span class="math">, where </span>e_{1},\\ldots,e_{t}<span class="math"> are </span>v$’s outgoing edges.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For convenience, we denote by <span class="math">\\mathsf{arity}(T)</span> the maximum of <span class="math">\\mathsf{arity}(v)</span> across all vertices <span class="math">v</span> in the vertex set <span class="math">V</span> of <span class="math">T</span>. Moreover, for every vertex <span class="math">v</span>, we define <span class="math">m_{v}:=\\max(\\sigma_{e_{1}}\\cup\\cdots\\cup\\sigma_{e_{t}})</span> so that <span class="math">\\sigma_{e_{1}},\\ldots,\\sigma_{e_{t}}\\subseteq\\{1,\\ldots,m_{v}\\}</span>.</p>

    <p class="text-gray-300">We are now ready to define a sum-product formula <span class="math">\\mathcal{F}</span>, an input <span class="math">\\mathbf{x}</span> for <span class="math">\\mathcal{F}</span>, and how to evaluate <span class="math">\\mathcal{F}</span> on <span class="math">\\mathbf{x}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Definition 8.2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A sum-product formula is a tuple <span class="math">\\mathcal{F}=(\\mathbb{F},H,\\delta_{\\mathsf{in}},\\delta_{\\mathsf{ff}},T,C)</span> where: <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span> (represented as a list of field elements), <span class="math">\\delta_{\\mathsf{in}},\\delta_{\\mathsf{ff}}</span> are positive integers (represented in unary) with $\\delta_{\\mathsf{ff}}\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>T=(V,E,\\rho,\\sigma)<span class="math"> is an ari-tree, and </span>C<span class="math"> labels each internal vertex </span>v<span class="math"> of </span>T<span class="math"> with an arithmetic circuit </span>C_{v}(\\vec{X},\\vec{Y},\\vec{Z})\\colon\\mathbb{F}^{\\mathsf{arity}(v)}\\times\\mathbb{F}^{m_{v}}\\times\\mathbb{F}^{\\mathsf{out}_{T}(v)}\\to\\mathbb{F}<span class="math"> of total degree at most </span>\\delta_{\\mathsf{in}}<span class="math">. An input </span>\\mathbf{x}<span class="math"> for </span>\\mathcal{F}<span class="math"> labels each leaf vertex </span>v<span class="math"> of </span>T<span class="math"> with a polynomial </span>\\mathbf{x}_{v}\\colon\\mathbb{F}^{\\mathsf{arity}(v)}\\to\\mathbb{F}<span class="math"> of individual degree at most </span>\\delta_{\\mathsf{ff}}<span class="math">. The value of </span>\\mathcal{F}<span class="math"> on an input </span>\\mathbf{x}<span class="math"> is denoted </span>\\mathcal{F}[\\mathbf{x}]<span class="math"> and equals </span>r_{T}[\\mathbf{x}]$, which we define below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The value of a vertex <span class="math">v</span> of <span class="math">T</span> on an input <span class="math">\\mathbf{x}</span> is denoted <span class="math">v[\\mathbf{x}]</span> and is recursively defined as follows. If <span class="math">v</span> is a leaf vertex, then <span class="math">v[\\mathbf{x}]</span> equals the polynomial <span class="math">\\mathbf{x}_{v}</span>. If <span class="math">v</span> is an internal vertex, then <span class="math">v[\\mathbf{x}]</span> is the <span class="math">\\mathsf{arity}(v)</span>-variate polynomial over <span class="math">\\mathbb{F}</span> defined by the following expression:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{\\vec{\\beta}\\in H^{m_{v}}}C_{v}\\big{(}\\vec{X},\\vec{\\beta},u_{1}[\\mathbf{x}](\\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{1}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{1}}}),\\ldots,u_{t}[\\mathbf{x}](\\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{t}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{t}}})\\big{)}\\enspace,$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">t:=\\mathsf{out}_{T}(v)</span>, and <span class="math">e_{1}=(v,u_{1}),\\ldots,e_{t}=(v,u_{t})</span> are the outgoing edges of <span class="math">v</span>. In particular, <span class="math">\\mathcal{F}[\\mathbf{x}]=r_{T}[\\mathbf{x}]</span> is a constant in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Given a sum-product formula we can ask two types of computational problems: (evaluation) does a given input lead to a given output? (satisfaction) does there exist an input that leads to a given output? We now define each of these.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Definition 8.3 (SPFE problem).</h6>

    <p class="text-gray-300">The sum-product formula evaluation problem is the following: given a sum-product formula <span class="math">\\mathcal{F}</span>, value <span class="math">\\mathbf{y}</span>, and input <span class="math">\\mathbf{x}</span> (given as a mapping from each leaf vertex <span class="math">v</span> of <span class="math">\\mathcal{F}</span>’s ari-tree <span class="math">T</span> to an arithmetic circuit computing the polynomial <span class="math">\\mathbf{x}_{v}</span>), determine if <span class="math">\\mathcal{F}[\\mathbf{x}]=\\mathbf{y}</span>. This problem induces the language</p>

    <p class="text-gray-300"><span class="math">\\mathscr{L}_{\\mathrm{SPFE}}:=\\big{\\{}(\\mathcal{F},\\mathbf{y},\\mathbf{x})\\text{ s.t. }\\mathcal{F}[\\mathbf{x}]=\\mathbf{y}\\big{\\}}\\enspace.</span></p>

    <p class="text-gray-300">(When <span class="math">\\mathbf{x}</span> is given as above, <span class="math">\\mathsf{space}(\\mathbf{x})</span> denotes the maximum space required to evaluate any circuit in <span class="math">\\mathbf{x}</span>.)</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Definition 8.4 (SPFS problem).</h6>

    <p class="text-gray-300">The sum-product formula satisfaction problem is the following: given a sum-product formula <span class="math">\\mathcal{F}</span>, partial mapping of leaf vertices to arithmetic circuits <span class="math">\\mathbf{x}</span>, and value <span class="math">\\mathbf{y}</span>, determine if there exists a mapping <span class="math">\\mathbf{z}</span> from the leaf vertices not in the domain of <span class="math">\\mathbf{x}</span> to polynomials s.t. <span class="math">\\mathcal{F}[\\mathbf{x},\\mathbf{z}]=\\mathbf{y}</span>. This problem induces the relation</p>

    <p class="text-gray-300"><span class="math">\\mathscr{R}_{\\mathrm{SPFS}}:=\\big{\\{}\\big{(}(\\mathcal{F},\\mathbf{y},\\mathbf{x}),\\mathbf{z}\\big{)}\\text{ s.t. }\\mathcal{F}[\\mathbf{x},\\mathbf{z}]=\\mathbf{y}\\big{\\}}\\enspace.</span></p>

    <p class="text-gray-300">(We refer to <span class="math">\\mathbf{x}</span> as the explicit input and <span class="math">\\mathbf{z}</span> as the auxiliary input.)</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">8.2.2 Delegating sum-product formula evaluation problems</h4>

    <p class="text-gray-300">We give an Interactive Proof to delegate sum-product formula <em>evaluation</em> problems.</p>

    <p class="text-gray-300">Theorem 8.5 (IP for SPFE). There exists a public-coin Interactive Proof for the language  <span class="math">\\mathcal{L}_{\\mathrm{SPFE}}</span> . In more detail:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {L} _ {\\mathrm {S P F E}} \\in \\mathbf {A M} \\left[ \\begin{array}{c c} \\text {s o u n d n e s s e r r o r :} &amp; O (\\delta_ {\\mathrm {i n}} \\delta_ {\\mathrm {f f}} \\cdot \\mathsf {a r i t y} (T) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V (T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\text {r o u n d c o m p l e x i t y :} &amp; O (\\mathsf {d e p t h} (T) \\cdot \\mathsf {a r i t y} (T)) \\\\ \\text {p r o v e r t i m e :} &amp; \\mathrm {p o l y} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {\\mathsf {a r i t y} (T)}) \\\\ \\text {v e r i f i e r t i m e :} &amp; \\mathrm {p o l y} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + O (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\text {v e r i f i e r s p a c e :} &amp; O (\\mathsf {a r i t y} (T) \\cdot \\mathsf {w i d t h} (T) \\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf {s p a c e} (\\mathbf {x})) \\end{array} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Before describing the Interactive Proof system, we define for every vertex  <span class="math">v</span>  in the ari-tree (of a sum-product formula) a function  <span class="math">\\hat{v}[\\mathbf{x}]</span>  based on the function  <span class="math">v[\\mathbf{x}]</span> , as follows. If  <span class="math">v</span>  is a leaf vertex, then  <span class="math">\\hat{v}[\\mathbf{x}]</span>  equals the polynomial  <span class="math">\\mathbf{x}_v</span> . If instead  <span class="math">v</span>  is an internal vertex, then  <span class="math">\\hat{v}[\\mathbf{x}]</span>  is the low-degree extension of the evaluation of  <span class="math">v[\\mathbf{x}]</span>  on  <span class="math">H^{\\mathrm{arity}(v)}</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\hat {v} [ \\mathbf {x} ] (\\vec {X}) := \\sum_ {\\vec {\\alpha} \\in H ^ {\\text {a r i t y} (v)}} I _ {H ^ {\\text {a r i t y} (v)}} (\\vec {X}, \\vec {\\alpha}) \\sum_ {\\vec {\\beta} \\in H ^ {m _ {v}}} C _ {v} \\left(\\vec {\\alpha}, \\vec {\\beta}, u _ {1} [ \\mathbf {x} ] \\left(\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {1}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {1}}}\\right), \\dots , u _ {t} [ \\mathbf {x} ] \\left(\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {t}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {t}}}\\right)\\right). \\tag {6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since  <span class="math">\\hat{v}[\\mathbf{x}]</span>  agrees with  <span class="math">v[\\mathbf{x}]</span>  on  <span class="math">H^{\\mathrm{arity}(v)}</span> , we can equivalently define  <span class="math">\\hat{v}[\\mathbf{x}]</span>  in terms of the  <span class="math">\\hat{u}_j[\\mathbf{x}]</span>  rather than the  <span class="math">u_j[\\mathbf{x}]</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\hat {v} [ \\mathbf {x} ] (\\vec {X}) := \\sum_ {\\vec {\\alpha} \\in H ^ {\\mathrm {a r i t y} (v)}} I _ {H ^ {\\mathrm {a r i t y} (v)}} (\\vec {X}, \\vec {\\alpha}) \\sum_ {\\vec {\\beta} \\in H ^ {m _ {v}}} C _ {v} \\big (\\vec {\\alpha}, \\vec {\\beta}, \\hat {u} _ {1} [ \\mathbf {x} ] (\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {1}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {1}}}), \\dots , \\hat {u} _ {t} [ \\mathbf {x} ] (\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {t}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {t}}}) \\big) \\\\ = \\sum_ {\\vec {\\alpha} \\in H ^ {\\mathrm {a r i t y} (v)}} \\sum_ {\\vec {\\beta} \\in H ^ {m _ {v}}} I _ {H ^ {\\mathrm {a r i t y} (v)}} (\\vec {X}, \\vec {\\alpha}) \\cdot C _ {v} \\big (\\vec {\\alpha}, \\vec {\\beta}, \\hat {u} _ {1} [ \\mathbf {x} ] (\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {1}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {1}}}), \\dots , \\hat {u} _ {t} [ \\mathbf {x} ] (\\vec {\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {t}}}, \\vec {\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {t}}}) \\big) . \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the summand in the last line above is a polynomial, and its individual degree in  <span class="math">(\\vec{\\alpha},\\vec{\\beta})</span>  is at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\delta_{\\mathrm{in}}\\cdot \\max \\{\\delta_{\\mathrm{ff}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} \\leq 2\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}}<span class="math"> . Indeed,  </span>\\hat{u}_i\\mathbf{x} = a_v<span class="math"> . In the claim &quot; </span>\\hat{v}<a href="\\vec{\\gamma}_v">\\mathbf{x}</a> = a_v<span class="math"> &quot; by the end of this subprotocol, the verifier has chosen  </span>\\vec{c}_1\\in \\mathbb{F}^{\\mathrm{arity}(v)}<span class="math">  and  </span>\\vec{c}_2\\in \\mathbb{F}^{m_v}<span class="math">  uniformly at random, and has derived from the prover&#x27;s messages a value  </span>b\\in \\mathbb{F}$  that allegedly satisfies the following equality:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b := I _ {H ^ {\\text {a r i t y} (v)}} \\left(\\vec {\\gamma} _ {v}, \\vec {c} _ {1}\\right) \\cdot C _ {v} \\left(\\vec {c} _ {1}, \\vec {c} _ {2}, \\hat {u} _ {1} [ \\mathbf {x} ] \\left(\\vec {c} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {1}}}, \\vec {c} _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {1}}}\\right), \\dots , \\hat {u} _ {t} [ \\mathbf {x} ] \\left(\\vec {c} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\rho_ {e _ {t}}}, \\vec {c} _ {2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\sigma_ {e _ {t}}}\\right)\\right), \\tag {7}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span>  are  <span class="math">v</span> 's outgoing edges.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) The prover sends  $h_1 \\coloneqq \\hat{u}_1\\mathbf{x}, \\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}, \\dots, h_t \\coloneqq \\hat{u}_t\\mathbf{x} \\in \\mathbb{F}$ , and the verifier checks that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">b = I _ {H ^ {\\text {a r i t y} (v)}} \\left(\\vec {\\gamma} _ {v}, \\vec {c} _ {1}\\right) \\cdot C _ {v} \\left(\\vec {c} _ {1}, \\vec {c} _ {2}, h _ {1}, \\dots , h _ {t}\\right). \\tag {8}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) For  <span class="math">j = 1,\\dots ,t</span>  , the verifier sets  $(\\vec{\\gamma}_{u_j},a_{u_j}):= ((\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_j}},\\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_j}}),h_j).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every leaf vertex  <span class="math">v</span>  of  <span class="math">T</span> , the verifier checks that  <span class="math">\\hat{v}<a href="\\vec{\\gamma}_v">\\mathbf{x}</a> = a_v</span> , i.e., that  <span class="math">\\mathbf{x}_v(\\vec{\\gamma}_v) = a_v</span> .</li>

    </ol>

    <p class="text-gray-300">While the above description considers sequential invocations of the sumcheck protocol, these can be run in parallel in  <span class="math">\\mathrm{depth}(T)</span>  phases: first the root (which has depth 0), then all vertices of depth 1, then all vertices of depth 2, and so on until all vertices of depth  <span class="math">\\mathrm{depth}(T) - 1</span> . Each such phase requires  <span class="math">O(\\mathrm{arity}(T))</span>  rounds, so that the number of rounds is now  <span class="math">O(\\mathrm{depth}(T) \\cdot \\mathrm{arity}(T))</span> , as claimed. The claimed running times for the prover and verifier follow immediately from the above description. The claimed space bound follows from the observation that in phase  <span class="math">i</span> , if we also check the</p>

    <p class="text-gray-300">34</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">leaf vertices at depth  <span class="math">i</span>  during this phase, then the verifier may discard  <span class="math">(\\vec{\\gamma}_v, a_v)</span>  for all vertices  <span class="math">v</span>  with  <span class="math">\\mathrm{depth}_T(v) &amp;lt; i - 1</span> ; and that the value of  <span class="math">I_{H^{\\mathrm{arity}}(v)}</span>  can be computed in space  $O(\\log (\\mathrm{arity}(v)) + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ . We are left to argue the claimed soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If for some internal vertex  <span class="math">v</span>  it holds that  <span class="math">v<a href="\\gamma_v">\\mathbf{x}</a> \\neq a_v</span> , then the soundness property of the sumcheck protocol implies that either the verifier rejects or Equation 7 holds with probability at most  $2\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}} \\cdot \\mathrm{arity}(v) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In this latter case, either Equation 7 fails to hold and the verifier rejects, or there exists  </span>j \\in \\{1, \\dots, \\mathrm{out}_T(v)\\}<span class="math">  such that  </span>e_j \\neq \\hat{u}_j<a href="\\vec{c}_1, \\vec{c}_2">\\mathbf{x}</a><span class="math"> , which means that there exists a vertex  </span>u<span class="math">  in the next layer (in fact,  </span>u = u_j<span class="math">  suffices) for which  </span>\\hat{u}<a href="\\vec{\\gamma}_u">\\mathbf{x}</a> \\neq a_u<span class="math"> . If  </span>u<span class="math">  is a leaf vertex then the verifier will reject when considering  </span>u<span class="math"> ; otherwise we repeat the above argument. Taking a union bound over the internal vertices of  </span>T$  yields the claimed soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We give an Interactive PCP to delegate sum-product formula satisfaction problems, via a simple extension of the Interactive Proof for evaluation problems in the previous section. Similarly to [Sha92; She92; GKR15], the verifier only needs to access the formula's input at a few locations, at the end of the protocol; thus the prover can simply send the input as a proof oracle, and the verifier can query it (via suitable low-degree testing and self-correction of polynomials).</p>

    <p class="text-gray-300">Theorem 8.6 (IPCP for SPFS). There exists a (public-coin and non-adaptive) Interactive PCP for the relation  <span class="math">\\mathcal{R}_{\\mathrm{SPFS}}</span> . In more detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSPFS ∈ IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(δinδff·arity(T)·</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(depth(T)·arity(T))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">V(T)</td>

            <td class="px-3 py-2 border-b border-gray-700">·</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(T))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">V(T)</td>

            <td class="px-3 py-2 border-b border-gray-700">·poly(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, arity(T), δff)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(T))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(arity(T)·width(T)·log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ space(x))</td>

            <td class="px-3 py-2 border-b border-gray-700">.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof sketch. The prover and verifier receive a SPFS instance  <span class="math">(\\mathcal{F},\\mathbf{y},\\mathbf{x})</span>  as input, and the prover additionally receives an auxiliary input  <span class="math">\\mathbf{z}</span>  for  <span class="math">\\mathcal{F}</span>  that is a valid witness for  <span class="math">(\\mathcal{F},\\mathbf{y},\\mathbf{x})</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle. The prover sends to the verifier the proof string  <span class="math">\\pi \\coloneqq \\mathcal{F}</span> , where each polynomial  <span class="math">\\mathbf{z}_v \\colon \\mathbb{F}^{\\mathrm{arity}(v)} \\to \\mathbb{F}</span>  is represented by its evaluation table over the whole domain.</li>

      <li>Interaction. The prover and verifier engage in an Interactive Proof for the claim “ <span class="math">(\\mathcal{F}, \\mathbf{y}, (\\mathbf{x}, \\mathbf{z})) \\in \\mathcal{L}_{\\mathrm{SPFE}}</span> ” using the protocol from the proof of Theorem 8.5 above. The verifier must access  <span class="math">\\mathbf{z}</span>  only at the end of the protocol, and at few locations: for each leaf vertex  <span class="math">v</span>  of  <span class="math">T</span>  where  <span class="math">v</span>  is not in the domain of  <span class="math">\\mathbf{x}</span> , the verifier needs the value of  <span class="math">\\mathbf{z}_v</span>  at a single location  <span class="math">\\vec{\\gamma}_v</span> . Thus, the verifier tests that each  <span class="math">\\mathbf{z}_v</span>  is close to the evaluation of a polynomial of suitable degree [GS06; GR15], and then uses self-correction to read each  <span class="math">\\mathbf{z}_v(\\vec{\\gamma}_v)</span>  [RS96; AS03].</li>

    </ul>

    <p class="text-gray-300">Setting parameters for low-degree testing and self-correction appropriately (for the case of individual-degree multivariate polynomials) yields the parameters claimed in the theorem statement.</p>

    <p class="text-gray-300">The purpose of this section is to (i) introduce sum-product circuits, and (ii) give proof systems for two computational problems about these, evaluation and satisfaction.</p>

    <p class="text-gray-300">As with a boolean circuit, the 'topology' of a sum-product circuit is a directed acyclic multi-graph: a tuple  <span class="math">G = (V, E)</span>  where  <span class="math">E</span>  is a multi-set of directed edges in  <span class="math">V \\times V</span>  with no directed cycles. We assume that there is a single vertex  <span class="math">r_G \\in V</span>  with in-degree zero, known as the root. The vertices with out-degree zero are known as the leaves, while</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">all other vertices are known as internal vertices. We also assume that, for every vertex <span class="math">v</span>, all directed paths from the root <span class="math">r_G</span> to <span class="math">v</span> have the same length, which we denote <span class="math">\\mathrm{depth}_G(v)</span>. The depth of <span class="math">G</span>, denoted <span class="math">\\mathrm{depth}(G)</span>, is the maximum depth of any vertex <span class="math">v</span> in <span class="math">V</span>. The width of <span class="math">G</span>, denoted <span class="math">\\mathrm{width}(G)</span>, is the maximum number of vertices at any depth: $\\max_{i=1}^{\\mathrm{depth}(G)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{v\\in V:\\mathrm{depth}_G(v)=i\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The in-degree and out-degree of a vertex </span>v<span class="math"> are denoted by </span>\\mathrm{in}_G(v)<span class="math"> and </span>\\mathrm{out}_G(v)<span class="math">; we also define </span>\\mathrm{in}(G):=\\max_{v\\in V}\\mathrm{in}_G(v)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 8.7.</strong> A tuple <span class="math">G = (V, E, \\rho, \\sigma)</span> is an <em>ari-graph</em> if <span class="math">(V, E)</span> is a directed acyclic multi-graph and both <span class="math">\\rho</span> and <span class="math">\\sigma</span> label every edge <span class="math">e</span> in <span class="math">E</span> with finite sets of positive integers <span class="math">\\rho_e</span> and <span class="math">\\sigma_e</span> that satisfy the following property. For every vertex <span class="math">v</span> in <span class="math">V</span>, there exists a (unique) non-negative integer <span class="math">\\mathrm{arity}(v)</span> such that: (1) if <span class="math">v</span> is the root then <span class="math">\\mathrm{arity}(v) = 0</span>, otherwise $\\mathrm{arity}(v) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{e_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{e_1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\cdots =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{e_{\\mathrm{in}_G(v)}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{e_{\\mathrm{in}_G(v)}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where </span>e_1, \\ldots, e_{\\mathrm{in}_G(v)}<span class="math"> are </span>v<span class="math">&#x27;s incoming edges; (2) </span>\\rho_{e_1}, \\ldots, \\rho_{e_{\\mathrm{out}_G(v)}} \\subseteq \\{1, \\ldots, \\mathrm{arity}(v)\\}<span class="math">, where </span>e_1, \\ldots, e_{\\mathrm{out}_G(v)}<span class="math"> are </span>v$'s outgoing edges.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For convenience, we denote by <span class="math">\\mathrm{arity}(G)</span> the maximum of <span class="math">\\mathrm{arity}(v)</span> across all vertices <span class="math">v</span> in the vertex set <span class="math">V</span> of <span class="math">G</span>. Moreover, for every vertex <span class="math">v</span>, we define <span class="math">m_v := \\max(\\sigma_{e_1} \\cup \\cdots \\cup \\sigma_{e_{\\mathrm{out}_G(v)}})</span> so that <span class="math">\\sigma_{e_1}, \\ldots, \\sigma_{e_{\\mathrm{out}_G(v)}} \\subseteq \\{1, \\ldots, m_v\\}</span>.</p>

    <p class="text-gray-300">We are now ready to define a sum-product circuit <span class="math">\\mathcal{C}</span>, an input <span class="math">\\mathbf{x}</span> for <span class="math">\\mathcal{C}</span>, and how to evaluate <span class="math">\\mathcal{C}</span> on <span class="math">\\mathbf{x}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 8.8.</strong> A sum-product circuit is a tuple <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G, C)</span> where: <span class="math">\\mathbb{F}</span> is a finite field, <span class="math">H</span> is a subset of <span class="math">\\mathbb{F}</span> (represented as a list of field elements), <span class="math">\\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}</span> are positive integers (represented in unary) with $\\delta_{\\mathrm{ff}} \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>G = (V, E, \\rho, \\sigma)<span class="math"> is an ari-graph, and </span>C<span class="math"> labels each internal vertex </span>v<span class="math"> of </span>G<span class="math"> with an arithmetic circuit </span>C_v(\\vec{X}, \\vec{Y}, \\vec{Z}) \\colon \\mathbb{F}^{\\mathrm{arity}(v)} \\times \\mathbb{F}^{m_v} \\times \\mathbb{F}^{\\mathrm{out}_T(v)} \\to \\mathbb{F}<span class="math"> of total degree at most </span>\\delta_{\\mathrm{in}}<span class="math">. An input </span>\\mathbf{x}<span class="math"> for </span>\\mathcal{C}<span class="math"> labels each leaf vertex </span>v<span class="math"> of </span>G<span class="math"> with a polynomial </span>\\mathbf{x}_v \\colon \\mathbb{F}^{\\mathrm{depth}_G(v) \\cdot m} \\to \\mathbb{F}<span class="math"> of individual degree at most </span>\\delta_{\\mathrm{ff}}<span class="math">. The value of </span>\\mathcal{C}<span class="math"> on an input </span>\\mathbf{x}<span class="math"> is denoted </span>\\mathcal{C}[\\mathbf{x}]<span class="math"> and equals </span>r_G[\\mathbf{x}]$, which we define below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The value of a vertex <span class="math">v</span> of <span class="math">G</span> on an input <span class="math">\\mathbf{x}</span> is denoted <span class="math">v[\\mathbf{x}]</span> and is recursively defined as follows. If <span class="math">v</span> is a leaf vertex, then <span class="math">v[\\mathbf{x}]</span> equals the polynomial <span class="math">\\mathbf{x}_v</span>. If <span class="math">v</span> is an internal vertex, then <span class="math">v[\\mathbf{x}]</span> is the <span class="math">\\mathrm{arity}(v)</span>-variate polynomial over <span class="math">\\mathbb{F}</span> defined by the following expression:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\vec{\\beta} \\in H^{m_v}} C_v \\big( \\vec{X}, \\vec{\\beta}, u_1[\\mathbf{x}] \\big( \\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}} \\big), \\ldots, u_t[\\mathbf{x}] \\big( \\vec{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}} \\big) \\big) ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">t \\coloneqq \\mathrm{out}_G(v)</span>, and <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span> are the outgoing edges of <span class="math">v</span> (with multiplicity). In particular, <span class="math">\\mathcal{C}[\\mathbf{x}] = r_G[\\mathbf{x}]</span> is a constant in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Given a sum-product circuit we can ask two types of computational problems: (evaluation) does a given input lead to a given output? (satisfaction) does there exist an input that leads to a given output? We now define each of these.</p>

    <p class="text-gray-300"><strong>Definition 8.9 (SPCE problem).</strong> The sum-product circuit evaluation problem is the following: given a sum-product circuit <span class="math">\\mathcal{C}</span>, value <span class="math">\\mathbf{y}</span>, and input <span class="math">\\mathbf{x}</span> (given as a mapping from each leaf vertex <span class="math">v</span> of <span class="math">\\mathcal{C}</span>'s ari-graph <span class="math">G</span> to an arithmetic circuit computing the polynomial <span class="math">\\mathbf{x}_v</span>), determine if <span class="math">\\mathcal{C}[\\mathbf{x}] = \\mathbf{y}</span>. This problem induces the language</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{L}_{\\mathrm{SPCE}} := \\left\\{ (\\mathcal{C}, \\mathbf{y}, \\mathbf{x}) \\text{ s.t. } \\mathcal{C}[\\mathbf{x}] = \\mathbf{y} \\right\\}.</span></div>

    <p class="text-gray-300">(When <span class="math">\\mathbf{x}</span> is given as above, <span class="math">\\mathrm{space}(\\mathbf{x})</span> denotes the maximum space required to evaluate any circuit in <span class="math">\\mathbf{x}</span>.)</p>

    <p class="text-gray-300"><strong>Definition 8.10 (SPCS problem).</strong> The sum-product circuit satisfaction problem is the following: given a sum-product circuit <span class="math">\\mathcal{C}</span>, partial mapping of leaf vertices to arithmetic circuits <span class="math">\\mathbf{x}</span>, and value <span class="math">\\mathbf{y}</span>, determine if there exists a mapping <span class="math">\\mathbf{z}</span> from the leaf vertices not in the domain of <span class="math">\\mathbf{x}</span> to polynomials s.t. <span class="math">\\mathcal{C}[\\mathbf{x}, \\mathbf{z}] = \\mathbf{y}</span>. This problem induces the relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{SPCS}} := \\left\\{ \\big( (\\mathcal{C}, \\mathbf{y}, \\mathbf{x}), \\mathbf{z} \\big) \\text{ s.t. } \\mathcal{C}[\\mathbf{x}, \\mathbf{z}] = \\mathbf{y} \\right\\}.</span></div>

    <p class="text-gray-300">(We refer to <span class="math">\\mathbf{x}</span> as the explicit input and <span class="math">\\mathbf{z}</span> as the auxiliary input.)</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">8.3.2 Delegating sum-product circuit evaluation problems</p>

    <p class="text-gray-300">We give an Interactive Proof to delegate sum-product formula evaluation problems.</p>

    <p class="text-gray-300"><strong>Theorem 8.11 (IP for SPCE).</strong> There exists a public-coin Interactive Proof for the language <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>. In more detail:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}_{\\mathrm{SPCE}} \\in \\mathbf{A M} \\left[ \\begin{array}{c c} \\text{soundness error:} &amp; O(\\delta_{\\mathrm{in}} \\delta_{\\mathrm{ff}} \\cdot \\mathsf{arity}(G) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\text{round complexity:} &amp; O(\\mathsf{depth}(G) \\cdot \\mathsf{arity}(G)) \\\\ \\text{prover time:} &amp; \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\mathsf{arity}(G)}) \\\\ \\text{verifier time:} &amp; \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + O(\\mathsf{in}(G) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\text{verifier space:} &amp; O(\\mathsf{arity}(G) \\cdot \\mathsf{width}(G) \\cdot \\mathsf{in}(G) \\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathsf{space}(\\mathbf{x})) \\end{array} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Proof sketch.</strong> The prover and verifier receive as input a SPCE instance <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x})</span>. They both associate with each vertex <span class="math">v</span> of its ari-graph <span class="math">G</span> a set of labels <span class="math">L_v</span>; for the root, this set contains only the pair <span class="math">(\\bot ,\\mathbf{y})</span>, while for all other vertices this set is initially empty and will be populated with at most <span class="math">\\mathrm{in}_G(v)</span> pairs during the protocol. The prover and verifier then interact as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span> taken in (any) topological order, letting <span class="math">t \\coloneqq \\mathrm{out}_G(v)</span>:</li>

    </ol>

    <p class="text-gray-300">(a) For every <span class="math">(\\vec{\\gamma}_j,a_j)</span> in <span class="math">L_{v}</span>, the verifier samples a random <span class="math">\\alpha_{j}\\in \\mathbb{F}</span> and sends it to the prover. (b) The prover and verifier invoke the sumcheck protocol on the following claim:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{\`\`} \\quad \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\hat{v}<a href="\\vec{\\gamma}_j">\\mathbf{x}</a> = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j a_j \\quad \\text{''}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">By the end of this subprotocol, the verifier has chosen <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\mathrm{arity}(v)}</span> and <span class="math">\\vec{c}_2 \\in \\mathbb{F}^{m_v}</span> uniformly at random, and has derived from the prover's messages a value <span class="math">b \\in \\mathbb{F}</span> that allegedly satisfies the following equality:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\left(I_{H^{\\operatorname{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v \\left(\\vec{c}_1, \\vec{c}_2, \\hat{u}_1[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}), \\dots, \\hat{u}_t[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}})\\right)\\right), \\tag{9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span> are the outgoing edges of <span class="math">v</span> (with multiplicity).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) The prover sends $h_1 \\coloneqq \\hat{u}_1[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}), \\ldots, h_t \\coloneqq \\hat{u}_t[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}}) \\in \\mathbb{F}$, and the verifier checks that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\left(I_{H^{\\operatorname{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v \\left(\\vec{c}_1, \\vec{c}_2, h_1, \\dots, h_t\\right)\\right). \\tag{10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(d) For every <span class="math">j = 1, \\ldots, t</span>, the verifier adds the label $((\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_j}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_j}}), h_j)<span class="math"> to </span>L_{u_j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every leaf vertex <span class="math">v</span> of <span class="math">G</span>, and for every <span class="math">(\\vec{\\gamma}, a) \\in L_v</span>, the verifier checks that <span class="math">\\hat{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a> = a</span>, i.e., that <span class="math">\\mathbf{x}_v(\\vec{\\gamma}) = a</span>. (Note that every set <span class="math">L_v</span> has had <span class="math">\\mathrm{in}_G(v)</span> labels added to it. The size of <span class="math">L_v</span> is then at most <span class="math">\\mathrm{in}_G(v)</span>, with the 'strictly less' case occurring if the verifier happens to have added the same label twice.)</li>

    </ol>

    <p class="text-gray-300">While the above description considers sequential invocations of the sumcheck protocol, these can be run in parallel in <span class="math">\\mathrm{depth}(G)</span> phases: first the root (which has depth 0), then all vertices of depth 1, then all vertices of depth 2, and so on until all vertices of depth <span class="math">\\mathrm{depth}(G) - 1</span>. Each such phase requires <span class="math">O(\\mathrm{arity}(G))</span> rounds, so that the number of rounds is now <span class="math">O(\\mathrm{depth}(G) \\cdot \\mathrm{arity}(G))</span>, as claimed. The claimed running times for the prover and verifier follow immediately from the above description. The claimed space bound can be attained by discarding all labels at previous levels before moving to the next level, and checking leaf vertices at the same time as the internal vertices at the same depth. We are left to argue the claimed soundness error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that, when considering some internal vertex <span class="math">v</span> of <span class="math">G</span> in the protocol above, there exists <span class="math">(\\vec{\\gamma}, a) \\in L_v</span> such that <span class="math">\\hat{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a> \\neq a</span>. Then, with probability at least $1 - 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, it holds that </span>\\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\hat{v}<a href="\\vec{\\gamma}_j">\\mathbf{x}</a> \\neq \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j a_j$, which means that the prover and verifier invoke the sumcheck protocol on a false claim. By the soundness of the sumcheck protocol, either</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">37</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the verifier rejects or Equation 9 holds with probability at most  $2\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}}\\cdot \\mathsf{arity}(v) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . In this latter case, either Equation 10 fails to hold and the verifier rejects, or there exists  </span>j\\in \\{1,\\ldots ,\\mathrm{out}_G(v)\\}<span class="math">  such that  </span>h_j\\neq \\hat{u}_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_j}},\\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_j}})<span class="math"> , which means that there exists a vertex  </span>u<span class="math">  in the next layer (in particular,  </span>u = u_{j}<span class="math"> ) for which there exists  </span>(\\vec{\\gamma}^{\\prime},a^{\\prime})\\in L_{u}<span class="math">  such that  </span>\\hat{u}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\vec{\\gamma}^{\\prime})\\neq a^{\\prime}<span class="math"> . If  </span>u<span class="math">  is a leaf vertex then the verifier will reject when considering  </span>u<span class="math"> ; otherwise we repeat the above argument. Taking a union bound over the internal vertices of  </span>G$  yields the claimed soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We give an Interactive PCP to delegate sum-product circuit satisfaction problems.</p>

    <p class="text-gray-300">Theorem 8.12 (IPCP for SPCS). There exists a (public-coin and non-adaptive) Interactive PCP for the relation  <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span> . In more detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSPCS ∈ IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(δinδff·arity(G)·</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(depth(G)·arity(G))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">·</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">·poly(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, arity(G), δff)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(arity(G)·width(G)·in(G)·log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">+ space(x))</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. The protocol is analogous to that in the proof of Theorem 8.6, which considers the relation  <span class="math">\\mathcal{R}_{\\mathrm{SPFS}}</span>  (sum-product formula satisfaction) rather than  <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span>  (sum-product circuit satisfaction). Specifically, we only need to replace the Interactive Proof for the language  <span class="math">\\mathcal{L}_{\\mathrm{SPFE}}</span>  (sum-product formula evaluation) with the Interactive Proof for the language  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  (sum-product circuit evaluation) that we gave in the proof of Theorem 8.11. We omit the details, except for one technicality that we now describe.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The strategy described in the above paragraph eventually leads the verifier to read, via self-correction, at most  <span class="math">\\mathrm{in}_G(v)</span>  values of  <span class="math">\\mathbf{z}_v</span>  for every leaf vertex  <span class="math">v</span>  of  <span class="math">G</span>  not in the domain of  <span class="math">\\mathbf{x}</span> . Overall, the verifier reads at most  $\\sum_v\\mathrm{in}_G(v)\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  values via self-correction, which corresponds to  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathrm{arity}(G) + \\delta_{\\mathrm{ff}})<span class="math">  actual queries, and a soundness error of  </span>O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}}\\cdot \\mathrm{arity}(G)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ . To obtain the stated query complexity, we reduce the number of values read via self-correction to a single value per leaf vertex, via the following standard trick.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">t_1, \\ldots, t_{\\mathrm{in}_G(v)} \\in \\mathbb{F}</span>  be arbitrary distinct values known to both the prover and verifier, and let  <span class="math">A_v \\colon \\mathbb{F} \\to \\mathbb{F}^{\\mathrm{arity}(v)}</span>  be the unique polynomial of degree less than  <span class="math">\\mathrm{in}_G(v)</span>  such that  <span class="math">A_v(t_i) = \\vec{\\gamma}_i</span>  for every  <span class="math">(\\vec{\\gamma}_i, a_i) \\in L_v</span> . The prover sends  <span class="math">B_v \\coloneqq (\\mathbf{z}_v \\circ A_v) \\colon \\mathbb{F} \\to \\mathbb{F}</span>  to the verifier (as a list of at most  <span class="math">\\mathrm{arity}(v) \\cdot \\mathrm{in}_G(v) \\cdot \\delta_{\\mathrm{ff}}</span>  coefficients), who checks that  <span class="math">B_v(t_i) = a_i</span>  for every  <span class="math">i \\in \\{1, \\ldots, \\mathrm{in}_G(v)\\}</span> . The verifier then picks  <span class="math">t \\in \\mathbb{F}</span>  uniformly at random and checks that  <span class="math">\\mathbf{z}_v(A_v(t)) = B_v(t)</span> ; this involves obtaining, via self-correction, the value of  <span class="math">\\mathbf{z}_v</span>  at  <span class="math">A_v(t)</span> . Soundness is maintained because if the prover sends  <span class="math">B_v&#x27; \\neq B_v</span>  then the probability that  <span class="math">\\mathbf{z}_v(A_v(t)) = B_v&#x27;(t)</span>  for uniformly random  <span class="math">t \\in \\mathbb{F}</span>  is at most  $\\mathrm{arity}(v) \\cdot \\mathrm{in}_G(v) \\cdot \\delta_{\\mathrm{ff}} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The overall soundness error is then, by a union bound, at most  </span>O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}} \\cdot \\mathrm{arity}(G) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + \\sum_v \\mathrm{arity}(v) \\cdot \\mathrm{in}_G(v) \\cdot \\delta_{\\mathrm{ff}} /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}} \\cdot \\mathrm{arity}(G) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . The additional space required for this test is  </span>O(\\mathrm{arity}(G) \\cdot \\mathrm{in}(G) \\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ , so the space bound is unaffected.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocols for delegating sum-product computations described in Section 8 are not zero knowledge. We show how to delegate, in the Interactive PCP model, sum-product circuit evaluation problems (Section 9.1) and satisfaction problems (Section 9.2). As a special case, we also obtain the same for sum-product formulas.</p>

    <p class="text-gray-300">The purpose of this section is to show that the language  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  (consisting of sum-product circuit evaluation problems, see Definition 8.9) has perfect zero knowledge Interactive PCPs:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9.1 (PZK IPCP for  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span> ). For every query bound function  <span class="math">b(n)</span> , the language  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all  <span class="math">b</span> -query malicious verifiers. In more detail, letting  $\\alpha := \\log b / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LSPCE ∈ PZK-IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(δinδlf · in(G) · (arity(G) + α) ·</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(depth(G) · (arity(G) + α))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">·</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G)+α)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">· poly(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, arity(G), α, δin, δlf, in(G))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G)+α)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">, α) + O(in(G) ·</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O((arity(G) + α) · width(G) · in(G) · log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">+ space(x))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">simulator overhead:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">, α) · (</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ qV3).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We introduce some notation before the proof. Given a subset  <span class="math">H</span>  of  <span class="math">\\mathbb{F}</span>  and a positive integer  <span class="math">m</span> , we denote by  <span class="math">\\mathbb{Z}_{H^m}</span>  the  <span class="math">m</span> -variate polynomial  <span class="math">\\prod_{i=1}^{m} \\prod_{\\alpha \\in H} (X_i - \\alpha)</span> . Note that  <span class="math">\\mathbb{Z}_{H^m}</span>  is zero on  <span class="math">H^m</span>  and nonzero on  <span class="math">(\\mathbb{F} - H)^m</span> , and can be evaluated in  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m)<span class="math">  field operations and space  </span>O(\\log m + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To guide us to the proof of the above theorem, it is instructive to look at why the protocol of Theorem 8.11 may not be zero knowledge. We identify two potential sources of leakage: the first is the values  <span class="math">\\hat{v}\\mathbf{x}</span>  for internal vertices  <span class="math">v</span>  which the prover sends in Step 1c of the protocol; the second is the partial sums which are leaked by the sumcheck subprotocol itself.</p>

    <p class="text-gray-300">We resolve the first issue by replacing, for each internal vertex  <span class="math">v</span> , the low-degree extension  <span class="math">\\hat{v}[\\mathbf{x}]</span>  in the SPCE protocol with a randomized low-degree extension  <span class="math">\\hat{v}[\\mathbf{x}]</span> , which is  <span class="math">\\mathrm{in}_G(v)</span> -wise independent outside of  <span class="math">H^{\\mathrm{arity}(v)}</span> . More precisely, for any list of distinct query points  <span class="math">\\vec{\\gamma}_1, \\ldots, \\vec{\\gamma}_{\\mathrm{in}_G(v)} \\in (\\mathbb{F} - H)^{\\mathrm{arity}(v)}</span> ,  <span class="math">(\\hat{v}<a href="\\vec{\\gamma}_i">\\mathbf{x}</a>)_{i=1}^{\\mathrm{in}_G(v)}</span>  is uniformly random in  <span class="math">\\mathbb{F}^\\ell</span> . Given such a low-degree extension, it suffices to ensure that the verifier may only learn its evaluations inside  <span class="math">(\\mathbb{F} - H)^m</span> , and then only on at most  <span class="math">\\mathrm{in}_G(v)</span>  distinct points; then we can simulate all of these queries with uniformly random field elements.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a sum-product circuit  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{lf}}, G, C)</span> , we define for every vertex  <span class="math">v</span>  in its ari-graph  <span class="math">G = (V, E, \\rho, \\sigma)</span>  a random variable  <span class="math">\\hat{v}[\\mathbf{x}]</span>  based on  <span class="math">v[\\mathbf{x}]</span> , as follows. Let  $\\lambda := 2\\delta_{\\mathrm{in}} \\cdot (\\delta_{\\mathrm{lf}} + \\mathrm{in}(G)) = \\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . If  </span>v<span class="math">  is a leaf vertex, then  </span>\\hat{v}[\\mathbf{x}]<span class="math">  simply equals  </span>\\mathbf{x}_v<span class="math">  with probability 1. If instead  </span>v<span class="math">  is an internal vertex, then  </span>\\hat{v}[\\mathbf{x}]<span class="math">  is a &quot;randomized&quot; low-degree extension of  </span>v[\\mathbf{x}]$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\hat {v} [ \\mathbf {x} ] (\\vec {X}) := \\hat {v} [ \\mathbf {x} ] (\\vec {X}) + \\mathbb {Z} _ {H ^ {\\mathrm {a r i t y} (v)}} (\\vec {X}) \\sum_ {\\vec {\\gamma} \\in G ^ {k}} R _ {v} (\\vec {X}, \\vec {\\gamma}) ,</span></div>

    <p class="text-gray-300">where  <span class="math">\\hat{v}[\\mathbf{x}]</span>  is the fixed low-degree extension of  <span class="math">v[\\mathbf{x}]</span>  that we used in Section 8 (see Equation 6),  <span class="math">k</span>  is a security parameter,  <span class="math">G</span>  is an arbitrary subset of  <span class="math">\\mathbb{F}</span>  of size  <span class="math">\\lambda</span>  with  <span class="math">0 \\in G</span> ,  <span class="math">R_v</span>  is uniformly random in  <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathrm{arity}(v)}^{\\leq \\mathrm{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> , and  <span class="math">\\mathrm{in}_G(v)</span>  is the in-degree of  <span class="math">v</span>  in  <span class="math">G</span> . (In the protocol, the verifier receives in the oracle message the evaluation table of independently drawn  <span class="math">R_v</span> , for every internal vertex  <span class="math">v</span>  of  <span class="math">G</span> .)</p>

    <p class="text-gray-300">Since <span class="math">\\dot{v}[\\mathbf{x}]</span> agrees with <span class="math">v[\\mathbf{x}]</span> on <span class="math">H^{\\mathrm{arity}(v)}</span>, we can equivalently write (using the definition of <span class="math">\\hat{v}[\\mathbf{x}]</span>):</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dot{v}<a href="\\vec{X}">\\mathbf{x}</a> &amp;:=\\left(\\sum_{\\vec{\\alpha}\\in H^{\\mathrm{arity}(v)}}\\sum_{\\vec{\\beta}\\in H^{m_{v}}}I_{H^{\\mathrm{arity}(v)}}(\\vec{X},\\vec{\\alpha})\\cdot C_{v}\\big(\\vec{\\alpha},\\vec{\\beta},\\dot{u}_{1}[\\mathbf{x}](\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{1}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{1}}}),\\ldots,\\dot{u}_{t}[\\mathbf{x}](\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{t}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{t}}})\\big{)}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp;\\quad+\\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{X})\\sum_{\\vec{\\gamma}\\in G^{b}}R_{v}(\\vec{X},\\vec{\\gamma}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp;= \\sum_{\\vec{\\alpha}\\in H^{\\mathrm{arity}(v)}}\\sum_{\\vec{\\beta}\\in H^{m_{v}}}\\sum_{\\vec{\\gamma}\\in G^{b}}\\Big{(}I_{G^{b}}(\\vec{0},\\vec{\\gamma})\\cdot I_{H^{\\mathrm{arity}(v)}}(\\vec{X},\\vec{\\alpha})\\cdot C_{v}\\big(\\vec{\\alpha},\\vec{\\beta},\\dot{u}_{1}[\\mathbf{x}](\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{1}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{1}}}),\\ldots,\\dot{u}_{t}[\\mathbf{x}](\\vec{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_{t}}},\\vec{\\beta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_{t}}})\\big) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp;\\quad+I_{H^{\\mathrm{arity}(v)+m_{v}}}((\\vec{\\alpha},\\vec{\\beta}),\\vec{0})\\cdot\\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{X})\\cdot R_{v}(\\vec{X},\\vec{\\gamma})\\Big{)}\\enspace. \\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the individual degree of <span class="math">\\dot{v}<a href="\\vec{X}">\\mathbf{x}</a></span> is exactly $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathrm{in}_{G}(v)<span class="math">. The individual degree of the summand in the last line (in </span>\\vec{\\alpha},\\vec{\\beta},\\vec{\\gamma}<span class="math">) is at most </span>\\max\\{2\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathrm{in}_{G}(v)+\\delta_{\\mathrm{in}}\\cdot\\max\\{\\delta_{\\mathrm{ff}},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\max_{1\\leq i\\leq\\mathrm{out}_{G}(v)}\\mathrm{in}_{G}(u_{i})\\}\\}\\leq 2\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe first that <span class="math">R_{v}</span> is a perfectly-hiding commitment to the random polynomial <span class="math">S_{v}(\\vec{X}):=\\sum_{\\vec{\\gamma}\\in G^{b}}R_{v}(\\vec{X},\\vec{\\gamma})</span>, and so <span class="math">S_{v}(\\vec{x})</span> itself is uniformly random even conditioned on strictly fewer than <span class="math">\\lambda^{k}</span> queries to <span class="math">R_{v}</span>. Then since <span class="math">\\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{X})</span> is non-zero in <span class="math">(\\mathbb{F}-H)^{\\mathrm{arity}(v)}</span> and the individual degree of <span class="math">S_{v}</span> is <span class="math">\\mathrm{in}_{G}(v)</span>, the required independence property holds. If we ensure that the verifier chooses its challenges in the sumcheck protocol from <span class="math">\\mathbb{F}-H</span> rather than all of <span class="math">\\mathbb{F}</span> (i.e. the prover aborts otherwise), then the values sent to the verifier in the SPCE protocol will indeed be uniformly random.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We resolve the second issue by replacing the sumcheck subprotocol with the zero knowledge IPCP for sumcheck defined in Section 6. This requires sending $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> proofs, which we can concatenate together with the </span>R_{v}<span class="math"> into a single oracle. Note that here we will require the full strength of the zero knowledge guarantee which we obtain in Theorem 6.4 (as opposed to the weaker guarantee of [BCFGRS16]), because the simulator is not able to make an arbitrary polynomial number of queries to </span>\\dot{v}[\\mathbf{x}]<span class="math"> for any internal vertex </span>v<span class="math">. Instead the number of queries must be bounded by </span>\\mathrm{in}_{G}(v)<span class="math"> for each </span>v$, so that these queries can be simulated by choosing uniformly random field elements; the zero knowledge guarantee of Theorem 6.4 allows us to do exactly that.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are now ready to put everything together.</p>

    <p class="text-gray-300">Proof. Fix <span class="math">k:=\\lceil\\log b/\\log\\lambda\\rceil</span>. The prover and verifier receive as input a SPCE instance <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x})</span>. We first describe the oracle message that is first sent to the verifier, and then describe the subsequent interaction between the prover and verifier.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Oracle. The prover sends to the verifier a proof string <span class="math">\\pi</span> that contains, for each internal vertex <span class="math">v</span> of <span class="math">G</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the evaluation table of the polynomial <span class="math">R_{v}\\in\\mathbb{F}[X_{1,\\ldots,\\mathrm{arity}(v)}^{\\leq\\mathrm{in}_{G}(v)},Y_{1,\\ldots,k}^{\\leq 2\\lambda}]</span> drawn independently and uniformly at random;</li>

      <li>a proof string <span class="math">\\pi_{v}</span> which is the oracle sent in a <span class="math">\\lambda^{k}</span>-strong zero knowledge sumcheck protocol on input <span class="math">(\\mathbb{F},\\mathrm{arity}(v)+m_{v}+k,\\lambda,H,\\cdot)</span>.</li>

      <li>Interaction. The prover and verifier associate, for each vertex <span class="math">v</span> of <span class="math">G</span>, a set of labels <span class="math">L_{v}</span>; for the root, this set contains only the pair <span class="math">(\\bot,\\mathbf{y})</span>, while for all other vertices this set is initially empty and will be populated during the protocol. The prover and verifier then interact as follows.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span> taken in (any) topological order, letting <span class="math">t:=\\mathrm{out}_{G}(v)</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">(\\vec{\\gamma}_{j},a_{j})</span> in <span class="math">L_{v}</span>, the verifier samples a random <span class="math">\\alpha_{j}\\in\\mathbb{F}</span> and sends it to the prover.</li>

      <li>The prover and verifier invoke a <span class="math">\\lambda^{k}</span>-strong perfect zero knowledge Interactive Probabilistically Checkable Proof system for sumcheck (see Section 6) on the claim</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">" \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{j}\\dot{v}<a href="\\vec{\\gamma}_{j}">\\mathbf{x}</a>=\\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\alpha_{j}a_{j} \\quad "</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">3Recall that we do not need to specify <span class="math">a</span> until later on in the protocol, and it will depend on the verifier's random choices.</p>

    <p class="text-gray-300">using <span class="math">\\pi_v</span> as the oracle, and with <span class="math">I := \\mathbb{F} \\setminus H</span>. By the end of this subprotocol, the verifier has chosen <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\mathrm{arity}(v)}</span>, <span class="math">\\vec{c}_2 \\in \\mathbb{F}^m</span>, and <span class="math">\\vec{c}_3 \\in \\mathbb{F}^k</span> uniformly at random, and has derived from the prover's messages a value <span class="math">b \\in \\mathbb{F}</span> that allegedly satisfies the following equality:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\left(I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, \\dot{u}_1[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}})\\right) \\tag{11} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad + I_{H^{\\text{arity}(v)+m_v}}((\\vec{c}_1, \\vec{c}_2), \\vec{0}) \\cdot \\mathbb{Z}_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\right), \\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span> are the outgoing edges of <span class="math">v</span> (with multiplicity).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c) The prover sends <span class="math">\\vec{h}_v := (h_1, \\ldots, h_t)</span> where $h_1 := \\dot{u}_1[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}), \\ldots, h_t := \\dot{u}_t[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}})<span class="math">. For every </span>j = 1, \\ldots, t<span class="math">, the verifier adds the label </span>((\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_j}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_j}}), h_j)<span class="math"> to </span>L_{u_j}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span>, the verifier checks that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\left(I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, \\vec{h}_v) + I_{H^{\\text{arity}(v)+m_v}}((\\vec{c}_1, \\vec{c}_2), \\vec{0}) \\cdot \\mathbb{Z}_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3)\\right). \\tag{12}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For this, the prover sends $(R_v(\\vec{\\gamma}_j, \\vec{c}_3))_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, which the verifier uses to compute the above expression. The verifier checks that these values are correct using a standard interpolation trick and a single query to </span>R_v<span class="math">. To make this query, the verifier (i) tests that </span>R_v<span class="math"> is close to (the evaluation of) a polynomial in </span>\\mathbb{F}[X_{1,\\dots,\\text{arity}(v)}^{\\leq \\mathrm{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]$; (ii) uses self-correction to make the required query.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every leaf vertex <span class="math">v</span> of <span class="math">G</span>, and for every <span class="math">(\\vec{\\gamma}, a) \\in L_v</span>, the verifier checks that <span class="math">\\dot{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a> = a</span>, i.e., that <span class="math">\\mathbf{x}_v(\\vec{\\gamma}) = a</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency. The protocol runs a <span class="math">\\lambda^k</span>-strong zero knowledge sumcheck protocol at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times on polynomials of at most </span>\\operatorname{arity}(G) + k<span class="math"> variables. Inspection of the protocol shows that we can execute Step 1 in parallel for all vertices at the same depth, so the number of rounds is at most </span>\\operatorname{depth}(G)(\\operatorname{arity}(G) + 2k + 2)<span class="math">. The running time of the verifier is clearly polynomial in </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The number of queries to the </span>R_v<span class="math"> is at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ k + \\lambda)<span class="math">, and the number of queries to the </span>\\pi_v<span class="math"> is at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\operatorname{arity}(G) + k + \\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness. Perfect completeness is clear from the protocol description and the perfect completeness of the zero-knowledge sumcheck protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Let <span class="math">v_1, v_2, \\ldots</span> be any topological order of the internal vertices of <span class="math">G</span>, and define let <span class="math">V_{\\geq i}</span> be the union of <span class="math">\\{v_j : j \\geq i\\}</span> and the leaf vertices of <span class="math">G</span>. First we argue that if before iteration <span class="math">i</span> of Step 1 there exists <span class="math">v \\in V_{\\geq i}</span> such that <span class="math">L_v</span> contains <span class="math">(\\vec{\\gamma}, a)</span> with <span class="math">\\dot{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a> \\neq a</span>, then after this iteration with high probability either (a) the verifier rejects, or (b) there exists <span class="math">w \\in V_{\\geq i+1}</span>, such that there is <span class="math">(\\vec{\\gamma}&#x27;, b) \\in L_w</span> with <span class="math">\\dot{w}<a href="\\vec{\\gamma}&#x27;">\\mathbf{x}</a> \\neq b</span>. If <span class="math">v \\in V_{\\geq i+1}</span> then there is nothing to do, so we may assume that <span class="math">v = v_i</span>. The probability that $\\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{v_i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\dot{v}_i<a href="\\vec{\\gamma}_j">\\mathbf{x}</a> = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{v_i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j a_j<span class="math"> is </span>1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. So with probability </span>1 - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> we run the zero knowledge sumcheck protocol on a false claim about a polynomial with </span>(\\operatorname{arity}(v) + m_v + k)<span class="math"> variables and individual degree at most </span>2\\lambda<span class="math">, which means that with probability at least </span>1 - O((\\operatorname{arity}(v) + m_v + k) \\cdot \\lambda / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$ either the verifier rejects or outputs the false claim</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\left( \\alpha_j I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, \\dot{u}_1[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_1}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_1}}), \\dots, \\dot{u}_t[\\mathbf{x}](\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_t}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_t}}) \\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad + I_{H^{\\text{arity}(v)+m_v}}((\\vec{c}_1, \\vec{c}_2), \\vec{0}) \\cdot \\mathbb{Z}_{H^{\\text{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3) \\right). \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The verifier receives values $(r_j)_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, which it substitutes for </span>R_v(\\vec{\\gamma}_j, \\vec{c}_3)<span class="math"> in Equation 12. If this expression does not evaluate to </span>b<span class="math">, then the verifier rejects. If </span>R_v<span class="math"> is far from any polynomial in </span>\\mathbb{F}[X_{1,\\dots,\\text{arity}(v)}^{\\leq \\mathrm{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2}]<span class="math">, then the verifier rejects with high probability. If there exists some </span>j<span class="math"> such that </span>r_j \\neq R_v(\\vec{\\gamma}_j, \\vec{c}_3)<span class="math">, then by the soundness of the polynomial interpolation test, the verifier will reject with probability at least </span>1 - O((\\operatorname{arity}(v) + k) \\cdot \\lambda /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. Otherwise, it must be</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the case that <span class="math">\\dot{u}_j<a href="\\vec{c}">\\mathbf{x}</a> \\neq h_j</span> where <span class="math">u_j</span> is one of the <span class="math">\\mathrm{out}_G(v_i)</span> children of <span class="math">v_i</span>. Since <span class="math">u_j \\in V_{\\geq i+1}</span>, with high probability after this iteration either the verifier has already rejected or there is <span class="math">w \\in V_{\\geq i+1}</span> and <span class="math">(\\vec{\\gamma}&#x27;, a&#x27;) \\in L_w</span> with <span class="math">\\dot{w}<a href="\\vec{\\gamma}&#x27;">\\mathbf{x}</a> \\neq a&#x27;</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above implies soundness in a straightforward way: if <span class="math">\\mathcal{C}[\\mathbf{x}] \\neq \\mathbf{y}</span> then the condition is satisfied before the first iteration, and in each iteration with high probability either the condition is maintained or the verifier rejects. Thus with high probability either the verifier rejects or the invariant holds before the last iteration; after the last iteration, the verifier will reject with high probability because only leaf vertices are left (and claims about them are checked directly). More precisely, by a union bound over all the internal vertices, and setting the parameters of the proximity test appropriately, if <span class="math">\\mathcal{C}[\\mathbf{x}] \\neq \\mathbf{y}</span> then the verifier accepts with probability $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathrm{arity}(G) + k) \\cdot \\lambda / (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Zero knowledge. We prove that the protocol has perfect zero knowledge by exhibiting a polynomial-time simulator that perfectly samples the view of any malicious verifier. We will assume that the simulator maintains the label sets <span class="math">L_v</span> in the same way as the honest verifier, but for clarity we will not state this in its description.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span>, sample <span class="math">R_{\\mathrm{sim}}^v \\in \\mathbb{F}[X_{1,\\dots,\\mathrm{arity}(v)}^{\\leq \\mathrm{in}_G(v)}, Y_{1,\\dots,k}^{\\leq 2\\lambda}]</span> uniformly at random. Use <span class="math">R_{\\mathrm{sim}}^v</span> to answer queries to <span class="math">R_v</span>.</li>

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span>, run the <span class="math">\\lambda^k</span>-strong ZK sumcheck simulator on input <span class="math">(\\mathbb{F}, \\mathrm{arity}(v) + m_v + k, \\lambda, H, \\cdot)</span>, and use it to answer queries to <span class="math">\\pi_v</span> throughout. Recall that the behavior of each simulator does not depend on the claim being proven until after the first simulated message, so we can choose these later.</li>

      <li>For every internal vertex <span class="math">v</span> of <span class="math">G</span> taken in (any) topological order, letting <span class="math">t \\coloneqq \\mathrm{out}_G(v)</span>:</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a) Receive $\\tilde{\\alpha}_1, \\ldots, \\tilde{\\alpha}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ from the verifier.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) Using the subsimulator for <span class="math">v</span>, simulate the strong ZK sumcheck protocol on the claim</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">" \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\tilde{\\alpha}_j \\dot{v}<a href="\\vec{\\gamma}_j">\\mathbf{x}</a> = \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\tilde{\\alpha}_j a_j".</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The subsimulator will query the oracle <span class="math">F</span> at a single location <span class="math">\\vec{c} = (\\vec{c}_1, \\vec{c}_2, \\vec{c}_3)</span> with <span class="math">\\vec{c}_1 \\in \\mathbb{F}^{\\mathrm{arity}(v)}</span>, <span class="math">\\vec{c}_2 \\in \\mathbb{F}^{m_v}</span>, and <span class="math">\\vec{c}_3 \\in \\mathbb{F}^k</span>. Reply with the value</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\sum_{j=1}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\alpha_j \\left(I_{G^k}(\\vec{0}, \\vec{c}_3) \\cdot I_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j, \\vec{c}_1) \\cdot C_v(\\vec{c}_1, \\vec{c}_2, h_{\\mathrm{sim}}^1, \\dots, h_{\\mathrm{sim}}^t) \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp; \\quad \\left. + I_{H^{\\mathrm{arity}(v) + m_v}}\\left((\\vec{c}_1, \\vec{c}_2), \\vec{0}\\right) \\cdot \\mathbb{Z}_{H^{\\mathrm{arity}(v)}}(\\vec{\\gamma}_j) \\cdot R_v(\\vec{\\gamma}_j, \\vec{c}_3)\\right), \\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">h_{\\mathrm{sim}}^1, \\ldots, h_{\\mathrm{sim}}^t \\in \\mathbb{F}</span> are chosen as follows. Let <span class="math">e_1 = (v, u_1), \\ldots, e_t = (v, u_t)</span> be the outgoing edges of <span class="math">v</span> (with multiplicity). For every <span class="math">k \\in \\{1, \\ldots, t\\}</span>, letting $\\vec{c}_k := (\\vec{c}_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\rho_{e_k}}, \\vec{c}_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\sigma_{e_k}})$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">i. if <span class="math">u_k</span> is a leaf vertex, then <span class="math">h_{\\mathrm{sim}}^k \\coloneqq \\mathbf{x}_{u_k}(\\vec{c}_k)</span>. ii. if <span class="math">u_k</span> is an internal vertex and <span class="math">(\\vec{c}_k, h) \\in L_{u_k}</span> for some <span class="math">h \\in \\mathbb{F}</span>, <span class="math">h_{\\mathrm{sim}}^k \\coloneqq h</span>. iii. if <span class="math">u_k</span> is an internal vertex and <span class="math">(\\vec{c}_k, h) \\notin L_{u_k}</span> for all <span class="math">h \\in \\mathbb{F}</span>, sample <span class="math">h_{\\mathrm{sim}}^k</span> at random and add <span class="math">(\\vec{c}_k, h_{\\mathrm{sim}}^k)</span> to <span class="math">L_{u_k}</span>.</p>

    <p class="text-gray-300">(c) Send <span class="math">h_{\\mathrm{sim}}^1, \\ldots, h_{\\mathrm{sim}}^t</span> to the verifier.</p>

    <p class="text-gray-300">The view of the verifier in a real execution is composed of the messages from the prover during each sumcheck protocol, the values <span class="math">\\dot{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a></span> for every internal vertex <span class="math">v</span> in <span class="math">V</span> and <span class="math">(\\vec{\\gamma}, a) \\in L_v</span>, and the verifier's queries to the oracles <span class="math">R_v</span> and <span class="math">\\pi_v</span> for every internal vertex <span class="math">v</span> in <span class="math">V</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Any <span class="math">b</span>-query malicious verifier <span class="math">\\tilde{V}</span> may query any <span class="math">R_v</span> at strictly fewer than <span class="math">b</span> points. By Corollary 5.3, <span class="math">S_v(\\vec{x}) \\coloneqq \\sum_{\\vec{y} \\in G^k} R_v(\\vec{x}, \\vec{y})</span> is uniformly random in <span class="math">\\mathbb{F}[X_{1,\\dots,\\mathrm{arity}(v)}^{\\leq \\mathrm{in}_G(v)}]</span>, even conditioned on the values of the fewer than <span class="math">\\lambda^k \\leq b</span> queries made by <span class="math">\\tilde{V}</span> to <span class="math">R_v</span>. Therefore any string <span class="math">\\left(\\dot{v}<a href="\\vec{\\gamma}_1">\\mathbf{x}</a>, \\ldots, \\dot{v}<a href="\\vec{\\gamma}_\\ell">\\mathbf{x}</a>\\right)</span> for <span class="math">\\ell \\leq \\mathrm{in}_G(v)</span> and distinct <span class="math">\\vec{\\gamma}_1, \\ldots, \\vec{\\gamma}_\\ell \\in (\\mathbb{F} - H)^{\\mathrm{arity}(v)}</span> is identically distributed to a uniformly random string in <span class="math">\\mathbb{F}^\\ell</span>. Observe that for every internal vertex <span class="math">v</span> in <span class="math">V</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathrm{in}_G(v)<span class="math">, and the prover sends </span>\\dot{v}<a href="\\vec{\\gamma}">\\mathbf{x}</a><span class="math"> for each </span>(\\vec{\\gamma}, a) \\in L_v<span class="math">, so all of these values are uniformly random in </span>\\mathbb{F}<span class="math">, and thus identically distributed to the values </span>h_{\\mathrm{sim}}^i$ the simulator sends.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Clearly <span class="math">R_{\\mathrm{sim}}^v</span> and <span class="math">R_v</span> are identically distributed for every internal vertex <span class="math">v</span> in <span class="math">V</span>. The perfect zero knowledge property of the strong ZK sumcheck simulator guarantees that the simulation of <span class="math">\\pi_v</span> and the messages sent during the sumcheck protocol is perfect given a single query to the oracle <span class="math">F</span>. We simulate this query by substituting values <span class="math">h_{\\mathrm{sim}}^i</span> in place of <span class="math">\\dot{u}_i<a href="\\vec{c}_i">\\mathbf{x}</a></span>, which we argue above are identically distributed.</p>

    <p class="text-gray-300">42</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It follows from the description and the efficiency of the subsimulator that the simulator runs in time  $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathrm{arity}(G) + k)(\\lambda \\mathfrak{q}_{\\hat{V}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\lambda^3 \\mathfrak{q}_{\\hat{V}}^3) \\cdot \\mathrm{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ , provided we use the algorithm of Corollary 4.1 for Step 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To make the sum-product circuit satisfaction protocol zero knowledge, in addition to the above considerations we must also avoid leaking information about the witness  <span class="math">\\mathbf{x}</span> . This we achieve using similar techniques to those seen previously: for each leaf vertex  <span class="math">w</span> , rather than directly sending the auxiliary input polynomial  <span class="math">\\mathbf{z}_w(\\vec{X})</span> , the prover sends a polynomial  <span class="math">\\mathbf{z}_w&#x27;(\\vec{X},\\vec{Y})</span>  chosen randomly from the set of low-degree polynomials summing over  <span class="math">H^k</span>  to  <span class="math">\\mathbf{z}_w(\\vec{X})</span>  for some appropriately-chosen  <span class="math">k</span> . This acts as a perfectly hiding commitment to the witness.</p>

    <p class="text-gray-300">We show that we can efficiently construct a sum-product circuit  <span class="math">\\mathcal{C}&#x27;</span>  which outputs  <span class="math">\\mathbf{y}</span>  on input  <span class="math">(\\mathbf{x},\\mathbf{z}_w&#x27;)</span>  if and only if the original sum-product circuit outputs  <span class="math">\\mathbf{y}</span>  on input  <span class="math">(\\mathbf{x},\\mathbf{z}_w)</span> . We then obtain our zero-knowledge protocol by running the protocol of Theorem 9.1 on  <span class="math">\\mathcal{C}&#x27;</span> , implementing the queries to the input as queries to the proof (with self-correction).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9.2 (PZK IPCP for  <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span> ). For every query bound function  <span class="math">b(n)</span> , the relation  <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all  <span class="math">b</span> -query malicious verifiers. In more detail, letting  $\\alpha := \\log b / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RSPCS ∈ PZK-IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">O(δinδlf · in(G) · (arity(G) + α) ·</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(depth(G) · (arity(G) + α))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">·</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G)+2α)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">V(G)</td>

            <td class="px-3 py-2 border-b border-gray-700">· poly(log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">, arity(G), α, δin, δlf, in(G))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">arity(G)+α)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">,</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O((arity(G) + α) · width(G) · in(G) · log</td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">+ log</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">+ space(x))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">simulator overhead:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(</td>

            <td class="px-3 py-2 border-b border-gray-700">C</td>

            <td class="px-3 py-2 border-b border-gray-700">, α) · (</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">+ qV3).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix  $k \\coloneqq \\log b / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Let  </span>\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{lf}}, G, C)<span class="math">  be a sum-product circuit and let  </span>G = (V, E, \\rho, \\sigma)<span class="math">  be its ari-graph. Let  </span>\\mathbf{x}<span class="math">  be a partial mapping of the leaf vertices of  </span>G<span class="math">  to arithmetic circuits. We construct the new sum-product circuit  </span>\\mathcal{C}' = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\max\\{\\delta_{\\mathrm{lf}}, 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}, G', C')$  where:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the new ari-graph  <span class="math">G&#x27; = (V&#x27;, E&#x27;, \\rho&#x27;, \\sigma&#x27;)</span>  extends  <span class="math">G</span>  by adding a new vertex  <span class="math">v_w</span>  and a new edge  <span class="math">(w, v_w)</span>  for each leaf vertex  <span class="math">w</span>  not in the domain of  <span class="math">\\mathbf{x}</span>  as follows</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">V ^ {\\prime} := V \\cup \\left\\{v _ {w}: w \\in V \\text {i s a l e a f} \\right\\},</span></div>

    <div class="my-4 text-center"><span class="math-block">E ^ {\\prime} := E \\cup \\left\\{\\left(w, v _ {w}\\right): w \\in V \\text {i s a l e a f} \\right\\},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {e} ^ {\\prime} := \\left\\{ \\begin{array}{l l} \\rho_ {e} &amp;amp; \\text {i f} e \\in E \\\\ \\{1, \\ldots , \\mathsf {a r i t y} (w) \\} &amp;amp; \\text {i f} e = (w, v _ {w}) \\text {a n d} w \\text {i s a l e a f i n} V \\end{array} \\right.,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sigma_ {e} ^ {\\prime} := \\left\\{ \\begin{array}{l l} \\sigma_ {e} &amp;amp; \\text {i f} e \\in E \\\\ \\{1, \\ldots , k \\} &amp;amp; \\text {i f} e = (w, v _ {w}) \\text {a n d} w \\text {i s a l e a f i n} V \\end{array} \\right..</span></div>

    <p class="text-gray-300">Note that the vertex and edge sets at most double in size,  <span class="math">\\mathrm{depth}(G&#x27;) = \\mathrm{depth}(G) + 1</span> ,  <span class="math">\\mathrm{arity}(v_w) = \\mathrm{arity}(w) + k</span>  and  <span class="math">m_{v_w} = k</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C&#x27;</span>  is such that  <span class="math">C_v&#x27; := C_v</span>  for every internal vertex  <span class="math">v</span>  in  <span class="math">V</span> , and  <span class="math">C_v&#x27;</span>  is the univariate polynomial  <span class="math">X</span>  for every leaf vertex  <span class="math">v</span>  in  <span class="math">V</span> .</li>

    </ul>

    <p class="text-gray-300">Before describing the protocol, we prove a claim that relates the two sum-product circuits  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathcal{C}&#x27;</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim. For every  <span class="math">\\mathbf{y} \\in \\mathbb{F}</span> ,  <span class="math">(\\mathcal{C}, \\mathbf{y}, \\mathbf{x}) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span>  if and only if  <span class="math">(\\mathcal{C}&#x27;, \\mathbf{y}, (\\mathbf{x}, \\mathbf{z}&#x27;)) \\in \\mathcal{L}_{\\mathrm{SPCE}}</span>  for some input  <span class="math">\\mathbf{z}&#x27;</span>  for  <span class="math">\\mathcal{C}&#x27;</span>  such that  $\\mathbf{z}_{v_w}' \\in \\mathbb{F}[X_{1,\\ldots,\\mathrm{arity}(w)}^{\\leq \\delta_{\\mathrm{lf}}}, Y_{1,\\ldots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">  for every leaf  </span>w<span class="math">  in  </span>V$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of claim. First suppose that <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x})\\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span>, so there exists an auxiliary input <span class="math">\\mathbf{z}</span> for <span class="math">\\mathcal{C}</span> such that <span class="math">\\mathcal{C}[\\mathbf{x},\\mathbf{z}] = \\mathbf{y}</span>. Define <span class="math">\\mathbf{z}&#x27;</span> to be the auxiliary input for <span class="math">\\mathcal{C}&#x27;</span> such that <span class="math">\\mathbf{z}_{v_w}&#x27;(\\vec{X},\\vec{Y}):= I_{H^k}(\\vec{Y},\\vec{0})\\cdot \\mathbf{x}_w(\\vec{X})</span> for every leaf <span class="math">w</span> in <span class="math">V</span> in the domain of <span class="math">\\mathbf{z}</span>. Note that for each such leaf <span class="math">w</span> in <span class="math">V</span>, <span class="math">\\mathbf{z}_{v_w}&#x27;</span> respects the desired degree bounds and, moreover, <span class="math">w\\mathbf{x},\\mathbf{z}&#x27; = \\sum_{\\vec{\\beta}\\in H^k}I_{H^k}(\\vec{\\beta},\\vec{0})\\cdot \\mathbf{z}_w(\\vec{X}) = \\mathbf{z}_w(\\vec{X}) = w\\mathbf{x},\\mathbf{z}</span>. By construction of <span class="math">G&#x27;</span>, we deduce that <span class="math">\\mathcal{C}&#x27;[\\mathbf{x},\\mathbf{z}&#x27;] = \\mathbf{y}</span>, so that <span class="math">(\\mathcal{C}&#x27;,\\mathbf{y},(\\mathbf{x},\\mathbf{z}&#x27;))\\in \\mathcal{L}_{\\mathrm{SPCE}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next suppose that <span class="math">(\\mathcal{C}&#x27;,\\mathbf{y},(\\mathbf{x},\\mathbf{z}&#x27;))\\in \\mathcal{L}_{\\mathrm{SPCE}}</span> for some input <span class="math">\\mathbf{z}&#x27;</span> for <span class="math">\\mathcal{C}&#x27;</span> such that $\\mathbf{z}_{v_w}' \\in \\mathbb{F}[X_{1,\\dots,\\mathrm{arity}(w)}^{\\leq \\delta_{\\mathrm{ff}}}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> for every leaf </span>w<span class="math"> in </span>V<span class="math"> not in the domain of </span>\\mathbf{x}<span class="math">. Define </span>\\mathbf{z}<span class="math"> to be the input for </span>\\mathcal{C}<span class="math"> such that </span>\\mathbf{z}_w(\\vec{X}) := \\sum_{\\beta \\in H^k} \\mathbf{z}_{v_w}'(\\vec{X}, \\vec{\\beta})<span class="math"> for each leaf </span>w<span class="math"> in </span>V<span class="math">. Note that for each leaf </span>w<span class="math"> in </span>V<span class="math"> not in the domain of </span>\\mathbf{x}<span class="math">, </span>\\mathbf{z}_w<span class="math"> has individual degree at most </span>\\delta_{\\mathrm{ff}}<span class="math"> and, moreover, </span>w\\mathbf{x},\\mathbf{z} = \\sum_{\\beta \\in H^k} \\mathbf{z}_{v_w}'(\\vec{X}, \\vec{\\beta}) = w\\mathbf{x},\\mathbf{z}'<span class="math">. By construction of </span>G'<span class="math">, this implies that </span>\\mathcal{C}[\\mathbf{x},\\mathbf{z}'] = \\mathbf{y}<span class="math">, so that </span>(\\mathcal{C},\\mathbf{y},\\mathbf{x}) \\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol proceeds as follows. The prover and verifier receive a SPCS instance <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x})</span> as input, and the prover additionally receives an auxiliary input <span class="math">\\mathbf{z}</span> for <span class="math">\\mathcal{C}</span> that is a valid witness for <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x})</span>. Both use <span class="math">\\mathcal{C}</span> to construct the new sum-product circuit <span class="math">\\mathcal{C}&#x27;</span> from the above claim; in addition, the prover uses <span class="math">\\mathbf{z}</span> to sample an input <span class="math">\\mathbf{z}&#x27;</span> for <span class="math">\\mathcal{C}&#x27;</span> by choosing, for each leaf <span class="math">w</span> in the domain of <span class="math">\\mathbf{z}</span>, a polynomial $\\mathbf{z}_{v_w}' \\in \\mathbb{F}[X_{1,\\dots,\\text{arity}(w)}^{\\leq \\delta_{\\mathrm{ff}}}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> uniformly at random conditioned on </span>\\sum_{\\vec{\\beta} \\in H^k} \\mathbf{z}_{v_w}'(\\vec{\\alpha}, \\vec{\\beta}) = \\mathbf{z}_w(\\vec{\\alpha})<span class="math"> for all </span>\\vec{\\alpha} \\in \\mathbb{F}^{\\text{arity}(w)}<span class="math">. The prover and verifier then engage in the zero knowledge Interactive Probabilistically Checkable Proof for the language </span>\\mathcal{L}_{\\mathrm{SPCE}}<span class="math"> (see Theorem 9.1) on input </span>(\\mathcal{C}',\\mathbf{y},(\\mathbf{x},\\mathbf{z}'))<span class="math">, with the prover appending the auxiliary input </span>\\mathbf{z}'<span class="math"> to the proof oracle. At the end of the protocol the verifier needs to make a single query </span>\\vec{\\gamma}_{v_w}<span class="math"> to </span>\\mathbf{z}_{v_w}'<span class="math"> for each leaf vertex </span>w<span class="math"> in the domain of </span>\\mathbf{x}<span class="math">, so the verifier tests that </span>\\mathbf{z}_{v_w}'<span class="math"> is close to the evaluation of a polynomial in </span>\\mathbb{F}[X_{1,\\dots,\\text{arity}(w)}^{\\leq \\delta_{\\mathrm{ff}}}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> and then uses self-correction to read </span>\\mathbf{z}_{v_w}'(\\vec{\\gamma}_{v_w})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completeness is straightforward to argue; we only discuss soundness and then zero knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">(\\mathcal{C},\\mathbf{y},\\mathbf{x}) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span>, and let <span class="math">\\tilde{\\mathbf{z}}</span> be the input for <span class="math">\\mathcal{C}&#x27;</span> that the prover has appended to the proof oracle. If there exists a leaf vertex <span class="math">w</span> in the domain of <span class="math">\\tilde{\\mathbf{z}}</span> such that <span class="math">\\tilde{\\mathbf{z}}_{v_w}</span> is more than <span class="math">\\delta</span>-far from a polynomial in $\\mathbb{F}[X_{1,\\dots,\\text{arity}(w)}^{\\leq \\delta_{\\mathrm{ff}}}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math">, then the verifier accepts with probability at most </span>\\epsilon<span class="math">. So suppose that this is not the case, and let </span>\\tilde{\\mathbf{z}}_{v_w}'<span class="math"> be the unique polynomial in </span>\\mathbb{F}[X_{1,\\dots,\\text{arity}(w)}^{\\leq \\delta_{\\mathrm{ff}}}, Y_{1,\\dots,k}^{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}]<span class="math"> that is </span>\\delta<span class="math">-close to </span>\\tilde{\\mathbf{z}}_{v_w}<span class="math">. Using self-correction, the verifier obtains </span>\\tilde{\\mathbf{z}}_{v_w}'(\\vec{\\gamma}_{v_w})<span class="math"> with probability at least </span>1 - \\epsilon<span class="math">. By a union bound, the probability that the verifier learns all the values correctly is at least </span>1 - \\epsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By the claim, </span>(\\mathcal{C},\\mathbf{y},\\mathbf{x}) \\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})<span class="math"> implies that </span>(\\mathcal{C}',\\mathbf{y},(\\mathbf{x},\\tilde{\\mathbf{z}}')) \\notin \\mathcal{L}_{\\mathrm{SPCE}}<span class="math">, so if all of the verifier&#x27;s queries are answered according to </span>\\tilde{\\mathbf{z}}'<span class="math">, the soundness of the protocol for </span>\\mathcal{L}_{\\mathrm{SPCE}}<span class="math"> implies that the verifier accepts with probability at most </span>O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{ff}} \\cdot \\mathrm{in}(G) \\cdot (\\mathrm{arity}(G) + \\log b) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Setting </span>\\epsilon<span class="math"> and </span>\\delta$ appropriately yields the claimed soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Perfect zero knowledge follows from Corollary 5.3: if a verifier makes fewer than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^k<span class="math"> queries to the proof, then each </span>\\mathbf{z}_v'<span class="math"> is indistinguishable from a random polynomial. The simulator for this protocol simply runs the simulator from Theorem 9.1 on </span>(\\mathcal{C}',\\mathbf{y},(\\mathbf{x},\\mathbf{z}'))<span class="math">, and uses the algorithm of Corollary 4.1 to simulate its queries to each </span>\\mathbf{z}_v'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We present an efficient reduction from problems decidable in polynomial space (PSPACE) to sum-product circuit evaluation problems ( <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span> , Definition 8.9). The reduction yields perfect zero knowledge IPCPs for PSPACE, via our construction of perfect zero knowledge IPCPs for  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  (Theorem 9.1), resolving an open problem of [BCFGRS16].</p>

    <p class="text-gray-300">Our starting point is the language of true quantified boolean formulas (TQBFs), which is PSPACE-complete:</p>

    <p class="text-gray-300">Definition 10.1. Let  <span class="math">\\mathcal{L}_{\\mathrm{TQBF}}</span>  be the language of quantified boolean formulas  <span class="math">\\Phi = \\mathrm{Q}_1x_1\\cdots \\mathrm{Q}_nx_n\\phi(x_1,\\ldots,x_n)</span> , with  <span class="math">\\mathrm{Q}_i \\in \\{\\forall, \\exists\\}</span> , that evaluate to true. We denote by  <span class="math">n</span>  the number of variables and by  <span class="math">c</span>  the number of clauses in  <span class="math">\\phi</span> .</p>

    <p class="text-gray-300">The theorem below is a 'zero knowledge analogue' of Shamir's protocol for  <span class="math">\\mathcal{L}_{\\mathrm{TQBF}}</span>  [Sha92], sharing all its key features except that it is an Interactive PCP rather than an Interactive Proof. We prove that  <span class="math">\\mathcal{L}_{\\mathrm{TQBF}}</span>  has a public-coin Interactive PCP that is perfect zero knowledge, with exponential proof length and polynomial query complexity; also, like Shamir's protocol, the number of rounds is  <span class="math">O(n^{2})</span> , the prover runs in space  <span class="math">\\mathrm{poly}(c)</span>  and the verifier in time  <span class="math">\\mathrm{poly}(c)</span> .</p>

    <p class="text-gray-300">Theorem 10.2 (PZK IPCP for PSPACE). For every query bound function  <span class="math">\\mathsf{b}(n)</span> , the PSPACE-complete language  <span class="math">\\mathcal{L}_{\\mathrm{TQBF}}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all b-query malicious verifiers. In more detail:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {L} _ {\\mathrm {T Q B F}} \\in \\mathbf {P Z K - I P C P} \\left[ \\begin{array}{l l} \\text {s o u n d n e s s e r r o r :} &amp; 1 / 2 \\\\ \\text {r o u n d c o m p l e x i t y :} &amp; O (n \\cdot (n + \\log \\mathsf {b})) \\\\ \\text {p r o o f l e n g t h :} &amp; (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log \\mathsf {b}) ^ {O (n + \\log \\mathsf {b})} \\\\ \\text {q u e r y c o m p l e x i t y :} &amp; \\mathrm {p o l y} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log \\mathsf {b}) \\\\ \\text {p r o v e r t i m e :} &amp; (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log \\mathsf {b}) ^ {O (n + \\log \\mathsf {b})} \\\\ \\text {v e r i f i e r t i m e :} &amp; \\mathrm {p o l y} (n, \\log \\mathsf {b}) + O (c) \\\\ \\text {v e r i f i e r s p a c e :} &amp; O ((n + \\log \\mathsf {b}) \\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\\\ \\text {s i m u l a t o r o v e r h e a d :} &amp; \\mathrm {p o l y} (n + \\log \\mathsf {b}) \\cdot \\mathsf {q} _ {2} ^ {3}. \\end{array} \\right].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We first state and prove the reduction from  <span class="math">\\mathcal{L}_{\\mathrm{TQBF}}</span>  to  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  (Lemma 10.3 below), and then prove the theorem. The reduction is based on Shen's arithmetization of QBFs [She92] and (at least implicitly) his idea of degree reduction. (In particular, we do not rely on Shamir's restriction to 'simple' QBFs [Sha92].) We use Shen's arithmetization in order to ensure that the arithmetized expression only takes boolean values.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 10.3 ( <span class="math">\\mathcal{L}_{\\mathrm{TQBF}} \\to \\mathcal{L}_{\\mathrm{SPCE}}</span> ). There exists a polynomial-time function  <span class="math">f</span>  such that, for every quantified boolean formula  <span class="math">\\Phi</span>  and prime  <span class="math">p</span> ,  <span class="math">f(\\Phi, p) \\in \\mathcal{L}_{\\mathrm{SPCE}}</span>  if and only if  <span class="math">\\Phi</span>  is true. Moreover, if  <span class="math">\\Phi</span>  has  <span class="math">n</span>  variables and  <span class="math">c</span>  clauses then  <span class="math">f(\\Phi, p)</span>  is a sum-product circuit instance  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{lf}}, G, C)</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(1)<span class="math"> ,  </span>\\delta_{\\mathrm{in}} = \\Theta(1)<span class="math"> ,  </span>\\delta_{\\mathrm{lf}} = \\Theta(c)<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(n)<span class="math"> ,  </span>\\operatorname{arity}(G) = \\Theta(n)<span class="math"> ,  </span>\\operatorname{in}(G) = \\Theta(1)<span class="math"> ,  </span>\\operatorname{width}(G) = \\Theta(1)<span class="math"> ,  </span>\\operatorname{space}(\\mathbf{x}) = O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Let  <span class="math">\\Phi</span>  be a quantified boolean formula that, without loss of generality, has the following 'regular' form:</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi = \\forall x _ {1} \\exists x _ {2} \\dots \\forall x _ {n - 1} \\exists x _ {n} \\phi (x _ {1}, x _ {2}, \\ldots , x _ {n - 1}, x _ {n}) ,</span></div>

    <p class="text-gray-300">where  <span class="math">\\phi</span>  is a 3-CNF formula with  <span class="math">c</span>  clauses, and  <span class="math">n</span>  is even. This regular form is achievable with only constant multiplicative overheads in the number of variables and clauses. We arithmetize the formula and quantifiers.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The arithmetization of a 3-CNF formula  <span class="math">\\phi</span>  with variables  <span class="math">z_{1},\\ldots ,z_{n}</span>  and clauses  <span class="math">K_{1},\\ldots ,K_{c}</span>  is the polynomial  <span class="math">\\hat{\\phi}</span>  of total degree at most  <span class="math">3c</span>  given by:  <span class="math">\\hat{\\phi} (Z_1,\\dots,Z_n)\\coloneqq \\prod_{K\\in \\phi}(1 - \\prod_{\\{i:z_i\\in K\\}}(1 - Z_i)\\cdot \\prod_{\\{i:\\bar{z}_i\\in K\\}}Z_i)</span> . Note that  <span class="math">\\hat{\\phi} (x_{1},\\ldots ,x_{n}) = \\phi (x_{1},\\ldots ,x_{n})</span>  for all boolean  <span class="math">x_{1},\\ldots ,x_{n}</span>  (i.e., they agree on the boolean hypercube).</li>

      <li>The arithmetization of the two quantifiers is as follows:  <span class="math">\\forall x\\phi (x)</span>  maps to  <span class="math">\\prod_{x\\in \\{0,1\\}}\\hat{\\phi} (x)</span>  and  <span class="math">\\exists x\\phi (x)</span>  maps to  <span class="math">\\prod_{x\\in \\{0,1\\}}\\hat{\\phi} (x)\\coloneqq \\big(1 - (1 - \\hat{\\phi} (0))(1 - \\hat{\\phi} (1))\\big)</span> . These arithmetic expressions have the same value as the boolean expressions (over any field); in particular they are 0 or 1.</li>

    </ul>

    <p class="text-gray-300">For any prime  <span class="math">p</span> , consider the following construction.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use <span class="math">n, c, p</span> to construct a sum-product circuit instance <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G, C)</span> where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{F} := \\mathbb{F}_p; \\quad H := \\{0, 1\\}; \\quad \\delta_{\\mathrm{in}} := 4; \\quad \\delta_{\\mathrm{ff}} := 3c;</span></div>

    <p class="text-gray-300">the ari-graph <span class="math">G \\coloneqq (V, E)</span> is defined as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} V &amp;amp;:= \\{v_i\\}_{i \\in \\{0, \\dots, n\\}} \\\\ E &amp;amp;:= \\{e_i, e_i&#x27; = (v_i, v_{i+1})\\}_{i \\in \\{0, \\dots, n-1\\}} \\\\ \\rho_e &amp;amp;:= \\{1, \\dots, i\\} \\quad \\text{if } e = e_i \\text{ or } e = e_i&#x27; \\text{ for some } i \\in \\{0, \\dots, n-1\\}, \\\\ \\sigma_e &amp;amp;:= \\begin{cases} \\{1\\} &amp;amp; \\text{if } e = e_i \\text{ for some } i \\in \\{0, \\dots, n-1\\} \\text{ or} \\\\ \\{2\\} &amp;amp; \\text{if } e = e_i&#x27; \\text{ for some } i \\in \\{0, \\dots, n-1\\}, \\\\ C_{v_i} &amp;amp;:= \\begin{cases} (1 - X_i)X_i \\cdot ZZ&#x27; &amp;amp; \\text{if } i \\in \\{0, \\dots, n-1\\} \\text{ is even or} \\\\ (1 - X_i)X_i \\cdot \\big(1 - (1 - Z)(1 - Z&#x27;)\\big) &amp;amp; \\text{if } i \\in \\{0, \\dots, n-1\\} \\text{ is odd}, \\end{cases} \\end{aligned}</span></div>

    <p class="text-gray-300">where <span class="math">Z, Z&#x27;</span> in both cases correspond to the edges <span class="math">e_i, e_i&#x27;</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct an input <span class="math">\\mathbf{x}</span> for <span class="math">\\mathcal{C}</span> that maps <span class="math">v_n</span> to the polynomial <span class="math">\\hat{\\phi}</span> in <span class="math">\\mathbb{F}_p[X_{1,\\dots,n}^{\\leq 3c}]</span> that equals the arithmetization of <span class="math">\\phi</span>.</li>

    </ul>

    <p class="text-gray-300">See Figure 1, Figure 2, Figure 3 for diagrams of this sum-product circuit and input for 2, 4, <span class="math">n</span> variables respectively.</p>

    <p class="text-gray-300">We claim that for every even <span class="math">i</span> in <span class="math">\\{0, \\dots, n\\}</span> and <span class="math">x_1, \\dots, x_i \\in \\{0, 1\\}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">v_i[\\mathbf{x}] (x_1, x_2 \\dots, x_{i-1}, x_i) = \\prod_{x_{i+1} \\in \\{0,1\\}} \\prod_{x_{i+2} \\in \\{0,1\\}} \\dots \\prod_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1, x_2, \\dots, x_{n-1}, x_n) \\tag{13}</span></div>

    <p class="text-gray-300">We argue the equality by induction on <span class="math">i</span>. When <span class="math">i = n</span>, Equation 13 is <span class="math">v_n[\\mathbf{x}] = \\hat{\\phi}</span>, which holds by definition; next, we assume the equality for <span class="math">i + 2</span> and prove it for <span class="math">i</span>. By construction, for every <span class="math">x_1, \\ldots, x_i \\in \\{0,1\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_{i+1}[\\mathbf{x}] (x_1, \\dots, x_i) &amp;amp;= \\sum_{x_{i+1}, x_{i+1}&#x27; \\in \\{0,1\\}} (1 - x_{i+1}) x_{i+1}&#x27; \\cdot (1 - (1 - v_{x_{i+2}}[\\mathbf{x}] (x_1, \\dots, x_i, x_{i+1})) (1 - v_{x_{i+2}}[\\mathbf{x}] (x_1, \\dots, x_i, x_{i+1}))) \\\\ &amp;amp;= (1 - (1 - v_{x_{i+2}}[\\mathbf{x}] (x_1, \\dots, x_i, 0)) (1 - v_{x_{i+2}}[\\mathbf{x}] (x_1, \\dots, x_i, 1))) \\\\ &amp;amp;= \\prod_{x_{i+2} \\in \\{0,1\\}} \\dots \\prod_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1, x_2, \\dots, x_{n-1}, x_n) \\tag{14} \\end{aligned}</span></div>

    <p class="text-gray-300">where the second equality follows by the inductive assumption. Then, by a similar argument,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} v_i[\\mathbf{x}] (x_1, \\dots, x_i) &amp;amp;= v_{i+1}[\\mathbf{x}] (x_1, \\dots, x_i, 0) \\cdot v_i[\\mathbf{x}] (x_1, \\dots, x_i, 1) \\\\ &amp;amp;= \\prod_{x_{i+1} \\in \\{0,1\\}} \\prod_{x_{i+2} \\in \\{0,1\\}} \\dots \\prod_{x_{n-1} \\in \\{0,1\\}} \\prod_{x_n \\in \\{0,1\\}} \\hat{\\phi}(x_1, x_2, \\dots, x_{n-1}, x_n) \\tag{15} \\end{aligned}</span></div>

    <p class="text-gray-300">which completes the induction.</p>

    <p class="text-gray-300">We now turn to the reduction's completeness and soundness. The key fact, which immediately follows from Equation 13 and the arithmetization's properties, is that the quantified boolean formula <span class="math">\\Phi</span> is true if and only if <span class="math">\\mathcal{C}[\\mathbf{x}] = v_{x_1}[\\mathbf{x}]</span> is 1 (over any field <span class="math">\\mathbb{F}</span>). Thus, regardless of the choice of prime <span class="math">p</span>, <span class="math">\\Phi</span> is true if and only if <span class="math">(\\mathcal{C}, 1, \\mathbf{x}) \\in \\mathcal{L}_{\\mathrm{SPCE}}</span>. <span class="math">\\square</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 10.2. The prover and verifier receive as input a quantified boolean formula <span class="math">\\Phi</span>. They agree on a deterministic procedure to find a prime in the range <span class="math">[cn^3 \\log b, 2cn^3 \\log b]</span>; this can easily be done in polynomial time by exhaustive search and brute-force primality testing. The prover and the verifier then engage in the perfect zero knowledge Interactive PCP for <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span> (Theorem 9.1) on the input <span class="math">f(\\Phi, p)</span>. The soundness error of the protocol is $O(\\delta_{\\mathrm{in}} \\delta_{\\mathrm{ff}} \\cdot \\mathrm{in}(G) \\cdot (\\mathrm{arity}(G) + \\log b) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O(cn^2 \\log b / p)<span class="math">; the size of </span>p<span class="math"> ensures that the soundness error is </span>O(1/n) &lt; 1/2<span class="math"> for sufficiently large </span>n<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 1: Sum-product circuit and its input for QBF with 2 variables.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: Sum-product circuit and its input for QBF with 4 variables.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 3: Sum-product circuit and its input for QBF with  <span class="math">n</span>  variables.</p>

    <p class="text-gray-300">We present a 'zero knowledge analogue' of GKR's protocol for circuit evaluation [GKR15], except that the protocol is an Interactive PCP rather than an Interactive Proof. We achieve this by exhibiting an efficient reduction from circuit evaluation (for certain circuits) to sum-product circuit evaluation problems ( <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span> , Definition 8.9). The reduction then yields the desired zero knowledge protocol (Theorem 11.1 below), via our construction of perfect zero knowledge Interactive PCPs for  <span class="math">\\mathcal{L}_{\\mathrm{SPCE}}</span>  (Theorem 9.1). We now provide context, state the theorem, and then describe its proof.</p>

    <p class="text-gray-300">Goldwasser, Kalai, and Rothblum [GKR15] give interactive proofs for muggles (also known as doubly-efficient interactive proofs [RRR16]) for low-depth circuits that are sufficiently uniform.</p>

    <p class="text-gray-300">Namely, given a language  <span class="math">\\mathcal{L}</span>  decidable by a family of  <span class="math">O(\\log S(n))</span> -space uniform boolean circuits of size  <span class="math">S(n)</span>  and depth  <span class="math">D(n)</span> , [GKR15] gives a public-coin Interactive Proof for  <span class="math">\\mathcal{L}</span>  where the prover runs in time  <span class="math">\\mathrm{poly}(S(n))</span>  and the verifier runs in time  <span class="math">(n + D(n)) \\cdot \\mathrm{poly}(\\log S(n))</span>  and space  <span class="math">O(\\log S(n))</span> ; the number of rounds and communication complexity are  <span class="math">D(n) \\cdot \\mathrm{poly}(\\log S(n))</span> . Moreover, if the verifier is given oracle access to the low-degree extension of the circuit's input, the verifier runs only in time  <span class="math">D(n) \\cdot \\mathrm{poly}(\\log S(n))</span> ; this sub-linear running time enables applications to Interactive Proofs of Proximity [RVW13].</p>

    <p class="text-gray-300">The theorem below provides similar features, but in addition also provides perfect zero knowledge, via an Interactive PCP instead of an Interactive Proof.</p>

    <p class="text-gray-300">Theorem 11.1 (PZK IPCP for low-depth uniform boolean circuits). Let  <span class="math">\\mathcal{L}</span>  be a language decidable by a family of  <span class="math">O(\\log S(n))</span> -space uniform boolean circuits of size  <span class="math">S(n)</span>  and depth  <span class="math">D(n)</span> , and let  <span class="math">b(n)</span>  be a query bound function. Then  <span class="math">\\mathcal{L}</span>  has a (public-coin and non-adaptive) Interactive PCP that is perfect zero knowledge against all  <span class="math">b</span> -query malicious verifiers. In more detail:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L ∈ PZK-IPCP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">soundness error:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1/2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">round complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">D(n) · log b(n) · poly(log S(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">proof length:</td>

            <td class="px-3 py-2 border-b border-gray-700">D(n) · poly(S(n), b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">query complexity:</td>

            <td class="px-3 py-2 border-b border-gray-700">D(n) · poly(log S(n), log b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">prover time:</td>

            <td class="px-3 py-2 border-b border-gray-700">D(n) · poly(S(n), b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier time:</td>

            <td class="px-3 py-2 border-b border-gray-700">n · poly(D(n), log S(n), log b(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">verifier space:</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log S(n) + log b(n)/ log log S(n))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">simulator overhead:</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(D(n), log S(n), log b(n)) · (n + qV3).</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if the verifier (resp. simulator) is given oracle access to the low-degree extension of the circuit's input, the verifier runs in time  <span class="math">D(n) \\cdot \\mathrm{poly}(\\log S(n), \\log b(n))</span> , and the simulator overhead is  <span class="math">\\mathrm{poly}(D(n), \\log S(n), \\log b(n)) \\cdot \\mathfrak{q}_V^3</span> .</p>

    <p class="text-gray-300">Our proof of the theorem follows the structure in [GKR15]. After recalling some notions for circuits (Section 11.1) and extending some of our definitions (Section 11.2), we proceed in three steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1 (Section 11.3). We reduce the evaluation of a given layered arithmetic circuit to the evaluation of a sum-product circuit, when given oracles for low-degree extensions for the circuit's wiring predicates. One can view this step as casting the barebones protocol of [GKR15, Section 3] in the framework of sum-product circuits.</li>

      <li>Step 2 (Section 11.4). We reduce small-space Turing machine computations to sum-product circuit evaluations.</li>

      <li>Step 3 (Section 11.5). We combine the previous two steps to prove the theorem, using the fact that small-space Turing machines can evaluate low-degree extensions of the wiring predicates for sufficiently uniform boolean circuits.</li>

    </ul>

    <p class="text-gray-300">Before discussing each of the above steps, we discuss consequences for Turing machine computations.</p>

    <p class="text-gray-300">As in [GKR15], we can derive from the above theorem a useful corollary for Turing machine computations, using their reduction from Turing machines to boolean circuits.</p>

    <p class="text-gray-300">Corollary 11.2 (PZK IPCP for Turing machines). Let  <span class="math">\\mathcal{L}</span>  be a language decidable by a (deterministic) Turing machine in space  <span class="math">s(n) = \\Omega (\\log n)</span> , and let  <span class="math">b(n)</span>  be a query bound function. Then  <span class="math">\\mathcal{L}</span>  has a (public-coin and non-adaptive)</p>

    <p class="text-gray-300">Interactive PCP that is perfect zero knowledge against all  <span class="math">b</span> -query malicious verifiers. In more detail:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} \\in \\mathbf {P Z K - I P C P} \\left[ \\begin{array}{c c} \\text {s o u n d n e s s e r r o r :} &amp;amp; 1 / 2 \\\\ \\text {r o u n d c o m p l e x i t y :} &amp;amp; \\operatorname {p o l y} (s (n)) \\cdot \\log b (n) \\\\ \\text {p r o o f l e n g t h :} &amp;amp; \\operatorname {p o l y} (2 ^ {s (n)}, b (n)) \\\\ \\text {q u e r y c o m p l e x i t y :} &amp;amp; \\operatorname {p o l y} (s (n), b (n)) \\\\ \\text {p r o v e r t i m e :} &amp;amp; \\operatorname {p o l y} (2 ^ {s (n)}, b (n)) \\\\ \\text {v e r i f i e r t i m e :} &amp;amp; n \\cdot \\operatorname {p o l y} (s (n), \\log b (n)) \\\\ \\text {v e r i f i e r s p a c e :} &amp;amp; O (s (n) + \\log b (n) / \\log s (n)) \\end{array} \\right].</span></div>

    <p class="text-gray-300">Proof. By [GKR15, Lemma 4.1], a language  <span class="math">\\mathcal{L}</span>  decidable by a Turing machine in time  <span class="math">t(n)</span>  and space  <span class="math">s(n)</span>  is also decidable by a  <span class="math">O(s(n))</span> -space uniform circuit family of size  <span class="math">\\mathrm{poly}(t(n)2^{s(n)}) = \\mathrm{poly}(2^{s(n)})</span>  and depth  <span class="math">\\mathrm{poly}(s(n))</span> . Applying Theorem 11.1 to this circuit family yields the corollary.</p>

    <p class="text-gray-300">In each of the results above, one can set the query bound  <span class="math">b(n)</span>  to be superpolynomial in  <span class="math">n</span>  (say,  <span class="math">b(n) \\coloneqq n^{O(\\log \\log n)}</span> ) to obtain Interactive PCPs that are perfect zero knowledge against all polynomial-time malicious verifiers, without affecting the efficiency of the honest verifier.</p>

    <p class="text-gray-300">We briefly recall some definitions and observations from [GKR15].</p>

    <p class="text-gray-300">Definition 11.3. A layered arithmetic circuit  <span class="math">C \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  of depth  <span class="math">D</span>  and size  <span class="math">S</span>  (with  <span class="math">n \\leq S</span> ) is an arithmetic circuit, with fan-in 2, arranged into  <span class="math">D + 1</span>  layers: the output layer (layer 0) has a single gate; layers  <span class="math">1, \\ldots, D - 1</span>  have  <span class="math">S</span>  gates each; and the input layer (layer  <span class="math">D</span> ) has  <span class="math">n</span>  gates. For  <span class="math">i \\in \\{0, \\ldots, D - 1\\}</span> , each gate in layer  <span class="math">i</span>  has two inputs, which are gates in layer  <span class="math">i + 1</span> ; the  <span class="math">n</span>  gates in layer  <span class="math">D</span>  are  <span class="math">C</span> 's inputs; the single gate in layer 0 is  <span class="math">C</span> 's output.</p>

    <p class="text-gray-300">For  <span class="math">i \\in \\{1, \\dots, D - 1\\}</span> , we denote by  <span class="math">V_i \\colon \\mathbb{F}^n \\times [S] \\to \\mathbb{F}</span>  the function such that  <span class="math">V_i(\\vec{x}, j) = v</span>  if and only if the  <span class="math">j</span> -th gate of the  <span class="math">i</span> -th layer has value  <span class="math">v</span>  when  <span class="math">C</span> 's input is  <span class="math">\\vec{x} \\in \\mathbb{F}^n</span> . Moreover, we denote by  <span class="math">V_D \\colon \\mathbb{F}^n \\times [n] \\to \\mathbb{F}</span>  the function  <span class="math">V_D(\\vec{x}, j) \\coloneqq x_j</span> , and by  <span class="math">V_D \\colon \\mathbb{F}^n \\to \\mathbb{F}</span>  the function  <span class="math">V_0(\\vec{x}) \\coloneqq C(x)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">H \\subseteq \\mathbb{F}</span>  and  <span class="math">m, m&#x27; \\in \\mathbb{N}</span>  be such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2<span class="math"> ,  </span>m \\geq \\lceil \\log S / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> , and  </span>m' \\geq \\lceil \\log n / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For  <span class="math">i \\in \\{1, \\dots, D - 1\\}</span> , we can equivalently view  <span class="math">V_i</span>  as a function from  <span class="math">\\mathbb{F}^n \\times H^m</span>  to  <span class="math">\\mathbb{F}</span> , by taking an arbitrary order  <span class="math">\\alpha</span>  on  <span class="math">H^m</span> , and letting  <span class="math">V_i(\\vec{x}, \\vec{z}) = 0</span>  for every  <span class="math">\\vec{z} \\in H^m</span>  with  <span class="math">\\alpha(z) &amp;gt; S</span> . The following equation then relates  <span class="math">V_{i-1}</span>  to  <span class="math">V_i</span> :</p>

    <div class="my-4 text-center"><span class="math-block">V _ {i - 1} (\\vec {x}, \\vec {z}) = \\sum_ {\\vec {\\omega} _ {1}, \\vec {\\omega} _ {2} \\in H ^ {m}} \\mathrm {a d d} _ {i} (\\vec {z}, \\vec {\\omega} _ {1}, \\vec {\\omega} _ {2}) \\cdot \\left(V _ {i} (\\vec {x}, \\vec {\\omega} _ {1}) + V _ {i} (\\vec {x}, \\vec {\\omega} _ {2})\\right) + \\mathrm {m u l} _ {i} (\\vec {z}, \\vec {\\omega} _ {1}, \\vec {\\omega} _ {2}) \\cdot \\left(V _ {i} (\\vec {x}, \\vec {\\omega} _ {1}) \\cdot V _ {i} (\\vec {x}, \\vec {\\omega} _ {2})\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathrm{add}_i\\colon H^{3m}\\to \\mathbb{F}</span>  (resp.,  <span class="math">\\mathrm{mul}_i\\colon H^{3m}\\to \\mathbb{F}</span> ) is the predicate such that, for every  <span class="math">(\\vec{a},\\vec{b},\\vec{c})\\in H^{3m}</span> ,  <span class="math">\\mathrm{add}_i(\\vec{a},\\vec{b},\\vec{c})</span>  (resp.,  <span class="math">\\mathrm{mul}_i(\\vec{a},\\vec{b},\\vec{c})</span> ) equals 1 if the  <span class="math">\\alpha (\\vec{a})</span> -th gate of layer  <span class="math">i - 1</span>  is an addition (resp., multiplication) gate whose inputs are gates  <span class="math">\\alpha (\\vec{b})\\leq \\alpha (\\vec{c})</span>  of layer  <span class="math">i</span> , or 0 otherwise. The situation for the input layer and output layer is somewhat different.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The input layer (layer  <span class="math">D</span> ) has  <span class="math">n</span>  gates (rather than  <span class="math">S</span> ), so we can equivalently view  <span class="math">V_{D}</span>  as a function from  <span class="math">\\mathbb{F}^n \\times H^{m&#x27;}</span>  to  <span class="math">\\mathbb{F}</span> , by taking an arbitrary order  <span class="math">\\alpha&#x27;</span>  on  <span class="math">H^{m&#x27;}</span> , and letting  <span class="math">V_{D}(\\vec{x}, \\vec{z}) = 0</span>  for every  <span class="math">\\vec{z} \\in H^{m&#x27;}</span>  with  <span class="math">\\alpha&#x27;(z) &amp;gt; n</span> . Naturally, we need to adjust the expression for  <span class="math">V_{D - 1}</span>  and the definitions of  <span class="math">\\mathrm{add}_D, \\mathrm{mul}_D</span>  appropriately.</li>

      <li>The output layer (layer 0) has a single gate (rather than  <span class="math">S</span> ), so and we can write</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">V _ {0} (\\vec {x}) = \\sum_ {\\vec {\\omega} _ {1}, \\vec {\\omega} _ {2} \\in H ^ {m}} \\mathrm {a d d} _ {1} (\\vec {0}, \\vec {\\omega} _ {1}, \\vec {\\omega} _ {2}) \\cdot \\left(V _ {1} (\\vec {x}, \\vec {\\omega} _ {1}) + V _ {1} (\\vec {x}, \\vec {\\omega} _ {2})\\right) + \\mathrm {m u l} _ {1} (\\vec {0}, \\vec {\\omega} _ {1}, \\vec {\\omega} _ {2}) \\cdot \\left(V _ {1} (\\vec {x}, \\vec {\\omega} _ {1}) \\cdot V _ {1} (\\vec {x}, \\vec {\\omega} _ {2})\\right).</span></div>

    <p class="text-gray-300">Remark 11.4. For  <span class="math">i \\in \\{1, \\dots, D\\}</span> , we view  <span class="math">V_i</span>  as a function not only of the gate number  <span class="math">j</span>  (represented as  <span class="math">\\vec{z} \\in H^m</span> ) but also of the circuit's input  <span class="math">\\vec{x}</span> , and we view  <span class="math">V_0</span>  as a function of the input only. In contrast, [GKR15] defines  <span class="math">V_0, \\dots, V_D</span>  with  <span class="math">\\vec{x}</span>  'hard-coded'. We require the additional flexibility ( <span class="math">\\vec{x}</span>  is an input) to compose sum-product circuits below.</p>

    <p class="text-gray-300">11.2 Sum-product subcircuits and oracle inputs</p>

    <p class="text-gray-300">Later on we will need to assemble different sum-product circuits into one such circuit, which requires relaxing the definition of an ari-graph to allow the root to have positive arity. This is stated formally below (difference highlighted).</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Definition 11.5 (extends Definition 8.7).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A tuple <span class="math">G=(V,E,\\rho,\\sigma)</span> is an ari-graph if <span class="math">(V,E)</span> is a directed acyclic multi-graph and both <span class="math">\\rho</span> and <span class="math">\\sigma</span> label every edge <span class="math">e</span> in <span class="math">E</span> with finite sets of positive integers <span class="math">\\rho_{e}</span> and <span class="math">\\sigma_{e}</span> that satisfy the following property. For every vertex <span class="math">v</span> in <span class="math">V</span>, there exists a (unique) non-negative integer <span class="math">\\mathsf{arity}(v)</span> such that, if <span class="math">e_{1},\\ldots,e_{t}</span> are <span class="math">v</span>’s outgoing edges: (1) if <span class="math">v</span> is the root then <span class="math">\\mathsf{arity}(v)=\\max(\\sigma_{e_{1}}\\cup\\ldots\\cup\\sigma_{e_{t}})</span>, otherwise $\\mathsf{arity}(v)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{e_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{e_{1}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\cdots=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rho_{e_{t}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{e_{t}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where </span>e_{1},\\ldots,e_{\\mathsf{in}_{G}(v)}<span class="math"> are </span>v<span class="math">’s incoming edges; (2) </span>\\rho_{e_{1}},\\ldots,\\rho_{e_{t}}\\subseteq\\{1,\\ldots,\\mathsf{arity}(v)\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For consistency, we retain the original definition of sum-product circuits, where the root must have arity zero, and so its value is a constant in <span class="math">\\mathbb{F}</span>. Instead, we now define sum-product subcircuits, where the root may have positive arity.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Definition 11.6.</h6>

    <p class="text-gray-300">A sum-product subcircuit <span class="math">\\mathcal{C}</span> is a tuple <span class="math">(\\mathbb{F},H,\\delta_{\\mathsf{in}},\\delta_{\\mathsf{ff}},G,C)</span> whose definition is identical to that of a sum-product circuit (see Definition 8.8), except that the root of <span class="math">G</span> may have positive arity. In particular, <span class="math">\\mathcal{C}[\\mathbf{x}]</span> may be a non-constant polynomial (having the same arity as the root of <span class="math">G</span>).</p>

    <p class="text-gray-300">It is not difficult to see that, provided the arities match, we can replace a leaf of a sum-product circuit <span class="math">\\mathcal{C}</span> with a sum-product subcircuit <span class="math">\\mathcal{C}_{0}</span> computing the same function (over the appropriate subdomain) without affecting <span class="math">\\mathcal{C}</span>’s output.</p>

    <p class="text-gray-300">Finally, in the discussions below, we also need a way to talk about oracles in the context of a sum-product (sub)circuit. The structure of the protocol is such that the calls to the oracle will be made at the leaves of <span class="math">\\mathcal{C}</span>, and so we associate the oracle with the circuit’s input.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Definition 11.7.</h6>

    <p class="text-gray-300">Given a sub-product (sub)circuit <span class="math">\\mathcal{C}</span> and a list of oracles <span class="math">O=\\{O_{i}\\}_{i\\in[\\ell]}</span> with <span class="math">O_{i}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}</span> for each <span class="math">i\\in[\\ell]</span>, we say that <span class="math">\\mathbf{x}^{O}</span> is an oracle input for <span class="math">\\mathcal{C}</span> if it labels the leaves of <span class="math">\\mathcal{C}</span> with oracle circuits: arithmetic circuits that may include oracle gates. An oracle gate is a gate labeled with the name of an oracle <span class="math">O_{i}</span>; it has <span class="math">k</span> inputs and a single output defined as the evaluation of <span class="math">O_{i}</span> on its inputs.</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">11.3 Sum-product subcircuits for layered arithmetic circuits</h3>

    <p class="text-gray-300">We show that the evaluation problem for a given layered arithmetic circuit can be reduced to a sum-product subcircuit, when given oracles for low-degree extensions of the wiring predicates. The reduction essentially consists of casting the <em>barebones protocol</em> of <em>[x13, Section 3]</em> as (the evaluation of) a sum-product subcircuit on an oracle input. The barebones protocol is an Interactive Proof that enables a verifier to check a statement of the form “<span class="math">C(\\vec{x})=y</span>”, where <span class="math">C</span> is a layered arithmetic circuit of size <span class="math">S</span> and depth <span class="math">D</span>, in time <span class="math">n\\cdot\\operatorname{poly}(D,\\log S)</span> and space <span class="math">O(\\log S)</span>, provided that the verifier has oracle access to low-degree extensions of the wiring predicates <span class="math">\\{\\operatorname{add}_{i},\\operatorname{mul}_{i}\\}_{i\\in\\{1,\\ldots,D\\}}</span> for the circuit <span class="math">C</span>. The arithmetization of <span class="math">C</span> underlying that protocol provides the basic intuition for how to ‘program’ a sum-product subcircuit to encode this computation.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 11.8 (sum-product subcircuits for layered arithmetic circuits).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field, <span class="math">C\\colon\\mathbb{F}^{n}\\to\\mathbb{F}</span> a layered arithmetic circuit of depth <span class="math">D</span> and size <span class="math">S</span>, <span class="math">H\\subseteq\\mathbb{F}</span>, <span class="math">m,m^{\\prime}\\in\\mathbb{N}</span> and <span class="math">F=(\\operatorname{add}_{i},\\operatorname{mul}_{i})_{i\\in\\{1,\\ldots,D\\}}</span> any degree-<span class="math">\\delta</span> extensions of the wiring predicates <span class="math">\\{\\operatorname{add}_{i},\\operatorname{mul}_{i}\\}_{i\\in\\{1,\\ldots,D\\}}</span>, with <span class="math">\\delta\\leq\\operatorname{polylog}(S)</span>. Then there exists a sum-product subcircuit <span class="math">\\mathcal{C}</span>, constructible in time <span class="math">n\\cdot\\operatorname{poly}(D,\\log S)</span> and space <span class="math">O(\\log S)</span>, and oracle input <span class="math">\\mathbf{x}^{F}</span> constructible in time <span class="math">\\operatorname{poly}(D,\\log S)</span> and space <span class="math">O(\\log S)</span>, such that <span class="math">\\mathcal{C}<a href="\\vec{x}">\\mathbf{x}^{F}</a>=C(\\vec{x})</span>, for all <span class="math">\\vec{x}\\in\\mathbb{F}^{n}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\mathsf{in}},\\delta_{\\mathsf{ff}},G,C)</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(D,\\log S)<span class="math">, </span>\\delta_{\\mathsf{in}}=\\Theta(1)<span class="math">, </span>\\delta_{\\mathsf{ff}}=\\operatorname{poly}(D,\\log S)<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(D)<span class="math">, </span>\\mathsf{arity}(G)=O(n+\\log S/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G)=\\Theta(1)<span class="math">, </span>\\mathsf{width}(G)=\\Theta(1)<span class="math">; and </span>\\mathsf{space}(\\mathbf{x})=O(\\log S)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H\\subseteq\\mathbb{F}</span> be such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\Omega(1)}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\operatorname{poly}(D,\\log S)<span class="math">; </span>m\\in\\mathbb{N}<span class="math"> be such that </span>S\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m}\\leq\\operatorname{poly}(S)<span class="math">; </span>m^{\\prime}\\in\\mathbb{N}<span class="math"> be such that </span>n\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m^{\\prime}}\\leq n\\cdot\\operatorname{poly}(D,\\log S)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Figure 4: Sum-product circuit and its input for layered circuit of depth 1.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 5: Sum-product circuit and its input for layered circuit of depth 2.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Figure 6: Sum-product circuit and its input for layered circuit of depth  <span class="math">D</span> .</p>

    <p class="text-gray-300">First, we use  <span class="math">D,m,m^{\\prime}</span>  to construct an ari-graph  <span class="math">G = (V,E,\\rho ,\\sigma)</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">V\\coloneqq \\{v_{i}\\}_{i\\in \\{0,\\dots ,D\\}}\\cup \\{u_{\\mathrm{add}_i},u_{\\mathrm{mul}_i}\\}_{i\\in \\{1,\\dots ,D\\}}</span></p>

    <p class="text-gray-300"><span class="math">E\\coloneqq \\{e_i,e_i&#x27; = (v_i,v_{i + 1})\\}_{i\\in \\{0,\\dots ,D - 1\\}}\\cup \\{(v_i,u_{f_{i + 1}}):f\\in \\{\\mathrm{add},\\mathrm{mul}\\} \\}_{i\\in \\{0,\\dots ,D - 1\\}}</span></p>

    <p class="text-gray-300"><span class="math">\\rho_{e}\\coloneqq \\left\\{ \\begin{array}{ll}\\emptyset &amp;amp; \\mathrm{if~}e = (v_{0},u_{f_{1}})\\mathrm{for~}f\\in \\{\\mathrm{add},\\mathrm{mul}\\} ,\\mathrm{or}\\\\ n + [m] &amp;amp; \\mathrm{if~}e = (v_{i},u_{f_{i + 1}})\\mathrm{for~}f\\in \\{\\mathrm{add},\\mathrm{mul}\\} \\mathrm{and} i\\in \\{1,\\ldots ,D - 1\\} ,\\\\ [n] &amp;amp; \\mathrm{otherwise}; \\end{array} \\right.</span></p>

    <p class="text-gray-300"><span class="math">\\sigma_{e}\\coloneqq \\left\\{ \\begin{array}{ll}[2m] &amp;amp; \\mathrm{if~}e = (v_{i},u_{f_{i + 1}})\\mathrm{for~}f\\in \\{\\mathrm{add},\\mathrm{mul}\\} \\mathrm{and} i\\in \\{0,\\ldots ,D - 2\\} ,\\\\ [m] &amp;amp; \\mathrm{if~}e = e_{i}\\mathrm{for~some} i\\in \\{0,\\ldots ,D - 2\\} ,\\\\ m + [m] &amp;amp; \\mathrm{if~}e = e_{i}^{\\prime}\\mathrm{for~some} i\\in \\{0,\\ldots ,D - 2\\} ,\\\\ [2m^{\\prime}] &amp;amp; \\mathrm{if~}e = (v_{D - 1},u_{f_{D}})\\mathrm{for~}f\\in \\{\\mathrm{add},\\mathrm{mul}\\} ,\\\\ [m^{\\prime}] &amp;amp; \\mathrm{if~}e = e_{D - 1},\\mathrm{or}\\\\ m^{\\prime} + [m^{\\prime}] &amp;amp; \\mathrm{if~}e = e_{D - 1}^{\\prime}. \\end{array} \\right.</span></p>

    <p class="text-gray-300">Note that  <span class="math">E</span>  is a multiset and contains, for every  <span class="math">i \\in \\{0, \\dots, D - 1\\}</span> , two distinct edges,  <span class="math">e_i</span>  and  <span class="math">e_i&#x27;</span> , from  <span class="math">v_i</span>  to  <span class="math">v_{i + 1}</span>  (with different projection labels). The root of  <span class="math">G</span>  is  <span class="math">v_0</span> , and its leaves are  <span class="math">v_D</span>  and  <span class="math">\\{u_{\\mathrm{add}_i}, u_{\\mathrm{mul}_i}\\}_{i \\in \\{1, \\dots, D\\}}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we construct the sum-product circuit  <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G, C)</span>  where  <span class="math">\\delta_{\\mathrm{in}} := 3</span> ,  $\\delta_{\\mathrm{ff}} := \\max(\\delta,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , and  </span>C<span class="math">  labels internal vertices of  </span>G<span class="math">  as follows. For every  </span>i \\in \\{0, \\dots, D-1\\}<span class="math"> ,  </span>C_{v_i} := X_1 \\cdot (Y_1 + Y_2) + X_2 \\cdot Y_1 \\cdot Y_2<span class="math"> , where  </span>Y_1, Y_2<span class="math">  correspond to  </span>e_i, e_i'<span class="math">  respectively, and  </span>X_1, X_2<span class="math">  correspond to  </span>(v_i, u_{\\mathrm{add}_i})<span class="math"> ,  </span>(v_i, u_{\\mathrm{mul}_i})$  respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, we construct the input  <span class="math">\\mathbf{x}</span>  for  <span class="math">\\mathcal{C}</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for all  <span class="math">f \\in  \\{ \\mathrm{add},\\mathrm{mul}\\} ,{\\mathbf{x}}_{u_{f_1}}</span>  is the oracle circuit that outputs  <span class="math">\\hat{f}_1(\\vec{0},\\vec{\\omega}_1,\\vec{\\omega}_2)</span>  on input  <span class="math">(\\vec{\\omega}_1,\\vec{\\omega}_2)</span></li>

      <li>for all  <span class="math">i \\in \\{2, \\dots, D\\}</span>  and  <span class="math">f \\in \\{\\mathrm{add}, \\mathrm{mul}\\}</span> ,  <span class="math">\\mathbf{x}_{u_{f_i}}</span>  is the oracle circuit that outputs  <span class="math">\\hat{f}_i(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2)</span>  on input  <span class="math">(\\vec{z}, \\vec{\\omega}_1, \\vec{\\omega}_2)</span> ;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  <span class="math">\\mathbf{x}_{v_D}</span>  is the polynomial  <span class="math">V_{D}(\\vec{x},\\vec{z})\\coloneqq \\sum_{\\vec{\\beta}\\in H^{m^{\\prime}}}I_{H^{m^{\\prime}}}(\\vec{z},\\vec{\\beta})x_{\\alpha^{\\prime}(\\vec{\\beta})}</span>  (with  <span class="math">x_{i}\\coloneqq 0</span>  for  <span class="math">i &amp;gt; n</span> ), which has individual degree less than  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , that is the low-degree extension of  </span>V_{D}<span class="math">  and can be computed in time  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m^{\\prime}}\\cdot \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,m^{\\prime})\\leq n\\cdot \\mathrm{poly}(D,\\log S)<span class="math">  and space  </span>O(m^{\\prime}\\cdot \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\leq \\log n + \\mathrm{polylog}(D,\\log S)\\leq O(\\log S)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See Figure 4, Figure 5, Figure 6 for diagrams of this sum-product circuit and input for depth 1, 2,  <span class="math">D</span>  respectively.</p>

    <p class="text-gray-300">We are left to argue correctness of the reduction: it is easy to see that  <span class="math">v_{D}<a href="\\vec{x},\\vec{z}">\\mathbf{x}^{F}</a> = V_{D}(\\vec{x},\\vec{z})</span>  for every  <span class="math">\\vec{x}\\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{z}\\in H^{m&#x27;}</span> ; hence, for every  <span class="math">i\\in \\{1,\\dots ,D - 1\\}</span> ,  <span class="math">v_{i}\\mathbf{x}^{F} = V_{i}(\\vec{x},\\vec{z})</span>  for every  <span class="math">\\vec{x}\\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{z}\\in H^{m}</span> . We conclude that  <span class="math">\\mathcal{C}[\\mathbf{x}^F] = v_0[\\mathbf{x}^F] = V_0</span>  (as functions in  <span class="math">\\vec{x}</span> ), as claimed.</p>

    <p class="text-gray-300">We show that small-space Turing machine computations can be reduced to the evaluation of sum-product subcircuits whose size is polynomially related to the space bound. This theorem is the analogue of [GKR15, Theorem 4.4] for our</p>

    <p class="text-gray-300">framework: we use Lemma 11.8 and then instantiate the oracle input with explicit arithmetic circuits.</p>

    <p class="text-gray-300">To prove Theorem 11.1 we need to construct a sum-product subcircuit whose value is a function <span class="math">f\\colon\\mathbb{F}^{n}\\to\\mathbb{F}</span> computable by a Turing machine in small space. However, if we simply apply Lemma 11.8 to a circuit given by <em>[x11, Lemma 4.3]</em>, then we only obtain sum-product subcircuits for <em>boolean</em> functions computable in small space. We therefore apply <em>[x11, Lemma 4.3]</em> to the language <span class="math">\\mathscr{L}_{f}:=\\{(\\vec{x},a):f(\\vec{x})=a\\}</span>, which by Lemma 11.8 yields a subcircuit whose value is a function <span class="math">f^{\\prime}\\colon\\mathbb{F}^{n}\\times\\mathbb{F}\\to\\{0,1\\}</span>, the indicator function of <span class="math">\\mathscr{L}_{f}</span>. Then it holds that <span class="math">\\sum_{a\\in\\mathbb{F}}a\\cdot f^{\\prime}(x,a)=f(x)</span>, and this summation can be implemented by adding an extra vertex to the subcircuit.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 11.9 (sum-product subcircuits for small-space Turing machines).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">s\\colon\\mathbb{N}\\to\\mathbb{N}</span> be a space function with <span class="math">s(n)=\\Omega(\\log n)</span>, <span class="math">H</span> an extension field of <span class="math">\\mathbb{F}_{2}</span>, and <span class="math">\\mathbb{F}</span> an extension field of <span class="math">H</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(s(n))<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Let </span>f\\colon\\mathbb{F}^{n}\\to\\mathbb{F}<span class="math"> be a function computable by a non-deterministic Turing machine </span>M<span class="math"> in space </span>s(n)<span class="math"> in the following sense: </span>M<span class="math"> accepts </span>(\\vec{x},a)\\in\\mathbb{F}^{n}\\times\\mathbb{F}<span class="math"> if and only if </span>f(\\vec{x})=a<span class="math">. Then there exist a sum-product subcircuit </span>\\mathcal{C}<span class="math"> and input </span>\\mathbf{x}<span class="math"> for </span>\\mathcal{C}<span class="math"> such that </span>\\mathcal{C}<a href="\\vec{x}">\\mathbf{x}</a>=f(\\vec{x})<span class="math"> for all </span>x\\in\\mathbb{F}^{n}<span class="math">; </span>\\mathcal{C}<span class="math"> is constructible in time </span>n\\cdot\\operatorname{poly}(s(n))<span class="math"> and space </span>O(s(n))<span class="math">, and </span>\\mathbf{x}<span class="math"> is constructible in time </span>n\\cdot\\operatorname{poly}(s(n))<span class="math"> and space </span>O(s(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\text{in}},\\delta_{\\text{lf}},G,C)</span> where <span class="math">\\delta_{\\text{in}}=\\Theta(1)</span>, <span class="math">\\delta_{\\text{lf}}=\\operatorname{poly}(s(n))</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(s^{2}(n))<span class="math">, </span>\\mathsf{arity}(G)=O(n+s(n)/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G)=\\Theta(1)<span class="math">, </span>\\mathsf{width}(G)=\\Theta(1)<span class="math">; and </span>\\mathsf{space}(\\mathbf{x})=O(s(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-75" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix an input length <span class="math">n</span>, and let $k:=\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (</span>k<span class="math"> is an integer because </span>\\mathbb{F}<span class="math"> is an extension field of </span>H<span class="math">). Let </span>\\gamma\\colon H^{k}\\to\\mathbb{F}<span class="math"> be the trivial isomorphism, and let </span>\\mathscr{L}:=\\{(\\vec{x},\\vec{z}):f(\\vec{x})=\\gamma(\\vec{z})\\}<span class="math">. Note that </span>\\mathscr{L}<span class="math"> is computable by a non-deterministic Turing machine in space </span>O(s(n))<span class="math"> because (i) </span>f<span class="math"> is and (ii) </span>\\gamma(\\vec{z})<span class="math"> can be implemented at the bit level as the identity function. By <em>[x11, Lemma 4.3]</em>, </span>\\mathscr{L}<span class="math"> can be computed by a layered arithmetic circuit </span>C<span class="math"> over </span>\\mathbb{F}<span class="math"> of size </span>S(n)=\\operatorname{poly}(2^{s(n)})<span class="math"> and depth </span>D(n)=O(s^{2}(n))<span class="math">; moreover, one can generate arithmetic circuits for and evaluate some low-degree extensions </span>\\mathrm{add}_{i},\\mathrm{mul}_{i}<span class="math"> of the wiring predicates in time </span>\\operatorname{poly}(s(n))<span class="math"> and space </span>O(\\log s(n))<span class="math">. The degree of these extensions is </span>\\operatorname{poly}(s(n))=\\operatorname{polylog}(S(n))<span class="math">, independent of </span>\\mathbb{F}$ (which is crucial for soundness).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that <span class="math">H</span> is of size <span class="math">\\operatorname{poly}(s(n))=\\operatorname{poly}(D(n),\\log S(n))</span>. By Lemma 11.8, we can construct a sum-product subcircuit <span class="math">\\mathcal{C}^{\\prime}=(\\mathbb{F},H,\\delta_{\\text{in}},\\delta_{\\text{lf}},G,C)</span> and oracle input <span class="math">\\mathbf{x}^{F}</span> such that <span class="math">\\mathcal{C}^{\\prime}<a href="\\vec{x},\\vec{z}">\\mathbf{x}^{F}</a>=C(\\vec{x},\\vec{z})</span> for every <span class="math">\\vec{x}\\in\\mathbb{F}^{n}</span> and <span class="math">\\vec{z}\\in H^{k}</span>. We replace the oracle gates in <span class="math">\\mathbf{x}^{F}</span> with the explicit circuits for <span class="math">\\mathrm{add}_{i},\\mathrm{mul}_{i}</span> to obtain a non-oracle input <span class="math">\\mathbf{x}^{\\prime}</span>.</p>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">f(\\vec{x})=\\sum_{\\vec{z}\\in H^{k}}C(\\vec{x},\\vec{z})\\cdot\\gamma(\\vec{z})=\\sum_{\\vec{z}\\in H^{k}}\\mathcal{C}^{\\prime}<a href="\\vec{x},\\vec{z}">\\mathbf{x}</a>\\cdot\\hat{\\gamma}(\\vec{z})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\hat{\\gamma}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}</span> is the unique <span class="math">\\mathbb{F}</span>-linear function such that <span class="math">\\hat{\\gamma}(\\vec{z})=\\gamma(\\vec{z})</span> for <span class="math">\\vec{z}\\in H^{k}</span>. Note that <span class="math">\\hat{\\gamma}</span> is computable by an arithmetic circuit of size <span class="math">O(k)</span>, and can be evaluated in space $O(k+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The sum-product subcircuit <span class="math">\\mathcal{C}</span> is obtained from <span class="math">\\mathcal{C}^{\\prime}</span> by adding a vertex <span class="math">v</span> to <span class="math">G</span> labeled with <span class="math">X\\cdot Y</span> and a leaf vertex <span class="math">u_{\\gamma}</span>, and two edges <span class="math">e:=(v,r_{G})</span> and <span class="math">e^{\\prime}:=(v,u_{\\gamma})</span> with labels <span class="math">(\\rho_{e},\\sigma_{e}):=([n],[k])</span> and <span class="math">(\\rho_{e^{\\prime}},\\sigma_{e^{\\prime}}):=(\\varnothing,[k])</span>. The input <span class="math">\\mathbf{x}</span> is obtained from <span class="math">\\mathbf{x}^{\\prime}</span> by mapping <span class="math">u_{\\gamma}</span> to the arithmetic circuit computing <span class="math">\\hat{\\gamma}</span>. ∎</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">11.5 Proof of Theorem 11.1</h3>

    <p class="text-gray-300">Let <span class="math">\\mathscr{L}</span> be a language decidable by a family of <span class="math">O(\\log S(n))</span>-space uniform boolean circuits of size <span class="math">S(n)</span> and depth <span class="math">D(n)</span>, and let <span class="math">b(n)</span> be a query bound function. The prover and verifier receive an input <span class="math">\\vec{x}\\in\\{0,1\\}^{n}</span>. Let <span class="math">C</span> be the boolean circuit (i.e., arithmetic circuit over <span class="math">\\mathbb{F}_{2}</span>) for this input size; we assume that <span class="math">C</span> is layered with fan-in <span class="math">2</span>, as in Definition 11.3. (Any circuit can be efficiently converted into this form, with only a quadratic increase in size and a <span class="math">\\log S(n)</span>-factor increase in depth, which does not affect the theorem’s statement.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H</span> be an extension field of <span class="math">\\mathbb{F}_{2}</span> and <span class="math">\\mathbb{F}</span> an extension field of <span class="math">H</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\operatorname{poly}(D(n),\\log S(n))<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\Omega(1)}<span class="math">. Define </span>m:=\\lceil\\log S(n)/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math"> and </span>m^{\\prime}:=\\lceil\\log n/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\rceil<span class="math">. Throughout we fix </span>\\delta_{\\text{in}}=\\Theta(1)<span class="math"> and </span>\\delta_{\\text{lf}}=\\operatorname{poly}(D(n),\\log S(n))$, as these settings suffice for all the (sub)circuits that we construct.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Part A: efficiently computable sum-product subcircuits for low-degree extensions of the wiring predicates. By <em>[x11, Claim 4.6]</em>, for every <span class="math">i\\in\\{1,\\ldots,D(n)\\}</span>, the low-degree extensions <span class="math">\\mathrm{add}_{i},\\mathrm{mul}_{i}\\colon\\mathbb{F}^{m}\\to\\mathbb{F}</span> of <span class="math">C</span>’s wiring predicates can be computed by a Turing machine in space <span class="math">O(\\log S(n))</span>. The machine takes as input <span class="math">1^{n}</span>, <span class="math">H</span>, <span class="math">\\mathbb{F}</span>, <span class="math">m</span>, <span class="math">m^{\\prime}</span>, <span class="math">i</span>, <span class="math">f\\in\\{\\mathrm{add},\\mathrm{mul}\\}</span>, and <span class="math">(\\vec{a},\\vec{b},\\vec{c})\\in\\mathbb{F}^{3m}</span>, and outputs <span class="math">\\hat{f}_{i}(\\vec{a},\\vec{b},\\vec{c})</span>. Here we consider all inputs besides <span class="math">(\\vec{a},\\vec{b},\\vec{c})</span> as hard-coded in the machine. By Lemma 11.9, there exist sum-product subcircuits <span class="math">\\mathcal{C}_{f_{i}}=(\\mathbb{F},H,\\delta_{\\text{in}},\\delta_{\\text{lf}},G_{f_{i}},C_{f_{i}})</span> and inputs <span class="math">\\mathbf{x}_{f_{i}}</span> (for every <span class="math">f\\in\\mathrm{add},\\mathrm{mul}</span> and <span class="math">i\\in\\{1,\\ldots,D\\}</span>) such that <span class="math">\\mathcal{C}_{f_{i}}<a href="\\vec{a},\\vec{b},\\vec{c}">\\mathbf{x}_{f_{i}}</a>=\\hat{f}_{i}(\\vec{a},\\vec{b},\\vec{c})</span> for all <span class="math">(\\vec{a},\\vec{b},\\vec{c})\\in\\mathbb{F}^{3m}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every <span class="math">f \\in \\mathrm{add}, \\mathrm{mul}</span> and <span class="math">i \\in \\{1, \\dots, D\\}</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G_{f_i})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(\\log S(n))<span class="math">, </span>\\mathsf{arity}(G_{f_i}) = O(\\log S(n) / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G_{f_i}) = \\Theta(1)<span class="math">, </span>\\mathsf{width}(G_{f_i}) = \\Theta(1)<span class="math">, and </span>\\mathsf{space}(\\mathbf{x}_{f_i}) = O(\\log S(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Part B: sum-product circuit with oracle input for <span class="math">C(\\vec{x})</span>.</strong> We now invoke Lemma 11.8 on <span class="math">C</span> to obtain a sum-product subcircuit <span class="math">\\mathcal{C}&#x27; = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G&#x27;, C&#x27;)</span> and oracle input <span class="math">\\mathbf{x}^F</span>. For the theorem, we need to transform this into a sum-product circuit (i.e., where the root has arity 0). To do this, we will modify the projections so that the input <span class="math">\\vec{x}</span> is no longer 'carried down', and then 'hard-code' it into <span class="math">\\mathbf{x}^F</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\rho&#x27;</span> be given by defining, for every <span class="math">e \\in E&#x27;</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\rho_ {e} ^ {\\prime} := \\left\\{ \\begin{array}{l l} \\{1, \\ldots , m \\} &amp;amp; \\text {if } e = (v _ {i}, u _ {f _ {i + 1}}) \\text { for } f \\in \\{\\mathrm {a d d}, \\mathrm {m u l} \\} \\text { and } i \\in \\{1, \\ldots , D - 1 \\} \\text { or} \\\\ \\varnothing &amp;amp; \\text {otherwise.} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Observe that in <span class="math">G&#x27;&#x27; \\coloneqq (V(G&#x27;), E(G&#x27;), \\rho&#x27;, \\sigma(G&#x27;))</span>, the root <span class="math">v_0</span> has <span class="math">\\mathsf{arity}(v_0) = 0</span>, and so <span class="math">G&#x27;&#x27;</span> is an ari-graph. Let the input <span class="math">\\mathbf{x}&#x27;^F</span> be identical to <span class="math">\\mathbf{x}^F</span> except that <span class="math">\\mathbf{x}_{v_D}&#x27;^F(\\vec{Z}) \\coloneqq \\mathbf{x}_{v_D}^F(\\vec{x}, \\vec{Z})</span>; that is, we 'hard-code' the input <span class="math">\\vec{x}</span> to the circuit <span class="math">C</span> into the input <span class="math">\\mathbf{x}&#x27;^F</span> of the sum-product circuit (as in the original GKR protocol). This can only reduce the degree of <span class="math">\\mathbf{x}_{v_D}&#x27;^F</span>. Now let <span class="math">\\mathcal{C}&#x27;&#x27; \\coloneqq (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G&#x27;&#x27;, C&#x27;)</span>; it holds that <span class="math">\\mathcal{C}&#x27;&#x27;</span> is a sum-product circuit and <span class="math">\\mathcal{C}&#x27;&#x27;[\\mathbf{x}&#x27;^F] = \\mathcal{C}&#x27;<a href="\\vec{x}">\\mathbf{x}^F</a></span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We obtain the following parameters: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G'')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta(D(n))<span class="math">, </span>\\mathsf{arity}(G'') = O(\\log S(n) / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G'') = \\Theta(1)<span class="math">, </span>\\mathsf{width}(G'') = \\Theta(1)<span class="math">; and </span>\\mathsf{space}(\\mathbf{x}'^F) = O(\\log S(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Part C: composing sum-product subcircuits.</strong> The final sum-product circuit <span class="math">\\mathcal{C} = (\\mathbb{F}, H, \\delta_{\\mathrm{in}}, \\delta_{\\mathrm{ff}}, G, C)</span> is constructed as follows. The ari-graph <span class="math">G</span> is obtained from <span class="math">G&#x27;&#x27;</span> by replacing each leaf node <span class="math">u_{f_i}</span> with the ari-graph <span class="math">G_{f_i}</span>, every <span class="math">f \\in \\mathrm{add}, \\mathrm{mul}</span> and <span class="math">i \\in \\{1, \\dots, D\\}</span>. The vertex label <span class="math">C</span> is the union of the vertex labels <span class="math">C&#x27;</span> and <span class="math">\\{C_{f_i}\\}_{f \\in \\{\\mathrm{add}, \\mathrm{mul}\\}, i \\in \\{1, \\dots, D\\}}</span>.</p>

    <p class="text-gray-300">The input <span class="math">\\mathbf{x}</span> for <span class="math">\\mathcal{C}</span> is equals the union of <span class="math">\\{\\mathbf{x}_{f_i}\\}_{f\\in \\{\\mathrm{add},\\mathrm{mul}\\},i\\in \\{1,\\dots,D\\}}</span> and the mapping <span class="math">\\mathbf{x}_{v_D} := \\mathbf{x}_{v_D}&#x27;^F</span> (for <span class="math">v_{D} \\in G&#x27;&#x27;</span>).</p>

    <p class="text-gray-300">Given the above definitions, one can verify that <span class="math">\\mathcal{C}[\\mathbf{x}] = C(\\vec{x})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, by inspection: $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= D(n) \\cdot \\mathrm{poly}(\\log S(n))<span class="math">, </span>\\mathsf{arity}(G) = O(\\log S(n) / \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G) = \\Theta(1)<span class="math">, </span>\\mathsf{width}(G) = \\mathrm{poly}(\\log S(n))<span class="math">, and </span>\\mathsf{space}(\\mathbf{x}) = O(\\log S(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Part D: invoke PZK IPCP for sum-product circuit evaluation.</strong> All oracles have now been instantiated, we can now rely on our construction of perfect zero knowledge Interactive PCPs for sum-product circuit evaluation problems. More precisely, the prover and verifier construct the sum-product circuit <span class="math">\\mathcal{C}</span> and its input <span class="math">\\mathbf{x}</span> as above, in time <span class="math">n \\cdot \\mathrm{poly}(D(n), \\log S(n))</span> and space <span class="math">O(\\log S(n))</span>. (While this amount of space is not enough to store the whole circuit at once, the verifier can construct each part as needed.) The prover and verifier then engage in the protocol of Theorem 9.1 on the input <span class="math">(\\mathcal{C}, 1, \\mathbf{x})</span>. Correctness comes from the fact that <span class="math">(\\mathcal{C}, 1, \\mathbf{x}) \\in \\mathcal{L}_{\\mathrm{SPCE}}</span> if and only if <span class="math">C(\\vec{x}) = 1</span>.</p>

    <p class="text-gray-300">Plugging the parameters above into Theorem 9.1 yields the parameters claimed by Theorem 11.1, with the exception of the verifier space bound. A direct computation only shows that the verifier runs in space <span class="math">\\mathrm{poly}(\\log S(n))</span>, because <span class="math">\\mathrm{width}(G) = \\mathrm{poly}(\\log S(n))</span>. Yet, since <span class="math">\\mathcal{C}</span> is 'treelike' in the sense that the subcircuits can be handled independently, the evaluation protocol need only consider a constant number of vertices at any one time, at the expense of a <span class="math">\\mathrm{poly}(\\log S(n))</span>-factor increase in the round complexity. Doing so yields the claimed <span class="math">O(\\log S(n))</span> space complexity of the verifier.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">The authors would like to thank Eli Ben-Sasson for numerous enlightening conversations in early stages of this work. The authors also thank Thomas Vidick for suggesting that we use our techniques to obtain a zero knowledge analogue of <em>[x1, x2]</em>, as captured by Theorem 7.2. The authors thank Tom Gur for comments on the writeup.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A Algebraic query complexity of polynomial summation: details</p>

    <p class="text-gray-300">In this section we prove the results whose statements appear in Section 5.</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">A.1 Proof of Theorem 5.1</h3>

    <p class="text-gray-300">First, since <span class="math">Z</span> has individual degree at most <span class="math">d</span> in <span class="math">\\vec{X}</span>, we can rewrite any such linear combination in the following way:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\alpha}\\in L^{m}}C_{\\vec{\\alpha},i}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})=\\sum_{\\vec{\\alpha}\\in L^{m}}C_{\\vec{\\alpha},i}\\sum_{\\vec{\\beta}\\in K^{m}}b_{\\vec{\\beta},\\vec{\\alpha}}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})=\\sum_{\\vec{\\alpha}\\in K^{m}}C^{\\prime}_{\\vec{\\alpha},i}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})=\\sum_{\\vec{q}\\in S}D_{\\vec{q},i}Z(\\vec{q})\\enspace,</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">C^{\\prime}:=BC</span>. If $d^{\\prime}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2<span class="math"> then the bound is trivial. Otherwise, let </span>H<span class="math"> be some arbitrary subset of </span>G<span class="math"> of size </span>\\min\\{d^{\\prime}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">. Let </span>P_{0}\\subseteq\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}]<span class="math"> be such that for all </span>p\\in P_{0}<span class="math"> and for all </span>\\vec{q}\\in S<span class="math">, </span>p(\\vec{q})=0<span class="math">. Since this is at most </span>S<span class="math"> linear constraints, </span>P_{0}<span class="math"> has dimension at least </span>(d+1)^{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>B_{0}\\in\\mathbb{F}^{n\\times(d+1)^{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}}<span class="math"> be a matrix whose rows form a basis for the vector space </span>\\{\\big{(}p(\\vec{\\alpha},\\vec{\\beta})\\big{)}_{\\vec{\\alpha}\\in K^{m},\\vec{\\beta}\\in H^{k}}:p\\in P_{0}\\}<span class="math"> of evaluations of polynomials in </span>P_{0}<span class="math"> on </span>K^{m}\\times H^{k}<span class="math">; we have </span>n\\geq(d+1)^{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. By an averaging argument there exists </span>\\vec{\\beta}_{0}\\in H^{k}<span class="math"> such that the submatrix </span>B_{\\vec{\\beta}_{0}}<span class="math"> consisting of columns </span>(\\vec{\\alpha},\\vec{\\beta}_{0})<span class="math"> of </span>B_{0}<span class="math"> for each </span>\\vec{\\alpha}\\in K^{m}<span class="math"> has rank at least </span>(d+1)^{m}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $q\\in\\mathbb{F}[Y_{1,\\ldots,k}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}]<span class="math"> be the polynomial such that </span>q(\\vec{\\beta}_{0})=1<span class="math">, and </span>q(\\vec{y})=0<span class="math"> for all </span>\\vec{y}\\in G^{k}-\\{\\vec{\\beta}_{0}\\}<span class="math">. For arbitrary </span>p\\in P_{0}<span class="math">, let </span>Z(\\vec{X},\\vec{Y}):=q(\\vec{Y})p(\\vec{X},\\vec{Y})\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}]<span class="math">. Observe that our choice of </span>H<span class="math"> ensures that the degree of </span>Z<span class="math"> in </span>\\vec{Y}<span class="math"> is at most </span>d^{\\prime}<span class="math">. Then for all </span>i\\in\\{1,\\ldots,\\ell\\}$, it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{\\vec{\\alpha}\\in K^{m}}C^{\\prime}_{\\vec{\\alpha},i}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})=\\sum_{\\vec{\\alpha}\\in K^{m}}C^{\\prime}_{\\vec{\\alpha},i}\\cdot p(\\vec{\\alpha},\\vec{\\beta}_{0})=\\sum_{\\vec{q}\\in S}D_{\\vec{q},i}\\cdot Z(\\vec{\\alpha},\\vec{y})=0\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus the column space of <span class="math">C^{\\prime}</span> is contained in the null space of <span class="math">B_{\\vec{\\beta}_{0}}</span>, and so the null space of <span class="math">B_{\\vec{\\beta}_{0}}</span> has rank at least <span class="math">\\operatorname{rank}(C^{\\prime})</span>. Hence $(d+1)^{m}-\\operatorname{rank}(C^{\\prime})\\geq\\operatorname{rank}(B_{\\vec{\\beta}_{0}})\\geq(d+1)^{m}-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}<span class="math">, so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\operatorname{rank}(C^{\\prime})\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}$, which yields the theorem. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">A.2 Proof of Corollary 5.3</h3>

    <p class="text-gray-300">We will need a simple fact from linear algebra: that ‘linear independence equals statistical independence’. That is, if we sample an element from a vector space and examine some subsets of its entries, these distributions are independent if and only if there does not exist a linear dependence between the induced subspaces. The formal statement of the claim is as follows; its proof is deferred to the end of this subsection.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Claim A.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">D</span> a finite set. Let <span class="math">V\\subseteq\\mathbb{F}^{D}</span> be an <span class="math">\\mathbb{F}</span>-vector space, and let <span class="math">\\vec{v}</span> be a random variable which is uniform over <span class="math">V</span>. For any subdomains <span class="math">S,S^{\\prime}\\subseteq D</span>, the restrictions $\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S}<span class="math"> and </span>\\vec{v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S^{\\prime}}<span class="math"> are statistically dependent if and only if there exist constants </span>(c_{i})_{i\\in S}<span class="math"> and </span>(d_{i})_{i\\in S^{\\prime}}$ such that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exists <span class="math">\\vec{w}\\in V</span> such that <span class="math">\\sum_{i\\in S}c_{i}w_{i}\\neq 0</span>, and</li>

      <li>for all <span class="math">\\vec{w}\\in V</span>, <span class="math">\\sum_{i\\in S}c_{i}w_{i}=\\sum_{i\\in S^{\\prime}}d_{i}w_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">Now observe that</p>

    <p class="text-gray-300"><span class="math">\\Big{\\{}\\Big{(}\\big{(}Z(\\vec{\\gamma})\\big{)}_{\\vec{\\gamma}\\in\\mathbb{F}^{m+k}},\\big{(}\\sum_{\\vec{y}\\in G^{k}}Z(\\vec{\\alpha},\\vec{y})\\big{)}_{\\vec{\\alpha}\\in\\mathbb{F}^{m}}\\Big{)}:Z\\in\\mathbb{F}[X_{1,\\ldots,m}^{\\leq d},Y_{1,\\ldots,k}^{\\leq d^{\\prime}}]\\Big{\\}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is an <span class="math">\\mathbb{F}</span>-vector space with domain <span class="math">\\mathbb{F}^{m+k}\\cup\\mathbb{F}^{m}</span>. Consider subdomains <span class="math">\\mathbb{F}^{m}</span> and <span class="math">S</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{k}<span class="math">, by Theorem 5.1 there exist no constants </span>(c_{\\vec{\\alpha}})_{\\alpha\\in\\mathbb{F}^{m}}<span class="math">, </span>(d_{\\vec{\\gamma}})_{\\vec{\\gamma}\\in S}$ such that the conditions of the claim hold. This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Proof of Claim A.1. For arbitrary  <span class="math">\\vec{x} \\in \\mathbb{F}^S</span> ,  <span class="math">\\vec{x}&#x27; \\in \\mathbb{F}^{S&#x27;}</span> , we define the quantity</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p _ {\\vec {x}, \\vec {x} ^ {\\prime}} := \\operatorname * {P r} _ {\\vec {v} \\in V} [ \\vec {v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {S} = \\vec {x} \\wedge \\vec {v}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {S ^ {\\prime}} = \\vec {x} ^ {\\prime} ].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">d \\coloneqq \\dim(V)</span> , and let  <span class="math">B \\in \\mathbb{F}^{D \\times d}</span>  be a basis for  <span class="math">V</span> . Let  <span class="math">B_S \\in \\mathbb{F}^{S \\times d}</span>  be  <span class="math">B</span>  restricted to rows corresponding to elements of  <span class="math">S</span> , and let  <span class="math">B_{S&#x27;}</span>  be defined likewise. Finally, let  $B_{S,S'} \\in \\mathbb{F}^{(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\times d}<span class="math">  be the matrix whose rows are the rows of  </span>B_S<span class="math"> , followed by the rows of  </span>B_{S'}$ . Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">p _ {\\vec {x}, \\vec {x} ^ {\\prime}} = \\operatorname * {P r} _ {\\vec {z} \\in \\mathbb {F} ^ {d}} \\left[ B _ {S, S ^ {\\prime}} \\cdot \\vec {z} = (\\vec {x}, \\vec {x} ^ {\\prime}) \\right].</span></div>

    <p class="text-gray-300">One can verify that, for any matrix  <span class="math">A \\in \\mathbb{F}^{m \\times n}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} _ {\\vec {z} \\in \\mathbb {F} ^ {n}} [ A \\vec {z} = \\vec {b} ] = \\left\\{ \\begin{array}{l l} \\mathbb {F} ^ {- \\operatorname {r a n k} (A)} &amp;amp; \\text {i f} \\vec {b} \\in \\operatorname {c o l s p} (A), \\text {a n d} \\\\ 0 &amp;amp; \\text {o t h e r w i s e .} \\end{array} \\right.</span></div>

    <p class="text-gray-300">The column space  <span class="math">\\mathrm{colsp}(B_{S,S&#x27;}) \\subseteq \\mathrm{colsp}(B_S) \\times \\mathrm{colsp}(B_{S&#x27;})</span> , and equality holds if and only if  <span class="math">\\mathrm{rank}(B_{S,S&#x27;}) = \\mathrm{rank}(B_S) + \\mathrm{rank}(B_{S&#x27;})</span> . It follows that  <span class="math">p_{\\vec{x},\\vec{x}&#x27;} = \\operatorname<em>{Pr}_{\\vec{v} \\in V}[\\vec{v}]_S = \\vec{x}] \\cdot \\operatorname</em>{Pr}_{\\vec{v} \\in V}[\\vec{v}]_{S&#x27;} = \\vec{x}&#x27;</span>  if and only if  <span class="math">\\mathrm{rank}(B_{S,S&#x27;}) = \\mathrm{rank}(B_S) + \\mathrm{rank}(B_{S&#x27;})</span> . By the rank-nullity theorem and the construction of  <span class="math">B_{S,S&#x27;}</span> , this latter condition holds if and only if  <span class="math">\\mathrm{nul}(B_{S,S&#x27;}^T) \\subseteq \\mathrm{nul}(B_S^T) \\times \\mathrm{nul}(B_{S&#x27;}^T)</span> . To conclude the proof, it remains only to observe that the condition in the claim is equivalent to the existence of vectors  <span class="math">\\vec{c} \\in \\mathbb{F}^S</span> ,  <span class="math">\\vec{d} \\in \\mathbb{F}^{S&#x27;}</span>  such that  <span class="math">\\vec{c} \\notin \\mathrm{nul}(B_S^T)</span>  but  <span class="math">(\\vec{c}, -\\vec{d}) \\in \\mathrm{nul}(B_{S,S&#x27;}^T)</span> .</p>

    <h2 id="sec-80" class="text-2xl font-bold">A.3 Upper bounds</h2>

    <p class="text-gray-300">In this section we show that in certain cases the degree constraints in Theorem 5.1 are tight.</p>

    <h3 id="sec-81" class="text-xl font-semibold mt-8">A.3.1 The case of multilinear polynomials</h3>

    <p class="text-gray-300">The first result is for the case of multivariate polynomials over any finite field, where  <span class="math">H \\subseteq \\mathbb{F}</span>  is arbitrary. The proof is a simple extension of a proof due to [JKRS09] for the case  <span class="math">H = \\{0,1\\}</span> .</p>

    <p class="text-gray-300"><strong>Theorem A.2 (Multilinear Polynomials).</strong> Let  <span class="math">\\mathbb{F}</span>  be a finite field,  <span class="math">H</span>  a subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\gamma := \\sum_{\\alpha \\in H} \\alpha</span> . For every  <span class="math">P \\in \\mathbb{F}[X_1^{\\leq 1}, \\ldots, m]</span>  (i.e., for every  <span class="math">m</span> -variate multilinear polynomial  <span class="math">P</span> ) it holds that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {\\vec {\\alpha} \\in H ^ {m}} P (\\vec {\\alpha}) = \\left\\{ \\begin{array}{l l} P \\big (\\frac {\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\ldots , \\frac {\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\big) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {m} &amp; \\text {i f} \\operatorname {c h a r} (\\mathbb {F}) \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\kappa \\cdot \\gamma^ {m} &amp; \\text {i f} \\operatorname {c h a r} (\\mathbb {F}) \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array} \\right.,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\kappa</span>  is the coefficient of  <span class="math">X_{1}\\cdot \\cdot \\cdot X_{m}</span>  in  <span class="math">P</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> First suppose that  <span class="math">\\mathrm{char}(\\mathbb{F})</span>  does not divide  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Let  </span>\\vec{\\alpha}<span class="math">  be uniformly random in  </span>H^{m}<span class="math"> ; in particular,  </span>\\alpha_{i}<span class="math">  and  </span>\\alpha_{j}<span class="math">  are independent for  </span>i \\neq j<span class="math"> . For every monomial  </span>m(\\vec{X}) = X_1^{e_1} \\cdots X_m^{e_m}<span class="math">  with  </span>e_1, \\ldots, e_m \\in \\{0, 1\\}$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ M (\\vec {\\alpha}) ] = \\mathbb {E} [ \\alpha_ {1} ^ {e _ {1}} \\dots \\alpha_ {m} ^ {e _ {m}} ] = \\mathbb {E} [ \\alpha_ {1} ^ {e _ {1}} ] \\dots \\mathbb {E} [ \\alpha_ {m} ^ {e _ {m}} ] = \\mathbb {E} [ \\alpha_ {1} ] ^ {e _ {1}} \\dots \\mathbb {E} [ \\alpha_ {m} ] ^ {e _ {m}} = M (\\mathbb {E} [ \\alpha_ {1} ], \\ldots , \\mathbb {E} [ \\alpha_ {m} ]) .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  <span class="math">P</span>  is a linear combination of monomials,  <span class="math">\\mathbb{E}[P(\\vec{\\alpha})] = P(\\mathbb{E}[\\vec{\\alpha}])</span> . Each  <span class="math">\\alpha_{i}</span>  is uniformly random in  <span class="math">H</span> , so  $\\mathbb{E}[\\alpha_i] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\sum_{\\alpha \\in H}\\alpha = \\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , and thus  </span>P(\\mathbb{E}[\\vec{\\alpha}]) = P(\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\ldots ,\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> , which implies that  </span>\\mathbb{E}[P(\\vec{\\alpha})] = P(\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},\\ldots ,\\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> . To deduce the claimed relation, it suffices to note that  </span>\\mathbb{E}[P(\\vec{\\alpha})] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^m}\\sum_{\\vec{\\alpha}\\in H^m}P(\\vec{\\alpha})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next suppose that  <span class="math">\\mathrm{char}(\\mathbb{F})</span>  divides  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For every monomial  </span>m(\\vec{X}) = X_1^{e_1}\\dots X_m^{e_m}<span class="math">  with  </span>e_1,\\ldots ,e_m\\in \\{0,1\\}$ :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if there exists  <span class="math">j \\in [m]</span>  such that  <span class="math">e_j = 0</span>  then</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {\\vec {\\alpha} \\in H ^ {m}} M (\\vec {\\alpha}) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {\\alpha_ {1}, \\dots , \\alpha_ {j - 1}, \\alpha_ {j + 1}, \\dots , \\alpha_ {m} \\in H} \\alpha_ {1} ^ {e _ {1}} \\dots \\alpha_ {j - 1} ^ {e _ {j - 1}} \\alpha_ {j + 1} ^ {e _ {j + 1}} \\dots \\alpha_ {m} ^ {e _ {m}} = 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if instead <span class="math">e_1 = \\cdots = e_m = 1</span> then</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{\\alpha} \\in H^m} M(\\vec{\\alpha}) = \\sum_{\\vec{\\alpha} \\in H^m} \\prod_{i=1}^{m} \\alpha_i = \\prod_{i=1}^{m} \\sum_{\\alpha_i \\in H} \\alpha_i = \\left(\\sum_{\\alpha \\in H} \\alpha\\right)^m.</span></div>

    <p class="text-gray-300">The following corollary shows that for prime fields of odd size, the value of <span class="math">\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha})</span> can be computed efficiently for any <span class="math">H \\subseteq \\mathbb{F}</span> using at most a single query to <span class="math">P</span>.</p>

    <p class="text-gray-300"><strong>Corollary A.3.</strong> Let <span class="math">\\mathbb{F}</span> be a prime field of odd size, <span class="math">H</span> a subset of <span class="math">\\mathbb{F}</span>, and <span class="math">\\gamma := \\sum_{\\alpha \\in H} \\alpha</span>. For every <span class="math">P \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq 1}]</span> (i.e., for every <span class="math">m</span>-variate multilinear polynomial <span class="math">P</span>) it holds that</p>

    <p class="text-gray-300">$$ \\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = \\begin{cases}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P \\left( \\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\ldots, \\frac{\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\right) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^m &amp; \\text{if } \\operatorname{char}(\\mathbb{F}) \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{cases}. $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Theorem A.2 directly implies both cases. If <span class="math">\\operatorname{char}(\\mathbb{F})</span> does not divide $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then the claimed value is as in the theorem. If instead </span>\\operatorname{char}(\\mathbb{F})<span class="math"> divides </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then it must be the case that </span>H = \\mathbb{F}<span class="math">, since </span>p := \\operatorname{char}(\\mathbb{F})<span class="math"> equals </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; in this case, </span>\\gamma = \\sum_{\\alpha \\in H} \\alpha = (p - 1)p/2<span class="math">, which is divisible by </span>p<span class="math"> since 2 must divide </span>p - 1<span class="math"> (as </span>p$ is odd).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-82" class="text-2xl font-bold">A.3.2 The case of subsets with group structure</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we show that if <span class="math">H</span> is assumed to have some group structure, then few queries may suffice even for polynomials of degree greater than one. In particular, the following result shows that a single query suffices for $d \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> when </span>H<span class="math"> is a multiplicative subgroup of </span>\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma A.4 (Multiplicative Groups).</strong> Let <span class="math">\\mathbb{F}</span> be a field, <span class="math">H</span> a finite multiplicative subgroup of <span class="math">\\mathbb{F}</span>, and <span class="math">m, d</span> positive integers with $d &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For every </span>P \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\vec{\\alpha} \\in H^m} P(\\vec{\\alpha}) = P(0, \\ldots, 0) \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^m.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Remark A.5.</strong> The hypothesis that $d &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is necessary for the lemma, as we now explain. Choose </span>H = \\mathbb{K}^{\\times}<span class="math">, where </span>\\mathbb{K}<span class="math"> is a proper subfield of </span>\\mathbb{F}<span class="math">, </span>m = 1<span class="math">, and </span>d =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Consider the polynomial </span>X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, which has degree at least </span>d<span class="math">: </span>X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> vanishes on 0; however, </span>X^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> evaluates to 1 everywhere on </span>H<span class="math"> so that its sum over </span>H<span class="math"> equals </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neq 0<span class="math">. (Note that if </span>H<span class="math"> is a multiplicative subgroup of </span>\\mathbb{F}<span class="math"> then </span>\\operatorname{char}(\\mathbb{F}) \\nmid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> because </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> equals </span>\\operatorname{char}(\\mathbb{F})^k - 1<span class="math"> for some positive integer </span>k$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> The proof is by induction on the number of variables <span class="math">m</span>. The base case is when <span class="math">m = 1</span>, which we argue as follows. The group <span class="math">H</span> is cyclic, because it is a (finite) multiplicative subgroup of a field; so let <span class="math">\\omega</span> generate <span class="math">H</span>. Writing <span class="math">P(X_1) = \\sum_{j=0}^{d} \\beta_j X_1^j</span> for some <span class="math">\\beta_0, \\ldots, \\beta_d \\in \\mathbb{F}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{\\alpha_1 \\in H} P(\\alpha_1) = \\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} P(\\omega^i) = \\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} \\sum_{j=0}^{d} \\beta_j \\omega^{ij} = \\sum_{j=0}^{d} \\beta_j \\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} (\\omega^j)^i = \\beta_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= f(0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">which proves the base case. The second-to-last equality follows from the fact that for every <span class="math">\\gamma \\in H</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{i=0}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} \\gamma^i = \\begin{cases}</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\frac{\\gamma^{</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">}_{\\gamma-1}}{\\gamma-1} = 0 &amp; \\text{if } \\gamma \\neq 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{cases}. $$</p>

    <p class="text-gray-300">For the inductive step, assume the statement for any number of variables less than <span class="math">m</span>; we now prove that it holds for <span class="math">m</span> variables as well. Let <span class="math">P_{\\alpha}</span> denote <span class="math">P</span> with the variable <span class="math">X_1</span> fixed to <span class="math">\\alpha</span>. Next, apply the inductive assumption below in</p>

    <p class="text-gray-300">the second equality (with <span class="math">m - 1</span> variables) and last one (with 1 variable), to obtain</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_{\\vec{\\alpha} \\in H^{m}} P(\\alpha_{1}, \\dots, \\alpha_{m}) = \\sum_{\\alpha_{1} \\in H} \\sum_{(\\alpha_{2}, \\dots, \\alpha_{m}) \\in H^{m-1}} P_{\\alpha_{1}}(\\alpha_{2}, \\dots, \\alpha_{m}) \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{m-1} \\sum_{\\alpha_{1} \\in H} P_{\\alpha_{1}}(0^{m-1}) \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">H</td>

            <td class="px-3 py-2 border-b border-gray-700">^{m} P(0, \\dots, 0) \\ ,</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">as claimed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma A.6 (Additive Groups). Let <span class="math">\\mathbb{F}</span> be a field, <span class="math">H</span> a finite additive subgroup of <span class="math">\\mathbb{F}</span>, and <span class="math">m, d</span> positive integers with $d &lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For every </span>P \\in \\mathbb{F}[X_{1,\\ldots,m}^{\\leq d}]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{\\alpha} \\in H^{m}} P(\\vec{\\alpha}) = \\kappa \\cdot a_{0}^{m} ,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\kappa</span> is the coefficient of $X_1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1} \\cdots X_m^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}<span class="math"> in </span>P<span class="math">, and </span>a_0<span class="math"> is the (formal) linear term of the subspace polynomial </span>\\prod_{h \\in H} (X - h)<span class="math">. In particular, if </span>P<span class="math"> has total degree strictly less than </span>m(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$, then the above sum evaluates to 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Without loss of generality, let $d \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">. The proof is by induction on the number of variables </span>m<span class="math">. When </span>m = 1<span class="math">, we have that </span>P(X) = \\sum_{j=0}^{d} \\beta_{j} X^{j}<span class="math"> for some </span>\\beta_{0}, \\ldots, \\beta_{d} \\in \\mathbb{F}$. Then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\alpha \\in H} P(\\alpha) = \\sum_{\\alpha \\in H} \\sum_{j=0}^{d} \\beta_{j} \\alpha^{j} = \\sum_{j=0}^{d} \\beta_{j} \\sum_{\\alpha \\in H} \\alpha^{j} = \\beta_{d} a_{0}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the final equality follows by [BC99, Theorem 1], and the fact that $d =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the inductive step, assume the statement for <span class="math">m - 1</span> variables; we now prove that it holds for <span class="math">m</span> variables as well. Let <span class="math">P_{\\alpha}</span> denote <span class="math">P</span> with the variable <span class="math">X_{1}</span> fixed to <span class="math">\\alpha</span>; we have <span class="math">P_{\\alpha}(X_2,\\ldots ,X_m) = \\sum_{\\vec{e}\\in \\{0,\\dots,d\\}^m}\\beta_{\\vec{e}}\\cdot \\alpha^{e_1}X_2^{e_2}\\dots X_m^{e_m}</span>. Next, apply the inductive hypothesis below in the second equality (with <span class="math">m - 1</span> variables) to obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{\\alpha} \\in H^{m}} P(\\alpha_{1}, \\dots, \\alpha_{m}) = \\sum_{\\alpha_{1} \\in H} \\sum_{(\\alpha_{2}, \\dots, \\alpha_{m}) \\in H^{m-1}} P_{\\alpha_{1}}(\\alpha_{2}, \\dots, \\alpha_{m}) = \\sum_{\\alpha_{1} \\in H} a_{0}^{m-1} \\kappa(\\alpha_{1}) \\ ,</span></div>

    <p class="text-gray-300">where <span class="math">\\kappa(X_1) \\coloneqq \\sum_{j=0}^{d} \\beta_{(j,d,\\ldots,d)} X_1^j</span>. Applying the hypothesis again for 1 variable yields</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\alpha_{1} \\in H} a_{0}^{m-1} \\kappa(\\alpha_{1}) = a_{0}^{m} \\cdot \\beta_{(d, \\dots, d)} ,</span></div>

    <p class="text-gray-300">and the claim follows.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">58</p>

    <p class="text-gray-300">B Proof of Theorem 7.2 via sum-product circuits</p>

    <p class="text-gray-300">In this section we re-prove Theorem 7.2 using sum-product circuits. In particular we reduce <span class="math">\\mathcal{R}_{\\mathrm{O3SAT}}</span> to <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span> by constructing a sum-product circuit whose satisfaction encodes oracle 3-satisfiability. The reduction then yields Theorem 7.2 by the perfect zero knowledge IPCP for <span class="math">\\mathcal{R}_{\\mathrm{SPCS}}</span> given in Theorem 9.2.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Lemma B.1 (<span class="math">\\mathcal{R}_{\\mathrm{O3SAT}}\\to\\mathcal{R}_{\\mathrm{SPCS}}</span>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">H</span> be an extension field of <span class="math">\\mathbb{F}_{2}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 8<span class="math">, and </span>\\mathbb{F}<span class="math"> an extension field of </span>H<span class="math">. There exist polynomial-time functions </span>f,g<span class="math"> such that for every </span>r,s\\in\\mathbb{N}<span class="math"> and boolean formula </span>B\\colon\\{0,1\\}^{r+3s+3}\\to\\{0,1\\}$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">A\\colon\\{0,1\\}^{s}\\to\\{0,1\\}</span> is such that <span class="math">((r,s,B),A)\\in\\mathcal{R}_{\\mathrm{O3SAT}}</span> then</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\Pr_{\\vec{x},\\vec{y}\\leftarrow\\vec{\\mathbb{F}}^{r+3s}}\\left[\\left((f(r,s,B,\\vec{x},\\vec{y}),0,\\bot),g(A)\\right)\\in\\mathcal{R}_{\\mathrm{SPCS}}\\right]=1\\enspace;</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">(r,s,B)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span> then</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\vec{x},\\vec{y}\\leftarrow\\vec{\\mathbb{F}}^{r+3s}}\\left[\\left(f(r,s,B,\\vec{x},\\vec{y}),0,\\bot\\right)\\in\\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})\\right]\\leq\\frac{r+3s}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Moreover, <span class="math">f(r,s,B,\\vec{x},\\vec{y})</span> is a sum-product circuit <span class="math">(\\mathbb{F},H,\\delta_{\\mathrm{in}},\\delta_{\\mathrm{lf}},G,C)</span> with $\\delta_{\\mathrm{in}}=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\delta_{\\mathrm{lf}}=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Theta(1)<span class="math">, </span>\\mathsf{arity}(G)=O((r+s)/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, </span>\\mathsf{in}(G)=\\Theta(1)<span class="math">, </span>\\mathsf{width}(G)=\\Theta(1)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that in Section 7 we reduced checking <span class="math">((B,r,s),A)\\in\\mathcal{R}_{\\mathrm{O3SAT}}</span> to checking whether the following expression is the zero polynomial, for some polynomials <span class="math">g_{1},g_{2}</span> which depend on the low-degree extension of <span class="math">A</span>.</p>

    <p class="text-gray-300"><span class="math">F(\\vec{X},\\vec{Y})=\\sum_{\\vec{\\alpha}\\in H^{m_{1}}\\atop\\vec{\\beta}_{1},\\vec{\\beta}_{2},\\vec{\\beta}_{3}\\in H^{m_{2}}}</span> <span class="math">g_{1}(\\hat{\\gamma}(\\vec{\\alpha},\\vec{\\beta}_{1},\\vec{\\beta}_{2},\\vec{\\beta}_{3}))\\prod_{i=1}^{r+3s}(1+(X_{i}-1)\\hat{\\gamma}(\\vec{\\alpha},\\vec{\\beta}_{1},\\vec{\\beta}_{2},\\vec{\\beta}_{3})_{i})</span> <span class="math">+g_{2}(\\hat{\\gamma}_{2}(\\vec{\\beta}_{1}))\\prod_{i=1}^{r+3s}(1+(Y_{i}-1)\\hat{\\gamma}(\\vec{\\alpha},\\vec{\\beta}_{1},\\vec{\\beta}_{2},\\vec{\\beta}_{3})_{i})\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fix <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}^{r+3s}</span>. We construct a sum-product circuit <span class="math">\\mathcal{C}=(\\mathbb{F},H,\\delta_{\\mathrm{in}},\\delta_{\\mathrm{lf}},G,C)</span> whose value with explicit input <span class="math">\\bot</span> (the empty map) and auxiliary input <span class="math">\\hat{A}</span> is <span class="math">F(\\vec{x},\\vec{y})</span>. Fix $\\delta_{\\mathrm{in}}:=O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and </span>\\delta_{\\mathrm{lf}}:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>G=(V,E,\\sigma,\\rho)$ be the ari-graph defined as follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">V</span> <span class="math">:=\\{v,u\\}\\enspace,</span> <span class="math">E</span> <span class="math">:=\\{e_{1},e_{2},e_{3}=(v,u)\\}\\enspace,</span> <span class="math">\\rho_{e}</span> <span class="math">:=\\varnothing\\quad\\text{ for all }e\\in E\\enspace,</span> <span class="math">\\sigma_{e_{i}}</span> <span class="math">:=m_{1}+(i-1)m_{2}+[m_{2}]\\quad\\text{ for }i\\in\\{1,2,3\\}\\enspace.</span></p>

    <p class="text-gray-300">The vertex label <span class="math">C</span> is given by</p>

    <p class="text-gray-300"><span class="math">C_{v}:=\\left(\\hat{B}(\\vec{Y},Z_{1},Z_{2},Z_{3})\\cdot\\prod_{i=1}^{r+3s+3}(1+(x_{i}-1))\\hat{\\gamma}(\\vec{Y})_{i}\\right)+\\left(Z_{1}(1-Z_{1})\\cdot\\prod_{i=1}^{r+3s}(1+(y_{i}-1))\\hat{\\gamma}(\\vec{Y})_{i}\\right)\\enspace,</span></p>

    <p class="text-gray-300">where the variables <span class="math">Z_{1},Z_{2},Z_{3}</span> correspond to the edges <span class="math">e_{1},e_{2},e_{3}</span> respectively.</p>

    <p class="text-gray-300">From the construction of the circuit, if <span class="math">\\mathbf{z}_{u}=\\hat{A}(\\hat{\\gamma}_{2}(\\cdot))</span> then <span class="math">\\mathcal{C}[\\mathbf{x},\\mathbf{z}]=F(\\vec{x},\\vec{y})</span>. The stated parameters follow easily.</p>

    <p class="text-gray-300">If <span class="math">((r,s,B),A)\\in\\mathcal{R}_{\\mathrm{O3SAT}}</span> then <span class="math">F(\\vec{X},\\vec{Y})</span> is the zero polynomial. Hence <span class="math">F(\\vec{x},\\vec{y})=0</span> for all <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}^{r+3s}</span>. We conclude that if <span class="math">((r,s,B),A)\\in\\mathcal{R}_{\\mathrm{O3SAT}}</span> then <span class="math">((\\mathcal{C},0,\\mathbf{x}),\\mathbf{z})\\in\\mathcal{R}_{\\mathrm{SPCS}}</span> with probability <span class="math">1</span> over the choice of <span class="math">\\vec{x},\\vec{y}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">(r,s,B)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span> then there is no choice of <span class="math">\\hat{A}</span> such that <span class="math">F(\\vec{X},\\vec{Y})</span> is the zero polynomial. Thus, for any choice of <span class="math">\\hat{A}</span>, <span class="math">F(\\vec{x},\\vec{y})=0</span> with probability at most $(r+3s)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the choice of </span>\\vec{x},\\vec{y}<span class="math">. We conclude that if </span>(r,s,B)\\notin\\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})<span class="math"> then </span>(\\mathcal{C},0,\\mathbf{x})\\in\\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})<span class="math"> with probability at most </span>(r+3s)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 7.2. The protocol proceeds as follows. The prover and verifier deterministically (non-interactively) choose an extension field <span class="math">H</span> of <span class="math">\\mathbb{F}_2</span> and an extension field <span class="math">\\mathbb{F}</span> of <span class="math">H</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\log b)<span class="math">. The verifier chooses </span>\\vec{x}, \\vec{y} \\in \\mathbb{F}^{r + 3s}<span class="math"> uniformly at random, and sends them to the prover; the prover and verifier construct the sum-product circuit </span>\\mathcal{C} := f(r, s, B, \\vec{x}, \\vec{y})<span class="math">, and then engage in the protocol of Theorem 9.2 on the input </span>(\\mathcal{C}, 0, \\bot)<span class="math">, with auxiliary input </span>g(A)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">((B,r,s),A)\\in \\mathcal{R}_{\\mathrm{O3SAT}}</span> then <span class="math">((\\mathcal{C},0,\\bot),g(A))\\in \\mathcal{R}_{\\mathrm{SPCS}}</span> with probability 1, and so the verifier will accept with probability 1. If <span class="math">(B,r,s)\\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{O3SAT}})</span> then <span class="math">(\\mathcal{C},0,\\bot)\\in \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})</span> with probability at most $(r + 3s) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Also, if </span>(\\mathcal{C},0,\\bot)\\notin \\mathcal{L}(\\mathcal{R}_{\\mathrm{SPCS}})<span class="math">, then the verifier accepts with probability at most </span>O(\\delta_{\\mathrm{in}}\\delta_{\\mathrm{H}}\\cdot \\mathrm{in}(G)\\cdot (\\mathrm{arity}(G) + \\alpha)\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot(r + s + \\log b)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">. By our choices of the cardinality of </span>H<span class="math"> and </span>\\mathbb{F}<span class="math">, both of these probabilities are </span>O(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> so that, by a union bound, the probability that the verifier accepts is also </span>O(1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, which is less than </span>1 / 2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocol as stated is not an IPCP because there is a round of interaction before the oracle is sent. However, observe that the oracle does not depend on the choice of <span class="math">\\vec{x},\\vec{y}</span>, and therefore can be sent before this interaction.</p>

    <p class="text-gray-300">60</p>

    <p class="text-gray-300">[AH91] William Aiello and Johan Håstad. "Statistical Zero-Knowledge Languages can be Recognized in Two Rounds". In: Journal of Computer and System Sciences 42.3 (1991). Preliminary version appeared in FOCS '87., pp. 327-345. [ALMSS98] Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy. "Proof verification and the hardness of approximation problems". In: Journal of the ACM 45.3 (1998). Preliminary version in FOCS '92., pp. 501-555. [AS03] Sanjeev Arora and Madhu Sudan. "Improved Low-Degree Testing and its Applications". In: Combinatorica 23.3 (2003). Preliminary version appeared in STOC '97., pp. 365-426. [AS98] Sanjeev Arora and Shmuel Safra. "Probabilistic checking of proofs: a new characterization of NP". In: Journal of the ACM 45.1 (1998). Preliminary version in FOCS '92., pp. 70-122. [AW09] Scott Aaronson and Avi Wigderson. "Algebrization: A New Barrier in Complexity Theory". In: ACM Transactions on Computation Theory 1.1 (2009), 2:1-2:54. [BC12] Nir Bitansky and Alessandro Chiesa. "Succinct Arguments from Multi-Prover Interactive Proofs and their Efficiency Benefits". In: Proceedings of the 32nd Annual International Cryptology Conference. CRYPTO '12. 2012, pp. 255-272. [BC99] Nigel P. Byott and Robin J. Chapman. "Power Sums over Finite Subspaces of a Field". In: Finite Fields and Their Applications 5.3 (July 1999), pp. 254-265. [BCFGRS16] Eli Ben-Sasson, Alessandro Chiesa, Michael A. Forbes, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. On Probabilistic Checking in Perfect Zero Knowledge. Cryptology ePrint Archive, Report 2016/988. 2016. [BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. "Interactive oracle proofs". In: Proceedings of the 14th Theory of Cryptography Conference. TCC '16-B. 2016, pp. 31-60. [BFL91] László Babai, Lance Fortnow, and Carsten Lund. “Non-Deterministic Exponential Time has Two-Prover Interactive Protocols”. In: Computational Complexity 1 (1991). Preliminary version appeared in FOCS '90., pp. 3–40. [BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. "Checking computations in polylogarithmic time". In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing. STOC '91. 1991, pp. 21-32. [BGGHKMR88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan Håstad, Joe Kilian, Silvio Micali, and Phillip Rogaway. "Everything Provable is Provable in Zero-Knowledge". In: Proceedings of the 8th Annual International Cryptology Conference. CRYPTO '89. 1988, pp. 37-56. [BGKW88] Michael Ben-Or, Shafi Goldwasser, Joe Kilian, and Avi Wigderson. "Multi-prover interactive proofs: how to remove intractability assumptions". In: Proceedings of the 20th Annual ACM Symposium on Theory of Computing. STOC '88. 1988, pp. 113-131. [BM88] László Babai and Shlomo Moran. “Arthur-Merlin Games: A Randomized Proof System, and a Hierarchy of Complexity Classes”. In: Journal of Computer and System Sciences 36.2 (1988), pp. 254–276. [BRV17] Itay Berman, Ron D. Rothblum, and Vinod Vaikuntanathan. Zero-Knowledge Proofs of Proximity. Cryptology ePrint Archive, Report 2017/114. 2017. [BW04] Andrej Bogdanov and Hoeteck Wee. “A Stateful Implementation of a Random Function Supporting Parity Queries over Hypercubes”. In: Proceedings of the 7th International Workshop on Approximation Algorithms for Combinatorial Optimization Problems, and of the 8th International Workshop on Randomization and Computation. APPROX-RANDOM '04. 2004, pp. 298-309. [Bab85] László Babai. "Trading group theory for randomness". In: Proceedings of the 17th Annual ACM Symposium on Theory of Computing. STOC '85. 1985, pp. 421-429. [CD98] Ronald Cramer and Ivan Damgård. “Zero-Knowledge Proofs for Finite Field Arithmetic; or: Can Zero-Knowledge be for Free?” In: Proceedings of the 18th Annual International Cryptology Conference. CRYPTO '98. 1998, pp. 424-441. [CKLR11] Kai-Min Chung, Yael Kalai, Feng-Hao Liu, and Ran Raz. “Memory Delegation”. In: Proceeding of the 31st Annual Cryptology Conference. CRYPTO '10. 2011, pp. 151-168.</p>

    <p class="text-gray-300">[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. “Practical Verified Computation with Streaming Interactive Proofs”. In: Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science. ITCS ’12. 2012, pp. 90–112.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CRR13] Ran Canetti, Ben Riva, and Guy N. Rothblum. “Refereed delegation of computation”. In: Information and Computation 226 (2013), pp. 16–36.</li>

      <li>[DFKNS92] Cynthia Dwork, Uriel Feige, Joe Kilian, Moni Naor, and Shmuel Safra. “Low Communication 2-Prover Zero-Knowledge Proofs for NP”. In: Proceedings of the 11th Annual International Cryptology Conference. CRYPTO ’92. 1992, pp. 215–227.</li>

      <li>[DS98] Cynthia Dwork and Amit Sahai. “Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints”. In: Proceedings of the 18th Annual International Cryptology Conference. CRYPTO ’98. 1998, pp. 442–457.</li>

      <li>[FGLSS91] Uriel Feige, Shafi Goldwasser, László Lovász, Shmuel Safra, and Mario Szegedy. “Approximating clique is almost NP-complete (preliminary version)”. In: Proceedings of the 32nd Annual Symposium on Foundations of Computer Science. SFCS ’91. 1991, pp. 2–12.</li>

      <li>[FGLSS96] Uriel Feige, Shafi Goldwasser, Laszlo Lovász, Shmuel Safra, and Mario Szegedy. “Interactive proofs and the hardness of approximating cliques”. In: Journal of the ACM 43.2 (1996). Preliminary version in FOCS ’91., pp. 268–292.</li>

      <li>[FRS88] Lance Fortnow, John Rompel, and Michael Sipser. “On the Power of Multi-Prover Interactive Protocols”. In: Theoretical Computer Science. 1988, pp. 156–161.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. “How to prove yourself: practical solutions to identification and signature problems”. In: Proceedings of the 6th Annual International Cryptology Conference. CRYPTO ’86. 1986, pp. 186–194.</li>

      <li>[FS89] Uriel Feige and Adi Shamir. “Zero Knowledge Proofs of Knowledge in Two Rounds”. In: Proceedings of the 9th Annual International Cryptology Conference. CRYPTO ’89. 1989, pp. 526–544.</li>

      <li>[For87] Lance Fortnow. “The Complexity of Perfect Zero-Knowledge (Extended Abstract)”. In: Proceedings of the 19th Annual ACM Symposium on Theory of Computing. STOC ’87. 1987, pp. 204–209.</li>

      <li>[GIMS10] Vipul Goyal, Yuval Ishai, Mohammad Mahmoody, and Amit Sahai. “Interactive locking, zero-knowledge PCPs, and unconditional cryptography”. In: Proceedings of the 30th Annual Conference on Advances in Cryptology. CRYPTO’10. 2010, pp. 173–190.</li>

      <li>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: Journal of the ACM 62.4 (2015), 27:1–27:64.</li>

      <li>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. “The knowledge complexity of interactive proof systems”. In: SIAM Journal on Computing 18.1 (1989). Preliminary version appeared in STOC ’85., pp. 186–208.</li>

      <li>[GR15] Tom Gur and Ron D. Rothblum. “Non-Interactive Proofs of Proximity”. In: Proceedings of the 6th Innovations in Theoretical Computer Science Conference. ITCS ’15. 2015, pp. 133–142.</li>

      <li>[GS06] Oded Goldreich and Madhu Sudan. “Locally testable codes and PCPs of almost-linear length”. In: Journal of the ACM 53 (4 2006). Preliminary version in STOC ’02., pp. 558–655.</li>

      <li>[Gol01] Oded Goldreich. Foundations of Cryptography: Volume 1. Cambridge University Press, 2001. isbn: 978-0-521-03536-1.</li>

      <li>[IMSX15] Yuval Ishai, Mohammad Mahmoody, Amit Sahai, and David Xiao. On Zero-Knowledge PCPs: Limitations, Simplifications, and Applications. Available at http://www.cs.virginia.edu/~mohammad/files/papers/ZKPCPs-Full.pdf. 2015.</li>

      <li>[IY87] Russell Impagliazzo and Moti Yung. “Direct Minimum-Knowledge Computations”. In: Proceedings of the 7th Annual International Cryptology Conference. CRYPTO ’87. 1987, pp. 40–51.</li>

      <li>[JKRS09] Ali Juma, Valentine Kabanets, Charles Rackoff, and Amir Shpilka. “The Black-Box Query Complexity of Polynomial Summation”. In: Computational Complexity 18.1 (2009), pp. 59–79.</li>

      <li>[KPT97] Joe Kilian, Erez Petrank, and Gábor Tardos. “Probabilistically checkable proofs with zero knowledge”. In: Proceedings of the 29th Annual ACM Symposium on Theory of Computing. STOC ’97. 1997, pp. 496–505.</li>

      <li>[KR08] Yael Kalai and Ran Raz. “Interactive PCP”. In: Proceedings of the 35th International Colloquium on Automata, Languages and Programming. ICALP ’08. 2008, pp. 536–547.</li>

    </ul>

    <p class="text-gray-300">[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. “How to delegate computations: the power of no-signaling proofs”. In: Proceedings of the 46th Annual ACM Symposium on Theory of Computing. STOC ’14. 2014, pp. 485–494.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Kil92] Joe Kilian. “A note on efficient zero-knowledge proofs and arguments”. In: Proceedings of the 24th Annual ACM Symposium on Theory of Computing. STOC ’92. 1992, pp. 723–732.</li>

      <li>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</li>

      <li>[Mei13] Or Meir. “IP = PSPACE Using Error-Correcting Codes”. In: SIAM Journal on Computing 42.1 (2013), pp. 380–403.</li>

      <li>[Mic00] Silvio Micali. “Computationally Sound Proofs”. In: SIAM Journal on Computing 30.4 (2000). Preliminary version appeared in FOCS ’94., pp. 1253–1298.</li>

      <li>[OW93] Rafail Ostrovsky and Avi Wigderson. “One-Way Functions are Essential for Non-Trivial Zero-Knowledge”. In: Proceedings of the 2nd Israel Symposium on Theory of Computing Systems. ISTCS ’93. 1993, pp. 3–17.</li>

      <li>[Ost91] Rafail Ostrovsky. “One-Way Functions, Hard on Average Problems, and Statistical Zero-Knowledge Proofs”. In: Proceedings of the 6th Annual Structure in Complexity Theory Conference. CoCo ’91. 1991, pp. 133–138.</li>

      <li>[RG17] Guy N. Rothblum and Oded Goldreich. Simple doubly-efficient interactive proof systems for locally-characterizable sets. ECCC TR17-018. 2017.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[RS05] Ran Raz and Amir Shpilka. “Deterministic polynomial identity testing in non-commutative models”. In: Computational Complexity 14.1 (2005). Preliminary version appeared in CCC ’04., pp. 1–19.</li>

      <li>[RS96] Ronitt Rubinfeld and Madhu Sudan. “Robust Characterizations of Polynomials with Applications to Program Testing”. In: SIAM Journal on Computing 25.2 (1996), pp. 252–271.</li>

      <li>[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. “Interactive proofs of proximity: delegating computation in sublinear time”. In: Proceedings of the 45th ACM Symposium on the Theory of Computing. STOC ’13. 2013, pp. 793–802.</li>

      <li>[Sha92] Adi Shamir. “IP = PSPACE”. In: Journal of the ACM 39.4 (1992), pp. 869–877.</li>

      <li>[She92] Alexander Shen. “IP = PSPACE: Simplified Proof”. In: Journal of the ACM 39.4 (1992), pp. 878–880.</li>

      <li>[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. “Verifiable Computation with Massively Parallel Interactive Proofs”. In: CoRR abs/1202.1350 (2012).</li>

      <li>[TV07] Luca Trevisan and Salil Vadhan. “Pseudorandomness and Average-Case Complexity Via Uniform Reductions”. In: Computational Complexity 16.4 (2007), pp. 331–364.</li>

      <li>[Tha13] Justin Thaler. “Time-Optimal Interactive Proofs for Circuit Evaluation”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 71–89.</li>

      <li>[Tha15] Justin Thaler. A Note on the GKR Protocol. http://people.cs.georgetown.edu/jthaler/GKRNote.pdf. 2015.</li>

      <li>[WHGSW16] Riad S. Wahby, Max Howald, Siddharth J. Garg, Abhi Shelat, and Michael Walfish. “Verifiable ASICs”. In: Proceedings of the 37th IEEE Symposium on Security and Privacy. S&amp;P ’16. 2016, pp. 759–778.</li>

      <li>[WJBSTWW17] Riad S. Wahby, Ye Ji, Andrew J. Blumberg, Abhi Shelat, Justin Thaler, Michael Walfish, and Thomas Wies. Full accounting for verifiable outsourcing. Cryptology ePrint Archive, Report 2017/242. 2017.</li>

    </ul>`;
---

<BaseLayout title="A Zero Knowledge Sumcheck and its Applications (2017/305)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2017 &middot; eprint 2017/305
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
