---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1447';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Compressed $\\Sigma$-Protocols for Bilinear Group Arithmetic Circuits and Application to Logarithmic Transparent Threshold Signatures';
const AUTHORS_HTML = 'Thomas Attema, Ronald Cramer, Matthieu Rambaud';

const CONTENT = `    <p class="text-gray-300">Thomas Attema<span class="math">^{1,2,4}</span>, <span class="math">*</span>, Ronald Cramer<span class="math">^{1,2}</span>, <span class="math">^{\\dagger}</span>, and Matthieu Rambaud<span class="math">^{3}</span>, <span class="math">^{\\ddagger}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> CWI, Cryptology Group, Amsterdam, The Netherlands <span class="math">^{2}</span> Leiden University, Mathematical Institute, Leiden, The Netherlands <span class="math">^{3}</span> Telecom Paris, Institut Polytechnique de Paris, Palaiseau, France <span class="math">^{4}</span> TNO, Cyber Security and Robustness, The Hague, The Netherlands</p>

    <p class="text-gray-300">Version 4 - January 10, 2023<span class="math">^{5}</span></p>

    <p class="text-gray-300">Abstract. Lai et al. (CCS 2019) have shown how Bulletproofs arithmetic circuit zero-knowledge protocol (Bootle et al., EUROCRYPT 2016 and Bünz et al., S&amp;P 2018) can be generalized to work for bilinear group arithmetic circuits directly, i.e., without requiring these circuits to be translated into arithmetic circuits.</p>

    <p class="text-gray-300">In a nutshell, a bilinear group arithmetic circuit is a standard arithmetic circuit augmented with special gates capturing group exponentiations or pairings. Such circuits are highly relevant, e.g., in the context of zero-knowledge statements over pairing-based languages. As expressing these special gates in terms of a standard arithmetic circuit results in a significant overhead in circuit size, an approach to zero-knowledge via standard arithmetic circuits may incur substantial additional costs. The approach due to Lai et al. shows how to avoid this by integrating additional zero-knowledge techniques into the Bulletproof framework so as to handle the special gates very efficiently.</p>

    <p class="text-gray-300">We take a different approach by generalizing Compressed <span class="math">\\Sigma</span>-Protocol Theory (CRYPTO 2020) from arithmetic circuit relations to bilinear group arithmetic circuit relations. Besides its conceptual simplicity, our approach has the practical advantage of reducing the communication costs of Lai et al.'s protocol by roughly a multiplicative factor 3.</p>

    <p class="text-gray-300">Finally, we show an application of our results which may be of independent interest. We construct the first <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature scheme (TSS) that allows for transparent setup and that yields threshold signatures of size logarithmic in <span class="math">n</span>. The threshold signature hides the identities of the <span class="math">k</span> signers and the threshold <span class="math">k</span> can be dynamically chosen at aggregation time.</p>

    <p class="text-gray-300">Keywords: Zero-Knowledge, Bilinear Groups, Pairings, Compressed <span class="math">\\Sigma</span>-Protocol Theory, Threshold Signature Schemes.</p>

    <p class="text-gray-300">Bulletproofs [BCC<span class="math">^{+}</span>16, BBB<span class="math">^{+}</span>18] introduced an ingenious technique to compress the communication complexity of discrete logarithm (DL) based circuit zero-knowledge (ZK) protocols from linear to logarithmic. Their approach was presented as a drop-in replacement for the well-established <span class="math">\\Sigma</span>-protocol theory and it results in efficient zero-knowledge protocols for relations captured by a circuit defined over <span class="math">\\mathbb{Z}_q \\cong \\mathbb{Z}/(q\\mathbb{Z})</span>. In [AC20], Bulletproofs and <span class="math">\\Sigma</span>-protocol theory were reconciled by repurposing an appropriate adaptation of</p>

    <p class="text-gray-300">*thomas.attema@tno.nl</p>

    <p class="text-gray-300">\\dagger cramer@cwi.nl, cramer@math.leidenuniv.nl</p>

    <p class="text-gray-300">\\dagger rambaud@enst.fr</p>

    <p class="text-gray-300">Sections 1-6 were published in the same title work at ASIACRPT 2021. Section 7 and Appendix A did not appear in that work.</p>

    <p class="text-gray-300"><span class="math">^{5}</span>Change log w.r.t. Version 3 - March 10, 2021: (a) editorial changes throughout, (b) corrected a technical oversight in Appendix A without affecting the rest of the paper, and (c) added a short discussion on seemingly contradictory complexity assumptions (Section 5.2).</p>

    <p class="text-gray-300">Bulletproofs as a black-box compression mechanism for basic <span class="math">\\Sigma</span>-protocols. They first show how to handle linear arithmetic relations by deploying a basic <span class="math">\\Sigma</span>-protocol. Second, they show how an adaptation of Bulletproofs allows the communication complexity of the basic <span class="math">\\Sigma</span>-protocol to be compressed from linear to logarithmic. Hence, the resulting compressed <span class="math">\\Sigma</span>-protocol allows a prover to prove linear statements with a communication complexity that is logarithmic in the size of the witness. Finally, to handle arbitrary non-linear relations, arithmetic secret sharing based techniques <em>[x10]</em> are deployed to linearize these non-linearities. Cryptographic protocol design can now follow well-established approaches from <span class="math">\\Sigma</span>-protocol theory, but with the additional black-box compression mechanism to reduce the communication complexity down to logarithmic.</p>

    <p class="text-gray-300">These, and other, recent advances in communication-efficient circuit ZK lead to an obvious, but indirect, approach for efficient protocols for arbitrary relations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Construct an arithmetic circuit capturing the relation;</li>

      <li>Apply an efficient circuit ZK protocol to this arithmetic circuit.</li>

    </ol>

    <p class="text-gray-300">However, for some relations, the associated arithmetic circuits can be large and complex. Thereby losing the conceptual simplicity and possibly even the concrete efficiency over a more direct approach. The work of <em>[x1]</em>, for instance, describes a number of efficiency advantages of their direct approach for proving knowledge of <span class="math">k</span> discrete logarithms out of <span class="math">n</span> public group elements.</p>

    <p class="text-gray-300">Moreover, Lai et al. <em>[x24]</em> construct a zero-knowledge proof system for directly handling relations captured by bilinear group arithmetic circuits. A bilinear group is a tuple <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>, where <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span> is a bilinear map, also called a pairing, and <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups (group operations are written additively) of prime order <span class="math">q</span> generated by <span class="math">G</span>, <span class="math">H</span> and <span class="math">e(G,H)</span>, respectively. A bilinear group arithmetic circuit, or a bilinear circuit, is a circuit in which each wire takes values in <span class="math">W\\in\\{\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}\\}</span> and the gates all have fan-in 2 and unbounded fan-out. Gates are either group operations, <span class="math">\\mathbb{Z}_{q}</span>-scalar multiplications or bilinear pairings. For more details see Section 6. Bilinear circuits directly capture relations encountered in, e.g., identity based encryption <em>[x33]</em> and structure preserving signatures <em>[AFG^{+}10]</em>. We note that, for a highly optimized group of order <span class="math">q\\approx 2^{256}</span>, multiplying a single group element with a <span class="math">\\mathbb{Z}_{q}</span>-scalar requires an arithmetic circuit with approximately 800 multiplication gates <em>[x16]</em>, instead of a single gate in the bilinear circuit model. Hence, besides conceptual simplicity there can be significant efficiency advantages of the direct approach over the indirect approach that uses generic solutions for arithmetic circuit ZK.</p>

    <p class="text-gray-300">In this work, we focus on one application of our bilinear circuit ZK protocols: Threshold Signature Schemes (TSSs) <em>[x12]</em>. A <span class="math">k</span>-out-of-<span class="math">n</span> TSS is a standard signature scheme, allowing each of the <span class="math">n</span> players to individually sign arbitrary messages <span class="math">m</span>, enriched with a public <span class="math">k</span>-aggregation algorithm. The <span class="math">k</span>-aggregation algorithm takes as input <span class="math">k</span> signatures, issued by any <span class="math">k</span> distinct players, on the same message <span class="math">m</span> and outputs a threshold signature <span class="math">\\sigma</span>. A naive TSS is obtained by exhibiting the <span class="math">k</span> individual signatures directly. However, this approach results in threshold signatures with size linear in the threshold <span class="math">k</span>. The main goal for TSSs is to have succinct threshold signatures, i.e., with size sub-linear in <span class="math">k</span>. The succinct TSS of <em>[x35]</em> immediately found an application in reducing the communication complexity of consensus protocols <em>[x11]</em>. The impact of succinctness is significant since, in consensus applications, the threshold <span class="math">k</span> is of the same order of magnitude as <span class="math">n</span> (typically <span class="math">k=n/2</span> or <span class="math">k=2n/3</span>). Although desirable in some applications, it is not required that a threshold signature hides the <span class="math">k</span>-subset of signers.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Contributions</h3>

    <p class="text-gray-300">In this work, we present a novel ZK protocol for relations captured by bilinear circuits. We show that there is a generalization of the approach of <em>[x2]</em> for arithmetic circuit relations to bilinear circuit relations. Generalizing <em>[x2]</em>, our approach is to first compress a basic <span class="math">\\Sigma</span>-protocol for proving linear statements about committed vectors and, second, to show how to handle arbitrary bilinear circuit relations by linearizing non-linearities. This leads to a conceptually simple and modular construction of ZK protocols for bilinear circuit relations.</p>

    <p class="text-gray-300">In <em>[x1]</em>, an abstraction of the compressed <span class="math">\\Sigma</span>-protocols for proving linear relations was introduced. An appropriate instantiation of these abstract protocols immediately results in a compressed <span class="math">\\Sigma</span>-protocol</p>

    <p class="text-gray-300">for proving that a <em>mixed</em> vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> satisfies a <em>linear</em> constraint defined over a bilinear circuit. The main ingredient in this instantiation is a homomorphic commitment scheme <em>[AFG^{+}10, x16]</em> that allows a prover to commit to such mixed vectors. However, a number of modification to this straightforward approach are warranted.</p>

    <p class="text-gray-300">First, in contrast to the Pedersen commitment scheme for <span class="math">\\mathbb{Z}_{q}</span>-vectors, the commitment scheme for mixed vectors is not <em>compact</em>, i.e., the size of a commitment is not constant in the size of the committed vector. More precisely, the size of a commitment to a vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> is constant in the dimensions <span class="math">n_{0}</span>, <span class="math">n_{1}</span> and <span class="math">n_{2}</span>, but it is linear in the dimension <span class="math">n_{T}</span>. For this reason, compression should only be applied to the compact part of the commitment scheme. We handle this complication in an abstract manner by considering homomorphisms <span class="math">\\Psi(\\mathbf{x}_{1},\\mathbf{x}_{2})</span>, where the input consists of two parts and compressing is only applied to the first part <span class="math">\\mathbf{x}_{1}</span>.</p>

    <p class="text-gray-300">Second, the arithmetic circuit instantiation of the abstract protocol allows for an additional reduction of the communication costs by roughly a factor <span class="math">2</span>. This technique stems from <em>[BBB^{+}18]</em> and was also applied in the compressed <span class="math">\\Sigma</span>-protocols of <em>[x1]</em>. However, it is not applicable in general, i.e., for arbitrary homomorphisms <span class="math">\\Psi</span>, and has therefore been omitted in the abstract framework of <em>[x2]</em>. Here, we show how this technique can be adapted to the bilinear circuit setting. Again, and in contrast to prior works, the compact part and the non-compact part of the commitment must be treated separately.</p>

    <p class="text-gray-300">Third, the non-compact part of the commitment scheme has an “El Gamal structure”. We adapt the basic <span class="math">\\Sigma</span>-protocols, used in compressed <span class="math">\\Sigma</span>-protocol, to exploit this structure. Informally, to prove knowledge of an opening of an El Gamal commitment it is sufficient to prove knowledge of commitment randomness <span class="math">\\gamma\\in\\mathbb{Z}_{q}</span> satisfying certain properties. Altogether, this technique reduces the constant in the linear component of the communication costs from <span class="math">3</span> down to <span class="math">1</span> (the other components are logarithmic).</p>

    <p class="text-gray-300">Finally, the abstract framework of <em>[x1]</em> only considers linear relations. To handle non-linear relations, we show how the linearization techniques from the arithmetic circuit setting of <em>[x1]</em> can be adapted to the bilinear circuit setting.</p>

    <p class="text-gray-300">The communication complexity of our protocols is logarithmic in <span class="math">n_{0}</span>, <span class="math">n_{1}</span> and <span class="math">n_{2}</span>, but linear in <span class="math">n_{T}</span>. Asymptotically this is comparable to the prior work of <em>[x16]</em>. However, we consider a strictly stronger application scenario, i.e., <em>[x16]</em> only considers bilinear relations captured by a limited class of circuits. Moreover, in comparison to <em>[x16]</em>, we improve upon the <em>concrete</em> communication costs by roughly a factor <span class="math">3</span>. More precisely, we reduce the constant in the logarithmic component of the communication costs from <span class="math">16</span> down to <span class="math">6</span>, and the constant in the linear component from <span class="math">3</span> down to <span class="math">1</span>. See Section 6.3 for a detailed comparison.</p>

    <p class="text-gray-300">Another application of the commitment scheme of <em>[AFG^{+}10, x16]</em> is that it allows a prover to commit to Pedersen commitments in a pairing-based platform. This layered approach, of committing to commitments, was already suggested in <em>[AFG^{+}10]</em> and it allows a prover to commit to <span class="math">n^{2}</span> <span class="math">\\mathbb{Z}_{q}</span>-coefficients using only <span class="math">2n+1</span> public group elements, instead of the <span class="math">n^{2}+1</span> public group elements required when using Pedersen commitments directly. Replacing the Pedersen commitment scheme, in circuit ZK protocols derived from Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> or Compressed <span class="math">\\Sigma</span>-Protocol Theory <em>[x1]</em>, by this layered commitment scheme immediately gives a square root reduction in the size of the set of public parameters while leaving the logarithmic communication costs exactly the same.</p>

    <p class="text-gray-300">An additional advantage of our approach is that we can handle linear relations directly. By contrast, Lai et al. <em>[x16]</em> generalize the Bulletproof approach <em>[BCC^{+}16, BBB^{+}18]</em> where the pivotal protocol handles a specific non-linear inner-product relation. Applying this approach to a linear relation requires a cumbersome approach of capturing this linear relation by a set of non-linear inner-product constraints, leading to unnecessarily complicated protocols.</p>

    <p class="text-gray-300">As an application of our compressed <span class="math">\\Sigma</span>-protocol for proving linear relations, we construct a transparent <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature scheme (TSS) with threshold signatures that are <span class="math">O(\\kappa\\log(n))</span> bits, where <span class="math">\\kappa</span> is the security parameter. Recall that a TSS enables any set of at least <span class="math">k</span> players, in a group of <span class="math">n</span>, to issue a “threshold” signature on a message <span class="math">m</span>, but no subset of less than <span class="math">k</span> players is able to issue one. A TSS is called <em>transparent</em> if it does not require a trusted setup phase, i.e., all public parameters are random coins.</p>

    <p class="text-gray-300">Given recent advances in efficient circuit zero-knowledge, an obvious solution is to construct a threshold signature as a proof of knowledge attesting the knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> signatures. With the appropriate ZK protocol this would immediately result in a transparent TSS with sublinear size threshold signatures. However, this approach requires an inefficient reduction from the corresponding threshold signature relation to a relation defined over an arithmetic circuit. More precisely, the arithmetic circuits capturing these relations are typically large.</p>

    <p class="text-gray-300">For this reason, we follow a more direct approach avoiding this inefficient reduction. Namely, we append the BLS signature scheme <em>[x1, x2]</em> with a <span class="math">k</span>-aggregation algorithm. The BLS signature scheme is defined over a bilinear group. In particular, the BLS verification algorithms naturally fit with our compressed <span class="math">\\Sigma</span>-protocols for relations defined over bilinear groups. A key feature of this signature scheme is that its signing algorithm does not contain the evaluation of a hash function. This would namely require the hash function to be expressed in terms of a (typically large) bilinear circuit. To derive the required threshold functionality, we use an appropriated adaptation of <span class="math">k</span>-out-of-<span class="math">n</span> proofs of partial knowledge from a recent work <em>[x1]</em>.</p>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocols are interactive and can be made non-interactive by the Fiat-Shamir transform <em>[x10]</em>. In general, the Fiat-Shamir transformation of a <span class="math">(2\\mu+1)</span>-move protocol increases the knowledge error from <span class="math">\\kappa</span> to <span class="math">Q^{\\mu}\\cdot\\kappa</span>, where <span class="math">Q</span> is the number of random oracle queries the non-interactive prover is allowed to make, i.e., the security loss is exponential in the number of rounds. However, for <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocols such as ours, it is believed that this loss is actually constant in the number of rounds. This claim was recently proven in the algebraic group model <em>[x16]</em>.</p>

    <p class="text-gray-300">The non-interactive proofs contain precisely the messages sent from the prover to the verifier. Hence, the logarithmic proof size is inherited by the logarithmic communication complexity of the compressed <span class="math">\\Sigma</span>-protocol. More precisely, a <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature contains <span class="math">4\\left\\lceil\\log_{2}(n)\\right\\rceil+3</span> <span class="math">\\mathbb{G}_{T}</span>-elements, <span class="math">1</span> <span class="math">\\mathbb{G}_{1}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{Z}_{q}</span>-element.</p>

    <p class="text-gray-300">The <span class="math">k</span>-aggregation algorithm can be evaluated by any party with input at least <span class="math">k</span> valid signatures from distinct signers. Besides the signatures, the <span class="math">k</span>-aggregation algorithm only takes public input values. Moreover, the threshold <span class="math">k</span> can be chosen at aggregation time independent of the set-up phase. By contrast, Shoup’s construction <em>[x24]</em> requires a different trusted setup phase for every threshold <span class="math">k</span>. Since the compressed <span class="math">\\Sigma</span>-protocol is zero-knowledge, an additional property of our TSS is that a threshold signature hides the <span class="math">k</span>-subset of signers <span class="math">\\mathcal{S}</span>. Our TSS does not require a trusted setup and is therefore transparent. More precisely, the players can generate their own public-private key-pairs and the <span class="math">\\Sigma</span>-protocol only requires an unstructured public random string defined by the public parameters of the commitment scheme.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">Zero-Knowledge Proof Systems. Groth and Sahai <em>[x11]</em> were the first to consider zero-knowledge proof systems for relations defined over bilinear groups directly. In contrast to more standard indirect approaches, their work avoids inefficient reductions to arithmetic circuit relations. Bilinear groups have found applications in many areas of cryptography. For instance, in digital signatures, identity based encryption and efficient zero-knowledge proof systems. For this reason many relevant relations are naturally defined over bilinear groups. The goal is not only to achieve efficiency, but also modularity in the design of cryptographic protocols.</p>

    <p class="text-gray-300">A drawback of the Groth-Sahai proof system is that its proof sizes are linear in the size of the statements. By contrast, Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> are practically efficient DL-based proof systems for arithmetic circuit relations with logarithmic proof sizes. Their main building block is an efficient protocol for proving a specific non-linear inner-product relation. Arbitrary relations captured by an arithmetic circuit are reduced to a set of inner-product constraints. Lai et al. <em>[x20]</em> adapted the techniques from Bulletproofs to the bilinear circuit model achieving a communication-efficient ZKP system for relations defined over bilinear circuits. More precisely, the communication complexity is logarithmic in the number of <span class="math">\\mathbb{Z}_{q}</span>, <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> inputs, but linear in the number of <span class="math">\\mathbb{G}_{T}</span> inputs. They first reduce the bilinear circuit relation to a set of inner-products constraints, and subsequently describe protocols for proving various inner-product relations. The work of <em>[x3]</em> improves the efficiency for a specific subset of bilinear inner-product relations. Hence, although these approaches avoid reductions to arithmetic circuits, they do rely on the reduction to a set of inner-product constraints.</p>

    <p class="text-gray-300">In <em>[x1]</em>, an alternative approach for arithmetic circuit relations is described. Their pivotal protocol is a basic <span class="math">\\Sigma</span>-protocol for proving linear relations. They show how to compress the communication complexity down to logarithmic and how to handle non-linearities in arbitrary arithmetic circuit relations. This approach is compatible with standard <span class="math">\\Sigma</span>-protocol theory and avoids the need for reinventing cryptographic protocol design around non-linear inner-product relations. Here, we generalize compressed <span class="math">\\Sigma</span>-protocols to the bilinear circuit model.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Threshold Signature Schemes.</h4>

    <p class="text-gray-300">Shoup’s TSS <em>[x24]</em> already achieves threshold signatures of constant size. However, his approach, and all other approaches with threshold signature sizes sub-linear in <span class="math">k</span> and <span class="math">n</span> are not transparent <em>[x11, x12, x13, x14, x15, x16, x17, x18]</em>. These works require either an explicit trusted dealer, or they have implemented this trusted dealer by an MPC (or other interactive) protocol that is evaluated before messages are signed. At first glance it might seem that <em>[x11]</em> also achieves a transparent setup. However, in their protocol the <span class="math">k</span> signing players first have to run an interactive protocol before they can generate threshold signatures. This interactive protocol has to be evaluated before players can produce their inputs to the aggregation algorithm, therefore we consider this as a trusted setup.</p>

    <p class="text-gray-300">The standard approach, introduced by Desmedt and Frankel <em>[x6]</em>, works by secret sharing the private key amongst the <span class="math">n</span> players. This requires the private key to be generated by either a trusted dealer or an MPC protocol, i.e., this approach has a trusted set-up and is not transparent. Moreover, in contrast to our scheme, the threshold <span class="math">k</span> should be fixed during the setup phase.</p>

    <p class="text-gray-300">By contrast, all known transparent TSSs have size at least linear in the threshold <span class="math">k</span>. Besides the naive implementation of simply outputting <span class="math">k</span> valid signatures, there is also the following approach used by the decentralized transaction system Libra <em>[x16]</em> and by <em>[NRS^{+}20]</em>. Every player generates its own public-private key-pair. A threshold signature is computed as the sum of <span class="math">k</span> individual BLS signatures, and it can be verified by running the BLS verification algorithm using the sum of the public keys of the <span class="math">k</span> signers. Hence, the threshold signature should contain a list of the <span class="math">k</span> signers, i.e., it is of size <span class="math">O(n)</span> or <span class="math">O(k\\log(n))</span> depending on the exact encoding of this list. Moreover, these threshold signatures clearly do not hide the <span class="math">k</span>-subset of signers. By contrast, Haque et al. <em>[x13]</em> construct a transparent TSS that does hide the <span class="math">k</span>-subset of signers. However, while individual signature sizes are logarithmic in <span class="math">n</span>, the threshold signatures are linear in the threshold <span class="math">k</span>.</p>

    <p class="text-gray-300">Finally, a recent work <em>[x2]</em> presents a different variant of a TSS, which they call succinctly reconstructed distributed signatures (SRDS). Their SRDS is most similar to the obvious approach of reducing the problem to an arithmetic circuit relation. It indeed applies a general (unspecified) SNARK in a black-box manner to achieve <span class="math">O(\\mathsf{polylog}(n))</span>-size signatures. However, their SRDS can only tolerate up to <span class="math">n/3</span> corruptions.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Organization of the Paper</h3>

    <p class="text-gray-300">The remainder of the paper is organized as follows. In Section 2, we recall basic notation and definitions regarding bilinear groups and zero-knowledge proof systems. In Section 3, we define a number of commitment schemes generalizing Pedersen vector commitments. In Section 4, we describe a compressed <span class="math">\\Sigma</span>-protocol for proving linear relations about committed vectors, with logarithmic communication complexity. In Section 5, as an application of our compressed <span class="math">\\Sigma</span>-protocol, we construct a novel threshold signature scheme. In Section 6, we describe our linearization strategy for handling non-linear relations.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Bilinear Groups</h3>

    <p class="text-gray-300">We consider the ring <span class="math">\\mathbb{Z}_{q}\\cong\\mathbb{Z}/(q\\mathbb{Z})</span> for a prime <span class="math">q</span>. Moreover, we let <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> be groups of prime order <span class="math">q</span> supporting discrete-log (DL) based cryptography, hence <span class="math">\\log(q)=O(\\kappa)</span> for security parameter <span class="math">\\kappa</span>. Some</p>

    <p class="text-gray-300">properties of commitment schemes used in this work rely on the stronger Decisional Diffie-Hellman (DDH) assumption. Therefore, we assume the DDH assumption to hold in all groups.</p>

    <p class="text-gray-300">We write the group operations additively. Clearly, all groups <span class="math">\\mathbb{G}_{i}</span> are <span class="math">\\mathbb{Z}_{q}</span>-modules and, for all <span class="math">a\\in\\mathbb{Z}_{q}</span> and <span class="math">g\\in\\mathbb{G}_{i}</span>, the product <span class="math">ag\\in\\mathbb{G}_{i}</span> is well-defined. We write vectors in boldface and inner-products are defined naturally, i.e., for all <span class="math">\\mathbf{a}=(a_{1},\\ldots,a_{n})\\in\\mathbb{Z}_{q}^{n}</span> and <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{n})\\in\\mathbb{G}_{i}^{n}</span> we define <span class="math">\\langle\\mathbf{a},\\mathbf{g}\\rangle:=\\sum_{i=1}^{n}a_{i}g_{i}</span>.</p>

    <p class="text-gray-300">Let <span class="math">G\\in\\mathbb{G}_{1}</span> and <span class="math">H\\in\\mathbb{G}_{2}</span> be generators and let <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> be a non-trivial bilinear mapping, i.e., <span class="math">e</span> is a pairing such that <span class="math">e(G,H)</span> generates <span class="math">\\mathbb{G}_{T}</span>. Then, a tuple <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span> defines a bilinear group. For vectors <span class="math">\\mathbf{G}\\in\\mathbb{G}_{1}^{n}</span> and <span class="math">\\mathbf{H}\\in\\mathbb{G}_{2}^{n}</span> the following inner-product is defined <span class="math">e(\\mathbf{G},\\mathbf{H}):=\\sum_{i=1}^{n}e(G_{i},H_{i})</span>.</p>

    <p class="text-gray-300">We say that the Symmetrical External Diffie-Hellman (SXDH) holds in a bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>, if the DDH assumption holds in both <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> <em>[x1]</em>. By the above assumption that the DDH assumption holds in all <span class="math">\\mathbb{G}_{i}</span>, it follows that the SXDH assumption holds for all bilinear groups that are considered in this work. The SXDH assumption implies that there is no efficiently computable isomorphism from <span class="math">\\mathbb{G}_{1}</span> to <span class="math">\\mathbb{G}_{2}</span> or from <span class="math">\\mathbb{G}_{2}</span> to <span class="math">\\mathbb{G}_{1}</span> <em>[x2]</em>, i.e., we only consider bilinear groups of Type III <em>[x11]</em>.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Proofs of Knowledge</h3>

    <p class="text-gray-300">We recall some standard notions regarding Proofs of Knowledge (PoKs) following the notation and definitions of <em>[x1, x2]</em>. A relation <span class="math">R</span> is a set of statement-witness pairs <span class="math">(x;w)</span>. A <span class="math">\\mu</span>-move protocol <span class="math">\\Pi</span> for relation <span class="math">R</span> is an interactive protocol with <span class="math">\\mu</span> communication rounds between a prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. It allows <span class="math">\\mathcal{P}</span> to convince <span class="math">\\mathcal{V}</span> that it knows a witness <span class="math">w</span> for statement <span class="math">x</span>, i.e., <span class="math">(x;w)\\in R</span>. Protocol <span class="math">\\Pi</span> is also called an interactive proof for relation <span class="math">R</span>. The statement <span class="math">x</span> is public input for both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> and the witness <span class="math">w</span> is private input only for <span class="math">\\mathcal{P}</span>. In our protocol descriptions this is written as <span class="math">\\textsc{Input}(x;w)</span>, i.e., the public and private input are separated by a semicolon. As the output of the protocol <span class="math">\\mathcal{V}</span> either accepts or rejects <span class="math">\\mathcal{P}</span>’s claim. The messages sent between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> in one protocol execution are also referred to as a conversation or transcript. If <span class="math">\\mathcal{V}</span> accepts the associated transcript, it is called accepting.</p>

    <p class="text-gray-300">An interactive proof is said to be public coin, if all messages from <span class="math">\\mathcal{V}</span> are chosen uniformly at random and independent from prior messages. Interactive protocols that are public-coin can be made non-interactive by the Fiat-Shamir transformation <em>[x10]</em>, as proven in <em>[x3]</em>, without increasing the communication costs from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span>. All interactive proofs in this work are public-coin.</p>

    <p class="text-gray-300">Let us now describe some desirable (security) properties.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 1 (Completeness)</h6>

    <p class="text-gray-300">An interactive proof <span class="math">\\Pi</span> is called perfectly complete, if on any input <span class="math">(x;w)\\in R</span>, the verifier <span class="math">\\mathcal{V}</span> always accepts.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2 (Knowledge Soundness)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An interactive proof <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> is said to be knowledge sound with knowledge error <span class="math">\\kappa:\\mathbb{N}\\to[0,1)</span>, if there exists a polynomial <span class="math">q:\\mathbb{N}\\to\\mathbb{N}</span> and an algorithm <span class="math">\\chi</span> (extractor) with the following properties. For each (potentially dishonest) PPT prover <span class="math">\\mathcal{P}^{\\star}</span>, for each <span class="math">x\\in\\{0,1\\}^{\\star}</span>, whenever <span class="math">(\\mathcal{P}^{\\ast},\\mathcal{V})(x)</span> outputs accept with probability $\\epsilon(x)\\geq\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, the extractor </span>\\chi<span class="math">, given input </span>x<span class="math"> and rewindable oracle access to the </span>\\mathcal{P}^{\\star}<span class="math">, runs in expected polynomial time and successfully outputs a witness </span>w<span class="math"> for statement </span>x<span class="math"> with probability at least </span>(\\epsilon(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))/q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 3 (Proof/Argument of Knowledge)</h6>

    <p class="text-gray-300">An interactive proof that is both complete and knowledge sound is said to be a Proof or Knowledge (PoK). PoKs for which knowledge soundness only holds under computational assumptions are also referred to as Arguments of Knowledge.</p>

    <p class="text-gray-300">Witness extended emulation <em>[x14]</em> gives an alternative notion for knowledge soundness, sufficient for most practical scenarios, and it is known to be implied by knowledge soundness <em>[x14]</em>. For details we refer to <em>[x14, x12, x2]</em>.</p>

    <p class="text-gray-300">We now recall a generalization of the special-soundness property. Special soundness is in general easier to handle than knowledge soundness. We first introduce the notion of a tree of accepting transcripts.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 4 (Tree of Accepting Transcripts).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a <span class="math">(2\\mu+1)</span>-move protocol. A <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts for protocol <span class="math">\\Pi</span> is a set of <span class="math">\\prod_{i=1}^{\\mu}k_{i}</span> accepting transcripts that are arranged in the following tree structure. The nodes in this tree correspond to the prover’s messages and the edges correspond to the verifier’s challenges. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 5 (Special Soundness).</h6>

    <p class="text-gray-300">A <span class="math">(2\\mu+1)</span>-move protocol is said to be <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-special-sound, if there exists an efficient algorithm that on input a <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-tree of accepting transcripts for statement <span class="math">x</span>, outputs a witness <span class="math">w</span> for <span class="math">x</span>. A <span class="math">3</span>-move protocol is said to be special-sound if it is <span class="math">2</span>-special-sound.</p>

    <p class="text-gray-300">Recently, it was shown that <span class="math">(k_{1},k_{2},\\ldots,k_{\\mu})</span>-special-soundness <em>tightly</em> implies knowledge soundness <em>[x1]</em>. Therefore, protocols that are complete and special-sound are also referred to as proofs of knowledge (PoKs).</p>

    <p class="text-gray-300">In some protocols there are rounds in which <span class="math">\\mathcal{V}</span> sends multiple challenges per round, i.e., <span class="math">\\mu</span> challenges are sent in less than <span class="math">2\\mu+1</span> rounds. For these protocols we also consider the <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special-soundness property. However, in this case a tree of accepting transcripts contains nodes that do not correspond to a message sent from <span class="math">\\mathcal{P}</span> to <span class="math">\\mathcal{V}</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 6 (Honest Verifier Zero-Knowledge (HVZK)).</h6>

    <p class="text-gray-300">An interactive proof <span class="math">\\Pi</span> is said to be honest verifier zero-knowledge (HVZK), if there exists a PPT simulator that, on input a statement <span class="math">x</span> that admits a witness <span class="math">w</span>, outputs an accepting transcript, such that simulated transcripts follow exactly the same distribution as transcripts between an honest prover and an honest verifier. If the simulator proceeds by first sampling the random challenges, the protocol is said to be special honest verifier zero-knowledge (SHVZK).</p>

    <p class="text-gray-300">Finally, we recall that two protocols, <span class="math">\\Pi_{a}</span> for relation <span class="math">R_{a}</span> and <span class="math">\\Pi_{b}</span> for relation <span class="math">R_{b}</span>, are said to be <em>composable</em>, if the final message of protocol <span class="math">\\Pi_{a}</span> contains a witness for relation <span class="math">R_{b}</span> <em>[x2]</em>. In this case, the composition <span class="math">\\Pi_{b}\\diamond\\Pi_{a}</span> runs Protocol <span class="math">\\Pi_{a}</span> but replaces the witness for relation <span class="math">R_{b}</span> in its final message by an appropriate instantiation of Protocol <span class="math">\\Pi_{b}</span>. If protocol <span class="math">\\Pi_{a}</span> is <span class="math">(k_{1},\\ldots,k_{\\mu_{1}})</span>-special-sound and protocol <span class="math">\\Pi_{b}</span> is <span class="math">(k_{1}^{\\prime},\\ldots,k_{\\mu_{2}}^{\\prime})</span>-special-sound, then the composition <span class="math">\\Pi_{b}\\diamond\\Pi_{a}</span> is easily seen to be <span class="math">(k_{1},\\ldots,k_{\\mu_{1}},k_{1}^{\\prime},\\ldots,k_{\\mu_{2}}^{\\prime})</span>-special-sound.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Commitment Schemes</h2>

    <p class="text-gray-300">Compressed <span class="math">\\Sigma</span>-protocols allow a prover to prove that a committed vector satisfies some public constraint. These protocols crucially depend on the homomorphic properties of the commitment scheme. In this section, we describe a number of homomorphic commitment schemes for committing to vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> with coefficients in a bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>.</p>

    <p class="text-gray-300">First, the Pedersen vector commitment scheme <em>[x24]</em> considers the case <span class="math">n_{1}=n_{2}=n_{T}=0</span>, i.e., the committed vector is a <span class="math">\\mathbb{Z}_{q}</span>-vector. Recall that group operations are written additively.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 7 (Pedersen Vector Commitment <em>[x24]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{G}</span> be an Abelian group of prime order <span class="math">q</span>. Pedersen vector commitments to vectors <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n}</span> are defined by the following setup and commitment phase:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">\\mathbf{g}=(g_{1},\\ldots,g_{n})\\leftarrow_{R}\\mathbb{G}^{n}</span>, <span class="math">h\\leftarrow_{R}\\mathbb{G}</span>.</li>

      <li>Commit: <span class="math">\\textsc{Com}:\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}\\rightarrow\\mathbb{G},\\quad(\\mathbf{x},\\gamma)\\mapsto h\\gamma+\\langle\\mathbf{g},\\mathbf{x}\\rangle</span>.</li>

    </ul>

    <p class="text-gray-300">Abe et al. <em>[AFG^{+}10]</em> constructed a similar commitment scheme that works with bilinear groups <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span> and allows a prover to commit to vectors of group elements <span class="math">\\mathbf{x}\\in\\mathbb{G}_{1}^{n}</span>. Lai, Malavolta and Ronge <em>[x21]</em> showed how a variation of this commitment scheme can be generalized to allow a prover to commit to vectors <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}</span>. The commitment scheme is perfectly hiding and computationally binding under the DDH assumption in <span class="math">\\mathbb{G}_{2}</span>. Analogously, this construction results in a commitment scheme for vectors <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{2}^{n_{2}}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 8 (Commitment to <span class="math">(\\mathbb{Z}_{q},\\mathbb{G}_{1})</span>-vectors <em>[AFG^{+}10, x21]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span> be a bilinear group and let <span class="math">n_{0},n_{1}\\geq 0</span>. The following setup and commitment phase define a commitment scheme for vectors in <span class="math">\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">\\mathbf{g} = (g_1, \\ldots, g_{n_0}) \\leftarrow_R \\mathbb{G}_T^{n_0}</span>, <span class="math">h \\leftarrow_R \\mathbb{G}_T</span>, <span class="math">\\mathbf{H} = (H_1, \\ldots, H_{n_1}) \\leftarrow_R \\mathbb{G}_2^{n_1}</span>.</li>

      <li>Commit: <span class="math">\\mathrm{COM} : \\mathbb{Z}_q^{n_0} \\times \\mathbb{G}_1^{n_1} \\times \\mathbb{Z}_q \\to \\mathbb{G}_T</span>, <span class="math">(\\mathbf{x}, \\mathbf{y}, \\gamma) \\mapsto h\\gamma + \\langle \\mathbf{g}, \\mathbf{x} \\rangle + e(\\mathbf{y}, \\mathbf{H})</span>.</li>

    </ul>

    <p class="text-gray-300">Remark 1. As an application of the commitment scheme of Definition 8, Abe et al. [AFG⁺10] mention commitments to Pedersen vector commitments. A commitment to <span class="math">n</span> <span class="math">n</span>-dimensional Pedersen vector commitments is namely a commitment to an <span class="math">n^2</span>-dimensional <span class="math">\\mathbb{Z}_q</span>-vector. This two-tiered commitment scheme only requires <span class="math">2n + 1</span> public group elements. By contrast, Pedersen's commitment scheme requires <span class="math">n^2 + 1</span> public group elements to commit to an <span class="math">n^2</span>-dimensional <span class="math">\\mathbb{Z}_q</span>-vector. Replacing the Pedersen vector commitment scheme in, for example, [BCC⁺16, BBB⁺18, AC20] by this two-tiered commitment scheme results in arithmetic circuit ZK protocols with exactly the same communication complexity, but with a square root improvement in the size of the public parameters.</p>

    <p class="text-gray-300">In addition, Lai et al. [LMR19] show how this approach can be extended to construct a commitment scheme for vectors with coefficients in <span class="math">\\mathbb{Z}_q</span>, <span class="math">\\mathbb{G}_1</span> and <span class="math">\\mathbb{G}_2</span>. In contrast to the previous commitments, a commitment to a vector <span class="math">\\mathbf{x} \\in \\mathbb{Z}_q^{n_0} \\times \\mathbb{G}_1^{n_1} \\times \\mathbb{G}_2^{n_2}</span> consists of two target group elements. Informally, the reason is that, with high probability, <span class="math">(S, -R) \\in \\mathbb{G}_1 \\times \\mathbb{G}_2</span> is a non-trivial solution for the equation <span class="math">e(x,R) + e(S,y) = 1</span>, where <span class="math">(S,R) \\in \\mathbb{G}_1 \\times \\mathbb{G}_2</span> is sampled uniformly at random. Such a solution would break the binding property of the naive generalization in which commitments consist of only one target group element. However, with high probability, there does not exist a solution <span class="math">(x,y) \\in \\mathbb{G}_1 \\times \\mathbb{G}_2</span> to the system of equations <span class="math">e(x,R_1) + e(S_1,y) = 1</span> and <span class="math">e(x,R_2) + e(S_2,y) = 1</span>, where <span class="math">(S_1,R_1), (S_2,R_2) \\in \\mathbb{G}_1 \\times \\mathbb{G}_2</span> are sampled uniformly at random. For this reason, the commitments consist of two target group elements and breaking their binding property can be reduced to solving a similar system of equations. The resulting commitment scheme is described in Definition 9. It is computationally hiding under the DDH assumption in <span class="math">\\mathbb{G}_T</span>, and it is computationally binding under the SXDH assumption [LMR19]. The scheme can be made perfectly hiding by introducing an additional randomizer <span class="math">\\gamma_2 \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">Definition 9 (Commitment to <span class="math">(\\mathbb{Z}_q,\\mathbb{G}_1,\\mathbb{G}_2)</span>-vectors [LMR19]). Let <span class="math">(q,\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T,e,G,H)</span> be a bilinear group and let <span class="math">n_0,n_1,n_2\\geq 0</span>. The following setup and commitment phase define a commitment scheme for vectors in <span class="math">\\mathbb{Z}_q^{n_0}\\times \\mathbb{G}_1^{n_1}\\times \\mathbb{G}_2^{n_2}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">\\mathbf{g} \\leftarrow_R \\mathbb{G}_T^{2 \\times n_0}</span>, <span class="math">h \\leftarrow_R \\mathbb{G}_T^2</span>, <span class="math">\\mathbf{H} \\leftarrow_R \\mathbb{G}_2^{2 \\times n_1}</span>, <span class="math">\\mathbf{G} \\leftarrow_R \\mathbb{G}_1^{2 \\times n_2}</span>.</li>

      <li>Commit: <span class="math">\\mathrm{COM}_1 : \\mathbb{Z}_q^{n_0} \\times \\mathbb{G}_1^{n_1} \\times \\mathbb{G}_2^{n_2} \\times \\mathbb{Z}_q \\to \\mathbb{G}_T^2</span>, <span class="math">(\\mathbf{x}, \\mathbf{y}, \\mathbf{z}, \\gamma) \\mapsto h\\gamma + \\langle \\mathbf{g}, \\mathbf{x} \\rangle + e(\\mathbf{y}, \\mathbf{H}) + e(\\mathbf{G}, \\mathbf{z})</span>, where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">h \\gamma + \\langle \\mathbf {g}, \\mathbf {x} \\rangle + e (\\mathbf {y}, \\mathbf {H}) + e (\\mathbf {G}, \\mathbf {z}) := \\binom {h _ {1} \\gamma + \\langle \\mathbf {g} _ {1}, \\mathbf {x} \\rangle + e (\\mathbf {y}, \\mathbf {H} _ {1}) + e (\\mathbf {G} _ {1}, \\mathbf {z})} {h _ {2} \\gamma + \\langle \\mathbf {g} _ {2}, \\mathbf {x} \\rangle + e (\\mathbf {y}, \\mathbf {H} _ {2}) + e (\\mathbf {G} _ {2}, \\mathbf {z})}. \\tag {1}</span></div>

    <p class="text-gray-300">The aforementioned commitment schemes do not allow a prover to commit to elements of the target group <span class="math">\\mathbb{G}_T</span> of the bilinear pairing <span class="math">e:\\mathbb{G}_1\\times \\mathbb{G}_2\\to \\mathbb{G}_T</span>. For this reason, we introduce the homomorphic commitment scheme of Definition 10. This scheme is based on the El Gamal encryption scheme [Gam84]. The commitment scheme is unconditionally binding and hiding under the DDH assumption in <span class="math">\\mathbb{G}_T</span>.</p>

    <p class="text-gray-300">Definition 10 (Commitment to <span class="math">(\\mathbb{G}_T)</span>-vectors [Gam84, LMR19]). Let <span class="math">\\mathbb{G}_T</span> be an Abelian group of prime order <span class="math">q</span>. The following setup and commitment phase define a commitment scheme for vectors in <span class="math">\\mathbb{G}_T^{n_T}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">\\mathbf{g} \\leftarrow_R \\mathbb{G}_T^{n_T}</span>, <span class="math">h \\leftarrow_R \\mathbb{G}_T</span>.</li>

      <li>Commit: <span class="math">\\mathrm{COM}_2 : \\mathbb{G}_T^{n_T} \\times \\mathbb{Z}_q \\to \\mathbb{G}_T^{n_T + 1}</span>, <span class="math">(\\mathbf{x}, \\gamma) \\mapsto \\binom{h\\gamma}{\\mathbf{g}\\gamma + \\mathbf{x}}</span>.</li>

    </ul>

    <p class="text-gray-300">Note that, in contrast to the schemes of Definitions 7, 8 and 9, this commitment scheme is not compact, i.e., a commitment to a vector <span class="math">\\mathbf{x} \\in \\mathbb{G}_T^{n_T}</span> contains <span class="math">n_T + 1</span> group elements. For this reason, the compression techniques applicable to compact commitments are of no benefit for commitments to <span class="math">\\mathbb{G}_T</span>-vectors, and we will treat commitments to target group elements separately.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Altogether, for a bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>, we obtain the following commitment scheme:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Com}:\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}\\times\\mathbb{Z}_{q}^{2}\\to\\mathbb{G}_{T}^{n_{T}+3},\\quad(\\mathbf{x},\\mathbf{y},\\gamma_{1},\\gamma_{2})\\mapsto\\binom{\\mathrm{Com}_{1}(\\mathbf{x};\\gamma_{1})}{\\mathrm{Com}_{2}(\\mathbf{y};\\gamma_{2})},</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}</span>, <span class="math">\\mathbf{y}\\in\\mathbb{G}_{T}^{n_{T}}</span>, <span class="math">\\mathrm{Com}_{1}</span> is the commitment scheme from Definition 9, and <span class="math">\\mathrm{Com}_{2}</span> is the commitment scheme from Definition 10.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4 Compressed <span class="math">\\Sigma</span>-Protocol for Opening Homomorphisms</h2>

    <p class="text-gray-300">In this section, we describe a compressed <span class="math">\\Sigma</span>-protocol for proving that a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> satisfies a linear constraint <span class="math">f(\\mathbf{x})=y</span> captured by an arbitrary homomorphism <span class="math">f</span>. We also say that this protocol allows a prover to open a homomorphism <span class="math">f</span>.</p>

    <p class="text-gray-300">We present our protocols in an abstract language. More precisely, let</p>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathbb{H}_{1}\\times\\mathbb{H}_{2}\\to\\mathbb{H},\\quad(x_{1},x_{2})\\to\\Psi(x_{1},x_{2}),</span></p>

    <p class="text-gray-300">be a homomorphism between <span class="math">\\mathbb{Z}_{q}</span>-modules. We construct a compressed <span class="math">\\Sigma</span>-protocol for proving knowledge of a pre-image <span class="math">x=(x_{1},x_{2})</span> of <span class="math">y=\\Psi(x)</span>. Instantiating this abstract protocol with <span class="math">\\mathbb{H}_{1}=\\mathbb{Z}_{q}^{n_{0}+1}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}</span>, <span class="math">\\mathbb{H}_{2}=\\mathbb{Z}_{q}\\times\\mathbb{G}_{T}^{n_{T}}</span> and <span class="math">\\Psi=(\\mathrm{Com}_{1},\\mathrm{Com}_{2},f)</span>, where <span class="math">f</span> is understood to ignore the commitment randomness in <span class="math">x_{1}</span> and <span class="math">x_{2}</span>, results in exactly the desired functionality.</p>

    <p class="text-gray-300">Prior works <em>[x1, x2]</em> have considered similar abstractions of compressed <span class="math">\\Sigma</span>-protocols. However, we adapt these approaches in order to be able to treat the compact and non-compact parts of the commitment scheme separately. More precisely, we explicitly consider homomorphism where the domain is a Cartesian product <span class="math">\\mathbb{H}_{1}\\times\\mathbb{H}_{2}</span> and apply the compression techniques only to the <span class="math">\\mathbb{H}_{1}</span>-part.</p>

    <p class="text-gray-300">In Section 4.1, we construct a basic <span class="math">\\Sigma</span>-protocol for proving knowledge of a <span class="math">\\Psi</span>-pre-image. In Section 4.2, we describe the compression mechanism that reduces the communication complexity of a <span class="math">\\Sigma</span>-protocol. In Section 4.3, we introduce the compressed <span class="math">\\Sigma</span>-protocol for our abstract problem. This protocol is the recursive composition of the <span class="math">\\Sigma</span>-protocol and the compression mechanism. In Section 4.4 and Section 4.5, we describe efficiency improvements applicable to the special case where the homomorphism <span class="math">\\Psi</span> is defined over a bilinear group. Finally, in Section 4.6, we compose the different building blocks and describe our compressed <span class="math">\\Sigma</span>-protocol for opening homomorphisms on a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span>.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 Basic <span class="math">\\Sigma</span>-Protocol</h3>

    <p class="text-gray-300">Protocol 0, denoted by <span class="math">\\Pi_{0}</span>, is a basic <span class="math">\\Sigma</span>-protocol for proving knowledge of a pre-image of a homomorphism <span class="math">\\Psi\\colon\\mathbb{H}_{1}\\times\\mathbb{H}_{2}\\to\\mathbb{H}</span>. More precisely, it is a <span class="math">\\Sigma</span>-protocol for the following relation</p>

    <p class="text-gray-300"><span class="math">R_{\\Psi}=\\big{\\{}\\,(y;x):y=\\Psi(x)\\big{\\}}.</span> (3)</p>

    <p class="text-gray-300">Protocol 0 follows the generic design for <span class="math">q</span>-one-way homomorphisms <em>[x5, x6]</em> and its main properties are summarized in Theorem 1. Note that this <span class="math">\\Sigma</span>-protocol does not yet rely on the special structure of the homomorphism <span class="math">\\Psi</span>, i.e., it does not rely on the fact that the domain of <span class="math">\\Psi</span> is a Cartesian product <span class="math">\\mathbb{H}_{1}\\times\\mathbb{H}_{2}</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 1 (Homomorphism Evaluation).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{0}</span> is a <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{\\Psi}</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally special-sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">1</span> <span class="math">\\mathbb{H}</span>-element, 1 <span class="math">\\mathbb{H}_{1}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{H}_{2}</span>-element.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> <span class="math">\\mathbb{Z}_{q}</span>-element.</li>

    </ul>

    <p class="text-gray-300">Protocol 0  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0</span>  for relation  <span class="math">R_{\\Psi}</span> <span class="math">\\Sigma</span> -protocol for proving knowledge of the pre-image of a  <span class="math">\\mathbb{Z}_q</span> -module homomorphism  <span class="math">\\Psi \\colon \\mathbb{H}_1 \\times \\mathbb{H}_2 \\to \\mathbb{H}</span> .</p>

    <p class="text-gray-300">|  INPUT(y;x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  y = Ψ(x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  r←R H1 × H2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t = Ψ(r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | c←R Zq  |</p>

    <p class="text-gray-300">|  z = cx + r |   |</p>

    <p class="text-gray-300">|   | z → Ψ(z) = cy + t  |</p>

    <p class="text-gray-300">In [AC20], it was observed that the final message  <span class="math">z</span>  of  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0</span>  is actually a witness for the statement  <span class="math">cy + t</span>  of relation  <span class="math">R_{\\Psi}</span> , i.e., the final message of this  <span class="math">\\Sigma</span> -protocol constitutes a trivial proof of knowledge for relation  <span class="math">R_{\\Psi}</span>  in which the witness is simply revealed. Moreover, replacing this trivial PoK by a PoK with smaller communication costs would improve the communication-efficiency of the overall protocol. Note that the alternative protocol does not have to be zero-knowledge, because the trivial PoK clearly is not.</p>

    <p class="text-gray-300">In order to construct a more efficient PoK for relation  <span class="math">R_{\\Psi}</span> , let us assume that  <span class="math">\\mathbb{H}_1</span>  is the Cartesian product of a group  <span class="math">\\mathbb{H}_0</span>  with itself, i.e.,  <span class="math">\\mathbb{H}_1 = \\mathbb{H}_0 \\times \\mathbb{H}_0</span> . In this case, for all  <span class="math">x_1 \\in \\mathbb{H}_1</span> , we can write  <span class="math">x_1 = (x_1^L, x_1^R)</span>  with  <span class="math">x_1^L, x_1^R \\in \\mathbb{H}_0</span> .</p>

    <p class="text-gray-300">The compression mechanism is a proof of knowledge for relation  <span class="math">R_{\\Psi}</span>  with communication costs smaller than the communication-costs of the trivial PoK. The main idea of this compression mechanism is that, after receiving a challenge  <span class="math">c</span>  from the verifier, the prover folds the secret element  <span class="math">x_{1} \\in \\mathbb{H}_{1}</span>  in half by computing the response  <span class="math">z = x_{1}^{L} + cx_{1}^{R} \\in \\mathbb{H}_{0}</span> . Note that  <span class="math">z \\in \\mathbb{H}_{0}</span>  and  <span class="math">x_{1} \\in \\mathbb{H}_{1} = \\mathbb{H}_{0} \\times \\mathbb{H}_{0}</span> , so this folding procedure indeed reduces the size of the witness. The cost of this reduction is that the prover has to send two "cross-terms"  <span class="math">a = \\varPsi((0,x_1^L),0)</span>  and  <span class="math">b = \\varPsi_{1}((x_{1}^{R},0),0)</span>  to the verifier before receiving the challenge.</p>

    <p class="text-gray-300">This compression mechanism is an adaptation of the compression mechanisms of [AC20, ACF21]. The difference with these prior works is that here the folding procedure is only applied on the first part of the secret witness, i.e., the  <span class="math">\\mathbb{H}_1</span> -part. The compression mechanism, denoted by  <span class="math">\\varPi_1</span> , is described in Protocol 1 and its main properties are summarized in Theorem 2.</p>

    <p class="text-gray-300">Protocol 1 Compression Mechanism  <span class="math">\\varPi_{1}</span>  for relation  <span class="math">R_{\\Psi}</span> .</p>

    <p class="text-gray-300">|  INPUT (y; x = (x1, x2))  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  a = Ψ((0, x1L), 0) |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b = Ψ((x1R, 0), 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a, b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ←R Zq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | c |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z = x1L + cx1R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z, x2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ψ((cz, z), cx2) = a + cy + c2b</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 2 (Compression Mechanism).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{1}</span> is a <span class="math">3</span>-move protocol for relation <span class="math">R_{\\Psi}</span>. It is perfectly complete and unconditionally <span class="math">3</span>-special-sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2</span> <span class="math">\\mathbb{H}</span>-elements, <span class="math">1</span> <span class="math">\\mathbb{H}_{0}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{H}_{2}</span>-element.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> <span class="math">\\mathbb{Z}_{q}</span>-element.</li>

    </ul>

    <p class="text-gray-300">The proof of Theorem 2 is almost identical to the proofs of <em>[x1, Theorem 2]</em> and <em>[x2, Theorem 2]</em>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300"><span class="math">3</span>-Special Soundness: Let <span class="math">(a,b;c_{1};z_{1},x_{1})</span>, <span class="math">(a,b;c_{2};z_{2},x_{2})</span> and <span class="math">(a,b;c_{3};z_{3},x_{3})</span> be three accepting transcripts for distinct challenges <span class="math">c_{1},c_{2},c_{3}\\in\\mathbb{Z}_{q}</span> and with common first message <span class="math">(a,b)</span>. Let <span class="math">\\alpha_{1},\\alpha_{2},\\alpha_{3}\\in\\mathbb{Z}_{q}</span> be such that</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}1&1&1\\\\ c_{1}&c_{2}&c_{3}\\\\ c_{1}^{2}&c_{2}^{2}&c_{3}^{2}\\end{pmatrix}\\begin{pmatrix}\\alpha_{1}\\\\ \\alpha_{2}\\\\ \\alpha_{3}\\end{pmatrix}=\\begin{pmatrix}0\\\\ 1\\\\ 0\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Note that, since the challenges are distinct, this Vandermonde matrix is invertible and a solution to this equation exists. Let <span class="math">\\bar{z}=\\sum_{i=1}^{3}\\alpha_{i}((c_{i}z_{i},z_{i}),c_{i}x_{i})</span>. Then, since <span class="math">\\Psi</span> is a homomorphism, it follows that <span class="math">\\Psi(\\bar{z})=y</span>. Hence, <span class="math">\\bar{z}</span> is a witness for statement <span class="math">y</span> of relation <span class="math">R_{\\Psi}</span>, which completes the proof. ∎</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.3 Abstract Compressed <span class="math">\\Sigma</span>-Protocol</h3>

    <p class="text-gray-300">The the final message <span class="math">(z,x_{2})</span> of <span class="math">\\Pi_{1}</span> is again a witness, but now for statement <span class="math">a+cy+c^{2}b</span> of relation <span class="math">R_{\\Psi^{\\prime}}</span> where <span class="math">\\Psi^{\\prime}(z,x_{2})=\\Psi((cz,z),cx_{2})</span>. Hence, if <span class="math">\\mathbb{H}_{0}</span> is the Cartesian product of a group <span class="math">\\mathbb{H}_{0}^{\\prime}</span> with itself, the compression mechanism can be applied again, i.e., instead of sending <span class="math">(z,x_{2})</span> the prover and verifier run an appropriately instantiated compression mechanism. In particular, if <span class="math">\\mathbb{H}_{1}=\\mathbb{H}_{0}^{n}</span>, the compression mechanism can be applied recursively, i.e., the first part of the witness is folded until it consists of only one <span class="math">\\mathbb{H}_{0}</span> element.</p>

    <p class="text-gray-300">The recursive composition of <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> and compression mechanism <span class="math">\\Pi_{1}</span> is a compressed <span class="math">\\Sigma</span>-protocol for relation <span class="math">R_{\\Psi}</span>. It is denoted by</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathrm{abs}}=\\underbrace{\\Pi_{1}\\diamond\\cdots\\diamond\\Pi_{1}}_{\\mu\\text{ times}}\\diamond\\Pi_{0},</span> (4)</p>

    <p class="text-gray-300">where <span class="math">\\mu=\\lceil\\log_{2}(n)\\rceil</span>. Note that if <span class="math">n</span> is not a power of <span class="math">2</span> it can be appended with zeros. The basic <span class="math">\\Sigma</span>-protocol requires the prover to send one <span class="math">\\mathbb{H}_{1}</span>-element, or equivalently <span class="math">n</span> <span class="math">\\mathbb{H}_{0}</span>-elements. By contrast, the compressed <span class="math">\\Sigma</span>-protocol only has to send <span class="math">1</span> <span class="math">\\mathbb{H}_{0}</span>-element. However, this reduction comes at the cost of sending a logarithmic number of <span class="math">2\\mu+3</span> <span class="math">\\mathbb{H}</span>-elements. The properties of <span class="math">\\Pi_{\\mathrm{abs}}</span> are summarized in Theorem 3. Note that <span class="math">\\Pi_{\\mathrm{abs}}</span> is SHVZK because <span class="math">\\Pi_{0}</span> is.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 3 (Abstract Compressed <span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">Let <span class="math">n\\in\\mathbb{N}</span>, <span class="math">\\mu=\\lceil\\log_{2}(n)\\rceil</span> and <span class="math">\\Psi\\colon\\mathbb{H}_{0}^{n}\\times\\mathbb{H}_{2}\\to\\mathbb{H}</span> be a <span class="math">\\mathbb{Z}_{q}</span>-module homomorphism. Then <span class="math">\\Pi_{\\mathrm{abs}}</span> is a <span class="math">2\\mu+3</span>-move protocol for relation <span class="math">R_{\\Psi}</span>. It is perfectly complete, special honest-verifier zero-knowledge and unconditionally <span class="math">3</span>-special-sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\mu+1</span> <span class="math">\\mathbb{H}</span>-elements, <span class="math">1</span> <span class="math">\\mathbb{H}_{0}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{H}_{2}</span>-element.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\mu+1</span> <span class="math">\\mathbb{Z}_{q}</span>-elements.</li>

    </ul>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.4 Efficiency Improvements for Bilinear Instances</h3>

    <p class="text-gray-300">In this section, we consider the following <span class="math">\\mathbb{Z}_{q}</span>-module homomorphism</p>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathbb{Z}_{q}^{n_{0}+2}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> <span class="math">\\to\\mathbb{G}_{T}^{n_{T}+3}\\times\\mathbb{Z}_{q}\\times\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\times\\mathbb{G}_{T},</span> <span class="math">(\\mathbf{x}_{1},\\mathbf{x}_{2})</span> <span class="math">\\mapsto\\big{(}\\mathrm{Com}_{1}(\\mathbf{x}_{1}),\\mathrm{Com}_{2}(\\mathbf{x}_{2}),f(\\mathbf{x}_{1},\\mathbf{x}_{2})\\big{)},</span></p>

    <p class="text-gray-300">where the vectors <span class="math">\\mathbf{x}_{1}=(\\mathbf{x}_{1}^{\\prime},\\gamma_{1})\\in\\mathbb{Z}_{q}^{n_{0}+1}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}</span> and <span class="math">\\mathbf{x}_{2}=(\\mathbf{x}_{2}^{\\prime},\\gamma_{2})\\in\\mathbb{G}_{T}^{n_{T}}\\times\\mathbb{Z}_{q}</span> both include the commitment randomness <span class="math">\\gamma_{1},\\gamma_{2}\\in\\mathbb{Z}_{q}</span> and the homomorphism <span class="math">f</span> is understood to ignore this commitment randomness. This notation allows the commitment randomness to be treated implicitly.</p>

    <p class="text-gray-300">Instantiating compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{abs}}</span> with homomorphism <span class="math">\\Psi</span> allows a prover to show that a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> satisfies the linear constraint <span class="math">f(\\mathbf{x})=\\mathbf{y}</span>. In Section 4.7, it is explained why we can restrict ourselves to linear relation captured by homomorphisms with codomain <span class="math">\\mathbb{Z}_{q}\\times\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\times\\mathbb{G}_{T}</span>. This instantiation therefore immediately results in the desired linear functionality. However, we describe two improvements that are applicable to this specific instantiation of compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{abs}}</span>.</p>

    <p class="text-gray-300">First, we note that in this case the first message <span class="math">(a,b)</span> of compression mechanism <span class="math">\\Pi_{1}</span> is always of the form</p>

    <p class="text-gray-300"><span class="math">a</span> <span class="math">=\\Psi((0,x_{1}^{L}),0)=\\big{(}\\mathrm{Com}_{1}(0,x_{1}^{L}),\\mathrm{Com}_{2}(0),f((0,x_{1}^{L}),0)\\big{)},</span> <span class="math">b</span> <span class="math">=\\Psi((x_{1}^{R},0),0)=\\big{(}\\mathrm{Com}_{1}(x_{1}^{R},0),\\mathrm{Com}_{2}(0),f((x_{1}^{R},0),0)\\big{)}.</span></p>

    <p class="text-gray-300">Hence, the second component of both <span class="math">a</span> and <span class="math">b</span> equals <span class="math">\\mathrm{Com}_{2}(0)=0</span> and does not have to be sent to the verifier. For this reason, we understand <span class="math">\\Pi_{\\mathrm{abs}}</span> to omit this information from the first message.</p>

    <p class="text-gray-300">Second, we observe that in every iteration of the compression mechanism the prover has to send two evaluations of the homomorphism <span class="math">f</span> to the verifier. This step can be made more efficient by a pre-processing step in which part of the evaluation of <span class="math">f</span> is “incorporated into the commitment”. The goal is not to hide the evaluation <span class="math">y=f(\\mathbf{x})</span>, in fact <span class="math">y</span> is still public, but to reduce the overall communication complexity that is achieved after compression. Ultimately, this step will reduce a relevant constant in the communication costs of our compressed <span class="math">\\Sigma</span>-protocol by a factor <span class="math">1/2</span>. This technique was first deployed in <em>[BBB^{+}18]</em> to improve the communication complexity of certain protocols <em>[BCC^{+}16]</em> for inner-product relations defined over <span class="math">\\mathbb{Z}_{q}</span>. Here, it is generalized to our bilinear setting.</p>

    <p class="text-gray-300">To this end, we write <span class="math">f=(f_{1},f_{2})</span> with <span class="math">f_{1}(x)\\in\\mathbb{Z}_{q}\\times\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> and <span class="math">f_{2}(x)\\in\\mathbb{G}_{T}</span> for all <span class="math">x</span>. The reason is that the commitment scheme is not compact on the <span class="math">\\mathbb{G}_{T}</span>-part. Hence incorporating <span class="math">f_{2}(x)</span> into the commitment will not reduce the communication complexity of the protocol.</p>

    <p class="text-gray-300">The pre-processing step proceeds as follows. After the verifier has sent a random challenge <span class="math">\\rho</span> to the prover, the problem of proving knowledge of a pre-image for <span class="math">\\Psi</span> is reduced to proving knowledge of a pre-image for</p>

    <p class="text-gray-300"><span class="math">\\Psi_{\\rho}(\\mathbf{x}_{1},\\mathbf{x}_{2})=\\left(\\mathrm{Com}_{1}(\\mathbf{x}_{1},\\rho\\cdot f_{1}(\\mathbf{x}_{1},\\mathbf{x}_{2})),\\mathrm{Com}_{2}(\\mathbf{x}_{2}),f_{2}(\\mathbf{x}_{1},\\mathbf{x}_{2})\\right),</span></p>

    <p class="text-gray-300">where the domain of <span class="math">\\mathrm{Com}_{1}</span> has been increased from <span class="math">\\mathbb{Z}_{q}^{n_{0}+1}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}</span> to <span class="math">\\mathbb{Z}_{q}^{n_{0}+2}\\times\\mathbb{G}_{1}^{n_{1}+1}\\times\\mathbb{G}_{2}^{n_{2}+1}</span>. Note that, since <span class="math">\\mathrm{Com}_{1}</span> is compact, the codomain of <span class="math">\\Psi_{\\rho}</span> is smaller than the codomain of <span class="math">\\Psi</span>. Because the challenge <span class="math">\\rho</span> is sampled uniformly at random and the commitment scheme <span class="math">\\mathrm{Com}_{1}</span> is binding, the reduction is sound, i.e., a prover that knows a pre-image for <span class="math">\\Psi_{\\rho}</span> must also know a pre-image for <span class="math">\\Psi</span>.</p>

    <p class="text-gray-300">The reduction, denoted by <span class="math">\\Pi_{r}</span>, is formalized in Protocol 2 and its main properties are summarized in Lemma 1. Note that, in contrast to the previous protocols, <span class="math">\\Pi_{r}</span> only has computational soundness. Moreover, this protocol is clearly not special-honest verifier zero-knowledge; the secret witness <span class="math">\\mathbf{x}</span> is sent to the verifier. However, since the final message of this reduction will be replaced by an appropriate compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{abs}}</span>, it does not have to be SHVZK.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{r}</span> is a <span class="math">2</span>-move protocol for relation <span class="math">R_{\\Psi}</span>. It is perfectly complete and computationally special-sound, under the assumption that the commitment scheme <span class="math">\\mathrm{Com}_{1}</span> is binding. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}^{n_{0}+2}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300">Special soundness: We show that there exists an efficient algorithm <span class="math">\\chi</span> that, on input two accepting transcripts, either extracts a witness for <span class="math">R_{\\psi}</span>, or finds two different openings to the same commitment, and thereby breaks the binding property of the <span class="math">\\mathrm{Com}_{1}</span>.</p>

    <p class="text-gray-300">Protocol 2 Argument of Knowledge  <span class="math">\\varPi_r</span>  for  <span class="math">R_{\\Psi}</span>  Reduction from relation  <span class="math">R_{\\Psi}</span>  to relation  <span class="math">R_{\\Psi_{\\rho}}</span>  , where  <span class="math">\\varPsi(\\mathbf{x}_1,\\mathbf{x}_2)=(\\mathrm{COM}_1(\\mathbf{x}_1),\\mathrm{COM}_2(\\mathbf{x}_2),f(\\mathbf{x}_1,\\mathbf{x}_2))</span></p>

    <p class="text-gray-300">|  INPUT(z=(P1,P2,y1,y2);x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  z=Ψ(x)  |   |</p>

    <p class="text-gray-300">|  y1=f1(x)  |   |</p>

    <p class="text-gray-300">|  y2=f2(x)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Ψρ(x) = z + (COM1(0,ρ·y1),0,0)  |</p>

    <p class="text-gray-300">So let  <span class="math">(\\rho, \\mathbf{x})</span>  and  <span class="math">(\\rho&#x27;, \\mathbf{x}&#x27;)</span>  be two accepting transcripts with  <span class="math">\\rho \\neq \\rho&#x27;</span> , then by subtracting the two verification equations and since  <span class="math">\\mathrm{COM}_1(\\cdot)</span>  is a homomorphism,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {C O M} _ {1} \\left(\\mathbf {x} - \\mathbf {x} ^ {\\prime}, \\rho f _ {1} (\\mathbf {x}) - \\rho^ {\\prime} f _ {1} (\\mathbf {x} ^ {\\prime})\\right) = \\mathrm {C O M} \\left(0, (\\rho - \\rho^ {\\prime}) y _ {1}, 0\\right).</span></div>

    <p class="text-gray-300">Hence, either we have extracted two different openings to the same commitment, or  <span class="math">\\mathbf{x} = \\mathbf{x}&#x27;</span> ,  <span class="math">\\rho f_1(\\mathbf{x}) - \\rho&#x27; f_1(\\mathbf{x}&#x27;) = (\\rho - \\rho&#x27;) y_1</span> . In the latter case, it follows that  <span class="math">f_1(\\mathbf{x}) = f_1(\\mathbf{x}&#x27;) = y_1</span> . Moreover, in this case it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {C O M} _ {1} \\left(\\mathbf {x} _ {1}, \\rho f _ {1} (\\mathbf {x})\\right) = P _ {1} + \\mathrm {C O M} _ {1} \\left(0, \\rho y _ {1}\\right),</span></div>

    <p class="text-gray-300">which implies that  <span class="math">\\mathrm{COM}_1(\\mathbf{x}_1) = P_1</span> . Hence,  <span class="math">\\varPsi(\\mathbf{x})=z</span>  and  <span class="math">\\mathbf{x}</span>  is a witness for statement  <span class="math">z</span>  of relation  <span class="math">R_{\\Psi}</span> , which completes the proof.</p>

    <p class="text-gray-300">The basic  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_0</span>  of Section 4.1 follows the generic design for  <span class="math">q</span> -one-way group homomorphisms  <span class="math">\\varPsi</span>  [Cra96, CD98]. However, for some instantiations of  <span class="math">\\varPsi</span>  this generic approach is sub-optimal as it leads to unnecessarily high communication costs. This is the case for our bilinear instantiation that makes use of the El Gamal based commitment scheme  <span class="math">\\mathrm{COM}_2</span>  of Definition 10,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {C O M} _ {2}: \\mathbb {G} _ {T} ^ {n _ {T}} \\times \\mathbb {Z} _ {q} \\to \\mathbb {G} _ {T} ^ {n _ {T} + 1}, \\quad (\\mathbf {x}, \\gamma) \\mapsto \\left( \\begin{array}{c} h \\gamma \\\\ \\mathbf {g} \\gamma + \\mathbf {x} \\end{array} \\right).</span></div>

    <p class="text-gray-300">Here, we describe a more efficient approach tailored to the commitment scheme  <span class="math">\\mathrm{COM}_2</span> . Subsequently, we explain how this improvement translates to a reduction of the communication costs of our compressed  <span class="math">\\Sigma</span> -protocol.</p>

    <p class="text-gray-300">The main observation is that to open a  <span class="math">\\mathrm{COM}_2</span> -commitment  <span class="math">P = (P_1, P_2) \\in \\mathbb{G}_T \\times \\mathbb{G}_T^{n_T}</span> , a prover merely has to reveal  <span class="math">\\gamma \\in \\mathbb{Z}_q</span>  with  <span class="math">h\\gamma = P_1</span> . The committed vector  <span class="math">\\mathbf{x} \\in \\mathbb{G}_T^{n_T}</span>  can be computed from the commitment  <span class="math">P</span>  and the opening  <span class="math">\\gamma</span> , i.e.,  <span class="math">\\mathbf{x} = P_2 - \\mathbf{g}\\gamma</span> . Hence, proving knowledge of a commitment opening is equivalent to proving knowledge of a discrete logarithm (in base  <span class="math">h</span> ). The latter problem has a natural  <span class="math">\\Sigma</span> -protocol with constant communication complexity. By contrast, the natural  <span class="math">\\Sigma</span> -protocol for proving knowledge of a preimage of the homomorphism  <span class="math">\\mathrm{COM}_2</span>  has communication costs linear in the dimension  <span class="math">n_T</span>  of the committed vector. A straightforward extension of this protocol allows a prover to prove that the committed vector satisfies an arbitrary linear relation.</p>

    <p class="text-gray-300">The resulting protocol, denoted by  <span class="math">\\Pi_{EG}</span> , is a protocol for relation  <span class="math">R_{EG} = \\left\\{\\left(P \\in \\mathbb{G}_T^{n_T + 1}, y \\in \\mathbb{H}; \\mathbf{x} \\in \\mathbb{G}_T^{n_T}, \\gamma \\in \\mathbb{Z}_q\\right) : P = \\mathrm{COM}_2(\\mathbf{x}, \\gamma), f(\\mathbf{x}) = y\\right\\}</span> . It is described in Protocol 3 and its properties are summarized in Theorem 4.</p>

    <p class="text-gray-300">Theorem 4 ( <span class="math">\\Sigma</span> -Protocol for El Gamal Based Commitments).  <span class="math">\\Pi_{EG}</span>  is a  <span class="math">\\Sigma</span> -protocol for relation  <span class="math">R_{EG}</span> . It is perfectly complete, special honest-verifier zero-knowledge and unconditionally special-sound. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> : 1  <span class="math">\\mathbb{G}_T</span> -element, 1  <span class="math">\\mathbb{H}</span> -element, 1  <span class="math">\\mathbb{Z}_q</span> -element.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> : 1  <span class="math">\\mathbb{Z}_q</span> -element.</li>

    </ul>

    <p class="text-gray-300">Proof. Completeness follows directly.</p>

    <p class="text-gray-300">Special Honest-Verifier Zero-Knowledge (SHVZK): Upon receiving a random challenge  <span class="math">c \\in \\mathbb{Z}_q</span>  a simulator proceeds as follows. The simulator samples  <span class="math">\\phi \\in \\mathbb{Z}_q</span>  uniformly at random and computes  <span class="math">A = h\\phi - cP_1</span>  and  <span class="math">t = cy - f(cP_2 - \\mathbf{g}\\phi)</span> . It is easily seen that the transcript  <span class="math">(A, t, c, \\phi)</span>  is accepting and that simulated transcripts follow exactly the same distribution as transcripts between an honest prover and an honest verifier.</p>

    <p class="text-gray-300">Special Soundness: We show that there exists an efficient algorithm, that on input two accepting transcripts, computes a witness for relation  <span class="math">R_{EG}</span> . Let  <span class="math">(A,t,c,\\phi)</span>  and  <span class="math">(A,t,c&#x27;,\\phi&#x27;)</span>  be accepting transcripts, for challenges  <span class="math">c \\neq c&#x27;</span>  and with common first message  <span class="math">(A,t)</span> . We define  <span class="math">\\hat{\\phi} = (\\phi - \\phi&#x27;) / (c - c&#x27;) \\in \\mathbb{Z}_q</span>  and  <span class="math">\\bar{\\mathbf{z}} = P_2 - \\mathbf{g}\\hat{\\phi} \\in \\mathbb{G}_T^{n_T}</span> . Then it is easily verified that  <span class="math">\\mathrm{COM}_2(\\bar{z},\\hat{\\phi}) = P</span>  and that  <span class="math">f(\\bar{\\mathbf{z}}) = y</span> . Hence,  <span class="math">(\\bar{\\mathbf{z}},\\hat{\\phi})</span>  is a witness for statement  <span class="math">(P,y)</span>  of relation  <span class="math">R_{EG}</span> , which completes the proof.</p>

    <p class="text-gray-300">Protocol 3  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_{EG}</span>  for relation  <span class="math">R_{EG}</span> <span class="math">\\Sigma</span> -protocol for opening a homomorphism on a committed  <span class="math">\\mathbb{G}_T</span>  vector.</p>

    <p class="text-gray-300">|  INPUT(P,y;x,γ)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  P=(P1,P2)=COM2(x,γ)  |   |   |</p>

    <p class="text-gray-300">|  y=f(x)  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ρ←RZq |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A=hρ,t=f(gρ)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A,t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">φ=cγ+ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">φ</td>

            <td class="px-3 py-2 border-b border-gray-700">hφ?cP1+A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | f(cP2-gφ) = cy-t  |</p>

    <p class="text-gray-300">Let  <span class="math">\\varPi_{c}</span>  be the compressed  <span class="math">\\Sigma</span> -protocol obtained by instantiating  <span class="math">\\varPi_{\\mathrm{abs}}</span>  with homomorphism</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\varPsi \\colon \\mathbb {Z} _ {q} ^ {n _ {0} + 2} \\times \\mathbb {G} _ {1} ^ {n _ {1}} \\times \\mathbb {G} _ {2} ^ {n _ {2}} \\times \\mathbb {G} _ {T} ^ {n _ {T}} \\to \\mathbb {G} _ {T} ^ {n _ {T} + 3} \\times \\mathbb {Z} _ {q} \\times \\mathbb {G} _ {1} \\times \\mathbb {G} _ {2} \\times \\mathbb {G} _ {T}, \\\\ \\left(\\mathbf {x} _ {1}, \\mathbf {x} _ {2}\\right) \\mapsto \\left(\\operatorname {C o m} _ {1} \\left(\\mathbf {x} _ {1}\\right), \\operatorname {C o m} _ {2} \\left(\\mathbf {x} _ {2}\\right), f \\left(\\mathbf {x} _ {1}, \\mathbf {x} _ {2}\\right)\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and incorporating the efficiency improvements of Section 4.4 and Section 4.5. These efficiency improvements are applicable, because we restrict ourselves to homomorphisms  <span class="math">\\varPsi</span>  defined over a bilinear group. More precisely, for  <span class="math">\\mu = \\lceil \\log_2(\\max (n_0 + 1,n_1,n_2))\\rceil</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pi_ {c} = \\underbrace {\\Pi_ {1} \\diamond \\cdots \\diamond \\Pi_ {1}} _ {\\mu \\text {t i m e s}} \\diamond \\Pi_ {0} \\diamond \\Pi_ {r}, \\tag {5}</span></div>

    <p class="text-gray-300"><span class="math">\\Pi_{0}</span> is understood to apply the improved <span class="math">\\Sigma</span>-protocol of Section 4.5 to <span class="math">\\Psi</span>’s <span class="math">\\mathbb{G}_{T}</span>-part. This protocol allows a prover to prove that a committed vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span> satisfies a <em>linear</em> constraint <span class="math">f(\\mathbf{x})=y</span>. The properties of <span class="math">\\Pi_{c}</span> are summarized in the Theorem 5. Note that, by the improvement of Section 4.5, the communication costs are independent of the dimension <span class="math">n_{T}</span> of the <span class="math">\\mathbb{G}_{T}</span>-part of the committed vector, even though the size of the commitment is linear in <span class="math">n_{T}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 5 (Compressed <span class="math">\\Sigma</span>-Protocol for Opening Homomorphisms).</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{c}</span> is a <span class="math">(2\\mu+4)</span>-move protocol for relation <span class="math">R_{\\Psi}</span>, where <span class="math">\\mu=\\lceil\\log_{2}\\left(\\max(n_{0}+1,n_{1},n_{2})\\right)\\rceil</span>. It is perfectly complete, special honest-verifier zero-knowledge and computationally <span class="math">(2,2,3,\\ldots,3)</span>-special-sound, under the assumption that the commitment scheme <span class="math">\\mathrm{Com}_{1}</span> is binding. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">6\\mu+3</span> <span class="math">\\mathbb{G}_{T}</span>-elements, <span class="math">2</span> <span class="math">\\mathbb{Z}_{q}</span>-elements, <span class="math">1</span> <span class="math">\\mathbb{G}_{1}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{G}_{2}</span>-element.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\mu+2</span> <span class="math">\\mathbb{Z}_{q}</span>-elements.</li>

    </ul>

    <h6 id="sec-33" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocols of <em>[x1]</em>, for relations defined over <span class="math">\\mathbb{Z}_{q}</span>, have a similar structure as <span class="math">\\Pi_{c}</span>. However, there a variant of the reduction <span class="math">\\Pi_{r}</span> is applied <em>after</em> applying the <span class="math">\\Sigma</span>-protocol. By contrast, we first apply reduction <span class="math">\\Pi_{r}</span> and subsequently apply the basic <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span>. This adaptation yields a minor improvement as it reduces the communication costs by <span class="math">3</span> elements.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.7 Amortization</h3>

    <p class="text-gray-300">Standard amortization techniques apply to the basic <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> for relation <span class="math">R_{\\Psi}</span>, and thereby also to compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span>. These amortization techniques allow a prover to open <em>many</em> homomorphisms on <em>one</em> commitment, or <em>one</em> homomorphism on <em>many</em> commitments, without increasing the communication costs from the prover to the verifier. For details we refer to <em>[x1, Section 5.1]</em>.</p>

    <p class="text-gray-300">These amortization techniques allow us to restrict ourselves to homomorphisms with the codomain <span class="math">\\mathbb{Z}_{q}\\times\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\times\\mathbb{G}_{T}</span>. Namely, opening a homomorphism <span class="math">f</span> with codomain <span class="math">\\mathbb{Z}_{q}^{s_{0}}\\times\\mathbb{G}_{1}^{s_{1}}\\times\\mathbb{G}_{2}^{s_{2}}\\times\\mathbb{G}_{T}^{s_{T}}</span> can be casted as opening <span class="math">\\max(s_{i})</span> homomorphisms with codomain <span class="math">\\mathbb{Z}_{q}\\times\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\times\\mathbb{G}_{T}</span>.</p>

    <h2 id="sec-35" class="text-2xl font-bold">5 Threshold Signature Schemes</h2>

    <p class="text-gray-300">In this section, we describe a threshold signature scheme (TSS), as an application of the compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span> for proving linear statements on committed vectors <span class="math">\\mathbf{x}</span>. Informally a <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature can only be computed given <span class="math">k</span> valid signatures issued by a <span class="math">k</span>-subset of <span class="math">n</span> players. We first describe the formal definition of a TSS. Subsequently, we give our construction based on the compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span>.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.1 Definition and Security Model</h3>

    <p class="text-gray-300">We deviate from standard TSS definitions and aim for a strictly stronger functionality. In standard TSS definitions <em>[x20, x3]</em>, a non-transparent mechanism generates a single public key and <span class="math">n</span> private keys that are distributed amongst the <span class="math">n</span> players. The private keys allow individual players to generate <em>partial</em> signatures on messages <span class="math">m</span>. There is a public algorithm to aggregate <span class="math">k</span> partial signatures into a threshold signature. The threshold signature can be verified with the public key.</p>

    <p class="text-gray-300">By contrast, we define a TSS as an <em>extension</em> of a digital signature scheme. Our fundamental strengthening of the definitions of <em>[x20, x3]</em> and related works, is that the public and private keys are generated by the players locally. Public keys are published on a <em>bulletin board</em> and thereby publicly tied to the player’s identities. This setup is thus <em>transparent</em> (called “bulletin board” in <em>[x2]</em> and formalized as <span class="math">\\mathcal{F}_{CA}</span> in the UC framework <em>[x4]</em>). The players can individually sign messages by using their private keys. The aggregation algorithm now takes as input <span class="math">k</span> signatures, instead of partial signatures, to generate a threshold signature.</p>

    <p class="text-gray-300">For simplicity we assume the threshold <span class="math">k</span> to be fixed. We will explain later why our construction (trivially) satisfies some stronger properties.</p>

    <p class="text-gray-300">Let us first give a definition for the basic building block of our TSS.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 11 (Digital Signature).</h6>

    <p class="text-gray-300">A digital signature scheme consists of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>keygen is a randomized key generation algorithm that outputs a public-private key-pair <span class="math">(\\mathsf{pk},\\mathsf{sk})</span>.</li>

      <li>sign is a (possibly randomized) signing algorithm. On input a message <span class="math">m\\in\\{0,1\\}^{*}</span> and a secret key <span class="math">\\mathsf{sk}</span>, it outputs a signature <span class="math">\\sigma=\\textsc{sign}(\\mathsf{sk},m)</span>.</li>

      <li>verify is a deterministic verification algorithm. On input a public key <span class="math">\\mathsf{pk}</span>, a message <span class="math">m</span> and a signature <span class="math">\\sigma</span>, it outputs either accept or reject.</li>

    </ul>

    <p class="text-gray-300">A signature scheme is correct if verify<span class="math">(\\mathsf{pk},m,\\textsc{sign}(\\mathsf{sk},m))=\\mathsf{accept}</span> for all key-pairs <span class="math">(\\mathsf{pk},\\mathsf{sk})\\leftarrow\\textsc{keygen}</span> and messages <span class="math">m\\in\\{0,1\\}^{<em>}</span>. If verify<span class="math">(\\mathsf{pk},m,\\sigma)=\\mathsf{accept}</span> we say that <span class="math">\\sigma</span> is a valid signature on message <span class="math">m</span>. Moreover, an adversary that does not know the secret key <span class="math">\\mathsf{sk}</span> should not be able to forge a valid signature. This security property is formally captured in the widely accepted definition Existential Unforgeability under Chosen-Message Attacks (EUF-CMA) </em>[x1]*. We assume digital signature schemes to be correct and EUF-CMA by definition.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Definition 12 (Threshold Signature).</h6>

    <p class="text-gray-300">A <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature scheme (TSS) is a digital signature scheme (keygen, sign, verify) appended with two algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">k</span>-aggregate is a (possibly randomized) aggregation algorithm. On input <span class="math">n</span> public keys <span class="math">(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n})</span>, <span class="math">k</span> signatures <span class="math">(\\sigma_{i})_{i\\in\\mathcal{S}}</span> for a <span class="math">k</span>-subset <span class="math">\\mathcal{S}\\subset\\{1,\\ldots,n\\}</span> and a message <span class="math">m\\in\\{0,1\\}^{*}</span>, it outputs a threshold signature <span class="math">\\Sigma</span>.</li>

      <li><span class="math">k</span>-verify is a deterministic verification algorithm. On input <span class="math">n</span> public keys <span class="math">(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n})</span>, a message <span class="math">m</span> and a threshold signature <span class="math">\\Sigma</span>, it outputs either accept or reject.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathcal{S}\\subset\\{1,\\ldots,n\\}</span> be some <span class="math">k</span>-subset of indices and let <span class="math">(\\sigma)_{i\\in\\mathcal{S}}</span> be signatures, such that verify<span class="math">(\\mathsf{pk}_{i},m,\\sigma_{i})=\\mathsf{accept}</span>, for all <span class="math">i\\in\\mathcal{S}</span>, and for some message <span class="math">m\\in\\{0,1\\}^{*}</span>. Then a TSS is correct, if for all <span class="math">(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n})</span>, <span class="math">m</span>, <span class="math">\\mathcal{S}</span> and <span class="math">(\\sigma)_{i\\in\\mathcal{S}}</span>,</p>

    <p class="text-gray-300"><span class="math">k\\text{-verify}\\Big{(}(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n}),m,k\\text{-aggregate}\\big{(}m,(\\sigma_{i})_{i\\in\\mathcal{S}}\\big{)}\\Big{)}=\\mathsf{accept}.</span></p>

    <p class="text-gray-300">If <span class="math">k\\text{-verify}\\Big{(}(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n}),m,\\Sigma\\Big{)}=\\mathsf{accept}</span> we say that <span class="math">\\Sigma</span> is a valid threshold signature. Moreover, an adversary with at most <span class="math">k-1</span> valid signatures on a message <span class="math">m</span> should not be able to construct a valid threshold signature. This unforgeability property can be formalized by the following security game. Consider an adversary that is allowed to choose a subset of <span class="math">k-1</span> indices <span class="math">\\mathcal{I}\\subset\\{1,\\ldots,n\\}</span> and impose the values of the keys <span class="math">\\mathsf{pk}_{i}</span> in this subset. Assume that all remaining keys <span class="math">\\mathsf{pk}_{i}</span> were generated honestly from keygen and therefore correspond to secret keys <span class="math">\\mathsf{sk}_{i}</span>. The adversary is allowed to query polynomially many signatures <span class="math">\\sigma^{\\prime}_{i}=\\textsc{sign}(sk_{i},m^{\\prime})</span> for arbitrary messages <span class="math">m^{\\prime}</span>. The TSS is said to be unforgeable, if the adversary is incapable of producing a valid <span class="math">k</span>-out-of-<span class="math">n</span> threshold signature on some message <span class="math">m</span> that has not been queried. We assume threshold signatures schemes to be correct and unforgeable by definition.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">5.2 Our Threshold Signature Scheme</h3>

    <p class="text-gray-300">We follow a non-standard, but conceptually simple, approach for constructing a threshold signature scheme. The starting point of our TSS is a digital signature scheme (keygen, sign, verify) and the <span class="math">k</span>-aggregation algorithm <span class="math">k</span>-aggregate simply produces a proof of knowledge of <span class="math">k</span> valid signatures on a message <span class="math">m</span>, i.e., a PoK for the following relation:</p>

    <p class="text-gray-300"><span class="math">R_{T}=\\big{\\{}</span> <span class="math">(\\mathsf{pk}_{1},\\ldots,\\mathsf{pk}_{n},m;\\mathcal{S},(\\sigma_{i})_{i\\in\\mathcal{S}}):</span> (6)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,\\text{ verify}(\\mathsf{pk}_{i},m,\\sigma_{i})=\\mathsf{accept}\\ \\forall i\\in\\mathcal{S}\\big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The obvious approach is to capture this relation by an arithmetic circuit, i.e., reduce it to a number of constraints defined over <span class="math">\\mathbb{Z}_{q}</span>, and apply a communication-efficient proof of knowledge for arithmetic circuit relations in a black-box manner. A significant drawback of this indirect approach is that it relies on an</p>

    <p class="text-gray-300">inefficient reduction to arithmetic circuit relations. For this reason, we follow a direct approach avoiding these inefficient reductions.</p>

    <p class="text-gray-300">We instantiate our TSS with the BLS signature scheme <em>[x1, x2]</em> defined over a bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>. Let us now briefly recall the BLS signature scheme, instantiated in our <span class="math">n</span>-player setting. All players <span class="math">i</span>, <span class="math">1\\leq i\\leq n</span>, generate their own private key <span class="math">u_{i}\\in\\mathbb{Z}_{q}</span>, and publish the associated public key <span class="math">P_{i}=u_{i}H\\in\\mathbb{G}_{2}</span>. To sign a message <span class="math">m\\in\\{0,1\\}^{<em>}</span>, player <span class="math">i</span> computes signature <span class="math">\\sigma_{i}=u_{i}\\mathcal{H}(m)\\in\\mathbb{G}_{1}</span>, where <span class="math">\\mathcal{H}\\colon\\{0,1\\}^{</em>}\\to\\mathbb{G}_{1}</span> is some public hash function. The public verification algorithm accepts a signature <span class="math">\\sigma_{i}</span> if</p>

    <p class="text-gray-300"><span class="math">e(\\sigma_{i},H)=e(\\mathcal{H}(m),P_{i}).</span> (7)</p>

    <p class="text-gray-300">By the bilinearity of <span class="math">e</span>, all honestly generated signatures are accepted.</p>

    <p class="text-gray-300">The BLS signature scheme was originally instantiated such that <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span>, i.e., both input coordinates of the pairing <span class="math">e</span> are elements of the same group. However, the authors already showed that the scheme can be instantiated in a more general setting, where <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are possibly different. But still, their security proof, showing that unforgeability follows from the Computational co-Diffie-Hellman (co-CDH) assumption, requires the existence of an efficiently computable isomorphism <span class="math">\\psi\\colon\\mathbb{G}_{2}\\to\\mathbb{G}_{1}</span>. As discussed in Section 2.1, the existence of such an isomorphism contradicts the SXDH assumption; more precisely, the DDH assumption in <span class="math">\\mathbb{G}_{2}</span> cannot hold if there exists an efficiently computable isomorphism <span class="math">\\psi\\colon\\mathbb{G}_{2}\\to\\mathbb{G}_{1}</span>. Now recall that the binding properties of the commitment schemes of Definition 8 and Definition 9 are derived from the DDH assumption in <span class="math">\\mathbb{G}_{2}</span> and the SXDH assumption, respectively. Hence, at first glance the BLS signature scheme and the aforementioned commitment schemes seem to be incompatible, i.e., they appear to require different bilinear groups. Fortunately, Boneh, Lynn and Shacham already commented on the necessity of the isomorphism <span class="math">\\psi</span> in the journal version of their work <em>[x1]</em>. They mention that, by relying on a slightly different complexity assumption referred to as the co-CDH<em> assumption </em>[x30]<em>, the BLS signature scheme can also be instantiated in bilinear groups <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span> without an efficiently computable isomorphism <span class="math">\\psi\\colon\\mathbb{G}_{2}\\to\\mathbb{G}_{1}</span>. This shows that, under the co-CDH</em> assumption, we can safely instantiate the BLS signature scheme and the commitment scheme in the same bilinear group of Type III. A more detailed analysis of certain pairing-based signature schemes, instantiated with Type III bilinear groups, is provided in <em>[x7]</em>. In particular, they show that the co-DHP and co-DHP* assumptions are equivalent if the generators are suitably chosen and conclude that existing evidence suggests that Type III pairings offer at least as much security as Type II pairings when used to implement the BLS signature scheme.</p>

    <p class="text-gray-300">In this section, we do not need to commit to <span class="math">\\mathbb{G}_{2}</span>-coefficients. Therefore, instead of the commitment scheme from Definition 9, we can use the somewhat simpler commitment scheme of Definition 8 defined by the commitment function:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Com}:\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{Z}_{q}\\to\\mathbb{G}_{T},\\ (\\mathbf{x}_{\\mathbb{Z}_{q}},\\mathbf{x}_{G_{1}},\\gamma)\\mapsto h\\gamma+\\left\\langle\\mathbf{g},\\mathbf{x}_{\\mathbb{Z}_{q}}\\right\\rangle+e(\\mathbf{x}_{G_{1}},\\mathbf{H}).</span></p>

    <p class="text-gray-300">In particular, these commitments consist of only 1 instead of 2 <span class="math">\\mathbb{G}_{T}</span>-elements.</p>

    <p class="text-gray-300">Instantiating relation <span class="math">R_{T}</span> with the BLS signature scheme therefore results in the following relation,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$R_{TSS}=\\left\\{(P_{1},\\ldots,P_{n},m;\\mathcal{S},(\\sigma_{i})_{i\\in\\mathcal{S}}):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,\\ e(\\sigma_{i},H)=e(\\mathcal{H}(m),P_{i})\\ \\forall i\\in\\mathcal{S}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The <span class="math">k</span>-aggregate algorithm simply computes a proof of knowledge for relation <span class="math">R_{TSS}</span>. The main challenge is that the prover only knows <span class="math">k</span>-out-of-<span class="math">n</span> signatures. To handle this problem the <span class="math">k</span>-out-of-<span class="math">n</span> case is reduced to the <span class="math">n</span>-out-of-<span class="math">n</span> case as follows. The <span class="math">k</span> signatures are appended with <span class="math">n-k</span> signatures <span class="math">\\sigma_{i}=0</span> and a binary vector that allows the prover to eliminate the <span class="math">n-k</span> new and invalid signatures. The left hand side of the verification remains the same, while the right hand side is multiplied by the corresponding coefficient of the binary vector. This approach results in a TSS with the desired properties. However, it requires the prover to prove a number of non-linear statements, i.e., that the committed binary vector is binary and contains at most <span class="math">n-k</span> zeros. Although this can be done efficiently, e.g., with the range proofs of <em>[x1]</em>, a recent result on <span class="math">k</span>-out-of-<span class="math">n</span> proofs of partial knowledge <em>[x2]</em> gives an even more efficient solution, that completely avoids non-linearities.</p>

    <p class="text-gray-300">The proof of partial knowledge technique allows us to reduce relation <span class="math">R_{TSS}</span> to a linear relation defined over the bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span>. Let <span class="math">p(X)=1+\\sum_{j=1}^{n-k}a_{j}X^{j}\\in\\mathbb{Z}_{q}[X]</span> be the unique polynomial</p>

    <p class="text-gray-300">of degree at most  <span class="math">n - k</span>  with  <span class="math">p(i) = 0</span>  for all  <span class="math">i \\in \\{1, \\dots, n\\} \\backslash S</span> . Note that this polynomial defines an  <span class="math">(n - k, n)</span>  secret sharing of 1, with shares  <span class="math">s_i = 0</span>  for all  <span class="math">i \\notin S</span> . The  <span class="math">k</span> -aggregator defines  <span class="math">\\widetilde{\\sigma}_i = p(i)\\sigma_i</span> , where  <span class="math">\\widetilde{\\sigma}_i</span>  is understood to be equal to 0 for  <span class="math">i \\notin S</span> , i.e., the secret sharing defined by  <span class="math">p(X)</span>  eliminates the signatures  <span class="math">(\\sigma_i)_{i \\notin S}</span>  that the  <span class="math">k</span> -aggregator does not know. Subsequently, the  <span class="math">k</span> -aggregator commits to</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {x} = \\left(a _ {1}, \\dots , a _ {n - k}, \\widetilde {\\sigma} _ {1}, \\dots , \\widetilde {\\sigma} _ {n}\\right) \\in \\mathbb {Z} _ {q} ^ {n - k} \\times \\mathbb {G} _ {1} ^ {n}.</span></div>

    <p class="text-gray-300">Now note that the committed vector  <span class="math">\\mathbf{x}</span>  satisfies  <span class="math">f_{i}(\\mathbf{x}) = f_{i}(a_{1},\\ldots ,a_{n - k},\\widetilde{\\sigma}_{1},\\ldots \\widetilde{\\sigma}_{n}) = e(\\mathcal{H}(m),P_{i})</span>  for all  <span class="math">1\\leq i\\leq n</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">f _ {i}: \\mathbb {Z} _ {q} ^ {n - k} \\times \\mathbb {G} _ {1} ^ {n} \\rightarrow \\mathbb {G} _ {T}, \\quad \\mathbf {x} \\mapsto e (\\widetilde {\\sigma} _ {i}, H) - \\sum_ {j = 1} ^ {n - k} a _ {j} i ^ {j} e (\\mathcal {H} (m), P _ {i}). \\tag {8}</span></div>

    <p class="text-gray-300">Hence, by proving that the committed vector satisfies these relations, it follows that the  <span class="math">k</span> -aggregator knows a non-zero polynomial  <span class="math">p(X)</span>  of degree at most  <span class="math">n - k</span>  and group elements  <span class="math">\\widetilde{\\sigma}_1, \\ldots, \\widetilde{\\sigma}_n \\in \\mathbb{G}_1</span>  such that  <span class="math">e(\\widetilde{\\sigma}_i, H) = p(i)e(\\mathcal{H}(m), P_i)</span>  for all  <span class="math">1 \\leq i \\leq n</span> . Therefore, the  <span class="math">k</span> -aggregator must know valid signatures for all indices  <span class="math">i</span>  with  <span class="math">p(i) \\neq 0</span> , and since  <span class="math">p(X)</span>  is non-zero and of degree at most  <span class="math">n - k</span> , at least  <span class="math">k</span>  of its evaluations are non-zero. Because the mappings  <span class="math">f_i</span>  are homomorphisms, the required proof of knowledge follows from an appropriate instantiation of compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Pi_c</span> . We apply the amortization techniques of Section 4.7 to prove all  <span class="math">n</span>  relations of eq. (8) for essentially the price of one. Moreover, we apply the Fiat-Shamir transform to make protocol  <span class="math">\\Pi_c</span>  non-interactive. Altogether the threshold signature contains a commitment  <span class="math">P \\in \\mathbb{G}_T</span>  to the vector  <span class="math">\\mathbf{x}</span>  together with a non-interactive proof of knowledge  <span class="math">\\pi</span>  of an opening of  <span class="math">P</span>  that satisfies the aforementioned linear constraints. The  <span class="math">k</span> -AGGREGATE algorithm is summarized in Algorithm 4. The associated  <span class="math">k</span> -verification algorithm  <span class="math">k</span> -verify simply runs the verifier of  <span class="math">\\Pi_c</span> . Correctness of the resulting threshold signature follows immediately from the completeness of  <span class="math">\\Pi_c</span> , and unforgeability follows from the soundness of  <span class="math">\\Pi_c</span> . The properties of the TSS are summarized in Theorem 6. Note that our TSS has some additional properties not required by the definition of Section 5.1. For instance, since the proof of knowledge  <span class="math">\\Pi_c</span>  is special honest-verifier zero-knowledge, our threshold signatures hide the  <span class="math">k</span> -subset  <span class="math">S</span>  of signers.</p>

    <p class="text-gray-300">Algorithm 4  <span class="math">k</span> -Aggregation Algorithm  <span class="math">k</span> -AGGREGATE</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PUBLIC INPUT:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Keys P1, ..., Pn ∈ G2 Message m ∈ {0,1}^* Private INPUT: k - Subset S ⊂ {1, ..., n} Signatures (σi)i∈S ∈ G1^k</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OUTPUT:</td>

            <td class="px-3 py-2 border-b border-gray-700">Threshold Signature. Σ = (π, P) ∈ Zq × G1 × G4[log2(n)]+3 ∪ {⊥}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">\\exists i\\in S</span>  such that  <span class="math">e(\\sigma_i,H)\\neq e(\\mathcal{H}(m),P_i)</span>  output  <span class="math">\\perp</span>  and abort.</li>

      <li>Compute the unique polynomial  <span class="math">p(X) = 1 + \\sum_{i=1}^{n-k} a_j X^j \\in \\mathbb{Z}_q[X]</span>  of degree at most  <span class="math">n - k</span>  such that  <span class="math">p(i) = 0</span>  for all  <span class="math">i \\in \\{1, \\ldots, n\\} \\backslash S</span> .</li>

      <li>Compute  <span class="math">\\widetilde{\\sigma}_i\\coloneqq p(i)\\sigma_i</span>  for all  <span class="math">i\\in S</span>  and set  <span class="math">\\widetilde{\\sigma}_i = 0</span>  for all  <span class="math">i\\notin S</span></li>

      <li>Let  <span class="math">\\mathbf{x} = (a_{1},\\ldots ,a_{n - k},\\widetilde{\\sigma}_{1},\\ldots ,\\widetilde{\\sigma}_{n})\\in \\mathbb{Z}_{q}^{n - k}\\times \\mathbb{G}_{1}^{n}</span>  and compute commitment  <span class="math">P = \\mathrm{COM}(\\mathbf{x},\\gamma)\\in \\mathbb{G}_T</span>  for  <span class="math">\\gamma \\in \\mathbb{Z}_q</span>  sampled uniformly at random.</li>

      <li>Run the non-interactive variant of  <span class="math">\\varPi_{c}</span>  to produce a proof  <span class="math">\\pi</span>  attesting that the committed vector  <span class="math">\\mathbf{x}</span>  satisfies  <span class="math">f_{i}(\\mathbf{x}) = f_{i}(a_{1},\\ldots ,a_{n - k},\\widetilde{\\sigma}_{1},\\ldots \\widetilde{\\sigma}_{n}) = e(\\mathcal{H}(m),P_{i})</span>  for all  <span class="math">1\\leq i\\leq n</span> , where  <span class="math">f_{i}</span>  are homomorphisms defined in Equation (8).</li>

      <li>Output commitment  <span class="math">P</span>  and the non-interactive proof  <span class="math">\\pi \\in \\mathbb{Z}_q\\times \\mathbb{G}_1\\times \\mathbb{G}_T^{4\\lceil \\log_2(n)\\rceil +2}</span></li>

    </ol>

    <p class="text-gray-300">Theorem 6 (Threshold Signature Scheme). The  <span class="math">k</span> -out-of- <span class="math">n</span>  threshold signature scheme defined by the BLS signatures scheme [BLS01, BLS04] appended with the algorithms  <span class="math">(k</span> -AGGREGATE,  <span class="math">k</span> -VERIFY) is correct and unforgeable. Moreover:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A threshold signature contains exactly <span class="math">4\\left\\lceil\\log_{2}(n)\\right\\rceil+3</span> <span class="math">\\mathbb{G}_{T}</span>-elements, <span class="math">1</span> <span class="math">\\mathbb{G}_{1}</span>-element and <span class="math">1</span> <span class="math">\\mathbb{Z}_{q}</span>-element.</li>

      <li>A threshold signature is zero-knowledge on the identities of the <span class="math">k</span> signers.</li>

      <li>The threshold <span class="math">k</span> can be chosen at aggregation time.</li>

      <li>It resists against an adaptive adversary which can replace the public keys of corrupted players.</li>

    </ul>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Correctness immediately follows from the completeness of <span class="math">\\Pi_{c}</span>.</p>

    <p class="text-gray-300">Unforgeability. The proof is similar to the proof of <em>[x1, Theorem 6]</em>. From special-soundness of <span class="math">\\Pi_{c}</span> (Theorem 5), it follows that there exists an efficient extractor <span class="math">\\chi</span> that outputs a vector <span class="math">\\mathbf{x}^{\\prime}=(\\mathbf{a}^{\\prime},S_{1},\\ldots,S_{n})\\in\\mathbb{Z}_{q}^{n-k}\\times\\mathbb{G}_{1}^{n}</span> such that <span class="math">f_{i}(\\mathbf{x})=e(\\mathcal{H}(m),P_{i})</span> for all <span class="math">1\\leq i\\leq n</span>, where <span class="math">f_{i}</span> are as in Equation (8). Let us denote <span class="math">p^{\\prime}(X)=1+\\sum_{i=1}^{n-k}a_{j}^{\\prime}X^{k}\\in\\mathbb{Z}_{q}[X]</span>, then <span class="math">\\mathcal{S}^{\\prime}=\\{i:p^{\\prime}(i)\\neq 0\\}</span> has cardinality at least <span class="math">k</span>. Moreover, it is easily seen that <span class="math">p^{\\prime}(i)^{-1}S_{i}</span> is a valid BLS signature on message <span class="math">m</span> associated to public key <span class="math">P_{i}</span>. Hence, an adversary capable of forging a threshold signature is also capable of computing <span class="math">k</span> distinct valid signatures on <span class="math">m</span>. Since the adversary is capable of corrupting at most <span class="math">k-1</span> players, this contradicts the unforgeability of the BLS signature scheme.</p>

    <p class="text-gray-300">The remaining properties are trivially verified. ∎</p>

    <h2 id="sec-41" class="text-2xl font-bold">6 Generalized Circuit Zero-Knowledge Protocols</h2>

    <p class="text-gray-300">The Compressed <span class="math">\\Sigma</span>-Protocol <span class="math">\\Pi_{c}</span> of Section 4 allows a prover to prove linear statements. In this section, we show how to handle non-linear statements. Our approach is a generalization of the linearization techniques of <em>[x2]</em>, where it was shown how to linearize non-linearities in arithmetic circuit relations. More precisely, we aim to find a SHVZK PoK for proving knowledge of a witness <span class="math">\\mathbf{x}</span> such that <span class="math">C(\\mathbf{x})=0</span> for some circuit <span class="math">C</span> defined over a bilinear group, i.e., a protocol for the following circuit satisfiability relation:</p>

    <p class="text-gray-300"><span class="math">R_{cs}=\\{(C;\\mathbf{x}):C(\\mathbf{x})=0\\}.</span> (9)</p>

    <p class="text-gray-300">Circuits defined over a bilinear group have the following form:</p>

    <p class="text-gray-300"><span class="math">C:\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}\\to\\mathbb{Z}_{q}^{s_{0}}\\times\\mathbb{G}_{1}^{s_{1}}\\times\\mathbb{G}_{2}^{s_{2}}\\times\\mathbb{G}_{T}^{s_{T}}.</span></p>

    <p class="text-gray-300">These circuits are also called bilinear group arithmetic circuits <em>[x14]</em> and they are composed of addition gates and the following 5 types of bilinear gates:</p>

    <p class="text-gray-300">\\[ \\begin{array}[]{lll}\\text{Gate}_{0}:\\mathbb{Z}_{q}&\\times\\mathbb{Z}_{q}&\\to\\mathbb{Z}_{q},&(a,b)\\to ab,\\\\ \\text{Gate}_{1}:\\mathbb{G}_{1}&\\times\\mathbb{Z}_{q}&\\to\\mathbb{G}_{1},&(g,a)\\to ga,\\\\ \\text{Gate}_{2}:\\mathbb{G}_{2}&\\times\\mathbb{Z}_{q}&\\to\\mathbb{G}_{2},&(h,a)\\to ha,\\\\ \\text{Gate}_{3}:\\mathbb{G}_{T}&\\times\\mathbb{Z}_{q}&\\to\\mathbb{G}_{T},&(k,a)\\to ka,\\\\ \\text{Gate}_{4}:\\mathbb{G}_{1}&\\times\\mathbb{G}_{2}&\\to\\mathbb{G}_{T},&(g,h)\\to e(g,h).\\end{array} \\] (10)</p>

    <p class="text-gray-300">Each wire of <span class="math">C</span> corresponds to a variable that takes values in a group <span class="math">W\\in\\{\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}\\}</span>. We assume all gates to have fan-in two and unbounded fan-out. Note that these circuits are indeed generalizations of arithmetic circuits, where wires take values in <span class="math">\\mathbb{Z}_{q}</span>, and gates are addition or multiplication gates.</p>

    <p class="text-gray-300">Bilinear gates taking one constant and one variable input value are linear mappings. Hence, circuits <span class="math">C</span> containing no bilinear gates with two variable inputs are handled directly by the techniques from Section 4. In this case, <span class="math">C(\\mathbf{x})=f(\\mathbf{x})+a</span> for a homomorphism <span class="math">f</span> and a fixed constant <span class="math">a</span>. A protocol for relation <span class="math">R_{cs}</span> then goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to <span class="math">\\mathbf{x}\\in\\mathbb{Z}_{q}^{n_{0}}\\times\\mathbb{G}_{1}^{n_{1}}\\times\\mathbb{G}_{2}^{n_{2}}\\times\\mathbb{G}_{T}^{n_{T}}</span>.</li>

      <li>The prover and the verifier run <span class="math">\\Pi_{c}</span> to open the homomorphism <span class="math">f</span>, i.e., the prover reveals a value <span class="math">y</span> and proves that <span class="math">f(\\mathbf{x})=y</span>.</li>

      <li>The verifier checks that <span class="math">y+a=0</span>.</li>

    </ol>

    <p class="text-gray-300">When <span class="math">C</span> contains bilinear gates, we cannot express the circuit in this linear manner. To handle non-linearities, the prover appends the secret vector <span class="math">\\mathbf{x}</span> with a vector <span class="math">\\mathsf{aux}</span> containing auxiliary information, i.e., in the first step of the protocol the prover commits to the appended vector <span class="math">(\\mathbf{x},\\mathsf{aux})</span>. The approach is a generalization of the secret sharing based techniques from <em>[x1]</em>; linearizing non-linearities.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{c}</span> be the vector of wire values associated to the output wires of all the bilinear gates in <span class="math">C(\\mathbf{x})</span>. Note that <span class="math">\\mathbf{c}</span> depends on the secret vector <span class="math">\\mathbf{x}</span>. Then, there exists a homomorphism <span class="math">f</span> and a constant <span class="math">a</span>, independent from <span class="math">\\mathbf{x}</span>, such that <span class="math">C(\\mathbf{x})=f(\\mathbf{x},\\mathbf{c})+a</span>. A naive generalization of the above approach to arbitrary circuits is now obtained by taking <span class="math">\\mathsf{aux}=\\mathbf{c}</span>. However, this approach does not guarantee that the committed vector <span class="math">(\\mathbf{x},\\mathbf{c})</span> is of the appropriate form, i.e., that <span class="math">\\mathbf{c}</span> corresponds to the outputs of bilinear gates when <span class="math">C</span> is evaluated in <span class="math">\\mathbf{x}</span>.</p>

    <p class="text-gray-300">To prove that the committed vector <span class="math">(\\mathbf{x},\\mathbf{c})</span> is of the appropriate form the inputs and outputs of the bilinear gates are encoded in polynomials <span class="math">f\\in A[X]</span> where <span class="math">A\\in\\{\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}\\}</span>. We first describe some properties of these polynomials.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">6.1 Polynomials over Groups of Prime Order</h3>

    <p class="text-gray-300">The <span class="math">\\mathbb{Z}_{q}</span>-module structure of the groups <span class="math">\\mathbb{G}_{i}</span> naturally extends to their polynomial rings, i.e., <span class="math">\\mathbb{G}_{i}[X]</span> is a <span class="math">\\mathbb{Z}_{q}[X]</span>-module for all <span class="math">i</span> and the product <span class="math">h(X)</span> of two polynomials <span class="math">f(X)=\\sum_{i=0}^{n}a_{i}X^{i}\\in\\mathbb{Z}_{q}[X]</span> and <span class="math">g(X)=\\sum_{i=0}^{m}g_{i}X^{i}\\in\\mathbb{G}_{i}[X]</span> is defined as follows</p>

    <p class="text-gray-300"><span class="math">h(X)=f(X)g(X):=\\sum_{i=0}^{n}\\sum_{j=0}^{m}(a_{i}g_{j})X^{i+j}\\in\\mathbb{G}_{i}[X].</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathbb{G}_{i}</span> is a <span class="math">\\mathbb{Z}_{q}</span>-module, a polynomial <span class="math">f=\\sum_{i=0}^{n}a_{i}X^{i}\\in\\mathbb{G}_{i}[X]</span> defines a mapping <span class="math">f:\\mathbb{Z}_{q}\\to\\mathbb{G}_{i},\\quad\\rho\\to f(\\rho)=\\sum_{i=0}^{n}a_{i}\\rho^{i}</span>, called the “evaluation” mapping. Moreover, every <span class="math">\\rho\\in\\mathbb{Z}_{q}</span> defines a mapping:</p>

    <p class="text-gray-300"><span class="math">F_{\\rho}:\\mathbb{G}_{i}[X]\\to\\mathbb{G}_{i},\\quad f=\\sum_{i=0}^{n}a_{i}X^{i}\\to f(\\rho)=\\sum_{i=0}^{n}a_{i}\\rho^{i},</span></p>

    <p class="text-gray-300">called the “evaluation at <span class="math">\\rho</span>” mapping, which is linear.</p>

    <p class="text-gray-300">A bilinear gate <span class="math">\\mathrm{Gate}:\\mathrm{L}\\times\\mathrm{R}\\to\\mathrm{U}</span> can be extended to act on polynomials:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Gate}\\left(\\sum_{i=0}^{n}a_{i}X^{i},\\sum_{j=0}^{m}b_{j}X^{j}\\right)=\\sum_{i=0}^{n}\\sum_{j=0}^{m}\\mathrm{Gate}(a_{i},b_{j})X^{i+j}\\in\\mathrm{U}[X].</span> (11)</p>

    <p class="text-gray-300">By the bilinearity of <span class="math">\\mathrm{Gate}</span> it follows that this mapping commutes with polynomial evaluation, i.e., for all <span class="math">\\rho\\in\\mathbb{Z}_{q}</span> it holds that <span class="math">\\mathrm{Gate}(f(\\rho),g(\\rho))=\\mathrm{Gate}(f,g)(\\rho)</span>.</p>

    <p class="text-gray-300">The following lemma shows that a non-zero polynomial <span class="math">f</span> has at most <span class="math">\\deg(f)</span> zeros. From this it follows that, for a fixed non-zero polynomial <span class="math">f</span> and a random challenge <span class="math">c</span>, the probability that <span class="math">f(c)=0</span> is at most <span class="math">\\deg(f)/q</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">Let <span class="math">f(X)\\in A[X]</span> be non-zero, for some <span class="math">A\\in\\{\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}\\}</span>. Then <span class="math">f(X)</span> has at most <span class="math">\\deg(f)</span> zeros.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">A</span> has prime order <span class="math">q</span> and let <span class="math">g</span> be a generator of <span class="math">A</span>. Then it is easily seen that <span class="math">f(X)=f^{\\prime}(X)g</span> for some polynomial <span class="math">f^{\\prime}(X)\\in\\mathbb{Z}_{q}[X]</span> with <span class="math">\\deg(f)=\\deg(f^{\\prime})</span>. Moreover, since <span class="math">g</span> is a generator of <span class="math">A</span>, it holds that <span class="math">f(a)=0</span> if and only if <span class="math">f^{\\prime}(a)=0</span>. The lemma now follows from the fact that a non-zero polynomial <span class="math">f^{\\prime}</span> defined over the field <span class="math">\\mathbb{Z}_{q}</span> has at most <span class="math">\\deg(f^{\\prime})</span> zeros. ∎</p>

    <p class="text-gray-300">The following lemma describes an approach for testing whether three polynomials <span class="math">f(X)</span>, <span class="math">g(X)</span> and <span class="math">h(X)</span> satisfy a bilinear relation defined by <span class="math">\\mathrm{Gate}:\\ \\mathrm{L}\\times\\mathrm{R}\\to\\mathrm{U}</span>. More precisely, when the bilinear relation holds in a random evaluation point <span class="math">c\\in\\mathbb{Z}_{q}</span> then, with high probability, it holds for the polynomials <span class="math">f</span>, <span class="math">g</span> and <span class="math">h</span>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 3.</h6>

    <p class="text-gray-300">Let <span class="math">f(X)\\in\\mathrm{L}[X]</span>, <span class="math">g(X)\\in\\mathrm{R}[X]</span> and <span class="math">h(X)\\in\\mathrm{U}[X]</span> with <span class="math">\\deg(f),\\deg(g)\\leq n</span> and <span class="math">\\deg(h)\\leq 2n</span>. Then, for <span class="math">d\\in\\mathcal{C}\\subset\\mathbb{Z}_{q}</span> sampled uniformly at random, it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left(\\mathrm{Gate}\\left(f(d),g(d)\\right)=h(d)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Gate}\\left(f(X),g(X)\\right)\\neq h(X))\\leq 2n/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The polynomial <span class="math">h(X)-\\mathrm{Gate}\\left(f(X),g(X)\\right)\\in\\mathrm{U}[X]</span> has degree at most <span class="math">2n</span>. The lemma now follows from Lemma 2. ∎</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">6.2 Linearization of Bilinear Gates</h3>

    <p class="text-gray-300">We are now ready to describe the linearization approach. To this end, for <span class="math">0\\leq i\\leq 4</span>, let <span class="math">m_{i}</span> be the number of gates <span class="math">\\mathrm{Gate}_{i}\\colon\\mathrm{L}_{i}\\times\\mathrm{R}_{i}\\to\\mathrm{U}_{i}</span> of type <span class="math">i</span> in circuit <span class="math">C</span>. Then, for a circuit evaluation <span class="math">C(\\mathbf{x})</span>, we let <span class="math">\\mathbf{a}_{i}\\in\\mathrm{L}_{i}^{m_{i}}</span> and <span class="math">\\mathbf{b}_{i}\\in\\mathrm{R}_{i}^{m_{i}}</span> be the vectors of left and right input values of these gates. Similarly, we let <span class="math">\\mathbf{c}_{i}\\in\\mathrm{U}_{i}^{m_{i}}</span> be the vector of output values for the gates of type <span class="math">i</span>.</p>

    <p class="text-gray-300">The protocol now goes as follows. First, for each <span class="math">i</span>, the prover samples two polynomials <span class="math">f_{i}(X)\\in\\mathrm{L}_{i}[X]_{\\leq m_{i}}</span> and <span class="math">g_{i}(X)\\in\\mathrm{R}_{i}[X]_{\\leq m_{i}}</span> of degree at most <span class="math">m_{i}</span> uniformly at random under the condition that <span class="math">f_{i}(j)=a_{i,j}</span> and <span class="math">g_{i}(j)=b_{i,j}</span> for all <span class="math">1\\leq j\\leq m_{i}</span>. Note that these polynomials define packed Shamir secret sharings <em>[x20]</em> with <span class="math">(m_{i}+1)</span>-reconstruction and <span class="math">1</span>-privacy of the vectors <span class="math">\\mathbf{a}_{i}</span> and <span class="math">\\mathbf{b}_{i}</span>, i.e., the vectors <span class="math">\\mathbf{a}_{i}</span> and <span class="math">\\mathbf{b}_{i}</span> can be reconstructed from any <span class="math">m_{i}+1</span> evaluations of <span class="math">f_{i}(X)</span> and <span class="math">g_{i}(X)</span> and any single evaluation outside <span class="math">\\{1,\\ldots,m_{i}\\}</span> is independent from the vectors <span class="math">\\mathbf{a}_{i}</span> and <span class="math">\\mathbf{b}_{i}</span>.</p>

    <p class="text-gray-300">Second, the prover computes the polynomial <span class="math">h_{i}(X)=\\mathrm{Gate}_{i}\\left(f_{i}(X),g_{i}(X)\\right)</span>. By the strong-multiplicativity of Shamir’s secret sharing scheme, <span class="math">h_{i}(X)\\in\\mathrm{U}_{i}[X]</span> defines a packed secret sharing of the vector <span class="math">\\mathbf{c}_{i}\\in\\mathrm{U}_{i}^{m_{i}}</span> with <span class="math">2m_{i}+1</span> reconstruction. More precisely, <span class="math">h_{i}(X)</span> is of degree at most <span class="math">2m_{i}</span> and <span class="math">h_{i}(j)=c_{i,j}</span> for all <span class="math">1\\leq j\\leq m_{i}</span>. Subsequently, the prover sends a commitment to the following secret vector to the verifier:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=\\big{(}\\mathbf{x},f_{0}(0),g_{0}(0),h_{0}(0),\\ldots,h_{0}(2m_{0}),\\ldots,f_{4}(0),g_{4}(0),h_{4}(0),h_{4}(1),\\ldots,h_{4}(2m_{4})\\big{)}.</span></p>

    <p class="text-gray-300">The vector <span class="math">\\mathbf{y}=(\\mathbf{x},\\mathsf{aux})</span> contains the vector <span class="math">\\mathbf{c}=(\\mathbf{c}_{1},\\ldots,\\mathbf{c}_{\\ell})</span> of the output values of all bilinear gates as a sub-vector. Hence, all wire values can be expressed as the evaluation of some public homomorphism in <span class="math">\\mathbf{y}</span> plus a public constant value. This holds in particular for the evaluations <span class="math">f_{i}(j)</span> and <span class="math">g_{i}(j)</span> for all <span class="math">1\\leq i\\leq\\ell</span> and <span class="math">1\\leq j\\leq m_{j}</span>. Hence, for every <span class="math">i</span>, <span class="math">m_{i}+1</span> evaluations of <span class="math">f_{i}</span> and <span class="math">g_{i}</span> can be computed as affine functions evaluated in <span class="math">\\mathbf{y}</span>, i.e., <span class="math">\\mathbf{y}</span> uniquely defines polynomials <span class="math">f_{i}(X)</span> and <span class="math">g_{i}(X)</span> of degree at most <span class="math">m_{i}</span>. Similarly, <span class="math">\\mathbf{y}</span> uniquely defines polynomials <span class="math">h_{i}(X)</span> of degree at most <span class="math">2m_{i}</span>. By the linearity of Lagrange interpolation it follows that, in addition to the wire values, all evaluations of the polynomials <span class="math">f_{i}(X)</span>, <span class="math">g_{i}(X)</span> and <span class="math">h_{i}(X)</span> can be expressed as some homomorphism evaluated in <span class="math">\\mathbf{y}</span> plus a constant.</p>

    <p class="text-gray-300">These properties allow the prover to convince the verifier that the vector <span class="math">\\mathbf{y}</span> is of the appropriate form by proving that certain linear constraints hold. Namely, in the next step of the protocol, the verifier samples a random challenge <span class="math">d\\in\\mathbb{Z}_{q}\\setminus\\{1,\\ldots,\\max(m_{i})\\}</span> uniformly at random and asks the prover to run protocol <span class="math">\\Pi_{c}</span> to open <span class="math">C(\\mathbf{x})</span>, <span class="math">f_{i}(d)</span>, <span class="math">g_{i}(d)</span> and <span class="math">h_{i}(d)</span> for all <span class="math">1\\leq i\\leq\\ell</span>. Note that all these values correspond to homomorphisms evaluated in the committed vector <span class="math">\\mathbf{y}=(\\mathbf{x},\\mathsf{aux})</span>. To further reduce the communication costs, the amortization techniques mentioned in 4.7 are applied. Finally, the verifier verifies that <span class="math">C(\\mathbf{x})=0</span> and that <span class="math">\\mathrm{Gate}\\left(f_{i}(d),g_{i}(d)\\right)=h_{i}(d)</span> for all <span class="math">0\\leq i\\leq 4</span>. By Lemma 3 this final verification implies that <span class="math">\\mathrm{Gate}\\left(f_{i}(X),g_{i}(X)\\right)=h_{i}(X)</span>, and therefore that <span class="math">\\mathrm{Gate}\\left(a_{i,j},b_{i,j}\\right)=c_{i,j}</span> for all <span class="math">j</span>, with probability at least <span class="math">1-2m_{i}/(q-m_{i})</span>. If <span class="math">m_{i}</span> is polynomial and <span class="math">q</span> is exponential in the security parameter, this probability is overwhelming. The protocol is SHVZK because the polynomials <span class="math">f_{i}(X)</span>, <span class="math">g_{i}(X)</span> and <span class="math">h_{i}(X)</span> define secret sharings with <span class="math">1</span>-privacy, and because protocol <span class="math">\\Pi_{c}</span> is SHVZK. For a more detailed discussion we refer to <em>[x1]</em> in which this approach is restricted to arithmetic circuits.</p>

    <p class="text-gray-300">The resulting protocol, denoted by <span class="math">\\Pi_{cs}</span>, is described in Protocol 5. To state the properties of protocol <span class="math">\\Pi_{cs}</span> observe that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\mathbf{x},\\mathsf{aux})\\in\\mathbb{Z}_{q}^{n_{0}+2m_{0}+6}\\times\\mathbb{G}_{1}^{n_{1}+2m_{1}+3}\\times\\mathbb{G}_{1}^{n_{2}+2m_{2}+3}\\times\\mathbb{G}_{T}^{n_{T}+2m_{3}+2m_{4}+3},</span></p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{y}</span>  is the vector to which the prover commits in the first round of protocol  <span class="math">\\varPi_{cs}</span> . For ease of notation we define the following parameters:</p>

    <div class="my-4 text-center"><span class="math-block">m := \\max  (m _ {i}), \\quad s := \\max  (s _ {0} + 6, s _ {1} + 3, s _ {2} + 3, s _ {T} + 3),</span></div>

    <div class="my-4 text-center"><span class="math-block">N := \\max  \\left(n _ {0} + 2 m _ {0} + 7, n _ {1} + 2 m _ {1} + 3, n _ {2} + 2 m _ {2} + 3\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">N _ {T} := n _ {T} + 2 m _ {3} + 2 m _ {4} + 3.</span></div>

    <p class="text-gray-300">Note that we make a distinction between the  <span class="math">(\\mathbb{Z}_q,\\mathbb{G}_1,\\mathbb{G}_2)</span> -part, for which the commitment scheme is compact, and the  <span class="math">\\mathbb{G}_T</span> -part of the vector  <span class="math">\\mathbf{y}</span> . Using this notation, the properties of  <span class="math">\\varPi_{cs}</span>  are summarized in Theorem 7.</p>

    <p class="text-gray-300">Theorem 7 (Circuit Zero-Knowledge Protocol for Bilinear Circuits).  <span class="math">\\Pi_{cs}</span>  is a  <span class="math">(2\\mu + 7)</span> -move protocol for circuit relation  <span class="math">R_{cs}</span> , where  <span class="math">\\mu = \\lceil \\log_2(N) \\rceil</span> . It is perfectly complete, special honest-verifier zero-knowledge, under the DDH assumption in  <span class="math">\\mathbb{G}_T</span> , and computationally  <span class="math">(2m + 1, s, 2, 2, 3, \\ldots, 3)</span> -special-sound under the SXDH assumption. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">6\\mu + N_T + 9</span> <span class="math">\\mathbb{G}_T</span> -elements, 4  <span class="math">\\mathbb{G}_1</span> -elements, 4  <span class="math">\\mathbb{G}_2</span> -elements and 8  <span class="math">\\mathbb{Z}_q</span> -elements.</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\mu + 4\\mathbb{Z}_q</span> -elements.</li>

    </ul>

    <p class="text-gray-300">Remark 3. Without the improvement of Section 4.5, for El Gamal based commitments, the prover would have to communicate  <span class="math">2N_{T}</span>  additional  <span class="math">\\mathbb{G}_T</span>  elements in protocol  <span class="math">\\varPi_{cs}</span> . Hence, this improvement causes the constant in front of the only linear term of the communication costs to be reduced from 3 down to 1.</p>

    <p class="text-gray-300">Protocol 5 Circuit Satisfiability Argument  <span class="math">\\Pi_{cs}</span>  for Relation  <span class="math">R_{cs}</span></p>

    <p class="text-gray-300">The polynomials  <span class="math">f_{i}</span>  and  <span class="math">g_{i}</span>  are sampled uniformly at random such that their evaluations in  <span class="math">1, \\ldots, m_{i} \\in \\mathbb{Z}_{q}</span>  coincide with the left and, respectively, right inputs of the  <span class="math">m_{i}</span>  type  <span class="math">i</span>  gates of  <span class="math">C</span>  evaluated in  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">6.3 Comparison of the Communication Costs</p>

    <p class="text-gray-300">In this section, we compare the communication costs of our protocol <span class="math">\\Pi_{cs}</span> to the bilinear circuit ZK protocol of <em>[x10]</em>. We note that, a rigorous comparison is difficult, for the following two reasons. First, we consider arbitrary bilinear circuits, whereas they assume certain structural properties. The communication costs stated in <em>[x10]</em> hold only for circuits in which the gates with <span class="math">\\mathbb{G}_{T}</span> outputs are output gates. Second, we consider a strictly stronger scenario in which the prover proves that the committed input values satisfy some bilinear relation, instead of merely proving knowledge of a satisfying input vector without being committed to this input vector, i.e., we consider a commit-and-proof functionality. This difference explains why their communications costs are independent of the input dimensions <span class="math">n_{0}</span>, <span class="math">n_{1}</span> and <span class="math">n_{2}</span>.</p>

    <p class="text-gray-300">Despite these two aspects, showing that we consider a stronger application scenario, it is interesting to note that our communication costs are smaller in certain parameter regimes. From Theorem 7 it follows that our Protocol <span class="math">\\Pi_{cs}</span> requires the prover to send a total of</p>

    <p class="text-gray-300"><span class="math">6\\left\\lceil\\log_{2}\\left(N\\right)\\right\\rceil+N_{T}+28</span></p>

    <p class="text-gray-300">elements (group and field elements) to the verifier, i.e., the communication costs associated to the <span class="math">(\\mathbb{Z}_{q},\\mathbb{G}_{1},\\mathbb{G}_{2})</span>-part are logarithmic and the communications costs associated to the <span class="math">\\mathbb{G}_{T}</span>-part are linear. By contrast, the protocol of <em>[x10]</em> results in a total communication cost of</p>

    <p class="text-gray-300"><span class="math">16\\log_{2}\\left(\\ell_{mix}\\right)+3n_{T}+71</span></p>

    <p class="text-gray-300">elements, where <span class="math">\\ell_{mix}=2m_{0}^{\\prime}+m_{1}^{\\prime}+m_{2}^{\\prime}+n_{T}m_{3}^{\\prime}+m_{4}^{\\prime}</span>. Here, the variable <span class="math">m_{i}^{\\prime}</span> counts all gates of type <span class="math">i</span>, including the ones taking a constant input value, i.e., <span class="math">m_{i}^{\\prime}\\geq m_{i}</span>. Hence, we have reduced the constant of the logarithmic part from <span class="math">16</span> down to <span class="math">6</span>, and the constant of the linear part from <span class="math">3</span> down to <span class="math">1</span>. However, when comparing the linear parts of the communication complexity, we note that there exist bilinear circuits for which <span class="math">3n_{T}&lt;N_{T}=n_{T}+2m_{3}+2m_{4}+3</span>, e.g., circuits with <span class="math">n_{T}=0</span> and <span class="math">m_{4}&gt;0</span>. Therefore, depending on the bilinear circuit our linear communication costs can be larger. This can partially be explained by the fact that Lai et al. <em>[x10]</em> make structural assumptions on the bilinear circuit. For instance, they assume that only input and output wires can take values in <span class="math">\\mathbb{G}_{T}</span>, whereas our protocol works for arbitrary bilinear circuits.</p>

    <p class="text-gray-300">Nevertheless, as opposed to general bilinear circuits, there are specific quadratic inner-product relations for which the approach of Lai et al. <em>[x10]</em> can result in communication costs lower than those obtained by applying our generic approach. These relations exploit the fact that their approach reduces bilinear circuit relations to sets of inner-product constraints. These techniques are further improved in Bünz et al. <em>[x3]</em>, who focus on communication-efficient protocols for quadratic inner-product relations. By contrast, for the example of threshold signature schemes, which only rely on linear circuits, application of the latter approach would result in unnecessary overhead as compared to our compressed <span class="math">\\Sigma</span>-protocol approach.</p>

    <h2 id="sec-48" class="text-2xl font-bold">7 Proving Knowledge of Signed Messages Satisfying a Public Predicate</h2>

    <p class="text-gray-300">In this section, we consider a functionality more general than that of threshold signature schemes. Namely, proving knowledge of a set of signed messages <span class="math">m_{1},\\ldots,m_{n}</span> satisfying a public predicate <span class="math">F(m_{1},\\ldots,m_{n})=0</span>. Moreover, we allow the prover to choose <span class="math">n-k</span> input messages <span class="math">m_{i}</span> freely, i.e., the prover is only required to prove knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> valid signatures.</p>

    <p class="text-gray-300">More precisely, we aim to construct a proof-of-knowledge for relation</p>

    <p class="text-gray-300"><span class="math">R_{\\sf pred}=\\big{\\{}\\left({\\sf pk}_{1},\\ldots,{\\sf pk}_{n},{\\sf tag};m_{1},\\ldots,m_{n},\\mathcal{S},(\\sigma_{i})_{i\\in\\mathcal{S}}\\right):</span> (12)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$F(m_{1},\\ldots,m_{n})=0,\\;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\textsc{verify}({\\sf pk}_{i},(m_{i},{\\sf tag}),\\sigma_{i})=\\textsc{accept}\\;\\forall i\\in\\mathcal{S}\\big{\\}}.</span></p>

    <p class="text-gray-300">The public statement contains the public-keys of the <span class="math">n</span> players and a tag. The tag is a unique identifier that, for example, ensures that a dishonest player can not reuse signatures received in previous rounds of the protocol. Signatures <span class="math">\\sigma_{i}</span> on the pair <span class="math">(m_{i},{\\sf tag})</span> can be verified by running the algorithm Verify.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">In <em>[x18]</em>, a communication-efficient proof (or argument) of knowledge for relation <span class="math">R_{\\sf pred}</span> is used for communication-efficient consensus; zero-knowledge is not required in their application. Black-box application of such a PoK suffices, but typically requires relation <span class="math">R_{\\sf pred}</span> to be captured by an arithmetic circuit. As stated before, this generic black-box approach results in large arithmetic circuits with sub-optimal concrete efficiency. Using our techniques, we avoid this cumbersome transformation by directly constructing a PoK for relation <span class="math">R_{\\sf pred}</span>. However, the required functionality does not follow straightforwardly and some adaptations are required. We demonstrate the plug-and-play nature of compressed <span class="math">\\Sigma</span>-protocol theory by composing the different elements of this theory with a novel building block to construct the required protocol.</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">7.1 Communication-Efficient Protocol</h3>

    <p class="text-gray-300">Let us now describe our approach. By assuming that the input messages <span class="math">m_{i}</span> are elements of <span class="math">\\mathbb{Z}_{q}</span> and that <span class="math">F</span> can be described by an arithmetic circuit, proving that the constraint <span class="math">F(m_{1},\\ldots,m_{n})=0</span> is satisfied follows directly from the techniques from Section 6. Hence, for simplicity, we consider the relation</p>

    <p class="text-gray-300"><span class="math">R^{\\prime}_{\\sf pred}=\\big{\\{}</span> <span class="math">\\left(\\sf pk_{1},\\ldots,\\sf pk_{n},\\sf tag;m_{1},\\ldots,m_{n},\\mathcal{S},(\\sigma_{i})_{i\\in\\mathcal{S}}\\right):</span> (13)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=k,\\ \\textsc{verify}(\\sf pk_{i},(m_{i},\\sf tag),\\sigma_{i})=\\sf{accept}\\ \\forall i\\in\\mathcal{S}\\big{\\}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This relation is very similar to the threshold signature relation <span class="math">R_{T}</span> of Equation 6. However, there is one important difference that requires us to make certain protocol adaptations. Namely, in the TSS relation all players sign the same public message. Here, the players sign secret and possibly different messages <span class="math">m_{1},\\ldots,m_{n}</span>.</p>

    <p class="text-gray-300">The BLS verification algorithm involves the evaluation of a hash function <span class="math">H(m_{i})</span>. Because the messages in relation <span class="math">R^{\\prime}_{\\sf pred}</span> are secret, a direct application of our circuit ZK approach to BLS signatures requires the cumbersome and inefficient approach of expressing the hash function as an arithmetic circuit. Recall that, the protocol is not required to be zero-knowledge. However, revealing the messages <span class="math">m_{i}</span> requires a linear communication complexity. For this reason, we consider the structure preserving signature (SPS) scheme of <em>[x1]</em>, that avoids the use of hash functions. For a complete description of the signature scheme we refer to <em>[x1]</em>. Here, we are mainly interested in the verification algorithm.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">Structure Preserving Signature Scheme.</h4>

    <p class="text-gray-300">The SPS scheme works over a bilinear group <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,G,H)</span> and it allows a prover to sign a pair of group elements <span class="math">(M,N)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span>. The verification key is of the form <span class="math">(U,V,W,Z)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}^{3}</span> and a signature is of the form <span class="math">(R,S,T)\\in\\mathbb{G}_{1}^{2}\\times\\mathbb{G}_{2}</span>. A signature <span class="math">(R,S,T)</span> on a message <span class="math">(M,N)</span> is accepted by a verifier if the following two equations hold</p>

    <p class="text-gray-300">(1) <span class="math">e(R,V)+e(S,H)+e(M,W)=e(G,Z),</span> (14) (2) <span class="math">e(R,T)+e(U,N)=e(G,H).</span></p>

    <p class="text-gray-300">Recall that group operations in <span class="math">\\mathbb{G}_{T}</span> are written additively. Note that this signature scheme allows a prover to sign pairs of group elements, while what we actually need is a scheme for signing pairs of field elements <span class="math">(m_{i},\\sf tag)\\in\\mathbb{Z}_{q}^{2}</span>. However, to sign a pair <span class="math">(m,\\sf tag)\\in\\mathbb{Z}_{q}^{2}</span> the prover simply uses the SPS scheme to create a signature on <span class="math">(mG,\\sf tagH)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span>. Because, group exponentiation is a linear operation this additional step is easily dealt with in our proofs of knowledge. For simplicity, we therefore assume that the input messages and tag of relation <span class="math">R^{\\prime}_{\\sf pred}</span> are group elements, i.e., <span class="math">(M,\\sf tag)\\in\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span>.</p>

    <p class="text-gray-300">Hence, the SPS scheme avoids the hash function and the verification only consists of a small number of bilinear-group operations. This means that, using this signature scheme, both relations <span class="math">R_{\\sf pred}</span> and <span class="math">R^{\\prime}_{\\sf pred}</span> can be captured by small bilinear circuits. Our proofs for bilinear circuit relations, combined with the proofs of partial knowledge <em>[x2]</em>, directly result in the required protocols.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Inner-Product Argument of Knowledge.</h4>

    <p class="text-gray-300">However, this approach still results in communication complexity that is linear in the number of players. The second verification equation of the SPS scheme is not</p>

    <p class="text-gray-300">linear in the input, i.e., it contains a pairing gate <span class="math">e(R,T)</span> taking two variable input values. Combined with the fact that our bilinear circuit protocols have a complexity that is linear in the number of pairing gates with two variable input values, a linear communication complexity follows. To avoid this linear complexity, we make an adaptation to our generic approach. Instead of using the linearization strategy of Section 6, we deploy a protocol that proves a quadratic inner-product relation directly, i.e., without linearizing the non-linearities first. Combined with our techniques this results in PoK for relation <span class="math">R^{\\prime}_{\\textsf{pred}}</span> with a logarithmic communication complexity.</p>

    <p class="text-gray-300">In Appendix A, we present a natural abstraction of an inner-product compression mechanism. Various instantiations of this protocol can be found in literature <em>[BCC^{+}16, BBB^{+}18, LM+19, BMM+19]</em>. The protocol is defined for arbitrary group homomorphisms <span class="math">\\Psi</span>. In our instantiation, <span class="math">\\Psi:\\mathbb{G}_{1}^{n}\\times\\mathbb{G}_{2}^{n}\\to\\mathbb{G}_{T}^{2}</span> will simply be the commitment function of Definition 9 (omitting the commitment randomness). The compression mechanism <span class="math">\\Pi_{\\text{IP}}</span>, is a proof-of-knowledge for the following inner-product relation,</p>

    <p class="text-gray-300"><span class="math">R_{\\text{IP}}=\\{(P,u;x,y):\\Psi(x,y)=P,\\ \\langle x,y\\rangle=u\\}.</span></p>

    <p class="text-gray-300">This protocol is knowledge sound under the assumption that a prover can not find a non-trivial pre-image in <span class="math">\\Psi^{-1}(0)</span>, i.e., the commitment scheme must be binding. When this protocol is applied recursively (as before), the communication complexity is roughly equal to <span class="math">6\\log_{2}(n)</span>. This can be reduced to roughly <span class="math">4\\log_{2}(n)</span> by applying the techniques from Section 4.4.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Composing the Building Blocks.</h4>

    <p class="text-gray-300">We are now ready to describe the composition of the different building blocks resulting in a protocol <span class="math">\\Pi^{\\prime}_{\\textsf{pred}}</span> for relation <span class="math">R^{\\prime}_{\\textsf{pred}}</span>. Similar to our TSS approach, we use the proof-of-partial knowledge techniques <em>[x1]</em> to reduces the <span class="math">k</span>-out-of-<span class="math">n</span> case to the <span class="math">n</span>-out-of-<span class="math">n</span>. To this end, the prover uses an appropriate polynomial <span class="math">p(X)</span> to modify the signatures <span class="math">\\sigma_{i}=(R_{i},S_{i},T_{i})</span>, messages <span class="math">M_{i}</span> and verification equations such that <span class="math">n</span>-out-of-<span class="math">n</span>, instead of <span class="math">k</span>-out-of-<span class="math">n</span> will be satisfied. What remains is for the prover to prove knowledge of a polynomial <span class="math">p(X)=1+\\sum_{j=1}^{n-k}a_{j}X^{j}</span> and modified messages <span class="math">\\widetilde{M}_{i}=p(i)M_{i}</span> and signatures <span class="math">(\\widetilde{R}_{i},\\widetilde{S}_{i},T_{i})=(p(i)R_{i},p(i)S_{i},T_{i})</span> such that</p>

    <p class="text-gray-300">(1) <span class="math">e(\\widetilde{R}_{i},V_{i})+e(\\widetilde{S}_{i},H)+e(\\widetilde{M_{i}},W_{i})=p(i)e(G,Z_{i}),</span> (15) (2) <span class="math">e(\\widetilde{R}_{i},T_{i})=p(i)e(G,H)-p(i)e(U_{i},\\texttt{tag}).</span></p>

    <p class="text-gray-300">To this end the prover commits to a vector <span class="math">\\mathbf{y}</span> containing the coefficients of <span class="math">p(X)</span> and the modified messages and signatures in a single compact commitment <span class="math">P</span>. Using compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span> the linear constraint (1) can easily be proven to be satisfied for all <span class="math">i</span>. To prove that the second non-linear constraint is satisfied for all <span class="math">i</span>, we transform these <span class="math">n</span> constraints into a single inner-product constraint and apply the inner-product protocol <span class="math">\\Pi_{\\text{IP}}</span> described in Appendix A. To this end the verifier sends a challenge <span class="math">\\rho\\in\\mathbb{Z}_{q}</span> sampled uniformly at random to the prover. The prover computes a compact (non-hiding) commitment <span class="math">Q=\\textsc{Com}((\\mathbf{x}^{\\prime},\\mathbf{y}^{\\prime}),0)</span> to the vector <span class="math">(\\mathbf{x}^{\\prime},\\mathbf{y}^{\\prime})=(\\widetilde{R}_{1},\\ldots,\\widetilde{R}_{n},T_{1},\\rho T_{2},\\ldots,\\rho^{n-1}T_{n})</span> and sends <span class="math">Q</span> to the verifier, together with the value</p>

    <p class="text-gray-300"><span class="math">u:=\\sum_{i=1}^{n}\\rho^{i-1}\\left(p(i)e(G,H)-p(i)e(U_{i},\\texttt{tag})\\right)\\in\\mathbb{G}_{T}.</span></p>

    <p class="text-gray-300">Note that <span class="math">Q</span> is the output of a public homomorphism evaluated in <span class="math">\\mathbf{y}</span>. Hence, the prover can prove that it has been computed honestly by running compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span> on public input <span class="math">P</span>. Similarly, the prover shows that <span class="math">u</span> has been computed honestly. As final step of the protocol, the prover uses the inner-product protocol <span class="math">\\Pi_{\\text{IP}}</span> on public input <span class="math">Q</span> to prove that the committed vector <span class="math">(\\mathbf{x}^{\\prime},\\mathbf{y}^{\\prime})</span> satisfies the inner product relation</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{n}e(x^{\\prime}_{i},y^{\\prime}_{i})=u.</span> (16)</p>

    <p class="text-gray-300">From this it follows, with probability at least <span class="math">1-(n-1)/q</span>, that non-linear equation (2) is satisfied for all <span class="math">\\widetilde{R}_{i}</span> and <span class="math">T_{i}</span> committed to in commitment <span class="math">Q</span>. Here, the probability is taken over the randomness of the challenge <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Protocol <span class="math">\\Pi_{\\mathsf{pred}}^{\\prime}</span> for relation <span class="math">R_{\\mathsf{pred}}^{\\prime}</span> is formally described in Algorithm 6. Its communication complexity is easily seen to be logarithmic, because all its components have logarithmic communication. The concrete efficiency of <span class="math">\\Pi_{\\mathsf{pred}}^{\\prime}</span> can be further improved by amortizing certain steps of the protocol. To improve the presentation we have omitted these concrete efficiency improvements.</p>

    <p class="text-gray-300">As mentioned above, the protocol is easily adaptable to messages and tags that are field elements instead of group elements. From there it is straightforward to prove additional constraints (captured by an arithmetic circuit) on the input messages <span class="math">m_{1},\\ldots ,m_{n}</span>. In particular, a protocol <span class="math">\\varPi_{\\mathsf{pred}}</span> for relation <span class="math">R_{\\mathsf{pred}}</span>. The communication complexity of <span class="math">\\varPi_{\\mathsf{pred}}</span> is logarithmic in <span class="math">n</span> and the size of the circuit capturing the predicate <span class="math">F(m_{1},\\dots,m_{n}) = 0</span>.</p>

    <p class="text-gray-300">Algorithm 6 Interactive Protocol <span class="math">\\Pi_{\\mathsf{pred}}^{\\prime}</span> for relation <span class="math">R_{\\mathsf{pred}}^{\\prime}</span> Proving knowledge of <span class="math">k</span>-out-of-<span class="math">n</span> signed messages.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PUBLIC INPUT:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Keys pk_i = (Ui, Vi, Wi, Zi) ∈ G1 × G23 for 1 ≤ i ≤ n, Tag tag ∈ G2.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PRIVATE INPUT:</td>

            <td class="px-3 py-2 border-b border-gray-700">Messages Mi ∈ G1 for 1 ≤ i ≤ n, Signatures σi = (Ri, Si, Ti) ∈ G12 × G2 for 1 ≤ i ≤ n, k - Subset S ⊂ {1, ..., n} such that Verify(pki, (Mi, tag), σi) = accept ∀i ∈ S.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OUTPUT:</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof π</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover computes the unique polynomial <span class="math">p(X) = 1 + \\sum_{j=1}^{n-k} a_j X^j \\in \\mathbb{Z}_q[X]</span> of degree at most <span class="math">n - k</span> such that <span class="math">p(i) = 0</span> for all <span class="math">i \\in \\{1, \\dots, n\\} \\backslash S</span>.</li>

      <li>Prover computes <span class="math">\\widetilde{M}_i = p(i)M_i</span> and <span class="math">(\\widetilde{R}_i, \\widetilde{S}_i, T_i) = (p(i)R_i, p(i)S_i, T_i)</span> for all <span class="math">1 \\leq i \\leq n</span>.</li>

      <li>Prover sends a commitment <span class="math">P</span> to the vector</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {y} = \\left(a _ {1}, \\dots , a _ {n - k}, \\widetilde {M} _ {1}, \\dots , \\widetilde {M} _ {n}, \\widetilde {R} _ {1}, \\widetilde {S} _ {1}, T _ {1}, \\dots , \\widetilde {R} _ {n}, \\widetilde {S} _ {n}, T _ {n}\\right) \\in \\mathbb {Z} _ {q} ^ {n - k} \\times \\mathbb {G} _ {1} ^ {3 n} \\times \\mathbb {G} _ {2} ^ {n}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends a challenge <span class="math">\\rho \\gets_{R} \\mathbb{Z}_{q}</span> sampled uniformly at random.</li>

      <li>Prover computes <span class="math">u = \\sum_{i=1}^{n} \\rho^{i-1} (p(i)e(G, H) - p(i)e(U_i, \\mathbf{tag})) \\in \\mathbb{G}_T</span> and sends it together with a commitment <span class="math">Q = \\mathrm{Com}_1((\\mathbf{x}&#x27;, \\mathbf{y}&#x27;), 0)</span> to the vector</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {x} ^ {\\prime}, \\mathbf {y} ^ {\\prime}\\right) = \\left(\\widetilde {R} _ {1}, \\dots , \\widetilde {R} _ {n}, T _ {1}, \\rho T _ {2}, \\dots , \\rho^ {n - 1} T _ {n}\\right) \\in \\mathbb {G} _ {1} ^ {n} \\times \\mathbb {G} _ {2} ^ {n}.</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover and verifier run compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{c}</span> on public input <span class="math">P</span> to show that (1) of Equation 15 is satisfied, and to prove that <span class="math">u</span> and <span class="math">Q</span> were computed honestly.</li>

      <li>Prover and verifier run the recursive composition of inner-product protocol <span class="math">\\Pi_{\\mathrm{IP}}</span> to prove that the committed vector <span class="math">(\\mathbf{x}&#x27;,\\mathbf{y}&#x27;)</span> satisfies the inner-product relation of Equation 16.</li>

    </ol>

    <p class="text-gray-300">We are grateful for the constructive and encouraging comments from Hieu Phan. We also thank Thijs Veugen for numerous helpful editorial comments. We thank Russell Lai for answering some relevant questions regarding his prior work [LMR19] and for explaining their techniques. Further, we would like to thank Christophe Levrat for pointing out a technical oversight in the appendix of an earlier preprint of our work. Thomas Attema has been supported by the Vraaggestuurd Programma Veilige Maatschappij, supervised by the Innovation Team of the Dutch Ministry of Justice and Security, and the Vraaggestuurd Programma Cyber Security, part of the Dutch Top Sector High Tech Systems and Materials programme. Ronald Cramer has been supported by ERC ADG project No 74079 (ALGSTRONGCRYPTO) and by the NWO Gravitation Programme (QSC).</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AAR21] Mark Abspoel, Thomas Attema, and Matthieu Rambaud. Brief announcement: Malicious security comes for free in consensus with leaders. In Avery Miller, Keren Censor-Hillel, and Janne H. Korhonen, editors, Principles of Distributed Computing (PODC), pages 195–198. ACM, 2021.</li>

      <li>[AC20] Thomas Attema and Ronald Cramer. Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug & play secure algorithmics. In CRYPTO (3), volume 12172 of Lecture Notes in Computer Science, pages 513–543. Springer, 2020.</li>

      <li>[ACF21] Thomas Attema, Ronald Cramer, and Serge Fehr. Compressing proofs of k-out-of-n partial knowledge. In CRYPTO (4), volume 12828 of Lecture Notes in Computer Science, pages 65–91. Springer, 2021.</li>

      <li>[ACHdM05] Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, and Breno de Medeiros. Practical group signatures without random oracles. IACR Cryptol. ePrint Arch., 2005:385, 2005.</li>

      <li>[ACK21] Thomas Attema, Ronald Cramer, and Lisa Kohl. A compressed <span class="math">\\Sigma</span>-protocol theory for lattices. In CRYPTO (2), volume 12826 of Lecture Notes in Computer Science, pages 549–579. Springer, 2021.</li>

      <li>[AFG^{+}10] Masayuki Abe, Georg Fuchsbauer, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. Structure-preserving signatures and commitments to group elements. In CRYPTO, volume 6223 of Lecture Notes in Computer Science, pages 209–236. Springer, 2010.</li>

      <li>[AGHO11] Masayuki Abe, Jens Groth, Kristiyan Haralambiev, and Miyako Ohkubo. Optimal structure-preserving signatures in asymmetric bilinear groups. In CRYPTO, volume 6841 of Lecture Notes in Computer Science, pages 649–666. Springer, 2011.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society, 2018.</li>

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT (2), volume 9666 of Lecture Notes in Computer Science, pages 327–357. Springer, 2016.</li>

      <li>[BCG21] Elette Boyle, Ran Cohen, and Aarushi Goel. Breaking the <span class="math">O(\\sqrt{n})</span>-bits barrier: Balanced byzantine agreement with polylog bits per-party. In PODC. ACM, 2021.</li>

      <li>[BGdMM05] Lucas Ballard, Matthew Green, Breno de Medeiros, and Fabian Monrose. Correlation-resistant storage via keyword-searchable encryption. IACR Cryptol. ePrint Arch., 2005:417, 2005.</li>

      <li>[BLS01] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing. In ASIACRYPT, volume 2248 of Lecture Notes in Computer Science, pages 514–532. Springer, 2001.</li>

      <li>[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil pairing. Journal of Cryptology, 17(4):297–319, 2004.</li>

      <li>[BMMV19] Benedikt Bünz, Mary Maller, Pratyush Mishra, and Noah Vesely. Proofs for inner pairing products and applications. IACR Cryptol. ePrint Arch., 2019:1177, 2019.</li>

      <li>[Bol03] Alexandra Boldyreva. Threshold signatures, multisignatures and blind signatures based on the gap-diffie-hellman-group signature scheme. In Public Key Cryptography, volume 2567 of Lecture Notes in Computer Science, pages 31–46. Springer, 2003.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In ACM Conference on Computer and Communications Security, pages 62–73. ACM, 1993.</li>

      <li>[Can04] Ran Canetti. Universally composable signature, certification, and authentication. In CSFW, page 219. IEEE Computer Society, 2004.</li>

      <li>[CD98] Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In CRYPTO, volume 1462 of Lecture Notes in Computer Science, pages 424–441. Springer, 1998.</li>

      <li>[CDP12] Ronald Cramer, Ivan Damgård, and Valerio Pastro. On the amortized complexity of zero knowledge protocols for multiplicative relations. In ICITS, volume 7412 of Lecture Notes in Computer Science, pages 62–79. Springer, 2012.</li>

      <li>[CHKM10] Sanjit Chatterjee, Darrel Hankerson, Edward Knapp, and Alfred Menezes. Comparing two pairing-based aggregate signature schemes. Designs, Codes and Cryptography, 55(2-3):141–167, 2010.</li>

      <li>[CKS05] Christian Cachin, Klaus Kursawe, and Victor Shoup. Random oracles in constantinople: Practical asynchronous byzantine agreement using cryptography. J. Cryptol., 18(3):219–246, 2005.</li>

      <li>[Cra96] Ronald Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</li>

      <li>[DF89] Yvo Desmedt and Yair Frankel. Threshold cryptosystems. In CRYPTO, volume 435 of Lecture Notes in Computer Science, pages 307–315. Springer, 1989.</li>

    </ul>

    <p class="text-gray-300">FS86. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.</p>

    <p class="text-gray-300">Gam84. Taher El Gamal. A public key cryptosystem and a signature scheme based on discrete logarithms. In CRYPTO, volume 196 of Lecture Notes in Computer Science, pages 10–18. Springer, 1984.</p>

    <p class="text-gray-300">GG20. Rosario Gennaro and Steven Goldfeder. One round threshold ECDSA with identifiable abort. IACR Cryptol. ePrint Arch., 2020:540, 2020.</p>

    <p class="text-gray-300">GJKR96. Rosario Gennaro, Stanislaw Jarecki, Hugo Krawczyk, and Tal Rabin. Robust threshold DSS signatures. In EUROCRYPT, volume 1070 of Lecture Notes in Computer Science, pages 354–371. Springer, 1996.</p>

    <p class="text-gray-300">GJKR03. Rosario Gennaro, Stanislaw Jarecki, Hugo Krawczyk, and Tal Rabin. Secure applications of pedersen’s distributed key generation protocol. In CT-RSA, volume 2612 of Lecture Notes in Computer Science, pages 373–390. Springer, 2003.</p>

    <p class="text-gray-300">GPS08. Steven D. Galbraith, Kenneth G. Paterson, and Nigel P. Smart. Pairings for cryptographers. Discret. Appl. Math., 156(16):3113–3121, 2008.</p>

    <p class="text-gray-300">GS08. Jens Groth and Amit Sahai. Efficient non-interactive proof systems for bilinear groups. In EUROCRYPT, volume 4965 of Lecture Notes in Computer Science, pages 415–432. Springer, 2008.</p>

    <p class="text-gray-300">GT21. Ashrujit Ghoshal and Stefano Tessaro. Tight state-restoration soundness in the algebraic group model. In CRYPTO (3), volume 12827 of Lecture Notes in Computer Science, pages 64–93. Springer, 2021.</p>

    <p class="text-gray-300">HAP18. Yotam Harchol, Ittai Abraham, and Benny Pinkas. Distributed SSH key management with proactive RSA threshold signatures. In ACNS, volume 10892 of Lecture Notes in Computer Science, pages 22–43. Springer, 2018.</p>

    <p class="text-gray-300">HBHW20. Daira Hopwood, Sean Bowe, Taylor Hornby, and Nathan Wilcox. Zcash Protocol Specication - Version 2020.1.7, 2020.</p>

    <p class="text-gray-300">HKR19. Max Hoffmann, Michael Klooß, and Andy Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In ACM Conference on Computer and Communications Security, pages 2093–2110. ACM, 2019.</p>

    <p class="text-gray-300">HKSS20. Abida Haque, Stephan Krenn, Daniel Slamanig, and Christoph Striecks. Logarithmic-size (linkable) threshold ring signatures in the plain model. IACR Cryptol. ePrint Arch., 2020:683, 2020.</p>

    <p class="text-gray-300">KG20. Chelsea Komlo and Ian Goldberg. FROST: flexible round-optimized schnorr threshold signatures. In SAC, volume 12804 of Lecture Notes in Computer Science, pages 34–65. Springer, 2020.</p>

    <p class="text-gray-300">KSM20. Eleftherios Kokoris-Kogias, Alexander Spiegelman, and Dahlia Malkhi. Asynchronous distributed key generation for computationally-secure randomness, consensus, and threshold signatures. In ACM Conference on Computer and Communications Security. ACM, 2020.</p>

    <p class="text-gray-300">Lib19. Libra Team. State Machine Replication in the LibraBlockchain, 2019. Version 2019-10-24.</p>

    <p class="text-gray-300">Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003.</p>

    <p class="text-gray-300">LJY16. Benoit Libert, Marc Joye, and Moti Yung. Born and raised distributively: Fully distributed non-interactive adaptively-secure threshold signatures with short shares. Theor. Comput. Sci., 645:1–24, 2016.</p>

    <p class="text-gray-300">LMR19. Russell W. F. Lai, Giulio Malavolta, and Viktoria Ronge. Succinct arguments for bilinear group arithmetic: Practical structure-preserving cryptography. In ACM Conference on Computer and Communications Security, pages 2057–2074. ACM, 2019.</p>

    <p class="text-gray-300">NRS^{+}20. Kartik Nayak, Ling Ren, Elaine Shi, Nitin H. Vaidya, and Zhuolun Xiang. Improved extension protocols for byzantine broadcast and agreement. In DISC, volume 179 of LIPIcs, pages 28:1–28:17. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020.</p>

    <p class="text-gray-300">Ped91. Torben P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 129–140. Springer, 1991.</p>

    <p class="text-gray-300">Ram20. Matthieu Rambaud. Malicious security comes for free in consensus with leaders. IACR Cryptol. ePrint Arch., page 1480, 2020.</p>

    <p class="text-gray-300">Sha79. Adi Shamir. How to share a secret. Commun. ACM, 22(11):612–613, 1979.</p>

    <p class="text-gray-300">Sho00. Victor Shoup. Practical threshold signatures. In EUROCRYPT, volume 1807 of Lecture Notes in Computer Science, pages 207–220. Springer, 2000.</p>

    <p class="text-gray-300">SV07. Nigel P. Smart and Frederik Vercauteren. On computable isomorphisms in efficient asymmetric pairing-based systems. Discrete Applied Mathematics, 155(4):538–547, 2007.</p>

    <p class="text-gray-300">SW05. Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In EUROCRYPT, volume 3494 of Lecture Notes in Computer Science, pages 457–473. Springer, 2005.</p>

    <p class="text-gray-300">Appendix</p>

    <h2 id="sec-54" class="text-2xl font-bold">Appendix A Compression Mechanism for Inner Product Relation</h2>

    <p class="text-gray-300">This section describes an abstract compression mechanism for proving that the pre-image of a one-way homomorphism <span class="math">\\Psi</span> satisfies an inner-product relation. When composing this compression mechanism recursively the communication complexity drops from linear down to logarithmic. This protocol is not zero-knowledge, but can easily be made zero-knowledge by composing it with the appropriate SHVZK <span class="math">\\Sigma</span>-protocol. The protocol, denoted by <span class="math">\\Pi_{\\mathrm{IP}}</span>, is described in Protocol 7 and its properties are summarized in Theorem 8.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 8 (Abstract Inner Product Argument).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{H}=\\mathbb{H}^{\\prime}\\oplus\\mathbb{H}^{\\prime}</span> for some group <span class="math">\\mathbb{H}^{\\prime}</span> with prime exponent <span class="math">q</span> and let <span class="math">\\Psi:\\mathbb{H}\\oplus\\mathbb{H}\\to\\mathbb{G}</span> be a group homomorphism. Then <span class="math">\\Pi_{\\mathrm{IP}}</span> is a <span class="math">3</span>-move protocol for relation</p>

    <p class="text-gray-300"><span class="math">R_{\\mathrm{IP}}=\\{(P,u;x,y):\\Psi(x,y)=P,\\ \\langle x,y\\rangle=u\\}.</span></p>

    <p class="text-gray-300">It is perfectly complete and computationally <span class="math">4</span>-special sound, under the assumption that it is computationally hard to compute a non-trivial pre-image of <span class="math">0</span> for <span class="math">\\Psi</span>. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2</span> elements of <span class="math">\\mathbb{G}</span> and <span class="math">2</span> element of <span class="math">\\mathbb{H}^{\\prime}</span> and <span class="math">2</span> elements of <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">1</span> element of <span class="math">\\mathbb{Z}_{q}</span>.</li>

    </ul>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness follows directly.</p>

    <p class="text-gray-300">Special Soundness: We show that the protocol is <em>computationally</em> <span class="math">4</span>-special sound. Let <span class="math">(A,B,a,b,c_{1},z_{1,1},z_{2,1})</span>, <span class="math">(A,B,a,b,c_{2},z_{1,2},z_{2,2})</span>, <span class="math">(A,B,a,b,c_{3},z_{1,3},z_{2,3})</span> and <span class="math">(A,B,a,b,c_{4},z_{1,4},z_{2,4})</span> be four accepting transcripts for pairwise distinct challenges <span class="math">c_{1},c_{2},c_{3},c_{4}\\in\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">Let <span class="math">V^{-1}\\in\\mathbb{Z}_{q}^{3\\times 4}</span> be a left inverse of the Vandermonde matrix defined by <span class="math">c_{1},c_{2},c_{3},c_{4}</span>, i.e.,</p>

    <p class="text-gray-300">\\[ V^{-1}\\begin{pmatrix}1&c_{1}&c_{1}^{2}\\\\ 1&c_{2}&c_{2}^{2}\\\\ 1&c_{3}&c_{3}^{2}\\\\ 1&c_{4}&c_{4}^{2}\\end{pmatrix}=\\begin{pmatrix}1&0&0\\\\ 0&1&0\\\\ 0&0&1\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Since the challenges are distinct, this Vandermonde matrix has maximum rank and admits a left inverse <span class="math">V^{-1}\\in\\mathbb{Z}_{q}^{3\\times 4}</span>. Note that the left inverse <span class="math">V^{-1}</span> is not unique, however for this proof we merely need the existence of a left inverse and taking <span class="math">V^{-1}</span> to be any other left inverse of <span class="math">V</span> would also suffice. We now define</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}\\bar{\\mathbf{a}}\\\\ \\bar{\\mathbf{z}}\\\\ \\mathbf{b}\\end{pmatrix}=\\begin{pmatrix}\\bar{a}_{1}&\\bar{a}_{2}&\\bar{a}_{3}&\\bar{a}_{4}\\\\ \\bar{x}_{1}&\\bar{x}_{2}&\\bar{y}_{1}&\\bar{y}_{2}\\\\ \\bar{b}_{1}&\\bar{b}_{2}&\\bar{b}_{3}&\\bar{b}_{4}\\end{pmatrix}=V^{-1}\\begin{pmatrix}c_{1}z_{1,1}&z_{1,1}&z_{2,1}&c_{1}z_{2,1}\\\\ c_{2}z_{1,2}&z_{1,2}&z_{2,2}&c_{2}z_{2,2}\\\\ c_{3}z_{1,3}&z_{1,3}&z_{2,3}&c_{3}z_{2,3}\\\\ c_{4}z_{1,4}&z_{1,4}&z_{2,4}&c_{4}z_{2,4}\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Then, by the first verification equation of <span class="math">\\Pi_{\\Psi}</span>, it follows that <span class="math">\\Psi(\\bar{\\mathbf{a}})=A</span>, <span class="math">\\Psi(\\bar{\\mathbf{z}})=P</span> and <span class="math">\\Psi(\\bar{\\mathbf{b}})=B</span>. Hence,</p>

    <p class="text-gray-300"><span class="math">\\psi(\\bar{\\mathbf{a}}+c_{i}\\bar{\\mathbf{z}}+c_{i}^{2}\\bar{\\mathbf{b}})=AP^{c_{i}}B^{c_{i}^{2}}=\\Psi(c_{i}z_{1,i},z_{1,i},z_{1,i},c_{i}z_{1,i})\\,,</span></p>

    <p class="text-gray-300">for all <span class="math">1\\leq i\\leq 4</span>. Therefore, by the assumption that it is computationally hard to compute a non-trivial pre-image of <span class="math">0</span> for <span class="math">\\Psi</span>, it follows that</p>

    <p class="text-gray-300"><span class="math">c_{i}z_{1,i}</span> <span class="math">=\\bar{a}_{1}+c_{i}\\bar{x}_{1}+c_{i}^{2}\\bar{b}_{1},</span> <span class="math">z_{1,i}</span> <span class="math">=\\bar{a}_{2}+c_{i}\\bar{x}_{2}+c_{i}^{2}\\bar{b}_{2},</span> <span class="math">z_{2,i}</span> <span class="math">=\\bar{a}_{3}+c_{i}\\bar{y}_{1}+c_{i}^{2}\\bar{b}_{3},</span> <span class="math">c_{i}z_{2,i}</span> <span class="math">=\\bar{a}_{4}+c_{i}\\bar{y}_{2}+c_{i}^{2}\\bar{b}_{4},</span></p>

    <p class="text-gray-300">for all  <span class="math">1 \\leq i \\leq 4</span> . Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {a} _ {1} + c _ {i} \\bar {x} _ {1} + c _ {i} ^ {2} \\bar {b} _ {1} = c _ {i} \\bar {a} _ {2} + c _ {i} ^ {2} \\bar {x} _ {2} + c _ {i} ^ {3} \\bar {b} _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">c _ {i} \\bar {a} _ {3} + c _ {i} ^ {2} \\bar {y} _ {1} + c _ {i} ^ {3} \\bar {b} _ {3} = \\bar {a} _ {4} + c _ {i} \\bar {y} _ {2} + c _ {i} ^ {2} \\bar {b} _ {4},</span></div>

    <p class="text-gray-300">for all  <span class="math">1 \\leq i \\leq 4</span> . Since the four  <span class="math">c_{i}</span>  are pairwise distinct and the above equations are of degree 3, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {a} _ {1} = \\bar {a} _ {4} = \\bar {b} _ {2} = \\bar {b} _ {3} = 0,</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bar {a} _ {2} = \\bar {x} _ {1}, \\quad \\bar {a} _ {3} = \\bar {y} _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bar {b} _ {1} = \\bar {x} _ {2}, \\quad \\bar {b} _ {4} = \\bar {y} _ {1},</span></div>

    <p class="text-gray-300">which implies that</p>

    <div class="my-4 text-center"><span class="math-block">z _ {1, i} = \\bar {x} _ {1} + c _ {i} \\bar {x} _ {2},</span></div>

    <div class="my-4 text-center"><span class="math-block">z _ {2, i} = c _ {i} \\bar {y} _ {1} + \\bar {y} _ {2},</span></div>

    <p class="text-gray-300">for all  <span class="math">1 \\leq i \\leq 4</span> .</p>

    <p class="text-gray-300">Hence, by the second verification equation of Protocol 7, it holds that, for all  <span class="math">1 \\leq i \\leq 3</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} a + c _ {i} u + c _ {i} ^ {2} b = \\langle z _ {1, i}, z _ {2, i} \\rangle , \\\\ = \\langle \\bar {x} _ {1} + c _ {i} \\bar {x} _ {2}, c _ {i} \\bar {y} _ {1} + \\bar {y} _ {2} \\rangle , \\\\ = \\langle \\bar {x} _ {1}, \\bar {y} _ {2} \\rangle + c _ {i} \\langle (\\bar {x} _ {1}, \\bar {x} _ {2}), (\\bar {y} _ {1}, \\bar {y} _ {2}) \\rangle + c _ {i} ^ {2} \\langle \\bar {x} _ {2}, \\bar {y} _ {1} \\rangle . \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since, this equality holds for four pairwise distinct challenges it follows that  <span class="math">\\langle (\\bar{x}_1,\\bar{x}_2),(\\bar{y}_1,\\bar{y}_2)\\rangle = u</span> . Hence  <span class="math">\\tilde{z} = (\\bar{x}_1,\\bar{x}_2,\\bar{y}_1,\\bar{y}_2)</span>  is a witness for relation  <span class="math">R_{\\mathrm{IP}}</span> , which completes the proof.</p>

    <p class="text-gray-300">Protocol 7 Generic Compression Mechanism  <span class="math">\\varPi_{\\mathrm{IP}}</span>  for inner-product relation  <span class="math">R_{\\mathrm{IP}}</span> .</p>

    <p class="text-gray-300">|  INPUT(P,u;x=(xL,xR),y=(yL,yR))  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Verifier  |   |</p>

    <p class="text-gray-300">|  A=Ψ(0,xL,yR,0),a= <xL,yR> |  |   |</p>

    <p class="text-gray-300">|  B=Ψ(xR,0,0,yL),b= <xR,yL> |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A,B,a,b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c←R Zq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ←c |   |</p>

    <p class="text-gray-300">|  z1=xL+cxR |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z2=cyL+yR</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z1,z2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ψ(cz1,z1,z2,cz2)=APcBc2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  | <z1,z2>=a+cu+c2b  |</p>`;
---

<BaseLayout title="Compressed $\Sigma$-Protocols for Bilinear Group Arithmetic ... (2020/1447)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1447
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
